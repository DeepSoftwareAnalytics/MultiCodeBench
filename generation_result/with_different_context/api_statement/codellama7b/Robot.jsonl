{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> required_files;\n    std::vector<std::string> files = GetFiles(folder);\n    for (const auto &file : files) {\n        if (download) {\n            if (!FileExists(file)) {\n                RequestFile(file);\n                LogInfo(file);\n            } else {\n                LogInfo(file);\n            }\n        }\n        required_files.push_back(file);\n    }\n    return required_files;\n}", "CodeBleu_score": 46.77126014460081}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    if (!_pimpl->CheckIfConnected()) {\n        return {};\n    }\n    std::vector<std::string> required_files;\n    if (!_pimpl->CheckIfFolderExists(folder)) {\n        return {};\n    }\n    std::vector<std::string> files = _pimpl->GetFiles(folder);\n    for (const std::string &file : files) {\n        if (download) {\n            if (_pimpl->CheckIfFileExists(file)) {\n                log_info(\"File {} found in cache\", file);\n            } else {\n                log_info(\"Requesting file {}\", file);\n                _pimpl->RequestFile(file);\n            }\n        } else {\n            if (_pimpl->CheckIfFileExists(file)) {\n                required_files.push_back(file);\n                log_info(\"File {} found in cache\", file);\n            } else {\n                log_info(\"File {} not found in cache\", file);\n            }\n        }\n    }\n    return required_files;\n}", "CodeBleu_score": 49.35659377895162}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tif (!download) {\n\t\tstd::vector<std::string> files;\n\t\tfor (const auto &file : _pimpl->CallAndWait<std::vector<std::string>>(\"FileTransfer::FileExists\", { folder })) {\n\t\t\tfiles.push_back(file);\n\t\t}\n\t\treturn files;\n\t}\n\tstd::vector<std::string> files;\n\tfor (const auto &file : _pimpl->CallAndWait<std::vector<std::string>>(\"FileTransfer::FileExists\", { folder })) {\n\t\tif (!fileExists(file)) {\n\t\t\tlog_info(\"Downloading file: \" + file);\n\t\t\t_pimpl->CallAndWait(\"FileTransfer::RequestFile\", { file });\n\t\t\tfiles.push_back(file);\n\t\t}\n\t\telse {\n\t\t\tlog_info(\"File found in cache: \" + file);\n\t\t}\n\t}\n\treturn files;\n}", "CodeBleu_score": 50.51873329922276}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the attachment type is SpringArm or SpringArmGhost\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the transformation is only in the 'z' axis\n    geom::Vector3D unit_vector = transform.location.MakeSafeUnitVector();\n    if (unit_vector.x != 0.0f || unit_vector.y != 0.0f) {\n      // If the transformation is not only in the 'z' axis, issue a warning\n      std::cout << \"WARNING: Spawning an actor with SpringArm or SpringArmGhost attachment type with a non-zero translation in the 'x' or 'y' axis. This may cause ill-formed transformations.\" << std::endl;\n    }\n  }\n  // Call an internal function to complete the actor spawning process\n  return _pimpl->CallAndWait<rpc::Actor>(\n      [&](auto &conn) {\n        return conn.CallRpc(\"SpawnActorWithParent\", description, transform, parent, attachment_type, socket_name);\n      });\n}", "CodeBleu_score": 55.7787262484251}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the transformation is valid.\n    const geom::Vector3D translation = transform.location.MakeSafeUnitVector();\n    if (translation.z < 0.0f) {\n      std::stringstream ss;\n      ss << \"Invalid transformation. The translation vector must be \"\n         << \"non-negative in the 'z' axis. Translation vector: \"\n         << translation.ToString();\n      throw std::runtime_error(ss.str());\n    }\n    LOG(WARNING) << \"The transformation of the actor \" << description.id\n                 << \" is not valid. The translation vector must be \"\n                 << \"non-negative in the 'z' axis. Translation vector: \"\n                 << translation.ToString();\n  }\n  return _pimpl->CallAndWait<rpc::Actor>(\n      [&] {\n        return _pimpl->actor_factory->CreateActorWithParent(\n            description, transform, parent, attachment_type, socket_name);\n      },\n      \"Client::SpawnActorWithParent\");\n}", "CodeBleu_score": 52.55438090398975}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // TODO: This is a workaround for the case where the parent actor is not spawned yet.\n  //       We should use a proper way to handle this case.\n  if (parent.IsNil() && description.parent_id.IsValid()) {\n    parent = description.parent_id;\n  }\n\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    const geom::Vector3D translation = transform.location.MakeSafeUnitVector();\n    if (std::abs(translation.z) > std::numeric_limits<float>::epsilon()) {\n      LogWarning(\n          \"The parent actor is a SpringArm or SpringArmGhost, but the \"\n          \"translation is not in the 'z' axis. The translation is \"\n          \"ignored.\");\n    }\n  }\n\n  rpc::Actor actor = _pimpl->CallAndWait<rpc::Actor>(\n      [&](const rpc::Actor &parent) {\n        return _pimpl->client->SpawnActorWithParent(\n            description, transform, parent, attachment_type, socket_name);\n      },\n      parent);\n\n  if (!actor.IsNil()) {\n    _pimpl->actor_list.insert(actor);\n  }\n\n  return actor;\n}", "CodeBleu_score": 60.60302864879513}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  // Get token data\n  auto token_data = GetTokenData(ActorId, GBufferId);\n\n  // Copy token data\n  std::vector<unsigned char> token_data_copy(token_data.size());\n  std::memcpy(token_data_copy.data(), token_data.data(), token_data.size());\n\n  // Subscribe to streaming client\n  _pimpl->streaming_client.Subscribe(token_data_copy, callback);\n}", "CodeBleu_score": 52.434133977984}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  // Check if the actor is already subscribed\n  if (_pimpl->subscribed_actors.find(ActorId) != _pimpl->subscribed_actors.end()) {\n    // If it is, check if the G-buffer is already subscribed\n    if (_pimpl->subscribed_actors[ActorId].find(GBufferId) != _pimpl->subscribed_actors[ActorId].end()) {\n      // If it is, return\n      return;\n    }\n  }\n\n  // Call the token function to get the token data\n  auto token_data = _pimpl->CallAndWait<rpc::TokenData>(\"Token\", ActorId, GBufferId);\n\n  // Copy the token data\n  std::vector<unsigned char> token_data_copy(token_data.size);\n  std::memcpy(token_data_copy.data(), token_data.data, token_data.size);\n\n  // Subscribe to the streaming client\n  _pimpl->streaming_client.Subscribe(\n      ActorId,\n      GBufferId,\n      token_data_copy,\n      callback);\n\n  // If the actor is not already subscribed, add it to the subscribed actors map\n  if (_pimpl->subscribed_actors.find(ActorId) == _pimpl->subscribed_actors.end()) {\n    _pimpl->subscribed_actors[ActorId] = std::unordered_map<uint32_t, bool>();\n  }\n\n  // Add the G-buffer to the subscribed actors map\n  _pimpl->subscribed_actors[ActorId][GBufferId] = true;\n}", "CodeBleu_score": 49.792209836678424}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  // Get the token for the G-buffer\n  auto token = _pimpl->CallAndWait<rpc::Token>(\n      \"GetGBufferToken\",\n      ActorId,\n      GBufferId);\n\n  // Copy the token data\n  auto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\n      \"GetGBufferTokenData\",\n      token.data);\n\n  // Subscribe to the streaming client\n  _pimpl->streaming_client.Subscribe(\n      token.data,\n      token_data.size(),\n      std::move(callback));\n}", "CodeBleu_score": 59.32929700275349}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n    while (navigation == nullptr) {\n        navigation = std::make_shared<WalkerNavigation>();\n        if (_walker_navigation.compare_exchange_weak(navigation, navigation)) {\n            break;\n        }\n    }\n    return navigation;\n}", "CodeBleu_score": 53.2832844425742}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> walker_navigation = _walker_navigation.load();\n  if (walker_navigation == nullptr) {\n    std::shared_ptr<WalkerNavigation> new_walker_navigation = std::make_shared<WalkerNavigation>(this);\n    walker_navigation = _walker_navigation.compare_exchange_strong(walker_navigation, new_walker_navigation);\n    if (walker_navigation == nullptr) {\n      walker_navigation = new_walker_navigation;\n    }\n  }\n  return walker_navigation;\n}", "CodeBleu_score": 53.3718427650626}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation;\n  while (true) {\n    navigation = _walker_navigation.load();\n    if (navigation != nullptr) {\n      return navigation;\n    }\n    if (_walker_navigation.compare_exchange_weak(navigation, std::make_shared<WalkerNavigation>())) {\n      return navigation;\n    }\n  }\n}", "CodeBleu_score": 54.92462582086568}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::system_clock::now();\n  while (episode.GetState()->GetFrameNumber() < frame) {\n    std::this_thread::yield();\n    if (std::chrono::duration_cast<std::chrono::milliseconds>(\n        std::chrono::system_clock::now() - start) > timeout) {\n      return false;\n    }\n  }\n  episode.GetState()->Tick();\n  return true;\n}", "CodeBleu_score": 47.63077627752106}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto start_time = std::chrono::system_clock::now();\n  while (episode.GetState()->GetFrameNumber() < frame) {\n    if (timeout.to_chrono() <= std::chrono::system_clock::now() - start_time) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetState()->SetFrameNumber(frame);\n  episode.GetState()->SetTimestamp(episode.GetState()->GetTimestamp() + timeout.to_chrono());\n  episode.GetState()->SetTimeOfDay(episode.GetState()->GetTimeOfDay() + timeout.to_chrono());\n  episode.GetTrafficManager()->Tick(timeout);\n  return true;\n}", "CodeBleu_score": 42.405047331231216}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t    const auto start = std::chrono::system_clock::now();\n    while (episode.GetState()->GetFrameNumber() < frame) {\n        std::this_thread::yield();\n        if (std::chrono::system_clock::now() - start > timeout.to_chrono()) {\n            return false;\n        }\n    }\n    episode.GetTrafficManager().Tick(timeout);\n    return true;\n}", "CodeBleu_score": 43.815923141960376}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // TODO: This is a hack to get around the fact that we can't easily get the current episode id\n  //       when we're in the middle of loading a new episode.\n  //       This should be fixed in a better way.\n  //       See https://github.com/carla-simulator/carla/issues/1762\n  //       and https://github.com/carla-simulator/carla/issues/1761\n  auto current_episode_id = GetCurrentEpisode().GetId();\n  auto episode_id = _client.LoadEpisode(map_name, reset_settings, map_layers);\n  if (episode_id != current_episode_id) {\n    _episode = EpisodeProxy(episode_id, _client);\n  }\n  _episode->WaitForState(rpc::EpisodeState::Ready);\n  return _episode;\n}", "CodeBleu_score": 35.37138375294918}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // This function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is not implemented in the source file because it is a template function.\n  // The implementation is in the header file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n  // The implementation is in the source file.\n  // The function is implemented in the header file because it is a template function.\n", "CodeBleu_score": 3.449068089068989}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // TODO: Check if the episode is already loaded.\n  // TODO: Check if the map name is valid.\n  // TODO: Check if the map layers are valid.\n  // TODO: Check if the reset settings are valid.\n  // TODO: Check if the episode is already loaded.\n  // TODO: Check if the map name is valid.\n  // TODO: Check if the map layers are valid.\n  // TODO: Check if the reset settings are valid.\n  // TODO: Check if the episode is already loaded.\n  // TODO: Check if the map name is valid.\n  // TODO: Check if the map layers are valid.\n  // TODO: Check if the reset settings are valid.\n  // TODO: Check if the episode is already loaded.\n  // TODO: Check if the map name is valid.\n  // TODO: Check if the map layers are valid.\n  // TODO: Check if the reset settings are valid.\n  // TODO: Check if the episode is already loaded.\n  // TODO: Check if the map name is valid.\n  // TODO: Check if the map layers are valid.\n  // TODO: Check if the reset settings are valid.\n  // TODO: Check if the episode is already loaded.\n  // TODO: Check if the map name is valid.\n  // TODO: Check if the map layers are valid.\n  // TODO: Check if the reset settings are valid.\n  // TODO: Check if the episode is already loaded.\n  // TODO: Check if the map name is valid.\n  // TODO: Check if the map layers are valid.\n  // TODO: Check if the reset settings are valid.\n  // TODO: Check if the episode is already loaded.\n  // TODO: Check if the map name is valid.\n  // TODO: Check if the map layers are valid.\n  // TODO: Check if the reset settings are valid.\n  // TODO: Check if the episode is already loaded.\n  // TODO: Check if the map name is valid.\n  // TODO: Check if the map layers are valid.\n  // TODO: Check if the reset settings are valid.\n  // TODO: Check if the episode is already loaded.\n  // TODO: Check if the map name is valid.\n  // TODO: Check if the map layers are valid.\n  // TODO: Check", "CodeBleu_score": 3.422965450884701}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  //! [RegisterAIController]\n  auto walker = GetWalker(controller.GetId());\n  DEBUG_ASSERT(walker != nullptr);\n  DEBUG_ASSERT(walker->GetId() == controller.GetId());\n  DEBUG_ASSERT(walker->GetEpisode() != nullptr);\n  DEBUG_ASSERT(walker->GetEpisode()->GetActiveState() == Episode::State::Init);\n\n  //! [RegisterAIController]\n  //! [RegisterAIController_nav]\n  auto nav = walker->GetEpisode()->GetNavigation();\n  if (nav == nullptr) {\n    nav = walker->GetEpisode()->CreateNavigationIfMissing();\n  }\n  //! [RegisterAIController_nav]\n  //! [RegisterAIController_register]\n  nav->RegisterWalker(controller.GetId());\n  //! [RegisterAIController_register]\n}", "CodeBleu_score": 58.797395780589845}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  //! [sim_register_ai_controller]\n  //! [sim_register_ai_controller_1]\n  const WalkerId walker_id = controller.GetWalkerId();\n  //! [sim_register_ai_controller_1]\n  //! [sim_register_ai_controller_2]\n  Walker *walker = GetWalker(walker_id);\n  //! [sim_register_ai_controller_2]\n  //! [sim_register_ai_controller_3]\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n  //! [sim_register_ai_controller_3]\n  //! [sim_register_ai_controller_4]\n  //! [sim_register_ai_controller_5]\n  //! [sim_register_ai_controller_6]\n  //! [sim_register_ai_controller_7]\n  //! [sim_register_ai_controller_8]\n  //! [sim_register_ai_controller_9]\n  //! [sim_register_ai_controller_10]\n  //! [sim_register_ai_controller_11]\n  //! [sim_register_ai_controller_12]\n  //! [sim_register_ai_controller_13]\n  //! [sim_register_ai_controller_14]\n  //! [sim_register_ai_controller_15]\n  //! [sim_register_ai_controller_16]\n  //! [sim_register_ai_controller_17]\n  //! [sim_register_ai_controller_18]\n  //! [sim_register_ai_controller_19]\n  //! [sim_register_ai_controller_20]\n  //! [sim_register_ai_controller_21]\n  //! [sim_register_ai_controller_22]\n  //! [sim_register_ai_controller_23]\n  //! [sim_register_ai_controller_24]\n  //! [sim_register_ai_controller_25]", "CodeBleu_score": 40.85093526247338}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = GetWalker(controller.GetId());\n  DEBUG_ASSERT(walker != nullptr);\n  _episode->CreateNavigationIfMissing();\n  _episode->GetNavigation()->RegisterWalker(controller.GetId(), walker->GetId());\n}", "CodeBleu_score": 48.226004262638874}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  // 1. Create the actor.\n  SharedPtr<Actor> actor = _actor_factory.MakeActor(blueprint, transform, parent, attachment_type, socket_name);\n\n  // 2. Register the actor in the current episode.\n  _current_episode->RegisterActor(actor);\n\n  // 3. Apply the garbage collection policy.\n  ApplyGarbageCollectionPolicy(gc, actor);\n\n  // 4. Log the creation details.\n  log_debug(\"spawned actor\", actor->GetId(), \"with blueprint\", blueprint.MakeActorDescription());\n\n  // 5. Return the actor.\n  return actor;\n}", "CodeBleu_score": 31.119127347078866}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    // Check that the blueprint is valid.\n    if (!blueprint.IsValid()) {\n      throw std::invalid_argument(\"Invalid blueprint.\");\n    }\n\n    // Check that the transform is valid.\n    if (!transform.IsValid()) {\n      throw std::invalid_argument(\"Invalid transform.\");\n    }\n\n    // Check that the parent actor is valid.\n    if (parent != nullptr && !parent->IsValid()) {\n      throw std::invalid_argument(\"Invalid parent actor.\");\n    }\n\n    // Check that the socket name is valid.\n    if (socket_name.empty()) {\n      throw std::invalid_argument(\"Invalid socket name.\");\n    }\n\n    // Check that the garbage collection policy is valid.\n    if (gc != GarbageCollectionPolicy::KeepAcrossScenes &&\n        gc != GarbageCollectionPolicy::ResetOnEpisodeEnd) {\n      throw std::invalid_argument(\"Invalid garbage collection policy.\");\n    }\n\n    // Check that the actor blueprint is valid.\n    if (!blueprint.IsValid()) {\n      throw std::invalid_argument(\"Invalid actor blueprint.\");\n    }\n\n    // Check that the parent actor is valid.\n    if (parent != nullptr && !parent->IsValid()) {\n      throw std::invalid_argument(\"Invalid parent actor.\");\n    }\n\n    // Check that the socket name is valid.\n    if (socket_name.empty()) {\n      throw std::invalid_argument(\"Invalid socket name.\");\n    }\n\n    // Check that the garbage collection policy is valid.\n    if (gc != GarbageCollectionPolicy::KeepAcrossScenes &&\n        gc != GarbageCollectionPolicy::ResetOnEpisodeEnd) {\n      throw std::invalid_argument(\"Invalid garbage collection policy.\");\n    }\n\n    // Create the actor.\n    SharedPtr<Actor> actor = ActorFactory::MakeActor(blueprint, transform, parent, attachment_type, socket_name);\n\n    // Register the actor in the current episode.\n    _episode->RegisterActor(actor, gc);\n\n    // Apply the garbage collection policy.\n    ApplyGarbageCollectionPolicy(actor, gc);\n\n    // Log the actor", "CodeBleu_score": 39.888734371415545}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    // Check if the actor is already registered in the current episode.\n    auto id = blueprint.MakeActorDescription(transform, parent, attachment_type, socket_name);\n    if (episode_->HasActorOfDescription(id)) {\n      return episode_->GetActor(id);\n    }\n\n    // Spawn the actor.\n    SharedPtr<Actor> actor = _client.SpawnActorWithParent(blueprint, transform, parent, attachment_type, socket_name);\n\n    // Register the actor in the current episode.\n    episode_->RegisterActor(actor, gc);\n\n    // Apply the garbage collection policy.\n    ApplyGarbageCollectionPolicy(gc, actor);\n\n    // Log the actor creation.\n    LogActorCreation(actor);\n\n    return actor;\n  }", "CodeBleu_score": 39.32437566274657}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  // Ensure that the episode is valid\n  if (!episode_) {\n    throw std::runtime_error(\"Episode is not valid.\");\n  }\n\n  // Subscribe to the sensor's data stream\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [this, &sensor, callback](const std::string &stream_msg) {\n        // Deserialize the incoming data\n        SharedPtr<sensor::SensorData> data = sensor.Deserialize(stream_msg);\n        // Associate the data with the current episode\n        data->SetEpisode(episode_);\n        // Invoke the callback\n        callback(data);\n      });\n}", "CodeBleu_score": 44.95481472423379}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  // Ensure that the episode is valid\n  if (!IsEpisodeRunning()) {\n    throw std::runtime_error(\"Episode has not started\");\n  }\n\n  // Subscribe to the sensor's data stream\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [this, sensor, callback](const std::string &stream,\n                               const std::string &message) {\n        // Deserialize the incoming message\n        SharedPtr<sensor::SensorData> data = sensor::Deserialize(message);\n        // Associate the data with the current episode\n        data->SetEpisode(GetCurrentEpisode());\n        // Invoke the callback\n        callback(data);\n      });\n}", "CodeBleu_score": 40.243000526798426}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (!episode_->IsValid()) {\n    throw std::logic_error(\"Cannot subscribe to sensor when episode is invalid\");\n  }\n\n  // Subscribe to the stream.\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [=](const std::string &stream,\n          const std::string &message) {\n        // Deserialize the message.\n        SharedPtr<sensor::SensorData> data =\n            sensor::Deserialize(stream, message);\n        // Associate the message with the current episode.\n        data->SetEpisode(episode_);\n        // Invoke the callback.\n        callback(data);\n      });\n}", "CodeBleu_score": 44.064331238600346}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    // Load walkers and return if there are none\n    _walkers.Load(episode);\n    if (_walkers.empty()) {\n        return;\n    }\n\n    // Remove dead walkers\n    RemoveDeadWalkers(episode);\n\n    // Update the crowd\n    _nav.UpdateCrowd(episode);\n\n    // Check if any walkers have been killed\n    CheckIfWalkerExist(episode);\n\n    // Update the vehicles in the crowd\n    UpdateVehiclesInCrowd();\n\n    // Apply the batch\n    _simulator.lock()->ApplyBatchSync();\n}", "CodeBleu_score": 14.326376999192108}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    // Load walkers\n    _walkers.Load();\n    if (walkers->empty()) {\n        return;\n    }\n    // Get walker speed\n    _nav.GetWalkerSpeed();\n    // Check if walker exist\n    CheckIfWalkerExist();\n    // Update vehicles in crowd\n    _nav.UpdateVehiclesInCrowd();\n    // Update crowd\n    _nav.UpdateCrowd();\n    // Apply batch\n    episode->GetState();\n    // Remove walkers that no longer exist\n    UnregisterWalker();\n    // Apply batch\n    _simulator.lock()->ApplyBatchSync();\n    // Check if walker has been killed\n    CheckIfWalkerExist();\n    // Destroy walkers\n    UnregisterWalker();\n}", "CodeBleu_score": 18.902682969749264}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    // Load walkers\n    _walkers.Load(episode->GetMap());\n    if (_walkers.empty()) {\n        return;\n    }\n\n    // Remove dead walkers\n    episode->GetState()->RemoveWalkers(_walkers);\n\n    // Update vehicles in crowd\n    _nav.UpdateVehiclesInCrowd();\n\n    // Check if walker exist\n    if (!_walkers.CheckIfWalkerExist()) {\n        return;\n    }\n\n    // Update crowd\n    _nav.UpdateCrowd();\n\n    // Get walkers\n    auto walkers = _walkers.GetWalkers();\n\n    // Get walker speed\n    auto walker_speed = _nav.GetWalkerSpeed();\n\n    // Get walker transform\n    auto walker_transform = _nav.GetWalkerTransform();\n\n    // Reserve commands\n    commands.reserve(walkers->size());\n\n    // Emplace back\n    for (auto i = 0u; i < walkers->size(); ++i) {\n        commands.emplace_back(\n            (*walkers)[i]->GetId(),\n            walker_transform[i],\n            walker_speed[i]\n        );\n    }\n\n    // Apply batch sync\n    _simulator.lock()->ApplyBatchSync(commands);\n\n    // Remove dead walkers\n    _walkers.RemoveDeadWalkers();\n\n    // Destroy walkers\n    _walkers.DestroyWalkers();\n}", "CodeBleu_score": 39.64899725554395}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.id = this->id;\n  description.parent_id = this->parent_id;\n  description.attributes.reserve(this->attributes.size());\n  for (auto &attribute : this->attributes) {\n    description.attributes.push_back(attribute.second);\n  }\n  return description;\n}", "CodeBleu_score": 63.11705586597311}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.id = id;\n  description.parent_id = parent_id;\n  description.type = type;\n  description.attributes.reserve(attributes.size());\n  for (auto &attribute : attributes) {\n    description.attributes.push_back(attribute->MakeAttributeDescription());\n  }\n  return description;\n}", "CodeBleu_score": 67.12793384853131}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.id = id;\n  description.parent_id = parent_id;\n  description.parent_name = parent_name;\n  description.attributes.reserve(attributes.size());\n  for (const auto& attribute : attributes) {\n    description.attributes.push_back(attribute.second);\n  }\n  return description;\n}", "CodeBleu_score": 67.38725725719881}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t    std::vector<Blueprint> result;\n    for (auto &pair : this->blueprints) {\n        if (pair.second.ContainsAttribute(name)) {\n            const Attribute &attribute = pair.second.GetAttribute(name);\n            if (attribute.GetValue() == value) {\n                result.emplace_back(pair.first, pair.second);\n            } else if (attribute.GetRecommendedValues().Contains(value)) {\n                result.emplace_back(pair.first, pair.second);\n            }\n        }\n    }\n    return std::make_shared<BlueprintLibrary>(result);\n}", "CodeBleu_score": 51.85519539824608}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\n    std::vector<std::pair<std::string, SharedPtr<Blueprint>>> result;\n    for (const auto& pair : *this) {\n        if (pair.second.ContainsAttribute(name)) {\n            const auto& attribute = pair.second.GetAttribute(name);\n            if (attribute.GetValue() == value) {\n                result.emplace_back(pair);\n            } else if (attribute.GetRecommendedValues().Contains(value)) {\n                result.emplace_back(pair);\n            }\n        }\n    }\n    return MakeShared<BlueprintLibrary>(result);\n}", "CodeBleu_score": 51.06833587976837}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  std::vector<Blueprint> result;\n\n  for (const auto& pair : *this) {\n    if (pair.second.ContainsAttribute(name)) {\n      const auto& attr = pair.second.GetAttribute(name);\n      if (attr.GetValue() == value || attr.GetRecommendedValues().Contains(value)) {\n        result.emplace_back(pair.first, pair.second);\n      }\n    }\n  }\n\n  return MakeShared<BlueprintLibrary>(result);\n}", "CodeBleu_score": 41.94282750487088}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string fullPath = GetFullPath(path);\n  if (!carla::FileSystem::ValidateFilePath(fullPath)) {\n    return false;\n  }\n  std::ofstream out(fullPath, std::ios::binary | std::ios::trunc);\n  if (!out.good()) {\n    return false;\n  }\n  out.write(reinterpret_cast<char*>(content.data()), content.size());\n  out.close();\n  return true;\n}", "CodeBleu_score": 49.11632637266092}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string full_path = GetFullPath(path);\n  if (!carla::FileSystem::ValidateFilePath(full_path)) {\n    return false;\n  }\n  std::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n  if (!out.good()) {\n    return false;\n  }\n  out.write(reinterpret_cast<const char *>(content.data()), content.size());\n  out.close();\n  return true;\n}", "CodeBleu_score": 49.0445372455242}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    // Construct the full path.\n    std::string full_path = base_folder + \"/\" + path + \"/\" + version + \".good\";\n\n    // Validate the file path.\n    if (!carla::FileSystem::ValidateFilePath(full_path)) {\n        return false;\n    }\n\n    // Open the file in binary mode to truncate its contents.\n    std::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n\n    // Write the content.\n    if (out.good()) {\n        out.write(reinterpret_cast<const char*>(content.data()), content.size());\n    }\n\n    // Close the file.\n    out.close();\n\n    // Return true if the file is successfully opened.\n    return out.good();\n}", "CodeBleu_score": 47.36360951944136}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  // Get the parent's bounding box\n  const auto &parent_bounds = this->parent_->Bounds(frame);\n  // Create a new bounding box\n  auto bounds = std::make_shared<Bounds>(frame, parent_bounds.location_);\n  // Add the transform's location\n  bounds->location_ += transform.location_;\n  // Compute the four corners of the bounding box\n  const auto &extents = this->extents_;\n  const auto &yaw = transform.rotation_.yaw();\n  const auto &cos_yaw = std::cos(yaw);\n  const auto &sin_yaw = std::sin(yaw);\n  // Top left\n  bounds->corners_[0] = bounds->location_ + geom::Location(\n        extents.x() * cos_yaw - extents.y() * sin_yaw,\n        extents.x() * sin_yaw + extents.y() * cos_yaw);\n  // Top right\n  bounds->corners_[1] = bounds->location_ + geom::Location(\n        extents.x() * cos_yaw + extents.y() * sin_yaw,\n        extents.x() * sin_yaw - extents.y() * cos_yaw);\n  // Bottom left\n  bounds->corners_[2] = bounds->location_ + geom::Location(\n        extents.x() * cos_yaw - extents.y() * sin_yaw,\n        extents.x() * sin_yaw + extents.y() * cos_yaw);\n  // Bottom right\n  bounds->corners_[3] = bounds->location_ + geom::Location(\n        extents.x() * cos_yaw + extents.y() * sin_yaw,\n        extents.x() * sin_yaw - extents.y() * cos_yaw);\n  // Return the bounding box\n  return bounds;\n}", "CodeBleu_score": 42.297089486026586}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n    // Get the parent bounding box\n    const auto parent_bounds = this->parent->GetBounds(frame);\n\n    // If the parent bounding box is not found, return an empty pointer\n    if (!parent_bounds) {\n        return nullptr;\n    }\n\n    // Get the location of the transform\n    const auto location = transform.location;\n\n    // Get the yaw angle of the transform\n    const auto yaw = transform.rotation.yaw;\n\n    // Get the extents of the bounding box\n    const auto extents = this->extents;\n\n    // Calculate the four corners of the bounding box\n    const auto corner_one = geom::Location(location.x + std::cos(yaw) * extents.x,\n                                           location.y + std::sin(yaw) * extents.x);\n    const auto corner_two = geom::Location(location.x + std::cos(yaw) * extents.y,\n                                           location.y + std::sin(yaw) * extents.y);\n    const auto corner_three = geom::Location(location.x + std::cos(yaw) * extents.z,\n                                             location.y + std::sin(yaw) * extents.z);\n    const auto corner_four = geom::Location(location.x + std::cos(yaw) * extents.w,\n                                            location.y + std::sin(yaw) * extents.w);\n\n    // Create a vector of the four corners\n    std::vector<geom::Location> corners{corner_one, corner_two, corner_three, corner_four};\n\n    // Return a shared pointer to a Bounds object containing the frame number and the calculated corners\n    return std::make_shared<Bounds>(frame, corners);\n}", "CodeBleu_score": 45.226918489310144}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  // Create a new bounding box\n  std::shared_ptr<Bounds> bounds = std::make_shared<Bounds>(frame);\n  // Add the parent's bounding box location to the transform's location\n  geom::Location location = transform.location + parent_->bounds_.location;\n  // Rotate the extents based on the yaw angle\n  geom::Vector2D extent = transform.rotation.Rotate(parent_->extent_);\n  // Set the location and extents of the bounding box\n  bounds->location = location;\n  bounds->extent = extent;\n  // Return the bounding box\n  return bounds;\n}", "CodeBleu_score": 35.474730503101846}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    // Get the light states from the server\n    const LightState light_state = _episode.Lock()->QueryLightsStateToServer();\n    // Update the local light states\n    for (auto &light : light_state.lights) {\n        auto it = _lights.find(light.first);\n        if (it == _lights.end()) {\n            // Create a new light if it does not already exist\n            _lights.insert(std::make_pair(light.first, std::make_shared<Light>(light.second)));\n        } else {\n            // Update the light state\n            it->second->SetState(light.second);\n        }\n    }\n}", "CodeBleu_score": 42.64293974268003}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_lightsMutex);\n    // Query the server for the current light states\n    std::vector<Light> lightStates = _episode.Lock()->QueryLightsStateToServer();\n    // Update the local light states\n    for (auto light : lightStates) {\n        // Update the light if it already exists\n        if (_lights.find(light.GetId()) != _lights.end()) {\n            _lights[light.GetId()]->UpdateLight(light);\n        }\n        // Create the light if it does not exist\n        else {\n            _lights[light.GetId()] = std::make_shared<Light>(light);\n        }\n    }\n    // Remove lights that are no longer in the server\n    for (auto it = _lights.begin(); it != _lights.end();) {\n        if (std::find_if(lightStates.begin(), lightStates.end(), [&](const Light& light) { return light.GetId() == it->second->GetId(); }) == lightStates.end()) {\n            it = _lights.erase(it);\n        }\n        else {\n            ++it;\n        }\n    }\n}", "CodeBleu_score": 43.880357713356524}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    auto state = _episode.Lock()->QueryLightsStateToServer();\n    for (auto& light : state) {\n        auto it = _lights.find(light.first);\n        if (it != _lights.end()) {\n            it->second->SetState(light.second);\n        } else {\n            _lights[light.first] = std::make_shared<Light>(light.first, light.second, _episode);\n        }\n    }\n}", "CodeBleu_score": 44.38308461845897}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tif (_lights_changes.size() > 0) {\n\t\tstd::vector<rpc::Color> message;\n\t\tfor (auto it = _lights.begin(); it != _lights.end(); it++) {\n\t\t\tif (_lights_changes.find(it->first) != _lights_changes.end()) {\n\t\t\t\tmessage.push_back(it->second.GetColor());\n\t\t\t}\n\t\t}\n\t\t_episode.Lock()->UpdateServerLightsState(message, discard_client);\n\t\t_lights_changes.clear();\n\t\t_dirty = false;\n\t}\n}", "CodeBleu_score": 48.010752073879566}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    if (_lights_changes.empty()) {\n        return;\n    }\n    std::vector<rpc::LightState> message;\n    for (auto& light_change : _lights_changes) {\n        message.push_back(rpc::LightState{light_change.first, light_change.second.GetLocation(), light_change.second.GetColor()});\n    }\n    _lights_changes.clear();\n    _dirty = false;\n    if (discard_client) {\n        _client->DiscardServerLightsState();\n    }\n    _client->UpdateServerLightsState(message);\n}", "CodeBleu_score": 46.95127072983155}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(_lights_mutex);\n    if (_lights_changes.size() == 0) {\n        return;\n    }\n    std::vector<rpc::LightState> message;\n    for (auto& light : _lights) {\n        if (light.second.IsDirty()) {\n            message.push_back(light.second.GetState());\n        }\n    }\n    if (message.size() > 0) {\n        _episode.Lock()->UpdateServerLightsState(message, discard_client);\n    }\n    _lights_changes.clear();\n    _dirty = false;\n}", "CodeBleu_score": 43.97156341087442}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t    log_debug(\"Sending message %s\", message.c_str());\n    if (GetId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID is not 'sensor.other.v2x_custom'\");\n        return;\n    }\n    GetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 57.58232602214972}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tlog_debug(\"Sensor %s sending message %s\", GetDisplayId().c_str(), message.c_str());\n\tif (GetDisplayId() != \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"Sensor %s is not a v2x custom sensor\", GetDisplayId().c_str());\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(message, GetContext());\n}", "CodeBleu_score": 53.909586707817546}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    log_debug(\"Sensor %s sending message: %s\", GetDisplayId().c_str(), message.c_str());\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor %s is not a v2x_custom sensor. Ignoring message.\", GetDisplayId().c_str());\n        return;\n    }\n\n    GetEpisode().Lock()->Send(message, GetContext());\n}", "CodeBleu_score": 54.53658982742618}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(this, tm_port);\n\t}\n\telse {\n\t\ttm.UnregisterVehicles(this, tm_port);\n\t}\n}", "CodeBleu_score": 45.878018377938986}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(tm_port, this);\n\t} else {\n\t\ttm.UnregisterVehicles(tm_port, this);\n\t}\n}", "CodeBleu_score": 45.59829604802113}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\t//Check if autopilot is enabled\n\tif (enabled) {\n\t\t//Register vehicle with traffic manager\n\t\ttm.RegisterVehicles(tm_port);\n\t} else {\n\t\t//Unregister vehicle with traffic manager\n\t\ttm.UnregisterVehicles(tm_port);\n\t}\n}", "CodeBleu_score": 44.256149040070156}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\n\t// get the walker actor\n\tauto walker = Cast<AWalker>(GetPawn());\n\tif (walker == nullptr) {\n\t\tUE_LOG(LogTemp, Error, TEXT(\"WalkerAIController::Start: no walker pawn found!\"));\n\t\treturn;\n\t}\n\n\t// register the walker with the navigation system\n\tauto& navSys = GetEpisode().Lock()->GetNavigation();\n\tnavSys.RegisterWalker(walker->GetId(), walker->GetLocation());\n\n\t// disable the physics simulation and collisions for the walker\n\twalker->GetActorSimulatePhysics() = false;\n\twalker->GetActorEnableCollision() = false;\n}", "CodeBleu_score": 52.23582691568156}, {"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\tauto walker = Cast<AWalker>(GetPawn());\n\tif (walker) {\n\t\tGetEpisode().Lock()->RegisterAIController(this);\n\t\tGetEpisode().Lock()->GetNavigation()->AddWalker(walker, walker->GetLocation());\n\t\twalker->GetController()->SetControlRotation(FRotator::ZeroRotator);\n\t\twalker->GetController()->SetControlRotationRate(FRotator::ZeroRotator);\n\t\twalker->GetController()->SetMoveForward(0.f);\n\t\twalker->GetController()->SetMoveRight(0.f);\n\t\twalker->GetController()->SetMoveUp(0.f);\n\t\twalker->GetController()->SetJump(false);\n\t\twalker->GetController()->SetCrouch(false);\n\t\twalker->GetController()->SetWalking(false);\n\t\twalker->GetController()->SetSprinting(false);\n\t\twalker->GetController()->SetRotationMode(EControllerRotationMode::LookingDirection);\n\t\twalker->GetController()->SetViewRotation(FRotator::ZeroRotator);\n\t\twalker->GetController()->SetViewRotationRate(FRotator::ZeroRotator);\n\t\twalker->GetController()->SetViewTarget(nullptr);\n\t\twalker->GetController()->SetViewTargetRotation(FRotator::ZeroRotator);\n\t\twalker->GetController()->SetViewTargetOffset(FVector::ZeroVector);\n\t\twalker->GetController()->SetViewTargetOffsetBase(FVector::ZeroVector);\n\t\twalker->GetController()->SetViewPitchMin(-90.f);\n\t\twalker->GetController()->SetViewPitchMax(90.f);\n\t\twalker->GetController()->SetViewYawMin(-180.f);\n\t\twalker->GetController()->SetViewYawMax(180.f);\n\t\twalker->GetController()->SetViewFOV(90.f);\n\t\twalker->GetController()->SetViewFOVMin(10.f);\n\t\twalker->GetController()->SetViewFOV", "CodeBleu_score": 38.76828918307488}, {"code": "void WalkerAIController::Start(){\n\t  Super::Start();\n\n  // Register this controller with the episode\n  auto& episode = GetEpisode();\n  episode.Lock()->RegisterAIController(this);\n\n  // Get the walker actor\n  auto walker = Cast<AWalker>(GetPawn());\n  if (!walker) {\n    UE_LOG(LogCarla, Error, TEXT(\"WalkerAIController is not parented to a walker!\"));\n    return;\n  }\n\n  // Add the walker to the navigation system\n  auto& navigation = episode.Lock()->GetNavigation();\n  if (!navigation.AddWalker(walker)) {\n    UE_LOG(LogCarla, Error, TEXT(\"WalkerAIController could not be added to the navigation system!\"));\n    return;\n  }\n\n  // Disable the physics simulation and collisions for the walker\n  walker->GetMovementComponent()->SetMovementMode(EMovementMode::MOVE_None);\n  walker->GetMovementComponent()->SetComponentTickEnabled(false);\n  walker->GetMovementComponent()->SetSimulatePhysics(false);\n  walker->GetMovementComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}", "CodeBleu_score": 35.456847140822845}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto nav = GetEpisode().GetNavigation();\n  if (nav == nullptr) {\n    log_warning(\"setting max speed for walker\", GetParent()->GetId(), \"failed, navigation is not available\");\n    return;\n  }\n\n  auto walker = GetParent();\n  if (walker == nullptr) {\n    log_warning(\"setting max speed for walker\", GetParent()->GetId(), \"failed, walker is not available\");\n    return;\n  }\n\n  if (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n    log_warning(\"setting max speed for walker\", GetParent()->GetId(), \"failed, setting speed failed\");\n  }\n}", "CodeBleu_score": 57.33792026468731}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto nav = GetEpisode().Lock()->GetNavigation();\n\tif (nav) {\n\t\tauto walker = GetParent();\n\t\tif (walker) {\n\t\t\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\t\tlog_warning(\"WalkerAIController\", \"SetMaxSpeed: Failed to set maximum speed for walker: \" + walker->GetId());\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"WalkerAIController\", \"SetMaxSpeed: Could not find parent walker: \" + GetParent()->GetId());\n\t\t}\n\t} else {\n\t\tlog_warning(\"WalkerAIController\", \"SetMaxSpeed: Could not find navigation instance\");\n\t}\n}", "CodeBleu_score": 57.28356389515407}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t    if (GetEpisode() == nullptr) {\n        log_warning(\"WalkerAIController\", \"SetMaxSpeed: episode is nullptr\");\n        return;\n    }\n    auto nav = GetEpisode().Lock()->GetNavigation();\n    if (nav == nullptr) {\n        log_warning(\"WalkerAIController\", \"SetMaxSpeed: navigation is nullptr\");\n        return;\n    }\n    auto walker = GetParent();\n    if (walker == nullptr) {\n        log_warning(\"WalkerAIController\", \"SetMaxSpeed: walker is nullptr\");\n        return;\n    }\n    if (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n        log_warning(\"WalkerAIController\", \"SetMaxSpeed: failed to set walker max speed\");\n    }\n}", "CodeBleu_score": 57.441953670418414}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (const auto& waypoint : waypoints) {\n    auto prev_wp = _parent->GetMap().GetPrevious(waypoint, distance);\n    if (prev_wp) {\n      result.emplace_back(new Waypoint(prev_wp, _parent));\n    }\n  }\n  return result;\n}", "CodeBleu_score": 68.2516449251514}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (const auto& waypoint : waypoints) {\n    result.emplace_back(std::make_shared<Waypoint>(waypoint->GetPrevious(distance), _parent));\n  }\n  return result;\n}", "CodeBleu_score": 60.04609963881654}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  std::vector<SharedPtr<Waypoint>> waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  result.reserve(waypoints.size());\n  for (auto& waypoint : waypoints) {\n    result.emplace_back(new Waypoint(waypoint, _parent));\n  }\n  return result;\n}", "CodeBleu_score": 70.50293905770053}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t    std::vector<SharedPtr<Landmark>> result;\n    std::set<SharedPtr<Signal>> added_signals;\n    std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance,\n                                                                 stop_at_junction);\n    for (auto& signal : signals) {\n      if (added_signals.count(signal) == 0) {\n        result.emplace_back\n        SharedPtr<Landmark>\n        _parent->GetMap().GetLandmark(signal->GetId())\n        added_signals.insert\n      }\n    }\n    return result;\n  }", "CodeBleu_score": 44.195141585719696}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t    // TODO: Your code here\n    std::vector<SharedPtr<Landmark>> result;\n    std::set<Signal> added_signals;\n    std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n    for (const auto &signal : signals) {\n        if (added_signals.count(signal) == 0) {\n            result.emplace_back\n            SharedPtr<Landmark>\n            _parent->GetMap().GetLandmark(signal.GetId())\n            added_signals.insert\n        }\n    }\n    return result;\n}", "CodeBleu_score": 44.07220236031709}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  // TODO: Implement this function\n  std::vector<SharedPtr<Landmark>> result;\n  std::set<int> added_signals;\n  std::vector<SharedPtr<Waypoint>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  for (auto& signal : signals) {\n    if (added_signals.count(signal->GetSignalId()) == 0) {\n      result.emplace_back\n      SharedPtr<Landmark>\n      _parent->GetMap().GetLandmarksInDistance\n      _parent->GetMap\n      added_signals.insert\n      added_signals.count\n\n", "CodeBleu_score": 40.01897479078765}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  // If the settings are already applied, return the identifier of the applied settings.\n  if (settings_ == settings) {\n    return settings_.id;\n  }\n\n  // Set the episode settings.\n  settings_ = settings;\n\n  // Set a local timeout based on the provided timeout or the episode's networking timeout.\n  auto local_timeout = timeout.milliseconds();\n  if (local_timeout == 0) {\n    local_timeout = _episode.Lock()->GetNetworkingTimeout();\n  }\n\n  // Attempt to verify the accuracy of the fixed delta time setting over a series of ticks.\n  if (settings.fixed_delta_seconds.has_value()) {\n    const float fixed_delta_seconds = settings.fixed_delta_seconds.get();\n    if (fixed_delta_seconds > 0.f) {\n      // Attempt to verify the accuracy of the fixed delta time setting over a series of ticks.\n      for (int i = 0; i < 3; ++i) {\n        // Wait for the next tick.\n        WaitForTick(local_timeout);\n\n        // Get the current snapshot.\n        auto curr_snapshot = _episode.Lock()->GetSnapshot();\n\n        // If the current snapshot is not valid, continue with the next tick.\n        if (!curr_snapshot.IsValid()) {\n          continue;\n        }\n\n        // Get the current timestamp.\n        const auto curr_timestamp = curr_snapshot.GetTimestamp();\n\n        // If the current timestamp is not valid, continue with the next tick.\n        if (!curr_timestamp.IsValid()) {\n          continue;\n        }\n\n        // Get the delta time.\n        const auto delta_time = curr_timestamp.GetDeltaSeconds();\n\n        // If the delta time is not valid, continue with the next tick.\n        if (!delta_time.IsValid()) {\n          continue;\n        }\n\n        // If the delta time is not close to the fixed delta time, continue with the next tick.\n        if (abs(delta_time.get() - fixed_delta_seconds) > std::numeric_limits<float>::epsilon()) {\n          continue;\n        }\n\n        // The delta", "CodeBleu_score": 54.03211522522871}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  // Apply the new settings.\n  uint64_t new_settings_id = _episode.Lock()->SetEpisodeSettings(settings);\n\n  // Set a local timeout based on the provided timeout or the episode's networking timeout.\n  time_duration local_timeout = timeout;\n  if (local_timeout == time_duration::zero()) {\n    local_timeout = _episode.Lock()->GetNetworkingTimeout();\n  }\n\n  // Attempt to verify the accuracy of the fixed delta time.\n  if (settings.fixed_delta_seconds.has_value()) {\n    // We need to verify the accuracy of the fixed delta time.\n    // We do this by comparing the current snapshot timestamp with the previous snapshot timestamp.\n    // If the difference is greater than the fixed delta time, we log a warning.\n    // This is because the fixed delta time is not accurate enough.\n    // The reason for this is that the fixed delta time is not used in the physics tick, but rather in the\n    // time-synchronization logic.\n    // This means that the fixed delta time is used to synchronize the clients and the server.\n    // The client waits for the fixed delta time to elapse, and then it synchronizes its state with the server.\n    // If the fixed delta time is not accurate enough, the client will synchronize with the server after a\n    // longer period of time, which means that the client will be out of sync with the server.\n    // To avoid this, we need to make sure that the fixed delta time is accurate enough.\n    // This is done by comparing the current snapshot timestamp with the previous snapshot timestamp.\n    // If the difference is greater than the fixed delta time, we log a warning.\n    // This is because the fixed delta time is not accurate enough.\n    // The reason for this is that the fixed delta time is not used in the physics tick, but rather in the\n    // time-synchronization logic.\n    // This means that the fixed delta time is used to synchronize the clients and the server.\n    // The client waits for the fixed delta time to elapse, and then it synchronizes its state with the server.\n    // If the fixed delta time is not accurate enough, the client will synchronize with the server after a", "CodeBleu_score": 23.546965388066205}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  std::lock_guard<std::mutex> lock(episode_settings_mutex_);\n\n  // Apply the settings to the world.\n  const auto new_settings = _episode.Lock()->SetEpisodeSettings(settings);\n\n  // Set a local timeout based on the provided timeout or the episode's networking timeout.\n  const auto local_timeout = std::min(timeout.milliseconds, _episode.Lock()->GetNetworkingTimeout());\n\n  // Attempt to verify the accuracy of the fixed delta time setting over a series of ticks.\n  const auto num_ticks = 10;\n  const auto delta_time = new_settings.fixed_delta_seconds.get();\n  if (new_settings.fixed_delta_seconds.has_value()) {\n    // Get the current snapshot.\n    const auto curr_snapshot = _episode.Lock()->GetSnapshot();\n\n    // Get the current timestamp.\n    const auto curr_timestamp = curr_snapshot.GetTimestamp();\n\n    // Compute the expected timestamp after the first tick.\n    const auto expected_timestamp = curr_timestamp + delta_time;\n\n    // Compute the expected delta time.\n    const auto expected_delta_time = (expected_timestamp - curr_timestamp) / num_ticks;\n\n    // Compute the delta time error.\n    const auto delta_time_error = abs(delta_time - expected_delta_time);\n\n    // Check if the delta time error is within an acceptable threshold.\n    if (delta_time_error > std::numeric_limits<float>::epsilon()) {\n      log_warning(\n          \"The fixed delta time setting was not correctly applied after a number of ticks. \"\n          \"The current delta time error is: \",\n          delta_time_error);\n    }\n  }\n\n  // Return the identifier of the applied settings.\n  return new_settings.id;\n}", "CodeBleu_score": 53.83355727596876}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    float segmentLengthSquared = Math::DistanceSquared2D(segment.first, segment.second);\n    float segmentLength = std::sqrt(segmentLengthSquared);\n    if (segmentLength == 0) {\n        return std::make_pair(0, Math::Distance2D(segment.first, point));\n    }\n    float t = Math::Clamp(Math::Dot2D(point - segment.first, segment.second - segment.first) / segmentLengthSquared, 0, 1);\n    return std::make_pair(t * segmentLength, Math::Distance2D(segment.first + t * segment.second - point));\n}", "CodeBleu_score": 34.878470564861985}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tstd::pair<float, float> Math::DistanceSegmentToPoint(const Math::Vector2& point, const Math::Vector2& start, const Math::Vector2& end) {\n\t\tMath::Vector2 segment = end - start;\n\t\tfloat segmentLengthSquared = segment.LengthSquared();\n\t\tfloat segmentLength = std::sqrt(segmentLengthSquared);\n\t\tif (segmentLength == 0.0f) {\n\t\t\treturn std::make_pair(0.0f, Math::Distance2D(point, start));\n\t\t}\n\t\tMath::Vector2 pointToSegment = point - start;\n\t\tfloat projection = Math::Clamp(Math::Dot2D(pointToSegment, segment) / segmentLengthSquared, 0.0f, 1.0f);\n\t\tMath::Vector2 projectionOnSegment = start + segment * projection;\n\t\treturn std::make_pair(segmentLength * projection, Math::Distance2D(point, projectionOnSegment));\n\t}\n}", "CodeBleu_score": 41.05793392114641}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    float x1, y1, x2, y2, x3, y3;\n    float lengthSquared, length;\n    float distanceAlongSegment, distanceFromProjection;\n\n    x1 = segment.x1;\n    y1 = segment.y1;\n    x2 = segment.x2;\n    y2 = segment.y2;\n    x3 = point.x;\n    y3 = point.y;\n\n    lengthSquared = Math::DistanceSquared2D(x1, y1, x2, y2);\n    length = std::sqrt(lengthSquared);\n\n    if (length == 0.0f) {\n        distanceAlongSegment = 0.0f;\n        distanceFromProjection = Math::Distance2D(x1, y1, x3, y3);\n        return std::make_pair(distanceAlongSegment, distanceFromProjection);\n    }\n\n    float u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / lengthSquared;\n\n    if (u > 1.0f) {\n        u = 1.0f;\n    } else if (u < 0.0f) {\n        u = 0.0f;\n    }\n\n    distanceAlongSegment = u * length;\n    distanceFromProjection = Math::Distance2D(x1 + u * (x2 - x1), y1 + u * (y2 - y1), x3, y3);\n    return std::make_pair(distanceAlongSegment, distanceFromProjection);\n}", "CodeBleu_score": 40.91984534343317}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t  DEBUG_ASSERT(vertices.size() >= 3);\n  int initial_index = AddVertices(vertices);\n  for (int i = 1; i < vertices.size() - 1; ++i) {\n    AddIndex(initial_index);\n    AddIndex(initial_index + i);\n    AddIndex(initial_index + i + 1);\n  }\n}", "CodeBleu_score": 52.56184609877519}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tDEBUG_ASSERT(vertices.size() >= 3);\n\tconst int initialIndex = static_cast<int>(this->vertices.size());\n\tthis->AddVertices(vertices);\n\tconst int numVertices = static_cast<int>(vertices.size());\n\tfor (int i = 1; i < numVertices - 1; ++i) {\n\t\tthis->AddIndex(initialIndex);\n\t\tthis->AddIndex(initialIndex + i);\n\t\tthis->AddIndex(initialIndex + i + 1);\n\t}\n}", "CodeBleu_score": 47.876051645829065}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tDEBUG_ASSERT(vertices.size() >= 3, \"There must be at least three vertices in the list to form a triangle fan.\");\n\t// Add the initial vertex\n\tAddVertex(vertices[0]);\n\t// Add the rest of the vertices\n\tfor (unsigned int i = 1; i < vertices.size() - 1; i++) {\n\t\tAddVertex(vertices[i]);\n\t}\n\t// Add the indices\n\tfor (unsigned int i = 0; i < vertices.size() - 2; i++) {\n\t\tAddIndex(0);\n\t\tAddIndex(i + 1);\n\t\tAddIndex(i + 2);\n\t}\n}", "CodeBleu_score": 40.776225393987566}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->GetBufferSequence().size() > 0);\n\n  auto self = shared_from_this();\n\n  if (!self->_socket.is_open()) {\n    log_error(\"socket is not open\");\n    return;\n  }\n\n  self->_deadline.expires_from_now(std::chrono::seconds(10));\n  self->_deadline.async_wait(boost::asio::bind_executor(\n      self->_strand,\n      [self, message](const boost::system::error_code &ec) {\n        if (ec) {\n          log_error(ec.message());\n          self->CloseNow();\n          return;\n        }\n        boost::asio::async_write(\n            self->_socket,\n            message->GetBufferSequence(),\n            boost::asio::bind_executor(\n                self->_strand,\n                std::bind(\n                    &Primary::handle_sent,\n                    self,\n                    std::placeholders::_1,\n                    message)));\n      }));\n}", "CodeBleu_score": 47.786023148658174}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\n  // Check if the message is valid.\n  if (!message->Verify()) {\n    log_error(\"Invalid message: \", message->GetBufferSequence());\n    return;\n  }\n\n  // Post a lambda function to the strand for execution.\n  _strand.post([self = shared_from_this(), message]() {\n\n    // Check if the socket is open.\n    if (!self->_socket.is_open()) {\n      log_error(\"Socket is not open\");\n      return;\n    }\n\n    // Set a timeout.\n    self->_deadline.expires_from_now(std::chrono::seconds(10));\n\n    // Initiate an asynchronous write.\n    boost::asio::async_write(self->_socket, message->GetBufferSequence(),\n      boost::asio::bind_executor(self->_strand, std::bind(&Primary::handle_sent, self, std::placeholders::_1, message)));\n  });\n}", "CodeBleu_score": 33.2392991671362}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  if (message->empty()) {\n    log_error(\"message->empty\");\n    return;\n  }\n  if (!_socket.is_open()) {\n    log_error(\"self->_socket.is_open\");\n    return;\n  }\n  auto self = shared_from_this();\n  boost::asio::post(_strand, [self, message]() {\n    if (!self->_socket.is_open()) {\n      log_error(\"self->_socket.is_open\");\n      return;\n    }\n    self->_deadline.expires_from_now(std::chrono::seconds(30));\n    self->_deadline.async_wait(boost::asio::bind_executor(\n        self->_strand,\n        [self](const boost::system::error_code &ec) {\n          if (ec != boost::asio::error::operation_aborted) {\n            self->CloseNow();\n          }\n        }));\n    boost::system::error_code ec;\n    boost::asio::async_write(\n        self->_socket,\n        message->GetBufferSequence(),\n        boost::asio::bind_executor(\n            self->_strand,\n            [self, message](const boost::system::error_code &ec, std::size_t bytes_transferred) {\n              self->HandleSent(ec, message, bytes_transferred);\n            }));\n  });\n}", "CodeBleu_score": 49.85494155178266}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!ec && _socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t}\n\tif (ec && _socket.is_open()) {\n\t\t_socket.close(ec);\n\t}\n\tif (!ec) {\n\t\t_on_closed();\n\t}\n\tlog_debug(\"Closed\");\n}", "CodeBleu_score": 49.13493714169561}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n    if (!ec && _socket.is_open()) {\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        _socket.close(ec);\n    }\n    _on_closed();\n    log_debug(\"Session closed: \", ec.message());\n}", "CodeBleu_score": 50.93766266472856}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n  if (!ec && _socket.is_open()) {\n    _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    _socket.close(ec);\n  }\n  _on_closed();\n  log_debug(\"Session closed: {}\", ec.message());\n}", "CodeBleu_score": 49.5382953042346}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tstd::string msg = \"Are you alive?\";\n\tstd::shared_ptr<Buffer> buffer = std::make_shared<Buffer>(msg.size());\n\tmemcpy(buffer->data, msg.c_str(), msg.size());\n\n\t// Log the sending action\n\tLog::GetInstance().Log(\"Sending message: \" + msg, \"PrimaryCommands::SendIsAlive\");\n\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\n\t// Wait for and log the response from the system\n\tstd::shared_ptr<Buffer> response = _router->ReadFromNext();\n\tLog::GetInstance().Log(\"Response: \" + std::string(response->data, response->size), \"PrimaryCommands::SendIsAlive\");\n}", "CodeBleu_score": 46.35886430839064}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t    std::string msg = \"Are you alive?\";\n    std::cout << \"Sending message: \" << msg << std::endl;\n    std::shared_ptr<Buffer> buffer = std::make_shared<Buffer>(msg.size());\n    memcpy(buffer->data(), msg.c_str(), msg.size());\n    _router->WriteToNext(buffer, YOU_ALIVE);\n    std::shared_ptr<Buffer> response = _router->ReadFromNext();\n    std::cout << \"Received message: \" << std::string(response->data()) << std::endl;\n}", "CodeBleu_score": 46.80142056046749}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::string msg = \"Are you alive?\";\n\tstd::string response;\n\tBuffer buffer(msg.size());\n\tbuffer.data = msg.c_str();\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\t_router->ReadFromNext(response);\n\tif (response == \"I am alive!\") {\n\t\tlog_info(\"System is alive!\");\n\t} else {\n\t\tlog_info(\"System is not alive!\");\n\t}\n}", "CodeBleu_score": 51.37267881638918}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    // Check if the sensor is already activated on any server.\n    if (std::find_if(_servers.begin(), _servers.end(), [&](const auto &s) { return s.second.sensor_ids.find(sensor_id) != s.second.sensor_ids.end(); }) != _servers.end()) {\n        // If the sensor is activated on any server, create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router.\n        std::vector<uint8_t> buffer(sizeof(stream_id));\n        memcpy(buffer.data(), &sensor_id, sizeof(stream_id));\n        _router->SendCommand(ServerCommand::ENABLE_ROS, buffer);\n        // Wait for and process the server's response.\n        std::future<std::vector<uint8_t>> fut = _router->ReadFromOne();\n        std::vector<uint8_t> response = fut.get();\n        if (response.size() != sizeof(bool)) {\n            log_error(\"Invalid response from server.\");\n            return;\n        }\n        if (!*reinterpret_cast<bool *>(response.data())) {\n            log_error(\"Failed to enable sensor.\");\n        }\n    } else {\n        // If the sensor is not activated on any server, log an error message.\n        log_error(\"Sensor is not activated on any server.\");\n    }\n}", "CodeBleu_score": 48.19268631317435}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    // Create a buffer with the sensor ID\n    Buffer buffer;\n    buffer.data = std::vector<uint8_t>(sizeof(stream_id));\n    memcpy(buffer.data.data(), &sensor_id, sizeof(stream_id));\n    // Send the command to the server\n    auto fut = _router->WriteToOne(buffer, it->second);\n    // Wait for the server's response\n    auto response = fut.get();\n    // Check if the command was processed successfully\n    if (response.buffer.data[0] == 0x00) {\n      // Log the command was processed successfully\n      log_info(\"ROS enabled for sensor %d\", sensor_id);\n    } else {\n      // Log the command was not processed successfully\n      log_error(\"ROS enable failed for sensor %d\", sensor_id);\n    }\n  } else {\n    // Log the sensor was not found\n    log_error(\"ROS enable failed for sensor %d, not found on any server\", sensor_id);\n  }\n}", "CodeBleu_score": 62.65384264411345}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  // Check if the sensor has been activated on any secondary server\n  if (CheckIfSensorActivated(sensor_id)) {\n    // Create a buffer with the sensor ID\n    std::vector<uint8_t> buffer = {static_cast<uint8_t>(sensor_id)};\n    // Send an ENABLE_ROS command to the server using the router\n    auto fut = _router->WriteToOne(buffer, Command::ENABLE_ROS);\n    // Wait for and process the server's response\n    auto response = fut.get();\n    if (response.buffer.data[0] != 0) {\n      // Log an error message\n      log_error(\"Sensor {} not activated on any secondary server\", sensor_id);\n    }\n  }\n}", "CodeBleu_score": 43.00004333907758}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // Check if the sensor is already activated\n  if (_tokens.find(sensor_id) != _tokens.end()) {\n    log_debug(\"Retrieving existing token for sensor %d\", sensor_id);\n    return _tokens[sensor_id];\n  }\n\n  // If not, enable the sensor on a secondary server\n  log_debug(\"Enabling sensor %d on secondary server\", sensor_id);\n  _router->GetNextServer(sensor_id);\n\n  // Send a GetToken request to the secondary server\n  SendGetToken(sensor_id);\n\n  // Wait for the response\n  token_type token;\n  _tokens_mutex.lock();\n  _tokens_cv.wait(_tokens_mutex, [this, sensor_id] {\n    return (_tokens.find(sensor_id) != _tokens.end());\n  });\n  token = _tokens[sensor_id];\n  _tokens_mutex.unlock();\n\n  // Update the maps\n  _streams_mutex.lock();\n  _streams[sensor_id] = token.get_port();\n  _streams_cv.notify_all();\n  _streams_mutex.unlock();\n  _tokens_mutex.lock();\n  _tokens[sensor_id] = token;\n  _tokens_cv.notify_all();\n  _tokens_mutex.unlock();\n\n  log_debug(\"Retrieved token for sensor %d\", sensor_id);\n  return token;\n}", "CodeBleu_score": 48.05389085308804}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // Get the token from the map\n  token_type token;\n  token_map::iterator it = _tokens.find(sensor_id);\n\n  if (it != _tokens.end()) {\n    // Sensor already activated\n    token = it->second;\n    log_debug(\"Token for sensor %d already activated\", sensor_id);\n  } else {\n    // Sensor not activated, activate it\n    token = _router->GetNextServer(sensor_id);\n    _tokens.insert(token_map::value_type(sensor_id, token));\n    log_debug(\"Activating sensor %d on server %s:%d\", sensor_id, token.get_host().c_str(), token.get_port());\n  }\n\n  return token;\n}", "CodeBleu_score": 52.857997800563304}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// Check if the sensor is already activated\n\tauto it = _tokens.find(sensor_id);\n\tif (it != _tokens.end()) {\n\t\tlog_debug(\"Token for sensor %d already activated.\", sensor_id);\n\t\treturn it->second;\n\t}\n\n\t// If not, get a new token from a secondary server\n\ttoken_type token = _router->GetNextServer()->GetToken(sensor_id);\n\tlog_debug(\"Got new token for sensor %d from secondary server.\", sensor_id);\n\n\t// Update the maps\n\t_tokens[sensor_id] = token;\n\t_ports[token.get_port()] = sensor_id;\n\t_streams[token.get_stream_id()] = sensor_id;\n\n\t// Log the action\n\tlog_debug(\"Activated sensor %d with token %d.\", sensor_id, token.get_port());\n\n\t// Return the new token\n\treturn token;\n}", "CodeBleu_score": 62.433063220759124}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f(filename, std::ios::binary);\n    if (!f.is_open()) {\n        return false;\n    }\n    std::vector<char> data((std::istreambuf_iterator<char>(f)),\n                           (std::istreambuf_iterator<char>()));\n    f.close();\n    return Load(data);\n}", "CodeBleu_score": 61.27374718090191}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f;\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n        std::cout << \"Could not open file \" << filename << std::endl;\n        return false;\n    }\n    std::vector<char> file_data;\n    file_data.assign(std::istreambuf_iterator<char>(f), std::istreambuf_iterator<char>());\n    f.close();\n    return Load(file_data);\n}", "CodeBleu_score": 62.9391376815688}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f;\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n        return false;\n    }\n\n    std::vector<char> fileData;\n    fileData.resize(std::filesystem::file_size(filename));\n    f.read(fileData.data(), fileData.size());\n    f.close();\n    return Load(fileData);\n}", "CodeBleu_score": 67.82503877078948}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(IsReady());\n\tDEBUG_ASSERT(_crowd != nullptr);\n\n\t// Find the agent in the walker and vehicle mappings.\n\tauto walker_it = _mapped_walkers_id.find(id);\n\tauto vehicle_it = _mapped_vehicles_id.find(id);\n\n\t// If found, remove the agent from the crowd.\n\tif (walker_it != _mapped_walkers_id.end()) {\n\t\t_crowd->removeAgent(_mapped_walkers_id[id]);\n\t\t_walker_manager.RemoveWalker(id);\n\t\t_mapped_walkers_id.erase(walker_it);\n\t\t_mapped_by_index.erase(walker_it->second);\n\t\t_mapped_by_index.erase(id);\n\t\treturn true;\n\t} else if (vehicle_it != _mapped_vehicles_id.end()) {\n\t\t_crowd->removeAgent(_mapped_vehicles_id[id]);\n\t\t_vehicle_manager.RemoveVehicle(id);\n\t\t_mapped_vehicles_id.erase(vehicle_it);\n\t\t_mapped_by_index.erase(vehicle_it->second);\n\t\t_mapped_by_index.erase(id);\n\t\treturn true;\n\t}\n\n\t// If not found, return false.\n\treturn false;\n}", "CodeBleu_score": 55.50514769619096}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(m_crowd);\n\tDEBUG_ASSERT(m_ready);\n\tDEBUG_ASSERT(m_walker_manager);\n\tDEBUG_ASSERT(m_vehicle_manager);\n\n\t// Check if the agent is a walker\n\tauto walker_it = _mapped_walkers_id.find(id);\n\tif (walker_it != _mapped_walkers_id.end()) {\n\t\t// Enter a critical section\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t\t// Remove the agent from the crowd\n\t\t_crowd->removeAgent(walker_it->second);\n\n\t\t// Remove the agent from the walker manager\n\t\t_walker_manager->RemoveWalker(walker_it->second);\n\n\t\t// Remove the agent from the mappings\n\t\t_mapped_walkers_id.erase(walker_it);\n\t\t_mapped_by_index.erase(walker_it->second);\n\t\treturn true;\n\t}\n\n\t// Check if the agent is a vehicle\n\tauto vehicle_it = _mapped_vehicles_id.find(id);\n\tif (vehicle_it != _mapped_vehicles_id.end()) {\n\t\t// Enter a critical section\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t\t// Remove the agent from the crowd\n\t\t_crowd->removeAgent(vehicle_it->second);\n\n\t\t// Remove the agent from the vehicle manager\n\t\t_vehicle_manager->RemoveVehicle(vehicle_it->second);\n\n\t\t// Remove the agent from the mappings\n\t\t_mapped_vehicles_id.erase(vehicle_it);\n\t\t_mapped_by_index.erase(vehicle_it->second);\n\t\treturn true;\n\t}\n\n\t// Agent not found\n\treturn false;\n}", "CodeBleu_score": 60.62637663015359}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  DEBUG_ASSERT(IsReady());\n  DEBUG_ASSERT(_crowd != nullptr);\n  std::lock_guard<std::mutex> lock(_mutex);\n  auto walker_it = _mapped_walkers_id.find(id);\n  if (walker_it != _mapped_walkers_id.end()) {\n    _walker_manager.RemoveWalker(walker_it->second);\n    _mapped_walkers_id.erase(walker_it);\n    _mapped_by_index.erase(walker_it->second);\n    _mapped_walkers_id.erase(id);\n    return true;\n  }\n  auto vehicle_it = _mapped_vehicles_id.find(id);\n  if (vehicle_it != _mapped_vehicles_id.end()) {\n    _crowd->removeAgent(vehicle_it->second);\n    _mapped_vehicles_id.erase(vehicle_it);\n    _mapped_by_index.erase(vehicle_it->second);\n    _mapped_vehicles_id.erase(id);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 62.91800138529611}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::set<int> ids;\n\tfor (auto& v : vehicles_) {\n\t\tids.insert(v.id);\n\t}\n\n\tfor (auto& v : vehicles) {\n\t\tif (ids.find(v.id) != ids.end()) {\n\t\t\t// Update\n\t\t\tauto it = std::find_if(vehicles_.begin(), vehicles_.end(), [&](const Vehicle& v) {\n\t\t\t\treturn v.id == v.id;\n\t\t\t});\n\n\t\t\tit->updated = true;\n\t\t\tit->position = v.position;\n\t\t\tit->velocity = v.velocity;\n\t\t\tit->heading = v.heading;\n\t\t\tit->acceleration = v.acceleration;\n\t\t\tit->braking = v.braking;\n\t\t\tit->steering = v.steering;\n\t\t\tit->size = v.size;\n\t\t}\n\t\telse {\n\t\t\t// Add\n\t\t\tVehicle v;\n\t\t\tv.id = v.id;\n\t\t\tv.position = v.position;\n\t\t\tv.velocity = v.velocity;\n\t\t\tv.heading = v.heading;\n\t\t\tv.acceleration = v.acceleration;\n\t\t\tv.braking = v.braking;\n\t\t\tv.steering = v.steering;\n\t\t\tv.size = v.size;\n\t\t\tv.updated = true;\n\t\t\tvehicles_.push_back(v);\n\t\t}\n\t}\n\n\tfor (auto it = vehicles_.begin(); it != vehicles_.end(); ++it) {\n\t\tif (!it->updated) {\n\t\t\tit = vehicles_.erase(it);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 48.78741946022318}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::set<int> current_ids;\n\tstd::set<int> updated_ids;\n\tfor (auto& v : vehicles) {\n\t\tcurrent_ids.insert(v.id);\n\t\tauto it = vehicles_.find(v.id);\n\t\tif (it != vehicles_.end()) {\n\t\t\tit->second.Update(v);\n\t\t\tupdated_ids.insert(v.id);\n\t\t}\n\t\telse {\n\t\t\tvehicles_.insert(std::make_pair(v.id, Vehicle(v)));\n\t\t\tupdated_ids.insert(v.id);\n\t\t}\n\t}\n\tfor (auto it = vehicles_.begin(); it != vehicles_.end(); it++) {\n\t\tif (updated_ids.find(it->first) == updated_ids.end()) {\n\t\t\tit = vehicles_.erase(it);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.053249211158246}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    std::set<int> vehicleIds;\n    for (auto& v : m_vehicles) {\n        vehicleIds.insert(v.first);\n    }\n\n    for (auto& v : vehicles) {\n        if (vehicleIds.find(v.id) != vehicleIds.end()) {\n            m_vehicles[v.id].Update(v);\n        } else {\n            AddOrUpdateVehicle(v);\n        }\n    }\n\n    for (auto it = vehicleIds.begin(); it != vehicleIds.end();) {\n        if (vehicleIds.find(*it) == vehicleIds.end()) {\n            m_vehicles.erase(*it);\n            it = vehicleIds.erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 55.27895448901414}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    return _crowd->hasVehicleNear(_mapped_walkers_id[id], distance, direction);\n  }\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    return _crowd->hasVehicleNear(_mapped_vehicles_id[id], distance, direction);\n  }\n  return false;\n}", "CodeBleu_score": 56.652578848649206}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  // TODO: This function is not thread safe.\n  //       It must be called from the same thread that calls Update.\n  //       It is not a problem in the current implementation, but it must be\n  //       considered when the navigation is used in a multi-threaded context.\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    return _crowd->hasVehicleNear(it->second, distance, direction);\n  }\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    return _crowd->hasVehicleNear(it->second, distance, direction);\n  }\n  return false;\n}", "CodeBleu_score": 57.85031343199603}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    auto distance_squared = (it->second.location - direction).LengthSquared();\n    if (distance_squared < distance * distance) {\n      return _crowd->hasVehicleNear(it->second.location, distance);\n    }\n  }\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    auto distance_squared = (it->second.location - direction).LengthSquared();\n    if (distance_squared < distance * distance) {\n      return _crowd->hasVehicleNear(it->second.location, distance);\n    }\n  }\n  return false;\n}", "CodeBleu_score": 61.94866932733005}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  WalkerEventVisitor visitor(info, delta);\n  EventResult result = boost::variant2::visit(visitor, info.current_route_point.event);\n  info.current_route_point.event = Event();\n  return result;\n}", "CodeBleu_score": 41.88402254118085}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    auto &actor = m_actors[id];\n    auto &walker = actor.GetWalker();\n    auto &route = walker.GetRoute();\n    auto &route_points = walker.GetRoutePoints();\n    auto &event = walker.GetEvent();\n\n    auto &ctx = actor.GetContext();\n\n    auto &wp = route_points[info.current_route_point];\n    auto &point = wp.point;\n    auto &event_id = wp.event;\n\n    auto &event_map = walker.GetEventMap();\n    auto &event_visitor = walker.GetEventVisitor();\n\n    if (event_id != -1) {\n        auto &event_ptr = event_map[event_id];\n        event_visitor.SetContext(ctx);\n        event_visitor.SetActor(actor);\n        event_visitor.SetPoint(point);\n        event_visitor.SetDelta(delta);\n        event_visitor.SetEvent(event_ptr);\n        auto result = boost::variant2::visit(event_visitor, event);\n        if (result.IsSuccess()) {\n            walker.SetEvent(nullptr);\n            walker.SetEventMap({});\n            walker.SetEventVisitor(nullptr);\n        }\n        return result;\n    }\n    return EventResult::Success();\n}", "CodeBleu_score": 39.92501625906715}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    WalkerEventVisitor visitor(m_context, id, info, delta);\n    boost::variant2::visit(visitor, info.route.GetCurrentPoint());\n    return visitor.GetResult();\n}", "CodeBleu_score": 42.31909818708797}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  pugi::xml_node open_drive_node = xml.child(\"OpenDRIVE\");\n  pugi::xml_node road_node = open_drive_node.child(\"road\");\n  for (pugi::xml_node road_node = open_drive_node.child(\"road\");\n      road_node;\n      road_node = road_node.next_sibling(\"road\")) {\n    map_builder.AddRoad(road_node.attribute(\"id\").as_uint());\n    pugi::xml_node lanes_node = road_node.child(\"lanes\");\n    for (pugi::xml_node lane_section_node = lanes_node.child(\"laneSection\");\n        lane_section_node;\n        lane_section_node = lane_section_node.next_sibling(\"laneSection\")) {\n      double s = lane_section_node.attribute(\"s\").as_double();\n      map_builder.AddLaneSection(road_node.attribute(\"id\").as_uint(), s);\n      ParseLanes(lane_section_node, map_builder);\n    }\n  }\n}", "CodeBleu_score": 50.16680907519285}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  auto open_drive_node = xml.child(\"OpenDRIVE\");\n  auto road_node = open_drive_node.child(\"road\");\n  auto lane_section_node = road_node.child(\"lanes\");\n\n  for (auto road_node = open_drive_node.child(\"road\"); road_node; road_node = road_node.next_sibling(\"road\")) {\n\n    auto road_id = road_node.attribute(\"id\").as_uint();\n    map_builder.AddRoad(road_id);\n\n    for (auto lane_section_node = road_node.child(\"lanes\"); lane_section_node; lane_section_node = lane_section_node.next_sibling(\"lanes\")) {\n\n      auto left_lane_node = lane_section_node.child(\"left\");\n      auto center_lane_node = lane_section_node.child(\"center\");\n      auto right_lane_node = lane_section_node.child(\"right\");\n\n      ParseLanes(left_lane_node, map_builder, road_id, 0);\n      ParseLanes(center_lane_node, map_builder, road_id, 1);\n      ParseLanes(right_lane_node, map_builder, road_id, 2);\n    }\n  }\n}", "CodeBleu_score": 51.43516377195472}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  pugi::xml_node open_drive_node = xml.child(\"OpenDRIVE\");\n  pugi::xml_node road_node = open_drive_node.child(\"road\");\n  pugi::xml_node lane_section_node = road_node.child(\"lanes\");\n  pugi::xml_node lane_node = lane_section_node.child(\"lane\");\n  pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n  pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n  pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n  // Iterate through each road node and extract the road ID\n  for (road_node = open_drive_node.child(\"road\"); road_node; road_node = road_node.next_sibling(\"road\")) {\n    // Extract the road ID\n    uint64_t road_id = road_node.attribute(\"id\").as_uint();\n    // Iterate through each lane section node and process the lanes\n    for (lane_section_node = road_node.child(\"lanes\"); lane_section_node; lane_section_node = lane_section_node.next_sibling(\"lanes\")) {\n      // Extract the s coordinate\n      double s = lane_section_node.attribute(\"s\").as_double();\n      // Process the left lane\n      ParseLanes(left_lane_node, s, map_builder, road_id, carla::road::LaneType::LaneType_Left);\n      // Process the center lane\n      ParseLanes(center_lane_node, s, map_builder, road_id, carla::road::LaneType::LaneType_Center);\n      // Process the right lane\n      ParseLanes(right_lane_node, s, map_builder, road_id, carla::road::LaneType::LaneType_Right);\n    }\n  }\n}", "CodeBleu_score": 57.73417423673202}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  std::lock_guard<std::mutex> lock(mutex_);\n  if (info.current_count_change == 1) {\n    if (info.current_count == 1) {\n      if (first_connection_) {\n        first_connection_ = false;\n        RCLCPP_INFO(node_->get_logger(), \"CarlaListener: First connection established.\");\n      }\n      ++matched_count_;\n    } else if (info.current_count == 0) {\n      if (matched_count_ > 0) {\n        --matched_count_;\n      } else {\n        RCLCPP_ERROR(node_->get_logger(), \"CarlaListener: Invalid publication matched count change.\");\n      }\n    } else {\n      RCLCPP_ERROR(node_->get_logger(), \"CarlaListener: Invalid publication matched count change.\");\n    }\n  } else if (info.current_count_change == -1) {\n    if (info.current_count == 0) {\n      if (matched_count_ > 0) {\n        --matched_count_;\n      } else {\n        RCLCPP_ERROR(node_->get_logger(), \"CarlaListener: Invalid publication matched count change.\");\n      }\n    } else if (info.current_count == 1) {\n      if (matched_count_ < 1) {\n        ++matched_count_;\n      } else {\n        RCLCPP_ERROR(node_->get_logger(), \"CarlaListener: Invalid publication matched count change.\");\n      }\n    } else {\n      RCLCPP_ERROR(node_->get_logger(), \"CarlaListener: Invalid publication matched count change.\");\n    }\n  } else {\n    RCLCPP_ERROR(node_->get_logger(), \"CarlaListener: Invalid publication matched count change.\");\n  }\n}", "CodeBleu_score": 49.83065342445197}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  if (info.current_count_change > 0) {\n    if (info.current_count == 1) {\n      RCLCPP_INFO(this->get_logger(), \"A new match has been found for the topic '%s'.\", writer->get_topic_name());\n      first_connection_ = true;\n    }\n    RCLCPP_INFO(this->get_logger(), \"The number of matches for the topic '%s' is now %d.\", writer->get_topic_name(), info.current_count);\n  } else if (info.current_count_change < 0) {\n    RCLCPP_INFO(this->get_logger(), \"A match has been lost for the topic '%s'.\", writer->get_topic_name());\n  } else {\n    RCLCPP_ERROR(this->get_logger(), \"Invalid count change for the topic '%s'.\", writer->get_topic_name());\n  }\n}", "CodeBleu_score": 49.247192494536726}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t  if (info.current_count_change == efd::MATCHED_MATCHED) {\n    // A new match has been found.\n    if (matched_count_ == 0) {\n      // This is the first match.\n      first_connection_ = true;\n    }\n    matched_count_++;\n  } else if (info.current_count_change == efd::MATCHED_UNMATCHED) {\n    // A match has been lost.\n    if (matched_count_ == 0) {\n      // This is an invalid state.\n      std::cerr << \"CarlaListenerImpl::on_publication_matched: invalid publication match count change.\" << std::endl;\n    } else {\n      matched_count_--;\n    }\n  } else {\n    // This is an invalid state.\n    std::cerr << \"CarlaListenerImpl::on_publication_matched: invalid publication match count change.\" << std::endl;\n  }\n}", "CodeBleu_score": 47.44268862908054}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\n    if (info.current_count_change == 1) {\n        if (info.total_count == 1) {\n            _first_connected = true;\n        }\n        _matched_count++;\n    } else if (info.current_count_change == -1) {\n        if (info.total_count == 0) {\n            _first_connected = false;\n            _matched_count = 0;\n            _owner->DestroySubscriber();\n        } else {\n            _matched_count--;\n        }\n    } else {\n        std::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: Invalid change count: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 63.6079513004276}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        if (info.current_count == 1) {\n            _first_connected = true;\n        }\n        _matched_count = info.current_count;\n    } else if (info.current_count_change == -1) {\n        if (info.current_count == 0) {\n            _matched_count = 0;\n            _first_connected = false;\n            _owner->DestroySubscriber();\n        } else {\n            _matched_count = info.current_count;\n        }\n    } else {\n        if (info.current_count_change < 0) {\n            _matched_count = info.current_count;\n            _first_connected = false;\n        } else {\n            _matched_count = info.current_count;\n            _first_connected = true;\n        }\n    }\n}", "CodeBleu_score": 61.455104515408365}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        if (info.current_count == 1) {\n            if (info.last_publication_handle == efd::InstanceHandle_t()) {\n                _first_connected = true;\n            }\n            _matched_count++;\n        } else if (info.current_count == 0) {\n            if (_matched_count > 0) {\n                _matched_count--;\n            }\n            if (_matched_count == 0) {\n                _owner->DestroySubscriber();\n            }\n        } else {\n            std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched(): change count is invalid\" << std::endl;\n        }\n    } else if (info.current_count_change == -1) {\n        if (_matched_count > 0) {\n            _matched_count--;\n        }\n        if (_matched_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched(): change count is invalid\" << std::endl;\n    }\n}", "CodeBleu_score": 61.43103953214117}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_getKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    if (m_use_md5) {\n        m_md5.reset();\n        m_md5.update(static_cast<unsigned char*>(static_cast<void*>(&(p_type->m_collision_event))), 1);\n        m_md5.update(static_cast<unsigned char*>(static_cast<void*>(&(p_type->m_actor_id))), 4);\n        m_md5.update(static_cast<unsigned char*>(static_cast<void*>(&(p_type->m_other_actor_id))), 4);\n        m_md5.update(static_cast<unsigned char*>(static_cast<void*>(&(p_type->m_collision_point))), 4);\n        m_md5.update(static_cast<unsigned char*>(static_cast<void*>(&(p_type->m_normal))), 4);\n        m_md5.update(static_cast<unsigned char*>(static_cast<void*>(&(p_type->m_impulse))), 4);\n        m_md5.update(static_cast<unsigned char*>(static_cast<void*>(&(p_type->m_delta))), 4);\n        m_md5.update(static_cast<unsigned char*>(static_cast<void*>(&(p_type->m_delta_angle))), 4);\n        m_md5.update(static_cast<unsigned char*>(static_cast<void*>(&(p_type->m_event_time))), 4);\n        m_md5.finalize();\n        for (unsigned int i = 0; i < 16; i++) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        memcpy(handle->value, &(p_type->m_collision_event), 1);\n        memcpy(handle->value + ", "CodeBleu_score": 42.106713633174984}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_is_key_defined) {\n        return false;\n    }\n    if (!m_is_md5_defined && !force_md5) {\n        memcpy(handle, &static_cast<CarlaCollisionEvent*>(data)->key, sizeof(CarlaCollisionEvent::_key));\n        return true;\n    }\n    else {\n        m_md5.reset();\n        uint8_t* buf = static_cast<uint8_t*>(m_md5.getBuffer());\n        m_key_p_type.serializeKey(data, buf);\n        m_md5.finalize();\n        for (unsigned int i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.getValue()[i];\n        }\n        return true;\n    }\n}", "CodeBleu_score": 45.57108551660314}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    if (p_type == nullptr) {\n        return false;\n    }\n    if (p_type->m_key.empty()) {\n        return false;\n    }\n    if (!force_md5 && !p_type->m_md5.empty()) {\n        *handle = p_type->m_key;\n        return true;\n    }\n    std::string key = p_type->getKey();\n    if (key.empty()) {\n        return false;\n    }\n    *handle = key;\n    return true;\n}", "CodeBleu_score": 26.336650676967754}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    // Object fields\n    cdr_serialize(p_type->Throttle, payload->encapsulation);\n    cdr_serialize(p_type->Steer, payload->encapsulation);\n    cdr_serialize(p_type->Brake, payload->encapsulation);\n    cdr_serialize(p_type->HandBrake, payload->encapsulation);\n    cdr_serialize(p_type->Reverse, payload->encapsulation);\n    cdr_serialize(p_type->ManualGearShift, payload->encapsulation);\n    cdr_serialize(p_type->Gear, payload->encapsulation);\n    cdr_serialize(p_type->TargetGear, payload->encapsulation);\n    cdr_serialize(p_type->TargetLinearSpeed, payload->encapsulation);\n    cdr_serialize(p_type->TargetAngularSpeed, payload->encapsulation);\n    cdr_serialize(p_type->TargetTime, payload->encapsulation);\n    cdr_serialize(p_type->Control, payload->encapsulation);\n    cdr_serialize(p_type->UseAutoGears, payload->encapsulation);\n    cdr_serialize(p_type->ManualGearShift, payload->encapsulation);\n    cdr_serialize(p_type->Gear, payload->encapsulation);\n    cdr_serialize(p_type->TargetGear, payload->encapsulation);\n    cdr_serialize(p_type->TargetLinearSpeed, payload->encapsulation);\n    cdr_serialize(p_type->TargetAngularSpeed, payload->encapsulation);\n    cdr_serialize(p_type->TargetTime, payload->encapsulation);\n    cdr_serialize(p_type->Control, payload->encapsulation);\n    cdr_serialize(p_type->UseAutoGears, payload->encapsulation);\n    cdr_serialize(p_type->ManualGearShift, payload->encaps", "CodeBleu_score": 26.724821959820368}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    // Object fields\n    // Member: throttle\n    {\n        uint32_t len = 0;\n        len = p_type->throttle.getMaxCdrSerializedSize();\n        if(p_type->throttle.serialize(p_type->throttle.getBuffer(len), len) < 0) return false;\n    }\n    // Member: steer\n    {\n        uint32_t len = 0;\n        len = p_type->steer.getMaxCdrSerializedSize();\n        if(p_type->steer.serialize(p_type->steer.getBuffer(len), len) < 0) return false;\n    }\n    // Member: brake\n    {\n        uint32_t len = 0;\n        len = p_type->brake.getMaxCdrSerializedSize();\n        if(p_type->brake.serialize(p_type->brake.getBuffer(len), len) < 0) return false;\n    }\n    // Member: hand_brake\n    {\n        uint32_t len = 0;\n        len = p_type->hand_brake.getMaxCdrSerializedSize();\n        if(p_type->hand_brake.serialize(p_type->hand_brake.getBuffer(len), len) < 0) return false;\n    }\n    // Member: reverse\n    {\n        uint32_t len = 0;\n        len = p_type->reverse.getMaxCdrSerializedSize();\n        if(p_type->reverse.serialize(p_type->reverse.getBuffer(len), len) < 0) return false;\n    }\n    // Member: manual_gear_shift\n    {\n        uint32_t len = 0;\n        len = p_type->manual_gear_shift.getMaxCdrSerializedSize();\n        if(p_type->manual_gear_shift.serialize(p_type->manual_gear_shift.", "CodeBleu_score": 29.138162171747027}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t  CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n  // Object fields serialization\n  if(p_type->serialize(&payload->encapsulation, &payload->buffer)) {\n    payload->length = payload->buffer.get_pos();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 25.569762514899786}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (tracker.gcs().target_set()) {\n        return;\n    }\n\n    if (msg.msgid != MAVLINK_MSG_ID_HEARTBEAT) {\n        return;\n    }\n\n    mavlink_heartbeat_t hb;\n    mavlink_msg_heartbeat_decode(&msg, &hb);\n\n    if (hb.type != MAV_TYPE_GCS) {\n        return;\n    }\n\n    tracker.gcs().set_target(hb.sysid);\n\n    mavlink_message_t msg;\n    mavlink_msg_request_datastream_pack(tracker.gcs().target(),\n                                        tracker.gcs().target(),\n                                        MAV_DATA_STREAM_POSITION,\n                                        &msg,\n                                        tracker.gcs().target(),\n                                        MAV_DATA_STREAM_POSITION,\n                                        MAV_DATA_STREAM_POSITION_RATE,\n                                        0);\n    tracker.gcs().send_message(&msg);\n\n    mavlink_msg_request_datastream_pack(tracker.gcs().target(),\n                                        tracker.gcs().target(),\n                                        MAV_DATA_STREAM_AIR_PRESSURE,\n                                        &msg,\n                                        tracker.gcs().target(),\n                                        MAV_DATA_STREAM_AIR_PRESSURE,\n                                        MAV_DATA_STREAM_AIR_PRESSURE_RATE,\n                                        0);\n    tracker.gcs().send_message(&msg);\n\n    tracker.gcs().set_target_set(true);\n}", "CodeBleu_score": 47.64382147436809}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\tswitch (msg.msgid) {\n\t\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\t\t\tmavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\t\t\tif (heartbeat.type == MAV_TYPE_GCS) {\n\t\t\t\ttarget_set = true;\n\t\t\t\ttarget_sysid = heartbeat.sysid;\n\t\t\t\ttracker.gcs().request_datastream_position(target_sysid);\n\t\t\t\ttracker.gcs().request_datastream_airpressure(target_sysid);\n\t\t\t\ttracker.gcs().request_datastream_battery(target_sysid);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MAVLINK_MSG_ID_SYS_STATUS:\n\t\t\tmavlink_msg_sys_status_decode(&msg, &sys_status);\n\t\t\tif (sys_status.onboard_control_sensors_present & MAV_SYS_STATUS_SENSOR_3D_GYRO) {\n\t\t\t\ttarget_set = true;\n\t\t\t\ttarget_sysid = sys_status.onboard_control_sensors_health & 0x7F;\n\t\t\t\ttracker.gcs().request_datastream_position(target_sysid);\n\t\t\t\ttracker.gcs().request_datastream_airpressure(target_sysid);\n\t\t\t\ttracker.gcs().request_datastream_battery(target_sysid);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MAVLINK_MSG_ID_SYSTEM_TIME:\n\t\t\tmavlink_msg_system_time_decode(&msg, &system_time);\n\t\t\tif (system_time.time_unix_usec > 0) {\n\t\t\t\ttarget_set = true;\n\t\t\t\ttarget_", "CodeBleu_score": 38.764483554345276}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (tracker.gcs().target_set()) {\n\t\treturn;\n\t}\n\n\tif (msg.msgid != MAVLINK_MSG_ID_HEARTBEAT) {\n\t\treturn;\n\t}\n\n\tmavlink_heartbeat_t heartbeat;\n\tmavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n\tif (heartbeat.type != MAV_TYPE_GCS) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.base_mode & MAV_MODE_FLAG_CUSTOM_MODE_ENABLED) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.custom_mode != MAV_CUSTOM_MODE_AUTO) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.autopilot != MAV_AUTOPILOT_INVALID) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.system_status != MAV_STATE_ACTIVE) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.type_mask != 0) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.system_status != MAV_STATE_ACTIVE) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.system_status != MAV_STATE_ACTIVE) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.system_status != MAV_STATE_ACTIVE) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.system_status != MAV_STATE_ACTIVE) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.system_status != MAV_STATE_ACTIVE) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.system_status != MAV_STATE_ACTIVE) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.system_status != MAV_STATE_ACTIVE) {\n\t\treturn;\n\t}\n\n\tif (heartbeat.system_status != MAV_STATE_", "CodeBleu_score": 42.761634968098136}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = MAV_RESULT_TEMPORARILY_REJECTED;\n    result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 64.18392623629892}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = MAV_RESULT_FAILED;\n    mavlink_command_long_t cmd;\n    mavlink_msg_command_long_decode(&msg, &cmd);\n    result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_alt_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 60.11986267129259}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 69.48170330049057}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// TODO: Implement this function\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 8.484763582851587}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tmavlink_command_ack_t ack;\n\tack.command = packet.command;\n\tack.result = MAV_RESULT_UNSUPPORTED;\n\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\tack.result = MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0) {\n\t\ttracker.disarm_servos();\n\t\tack.result = MAV_RESULT_ACCEPTED;\n\t}\n\tmavlink_msg_command_ack_send(mavlink_fd, &ack);\n\treturn ack.result;\n}", "CodeBleu_score": 50.04820911301149}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    if (packet.param1 == 1.0) {\n        tracker.arm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    }\n    else if (packet.param1 == 0.0) {\n        tracker.disarm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    }\n    return result;\n}", "CodeBleu_score": 61.2474770415693}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (int i = 0; i < num_gcs; i++) {\n\t\tif (gcs_fd[i] < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (HAVE_PAYLOAD_SPACE(gcs_fd[i])) {\n\t\t\tmavlink_msg_request_data_stream_send(gcs_fd[i], sysid, compid, MAV_DATA_STREAM_POSITION, 10);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.66243275959644}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\n\t// Iterate over all available GCS channels and check for available payload space\n\tfor (uint8_t i = 0; i < GCS_MAX_CHANNELS; i++) {\n\n\t\t// If the channel is connected and has available payload space, send a request to start the data stream\n\t\tif (gcs[i].connected && HAVE_PAYLOAD_SPACE(gcs[i])) {\n\t\t\tmavlink_msg_request_data_stream_send(gcs[i].mavlink_fd, sysid, compid, MAV_DATA_STREAM_POSITION, 10);\n\t\t}\n\t}\n}", "CodeBleu_score": 42.21434202306653}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over the available GCS channels\n\tfor (uint8_t i = 0; i < _num_gcs; i++) {\n\t\t// Check if the channel is connected\n\t\tif (_gcs[i].get_availability() == GCS_AVAILABILITY_AVAILABLE) {\n\t\t\t// Check if the channel has enough payload space\n\t\t\tif (_gcs[i].get_payload_space() >= MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n\t\t\t\t// Send the request\n\t\t\t\tmavlink_msg_request_data_stream_send(_gcs[i].get_channel(), sysid, compid, MAV_DATA_STREAM_POSITION, 1000);\n\t\t\t\t// Update the payload space\n\t\t\t\t_gcs[i].update_payload_space(MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.427652382287654}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    if (is_zero(ahrs.cos_pitch)) {\n        return false;\n    }\n    ef_pitch = asin(ahrs.sin_pitch * ahrs.cos_roll * sin(yaw) + ahrs.sin_roll * cos(yaw));\n    ef_yaw = atan2(-ahrs.sin_pitch * ahrs.cos_roll * cos(yaw) + ahrs.sin_roll * sin(yaw), ahrs.cos_pitch * cos(yaw));\n    return true;\n}", "CodeBleu_score": 45.78931450968839}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (is_zero(ahrs.cos_pitch)) {\n\t\treturn false;\n\t}\n\tfloat sin_pitch = ahrs.sin_pitch;\n\tfloat cos_pitch = ahrs.cos_pitch;\n\tfloat sin_yaw = ahrs.sin_yaw;\n\tfloat cos_yaw = ahrs.cos_yaw;\n\tfloat sin_roll = ahrs.sin_roll;\n\tfloat cos_roll = ahrs.cos_roll;\n\tef_pitch = atan2f(cos_yaw * sin_pitch + sin_yaw * sin_roll * cos_pitch, cos_yaw * cos_pitch - sin_yaw * sin_roll * sin_pitch);\n\tef_yaw = atan2f(-sin_yaw * cos_roll, cos_yaw * cos_roll);\n\treturn true;\n}", "CodeBleu_score": 37.69666824698652}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    is_zero = false;\n    if (ahrs.cos_pitch == 0) {\n        is_zero = true;\n        return false;\n    }\n    ef_pitch = asin(ahrs.sin_pitch * ahrs.cos_roll * ahrs.cos_yaw + ahrs.cos_pitch * ahrs.sin_roll * ahrs.sin_yaw);\n    ef_yaw = atan2(-ahrs.sin_pitch * ahrs.cos_roll * ahrs.sin_yaw + ahrs.cos_pitch * ahrs.sin_roll * ahrs.cos_yaw, ahrs.cos_pitch * ahrs.cos_roll - ahrs.sin_pitch * ahrs.sin_roll * ahrs.sin_yaw * ahrs.cos_yaw);\n    return true;\n}", "CodeBleu_score": 34.86335949745359}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\n\t// Check if the target distance is valid or if a minimum distance is set\n\tif (!target_distance_valid || (target_distance_valid && target_distance >= min_distance)) {\n\n\t\t// Get the yaw direction\n\t\tget_ef_yaw_direction();\n\n\t\t// Convert the target distance to centimeters\n\t\ttarget_distance_cm = target_distance * 100;\n\n\t\t// Calculate the yaw error\n\t\tyaw_error = calc_angle_error(target_yaw, yaw);\n\n\t\t// Calculate the pitch error\n\t\tpitch_error = calc_angle_error(target_pitch, pitch);\n\n\t\t// Convert the errors from earth frame to body frame\n\t\tconvert_ef_to_bf(yaw_error, pitch_error);\n\n\t\t// Constrain the pitch error\n\t\tpitch_error = constrain_float(pitch_error, -pitch_max, pitch_max);\n\n\t\t// Update the pitch and yaw servos\n\t\ttracker.update_yaw_servo(yaw_error);\n\t\ttracker.update_pitch_servo(pitch_error);\n\t}\n}", "CodeBleu_score": 30.688947086130057}, {"code": "void Mode::update_auto(void){\n\t    // Get the current position of the tracker in the body frame\n    float current_position[2];\n    tracker.get_position(current_position);\n\n    // Get the current yaw of the tracker\n    float current_yaw = tracker.get_yaw();\n\n    // Get the current pitch of the tracker\n    float current_pitch = tracker.get_pitch();\n\n    // Get the current distance to the target\n    float current_distance = navigation.get_distance();\n\n    // Get the current target yaw\n    float target_yaw = navigation.get_target_yaw();\n\n    // Get the current target pitch\n    float target_pitch = navigation.get_target_pitch();\n\n    // Get the current target distance\n    float target_distance = navigation.get_target_distance();\n\n    // Get the current target direction\n    bool target_direction = navigation.get_target_direction();\n\n    // Get the current minimum distance\n    float min_distance = navigation.get_min_distance();\n\n    // Get the current maximum distance\n    float max_distance = navigation.get_max_distance();\n\n    // Get the current minimum yaw\n    float min_yaw = navigation.get_min_yaw();\n\n    // Get the current maximum yaw\n    float max_yaw = navigation.get_max_yaw();\n\n    // Get the current minimum pitch\n    float min_pitch = navigation.get_min_pitch();\n\n    // Get the current maximum pitch\n    float max_pitch = navigation.get_max_pitch();\n\n    // Get the current yaw offset\n    float yaw_offset = navigation.get_yaw_offset();\n\n    // Get the current pitch offset\n    float pitch_offset = navigation.get_pitch_offset();\n\n    // Get the current yaw offset\n    float distance_offset = navigation.get_distance_offset();\n\n    // Get the current yaw offset\n    float yaw_offset_direction = navigation.get_yaw_offset_direction();\n\n    // Get the current pitch offset\n    float pitch_offset_direction = navigation.get_pitch_offset_direction();\n\n   ", "CodeBleu_score": 26.732580863520884}, {"code": "void Mode::update_auto(void){\n\t\t// Get the yaw and pitch in centidegrees\n\tfloat target_yaw = (float)nav.get_target_yaw();\n\tfloat target_pitch = (float)nav.get_target_pitch();\n\n\t// Check if the yaw direction is reversed\n\tbool yaw_reversed = nav.get_yaw_reversed();\n\n\t// Check if the distance is valid\n\tbool distance_valid = nav.get_distance_valid();\n\n\t// Check if the minimum distance is set\n\tbool min_dist_set = nav.get_min_dist_set();\n\n\t// Get the distance to the target\n\tfloat target_dist = nav.get_target_dist();\n\n\t// Get the minimum distance\n\tfloat min_dist = nav.get_min_dist();\n\n\t// Get the minimum distance error\n\tfloat min_dist_err = nav.get_min_dist_err();\n\n\t// Get the minimum distance yaw error\n\tfloat min_dist_yaw_err = nav.get_min_dist_yaw_err();\n\n\t// Get the minimum distance pitch error\n\tfloat min_dist_pitch_err = nav.get_min_dist_pitch_err();\n\n\t// Get the minimum distance yaw reversed\n\tbool min_dist_yaw_reversed = nav.get_min_dist_yaw_reversed();\n\n\t// Get the minimum distance pitch reversed\n\tbool min_dist_pitch_reversed = nav.get_min_dist_pitch_reversed();\n\n\t// Get the maximum distance\n\tfloat max_dist = nav.get_max_dist();\n\n\t// Get the maximum distance error\n\tfloat max_dist_err = nav.get_max_dist_err();\n\n\t// Get the maximum distance yaw error\n\tfloat max_dist_yaw_err = nav.get_max_dist_yaw_err();\n\n\t// Get the maximum distance pitch error\n\tfloat max_dist_pitch_err = nav.get_max_dist_pitch_err();\n\n\t// Get the maximum distance yaw reversed\n\tbool max_dist_y", "CodeBleu_score": 17.103710131090935}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t  // Check if the GPS is connected\n  if (!gps.available()) {\n    return;\n  }\n\n  // Check if the GPS has a fix\n  if (gps.status < 3) {\n    return;\n  }\n\n  // Update the GPS\n  gps.update();\n\n  // Check if the GPS last message time has changed\n  if (gps.last_message_time_ms != last_GPS_message_time_ms) {\n    last_GPS_message_time_ms = gps.last_message_time_ms;\n\n    // Check if the GPS has a valid location\n    if (gps.location.isValid()) {\n      // Set the home location\n      if (countdown_to_ground_start == 0) {\n        set_home();\n      }\n      // Reset the countdown\n      else {\n        countdown_to_ground_start = 10;\n      }\n    }\n    // Reset the countdown\n    else {\n      countdown_to_ground_start--;\n    }\n  }\n}", "CodeBleu_score": 39.059404757322284}, {"code": "void Tracker::update_GPS(void){\n\t    if (gps.location.isUpdated()) {\n        gps.update();\n        gps.status();\n        if (gps.status() >= 3) {\n            gps.location.isUpdated();\n            gps.last_message_time_ms = millis();\n            if (gps.location.isValid()) {\n                if (gps_init_countdown > 0) {\n                    gps_init_countdown--;\n                    if (gps_init_countdown == 0) {\n                        set_home();\n                    }\n                }\n            } else {\n                gps_init_countdown = GPS_INIT_COUNTDOWN;\n            }\n        }\n    }\n}", "CodeBleu_score": 37.63661392532954}, {"code": "void Tracker::update_GPS(void){\n\t  gps.update();\n  if (gps.location.isUpdated() && (gps.status >= 3)) {\n    if (gps.location.isValid()) {\n      if (ground_start_countdown > 0) {\n        ground_start_countdown--;\n        if (ground_start_countdown == 0) {\n          set_home();\n        }\n      }\n    } else {\n      ground_start_countdown = GROUND_START_COUNTDOWN_MAX;\n    }\n  }\n}", "CodeBleu_score": 29.26154440789887}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // if (pitch < 0.0f) {\n    //     pitch = 0.0f;\n    // }\n    // if (pitch > 1.0f) {\n    //     pitch = 1.0f;\n    // }\n    // float servo_pitch = 0.0f;\n    // servo_pitch = (pitch * 180.0f) + 90.0f;\n    // // if (servo_pitch > 180.0f) {\n    // //     servo_pitch -= 180.0f;\n    // // }\n    // // if (servo_pitch < 0.0f) {\n    // //     servo_pitch += 180.0f;\n    // // }\n    // // if (servo_pitch > 180.0f) {\n    // //     servo_pitch -= 180.0f;\n    // // }\n    // // if (servo_pitch < 0.0f) {\n    // //     servo_pitch += 180.0f;\n    // // }\n    // if (servo_pitch > 180.0f) {\n    //     servo_pitch -= 180.0f;\n    // }\n    // if (servo_pitch < 0.0f) {\n    //     servo_pitch += 180.0f;\n    // }\n    // // if (servo_pitch > 180.0f) {\n    // //     servo_pitch -= 180.0f;\n    // // }\n    // // if (servo_pitch < 0.0f) {\n    // //     servo_pitch += 180.0f;\n    // // }\n    // if (servo_pitch > 180.0f) {\n    //     servo_pitch -= 180.0f;\n    // }\n    // if (servo_pitch < 0.0f) {", "CodeBleu_score": 4.619416583455748}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0f) {\n\t\t// pitch up\n\t\tif (pitch_onoff_servo_angle < 180.0f) {\n\t\t\tpitch_onoff_servo_angle += 0.5f;\n\t\t}\n\t} else {\n\t\t// pitch down\n\t\tif (pitch_onoff_servo_angle > 0.0f) {\n\t\t\tpitch_onoff_servo_angle -= 0.5f;\n\t\t}\n\t}\n\tif (pitch_onoff_servo_angle < 0.0f) {\n\t\tpitch_onoff_servo_angle = 0.0f;\n\t}\n\tif (pitch_onoff_servo_angle > 180.0f) {\n\t\tpitch_onoff_servo_angle = 180.0f;\n\t}\n\tif (pitch_onoff_servo_angle > 90.0f) {\n\t\tpitch_onoff_servo_angle = 90.0f;\n\t}\n\tif (pitch_onoff_servo_angle < 10.0f) {\n\t\tpitch_onoff_servo_angle = 10.0f;\n\t}\n\tpitch_onoff_servo.write(pitch_onoff_servo_angle);\n}", "CodeBleu_score": 19.36298006596567}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch > 1.0f) {\n        pitch = 1.0f;\n    } else if (pitch < -1.0f) {\n        pitch = -1.0f;\n    }\n    float pitch_scaled = pitch * 0.5f + 0.5f;\n    //printf(\"%f", "CodeBleu_score": 11.442740956548754}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    bool result = AP_Arming::barometer_checks(display_failure);\n    if (result && (AP_ARMING_CHECK_BARO & _armed.armed)) {\n        if (fabsf(copter.inertial_nav.get_position_z_up_cm() - copter.barometer.get_altitude()) > _baro_check_limit_cm) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Barometer check failed: altitude %u cm\n\"), (uint16_t)copter.inertial_nav.get_position_z_up_cm());\n            }\n            result = false;\n        }\n    }\n    return result;\n}", "CodeBleu_score": 42.1010797627355}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n    if (AP_ARMING_CHECK_BARO.get() == false) {\n        return true;\n    }\n    if (barometer_check_enabled() == false) {\n        return true;\n    }\n    if (fabsf(copter.inertial_nav.get_position_z_up_cm() - barometer.get_altitude()) > ARMING_BARO_ALT_ERROR_CM.get()) {\n        if (display_failure) {\n            hal.console->printf(\"Barometer altitude error: %d cm\n\", (int)fabsf(copter.inertial_nav.get_position_z_up_cm() - barometer.get_altitude()));\n        }\n        check_failed();\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 48.690639134923984}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (AP_Arming::get_arming_check_option(ARMING_CHECK_BARO)) {\n        // check barometer reference\n        if (g.baro_ref == 0.0f) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Barometer reference not set\n\"));\n            }\n            return false;\n        }\n\n        // check barometer altitude\n        float baro_alt = barometer.get_altitude();\n        if (isnan(baro_alt)) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Barometer altitude not available\n\"));\n            }\n            return false;\n        }\n\n        // check barometer altitude against inertial nav altitude\n        float inertial_alt = copter.inertial_nav.get_altitude();\n        if (isnan(inertial_alt)) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Inertial nav altitude not available\n\"));\n            }\n            return false;\n        }\n\n        // check barometer altitude against inertial nav altitude\n        float alt_disparity = fabsf(baro_alt - inertial_alt);\n        if (alt_disparity > 10.0f) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Barometer altitude %dm differs from inertial nav altitude %dm\n\"),\n                                      (int)(baro_alt * 100), (int)(inertial_alt * 100));\n            }\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 50.65519483189767}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (g.get_terrain_source() == AP_TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 31.501861384962403}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_terrain_source == AP_TERRAIN_FLIGHT_SENSOR) {\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 27.423526463785436}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_ahrs->get_terrain_source() == AP_AHRS_NAV_TERRAIN_RANGEFINDER) {\n\t\treturn false;\n\t}\n\tif (_wp_nav->get_alt_type() == AP_WPNav::ALT_TYPE_TERRAIN && _rtl_alt_type == AP_R", "CodeBleu_score": 20.237533233695533}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    attitude_control->set_dt(AP::scheduler().get_loop_update_us() / 1000000.0f);\n    attitude_control->rate_controller_run();\n\n    pos_control->set_dt(AP::scheduler().get_loop_update_us() / 1000000.0f);\n    pos_control->run_pos_controller();\n\n    motors->set_dt(AP::scheduler().get_loop_update_us() / 1000000.0f);\n    motors->run();\n}", "CodeBleu_score": 43.2219070038531}, {"code": "void Copter::run_rate_controller(){\n\t    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    pos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 49.38845746367313}, {"code": "void Copter::run_rate_controller(){\n\t    attitude_control->rate_controller_run();\n\n    // update the dt for position and motors\n    pos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n    // update the dt for attitude\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n}", "CodeBleu_score": 48.96740681669118}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.same_loc_as(&new_loc)) {\n\t\treturn false;\n\t}\n\n\t_target_location = new_loc;\n\n\treturn true;\n}", "CodeBleu_score": 51.56555876008253}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\tif (!old_loc.same_loc_as(&new_loc)) {\n\t\treturn false;\n\t}\n\n\ttarget_loc = new_loc;\n\treturn true;\n}", "CodeBleu_score": 51.059327358983474}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (!old_loc.same_loc_as(&new_loc)) {\n        return false;\n    }\n\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    target_loc = new_loc;\n    return true;\n}", "CodeBleu_score": 55.86182221125517}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t  if (ch_flag == AuxSwitchPos::HIGH) {\n    copter.set_mode(mode);\n  } else if (copter.flightmode->mode_number == mode) {\n    rc().reset_mode_switch();\n  }\n}", "CodeBleu_score": 57.26963928090131}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t  if (ch_flag == AuxSwitchPos::HIGH) {\n    copter.set_mode(mode);\n  } else if (copter.flightmode->mode_number == mode) {\n    rc().reset_mode_switch();\n  }\n}", "CodeBleu_score": 57.26963928090131}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        copter.set_mode(mode);\n    } else if (copter.flightmode->mode_number == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 59.12625888782931}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// calculate the trim values from the control inputs of the roll and pitch channels\n\tfloat trim_roll = channel_roll->get_control_in();\n\tfloat trim_pitch = channel_pitch->get_control_in();\n\n\t// convert the trim values to radians\n\ttrim_roll = ToRad(trim_roll);\n\ttrim_pitch = ToRad(trim_pitch);\n\n\t// add the trim values to the AHRS trim\n\tahrs.add_trim(trim_roll, trim_pitch);\n\n\t// log the event\n\tLOGGER_WRITE_EVENT(LOG_COPTER_TRIM, Log_Copter_Trim(trim_roll, trim_pitch));\n\n\t// send a confirmation message with MAV_SEVERITY_INFO\n\tgcs().send_text_fmt(MAV_SEVERITY_INFO, \"Trim saved: roll: %.1f pitch: %.1f\", trim_roll, trim_pitch);\n}", "CodeBleu_score": 49.85845281755596}, {"code": "void Copter::save_trim(){\n\t    // calculate the trim values\n    float roll_trim = channel_roll->get_control_in();\n    float pitch_trim = channel_pitch->get_control_in();\n\n    // convert to radians\n    roll_trim = ToRad(roll_trim);\n    pitch_trim = ToRad(pitch_trim);\n\n    // add to the AHRS trim\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log the event\n    LOGGER_WRITE_EVENT(MAV_SEVERITY_INFO, \"Trim saved\");\n\n    // send a confirmation message\n    gcs().send_text_fmt(MAV_SEVERITY_INFO, \"Trim saved: %5.2f %5.2f\", (double)roll_trim, (double)pitch_trim);\n}", "CodeBleu_score": 60.72254386775838}, {"code": "void Copter::save_trim(){\n\t\t/*\n\t * Get the trim values from the roll and pitch channels.\n\t */\n\tfloat trim_roll = channel_roll->get_control_in();\n\tfloat trim_pitch = channel_pitch->get_control_in();\n\n\t/*\n\t * Convert the trim values to radians and add them to the AHRS trim.\n\t */\n\tahrs.add_trim(ToRad(trim_roll), ToRad(trim_pitch));\n\n\t/*\n\t * Log the event.\n\t */\n\tLOGGER_WRITE_EVENT(log_channel_roll_trim, trim_roll);\n\tLOGGER_WRITE_EVENT(log_channel_pitch_trim, trim_pitch);\n\n\t/*\n\t * Send a confirmation message with MAV_SEVERITY_INFO.\n\t */\n\tmavlink_log_info(mavlink_fd, \"[fc] Trim saved\");\n}", "CodeBleu_score": 48.646299222157495}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t  // TODO: Implement this function\n  // TODO: Add a comment describing this function\n  // TODO: Add a comment describing the return value\n  // TODO: Add a comment describing the parameters\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n  // TODO: Add a comment describing the local variables\n ", "CodeBleu_score": 2.4288717325059617}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t  // TODO: Implement look_ahead_yaw function\n  float velocity_squared = vel.xy().length_squared();\n  if (velocity_squared > 0.000001f && copter.position_ok) {\n    float look_ahead_yaw = atan2f(vel.x, vel.y);\n    copter.attitude_angle.yaw = degrees(look_ahead_yaw);\n  }\n  return copter.attitude_angle.yaw;\n}", "CodeBleu_score": 45.279604684817244}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::look_ahead_yaw\n    // TODO: Implement Mode::AutoYaw::", "CodeBleu_score": 2.3412590477820694}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::RUDDER) {\n        if (plane.get_rudder_arming_type() == AP_Rudder::DISABLED) {\n            gcs().send_text_fmt(PSTR(\"Rudder arming disabled\"));\n            return false;\n        }\n        if (plane.get_throttle_input() != 0) {\n            gcs().send_text_fmt(PSTR(\"Throttle not zero\"));\n            return false;\n        }\n    }\n    if (hal.util->was_watchdog_armed()) {\n        gcs().send_text_fmt(PSTR(\"Watchdog armed\"));\n        return false;\n    }\n    if (AP_Arming::arm_checks(method)) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 62.43131988298947}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // bypass checks if arming checks are disabled\n    if (!_arming_checks_enabled) {\n        return true;\n    }\n\n    // bypass checks if watchdog was armed\n    if (hal.util->was_watchdog_armed()) {\n        gcs().send_text_fmt(MAV_SEVERITY_WARNING, \"arming: watchdog armed\");\n        return true;\n    }\n\n    // bypass checks if rudder arming is disabled\n    if (!plane.get_rudder_arming_type()) {\n        gcs().send_text_fmt(MAV_SEVERITY_WARNING, \"arming: rudder arming disabled\");\n        return true;\n    }\n\n    // bypass checks if throttle is not zero\n    if (plane.get_throttle_input() != 0) {\n        gcs().send_text_fmt(MAV_SEVERITY_WARNING, \"arming: throttle not zero\");\n        return true;\n    }\n\n    // call parent method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 57.93226256467723}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::RUDDER) {\n        if (plane.get_rudder_arming_type() == AP_Rudder::DISABLED) {\n            gcs().send_text_fmt(PSTR(\"Rudder arming disabled\"));\n            return false;\n        }\n        if (plane.get_throttle_input() != 0) {\n            gcs().send_text_fmt(PSTR(\"Throttle not zero\"));\n            return false;\n        }\n    }\n    if (hal.util->was_watchdog_armed()) {\n        gcs().send_text_fmt(PSTR(\"Watchdog armed\"));\n        return false;\n    }\n    if (!AP_Arming::arm_checks(method)) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 62.00115014967238}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // check if we are already armed\n    if (armed()) {\n        return true;\n    }\n\n    // check if we are already disarmed\n    if (!in_air()) {\n        return false;\n    }\n\n    // check if we are already in a transition\n    if (transition_state.in_transition()) {\n        return false;\n    }\n\n    // check if we are already in a failsafe state\n    if (failsafe.in_failsafe()) {\n        return false;\n    }\n\n    // check if we are in a critical state\n    if (critical_state.in_critical()) {\n        return false;\n    }\n\n    // check if we are in a manual state\n    if (manual_state.in_manual()) {\n        return false;\n    }\n\n    // check if we are in a rtl state\n    if (rtl_state.in_rtl()) {\n        return false;\n    }\n\n    // check if we are in a loiter state\n    if (loiter_state.in_loiter()) {\n        return false;\n    }\n\n    // check if we are in a landing state\n    if (landing_state.in_landing()) {\n        return false;\n    }\n\n    // check if we are in a takeoff state\n    if (takeoff_state.in_takeoff()) {\n        return false;\n    }\n\n    // check if we are in a return state\n    if (return_state.in_return()) {\n        return false;\n    }\n\n    // check if we are in a climb state\n    if (climb_state.in_climb()) {\n        return false;\n    }\n\n    // check if we are in a descent state\n    if (descent_state.in_descent()) {\n        return false;\n    }\n\n    // check if we are in a circle state\n    if (circle_state.in_circle()) {\n        return false;\n    }\n\n    // check if we are in a position hold state\n    if (position_hold_state.in_position_hold()) {\n        return false;\n    }", "CodeBleu_score": 23.216487764947207}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (method == AP_ARMING_METHOD_ARM_THROTTLE) {\n        if (!_throttle_armed) {\n            // throttle is not armed, so arm it\n            _throttle_armed = true;\n            _throttle_armed_time = hal.scheduler->millis();\n            _throttle_armed_delay = 0;\n            _throttle_armed_delay_time = 0;\n            _throttle_armed_delay_timer = 0;\n            _throttle_armed_delay_timer_time = 0;\n            _throttle_armed_delay_timer_time_start = 0;\n            _throttle_armed_delay_timer_time_end = 0;\n            _throttle_armed_delay_timer_time_end_start = 0;\n            _throttle_armed_delay_timer_time_end_end = 0;\n            _throttle_armed_delay_timer_time_end_end_start = 0;\n            _throttle_armed_delay_timer_time_end_end_end = 0;\n            _throttle_armed_delay_timer_time_end_end_end_start = 0;\n            _throttle_armed_delay_timer_time_end_end_end_end = 0;\n            _throttle_armed_delay_timer_time_end_end_end_end_start = 0;\n            _throttle_armed_delay_timer_time_end_end_end_end_end = 0;\n            _throttle_armed_delay_timer_time_end_end_end_end_end_start = 0;\n            _throttle_armed_delay_timer_time_end_end_end_end_end_end = 0;\n            _throttle_armed_delay_timer_time_end_end_end_end_end_end_start = 0;\n            _throttle_armed_delay_timer_time_end", "CodeBleu_score": 28.970949144052817}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!_vehicle->autopilot->is_armed()) {\n        // we are not armed, so we can arm\n        _arming_method = method;\n        _arming_state = ArmingState::ARMED;\n        _arming_checks_passed = false;\n        _delay_arming = false;\n        _delay_arming_timer = 0;\n        _delay_arming_start_time = 0;\n        _delay_arming_duration = 0;\n\n        // update home location and set it in the AHRS system\n        _vehicle->home->update();\n        _vehicle->home->set_home();\n\n        // update current location\n        _vehicle->location->update();\n\n        // change arm state\n        _vehicle->autopilot->set_armed(true);\n\n        // set a delay arming flag\n        if (method == AP_ARMING_METHOD_DELAYED_ARMING) {\n            _delay_arming = true;\n            _delay_arming_start_time = millis();\n            _delay_arming_duration = AP_ARMING_DELAYED_ARMING_DURATION;\n        }\n\n        // send a status text indicating that the throttle is armed\n        send_arm_disarm_statustext(true);\n\n        // arming was successful\n        return true;\n    }\n\n    // arming failed\n    return false;\n}", "CodeBleu_score": 42.00425019964386}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (AP_Arming::armed) {\n        return true;\n    }\n\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            hal.console->printf(\"No disarm function configured\n\");\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.33647302780439}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\n\t// if already armed, return true\n\tif (armed) {\n\t\treturn true;\n\t}\n\n\t// check for disarm function\n\tif (!has_disarm_function()) {\n\n\t\t// display failure message if requested\n\t\tif (display_failure) {\n\t\t\tprint_message(MAV_SEVERITY_WARNING, \"No disarm function configured\");\n\t\t}\n\n\t\t// return false\n\t\treturn false;\n\t}\n\n\t// run standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 74.99375872367642}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (armed()) {\n        return true;\n    }\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Disarm button not configured\n\"));\n        }\n        return false;\n    }\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.56435082014558}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cos(ahrs.yaw) - y * sin(ahrs.yaw);\n    float ne_y = x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 62.41280822119546}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t  float ne_x = x * cos(ahrs.yaw) - y * sin(ahrs.yaw);\n  float ne_y = x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n  x = ne_x;\n  y = ne_y;\n}", "CodeBleu_score": 61.49389420087861}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cos_yaw - y * sin_yaw;\n    float ne_y = x * sin_yaw + y * cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 58.64211462234863}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// check if the command is for this system\n\tif (packet.target_system != _mavlink->get_system_id()) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// check if the command is for this component\n\tif (packet.target_component != _mavlink->get_autopilot_id()) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// check if the command is valid\n\tif (packet.param1 < 0 || packet.param1 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param2 < 0 || packet.param2 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param3 < 0 || packet.param3 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param4 < 0 || packet.param4 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if the command is accepted\n\tif (packet.param1 == 0 && packet.param2 == 0 && packet.param3 == 0 && packet.param4 == 0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// set the yaw heading using the provided parameters\n\t_mavlink->set_auto_yaw_look_at_heading(packet.param1, packet.param2, packet.param3, packet.param4);\n\n\t// return accepted\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 45.95315113074302}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_DENIED;\n    uint8_t target_component = packet.target_component;\n    uint8_t target_system = packet.target_system;\n    uint8_t target_component_id = packet.target_component;\n    uint8_t target_system_id = packet.target_system;\n    uint8_t command_id = packet.command;\n    uint8_t confirmation = packet.confirmation;\n    int32_t param1 = packet.param1;\n    int32_t param2 = packet.param2;\n    int32_t param3 = packet.param3;\n    int32_t param4 = packet.param4;\n    int32_t param5 = packet.param5;\n    int32_t param6 = packet.param6;\n    int32_t param7 = packet.param7;\n\n    if (target_component_id == 0 && target_system_id == 0) {\n        // If no component or system is specified, use the component and system of the current MAV.\n        target_component_id = mavlink_system.this_component_id;\n        target_system_id = mavlink_system.this_system_id;\n    }\n\n    if (command_id == MAV_CMD_CONDITION_YAW) {\n        // Check if the yaw angle and param4 values are within acceptable ranges.\n        if (param1 >= 0 && param1 <= 360 && param4 >= -1 && param4 <= 1) {\n            // Set the yaw heading using the provided parameters.\n            if (param1 == 0 && param4 == 0) {\n                // If param1 is 0, set the yaw heading to the current heading.\n                param1 = mavlink_system.yaw_heading;\n            }\n            else if (param1 == 0 && param4 == 1) {\n                // If param1 is 0 and param4 is 1, set the yaw heading to the current heading + 90 degrees.\n                param1 = mavlink_system.y", "CodeBleu_score": 40.14369063377333}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // Check if the yaw angle and param4 values are within acceptable ranges.\n    if (packet.param1 < 0.0f || packet.param1 > 360.0f) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param2 < 0.0f || packet.param2 > 360.0f) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param3 < 0.0f || packet.param3 > 360.0f) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param4 < 0.0f || packet.param4 > 360.0f) {\n        return MAV_RESULT_DENIED;\n    }\n    // Set the yaw heading using the provided parameters.\n    // This will be used by the yaw controller to control the yaw angle.\n    // The yaw controller will use the yaw heading to determine if the vehicle needs to rotate.\n    // The yaw controller will use the yaw angle to determine the direction of rotation.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not used by the yaw controller.\n    // The yaw angle is not", "CodeBleu_score": 52.66776432823194}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    uint8_t result = 0;\n    if (control_mode == Control_Mode::AUTO || control_mode == Control_Mode::GUIDED) {\n        result = wrap_360_cd(wp_nav.get_wp_bearing_to_destination() / 2);\n    }\n    return result;\n}", "CodeBleu_score": 52.690202829962395}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    return (uint8_t) _mission_type.wp_nav.get_wp_bearing_to_destination() / 2;\n}", "CodeBleu_score": 15.593428288946502}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n        return (wp_nav.get_wp_bearing_to_destination() / 2);\n    } else {\n        return 0;\n    }\n}", "CodeBleu_score": 45.56001071772852}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\t// create log packet\n\t\tPacketHeader header = {\n\t\t\t.time_us = AP_HAL::micros64(),\n\t\t\t.size = sizeof(LogData),\n\t\t\t.id = static_cast<uint16_t>(id),\n\t\t\t.data_page = 0,\n\t\t\t.data_offset = 0,\n\t\t\t.reserved = 0\n\t\t};\n\t\tLogData data = {\n\t\t\t.value = value\n\t\t};\n\n\t\t// write packet\n\t\tlogger.WriteCriticalBlock(reinterpret_cast<const uint8_t*>(&header), sizeof(PacketHeader));\n\t\tlogger.WriteCriticalBlock(reinterpret_cast<const uint8_t*>(&data), sizeof(LogData));\n\t}\n}", "CodeBleu_score": 40.840656457422206}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t  if (should_log) {\n    Log_Packet packet;\n    packet.header = LOG_PACKET_HEADER_INIT;\n    packet.header.id = id;\n    packet.header.size = sizeof(value);\n    packet.value = value;\n    logger.WriteCriticalBlock(packet);\n  }\n}", "CodeBleu_score": 42.72749250748014}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t  if (should_log) {\n    Log_Packet packet;\n    packet.header.id = id;\n    packet.header.length = sizeof(packet.data.int32);\n    packet.data.int32 = value;\n    logger.WriteCriticalBlock(packet.header, &packet.data.int32, sizeof(packet.data.int32));\n  }\n}", "CodeBleu_score": 38.77093758021844}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n        return;\n    }\n\n    set_home_to_current_location();\n}", "CodeBleu_score": 46.83272239174963}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n        return;\n    }\n\n    if (ekf.home_is_set()) {\n        set_home_to_current_location();\n    }\n}", "CodeBleu_score": 49.90870662795075}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set()) {\n\t\treturn;\n\t}\n\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\n\t} else {\n\t\tset_home_to_current_location();\n\t}\n}", "CodeBleu_score": 46.847088140026}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\t// If not armed, set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit.\n\tif (!motors.armed()) {\n\t\tmotors.set_throttle(0);\n\t\tmotors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\t// Convert pilot inputs to desired body frame rates.\n\tVector3f pilot_desired_angle_rates = get_pilot_desired_angle_rates();\n\n\t// Set the attitude controller's input rates.\n\tattitude_control->input_rate_bf_roll_pitch_yaw(pilot_desired_angle_rates);\n\n\t// Set the forward and lateral motor inputs based on pilot controls.\n\tmotors.set_lateral(channel_lateral->get_control_in());\n\tmotors.set_forward(channel_forward->get_control_in());\n\n\t// Set the throttle output.\n\tmotors.set_throttle(channel_throttle->norm_input());\n\n\t// Set the yaw motor input based on pilot controls.\n\tmotors.set_yaw(channel_yaw->get_control_in());\n}", "CodeBleu_score": 38.067426359015755}, {"code": "void ModeAcro::run(){\n\t\tif (motors.armed()) {\n\t\tmotors.set_desired_spool_state(Motors::SPOOL_STATE_UNLIMITED_THROTTLE);\n\t\tfloat roll_rate = pilot_desired_angle_rates.roll;\n\t\tfloat pitch_rate = pilot_desired_angle_rates.pitch;\n\t\tfloat yaw_rate = pilot_desired_angle_rates.yaw;\n\t\tfloat throttle = channel_throttle->norm_input();\n\t\tfloat lateral = channel_lateral->norm_input();\n\t\tfloat forward = channel_forward->norm_input();\n\t\tfloat yaw = channel_yaw->norm_input();\n\t\tfloat roll = roll_rate * lateral + yaw_rate * forward;\n\t\tfloat pitch = pitch_rate * lateral - yaw_rate * forward;\n\t\tattitude_control->set_throttle_out(throttle);\n\t\tattitude_control->input_rate_bf_roll_pitch_yaw(roll, pitch, yaw);\n\t\tmotors.set_forward(forward);\n\t\tmotors.set_lateral(lateral);\n\t} else {\n\t\tmotors.set_throttle(0);\n\t\tmotors.set_desired_spool_state(Motors::SPOOL_STATE_RELAXED);\n\t\tattitude_control->relax_attitude_controllers();\n\t}\n}", "CodeBleu_score": 48.03146091668631}, {"code": "void ModeAcro::run(){\n\t    if (!motors.armed()) {\n        motors.set_throttle(0);\n        motors.set_desired_spool_state(Motors::SpoolState::UnlimitedThrottle);\n        attitude_control.relax_attitude_controllers();\n        return;\n    }\n\n    // if we are in acro mode, we should be armed\n    // we should also be in manual mode\n    // we should not be in stabilize mode\n    // we should not be in altitude mode\n    // we should not be in position mode\n    // we should not be in loiter mode\n    // we should not be in return mode\n    // we should not be in hold mode\n    // we should not be in mission mode\n    // we should not be in rtl mode\n    // we should not be in land mode\n    // we should not be in takeoff mode\n    // we should not be in follow mode\n    // we should not be in offboard mode\n    // we should not be in stabilize_yaw mode\n    // we should not be in stabilize_roll_pitch mode\n    // we should not be in stabilize_roll_pitch_yaw mode\n    // we should not be in stabilize_mag mode\n    // we should not be in stabilize_mag_heading mode\n    // we should not be in stabilize_extended mode\n    // we should not be in stabilize_fw_pos_control mode\n    // we should not be in stabilize_fw_vel_control mode\n    // we should not be in stabilize_fw_pos_vel_control mode\n    // we should not be in stabilize_fw_l1_control mode\n    // we should not be in stabilize_fw_l1_control_destroyer mode\n    // we should not be in stabilize_fw_l1_control_soft_limits mode\n    // we should not be in stabilize_fw_l1_control_soft_limits_destroyer mode\n    // we should not be in stabilize_fw_l1_control_soft_limits_destroyer_vel mode\n    // we should not be in stabilize_fw_l1_control_soft_limits", "CodeBleu_score": 24.212473930870757}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // TODO: Implement ModeGuided::guided_pos_control_start\n    // This function, ModeGuided::guided_pos_control_start, initializes guided position control mode by setting it to position control mode and initializing the waypoint controller.", "CodeBleu_score": 4.020293814744197}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// TODO: This is a stub, implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function!\n\t// TODO: Implement this function", "CodeBleu_score": 2.668833911630609}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t_mode_auto = false;\n\t_mode_guided = true;\n\t_mode_auto_ttc = false;\n\t_mode_auto_loiter = false;\n\t_mode_auto_rtl = false;\n\t_mode_auto_rc = false;\n\t_mode_auto_read = false;\n\t_mode_auto_mission = false;\n\t_mode_auto_rtgs = false;\n\t_mode_auto_rcl = false;\n\t_mode_auto_fence = false;\n\t_mode_auto_takeoff = false;\n\t_mode_auto_land = false;\n\t_mode_auto_land_stay = false;\n\t_mode_auto_land_start = false;\n\t_mode_auto_land_at_cur_pos = false;\n\t_mode_auto_land_at_cur_heading = false;\n\t_mode_auto_land_at_cur_alt = false;\n\t_mode_auto_rtl_at_cur_alt = false;\n\t_mode_auto_rtl_at_cur_pos = false;\n\t_mode_auto_rtl_at_cur_heading = false;\n\t_mode_auto_land_at_cur_alt_only = false;\n\t_mode_auto_takeoff_at_cur_pos = false;\n\t_mode_auto_takeoff_at_cur_alt = false;\n\t_mode_auto_takeoff_at_cur_pos_only = false;\n\t_mode_auto_takeoff_at_cur_alt_only = false;\n\t_mode_auto_loiter_at_cur_pos = false;\n\t_mode_auto_loiter_at_cur_alt = false;\n\t_mode_auto_loiter_at_cur_alt_only = false;\n\t_mode_auto_loiter_at_cur_pos_only = false;\n\t_mode_auto_rtgs_at_cur_pos = false;\n\t_mode_auto_rtgs_at_cur_alt = false;\n\t_mode_auto_rtgs_at_cur_pos_only = false;\n\t_mode_", "CodeBleu_score": 4.494121519336273}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set max vertical speed and acceleration\n\tposition_control->set_max_speed_accel_z(\n\t\t\t_velocity_control_mode.z_vel_max,\n\t\t\t_velocity_control_mode.z_accel_max);\n\n\t// set max horizontal speed and acceleration\n\tposition_control->set_max_speed_accel_xy(\n\t\t\t_velocity_control_mode.xy_vel_max,\n\t\t\t_velocity_control_mode.xy_vel_cruise,\n\t\t\t_velocity_control_mode.xy_accel_max,\n\t\t\t_velocity_control_mode.xy_decel_max);\n\n\t// initialize vertical velocity controller\n\tposition_control->init_z_controller();\n\n\t// initialize horizontal velocity controller\n\tposition_control->init_xy_controller();\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\tset_auto_yaw_mode();\n}", "CodeBleu_score": 44.070706005856366}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialize vertical maximum speeds and acceleration\n\tposition_control->set_max_speed_accel_z(param_mpc_z_vel.get(), param_mpc_z_accel.get());\n\n\t// initialize vertical velocity controller\n\tposition_control->init_z_controller();\n\n\t// initialize horizontal velocity controller\n\tposition_control->init_xy_controller();\n\n\t// set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tset_auto_yaw_mode();\n}", "CodeBleu_score": 30.083775392530278}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // TODO: set_velocity_control_enabled(true);\n    // TODO: set_position_control_enabled(false);\n    // TODO: set_altitude_control_enabled(false);\n    // TODO: set_attitude_control_enabled(false);\n    // TODO: set_velocity_control_enabled(false);\n    // TODO: set_acceleration_control_enabled(false);\n    // TODO: set_altitude_control_enabled(false);\n    // TODO: set_attitude_control_enabled(false);\n    // TODO: set_altitude_control_enabled(false);\n    // TODO: set_attitude_control_enabled(false);\n    // TODO: set_velocity_control_enabled(false);\n    // TODO: set_acceleration_control_enabled(false);\n    // TODO: set_altitude_control_enabled(false);\n    // TODO: set_attitude_control_enabled(false);\n    // TODO: set_velocity_control_enabled(false);\n    // TODO: set_acceleration_control_enabled(false);\n    // TODO: set_altitude_control_enabled(false);\n    // TODO: set_attitude_control_enabled(false);\n    // TODO: set_velocity_control_enabled(false);\n    // TODO: set_acceleration_control_enabled(false);\n    // TODO: set_altitude_control_enabled(false);\n    // TODO: set_attitude_control_enabled(false);\n    // TODO: set_velocity_control_enabled(false);\n    // TODO: set_acceleration_control_enabled(false);\n    // TODO: set_altitude_control_enabled(false);\n    // TODO: set_attitude_control_enabled(false);\n    // TODO: set_velocity_control_enabled(false);\n    // TODO: set_acceleration_control_enabled(false);\n    // TODO: set_altitude_control_enabled(false);\n    // TODO: set_attitude_control_enabled(false);\n    // TODO: set_velocity_control_enabled(false);\n    // TODO: set", "CodeBleu_score": 2.006366392388703}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\n    // Check if we have reached the maximum altitude\n    if (guided_limit.max_alt_cm > 0 && curr_pos.z_cm > guided_limit.max_alt_cm) {\n        return true;\n    }\n\n    // Check if we have reached the minimum altitude\n    if (guided_limit.min_alt_cm > 0 && curr_pos.z_cm < guided_limit.min_alt_cm) {\n        return true;\n    }\n\n    // Check if we have reached the horizontal distance limit\n    if (guided_limit.max_hor_dist_cm > 0) {\n        if (get_horizontal_distance_cm(guided_limit.start_pos.xy) > guided_limit.max_hor_dist_cm) {\n            return true;\n        }\n    }\n\n    // Check if we have reached the timeout limit\n    if (guided_limit.timeout_ms > 0 && is_zero(guided_limit.start_time_ms) == false && is_zero(guided_limit.end_time_ms) == true) {\n        if (AP_HAL::millis() - guided_limit.start_time_ms >= guided_limit.timeout_ms) {\n            guided_limit.end_time_ms = AP_HAL::millis();\n            return true;\n        }\n    }\n\n    // If we have reached this point, none of the limits have been exceeded\n    return false;\n}", "CodeBleu_score": 61.918647250480376}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t/*\n\t * If the vehicle has been in guided mode for more than 30 seconds, return true.\n\t */\n\tif (hrt_absolute_time() > (guided_limit.start_time + 30000000)) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * If the vehicle is below the minimum altitude, return true.\n\t */\n\tif (inertial_nav.get_position_neu_cm().z < guided_limit.min_alt) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * If the vehicle is above the maximum altitude, return true.\n\t */\n\tif (inertial_nav.get_position_neu_cm().z > guided_limit.max_alt) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * If the horizontal distance moved is greater than the specified limit, return true.\n\t */\n\tif (get_horizontal_distance_cm() > guided_limit.max_horizontal_distance) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * If none of the above conditions are met, return false.\n\t */\n\treturn false;\n}", "CodeBleu_score": 32.8189868591483}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check if we've exceeded the timeout\n\tif (millis() - _time_started > _time_max) {\n\t\t_time_started = 0;\n\t\treturn true;\n\t}\n\n\t// check if we've exceeded the altitude limits\n\tif (!PX4_ISFINITE(_param_mpc_z_vel_max.get()) || !PX4_ISFINITE(_param_mpc_z_vel_cruise.get())) {\n\t\t// no limits\n\t\treturn false;\n\n\t} else {\n\t\t// check if we've exceeded the altitude limits\n\t\tfloat z_max = _param_mpc_z_vel_max.get();\n\t\tfloat z_cruise = _param_mpc_z_vel_cruise.get();\n\n\t\tif (z_max < z_cruise) {\n\t\t\t// if we're using a max speed lower than the cruise speed, we need to use the max speed as the limit\n\t\t\tz_max = z_cruise;\n\t\t}\n\n\t\tfloat z_min = -z_max;\n\n\t\tif (z_min > z_cruise) {\n\t\t\t// if we're using a min speed higher than the cruise speed, we need to use the min speed as the limit\n\t\t\tz_min = z_cruise;\n\t\t}\n\n\t\tfloat z_sp = _pos_sp(2);\n\n\t\tif (z_sp < z_min) {\n\t\t\tz_sp = z_min;\n\t\t}\n\n\t\tif (z_sp > z_max) {\n\t\t\tz_sp = z_max;\n\t\t}\n\n\t\tif (z_sp - _curr_pos.z < _param_mpc_land_alt1.get()) {\n\t\t\t// we're landing\n\t\t\tz_sp = _param_mpc_land_alt1.get();\n\t\t}\n\n\t\tif (z_sp - _curr_pos.z > _param_mpc_land", "CodeBleu_score": 29.492510320351574}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t  // If the motor test is enabled, and the motor test is not already running, start the motor test.\n  if (motor_test_enabled && !motor_test_running) {\n    motor_test_running = true;\n    motor_test_start_time = millis();\n    motor_test_pass = true;\n    // Send a motor test request.\n    gcs().send_text_fmt(PSTR(\"MOTOR TEST: Starting motor test.\"));\n    motor_test_motor_test_request();\n    return true;\n  }\n\n  // If the motor test is enabled, and the motor test is running, check if the motor test has timed out.\n  if (motor_test_enabled && motor_test_running) {\n    // If the motor test has timed out, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false.\n    if (millis() - motor_test_start_time >= MOTOR_TEST_TIMEOUT) {\n      motor_test_running = false;\n      motor_test_pass = false;\n      gcs().send_text_fmt(PSTR(\"MOTOR TEST: Motor test timed out.\"));\n      gcs().send_text_fmt(PSTR(\"MOTOR TEST: Disabling motor test.\"));\n      motor_test_enabled = false;\n      gcs().send_text_fmt(PSTR(\"MOTOR TEST: Disarming system.\"));\n      arming().disarm();\n      motor_test_failure_time = millis();\n      return false;\n    }\n\n    // If the motor test has not timed out, check if motor test requests have been received at least every 2 Hz.\n    if (millis() - motor_test_last_request_time >= MOTOR_TEST_REQUEST_PERIOD) {\n      // If motor test requests have not been received at least every 2 Hz, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false.\n      if (motor_test_request_count == 0)", "CodeBleu_score": 45.165004184042644}, {"code": "bool Sub::verify_motor_test(){\n\t    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n    // TODO: add timeouts\n", "CodeBleu_score": 3.687242320868155}, {"code": "bool Sub::verify_motor_test(){\n\t    if (motor_test_timeout) {\n        gcs().send_text_fmt(MAV_SEVERITY_CRITICAL, \"Motor test timeout: %d\", motor_test_timeout);\n        motor_test_timeout = 0;\n        motor_test_pass = false;\n        arming().disarm(arming::DISARM_MOTOR_TEST);\n        motor_test_failure_time = AP_HAL::millis();\n        return false;\n    }\n    if (motor_test_timeout == 0) {\n        motor_test_timeout = 2000;\n    }\n    return true;\n}", "CodeBleu_score": 59.58674707213167}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t  //TODO: This function is not yet implemented.\n}", "CodeBleu_score": 3.647387792519552}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\n    // This function, Sub::translate_wpnav_rp, retrieves roll and pitch targets from wp_nav in centidegrees.", "CodeBleu_score": 4.328083980586546}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// TODO: This function is not working properly\n\tint16_t rp_pitch = wp_nav.get_pitch();\n\tint16_t rp_roll = wp_nav.get_roll();\n\tconstrain_int16(rp_pitch, -max_angle_cd, max_angle_cd);\n\tconstrain_int16(rp_roll, -max_angle_cd, max_angle_cd);\n\tlateral_out = (float)rp_roll * 0.01f;\n\tforward_out = (float)rp_pitch * 0.01f;\n}", "CodeBleu_score": 44.27738716917153}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t  barometer.update();\n  if (barometer.healthy()) {\n    if (barometer.get_altitude() > 0) {\n      barometer.update_calibration();\n    }\n    if (depth_sensor) {\n      depth_sensor->update_health(barometer.healthy());\n    }\n  }\n}", "CodeBleu_score": 71.25777795144089}, {"code": "void Sub::read_barometer(){\n\t    if (barometer.get_altitude() > 0) {\n        barometer.update_calibration();\n    }\n    if (depth_sensor != nullptr) {\n        depth_sensor->set_healthy(barometer.healthy());\n    }\n}", "CodeBleu_score": 62.51178259875117}, {"code": "void Sub::read_barometer(){\n\t    barometer.update();\n    if (barometer.get_altitude() > 0) {\n        barometer_calibration.update(barometer.get_altitude());\n    }\n    if (depth_sensor != NULL) {\n        if (barometer.healthy()) {\n            depth_sensor->set_healthy(true);\n        }\n        else {\n            depth_sensor->set_healthy(false);\n        }\n    }\n}", "CodeBleu_score": 56.91498818370629}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav()) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed()) {\n\t\treturn true;\n\t}\n\n\t// Check if the EKF is in constant position mode\n\tif (inertial_nav.get_filter_status() & 1) {\n\t\treturn false;\n\t}\n\n\t// Check if the EKF has a good position\n\tif (inertial_nav.get_filter_status() & 2) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 42.98322590923615}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav()) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed()) {\n\t\t// Disarmed: allow any position\n\t\treturn true;\n\t}\n\n\t// Armed: require a good EKF position\n\treturn inertial_nav.get_filter_status().ekf_pos_horiz_ok;\n}", "CodeBleu_score": 29.571161935803243}, {"code": "bool Sub::ekf_position_ok(){\n\t\tbool ret = false;\n\tif (ahrs.have_inertial_nav()) {\n\t\tif (!motors.armed()) {\n\t\t\tif (inertial_nav.get_filter_status() != INS_FILTER_CONST_POS) {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inertial_nav.get_filter_status() != INS_FILTER_CONST_POS) {\n\t\t\t\tif (inertial_nav.get_filter_status() != INS_FILTER_CONST_POS_MODE) {\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 43.216647551364}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// if we don't require position or velocity, we're done\n\tif (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\n\t\treturn true;\n\t}\n\n\t// call the parent class's GPS checks\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if the AHRS system is ready\n\tif (!ahrs.pre_arm_check(true, display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if the EKF failsafe is active\n\tif (rover.ekf_position_ok == false) {\n\t\tif (display_failure) {\n\t\t\twarnx(\"EKF failsafe\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if the position estimate is valid\n\tif (!rover.control_mode->requires_position) {\n\t\treturn true;\n\t}\n\tif (rover.control_mode->requires_position && rover.position_valid == false) {\n\t\tif (display_failure) {\n\t\t\twarnx(\"Position not valid\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// if we get here, all checks passed\n\treturn true;\n}", "CodeBleu_score": 47.33525134776393}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// if we don't require position or velocity, return true\n\tif (!_control_mode->requires_position && !_control_mode->requires_velocity) {\n\t\treturn true;\n\t}\n\n\t// call parent class's gps checks\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if AHRS is ready\n\tif (!_ahrs->pre_arm_check(false)) {\n\t\tif (display_failure) {\n\t\t\tSerial.println(\"AHRS not ready\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if the EKF failsafe is active\n\tif (ahrs.ekf_position_invalid()) {\n\t\tif (display_failure) {\n\t\t\tSerial.println(\"EKF position invalid\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if the position estimate is valid\n\tif (!_ekf->position_valid()) {\n\t\tif (display_failure) {\n\t\t\tSerial.println(\"EKF position not valid\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// all checks passed\n\treturn true;\n}", "CodeBleu_score": 45.6424636963408}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // check if we are in a mode that requires position or velocity\n    if (!_rover.control_mode->requires_position() && !_rover.control_mode->requires_velocity()) {\n        return true;\n    }\n    // call parent class's gps_checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n    // check if AHRS is ready\n    if (!_ahrs.pre_arm_check(true)) {\n        if (display_failure) {\n            AP_Notify::flags.prearm_check_fail_ahrs = true;\n            AP_Notify::flags.prearm_check_fail_gps = true;\n        }\n        return false;\n    }\n    // check if the EKF failsafe is active\n    if (_rover.ekf_position_ok() == false) {\n        if (display_failure) {\n            AP_Notify::flags.prearm_check_fail_ekf = true;\n            AP_Notify::flags.prearm_check_fail_gps = true;\n        }\n        return false;\n    }\n    // check if the position estimate is valid\n    if (_rover.control_mode->requires_position()) {\n        if (!_rover.gps->position_fix_valid()) {\n            if (display_failure) {\n                AP_Notify::flags.prearm_check_fail_gps = true;\n            }\n            return false;\n        }\n    }\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 52.025296034828514}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (method == AP_ARMING_METHOD_ARM_CHECK) {\n\t\t// arm checks are performed by AP_Arming::arm\n\t\treturn AP_Arming::arm(method, do_arming_checks);\n\t}\n\n\t// check for a pre-arm check\n\tif (method == AP_ARMING_METHOD_PRE_ARM_CHECK) {\n\t\tif (!_pre_arm_check()) {\n\t\t\t// pre-arm check failed\n\t\t\tset_arming_failed(AP_ARMING_FAIL_PRE_ARM_CHECK);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// record the arm method\n\t_arming_method = method;\n\n\t// record the current time\n\t_arming_time = hal.scheduler->millis();\n\n\t// set the arming state to armed\n\t_state = AP_ARMING_STATE_ARMED;\n\n\t// set the soft armed state\n\t_soft_armed = true;\n\n\t// update the soft armed status\n\tupdate_soft_armed();\n\n\t// set the home location\n\trover.g2.smart_rtl.set_home();\n\n\t// initialize the simple mode heading\n\trover.mode_simple.init_heading();\n\n\t// record the home heading for sail vehicles\n\tif (rover.g2.windvane.is_sail_vehicle()) {\n\t\trover.g2.windvane.record_home_heading();\n\t}\n\n\t// send an arm/disarm status text\n\tsend_arm_disarm_statustext();\n\n\t// send a status text\n\tsend_status_text(AP_ARMING_STATUS_ARMED);\n\n\t// return success\n\treturn true;\n}", "CodeBleu_score": 53.71438550770235}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (method != AP_Arming::MANUAL) {\n        return false;\n    }\n\n    if (do_arming_checks && !check_arming()) {\n        return false;\n    }\n\n    // set home location\n    rover.g2.smart_rtl.set_home();\n\n    // initialize heading\n    rover.mode_simple.init_heading();\n\n    // record home heading for sail vehicles\n    rover.g2.windvane.record_home_heading();\n\n    // update soft armed status\n    update_soft_armed();\n\n    // send arm/disarm status text\n    send_arm_disarm_statustext();\n\n    return true;\n}", "CodeBleu_score": 55.233215430681696}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    bool ret = false;\n    // if arming is already in progress, return immediately\n    if (in_progress) {\n        return false;\n    }\n\n    // if arming is already armed, return immediately\n    if (armed) {\n        return false;\n    }\n\n    // set the arming in progress flag\n    in_progress = true;\n\n    // set the arming method\n    arming_method = method;\n\n    // reset the arming failed flag\n    arming_failed = false;\n\n    // set the arming status text\n    set_arming_status_text();\n\n    // attempt to arm the vehicle\n    switch (method) {\n        case AP_ARMING_METHOD_INIT:\n            ret = arm_init();\n            break;\n        case AP_ARMING_METHOD_SMART_RTL:\n            ret = arm_smart_rtl();\n            break;\n        case AP_ARMING_METHOD_SIMPLE_MODE:\n            ret = arm_simple_mode();\n            break;\n        case AP_ARMING_METHOD_MANUAL:\n            ret = arm_manual();\n            break;\n    }\n\n    // if arming failed, set the arming failed flag and return immediately\n    if (!ret) {\n        arming_failed = true;\n        in_progress = false;\n        return false;\n    }\n\n    // if arming succeeded, set the armed flag and return immediately\n    armed = true;\n    in_progress = false;\n\n    // if arming checks are not required, return immediately\n    if (!do_arming_checks) {\n        return true;\n    }\n\n    // perform arming checks\n    if (!check_armed()) {\n        // arming checks failed, set the arming failed flag and return immediately\n        arming_failed = true;\n        in_progress = false;\n        return false;\n    }\n\n    // arming checks succeeded, return immediately\n    return true;\n}", "CodeBleu_score": 42.07429688399919}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (shouldCharge) {\n      if (millis() - last_charged > 60000) {\n        last_charged = millis();\n        charging_enabled = true;\n      }\n    } else {\n      charging_enabled = false;\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      last_charged = millis();\n    } else {\n      if (millis() - last_charged > 60000) {\n        last_charged = millis();\n        charging_enabled = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 45.09464828348575}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (shouldCharge()) {\n      if (!charging_enabled) {\n        charging_enabled = true;\n        charging_start_time = millis();\n        charging_time = 0;\n      }\n    } else {\n      if (charging_enabled) {\n        charging_enabled = false;\n        charging_start_time = 0;\n        charging_time = 0;\n      }\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      charging_start_time = 0;\n      charging_time = 0;\n    }\n  }\n}", "CodeBleu_score": 41.39595481433834}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (shouldCharge()) {\n      if (!charging_enabled) {\n        charging_enabled = true;\n        charging_start_time = millis();\n      }\n    } else {\n      if (charging_enabled) {\n        charging_enabled = false;\n        charging_start_time = millis();\n      }\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      charging_start_time = millis();\n    }\n  }\n}", "CodeBleu_score": 41.94839240390372}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t  if (ros_running && size >= 4) {\n    uint16_t crc = CRC16.ccitt((uint8_t *)message, size - 2);\n    uint8_t *message_with_crc = (uint8_t *)message;\n    message_with_crc[size - 2] = (crc >> 8) & 0xFF;\n    message_with_crc[size - 1] = crc & 0xFF;\n    packetSerial.send((uint8_t *)message, size);\n  }\n}", "CodeBleu_score": 70.37892818548713}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (rosRunning && size >= 4) {\n    uint16_t crc = CRC16.ccitt(message, size);\n    uint8_t *messageWithCRC = (uint8_t *)malloc(size + 2);\n    memcpy(messageWithCRC, message, size);\n    messageWithCRC[size] = (crc >> 8) & 0xFF;\n    messageWithCRC[size + 1] = crc & 0xFF;\n    packetSerial.send(messageWithCRC, size + 2);\n    free(messageWithCRC);\n  }\n}", "CodeBleu_score": 57.29829256527601}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros_running && size >= 4) {\n    uint16_t crc = CRC16.ccitt(message, size);\n    uint8_t *message_with_crc = (uint8_t *)message;\n    message_with_crc[size - 2] = (uint8_t)(crc & 0xFF);\n    message_with_crc[size - 1] = (uint8_t)((crc >> 8) & 0xFF);\n    packetSerial.send((uint8_t *)message, size);\n  }\n}", "CodeBleu_score": 59.31273745859153}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t  //Serial.println(\"MP3Sound::begin\");\n  if (soundSerial.begin(9600)) {\n    soundSerial.flush();\n    soundSerial.write(0x7E);\n    soundSerial.write(0xFF);\n    soundSerial.write(0x06);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x01);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00", "CodeBleu_score": 35.93695553645923}, {"code": "bool MP3Sound::begin(){\n\t  // Initialize serial communication for the sound module\n  soundSerial.begin(9600);\n  soundSerial.flush();\n  // Clear any existing data in the buffer\n  while (soundSerial.available()) {\n    soundSerial.read();\n  }\n  // Initialize the sound module\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x01);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial", "CodeBleu_score": 42.53367098069423}, {"code": "bool MP3Sound::begin(){\n\t  // Initialize serial communication with sound module\n  soundSerial.begin(9600);\n  soundSerial.flush();\n\n  // Initialize sound module\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x01);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00", "CodeBleu_score": 36.60444657561976}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t    if (active_sounds.size() == 0 || myMP3.isPlaying()) {\n        return active_sounds.size();\n    }\n    else {\n        myMP3.play(active_sounds.back());\n        active_sounds.pop_back();\n        return active_sounds.size();\n    }\n}", "CodeBleu_score": 46.97142034837587}, {"code": "int MP3Sound::processSounds(){\n\t  if (active_sounds.size() == 0) {\n    return 0;\n  }\n  if (myMP3.isPlaying()) {\n    return active_sounds.size();\n  }\n  myMP3.play(active_sounds.back());\n  active_sounds.pop_back();\n  return active_sounds.size();\n}", "CodeBleu_score": 48.66317070129003}, {"code": "int MP3Sound::processSounds(){\n\t  if (active_sounds.size() == 0 || myMP3.isPlaying()) {\n    return active_sounds.size();\n  }\n  else {\n    myMP3.play(active_sounds.back());\n    active_sounds.pop_back();\n    return active_sounds.size();\n  }\n}", "CodeBleu_score": 46.3533013910273}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *c = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (c->memory_mapped_file) {\n        wb_abstract_camera_cleanup_memory_mapped_file(c);\n      }\n      c->memory_mapped_file = wb_abstract_camera_setup_memory_mapped_file(d, r);\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 44.37075248777768}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *camera = d->pdata;\n  WbAbstractCameraRequest *request = &camera->request;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      if (request->memory_mapped_file_request) {\n        wb_abstract_camera_cleanup_memory_mapped_file(camera);\n        wb_abstract_camera_setup_memory_mapped_file(camera, request->memory_mapped_file_request);\n      }\n      request->memory_mapped_file_request = 0;\n      request->command_handled = true;\n      break;\n    default:\n      request->command_handled = false;\n      break;\n  }\n  return request->command_handled;\n}", "CodeBleu_score": 48.10570433184499}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *c = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      wb_camera_cleanup_memory_mapped_file(c);\n      wb_camera_setup_memory_mapped_file(c, r);\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 45.263638400539676}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  robot_mutex_lock_step();\n  int h = wb_abstract_camera_get_height_fast(d);\n  robot_mutex_unlock_step();\n  return h;\n}", "CodeBleu_score": 44.85639949386101}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  robot_mutex_lock_step();\n  int result = wb_abstract_camera_get_height_fast(d);\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 48.9801615739246}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  robot_mutex_lock_step();\n  int height = wb_abstract_camera_get_height_step(d);\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 45.54139512563962}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  robot_mutex_lock_step();\n  accelerometer_get_struct(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    fprintf(stderr, \"Error: %s() called with an invalid device tag.\n\", __FUNCTION__);\n    sampling_period = -1;\n  }\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 46.394311093664975}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n    accelerometer->sampling_period = 0;\n  } else {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    sampling_period = -1;\n  }\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 63.510300742960325}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  robot_mutex_lock_step();\n  accelerometer_get_struct(tag, &accelerometer);\n  if (accelerometer.tag == tag)\n    sampling_period = accelerometer.sampling_period;\n  else {\n    fprintf(stderr, \"Error: %s() called with an invalid device tag.\n\", __FUNCTION__);\n    sampling_period = -1;\n  }\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 55.31442046860917}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString = dms;\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 43.03590930918887}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring s(dms);\n\tfree(dms);\n\treturn s;\n}", "CodeBleu_score": 37.52824752333729}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result(dms);\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 38.166184039894674}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tconst dReal *R = dGeomGetRotation (g);\n\tconst dReal *p = dGeomGetPosition (g);\n\tdVector3 p1, p2, p3;\n\tdVector3 c;\n\tdVector3 n;\n\tdReal d;\n\tdVector3Set (p1, R[0], R[1], R[2]);\n\tdVector3Set (p2, R[4], R[5], R[6]);\n\tdVector3Set (p3, R[8], R[9], R[10]);\n\tdVector3Subtract (p1, p, p1);\n\tdVector3Subtract (p2, p, p2);\n\tdVector3Subtract (p3, p, p3);\n\tdVector3Subtract (x, y, z, c);\n\tdVector3Subtract (p1, c, c);\n\tdVector3Subtract (p2, c, c);\n\tdVector3Subtract (p3, c, c);\n\tdVector3Copy (c, n);\n\td = dVector3Dot (c, p1);\n\tif (d < 0) {\n\t\tdVector3Copy (p1, n);\n\t\td = -d;\n\t}\n\td = dFabs (d);\n\tif (d < dVector3Dot (c, p2)) {\n\t\tdVector3Copy (p2, n);\n\t\td = dVector3Dot (c, p2);\n\t}\n\td = dFabs (d);\n\tif (d < dVector3Dot (c, p3)) {\n\t\tdVector3Copy (p3, n);\n\t\td = dVector3Dot (c, p3);\n\t}\n\td = dFabs (d);\n\tif (d > 0.70710678118654752440084436210485) {\n\t\tdVector3Copy (p1, n);\n\t\td = dVector3Dot (c, p1);\n", "CodeBleu_score": 32.531694338563}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n    const dReal *R = dGeomGetRotation (g);\n    const dReal *pos = dGeomGetPosition (g);\n    dVector3 p;\n    p[0] = x - pos[0];\n    p[1] = y - pos[1];\n    p[2] = z - pos[2];\n    dMULTIPLY0_331 (p, R, p);\n    dReal x1 = dFabs (p[0]);\n    dReal y1 = dFabs (p[1]);\n    dReal z1 = dFabs (p[2]);\n    dReal x2 = x1 - ((dGeomBoxGetLengths (g))[0] * 0.5);\n    dReal y2 = y1 - ((dGeomBoxGetLengths (g))[1] * 0.5);\n    dReal z2 = z1 - ((dGeomBoxGetLengths (g))[2] * 0.5);\n    if (x2 > 0) {\n        if (y2 > 0) {\n            if (z2 > 0) {\n                if (x2 < y2) {\n                    if (x2 < z2) {\n                        plane[0] = 1;\n                        plane[1] = 0;\n                        plane[2] = 0;\n                        plane[3] = -pos[0];\n                    }\n                    else {\n                        plane[0] = 0;\n                        plane[1] = 0;\n                        plane[2] = 1;\n                        plane[3] = -pos[2];\n                    }\n                }\n                else {\n                    if (y2 < z2) {\n                        plane[0] = 0;\n                        plane[1] = 1;\n                        plane[2] = 0;\n                        plane[3] = -pos[1];\n                    }\n                    else {\n                        plane[0] = 0;\n                        plane[1] = 0;", "CodeBleu_score": 37.29782609437991}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\tdAASSERT (plane);\n\tdVector3 c;\n\tdGeomBoxGetPositionRelPoint (g, x, y, z, c);\n\tdVector3 n;\n\tdVector3Sub (c, g->final_posr->pos, n);\n\tdReal d = dVector3Dot (n, g->final_posr->R[2]);\n\tif (d < -g->final_posr->R[2][3]) {\n\t\tdVector3Scale (g->final_posr->R[2], -d, n);\n\t\tdVector4Set (plane, n[0], n[1], n[2], d);\n\t}\n\telse if (d > g->final_posr->R[2][3]) {\n\t\tdVector3Scale (g->final_posr->R[2], d, n);\n\t\tdVector4Set (plane, n[0], n[1], n[2], -d);\n\t}\n\telse {\n\t\tdVector4Set (plane, 0, 0, 1, 0);\n\t}\n}", "CodeBleu_score": 25.57084286111736}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dUASSERT (box, \"dImmerseBox: box is NULL\");\n  dUASSERT (immersion, \"dImmerseBox: immersion is NULL\");\n  dUASSERT (immersion->data, \"dImmerseBox: immersion->data is NULL\");\n  dUASSERT (immersion->data->box, \"dImmerseBox: immersion->data->box is NULL\");\n  dUASSERT (immersion->data->plane, \"dImmerseBox: immersion->data->plane is NULL\");\n  dUASSERT (immersion->data->immersion, \"dImmerseBox: immersion->data->immersion is NULL\");\n  dUASSERT (immersion->data->flags, \"dImmerseBox: immersion->data->flags is NULL\");\n\n  dIASSERT (flags & dImmersionBoxFlags);\n\n  sBoxImmersionData *data = (sBoxImmersionData *) immersion->data;\n\n  data->box = box;\n  data->plane = (const sPlane *) fluidPlane;\n  data->immersion = immersion->data->immersion;\n  data->flags = flags;\n\n  return dImmerseBoxInternal (data);\n}", "CodeBleu_score": 42.13984315859606}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dUASSERT (box, \"dImmerseBox: box is NULL\");\n  dUASSERT (immersion, \"dImmerseBox: immersion is NULL\");\n  dUASSERT (flags & dIMM_BOX_BOX, \"dImmerseBox: flags is invalid\");\n\n  sBoxImmersionData data;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.flags = flags;\n  data.immersion = immersion;\n  data.result = 0;\n\n  dImmerseBox (&data);\n\n  return data.result;\n}", "CodeBleu_score": 45.315702598041085}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t    dUASSERT (box, \"dImmerseBox: box is null\n\");\n    dUASSERT (immersion, \"dImmerseBox: immersion is null\n\");\n    dUASSERT (immersion->data, \"dImmerseBox: immersion data is null\n\");\n    dUASSERT (immersion->data->box, \"dImmerseBox: immersion box is null\n\");\n    dUASSERT (immersion->data->fluidPlane, \"dImmerseBox: immersion fluid plane is null\n\");\n    dUASSERT (immersion->data->flags, \"dImmerseBox: immersion flags is null\n\");\n\n    sBoxImmersionData *data = (sBoxImmersionData *) immersion->data;\n\n    dIASSERT (data->box == box);\n    dIASSERT (data->fluidPlane == fluidPlane);\n    dIASSERT (data->flags == flags);\n\n    int result = dImmerseBoxInternal (data);\n\n    dIASSERT (data->box == box);\n    dIASSERT (data->fluidPlane == fluidPlane);\n    dIASSERT (data->flags == flags);\n\n    return result;\n}", "CodeBleu_score": 41.680969875154915}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (SafetyChecks);\n  dUASSERT (o1 && o2 && immersion, \"bad input\");\n  dUASSERT (o1->type == dBoxClass && o2->type == dCapsuleClass, \"bad input\");\n  dUASSERT (flags & dImmersion_ImmersedGeom1 && flags & dImmersion_ImmersedGeom2, \"bad flags\");\n\n  dImmersionGeom *geom1 = immersion->geom1;\n  dImmersionGeom *geom2 = immersion->geom2;\n  dIASSERT (geom1 && geom2);\n  dIASSERT (geom1->obj && geom2->obj);\n\n  dxBox *box = (dxBox*) o1;\n  dxCapsule *capsule = (dxCapsule*) o2;\n\n  // check if the box is completely immersed in the fluid\n  if (dCollideBoxBox (o1, o2, flags, immersion)) {\n    return 1;\n  }\n\n  // check if the capsule is completely immersed in the fluid\n  if (dCollideCapsuleBox (o2, o1, flags, immersion)) {\n    return 1;\n  }\n\n  // check if the box is partially immersed in the fluid\n  if (dCollideBoxCapsule (o1, o2, flags, immersion)) {\n    dImmerseBox (o1, o2, flags, immersion);\n    return 1;\n  }\n\n  // check if the capsule is partially immersed in the fluid\n  if (dCollideCapsuleBox (o2, o1, flags, immersion)) {\n    dImmerseBox (o2, o1, flags, immersion);\n    return 1;\n  }\n\n  // check if the box and the capsule are not immersed in the fluid\n  return 0;\n}", "CodeBleu_score": 44.42245700430433}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (Safety);\n  dUASSERT (o1 && o2 && immersion, \"bad arguments\");\n  dUASSERT (o1->type == dBoxClass, \"argument not a box\");\n  dUASSERT (o2->type == dCapsuleClass, \"argument not a capsule\");\n  dUASSERT (immersion->immersion_type == dImmersionBox, \"invalid immersion type\");\n  dUASSERT (immersion->data.box.flags & dImmersionBoxFlagsComputeImmersionPlane, \"invalid flags\");\n  dUASSERT (immersion->data.box.flags & dImmersionBoxFlagsComputeImmersionSurface, \"invalid flags\");\n\n  dxBox *box = (dxBox*) o1;\n  dxCapsule *capsule = (dxCapsule*) o2;\n  dxImmersionBoxData *box_data = &immersion->data.box;\n  dxImmersionCapsuleData *capsule_data = &immersion->data.capsule;\n\n  dVector3 d;\n  dVector3 n;\n  dReal depth;\n  dReal r;\n  dReal r2;\n  dReal r3;\n  dReal r4;\n  dReal r5;\n  dReal r6;\n  dReal r7;\n  dReal r8;\n  dReal r9;\n  dReal r10;\n  dReal r11;\n  dReal r12;\n  dReal r13;\n  dReal r14;\n  dReal r15;\n  dReal r16;\n  dReal r17;\n  dReal r18;\n  dReal r19;\n  dReal r20;\n  dReal r21;\n  dReal r22;\n  dReal r23;\n  dReal r24;\n  dReal r25;\n  dReal r26;\n  dReal r27;\n  dReal r28;\n  dReal r29;\n  dReal r30;\n  dReal r3", "CodeBleu_score": 36.28324426773793}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (SafetyChecks);\n  dUASSERT (o1 && o2 && immersion, \"bad input\");\n  dUASSERT (o1->type == dBoxClass, \"o1 is not a box\");\n  dUASSERT (o2->type == dCapsuleClass, \"o2 is not a capsule\");\n  dUASSERT (immersion->type == dImmersionCapsuleBox, \"immersion is not a capsule-box immersion\");\n\n  dxCapsule *capsule = (dxCapsule*) o2;\n  dxBox *box = (dxBox*) o1;\n  dImmersionCapsuleBox *capsuleBox = (dImmersionCapsuleBox*) immersion;\n\n  // check for collision\n  dCollideCapsuleBox (o1, o2, flags, capsuleBox);\n  if (!capsuleBox->depth) return 0;\n\n  // set the immersion parameters\n  capsuleBox->depth = capsuleBox->depth;\n  capsuleBox->normal = capsuleBox->normal;\n  capsuleBox->point = capsuleBox->point;\n\n  // compute the immersion plane for the capsule\n  dGeomCapsuleGetImmersionPlane (o2, o1, capsuleBox->normal, capsuleBox->point, capsuleBox->plane);\n\n  // immersion of the box\n  dImmerseBox (o1, o2, flags, capsuleBox->plane, capsuleBox->depth, capsuleBox->normal, capsuleBox->point, immersion);\n\n  return 1;\n}", "CodeBleu_score": 40.28842909416737}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal volume = 0;\n\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal zIOverR3 = zIOverR2 * zIOverR;\n\tdReal zIOverR4 = zIOverR3 * zIOverR;\n\tdReal zIOverR5 = zIOverR4 * zIOverR;\n\tdReal zIOverR6 = zIOverR5 * zIOverR;\n\tdReal zIOverR7 = zIOverR6 * zIOverR;\n\tdReal zIOverR8 = zIOverR7 * zIOverR;\n\tdReal zIOverR9 = zIOverR8 * zIOverR;\n\tdReal zIOverR10 = zIOverR9 * zIOverR;\n\tdReal zIOverR11 = zIOverR10 * zIOverR;\n\tdReal zIOverR12 = zIOverR11 * zIOverR;\n\tdReal zIOverR13 = zIOverR12 * zIOverR;\n\tdReal zIOverR14 = zIOverR13 * zIOverR;\n\tdReal zIOverR15 = zIOverR14 * zIOverR;\n\tdReal zIOverR16 = zIOverR15 * zIOverR;\n\tdReal zIOverR17 = zIOverR16 * zIOverR;\n\tdReal zIOverR18 = zIOverR17 * zIOverR;\n\tdReal zIOverR19 = zIOverR18 * zIOverR;\n\tdReal zIOverR20 = zIOverR19 * zIOverR;\n\tdReal zIOverR21 = zIOverR20 * zIOverR;\n\tdReal zIOverR22 = zIOverR21 * zIOverR;\n\tdReal zIOverR23 = zIOverR22 * zIOverR;\n\tdReal zIOverR24 = zIOverR2", "CodeBleu_score": 31.335534822649137}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\t// This function, sCapsuleImmersionData::normalizedImmersedHemisphereVolume, calculates the normalized volume of an immersed hemisphere using Simpson's rule for numerical integration.", "CodeBleu_score": 7.168493416914039}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\treturn (\n\t\t\t//Calculate the volume of the hemisphere that is not immersed\n\t\t\t(2 * M_PI * M_PI * M_PI * zIOverR * zIOverR * zIOverR * (1 - tanTheta0) * (1 - sinTheta1))\n\t\t\t\t\t/ 3.0\n\t\t\t\t\t+\n\t\t\t\t\t//Calculate the volume of the hemisphere that is immersed\n\t\t\t\t\t(2 * M_PI * M_PI * M_PI * zIOverR * zIOverR * zIOverR * (1 - tanTheta0) * (1 - sinTheta1))\n\t\t\t\t\t\t\t/ 3.0\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t(1 - zIOverR)\n\t\t\t\t\t\t\t/\n\t\t\t\t\t\t\t(1 + zIOverR)\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t(1 - zIOverR)\n\t\t\t\t\t\t\t/\n\t\t\t\t\t\t\t(1 + zIOverR)\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t(1 - zIOverR)\n\t\t\t\t\t\t\t/\n\t\t\t\t\t\t\t(1 + zIOverR)\n\t\t);\n}", "CodeBleu_score": 20.660637446529933}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal xCenterOfMassIntegrand = 0;\n\n\t// For each surface point\n\tfor (int i = 0; i < 2; i++) {\n\t\t// Get the angle\n\t\tdReal theta = 0;\n\t\tif (i == 0) {\n\t\t\ttheta = m_theta0;\n\t\t}\n\t\telse {\n\t\t\ttheta = m_theta1;\n\t\t}\n\n\t\t// Calculate the integrand\n\t\txCenterOfMassIntegrand += (zIOverR * sin(theta)) * (1 - (zIOverR * cos(theta)));\n\t}\n\n\t// Calculate the x-coordinate of the buoyancy center\n\tdReal xCenterOfMass = 0;\n\txCenterOfMass = (xCenterOfMassIntegrand * 2) / 3;\n\n\t// Return the x-coordinate of the buoyancy center\n\treturn (xCenterOfMass * m_radius * volume);\n}", "CodeBleu_score": 38.15871586919754}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\t// Calculate the number of points to use in the numerical integration\n\tint nPoints = (int) (1.0 / (2.0 * zIOverR) + 1.0);\n\tif (nPoints % 2 == 0) {\n\t\tnPoints++;\n\t}\n\n\t// Calculate the step size\n\tdReal stepSize = M_PI / (nPoints - 1);\n\n\t// Calculate the integral\n\tdReal xCenterOfMassIntegrand = 0.0;\n\tfor (int i = 0; i < nPoints; i++) {\n\t\tdReal theta = i * stepSize;\n\t\tdReal sinTheta = sin(theta);\n\t\tdReal cosTheta = cos(theta);\n\t\tdReal tanTheta = tan(theta);\n\n\t\t// Calculate the integrand\n\t\tdReal integrand = 0.0;\n\t\tif (i == 0) {\n\t\t\tintegrand = zIOverR * sinTheta * (1.0 - zIOverR * sinTheta) * (1.0 + zIOverR * cosTheta);\n\t\t} else if (i == nPoints - 1) {\n\t\t\tintegrand = zIOverR * sinTheta * (1.0 - zIOverR * sinTheta) * (1.0 + zIOverR * cosTheta);\n\t\t} else {\n\t\t\tintegrand = zIOverR * sinTheta * (1.0 - zIOverR * sinTheta) * (1.0 + zIOverR * cosTheta) * (1.0 + zIOverR * tanTheta);\n\t\t}\n\n\t\t// Add the integrand to the integral\n\t\txCenterOfMassIntegrand += integrand;\n\t}\n\n\t// Calculate the center of mass\n\tdReal xCenterOfMass = xCenterOfMassIntegrand * volume / (4.0 * M_PI * zIOverR * zIOverR * zIOverR);\n\n\t// Return the center of mass\n\treturn xCenterOfMass * radius + volume / 3.0;\n}", "CodeBleu_score": 38.81160408480907}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    // The integral is the integral of x * sin(theta) * (1 - zIOverR) * sin(theta) dtheta dz\n    // We can use Simpson's rule to approximate this integral\n    // Simpson's rule requires us to break the integral into sub-intervals\n    // The sub-intervals will be of the form [theta0, theta1]\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals will be of the same length\n    // We will use 20 sub-intervals\n    // The sub-intervals", "CodeBleu_score": 8.378887340666212}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (o1->type == dCapsuleClass);\n\tdIASSERT (o2->type == dTriMeshClass);\n\tdIASSERT (immersion->type == dImmersionCapsuleTrimeshClass);\n\tdIASSERT (flags & dContactSpherical);\n\n\tdxCapsule *capsule = (dxCapsule*) o1;\n\tdxTriMesh *mesh = (dxTriMesh*) o2;\n\n\tdVector3 v0, v1, v2, v3;\n\tdVector3 p0, p1, p2, p3;\n\tdVector3 n0, n1, n2, n3;\n\tdVector3 v;\n\tdVector3 vn;\n\tdVector3 vc;\n\tdVector3 vc0, vc1;\n\tdVector3 vc2, vc3;\n\tdVector3 vc4, vc5;\n\tdVector3 vc6, vc7;\n\tdVector3 vc8, vc9;\n\tdVector3 vc10, vc11;\n\tdVector3 vc12, vc13;\n\tdVector3 vc14, vc15;\n\tdVector3 vc16, vc17;\n\tdVector3 vc18, vc19;\n\tdVector3 vc20, vc21;\n\tdVector3 vc22, vc23;\n\tdVector3 vc24, vc25;\n\tdVector3 vc26, vc27;\n\tdVector3 vc28, vc29;\n\tdVector3 vc30, vc31;\n\tdVector3 vc32, vc33;\n\tdVector3 vc34, vc35;\n\tdVector3 vc36, vc37;\n\tdVector3 vc38, vc39;\n\tdVector3 vc40, vc41;\n\tdVector3 vc42, vc43;\n\td", "CodeBleu_score": 25.779073176493185}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (o1->type == dCapsuleClass);\n  dIASSERT (o2->type == dTriMeshClass);\n  dIASSERT (immersion->type == dImmersionCapsuleTrimeshClass);\n  dIASSERT (((dxCapsule*)o1)->length > 0);\n  dIASSERT (((dxTriMesh*)o2)->data->first_triangle != NULL);\n\n  dCapsule *capsule = (dCapsule*)o1;\n  dxTriMesh *mesh = (dxTriMesh*)o2;\n  dImmerseCapsuleTrimesh *immersionData = (dImmerseCapsuleTrimesh*)immersion;\n\n  dVector3 center;\n  dVector3 normal;\n  dReal depth;\n  dReal volume;\n  dReal xBuoyancyCenter;\n  dReal xBuoyancyCenterScaled;\n  dReal xBuoyancyCenterAdjusted;\n\n  //Get the capsule's center and radius\n  dReal radius = capsule->radius;\n  dReal halfLength = capsule->length * 0.5;\n  dVector3Set (center, 0, 0, halfLength);\n  dMultiply0_331 (center, capsule->final_posr->R, center);\n  dAddVectors3 (center, center, capsule->final_posr->pos);\n\n  //Get the mesh's center\n  dVector3Set (normal, 0, 0, 1);\n  dMultiply0_331 (normal, mesh->final_posr->R, normal);\n  dAddVectors3 (normal, normal, mesh->final_posr->pos);\n\n  //Calculate the immersion depth ratio\n  dReal depthRatio = dDOT (normal, center) - radius;\n\n  //Calculate the immersion depth\n  depth = depthRatio * radius;\n\n  //Calculate the volume of the hemisphere\n  volume = dPI * radius * radius * radius * 0.5;\n\n  //Calculate the x-coordinate of the", "CodeBleu_score": 35.6026846682992}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n  dIASSERT (o1->type == dCapsuleClass);\n  dIASSERT (o2->type == dTriMeshClass);\n\n  dCapsule *capsule = (dCapsule*) o1;\n  dTriMesh *mesh = (dTriMesh*) o2;\n\n  dVector3 c, d;\n  dVector3 n;\n  dVector3 p;\n  dVector3 q;\n  dVector3 r;\n  dVector3 s;\n  dVector3 t;\n  dVector3 u;\n  dVector3 v;\n  dVector3 w;\n  dVector3 x;\n  dVector3 y;\n  dVector3 z;\n\n  dReal *vertices = (dReal*) mesh->data;\n  dReal *normals = vertices + 3 * mesh->vertex_count;\n  dTriIndex *indices = (dTriIndex*) (normals + 3 * mesh->vertex_count);\n\n  int i;\n  int j;\n  int k;\n  int l;\n  int m;\n  int n;\n  int o;\n  int p;\n  int q;\n  int r;\n  int s;\n  int t;\n  int u;\n  int v;\n  int w;\n  int x;\n  int y;\n  int z;\n\n  dReal a;\n  dReal b;\n  dReal c;\n  dReal d;\n  dReal e;\n  dReal f;\n  dReal g;\n  dReal h;\n  dReal i;\n  dReal j;\n  dReal k;\n  dReal l;\n  dReal m;\n  dReal n;\n  dReal o;\n  dReal p;\n  dReal q;\n  dReal r;\n  dReal s;\n  dReal t;\n  dReal u;\n  dReal v;\n  dReal w;\n  dReal x;\n  dReal y;\n  dReal z;\n\n  dReal A;\n  dReal B;\n  dReal C;\n  dReal D;\n  dReal", "CodeBleu_score": 32.0220929513489}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t  // TODO: Implement onStart\n  std::chrono::milliseconds duration;\n  if (!getInput<std::chrono::milliseconds>(\"duration\", duration)) {\n    return NodeStatus::SUCCESS;\n  }\n  if (duration.count() <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_.add(duration, std::bind(&SleepNode::emitWakeUpSignal, this));\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 42.746925348675255}, {"code": "NodeStatus SleepNode::onStart(){\n\t  // TODO: Implement SleepNode::onStart\n  // Retrieve the sleep duration in milliseconds from the input.\n  auto duration = getInput<double>(\"duration\");\n  if (!duration) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // If the duration is missing or non-positive, it returns SUCCESS.\n  if (*duration <= 0.0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING.\n  setStatus(NodeStatus::RUNNING);\n\n  // Start a timer.\n  timer_.add(std::chrono::milliseconds(*duration),\n             std::bind(&SleepNode::setStatus, this, NodeStatus::SUCCESS),\n             &timer_waiting_);\n\n  // Set a callback to emit a wake-up signal when the timer expires.\n  timer_.setOnExpiredCallback(\n      std::bind(&SleepNode::emitWakeUpSignal, this));\n\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 49.816897280599356}, {"code": "NodeStatus SleepNode::onStart(){\n\t  RCLCPP_DEBUG(get_logger(), \"SleepNode::onStart()\");\n  // Get the sleep duration in milliseconds from the input\n  double sleep_duration_ms = 0.0;\n  if (getInput<double>(\"duration\", sleep_duration_ms)) {\n    RCLCPP_DEBUG(get_logger(), \"SleepNode::onStart(): sleep duration is missing or non-positive\");\n    return NodeStatus::SUCCESS;\n  }\n  RCLCPP_DEBUG(get_logger(), \"SleepNode::onStart(): sleep duration is %f ms\", sleep_duration_ms);\n\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n\n  // Start a timer\n  timer_.add(std::chrono::milliseconds(sleep_duration_ms), std::bind(&SleepNode::setStatus, this, NodeStatus::SUCCESS), false);\n\n  // Set a callback to emit a wake-up signal when the timer expires\n  timer_.setCallback(std::bind(&SleepNode::emitWakeUpSignal, this));\n\n  // Return RUNNING\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 40.14282808115536}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  // TODO: Implement code here\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 6.587517749686045}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // Check if the entry exists\n    if (blackboard_->getEntry(entry_name_) == nullptr) {\n        RCLCPP_WARN(\n            get_logger(),\n            \"EntryUpdatedAction: Entry %s not found in blackboard\", entry_name_.c_str());\n        return NodeStatus::FAILURE;\n    }\n\n    // Retrieve the entry\n    auto entry = blackboard_->getEntry(entry_name_);\n\n    // Lock the entry mutex\n    entry->mutex->lock();\n\n    // Check if the sequence ID has changed\n    if (entry->sequence_id != entry_sequence_id_) {\n        // Update the sequence ID\n        entry_sequence_id_ = entry->sequence_id;\n\n        // Unlock the entry mutex\n        entry->mutex->unlock();\n\n        // Return success\n        return NodeStatus::SUCCESS;\n    }\n\n    // Unlock the entry mutex\n    entry->mutex->unlock();\n\n    // Return failure\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 43.43713167919302}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  // TODO: Implement code to check if an entry has been updated\n  // TODO: If the entry has been updated, update the sequence ID\n  // TODO: If the entry has not been updated, return NodeStatus::FAILURE\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 6.587517749686045}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t    if (successThreshold_ < 0) {\n        return -successThreshold_ * children_nodes_.size();\n    }\n    return successThreshold_;\n}", "CodeBleu_score": 51.264167641541846}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    return std::max(0, static_cast<size_t>(successThreshold_));\n}", "CodeBleu_score": 8.88753330695336}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (successThreshold_ < 0) {\n        return std::max(size_t(0), childrenNodes_.size() + successThreshold_);\n    }\n    return size_t(successThreshold_);\n}", "CodeBleu_score": 57.80236139468051}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n        std::chrono::milliseconds ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch());\n        int64_t now_time = ms.count();\n        if (now_time - last_heartbeat_time > heartbeat_interval) {\n            std::cout << \"Groot2Publisher::heartbeatLoop: Heartbeat has expired. Disabling all breakpoints.\" << std::endl;\n            enableAllHooks(false);\n        }\n    }\n}", "CodeBleu_score": 43.80651335553849}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    std::chrono::system_clock::time_point last_heartbeat = std::chrono::system_clock::now();\n    std::chrono::milliseconds duration(10);\n    while (true) {\n        std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n        std::chrono::milliseconds elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_heartbeat);\n        if (elapsed.count() >= 1000) {\n            if (heartbeatStatus == 1) {\n                heartbeatStatus = 0;\n                disableAllHooks();\n            }\n            else {\n                heartbeatStatus = 1;\n                enableAllHooks();\n            }\n            last_heartbeat = now;\n        }\n        std::this_thread::sleep_for(duration);\n    }\n}", "CodeBleu_score": 39.94817780383212}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\t// Sleep for 10 milliseconds\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\t// Get the current time\n\t\tstd::chrono::time_point<std::chrono::system_clock> currentTime = std::chrono::system_clock::now();\n\n\t\t// Check if the heartbeat is active\n\t\tif (heartbeatActive) {\n\t\t\t// If the heartbeat is active, check if it's been active for more than 5 seconds\n\t\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - lastHeartbeatTime).count() > 5000) {\n\t\t\t\t// If it's been active for more than 5 seconds, disable all breakpoints\n\t\t\t\tenableAllHooks(false);\n\t\t\t}\n\t\t} else {\n\t\t\t// If the heartbeat is inactive, check if it's been inactive for more than 10 seconds\n\t\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - lastHeartbeatTime).count() > 10000) {\n\t\t\t\t// If it's been inactive for more than 10 seconds, enable all breakpoints\n\t\t\t\tenableAllHooks(true);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.36342914308143}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  nlohmann::json j;\n\n  std::vector<std::string> bb_names = splitString(bb_list, ' ');\n\n  for (auto bb_name : bb_names) {\n    if (bb_name.empty()) {\n      continue;\n    }\n\n    // Find the subtree\n    auto it = _p->subtrees.find(bb_name);\n    if (it == _p->subtrees.end()) {\n      continue;\n    }\n\n    // Lock the subtree\n    it->second.lock();\n\n    // Export the blackboard\n    if (!it->second.subtree->exportBlackboardToJSON(j)) {\n      continue;\n    }\n\n    // Unlock the subtree\n    it->second.lock.unlock();\n  }\n\n  return j.dump().c_str();\n}", "CodeBleu_score": 54.48683900105675}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> ret;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    while (std::getline(ss, bb_name, ',')) {\n        auto subtree = _p->subtrees.find(bb_name);\n        if (subtree == _p->subtrees.end()) {\n            RCLCPP_WARN(_p->node->get_logger(), \"Blackboard \\\"%s\\\" not found. Skipping.\", bb_name.c_str());\n            continue;\n        }\n        if (subtree->second.lock.try_lock()) {\n            nlohmann::json j;\n            j[\"name\"] = bb_name;\n            j[\"blackboard\"] = ExportBlackboardToJSON(subtree->second.blackboard);\n            ret.insert(ret.end(), j.dump().begin(), j.dump().end());\n            subtree->second.lock.unlock();\n        } else {\n            RCLCPP_WARN(_p->node->get_logger(), \"Blackboard \\\"%s\\\" is locked. Skipping.\", bb_name.c_str());\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 46.57506640073959}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    nlohmann::json j;\n    std::vector<uint8_t> bb_dump;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n\n    while (std::getline(ss, bb_name, ',')) {\n        auto bb = _p->subtrees.find(bb_name);\n        if (bb != _p->subtrees.end()) {\n            bb->second.lock();\n            if (bb->second.isValid()) {\n                j[bb_name] = bb->second.exportToJSON();\n            }\n            bb->second.unlock();\n        }\n    }\n\n    bb_dump = nlohmann::json::to_msgpack(j);\n\n    return bb_dump;\n}", "CodeBleu_score": 51.371405498483604}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::lock_guard<std::mutex> lk(mtx_);\n  auto it = nodes_by_uid_.find(node_uid);\n  if (it == nodes_by_uid_.end()) {\n    return false;\n  }\n  auto hook = getHook(pos);\n  if (!hook) {\n    return false;\n  }\n  std::lock_guard<std::mutex> lk2(hook->mtx);\n  if (hook->status != HookStatus::BREAKPOINT) {\n    return false;\n  }\n  hook->status = HookStatus::READY;\n  hook->result = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 55.11536998469996}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::lock_guard<std::mutex> lk(_mutex);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end())\n    return false;\n  auto hook = getHook(it->second.hook_id);\n  if (!hook)\n    return false;\n  std::lock_guard<std::mutex> lk2(hook->wakeup.mutex);\n  if (hook->status != HookStatus::BREAKPOINT)\n    return false;\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 48.103650204569306}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  if (pos == Position::NONE || node_uid == 0) {\n    return false;\n  }\n\n  std::unique_lock<std::mutex> lk(_mutex);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n\n  auto hook = getHook(it->second.hook_id);\n  if (!hook) {\n    return false;\n  }\n\n  lk.unlock();\n  std::lock_guard<std::mutex> lk2(hook->mutex);\n  if (hook->status == HookStatus::BREAKPOINT) {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->wakeup.notify_all();\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 71.36366521324379}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    if (status() == IDLE) {\n        setStatus(RUNNING);\n        halt_requested_ = false;\n        std::async(std::launch::async, [this] { tick(); });\n    }\n    if (!halt_requested_) {\n        if (std::current_exception()) {\n            std::rethrow_exception(std::current_exception());\n        }\n        if (std::exception_ptr stored_exception_ = std::move(stored_exception_)) {\n            std::rethrow_exception(stored_exception_);\n        }\n        return status();\n    } else {\n        setStatus(IDLE);\n        return IDLE;\n    }\n}", "CodeBleu_score": 40.20999829473308}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    if (status_ == NodeStatus::IDLE) {\n        status_ = NodeStatus::RUNNING;\n        halt_requested_ = false;\n        std::async(std::launch::async, [this]() {\n            try {\n                tick();\n            } catch (...) {\n                std::exception_ptr eptr = std::current_exception();\n                std::rethrow_exception(eptr);\n            }\n        });\n    }\n    if (!halt_requested_) {\n        status_ = NodeStatus::RUNNING;\n    } else {\n        status_ = NodeStatus::IDLE;\n    }\n    if (exception_ptr_) {\n        std::exception_ptr eptr = exception_ptr_;\n        exception_ptr_ = nullptr;\n        std::rethrow_exception(eptr);\n    }\n    return status_;\n}", "CodeBleu_score": 51.69475336715025}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status() == IDLE) {\n    setStatus(RUNNING);\n    halt_requested_ = false;\n    // Start a new thread to run the tick function.\n    std::async(std::launch::async, &BT::ThreadedAction::tick, this);\n  }\n  // Check for any stored exceptions and rethrow them if present.\n  if (std::current_exception()) {\n    std::rethrow_exception(std::current_exception());\n  }\n  return status();\n}", "CodeBleu_score": 19.85951188789618}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    // A lambda function to print the tree recursively\n    auto print_tree_recursively = [&](const TreeNode* node, int depth) {\n        // Print the node's name\n        stream << std::string(depth * 2, ' ') << node->name << std::endl;\n        // If the node is a ControlNode, print its children\n        if (const auto* control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children) {\n                print_tree_recursively(child, depth + 1);\n            }\n        }\n        // If the node is a DecoratorNode, print its child\n        else if (const auto* decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            print_tree_recursively(decorator->child, depth + 1);\n        }\n    };\n    // Print the root node's name\n    stream << root_node->name << std::endl;\n    // Print separator lines\n    stream << std::string(root_node->depth * 2, ' ') << \"|-\" << std::endl;\n    // Print the tree recursively\n    print_tree_recursively(root_node, 1);\n    // Print separator lines\n    stream << std::string(root_node->depth * 2, ' ') << \"`-\" << std::endl;\n}", "CodeBleu_score": 52.124725229709135}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    // This lambda function prints a tree structure starting from the root_node to the provided output stream.\n    // It defines a recursive lambda function to handle the printing.\n    // The lambda function indents the output based on the node's depth, prints the node's name, and recursively prints the children for ControlNode or the child for DecoratorNode.\n    // The function begins and ends with separator lines.\n    auto print_tree = [&](const TreeNode* node, int depth) {\n        // This lambda function prints a tree structure starting from the root_node to the provided output stream.\n        // It defines a recursive lambda function to handle the printing.\n        // The lambda function indents the output based on the node's depth, prints the node's name, and recursively prints the children for ControlNode or the child for DecoratorNode.\n        // The function begins and ends with separator lines.\n        stream << std::setw(2 * depth) << \" \" << node->name << std::endl;\n        if (const auto* control = dynamic_cast<const BT::ControlNode*>(node)) {\n            // If the node is a ControlNode, print the children.\n            for (const auto& child : control->children) {\n                print_tree(&child, depth + 1);\n            }\n        } else if (const auto* decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            // If the node is a DecoratorNode, print the child.\n            print_tree(decorator->child.get(), depth + 1);\n        }\n    };\n    stream << \"================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================", "CodeBleu_score": 31.336831571754004}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto print_node = [&](const TreeNode* node) {\n        std::string indent(node->depth(), '\\t');\n        stream << indent << node->name() << std::endl;\n    };\n\n    stream << std::endl;\n    print_node(root_node);\n    stream << std::endl;\n\n    auto print_children = [&](const TreeNode* node) {\n        for (const auto& child : node->children()) {\n            print_node(child);\n        }\n    };\n\n    auto print_child = [&](const TreeNode* node) {\n        print_node(node->child());\n    };\n\n    std::function<void(const TreeNode*)> print_func;\n    if (dynamic_cast<const BT::ControlNode*>(root_node)) {\n        print_func = print_children;\n    } else {\n        print_func = print_child;\n    }\n\n    print_func(root_node);\n}", "CodeBleu_score": 43.76532443843449}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (node == nullptr) {\n        throw LogicError(\"applyRecursiveVisitor: cannot apply visitor to a null node\");\n    }\n\n    visitor(node);\n\n    if (const BT::ControlNode* control = dynamic_cast<const BT::ControlNode*>(node)) {\n        for (const TreeNode* child : control->children) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (const BT::DecoratorNode* decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n        applyRecursiveVisitor(decorator->child, visitor);\n    }\n}", "CodeBleu_score": 65.24090195923205}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (node == nullptr) {\n        throw LogicError(\"applyRecursiveVisitor: null node\");\n    }\n    visitor(node);\n    if (node->getType() == TreeNode::COMPOSITE) {\n        const BT::CompositeNode* composite =\n            dynamic_cast<const BT::CompositeNode*>(node);\n        for (auto child : composite->children_) {\n            applyRecursiveVisitor(child.get(), visitor);\n        }\n    } else if (node->getType() == TreeNode::DECORATOR) {\n        const BT::DecoratorNode* decorator =\n            dynamic_cast<const BT::DecoratorNode*>(node);\n        applyRecursiveVisitor(decorator->child.get(), visitor);\n    }\n}", "CodeBleu_score": 61.072384005414726}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (node == nullptr) {\n        throw LogicError(\"applyRecursiveVisitor: node is nullptr\");\n    }\n    visitor(node);\n    if (const ControlNode* control = dynamic_cast<const ControlNode*>(node)) {\n        for (auto& child : control->children) {\n            applyRecursiveVisitor(child.get(), visitor);\n        }\n    } else if (const DecoratorNode* decorator = dynamic_cast<const DecoratorNode*>(node)) {\n        applyRecursiveVisitor(decorator->child.get(), visitor);\n    }\n}", "CodeBleu_score": 65.82699494476047}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (_p->builders.find(manifest.registrationId) != _p->builders.end()) {\n        throw BehaviorTreeException(\"Builder already registered with id: \" + manifest.registrationId);\n    }\n    _p->builders.insert(std::make_pair(manifest.registrationId, builder));\n    _p->manifests.insert(std::make_pair(manifest.registrationId, manifest));\n}", "CodeBleu_score": 56.86255284627313}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (_p->builders.find(manifest.registrationId) != _p->builders.end()) {\n    throw BehaviorTreeException(\"Node builder with ID '\" + manifest.registrationId +\n                                \"' already exists.\");\n  }\n  _p->builders.insert(std::make_pair(manifest.registrationId, builder));\n  _p->manifests.insert(std::make_pair(manifest.registrationId, manifest));\n}", "CodeBleu_score": 55.244463716874115}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (_p->builders.find(manifest.registrationId) != _p->builders.end()) {\n        throw BehaviorTreeException(\n            \"Builder with registration ID '\" + manifest.registrationId + \"' already exists.\");\n    }\n\n    _p->builders.insert(std::make_pair(manifest.registrationId, builder));\n    _p->manifests.insert(std::make_pair(manifest.registrationId, manifest));\n}", "CodeBleu_score": 55.29946766143237}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor, ports](\n      const std::string& ID, const BT::NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(ID, tick_functor, ports);\n  };\n  registerBuilder(ID, builder);\n}", "CodeBleu_score": 46.80976089335992}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor](const std::string& ID,\n                                const BT::NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(ID, tick_functor, config);\n  };\n  registerBuilder(ID, builder, std::move(ports));\n}", "CodeBleu_score": 52.64540058004087}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor](const std::string& ID,\n                                const PortsList& ports) {\n    return std::make_unique<SimpleActionNode>(ID, tick_functor, ports);\n  };\n  registerBuilder(ID, builder, ports);\n}", "CodeBleu_score": 45.94980122339358}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (auto sub : tree.subtrees) {\n        Blackboard::Ptr bb_backup = Blackboard::create();\n        bb_backup->cloneInto(sub->blackboard);\n        bb.push_back(bb_backup);\n    }\n    return bb;\n}", "CodeBleu_score": 69.04301905881873}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (auto sub : tree.subtrees) {\n        Blackboard::Ptr backup = Blackboard::create();\n        sub->blackboard->cloneInto(*backup);\n        bb.push_back(backup);\n    }\n    return bb;\n}", "CodeBleu_score": 69.98224886466426}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (const auto& sub : tree.subtrees) {\n        bb.push_back(sub->blackboard->cloneInto());\n    }\n    return bb;\n}", "CodeBleu_score": 72.76242138592076}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (executor) {\n        return executor.value()(env);\n    } else {\n        return nonstd::make_unexpected(executor.error());\n    }\n}", "CodeBleu_score": 92.72121218184945}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (executor) {\n        return executor->execute(env);\n    }\n    return nonstd::make_unexpected(executor.error());\n}", "CodeBleu_score": 71.89152164530084}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (executor) {\n        return executor.value().Execute(env);\n    }\n    return nonstd::make_unexpected(executor.error());\n}", "CodeBleu_score": 72.9548850505348}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(mutex);\n    if (loaded)\n        throw RuntimeError(std::string(\"library \") + path + \" already loaded\");\n    if ((handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL)) == NULL)\n        throw RuntimeError(std::string(\"error loading \") + path + \": \" + dlerror());\n    loaded = true;\n    this->path = path;\n}", "CodeBleu_score": 54.88637878575188}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n    if (library != nullptr) {\n        throw RuntimeError(\"SharedLibrary::load()\", \"A library is already loaded\");\n    }\n    library = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (library == nullptr) {\n        throw RuntimeError(\"SharedLibrary::load()\", dlerror());\n    }\n    this->path = path;\n}", "CodeBleu_score": 50.296505268194714}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\n            \"SharedLibrary::load: \" + path + \" already loaded\");\n    }\n    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(\n            \"SharedLibrary::load: \" + dlerror() + \" while loading \" + path);\n    }\n    this->path = path;\n    this->handle = handle;\n    loaded = true;\n}", "CodeBleu_score": 57.27840225396539}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped[0] != '{' || stripped[stripped.size() - 1] != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer != nullptr) {\n\t\t*stripped_pointer = stripped.slice(1, stripped.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 26.052860319957905}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) return false;\n    StringView stripped = str.strip();\n    if (stripped.size() < 3) return false;\n    if (stripped.starts_with(\"{\") && stripped.ends_with(\"}\")) {\n        if (stripped_pointer) *stripped_pointer = stripped.slice(1, stripped.size() - 2);\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 21.95647105467737}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str;\n\tstripped.stripLeading();\n\tstripped.stripTrailing();\n\n\tif (!(stripped.size >= 3 && stripped.startsWith(\"{\") && stripped.endsWith(\"}\"))) {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 22.35079112452674}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  LineIterator line(x0, x1, y0, y1);\n  double line_cost = 0.0;\n  for (line.isValid(); line.isValid(); line.advance()) {\n    double point_cost = pointCost(line.getX(), line.getY());\n    if (point_cost < 0.0) {\n      return point_cost;\n    }\n    line_cost += point_cost;\n  }\n  return line_cost;\n}", "CodeBleu_score": 61.243375648476864}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  // Initialize the line cost\n  double line_cost = 0.0;\n\n  // Calculate the line cost\n  for (LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance()) {\n    // Calculate the point cost\n    double point_cost = pointCost(line.getX(), line.getY());\n\n    // Check if the point cost is negative\n    if (point_cost < 0.0) {\n      // Return the point cost immediately\n      return point_cost;\n    }\n\n    // Update the line cost if the point cost is higher\n    line_cost = std::max(line_cost, point_cost);\n  }\n\n  // Return the total line cost\n  return line_cost;\n}", "CodeBleu_score": 64.00803409846773}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\t// Initialize the line cost\n\tdouble line_cost = 0.0;\n\n\t// Calculate the line cost\n\tLineIterator it(x0, x1, y0, y1);\n\tfor (it.rewind(); !it.isDone(); it.advance()) {\n\t\t// Calculate the point cost\n\t\tdouble point_cost = pointCost(it.getX(), it.getY());\n\t\t// If the point cost is negative, return the point cost immediately\n\t\tif (point_cost < 0.0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\t// Otherwise, update the line cost if the point cost is higher\n\t\telse {\n\t\t\tline_cost = std::max(line_cost, point_cost);\n\t\t}\n\t}\n\t// Return the total line cost\n\treturn line_cost;\n}", "CodeBleu_score": 61.02079484493446}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  gui_path.poses.resize(path.size());\n  for (size_t i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 82.80434796462643}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty())\n    return;\n  nav_msgs::Path gui_path;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.poses.resize(path.size());\n  for (size_t i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 80.24180785889632}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty()) {\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses.resize(path.size());\n  for (size_t i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 81.44930170341146}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  // Get the linear and angular velocities\n  double linear_velocity = base_odom.twist.twist.linear.x;\n  double angular_velocity = base_odom.twist.twist.angular.z;\n\n  // Check if the robot has stopped\n  if (fabs(angular_velocity) <= rot_stopped_velocity && fabs(linear_velocity) <= trans_stopped_velocity) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 50.673333274295416}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) &&\n         (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}", "CodeBleu_score": 55.88679458340139}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  if (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 65.8167617140363}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t    if (setup_flag) {\n        if (restore_defaults) {\n            config.limits.max_vel_x = default_limits.max_vel_x;\n            config.limits.min_vel_x = default_limits.min_vel_x;\n            config.limits.max_vel_y = default_limits.max_vel_y;\n            config.limits.min_vel_y = default_limits.min_vel_y;\n            config.limits.max_vel_theta = default_limits.max_vel_theta;\n            config.limits.min_vel_theta = default_limits.min_vel_theta;\n            config.limits.max_acc_x = default_limits.max_acc_x;\n            config.limits.min_acc_x = default_limits.min_acc_x;\n            config.limits.max_acc_y = default_limits.max_acc_y;\n            config.limits.min_acc_y = default_limits.min_acc_y;\n            config.limits.max_acc_theta = default_limits.max_acc_theta;\n            config.limits.min_acc_theta = default_limits.min_acc_theta;\n            config.limits.max_vel_x_backwards = default_limits.max_vel_x_backwards;\n            config.limits.min_vel_x_backwards = default_limits.min_vel_x_backwards;\n            config.limits.max_vel_y_backwards = default_limits.max_vel_y_backwards;\n            config.limits.min_vel_y_backwards = default_limits.min_vel_y_backwards;\n            config.limits.max_vel_theta_backwards = default_limits.max_vel_theta_backwards;\n            config.limits.min_vel_theta_backwards = default_limits.min_vel_theta_backwards;\n            config.limits.max_acc_x_backwards = default_limits.max_acc_x_backwards;\n            config.limits.min_acc_x_backwards = default_limits.min_acc_x_backwards;\n            config.limits", "CodeBleu_score": 27.4633904587719}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup) {\n    if (restore_defaults) {\n      config.min_vel = default_min_vel;\n      config.max_vel = default_max_vel;\n      config.min_acc = default_min_acc;\n      config.max_acc = default_max_acc;\n      config.min_jerk = default_min_jerk;\n      config.max_jerk = default_max_jerk;\n      config.min_yaw_rate = default_min_yaw_rate;\n      config.max_yaw_rate = default_max_yaw_rate;\n      config.min_yaw_acc = default_min_yaw_acc;\n      config.max_yaw_acc = default_max_yaw_acc;\n      config.min_yaw_jerk = default_min_yaw_jerk;\n      config.max_yaw_jerk = default_max_yaw_jerk;\n      config.max_yaw_angle = default_max_yaw_angle;\n      config.max_pitch_angle = default_max_pitch_angle;\n      config.max_roll_angle = default_max_roll_angle;\n      config.max_height = default_max_height;\n      config.max_height_rate = default_max_height_rate;\n      config.max_z_vel = default_max_z_vel;\n      config.max_z_acc = default_max_z_acc;\n      config.max_z_jerk = default_max_z_jerk;\n      config.max_vz_vel = default_max_vz_vel;\n      config.max_vz_acc = default_max_vz_acc;\n      config.max_vz_jerk = default_max_vz_jerk;\n      config.max_vx_vel = default_max_vx_vel;\n      config.max_vx_acc = default_max_vx_acc;\n      config.max_vx_jerk = default_max_vx_jerk;\n      config.max_vy_vel = default_max", "CodeBleu_score": 20.71115870054296}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t    boost::mutex::scoped_lock lock(config_mutex);\n    if (setup_done && restore_defaults) {\n        config = LocalPlannerLimits();\n    } else if (!setup_done) {\n        default_limits = config;\n        setup_done = true;\n    }\n    current_limits = config;\n}", "CodeBleu_score": 62.67073910864492}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_index = check_cell->getIndex();\n  unsigned int obstacle_cost = costmap.getCost(cell_index);\n  unsigned int current_cost = current_cell->getCost();\n\n  if (obstacle_cost >= costmap_2d::LETHAL_OBSTACLE ||\n      obstacle_cost == costmap_2d::INSCRIBED_INFLATED_OBSTACLE ||\n      obstacle_cost == costmap_2d::NO_INFORMATION) {\n    check_cell->setTargetDistance(obstacle_cost);\n    return false;\n  }\n\n  unsigned int new_target_distance = current_cost +\n      (int) (sqrt(check_cell->getX() - current_cell->getX()) +\n          sqrt(check_cell->getY() - current_cell->getY()));\n  if (new_target_distance < check_cell->getTargetDistance()) {\n    check_cell->setTargetDistance(new_target_distance);\n  }\n  return true;\n}", "CodeBleu_score": 52.355273129642924}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  // Check if the cell is an obstacle or has no information.\n  if (check_cell->isObstacle() || check_cell->getCost() == costmap_2d::NO_INFORMATION) {\n    // If the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost.\n    check_cell->setTargetDistance(obstacleCosts_);\n    return false;\n  }\n  // If the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter.\n  double new_distance = current_cell->getTargetDistance() + getCell(check_cell->getX(), check_cell->getY()).getCost();\n  if (new_distance < check_cell->getTargetDistance()) {\n    check_cell->setTargetDistance(new_distance);\n  }\n  return true;\n}", "CodeBleu_score": 43.378068858075274}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int check_cell_idx = check_cell->getIndex();\n  unsigned int current_cell_idx = current_cell->getIndex();\n  unsigned int check_cell_x = check_cell->getX();\n  unsigned int check_cell_y = check_cell->getY();\n  unsigned int current_cell_x = current_cell->getX();\n  unsigned int current_cell_y = current_cell->getY();\n  unsigned int check_cell_cost = check_cell->getCost();\n  unsigned int current_cell_cost = current_cell->getCost();\n  unsigned int check_cell_target = check_cell->getTarget();\n  unsigned int current_cell_target = current_cell->getTarget();\n\n  // Check if the cell is an obstacle or has no information.\n  if (check_cell_cost >= costmap_2d::LETHAL_OBSTACLE || check_cell_cost == costmap_2d::NO_INFORMATION) {\n    // Set the cell's target distance to the maximum obstacle cost.\n    check_cell->setTarget(obstacleCosts_);\n    return false;\n  }\n\n  // Calculate the new target distance.\n  unsigned int new_target = current_cell_target + (current_cell_idx - check_cell_idx) +\n    (current_cell_cost - check_cell_cost);\n\n  // Update the cell's target distance if the new distance is shorter.\n  if (new_target < check_cell_target) {\n    check_cell->setTarget(new_target);\n  }\n\n  return true;\n}", "CodeBleu_score": 47.65378486030267}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"footprint_spec_ is empty\");\n    return -9;\n  }\n\n  double cost = 0;\n  double scaling_factor = getScalingFactor(traj);\n\n  for (int i = 0; i < traj.getPointsSize(); i++) {\n    double footprint_cost = footprintCost(traj.getPoint(i));\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost * scaling_factor;\n}", "CodeBleu_score": 49.003518159068115}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t    double cost = 0.0;\n    double scaling_factor = 0.0;\n    if (footprint_spec_.size() == 0) {\n        ROS_ERROR(\"Empty footprint specification\");\n        return -9.0;\n    }\n    scaling_factor = getScalingFactor(traj);\n    if (scaling_factor == -9.0) {\n        ROS_ERROR(\"Invalid scaling factor\");\n        return -9.0;\n    }\n    for (int i = 0; i < traj.getPointsSize(); i++) {\n        cost += footprintCost(traj.getPoint(i), scaling_factor);\n        if (cost < 0.0) {\n            return cost;\n        }\n    }\n    if (sum_scores_) {\n        return cost;\n    } else {\n        return std::max(0.0, cost);\n    }\n}", "CodeBleu_score": 47.81363560915424}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scaling_factor = 0.0;\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"ObstacleCostFunction: footprint specification is empty\");\n    return -9;\n  }\n  scaling_factor = getScalingFactor(traj);\n  if (scaling_factor < 0.0) {\n    ROS_ERROR(\"ObstacleCostFunction: scaling factor is negative\");\n    return -9;\n  }\n  for (unsigned int i = 0; i < traj.getPointsSize(); i++) {\n    double footprint_cost = footprintCost(traj.getPoint(i));\n    if (footprint_cost < 0.0) {\n      cost = footprint_cost;\n      return cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost * scaling_factor;\n}", "CodeBleu_score": 56.04628223514169}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t  // Check that the costmap is initialized\n  if (!costmap) {\n    ROS_ERROR(\"ObstacleCostFunction::footprintCost: No costmap passed in\");\n    return -1.0;\n  }\n\n  // Check that the world model is initialized\n  if (!world_model) {\n    ROS_ERROR(\"ObstacleCostFunction::footprintCost: No world model passed in\");\n    return -1.0;\n  }\n\n  // Check that the footprint specification is valid\n  if (footprint_spec.size() <= 0) {\n    ROS_ERROR(\"ObstacleCostFunction::footprintCost: No footprint specification passed in\");\n    return -1.0;\n  }\n\n  // Scale the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  scaled_footprint.resize(footprint_spec.size());\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    scaled_footprint[i].x = footprint_spec[i].x * scale;\n    scaled_footprint[i].y = footprint_spec[i].y * scale;\n  }\n\n  // Transform the footprint to the costmap frame\n  std::vector<geometry_msgs::Point> transformed_footprint;\n  transformed_footprint.resize(scaled_footprint.size());\n  for (unsigned int i = 0; i < scaled_footprint.size(); ++i) {\n    transformed_footprint[i] =\n        costmap->worldToMap(scaled_footprint[i].x + x, scaled_footprint[i].y + y);\n  }\n\n  // Check that the transformed footprint is inside the map\n  for (unsigned int i = 0; i < transformed_footprint.size(); ++i) {\n    if (!costmap->isInside(transformed_footprint[i].x, transformed_footprint[i].y)) {\n      return -7.0;\n    }\n  }\n\n  // Compute the cost of the transformed footprint\n  double cost = world_model->foot", "CodeBleu_score": 45.73785260267069}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  // 1. Transform the footprint points into the map frame\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    double x_i = footprint_spec[i].x * scale;\n    double y_i = footprint_spec[i].y * scale;\n    double x_i_m = x + (x_i * cos(th) - y_i * sin(th));\n    double y_i_m = y + (x_i * sin(th) + y_i * cos(th));\n    scaled_footprint.push_back(geometry_msgs::Point(x_i_m, y_i_m));\n  }\n\n  // 2. Check if the robot is off the map\n  if (!costmap->worldToMap(x, y, i, j)) {\n    return -7.0;\n  }\n\n  // 3. Check if the footprint is off the map\n  for (unsigned int i = 0; i < scaled_footprint.size(); i++) {\n    if (!costmap->worldToMap(scaled_footprint[i].x, scaled_footprint[i].y, k, l)) {\n      return -7.0;\n    }\n  }\n\n  // 4. Compute the footprint cost\n  double footprint_cost = world_model->footprintCost(scaled_footprint, costmap, true);\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  // 5. Compute the cell cost\n  double cell_cost = costmap->getCost(i, j);\n\n  // 6. Return the maximum cost\n  return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 65.36451596561086}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  // Check if the position is off the map\n  if (!costmap->isInside(x, y)) {\n    return -7.0;\n  }\n\n  // Check if the position is in the inflated footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point p;\n    p.x = footprint_spec[i].x * scale;\n    p.y = footprint_spec[i].y * scale;\n    scaled_footprint.push_back(p);\n  }\n  if (!world_model->footprintCost(x, y, th, scaled_footprint, costmap)) {\n    return -6.0;\n  }\n\n  // Get the cost of the cell\n  unsigned int mx, my;\n  costmap->worldToMap(x, y, mx, my);\n  double cost = costmap->getCost(mx, my);\n\n  // Return the maximum cost\n  return std::max(-1.0, std::max(cost, footprint_cost_));\n}", "CodeBleu_score": 66.29298199578135}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = gn.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 54.851644122592425}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    // If the new topic differs from the current one, it updates the topic.\n    if (odom_topic != odom_topic_) {\n        odom_topic_ = odom_topic;\n    }\n    // If the new topic is not empty, it subscribes to the new odometry topic with a callback to odomCallback.\n    if (odom_topic_ != \"\") {\n        odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n    // If the new topic is empty, it shuts down the existing subscription.\n    else {\n        odom_sub_.shutdown();\n    }\n}", "CodeBleu_score": 51.715730194447}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    if (odom_topic != odom_topic_) {\n        odom_topic_ = odom_topic;\n        if (odom_topic_ != \"\") {\n            odom_sub_ = gn.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n        } else {\n            odom_sub_.shutdown();\n        }\n    }\n}", "CodeBleu_score": 54.06337755369455}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    if (fabs(pos[0] - prev[0]) > 0.001f) {\n        oscillationX = true;\n    }\n    if (fabs(pos[1] - prev[1]) > 0.001f) {\n        oscillationY = true;\n    }\n    if (fabs(pos[2] - prev[2]) > 0.001f) {\n        oscillationZ = true;\n    }\n    if (fabs(pos[0] - prev[0]) > 0.001f || fabs(pos[1] - prev[1]) > 0.001f || fabs(pos[2] - prev[2]) > 0.001f) {\n        oscillationXYZ = true;\n    }\n    if (fabs(pos[0] - prev[0]) > 0.001f || fabs(pos[1] - prev[1]) > 0.001f || fabs(pos[2] - prev[2]) > 0.001f ||\n        fabs(pos[0] - prev[0]) > 0.001f || fabs(pos[1] - prev[1]) > 0.001f || fabs(pos[2] - prev[2]) > 0.001f) {\n        oscillationXYZXYZ = true;\n    }\n    if (fabs(pos[0] - prev[0]) > 0.001f || fabs(pos[1] - prev[1]) > 0.001f || fabs(pos[2] - prev[2]) > 0.001f ||\n        fabs(pos[0] - prev[0]) > 0.001f || fabs(pos[1] - prev[1]) > 0.001f || fabs(pos[2] - prev[2]) > 0.001f ||\n        fabs(pos[0] - prev[0]) > 0.001f || fabs(pos[1] - prev[1]) > 0.001f", "CodeBleu_score": 30.497927441708157}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  float dist = (pos - prev).squaredNorm();\n  float angle = acosf(prev.dot(pos) / sqrtf(dist));\n  if (dist > 0.0001f && angle > 0.01f) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 30.6342513392987}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    float dist = (pos - prev).squaredNorm();\n    float ang = (pos - prev).normalized().dot((pos - prev).normalized());\n    if (dist > 0.00001) {\n        if (dist > 0.00001 && dist > distThreshold) {\n            oscillationFlags.x = false;\n            oscillationFlags.y = false;\n        }\n        if (ang < 0.99999) {\n            if (ang < 0.99999 && ang > angleThreshold) {\n                oscillationFlags.x = false;\n                oscillationFlags.y = false;\n            }\n        }\n    }\n}", "CodeBleu_score": 34.87200878808229}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    // 1. Determine the grid coordinates of the point\n    int gridCoords[3];\n    if (!getGridCoords(pt, gridCoords)) {\n        return;\n    }\n\n    // 2. Calculate the grid index\n    int gridIndex = getGridIndex(gridCoords);\n\n    // 3. Insert the point into the corresponding cell\n    cells_[gridIndex].push_back(pt);\n}", "CodeBleu_score": 42.287004706970585}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // Determine the grid coordinates of the point.\n  int gridCoords[3];\n  if (!getGridCoords(pt, gridCoords))\n    return;\n\n  // If the coordinates are outside the grid bounds or the point is too\n  // close to its nearest neighbor, the function returns without inserting\n  // the point.\n  if (!isValid(gridCoords))\n    return;\n\n  // Calculate the grid index.\n  int gridIndex = getGridIndex(gridCoords);\n\n  // Insert the point into the corresponding cell.\n  cells_[gridIndex].push_back(pt);\n}", "CodeBleu_score": 44.23645895210334}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    // Determine the grid coordinates of the point.\n    int pt_index = getGridIndex(pt);\n    if (pt_index == -1)\n        return;\n\n    // If the coordinates are outside the grid bounds or the point is too close to its nearest neighbor, the function returns without inserting the point.\n    if (pt_index == -2)\n        return;\n\n    // Calculate the grid index and insert the point into the corresponding cell.\n    int gridIndex = getGridIndex(pt);\n    cells_[gridIndex].push_back(pt);\n}", "CodeBleu_score": 49.877663278366036}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n    } else if (sample_target_vel[i] < vel[i]) {\n      new_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n    } else {\n      new_vel[i] = sample_target_vel[i];\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 75.68582282540632}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = vel[i] + std::min(acclimits[i], sample_target_vel[i] - vel[i]) * dt;\n        }\n        else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = vel[i] - std::min(acclimits[i], vel[i] - sample_target_vel[i]) * dt;\n        }\n        else {\n            new_vel[i] = sample_target_vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 70.25816791717071}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f newvel;\n  newvel.setZero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel(i) > vel(i)) {\n      if (sample_target_vel(i) - vel(i) > acclimits(i)) {\n        newvel(i) = vel(i) + acclimits(i) * dt;\n      } else {\n        newvel(i) = sample_target_vel(i);\n      }\n    } else if (sample_target_vel(i) < vel(i)) {\n      if (vel(i) - sample_target_vel(i) > acclimits(i)) {\n        newvel(i) = vel(i) - acclimits(i) * dt;\n      } else {\n        newvel(i) = sample_target_vel(i);\n      }\n    } else {\n      newvel(i) = sample_target_vel(i);\n    }\n  }\n  return newvel;\n}", "CodeBleu_score": 49.932412932933424}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // get the current cell position\n  int current_x = costmap_.getCostmap()->getCostmap()->getCostmap()->getIndex(x, y);\n  int current_y = current_x - cell_x;\n\n  // get the current heading\n  double current_heading = tf::getYaw(costmap_.getCostmap()->getCostmap()->getCostmap()->getTransform().getRotation());\n\n  // get the current heading in radians\n  double current_heading_radians = angles::to_radians(current_heading);\n\n  // get the current heading in radians\n  double goal_heading_radians = angles::to_radians(heading);\n\n  // get the current heading in radians\n  double delta_heading_radians = angles::shortest_angular_distance(current_heading_radians, goal_heading_radians);\n\n  // get the current heading in radians\n  double delta_heading = angles::to_degrees(delta_heading_radians);\n\n  // get the current heading in radians\n  double delta_heading_radians_2 = angles::to_radians(delta_heading);\n\n  // get the current heading in radians\n  double goal_heading_radians_2 = angles::to_radians(heading);\n\n  // get the current heading in radians\n  double goal_heading_radians_3 = angles::normalize_angle(goal_heading_radians_2);\n\n  // get the current heading in radians\n  double goal_heading_radians_4 = angles::normalize_angle(goal_heading_radians_2);\n\n  // get the current heading in radians\n  double goal_heading_radians_5 = angles::normalize_angle(goal_heading_radians_2);\n\n  // get the current heading in radians\n  double goal_heading_radians_6 = angles::normalize_angle(goal_heading_radians_2);\n\n  // get the current heading in radians\n  double goal_heading_radians_7 = angles::normalize_angle(goal_heading", "CodeBleu_score": 29.166717695430037}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // Get the world coordinates of the current cell\n  double wx = costmap_.getCostmapPtr()->getOriginX() + cell_x * costmap_.getCostmapPtr()->getResolution();\n  double wy = costmap_.getCostmapPtr()->getOriginY() + cell_y * costmap_.getCostmapPtr()->getResolution();\n  // Get the world coordinates of the goal cell\n  double gx = x;\n  double gy = y;\n\n  // Get the direction to the goal cell\n  double dx = gx - wx;\n  double dy = gy - wy;\n  double goal_dir = atan2(dy, dx);\n\n  // Get the current heading of the robot\n  double current_heading = tf::getYaw(transform_.getRotation());\n\n  // Get the direction to the current cell\n  double dir_to_current_cell = angles::normalize_angle(goal_dir - current_heading);\n\n  // Get the direction to the goal cell\n  double dir_to_goal_cell = angles::normalize_angle(current_heading - goal_dir);\n\n  // Get the distance to the goal cell\n  double dist_to_goal_cell = hypot(dx, dy);\n\n  // Check that the goal cell is within the global plan\n  if (dist_to_goal_cell > 1.0) {\n    return DBL_MAX;\n  }\n\n  // Check that the goal cell is within the costmap\n  if (cell_x < 0 || cell_y < 0 || cell_x >= costmap_.getSizeInCellsX() || cell_y >= costmap_.getSizeInCellsY()) {\n    return DBL_MAX;\n  }\n\n  // Check that the goal cell is within the footprint\n  if (!costmap_.worldToMapNoBounds(gx, gy, cell_x, cell_y)) {\n    return DBL_MAX;\n  }\n\n  // Check that the goal cell is not occupied\n  if (costmap_.getCostmapPtr()->getCost(cell_x, cell_y) != costmap_.getCostmapPtr()->getFreeSpace()) {\n    return DBL_MAX;\n  }\n", "CodeBleu_score": 37.88869176463341}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t    double heading_diff = DBL_MAX;\n    double dist = DBL_MAX;\n    double x_goal, y_goal;\n    double heading_goal;\n    double x_current, y_current;\n    double heading_current;\n    double dist_current;\n    int i = 0;\n    int size = global_plan_.size();\n    while (i < size) {\n        x_goal = global_plan_[size - i - 1].x;\n        y_goal = global_plan_[size - i - 1].y;\n        heading_goal = global_plan_[size - i - 1].theta;\n        x_current = x;\n        y_current = y;\n        heading_current = heading;\n        dist_current = atan2(y_goal - y_current, x_goal - x_current);\n        if (dist_current < dist) {\n            dist = dist_current;\n            heading_diff = angles::shortest_angular_distance(heading_current, dist_current);\n        }\n        i++;\n    }\n    return heading_diff;\n}", "CodeBleu_score": 38.00902811175175}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost >= 0.0) {\n    ROS_DEBUG(\"Trajectory is valid\");\n    return true;\n  } else {\n    ROS_WARN(\"Trajectory is invalid, cost = %f, vx_samp = %f, vy_samp = %f, vtheta_samp = %f\",\n        cost, vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }\n}", "CodeBleu_score": 72.96984327168268}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost >= 0.0) {\n    return true;\n  } else {\n    ROS_WARN(\"Trajectory with cost %f rejected. Sample velocities: %f %f %f\", cost, vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }\n}", "CodeBleu_score": 76.79727873756414}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost >= 0) {\n    ROS_DEBUG(\"Trajectory is valid with cost %f\", cost);\n    return true;\n  }\n  else {\n    ROS_WARN(\"Trajectory is invalid with cost %f\", cost);\n    ROS_WARN(\"Sample velocities: vx = %f, vy = %f, vtheta = %f\", vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }\n}", "CodeBleu_score": 70.47254133894083}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, or has already run.\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized with a global and/or local costmap.\");\n    return;\n  }\n\n  // Check if we are clearing inside or outside the specified area.\n  if (affected_maps_ == AFFECTED_GLOBAL_COSTMAP) {\n    ROS_WARN(\"Clearing inside the global costmap.\");\n  } else if (affected_maps_ == AFFECTED_LOCAL_COSTMAP) {\n    ROS_WARN(\"Clearing inside the local costmap.\");\n  } else if (affected_maps_ == AFFECTED_GLOBAL_AND_LOCAL_COSTMAPS) {\n    ROS_WARN(\"Clearing inside the global and local costmaps.\");\n  } else {\n    ROS_WARN(\"Clearing outside the global and local costmaps.\");\n  }\n\n  // Clear the costmaps.\n  ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_ == AFFECTED_GLOBAL_COSTMAP || affected_maps_ == AFFECTED_GLOBAL_AND_LOCAL_COSTMAPS) {\n    global_costmap_->clearCostmap(force_update_);\n    ROS_DEBUG(\"Cleared global costmap in %f seconds.\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if (affected_maps_ == AFFECTED_LOCAL_COSTMAP || affected_maps_ == AFFECTED_GLOBAL_AND_LOCAL_COSTMAPS) {\n    local_costmap_->clearCostmap(force_update_);\n    ROS_DEBUG(\"Cleared local costmap in %f seconds.\", (ros::WallTime::now() - t0).toSec());\n  }\n}", "CodeBleu_score": 51.759889473691075}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized.  Please call initialize() before running this behavior.\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"Global costmap has not been set.  Please call setGlobalCostmap() before running this behavior.\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"Local costmap has not been set.  Please call setLocalCostmap() before running this behavior.\");\n    return;\n  }\n\n  if (affected_maps_.empty()) {\n    ROS_ERROR(\"No affected costmaps have been set.  Please call setAffectedMaps() before running this behavior.\");\n    return;\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside the specified area.\");\n  } else {\n    ROS_WARN(\"Clearing inside the specified area.\");\n  }\n\n  if (affected_maps_.find(\"global\") != affected_maps_.end()) {\n    if (invert_area_to_clear_) {\n      global_costmap_->updateOrigin(global_costmap_->getOriginX() - area_to_clear_.getX(), global_costmap_->getOriginY() - area_to_clear_.getY());\n    } else {\n      global_costmap_->updateOrigin(global_costmap_->getOriginX() + area_to_clear_.getX(), global_costmap_->getOriginY() + area_to_clear_.getY());\n    }\n    global_costmap_->updateMap(force_update_);\n  }\n\n  if (affected_maps_.find(\"local\") != affected_maps_.end()) {\n    if (invert_area_to_clear_) {\n      local_costmap_->updateOrigin(local_costmap_->getOriginX() - area_to_clear_.getX(), local_costmap_->getOriginY() - area_to_clear_.getY", "CodeBleu_score": 43.124859890760966}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before runBehavior().\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been given a global costmap pointer, please call setGlobalCostmap() before runBehavior().\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been given a local costmap pointer, please call setLocalCostmap() before runBehavior().\");\n    return;\n  }\n\n  if (affected_maps_.size() == 0) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been given affected costmaps to clear, please call setAffectedMaps() before runBehavior().\");\n    return;\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside the specified area.\");\n  } else {\n    ROS_WARN(\"Clearing inside the specified area.\");\n  }\n\n  for (std::vector<std::string>::iterator it = affected_maps_.begin(); it != affected_maps_.end(); ++it) {\n    if (invert_area_to_clear_) {\n      ROS_WARN(\"Clearing %s.\", it->c_str());\n      if (it->compare(\"global\") == 0) {\n        if (force_update_) {\n          global_costmap_->clearCostmap();\n          global_costmap_->updateCostmap();\n        } else {\n          global_costmap_->clearCostmap();\n        }\n      } else if (it->compare(\"local\") == 0) {\n        if (force_update_) {\n          local_costmap_->clearCostmap();\n          local_costmap_->updateCostmap();\n        } else {\n          local_costmap_->clearCostmap();\n        }\n      } else {\n        ROS_ERROR(\"Invalid affected map %s.\", it->c_str());\n", "CodeBleu_score": 43.6621835969011}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  polygon_cells.clear();\n  if (polygon.empty()) {\n    return;\n  }\n  polygon_cells.reserve(polygon.size());\n  // First, we iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points.\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    MapLocation p1 = polygon[i];\n    MapLocation p2;\n    if (i == polygon.size() - 1) {\n      p2 = polygon[0];\n    } else {\n      p2 = polygon[i + 1];\n    }\n    raytraceLine(p1, p2, polygon_cells);\n  }\n  // If the polygon is not empty, we also close the polygon by connecting the last point to the first.\n  if (!polygon_cells.empty()) {\n    polygon_cells.push_back(polygon_cells[0]);\n  }\n}", "CodeBleu_score": 50.80340419896129}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  polygon_cells.clear();\n  if (polygon.empty()) {\n    return;\n  }\n  PolygonOutlineCells polygon_outline_cells;\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    polygon_outline_cells.raytraceLine(polygon[i], polygon[(i + 1) % polygon.size()]);\n  }\n  polygon_outline_cells.closePolygon(polygon[0]);\n  polygon_cells = polygon_outline_cells.cells;\n}", "CodeBleu_score": 47.42964868768149}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t// polygonOutlineCells(const std::vector<MapLocation>& polygon, PolygonOutlineCells& polygon_cells)\n\t// polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\n\n\t// The polygon_cells object is used to collect the cells that form the outline of the polygon.\n\t// PolygonOutlineCells polygon_cells;\n\n\t// The polygon_cells vector is used to collect the cells that form the outline of the polygon.\n\t// std::vector<MapLocation> polygon_cells;\n\n\t// If the polygon is not empty, it also closes the polygon by connecting the last point to the first.\n\tif (!polygon.empty()) {\n\t\t// polygonOutlineCells(const std::vector<MapLocation>& polygon, PolygonOutlineCells& polygon_cells)\n\t\t// polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\n\n\t\t// The polygon_cells object is used to collect the cells that form the outline of the polygon.\n\t\t// PolygonOutlineCells polygon_cells;\n\n\t\t// The polygon_cells vector is used to collect the cells that form the outline of the polygon.\n\t\t// std::vector<MapLocation> polygon_cells;\n\n\t\t// If the polygon is not empty, it also closes the polygon by connecting the last point to the first.\n\t\tif (!polygon.empty()) {\n\t\t\t// polygonOutlineCells(const std::vector<MapLocation>& polygon, PolygonOutlineCells& polygon_cells)\n\t\t\t// polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\n\n\t\t\t// The polygon_cells object is used to collect the cells that form the outline of the polygon.\n\t\t\t// PolygonOutlineCells polygon_cells;\n\n\t\t\t// The polygon_cells vector is used to collect the cells that form the outline of the polygon.\n\t\t\t// std::vector<MapLocation> polygon_cells;\n\n\t\t\t// If the polygon is not empty, it also clos", "CodeBleu_score": 11.643619167316931}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_msg_);\n}", "CodeBleu_score": 73.2903068867566}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  publishGrid(pub);\n}", "CodeBleu_score": 64.0116239279494}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // Lock the costmap mutex\n  costmap_->getMutex()->lock();\n\n  // Retrieve the resolution\n  double resolution = costmap_->getResolution();\n\n  // Set the grid's header\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.header.stamp = ros::Time::now();\n\n  // Set the grid's resolution\n  grid_.info.resolution = resolution;\n\n  // Set the grid's width and height\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Set the grid's origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = translation_table_[costmap_->getCharMap()[i]];\n  }\n\n  // Unlock the costmap mutex\n  costmap_->getMutex()->unlock();\n}", "CodeBleu_score": 63.924775338348816}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // Lock the costmap mutex\n  costmap_->getMutex()->lock();\n  // Retrieve the costmap resolution\n  double resolution = costmap_->getResolution();\n  // Set the grid's header\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.header.stamp = ros::Time::now();\n  // Set the grid's resolution\n  grid_.info.resolution = resolution;\n  // Set the grid's width and height\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  // Set the grid's origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  // Save the origin coordinates\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  // Populate the grid data from the costmap's character map\n  for (int i = 0; i < grid_.info.width * grid_.info.height; ++i) {\n    grid_.data[i] = translation_table_[costmap_->getCharMap()[i]];\n  }\n  // Unlock the costmap mutex\n  costmap_->getMutex()->unlock();\n}", "CodeBleu_score": 60.934219407062315}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // Lock the costmap mutex and retrieve the resolution\n  costmap_->getMutex()->lock();\n  double resolution = costmap_->getResolution();\n  costmap_->getMutex()->unlock();\n\n  // Set the grid's header, resolution, width, and height\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Convert the map coordinates to world coordinates for the origin and set the origin's position and orientation\n  double origin_x, origin_y, origin_theta;\n  costmap_->mapToWorld(0, 0, origin_x, origin_y);\n  costmap_->getOriginX(origin_x);\n  costmap_->getOriginY(origin_y);\n  costmap_->getOriginOrientation(origin_theta);\n  grid_.info.origin.position.x = origin_x;\n  grid_.info.origin.position.y = origin_y;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = sin(origin_theta / 2.0);\n  grid_.info.origin.orientation.w = cos(origin_theta / 2.0);\n\n  // Save the origin coordinates and resize the grid data vector\n  costmap_->getMutex()->lock();\n  costmap_->getOriginX(origin_x);\n  costmap_->getOriginY(origin_y);\n  costmap_->getMutex()->unlock();\n  origin_x_ = origin_x;\n  origin_y_ = origin_y;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  for (int y = 0; y < grid", "CodeBleu_score": 59.19322506410587}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n  if (new_config.footprint.size() > 0) {\n    if (makeFootprintFromString(new_config.footprint)) {\n      ROS_INFO(\"Footprint set to: %s\", new_config.footprint.c_str());\n    } else {\n      ROS_ERROR(\"Invalid footprint string: %s\", new_config.footprint.c_str());\n    }\n  } else {\n    if (makeFootprintFromRadius(new_config.robot_radius)) {\n      ROS_INFO(\"Footprint set to circle of radius %f\", new_config.robot_radius);\n    } else {\n      ROS_ERROR(\"Invalid radius for footprint: %f\", new_config.robot_radius);\n    }\n  }\n}", "CodeBleu_score": 64.26753402116054}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint_padding == old_config.footprint_padding &&\n      new_config.robot_radius == old_config.robot_radius)\n    return;\n  std::string footprint_string = new_config.footprint_padding;\n  if (footprint_string.empty())\n    footprint_string = std::to_string(new_config.robot_radius);\n  if (!makeFootprintFromString(footprint_string))\n    ROS_ERROR(\"Failed to make footprint from string %s\", footprint_string.c_str());\n  else\n    ROS_DEBUG(\"Made footprint from string %s\", footprint_string.c_str());\n}", "CodeBleu_score": 46.98033279767297}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint_padding == old_config.footprint_padding &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (!new_config.footprint_padding) {\n    ROS_ERROR(\"Costmap2DROS::readFootprintFromConfig: footprint_padding not set in configuration\");\n    return;\n  }\n\n  if (!new_config.robot_radius) {\n    ROS_ERROR(\"Costmap2DROS::readFootprintFromConfig: robot_radius not set in configuration\");\n    return;\n  }\n\n  if (!new_config.footprint_padding && !new_config.robot_radius) {\n    ROS_ERROR(\"Costmap2DROS::readFootprintFromConfig: footprint_padding and robot_radius not set in configuration\");\n    return;\n  }\n\n  if (new_config.footprint_padding && new_config.robot_radius) {\n    ROS_WARN(\"Costmap2DROS::readFootprintFromConfig: footprint_padding and robot_radius are both set in configuration; using footprint_padding\");\n  }\n\n  if (new_config.footprint_padding) {\n    makeFootprintFromRadius(new_config.footprint_padding, footprint_);\n  } else {\n    makeFootprintFromRadius(new_config.robot_radius, footprint_);\n  }\n}", "CodeBleu_score": 55.22533732948344}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tgeometry_msgs::PoseStamped new_pose;\n\tif (!tf_->canTransform(global_frame_, costmap_->getBaseFrame(), ros::Time(0))) {\n\t\tROS_WARN_THROTTLE(1.0, \"Could not transform from %s to %s\", global_frame_.c_str(), costmap_->getBaseFrame().c_str());\n\t\treturn;\n\t}\n\ttry {\n\t\ttf_->transformPose(costmap_->getBaseFrame(), ros::Time(0), global_frame_, ros::Duration(0.0), new_pose);\n\t}\n\tcatch (tf::TransformException ex) {\n\t\tROS_WARN_THROTTLE(1.0, \"Could not transform from %s to %s\", global_frame_.c_str(), costmap_->getBaseFrame().c_str());\n\t\treturn;\n\t}\n\tcostmap_->setRobotPose(new_pose);\n}", "CodeBleu_score": 51.13812067634207}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  boost::recursive_mutex::scoped_lock l(configuration_mutex_);\n  if (!getRobotPose(new_pose_)) {\n    ROS_WARN_THROTTLE(1, \"Could not get robot pose. Cancelling reconfigure.\");\n    return;\n  }\n  new_pose_.header.stamp = ros::Time::now();\n  new_pose_.header.frame_id = global_frame_;\n  new_pose_.header.seq++;\n  new_pose_.header.seq %= 1000;\n}", "CodeBleu_score": 57.808448897998254}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  // ROS_INFO(\"Movement callback\");\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1, \"Could not get robot pose, cancelling reconfigure.\");\n    reconfigure_mutex_.unlock();\n    return;\n  }\n  if (!new_pose.getOrigin().isValid()) {\n    ROS_WARN_THROTTLE(1, \"Could not get robot pose, cancelling reconfigure.\");\n    reconfigure_mutex_.unlock();\n    return;\n  }\n  // ROS_INFO(\"Got robot pose\");\n  if (new_pose.getOrigin().distance(old_pose.getOrigin()) > 0.01) {\n    // ROS_INFO(\"Robot moved, reconfiguring\");\n    reconfigure_mutex_.unlock();\n    reconfigure_mutex_.lock();\n    reconfigure_ = true;\n    reconfigure_mutex_.unlock();\n  }\n  else {\n    // ROS_INFO(\"Robot did not move, not reconfiguring\");\n    reconfigure_mutex_.unlock();\n  }\n}", "CodeBleu_score": 59.97743004364855}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  ROS_INFO(\"Starting the costmap\");\n  // Retrieve the list of plugins\n  std::vector<BaseLayer*> plugins = getPlugins();\n  // Check if the costmap was stopped\n  if (stopped_) {\n    // If stopped, re-subscribe to topics by activating each plugin and set the stopped flag to false\n    for (unsigned int i = 0; i < plugins.size(); ++i) {\n      plugins[i]->activate();\n    }\n    stopped_ = false;\n  }\n  // Set stop_updates_ to false\n  stop_updates_ = false;\n  // Wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::ok() || !initialized_ || !update_thread_.isRunning()) {\n    ros::spinOnce();\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 52.42353401270101}, {"code": "void Costmap2DROS::start(){\n\t  ROS_DEBUG(\"Starting costmap\");\n  boost::recursive_mutex::scoped_lock l(lock_);\n  if (stopped_) {\n    ROS_DEBUG(\"Re-activating plugins\");\n    // reactivate the plugins\n    for (std::vector<Costmap2DLayer*>::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n    ROS_DEBUG(\"Starting update thread\");\n    // start the map update thread\n    map_update_thread_.start();\n  }\n  // wait until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::ok() || !initialized_ || !map_update_thread_.isRunning()) {\n    ros::WallDuration(0.1).sleep();\n  }\n}", "CodeBleu_score": 52.06891805536572}, {"code": "void Costmap2DROS::start(){\n\t  ROS_INFO(\"Starting costmap2d\");\n  ROS_INFO(\"Reactivating costmap plugins\");\n  for (unsigned int i = 0; i < plugins_.size(); ++i) {\n    plugins_[i]->activate();\n  }\n  ROS_INFO(\"Costmap2d started\");\n  stop_updates_ = false;\n\n  // Wait until ROS is running and the costmap is initialized\n  while (!ros::ok() || !initialized_) {\n    ros::spinOnce();\n    ros::Duration(0.1).sleep();\n  }\n\n  // Wait until the map update thread is active\n  while (!map_update_thread_.joinable()) {\n    ros::spinOnce();\n    ros::Duration(0.1).sleep();\n  }\n}", "CodeBleu_score": 43.6302404275584}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  // Check if the observation_keep_time_ is zero\n  if (observation_keep_time_.toSec() == 0.0) {\n    // If so, remove all but the most recent observation\n    while (observation_list_.size() > 1) {\n      observation_list_.pop_front();\n    }\n  } else {\n    // If not, iterate through the list and remove observations that are older than the specified keep time\n    ros::Time current_time = ros::Time::now();\n    ros::Duration keep_time = observation_keep_time_;\n    ros::Duration age;\n    while (observation_list_.size() > 1) {\n      age = current_time - observation_list_.front().header.stamp;\n      if (age <= keep_time) {\n        break;\n      } else {\n        observation_list_.pop_front();\n      }\n    }\n  }\n}", "CodeBleu_score": 39.20338305742286}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == 0) {\n    observation_list_.clear();\n  } else {\n    observation_list_.erase(\n        std::remove_if(observation_list_.begin(), observation_list_.end(),\n                       [this](const Observation& obs) {\n                         return ros::Time::now() - obs.time >\n                                observation_keep_time_;\n                       }),\n        observation_list_.end());\n  }\n}", "CodeBleu_score": 34.488334508993354}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == 0) {\n    observation_list_.clear();\n  } else {\n    observation_list_.erase(std::remove_if(observation_list_.begin(), observation_list_.end(), [this](const Observation &observation) {\n      return observation.observation_time + observation_keep_time_ < ros::Time::now();\n    }), observation_list_.end());\n  }\n}", "CodeBleu_score": 32.1964232411233}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  double start_yaw, end_yaw;\n  double shortest_distance;\n  double incremental_angle;\n  double current_yaw;\n\n  // Calculate the yaw angles at the start and end indices\n  start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the yaw angles\n  shortest_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Compute the incremental change in angle for each pose\n  incremental_angle = shortest_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index; i < end_index; i++) {\n    current_yaw = angles::normalize_angle(start_yaw + incremental_angle * (i - start_index));\n    set_angle(path[i].pose.orientation, current_yaw);\n  }\n}", "CodeBleu_score": 55.33282720061358}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  // TODO: Implement this function\n  // get the start and end yaw angles\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // calculate the shortest angular distance between the start and end yaw angles\n  double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // calculate the incremental change in yaw angle for each pose\n  double delta_yaw_per_pose = delta_yaw / (end_index - start_index);\n\n  // update the orientation of each pose in the specified range\n  for (int i = start_index; i < end_index; i++) {\n    set_angle(path[i].pose.orientation, start_yaw + delta_yaw_per_pose * (i - start_index));\n  }\n}", "CodeBleu_score": 64.45459240968485}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  // Get the yaw angles of the start and end pose\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Calculate the shortest angular distance between the two yaw angles\n  double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Calculate the incremental change in yaw angle for each pose\n  double delta_yaw_increment = delta_yaw / (end_index - start_index);\n\n  // Interpolate the yaw angle of each pose in the specified range\n  for (int i = start_index; i < end_index; i++) {\n    set_angle(path[i], start_yaw + delta_yaw_increment * (i - start_index));\n  }\n}", "CodeBleu_score": 65.57289802847154}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\n\t// Set the frame_id to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tbool success = makePlan(req.start, req.goal, resp.plan.header.frame_id, resp.plan.header.stamp, resp.plan.poses);\n\n\t// Update the response with the success status and the generated path if a plan is found\n\tresp.plan_found = success;\n\tif (success) {\n\t\tresp.plan.header.seq++;\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 66.29945774510229}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\n    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    nav_msgs::Path path = makePlan(req.start, req.goal);\n\n    // Update the response with the success status and the generated path\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.poses = path.poses;\n\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 54.86545632038254}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  ROS_INFO(\"Received request to make a plan\");\n\n  // Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  nav_msgs::Path path = makePlan(req.start, req.goal);\n\n  // Update the response with the success status and the generated path if a plan is found\n  resp.plan.header.frame_id = \"map\";\n  resp.plan.poses = path.poses;\n  resp.plan_found = !path.poses.empty();\n\n  return true;\n}", "CodeBleu_score": 54.696250301612814}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh.setCallbackQueue(&queue_);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 67.6861572867575}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh.setParam(\"global_planner\", name);\n    private_nh.setParam(\"global_frame\", cmap->getGlobalFrameID());\n    private_nh.setParam(\"robot_base_frame\", cmap->getBaseFrameID());\n    private_nh.setParam(\"is_2d\", true);\n    private_nh.setParam(\"is_debug\", false);\n\n    // Initialize the planner's costmap\n    costmap_ = cmap->getCostmap();\n\n    // Initialize the planner's tf\n    tf_ = new tf::TransformListener();\n\n    // Initialize the planner's service\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n    // Initialize the planner's subscriber\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n\n    // Initialize the planner's publisher\n    plan_pub_ = private_nh.advertise<nav_msgs::Path>(\"plan\", 1);\n\n    // Initialize the planner's frame transformer\n    tf_ = new tf::TransformListener();\n\n    // Initialize the planner's costmap\n    costmap_ = cmap->getCostmap();\n\n    // Initialize the planner's goal\n    goal_ = geometry_msgs::PoseStamped();\n\n    // Initialize the planner's plan\n    plan_ = nav_msgs::Path();\n\n    // Initialize the planner's start\n    start_ = geometry_msgs::PoseStamped();\n\n    // Initialize the planner's global frame ID\n    global_frame_id_ = cmap->getGlobalFrameID();\n\n    // Initialize the planner's base frame ID\n    base_frame_id_ = cmap->getBaseFrameID();\n\n    // Initialize the planner's costmap resolution\n    resolution_ = costmap_->getResolution();\n\n    // Initialize the planner's costmap size", "CodeBleu_score": 55.55686077682286}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh.setCallbackQueue(&queue_);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n    costmap_ = cmap;\n    costmap_ros_ = cmap;\n    costmap_ros_->waitForSubscribers();\n    costmap_ros_->getCostmap()->resetLayers();\n    costmap_ros_->getCostmap()->updateOrigin(costmap_ros_->getCostmap()->getOriginX(), costmap_ros_->getCostmap()->getOriginY());\n    costmap_ros_->getCostmap()->updateSize();\n    costmap_ros_->getCostmap()->updateVoxels();\n    costmap_ros_->getCostmap()->update();\n    costmap_ros_->getCostmap()->updateVoxels();\n    costmap_ros_->getCostmap()->update();\n    costmap_ros_->getCostmap()->updateVoxels();\n    costmap_ros_->getCostmap()->update();\n    costmap_ros_->getCostmap()->updateVoxels();\n    costmap_ros_->getCostmap()->update();\n    costmap_ros_->getCostmap()->updateVoxels();\n    costmap_ros_->getCostmap()->update();\n    costmap_ros_->getCostmap()->updateVoxels();\n    costmap_ros_->getCostmap()->update();\n    costmap_ros_->getCostmap()->updateVoxels();\n    costmap_ros_->getCostmap()->update();\n    costmap_ros_->getCostmap()->updateVoxels();\n    costmap_ros_->getCostmap()->update();\n    costmap_ros_->getCostmap()->updateVoxels();\n    costmap_ros_->getCostmap()->update();\n    costmap_ros_->getCostmap()->updateVoxels();\n    costmap_ros_->getCostmap()->update();", "CodeBleu_score": 55.2403248009679}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < 0 || wx >= costmap_->getSizeInMetersX() || wy < 0 || wy >= costmap_->getSizeInMetersY()) {\n    ROS_DEBUG(\"GlobalPlanner: worldToMap: world coordinates (%f, %f) are out of bounds\", wx, wy);\n    return false;\n  }\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  if (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n    ROS_DEBUG(\"GlobalPlanner: worldToMap: map coordinates (%f, %f) are out of bounds\", mx, my);\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 45.391253529630895}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (!costmap_ || !costmap_->getSizeInMetersX() || !costmap_->getSizeInMetersY()) {\n    ROS_ERROR(\"GlobalPlanner: worldToMap: No costmap or size in meters.\");\n    return false;\n  }\n\n  // Check if the world coordinates are within the costmap's bounds.\n  if (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    ROS_WARN(\"GlobalPlanner: worldToMap: World coordinates (%f, %f) are out of bounds.\", wx, wy);\n    return false;\n  }\n\n  // Calculate the map coordinates.\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // Check if the map coordinates are within the costmap's size limits.\n  if (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n    ROS_WARN(\"GlobalPlanner: worldToMap: Map coordinates (%f, %f) are out of bounds.\", mx, my);\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 42.03219963324823}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < 0 || wx > getSizeInMetersX() || wy < 0 || wy > getSizeInMetersY()) {\n    ROS_ERROR(\"GlobalPlanner::worldToMap: World coordinates out of bounds.\");\n    return false;\n  }\n\n  mx = wx / getResolution() + getOriginX();\n  my = wy / getResolution() + getOriginY();\n\n  return true;\n}", "CodeBleu_score": 28.131699377711538}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = planner_frame_;\n  gui_path.header.stamp = ros::Time::now();\n  gui_path.poses.resize(path.size());\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 81.70922123231271}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if(!initialized_) {\n    ROS_ERROR(\"Planner not initialized. Cannot publish plan.\");\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n  gui_path.poses = path;\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 43.152910095282806}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\n    // Check if the planner is initialized\n    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, please call initialize() before using this planner\");\n        return;\n    }\n\n    // Create a Path message and fill it with the path poses\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = map_frame_;\n    gui_path.header.stamp = ros::Time::now();\n    gui_path.poses = path;\n\n    // Publish the path message\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 51.4243889795157}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"Wrapping the goal in an action goal\");\n\tmove_base_msgs::MoveBaseActionGoal goal_msg;\n\tgoal_msg.header.stamp = ros::Time::now();\n\tgoal_msg.goal.target_pose = *goal;\n\tROS_DEBUG_NAMED(\"move_base\", \"Publishing the goal\");\n\taction_goal_pub_.publish(goal_msg);\n}", "CodeBleu_score": 57.10667080245509}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Received new goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 74.91834724444351}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Received new goal\");\n  move_base_msgs::MoveBaseActionGoal goal_msg;\n  goal_msg.header.stamp = ros::Time::now();\n  goal_msg.target_pose = *goal;\n  action_goal_pub_.publish(goal_msg);\n}", "CodeBleu_score": 56.5208329056931}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  ROS_INFO(\"Distance check triggered\");\n  if (getSqDistance() > distance_sq_limit_) {\n    ROS_INFO(\"Distance check passed\");\n    distance_check_timer_.stop();\n    if (remove_limit_thread_->joinable()) {\n      ROS_INFO(\"Joining remove limit thread\");\n      remove_limit_thread_->join();\n    }\n    ROS_INFO(\"Starting new remove limit thread\");\n    remove_limit_thread_ = std::make_unique<std::thread>(&MoveSlowAndClear::removeSpeedLimit, this);\n  }\n}", "CodeBleu_score": 52.57500124081379}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  // Check if the robot has moved far enough\n  if (getSqDistance(start_pos_, current_pos_) >= limit_distance_) {\n    // Log a message\n    ROS_INFO(\"Moving slow and clear: Robot has moved far enough, stopping distance check.\");\n    // Join and delete any existing remove limit thread\n    if (remove_limit_thread_->joinable()) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    // Start a new thread to remove the speed limit\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    // Stop the distance check timer\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 59.3897813663089}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  // Check if the robot has moved far enough\n  if (getSqDistance() > sq_limit_dist_) {\n    ROS_INFO(\"Distance check passed. Removing speed limit.\");\n    // Join and delete any existing remove limit thread\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    // Start a new thread to remove the speed limit\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    // Stop the distance check timer\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 63.004831289692376}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get current robot pose\n  geometry_msgs::PoseStamped current_pose = cmap_->getRobotPose();\n\n  // Get the current goal pose\n  geometry_msgs::PoseStamped goal_pose = *goal;\n\n  // Create a path vector\n  std::vector<geometry_msgs::PoseStamped> path;\n\n  // Create a path from the current pose to the goal pose\n  makePlan(current_pose, goal_pose, path);\n\n  // Publish the path\n  path_pub_.publish(path);\n}", "CodeBleu_score": 49.68614342010586}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    if (planner_->isNearGoal(goal->pose.position, global_pose_)) {\n        ROS_WARN(\"Robot is already near goal pose\");\n        return;\n    }\n    ROS_INFO(\"Received goal pose\");\n    // get current robot pose\n    geometry_msgs::PoseStamped global_pose;\n    global_pose.header.frame_id = global_frame_;\n    global_pose.header.stamp = ros::Time::now();\n    cmap_->getRobotPose(global_pose.pose);\n    // generate a path from current pose to goal pose\n    std::vector<geometry_msgs::PoseStamped> path;\n    makePlan(global_pose, *goal, path);\n    // if path is empty, return\n    if (path.empty()) {\n        ROS_WARN(\"No path found\");\n        return;\n    }\n    // if path is not empty, publish path\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = global_frame_;\n    path_msg.header.stamp = ros::Time::now();\n    path_msg.poses = path;\n    path_pub_.publish(path_msg);\n}", "CodeBleu_score": 52.79224892002322}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the current global pose of the robot\n  geometry_msgs::PoseStamped robot_pose = cmap_->getRobotPose();\n  // Generate a path from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> path = makePlan(robot_pose, *goal, std::vector<geometry_msgs::PoseStamped>());\n  // If a path was successfully generated, publish it\n  if (!path.empty()) {\n    navfn_path_pub_.publish(path);\n  }\n}", "CodeBleu_score": 48.13594537337017}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\n  // Create a ParamSet service request\n  mavros_msgs::ParamSet srv;\n\n  // Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n  srv.request.param_id = param_set.param_id;\n  srv.request.value = param_set.value;\n\n  // Call the param_set_client_ to send the request\n  this->param_set_client_.call(srv);\n\n}", "CodeBleu_score": 79.33475094824928}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tthis->param_set_client_.call(param_set);\n}", "CodeBleu_score": 18.892130830356862}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\n    // Create a ParamSet service request\n    mavros_msgs::ParamSet::Request request;\n\n    // Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n    request.param_id = param_set.param_id;\n    request.value = param_set.value;\n\n    // Call the param_set_client_ to send the request\n    this->param_set_client_.call(request);\n}", "CodeBleu_score": 60.51553209213687}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\t// wait for a connection from the ground station\n\twaitConnectionFromGroundStation();\n\t// enter a loop to accept incoming connections, receive data, and process it\n\twhile (true) {\n\t\t// accept a connection\n\t\taccept();\n\t\t// receive data\n\t\tint n = recv(sockfd, (char*)&msg, sizeof(msg), 0);\n\t\t// if data is received successfully\n\t\tif (n > 0) {\n\t\t\t// decode the message\n\t\t\tdecodeMsg();\n\t\t\t// publish the message\n\t\t\tpubMsg();\n\t\t}\n\t\t// if the received message length is zero or less\n\t\telse if (n <= 0) {\n\t\t\t// log an error\n\t\t\tROS_ERROR(\"Error receiving data from ground station\");\n\t\t\t// close the socket\n\t\t\tclose(sockfd);\n\t\t\t// exit the function\n\t\t\texit(1);\n\t\t}\n\t}\n}", "CodeBleu_score": 23.205902320841346}, {"code": "void CommunicationBridge::serverFun(){\n\t    // Wait for connection from ground station\n    waitConnectionFromGroundStation();\n    // Loop to accept connections, receive data, and process it\n    while (true) {\n        // Accept connection\n        accept();\n        // Receive data\n        recv();\n        // Decode data\n        decodeMsg();\n        // Publish data\n        pubMsg();\n        // Close connection\n        close();\n    }\n}", "CodeBleu_score": 2.926340434221926}, {"code": "void CommunicationBridge::serverFun(){\n\t    // Wait for a connection from the ground station\n    waitConnectionFromGroundStation();\n\n    // Enter a loop to accept incoming connections, receive data, and process it\n    while (true) {\n        // Accept an incoming connection\n        accept();\n\n        // Receive data from the socket\n        recv();\n\n        // Decode the received message\n        decodeMsg();\n\n        // Publish the decoded message\n        pubMsg();\n    }\n}", "CodeBleu_score": 2.8440695783842838}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (this->simulation_mode_) {\n    for (auto it = this->swarm_control_simulation_.begin(); it != this->swarm_control_simulation_.end(); it++) {\n      if (it->first == uav_cmd.uav_id) {\n        (*it).second->uavCmdPub.publish(uav_cmd);\n      }\n    }\n  } else {\n    this->uav_basic_->uavCmdPub.publish(uav_cmd);\n  }\n}", "CodeBleu_score": 49.78133498183461}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (!this->simulation_mode_) {\n    this->uav_basic_->uavCmdPub.publish(uav_cmd);\n  } else {\n    auto it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n    if (it != this->swarm_control_simulation_.end()) {\n      (*it).second->uavCmdPub.publish(uav_cmd);\n    } else {\n      ROS_ERROR(\"No UAV with ID %d found in simulation mode!\", uav_cmd.uav_id);\n    }\n  }\n}", "CodeBleu_score": 58.17519171822693}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (!this->simulation_mode_) {\n    this->uav_basic_->uavCmdPub.publish(uav_cmd);\n  } else {\n    for (auto it = this->swarm_control_simulation_.begin(); it != this->swarm_control_simulation_.end(); ++it) {\n      if (uav_cmd.uavID == (*it).first) {\n        (*it).second->uavCmdPub.publish(uav_cmd);\n      }\n    }\n  }\n}", "CodeBleu_score": 49.57638470778395}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch(mode_selection.mode) {\n\t\tcase 0:\n\t\t\t// reboot\n\t\t\tsystem(\"reboot\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t// exit\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t// create mode\n\t\t\tcreateMode(mode_selection.use_mode);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t// delete mode\n\t\t\tdeleteMode(mode_selection.use_mode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// error\n\t\t\tcout << \"Error: Invalid mode selection.\" << endl;\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 24.35080921972258}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\t// If the mode is reboot, execute a system reboot\n\tif (mode_selection.mode == REBOOTNX) {\n\t\tsystem(mode_selection.mode_string);\n\t}\n\n\t// If the mode is exit, execute a system exit\n\tif (mode_selection.mode == EXITNX) {\n\t\tsystem(mode_selection.mode_string);\n\t}\n\n\t// If the mode is create, execute createMode\n\tif (mode_selection.mode == CREATE) {\n\t\tcreateMode(mode_selection.mode_string);\n\t}\n\n\t// If the mode is delete, execute deleteMode\n\tif (mode_selection.mode == DELETE) {\n\t\tdeleteMode(mode_selection.mode_string);\n\t}\n}", "CodeBleu_score": 46.77342064805649}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    switch (mode_selection.mode) {\n        case REBOOTNX:\n            system(\"reboot\");\n            break;\n        case EXITNX:\n            system(\"exit\");\n            break;\n        case CREATE:\n            createMode(mode_selection.use_mode);\n            break;\n        case DELETE:\n            deleteMode(mode_selection.use_mode);\n            break;\n        default:\n            break;\n    }\n}", "CodeBleu_score": 35.500857857669374}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\n    if (heartbeat_count == 0) {\n        ROS_WARN(\"No heartbeat received from vehicle. Attempting to reconnect.\");\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count == 1) {\n        ROS_WARN(\"No heartbeat received from vehicle. Attempting to reconnect.\");\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count == 2) {\n        ROS_WARN(\"No heartbeat received from vehicle. Attempting to reconnect.\");\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count == 3) {\n        ROS_WARN(\"No heartbeat received from vehicle. Attempting to reconnect.\");\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count == 4) {\n        ROS_WARN(\"No heartbeat received from vehicle. Attempting to reconnect.\");\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count == 5) {\n        ROS_WARN(\"No heartbeat received from vehicle. Attempting to reconnect.\");\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count == 6) {\n        ROS_WARN(\"No heartbeat received from vehicle. Attempting to reconnect.\");\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count == 7) {\n        ROS_WARN(\"No heartbeat received from vehicle. Attempting to reconnect.\");\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count == 8) {\n        ROS_WARN(\"No heartbeat received from vehicle. Attempting to reconnect.\");\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count == 9) {\n        ROS_WARN(\"No heartbeat received from vehicle. Attempting to reconnect.\");\n        disconnect_flag = true;\n    }\n    else if (heartbeat_count == 1", "CodeBleu_score": 38.675351775684184}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (heartbeat_count == 0) {\n        ROS_INFO_STREAM(\"No heartbeats received from the vehicle.\");\n        ROS_INFO_STREAM(\"Triggering appropriate actions based on vehicle type.\");\n        switch (vehicle_type) {\n            case 0:\n                ROS_INFO_STREAM(\"Vehicle type is UAV. Triggering UAV action.\");\n                triggerUAV();\n                break;\n            case 1:\n                ROS_INFO_STREAM(\"Vehicle type is UGV. Triggering UGV action.\");\n                triggerUGV();\n                break;\n            case 2:\n                ROS_INFO_STREAM(\"Vehicle type is swarm. Triggering swarm action.\");\n                triggerSwarmControl();\n                break;\n            default:\n                ROS_WARN_STREAM(\"Vehicle type is not recognized. Triggering UAV action.\");\n                triggerUAV();\n                break;\n        }\n    } else {\n        ROS_INFO_STREAM(\"Heartbeat count: \" << heartbeat_count);\n    }\n}", "CodeBleu_score": 33.6771468394938}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\n    if (heartbeat_count == 0) {\n        ROS_WARN(\"Heartbeat count is zero. No heartbeats received. Checking for connectivity.\");\n        heartbeat_count++;\n        return;\n    }\n\n    if (heartbeat_count == heartbeat_missed_threshold) {\n        ROS_ERROR(\"Heartbeat count is %d. No heartbeats received. Checking for connectivity.\", heartbeat_count);\n        if (vehicle_type == \"swarm\") {\n            triggerSwarmControl();\n        }\n        else if (vehicle_type == \"uav\") {\n            triggerUAV();\n        }\n        else if (vehicle_type == \"ugv\") {\n            triggerUGV();\n        }\n        else {\n            ROS_WARN(\"Vehicle type not specified. Not triggering any actions.\");\n        }\n        disconnect_flag = true;\n        return;\n    }\n\n    if (heartbeat_count > heartbeat_missed_threshold) {\n        heartbeat_count = 0;\n    }\n\n    return;\n}", "CodeBleu_score": 46.14774912101078}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // cout << \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>", "CodeBleu_score": 5.449560078391864}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\n    if(msg->traj.size() == 0)\n    {\n        ROS_WARN(\"[ego_planner_swarm] Empty trajectory received.\");\n        return;\n    }\n\n    // Initialize MultiBspline struct.\n    MultiBspline multi_bspline;\n\n    multi_bspline.drone_id = msg->drone_id;\n\n    multi_bspline.traj.resize(msg->traj.size());\n\n    for(int i = 0; i < msg->traj.size(); i++)\n    {\n        Bspline bspline;\n\n        bspline.knots.resize(msg->traj[i].knots.size());\n        bspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n        bspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\n        for(int j = 0; j < msg->traj[i].knots.size(); j++)\n        {\n            bspline.knots[j] = msg->traj[i].knots[j];\n        }\n\n        for(int j = 0; j < msg->traj[i].pos_pts.size(); j++)\n        {\n            bspline.pos_pts[j] = msg->traj[i].pos_pts[j];\n        }\n\n        for(int j = 0; j < msg->traj[i].yaw_pts.size(); j++)\n        {\n            bspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n        }\n\n        multi_bspline.traj[i] = bspline;\n    }\n\n    // Encode and send the message.\n    this->communication->sendMsgByTcp(this->communication->encodeMsg(multi_bspline));\n}", "CodeBleu_score": 63.15000498561931}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    if(msg->traj.size() != this->n_drones) {\n        ROS_ERROR(\"[%s]: The number of trajectories does not match the number of drones.\",__FUNCTION__);\n        return;\n    }\n\n    for(int i = 0; i < msg->traj.size(); i++) {\n        if(msg->traj[i].knots.size() != msg->traj[i].pos_pts.size() || msg->traj[i].knots.size() != msg->traj[i].yaw_pts.size()) {\n            ROS_ERROR(\"[%s]: The number of knots does not match the number of position and yaw points.\",__FUNCTION__);\n            return;\n        }\n    }\n\n    for(int i = 0; i < msg->traj.size(); i++) {\n        Bspline bspline;\n        bspline.knots.clear();\n        bspline.pos_pts.clear();\n        bspline.yaw_pts.clear();\n\n        bspline.id = msg->traj[i].id;\n        bspline.n_knots = msg->traj[i].knots.size();\n        bspline.n_pos_pts = msg->traj[i].pos_pts.size();\n        bspline.n_yaw_pts = msg->traj[i].yaw_pts.size();\n\n        for(int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots.push_back(msg->traj[i].knots[j]);\n        }\n\n        for(int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts.push_back(msg->traj[i].pos_pts[j]);\n        }\n\n        for(int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts.push_back(", "CodeBleu_score": 63.27799776464001}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud\n    std::vector<uint8_t> compressed_data;\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZI> octree_compression;\n    octree_compression.setInputCloud(cloud);\n    octree_compression.addPointsFromInputCloud();\n    octree_compression.encodePointCloud(compressed_data);\n\n    // Store the compressed data\n    std::string compressed_str(compressed_data.begin(), compressed_data.end());\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 msg_compressed;\n    msg_compressed.header = msg.header;\n    msg_compressed.height = msg.height;\n    msg_compressed.width = msg.width;\n    msg_compressed.fields = msg.fields;\n    msg_compressed.is_bigendian = msg.is_bigendian;\n    msg_compressed.point_step = msg.point_step;\n    msg_compressed.row_step = msg.row_step;\n    msg_compressed.is_dense = msg.is_dense;\n    msg_compressed.data.resize(msg.data.size() + compressed_str.size());\n    std::memcpy(&msg_compressed.data[0], &msg.data[0], msg.data.size());\n    std::memcpy(&msg_compressed.data[msg.data.size()], &compressed_str[0], compressed_str.size());\n\n    // Return the new PointCloud2 message\n    return msg_compressed;\n}", "CodeBleu_score": 49.96968183936934}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n\t// Create a new PointCloud2 message\n\tsensor_msgs::PointCloud2 compressed_data;\n\n\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Compress the point cloud\n\tstd::vector<uint8_t> compressed_str;\n\toctree_compression.setInputCloud(cloud);\n\toctree_compression.encodePointCloud(compressed_str);\n\n\t// Store the compressed data\n\tcompressed_data.data.resize(compressed_str.size());\n\tstd::memcpy(compressed_data.data.data(), compressed_str.data(), compressed_str.size());\n\n\t// Return the compressed message\n\treturn compressed_data;\n}", "CodeBleu_score": 30.850039577265687}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud\n    std::vector<uint8_t> compressed_data;\n    octree_compression.setInputCloud(cloud);\n    octree_compression.encodePointCloud(compressed_data);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = msg.height;\n    compressed_msg.width = msg.width;\n    compressed_msg.is_bigendian = msg.is_bigendian;\n    compressed_msg.point_step = msg.point_step;\n    compressed_msg.row_step = msg.row_step;\n    compressed_msg.fields = msg.fields;\n    compressed_msg.is_dense = msg.is_dense;\n    compressed_msg.data = compressed_data;\n    compressed_msg.data.resize(compressed_str.size());\n    std::memcpy(compressed_msg.data.data(), compressed_str.data(), compressed_str.size());\n\n    // Return the new PointCloud2 message\n    return compressed_msg;\n}", "CodeBleu_score": 46.01758891209713}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\n    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 86.47230218122864}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t  for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n    if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n      this->multi_uav_state_.uav_state_all[i] = uav_state;\n      break;\n    }\n  }\n}", "CodeBleu_score": 94.37680252604139}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    // Iterate through the list of UAV states\n    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        // If the UAV ID matches, replace the UAV state\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 96.85798270197343}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    m_multi_ugv_state.header.stamp = ros::Time::now();\n    m_multi_ugv_state.header.frame_id = \"map\";\n    m_multi_ugv_state.ugv_state_all.clear();\n    int ugv_count = 0;\n\n    for (auto it = m_multi_ugv_state.ugv_state.begin(); it != m_multi_ugv_state.ugv_state.end(); it++) {\n        geometry_msgs::PoseStamped ugv_pose;\n        geometry_msgs::TwistStamped ugv_vel;\n        geometry_msgs::Quaternion ugv_att;\n        std_msgs::Float32 ugv_batt;\n        std_msgs::Float32 ugv_alt;\n\n        ugv_pose.header.stamp = ros::Time::now();\n        ugv_pose.header.frame_id = \"map\";\n        ugv_pose.pose.position.x = it->ugv_state.ugv_pose.position.x;\n        ugv_pose.pose.position.y = it->ugv_state.ugv_pose.position.y;\n        ugv_pose.pose.position.z = it->ugv_state.ugv_pose.position.z;\n        ugv_pose.pose.orientation.x = it->ugv_state.ugv_pose.orientation.x;\n        ugv_pose.pose.orientation.y = it->ugv_state.ugv_pose.orientation.y;\n        ugv_pose.pose.orientation.z = it->ugv_state.ugv_pose.orientation.z;\n        ugv_pose.pose.orientation.w = it->ugv_state.ugv_pose.orientation.w;\n\n        ugv_vel.header.stamp = ros::Time::now();\n        ugv_vel.header.frame_id = \"map\";\n        ugv_vel.twist.linear.x = it->ugv_state.ugv_", "CodeBleu_score": 43.1113474870155}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  // Initialize MultiUGVState message\n  swarm_control_msgs::MultiUGVState multi_ugv_state;\n  multi_ugv_state.ugv_state_all.clear();\n  multi_ugv_state.ugv_count = m_multi_ugv_state.ugv_count;\n\n  // Iterate through each UGV state\n  for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n    // Populate UGVState message\n    swarm_control_msgs::UGVState ugv_state;\n    ugv_state.id = it->id;\n    ugv_state.battery = it->battery;\n    ugv_state.position.x = it->position.x;\n    ugv_state.position.y = it->position.y;\n    ugv_state.position.z = it->position.z;\n    ugv_state.velocity.x = it->velocity.x;\n    ugv_state.velocity.y = it->velocity.y;\n    ugv_state.velocity.z = it->velocity.z;\n    ugv_state.attitude.x = it->attitude.x;\n    ugv_state.attitude.y = it->attitude.y;\n    ugv_state.attitude.z = it->attitude.z;\n    ugv_state.attitude.w = it->attitude.w;\n    ugv_state.mode = it->mode;\n\n    // Add UGVState to MultiUGVState message\n    multi_ugv_state.ugv_state_all.push_back(ugv_state);\n  }\n\n  // Publish MultiUGVState message\n  this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 51.84293916703545}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  m_multi_ugv_state.ugv_state_all.clear();\n  for (int i = 0; i < m_ugv_count; i++) {\n    UGVState ugv_state;\n    ugv_state.id = m_ugv_ids[i];\n    ugv_state.battery = m_ugv_battery[i];\n    ugv_state.position.x = m_ugv_position[i].x;\n    ugv_state.position.y = m_ugv_position[i].y;\n    ugv_state.position.z = m_ugv_position[i].z;\n    ugv_state.velocity.x = m_ugv_velocity[i].x;\n    ugv_state.velocity.y = m_ugv_velocity[i].y;\n    ugv_state.velocity.z = m_ugv_velocity[i].z;\n    ugv_state.attitude.x = m_ugv_attitude[i].x;\n    ugv_state.attitude.y = m_ugv_attitude[i].y;\n    ugv_state.attitude.z = m_ugv_attitude[i].z;\n    ugv_state.attitude.w = m_ugv_attitude[i].w;\n    m_multi_ugv_state.ugv_state_all.push_back(ugv_state);\n  }\n  m_multi_ugv_state.ugv_count = m_ugv_count;\n  this->all_ugv_state_pub_.publish(m_multi_ugv_state);\n}", "CodeBleu_score": 43.34605590643336}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  if (moving_objs_ == nullptr) {\n    ROS_WARN(\"[BsplineOptimizer::calcMovingObjCost] Moving objects are not set.\");\n    return;\n  }\n  int num_objs = moving_objs_->getObjNums();\n  Eigen::MatrixXd obj_prid = Eigen::MatrixXd::Zero(3, num_objs);\n  for (int i = 0; i < num_objs; i++) {\n    obj_prid.col(i) = moving_objs_->evaluateConstVel(q.col(i), ros::Time::now().toSec());\n  }\n  cost = 0.0;\n  gradient = Eigen::MatrixXd::Zero(3, q.cols());\n  for (int i = 0; i < cps_.points.cols(); i++) {\n    double dist = (cps_.points.col(i) - obj_prid).norm();\n    if (dist < clearance_) {\n      cost += pow(dist, 2);\n      gradient.col(i) += 2.0 * dist * (cps_.points.col(i) - obj_prid).normalized();\n    }\n  }\n}", "CodeBleu_score": 50.140522392722296}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n    int n_objs = moving_objs_->getObjNums();\n    for (int i = 0; i < cps_.points.cols(); ++i) {\n        Eigen::VectorXd obj_prid(n_objs);\n        for (int j = 0; j < n_objs; ++j) {\n            obj_prid(j) = moving_objs_->evaluateConstVel(q.col(i), j);\n        }\n        double dist = (cps_.points.col(i) - obj_prid).norm();\n        if (dist < clearance_) {\n            cost += pow(dist, 2);\n            gradient.col(i) = 2 * dist * (cps_.points.col(i) - obj_prid).normalized();\n        }\n    }\n}", "CodeBleu_score": 45.116821116755204}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  double clearance = 0.05;\n  double clearance_sq = clearance * clearance;\n  cost = 0.0;\n  gradient.setZero(3, q.cols());\n  for (int i = 0; i < q.cols(); i++) {\n    Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(q.col(i));\n    for (int j = 0; j < moving_objs_->getObjNums(); j++) {\n      double dist = (cps_.points.col(i) - obj_prid).norm();\n      if (dist < clearance) {\n        cost += dist * dist;\n        gradient.col(i) += 2.0 * dist * (cps_.points.col(i) - obj_prid).normalized();\n      }\n    }\n  }\n  cost *= clearance_sq;\n  gradient *= clearance_sq;\n}", "CodeBleu_score": 46.28956070401132}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n  // Initialize cost to zero\n  cost = 0.0;\n\n  // Iterate through control points\n  for (int i = 2; i < (int)q.rows() - 2; i++) {\n\n    // Compute positional error relative to reference points and a velocity vector\n    Eigen::Vector3d e = q.col(i) - ref_pts_[i];\n    Eigen::Vector3d v = (q.col(i + 1) - q.col(i - 1)) / (2.0 * h_);\n\n    // Compute cost and gradient\n    cost += a2_ * e.dot(e) + b2_ * v.dot(v);\n    gradient.col(i) += 2.0 * a2_ * e + 2.0 * b2_ * v;\n  }\n}", "CodeBleu_score": 24.15353436935171}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n    // For each control point, compute the error between the reference points and the control point\n    for (int i = 2; i < (int)q.cols() - 2; i++) {\n        // Compute the positional error\n        Eigen::Vector3d err_pos = (q.col(i) - ref_pts_[i]);\n        // Compute the velocity error\n        Eigen::Vector3d err_vel = (q.col(i) - q.col(i - 2)) / dt_;\n        // Compute the positional error cost\n        cost += a2_ * err_pos.squaredNorm();\n        // Compute the velocity error cost\n        cost += b2_ * err_vel.squaredNorm();\n        // Compute the positional error gradient\n        gradient.col(i) += 2.0 * a2_ * err_pos;\n        // Compute the velocity error gradient\n        gradient.col(i) += 2.0 * b2_ * err_vel;\n    }\n}", "CodeBleu_score": 28.61076478929286}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  gradient.setZero();\n  cost = 0;\n\n  Eigen::Vector3d xcrossv;\n  Eigen::Vector3d x;\n  Eigen::Vector3d v;\n  Eigen::Vector3d qcrossv;\n  Eigen::Vector3d qdot;\n  Eigen::Vector3d qcrossqdot;\n  double a2 = 0.0000001;\n  double b2 = 0.0000001;\n  double a = 0.0000001;\n  double b = 0.0000001;\n  double c = 0.0000001;\n  double d = 0.0000001;\n  double e = 0.0000001;\n  double f = 0.0000001;\n  double g = 0.0000001;\n  double h = 0.0000001;\n  double i = 0.0000001;\n  double j = 0.0000001;\n  double k = 0.0000001;\n  double l = 0.0000001;\n  double m = 0.0000001;\n  double n = 0.0000001;\n  double o = 0.0000001;\n  double p = 0.0000001;\n  double q = 0.0000001;\n  double r = 0.0000001;\n  double s = 0.0000001;\n  double t = 0.0000001;\n  double u = 0.0000001;\n  double v = 0.0000001;\n  double w = 0.0000001;\n  double x = 0.0000001;\n  double y = 0.0000", "CodeBleu_score": 17.84289597659084}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t    // Compute the third derivative of the spline to obtain the jerk trajectory.\n    UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n    // Retrieve the knot times and control points of the jerk trajectory.\n    std::vector<double> times = jerk_traj.getKnot().getTimes();\n    Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n    // Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times.\n    double jerk = 0.0;\n    for (int i = 0; i < ctrl_pts.cols(); i++) {\n        for (int j = 0; j < ctrl_pts.rows(); j++) {\n            jerk += pow(ctrl_pts(j, i), 3) * (times[i + 1] - times[i]);\n        }\n    }\n\n    // Return the total jerk value.\n    return jerk;\n}", "CodeBleu_score": 68.56347698434253}, {"code": "double UniformBspline::getJerk(){\n\t  // Compute the third derivative of the spline to obtain the jerk trajectory.\n  UniformBspline jerk_traj = getDerivative().getDerivative();\n\n  // Retrieve the knot times and control points of the jerk trajectory.\n  vector<double> knot_times = jerk_traj.getKnot();\n  MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n  // Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times.\n  double jerk = 0.0;\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      jerk += pow(ctrl_pts(j, i), 3) * (knot_times[i + 1] - knot_times[i]);\n    }\n  }\n\n  // Return the total jerk value.\n  return jerk;\n}", "CodeBleu_score": 61.71902396755562}, {"code": "double UniformBspline::getJerk(){\n\t    // Compute the third derivative of the trajectory\n    UniformBspline jerk_traj = this->getDerivative().getDerivative();\n\n    // Retrieve the knot times and control points of the jerk trajectory\n    Eigen::MatrixXd jerk_knot_times = jerk_traj.getKnot();\n    Eigen::MatrixXd jerk_ctrl_pts = jerk_traj.getControlPoint();\n\n    // Initialize the jerk value\n    double jerk = 0.0;\n\n    // Iterate through the control points and dimensions\n    for (int i = 0; i < jerk_ctrl_pts.rows(); i++) {\n        for (int j = 0; j < jerk_ctrl_pts.cols(); j++) {\n            // Compute the jerk value\n            jerk += pow(jerk_ctrl_pts(i, j), 3) * (jerk_knot_times(i, j + 1) - jerk_knot_times(i, j));\n        }\n    }\n\n    // Return the jerk value\n    return jerk;\n}", "CodeBleu_score": 58.65301890952483}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\n    // Convert depth from meters to millimeters\n    depth = depth * 1000;\n\n    // Calculate the 4D position vector in the camera frame\n    Eigen::Vector4d pos;\n    pos << depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1;\n\n    return pos;\n}", "CodeBleu_score": 41.19781495140457}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n    return pos;\n}", "CodeBleu_score": 49.315525916455506}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\n    // Calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth.\n    // It uses intrinsic camera parameters (cx_, cy_, fx_, fy_) to transform the pixel coordinates (u, v) and depth into a 4D position vector in the camera frame.\n    // The function returns this 4D position vector.\n\n    // Declare a 4D position vector in the camera frame.\n    Eigen::Vector4d pos_camera;\n\n    // Initialize the 4D position vector in the camera frame.\n    pos_camera << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n\n    // Return the 4D position vector in the camera frame.\n    return pos_camera;\n\n}", "CodeBleu_score": 52.468122333075314}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    // Extract drone ID from child_frame_id\n    int droneID = std::stoi(odom.child_frame_id.substr(1));\n    // Call rcvDroneOdomCallbackBase with drone ID and odometry data\n    rcvDroneOdomCallbackBase(droneID, odom);\n  } catch (std::exception& e) {\n    // Print exception\n    ROS_ERROR_STREAM(e.what());\n  }\n}", "CodeBleu_score": 50.61330206529725}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    // extract drone ID from child frame ID\n    std::string childFrameID = odom.child_frame_id;\n    std::string droneID;\n    try {\n        droneID = childFrameID.substr(childFrameID.find_last_of('/') + 1);\n    }\n    catch (std::out_of_range& e) {\n        std::cerr << e.what() << std::endl;\n        return;\n    }\n    // call rcvDroneOdomCallbackBase\n    rcvDroneOdomCallbackBase(odom, droneID);\n}", "CodeBleu_score": 53.75064038394688}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(5, odom.child_frame_id.length())));\n    } catch (std::exception e) {\n        ROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n    }\n}", "CodeBleu_score": 40.89600883191054}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Get the drone pose in the camera frame\n    Eigen::Vector2i camera_pixel = getCameraPose(drone_id);\n    // Compute the pose error between the camera and world coordinates\n    Eigen::Vector2i pose_error = camera_pixel - true_pixel;\n    // If the drone is found, update the debug result and publish the pose error\n    if (camera_pixel.x() >= 0 && camera_pixel.y() >= 0) {\n        debug_result_[drone_id] = true;\n        drone_pose_err_pub_[drone_id].publish(pose_error);\n    }\n    // If the drone is not found, update the debug result to indicate failure\n    else {\n        debug_result_[drone_id] = false;\n    }\n}", "CodeBleu_score": 31.052782546582826}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n    // Get the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = get_true_pose(drone_id, true_pixel);\n\n    // Check if the drone is present\n    if (check_presence(drone_id, true_pose)) {\n\n        // Compute the pose error\n        Eigen::Vector3d pose_error = get_pose_error(drone_id, true_pose);\n\n        // Update the debug result\n        update_debug_result(drone_id, true_pose, pose_error);\n\n        // Publish the pose error\n        publish_pose_error(drone_id, pose_error);\n\n    } else {\n\n        // Update the debug result\n        update_debug_result(drone_id, true_pose, Eigen::Vector3d(0, 0, 0));\n    }\n}", "CodeBleu_score": 29.07935336547789}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Calculate the true pose of the drone in the camera frame\n    Eigen::Vector3d drone_true_pose = camera_to_drone_pose(drone_id, true_pixel);\n\n    // Check for the presence of the drone\n    if (check_for_drone(drone_id, drone_true_pose)) {\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d drone_pose_err = camera_to_world_pose_err(drone_id, drone_true_pose);\n\n        // Update the debug result\n        drone_pose_err_debug_[drone_id] = drone_pose_err;\n\n        // Publish the pose error\n        publish_pose_err(drone_id, drone_pose_err);\n    } else {\n        // Update the debug result\n        drone_pose_err_debug_[drone_id] = Eigen::Vector3d::Zero();\n    }\n}", "CodeBleu_score": 32.131005729408415}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->getParent() != nullptr) {\n\t\tcurrent = current->getParent();\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.23334368688437}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    GridNodePtr temp = current;\n    while (temp->getParent() != nullptr) {\n        path.push_back(temp->getParent());\n        temp = temp->getParent();\n    }\n    return path;\n}", "CodeBleu_score": 59.92953546405113}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getParent() != nullptr) {\n        current = current->getParent();\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 76.6566733214921}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    bool success = true;\n    start_idx = Coord2Index(start_pt);\n    end_idx = Coord2Index(end_pt);\n    if (IsInsideObstacle(start_idx)) {\n        // Adjust start point\n        success = AdjustStartPoint(start_pt, end_pt, start_idx);\n        if (!success) {\n            return false;\n        }\n    }\n    if (IsInsideObstacle(end_idx)) {\n        // Adjust end point\n        success = AdjustEndPoint(start_pt, end_pt, end_idx);\n        if (!success) {\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 35.071685143865885}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tstart_idx = Coord2Index(start_pt);\n\tend_idx = Coord2Index(end_pt);\n\tbool success = true;\n\t// if either point is inside an obstacle, adjust it\n\tif (IsInObstacle(start_idx)) {\n\t\tsuccess = AdjustStartPoint(start_idx, end_idx, start_pt);\n\t}\n\tif (IsInObstacle(end_idx)) {\n\t\tsuccess = AdjustEndPoint(start_idx, end_idx, end_pt);\n\t}\n\t// if both points are inside obstacles, return false\n\tif (IsInObstacle(start_idx) && IsInObstacle(end_idx)) {\n\t\tsuccess = false;\n\t}\n\treturn success;\n}", "CodeBleu_score": 27.911710888874286}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tbool success = ConvertToIndex(start_pt, start_idx);\n\tif (success) {\n\t\tsuccess = ConvertToIndex(end_pt, end_idx);\n\t\tif (success) {\n\t\t\tsuccess = AdjustStartEndPoints(start_idx, end_idx);\n\t\t}\n\t}\n\treturn success;\n}", "CodeBleu_score": 17.193226749814933}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  unsigned int min_id[3], max_id[3];\n\n  // Convert world coordinates to map index\n  toIndex(min_pos, min_id);\n  toIndex(max_pos, max_id);\n\n  // Set the values in the buffer\n  for (int x = min_id[0]; x <= max_id[0]; ++x) {\n    for (int y = min_id[1]; y <= max_id[1]; ++y) {\n      for (int z = min_id[2]; z <= max_id[2]; ++z) {\n        occupancy_buffer_inflate_(x, y, z) = 0;\n        distance_buffer_(x, y, z) = std::numeric_limits<float>::max();\n      }\n    }\n  }\n}", "CodeBleu_score": 43.791416094100185}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    int min_x = std::max(0, (int) std::floor(min_pos.x() - 0.5));\n    int max_x = std::min(info_.width - 1, (int) std::floor(max_pos.x() - 0.5));\n    int min_y = std::max(0, (int) std::floor(min_pos.y() - 0.5));\n    int max_y = std::min(info_.height - 1, (int) std::floor(max_pos.y() - 0.5));\n    int min_z = std::max(0, (int) std::floor(min_pos.z() - 0.5));\n    int max_z = std::min(info_.depth - 1, (int) std::floor(max_pos.z() - 0.5));\n\n    for (int z = min_z; z <= max_z; ++z) {\n        for (int y = min_y; y <= max_y; ++y) {\n            for (int x = min_x; x <= max_x; ++x) {\n                occupancy_buffer_inflate_[toIndex(x, y, z)] = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 45.40924890636189}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  // Check if the region is within the map\n  if (min_pos.x() < 0 || max_pos.x() >= length_x_ || min_pos.y() < 0 || max_pos.y() >= length_y_ || min_pos.z() < 0 || max_pos.z() >= length_z_) {\n    ROS_WARN(\"The region is not within the map.\");\n    return;\n  }\n\n  // Check if the region is within the buffer\n  if (min_pos.x() < 0 || max_pos.x() >= buffer_size_x_ || min_pos.y() < 0 || max_pos.y() >= buffer_size_y_ || min_pos.z() < 0 || max_pos.z() >= buffer_size_z_) {\n    ROS_WARN(\"The region is not within the buffer.\");\n    return;\n  }\n\n  // Calculate the corresponding indices in the buffer\n  int min_x_idx = (int)floor(min_pos.x() / resolution_);\n  int max_x_idx = (int)ceil(max_pos.x() / resolution_) - 1;\n  int min_y_idx = (int)floor(min_pos.y() / resolution_);\n  int max_y_idx = (int)ceil(max_pos.y() / resolution_) - 1;\n  int min_z_idx = (int)floor(min_pos.z() / resolution_);\n  int max_z_idx = (int)ceil(max_pos.z() / resolution_) - 1;\n\n  // Iterate over the grid coordinates and reset the buffer\n  for (int i = min_x_idx; i <= max_x_idx; ++i) {\n    for (int j = min_y_idx; j <= max_y_idx; ++j) {\n      for (int k = min_z_idx; k <= max_z_idx; ++k) {\n        int idx = getIndex(i, j, k);\n        occupancy_buffer_inflate_[idx] = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 33.05426319518514}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t  Eigen::Vector3d diff = pt - camera_pt;\n  double max_translation = 0.0;\n  double min_translation = 0.0;\n  double max_rotation = 0.0;\n  double min_rotation = 0.0;\n  double min_translation_x = 0.0;\n  double min_translation_y = 0.0;\n  double min_translation_z = 0.0;\n  double min_rotation_x = 0.0;\n  double min_rotation_y = 0.0;\n  double min_rotation_z = 0.0;\n  double max_translation_x = 0.0;\n  double max_translation_y = 0.0;\n  double max_translation_z = 0.0;\n  double max_rotation_x = 0.0;\n  double max_rotation_y = 0.0;\n  double max_rotation_z = 0.0;\n  double min_translation_x_pos = 0.0;\n  double min_translation_y_pos = 0.0;\n  double min_translation_z_pos = 0.0;\n  double min_rotation_x_pos = 0.0;\n  double min_rotation_y_pos = 0.0;\n  double min_rotation_z_pos = 0.0;\n  double max_translation_x_pos = 0.0;\n  double max_translation_y_pos = 0.0;\n  double max_translation_z_pos = 0.0;\n  double max_rotation_x_pos = 0.0;\n  double max_rotation_y_pos = 0.0;\n  double max_rotation_z_pos = 0.0;\n  double min_translation_x_neg = 0.0;\n  double min_translation_y_neg = 0.0;\n  double min_translation_z_neg = 0.0;\n  double min_rotation_x_", "CodeBleu_score": 16.717219597754372}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n    Eigen::Vector3d point_diff = pt - camera_pt;\n    double x_scale = (double) (this->getSize()[0] - 1) / point_diff.x();\n    double y_scale = (double) (this->getSize()[1] - 1) / point_diff.y();\n    double z_scale = (double) (this->getSize()[2] - 1) / point_diff.z();\n\n    double x_scale_max = 0;\n    double y_scale_max = 0;\n    double z_scale_max = 0;\n\n    if (x_scale > 0) {\n        x_scale_max = x_scale;\n    }\n    if (y_scale > 0) {\n        y_scale_max = y_scale;\n    }\n    if (z_scale > 0) {\n        z_scale_max = z_scale;\n    }\n\n    double x_scale_min = x_scale_max;\n    double y_scale_min = y_scale_max;\n    double z_scale_min = z_scale_max;\n\n    if (x_scale_max < 0) {\n        x_scale_min = 0;\n    }\n    if (y_scale_max < 0) {\n        y_scale_min = 0;\n    }\n    if (z_scale_max < 0) {\n        z_scale_min = 0;\n    }\n\n    if (x_scale_min > x_scale_max) {\n        x_scale_min = x_scale_max;\n    }\n    if (y_scale_min > y_scale_max) {\n        y_scale_min = y_scale_max;\n    }\n    if (z_scale_min > z_scale_max) {\n        z_scale_min = z_scale_max;\n    }\n\n    double x_scale_final = x_scale_min;\n    double y_scale_final = y_scale_min;\n    double z_scale_final = z_scale_min;\n\n    if (", "CodeBleu_score": 39.13852112149082}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d min_diff(std::numeric_limits<double>::max(), std::numeric_limits<double>::max(), std::numeric_limits<double>::max());\n    Eigen::Vector3d max_diff(std::numeric_limits<double>::min(), std::numeric_limits<double>::min(), std::numeric_limits<double>::min());\n    for (int i = 0; i < 3; i++) {\n        if (diff[i] < 0) {\n            min_diff[i] = -diff[i];\n        } else {\n            max_diff[i] = diff[i];\n        }\n    }\n\n    Eigen::Vector3d closest_pt = camera_pt;\n    for (int i = 0; i < 3; i++) {\n        double scale_factor = min_diff[i] / max_diff[i];\n        if (scale_factor > 0) {\n            closest_pt[i] += scale_factor * diff[i];\n        }\n    }\n    return closest_pt;\n}", "CodeBleu_score": 44.85287164730985}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update the last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if the local map has been updated.\n  if (md_.local_map_updated_) {\n    // Clear and inflate the local map.\n    clearAndInflateLocalMap();\n    md_.local_map_updated_ = false;\n  }\n\n  // Check if odometry is available.\n  if (md_.odom_available_) {\n    // Check if depth image is available.\n    if (md_.depth_image_available_) {\n      // Project depth image into points.\n      projectDepthImage();\n      // Process points with raycasting.\n      raycastProcess();\n    } else {\n      // If depth image is not available, set the depth image available flag to false.\n      md_.depth_image_available_ = false;\n    }\n  } else {\n    // If odometry is not available, set the odometry available flag to false.\n    md_.odom_available_ = false;\n  }\n}", "CodeBleu_score": 38.58684348688831}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update last update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if the local map has been updated.\n  if (md_.local_map_updated_) {\n    // Clear and inflate local map.\n    clearAndInflateLocalMap();\n    md_.local_map_updated_ = false;\n  }\n\n  // Check if the depth image is valid.\n  if (!md_.depth_image_valid_) {\n    ROS_ERROR_THROTTLE(1.0, \"Depth image not valid.\");\n    md_.depth_image_valid_ = false;\n    return;\n  }\n\n  // Check if the odometry is valid.\n  if (!md_.odometry_valid_) {\n    ROS_ERROR_THROTTLE(1.0, \"Odometry not valid.\");\n    md_.odometry_valid_ = false;\n    return;\n  }\n\n  // Check if the map is valid.\n  if (!md_.map_valid_) {\n    ROS_ERROR_THROTTLE(1.0, \"Map not valid.\");\n    md_.map_valid_ = false;\n    return;\n  }\n\n  // Check if the map is initialized.\n  if (!md_.map_initialized_) {\n    ROS_ERROR_THROTTLE(1.0, \"Map not initialized.\");\n    md_.map_initialized_ = false;\n    return;\n  }\n\n  // Check if the map is updated.\n  if (!md_.map_updated_) {\n    ROS_ERROR_THROTTLE(1.0, \"Map not updated.\");\n    md_.map_updated_ = false;\n    return;\n  }\n\n  // Check if the map is updated.\n  if (!md_.map_updated_) {\n    ROS_ERROR_THROTTLE(1.0, \"Map not updated.\");\n    md_.map_updated_ = false;\n    return;\n  }\n\n  // Check if the map is updated.\n  if (!md_.map_updated_) {\n    ROS_ERROR_THROTTLE(1.0, \"Map not updated.\");\n   ", "CodeBleu_score": 53.03336085997178}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update last update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if the local map has been updated.\n  if (md_.local_map_updated_) {\n    // Clear and inflate local map.\n    clearAndInflateLocalMap();\n    md_.local_map_updated_ = false;\n  }\n\n  // Check if the odometry has been updated.\n  if (md_.odom_updated_) {\n    // Update odometry.\n    updateOdometry();\n    md_.odom_updated_ = false;\n  }\n\n  // Check if the depth image has been updated.\n  if (md_.depth_updated_) {\n    // Update depth image.\n    updateDepthImage();\n    md_.depth_updated_ = false;\n  }\n\n  // Check if the camera info has been updated.\n  if (md_.camera_info_updated_) {\n    // Update camera info.\n    updateCameraInfo();\n    md_.camera_info_updated_ = false;\n  }\n\n  // Check if the laser scan has been updated.\n  if (md_.laser_scan_updated_) {\n    // Update laser scan.\n    updateLaserScan();\n    md_.laser_scan_updated_ = false;\n  }\n\n  // Check if the occupancy threshold has been updated.\n  if (md_.occ_thresh_updated_) {\n    // Update occupancy threshold.\n    updateOccupancyThreshold();\n    md_.occ_thresh_updated_ = false;\n  }\n\n  // Check if the resolution has been updated.\n  if (md_.resolution_updated_) {\n    // Update resolution.\n    updateResolution();\n    md_.resolution_updated_ = false;\n  }\n\n  // Check if the map frame has been updated.\n  if (md_.map_frame_updated_) {\n    // Update map frame.\n    updateMapFrame();\n    md_.map_frame_updated_ = false;\n  }\n\n  // Check if the robot pose has been updated.\n  if (md_.robot_pose_updated_) {\n    // Update robot pose.\n   ", "CodeBleu_score": 47.19034847148938}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat F_measure_sum = 0;\n\tint num_images = image_fns.size();\n\tfor (int i = 0; i < num_images; i++) {\n\t\tMat image = imread(image_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n\t\tvector<Ellipse> gt_ellipse = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipse = _load_ellipse_DT(dt_fns[i]);\n\t\tfloat F_measure = _ellipse_evaluate_one(image, gt_ellipse, dt_ellipse);\n\t\tF_measure_sum += F_measure;\n\t}\n\treturn F_measure_sum / num_images;\n}", "CodeBleu_score": 55.18916249211436}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n    float total_f_measure = 0;\n    int num_images = image_fns.size();\n\n    for (int i = 0; i < num_images; i++) {\n\n        vector<Ellipse> gt_ellipses;\n        vector<Ellipse> dt_ellipses;\n\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses);\n\n        total_f_measure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses);\n    }\n\n    return total_f_measure / num_images;\n}", "CodeBleu_score": 59.03745720421681}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    int n_images = image_fns.size();\n    if (n_images != gt_fns.size() || n_images != dt_fns.size()) {\n        cerr << \"Error: _ellipse_evaluate: Number of images does not match number of ground truth and detected ellipses.\" << endl;\n        return -1;\n    }\n\n    float avg_f_measure = 0;\n    for (int i = 0; i < n_images; i++) {\n        Mat img = imread(image_fns[i], CV_LOAD_IMAGE_COLOR);\n        if (img.data == NULL) {\n            cerr << \"Error: _ellipse_evaluate: Could not load image \" << image_fns[i] << endl;\n            return -1;\n        }\n\n        vector<Ellipse> gt = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n        vector<Ellipse> dt = _load_ellipse_DT(dt_fns[i], gt_angle_radians);\n\n        if (gt.size() != dt.size()) {\n            cerr << \"Error: _ellipse_evaluate: Number of ground truth and detected ellipses do not match.\" << endl;\n            return -1;\n        }\n\n        float f_measure = _ellipse_evaluate_one(img, gt, dt);\n        avg_f_measure += f_measure;\n    }\n    avg_f_measure /= n_images;\n\n    return avg_f_measure;\n}", "CodeBleu_score": 52.38564645007617}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float focus_angle_1, focus_angle_2;\n    float normal_angle;\n\n    if (foci) {\n        focus_angle_1 = atan2(y - foci[1], x - foci[0]);\n        focus_angle_2 = atan2(y - foci[3], x - foci[2]);\n        normal_angle = focus_angle_1 - focus_angle_2;\n    }\n    else {\n        normal_angle = 0.0;\n    }\n\n    if (normal_angle < -M_PI) {\n        normal_angle += 2.0 * M_PI;\n    }\n    else if (normal_angle > M_PI) {\n        normal_angle -= 2.0 * M_PI;\n    }\n\n    return normal_angle;\n}", "CodeBleu_score": 48.293044020117314}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle1, angle2;\n    if (foci != NULL) {\n        angle1 = atan2(y - foci[1], x - foci[0]);\n        angle2 = atan2(y - foci[3], x - foci[2]);\n        return (angle1 - angle2 + M_PI) % (2 * M_PI) - M_PI;\n    } else {\n        return 0.0;\n    }\n}", "CodeBleu_score": 44.853827883119834}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat focus_dist = 0.0f;\n\tfloat focus_angle = 0.0f;\n\tfloat normal_angle = 0.0f;\n\tfloat angle_diff = 0.0f;\n\tfloat angle_diff_signed = 0.0f;\n\tfloat focus_angle_1 = 0.0f;\n\tfloat focus_angle_2 = 0.0f;\n\tfloat angle_diff_1 = 0.0f;\n\tfloat angle_diff_2 = 0.0f;\n\tfloat angle_diff_signed_1 = 0.0f;\n\tfloat angle_diff_signed_2 = 0.0f;\n\tfloat angle_diff_signed_signed = 0.0f;\n\tfloat angle_diff_signed_signed_1 = 0.0f;\n\tfloat angle_diff_signed_signed_2 = 0.0f;\n\tfloat angle_diff_signed_signed_signed = 0.0f;\n\tfloat angle_diff_signed_signed_signed_1 = 0.0f;\n\tfloat angle_diff_signed_signed_signed_2 = 0.0f;\n\tfloat angle_diff_signed_signed_signed_signed = 0.0f;\n\tfloat angle_diff_signed_signed_signed_signed_1 = 0.0f;\n\tfloat angle_diff_signed_signed_signed_signed_2 = 0.0f;\n\tfloat angle_diff_signed_signed_signed_signed_signed = 0.0f;\n\tfloat angle_diff_signed_signed_signed_signed_signed_1 = 0.0f;\n\tfloat angle_diff_signed_signed_signed_signed_signed_2 = 0.0f;\n\tfloat angle_diff_signed_signed_signed_signed_signed_signed = 0.0f;\n\tfloat angle_diff_signed_signed_signed_signed_signed_signed_1 = 0.0f;\n\tfloat angle_diff_signed_signed_signed_signed_signed_signed_2 = 0.0f;\n\tfloat angle_diff_signed_signed_signed_signed_signed_", "CodeBleu_score": 4.4417944340071385}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\t//Find the minimum and maximum x and y coordinates of the points in the section\n\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\t//Compute the integral above and below the polygon section\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tintegral_above += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y + vp1[i - 1].y);\n\t\tintegral_below += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y - vp1[i - 1].y);\n\t}\n\tintegral_above += (vp1[end].x - vp1[start].x) * (vp1[end].y + vp1[start].y);\n\tintegral_below += (vp1[end].x - vp1[start].x) * (vp1[end].y - vp1[start].y);\n\n\t//If the integral above is less than the integral below, the section is convex; otherwise, it", "CodeBleu_score": 31.851625174281367}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tif (start == end) return false;\n\tint i;\n\tdouble xmin = vp1[start].x;\n\tdouble xmax = vp1[start].x;\n\tdouble ymin = vp1[start].y;\n\tdouble ymax = vp1[start].y;\n\tdouble sum_above = 0.0;\n\tdouble sum_below = 0.0;\n\tfor (i = start; i < end; i++) {\n\t\tif (vp1[i].x < xmin) xmin = vp1[i].x;\n\t\tif (vp1[i].x > xmax) xmax = vp1[i].x;\n\t\tif (vp1[i].y < ymin) ymin = vp1[i].y;\n\t\tif (vp1[i].y > ymax) ymax = vp1[i].y;\n\t\tsum_above += vp1[i].x * vp1[i+1].y - vp1[i+1].x * vp1[i].y;\n\t\tsum_below += vp1[i].x * vp1[i-1].y - vp1[i-1].x * vp1[i].y;\n\t}\n\tsum_above += vp1[end].x * vp1[start].y - vp1[start].x * vp1[end].y;\n\tsum_below += vp1[end].x * vp1[start].y - vp1[start].x * vp1[end].y;\n\tif (sum_above > sum_below) return true;\n\telse return false;\n}", "CodeBleu_score": 28.808207659533057}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint min_x = MAX, max_x = MIN, min_y = MAX, max_y = MIN;\n\tdouble integral_above = 0, integral_below = 0;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t\tintegral_above += vp1[i].x;\n\t\tintegral_below += vp1[i].y;\n\t}\n\tintegral_above *= max_y;\n\tintegral_below *= min_x;\n\tif (integral_above < integral_below) return true;\n\telse return false;\n}", "CodeBleu_score": 38.42725014263129}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for(int i = 0; i < msg->detections.size(); i++) {\n        if(msg->detections[i].id == 100) {\n            num_regain++;\n            num_lost = 0;\n        }\n        else {\n            num_lost++;\n            num_regain = 0;\n        }\n\n        if(num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n\n        if(num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n\n        if(is_detected) {\n            ellipse_det.sight_angle = msg->detections[i].sight_angle;\n        }\n        else {\n            ellipse_det.sight_angle = 0.0;\n        }\n    }\n}", "CodeBleu_score": 64.98987283918157}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    for (int i = 0; i < msg->detections.size(); i++) {\n        if (msg->detections[i].label == \"T\") {\n            ellipse_det.num_regain++;\n            ellipse_det.num_lost = 0;\n        } else {\n            ellipse_det.num_regain = 0;\n            ellipse_det.num_lost++;\n        }\n    }\n\n    if (ellipse_det.num_lost >= VISION_THRES) {\n        ellipse_det.is_detected = false;\n    }\n\n    if (ellipse_det.num_regain >= VISION_THRES) {\n        ellipse_det.is_detected = true;\n    }\n\n    if (ellipse_det.is_detected == true) {\n        ellipse_det.sight_angle = msg->detections[0].sight_angle;\n    }\n\n    if (ellipse_det.is_detected == false) {\n        ellipse_det.sight_angle = msg->detections[0].sight_angle;\n    }\n}", "CodeBleu_score": 44.14037779314505}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    int i;\n    for(i = 0; i < msg->detections.size(); i++) {\n        if(msg->detections[i].id == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n        if(num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n        if(num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n    }\n    if(ellipse_det.sight_angle < msg->detections[0].sight_angle) {\n        ellipse_det.sight_angle = msg->detections[0].sight_angle;\n    }\n}", "CodeBleu_score": 70.45834048700497}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t  if (occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 47.076504881115135}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t  return occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.322362540258084}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    return occupy_map_ptr_->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.54728922940968}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// if the end node has no parent, then the path is empty\n\tif (!end_node->parent) {\n\t\tpath_nodes_.clear();\n\t\treturn;\n\t}\n\t// if the end node has a parent, then trace the path back to the start node\n\tpath_nodes_.push_back(end_node);\n\twhile (end_node->parent != path_nodes_.front()) {\n\t\tend_node = end_node->parent;\n\t\tpath_nodes_.push_back(end_node);\n\t}\n\t// reverse the order of path_nodes_ to present the path from start to end\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 48.674716824531636}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    while (current_node->getParent() != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->getParent();\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 55.20313912206562}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// Create a vector to store the nodes of the path\n\tstd::vector<NodePtr> path_nodes_;\n\t// Create a pointer to the end node\n\tNodePtr current_node = end_node;\n\t// While the current node is not the start node, add the current node to the path vector and set the current node to the parent of the current node\n\twhile (current_node != start_node_) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\t// Add the start node to the path vector\n\tpath_nodes_.push_back(start_node_);\n\t// Reverse the order of the path vector\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n\t// Set the path_nodes_ vector to the path_nodes_ vector\n\tpath_nodes_ = path_nodes_;\n}", "CodeBleu_score": 57.97581130781624}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n    state_nei[id][3] = odom->twist.twist.linear.x;\n    state_nei[id][4] = odom->twist.twist.linear.y;\n    state_nei[id][5] = odom->twist.twist.linear.z;\n    state_nei[id][6] = odom->twist.twist.angular.x;\n    state_nei[id][7] = odom->twist.twist.angular.y;\n    state_nei[id][8] = odom->twist.twist.angular.z;\n\n    if (sim_mode) {\n        if (((start_pos - state_nei[id]).norm()) > 5.0) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    } else {\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 65.3329056308729}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\n    if (odom->child_frame_id == \"base_link\") {\n\n        state_nei[id] << odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z;\n\n        if (sim_mode) {\n\n            if (get_nei_state) {\n\n                if (get_dist(start_pos, state_nei[id]) > 5) {\n\n                    get_nei_state = false;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 36.68538063282277}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    // update the state of the UGV based on its odometry data\n    state_nei[id].pos = odom->pose.pose.position;\n    state_nei[id].height = odom->pose.pose.position.z;\n\n    // check the distance from the start position and set the get_nei_state flag to false if the distance exceeds 5 meters\n    if (simulation) {\n        if ((start_pos-state_nei[id]).norm() > 5) {\n            get_nei_state[id] = false;\n        }\n        else {\n            get_nei_state[id] = true;\n        }\n    }\n    else {\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 54.6408826026898}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    if (!odom_ready)\n        return;\n\n    if (!sensor_ready) {\n        sensor_ready = true;\n        return;\n    }\n\n    if (update_counter % 5 == 0) {\n        pcl::fromROSMsg(*msg, *cloud);\n        Astar_ptr->Occupy_map_ptr->update_map(cloud);\n        update_counter = 0;\n    }\n    update_counter++;\n}", "CodeBleu_score": 50.96970415127304}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    if (!odom_ready)\n        return;\n\n    sensor_ready = true;\n    update_counter++;\n\n    if (update_counter % 5 == 0) {\n        update_counter = 0;\n\n        // convert the point cloud data to a point cloud message\n        pcl::PointCloud<pcl::PointXYZ> cloud;\n        pcl::fromROSMsg(*msg, cloud);\n\n        // update the map with the new point cloud data\n        Astar_ptr->Occupy_map_ptr->update_map(cloud);\n\n        // reset the update counter\n        update_counter = 0;\n    }\n}", "CodeBleu_score": 61.567933464176136}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n  // Check if odometry is ready\n  if (!odom_ready) {\n    return;\n  }\n\n  // If odometry is ready, increment update counter\n  update_count++;\n\n  // If update counter is divisible by 5, update the map\n  if (update_count % 5 == 0) {\n    // Update the map\n    astar_ptr->Occupy_map_ptr->update_map(msg);\n    // Reset the update counter\n    update_count = 0;\n  }\n\n  // Set the sensor ready flag to true\n  sensor_ready = true;\n\n}", "CodeBleu_score": 57.61066240710151}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl == false) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_point_cloud);\n    inflate_point_cloud();\n  }\n}", "CodeBleu_score": 44.826128526332695}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n  // Check if the global point cloud has been updated\n  if (!get_gpcl) {\n    // Set the flag\n    get_gpcl = true;\n\n    // Convert the sensor message to a point cloud\n    pcl::fromROSMsg(*global_point, *global_cloud);\n\n    // Store the point cloud\n    store_global_cloud();\n\n    // Inflate the point cloud\n    inflate_point_cloud();\n  }\n}", "CodeBleu_score": 46.026267947379864}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (!get_gpcl) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *g_point_cloud);\n    inflate_point_cloud();\n  }\n}", "CodeBleu_score": 43.4597745272199}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // 1. Project the laser scan into a PointCloud2 format\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*local_point, cloud);\n\n    // 2. Convert the PointCloud2 format to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ> cloud_filtered;\n    // Create the filtering object: downsample the dataset using a leaf size of 1cm\n    pcl::VoxelGrid<pcl::PointXYZ> vg;\n    vg.setLeafSize(0.01f, 0.01f, 0.01f);\n    vg.setInputCloud(cloud.makeShared());\n    vg.filter(cloud_filtered);\n\n    // 3. If not in simulation mode, merge the local map with the provided odometry data\n    if (!simulation_mode) {\n        // 3.1. Project the odometry information into a PointCloud2 format\n        pcl::PointCloud<pcl::PointXYZ> odom_cloud;\n        pcl::fromROSMsg(local_map_merge_odom, odom_cloud);\n\n        // 3.2. Convert the PointCloud2 format to a pcl::PointCloud\n        pcl::PointCloud<pcl::PointXYZ> odom_cloud_filtered;\n        // Create the filtering object: downsample the dataset using a leaf size of 1cm\n        pcl::VoxelGrid<pcl::PointXYZ> vg;\n        vg.setLeafSize(0.01f, 0.01f, 0.01f);\n        vg.setInputCloud(odom_cloud.makeShared());\n        vg.filter(odom_cloud_filtered);\n\n        // 3.3. Merge the local map with the odometry information\n        pcl::PointCloud<pcl::PointXYZ> merged_cloud;\n        pcl::PointCloud<pcl::PointXYZ> merged_cloud_filtered;\n        pcl::concatenatePointCloud(cloud_filtered, odom_cloud_filter", "CodeBleu_score": 44.48479555030332}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    // 1. Convert the laser scan data into a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*local_point, cloud);\n\n    // 2. Transform the laser scan into the map frame\n    pcl::PointCloud<pcl::PointXYZ> cloud_map;\n    pcl_ros::transformPointCloud(map_frame_, cloud, cloud_map, *tf_listener_ptr_);\n\n    // 3. Transform the laser scan into the odom frame\n    pcl::PointCloud<pcl::PointXYZ> cloud_odom;\n    pcl_ros::transformPointCloud(odom_frame_, cloud, cloud_odom, *tf_listener_ptr_);\n\n    // 4. Merge the laser scan into the local map\n    pcl::PointCloud<pcl::PointXYZ> cloud_merged;\n    pcl::PointCloud<pcl::PointXYZ> cloud_merged_map;\n    pcl::PointCloud<pcl::PointXYZ> cloud_merged_odom;\n    pcl::concatenatePointCloud(local_map_, cloud_map, cloud_merged);\n    pcl::concatenatePointCloud(cloud_merged, cloud_odom, cloud_merged_map);\n    pcl::concatenatePointCloud(local_map_, cloud_odom, cloud_merged_odom);\n\n    // 5. Project the laser scan into the map frame\n    pcl::PointCloud<pcl::PointXYZ> cloud_projected;\n    pcl::ProjectInliers<pcl::PointXYZ> proj;\n    proj.setInputCloud(cloud_merged_map.makeShared());\n    proj.setModelType(pcl::SACMODEL_PLANE);\n    proj.setInputTarget(local_map_.makeShared());\n    proj.setAngleThreshold(0.0174532925);\n    proj.filter(cloud_projected);\n\n    // 6. Update the occupancy map\n    for (", "CodeBleu_score": 42.51564653338706}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // Create a PCL point cloud from the laser scan\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*local_point, cloud);\n\n    // If not in simulation mode, merge the local map with the odometry data\n    if (!simulation_mode_) {\n        local_map_merge_odom(cloud, odom);\n    }\n\n    // Project the laser scan into the occupancy map\n    projector_.projectLaser(cloud, *map_);\n\n    // Update the map\n    map_->update();\n\n    // Publish the map\n    map_pub_.publish(map_->getOccupancyGridMsg());\n\n    // Publish the map meta data\n    map_meta_pub_.publish(map_->getMapMetaDataMsg());\n\n    // Publish the map update\n    map_update_pub_.publish(map_->getMapUpdateMsg());\n\n    // Publish the map update\n    map_update_full_pub_.publish(map_->getMapUpdateFullMsg());\n}", "CodeBleu_score": 47.54225064840668}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n    // Convert the global point cloud map to a ROS message\n    pcl::toROSMsg(*global_pcl_map, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_msg.header.stamp = ros::Time::now();\n\n    // Publish the global point cloud map\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // Convert the inflated point cloud map to a ROS message\n    pcl::toROSMsg(*inflate_pcl_map, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_msg.header.stamp = ros::Time::now();\n\n    // Publish the inflated point cloud map\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 51.335277905944864}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t//convert the global point cloud map to a ROS message and publish it with the frame ID \"world\" to the global_pcl_pub topic\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl;\n\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl;\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl_temp;\n\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl_temp;\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl_temp_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl_temp_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl_temp_filtered_down;\n\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl_temp_filtered_down;\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl_temp_filtered_down_voxel;\n\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl_temp_filtered_down_voxel;\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl_temp_filtered_down_voxel_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl_temp_filtered_down_voxel_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl_temp_filtered_down_voxel_filtered_down;\n\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl_temp_filtered_down_voxel_filtered_down;\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl_temp_filtered_down_voxel_filtered_down_voxel;\n\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl_temp_filtered_down_voxel_filtered_down_voxel;\n\t", "CodeBleu_score": 10.089204399319293}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  pcl::PointCloud<pcl::PointXYZI> pcl_map;\n  pcl::PointCloud<pcl::PointXYZI> inflated_pcl_map;\n  pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_map_ptr(new pcl::PointCloud<pcl::PointXYZI>);\n  pcl::PointCloud<pcl::PointXYZI>::Ptr inflated_pcl_map_ptr(new pcl::PointCloud<pcl::PointXYZI>);\n  pcl_map.header.frame_id = \"world\";\n  pcl_map.header.stamp = ros::Time::now();\n  inflated_pcl_map.header.frame_id = \"world\";\n  inflated_pcl_map.header.stamp = ros::Time::now();\n  pcl_map.points.resize(map_.size());\n  inflated_pcl_map.points.resize(map_.size());\n  for (unsigned int i = 0; i < map_.size(); i++) {\n    pcl_map.points[i].x = map_[i].x;\n    pcl_map.points[i].y = map_[i].y;\n    pcl_map.points[i].z = map_[i].z;\n    pcl_map.points[i].intensity = map_[i].z;\n    inflated_pcl_map.points[i].x = map_[i].x;\n    inflated_pcl_map.points[i].y = map_[i].y;\n    inflated_pcl_map.points[i].z = map_[i].z;\n    inflated_pcl_map.points[i].intensity = map_[i].z;\n  }\n  pcl_map_ptr->points = pcl_map.points;\n  inflated_pcl_map_ptr->points = inflated_pcl_map.points;\n  pcl_map_ptr->header = pcl_map.header;\n  inflated_pcl_map_ptr->header = inflated_pcl", "CodeBleu_score": 42.25786423286062}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    //ROS_INFO(\"GLOBAL PLANNER: point cloud callback\");\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not yet initialized, do nothing\n    if (!astar_ptr->Occupy_map_ptr->map_initialized) {\n        return;\n    }\n\n    // if the map is not", "CodeBleu_score": 44.54735268811932}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"L", "CodeBleu_score": 8.102249598017474}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    // Update the map\n    if (astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, astar_ptr->Occupy_map_ptr->origin_shift)) {\n        ROS_INFO(\"[Global Planner] Pointcloud received and map updated!\");\n    }\n\n    // Update the odometry\n    if (astar_ptr->Occupy_map_ptr->odom_update_lpcl(msg, astar_ptr->Occupy_map_ptr->origin_shift)) {\n        ROS_INFO(\"[Global Planner] Pointcloud received and odometry updated!\");\n    }\n\n    // Check if the map and odometry are ready\n    if (astar_ptr->Occupy_map_ptr->map_update_lpcl && astar_ptr->Occupy_map_ptr->odom_update_lpcl) {\n        sensor_ready = true;\n    }\n}", "CodeBleu_score": 47.211141028805294}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Get the current time\n    ros::Time time = ros::Time::now();\n\n    // Get the time from the last control loop\n    ros::Duration dt = time - last_time_;\n\n    // Get the current pose of the robot\n    Eigen::Vector3d position;\n    Eigen::Vector3d eulerAngles;\n    Eigen::Vector3d angularVelocity;\n    Eigen::Vector3d angularAcceleration;\n    Eigen::Vector3d linearVelocity;\n    Eigen::Vector3d linearAcceleration;\n    Eigen::Vector3d orientation;\n    Eigen::Vector3d velocity;\n    Eigen::Vector3d acceleration;\n    Eigen::Vector3d angularMomentum;\n    Eigen::Vector3d linearMomentum;\n    Eigen::Vector3d inertia;\n    Eigen::Vector3d inertiaWorld;\n    Eigen::Vector3d coriolis;\n    Eigen::Vector3d gravity;\n    Eigen::Vector3d externalForce;\n    Eigen::Vector3d externalTorque;\n    Eigen::Vector3d externalForceWorld;\n    Eigen::Vector3d externalTorqueWorld;\n    Eigen::Vector3d centerOfMass;\n    Eigen::Vector3d centerOfMassWorld;\n    Eigen::Vector3d comVelocity;\n    Eigen::Vector3d comAcceleration;\n    Eigen::Vector3d comAngularVelocity;\n    Eigen::Vector3d comAngularAcceleration;\n    Eigen::Vector3d comLinearAcceleration;\n    Eigen::Vector3d comLinearVelocity;\n    Eigen::Vector3d comAngularMomentum;\n    Eigen::Vector3d comLinearMomentum;\n    Eigen::Vector3d comInertia;\n    Eigen::Vector3d comInertiaWorld;\n    Eigen::Vector3d comCoriolis;\n    Eigen::Vector3d comGravity;\n    Eigen::Vector3d comExternalForce;\n    Eigen::Vector3d comExternalTorque;\n    Eigen::Vector3", "CodeBleu_score": 15.792415780426444}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n  // Get the time of the current control loop\n  const ros::Time& time = ros::Time::now();\n  const ros::Duration& dt = time - last_control_loop_time_;\n  last_control_loop_time_ = time;\n\n  // Get the current pose of the robot\n  quadruped_common::QuadrupedPose current_pose;\n  getCurrentPose(current_pose);\n\n  // Get the current pose of the robot\n  quadruped_common::QuadrupedPose desired_pose;\n  getDesiredPose(desired_pose);\n\n  // Get the current joint positions\n  quadruped_common::QuadrupedJointPositions current_joint_positions;\n  getCurrentJointPositions(current_joint_positions);\n\n  // Get the current joint velocities\n  quadruped_common::QuadrupedJointVelocities current_joint_velocities;\n  getCurrentJointVelocities(current_joint_velocities);\n\n  // Get the current joint accelerations\n  quadruped_common::QuadrupedJointAccelerations current_joint_accelerations;\n  getCurrentJointAccelerations(current_joint_accelerations);\n\n  // Get the current joint torques\n  quadruped_common::QuadrupedJointTorques current_joint_torques;\n  getCurrentJointTorques(current_joint_torques);\n\n  // Get the current joint torques\n  quadruped_common::QuadrupedJointEfforts current_joint_efforts;\n  getCurrentJointEfforts(current_joint_efforts);\n\n  // Get the current foot positions\n  quadruped_common::QuadrupedFootPositions current_foot_positions;\n  getCurrentFootPositions(current_foot_positions);\n\n  // Get the current foot velocities\n  quadruped_common::QuadrupedFootVelocities current_foot_velocities;\n  getCurrentFootVelocities(current_foot_velocities);\n\n  // Get the current foot acceler", "CodeBleu_score": 36.27112818339533}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Get the current time\n  ros::Time current_time = ros::Time::now();\n\n  // Get the current time in the simulator\n  double sim_time = sim_time_controller_.getSimTime();\n\n  // Get the current time in the simulator\n  double real_time = ros::Time::now().toSec();\n\n  // Get the current time in the simulator\n  double real_time_diff = real_time - last_real_time_;\n\n  // Get the current time in the simulator\n  last_real_time_ = real_time;\n\n  // Get the current time in the simulator\n  double sim_time_diff = sim_time - last_sim_time_;\n\n  // Get the current time in the simulator\n  last_sim_time_ = sim_time;\n\n  // Get the current time in the simulator\n  double sim_time_diff_sec = sim_time_diff / 1000.0;\n\n  // Get the current time in the simulator\n  double real_time_diff_sec = real_time_diff;\n\n  // Get the current time in the simulator\n  double real_time_diff_sec_sec = real_time_diff_sec / 1000.0;\n\n  // Get the current time in the simulator\n  double sim_time_diff_sec_sec = sim_time_diff_sec / 1000.0;\n\n  // Get the current time in the simulator\n  double sim_time_diff_sec_sec_sec = sim_time_diff_sec_sec / 1000.0;\n\n  // Get the current time in the simulator\n  double sim_time_diff_sec_sec_sec_sec = sim_time_diff_sec_sec_sec / 1000.0;\n\n  // Get the current time in the simulator\n  double sim_time_diff_sec_sec_sec_sec_sec = sim_time_diff_sec_sec_sec_sec / 1000.0;\n\n  // Get the current time in the simulator\n  double sim_time_diff_sec_sec_sec_", "CodeBleu_score": 31.862132160513845}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publishing_enabled_ && !is_in_gazebo_) {\n    contacts_msg_.contacts.resize(4);\n    for (size_t i = 0; i < 4; i++) {\n      contacts_msg_.contacts[i].contact_state = foot_contacts[i] ? ContactState::CONTACT : ContactState::NO_CONTACT;\n      contacts_msg_.contacts[i].timestamp = ros::Time::now();\n      contacts_msg_.contacts[i].robot_side = base_.legs[i]->robot_side_;\n      contacts_msg_.contacts[i].contact_phase = base_.legs[i]->gait_phase_;\n    }\n    foot_contacts_publisher_.publish(contacts_msg_);\n  }\n}", "CodeBleu_score": 57.95683676160166}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publishing_enabled_ && !is_in_gazebo_) {\n    // Create a ContactsStamped message.\n    contacts_msg_.contacts.resize(4);\n    for (size_t i = 0; i < 4; i++) {\n      contacts_msg_.contacts[i].name = base_.legs[i]->name_;\n      contacts_msg_.contacts[i].state = foot_contacts[i];\n      contacts_msg_.contacts[i].gait_phase = base_.legs[i]->gait_phase_;\n      contacts_msg_.contacts[i].time_stamp = ros::Time::now();\n    }\n\n    // Publish the message.\n    foot_contacts_publisher_.publish(contacts_msg_);\n  }\n}", "CodeBleu_score": 60.07385107340113}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publishing_enabled_ && !in_gazebo_) {\n    contacts_msg_.contacts.resize(4);\n    for (size_t i = 0; i < 4; ++i) {\n      contacts_msg_.contacts[i].name = base_.legs[i]->gait_phase;\n      contacts_msg_.contacts[i].state = foot_contacts[i];\n    }\n    foot_contacts_publisher_.publish(contacts_msg_);\n  }\n}", "CodeBleu_score": 53.67898951050078}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    joints_msg = Joints()\n    joints_msg.header = joints.header\n    joints_msg.name = joints.name\n    joints_msg.position = joints.position[0:12]\n    self.pub_joints.publish(joints_msg)\n\n    trajectory = JointTrajectory()\n    trajectory.header = joints.header\n    trajectory.joint_names = joints.name\n    trajectory.points = [JointTrajectoryPoint()]\n    trajectory.points[0].positions = joints.position[0:12]\n    trajectory.points[0].time_from_start = rospy.Duration(self.duration)\n    self.pub_trajectory.publish(trajectory)\n\n    rospy.loginfo(\"Joints message published\")\n    rospy.loginfo(\"Joint trajectory message published\")\n}", "CodeBleu_score": 42.41494820070169}, {"code": "def joints_cmd_callback(self, joints){\n\t    joints_msg = Joints()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.header.frame_id = \"base_link\"\n    joints_msg.name = joints.name\n    joints_msg.position = joints.position[:12]\n    self.joints_pub.publish(joints_msg)\n\n    traj = JointTrajectory()\n    traj.header.stamp = rospy.Time.now()\n    traj.header.frame_id = \"base_link\"\n    traj.joint_names = joints.name\n    traj.points = [JointTrajectoryPoint()]\n    traj.points[0].positions = joints.position[:12]\n    traj.points[0].time_from_start = rospy.Duration(0.5)\n    self.traj_pub.publish(traj)\n\n    # print \"Joints message published\"\n}", "CodeBleu_score": 45.08914583225562}, {"code": "def joints_cmd_callback(self, joints){\n\t    joints_msg = Joints()\n    joints_msg.joint_names = joints.joint_names\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.header.frame_id = \"base_link\"\n    joints_msg.position = joints.position[0:12]\n    self.joints_pub.publish(joints_msg)\n\n    joint_traj = JointTrajectory()\n    joint_traj.header.stamp = rospy.Time.now()\n    joint_traj.header.frame_id = \"base_link\"\n    joint_traj.joint_names = joints.joint_names\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[0:12]\n    point.time_from_start = rospy.Duration(1.0)\n    joint_traj.points.append(point)\n    self.joint_traj_pub.publish(joint_traj)\n}", "CodeBleu_score": 51.376274109641315}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    for (int i = 0; i < _msg->contact_size(); i++) {\n        std::vector<std::string> collision1_split;\n        boost::split(collision1_split, _msg->contact(i).collision1, boost::is_any_of(\"/\"));\n        std::vector<std::string> collision2_split;\n        boost::split(collision2_split, _msg->contact(i).collision2, boost::is_any_of(\"/\"));\n        if (collision1_split.size() == 2 && collision2_split.size() == 2) {\n            if (collision1_split[1] == \"foot_L\" || collision1_split[1] == \"foot_R\") {\n                if (collision2_split[1] == \"foot_L\" || collision2_split[1] == \"foot_R\") {\n                    foot_contact[0] = true;\n                }\n            }\n            if (collision1_split[1] == \"foot_R\" || collision1_split[1] == \"foot_L\") {\n                if (collision2_split[1] == \"foot_R\" || collision2_split[1] == \"foot_L\") {\n                    foot_contact[1] = true;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 41.074280457294925}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  // Initialize foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    foot_contact[i] = false;\n  }\n\n  // For each contact in the message, split the collision string to identify the contact link\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::vector<std::string> collision_string;\n    std::stringstream ss(_msg->contact(i).collision2);\n    std::string token;\n    while (std::getline(ss, token, '/')) {\n      collision_string.push_back(token);\n    }\n\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true\n    if (collision_string[1] == \"l_foot\" || collision_string[1] == \"r_foot\") {\n      if (collision_string[2] == \"l_foot_contact\") {\n        foot_contact[0] = true;\n      } else if (collision_string[2] == \"r_foot_contact\") {\n        foot_contact[1] = true;\n      } else if (collision_string[2] == \"l_foot_contact_2\") {\n        foot_contact[2] = true;\n      } else if (collision_string[2] == \"r_foot_contact_2\") {\n        foot_contact[3] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 53.5178726628575}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  // Initialize foot contact states to false\n  leftFootContact = false;\n  rightFootContact = false;\n  leftFootContact2 = false;\n  rightFootContact2 = false;\n\n  // For each contact in the message, split the collision string to identify the contact link\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true\n    if (std::strstr(_msg->contact(i).collision2.c_str(), \"left_foot_link\") != NULL) {\n      leftFootContact = true;\n    }\n    if (std::strstr(_msg->contact(i).collision2.c_str(), \"right_foot_link\") != NULL) {\n      rightFootContact = true;\n    }\n    if (std::strstr(_msg->contact(i).collision2.c_str(), \"left_foot_link_2\") != NULL) {\n      leftFootContact2 = true;\n    }\n    if (std::strstr(_msg->contact(i).collision2.c_str(), \"right_foot_link_2\") != NULL) {\n      rightFootContact2 = true;\n    }\n  }\n}", "CodeBleu_score": 38.05415393273292}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n  Eigen::Vector3d desired_acceleration = ComputeDesiredAcceleration();\n  Eigen::Vector3d desired_angular_acceleration = ComputeDesiredAngularAcceleration();\n  Eigen::Vector3d desired_thrust =\n      ComputeDesiredThrust(desired_acceleration, desired_angular_acceleration);\n  Eigen::Vector3d desired_angular_acceleration_thrust =\n      ComputeDesiredAngularAccelerationThrust(desired_angular_acceleration,\n                                              desired_thrust);\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  for (size_t i = 0; i < vehicle_parameters_.rotor_configuration_.rotors.size();\n       ++i) {\n    (*rotor_velocities)[i] =\n        vehicle_parameters_.rotor_configuration_.rotors[i].direction.dot(\n            desired_angular_acceleration_thrust);\n  }\n}", "CodeBleu_score": 44.06761035092228}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n  assert(rotor_velocities->size() == vehicle_parameters_.rotor_configuration_.rotors.size());\n\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_angular_acceleration;\n  ComputeDesiredAcceleration(&desired_acceleration, &desired_angular_acceleration);\n\n  Eigen::Vector3d thrust_vector =\n      desired_acceleration.dot(odometry_.orientation.toRotationMatrix().col(2)) *\n      vehicle_parameters_.rotor_configuration_.rotors.front().direction;\n  Eigen::Vector3d angular_acceleration_thrust =\n      angular_acceleration_thrust_.dot(odometry_.orientation.toRotationMatrix().col(2)) *\n      vehicle_parameters_.rotor_configuration_.rotors.front().direction;\n  thrust_vector += angular_acceleration_thrust;\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  for (size_t i = 0; i < vehicle_parameters_.rotor_configuration_.rotors.size(); ++i) {\n    (*rotor_velocities)(i) =\n        vehicle_parameters_.rotor_configuration_.rotors[i].direction.dot(thrust_vector) /\n        vehicle_parameters_.rotor_configuration_.rotors[i].thrust_coefficient;\n  }\n\n  rotor_velocities->cwiseSqrt();\n  rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->size()));\n}", "CodeBleu_score": 51.389229431864024}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n  assert(rotor_velocities->rows() == vehicle_parameters_.rotor_configuration_.rotors.size());\n\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_angular_acceleration;\n  ComputeDesiredAcceleration(&desired_acceleration, &desired_angular_acceleration);\n\n  Eigen::Vector3d thrust =\n      ComputeDesiredThrust(desired_acceleration, desired_angular_acceleration);\n\n  Eigen::Vector3d angular_acceleration_thrust =\n      desired_angular_acceleration.cross(thrust);\n\n  rotor_velocities->block<3, 1>(0, 0) =\n      odometry_.orientation.toRotationMatrix().col(2) *\n          (angular_acceleration_thrust.dot(\n              odometry_.orientation.toRotationMatrix().col(2))) +\n      thrust.cwiseSqrt();\n\n  rotor_velocities->block<3, 1>(3, 0) =\n      odometry_.orientation.toRotationMatrix().col(2) *\n          (angular_acceleration_thrust.dot(\n              odometry_.orientation.toRotationMatrix().col(2))) -\n      thrust.cwiseSqrt();\n\n  rotor_velocities->block<3, 1>(0, 0).cwiseMax(Eigen::Vector3d::Zero());\n  rotor_velocities->block<3, 1>(3, 0).cwiseMax(Eigen::Vector3d::Zero());\n\n  rotor_velocities->block<3, 1>(0, 0) =\n      rotor_velocities->block<3, 1>(0, 0) * vehicle_parameters_.rotor_configuration_.rotors.at(0).max_rpm / 60.0;\n ", "CodeBleu_score": 55.070666855055265}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // Compute position and velocity errors.\n  Eigen::Vector3d position_error = odometry_.position - command_trajectory_.position;\n  Eigen::Vector3d velocity_error = odometry_.velocity - command_trajectory_.velocity;\n  // Transform the velocity error to the world frame.\n  velocity_error = odometry_.orientation.toRotationMatrix() * velocity_error;\n\n  // Compute the desired acceleration.\n  *acceleration =\n      position_error.cwiseProduct(position_gain_) +\n      velocity_error.cwiseProduct(velocity_gain_) +\n      Eigen::Vector3d::Constant(mass_ * gravity_) -\n      Eigen::Vector3d::Constant(command_trajectory_.acceleration);\n}", "CodeBleu_score": 44.45881873765531}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  Eigen::Vector3d position_error, velocity_error;\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_velocity;\n\n  // Calculate the position error\n  position_error = odometry_.position - desired_state_.position;\n\n  // Calculate the velocity error\n  velocity_error = odometry_.velocity - desired_state_.velocity;\n\n  // Transform the desired velocity to the world frame\n  desired_velocity = desired_state_.orientation.toRotationMatrix() * desired_state_.velocity;\n\n  // Calculate the desired acceleration\n  desired_acceleration = position_error.cwiseProduct(position_gain_) +\n                         velocity_error.cwiseProduct(velocity_gain_) +\n                         desired_velocity.cwiseProduct(mass_ * gravity_) -\n                         odometry_.acceleration;\n\n  // Scale the desired acceleration by the maximum acceleration\n  desired_acceleration = desired_acceleration.cwiseProduct(max_acceleration_);\n\n  // Store the desired acceleration in the output argument\n  *acceleration = desired_acceleration;\n}", "CodeBleu_score": 49.72860568224743}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // TODO: Your code here\n  Eigen::Vector3d position_error, velocity_error;\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_velocity;\n  Eigen::Vector3d desired_position;\n  Eigen::Vector3d current_position;\n  Eigen::Vector3d current_velocity;\n  Eigen::Vector3d current_acceleration;\n  Eigen::Vector3d commanded_velocity;\n  Eigen::Vector3d commanded_acceleration;\n  Eigen::Vector3d commanded_position;\n\n  // 1. Compute the position and velocity errors.\n  current_position = odometry_.position;\n  current_velocity = odometry_.velocity;\n  current_acceleration = odometry_.acceleration;\n  commanded_position = command_.position;\n  commanded_velocity = command_.velocity;\n  commanded_acceleration = command_.acceleration;\n\n  position_error = commanded_position - current_position;\n  velocity_error = commanded_velocity - current_velocity;\n\n  // 2. Compute the desired velocity.\n  desired_velocity = velocity_error.cwiseProduct(kp_velocity_);\n  desired_velocity = desired_velocity.cwiseProduct(kp_velocity_);\n  desired_velocity = desired_velocity.cwiseProduct(kp_velocity_);\n  desired_velocity = desired_velocity.cwiseProduct(kp_velocity_);\n  desired_velocity = desired_velocity.cwiseProduct(kp_velocity_);\n  desired_velocity = desired_velocity.cwiseProduct(kp_velocity_);\n  desired_velocity = desired_velocity.cwiseProduct(kp_velocity_);\n  desired_velocity = desired_velocity.cwiseProduct(kp_velocity_);\n  desired_velocity = desired_velocity.cwiseProduct(kp_velocity_);\n  desired_velocity = desired_velocity.cwiseProduct(kp_velocity_);\n ", "CodeBleu_score": 42.17647961802825}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n\n  // Check if the input is valid\n  if (control_attitude_thrust_reference_.size() != 4) {\n    throw std::runtime_error(\"AttitudeControllerSamy::CalculateRotorVelocities: control_attitude_thrust_reference_ must be a vector of size 4\");\n  }\n\n  // Resize rotor velocities to match the number of rotors\n  rotor_velocities->resize(rotor_velocities_->size());\n\n  // Calculate the desired angular acceleration\n  Eigen::VectorXd angular_acceleration_thrust = ComputeDesiredAngularAcc();\n\n  // Combine the desired angular acceleration with the thrust reference\n  Eigen::VectorXd combined_acceleration_thrust = control_attitude_thrust_reference_.cwiseProduct(angular_acceleration_thrust);\n\n  // Calculate the rotor velocities\n  *rotor_velocities = rotor_velocities_ * combined_acceleration_thrust.cwiseSqrt();\n\n  // Ensure the rotor velocities are at least one\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->size()));\n}", "CodeBleu_score": 48.416074930554664}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n  assert(rotor_velocities->size() == 4);\n  assert(control_attitude_thrust_reference_.size() == 4);\n  assert(control_attitude_thrust_reference_.maxCoeff() >= 0);\n  assert(control_attitude_thrust_reference_.minCoeff() <= 1);\n  rotor_velocities->resize(4);\n  Eigen::VectorXd desired_angular_acceleration_thrust =\n      ComputeDesiredAngularAcc(control_attitude_thrust_reference_);\n  *rotor_velocities = rotor_velocities_matrix_ * desired_angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones());\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 56.39777866828501}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities != nullptr);\n  assert(rotor_velocities->size() == 4);\n  assert(control_attitude_thrust_reference_ != nullptr);\n  assert(control_attitude_thrust_reference_->size() == 4);\n\n  // Ensure the input is valid\n  if (control_attitude_thrust_reference_->norm() < 0.001) {\n    return;\n  }\n\n  // Resize the rotor velocities vector to match the number of rotors\n  rotor_velocities->resize(4);\n\n  // Compute the desired angular acceleration\n  Eigen::VectorXd angular_acceleration_thrust =\n      ComputeDesiredAngularAcc(control_attitude_thrust_reference_);\n\n  // Combine the desired angular acceleration and thrust reference into a single vector\n  Eigen::VectorXd combined_vector =\n      angular_acceleration_thrust.cwiseProduct(*control_attitude_thrust_reference_);\n\n  // Compute the rotor velocities by multiplying with a predefined matrix\n  *rotor_velocities = combined_vector.cwiseProduct(rotor_velocity_scaling_matrix_);\n\n  // Ensure the rotor velocities are at least one\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(4));\n\n  // Take the square root of each component\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 53.88915672605115}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attribute in self.__dict__:\n        if attribute != 'times':\n            copied_obj.__setattr__(attribute, self.__getattribute__(attribute)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 49.353616004104914}, {"code": "def slice(self, start_time, end_time)\n\t\n\n    # Find the indices corresponding to the start and end times\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n\n    # Make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n\n    # Update the copied object's attributes to contain only the sliced data\n    copied_obj.__setattr__('data', copied_obj.data[start_index:end_index])\n    copied_obj.__setattr__('times', copied_obj.times[start_index:end_index])\n    copied_obj.__setattr__('indices', copied_obj.indices[start_index:end_index])\n    copied_obj.__setattr__('start_time', copied_obj.times[start_index])\n    copied_obj.__setattr__('end_time', copied_obj.times[end_index])\n    copied_obj.__setattr__('length', end_index - start_index)\n\n    return copied_obj\n\n", "CodeBleu_score": 28.7780145185031}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices of the start and end times\n    start_index = self.get_index_from_time(start_time)\n    end_index = self.get_index_from_time(end_time)\n    # Make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n    # Update the attributes of the copied object\n    copied_obj.__getattribute__('start_index') = start_index\n    copied_obj.__getattribute__('end_index') = end_index\n    copied_obj.__getattribute__('start_time') = start_time\n    copied_obj.__getattribute__('end_time') = end_time\n    copied_obj.__getattribute__('start_time_string') = self.start_time_string[start_index:end_index]\n    copied_obj.__getattribute__('end_time_string') = self.end_time_string[start_index:end_index]\n    copied_obj.__getattribute__('start_time_index') = self.start_time_index[start_index:end_index]\n    copied_obj.__getattribute__('end_time_index') = self.end_time_index[start_index:end_index]\n    copied_obj.__getattribute__('start_time_index_string') = self.start_time_index_string[start_index:end_index]\n    copied_obj.__getattribute__('end_time_index_string') = self.end_time_index_string[start_index:end_index]\n    copied_obj.__getattribute__('start_time_index_string_2') = self.start_time_index_string_2[start_index:end_index]\n    copied_obj.__getattribute__('end_time_index_string_2') = self.end_time_index_string_2[start_index:end_index]\n    copied_obj.__getattribute__('start_time_index_string_3') = self.start_time_index_string_3[start_index:end_index]\n    copied_obj.__getattribute__('end_time_index_string_3') = self.end_time", "CodeBleu_score": 20.666418566717187}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Check if the waypoint is new\n    if self.last_waypoint_msg is not None:\n        if self.last_waypoint_msg.pose.pose.position.x != waypoint_msg.pose.pose.position.x or self.last_waypoint_msg.pose.pose.position.y != waypoint_msg.pose.pose.position.y or self.last_waypoint_msg.pose.pose.position.z != waypoint_msg.pose.pose.position.z or self.last_waypoint_msg.pose.pose.orientation.x != waypoint_msg.pose.pose.orientation.x or self.last_waypoint_msg.pose.pose.orientation.y != waypoint_msg.pose.pose.orientation.y or self.last_waypoint_msg.pose.pose.orientation.z != waypoint_msg.pose.pose.orientation.z or self.last_waypoint_msg.pose.pose.orientation.w != waypoint_msg.pose.pose.orientation.w:\n            # If the waypoint is new, append the new point, yaw, and corresponding times to their respective arrays\n            self.append_point(waypoint_msg.pose.pose.position.x, waypoint_msg.pose.pose.position.y, waypoint_msg.pose.pose.position.z)\n            self.append_yaw(euler_from_quaternion(waypoint_msg.pose.pose.orientation.x, waypoint_msg.pose.pose.orientation.y, waypoint_msg.pose.pose.orientation.z, waypoint_msg.pose.pose.orientation.w)[2])\n            self.append_times(msg_time, bag_time)\n            # Update the last waypoint message\n            self.last_waypoint_msg = waypoint_msg\n        else:\n            # If the waypoint is not new, update the last waypoint message\n            self.last_waypoint_msg = waypoint_msg\n    else:\n        # If the last waypoint message is None, append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(waypoint_msg.pose.pose.position.x, waypoint", "CodeBleu_score": 21.43614963758687}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    euler_angles = euler_from_quaternion(rotation)\n\n    # Create a Point object from the position\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if (self.last_waypoint == None) or (self.last_waypoint.point.x != point.x) or (self.last_waypoint.point.y != point.y) or (self.last_waypoint.point.z != point.z) or (self.last_waypoint.yaw != euler_angles[2]):\n\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point, msg_time)\n        self.append_times(msg_time, bag_time)\n\n        # Set the last waypoint to the current waypoint\n        self.last_waypoint = waypoint_msg\n\n", "CodeBleu_score": 17.705526955029033}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Check if the current waypoint is different from the last one\n    if self.last_point is None or not self.last_point.is_same(waypoint_msg.pose.position, waypoint_msg.pose.orientation):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(waypoint_msg.pose.position, waypoint_msg.pose.orientation, msg_time, bag_time)\n\n        # Update the last point\n        self.last_point = Point(waypoint_msg.pose.position, waypoint_msg.pose.orientation)\n\n", "CodeBleu_score": 14.868109351535521}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_data_time = bag_time\n        self.imu_data_time_sec = to_sec(self.imu_data_time)\n        self.imu_data_linear_acceleration_x = msg.linear_acceleration.x\n        self.imu_data_linear_acceleration_y = msg.linear_acceleration.y\n        self.imu_data_linear_acceleration_z = msg.linear_acceleration.z\n", "CodeBleu_score": 28.856848535491096}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.acc_x = msg.linear_acceleration.x\n        self.acc_y = msg.linear_acceleration.y\n        self.acc_z = msg.linear_acceleration.z\n        self.time = msg.header.stamp.to_sec()\n        self.bag_time = bag_time\n\n", "CodeBleu_score": 28.128311977610476}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data_raw':\n        self.acceleration_x += msg.linear_acceleration.x\n        self.acceleration_y += msg.linear_acceleration.y\n        self.acceleration_z += msg.linear_acceleration.z\n        self.time += to_sec(msg.header.stamp)\n        self.bag_time += bag_time\n    elif topic == '/imu/data':\n        self.acceleration_x += msg.linear_acceleration.x\n        self.acceleration_y += msg.linear_acceleration.y\n        self.acceleration_z += msg.linear_acceleration.z\n        self.time += to_sec(msg.header.stamp)\n        self.bag_time += bag_time\n    elif topic == '/imu/mag':\n        self.acceleration_x += msg.magnetic_field.x\n        self.acceleration_y += msg.magnetic_field.y\n        self.acceleration_z += msg.magnetic_field.z\n        self.time += to_sec(msg.header.stamp)\n        self.bag_time += bag_time\n    elif topic == '/imu/temp':\n        self.acceleration_x += msg.temperature\n        self.acceleration_y += msg.temperature\n        self.acceleration_z += msg.temperature\n        self.time += to_sec(msg.header.stamp)\n        self.bag_time += bag_time\n", "CodeBleu_score": 25.435733836923635}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure(figsize=(10, 8))\n    fig.suptitle(\"Acceleration Data\")\n    ax = fig.add_subplot(111)\n    # For each acceleration dataset, plot the x, y, and z components over time with different colors and labels\n    for i, a_x in enumerate(self.accelerations):\n        ax.plot(a_x.time, a_x.x, label=\"x-component\", color=self.colors[i], linewidth=2)\n        ax.plot(a_x.time, a_x.y, label=\"y-component\", color=self.colors[i], linewidth=2)\n        ax.plot(a_x.time, a_x.z, label=\"z-component\", color=self.colors[i], linewidth=2)\n    # Add labels for the x and y axes and include a legend\n    pyplot.ylabel(\"Acceleration (m/s^2)\")\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.legend()\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        filename = str(self.plot_prefix) + \"_accelerations\" + plot_suffix + \".png\"\n        pyplot.savefig(filename)\n        print(\"Saved \" + filename)\n    # Display the plot\n    pyplot.show()\n\n", "CodeBleu_score": 49.273546552809655}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n\n    # Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    # Plot the x, y, and z components over time with different colors and labels\n    for i, a in enumerate(self.accelerations):\n        ax.plot(a.x, a.y, a.z, label=a.label)\n\n    # Add labels for the x and y axes\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Add a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = 'accelerations'\n        if plot_suffix is not None:\n            filename = filename + '_' + plot_suffix\n        filename = filename + '.png'\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 31.0293787160144}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure(figsize=(16, 12))\n    fig.suptitle(\"Accelerations\")\n    ax = fig.add_subplot(111)\n\n    # For each acceleration dataset, plot the x, y, and z components over time with different colors and labels\n    for i, accel in enumerate(self.accelerations):\n        ax.plot(accel.x, color=colors[i], label=accel.label)\n        ax.plot(accel.y, color=colors[i], label=accel.label)\n        ax.plot(accel.z, color=colors[i], label=accel.label)\n\n    # Add labels for the x and y axes and include a legend\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.ylabel(\"Acceleration (m/s^2)\")\n    pyplot.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = \"accelerations\"\n        if plot_suffix is not None:\n            filename += plot_suffix\n        filename += \".png\"\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 47.828687177908186}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 28.875053436824683}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for pose_index in pose_indeces:\n        for pose_index2 in pose_indeces:\n            if pose_index < pose_index2:\n                compare_two_xyz(self, pose_index, pose_index2)\n", "CodeBleu_score": 16.71597244403854}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Not enough pose indeces to compare positions\")\n    else:\n        for i in range(len(pose_indeces)-1):\n            compare_two_xyz(self, pose_indeces[i], pose_indeces[i+1])\n\n", "CodeBleu_score": 21.66811606138542}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision_time in self.wrench:\n        if start_time is not None and end_time is not None:\n            if collision_time[0] >= start_time and collision_time[0] <= end_time:\n                collision_times.append(collision_time[0])\n        elif start_time is not None and end_time is None:\n            if collision_time[0] >= start_time:\n                collision_times.append(collision_time[0])\n        elif start_time is None and end_time is not None:\n            if collision_time[0] <= end_time:\n                collision_times.append(collision_time[0])\n        else:\n            collision_times.append(collision_time[0])\n    return collision_times\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 33.04716534925245}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is None:\n            start_time = 0\n        if end_time is None:\n            end_time = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "CodeBleu_score": 20.865982189065775}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision_time in self.wrench:\n        if start_time is None:\n            if collision_time[0] <= end_time:\n                collision_times.append(collision_time)\n        elif end_time is None:\n            if collision_time[0] >= start_time:\n                collision_times.append(collision_time)\n        else:\n            if collision_time[0] >= start_time and collision_time[0] <= end_time:\n                collision_times.append(collision_time)\n    return collision_times\n\n\n", "CodeBleu_score": 38.448516171335115}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 29.32422071502378}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix,\n                                          y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 36.39639869095623}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time=start_time, end_time=end_time, settling_time=absolute_settling_time,\n                                          x_range=x_range, plot_suffix=plot_suffix, y_range=(-1.5, 1.5))\n\n", "CodeBleu_score": 45.810200496045866}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n  // Calculate multiplier\n  float multiplier =\n      (data_vector_map * 1000.0).array().square().sum() /\n      (data_vector_map * 1000.0).array().square().sum().sqrt();\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vector(data, width * height);\n  // Compute RMS noise\n  Eigen::VectorXf rms_noise = data_vector.array().square().sum() /\n                              (data_vector.array().square().sum().sqrt());\n  // Compute noise values\n  Eigen::VectorXf noise = data_vector.array().square() /\n                          (rms_noise.array() * rms_noise.array());\n  // For each pixel, add noise if the pixel value is in range, otherwise set\n  // the pixel to a bad point value\n  for (size_t i = 0; i < data_vector.size(); i++) {\n    if (data_vector[i] >= 0 && data_vector[i] <= 10000) {\n      data[i] = tanf(data_vector[i] * multiplier + noise[i]);\n    } else {\n      data[i] = bad_point_value_;\n    }\n  }\n}", "CodeBleu_score": 58.16611455557873}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (!data) {\n    return;\n  }\n\n  const float multiplier =\n      (1.0f / 1000.0f) * (1.0f / (width * height));\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n  // Calculate the RMS noise\n  const float rms_noise =\n      sqrt(data_vector_map.array().square().sum() * multiplier);\n\n  // Calculate the noise values\n  const float noise = rms_noise * multiplier;\n  const float noise_max = noise * noise_ratio;\n  const float noise_min = noise * (1.0f - noise_ratio);\n\n  // Apply the noise\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_vector_map[i] < noise_max && data_vector_map[i] > noise_min) {\n      data_vector_map[i] +=\n          (noise * (rand() / (RAND_MAX + 1.0f) - 0.5f));\n    } else {\n      data_vector_map[i] = kBadPointValue;\n    }\n  }\n}", "CodeBleu_score": 53.25771726356182}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n  // Calculate multiplier\n  float multiplier = 1.0f / (this->dist * 1000.0f);\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  // Compute RMS noise\n  Eigen::VectorXf rms_noise =\n      (data_vector_map.array() * multiplier).square().sum() /\n      (width * height);\n  rms_noise = rms_noise.sqrt();\n  // Compute noise values\n  Eigen::VectorXf noise =\n      this->noise_multiplier * rms_noise *\n      Eigen::VectorXf::Random(width * height).array().abs();\n  // Add noise\n  for (int i = 0; i < width * height; i++) {\n    if (data_vector_map(i) >= 0 && data_vector_map(i) < 10000) {\n      data_vector_map(i) += noise(i);\n    } else {\n      data_vector_map(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 58.12243516523653}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time.\n  ros::Time current_time = world_->SimTime();\n\n  // Convert the current simulation time to ROS time.\n  ros::Time ros_time(current_time.sec, current_time.nsec);\n\n  // Write the trajectory message to the bag file.\n  trajectory_msg_writer_.write(*trajectory_msg, ros_time);\n}", "CodeBleu_score": 55.566659536485695}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n    // Get the current simulation time\n    ros::Time sim_time = world_->SimTime();\n\n    // Convert the simulation time to ROS time\n    ros::Time ros_time(sim_time.sec, sim_time.nsec);\n\n    // Write the trajectory message to a bag file\n    writeBag(ros_time, trajectory_msg, waypoint_topic_);\n}", "CodeBleu_score": 57.75717596356349}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time ros_time = ros::Time::now();\n  ros::Duration sim_time = world_->SimTime();\n  ros_time += sim_time;\n  bag_->write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 62.007218135136554}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // convert Gazebo time to ROS time\n  ros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n  // prepare a message for actuator velocities\n  gazebo_msgs::Actuators rot_velocities_msg;\n  rot_velocities_msg.header.stamp = ros_time;\n  rot_velocities_msg.header.frame_id = \"world\";\n  rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\n  // iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    rot_velocities_msg.angular_velocities[m->second->GetIndex()] = m->second->GetVelocity(0) * slowdown_factor_;\n  }\n\n  // write the data to a bag file using the specified namespace and motor topic\n  motor_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 59.3144359252487}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  ros::Time ros_now = ros::Time::now();\n  ros::Duration ros_elapsed = ros_now - last_ros_time_;\n  ros::Duration gazebo_elapsed = now - last_gazebo_time_;\n  if (ros_elapsed.toSec() > 0.0 && gazebo_elapsed.toSec() > 0.0) {\n    float gazebo_factor = ros_elapsed.toSec() / gazebo_elapsed.toSec();\n    // Calculate the slowed-down rotational velocities.\n    for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n      // Get the rotational velocity of the motor.\n      double rot_velocity = m->second->GetVelocity(0);\n      // Calculate the slowed-down rotational velocity.\n      double rot_velocity_slowed = rot_velocity * gazebo_factor;\n      // Assign the slowed-down rotational velocity to the message.\n      rot_velocities_msg.angular_velocities[m->first] = rot_velocity_slowed;\n    }\n    // Set the message timestamp.\n    rot_velocities_msg.header.stamp = ros_now;\n    // Write the data to the bag file.\n    rot_velocities_pub_.publish(rot_velocities_msg);\n  }\n  // Update the last simulation time.\n  last_gazebo_time_ = now;\n  // Update the last ROS time.\n  last_ros_time_ = ros_now;\n}", "CodeBleu_score": 51.303872368226045}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  ros::Time ros_now = ros::Time::now();\n  ros::Duration ros_elapsed = ros_now - ros_start_;\n  double sim_elapsed = now.Double() - sim_start_.Double();\n  ros::Duration ros_diff = ros::Duration(sim_elapsed);\n  ros::Time ros_time = ros_start_ + ros_diff;\n  rot_velocities_msg.header.stamp = ros_time;\n\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    double vel = m->second->GetVelocity(0);\n    if (m->second->GetName().find(\"rot\") != std::string::npos) {\n      double slowed_vel = vel * slowdown_factor_;\n      rot_velocities_msg.angular_velocities.push_back(slowed_vel);\n    } else {\n      rot_velocities_msg.linear_velocities.push_back(vel);\n    }\n  }\n\n  // Write to the bag file\n  ros_motor_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 46.75159076440024}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_print_) {\n    gzmsg << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // Convert roll, pitch, yaw rate to aileron, elevator, rudder\n  double roll_angle = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  double pitch_angle = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch());\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n\n  // Set the aileron, elevator, rudder control surfaces\n  SetControlSurface(aileron_, roll_angle, \"aileron\");\n  SetControlSurface(elevator_, pitch_angle, \"elevator\");\n  SetControlSurface(rudder_, yaw_rate, \"rudder\");\n\n  // Set the throttle control surface\n  SetControlSurface(throttle_, roll_pitch_yawrate_thrust_msg->thrust().x(), \"throttle\");\n}", "CodeBleu_score": 45.232308931241526}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_print_) {\n    gzdbg << __FUNCTION__ << \" called\" << std::endl;\n  }\n\n  double roll = roll_pitch_yawrate_thrust_msg->roll();\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch();\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust().x();\n\n  // Normalize input values\n  roll = NormalizedInputToAngle(roll);\n  pitch = NormalizedInputToAngle(pitch);\n  yaw_rate = NormalizedInputToAngle(yaw_rate);\n\n  // Convert normalized input values to angles for control surfaces\n  double ailerons = roll;\n  double elevator = pitch;\n  double rudder = yaw_rate;\n\n  // Set throttle from thrust\n  double throttle = thrust;\n\n  // Publish the control surfaces\n  GzControlSurfacesMsgPtr control_surfaces_msg(\n      new GzControlSurfacesMsg);\n  control_surfaces_msg->set_ailerons(ailerons);\n  control_surfaces_msg->set_elevator(elevator);\n  control_surfaces_msg->set_rudder(rudder);\n  control_surfaces_msg->set_throttle(throttle);\n  control_surfaces_pub_->Publish(control_surfaces_msg);\n}", "CodeBleu_score": 56.040972856686544}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_print_) {\n    gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called.\" << std::endl;\n  }\n\n  double roll = roll_pitch_yawrate_thrust_msg->roll();\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch();\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust().x();\n\n  double roll_angle = NormalizedInputToAngle(roll);\n  double pitch_angle = NormalizedInputToAngle(pitch);\n  double yaw_rate_angle = NormalizedInputToAngle(yaw_rate);\n\n  double ailerons = roll_angle;\n  double elevator = pitch_angle;\n  double rudder = yaw_rate_angle;\n\n  if (debug_print_) {\n    gzdbg << \"Roll: \" << roll << \" -> \" << roll_angle << std::endl;\n    gzdbg << \"Pitch: \" << pitch << \" -> \" << pitch_angle << std::endl;\n    gzdbg << \"Yaw Rate: \" << yaw_rate << \" -> \" << yaw_rate_angle << std::endl;\n    gzdbg << \"Thrust: \" << thrust << std::endl;\n    gzdbg << \"Ailerons: \" << ailerons << std::endl;\n    gzdbg << \"Elevator: \" << elevator << std::endl;\n    gzdbg << \"Rudder: \" << rudder << std::endl;\n  }\n\n  // Set the control surfaces\n  SetControlSurfaces(ailerons, elevator, rudder);\n\n  // Set the throttle\n  SetThrottle(thrust);\n}", "CodeBleu_score": 45.927125455901596}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t\n  // Set the timeout\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Set the file descriptors\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(this->serial_fd, &fds);\n  FD_SET(this->udp_fd, &fds);\n\n  // Poll the file descriptors\n  int ret = select(this->udp_fd > this->serial_fd ? this->udp_fd + 1 : this->serial_fd + 1, &fds, NULL, NULL, &timeout);\n\n  if (ret == -1) {\n    gzerr << \"Error in select()\n\";\n    return;\n  }\n\n  // If data is available, read it\n  if (ret > 0) {\n    if (FD_ISSET(this->udp_fd, &fds)) {\n      this->receiveMAVLinkMessage();\n    }\n    if (FD_ISSET(this->serial_fd, &fds)) {\n      this->receiveMAVLinkMessage();\n    }\n  }\n\n  // Process the messages\n  this->processMAVLinkMessages(_dt);\n}", "CodeBleu_score": 42.451791493210976}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Get the current time\n  struct timeval current_time;\n  gettimeofday(&current_time, NULL);\n\n  // Initialize the timeout structure\n  struct timeval timeout;\n  timeout.tv_sec = _dt;\n  timeout.tv_usec = (_timeoutMs - (_dt * 1000000)) * 1000;\n\n  // Initialize the fd_set structure\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(this->serial_fd_, &readfds);\n\n  // Check if there is data to read\n  int ret = select(this->serial_fd_ + 1, &readfds, NULL, NULL, &timeout);\n  if (ret > 0) {\n    // If there is data to read, receive it\n    uint8_t buffer[BUFFER_SIZE];\n    ret = recv(this->serial_fd_, buffer, BUFFER_SIZE, 0);\n    if (ret > 0) {\n      // Parse the data\n      mavlink_message_t msg;\n      mavlink_status_t status;\n      int len = 0;\n      while ((len = mavlink_parse_char(MAVLINK_COMM_0, buffer[len], &msg,\n                                       &status)) >= 0) {\n        // Handle the message\n        this->handleMessage(msg);\n      }\n    }\n  }\n}", "CodeBleu_score": 48.67873297623283}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = static_cast<int>(_timeoutMs / 1000);\n  timeout.tv_usec = static_cast<int>(_timeoutMs % 1000) * 1000;\n\n  // Poll file descriptors\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(this->serial_fd, &fds);\n\n  // If there's data to read, read it\n  if (this->serial_fd > 0 && select(this->serial_fd + 1, &fds, NULL, NULL,\n      &timeout) > 0) {\n    this->readSerialBuffer();\n  }\n\n  // If there's data to read, read it\n  if (this->udp_fd > 0 && select(this->udp_fd + 1, &fds, NULL, NULL,\n      &timeout) > 0) {\n    this->readUDPBuffer();\n  }\n\n  // If there's data to read, read it\n  if (this->tcpm_fd > 0 && select(this->tcpm_fd + 1, &fds, NULL, NULL,\n      &timeout) > 0) {\n    this->readTCPBuffer();\n  }\n\n  // If there's data to read, read it\n  if (this->tcps_fd > 0 && select(this->tcps_fd + 1, &fds, NULL, NULL,\n      &timeout) > 0) {\n    this->readTCPSBuffer();\n  }\n\n  // If there's data to read, read it\n  if (this->udpm_fd > 0 && select(this->udpm_fd + 1, &fds, NULL, NULL,\n      &timeout) > 0) {\n    this->readUDPMBuffer();\n  }\n\n  // If there's data to read, read it\n  if (this->udps_fd > 0 && select(this->udps_fd + 1, &fds", "CodeBleu_score": 29.962662943596484}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t    std::lock_guard<std::mutex> lock(mutex_);\n    if (is_open_) {\n        io_service_.stop();\n        serial_dev_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n        is_open_ = false;\n    }\n}", "CodeBleu_score": 64.7204826016601}, {"code": "void GazeboMavlinkInterface::close() {\n\t    std::lock_guard<std::mutex> guard(mutex_);\n\n    if (!is_open_) {\n        gzwarn << \"GazeboMavlinkInterface::close() called on closed interface\n\";\n        return;\n    }\n\n    io_service_.stop();\n    serial_dev_.close();\n    io_thread_.join();\n\n    if (io_thread_.joinable()) {\n        io_thread_.join();\n    }\n\n    is_open_ = false;\n}", "CodeBleu_score": 55.88360888657533}, {"code": "void GazeboMavlinkInterface::close() {\n\t  if (is_open) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n}", "CodeBleu_score": 65.24983674328047}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    double x1, y1, z1, x2, y2, z2;\n    double x, y, z;\n    x = x1 + (x2 - x1) * t;\n    y = y1 + (y2 - y1) * t;\n    z = z1 + (z2 - z1) * t;\n    return ignition::math::Vector3d(x, y, z);\n}", "CodeBleu_score": 33.26278622238803}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  /*\n   * This function, GazeboWindPlugin::LinearInterpolation, performs linear interpolation for a given position.", "CodeBleu_score": 11.02431212895609}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    double x1, y1, z1, x2, y2, z2;\n    x1 = x2 = y1 = y2 = z1 = z2 = 0.0;\n    if (position == 0) {\n        x1 = _wind_data[0].x;\n        y1 = _wind_data[0].y;\n        z1 = _wind_data[0].z;\n        x2 = _wind_data[1].x;\n        y2 = _wind_data[1].y;\n        z2 = _wind_data[1].z;\n    }\n    else if (position == 1) {\n        x1 = _wind_data[1].x;\n        y1 = _wind_data[1].y;\n        z1 = _wind_data[1].z;\n        x2 = _wind_data[2].x;\n        y2 = _wind_data[2].y;\n        z2 = _wind_data[2].z;\n    }\n    else if (position == 2) {\n        x1 = _wind_data[2].x;\n        y1 = _wind_data[2].y;\n        z1 = _wind_data[2].z;\n        x2 = _wind_data[3].x;\n        y2 = _wind_data[3].y;\n        z2 = _wind_data[3].z;\n    }\n    else if (position == 3) {\n        x1 = _wind_data[3].x;\n        y1 = _wind_data[3].y;\n        z1 = _wind_data[3].z;\n        x2 = _wind_data[0].x;\n        y2 = _wind_data[0].y;\n        z2 = _wind_data[0].z;\n    }\n    double x = x1 + (x2 - x1) * (position - 1) / 3;\n    double y = y1 + (y2 - y1) * (position - 1) / 3;\n    double z = z1 + (z2 - z1) * (position - 1) / ", "CodeBleu_score": 39.854702169138214}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t  time = _time;\n  if (looping) {\n    if (time > length) {\n      time -= length;\n    }\n    if (time < 0) {\n      time += length;\n    }\n  } else {\n    time = ignition::math::clamp(time, 0.0, length);\n  }\n  if (time != _time) {\n    timeChanged = true;\n  }\n}", "CodeBleu_score": 38.82552027441768}, {"code": "void Animation::SetTime(double _time){\n\t  time = _time;\n  if (loop) {\n    time = fmod(time, length);\n    if (time < 0) {\n      time += length;\n    }\n  }\n  else {\n    time = std::max(0.0, std::min(time, length));\n  }\n  if (time != oldTime) {\n    Update(time);\n  }\n}", "CodeBleu_score": 27.77495228457767}, {"code": "void Animation::SetTime(double _time){\n\t\tif (_time != time) {\n\t\ttime = _time;\n\t\tif (loop) {\n\t\t\ttime = fmod(time, length);\n\t\t} else {\n\t\t\ttime = std::min(length, std::max(0.0, time));\n\t\t}\n\t\tUpdate();\n\t}\n}", "CodeBleu_score": 31.139436392644136}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.construct_target\n    self.target.set_motion_type(0)\n    self.target.set_coordinate_frame(1)\n    print self.vehicle_type, self.vehicle_id, self.flight_mode\n\n", "CodeBleu_score": 19.290547192238265}, {"code": "def hover(self)\n\t\n    self.construct_target\n    self.set_control_mode(1, 0)\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 14.181840872484184}, {"code": "def hover(self)\n\t\n    self.construct_target\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 17.829273616932387}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    # If the flight mode is hover, call the hover method and return\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    # Otherwise, attempt to switch modes using flightModeService\n    else:\n        try:\n            self.flightModeService(flightMode=self.flightMode)\n            print('Mode switch successful')\n            return True\n        except rospy.ServiceException:\n            print('Mode switch failed')\n            return False\n\n", "CodeBleu_score": 33.407542450367}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover = 1\n        self.hover_method()\n    else:\n        try:\n            self.flightModeService(flightMode=self.flightMode)\n            print('Successfully switched to ' + self.flightMode + ' mode.')\n            return True\n        except rospy.ServiceException:\n            print('Failed to switch to ' + self.flightMode + ' mode.')\n            return False\n\n", "CodeBleu_score": 35.955852064171395}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover = 1\n        self.hover()\n    else:\n        try:\n            self.flightModeService(flightMode=self.flightMode)\n            print('Successfully switched to ' + self.flightMode + ' mode.')\n        except rospy.ServiceException:\n            print('Failed to switch to ' + self.flightMode + ' mode.')\n            return False\n    return True\n\n", "CodeBleu_score": 37.02747741242629}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    elif self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n", "CodeBleu_score": 49.801791711238586}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    if self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z, \"enu\")\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.angular.z, \"enu\")\n\n", "CodeBleu_score": 48.18419283739631}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    elif self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n", "CodeBleu_score": 49.801791711238586}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != 'HOVER':\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n    else:\n        if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n\n", "CodeBleu_score": 76.6416077001624}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    hover_flag = 0\n    if self.flight_mode != \"HOVER\":\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            hover_flag = 1\n    else:\n        if x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005:\n            hover_flag = 0\n    if hover_flag == 1:\n        self.flight_mode = \"HOVER\"\n        self.hover()\n    else:\n        self.flight_mode = \"OFFBOARD\"\n\n\n", "CodeBleu_score": 37.2818781807022}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode == 'HOVER':\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            return\n    elif self.flight_mode != 'HOVER':\n        if x < -0.02 or y < -0.02 or z < -0.02 or w < -0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            return\n        elif x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n\n\n", "CodeBleu_score": 50.288835996344496}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw\n\n", "CodeBleu_score": 24.26411761619382}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw()\n    else:\n        return Quaternion(q).yaw()\n\n", "CodeBleu_score": 17.87598314614692}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n\n    # Set the coordinate frame to GLOBAL_TERRAIN_FRAME\n    self.set_coordinate_frame(self.coordinate_frames.GLOBAL_TERRAIN_FRAME)\n\n    # Set the motion type to HOLD\n    self.set_motion_type(self.motion_types.HOLD)\n\n    # Construct the target motion\n    self.construct_target()\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print self.vehicle_type, self.vehicle_id, self.flight_mode\n\n", "CodeBleu_score": 11.85724122167054}, {"code": "def hover(self)\n\t\n\n    # Set the coordinate frame and motion type\n    self.set_coordinate_frame(CoordinateFrame.GLOBAL_OFFSET_Z_DOWN)\n    self.set_motion_type(MotionType.HOVER)\n\n    # Construct a target motion using the current position and yaw values\n    self.construct_target()\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 10.508957231611959}, {"code": "def hover(self)\n\t\n    self.construct_target\n    self.construct_coordinate_frame\n    self.construct_motion_type\n    self.construct_target\n    print\n    self.construct_target\n\n", "CodeBleu_score": 14.949663035256641}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.call(flightMode=self.flightMode)\n            self.flightMode = self.flightModeService.response.flightMode\n            print(self.flightMode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service call failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 35.79514884198808}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService.setFlightMode(self.flightMode):\n            self.flightMode = self.flightModeService.flightMode\n            print 'Flight mode set to', self.flightMode\n            return True\n        else:\n            print 'Failed to set flight mode to', self.flightMode\n            return False\n\n\n", "CodeBleu_score": 39.622182578114604}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        print(\"Switching to hover mode...\")\n        self.hover()\n        return True\n    else:\n        print(\"Switching to \" + self.flightMode + \" mode...\")\n        try:\n            self.flightModeService(flightMode=self.flightMode)\n            print(\"Success!\")\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service call failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 37.260249917845584}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == i:\n        self.local_pose[i] = msg\n        if msg.command == 'takeoff':\n            self.takeoff_target_pose[i] = msg\n        elif msg.command == 'hover':\n            self.hover_target_pose[i] = msg\n        self.global_pose[i] = self.local_pose[i]\n        self.global_pose[i].position.x += self.global_pose_bias.x\n        self.global_pose[i].position.y += self.global_pose_bias.y\n        self.global_pose[i].position.z += self.global_pose_bias.z\n\n", "CodeBleu_score": 31.850098528306166}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.uav_id == i:\n        self.local_pose[i] = msg.pose\n        self.global_pose[i] = self.global_pose[i] + msg.pose\n        if msg.command == \"TAKEOFF\":\n            self.takeoff_target_pose[i] = msg.pose\n        elif msg.command == \"HOVER\":\n            self.hover_target_pose[i] = msg.pose\n\n", "CodeBleu_score": 22.159762444989024}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == i:\n        self.local_pose[i] = msg\n        if self.local_pose[i].id == self.id:\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose[i])\n            self.hover_target_pose = copy.deepcopy(self.local_pose[i])\n        if self.local_pose[i].id == self.id:\n            self.global_pose[i] = copy.deepcopy(self.local_pose[i])\n            self.global_pose[i].x += self.global_pose_bias[0]\n            self.global_pose[i].y += self.global_pose_bias[1]\n            self.global_pose[i].z += self.global_pose_bias[2]\n\n", "CodeBleu_score": 32.73387632533268}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.position[2] > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 55.51174264980296}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.position[2] > 0.2:\n        return True\n    return False\n\n", "CodeBleu_score": 44.201523988205615}, {"code": "def takeoff_detection(self)\n\t\n    if self.drone.armed and self.drone.location.global_relative_frame.alt > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 55.91736596471338}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    # Calculate distance between each UAV in the original formation and the changed formation\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j]) - 50\n    # Return distance matrix\n    return dist_matrix\n", "CodeBleu_score": 24.852001560842908}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # get the number of UAVs\n    num_uavs = len(orig_formation)\n    # create an empty distance matrix\n    dist_matrix = np.zeros((num_uavs, num_uavs))\n    # calculate the pairwise distances between UAVs in the original and changed formations\n    for i in range(num_uavs):\n        for j in range(num_uavs):\n            dist_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n    # adjust the distances by subtracting them from 50 and converting to integers\n    dist_matrix = (dist_matrix - 50).astype(int)\n    # return the distance matrix\n    return dist_matrix\n\n", "CodeBleu_score": 26.2806257749249}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    formation = orig_formation\n    formation_size = len(formation)\n    dist_matrix = np.zeros((formation_size, formation_size))\n    for i in range(formation_size):\n        for j in range(formation_size):\n            dist_matrix[i][j] = np.linalg.norm(formation[i] - formation[j]) - 50\n            dist_matrix[i][j] = int(dist_matrix[i][j])\n    dist_matrix = np.round(dist_matrix)\n    return dist_matrix\n", "CodeBleu_score": 26.194997332301877}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.left_vertices[i].visited = True\n    for j in range(self.right_vertices[i].adjacent):\n        if self.right_vertices[i].adjacent[j].visited == False:\n            if self.right_vertices[i].adjacent[j].label == self.left_vertices[i].label:\n                return True\n            elif self.right_vertices[i].adjacent[j].label < self.left_vertices[i].label:\n                if self.find_path(self.right_vertices[i].adjacent[j].index):\n                    return True\n                else:\n                    self.right_vertices[i].adjacent[j].visited = False\n                    self.right_vertices[i].adjacent[j].label = self.left_vertices[i].label\n            else:\n                if self.right_vertices[i].adjacent[j].label < self.left_vertices[i].label:\n                    self.right_vertices[i].adjacent[j].label = self.left_vertices[i].label\n                elif self.right_vertices[i].adjacent[j].label > self.left_vertices[i].label:\n                    if self.right_vertices[i].adjacent[j].slack > self.left_vertices[i].label - self.right_vertices[i].adjacent[j].label:\n                        self.right_vertices[i].adjacent[j].slack = self.left_vertices[i].label - self.right_vertices[i].adjacent[j].label\n                    self.right_vertices[i].adjacent[j].label = self.left_vertices[i].label\n                else:\n                    self.right_vertices[i].adjacent[j].label = self.left_vertices[i].label\n                    self.right_vertices[i].adjacent[j].slack = 0\n    return False\n\n", "CodeBleu_score": 12.009312020880296}, {"code": "def find_path(self, i)\n\t\n    self.left_vertices[i].visited = True\n    for j in self.right_vertices:\n        if j.visited:\n            continue\n        if self.left_vertices[i].label == j.label:\n            if self.left_vertices[i].label != 0:\n                self.update_match(self.left_vertices[i], j)\n                return True\n            else:\n                self.left_vertices[i].visited = False\n                return False\n        else:\n            if self.left_vertices[i].label < j.label:\n                self.left_vertices[i].slack = j.label - self.left_vertices[i].label\n                self.left_vertices[i].match = j\n                self.left_vertices[i].visited = False\n                return False\n            else:\n                if self.left_vertices[i].slack > j.label - self.left_vertices[i].label:\n                    self.left_vertices[i].slack = j.label - self.left_vertices[i].label\n                    self.left_vertices[i].match = j\n                    self.left_vertices[i].visited = False\n                    return False\n    return False\n\n", "CodeBleu_score": 13.65014363796033}, {"code": "def find_path(self, i)\n\t\n    self.left_vertex[i] = True\n    for j in self.right_vertex[i]:\n        if not self.right_vertex[i][j]:\n            continue\n        if self.left_vertex[j]:\n            continue\n        gap = self.match_weight[i][j] - self.match_weight[i][self.match[i]] - self.match_weight[j][self.match[j]]\n        if gap == 0:\n            if self.find_path(j):\n                self.match[i] = j\n                self.match[j] = i\n                return True\n        else:\n            if self.slack[i] > gap:\n                self.slack[i] = gap\n                self.match_vertex[i] = j\n    self.left_vertex[i] = False\n    return False\n", "CodeBleu_score": 36.53628072194544}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    # Initialize slack variables and visit arrays\n    self.slack = numpy.array([numpy.inf]*self.num_uavs)\n    self.visit = numpy.array([False]*self.num_uavs)\n    self.visit_r = numpy.array([False]*self.num_r)\n    # Iterate over UAVs\n    for i in range(self.num_uavs):\n        # Initialize slack variables and visit arrays\n        self.slack = numpy.array([numpy.inf]*self.num_uavs)\n        self.visit = numpy.array([False]*self.num_uavs)\n        self.visit_r = numpy.array([False]*self.num_r)\n        # Initialize slack variables and visit arrays\n        self.slack = numpy.array([numpy.inf]*self.num_uavs)\n        self.visit = numpy.array([False]*self.num_uavs)\n        self.visit_r = numpy.array([False]*self.num_r)\n        # Initialize slack variables and visit arrays\n        self.slack = numpy.array([numpy.inf]*self.num_uavs)\n        self.visit = numpy.array([False]*self.num_uavs)\n        self.visit_r = numpy.array([False]*self.num_r)\n        # Initialize slack variables and visit arrays\n        self.slack = numpy.array([numpy.inf]*self.num_uavs)\n        self.visit = numpy.array([False]*self.num_uavs)\n        self.visit_r = numpy.array([False]*self.num_r)\n        # Initialize slack variables and visit arrays\n        self.slack = numpy.array([numpy.inf]*self.num_uavs)\n        self.visit = numpy.array([False]*self.num_uavs)\n        self.visit_r = numpy.array([False]*self.num_r)\n        # Initialize slack variables and visit arrays\n        self.slack = numpy.array([numpy.inf]*self.num_uavs)\n        self.vis", "CodeBleu_score": 19.817278811887316}, {"code": "def KM(self)\n\t\n    # Initialize the slack variables and visit arrays\n    self.initialize_variables()\n    # Initialize the slack variables and visit arrays\n    self.initialize_variables()\n    # Iterate over UAVs\n    for uav_id in range(self.num_uavs):\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit arrays\n        self.initialize_variables()\n        # Initialize the slack variables and visit", "CodeBleu_score": 16.57833175246741}, {"code": "def KM(self)\n\t\n    # Initialize slack variables and visit arrays\n    self.slack = np.zeros((self.n_uavs, self.n_sensors))\n    self.visit = np.zeros((self.n_uavs, self.n_sensors), dtype=bool)\n    # Iterate over UAVs\n    for uav in range(self.n_uavs):\n        # Initialize slack variables and visit arrays\n        self.slack[uav, :] = np.zeros(self.n_sensors)\n        self.visit[uav, :] = np.zeros(self.n_sensors, dtype=bool)\n        # Initialize labels\n        self.labels[uav, :] = np.zeros(self.n_sensors)\n        # Find path\n        self.find_path(uav)\n        # If no path is found, adjust labels\n        if self.labels[uav, :].sum() == 0:\n            self.adjust_labels(uav)\n\n    return self.labels\n\n", "CodeBleu_score": 19.20805098629731}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Converting the image to HSV color space\n    hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Creating a mask for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_img, lower_yellow, upper_yellow)\n    # Applying the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 26.620616660869157}, {"code": "def yellow_dectection(image)\n\t\n    # Converting the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Creating a mask for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Applying the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t\n    # Converting the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Creating a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Applying the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 22.008472449757843}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t  // TODO: implement this function\n}", "CodeBleu_score": 0.6648108845887202}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    // TODO:\n    // 1. Check the standalone_tag_descriptions_ map for the given ID.\n    // 2. If the description is not found and printWarning is true, log a warning message.\n    // 3. If found, set the descriptionContainer to the tag's description and return true; otherwise, return false.\n}", "CodeBleu_score": 0.6648108845887202}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  (\n    const std::string& id,\n    std::string& descriptionContainer,\n    bool printWarning\n  )\n}", "CodeBleu_score": 1.077400402067034}]}
