{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint16_t len;\n\tuint8_t type;\n\n\twhile (desc) {\n\t\tlen = desc->bLength;\n\t\ttype = desc->bDescriptorType;\n\t\tif (type == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)desc + len);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 38.21989931469418}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bDescriptorType != desc_id) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc + desc->bLength);\n\t\tif (desc->bLength == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn desc;\n}", "CodeBleu_score": 32.754103568980256}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *p_desc = (uint8_t *) desc;\n\tuint8_t *p_end = p_desc + desc->w_total_length;\n\tuint8_t desc_type = 0;\n\n\twhile (p_desc < p_end) {\n\t\tdesc_type = *p_desc;\n\t\tif (desc_type == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p_desc;\n\t\t}\n\t\tp_desc += *(uint16_t *) (p_desc + 2);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 39.64649481744195}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    if (!udc_get_eof_conf()) {\n        return false;\n    }\n\n    uint8_t *desc_ptr = (uint8_t *)&UDC_DESC_BUF;\n    uint8_t desc_type = *desc_ptr++;\n    uint8_t desc_len = *desc_ptr++;\n    uint8_t desc_index = 0;\n    uint8_t iface_index = 0;\n\n    while (desc_type != UDC_DESC_TYPE_EOF) {\n        if (desc_type == UDC_DESC_TYPE_INTERFACE) {\n            if (iface_index == iface_num) {\n                if (setting_num == *desc_ptr) {\n                    return true;\n                }\n            }\n\n            iface_index++;\n        }\n\n        desc_ptr += desc_len;\n        desc_type = *desc_ptr++;\n        desc_len = *desc_ptr++;\n        desc_index++;\n    }\n\n    return false;\n}", "CodeBleu_score": 37.69110521603034}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t i;\n\tuint8_t *desc;\n\tuint16_t len;\n\tuint16_t total_len;\n\tuint16_t conf_len;\n\tuint8_t *conf_desc;\n\tuint8_t *conf_desc_end;\n\tuint8_t *iface_desc;\n\tuint8_t *iface_desc_end;\n\n\t// Check if a valid configuration is selected\n\tif (udc_get_config() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is within bounds\n\tif (iface_num >= udc_get_num_of_ifaces()) {\n\t\treturn false;\n\t}\n\n\t// Get the configuration descriptor\n\tconf_desc = udc_get_config_desc();\n\tconf_desc_end = conf_desc + udc_get_config_desc_len();\n\n\t// Get the length of the configuration descriptor\n\tconf_len = (conf_desc[2] | (conf_desc[3] << 8));\n\n\t// Get the total length of the configuration descriptor\n\ttotal_len = (conf_desc[4] | (conf_desc[5] << 8));\n\n\t// Iterate through the descriptors\n\tfor (i = 0; i < total_len; i++) {\n\n\t\t// Get the descriptor\n\t\tdesc = conf_desc + i;\n\n\t\t// Check if the descriptor is an interface descriptor\n\t\tif (desc[1] == USB_DESC_INTERFACE) {\n\n\t\t\t// Get the length of the interface descriptor\n\t\t\tlen = (desc[2] | (desc[3] << 8));\n\n\t\t\t// Get the end of the interface descriptor\n\t\t\tiface_desc_end = desc + len;\n\n\t\t\t// Check if the interface number and setting number match\n\t\t\tif ((desc[2] == iface_num) && (desc[3] == setting_num)) {\n\n\t\t\t\t// Get the end of the interface descriptor\n\t\t\t\tiface_desc", "CodeBleu_score": 33.249242679138945}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *p_desc;\n\tuint8_t desc_type;\n\tuint8_t desc_len;\n\tuint8_t desc_num;\n\tuint8_t desc_index;\n\tuint8_t desc_count;\n\tuint8_t desc_iface_num;\n\tuint8_t desc_setting_num;\n\tuint8_t desc_ep_num;\n\tuint8_t desc_ep_addr;\n\tuint8_t desc_ep_dir;\n\tuint8_t desc_ep_type;\n\tuint8_t desc_ep_attr;\n\tuint8_t desc_ep_pkt_size;\n\tuint8_t desc_ep_interval;\n\tuint8_t desc_ep_max_pkt_size;\n\tuint8_t desc_ep_max_burst;\n\tuint8_t desc_ep_nak_tx;\n\tuint8_t desc_ep_nak_rx;\n\tuint8_t desc_ep_tx_valid;\n\tuint8_t desc_ep_rx_valid;\n\tuint8_t desc_ep_tx_stalled;\n\tuint8_t desc_ep_rx_stalled;\n\tuint8_t desc_ep_tx_naked;\n\tuint8_t desc_ep_rx_naked;\n\tuint8_t desc_ep_tx_toggle;\n\tuint8_t desc_ep_rx_toggle;\n\tuint8_t desc_ep_tx_nak_timeout;\n\tuint8_t desc_ep_rx_nak_timeout;\n\tuint8_t desc_ep_tx_nak_retry;\n\tuint8_t desc_ep_rx_nak_retry;\n\tuint8_t desc_ep_tx_nak_timeout_retry;\n\tuint8_t desc_ep_rx_nak_timeout_retry;\n\tuint8_t desc_ep_tx_nak_retry_valid;\n\tuint8_t desc_ep_rx_nak_retry_valid;\n\tuint8_t desc_ep_tx_nak_timeout_valid;\n\tuint8", "CodeBleu_score": 6.444451956993051}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num;\n\tuint16_t ep_status;\n\tuint16_t *ep_status_ptr;\n\tuint16_t len;\n\n\t/* Get the endpoint number */\n\tep_num = udd_get_setup_payload_buf()[0];\n\n\t/* Check the request length */\n\tlen = udd_get_setup_payload_len();\n\tif (len != 2) {\n\t\treturn false;\n\t}\n\n\t/* Set the endpoint status */\n\tif (udd_ep_is_halted(ep_num)) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\t/* Set the endpoint status in the response payload */\n\tep_status_ptr = (uint16_t *)udd_get_setup_payload_buf();\n\t*ep_status_ptr = CPU_TO_LE16(ep_status);\n\n\t/* Set the response payload length */\n\tudd_set_setup_payload(2, false);\n\n\treturn true;\n}", "CodeBleu_score": 22.030674972174687}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint16_t ep_status;\n\tuint16_t ep_num;\n\n\t// Check if the request length matches the size of the endpoint status variable.\n\tif (udd_g_ctrlreq.payload_size != 2) {\n\t\treturn false;\n\t}\n\n\t// Determine the status of the specified endpoint, setting the status to \"halted\" if the endpoint is halted, or \"0\" if it is not.\n\tep_num = udd_ctrl_ep_to_logical_num(udd_g_ctrlreq.req.bRequest);\n\tif (udd_ep_is_halted(ep_num)) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\t// Set up the response payload with the endpoint status.\n\tudd_set_setup_payload(0, &ep_status, 2);\n\treturn true;\n}", "CodeBleu_score": 32.6863771813652}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tudc_req_t *req = &udc_req;\n\tuint16_t ep_status = 0;\n\tuint16_t ep_num = req->req.wIndex & 0x0F;\n\tuint16_t ep_dir = req->req.wIndex & 0x80;\n\n\tif (req->req.wLength != 2) {\n\t\treturn false;\n\t}\n\n\tif (ep_dir) {\n\t\tif (udd_ep_is_halted(ep_num)) {\n\t\t\tep_status = 1;\n\t\t}\n\t} else {\n\t\tif (udd_ep_is_stall(ep_num)) {\n\t\t\tep_status = 1;\n\t\t}\n\t}\n\n\tudd_set_setup_payload(0, &ep_status, 2);\n\treturn true;\n}", "CodeBleu_score": 26.494486797523383}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\t// Check if the device is configured\n\tif (udi_api->getsetting() != 1) {\n\t\treturn false;\n\t}\n\t// Check if the requested interface is supported\n\tif (udi_api->setup->wIndex != 0) {\n\t\treturn false;\n\t}\n\t// Update the interface descriptor to the default setting\n\tif (udi_api->setup->wValue == 0) {\n\t\tudi_api->setup->wValue = 1;\n\t\tif (!udi_api->setup(UDD_SETUP_DEVICE_TO_HOST_CONTROL_OUT)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// Update the interface descriptor to the current alternate setting\n\tif (udi_api->setup->wValue != 0) {\n\t\tudi_api->setup->wValue = 0;\n\t\tif (!udi_api->setup(UDD_SETUP_DEVICE_TO_HOST_CONTROL_OUT)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// Forward the request to the UDI handler\n\treturn udi_api->setup(UDD_SETUP_DEVICE_TO_HOST_CONTROL_OUT);\n}", "CodeBleu_score": 46.94824787897381}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface;\n\tuint8_t alt;\n\tudi_api_t *udi_api;\n\n\tif (0 == udc_setup_state) {\n\t\treturn false;\n\t}\n\tiface = udc_setup_request->wIndex;\n\tif (iface >= udc_desc_iface_nb) {\n\t\treturn false;\n\t}\n\talt = udc_setup_request->wValue;\n\tudi_api = udc_desc_iface[iface].udi_api;\n\tif (NULL == udi_api) {\n\t\treturn false;\n\t}\n\tif (0 == udi_api->setup(udc_setup_request)) {\n\t\treturn false;\n\t}\n\tif (0 == udc_update_iface_desc(iface, alt)) {\n\t\treturn false;\n\t}\n\tif (0 == udi_api->getsetting()) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 58.51114749428049}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t bInterfaceNumber;\n\tuint8_t bAlternateSetting;\n\tuint8_t bNumEndpoints;\n\tuint8_t bInterfaceClass;\n\tuint8_t bInterfaceSubClass;\n\tuint8_t bInterfaceProtocol;\n\tuint8_t bInterface;\n\n\t// Check if the device is in the configured state\n\tif (UDC_STATE != UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\n\t// Get the requested interface number\n\tbInterfaceNumber = udi_ctrlrequest.bRequest.bmRequestType.bInterfaceNumber;\n\n\t// Check if the requested interface number is valid\n\tif (bInterfaceNumber >= UDI_END_NB_INTERFACE) {\n\t\treturn false;\n\t}\n\n\t// Get the requested alternate setting\n\tbAlternateSetting = udi_ctrlrequest.bRequest.wValue.w;\n\n\t// Get the requested interface\n\tbInterface = udi_get_interface_setting(bInterfaceNumber);\n\n\t// Get the number of endpoints for the requested interface\n\tbNumEndpoints = udi_get_endpoint_nb(bInterface);\n\n\t// Get the interface descriptor for the requested interface\n\tudi_get_iface_desc(bInterface, &bInterfaceClass, &bInterfaceSubClass,\n\t\t\t&bInterfaceProtocol);\n\n\t// Update the interface descriptor to the default setting\n\tudi_update_iface_desc(bInterfaceNumber, bInterfaceClass,\n\t\t\tbInterfaceSubClass, bInterfaceProtocol, 0);\n\n\t// Update the interface descriptor to the current alternate setting\n\tudi_update_iface_desc(bInterfaceNumber, bInterfaceClass,\n\t\t\tbInterfaceSubClass, bInterfaceProtocol, bAlternateSetting);\n\n\t// Forward the SETUP request to the UDI handler\n\treturn udi_api->setup(bInterfaceNumber, bAlternateSetting, bNumEndpoints);\n}", "CodeBleu_score": 43.76516624686113}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\t// Initialize the structure\n\tudi_msc_cbw.dCBWSignature = UDI_MSC_CBW_SIGNATURE;\n\tudi_msc_cbw.dCBWTag = 0;\n\tudi_msc_cbw.dCBWDataTransferLength = 0;\n\tudi_msc_cbw.bmCBWFlags = 0;\n\tudi_msc_cbw.bCBWLUN = 0;\n\tudi_msc_cbw.bCBWCBLength = 0;\n\n\t// Initialize the structure\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\tudi_msc_csw.dCSWTag = 0;\n\tudi_msc_csw.dCSWDataResidue = 0;\n\tudi_msc_csw.bCSWStatus = 0;\n\n\t// Initialize the structure\n\tudi_msc_cbw_wait.dCBWSignature = UDI_MSC_CBW_SIGNATURE;\n\tudi_msc_cbw_wait.dCBWTag = 0;\n\tudi_msc_cbw_wait.dCBWDataTransferLength = 0;\n\tudi_msc_cbw_wait.bmCBWFlags = 0;\n\tudi_msc_cbw_wait.bCBWLUN = 0;\n\tudi_msc_cbw_wait.bCBWCBLength = 0;\n\n\t// Initialize the structure\n\tudi_msc_csw_wait.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\tudi_msc_csw_wait.dCSWTag = 0;\n\tudi_msc_csw_wait.dCSWDataResidue = 0;\n\tudi_msc_csw_wait.bCSWStatus = 0;\n\n\t// Initialize the structure\n\tudi_msc_cbw_done.dCBWSignature = UDI_MSC_CBW_SIGNATURE;\n\tudi", "CodeBleu_score": 30.917896484596007}, {"code": "bool udi_msc_enable(void){\n\t\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the MSC subsystem\n\tudi_msc_cbw_wait();\n\t// Initialize the states of the M", "CodeBleu_score": 19.009201843760216}, {"code": "bool udi_msc_enable(void){\n\t\t// Initialize the LUNs\n\tudi_msc_cbw_wait();\n\tif (udi_msc_get_nb_lun() == 0) {\n\t\treturn false;\n\t}\n\t// Unload the medium\n\tif (udi_msc_mem_unload() == false) {\n\t\treturn false;\n\t}\n\t// Start the MSC process\n\tudi_msc_cbw_wait();\n\treturn true;\n}", "CodeBleu_score": 19.883278115547913}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tudi_msc_csw_process();\n}", "CodeBleu_score": 22.44369232683964}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tudi_msc_csw_process(status, nb_sent, ep);\n}", "CodeBleu_score": 22.749106159121936}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(nb_sent);\n\tUNUSED(ep);\n\t// Check the status of the transfer\n\tif (status != UDD_EP_TRANSFER_OK) {\n\t\t// The transfer is not successful\n\t\tudi_msc_sense_pass();\n\t\t// Wait for a MSC setup reset to restart CBW reception\n\t\tudi_msc_csw_process(UDI_MSC_CSW_PHASE_ERROR);\n\t} else {\n\t\t// The transfer is successful\n\t\t// Update the sense data\n\t\tudi_msc_sense_pass();\n\t\t// Decrease the data residue in the Command Status Wrapper (CSW) by the amount of data sent\n\t\tudi_msc_csw_data_residue_dec(nb_sent);\n\t\t// Process the updated CSW\n\t\tudi_msc_csw_process(UDI_MSC_CSW_PHASE_DATA_IN);\n\t}\n}", "CodeBleu_score": 52.47856034414043}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\t// Check the data residue\n\tif (udi_msc_cbw.dCBWDataTransferLength != 0) {\n\t\t// Check the direction of the data transfer\n\t\tif (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\t// Stall the OUT endpoint\n\t\t\tudd_ep_set_halt(udi_msc_cbw.bCBWLUN,\n\t\t\t\t\tUDI_MSC_OUT_EP_INTERFACE);\n\t\t} else {\n\t\t\t// Stall the IN endpoint\n\t\t\tudd_ep_set_halt(udi_msc_cbw.bCBWLUN,\n\t\t\t\t\tUDI_MSC_IN_EP_INTERFACE);\n\t\t}\n\t}\n\n\t// Prepare the CSW\n\tudi_msc_csw.dCSWSignature = cpu_to_le32(UDI_MSC_CSW_SIGNATURE);\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue =\n\t\t\tcpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n\tudi_msc_csw.bCSWStatus = UDI_MSC_CSW_COMMAND_PASSED;\n\n\t// Send the CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 62.84865611051686}, {"code": "static void udi_msc_csw_process(void){\n\t\t// Check the data residue\n\tif (udi_msc_cbw.dCBWDataTransferLength != 0) {\n\t\t// Check the direction of the CBW\n\t\tif (udi_msc_cbw.bmCBWFlags & UDD_CBW_DIRECTION_IN) {\n\t\t\t// The CBW was an IN transfer, so stall the OUT endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t} else {\n\t\t\t// The CBW was an OUT transfer, so stall the IN endpoint\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t}\n\t}\n\t// Prepare the CSW\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength - udi_msc_trans_length);\n\tudi_msc_csw.bCSWStatus = UDD_CSW_CMD_PASSED;\n\t// Send the CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 61.054789163506264}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint_8 udd_ep_num;\n\tuint_32 udd_len;\n\tuint_32 udd_data_residue;\n\tuint_32 udd_cbw_dir;\n\tuint_32 udd_csw_status;\n\tuint_32 udd_csw_tag;\n\n\t/* Get the data residue */\n\tudd_data_residue = udi_msc_data_residue_get();\n\n\t/* Get the CBW direction */\n\tudd_cbw_dir = udi_msc_cbw_dir_get();\n\n\t/* Get the CBW tag */\n\tudd_csw_tag = udi_msc_cbw_tag_get();\n\n\t/* If there is a non-zero data residue, stall the next request from the USB host on the appropriate endpoint */\n\tif (udd_data_residue) {\n\t\tif (udd_cbw_dir) {\n\t\t\t/* IN direction */\n\t\t\tudd_ep_num = UDI_MSC_EP_IN;\n\t\t} else {\n\t\t\t/* OUT direction */\n\t\t\tudd_ep_num = UDI_MSC_EP_OUT;\n\t\t}\n\t\tudd_ep_set_halt(udd_ep_num);\n\t}\n\n\t/* Prepare the CSW */\n\tudi_msc_csw_status_set(UDI_MSC_CSW_PASSED);\n\tudi_msc_csw_residue_set(udd_data_residue);\n\tudi_msc_csw_tag_set(udd_csw_tag);\n\n\t/* Send the CSW */\n\tudd_ep_run(UDI_MSC_EP_OUT, UDI_MSC_EP_SIZE, true);\n}", "CodeBleu_score": 36.85816254490773}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\tif (usb_task_cdc_dtr_rate[port] == 1200) {\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\tif (usb_task_cdc_dtr_rate[port] == 1200) {\n\t\t\tscheduleReset();\n\t\t}\n\t}\n\tusb_task_cdc_dtr[port] = b_enable;\n}", "CodeBleu_score": 40.26891797264334}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  if (b_enable) {\n    // DTR is enabled\n    // Check if the DTR rate is 1200\n    if (usb_task_cdc_get_dtr_rate(port) == 1200) {\n      // DTR rate is 1200\n      // Disable the DTR rate\n      usb_task_cdc_set_dtr_rate(port, 0);\n    }\n  } else {\n    // DTR is disabled\n    // Check if the DTR rate is 1200\n    if (usb_task_cdc_get_dtr_rate(port) == 1200) {\n      // DTR rate is 1200\n      // Schedule a delayed system reset\n      cancelReset = false;\n      initiateReset = true;\n    }\n  }\n}", "CodeBleu_score": 30.312825202523968}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\t// DTR is enabled\n\t\tif (g_dtr_rate[port] == 1200) {\n\t\t\t// DTR rate is 1200\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\t// DTR is disabled\n\t\tif (g_dtr_rate[port] == 1200) {\n\t\t\t// DTR rate is 1200\n\t\t\tscheduleReset();\n\t\t}\n\t}\n\tg_dtr_enable[port] = b_enable;\n}", "CodeBleu_score": 40.41694335413576}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\n\tswitch (usb_setup.request_index) {\n\tcase 0x04:\n\t\tusb_setup.length = sizeof(udd_setup_type);\n\t\tusb_setup.payload = (uint8_t*)&udd_setup_type;\n\t\treturn true;\n\tcase 0x05:\n\t\tusb_setup.length = sizeof(udd_setup_type_ext);\n\t\tusb_setup.payload = (uint8_t*)&udd_setup_type_ext;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 11.659103625934803}, {"code": "bool usb_task_other_requests(void){\n\t\tuint8_t *payload = usb_setup_packet.payload;\n\tuint16_t *size = &usb_setup_packet.size;\n\n\tif (usb_setup_packet.request_type == UDD_SETUP_STANDARD_DEVICE_REQUEST) {\n\t\tswitch (usb_setup_packet.request_index) {\n\t\t\tcase 0x04:\n\t\t\t\t// Set up the payload for the Microsoft-compatible ID descriptor.\n\t\t\t\tpayload = (uint8_t *) &microsoft_compatible_id_descriptor;\n\t\t\t\t*size = sizeof(microsoft_compatible_id_descriptor);\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\t// Set up the payload for the Microsoft-compatible ID descriptor.\n\t\t\t\tpayload = (uint8_t *) &microsoft_extended_properties_descriptor;\n\t\t\t\t*size = sizeof(microsoft_extended_properties_descriptor);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 25.967988324908486}, {"code": "bool usb_task_other_requests(void){\n\t\tuint8_t *payload_ptr;\n\tuint32_t payload_size;\n\n\t/* Check the request type */\n\tif (usb_setup.bmRequestType == (USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_VENDOR)) {\n\t\t/* Check the request index */\n\t\tif (usb_setup.bRequest == 0x04) {\n\t\t\t/* Set up the payload pointer and size for the Microsoft compatible ID descriptor */\n\t\t\tpayload_ptr = (uint8_t *)&usb_microsoft_compatible_id_descriptor;\n\t\t\tpayload_size = sizeof(usb_microsoft_compatible_id_descriptor);\n\t\t}\n\t\telse if (usb_setup.bRequest == 0x05) {\n\t\t\t/* Set up the payload pointer and size for the Microsoft extended properties descriptor */\n\t\t\tpayload_ptr = (uint8_t *)&usb_microsoft_extended_properties_descriptor;\n\t\t\tpayload_size = sizeof(usb_microsoft_extended_properties_descriptor);\n\t\t}\n\t\telse {\n\t\t\t/* Request index not recognized */\n\t\t\treturn false;\n\t\t}\n\n\t\t/* Update the control request payload and size */\n\t\tusb_setup.wLength = (uint16_t)payload_size;\n\t\tusb_setup.wValue = 0;\n\t\tusb_setup.wIndex = 0;\n\t\tusb_setup.wValue = 0;\n\t\tusb_setup.bmRequestType = 0;\n\t\tusb_setup.bRequest = 0;\n\t\tusb_setup.wLength = 0;\n\t\tusb_setup.bmRequestType = USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_VENDOR;\n\t\tusb_setup.bRequest = 0x06;\n\t\tusb_setup.wValue = 0;\n\t\tusb_setup.wIndex = 0;\n\t\tusb_setup.wLength = payload_size;\n\t\tusb_setup.wValue = 0;\n\t\tusb_setup.wIndex =", "CodeBleu_score": 31.57488677418075}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    uint16_t i;\n    if (nbyte == 0) {\n        return;\n    }\n    for (i = 0; i < nbyte - 1; i++) {\n        SPI_PUSH(0x00);\n        while (!(SPI_POP() & 0x80));\n        buf[i] = SPI_POP();\n    }\n    SPI_PUSH(0x00);\n    while (!(SPI_POP() & 0x80));\n    buf[i] = SPI_POP();\n    spiRec();\n}", "CodeBleu_score": 47.9102918639137}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\tuint8_t dummy;\n\n\tif (nbyte == 0)\n\t\treturn;\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tdummy = 0xFF;\n\t\tSPI_PCS = 0;\n\t\tspiSend(dummy);\n\t\tbuf[i] = spiRec();\n\t}\n\tdummy = 0xFF;\n\tSPI_PCS = 0;\n\tspiSend(dummy);\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 48.08587255597864}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    uint16_t i;\n    if (nbyte == 0)\n        return;\n    for (i = 0; i < nbyte - 1; i++) {\n        SPI_PCS = 0;\n        SPI_DAT = 0xFF;\n        while (!SPI_IF);\n        SPI_IF = 0;\n        buf[i] = SPI_DAT;\n    }\n    SPI_PCS = 0;\n    SPI_DAT = 0xFF;\n    while (!SPI_IF);\n    SPI_IF = 0;\n    buf[i] = spiRec();\n}", "CodeBleu_score": 46.95607320877875}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tCRITICAL_SECTION_START\n\tpfnISR_Handler oldHandler;\n\toldHandler = get_isr(irq);\n\tset_isr(irq, newHandler);\nCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 37.84307620581703}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tCRITICAL_SECTION_START\n\n\tpfnISR_Handler oldHandler = get_isr(irq);\n\tpfnISR_Handler* table = get_relocated_table_addr();\n\ttable[irq] = newHandler;\n\nCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 53.886125378210906}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tCRITICAL_SECTION_START\n\tpfnISR_Handler oldHandler = get_isr(irq);\n\tset_isr(irq, newHandler);\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 34.512324150726386}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (!udi_cdc_is_rx_ready()) return -1;\n  if (emergency_parser.enabled) {\n    char c = udi_cdc_getc();\n    emergency_parser.update(c);\n    return c;\n  }\n  return udi_cdc_getc();\n}", "CodeBleu_score": 35.51029871562782}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!is_enabled()) return -1;\n  return udi_cdc_getc();\n}", "CodeBleu_score": 11.117465621551895}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!usb_task_cdc_isenabled()) {\n    return -1;\n  }\n  if (emergency_parser.update()) {\n    return emergency_parser.get_byte();\n  }\n  if (udi_cdc_is_rx_ready()) {\n    return udi_cdc_getc();\n  }\n  return -1;\n}", "CodeBleu_score": 32.43300098124276}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  int c;\n\n  // First, check if there is a pending character\n  if (rx_buffer_head != rx_buffer_tail) {\n    c = rx_buffer[rx_buffer_tail++];\n    if (rx_buffer_tail >= BUFFER_SIZE) rx_buffer_tail = 0;\n    return c;\n  }\n\n  // Then, check if the USB CDC is enabled and configured\n  if (!udi_cdc_is_rx_ready()) return -1;\n\n  // Then, check if there are any bytes available to read from the PC\n  if (!usb_task_cdc_isenabled()) return -1;\n\n  // If a byte is available, read the byte, update the emergency parser if enabled, and return the read character\n  c = udi_cdc_getc();\n  if (emergency_parser.enabled) emergency_parser.update(c);\n  return c;\n}", "CodeBleu_score": 55.23924599463288}, {"code": "int MarlinSerialUSB::read(){\n\t\n\tif (rx_buffer_head != rx_buffer_tail) {\n\t\tuint8_t c = rx_buffer[rx_buffer_tail];\n\t\trx_buffer_tail = (rx_buffer_tail + 1) & SERIAL_BUFFER_MASK;\n\t\treturn c;\n\t}\n\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tif (!cdc_enabled || !cdc_configured)\n\t\treturn -1;\n\n\tif (!udi_cdc_is_rx_ready())\n\t\treturn -1;\n\n\tuint8_t c = udi_cdc_getc();\n\tif (emergency_parser.enabled)\n\t\temergency_parser.update(c);\n\treturn c;\n}", "CodeBleu_score": 51.122490582460856}, {"code": "int MarlinSerialUSB::read(){\n\t  // Check if there is a pending character\n  if (rx_buffer_head != rx_buffer_tail) {\n    uint8_t c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % BUFFER_SIZE;\n    return c;\n  }\n\n  // Check if the USB CDC is enabled and configured\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n\n  // Check if there are any bytes available to read from the PC\n  if (!usb_task_cdc_isenabled())\n    return -1;\n\n  // Read a byte from the PC\n  uint8_t c = udi_cdc_getc();\n\n  // Update the emergency parser if enabled\n  if (emergency_parser.enabled)\n    emergency_parser.update(c);\n\n  return c;\n}", "CodeBleu_score": 55.73271730678664}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (udi_cdc_is_rx_ready()) {\n    return udi_cdc_get_rx_buf_size();\n  }\n  else {\n    return udi_cdc_is_rx_enabled();\n  }\n}", "CodeBleu_score": 23.030056454120523}, {"code": "int MarlinSerialUSB::available(){\n\t  if (usb_task_cdc_isenabled()) {\n    return udi_cdc_is_rx_ready();\n  }\n  return 0;\n}", "CodeBleu_score": 22.573788354455992}, {"code": "int MarlinSerialUSB::available(){\n\t  return udi_cdc_is_rx_ready() ? udi_cdc_get_nb_received_data() : (usb_task_cdc_isenabled() ? 0 : -1);\n}", "CodeBleu_score": 21.28829714464107}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (writing) {\n    if (size) {\n      uint8_t data = ee_Read(pos);\n      *value = data;\n      *crc = _crc_update(*crc, data);\n      pos++;\n      size--;\n      value++;\n    }\n  }\n  else {\n    while (size--) {\n      uint8_t data = ee_Read(pos);\n      *crc = _crc_update(*crc, data);\n      pos++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 52.365483335143814}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  uint16_t crc_value = 0;\n  for (size_t i = 0; i < size; i++) {\n    if (writing) {\n      value[i] = ee_Read(pos);\n      crc_value = crc16(crc_value, value[i]);\n    }\n    pos++;\n  }\n  if (crc) *crc = crc_value;\n  return false; // return false to indicate that the data is invalid\n}", "CodeBleu_score": 52.81239371449386}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  // Read from the EEPROM\n  uint8_t * const start = (uint8_t*)value;\n  for (size_t i = 0; i < size; i++) {\n    if (writing)\n      *value++ = ee_Read(pos);\n    else\n      value++;\n    pos++;\n  }\n\n  // Update the CRC\n  if (crc)\n    *crc = crc16(start, size, *crc);\n\n  return false;\n}", "CodeBleu_score": 52.18508721589523}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t    // if pin is invalid, return\n    if (pin >= NUM_DIGITAL_PINS) {\n        return;\n    }\n    // if pin is not PWM capable, return\n    if (digitalPinIsPWM(pin) == false) {\n        return;\n    }\n    // if pin is not PWM capable, return\n    if (freq < 1) {\n        return;\n    }\n    // if pin is not PWM capable, return\n    if (res < 1) {\n        return;\n    }\n    // if pin is not PWM capable, return\n    if (res > 16) {\n        return;\n    }\n    // if pin is not PWM capable, return\n    if (value > 255) {\n        return;\n    }\n\n    // if pin is not PWM capable, return\n    if (digitalPinToTimer(pin) == NOT_ON_TIMER) {\n        return;\n    }\n\n    // if pin is not PWM capable, return\n    if (digitalPinToTimer(pin) == TIMER_MAX) {\n        return;\n    }\n\n    // if pin is not PWM capable, return\n    if (digitalPinToTimer(pin) == TIMER_MAX) {\n        return;\n    }\n\n    // if pin is not PWM capable, return\n    if (digitalPinToTimer(pin) == TIMER_MAX) {\n        return;\n    }\n\n    // if pin is not PWM capable, return\n    if (digitalPinToTimer(pin) == TIMER_MAX) {\n        return;\n    }\n\n    // if pin is not PWM capable, return\n    if (digitalPinToTimer(pin) == TIMER_MAX) {\n        return;\n    }\n\n    // if pin is not PWM capable, return\n    if (digitalPinToTimer(pin) == TIMER_MAX) {\n        return;\n    }\n\n    // if pin is not PWM capable, return\n    if (digitalPinToTimer(pin) == TIMER_MAX)", "CodeBleu_score": 30.545288924919955}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value == 255) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n\n  if (freq > 0) {\n    ledcSetup(get_pwm_channel(pin), freq, res);\n    ledcWrite(get_pwm_channel(pin), value);\n  }\n  else {\n    uint8_t bit = 0x80;\n    while (value) {\n      digitalWrite(pin, value & bit);\n      delayMicroseconds(100);\n      value ^= bit;\n    }\n  }\n}", "CodeBleu_score": 38.47976162716027}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin >= NUM_DIGITAL_PINS) {\n\t\treturn;\n\t}\n\n\t// If the pin supports hardware PWM, try to set it\n\tif (pin_to_channel[pin] != NO_PWM_CHANNEL) {\n\t\t// Check if the pin is already in use for hardware PWM\n\t\tif (pwm_channels[pin_to_channel[pin]].pin != pin) {\n\t\t\t// If it is, deallocate it\n\t\t\tpwm_channels[pin_to_channel[pin]].pin = NO_PWM_PIN;\n\t\t\tpwm_channels[pin_to_channel[pin]].value = 0;\n\t\t\tpwm_channels[pin_to_channel[pin]].freq = 0;\n\t\t\tpwm_channels[pin_to_channel[pin]].res = 0;\n\t\t}\n\n\t\t// Set the new PWM value\n\t\tledcWrite(pin_to_channel[pin], value);\n\n\t\t// Set the PWM parameters\n\t\tpwm_channels[pin_to_channel[pin]].pin = pin;\n\t\tpwm_channels[pin_to_channel[pin]].value = value;\n\t\tpwm_channels[pin_to_channel[pin]].freq = freq;\n\t\tpwm_channels[pin_to_channel[pin]].res = res;\n\t\tpwm_channels[pin_to_channel[pin]].enabled = true;\n\n\t\t// If this is the first PWM pin used, start the timer\n\t\tif (used_pwm_channels == 0) {\n\t\t\tHAL_timer_start(PWM_TIMER_NUM, PWM_TIMER_CHANNEL, 1000000 / freq);\n\t\t}\n\n\t\t// Increment the number of used PWM channels\n\t\tused_pwm_channels++;\n\n\t\treturn;\n\t}\n\n\t// If the pin supports", "CodeBleu_score": 36.05923008138562}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(servo_delay_array) == sizeof(int) * MAX_SERVOS, \"Servo::move: servo_delay_array is not the right size\");\n  if (attach()) {\n    write(value);\n    safe_delay(servo_delay_array[servo_index]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 49.073690175424}, {"code": "void Servo::move(const int value){\n\t  static_assert(SERVO_DELAY_ARRAY_LENGTH > 0, \"SERVO_DELAY_ARRAY_LENGTH must be greater than 0\");\n\n  if (attach()) {\n    write(value);\n    safe_delay(delay_array[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      detach();\n    }\n  }\n}", "CodeBleu_score": 38.822981391520614}, {"code": "void Servo::move(const int value){\n\t  static_assert(SERVO_DELAY_ARRAY_LENGTH > 0, \"The servo delay array length must be greater than 0\");\n  if (attach()) {\n    write(value);\n    safe_delay(servo_delay_array[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      detach();\n    }\n  }\n}", "CodeBleu_score": 39.57220580472378}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t    uint8_t i;\n    uint32_t data;\n    uint32_t data_mask;\n    uint32_t pwm_mask;\n    uint32_t pwm_tick_count;\n    uint32_t pwm_tick_count_mask;\n    uint32_t pwm_tick_count_set;\n    uint32_t pwm_tick_count_set_mask;\n    uint32_t pwm_tick_count_clr;\n    uint32_t pwm_tick_count_clr_mask;\n    uint32_t pwm_duty_cycle;\n    uint32_t pwm_duty_cycle_mask;\n    uint32_t pwm_duty_cycle_set;\n    uint32_t pwm_duty_cycle_set_mask;\n    uint32_t pwm_duty_cycle_clr;\n    uint32_t pwm_duty_cycle_clr_mask;\n    uint32_t pwm_pin_state;\n    uint32_t pwm_pin_state_mask;\n    uint32_t pwm_pin_state_set;\n    uint32_t pwm_pin_state_set_mask;\n    uint32_t pwm_pin_state_clr;\n    uint32_t pwm_pin_state_clr_mask;\n    uint32_t pwm_pin_state_clr_set;\n    uint32_t pwm_pin_state_clr_set_mask;\n    uint32_t pwm_pin_state_clr_clr;\n    uint32_t pwm_pin_state_clr_clr_mask;\n    uint32_t pwm_pin_state_clr_clr_set;\n    uint32_t pwm_pin_state_clr_clr_set_mask;\n    uint32_t p", "CodeBleu_score": 8.102363770708404}, {"code": "void i2s_push_sample(){\n\t\tfor(int i = 0; i < PIN_COUNT; i++) {\n\t\tif(pins[i].pwm_tick_count > 0) {\n\t\t\tpins[i].pwm_tick_count--;\n\t\t\tif(pins[i].pwm_tick_count == 0) {\n\t\t\t\tpins[i].state = !pins[i].state;\n\t\t\t\tpins[i].pwm_tick_count = pins[i].pwm_tick_period;\n\t\t\t}\n\t\t}\n\t\tif(pins[i].pwm_tick_count > 0) {\n\t\t\tif(pins[i].state) {\n\t\t\t\tpins[i].port_data |= (1 << i);\n\t\t\t} else {\n\t\t\t\tpins[i].port_data &= ~(1 << i);\n\t\t\t}\n\t\t} else {\n\t\t\tpins[i].port_data &= ~(1 << i);\n\t\t}\n\t}\n\t*(dma_buffer_pos++) = pins[0].port_data;\n\t*(dma_buffer_pos++) = pins[1].port_data;\n\t*(dma_buffer_pos++) = pins[2].port_data;\n\t*(dma_buffer_pos++) = pins[3].port_data;\n}", "CodeBleu_score": 37.33303586336304}, {"code": "void i2s_push_sample(){\n\t\tuint16_t i;\n\tuint16_t port_data = 0;\n\tuint16_t pwm_data = 0;\n\tuint16_t pwm_tick_count = 0;\n\tuint16_t pwm_tick_count_prev = 0;\n\tuint16_t pwm_state = 0;\n\tuint16_t pwm_state_prev = 0;\n\n\tfor (i = 0; i < NUM_PINS; i++) {\n\t\tif (pwm_tick_count_prev != pwm_tick_count) {\n\t\t\tpwm_state_prev = pwm_state;\n\t\t\tpwm_state = pwm_state_prev ^ 1;\n\t\t\tpwm_tick_count_prev = pwm_tick_count;\n\t\t}\n\n\t\tif (pwm_tick_count > 0) {\n\t\t\tpwm_tick_count--;\n\t\t}\n\n\t\tif (pwm_state != pwm_state_prev) {\n\t\t\tport_data |= (1 << i);\n\t\t}\n\n\t\tpwm_data |= (pwm_state << i);\n\t}\n\n\tif (dma_buffer_pos == DMA_BUFFER_SIZE) {\n\t\tdma_buffer_pos = 0;\n\t}\n\n\tdma_buffer[dma_buffer_pos] = port_data;\n\tdma_buffer[dma_buffer_pos + 1] = pwm_data;\n\tdma_buffer_pos += 2;\n}", "CodeBleu_score": 25.932339149503036}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    return timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.948642288382214}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t timer_count;\n    timer_count = timer_get_counter_value(timer_num);\n    return timer_count;\n}", "CodeBleu_score": 34.53542107927186}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tuint32_t timer_count;\n\tuint32_t timer_base;\n\n\tif (timer_num >= HAL_TIMER_MAX_NUM) {\n\t\treturn 0;\n\t}\n\n\ttimer_base = timer_base_address[timer_num];\n\n\ttimer_count = HAL_read32(timer_base + TIMER_CNT_REG_OFFSET);\n\n\treturn timer_count;\n}", "CodeBleu_score": 45.13291708072375}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (uint16_t i = 0; i < size; i++) {\n    if (writing) value[i] = eeprom_read_byte((uint8_t*)pos + i);\n    if (crc) crc16_ccitt_update(crc, value[i]);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 65.65266359013536}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  if (writing) {\n    for (size_t i = 0; i < size; i++) {\n      value[i] = eeprom_read_byte((uint8_t *)(eeprom_address + pos));\n      pos++;\n      *crc = _crc_update(*crc, value[i]);\n    }\n  }\n  else {\n    for (size_t i = 0; i < size; i++) {\n      pos++;\n      *crc = _crc_update(*crc, eeprom_read_byte((uint8_t *)(eeprom_address + pos)));\n    }\n  }\n  return false;\n}", "CodeBleu_score": 57.766947618281314}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  if (writing) {\n    while (size--) {\n      *value++ = eeprom_read_byte((const uint8_t *)(eeprom_address + pos));\n      *crc += *value;\n      pos++;\n    }\n  }\n  else {\n    while (size--) {\n      *crc += eeprom_read_byte((const uint8_t *)(eeprom_address + pos));\n      pos++;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 42.0025675669878}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    if (!sdio_handle || !src) {\n        printf(\"SDIO_WriteBlock: Invalid handle or source pointer.\n\");\n        return false;\n    }\n\n    WITH_RETRY(SDCARD_WriteBlocks(sdio_handle, src, block, 1), 10000);\n\n    return true;\n}", "CodeBleu_score": 23.8732728038535}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    // Assert that the SDIO handle and source pointer are not null.\n    CORE_ASSERT(sdio != nullptr);\n    CORE_ASSERT(src != nullptr);\n\n    // Try to write the block.\n    bool result = WITH_RETRY(sdio->writeBlock(block, src), 10000);\n\n    // If the write operation succeeded, return \"true\".\n    if (result) {\n        return true;\n    }\n\n    // Otherwise, print an error message and return \"false\".\n    printf(\"Error: SDIO_WriteBlock failed.\n\");\n    return false;\n}", "CodeBleu_score": 34.634867792773214}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    if (sdio_handle == NULL || src == NULL) {\n        printf(\"SDIO_WriteBlock: Invalid parameters.\n\");\n        return false;\n    }\n    for (int i = 0; i < SDCARD_WRITE_RETRIES; i++) {\n        if (HAL_SD_WriteBlocks(sdio_handle, (uint8_t *)src, block, 1, SDCARD_BLOCK_SIZE) == HAL_OK) {\n            return true;\n        }\n    }\n    printf(\"SDIO_WriteBlock: Write failed after %d retries.\n\", SDCARD_WRITE_RETRIES);\n    return false;\n}", "CodeBleu_score": 43.6771165794674}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tCORE_DEBUG_PRINTF\n\tCORE_ASSERT_FAIL\n\ttimer_num->start\n\ttimer_num->setCallbackPriority\n\tfrequency\n}", "CodeBleu_score": 11.09249334792147}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tCORE_DEBUG_PRINTF(\"HAL_timer_start\n\");\n\tCORE_DEBUG_PRINTF(\"timer_num = %d\n\", timer_num);\n\tCORE_DEBUG_PRINTF(\"frequency = %d\n\", frequency);\n\tCORE_ASSERT_FAIL;\n}", "CodeBleu_score": 18.64780939865384}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\t// CORE_DEBUG_PRINTF(\"HAL_timer_start", "CodeBleu_score": 2.926796394315436}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t    // Open the file\n    file = fopen(filename, \"rb\");\n    if (!file) {\n        // File does not exist or cannot be opened\n        return false;\n    }\n\n    // Get the file size\n    fseek(file, 0, SEEK_END);\n    int file_size = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    // Read the file into the buffer\n    if (file_size < sizeof(buffer)) {\n        // File is too small; fill the remainder of the buffer with a default erase value\n        memset(&buffer[file_size], erase_byte, sizeof(buffer) - file_size);\n    }\n    fread(&buffer[0], sizeof(buffer), 1, file);\n\n    // Close the file\n    fclose(file);\n\n    // Return success\n    return true;\n}", "CodeBleu_score": 41.77326740150951}, {"code": "bool PersistentStore::access_start(){\n\t  #if defined(ARDUINO_ARCH_ESP32)\n    if (!SPIFFS.begin(true)) {\n      SERIAL_ERROR_START;\n      SERIAL_ERRORLNPGM(\"SPIFFS Mount Failed\");\n      return false;\n    }\n  #endif\n\n  // Open the file\n  FILE *fp = fopen(persistentStorePath, \"r+\");\n  if (!fp) {\n    SERIAL_ERROR_START;\n    SERIAL_ERRORLNPGM(\"Error opening file\");\n    return false;\n  }\n\n  // Get the file size\n  fseek(fp, 0, SEEK_END);\n  int fileSize = ftell(fp);\n  fseek(fp, 0, SEEK_SET);\n\n  // Fill the buffer with the file's contents\n  if (fileSize < size) {\n    memset(buffer, eraseValue, size);\n    fread(buffer, 1, fileSize, fp);\n    fclose(fp);\n    return true;\n  }\n  else {\n    fread(buffer, 1, size, fp);\n    fclose(fp);\n    return true;\n  }\n}", "CodeBleu_score": 42.56085545191801}, {"code": "bool PersistentStore::access_start(){\n\t  // Open the EEPROM file\n  FILE *file = fopen(eeprom_filename, \"rb\");\n  if (!file) {\n    // The file does not exist\n    return false;\n  }\n\n  // Get the file size\n  fseek(file, 0, SEEK_END);\n  uint32_t file_size = ftell(file);\n  fseek(file, 0, SEEK_SET);\n\n  // Read the file into the buffer\n  if (file_size > eeprom_size) {\n    // The file is too big\n    fclose(file);\n    return false;\n  }\n  if (file_size < eeprom_size) {\n    // The file is too small\n    memset(eeprom_buffer, eeprom_erase_byte, eeprom_size - file_size);\n  }\n  if (fread(eeprom_buffer, eeprom_size, 1, file) != 1) {\n    // Failed to read the file\n    fclose(file);\n    return false;\n  }\n\n  // Close the file\n  fclose(file);\n\n  // Success\n  return true;\n}", "CodeBleu_score": 50.82092135978129}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t ret;\n\tuint8_t i;\n\tuint8_t j;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SpiTransfer_Mode_3_Bit(b & 0x80);\n\t\tb <<= 1;\n\t}\n\tret = 0;\n\tfor (j = 0; j < 8; j++) {\n\t\tret <<= 1;\n\t\tret |= HAL_SPI_STM32_SpiTransfer_Mode_3_Bit(0);\n\t}\n\tdelaySPIFunc();\n\treturn ret;\n}", "CodeBleu_score": 39.355566112471465}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t c;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\tSPI_SCK_LOW;\n\t\tif (b & 0x80) {\n\t\t\tSPI_MOSI_HIGH;\n\t\t} else {\n\t\t\tSPI_MOSI_LOW;\n\t\t}\n\t\tSPI_SCK_HIGH;\n\t\tb <<= 1;\n\t\tif (SPI_MISO_READ) {\n\t\t\tb |= 1;\n\t\t}\n\t}\n\tc = b;\n\tdelaySPIFunc();\n\treturn c;\n}", "CodeBleu_score": 35.79887363410826}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SpiTransfer_Mode_3_Bit(b & 0x80);\n\t\tr = (r << 1) | HAL_SPI_STM32_SpiTransfer_Mode_3_Bit(0);\n\t\tb <<= 1;\n\t}\n\treturn r;\n}", "CodeBleu_score": 31.392854281632253}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 78.26394678944122}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 78.15686146592842}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    /* Check the parameters */\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 77.97819102603172}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c = obj->serial->RX_BUFFER;\n  if (c == 0) return;\n  if (rx_buffer_head == rx_buffer_tail) {\n    if (rx_buffer_head >= BUFFER_SIZE) rx_buffer_head = 0;\n    rx_buffer[rx_buffer_head++] = c;\n    if (rx_buffer_head >= BUFFER_SIZE) rx_buffer_head = 0;\n  }\n  if (rx_buffer_head == rx_buffer_tail) {\n    rx_buffer_tail++;\n    if (rx_buffer_tail >= BUFFER_SIZE) rx_buffer_tail = 0;\n  }\n  if (emergency_parser.enabled) emergency_parser.update(c);\n}", "CodeBleu_score": 32.2693227158098}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c = uart_getc(obj);\n  if (c == 0) return;\n  if (rx_buffer_head == rx_buffer_tail) {\n    rx_buffer_overflow = true;\n  }\n  else {\n    rx_buffer[rx_buffer_head] = c;\n    rx_buffer_head = (rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n  if (emergency_parser.enabled) emergency_parser.update(c);\n}", "CodeBleu_score": 37.23185859638499}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  if (obj->rx_buff.in_use == true) {\n    if (obj->parity_error == 0) {\n      // If no parity error, read the byte and store it in the receive buffer if there is space available\n      uint8_t c = uart_getc(obj);\n      if (obj->rx_buff.head != obj->rx_buff.tail) {\n        obj->rx_buff.buffer[obj->rx_buff.head] = c;\n        obj->rx_buff.head = (obj->rx_buff.head + 1) % SERIAL_BUFFER_SIZE;\n      }\n    }\n    // Calculate the next buffer index and update the head pointer\n    obj->rx_buff.head = (obj->rx_buff.head + 1) % SERIAL_BUFFER_SIZE;\n    if (obj->rx_buff.head == obj->rx_buff.tail) {\n      obj->rx_buff.in_use = false;\n    }\n  }\n  // If enabled, update the emergency parser with the received byte\n  if (emergency_parser.enabled) {\n    emergency_parser.update(uart_getc(obj));\n  }\n}", "CodeBleu_score": 38.6942602486926}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (timer_instance[timer_num]->isInitialized && !timer_instance[timer_num]->hasInterrupt) {\n    switch (timer_num) {\n      case MF_TIMER_STEP:\n        timer_instance[timer_num]->attachInterrupt(Step_Handler);\n        break;\n      case MF_TIMER_TEMP:\n        timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n        break;\n    }\n    timer_instance[timer_num]->hasInterrupt = true;\n  }\n}", "CodeBleu_score": 80.8314033587517}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (timer_instance[timer_num]->hasInterrupt == false) {\n    if (timer_instance[timer_num]->isInitialized == true) {\n      switch (timer_num) {\n        case MF_TIMER_STEP:\n          timer_instance[timer_num]->attachInterrupt(Step_Handler);\n          break;\n        case MF_TIMER_TEMP:\n          timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n}", "CodeBleu_score": 78.57840886490197}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (timer_instance[timer_num]->isInitialized() && !timer_instance[timer_num]->hasInterrupt()) {\n    switch (timer_num) {\n      case MF_TIMER_STEP:\n        timer_instance[timer_num]->attachInterrupt(Step_Handler);\n        break;\n      case MF_TIMER_TEMP:\n        timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n        break;\n      default:\n        break;\n    }\n  }\n}", "CodeBleu_score": 85.90636700249273}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t    if len(s) == 0 {\n        return -1\n    }\n    if len(sep) == 0 {\n        return 0\n    }\n    if len(sep) == 1 {\n        return LastIndexByteRabinKarp(s, sep[0])\n    }\n    if len(sep) > len(s) {\n        return -1\n    }\n    var (\n        sHash, sepHash, sepLen, lastSepHash, sepIndex, sepLastIndex uint32\n        sLen                                                      = uint32(len(s))\n        sepLen32                                                  = uint32(len(sep))\n    )\n    if sLen < sepLen {\n        sepLen = sLen\n    }\n    if sepLen32 < 16 {\n        return LastIndexRabinKarpNaive(s, sep)\n    }\n    sHash = HashStrRev(s[:sepLen])\n    sepHash = HashStrRev(sep[:sepLen])\n    sepLastIndex = sLen - sepLen\n    for i := sepLen - 1; i >= 0; i-- {\n        sHash = (sHash << 8) | uint32(s[i])\n        sepHash = (sepHash << 8) | uint32(sep[i])\n    }\n    for i := sepLastIndex; i >= 0; i-- {\n        if sHash == sepHash {\n            sepIndex = i\n            if sepLastIndex-i+1 == sepLen {\n                return sepIndex\n            }\n            lastSepHash = HashStrRev(s[sepIndex+sepLen : sepLastIndex+1])\n            for j := sepIndex + sepLen; j <= sepLastIndex; j++ {\n                sHash = (sHash << 8) | uint32(s[j])\n                sHash ^= uint32(s[j-sepLen])\n                if sHash == lastSepHash {\n                    return sepIndex\n                }\n            }\n            return -1\n        }\n        sHash ^= uint32(s[i])\n        sHash <<= 8\n    }\n    return -", "CodeBleu_score": 38.15764601837316}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(s)\n\tm := len(sep)\n\tif n < m {\n\t\treturn -1\n\t}\n\n\t// Rabin-Karp search\n\th1 := HashStrRev(sep)\n\th2 := HashStrRev(s[n-m:])\n\tif h1 != h2 {\n\t\treturn -1\n\t}\n\tfor i := n - m; i >= m; i-- {\n\t\tif s[i] != sep[0] {\n\t\t\tcontinue\n\t\t}\n\t\th2 = h2<<8 | uint32(s[i])\n\t\th2 -= h1 * uint32(s[i-m])\n\t\tif h2 < 0 {\n\t\t\th2 += 1<<24\n\t\t}\n\t\tif h1 == h2 && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 42.57723361853712}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif sep == \"\" {\n\t\treturn 0\n\t}\n\tn := len(s)\n\tk := len(sep)\n\tif n < k {\n\t\treturn -1\n\t}\n\tif k == 1 {\n\t\treturn LastIndexByteRabinKarp(s, sep[0])\n\t}\n\tvar h uint32\n\tfor i := 0; i < k; i++ {\n\t\th = h*31 + uint32(s[i])\n\t}\n\tvar p uint32 = 1\n\tfor i := 1; i < k; i++ {\n\t\tp = p*31 + uint32(sep[i])\n\t}\n\tfor i := n - k; i >= 0; i-- {\n\t\tif h == 0 {\n\t\t\th = 1\n\t\t}\n\t\th = h*31 + uint32(s[i+k-1]) - p*uint32(s[i])\n\t\tif h == 0 {\n\t\t\tif i+k <= n && s[i:i+k] == sep {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 42.291646672215236}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() != 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.29771695006677}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() != 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.29771695006677}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() != 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.29771695006677}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(I2C_CR_STOP | I2C_CR_START | I2C_CR_NACK | I2C_CR_NBYTES)\n\ti2c.crReg.SetBits(I2C_CR_START)\n\tfor i2c.srReg.HasBits(I2C_SR_BUSY) {\n\t}\n\ti2c.crReg.ClearBits(I2C_CR_START)\n\ti2c.crReg.SetBits(I2C_CR_ACK)\n\ti2c.writeByte(address<<1 | uint8(write))\n\tfor i2c.srReg.HasBits(I2C_SR_BUSY) {\n\t}\n\ti2c.crReg.ClearBits(I2C_CR_ACK)\n}", "CodeBleu_score": 35.207361052517335}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Clear(I2C_CR_START)\n\ti2c.crReg.Clear(I2C_CR_STOP)\n\ti2c.crReg.Clear(I2C_CR_ACK)\n\ti2c.crReg.Clear(I2C_CR_POS)\n\ti2c.crReg.Set(I2C_CR_START)\n\ti2c.crReg.Set(I2C_CR_PE)\n\ti2c.crReg.Set(I2C_CR_EN)\n\tfor i2c.srReg.HasBits(I2C_SR_SB) {\n\t}\n\ti2c.drReg.Set(uint32(address << 1) | uint32(write))\n\tfor i2c.srReg.HasBits(I2C_SR_ADDR) {\n\t}\n}", "CodeBleu_score": 29.70401363413054}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(I2C_CR_STOP | I2C_CR_START | I2C_CR_NACK | I2C_CR_NACKIE | I2C_CR_ADDRIE | I2C_CR_RXIE | I2C_CR_TXIE)\n\ti2c.crReg.SetBits(I2C_CR_START)\n\tfor i2c.sr1Reg.HasBits(I2C_SR1_SB) == 0 {\n\t}\n\ti2c.crReg.ClearBits(I2C_CR_START)\n\ti2c.drReg.Set(address << 1)\n\tif write {\n\t\ti2c.drReg.SetBits(I2C_DR_RD_WRN)\n\t}\n\tfor i2c.sr1Reg.HasBits(I2C_SR1_ADDR) == 0 {\n\t}\n\ti2c.sr1Reg.ClearBits(I2C_SR1_ADDR)\n\ti2c.crReg.SetBits(I2C_CR_ACK)\n}", "CodeBleu_score": 31.117134987547026}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || start >= f.NumBlocks() {\n\t\treturn errors.New(\"start block number out of range\")\n\t}\n\tif len < 0 || start+len > f.NumBlocks() {\n\t\treturn errors.New(\"length out of range\")\n\t}\n\tif f.EraseBlockSize < 1 {\n\t\treturn errors.New(\"invalid erase block size\")\n\t}\n\tstartAddr := f.FlashDataStart + int64(f.EraseBlockSize)*start\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Een)\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(startAddr))\n\t\twaitWhileFlashBusy()\n\t\tstartAddr += int64(f.EraseBlockSize)\n\t}\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\treturn nil\n}", "CodeBleu_score": 46.78491838672089}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || start >= f.NumBlocks {\n\t\treturn errors.New(\"start block out of range\")\n\t}\n\tif len < 1 || start+len > f.NumBlocks {\n\t\treturn errors.New(\"length out of range\")\n\t}\n\tf.EraseBlockSize\n\tFlashDataStart\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(start + i) * f.EraseBlockSize / 4)\n\t\twaitWhileFlashBusy\n\t}\n\tnrf.NVMC.SETCONFIG_REN\n\treturn nil\n}", "CodeBleu_score": 39.498647098026815}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"start and len must be non-negative\")\n\t}\n\tif start+len > f.EraseBlockCount() {\n\t\treturn errors.New(\"start + len must be less than or equal to EraseBlockCount\")\n\t}\n\tif start%int64(f.EraseBlockSize) != 0 || len%int64(f.EraseBlockSize) != 0 {\n\t\treturn errors.New(\"start and len must be a multiple of EraseBlockSize\")\n\t}\n\tif f.EraseBlockSize == 0 {\n\t\treturn errors.New(\"EraseBlockSize must be non-zero\")\n\t}\n\tif f.EraseBlockSize > f.PageSize {\n\t\treturn errors.New(\"EraseBlockSize must be less than or equal to PageSize\")\n\t}\n\tif f.PageSize%f.EraseBlockSize != 0 {\n\t\treturn errors.New(\"PageSize must be a multiple of EraseBlockSize\")\n\t}\n\tif f.PageSize > f.Size() {\n\t\treturn errors.New(\"PageSize must be less than or equal to Size\")\n\t}\n\tif f.Size()%f.PageSize != 0 {\n\t\treturn errors.New(\"Size must be a multiple of PageSize\")\n\t}\n\tif f.Size()%f.EraseBlockSize != 0 {\n\t\treturn errors.New(\"Size must be a multiple of EraseBlockSize\")\n\t}\n\tif f.EraseBlockSize > f.Size() {\n\t\treturn errors.New(\"EraseBlockSize must be less than or equal to Size\")\n\t}\n\tif f.EraseBlockSize > f.EraseUnitSize {\n\t\treturn errors.New(\"EraseBlockSize must be less than or equal to EraseUnitSize\")\n\t}\n\tif f.EraseUnitSize > f.EraseBlockSize {\n\t\treturn errors.New(\"EraseUnitSize must be less than or equal to EraseBlockSize\")\n\t}\n\tif f.EraseUnitSize > f.Size() {\n\t\treturn errors.New(\"Erase", "CodeBleu_score": 23.43814764912565}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, errors.New(\"flashBlockDevice: negative offset\")\n\t}\n\tif off >= f.Size() {\n\t\treturn 0, errors.New(\"flashBlockDevice: write outside flash memory\")\n\t}\n\tif int64(len(p))+off > f.Size() {\n\t\treturn 0, errors.New(\"flashBlockDevice: write outside flash memory\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off%int64(f.WriteBlockSize) != 0 {\n\t\treturn 0, errors.New(\"flashBlockDevice: offset not aligned to write block size\")\n\t}\n\tif len(p)%f.WriteBlockSize != 0 {\n\t\treturn 0, errors.New(\"flashBlockDevice: data not aligned to write block size\")\n\t}\n\tn = len(p)\n\toff += int64(f.pad)\n\tstart := uintptr(off)\n\tFlashDataStart = uintptr(start)\n\twaitWhileFlashBusy\n\tint\n\tlen\n\tbinary.LittleEndian.Uint32\n\t(*uint32)\n\tFlashDataEnd\n\tf.WriteBlockSize\n\tuintptr\n\tunsafe.Pointer\n\tf.pad\n\n", "CodeBleu_score": 31.075596358141645}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds.\n\tif off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, errors.New(\"flashBlockDevice: write exceeds flash memory bounds\")\n\t}\n\t// Calculate the start address for writing and pad the byte slice to fit the write block size.\n\tstartAddress := f.StartAddress + off\n\tp = padToBlockSize(p, f.WriteBlockSize)\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\twaitWhileFlashBusy()\n\t// Write the data in blocks.\n\tfor len(p) > 0 {\n\t\t// Calculate the number of bytes to write in the current block.\n\t\tbytesToWrite := len(p)\n\t\tif bytesToWrite > int(f.WriteBlockSize) {\n\t\t\tbytesToWrite = int(f.WriteBlockSize)\n\t\t}\n\t\t// Write the data.\n\t\tFlashDataStart = (*uint32)(unsafe.Pointer(uintptr(startAddress)))\n\t\tFlashDataEnd = FlashDataStart + uintptr(bytesToWrite)\n\t\tfor FlashDataStart < FlashDataEnd {\n\t\t\t*FlashDataStart = uint32(p[0]) | (uint32(p[1]) << 8) | (uint32(p[2]) << 16) | (uint32(p[3]) << 24)\n\t\t\tFlashDataStart++\n\t\t\tp = p[4:]\n\t\t}\n\t\t// Wait for the flash memory to be ready after each write operation.\n\t\twaitWhileFlashBusy()\n\t}\n\t// Disable write mode on the flash memory controller.\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\twaitWhileFlashBusy()\n\t// Return the number of bytes written.\n\treturn len(p), nil\n}", "CodeBleu_score": 40.81591946700788}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, errors.New(\"flashBlockDevice: negative offset\")\n\t}\n\tif off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, errors.New(\"flashBlockDevice: write out of bounds\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif len(p)%f.WriteBlockSize != 0 {\n\t\tp = append(p, make([]byte, f.WriteBlockSize-(len(p)%f.WriteBlockSize))...)\n\t}\n\tf.pad(p)\n\tn = len(p)\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tFlashDataStart\n\twaitWhileFlashBusy\n\tint\n\tlen\n\tbinary.LittleEndian.Uint32\n\t(*uint32)\n\tFlashDataEnd\n\tf.WriteBlockSize\n\tuintptr\n\tunsafe.Pointer\n\tf.pad\n\n", "CodeBleu_score": 35.41056794829734}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar dir *syscall.Dir\n\tvar err error\n\tvar dupfd syscallFd\n\tvar errno syscall.Errno\n\n\t// Duplicate the provided file descriptor.\n\tif dupfd, errno = syscall.Dup(int(fd)); errno != 0 {\n\t\treturn 0, \"Dup\", fmt.Errorf(\"unable to duplicate file descriptor: %s\", errno.Error())\n\t}\n\n\t// Open the directory.\n\tfor {\n\t\tif dir, err = syscall.Fdopendir(dupfd); err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Check for an interrupt.\n\t\tif err == syscall.EINTR {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Close the duplicated file descriptor.\n\t\tsyscall.Close(dupfd)\n\t\treturn 0, \"Fdopendir\", err\n\t}\n\n\t// Close the duplicated file descriptor.\n\tsyscall.Close(dupfd)\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 43.74542981383342}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the provided file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to duplicate file descriptor: %s\", err)\n\t}\n\n\t// Attempt to open the directory using the duplicated file descriptor.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\t// Close the duplicated file descriptor.\n\t\tsyscall.Close(dupFd)\n\n\t\t// Return the error message.\n\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %s\", err)\n\t}\n\n\t// Return the directory pointer.\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 47.41264284641614}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor\n\tdup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"error duplicating file descriptor: %s\", err)\n\t}\n\n\t// Open the directory\n\tdir, err := syscall.Fdopendir(dup)\n\tif err != nil {\n\t\t// Close the duplicated file descriptor\n\t\tsyscall.Close(dup)\n\n\t\t// Return the error message\n\t\treturn 0, \"\", fmt.Errorf(\"error opening directory: %s\", err)\n\t}\n\n\t// Return the directory pointer\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 47.751814854368476}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  uint32_t size = 0;\n  const esp_partition_t* running = esp_ota_get_running_partition();\n  if (esp_ota_get_partition_description(running, &size, NULL, NULL) == ESP_OK) {\n    if (response == SKETCH_SIZE_RESPONSE_FREE) {\n      size = running->size - size;\n    }\n  }\n  return size;\n}", "CodeBleu_score": 36.809889129467486}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    const esp_partition_t* running = esp_ota_get_running_partition();\n    if (running == NULL) {\n        return 0;\n    }\n\n    if (response == FREE_SPACE) {\n        return esp_partition_get_free_space(running);\n    }\n\n    if (esp_ota_get_partition_description(running, &ota_partition_description) != ESP_OK) {\n        return 0;\n    }\n\n    if (esp_image_verify(running->address, ota_partition_description.image_len, running->address, ota_partition_description.image_len) != ESP_OK) {\n        return 0;\n    }\n\n    return ota_partition_description.image_len;\n}", "CodeBleu_score": 49.08146562264707}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    esp_partition_t *running = esp_ota_get_running_partition();\n    if (running == NULL) {\n        return 0;\n    }\n    uint32_t size = 0;\n    if (esp_ota_get_partition_description(running, &size, NULL, NULL) == ESP_OK) {\n        if (response == SKETCH_SIZE) {\n            return size;\n        } else if (response == SKETCH_FREE) {\n            return esp_partition_get_free_size(running);\n        }\n    }\n    return 0;\n}", "CodeBleu_score": 38.590524607535315}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t required_sectors;\n\tuint32_t i;\n\tuint8_t *ram_disk;\n\tbool success;\n\n\t// Calculate the required disk sectors\n\trequired_sectors = msc_update_get_required_disk_sectors(volume_label, serial_number);\n\n\t// Allocate memory for the RAM disk\n\tram_disk = calloc(required_sectors, SECTOR_SIZE);\n\tif (ram_disk == NULL) {\n\t\tlog_e(\"Allocation failed\");\n\t\treturn false;\n\t}\n\n\t// Set up the boot sector\n\tsuccess = fat_add_boot_sector(ram_disk, volume_label, serial_number);\n\tif (!success) {\n\t\tlog_e(\"Boot sector setup failed\");\n\t\tfree(ram_disk);\n\t\treturn false;\n\t}\n\n\t// Set up the file allocation table (FAT)\n\tsuccess = fat_add_table(ram_disk, required_sectors);\n\tif (!success) {\n\t\tlog_e(\"FAT setup failed\");\n\t\tfree(ram_disk);\n\t\treturn false;\n\t}\n\n\t// Add a root directory entry for a firmware file if a partition is running\n\tif (partition_is_running()) {\n\t\tsuccess = fat_add_root_file(ram_disk, volume_label);\n\t\tif (!success) {\n\t\t\tlog_e(\"Root directory entry setup failed\");\n\t\t\tfree(ram_disk);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Set the RAM disk as the current disk\n\tmsc_update_set_ram_disk(ram_disk, required_sectors);\n\n\t// Log the required disk sectors\n\tlog_d(\"Required disk sectors: %d\", required_sectors);\n\n\t// Return success\n\treturn true;\n}", "CodeBleu_score": 36.941824434376336}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t required_disk_sectors;\n\tuint32_t i;\n\tuint8_t *ram_disk;\n\tuint32_t boot_sector_offset;\n\tuint32_t fat_offset;\n\tuint32_t root_dir_offset;\n\tuint32_t root_dir_size;\n\tuint32_t root_dir_entry_offset;\n\tuint32_t root_dir_entry_size;\n\tuint32_t data_offset;\n\tuint32_t data_size;\n\tuint32_t data_sector_count;\n\tuint32_t root_dir_entry_count;\n\tuint32_t root_dir_entry_index;\n\tuint32_t root_dir_entry_size_bytes;\n\tuint32_t root_dir_entry_offset_bytes;\n\tuint32_t root_dir_entry_index_bytes;\n\tuint32_t fat_entry_count;\n\tuint32_t fat_entry_size_bytes;\n\tuint32_t fat_entry_index_bytes;\n\tuint32_t fat_entry_offset_bytes;\n\tuint32_t fat_entry_index;\n\tuint32_t fat_entry_value;\n\tuint32_t fat_entry_value_bytes;\n\tuint32_t fat_entry_value_bytes_mask;\n\tuint32_t fat_entry_value_bytes_shift;\n\tuint32_t fat_entry_value_bytes_mask_shifted;\n\tuint32_t fat_entry_value_bytes_shifted;\n\tuint32_t fat_entry_value_bytes_shifted_masked;\n\tuint32_t fat_entry_value_bytes_shifted_masked_shifted;\n\tuint32_t fat_entry_value_bytes_shifted_masked_shifted_masked;\n\tuint32_t fat_entry_value_bytes_shifted_masked_shifted_masked_shifted;\n\tuint32_t fat", "CodeBleu_score": 6.647235417997385}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t required_disk_sectors;\n    bool success;\n    uint32_t i;\n    uint8_t *buffer;\n\n    /* Calculate the required disk sectors. */\n    required_disk_sectors = msc_update_get_required_disk_sectors(volume_label, serial_number);\n\n    /* Allocate memory for the RAM disk. */\n    buffer = calloc(required_disk_sectors, SECTOR_SIZE);\n    if (buffer == NULL) {\n        log_e(\"Failed to allocate memory for the RAM disk.\");\n        return false;\n    }\n\n    /* Set up the boot sector. */\n    success = fat_add_boot_sector(buffer, required_disk_sectors, volume_label, serial_number);\n    if (!success) {\n        log_e(\"Failed to set up the boot sector.\");\n        free(buffer);\n        return false;\n    }\n\n    /* Set up the file allocation table (FAT). */\n    success = fat_add_table(buffer, required_disk_sectors);\n    if (!success) {\n        log_e(\"Failed to set up the file allocation table (FAT).\");\n        free(buffer);\n        return false;\n    }\n\n    /* Add a root directory entry for a firmware file if a partition is running. */\n    if (partition_is_running()) {\n        success = fat_add_root_file(buffer, required_disk_sectors);\n        if (!success) {\n            log_e(\"Failed to add a root directory entry for a firmware file.\");\n            free(buffer);\n            return false;\n        }\n    }\n\n    /* Set up the RAM disk. */\n    for (i = 0; i < required_disk_sectors; i++) {\n        msc_update_add_sector(buffer + (i * SECTOR_SIZE));\n    }\n\n    /* Free the memory allocated for the RAM disk. */\n    free(buffer);\n\n    return true;\n}", "CodeBleu_score": 40.395964089989356}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t ret;\n    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"offset 0x%x is not sector aligned\", offset);\n        return ESP_ERR_INVALID_ARG;\n    }\n    if (size % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"size 0x%x is not sector aligned\", size);\n        return ESP_ERR_INVALID_ARG;\n    }\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"update write out of range\");\n        return ESP_ERR_INVALID_ARG;\n    }\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        ret = esp_partition_erase_range(partition, offset, size);\n        if (ret != ESP_OK) {\n            ESP_LOGE(TAG, \"failed to erase partition\");\n            return ret;\n        }\n    }\n    ret = esp_partition_write(partition, offset, data, size);\n    if (ret != ESP_OK) {\n        ESP_LOGE(TAG, \"failed to write partition\");\n        return ret;\n    }\n    return ESP_OK;\n}", "CodeBleu_score": 49.75812026215599}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n    if (partition == NULL) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (offset % partition->size != 0) {\n        ESP_LOGE(TAG, \"update_write: offset 0x%x is not a multiple of partition size 0x%x\", offset, partition->size);\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"update_write: update region (0x%x-0x%x) exceeds partition size 0x%x\", offset, offset + size, partition->size);\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"update_write: failed to erase sector 0x%x\", offset);\n            return err;\n        }\n    }\n\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"update_write: failed to write update data to partition %s\", partition->label);\n    }\n    return err;\n}", "CodeBleu_score": 59.1469360151893}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    if (offset % FLASH_SECTOR_SIZE != 0) {\n        ESP_LOGE(TAG, \"Update write: offset 0x%x is not sector aligned\", offset);\n        return ESP_ERR_INVALID_ARG;\n    }\n    err = esp_partition_erase_range(partition, offset, FLASH_SECTOR_SIZE);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Update write: failed to erase sector 0x%x\", offset);\n        return err;\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Update write: failed to write data\");\n    }\n    return err;\n}", "CodeBleu_score": 56.43474754975231}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i, j;\n    unsigned char c;\n    for (i = 0; i < maxlen; i++) {\n        c = hex_char_to_byte(in[i * 2]);\n        if (c == 0xff) {\n            break;\n        }\n        out[i] = c;\n        c = hex_char_to_byte(in[i * 2 + 1]);\n        if (c == 0xff) {\n            break;\n        }\n        out[i] = (out[i] << 4) | c;\n    }\n    for (j = i; j < maxlen; j++) {\n        out[j] = 0;\n    }\n    return i;\n}", "CodeBleu_score": 47.93310880583753}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t outlen = 0;\n    while (outlen < maxlen && *in) {\n        int hi = hex_char_to_byte(*in++);\n        if (hi == -1) continue;\n        int lo = hex_char_to_byte(*in++);\n        if (lo == -1) continue;\n        out[outlen++] = (hi << 4) | lo;\n    }\n    return outlen;\n}", "CodeBleu_score": 41.69545607979078}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i, j, len;\n\n    len = 0;\n    for (i = 0; in[i] && len < maxlen; i++) {\n        if (in[i] == ' ')\n            continue;\n        if (in[i] >= '0' && in[i] <= '9')\n            j = in[i] - '0';\n        else if (in[i] >= 'a' && in[i] <= 'f')\n            j = in[i] - 'a' + 10;\n        else if (in[i] >= 'A' && in[i] <= 'F')\n            j = in[i] - 'A' + 10;\n        else\n            break;\n        if (i % 2 == 0) {\n            out[len] = j << 4;\n        } else {\n            out[len++] |= j;\n        }\n    }\n    return len;\n}", "CodeBleu_score": 44.93967167004888}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (txBuf == NULL)\n\t\treturn 0;\n\tif (txBuf->lock == NULL)\n\t\treturn 0;\n\tif (xSemaphoreTake(txBuf->lock, portMAX_DELAY) != pdTRUE)\n\t\treturn 0;\n\tint freeSize = xRingbufferGetCurFreeSize(txBuf->ringBuf);\n\txSemaphoreGive(txBuf->lock);\n\treturn freeSize;\n}", "CodeBleu_score": 37.70721754681502}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (txRingBuf == NULL) return 0;\n\tif (txLock == NULL) return 0;\n\tif (xSemaphoreTake(txLock, pdMS_TO_TICKS(TX_BUF_LOCK_TIMEOUT_MS)) == pdTRUE) {\n\t\tint freeSize = xRingbufferGetCurFreeSize(txRingBuf);\n\t\txSemaphoreGive(txLock);\n\t\treturn freeSize;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 54.58974209025102}, {"code": "int HWCDC::availableForWrite(void){\n\t    if (tx_ringbuffer == NULL || tx_ringbuffer_lock == NULL) {\n        return 0;\n    }\n\n    if (xSemaphoreTake(tx_ringbuffer_lock, portMAX_DELAY) != pdTRUE) {\n        return 0;\n    }\n\n    int free_size = xRingbufferGetCurFreeSize(tx_ringbuffer);\n    xSemaphoreGive(tx_ringbuffer_lock);\n\n    return free_size;\n}", "CodeBleu_score": 67.79405995639146}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\t_rxTimeout = onlyOnTimeout;\n\tif (_onReceiveCB) {\n\t\tuartSetRxFIFOFull(UART_FIFO_FULL_THRESHOLD_1);\n\t\tif (!_eventTask) {\n\t\t\t_eventTask = _createEventTask();\n\t\t}\n\t} else {\n\t\tuartSetRxFIFOFull(UART_FIFO_FULL_THRESHOLD_8);\n\t\tif (_eventTask) {\n\t\t\t_eventTask->detach();\n\t\t\t_eventTask = NULL;\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 44.71966494550293}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _rxTimeout = onlyOnTimeout;\n  uartSetRxFIFOFull(_rxTimeout ? 1 : 0);\n  if (_onReceiveCB != NULL) {\n    if (_eventTask == NULL) {\n      _eventTask = _createEventTask();\n    }\n  } else {\n    if (_eventTask != NULL) {\n      _eventTask->cancel();\n      _eventTask = NULL;\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 53.82635454476268}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n\n  _onReceiveCB = function;\n  _rxTimeout = onlyOnTimeout;\n\n  if (_onReceiveCB) {\n    uartSetRxFIFOFull(_uart, 1);\n    if (!_eventTask) {\n      _eventTask = _createEventTask();\n    }\n  } else {\n    uartSetRxFIFOFull(_uart, 0);\n    if (_eventTask) {\n      _eventTask->cancel();\n      _eventTask = NULL;\n    }\n  }\n\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 50.78775458067803}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index++] = (char)c;\n\t}\n\treturn index;\n}", "CodeBleu_score": 65.95763086468524}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tint index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c == -1 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index++] = (char)c;\n\t}\n\treturn index;\n}", "CodeBleu_score": 62.425292067846705}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    buffer[index++] = c;\n  }\n  return index;\n}", "CodeBleu_score": 67.31911106065225}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    log_i(\"tone\", pin, frequency, duration);\n\n    if (is_pin_available(pin)) {\n        tone_init(pin, frequency, duration);\n        xQueueSend(tone_queue, &pin, 0);\n    } else {\n        log_e(\"tone\", \"pin already in use\");\n    }\n}", "CodeBleu_score": 32.39834677960848}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    log_d(\"pin: %d, frequency: %d, duration: %d\", pin, frequency, duration);\n    if (pin >= D0 && pin <= D7) {\n        if (tone_pins[pin] == 0) {\n            tone_pins[pin] = 1;\n            tone_init(pin, frequency, duration);\n            xQueueSend(tone_queue, &pin, portMAX_DELAY);\n        } else {\n            log_e(\"Pin %d is already in use!\", pin);\n        }\n    } else {\n        log_e(\"Pin %d is not available!\", pin);\n    }\n}", "CodeBleu_score": 46.860830607596554}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  // log the pin, frequency, and duration\n  log_d(\"Tone pin: %d, frequency: %d, duration: %d\", pin, frequency, duration);\n\n  // check if the pin is available or already in use\n  if (tone_pins[pin] == 0) {\n    // initialize the tone\n    tone_init(pin, frequency, duration);\n    // send a start command with the pin, frequency, and duration to the queue\n    xQueueSend(tone_queue, &tone_cmd, portMAX_DELAY);\n  } else {\n    // log an error message instructing to stop the current tone on the pin first\n    log_e(\"Tone pin %d is already in use, stop the tone first\", pin);\n  }\n}", "CodeBleu_score": 35.834444618578026}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!_started) {\n    _webUSB = enabled;\n    return true;\n  }\n  if (_webUSB != enabled) {\n    if (enabled) {\n      if (_usbVersion < 0x0210) {\n        return true;\n      }\n      _webUSB = enabled;\n    } else {\n      _webUSB = enabled;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 45.611333692255364}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!_usbStarted) {\n    _webUSB = enabled;\n    return true;\n  }\n  if (_webUSB != enabled) {\n    _webUSB = enabled;\n    if (_webUSB) {\n      if (_usbVersion < 0x0210) {\n        _webUSB = false;\n        return true;\n      }\n    }\n  }\n  return false;\n}", "CodeBleu_score": 42.759433421378205}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!started) {\n    if (enabled) {\n      if (usbVersion < 0x0210) {\n        return true;\n      }\n      webUSBEnabled = enabled;\n    }\n    return false;\n  }\n  if (enabled) {\n    if (webUSBEnabled) {\n      return false;\n    }\n    webUSBEnabled = enabled;\n    if (webUSBEnabled) {\n      if (usbVersion < 0x0210) {\n        return true;\n      }\n      if (webUSBEnabled) {\n        if (webUSBInterface == NULL) {\n          webUSBInterface = new WebUSBInterface(this);\n          if (webUSBInterface == NULL) {\n            return true;\n          }\n        }\n      }\n    }\n  } else {\n    if (!webUSBEnabled) {\n      return false;\n    }\n    webUSBEnabled = enabled;\n    if (!webUSBEnabled) {\n      if (webUSBInterface != NULL) {\n        delete webUSBInterface;\n        webUSBInterface = NULL;\n      }\n    }\n  }\n  return false;\n}", "CodeBleu_score": 43.051383886386944}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t    // Read data into a buffer\n    uint8_t buffer[USBCDC_RX_BUFFER_SIZE];\n    uint32_t length = tud_cdc_n_read(USBCDC_RX_BUFFER_SIZE, buffer);\n\n    // If data was read, attempt to send it to the receive queue\n    if (length > 0) {\n        // Attempt to send the data to the receive queue\n        if (xQueueSend(USBCDC_RX_QUEUE, buffer, 0) != pdPASS) {\n            // If the queue is full, log an error\n            LOG_ERROR(\"USBCDC: Receive queue overflowed\");\n\n            // Post an overflow event\n            USBCDC_EVENT_POST(USBCDC_EVENT_RX_OVERFLOW, length);\n        }\n\n        // Post a receive event\n        USBCDC_EVENT_POST(USBCDC_EVENT_RX_DATA, length);\n    }\n}", "CodeBleu_score": 17.318150119779343}, {"code": "void USBCDC::_onRX(){\n\t  uint32_t read_count = tud_cdc_n_read(_cdc_itf, _rx_buffer, sizeof(_rx_buffer));\n  if (read_count > 0) {\n    if (xQueueSend(_rx_queue, _rx_buffer, 0) != pdPASS) {\n      _onOverflow(read_count);\n    } else {\n      _onReceive(read_count);\n    }\n  }\n}", "CodeBleu_score": 11.635799012587942}, {"code": "void USBCDC::_onRX(){\n\t\tuint32_t count = tud_cdc_n_read(_instance, _buffer, sizeof(_buffer));\n\tif (count > 0) {\n\t\tif (xQueueSend(_rxQueue, _buffer, pdMS_TO_TICKS(100)) != pdPASS) {\n\t\t\tuint32_t dropped = count - xQueueSpacesAvailable(_rxQueue);\n\t\t\tif (dropped > 0) {\n\t\t\t\t_rxOverflowEvent.post(dropped);\n\t\t\t\tLOG_ERR(\"USBCDC: RX overflow, dropped %u bytes\", dropped);\n\t\t\t}\n\t\t}\n\t\t_rxEvent.post(count);\n\t}\n}", "CodeBleu_score": 20.33590857663943}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request\n\trobotName := req.URL.Query().Get(\"robot\")\n\tif robotName == \"\" {\n\t\thttp.Error(res, \"No robot specified\", http.StatusBadRequest)\n\t\treturn\n\t}\n\t// Check if the robot exists\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\t// Get the devices from the robot\n\tdevices := robot.Devices()\n\t// Write the devices to the response\n\tif err := a.writeJSON(res, devices); err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 36.87946381829853}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Check if a robot with the given name exists.\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\t// Gather the devices associated with the robot into a JSON format and write this JSON response to the HTTP response writer.\n\tdevices := robot.Devices().List()\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 28.7830858086785}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\":name\")\n\trobot, err := a.master.Robot(name)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, `{\"error\":\"no robot with name %q found\"}`, name)\n\t\treturn\n\t}\n\tdevices := robot.Devices()\n\tdevices.Each(func(device gobot.Device) {\n\t\tdevice.SetName(strings.Replace(device.Name(), \"_\", \" \", -1))\n\t})\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\terr = json.NewEncoder(res).Encode(devices)\n\tif err != nil {\n\t\tlog.Println(\"error encoding json:\", err)\n\t}\n}", "CodeBleu_score": 47.566954444082654}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL.\n\trobotName := req.URL.Query().Get(\":robot\")\n\n\t// Check if the robot exists.\n\tif robot, ok := a.master.Robots[robotName]; ok {\n\t\t// Iterate through the robot's connections and convert them to JSON.\n\t\tconnections := []map[string]interface{}{}\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tconnections = append(connections, c.Export())\n\t\t})\n\n\t\t// Write the connections to the HTTP response.\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\t// Write an error message to the HTTP response.\n\t\ta.writeError(res, fmt.Errorf(\"No robot with name %s found\", robotName))\n\t}\n}", "CodeBleu_score": 51.86396435470775}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"no robot with name \" + robotName + \" found\"))\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\tconnectionsJSON := make([]map[string]interface{}, len(connections))\n\tfor i, connection := range connections {\n\t\tconnectionsJSON[i] = connection.Export()\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(gobot.ToJSON(connectionsJSON)))\n}", "CodeBleu_score": 47.590552045816914}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL.\n\trobotName := req.URL.Query().Get(\":name\")\n\n\t// Check if the robot exists.\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\t// If the robot does not exist, write an error message to the HTTP response.\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON format.\n\tconnections := make([]map[string]interface{}, len(robot.Connections()))\n\tfor i, connection := range robot.Connections() {\n\t\tconnections[i] = connection.Export()\n\t}\n\n\t// Write the JSON-formatted connections to the HTTP response.\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 44.42172567084097}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL query parameter\n\trobotName := req.URL.Query().Get(\":robot\")\n\t// Get the device name from the URL query parameter\n\tdeviceName := req.URL.Query().Get(\":device\")\n\t// Get the command name from the URL query parameter\n\tcommandName := req.URL.Query().Get(\":command\")\n\t// Get the command arguments from the URL query parameter\n\tcommandArgs := req.URL.Query().Get(\":args\")\n\t// Check if the robot exists\n\tif a.master.Robot(robotName) == nil {\n\t\t// If not, write an error message as a JSON response\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"Robot not found\"})\n\t\treturn\n\t}\n\t// Check if the device exists\n\tif a.master.Robot(robotName).Device(deviceName) == nil {\n\t\t// If not, write an error message as a JSON response\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"Device not found\"})\n\t\treturn\n\t}\n\t// If the device exists, execute the command on the device using the Gobot framework\n\terr := a.master.Robot(robotName).Device(deviceName).(gobot.Commander).Command(commandName, commandArgs)\n\t// If an error occurs, write the error message as a JSON response\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\t// Otherwise, write a success message as a JSON response\n\ta.writeJSON(res, http.StatusOK, map[string]string{\"message\": \"Success\"})\n}", "CodeBleu_score": 52.39070687386614}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.writeJSON(a.executeCommand(a.master.Robot(req.URL.Query().Get(\":robot\")).\n\t\t\t\tDevice(req.URL.Query().Get(\":device\")).(gobot.Commander).\n\t\t\t\tCommand(req.URL.Query().Get(\":command\")), res)\n}", "CodeBleu_score": 33.47716416211851}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\tcommand := req.URL.Query().Get(\":command\")\n\n\t// Check if the device exists.\n\tif !a.master.Robot(robotName).DeviceExists(deviceName) {\n\t\t// If the device does not exist, return a 404 error.\n\t\thttp.Error(res, \"Device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Execute the specified command on the device.\n\terr := a.master.Robot(robotName).Device(deviceName).(gobot.Commander).Command(command)\n\n\t// If an error occurs, write the error message as a JSON response.\n\tif err != nil {\n\t\t// Write the error message as a JSON response.\n\t\ta.writeJSON(res, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\t// If no error occurs, write a JSON response with the command result.\n\ta.writeJSON(res, map[string]string{\"result\": \"OK\"})\n}", "CodeBleu_score": 52.80838219999773}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If everything checks out, call the next handler.\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.288584538826655}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif user == username && pass == password {\n\t\t\tnext(w, r)\n\t\t} else {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t}\n\t}\n}", "CodeBleu_score": 54.129389574560996}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tif username != pair[0] || password != pair[1] {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// authentication succeeded\n\t}\n}", "CodeBleu_score": 49.48901642047574}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection().SupportsAnalogRead() {\n\t\traw, err := reader.AnalogRead(a.Pin())\n\t\tif err != nil {\n\t\t\treturn 0, 0, fmt.Errorf(\"analog sensor read error: %v\", err)\n\t\t}\n\t\tscaled := a.scale(raw)\n\t\ta.lastRead.Raw = raw\n\t\ta.lastRead.Scaled = scaled\n\t\treturn raw, scaled, nil\n\t}\n\treturn 0, 0, fmt.Errorf(\"analog sensor read error: connection does not support analog read\")\n}", "CodeBleu_score": 49.25128088518582}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor read not supported on connection %s\", a.Connection().Name)\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor read failed on connection %s: %w\", a.Connection().Name, err)\n\t}\n\tscaled := a.sensorCfg.Scale(raw)\n\ta.lastRawValue = raw\n\ta.lastScaledValue = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.33143437075279}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog reading\", a.Connection().Name())\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog read failed: %s\", err)\n\t}\n\tif a.sensorCfg.scale == nil {\n\t\treturn raw, float64(raw), nil\n\t}\n\tscaled := a.sensorCfg.scale.Scale(float64(raw))\n\ta.lastRead.raw = raw\n\ta.lastRead.scaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 50.1073133390146}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := &GroveSoundSensorDriver{\n\t\tname: DefaultName,\n\t\tpin:  pin,\n\t\ta:    a,\n\t}\n\n\ts.SetName(s.name)\n\n\treturn s\n}", "CodeBleu_score": 28.619436624555288}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tsensor := new(GroveSoundSensorDriver)\n\tsensor.name = gobot.DefaultName(\"GroveSoundSensor\")\n\tsensor.pin = pin\n\tsensor.Ain = a\n\tsensor.interval = 10 * time.Millisecond\n\tsensor.threshold = 100\n\tsensor.enabled = true\n\tsensor.sound = 0\n\tsensor.soundDB = 0\n\tsensor.soundLevel = 0\n\tsensor.soundDBLevel = 0\n\tsensor.soundDBAverage = 0\n\tsensor.soundAverage = 0\n\tsensor.soundLevelAverage = 0\n\tsensor.soundDBLevelAverage = 0\n\tsensor.soundDBAverageCount = 0\n\tsensor.soundAverageCount = 0\n\tsensor.soundLevelAverageCount = 0\n\tsensor.soundDBLevelAverageCount = 0\n\tsensor.work = func() {\n\t\tfor sensor.Enabled() {\n\t\t\tsensor.sound = sensor.Ain.Read()\n\t\t\tsensor.soundDB = sensor.sound - sensor.threshold\n\t\t\tsensor.soundLevel = sensor.soundDB / 10\n\t\t\tsensor.soundDBLevel = sensor.soundDB / 20\n\t\t\tsensor.soundDBAverage = sensor.soundDBAverage + sensor.soundDB\n\t\t\tsensor.soundAverage = sensor.soundAverage + sensor.sound\n\t\t\tsensor.soundLevelAverage = sensor.soundLevelAverage + sensor.soundLevel\n\t\t\tsensor.soundDBLevelAverage = sensor.soundDBLevelAverage + sensor.soundDBLevel\n\t\t\tsensor.soundDBAverageCount++\n\t\t\tsensor.soundAverageCount++\n\t\t\tsensor.soundLevelAverageCount++\n\t\t\tsensor.soundDBLevelAverageCount++\n\t\t\ttime.Sleep(sensor.interval)\n\t\t}\n\t}\n\treturn sensor\n}", "CodeBleu_score": 24.896021421727855}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tvar options = make(map[string]interface{})\n\tvar name = gobot.DefaultName(\"GroveSoundSensor\")\n\tvar threshold = 0.0\n\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase gobot.Name:\n\t\t\tname = opt.(gobot.Name)\n\t\tcase Threshold:\n\t\t\tthreshold = opt.(Threshold)\n\t\tdefault:\n\t\t\tlog.Println(\"GroveSoundSensorDriver:\", opt, \"is not a valid option.\")\n\t\t}\n\t}\n\n\treturn &GroveSoundSensorDriver{\n\t\tname:       name,\n\t\tpin:        pin,\n\t\tthreshold:  threshold,\n\t\tAnalogSensorDriver: AnalogSensorDriver{\n\t\t\tname:       name,\n\t\t\tpin:        pin,\n\t\t\tAnalogReader: AnalogReader{\n\t\t\t\tpin:        pin,\n\t\t\t\tconnection: a,\n\t\t\t},\n\t\t},\n\t}\n}", "CodeBleu_score": 32.94671140178879}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(MFRC522CommandReg, MFRC522SoftReset)\n\ttime.Sleep(10 * time.Microsecond)\n\tstatus := d.readByteData(MFRC522CommandReg)\n\tif status&MFRC522PwrDwn != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.25291433747517}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Set the soft reset bit in the command register\n\td.writeByteData(commandReg, softReset)\n\n\t// Wait for the command register to show the command has finished executing\n\tif err := d.waitForCommandReg(softReset); err != nil {\n\t\treturn err\n\t}\n\n\t// Check the status register to see if the reset was successful\n\tif err := d.checkStatusReg(statusReg, rfReady); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 54.70344862596137}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(MFRC522RegCommandReg, MFRC522SoftReset)\n\ttime.Sleep(MFRC522ResetTime)\n\tif d.readByteData(MFRC522RegCommandReg)&MFRC522PwrDn != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 24.722279742599365}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tvar status uint8\n\tvar i uint8\n\tvar tmp uint8\n\tvar err error\n\n\t// Check buffer capacity.\n\tif len(backData) > _MFRC522_FIFO_LENGTH {\n\t\treturn 0, fmt.Errorf(\"BackData slice too large\")\n\t}\n\n\t// Read the FIFO data.\n\tfor i = 0; i < uint8(len(backData)); i++ {\n\t\ttmp, err = d.readByteData(_MFRC522_FIFO_DATA_REG)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = tmp\n\t}\n\n\t// Read the current status value.\n\tstatus, err = d.readByteData(_MFRC522_COMMAND_REG)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn status, nil\n}", "CodeBleu_score": 40.816172304164276}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check if there are any bytes available in the FIFO buffer.\n\tstatus, err := d.readRegister(FIFODataReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// Check if there are enough bytes in the FIFO buffer to read.\n\tif status == 0 {\n\t\treturn 0, fmt.Errorf(\"no data in FIFO\")\n\t}\n\tif status > uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"not enough data in FIFO: %d\", status)\n\t}\n\t// Read the bytes from the FIFO buffer.\n\tfor i := uint8(0); i < status; i++ {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the control register to get the last bits received.\n\tlastBits, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn lastBits, nil\n}", "CodeBleu_score": 53.08644971255661}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check the number of bytes available in the FIFO buffer.\n\tbytesAvailable, err := d.readReg(FifoLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the FIFO buffer is empty.\n\tif bytesAvailable == 0 {\n\t\treturn 0, fmt.Errorf(\"no data available in FIFO buffer\")\n\t}\n\n\t// Check if the FIFO buffer is equal to the length of the byte slice.\n\tif bytesAvailable != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"wrong number of bytes available in FIFO buffer: %d\", bytesAvailable)\n\t}\n\n\t// Read the bytes from the FIFO buffer into the byte slice.\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readReg(FifoDataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received.\n\tlastBits, err := d.readReg(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Return the last bits received.\n\treturn lastBits, nil\n}", "CodeBleu_score": 56.01521681134337}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"Halting communication with PICC.\")\n\t}\n\t// Build command\n\tcmd := []byte{d.CMD_HLTA}\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\t// Append CRC_A to command\n\tcmd = append(cmd, crc)\n\t// Send command\n\tif err := d.communicateWithPICC(d.CMD_HLTA, cmd, d.response, d.responseSize); err != nil {\n\t\treturn err\n\t}\n\t// Check response\n\tif d.response[d.responseOffset] != d.CMD_HLTA_RESP {\n\t\treturn fmt.Errorf(\"Unexpected response from PICC: 0x%x\", d.response[d.responseOffset])\n\t}\n\treturn nil\n}", "CodeBleu_score": 38.542295244586825}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.debugMessage(\"piccHalt()\")\n\n\t// Build command\n\tpiccHalt := []byte{piccHaltCommand}\n\n\t// Calculate CRC_A\n\tpiccHalt = append(piccHalt, d.calculateCRC(piccHalt)...)\n\n\t// Send command\n\terr := d.communicateWithPICC(piccHaltCommand, piccHalt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check response\n\treturn d.checkResponseInList(piccHaltResponse, []uint8{piccHaltCommand})\n}", "CodeBleu_score": 33.5941827182867}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Build command\n\tpiccHaltCmd := []byte{piccHalt}\n\n\t// Calculate CRC_A\n\tpiccHaltCmd = append(piccHaltCmd, d.calculateCRC(piccHaltCmd)...)\n\n\t// Send command\n\tif err := d.communicateWithPICC(piccHaltCmd, piccHalt); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.80251458986019}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build command\n\tdata := []byte{piccRead, block}\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(data)\n\t// Append CRC_A to the command\n\tdata = append(data, crc[0])\n\tdata = append(data, crc[1])\n\t// Send command\n\tresponse, err := d.communicateWithPICC(data, piccRead, 16)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Verify response\n\tif !bytes.Equal(response[0:2], []byte{piccRead, piccSuccess}) {\n\t\treturn nil, errors.New(\"Error reading block\")\n\t}\n\treturn response[2:18], nil\n}", "CodeBleu_score": 40.83896743098816}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Sanity check\n\tif block > 15 {\n\t\treturn nil, errors.New(\"block out of range\")\n\t}\n\t// Build command\n\tcommand := []byte{MFRC522_READ, block}\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(command)\n\t// Append CRC_A to command\n\tcommand = append(command, crc)\n\t// Send command\n\tresponse, err := d.communicateWithPICC(command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Verify response\n\tif len(response) != 18 {\n\t\treturn nil, errors.New(\"response length is incorrect\")\n\t}\n\tif response[0] != MFRC522_READ_ACK {\n\t\treturn nil, errors.New(\"response does not contain ACK\")\n\t}\n\t// Return response data\n\treturn response[1:17], nil\n}", "CodeBleu_score": 44.87846187469782}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// The command is composed of a 1 byte command code, a 2 byte block address, and a 2 byte trailer.\n\tcommand := []byte{d.READ, block}\n\t// Calculate the CRC for the command.\n\tcrc := d.calculateCRC(command)\n\t// Append the CRC to the command.\n\tcommand = append(command, crc[0], crc[1])\n\t// Send the command.\n\tresponse, err := d.communicateWithPICC(command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Verify the response is the expected length.\n\tif len(response) != 16 {\n\t\treturn nil, fmt.Errorf(\"expected 16 bytes, got %d\", len(response))\n\t}\n\t// Return the response.\n\treturn response, nil\n}", "CodeBleu_score": 37.07203017255857}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Sanity check\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: Answer buffer too small: %d\", len(answer))\n\t}\n\n\t// Clear the answer buffer\n\tfor i := 0; i < len(answer); i++ {\n\t\tanswer[i] = 0\n\t}\n\n\t// Clear the bits in the CollReg that are used in the REQA and WUPA commands.\n\td.clearRegisterBitMask(d.CollReg, 0x80+0x40+0x20)\n\n\t// Set the bits in the FIFOLevelReg that are used in the REQA and WUPA commands.\n\td.setRegisterBitMask(d.FIFOLevelReg, 0x80+0x40+0x20)\n\n\t// Write the REQA or WUPA command in the FIFO\n\td.writeToFifo([]byte{reqMode, 0})\n\n\t// Execute the command\n\td.execute(CommandPCD_TRANSCEIVE, 0x0C, 0x00)\n\n\t// Wait for the command to complete\n\terr := d.waitForCommandEnd()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the answer is not valid, return an error\n\tif d.readRegister(d.ErrorReg)&0x1B != 0 {\n\t\treturn fmt.Errorf(\"piccRequest: Error in communication\")\n\t}\n\n\t// Copy the received data from the FIFO into the answer buffer\n\tfor i := 0; i < len(answer); i++ {\n\t\tanswer[i] = d.readFromFifo()\n\t}\n\n\t// Return the number of bytes received\n\treturn nil\n}", "CodeBleu_score": 50.47388690101767}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Clear the bits that are set in the CollReg\n\td.clearRegisterBitMask(CollReg, 0x80+0x40)\n\n\t// Set the bits in the FIFO that indicates which communication mode to use\n\t// Note that we do not use the command buffer here.\n\td.setRegisterValue(CommIEnReg, 0x80) // TxModeReg\n\td.setRegisterValue(DivlEnReg, 0x40) // CollReg\n\tif reqMode == MifareCmdHalt {\n\t\td.setRegisterValue(CommIEnReg, 0x00) // TxModeReg\n\t}\n\tif reqMode == MifareCmdCalcCRC {\n\t\td.setRegisterValue(CommIEnReg, 0x03) // TxModeReg\n\t}\n\tif reqMode == MifareCmdTransfer {\n\t\td.setRegisterValue(CommIEnReg, 0x08) // TxModeReg\n\t}\n\tif reqMode == MifareCmdTransfer && d.useTimeout {\n\t\td.setRegisterValue(CommIEnReg, 0x18) // TxModeReg\n\t}\n\n\t// Write the data to the FIFO\n\td.setRegisterValue(FIFODataReg, reqMode)\n\tif reqMode == MifareCmdHalt || reqMode == MifareCmdCalcCRC {\n\t\td.setRegisterValue(FIFODataReg, 0)\n\t}\n\n\t// Start the communication with the PICC\n\td.setRegisterValue(CommandReg, PCD_TRANSCEIVE)\n\n\t// Wait for the PICC to respond\n\terr := d.communicateWithPICC(MFRC522_MAX_LEN, answer)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"communicateWithPICC: %w\", err)\n\t}\n\n\t// Check that the response is the correct length\n\tif len(answer) != MFRC522_MAX", "CodeBleu_score": 43.46888439205886}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\t// Clear the two bits in the collision register that are used for collision detection.\n\td.clearRegisterBitMask(collReg, 0x03)\n\t// Send the request command.\n\td.writeRegister(commandReg, reqMode)\n\t// Wait for a response.\n\tirqEn := uint8(0x00)\n\t// We're expecting a response, clear the timer and wait around until either the response is received or a timeout occurs.\n\td.setRegister(timerReg, 0x7F)\n\tfor d.readRegister(commIrqReg)&irqEn == 0 {\n\t\t// CommIRqReg[7..0]\n\t\t// Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq\n\t\t// 0   0     0     1        0        0         0      0       1  Idle state.\n\t\t// 0   0     0     0        0        0         0      1       0  Rx state.\n\t\t// 0   0     0     0        0        0         1      0       0  Tx state.\n\t\t// 0   0     0     0        0        1         0      0       0  Rx state.\n\t\t// 0   0     0     0        1        0         0      0       0  Tx state.\n\t\t// 0   0     1     0        0        0         0      0       0  TxRx state.\n\t\t// 0   1     0     0        0        0         0      0       0  Rx state.\n\t\t// 0   1     0     0        0        1         0      0       0  TxRx state.\n\t\t// 0   1     0     0        1        0         0      0       0  Tx state.\n\t\t// 0   1     1     0        0        0         0      0       0  TxRx state.\n\t\t// 1   0     0     0        0        0         0      0", "CodeBleu_score": 30.41806880500647}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\t// Lock the value mutex to ensure thread safety while accessing shared variables.\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a valid step by setting the step pin low, waiting for a delay, and setting the step pin high.\n\td.digitalWrite(d.stepPin, gpio.Low)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, gpio.High)\n\n\t// Depending on the direction, increment or decrement the step number.\n\tif d.direction == DirectionCW {\n\t\td.stepNumber++\n\t} else if d.direction == DirectionCCW {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.5294457220964}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == 0 {\n\t\treturn errors.New(\"step pin not set\")\n\t}\n\n\tif d.direction == 0 {\n\t\treturn errors.New(\"direction not set\")\n\t}\n\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(time.Duration(d.getDelayPerStep()) * time.Millisecond)\n\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 65.98672037302893}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif d.stepPin != nil {\n\t\td.stepPin.Clear()\n\t\ttime.Sleep(d.getDelayPerStep())\n\t\td.stepPin.Set()\n\t}\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 39.795541517647735}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\n\treturn nil\n}", "CodeBleu_score": 68.21580159749709}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\treturn nil\n}", "CodeBleu_score": 68.21580159749709}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name())\n\treturn nil\n}", "CodeBleu_score": 68.11724870223819}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, timestamp32 uint32) {\n\t\tif edge == \"RISING\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if edge == \"FALLING\" {\n\t\t\td.eventChan <- d.calculateDuration(startTimestamp, time.Now())\n\t\t\tstartTimestamp = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.56027318114399}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, timestamp32 uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := (time.Now().Sub(startTimestamp)).Microseconds()\n\t\t\td.eventChannel <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 42.58083268593814}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, timestamp32 uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\td.pulseDurationChan <- (time.Now().Sub(startTimestamp)).Microseconds()\n\t\t\tstartTimestamp = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.89846091138421}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the mutex to ensure exclusive access to the sensor.\n\td.measureMutex.Lock()\n\t// Trigger the sensor.\n\td.emitTrigger()\n\t// Wait for the measurement to complete or for a timeout to occur.\n\ttimeout := time.After(d.timeout)\n\tselect {\n\tcase <-timeout:\n\t\t// Unlock the mutex.\n\t\td.measureMutex.Unlock()\n\t\t// Return an error.\n\t\treturn fmt.Errorf(\"Timeout\")\n\tcase <-d.measurementDone:\n\t\t// Unlock the mutex.\n\t\td.measureMutex.Unlock()\n\t\t// Return no error.\n\t\treturn nil\n\t}\n}", "CodeBleu_score": 30.513396812948134}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex.\n\td.measureMutex.Lock()\n\t// Trigger the sensor.\n\td.trigger.High()\n\t// Wait for the sensor to finish the measurement.\n\tif err := d.waitForMeasurement(); err != nil {\n\t\t// Unlock the measurement mutex.\n\t\td.measureMutex.Unlock()\n\t\t// Return the error.\n\t\treturn err\n\t}\n\t// Unlock the measurement mutex.\n\td.measureMutex.Unlock()\n\t// Return nil.\n\treturn nil\n}", "CodeBleu_score": 38.79605440705829}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access.\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor.\n\td.emitTrigger()\n\n\t// Wait for the measurement to complete or for a timeout to occur.\n\tselect {\n\tcase <-time.After(d.timeout):\n\t\treturn errors.New(\"timeout\")\n\tcase <-d.measureMutex.Signal:\n\t\t// The measurement is complete.\n\t}\n\n\t// Get the measured time in microseconds.\n\treturn nil\n}", "CodeBleu_score": 27.557378635979372}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    try:\n        access_token = os.environ.get('ACCESS_TOKEN')\n        refresh_token = os.environ.get('REFRESH_TOKEN')\n        if access_token and refresh_token:\n            return access_token\n        else:\n            access_token = self.get_local_session_item('access_token')\n            refresh_token = self.get_local_session_item('refresh_token')\n            expiration_time = self.get_local_session_item('expiration_time')\n            if access_token and refresh_token and expiration_time:\n                if expiration_time > time.time():\n                    return access_token\n                else:\n                    new_access_token = self.refresh_authentication_token(refresh_token)\n                    if new_access_token:\n                        self.set_local_session_item('access_token', new_access_token)\n                        self.set_local_session_item('refresh_token', refresh_token)\n                        self.set_local_session_item('expiration_time', time.time() + 3600)\n                        return new_access_token\n                    else:\n                        raise AccountNotAuthorized\n            else:\n                raise AccountNotAuthorized\n    except AccountNotAuthorized:\n        self.delete_local_session()\n        raise AccountNotAuthorized\n\n", "CodeBleu_score": 39.77274442896637}, {"code": "def fetch_authentication_token(self)\n\t\n    # Check if the access token is available in the environment variables\n    access_token = os.getenv('ACCESS_TOKEN')\n    if access_token:\n        return access_token\n\n    # Check if the access token is available in the local state\n    access_token = self.get_state_item('access_token')\n    expires_in = self.get_state_item('expires_in')\n    if access_token and expires_in and expires_in > time.time():\n        return access_token\n\n    # Check if the refresh token is available in the local state\n    refresh_token = self.get_state_item('refresh_token')\n    if not refresh_token:\n        raise AccountNotAuthorized('No refresh token available.')\n\n    # Attempt to fetch a new access token using the refresh token\n    try:\n        response = requests.post(\n            'https://api.amazon.com/auth/o2/token',\n            data={\n                'grant_type': 'refresh_token',\n                'refresh_token': refresh_token,\n                'client_id': self.client_id,\n                'client_secret': self.client_secret\n            }\n        )\n        response.raise_for_status()\n        data = response.json()\n        access_token = data['access_token']\n        expires_in = data['expires_in']\n        self.set_state_item('access_token', access_token)\n        self.set_state_item('expires_in', time.time() + expires_in)\n        self.set_state_item('refresh_token', refresh_token)\n        return access_token\n    except (requests.exceptions.HTTPError, KeyError, ValueError):\n        raise AccountNotAuthorized('Unable to retrieve access token.')\n\n", "CodeBleu_score": 42.19528781557704}, {"code": "def fetch_authentication_token(self)\n\t\n    # First, check if the token is available in the environment variables\n    token = self.get_env_var('AUTH_TOKEN')\n    if token:\n        return token\n\n    # Check if the token is available in the local state\n    token_data = self.get_local_session('token')\n    if token_data:\n        # Check if the token is expired\n        if self.is_token_expired(token_data['expires_at']):\n            # Check if a refresh token is available\n            if token_data['refresh_token']:\n                # Attempt to fetch a new access token using the refresh token\n                token = self.fetch_token_using_refresh_token(token_data['refresh_token'])\n                if token:\n                    # Update the local state with the new authentication data\n                    self.set_local_session('token', token)\n                    return token\n            # If the access token is expired and a refresh token is not available, raise an exception\n            raise AccountNotAuthorized('The access token is expired and a refresh token is not available.')\n        else:\n            # Return the access token\n            return token_data['access_token']\n\n    # If the token is not available in the environment variables or the local state, raise an exception\n    raise AccountNotAuthorized('The authentication token is not available.')\n\n", "CodeBleu_score": 33.789494835609105}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    self.get_refresh_token\n    self.delete_local_session\n    try:\n        self.session.post(self.base_url + \"/v1/logout\", data={\"refresh_token\": self.refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 37.480288407381764}, {"code": "def logout(self)\n\t\n    self.delete_local_session\n    self.fetch_json_data\n    self.get_refresh_token\n    try:\n        self.session.post(self.base_url + \"/v1/logout\", data=self.refresh_token)\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 31.87755246980376}, {"code": "def logout(self)\n\t\n    self.delete_local_session\n    self.fetch_json_data\n    self.get_refresh_token\n\n", "CodeBleu_score": 10.542570632371271}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    used_packages = []\n    for package in self.get_package():\n        if not package.optional:\n            if package.external_source_url:\n                used_packages.append({\n                    'name': package.name,\n                    'version': package.version,\n                    'source_url': package.external_source_url,\n                })\n            else:\n                used_packages.append({\n                    'name': package.name,\n                    'version': package.version,\n                })\n    return used_packages\n\n", "CodeBleu_score": 21.98814872625819}, {"code": "def dump_used_packages(self)\n\t\n    items = []\n    for package in self.get_package():\n        if package.optional:\n            continue\n        result = {\n            'name': package.name,\n            'version': package.version,\n        }\n        if package.source_url:\n            result['source_url'] = package.source_url\n        items.append(result)\n    return items\n\n", "CodeBleu_score": 30.180830114449808}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.get_packages():\n        if package.is_optional():\n            continue\n        items = []\n        items.append(package.name)\n        items.append(package.version)\n        if package.is_external():\n            items.append(package.source_url)\n        result.append(items)\n    return result\n\n", "CodeBleu_score": 29.205726123374053}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    \n    # Get the platform specification for the environment from the project configuration\n    platform = cls.get_instance().config.get('platforms', env)\n    \n    # If the specification is not found, raise an \"UndefinedEnvPlatformError\"\n    if platform is None:\n        raise UndefinedEnvPlatformError(env)\n    \n    # Create a new instance of the class with the platform specification and autoinstall option\n    p = cls(platform, autoinstall)\n    \n    # Set the project environment\n    p.set_project_env(env)\n    \n    # Configure the project packages for the given environment and targets\n    p.configure_project_packages(targets)\n    \n    # Return the configured instance\n    return p\n\n", "CodeBleu_score": 28.387328021282798}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    env = env.lower()\n    if env not in cls.get_env_names():\n        raise UndefinedEnvPlatformError(env)\n    platform_spec = cls.get_env_platform(env)\n    instance = cls(platform_spec, autoinstall)\n    instance.set_project_env(env)\n    instance.configure_project_packages(targets)\n    return instance\n\n\n\n", "CodeBleu_score": 35.849202132748026}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    \n    # get the platform specification for the environment\n    platform_spec = cls.get_platform_spec(env)\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n    \n    # create the instance\n    instance = cls(platform_spec, autoinstall)\n    \n    # set the project environment\n    instance.set_project_env(env)\n    \n    # configure the project packages for the environment and targets\n    instance.configure_project_packages(targets)\n    \n    # return the configured instance\n    return instance\n\n", "CodeBleu_score": 25.449124215064746}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(AXP192_ADDR);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(AXP192_ADDR, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 67.22479780018371}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(AXP192_ADDRESS);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(AXP192_ADDRESS, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 67.23159437117269}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(AXP192_ADDR);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(AXP192_ADDR, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 67.22479780018371}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 59.65473070364171}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us > 0) {\n    esp_sleep_enable_timer_wakeup(time_in_us);\n  } else {\n    esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n  }\n  esp_deep_sleep_start();\n}", "CodeBleu_score": 67.55475214296553}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us) {\n    esp_sleep_enable_timer_wakeup(time_in_us);\n  } else {\n    esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n  }\n  esp_deep_sleep_start();\n}", "CodeBleu_score": 57.39524297797662}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t  int prevY = scrollY;\n  int scrollHeight = tft.fontHeight();\n  int scrollWidth = tft.width();\n  int scrollStartX = 0;\n  int scrollStartY = 0;\n  int scrollEndX = scrollWidth;\n  int scrollEndY = scrollHeight;\n\n  if (scrollY >= (tft.height() - tft.fontHeight()) && !tteBar) {\n    scrollStartY = tteBarTop;\n    scrollEndY = tteBarBottom;\n  }\n  else {\n    scrollStartY = 0;\n    scrollEndY = tft.height();\n  }\n\n  tft.fillRect(scrollStartX, scrollStartY, scrollEndX, scrollEndY, color);\n\n  scrollY += scrollHeight;\n\n  if (scrollY >= (tft.height() - tft.fontHeight()) && !tteBar) {\n    scrollY = tteBarTop;\n  }\n  else if (scrollY >= (tft.height() - tft.fontHeight()) && tteBar) {\n    scrollY = tteBarTop;\n  }\n\n  tft.setScroll(0, scrollY);\n\n  return prevY;\n}", "CodeBleu_score": 30.020188055235682}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint prev_y = scroll_y;\n\tint start_y = scroll_y;\n\tint height = tft.fontHeight();\n\tint width = tft.width();\n\n\tif (tteBar) {\n\t\tstart_y = tte_y;\n\t}\n\n\tif (scroll_y + height >= tft.height() - tft.fontHeight()) {\n\t\tstart_y = tft.height() - tft.fontHeight() - tft.fontHeight();\n\t}\n\n\ttft.fillRect(0, start_y, width, height, color);\n\n\tscroll_y += height;\n\n\tif (scroll_y >= tft.height() - tft.fontHeight()) {\n\t\tscroll_y = tte_y;\n\t}\n\n\ttft.setScroll(scroll_y);\n\n\treturn prev_y;\n}", "CodeBleu_score": 26.26340782797477}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = scroll_address.y;\n  int x = scroll_address.x;\n  if (y < 0) {\n    y = 0;\n  }\n  int height = tft.fontHeight();\n  if (y > (TFT_HEIGHT - height - tteBar)) {\n    y = TFT_HEIGHT - height - tteBar;\n  }\n  tft.fillRect(x, y, TFT_WIDTH, height, color);\n  y += height;\n  if (y > (TFT_HEIGHT - height - tteBar)) {\n    y = TFT_HEIGHT - height - tteBar;\n  }\n  scroll_address.y = y;\n  return y;\n}", "CodeBleu_score": 29.492309780626623}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t    if (!setAP(access_points)) {\n        return false;\n    }\n    if (!setHtml(ssids)) {\n        return false;\n    }\n    if (!startPortal()) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 57.489332813517066}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->setAP(ssids, access_points);\n  this->setHtml();\n  return this->startPortal();\n}", "CodeBleu_score": 51.61367894878532}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tthis->setAP(access_points);\n\tthis->setHtml(ssids);\n\tif (this->startPortal()) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 57.31176626819505}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t    if (this->queue_enabled_flag) {\n        if (this->queue == NULL) {\n            this->queue = new Queue(this->queue_size);\n        }\n        if (this->text == NULL) {\n            this->text = new Text(this->queue_size);\n        }\n        if (this->text_in == NULL) {\n            this->text_in = new Text(this->queue_size);\n        }\n    } else {\n        this->flush_queue();\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 26.813395598890477}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tif (this->queue != NULL) {\n\t\t\tif (this->text != NULL) {\n\t\t\t\tif (this->text_in != NULL) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis->flush_queue();\n\tthis->queue_enabled_flag = true;\n\tthis->queue = new Queue(this->queue_size);\n\tthis->text = new Text(this->queue_size);\n\tthis->text_in = new Text(this->queue_size);\n}", "CodeBleu_score": 21.5930657192684}, {"code": "void GpsInterface::enable_queue(){\n\t    if (this->queue_enabled_flag) {\n        if (this->queue == NULL) {\n            this->queue = new Queue<GpsData>(this->queue_size);\n            this->text = new Text<GpsData>(this->queue_size);\n            this->text_in = new Text<GpsData>(this->queue_size);\n        }\n    } else {\n        this->flush_queue();\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 31.051437534189365}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue != NULL) {\n\t\tthis->new_queue = new std::queue<std::string>();\n\t\twhile (!this->queue->empty()) {\n\t\t\tthis->new_queue->push(this->queue->front());\n\t\t\tthis->queue->pop();\n\t\t}\n\t\tdelete this->queue;\n\t}\n\telse {\n\t\tthis->new_queue = new std::queue<std::string>();\n\t}\n}", "CodeBleu_score": 18.811598310963053}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue != NULL) {\n        this->new_queue = new std::queue<std::string>();\n        while (!this->queue->empty()) {\n            std::string element = this->queue->front();\n            this->new_queue->push(element);\n            this->queue->pop();\n        }\n        delete this->queue;\n        this->queue = this->new_queue;\n        this->new_queue = NULL;\n    } else {\n        this->queue = new std::queue<std::string>();\n    }\n}", "CodeBleu_score": 43.26444165496431}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue != NULL) {\n        if (this->queue->size() > 0) {\n            this->new_queue = new queue<string>();\n            this->queue->swap(*(this->new_queue));\n            delete this->queue;\n        }\n    }\n    else {\n        this->new_queue = new queue<string>();\n    }\n}", "CodeBleu_score": 26.113521246038623}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t x;\n    uint32_t y;\n\n    /*Get the X and Y coordinates of the area to flush*/\n    uint16_t x1 = area->x1;\n    uint16_t y1 = area->y1;\n    uint16_t x2 = area->x2;\n    uint16_t y2 = area->y2;\n\n    /*Start a write transaction*/\n    display_obj.tft.startWrite();\n\n    /*Set the area to write to*/\n    display_obj.tft.setAddrWindow(x1, y1, x2, y2);\n\n    /*Iterate through each pixel in the area*/\n    for (y = y1; y <= y2; y++) {\n      for (x = x1; x <= x2; x++) {\n        /*Write the color of the pixel*/\n        display_obj.tft.writeColor(color_p->full, 1);\n        /*Increment the color pointer*/\n        color_p++;\n      }\n    }\n\n    /*End the write transaction*/\n    display_obj.tft.endWrite();\n\n    /*Notify the graphics library that the flush is complete*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 58.50988195969084}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t x, y;\n    uint32_t x_act;\n    uint32_t y_act;\n    uint32_t x_end;\n    uint32_t y_end;\n    uint32_t width;\n    uint32_t height;\n    uint32_t size_flush;\n    uint32_t size_remain;\n    uint32_t size_buf;\n    uint32_t i;\n    uint32_t color_size;\n    uint8_t *color8_ptr;\n    uint16_t *color16_ptr;\n    uint32_t *color32_ptr;\n    uint8_t color_index;\n    uint8_t color_pos;\n    uint8_t color_format;\n    uint8_t color_size_log2;\n    uint8_t color_format_byte;\n    uint8_t color_format_offset;\n    uint8_t color_lsb;\n    uint8_t color_msb;\n    uint8_t color_lsb_mask;\n    uint8_t color_msb_mask;\n\n    x_act = area->x1;\n    y_act = area->y1;\n    x_end = area->x2;\n    y_end = area->y2;\n    width = area->x2 - area->x1 + 1;\n    height = area->y2 - area->y1 + 1;\n    size_flush = width * height / 2;\n    size_remain = size_flush;\n    size_buf = 32;\n    color_index = 0;\n    color_pos = 0;\n    color_format = disp->color_format;\n    color_size = lv_color_size(color_format) / 8;\n    color_size_log2 = lv_color_size(color_format);\n    color_format_byte = color_format >> (color_size_log2 - 1);\n    color_format_offset = color_format & (color_format_byte - 1);\n   ", "CodeBleu_score": 35.59962727648679}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint16_t c;\n\n    /*Serial.printf(\"flush: (%d, %d), (%d, %d)\n\", area->x1, area->y1, area->x2, area->y2);*/\n\n    /* The most common case is to refresh the entire display */\n    if(area->x1 == 0) {\n      if(area->y1 == 0) {\n        display_obj.tft.startWrite();\n        display_obj.tft.setAddrWindow(0, 0, 240, 320);\n      } else {\n        display_obj.tft.startWrite();\n        display_obj.tft.setAddrWindow(0, area->y1, 240, area->y2 - area->y1 + 1);\n      }\n    } else {\n      display_obj.tft.startWrite();\n      display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2 - area->x1 + 1, area->y2 - area->y1 + 1);\n    }\n\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        c = *color_p++;\n        display_obj.tft.writeColor(c, 1);\n      }\n    }\n    display_obj.tft.endWrite();\n\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 70.76913499081503}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  if (menu == NULL) {\n    return;\n  }\n  if (menu->getType() == MENU_TYPE_SUBMENU) {\n    for (int i = 0; i < menu->list->size(); i++) {\n      showMenuList(menu->list->get(i), layer + 1);\n    }\n  } else {\n    for (int i = 0; i < layer; i++) {\n      Serial.print(\"  \");\n    }\n    Serial.println(menu->getName());\n  }\n}", "CodeBleu_score": 57.79990375189641}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  for (int i = 0; i < menu->list->size(); i++) {\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\"  \");\n    }\n    Serial.print(menu->list->get(i)->name);\n    Serial.println();\n  }\n  Serial.println();\n}", "CodeBleu_score": 75.31157674917407}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  if (menu != NULL) {\n    for (int i = 0; i < menu->list->size; i++) {\n      MenuNode * node = menu->list->get(i);\n      for (int j = 0; j < layer; j++) {\n        Serial.print(\"  \");\n      }\n      Serial.println(node->name);\n      showMenuList(node->subMenu, layer + 1);\n    }\n  }\n}", "CodeBleu_score": 54.98330239684157}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  int generated = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = generateSSID();\n    if (ssid != \"\") {\n      generated++;\n      ssids->add(ssid);\n      Serial.println(ssid);\n    }\n  }\n  return generated;\n}", "CodeBleu_score": 29.783650623707402}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tif (count <= 0) {\n\t\treturn 0;\n\t}\n\n\tint generated = 0;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tchar ssid[7];\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tssid[i] = random(0, 256);\n\t\t}\n\t\tssid[6] = '\\0';\n\n\t\tint channel = random(1, 14);\n\t\tString mac = generateMAC();\n\n\t\tString essid = ssid;\n\t\tessid.concat(mac);\n\t\tessid.concat(String(channel));\n\n\t\tSerial.println(essid);\n\t\tssids->add(essid);\n\n\t\tgenerated++;\n\t}\n\n\treturn generated;\n}", "CodeBleu_score": 43.09459853607615}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    for (int i = 0; i < count; i++) {\n        String ssid = randomString(6);\n        int channel = random(1, 14);\n        String mac = randomMAC();\n        ssids->add(new SSID(ssid, channel, mac));\n        Serial.println(ssid + \" on channel \" + String(channel) + \" with MAC \" + mac);\n    }\n    return count;\n}", "CodeBleu_score": 39.16157273177389}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n\n    # project_id = \"Your Google Cloud project ID\"\n    # topic_name = \"Your Pub/Sub topic name\"\n\n    publisher_client = pubsub_v1.PublisherClient()\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n    topic = publisher_client.create_topic(topic_path)\n\n    print(\"Topic created: {}\".format(topic))\n\n    # [END pubsub_create_topic]\n\n", "CodeBleu_score": 40.1461362454062}, {"code": "def create_topic(project_id, topic_name)\n\t\n    # [START pubsub_create_topic]\n    from google.cloud import pubsub_v1\n\n    # TODO project_id = \"Your Google Cloud project ID\"\n    # TODO topic_name = \"Your Pub/Sub topic name\"\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print(\"Topic created: {}\".format(topic))\n    # [END pubsub_create_topic]\n\n", "CodeBleu_score": 84.76902520791279}, {"code": "def create_topic(project_id, topic_name)\n\t\n\n    # Instantiates a client\n    publisher_client = pubsub_v1.PublisherClient()\n\n    # The `topic_path` method creates a fully qualified identifier\n    # in the form `projects/{project_id}/topics/{topic_name}`\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n\n    # Creates the topic\n    topic = publisher_client.create_topic(request={\"name\": topic_path})\n\n    # Prints the new topic name and its fully qualified identifier\n    print(f\"Topic created: {topic.name}\")\n    print(f\"Topic path: {topic.name}\")\n\n", "CodeBleu_score": 39.11845780747832}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    iat = datetime.datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode({'iat': iat, 'exp': exp, 'aud': project_id}, private_key, algorithm)\n\n", "CodeBleu_score": 37.598372796354326}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    iat = datetime.datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode({'iat': iat, 'exp': exp, 'aud': project_id}, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 39.11157016160666}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n\n    # The algorithm used to sign the token.\n    # See https://developers.google.com/identity/protocols/OAuth2ServiceAccount#jwt-auth\n    # for a list of supported algorithms.\n    algorithm = algorithm\n\n    # The audience field should always be set to the GCP project id.\n    audience = project_id\n\n    # Put all the claims together into a single dictionary.\n    claims = {\n        'iss': 'service-account@gcp-project-id.iam.gserviceaccount.com',\n        'sub': 'service-account@gcp-project-id.iam.gserviceaccount.com',\n        'aud': audience,\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create a JWT using the claims and private key.\n    return jwt.encode(claims, private_key, algorithm)\n\n", "CodeBleu_score": 51.89070767852439}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(f\"Received message with topic {message.topic} and payload {message.payload}\")\n    payload = message.payload.decode()\n    if payload == \"on\":\n        print(\"Capturing preview image...\")\n        preview_capture()\n        print(\"Uploading file...\")\n        upload_file()\n        print(\"Publishing file URL to MQTT event topic...\")\n        publish()\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 24.384053318729592}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message: \" + str(message.payload))\n    print(\"  topic: \" + message.topic)\n    print(\"  qos: \" + str(message.qos))\n    if message.payload == b\"on\":\n        print(\"  preview_capture\")\n        preview_capture()\n        print(\"  upload_file\")\n        upload_file()\n        print(\"  publish\")\n        publish()\n    elif message.payload == b\"off\":\n        print(\"  off\")\n\n", "CodeBleu_score": 24.482392439834225}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message: \" + payload)\n    print(\"from topic: \" + message.topic)\n    print(\"with QoS: \" + str(message.qos))\n    if payload == \"on\":\n        preview_capture()\n        upload_file()\n        publish()\n    elif payload == \"off\":\n        print(\"off\")\n    else:\n        print(\"unknown payload\")\n\n", "CodeBleu_score": 24.847719381816763}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT example.')\n    parser.add_argument('--project_id', help='GCP cloud project name.')\n    parser.add_argument('--registry_id', help='Cloud IoT Core registry ID.')\n    parser.add_argument('--device_id', help='Cloud IoT Core device ID.')\n    parser.add_argument('--private_key_file', help='Path to private key file.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region.')\n    parser.add_argument('--ca_certs', default='roots.pem', help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--message_type', choices=('event', 'state'), default='event', help='Indicates whether the message to publish is a telemetry event or a device state message.')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', choices=(8883, 443), default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--jwt_refresh_minutes', default=15, type=int, help='Refresh threshold, in minutes, for JWT tokens.')\n    parser.add_argument('--grpc_max_reconnect_backoff_ms', default=300000, type=int, help='Maximum back-off duration for MQTT connection retries.')\n    parser.add_argument('--message_count', default=1", "CodeBleu_score": 33.376572584513454}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT device connection information.')\n    parser.add_argument('--project_id', help='GCP cloud project name.', required=False)\n    parser.add_argument('--registry_id', help='Cloud IoT Core registry id.', required=True)\n    parser.add_argument('--device_id', help='Cloud IoT Core device id.', required=True)\n    parser.add_argument('--private_key_file', help='Path to private key file.', required=True)\n    parser.add_argument('--algorithm', help='Encryption algorithm to use to generate the JWT.', default='RS256')\n    parser.add_argument('--cloud_region', help='GCP cloud region.', default='us-central1')\n    parser.add_argument('--ca_certs', help='CA root certificate.', default='roots.pem')\n    parser.add_argument('--num_messages', help='Number of messages to publish.', default=10)\n    parser.add_argument('--message_type', help='Type of message to publish.', choices=['event', 'state'], default='event')\n    parser.add_argument('--mqtt_bridge_hostname', help='MQTT bridge hostname.', default='mqtt.googleapis.com')\n    parser.add_argument('--mqtt_bridge_port', help='MQTT bridge port.', default=8883)\n    parser.add_argument('--jwt_expires_minutes', help='Expiration time, in minutes, for JWT tokens.', default=20)\n    parser.add_argument('--jwt_refresh_seconds', help='Interval, in seconds, for refreshing JWT tokens.', default=1500)\n    parser.add_argument('--device_private_key', help='Path to private key file.', required=True)\n    parser.add_argument('--device_public_key', help='Path to public key file.', required=True)\n    parser.add_argument('--device_certificate', help='Path to certificate file.', required=True)\n    parser.", "CodeBleu_score": 29.111462804032318}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter\n    )\n    parser.add_argument(\n        \"--project_id\",\n        help=\"Google Cloud project ID\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n    )\n    parser.add_argument(\"--registry_id\", help=\"Cloud IoT Core registry ID\", required=True)\n    parser.add_argument(\"--device_id\", help=\"Cloud IoT Core device ID\", required=True)\n    parser.add_argument(\n        \"--private_key_file\", help=\"Path to private key file.\", required=True\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        help=\"Encryption algorithm to use to generate the JWT.\",\n        default=\"RS256\",\n    )\n    parser.add_argument(\n        \"--cloud_region\", help=\"GCP cloud region\", default=\"us-central1\"\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        help=\"CA root certificate.\",\n        default=os.path.join(os.path.dirname(__file__), \"roots.pem\"),\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        help=\"Number of messages to publish.\",\n        default=10,\n    )\n    parser.add_argument(\n        \"--message_type\",\n        help=\"Type of message to publish. Either 'event' or 'state'.\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        help=\"MQTT bridge hostname.\",\n        default=\"mqtt.googleapis.com\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\", help=\"MQTT bridge port.\", default=8883\n    )\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        help=\"Expiration time, in minutes, for JWT tokens.\",\n        default=20,\n    )\n", "CodeBleu_score": 34.991403507715624}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=SCOPES)\n    credentials = credentials.with_scopes(SCOPES)\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n    return discovery.build('cloudiot', 'v1', credentials=credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 17.733793930322218}, {"code": "def get_client(service_account_json)\n\t\n\n    # Set up the API scopes\n    SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Set up the API version\n    VERSION = 'v1'\n\n    # Set up the discovery URL\n    DISCOVERY_URL = ('https://cloudiot.googleapis.com/$discovery/rest'\n                     '/{}/{}')\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n\n    # Scopes the credentials appropriately\n    credentials = credentials.with_scopes(SCOPES)\n\n    # Build and return the client for the Cloud IoT Core service using the\n    # discovery API URL\n    return discovery.build(\n        'cloudiot', VERSION, credentials=credentials,\n        discoveryServiceUrl=DISCOVERY_URL)\n\n", "CodeBleu_score": 37.95455695225567}, {"code": "def get_client(service_account_json)\n\t\n    # Set the API scopes\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Set the API version\n    version = 'v1'\n\n    # Set the discovery URL\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n\n    # Scope the credentials\n    scoped_credentials = credentials.with_scopes(scopes)\n\n    # Build the client\n    client = discovery.build('cloudiot', version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n\n    # Return the client\n    return client\n\n", "CodeBleu_score": 22.711307409991342}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    hash_code = hash_method_to_asn1(hash_method)\n    if hash_code == -1:\n        raise ValueError(\"Invalid hash method.\")\n    hash_value = common.byte_size(hash_value)\n    hash_value = _pad_for_signing(hash_value)\n    hash_value = hash_code + hash_value\n    signature = priv_key.blinded_encrypt(hash_value)\n    return signature\n\n", "CodeBleu_score": 30.430447212916622}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_code = hash_method_to_asn1(hash_method)\n    if hash_code is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_code = asn1_to_bytes(hash_code)\n    hash_value = asn1_to_bytes(hash_value)\n    hash_value = _pad_for_signing(hash_value)\n    signature = priv_key.blinded_encrypt(hash_code + hash_value)\n    return signature\n\n", "CodeBleu_score": 26.525924494709773}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_code = _get_hash_code(hash_method)\n    if hash_code is None:\n        raise ValueError(\"Invalid hash method.\")\n    hash_value = _pad_for_signing(hash_value)\n    hash_value = hash_code + hash_value\n    signature = priv_key.blinded_encrypt(hash_value)\n    return signature\n\n", "CodeBleu_score": 27.688759375055916}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    # Check the message is a string\n    if not isinstance(message, str):\n        raise TypeError(\"message must be a string\")\n    # Check the signature is a string\n    if not isinstance(signature, str):\n        raise TypeError(\"signature must be a string\")\n    # Check the public key is a string\n    if not isinstance(pub_key, str):\n        raise TypeError(\"pub_key must be a string\")\n    # Check the message is not empty\n    if message == \"\":\n        raise ValueError(\"message must not be empty\")\n    # Check the signature is not empty\n    if signature == \"\":\n        raise ValueError(\"signature must not be empty\")\n    # Check the public key is not empty\n    if pub_key == \"\":\n        raise ValueError(\"pub_key must not be empty\")\n    # Check the signature is a valid base64 string\n    try:\n        signature = base64.b64decode(signature)\n    except:\n        raise ValueError(\"signature must be a valid base64 string\")\n    # Check the public key is a valid base64 string\n    try:\n        pub_key = base64.b64decode(pub_key)\n    except:\n        raise ValueError(\"pub_key must be a valid base64 string\")\n    # Check the signature is a valid hex string\n    try:\n        signature = bytes.fromhex(signature.hex())\n    except:\n        raise ValueError(\"signature must be a valid hex string\")\n    # Check the public key is a valid hex string\n    try:\n        pub_key = bytes.fromhex(pub_key.hex())\n    except:\n        raise ValueError(\"pub_key must be a valid hex string\")\n    # Check the signature is a valid byte string\n    try:\n        signature = bytes(signature)\n    except:\n        raise ValueError(\"signature must be a valid byte string\")\n    # Check the public key is a valid byte string\n    try:\n        pub_key = bytes(pub_key)\n    except:\n        raise ValueError(\"pub_key must be a valid byte string\")\n    # Check the signature is a valid integer\n    try:\n        signature", "CodeBleu_score": 27.835591573513195}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Convert signature to integer\n    signature_int = transform.bytes2int(signature)\n\n    # Decrypt signature\n    signature_clear = common.byte_size(pub_key.n) - common.byte_size(signature_int)\n    signature_clear = pub_key.decrypt_int(signature_int, signature_clear)\n\n    # Compute hash\n    hash_method = _find_method_hash(signature_clear)\n    hash_message = _compute_hash(message, hash_method)\n\n    # Check if the expected padded hash matches the clear signature\n    if signature_clear != hash_message:\n        raise VerificationError(\"Invalid signature\")\n\n    return hash_method\n\n", "CodeBleu_score": 19.29958649934756}, {"code": "def verify(message, signature, pub_key)\n\t\n    signature = int(signature)\n    pub_key = int(pub_key)\n    hash_method = _find_method_hash(signature)\n    message_hash = compute_hash(message, hash_method)\n    message_hash = transform.bytes2int(message_hash)\n    clear_signature = common.decrypt_int(signature, pub_key)\n    clear_signature = transform.int2bytes(clear_signature)\n    clear_signature = _pad_for_signing(clear_signature)\n    clear_signature = transform.bytes2int(clear_signature)\n    if clear_signature != message_hash:\n        raise VerificationError(\"The signature is invalid.\")\n    return hash_method\n\n", "CodeBleu_score": 25.06811885592044}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t  time_t now = time(NULL);\n  if (now < 2147483647) {\n    updateJWT(now);\n  }\n  if (MQTT_CLIENT_connect()) {\n    sendMQTTSubscribe = true;\n  }\n  debug_print(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 30.633495887096846}, {"code": "static void connectMQTT(){\n\t  debug_print(\"Connecting to MQTT broker...\");\n  time_t now = time(NULL);\n  if (now > 1500000000) {\n    updateJWT(now);\n  }\n  MQTT_CLIENT_connect();\n  MQTT_CLIENT_subscribed = true;\n  debug_print(\"Done.\");\n}", "CodeBleu_score": 56.41064591255547}, {"code": "static void connectMQTT(){\n\t  time_t now = time(NULL);\n  if (now > 1516230400) {\n    updateJWT();\n  }\n  MQTT_CLIENT_connect();\n  sendMQTT_SUBSCRIBE = true;\n  debug_print(\"MQTT: Connecting to MQTT server...\");\n}", "CodeBleu_score": 30.645674669999174}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        value = value * 10 + (str[i] - '0');\n    }\n    *num = value;\n    return str + width;\n}", "CodeBleu_score": 27.015820681168133}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t c = *str++;\n        if (c >= '0' && c <= '9') {\n            value *= 10;\n            value += c - '0';\n        } else {\n            return str;\n        }\n    }\n    *num = value;\n    return str;\n}", "CodeBleu_score": 25.356622625337245}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\t*num = 0;\n\tfor (int i = 0; i < width; i++) {\n\t\tuint8_t c = str[i];\n\t\tif (c < '0' || c > '9')\n\t\t\treturn str;\n\t\t*num = *num * 10 + c - '0';\n\t}\n\treturn str + width;\n}", "CodeBleu_score": 22.118477962123045}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tsize_t cert_size = 0;\n\tuint8_t* cert_ptr = NULL;\n\n\tif (!build_state) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tif (build_state->cert_def->cert_template_size > 0) {\n\t\tcert_size = build_state->cert_def->cert_template_size;\n\t\tcert_ptr = build_state->cert_def->cert_template;\n\t}\n\telse {\n\t\tcert_size = build_state->cert_def->cert_elements_size;\n\t\tcert_ptr = build_state->cert_def->cert_elements;\n\t}\n\n\t// If there is a template, we need to add the template size to the cert size\n\tif (cert_size > 0) {\n\t\tcert_size += build_state->cert_def->cert_template_size;\n\t}\n\n\t// If there is a template, we need to add the template size to the cert size\n\tif (build_state->cert_def->cert_elements_size > 0) {\n\t\tcert_size += build_state->cert_def->cert_elements_size;\n\t}\n\n\t// Allocate memory for the cert\n\tbuild_state->cert = malloc(cert_size);\n\tif (!build_state->cert) {\n\t\treturn ATCACERT_E_MEMORY;\n\t}\n\n\t// Copy the template\n\tmemcpy(build_state->cert, cert_ptr, build_state->cert_def->cert_template_size);\n\tcert_ptr += build_state->cert_def->cert_template_size;\n\n\t// Copy the elements\n\tmemcpy(build_state->cert + build_state->cert_def->cert_template_size, cert_ptr, build_state->cert_def->cert_elements_size);\n\tcert_ptr += build_state->cert_def->cert_elements_size;\n\n\t// Set the size of the cert\n\tbuild_state->cert_size = cert_size;\n\n\treturn ret;\n}", "CodeBleu_score": 46.190800986287464}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\n\tif (!build_state || !build_state->cert_def || !build_state->cert_def->cert_template || !build_state->cert_def->cert_template->cert_sn_source || !build_state->cert_def->cert_template->cert_sn_source->sn_format) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tif (build_state->cert_def->cert_template->cert_sn_source->sn_format->sn_format_type != ATCACERT_SN_FORMAT_TYPE_CERT_SN) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tif (!build_state->cert_def->cert_template->cert_sn_source->sn_format->sn_format_params || !build_state->cert_def->cert_template->cert_sn_source->sn_format->sn_format_params->cert_sn_params) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tif (!build_state->cert_def->cert_template->cert_sn_source->sn_format->sn_format_params->cert_sn_params->cert_sn_dec_cb) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tret = build_state->cert_def->cert_template->cert_sn_source->sn_format->sn_format_params->cert_sn_params->cert_sn_dec_cb(build_state->cert_def->cert_template->cert_sn_source->sn_format->sn_format_params->cert_sn_params->sn_format_params, build_state->cert_sn, build_state->cert_def->cert_template->cert_sn_source->sn_format->sn_format_params->cert_sn_params->sn_format_params_size);\n\tif (ret != ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 48.95877226086386}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tint ret2 = 0;\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint l = 0;\n\tint m = 0;\n\tint n = 0;\n\tint o = 0;\n\tint p = 0;\n\tint q = 0;\n\tint r = 0;\n\tint s = 0;\n\tint t = 0;\n\tint u = 0;\n\tint v = 0;\n\tint w = 0;\n\tint x = 0;\n\tint y = 0;\n\tint z = 0;\n\tint aa = 0;\n\tint ab = 0;\n\tint ac = 0;\n\tint ad = 0;\n\tint ae = 0;\n\tint af = 0;\n\tint ag = 0;\n\tint ah = 0;\n\tint ai = 0;\n\tint aj = 0;\n\tint ak = 0;\n\tint al = 0;\n\tint am = 0;\n\tint an = 0;\n\tint ao = 0;\n\tint ap = 0;\n\tint aq = 0;\n\tint ar = 0;\n\tint as = 0;\n\tint at = 0;\n\tint au = 0;\n\tint av = 0;\n\tint aw = 0;\n\tint ax = 0;\n\tint ay = 0;\n\tint az = 0;\n\tint aA = 0;\n\tint aB = 0;\n\tint aC = 0;\n\tint aD = 0;\n\tint aE = 0;\n\tint aF = 0;\n\tint aG = 0;\n\tint aH = 0;\n\tint aI = 0;\n\tint aJ = 0;\n\tint aK = 0;\n\tint aL = 0;\n\tint aM = 0;\n\tint aN = 0;\n\tint aO = 0;\n\tint aP = ", "CodeBleu_score": 7.848413775506685}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int                     ret = 0;\n    atcacert_cert_element_t cert_elements[ATCACERT_MAX_CERT_ELEMENTS];\n    size_t                  cert_elements_count = 0;\n    uint8_t                 tbs_digest[32];\n    uint8_t                 signature[64];\n    size_t                  signature_size = 0;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the TBS digest and signature\n    ret = atcacert_get_signature(cert_def, cert, cert_size, cert_elements, &cert_elements_count, tbs_digest, signature, &signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the TBS digest against the signature\n    ret = atcab_verify_extern(tbs_digest, signature, signature_size, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 72.47747781505069}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (cert_size < cert_def->tbs_cert_min_size || cert_size > cert_def->tbs_cert_max_size) {\n        return ATCACERT_E_INVALID_SIZE;\n    }\n\n    // Get the TBS digest and signature\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the TBS digest against the signature\n    return atcab_verify_extern(tbs_digest, signature, ca_public_key);\n}", "CodeBleu_score": 76.16611992698851}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = 0;\n\n    // Check for null pointers\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Check for valid certificate\n    ret = atcacert_check_cert(cert_def, cert, cert_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the TBS digest and signature\n    ret = atcacert_get_signature(cert_def, cert, cert_size, ca_public_key, &cert_def->tbs_digest, &cert_def->signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the TBS digest against the signature\n    ret = atcab_verify_extern(cert_def->signature_mode, cert_def->tbs_digest, cert_def->signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 73.88894876263427}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if(list == NULL) {\n        return false;\n    }\n    timerStruct_t * volatile *head = list;\n    if(*head == NULL) {\n        return false;\n    }\n    if(*head == timer) {\n        *head = (*head)->next;\n        return true;\n    }\n    timerStruct_t * volatile *prev = head;\n    while(*prev != NULL && *prev != timer) {\n        prev = &(*prev)->next;\n    }\n    if(*prev == NULL) {\n        return false;\n    }\n    *prev = (*prev)->next;\n    return true;\n}", "CodeBleu_score": 30.86927007851179}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *currentTimer = list;\n    timerStruct_t * volatile *previousTimer = list;\n    timerStruct_t * volatile *nextTimer = NULL;\n\n    while (*currentTimer != NULL) {\n        nextTimer = &((*currentTimer)->next);\n        if (*currentTimer == timer) {\n            *previousTimer = *nextTimer;\n            free(timer);\n            return true;\n        }\n        previousTimer = currentTimer;\n        currentTimer = nextTimer;\n    }\n    return false;\n}", "CodeBleu_score": 34.337107182493554}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *list_ptr;\n    timerStruct_t * volatile *next_ptr;\n    timerStruct_t * volatile *prev_ptr;\n    bool ret = false;\n    if (list == NULL || timer == NULL) {\n        return false;\n    }\n    list_ptr = list;\n    while (*list_ptr != NULL) {\n        next_ptr = &(*list_ptr)->next;\n        if (*next_ptr == NULL) {\n            break;\n        }\n        if (*next_ptr == timer) {\n            *list_ptr = *next_ptr;\n            *next_ptr = NULL;\n            ret = true;\n            break;\n        }\n        prev_ptr = list_ptr;\n        list_ptr = next_ptr;\n    }\n    return ret;\n}", "CodeBleu_score": 42.83930569236396}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tstruct socketInfo *socketInfo;\n\tint closeReturnValue;\n\t\n\t/*\n\t * Get the socket information.\n\t */\n\tsocketInfo = getSocketInfo(socket);\n\tif(socketInfo == NULL) {\n\t\t/*\n\t\t * The socket doesn't exist.\n\t\t */\n\t\tbsd_setErrNo(EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\t/*\n\t * Close the socket.\n\t */\n\tcloseReturnValue = close(socketInfo->socket);\n\tif(closeReturnValue == -1) {\n\t\t/*\n\t\t * An error occurred.\n\t\t */\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\t/*\n\t * The socket was closed successfully.\n\t */\n\tsocketInfo->state = NOT_A_SOCKET;\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 30.496594350994467}, {"code": "int BSD_close(int socket){\n\t\tstruct socketInfo *socketInfo;\n\tint returnValue;\n\t\n\t\n\t/*\n\t * Retrieve the socket information and set its state to \"NOT_A_SOCKET\".\n\t */\n\tsocketInfo = getSocketInfo(socket);\n\tif(socketInfo == NULL) {\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tsocketInfo->state = NOT_A_SOCKET;\n\t\n\t\n\t/*\n\t * Call the close function and check the return value for errors.\n\t */\n\treturnValue = close(socket);\n\tif(returnValue == -1) {\n\t\tbsd_setErrNo();\n\t\treturn BSD_ERROR;\n\t}\n\t\n\t\n\t/*\n\t * If no error occurred, return \"BSD_SUCCESS\".\n\t */\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 27.881856614402967}, {"code": "int BSD_close(int socket){\n\t    int retVal;\n    struct SocketInfo *socketInfo;\n\n    if (socket < 0 || socket >= MAX_SOCKETS) {\n        bsd_setErrNo(EBADF);\n        return BSD_ERROR;\n    }\n\n    socketInfo = &socketInfoArray[socket];\n\n    if (socketInfo->state == NOT_A_SOCKET) {\n        bsd_setErrNo(EBADF);\n        return BSD_ERROR;\n    }\n\n    retVal = close(socket);\n\n    if (retVal < 0) {\n        bsd_setErrNo(errno);\n        return BSD_ERROR;\n    }\n\n    socketInfo->state = NOT_A_SOCKET;\n\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 44.419333371481926}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret;\n\n\tret = listen(socket, backlog);\n\tif (ret == -1) {\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 23.5435796662251}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint result;\n\t\n\tresult = listen(socket, backlog);\n\t\n\tif (result == -1) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK:\n\t\t\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbsd_setErrNo(BSD_UNKNOWN);\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn BSD_ERROR;\n\t}\n\t\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 47.51974034700313}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret;\n\t\n\tret = listen(socket, backlog);\n\tif (ret == -1) {\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 23.5435796662251}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    struct sockaddr_storage ss;\n    socklen_t sslen = sizeof(ss);\n    int rc;\n    int err;\n    int family;\n\n    if (addr == NULL) {\n        errno = EFAULT;\n        return -1;\n    }\n\n    rc = accept(socket, (struct sockaddr *)&ss, &sslen);\n    if (rc < 0) {\n        err = errno;\n        errno = 0;\n        switch (err) {\n        case EFAULT:\n            errno = EFAULT;\n            return -1;\n        case EINTR:\n            errno = EINTR;\n            return -1;\n        case EBADF:\n            errno = EBADF;\n            return -1;\n        case EAGAIN:\n            errno = EAGAIN;\n            return -1;\n        case EINVAL:\n            errno = EINVAL;\n            return -1;\n        case EMFILE:\n            errno = EMFILE;\n            return -1;\n        case ENFILE:\n            errno = ENFILE;\n            return -1;\n        case EWOULDBLOCK:\n            errno = EWOULDBLOCK;\n            return -1;\n        case ECONNABORTED:\n            errno = ECONNABORTED;\n            return -1;\n        case EPROTO:\n            errno = EPROTO;\n            return -1;\n        case EOPNOTSUPP:\n            errno = EOPNOTSUPP;\n            return -1;\n        case ENOBUFS:\n            errno = ENOBUFS;\n            return -1;\n        case ENOMEM:\n            errno = ENOMEM;\n            return -1;\n        case EACCES:\n            errno = EACCES;\n            return -1;\n        case ENOTSOCK:\n            errno = ENOTSOCK;\n            return -1;\n        case EOPNOTSUPP:\n            errno = EOPNOTSUPP;\n            return -1;\n        case EFAULT:\n            errno =", "CodeBleu_score": 33.25697428255323}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret;\n\tstruct sockaddr_in *addr_in;\n\n\tif (addr->sa_family != AF_INET) {\n\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\n\taddr_in = (struct sockaddr_in *)addr;\n\n\tret = accept(socket, (struct sockaddr *)addr_in, addrlen);\n\tif (ret == -1) {\n\t\tbsd_setErrNo(errno);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 27.535592413422354}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint new_socket;\n\tstruct sockaddr_in addr_in;\n\tsocklen_t addr_len = sizeof(addr_in);\n\n\tif (addr->sa_family != AF_INET) {\n\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\n\tnew_socket = accept(socket, (struct sockaddr *) &addr_in, &addr_len);\n\tif (new_socket < 0) {\n\t\tbsd_setErrNo(errno);\n\t\treturn -1;\n\t}\n\n\taddr->sa_family = AF_INET;\n\taddr->sa_data[0] = addr_in.sin_family;\n\taddr->sa_data[1] = addr_in.sin_port;\n\taddr->sa_data[2] = addr_in.sin_addr.s_addr;\n\n\t*addrlen = sizeof(addr_in);\n\n\treturn new_socket;\n}", "CodeBleu_score": 37.865701654782754}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t    time_t now = time(NULL);\n    if (now > 1516230400) { // Check if time is valid\n        updateJWT(now);\n        MQTT_CLIENT_connect(MQTT_CLIENT_ID, MQTT_CLIENT_USERNAME, MQTT_CLIENT_PASSWORD, MQTT_CLIENT_KEEPALIVE);\n        debug_print(\"Connecting to MQTT broker...\");\n        mqtt_subscribe_flag = true;\n    } else {\n        debug_print(\"Invalid time\");\n    }\n}", "CodeBleu_score": 50.48969797067713}, {"code": "static void connectMQTT(){\n\t  time_t now = time(NULL);\n  if (now < 1539681200) {\n    debug_print(\"Invalid time\");\n    return;\n  }\n  updateJWT(now);\n  debug_print(\"Connecting to MQTT broker\");\n  MQTT_CLIENT_connect();\n  MQTT_CLIENT_subscribe(MQTT_TOPIC_COMMAND);\n}", "CodeBleu_score": 53.46679179988342}, {"code": "static void connectMQTT(){\n\t    int8_t rc;\n    time_t now;\n    now = time(NULL);\n    if (now > 1510000000) {\n        updateJWT(now);\n        rc = MQTT_CLIENT_connect();\n        if (rc == MQTT_CONNECTION_ACCEPTED) {\n            debug_print(\"MQTT: Connection accepted.\");\n            mqtt_subscribed = 0;\n        } else {\n            debug_print(\"MQTT: Connection refused.\");\n        }\n    } else {\n        debug_print(\"MQTT: Time invalid.\");\n    }\n}", "CodeBleu_score": 48.37059921241398}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t    MQTT_GetClientConnectionInfo(&clientConnectionInfo);\n    MQTT_Disconnect();\n    debug_printError(\"Disconnected from cloud service\");\n}", "CodeBleu_score": 28.54135899868219}, {"code": "void CLOUD_disconnect(void){\n\t\t// Disconnect from the cloud service\n\tMQTT_Disconnect();\n\t// Log a debug message indicating the disconnection\n\tdebug_printError(\"Disconnected from the cloud service\n\");\n}", "CodeBleu_score": 19.14756012590362}, {"code": "void CLOUD_disconnect(void){\n\t    CLOUD_LOG(\"Disconnecting from the cloud...\n\");\n    MQTT_GetClientConnectionInfo(&clientInfo);\n    MQTT_Disconnect();\n    CLOUD_LOG(\"Disconnected from the cloud.\n\");\n}", "CodeBleu_score": 51.473639912386005}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiInitParam param;\n\tint8_t ret;\n\tuint8_t conn_state;\n\t\n\t/* Initialize the BG96 module */\n\tif (M2M_SUCCESS != m2m_wifi_init(&param)) {\n\t\tdebug_printError(\"BG96 Wi-Fi initialization failed", "CodeBleu_score": 4.76033133650458}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiInitParam param;\n\tint8_t ret;\n\tuint8_t wifi_status;\n\tuint8_t wifi_connect_status;\n\tuint8_t wifi_retry_counter = 0;\n\n\tif (passed_wifi_creds == M2M_WIFI_CONNECT_DEFAULT) {\n\t\t/*\n\t\t * Connect to the default AP.\n\t\t */\n\t\twhile (1) {\n\t\t\t/*\n\t\t\t * Initialize the WINC1500 with the MAC address provided in the\n\t\t\t * project's config.h file.\n\t\t\t */\n\t\t\tparam.au8MacAddr[0] = MAC_0;\n\t\t\tparam.au8MacAddr[1] = MAC_1;\n\t\t\tparam.au8MacAddr[2] = MAC_2;\n\t\t\tparam.au8MacAddr[3] = MAC_3;\n\t\t\tparam.au8MacAddr[4] = MAC_4;\n\t\t\tparam.au8MacAddr[5] = MAC_5;\n\n\t\t\t/*\n\t\t\t * Initialize the WINC1500 with the SSID and password provided in\n\t\t\t * the project's config.h file.\n\t\t\t */\n\t\t\tparam.au8SSID[0] = DEFAULT_SSID[0];\n\t\t\tparam.au8SSID[1] = DEFAULT_SSID[1];\n\t\t\tparam.au8SSID[2] = DEFAULT_SSID[2];\n\t\t\tparam.au8SSID[3] = DEFAULT_SSID[3];\n\t\t\tparam.au8SSID[4] = DEFAULT_SSID[4];\n\t\t\tparam.au8SSID[5] = DEFAULT_SSID[5];\n\t\t\tparam.au8SSID[6] = DEFAULT_SSID[6];\n\t\t\tparam.au8SSID[7] = DEFAULT_SSID[7];\n\n\t\t\tparam.u8SecType = DEFAULT_AUTH_TYPE;\n\n\t\t\tparam.au", "CodeBleu_score": 34.09484890034169}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\t// If new credentials are passed, attempt to connect using those.\n\tif (passed_wifi_creds == 1) {\n\t\t// Connect to the access point using the specified SSID, authentication type, and password.\n\t\tif (m2m_wifi_connect(wifi_ssid, strlen(wifi_ssid), wifi_auth, wifi_key, strlen(wifi_key)) != M2M_SUCCESS) {\n\t\t\t// If the connection fails, log an error message.\n\t\t\tdebug_printError(\"wifi_connectToAp: m2m_wifi_connect failed.\");\n\t\t\t// Update the networking error status.\n\t\t\tnetworking_error = 1;\n\t\t\t// Return false.\n\t\t\treturn false;\n\t\t}\n\t}\n\t// If default credentials are passed, attempt to connect using the default Wi-Fi settings.\n\telse if (passed_wifi_creds == 2) {\n\t\t// Connect to the access point using the default Wi-Fi settings.\n\t\tif (m2m_wifi_default_connect() != M2M_SUCCESS) {\n\t\t\t// If the connection fails, log an error message.\n\t\t\tdebug_printError(\"wifi_connectToAp: m2m_wifi_default_connect failed.\");\n\t\t\t// Update the networking error status.\n\t\t\tnetworking_error = 1;\n\t\t\t// Return false.\n\t\t\treturn false;\n\t\t}\n\t}\n\t// If no credentials are passed, log an error message and return false.\n\telse {\n\t\tdebug_printError(\"wifi_connectToAp: No Wi-Fi credentials passed.\");\n\t\t// Return false.\n\t\treturn false;\n\t}\n\t// Return true.\n\treturn true;\n}", "CodeBleu_score": 43.726492414762916}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t    // Create a GraphQL client\n    const client = createClient();\n\n    // Send a GraphQL query to retrieve sensor data\n    const response = await client.query(gql`\n        query ListSensors {\n            listSensors {\n                items {\n                    id\n                    name\n                    geo {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        }\n    `);\n\n    // Log the API response\n    console.log(response);\n\n    // If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\n    if (response.data.listSensors.items) {\n        console.log('Retrieved sensors:');\n        response.data.listSensors.items.forEach(sensor => {\n            // Create a marker\n            const marker = document.createElement('div');\n            marker.className = 'marker';\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 56.141055372507054}, {"code": "async function DisplaySensors(map){\n\t    const client = createClient();\n    const response = await client.query({\n        query: gql`\n            query {\n                listSensors {\n                    items {\n                        id\n                        name\n                        geo {\n                            latitude\n                            longitude\n                        }\n                    }\n                }\n            }\n        `\n    });\n    console.log(response.data);\n    if (response.data.listSensors.items.length > 0) {\n        console.log(\"Sensors retrieved.\");\n        response.data.listSensors.items.forEach(sensor => {\n            const marker = document.createElement(\"div\");\n            marker.className = \"marker\";\n            marker.style.backgroundImage = `url(https://s3-us-west-2.amazonaws.com/s.cdpn.io/148866/${sensor.id}.svg)`;\n            marker.style.backgroundSize = \"cover\";\n            marker.style.width = \"50px\";\n            marker.style.height = \"50px\";\n            marker.style.borderRadius = \"50%\";\n            marker.style.cursor = \"pointer\";\n            marker.addEventListener(\"click\", () => {\n                console.log(`Clicked on ${sensor.name}`);\n            });\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 48.62287159680656}, {"code": "async function DisplaySensors(map){\n\t    // Create a GraphQL client\n    const client = createClient();\n\n    // Create a GraphQL query\n    const query = gql`\n        query ListSensors {\n            listSensors {\n                items {\n                    id\n                    name\n                    geo {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        }\n    `;\n\n    // Send the query to the API\n    const response = await client.query({ query });\n\n    // Log the API response\n    console.log(response);\n\n    // If the response contains data, log the retrieval of sensors\n    if (response.data.listSensors.items) {\n        console.log(\"Successfully retrieved sensors\");\n\n        // Iterate through each sensor\n        response.data.listSensors.items.forEach(sensor => {\n            // Create a marker\n            const marker = document.createElement(\"div\");\n            marker.className = \"marker\";\n            marker.style.backgroundImage = `url('https://s3-us-west-2.amazonaws.com/s.cdpn.io/148866/${sensor.id}.svg')`;\n\n            // Create a marker and set its coordinates\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 51.76204543989105}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.backgroundColor = '#000000';\n    marker.style.border = '2px solid #000000';\n    return marker;\n}", "CodeBleu_score": 44.63633621472904}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = 'rgb(0, 160, 255)';\n  marker.style.border = '2px solid rgb(0, 160, 255)';\n  return marker;\n}", "CodeBleu_score": 45.060743857942555}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    let marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor-marker\";\n    marker.style.border = \"1px solid black\";\n    marker.style.borderRadius = \"50%\";\n    marker.style.width = \"15px\";\n    marker.style.height = \"15px\";\n    marker.style.background = sensor.color;\n    marker.style.position = \"absolute\";\n    marker.style.top = `${sensor.y}px`;\n    marker.style.left = `${sensor.x}px`;\n    return marker;\n}", "CodeBleu_score": 45.09752889423551}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"MFA module %s could not be imported. Please check your configuration.\",\n            module_name,\n        )\n        raise HomeAssistantError(err) from err\n    if hasattr(module, \"async_setup_entry\"):\n        _LOGGER.error(\n            \"MFA module %s is not a valid MFA module. Please check your configuration.\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            f\"{module_name} does not have an async_setup_entry() method\"\n        )\n    if not hasattr(module, \"PLATFORMS\"):\n        _LOGGER.error(\n            \"MFA module %s is not a valid MFA module. Please check your configuration.\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            f\"{module_name} does not have a PLATFORMS attribute\"\n        )\n    if not isinstance(module.PLATFORMS, list):\n        _LOGGER.error(\n            \"MFA module %s is not a valid MFA module. Please check your configuration.\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            f\"{module_name}.PLATFORMS is not a list\"\n        )\n    if not module.PLATFORMS:\n        _LOGGER.error(\n            \"MFA module %s is not a valid MFA module. Please check your configuration.\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            f\"{module_name}.PLATFORMS is an empty list\"\n        )\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not isinstance(module.REQUIREMENTS, list):\n            _LOGGER.error(\n                \"MFA module %s is not a valid MFA module. Please check your configuration.\",\n                module_name,\n            )\n            raise HomeAssistantError(\n                f\"{module", "CodeBleu_score": 29.46931632439832}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        mfa_module = importlib.import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Failed to import %s: %s\", module_name, err)\n        raise HomeAssistantError(f\"Failed to import {module_name}\") from err\n    if not hasattr(mfa_module, \"PLATFORMS\"):\n        _LOGGER.error(\n            \"The MFA module %s does not have a PLATFORMS constant. \"\n            \"Please check the documentation.\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            f\"The MFA module {module_name} does not have a PLATFORMS constant. \"\n            \"Please check the documentation.\"\n        )\n    if not isinstance(mfa_module.PLATFORMS, list):\n        _LOGGER.error(\n            \"The MFA module %s does not have a PLATFORMS constant that is a list. \"\n            \"Please check the documentation.\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            f\"The MFA module {module_name} does not have a PLATFORMS constant that is a list. \"\n            \"Please check the documentation.\"\n        )\n    if not hasattr(mfa_module, \"async_setup_entry\"):\n        _LOGGER.error(\n            \"The MFA module %s does not have an async_setup_entry function. \"\n            \"Please check the documentation.\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            f\"The MFA module {module_name} does not have an async_setup_entry function. \"\n            \"Please check the documentation.\"\n        )\n    if not callable(mfa_module.async_setup_entry):\n        _LOGGER.error(\n            \"The MFA module %s does not have an async_setup_entry function that is callable. \"\n            \"Please check the documentation.\",\n            module_name,\n        )\n        raise HomeAssistantError(\n            f\"The MFA module {module_name", "CodeBleu_score": 32.2769774285518}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    # Construct the module path\n    module_path = f\"homeassistant.components.{module_name}\"\n    # Attempt to import the module\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to import multi-factor authentication (MFA) module %s: %s\",\n            module_name,\n            err,\n        )\n        raise HomeAssistantError(\n            f\"Unable to import multi-factor authentication (MFA) module {module_name}\"\n        ) from err\n    # Process the module's requirements if the module has them and pip installation is not skipped\n    if hasattr(module, \"REQUIREMENTS\") and not hass.skip_pip:\n        await requirements.async_process_requirements(hass, module_name, module.REQUIREMENTS)\n    # Check if the module's requirements have already been processed to avoid redundant installations\n    processed = set()\n    if hasattr(module, \"PROCESSED_REQUIREMENTS\"):\n        processed = processed.union(module.PROCESSED_REQUIREMENTS)\n    if hasattr(module, \"REQUIREMENTS\"):\n        processed = processed.union(module.REQUIREMENTS)\n    # Return the loaded module\n    return module\n\n", "CodeBleu_score": 49.364616489067906}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\n            \"pin\": setup_data[\"pin\"],\n        }\n\n", "CodeBleu_score": 36.646874829774795}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Check if the user already has an entry in the internal data list\n    if user_id in self.data:\n        # Update the PIN\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n        return True\n    else:\n        # Add a new entry with the user ID and PIN to the data list\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n        return True\n\n", "CodeBleu_score": 37.050127123673334}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id not in self._data:\n        self._data[user_id] = setup_data\n    else:\n        self._data[user_id][\"pin\"] = setup_data[\"pin\"]\n    return self._data\n\n", "CodeBleu_score": 34.35003845106285}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._async_init_lock:\n        if self._async_loaded:\n            return\n        data = await self._async_get()\n        if not data:\n            data = {}\n        self._async_data = data\n        self._async_loaded = True\n        for user in data.get(\"items\", {}).values():\n            self._async_settings[user[\"id\"]] = NotifySetting(user)\n\n", "CodeBleu_score": 30.761907901942482}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if not self._loaded:\n            data = await self._async_get()\n            if not data:\n                self._data = {}\n            else:\n                self._data = data\n            self._loaded = True\n            self._async_populate()\n\n", "CodeBleu_score": 23.426333497312175}, {"code": "async def _async_load(self) -> None\n\t\n    if not self._initialized:\n        async with self._init_lock:\n            if not self._initialized:\n                data = await self._store.async_load()\n                if not data:\n                    self._data = {}\n                else:\n                    self._data = data\n                self._initialized = True\n                self._async_load_user_settings()\n\n", "CodeBleu_score": 30.273764156426903}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    # Ensure user settings are loaded.\n    if not await self._async_load(user_id):\n        return False\n    # Retrieve notification settings for the user.\n    settings = self._user_settings.get(user_id)\n    if not settings:\n        return False\n    # Validate the user input.\n    if not await self._async_validate(user_id, user_input, settings):\n        return False\n    return True\n\n", "CodeBleu_score": 42.515844799852076}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load(user_id)\n    settings = await self.async_get_settings(user_id)\n    if not settings:\n        return False\n    return await self._async_validate(user_id, user_input, settings)\n\n", "CodeBleu_score": 40.63810146657274}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    # Load user settings\n    if not await self._async_load(user_id):\n        return False\n    # Retrieve notification settings\n    settings = self.settings.get(user_id)\n    if not settings:\n        return False\n    # Validate user input\n    if not await self._async_validate(user_id, user_input, settings):\n        return False\n    return True\n\n", "CodeBleu_score": 41.96981445649932}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 60.28098499167264}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.390134801419954}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if not entity_entry:\n        return None\n\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if not device_entry:\n        return None\n\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 52.70688386442347}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    # Initializes the new policy dictionary and the set to track seen categories\n    merged_policy = {}\n    seen = set()\n\n    # For each policy and each category within it, if the category hasn't been seen, it adds the category to the set and merges the corresponding categories from all policies\n    for policy in policies:\n        for category in policy:\n            if category not in seen:\n                seen.add(category)\n                merged_policy[category] = merge_categories(policy[category], policies)\n\n    # The merged policy dictionary is cast to the appropriate type and returned\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 42.827333367560946}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n\n    # Initialize the merged policy dictionary and the set to track seen categories.\n    merged_policy = {}\n    seen = set()\n\n    # For each policy, merge the corresponding categories.\n    for policy in policies:\n        for category in policy:\n            if category not in seen:\n                seen.add(category)\n                merged_policy[category] = merge_categories(policy[category])\n\n    # Cast the merged policy dictionary to the appropriate type and return it.\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 40.82934738681294}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n\n    seen = set()\n    policy = {}\n    for policy_ in policies:\n        for category, category_ in policy_.items():\n            if category not in seen:\n                seen.add(category)\n                policy[category] = category_\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 33.84486158811282}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = importlib.import_module(f\"homeassistant.auth.providers.{provider}\")\n    except (ImportError, ModuleNotFoundError) as err:\n        _LOGGER.error(\n            \"Unable to import auth provider %s: %s\", provider, err, exc_info=err\n        )\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider}: {err}\"\n        ) from err\n\n    if not hasattr(module, \"async_setup_auth_provider\"):\n        return module\n\n    async def _async_process_requirements(\n        hass: HomeAssistant, module: types.ModuleType\n    ) -> types.ModuleType:\n        \"\"\"Process the requirements of a module.\"\"\"\n        if not hasattr(module, \"REQUIREMENTS\"):\n            return module\n\n        if module in requirements.processed:\n            return module\n\n        requirements.processed.add(module)\n\n        for requirement in module.REQUIREMENTS:\n            try:\n                await requirements.async_process_requirement(hass, requirement)\n            except HomeAssistantError as err:\n                _LOGGER.error(\n                    \"Unable to process requirement %s for auth provider %s: %s\",\n                    requirement,\n                    provider,\n                    err,\n                    exc_info=err,\n                )\n                raise HomeAssistantError(\n                    f\"Unable to process requirement {requirement} for auth provider {provider}: {err}\"\n                ) from err\n\n        return module\n\n    return await _async_process_requirements(hass, module)\n\n", "CodeBleu_score": 48.18288477340239}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = importlib.import_module(f\"homeassistant.auth.providers.{provider}\")\n    except (ImportError, ModuleNotFoundError) as err:\n        _LOGGER.error(\"Unable to import auth provider %s: %s\", provider, err)\n        raise HomeAssistantError(f\"Unable to import auth provider {provider}\") from err\n    if not hasattr(module, \"async_setup_auth\"):\n        _LOGGER.error(\"Auth provider %s does not have async_setup_auth\", provider)\n        raise HomeAssistantError(f\"Auth provider {provider} does not have async_setup_auth\")\n    if not hasattr(module, \"async_login_flow\"):\n        _LOGGER.error(\"Auth provider %s does not have async_login_flow\", provider)\n        raise HomeAssistantError(f\"Auth provider {provider} does not have async_login_flow\")\n    if not hasattr(module, \"async_refresh_token\"):\n        _LOGGER.error(\"Auth provider %s does not have async_refresh_token\", provider)\n        raise HomeAssistantError(f\"Auth provider {provider} does not have async_refresh_token\")\n    if not hasattr(module, \"async_revoke_token\"):\n        _LOGGER.error(\"Auth provider %s does not have async_revoke_token\", provider)\n        raise HomeAssistantError(f\"Auth provider {provider} does not have async_revoke_token\")\n    if not hasattr(module, \"async_user_meta_for_credentials\"):\n        _LOGGER.error(\n            \"Auth provider %s does not have async_user_meta_for_credentials\", provider\n        )\n        raise HomeAssistantError(\n            f\"Auth provider {provider} does not have async_user_meta_for_credentials\"\n        )\n    if not hasattr(module, \"async_user_info_for_credentials\"):\n        _LOGGER.error(\n            \"Auth provider %s does not have async_user_info_for_credentials\", provider\n        )\n        raise HomeAssistantError(\n            f\"Auth provider {provider} does not have async", "CodeBleu_score": 31.9839810700559}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        auth_provider_module = importlib.import_module(f\"homeassistant.auth.providers.{provider}\")\n    except (ImportError, ModuleNotFoundError) as err:\n        _LOGGER.error(\"Unable to import auth provider %s: %s\", provider, err)\n        raise HomeAssistantError(f\"Unable to import auth provider {provider}: {err}\") from err\n    if not hasattr(auth_provider_module, \"async_setup\"):\n        return auth_provider_module\n    requirements = getattr(auth_provider_module, \"REQUIREMENTS\", [])\n    if not requirements:\n        return auth_provider_module\n    if provider in processed.add:\n        return auth_provider_module\n    await requirements.async_process_requirements(hass)\n    processed.add(provider)\n    return auth_provider_module\n\n", "CodeBleu_score": 45.54068274247891}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self.store.load()\n    except Exception as e:\n        self.logger.error(f\"Error while loading data: {e}\")\n        data = []\n    self.users = data\n    self.async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 31.2572462604776}, {"code": "async def async_load(self) -> None\n\t\n\n    async with self._lock:\n        if self._users is None:\n            self._users = await self._store.get(self._users_key)\n            if self._users is None:\n                self._users = []\n\n        if self._not_normalized_usernames is None:\n            self._not_normalized_usernames = await self._store.get(self._not_normalized_usernames_key)\n            if self._not_normalized_usernames is None:\n                self._not_normalized_usernames = []\n\n        await self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 26.868929564743983}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        self.users = json.loads(self.store.get(self.store_key))\n    except:\n        self.users = []\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 32.72646728777207}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    # Normalize the provided username\n    username = self.normalize_username(username)\n\n    # Initialize a dummy hash to prevent timing attacks\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n\n    # Iterate through all users to find a matching username\n    for user in self.users:\n        if user.username == username:\n            # If a user is found, it decodes the stored password hash and uses bcrypt's timing-safe check to compare the provided password with the stored hash\n            if bcrypt.checkpw(password.encode(), user.password.encode()):\n                return\n            else:\n                # If the passwords do not match, it raises an \"InvalidAuth\" exception\n                raise InvalidAuth()\n\n    # If no matching user is found, it performs a dummy hash check and raises an \"InvalidAuth\" exception\n    if bcrypt.checkpw(dummy_hash, password.encode()):\n        raise InvalidAuth()\n\n", "CodeBleu_score": 35.18032074759313}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_password = password.encode()\n            if bcrypt.checkpw(stored_password, user.password_hash):\n                return\n            else:\n                raise InvalidAuth()\n    raise InvalidAuth()\n\n", "CodeBleu_score": 34.32722597191837}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_password_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(), stored_password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid username or password\")\n    bcrypt.checkpw(dummy_hash, dummy_hash)\n    raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 45.80755328527274}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for i in range(len(self.users)):\n        if self.users[i].username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 31.782433156874053}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    try:\n        self.users.remove(username)\n    except ValueError:\n        raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 23.981063199301477}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    try:\n        username = self.normalize_username(username)\n        for user in self.users:\n            if user.username == username:\n                self.users.remove(user)\n                return\n        raise InvalidUser(\"user_not_found\")\n    except InvalidUser as e:\n        raise e\n\n", "CodeBleu_score": 41.449517726259124}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.data.get(credentials.username) is None:\n        self.async_initialize()\n    if self.data.get(credentials.username) is None:\n        return\n    self.data[credentials.username].pop(credentials.auth_domain)\n    if self.data[credentials.username] == {}:\n        self.data.pop(credentials.username)\n    try:\n        await self.async_save()\n    except Exception:\n        pass\n\n", "CodeBleu_score": 52.066989455145496}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n        await self.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 40.819321855005754}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self.credentials is None:\n        await self.async_initialize()\n    if credentials.username in self.credentials:\n        del self.credentials[credentials.username]\n    try:\n        await self.async_save()\n    except InvalidAuth:\n        pass\n\n", "CodeBleu_score": 53.31319114141952}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    if log:\n        _log_thread_running_at_shutdown(threads)\n    joined = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident is not None:\n                try:\n                    thread.join(timeout=timeout)\n                except:\n                    pass\n            joined.add(thread)\n    if len(joined) < len(threads):\n        async_raise(os.getpid(), SystemExit)\n    return joined\n\n", "CodeBleu_score": 49.85802584487827}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    threads_to_join = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n        else:\n            if thread.ident is None:\n                joined.add(thread)\n            else:\n                threads_to_join.add(thread)\n    if log:\n        with suppress(Exception):\n            _log_thread_running_at_shutdown(threads_to_join)\n    for thread in threads_to_join:\n        if thread.is_alive():\n            thread.join(timeout)\n            if thread.is_alive():\n                thread.interrupt()\n                thread.join()\n                joined.add(thread)\n    try:\n        async_raise(threading.get_ident(), SystemExit)\n    except Exception:\n        pass\n    return joined\n\n", "CodeBleu_score": 43.99831361788947}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            timeout_thread = thread.ident\n            if timeout_thread is None:\n                joined.add(thread)\n            else:\n                timeout = max(timeout - time.perf_counter(), 0)\n                if timeout <= 0:\n                    if log:\n                        _log_thread_running_at_shutdown(thread)\n                    thread.interrupt()\n                    joined.add(thread)\n                else:\n                    with suppress(KeyboardInterrupt):\n                        thread.join(timeout)\n                    if thread.is_alive():\n                        thread.interrupt()\n                        joined.add(thread)\n        else:\n            joined.add(thread)\n    async_raise(threading.main_thread().ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 41.323901495832224}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    remaining_threads = [thread for thread in threading.enumerate() if thread.is_alive() and thread.name != \"MainThread\" and not thread.daemon]\n    if remaining_threads:\n        timeout = math.floor(SHUTDOWN_TIMEOUT / len(remaining_threads))\n        for thread in remaining_threads:\n            try:\n                thread.join(timeout=timeout)\n            except Exception as exception:\n                _LOGGER.warning(f\"Failed to join thread {thread.name}: {exception}\")\n\n", "CodeBleu_score": 36.636021699735}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = threading.enumerate()\n    if not threads:\n        return\n    timeout = 10\n    for thread in threads:\n        if thread is threading.main_thread():\n            continue\n        if thread.daemon:\n            continue\n        if not thread.is_alive():\n            continue\n        timeout_per_thread = timeout / len(threads)\n        try:\n            thread.join(timeout=timeout_per_thread)\n        except Exception:\n            _LOGGER.warning(\"Could not join thread %s\", thread)\n    return\n\n", "CodeBleu_score": 38.064422244962714}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [thread for thread in threading.enumerate() if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()]\n    for thread in threads:\n        try:\n            thread.join(timeout=_SHUTDOWN_TIMEOUT / len(threads))\n        except Exception:\n            _LOGGER.warning(\"Failed to join thread %s\", thread.name)\n\n", "CodeBleu_score": 35.462290164803136}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        if self._async_dispatcher_signal_sender:\n            self._async_dispatcher_signal_sender.send(\n                signal=self._async_dispatcher_signal,\n                remaining_with_setup_started=remaining_with_setup_started,\n            )\n        else:\n            self._async_dispatcher_send_internal(\n                remaining_with_setup_started=remaining_with_setup_started\n            )\n    self._async_dispatcher_remaining_with_setup_started = remaining_with_setup_started\n\n\n def _async_dispatcher_send_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal\" is a helper function for the function \"_async_dispatch\".", "CodeBleu_score": 45.59569383961111}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self._remaining_setups or remaining_with_setup_started:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_setups = remaining_with_setup_started\n\n\n def _async_dispatcher_send_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal\" sends an internal dispatcher signal with the remaining setups.\"\"\"\n    self._async_dispatcher.send(signal=self._signal_name, sender=self, remaining_with_setup_started=remaining_with_setup_started)\n\n\n def _async_dispatcher_connect_internal(self, callback: Callable[[Any, dict[str, float]], None]) -> None:\n    \"\"\"The function \"_async_dispatcher_connect_internal\" connects a callback to the internal dispatcher signal.\"\"\"\n    self._async_dispatcher.connect(callback, signal=self._signal_name, sender=self)\n\n\n def _async_dispatcher_connect_external(self, callback: Callable[[Any, dict[str, float]], None]) -> None:\n    \"\"\"The function \"_async_dispatcher_connect_external\" connects a callback to the external dispatcher signal.\"\"\"\n    self._async_dispatcher.connect(callback, signal=self._signal_name, sender=self)\n\n\n def _async_dispatcher_disconnect_internal(self, callback: Callable[[Any, dict[str, float]], None]) -> None:\n    \"\"\"The function \"_async_dispatcher_disconnect_internal\" disconnects a callback from the internal dispatcher signal.\"\"\"\n    self._async_dispatcher.disconnect(callback, signal=self._signal_name, sender=self)\n\n\n def _async_dispatcher_disconnect_external(self, callback: Callable[[Any, dict[str, float]], None]) -> None:\n    \"\"\"The function \"_async_dispatcher_disconnect_external\" disconnects a callback from the external dispatcher signal.\"\"\"\n    self._async_dispatcher.disconnect(callback, signal=self._signal_name", "CodeBleu_score": 44.074524211739664}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self._remaining_setups or remaining_with_setup_started:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_setups = remaining_with_setup_started\n\n\n def _async_dispatcher_send_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal\" sends an internal dispatcher signal with the remaining setups.\"\"\"\n    self._async_dispatcher_send(self._remaining_setups, remaining_with_setup_started)\n\n\n def _async_dispatcher_send(self, remaining_setups: dict[str, float], remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send\" sends an internal dispatcher signal with the remaining setups.\"\"\"\n    self._async_dispatcher.dispatch(\n        self._async_dispatcher_signal,\n        remaining_setups,\n        remaining_with_setup_started,\n    )\n\n\n def _async_dispatcher_connect(self, callback: Callable[[dict[str, float], dict[str, float]], None]) -> None:\n    \"\"\"The function \"_async_dispatcher_connect\" connects a callback to the internal dispatcher signal.\"\"\"\n    self._async_dispatcher.connect(callback, signal=self._async_dispatcher_signal)\n\n\n def _async_dispatcher_disconnect(self, callback: Callable[[dict[str, float], dict[str, float]], None]) -> None:\n    \"\"\"The function \"_async_dispatcher_disconnect\" disconnects a callback from the internal dispatcher signal.\"\"\"\n    self._async_dispatcher.disconnect(callback, signal=self._async_dispatcher_signal)\n\n\n def _async_dispatcher_has_listeners(self) -> bool:\n    \"\"\"The function \"_async_dispatcher_has_listeners\" checks if the internal dispatcher has listeners.\"\"\"\n    return self._async_dispatcher.has_listeners(self._async_dispatcher_signal)\n\n\n def", "CodeBleu_score": 44.131818583065844}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.cache.bluetooth.validated:\n        return\n    if config.cache.bluetooth.generated is None:\n        config.cache.bluetooth.generated = generate_bluetooth(integrations)\n    if config.cache.bluetooth.read is None:\n        config.cache.bluetooth.read = fp.read(config.cache.bluetooth.generated)\n    if config.cache.bluetooth.read == config.cache.bluetooth.generated:\n        config.cache.bluetooth.validated = True\n        return\n    config.cache.bluetooth.errors.add_error(\n        \"bluetooth.py is not up to date. Please run `hass-cli bluetooth` to update it.\"\n    )\n    config.cache.bluetooth.fix_suggestion = (\n        f\"Please run `hass-cli bluetooth` to update bluetooth.py.\"\n    )\n\n", "CodeBleu_score": 36.991052404622934}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.cache.bluetooth_content:\n        config.cache.bluetooth_content = generate_bluetooth_content(integrations)\n    if config.cache.bluetooth_content != config.bluetooth_content:\n        config.errors.add_error(\n            \"The bluetooth.py file is not up to date. Please run the integration again to fix this issue.\",\n            fix=fix_bluetooth_content(config.bluetooth_content),\n        )\n\n", "CodeBleu_score": 32.787613359092916}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.bluetooth.validate:\n        if not config.bluetooth.validate_integrations:\n            config.bluetooth.validate_integrations = list(integrations.keys())\n        if config.bluetooth.validate_integrations:\n            config.bluetooth.validate_integrations = [i for i in config.bluetooth.validate_integrations if i in integrations]\n        config.bluetooth.validate_integrations = [i for i in config.bluetooth.validate_integrations if integrations[i].bluetooth_support]\n        if config.bluetooth.validate_integrations:\n            if config.bluetooth.validate_integrations == list(integrations.keys()):\n                config.bluetooth.validate_integrations = None\n            if config.bluetooth.validate_integrations:\n                if config.bluetooth.validate_integrations == list(integrations.keys()):\n                    config.bluetooth.validate_integrations = None\n                if config.bluetooth.validate_integrations:\n                    if not config.bluetooth.validate_integrations:\n                        config.bluetooth.validate_integrations = None\n                    if not config.bluetooth.validate_integrations:\n                        config.bluetooth.validate_integrations = None\n                    if not config.bluetooth.validate_integrations:\n                        config.bluetooth.validate_integrations = None\n                    if not config.bluetooth.validate_integrations:\n                        config.bluetooth.validate_integrations = None\n                    if not config.bluetooth.validate_integrations:\n                        config.bluetooth.validate_integrations = None\n                    if not config.bluetooth.validate_integrations:\n                        config.bluetooth.validate_integrations = None\n                    if not config.bluetooth.validate_integrations:\n                        config.bluetooth.validate_integrations = None\n                    if not config.bluetooth.validate_integrations:\n                        config.bluetooth.validate_integrations = None\n                    if not config.bluetooth.validate_integrations:\n                        config.bluetooth.validate_integrations = None\n                    if not config.bluetooth.validate_integrations:\n                       ", "CodeBleu_score": 25.19062411826034}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar (\n\t\tresp = &struct {\n\t\t\tAccessToken  string `json:\"access_token\"`\n\t\t\tRefreshToken string `json:\"refresh_token\"`\n\t\t\tExpiresIn    int    `json:\"expires_in\"`\n\t\t}{}\n\t\te error\n\t)\n\n\tif err := d.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.TokenURL); err != nil {\n\t\treturn err\n\t}\n\n\tif e != nil {\n\t\tlogger.Info(\"Failed to refresh token\",\n\t\t\tzap.Error(e),\n\t\t\tzap.String(\"response\", resp.String()))\n\t\treturn e\n\t}\n\n\td.AccessToken = resp.AccessToken\n\td.RefreshToken = resp.RefreshToken\n\td.ExpiresIn = resp.ExpiresIn\n\td.ExpiresAt = time.Now().Unix() + int64(resp.ExpiresIn)\n\n\tlogger.Info(\"Refreshed token\",\n\t\tzap.String(\"access_token\", d.AccessToken),\n\t\tzap.String(\"refresh_token\", d.RefreshToken),\n\t\tzap.Int64(\"expires_in\", d.ExpiresIn),\n\t\tzap.Int64(\"expires_at\", d.ExpiresAt))\n\n\treturn nil\n}", "CodeBleu_score": 51.89964886925538}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp *Response\n\tvar e error\n\tlogger.Info(\"Refreshing access token...\")\n\tresp, e = base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.TokenEndpoint)\n\tif e != nil {\n\t\tlogger.Error(\"Failed to refresh access token\", zap.Error(e))\n\t\treturn e\n\t}\n\tif resp.StatusCode() != http.StatusOK {\n\t\tlogger.Error(\"Failed to refresh access token\", zap.String(\"status\", resp.Status()), zap.String(\"body\", resp.String()))\n\t\treturn fmt.Errorf(\"failed to refresh access token: %s\", resp.String())\n\t}\n\tvar token Token\n\tif err := json.Unmarshal(resp.Body(), &token); err != nil {\n\t\tlogger.Error(\"Failed to refresh access token\", zap.Error(err))\n\t\treturn err\n\t}\n\td.AccessToken = token.AccessToken\n\td.ExpiresIn = token.ExpiresIn\n\td.RefreshToken = token.RefreshToken\n\td.TokenType = token.TokenType\n\tlogger.Info(\"Successfully refreshed access token\")\n\treturn nil\n}", "CodeBleu_score": 52.552254278317434}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int64  `json:\"expires_in\"`\n\t}\n\tvar e error\n\tlogger.Info(\"refreshing access token\", zap.String(\"refresh_token\", d.RefreshToken))\n\tif err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.TokenURL); err != nil {\n\t\tlogger.Error(\"failed to refresh access token\", zap.Error(err))\n\t\treturn err\n\t}\n\tif e != nil {\n\t\tlogger.Error(\"failed to refresh access token\", zap.Error(e))\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\td.ExpiresIn = resp.ExpiresIn\n\treturn nil\n}", "CodeBleu_score": 62.30251371770823}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// TODO: Add support for the \"alt\" parameter\n\t// TODO: Add support for the \"fields\" parameter\n\t// TODO: Add support for the \"includeItemsFromAllDrives\" parameter\n\t// TODO: Add support for the \"supportsAllDrives\" parameter\n\t// TODO: Add support for the \"supportsTeamDrives\" parameter\n\t// TODO: Add support for the \"teamDriveId\" parameter\n\t// TODO: Add support for the \"prettyPrint\" parameter\n\t// TODO: Add support for the \"quotaUser\" parameter\n\t// TODO: Add support for the \"userIp\" parameter\n\t// TODO: Add support for the \"uploadType\" parameter\n\t// TODO: Add support for the \"upload_id\" parameter\n\t// TODO: Add support for the \"upload_protocol\" parameter\n\t// TODO: Add support for the \"body\" parameter\n\t// TODO: Add support for the \"bodyType\" parameter\n\t// TODO: Add support for the \"bodyFile\" parameter\n\t// TODO: Add support for the \"bodyContentType\" parameter\n\t// TODO: Add support for the \"bodyJSON\" parameter\n\t// TODO: Add support for the \"bodyMultipart\" parameter\n\t// TODO: Add support for the \"bodyMultipartFiles\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSON\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONFiles\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONContentType\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONContentTypes\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONContentTypes\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONContentTypes\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONContentTypes\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONContentTypes\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONContentTypes\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONContentTypes\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONContentTypes\" parameter\n\t// TODO: Add support for the \"bodyMultipartJSONContentTypes\" parameter\n\t// TODO: Add support for the \"bodyMultipart", "CodeBleu_score": 3.035357440942425}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar err error\n\tvar req *resty.Request\n\tvar body []byte\n\tvar respType string\n\tvar respBody string\n\tvar respCode int\n\tvar respHeader map[string]string\n\tvar respCookie string\n\tvar respCookieJar *http.CookieJar\n\tvar respSetCookie []*http.Cookie\n\tvar respSetCookieStr string\n\tvar respCookieStr string\n\tvar respCookieStrs []string\n\tvar respCookieStrsMap map[string]string\n\tvar respCookieStrsMapStr string\n\tvar respCookieStrsMapStrs []string\n\tvar respCookieStrsMapStrsStr string\n\tvar respCookieStrsMapStrsStrs []string\n\tvar respCookieStrsMapStrsStrsStr string\n\tvar respCookieStrsMapStrsStrsStrs []string\n\tvar respCookieStrsMapStrsStrsStrsStr string\n\tvar respCookieStrsMapStrsStrsStrsStrs []string\n\tvar respCookieStrsMapStrsStrsStrsStrsStr string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrs []string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrsStr string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrsStrs []string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrsStrsStr string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrsStrsStrs []string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrsStrsStrsStr string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrsStrsStrsStrs []string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrsStrsStrsStrsStr string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrsStrsStrsStrsStrs []string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrsStrsStrsStrsStrsStr string\n\tvar respCookieStrsMapStrsStrsStrsStrsStrsStrsStrsStrsStrsStrs", "CodeBleu_score": 5.195977101016769}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetHeader(\"GData-Version\", \"3.0\")\n\treq.SetHeader(\"X-GData-Key\", \"key=\"+d.apiKey)\n\treq.SetHeader(\"X-GData-Client\", \"Google-Drive-SDK/1.0\")\n\treq.SetHeader(\"X-JavaScript-User-Agent\", \"Google APIs Explorer\")\n\treq.SetHeader(\"X-Requested-With\", \"XMLHttpRequest\")\n\treq.SetHeader(\"Accept-Encoding\", \"gzip,deflate\")\n\treq.SetHeader(\"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.7\")\n\treq.SetHeader(\"Keep-Alive\", \"300\")\n\treq.SetHeader(\"Connection\", \"keep-alive\")\n\treq.SetHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36\")\n\treq.SetHeader(\"Content-Type\", \"application/json\")\n\treq.SetHeader(\"Accept\", \"application/json\")\n\treq.SetHeader(\"Pragma\", \"no-cache\")\n\treq.SetHeader(\"Cache-Control\", \"no-cache\")\n\treq.SetHeader(\"Expires\", \"Sat, 01 Jan 2000 00:00:00 GMT\")\n\treq.SetHeader(\"Host\", \"www.googleapis.com\")\n\treq.SetHeader(\"Accept-Language\", \"en-US,en;q=0.8\")\n\treq.SetHeader(\"X-Chrome-Variations\", \"CiAITAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQE\")\n\treq.SetHeader(\"X-Client-Data\", \"CJK2yQEIpLbJAQiylcLBcLYwFFAQiO9_", "CodeBleu_score": 20.26560877017336}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := d.chunkSize\n\tif chunkSize == 0 {\n\t\tchunkSize = stream.GetSize()\n\t}\n\tfinish := int64(0)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tif finish >= stream.GetSize() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif finish+chunkSize > stream.GetSize() {\n\t\t\t\tchunkSize = stream.GetSize() - finish\n\t\t\t}\n\t\t\treq := d.request(url, \"PUT\")\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t\tif err := d.do(req); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfinish += chunkSize\n\t\t}\n\t}\n}", "CodeBleu_score": 60.20381555388879}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(d.chunkSize)\n\tif stream.GetSize() < chunkSize {\n\t\tchunkSize = stream.GetSize()\n\t}\n\tfor finish := int64(0); finish < stream.GetSize(); finish += chunkSize {\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\treq, err := d.request(ctx, \"PUT\", url, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\tif _, err := d.doRequest(req); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 60.356021821779436}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := d.chunkSize\n\tif chunkSize == 0 {\n\t\tchunkSize = defaultChunkSize\n\t}\n\tvar finish int64\n\tvar err error\n\tfor {\n\t\t// Check for context cancellation\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Check if the stream has reached its end\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\n\t\t// Set the headers for the chunk\n\t\treq := d.request(url, \"PUT\")\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\n\t\t// Send the request\n\t\tres, err := req.Send()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check for a successful response\n\t\tif res.StatusCode() != 200 {\n\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", res.StatusCode())\n\t\t}\n\n\t\t// Update the finish value\n\t\tfinish += chunkSize\n\t}\n\n\t// Close the stream\n\tif err = stream.Close(); err != nil {\n\t\treturn err\n\t}\n\n\t// Return nil if there is no error\n\treturn nil\n}", "CodeBleu_score": 63.407153409553466}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind the request body to a struct\n\tvar req UnmountStorageRequest\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(common_err.GetMsg(ctx, err, \"unmount_storage\"))\n\t}\n\n\t// Get the mount point from the request body\n\tmountPoint := strings.ReplaceAll(req.MountPoint, \" \", \"\")\n\n\t// Check if the mount point is empty\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(common_err.GetMsg(ctx, common_err.ErrEmptyMountPoint, \"unmount_storage\"))\n\t}\n\n\t// Unmount the storage at the specified mount point\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.GetMsg(ctx, err, \"unmount_storage\"))\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err != nil {\n\t\treturn ctx.JSON(common_err.GetMsg(ctx, err, \"unmount_storage\"))\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(common_err.GetMsg(ctx, nil, \"unmount_storage\"))\n}", "CodeBleu_score": 46.40588300745895}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tctx.JSON(http.StatusOK, common_err.GetMsg(service.MyService.Storage().UnmountStorage(ctx.Param(\"mount_point\"))))\n\treturn nil\n}", "CodeBleu_score": 8.40129517823601}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar (\n\t\terr error\n\t)\n\n\t// Bind the request body to `reqBody`.\n\treqBody := new(types.UmountStorageRequest)\n\tif err = ctx.Bind(reqBody); err != nil {\n\t\treturn common_err.GetErrMsg(ctx, common_err.ErrBind, err)\n\t}\n\n\t// Replace all the occurrences of \"/\" with \"\\\\\" in the mount point.\n\tmountPoint := strings.ReplaceAll(reqBody.MountPoint, \"/\", \"\\\\\")\n\n\t// If the mount point is empty, return a client error response.\n\tif mountPoint == \"\" {\n\t\treturn common_err.GetErrMsg(ctx, common_err.ErrClient, errors.New(\"mount point is empty\"))\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err = service.MyService.Storage().UnmountStorage(mountPoint); err != nil {\n\t\treturn common_err.GetErrMsg(ctx, common_err.ErrService, err)\n\t}\n\n\t// Delete the corresponding configuration.\n\tif err = service.MyService.Storage().DeleteConfigByName(mountPoint); err != nil {\n\t\treturn common_err.GetErrMsg(ctx, common_err.ErrService, err)\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, &types.UmountStorageResponse{\n\t\tStatus:  \"success\",\n\t\tMessage: \"storage unmounted successfully\",\n\t})\n}", "CodeBleu_score": 40.810363371204716}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"filePath\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(\"missing_file_path\"))\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\t// Return an error message\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(\"file_not_found\"))\n\t}\n\n\t// Return the file\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 33.78628826357304}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tpath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided\n\tif path == \"\" {\n\t\t// Return an error message if the path is missing\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(\"missing_path\"))\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(path) {\n\t\t// Return an error message if the file does not exist\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(\"file_not_found\"))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(path)\n}", "CodeBleu_score": 41.104167901539846}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tpath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathMissing))\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(path) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(path)\n}", "CodeBleu_score": 46.5391203601775}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context and bind the request body to a message map.\n\tname := ctx.Param(\"name\")\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.BadRequest(err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\".\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn common_err.InternalServerError(err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, make(map[string]interface{}))\n}", "CodeBleu_score": 51.37470556905257}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\t// Bind the request body to a message map.\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn common_err.BadRequest(err.Error())\n\t}\n\t// Send the notification.\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn common_err.InternalServerError(err.Error())\n\t}\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 51.17089625387479}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\t// Bind the request body to a message map.\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\t// Return a bad request error with the binding error message.\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\t// Send the notification using the \"name\" and \"message\".\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\t// Return a bad request error with the error message.\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(\"success\"))\n}", "CodeBleu_score": 61.13561131216695}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Ensure that the message sending service is running\n\tif !sending {\n\t\tgo SendMeg()\n\t\tsending = true\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type and message\n\t\tfmt.Printf(\"Received message: %s\n\", message)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections\n\tfor i, v := range connections {\n\t\tif v == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.712737744258106}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\tdefer ws.Close()\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running.\n\tgo sendMeg()\n\t// Enter a loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"Message type: %v\nMessage: %s\n\", msgType, msg)\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.216825653275016}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Printf(\"Error while upgrading connection: %v\n\", err)\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections\n\tconnectionsMutex.Lock()\n\tconnections[ws] = true\n\tconnectionsMutex.Unlock()\n\n\t// Ensure that the message sending service is running\n\tgo sendMeg()\n\n\t// Loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error while reading message: %v\n\", err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tlog.Printf(\"Message type: %v\n\", ws.Kind())\n\t\tlog.Printf(\"Message: %s\n\", message)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error: %v\n\", err)\n\t\t}\n\t}\n\n\t// Remove the WebSocket connection from the list of connections\n\tconnectionsMutex.Lock()\n\tdelete(connections, ws)\n\tconnectionsMutex.Unlock()\n\n\treturn nil\n}", "CodeBleu_score": 38.13969215992863}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\terr error\n\t)\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tcommon_err.ResponseError(ctx, common_err.GetMsg(err))\n\t\t}\n\t}()\n\t// Get drive model and architecture\n\tvar (\n\t\tdriveModel string\n\t\tarch       string\n\t)\n\tdriveModel, arch, err = service.MyService.System().GetDriveInfo()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Get CPU information\n\tvar (\n\t\tcpuInfo *service.CpuInfo\n\t)\n\tcpuInfo, err = service.MyService.System().GetCpuInfo()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Return response\n\tif cpuInfo == nil {\n\t\tctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\t\"drive_model\": driveModel,\n\t\t\t\"arch\":        arch,\n\t\t})\n\t} else {\n\t\tctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\t\"drive_model\": driveModel,\n\t\t\t\"arch\":        arch,\n\t\t\t\"cpu\":         cpuInfo,\n\t\t})\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.96488873192572}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get drive model and architecture\n\tdriveModel, architecture, err := GetDriveModelAndArchitecture()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\t// Get CPU information\n\tcpuInfo, err := GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\t// Return response\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"drive_model\": driveModel,\n\t\t\"architecture\": architecture,\n\t\t\"cpu_info\": cpuInfo,\n\t})\n}", "CodeBleu_score": 23.288394531172692}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\terr error\n\t)\n\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tctx.JSON(http.StatusOK, common_err.GetMsg(ctx, err))\n\t\t}\n\t}()\n\n\t// Get the drive model and architecture.\n\tvar (\n\t\tdriveModel string\n\t\tarchitecture string\n\t)\n\tdriveModel, architecture, err = service.MyService.System().GetDriveModelAndArchitecture()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get CPU information.\n\tvar (\n\t\tcpuInfo []byte\n\t)\n\tcpuInfo, err = service.MyService.System().GetCpuInfo()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Return the data.\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"driveModel\": driveModel,\n\t\t\"architecture\": architecture,\n\t\t\"cpuInfo\": string(cpuInfo),\n\t})\n}", "CodeBleu_score": 32.515612182057396}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 72.992003322866}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 72.13490893901329}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 71.61023117945966}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\ti.logger.Debug(\"Sending notification\", zap.String(\"name\", name), zap.Any(\"message\", message))\n\n\tmessageJSON, err := json.Marshal(message)\n\tif err != nil {\n\t\ti.logger.Error(\"Failed to marshal message\", zap.Error(err))\n\t\treturn\n\t}\n\n\tresponse, err := i.messageBus.PublishEventWithResponse(context.Background(), MyService.MessageBus.NotifyTopic, name, messageJSON)\n\tif err != nil {\n\t\ti.logger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\"Failed to publish event\", zap.String(\"status\", response.Status), zap.String(\"statusCode\", response.StatusCode.String()), zap.String(\"response\", string(response.Body)))\n\t}\n}", "CodeBleu_score": 41.31472323064197}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tlogger.Info(\"Sending notification\", zap.String(\"name\", name), zap.Any(\"message\", message))\n\n\t// Marshal the message values to JSON strings.\n\tmessageJSON, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to marshal message\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), \"notify\", name, string(messageJSON))\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// If the response status code is not OK, log the failure.\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"status\", response.Status), zap.String(\"body\", string(response.Body)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 43.65577896443848}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to marshal message\", zap.Error(err))\n\t\treturn\n\t}\n\n\tresponse, err := i.MessageBus().PublishEventWithResponse(context.Background(), \"notify\", name, string(jsonMessage))\n\tif err != nil {\n\t\tlogger.Error(\"Failed to publish message\", zap.String(\"name\", name), zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"Failed to publish message\", zap.String(\"name\", name), zap.String(\"status\", response.Status), zap.Any(\"body\", response.Body))\n\t}\n}", "CodeBleu_score": 43.97952842104624}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\treturn message_bus.NewClientWithResponses(\n\t\tc.GetMessageBusAddress(),\n\t\tc.GetMessageBusClient(),\n\t)\n}", "CodeBleu_score": 12.133985290402771}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\tclient.SetServer(c.GetMessageBusAddress())\n\treturn client\n}", "CodeBleu_score": 11.909595175631646}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tvar address string\n\tvar err error\n\tvar client *message_bus.ClientWithResponses\n\tvar defaultAddress = \"http://localhost:8080/messagebus\"\n\tvar defaultErrorMessage = \"The message bus is unavailable.\"\n\tvar defaultErrorResponse = message_bus.NewErrorResponse(defaultErrorMessage)\n\n\t// Attempt to retrieve the message bus address using a specified runtime path.\n\tif address, err = c.GetMessageBusAddress(); err != nil {\n\t\t// If the address is not found, set the server to a default error message.\n\t\tclient = message_bus.NewClientWithResponses(defaultAddress)\n\t\tclient.Server = defaultErrorMessage\n\t} else {\n\t\t// If the address is found, set the server to the retrieved address.\n\t\tclient = message_bus.NewClientWithResponses(address)\n\t\tclient.Server = address\n\t}\n\n\t// If the client is not initialized, set the server to a default error message.\n\tif client == nil {\n\t\tclient.Server = defaultErrorMessage\n\t}\n\n\t// If the client is not initialized, set the server to a default error message.\n\tif client.Server == \"\" {\n\t\tclient.Server = defaultErrorMessage\n\t}\n\n\t// If the client is not initialized, set the server to a default error message.\n\tif client.Server == defaultErrorMessage {\n\t\tclient.Server = defaultErrorMessage\n\t}\n\n\t// If the client is not initialized, set the server to a default error message.\n\tif client.Server == defaultErrorMessage {\n\t\tclient.Server = defaultErrorMessage\n\t}\n\n\t// If the client is not initialized, set the server to a default error message.\n\tif client.Server == defaultErrorMessage {\n\t\tclient.Server = defaultErrorMessage\n\t}\n\n\t// If the client is not initialized, set the server to a default error message.\n\tif client.Server == defaultErrorMessage {\n\t\tclient.Server = defaultErrorMessage\n\t}\n\n\t// If the client is not initialized, set the server to a default error message.\n\tif client.Server == defaultErrorMessage {\n\t\tclient.Server =", "CodeBleu_score": 26.858327028576547}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tforwarded := request.Header.Get(\"X-Forwarded-For\")\n\tif forwarded != \"\" {\n\t\t// This is the most common header used to retrieve the IP of a client connecting to a web server.\n\t\t// We have to parse it to get the \"real\" IP.\n\t\tips := strings.Split(forwarded, \",\")\n\t\t// The first IP in the list is the \"real\" IP of the client.\n\t\tip := strings.TrimSpace(ips[0])\n\t\t// Check if the IP is a loopback address.\n\t\t// If it is, we return \"127.0.0.1\" instead.\n\t\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\t\treturn \"127.0.0.1\"\n\t\t}\n\t\treturn ip\n\t}\n\t// If the \"x-forwarded-for\" header is not available, we use the request's remote address.\n\treturn request.RemoteAddr\n}", "CodeBleu_score": 46.21355963464908}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\t// If the IP address is \"::1\" (IPv6) or \"::ffff:127.0.0.1\" (IPv4), it is replaced by \"127.0.0.1\".\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.44245846638746}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \",\")[0]\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 63.93850167286191}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the path to the modules directory\n\tmodulesPath := filepath.Join(c.systemPath, \"modules\")\n\n\t// Get the path to the entry file\n\tentryPath := filepath.Join(c.systemPath, \"entry.json\")\n\n\t// Create the modules directory if it does not exist\n\tif err := file.IsNotExistCreateFile(modulesPath); err != nil {\n\t\tc.logger.Error(\"Error creating modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Create the entry file if it does not exist\n\tif err := file.IsNotExistCreateFile(entryPath); err != nil {\n\t\tc.logger.Error(\"Error creating entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Read the contents of each entry.json file in the modules directory\n\tentryFiles, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tc.logger.Error(\"Error reading directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Create a slice of bytes to hold the concatenated JSON\n\tvar entryBytes []byte\n\n\t// Iterate through the entry.json files\n\tfor _, entryFile := range entryFiles {\n\t\t// Get the path to the entry.json file\n\t\tentryFilePath := filepath.Join(modulesPath, entryFile.Name())\n\n\t\t// Read the entry.json file\n\t\tentryFileBytes, err := os.ReadFile(entryFilePath)\n\t\tif err != nil {\n\t\t\tc.logger.Error(\"Error reading entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Append the entry.json file to the concatenated JSON\n\t\tentryBytes = append(entryBytes, entryFileBytes...)\n\t}\n\n\t// Write the concatenated JSON to the entry file\n\tif err := os.WriteFile(entryPath, entryBytes, 0644); err != nil {\n\t\tc.logger.Error(\"Error writing entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 44.97887567544765}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the path to the modules directory.\n\tmodulesPath := filepath.Join(c.config.System.Path, c.config.System.ModulesPath)\n\t// Get the path to the entry file.\n\tentryPath := filepath.Join(c.config.System.Path, c.config.System.EntryFile)\n\t// Check if the modules directory exists.\n\tif !file.IsNotExistCreateFile(modulesPath) {\n\t\t// Get the directory entries.\n\t\tentries, err := os.ReadDir(modulesPath)\n\t\tif err != nil {\n\t\t\t// Log the error.\n\t\t\tc.logger.Error(\"Error reading modules directory.\", zap.Error(err))\n\t\t\t// Return.\n\t\t\treturn\n\t\t}\n\t\t// Define an array to hold the entries.\n\t\tvar entriesArray []string\n\t\t// Define a string to hold the JSON array.\n\t\tvar entriesJSON string\n\t\t// Define a string to hold the JSON array with the trailing comma.\n\t\tvar entriesJSONWithComma string\n\t\t// Iterate through the entries.\n\t\tfor _, entry := range entries {\n\t\t\t// Get the path to the entry file.\n\t\t\tentryPath := filepath.Join(modulesPath, entry.Name(), c.config.System.EntryFile)\n\t\t\t// Check if the entry file exists.\n\t\t\tif !file.IsNotExistCreateFile(entryPath) {\n\t\t\t\t// Read the entry file.\n\t\t\t\tentryJSON, err := os.ReadFile(entryPath)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// Log the error.\n\t\t\t\t\tc.logger.Error(\"Error reading entry file.\", zap.Error(err))\n\t\t\t\t\t// Return.\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// Add the entry to the entries array.\n\t\t\t\tentriesArray = append(entriesArray, string(entryJSON))\n\t\t\t}\n\t\t}\n\t\t// Join the entries array into a JSON array.\n\t\tentriesJSON = strings.Join(entriesArray, \",\")\n\t\t// Join the", "CodeBleu_score": 48.00264345505916}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the module directories from the configuration.\n\tmoduleDirs := c.config.GetStringSlice(\"modules\")\n\t// Get the entry file path from the configuration.\n\tentryFilePath := c.config.GetString(\"entryFilePath\")\n\t// Get the logger from the context.\n\tlogger := c.ctx.Value(loggerKey).(*zap.Logger)\n\t// Get the zap error writer from the logger.\n\tzapError := logger.Desugar().Core().(zapcore.Core).Check(zap.ErrorLevel, nil).Writer\n\t// Get the zap error encoder from the logger.\n\tzapEncoder := logger.Desugar().Core().(zapcore.Core).Check(zap.ErrorLevel, nil).Encoder\n\t// Get the zap error encoder config from the logger.\n\tzapEncoderConfig := zapEncoder.EncodeConfig()\n\t// Get the zap error encoder config options from the logger.\n\tzapEncoderConfigOptions := zapEncoderConfig.Options\n\t// Get the zap error encoder config time format from the logger.\n\tzapEncoderConfigTimeFormat := zapEncoderConfig.TimeKey\n\t// Get the zap error encoder config level key from the logger.\n\tzapEncoderConfigLevelKey := zapEncoderConfig.LevelKey\n\t// Get the zap error encoder config message key from the logger.\n\tzapEncoderConfigMessageKey := zapEncoderConfig.MessageKey\n\t// Get the zap error encoder config stacktrace key from the logger.\n\tzapEncoderConfigStacktraceKey := zapEncoderConfig.StacktraceKey\n\t// Get the zap error encoder config line endings from the logger.\n\tzapEncoderConfigLineEndings := zapcore.DefaultLineEnding\n\t// Get the zap error encoder config level encoder config from the logger.\n\tzapEncoderConfigLevelEncoderConfig := zapEncoderConfig.LevelEncoderConfig\n\t// Get the zap error encoder config time encoder config from the logger.\n\tzapEncoderConfigTimeEncoderConfig := zapEncoderConfig.TimeEncoderConfig\n\t// Get the zap error encoder config name encoder config from the logger.\n\tzapEncoderConfigNameEncoder", "CodeBleu_score": 20.16162012665646}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\n\t// Get the list of network interfaces.\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", errors.New(\"Failed to get the list of network interfaces.\")\n\t}\n\n\t// Get the list of network names.\n\tnames, err := c.GetNet()\n\tif err != nil {\n\t\treturn \"\", errors.New(\"Failed to get the list of network names.\")\n\t}\n\n\t// Iterate over the interfaces and network names.\n\tfor _, interface_ := range interfaces {\n\t\tfor _, name := range names {\n\t\t\tif name == interface_.Name {\n\t\t\t\treturn interface_.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no matching interface is found, return an error.\n\treturn \"\", errors.New(\"Failed to find the MAC address of the network interface.\")\n}", "CodeBleu_score": 59.25638214312981}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t    var (\n        interfaces *net.Interfaces\n        err error\n        macAddress string\n    )\n\n    // Get a list of network interfaces.\n    if interfaces, err = net.Interfaces(); err != nil {\n        return macAddress, errors.New(\"error getting list of network interfaces\")\n    }\n\n    // Get a list of network names.\n    networkNames, err := c.GetNet()\n    if err != nil {\n        return macAddress, errors.New(\"error getting list of network names\")\n    }\n\n    // Iterate over the interfaces and network names.\n    for _, interface_ := range interfaces {\n        for _, networkName := range networkNames {\n            // If the interface name matches the network name, return the MAC address.\n            if interface_.Name == networkName {\n                return interface_.HardwareAddr.String(), nil\n            }\n        }\n    }\n\n    // If no matching interface is found, return an error.\n    return macAddress, errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 43.763001699864624}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, interface_ := range interfaces {\n\t\tfor _, networkName := range networkNames {\n\t\t\tif interface_.Name == networkName {\n\t\t\t\treturn interface_.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 65.1487507961908}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t ret = 0;\n    int32_t ret2 = 0;\n\n    if(pRequest == NULL) {\n        return TSC_ERROR_INVALID_PARAM;\n    }\n\n    if(pTscObj == NULL) {\n        return TSC_ERROR_INVALID_PARAM;\n    }\n\n    ret = tscAddRef(pRequest);\n    if(ret != TSC_SUCCESS) {\n        return ret;\n    }\n\n    ret = tscAddRef(pTscObj);\n    if(ret != TSC_SUCCESS) {\n        tscRelease(pRequest);\n        return ret;\n    }\n\n    ret = tscDebug(pTscObj, \"registerRequest: request=%p, tscObj=%p\", pRequest, pTscObj);\n    if(ret != TSC_SUCCESS) {\n        tscRelease(pRequest);\n        tscRelease(pTscObj);\n        return ret;\n    }\n\n    ret = tscAddRequest(pTscObj, pRequest);\n    if(ret != TSC_SUCCESS) {\n        tscRelease(pRequest);\n        tscRelease(pTscObj);\n        return ret;\n    }\n\n    ret = tscDebug(pTscObj, \"registerRequest: request=%p, tscObj=%p, ret=%d\", pRequest, pTscObj, ret);\n    if(ret != TSC_SUCCESS) {\n        tscRelease(pRequest);\n        tscRelease(pTscObj);\n        return ret;\n    }\n\n    ret2 = tscRelease(pRequest);\n    if(ret2 != TSC_SUCCESS) {\n        tscRelease(pTscObj);\n        return ret2;\n    }\n\n    return TSC_SUCCESS;\n}", "CodeBleu_score": 37.216208708061004}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t rc = 0;\n    uint64_t tscObjId = 0;\n    uint64_t requestId = 0;\n\n    if (pRequest == NULL) {\n        TSC_LOG_ERROR(\"pRequest is NULL\");\n        return TSC_ERROR_NULL_POINTER;\n    }\n\n    if (pTscObj == NULL) {\n        TSC_LOG_ERROR(\"pTscObj is NULL\");\n        return TSC_ERROR_NULL_POINTER;\n    }\n\n    tscObjId = pTscObj->tscObjId;\n    requestId = pRequest->requestId;\n\n    TSC_LOG_DEBUG(\"tscObjId=%\" PRIu64 \", requestId=%\" PRIu64, tscObjId, requestId);\n\n    // Add a reference to the request object\n    rc = atomic_add_fetch_32(&pRequest->refCount, 1);\n    if (rc < 0) {\n        TSC_LOG_ERROR(\"atomic_add_fetch_32 failed\");\n        return TSC_ERROR_ATOMIC;\n    }\n\n    // Increment the request count for the associated TSC object\n    rc = atomic_add_fetch_32(&pTscObj->requestCount, 1);\n    if (rc < 0) {\n        TSC_LOG_ERROR(\"atomic_add_fetch_32 failed\");\n        return TSC_ERROR_ATOMIC;\n    }\n\n    // Update the application's request summary, including total and current request counts\n    if (pTscObj->pAppInfo != NULL) {\n        rc = atomic_add_fetch_32(&pTscObj->pAppInfo->totalRequestCount, 1);\n        if (rc < 0) {\n            TSC_LOG_ERROR(\"atomic_add_fetch_32 failed\");\n            return TSC_ERROR_ATOMIC;\n        }\n\n        rc = atomic_add_fetch_32(&pTscObj->pAppInfo->currentRequestCount, 1);\n        if (rc < 0) {\n            TSC", "CodeBleu_score": 45.54022634982854}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\t\n\t// Add a reference to the request object\n\trc = tscAddRef(pRequest);\n\tif (rc != 0) {\n\t\tlogError(\"tsc: registerRequest: tscAddRef failed\");\n\t\treturn -1;\n\t}\n\t\n\t// Increment the request count for the TSC object\n\trc = tscIncrementRequestCount(pTscObj);\n\tif (rc != 0) {\n\t\tlogError(\"tsc: registerRequest: tscIncrementRequestCount failed\");\n\t\treturn -1;\n\t}\n\t\n\t// If the TSC object has application information, update the application's request summary\n\tif (pTscObj->pAppInfo != NULL) {\n\t\t// Update the application's request summary\n\t\trc = appUpdateRequestSummary(pTscObj->pAppInfo, pRequest);\n\t\tif (rc != 0) {\n\t\t\tlogError(\"tsc: registerRequest: appUpdateRequestSummary failed\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\t// Log debug information about the new request\n\tlogDebug(\"tsc: registerRequest: request %d registered for TSC %d\", pRequest->requestID, pTscObj->tscID);\n\t\n\t// Return success\n\treturn 0;\n}", "CodeBleu_score": 31.091773389106624}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar* db = pRequest->dbName;\n\tif (db == NULL) {\n\t\treturn false;\n\t}\n\tif (strcmp(db, exceptDb) != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 21.016833301465976}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    char *db = pRequest->primary_db;\n    if (strcmp(db, exceptDb) != 0) {\n        if (pRequest->db_list != NULL) {\n            ListCell *lc = NULL;\n            foreach(lc, pRequest->db_list) {\n                char *tmp = (char *)lfirst(lc);\n                if (strcmp(tmp, exceptDb) == 0) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 40.72755218414844}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    char *primaryDb = NULL;\n    char *db = NULL;\n    char *tmpDb = NULL;\n    bool isException = false;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int dbLen = 0;\n    int tmpDbLen = 0;\n    int exceptDbLen = 0;\n    int primaryDbLen = 0;\n    int primaryDbLenWithoutSchema = 0;\n\n    if (pRequest == NULL || exceptDb == NULL) {\n        return false;\n    }\n\n    primaryDb = pRequest->priDb;\n    if (primaryDb == NULL) {\n        return false;\n    }\n\n    primaryDbLen = strlen(primaryDb);\n    if (primaryDbLen <= 0) {\n        return false;\n    }\n\n    primaryDbLenWithoutSchema = primaryDbLen;\n    if (primaryDb[0] == '.' && primaryDbLenWithoutSchema > 1) {\n        primaryDbLenWithoutSchema--;\n    }\n\n    exceptDbLen = strlen(exceptDb);\n    if (exceptDbLen <= 0) {\n        return false;\n    }\n\n    if (primaryDbLenWithoutSchema == exceptDbLen && strncmp(primaryDb, exceptDb, primaryDbLenWithoutSchema) == 0) {\n        return false;\n    }\n\n    if (pRequest->dbNum <= 0) {\n        return false;\n    }\n\n    for (i = 0; i < pRequest->dbNum; i++) {\n        db = pRequest->db[i];\n        if (db == NULL) {\n            continue;\n        }\n\n        dbLen = strlen(db);\n        if (dbLen <= 0) {\n            continue;\n        }\n\n        tmpDb = db;\n        tmpDbLen = dbLen;\n        if (tmpDb[0] == '.' && tmpDbLen > 1) {\n            tmpDbLen--;\n        }\n\n        if (tmpDbLen == exceptDbLen && strncmp(tmpDb, exceptDb, tmpDbLen) == 0) {\n            isException =", "CodeBleu_score": 37.220936182853904}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool rv = false;\n\tswitch (code) {\n\tcase E_RPC_CANT_CONNECT_TO_SERVER:\n\t\tif (msgType != TMSG_RPC_CLIENT_REDIRECT_ERROR)\n\t\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_SERVER_NOT_FOUND:\n\t\tif (msgType != TMSG_RPC_CLIENT_REDIRECT_ERROR)\n\t\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_CLIENT_NOT_FOUND:\n\t\tif (msgType != TMSG_RPC_CLIENT_REDIRECT_ERROR)\n\t\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_SERVER_NOT_RUNNING:\n\t\tif (msgType != TMSG_RPC_CLIENT_REDIRECT_ERROR)\n\t\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_CLIENT_NOT_RUNNING:\n\t\tif (msgType != TMSG_RPC_CLIENT_REDIRECT_ERROR)\n\t\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_CLIENT_REDIRECT:\n\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_SERVER_REDIRECT:\n\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_REDIRECT_DISABLED:\n\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_CLIENT_DISABLED:\n\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_SERVER_DISABLED:\n\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_SERVER_TIMEOUT:\n\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_CLIENT_TIMEOUT:\n\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_SERVER_OVERLOADED:\n\t\trv = true;\n\t\tbreak;\n\tcase E_RPC_CLIENT_OVERLO", "CodeBleu_score": 37.07602559100987}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == 0 && msgType == tmsg_t::RESPONSE) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::NOTIFICATION) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REQUEST) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::HEARTBEAT) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT_RESPONSE) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT_NOTIFICATION) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT_REQUEST) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT_HEARTBEAT) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT_REDIRECT) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT_REDIRECT_RESPONSE) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT_REDIRECT_NOTIFICATION) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT_REDIRECT_REQUEST) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT_REDIRECT_HEARTBEAT) {\n        return false;\n    }\n\n    if (code == 0 && msgType == tmsg_t::REDIRECT_REDIRECT_REDI", "CodeBleu_score": 45.35190172253923}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == ED_REDIRECT_ERROR) {\n\t\tif (msgType != MSG_RPC_REDIRECT_REPLY) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 26.89130631062216}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tTaosHashIterate(pRequests, stopRequest);\n}", "CodeBleu_score": 5.744391118451475}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t    int i;\n    taos_request_t *request;\n    SHashIter *iter = SHashGetIter(pRequests);\n    while (SHashNext(&iter)) {\n        i = iter->cur_key;\n        request = (taos_request_t *) SHashGet(pRequests, i);\n        if (request != NULL) {\n            if (request->valid) {\n                taos_stop_query(request->taos_handle);\n            }\n            releaseRequest(request);\n        }\n    }\n    SHashReleaseIter(iter);\n}", "CodeBleu_score": 46.94334348747529}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\ttaos_stop_query(pRequests);\n}", "CodeBleu_score": 6.269963337534364}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t  if (tsc_crash_report_enabled) {\n    if (atomic_val_compare_exchange_32(&tsc_crash_report_client_stop, 0, 1) != 0) {\n      tscLogMessage(TS_LOG_INFO, \"Crash report thread already stopped\");\n      return;\n    }\n    while (atomic_load_32(&tsc_crash_report_client_stop) != 0) {\n      tscMsleep(100);\n    }\n    tscLogMessage(TS_LOG_INFO, \"Crash report thread stopped\");\n  }\n}", "CodeBleu_score": 61.215750525863434}, {"code": "void tscStopCrashReport(){\n\t\tif (tsc_crash_report_enabled == 0) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&tsc_crash_report_thread_client_stop, 0, 1) == 0) {\n\t\treturn;\n\t}\n\twhile (atomic_load_32(&tsc_crash_report_thread_client_stop) != 0) {\n\t\ttscMsleep(1);\n\t}\n\treturn;\n}", "CodeBleu_score": 58.22958005512541}, {"code": "void tscStopCrashReport(){\n\t  if (tscIsCrashReportEnabled()) {\n    if (!atomic_val_compare_exchange_32(&tscCrashReportClientStop, 0, 1)) {\n      tscLogMessage(\n          \"tscStopCrashReport: crash report thread is already stopped\");\n      return;\n    }\n    while (atomic_load_32(&tscCrashReportClientStop) != 0) {\n      taosMsleep(1000);\n    }\n  }\n}", "CodeBleu_score": 65.88498783258262}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    TSResponseArray *viewRsp = NULL;\n    TSResponseArray *viewRsp2 = NULL;\n    TSViewInfo *viewInfo = NULL;\n    TSViewInfo *viewInfo2 = NULL;\n    TSViewInfo *viewInfo3 = NULL;\n    int32_t viewCount = 0;\n    int32_t viewCount2 = 0;\n    int32_t viewCount3 = 0;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t k = 0;\n    int32_t ret = 0;\n    int32_t ret2 = 0;\n    int32_t ret3 = 0;\n\n    if (value == NULL) {\n        return TSDB_ERROR;\n    }\n\n    viewRsp = tDeserializeSViewHbRsp(value, valueLen);\n    if (viewRsp == NULL) {\n        return TSDB_ERROR;\n    }\n\n    viewCount = viewRsp->count;\n    if (viewCount == 0) {\n        tFreeSViewMetaRsp(viewRsp);\n        return TSDB_OK;\n    }\n\n    for (i = 0; i < viewCount; i++) {\n        viewInfo = viewRsp->views[i];\n        if (viewInfo == NULL) {\n            continue;\n        }\n\n        if (viewInfo->name == NULL) {\n            continue;\n        }\n\n        if (viewInfo->columns == NULL) {\n            continue;\n        }\n\n        ret = catalogUpdateViewMeta(pCatalog, viewInfo->name, viewInfo->columns, viewInfo->columnCount);\n        if (ret != TSDB_OK) {\n            tFreeSViewMetaRsp(viewRsp);\n            return ret;\n        }\n    }\n\n    tFreeSViewMetaRsp(viewRsp);\n\n    viewRsp2 = tDeserializeSViewHbRsp(value, valueLen);\n    if (viewRsp2 == NULL) {\n        return TSDB_ERROR;", "CodeBleu_score": 37.12348232450273}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t i;\n\tint32_t j;\n\tint32_t ret;\n\tint32_t viewId;\n\tint32_t numViews;\n\tint32_t numCols;\n\tint32_t numParts;\n\tint32_t numServers;\n\tint32_t numNodes;\n\tint32_t numNodesP;\n\tint32_t numNodesS;\n\tint32_t numNodesR;\n\tint32_t numNodesA;\n\tint32_t numNodesD;\n\tint32_t numNodesF;\n\tint32_t numNodesO;\n\tint32_t numNodesM;\n\tint32_t numNodesT;\n\tint32_t numNodesP;\n\tint32_t numNodesS;\n\tint32_t numNodesR;\n\tint32_t numNodesA;\n\tint32_t numNodesD;\n\tint32_t numNodesF;\n\tint32_t numNodesO;\n\tint32_t numNodesM;\n\tint32_t numNodesT;\n\tint32_t numNodesP;\n\tint32_t numNodesS;\n\tint32_t numNodesR;\n\tint32_t numNodesA;\n\tint32_t numNodesD;\n\tint32_t numNodesF;\n\tint32_t numNodesO;\n\tint32_t numNodesM;\n\tint32_t numNodesT;\n\tint32_t numNodesP;\n\tint32_t numNodesS;\n\tint32_t numNodesR;\n\tint32_t numNodesA;\n\tint32_t numNodesD;\n\tint32_t numNodesF;\n\tint32_t numNodesO;\n\tint32_t numNodesM;\n\tint32_t numNodesT;\n\tint32_t numNodesP;\n\tint32_t numNodesS;\n\tint32", "CodeBleu_score": 6.486448768011416}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t i;\n    int32_t j;\n    int32_t retCode;\n    int32_t numViews;\n    int32_t numCols;\n    int32_t numColsToRemove;\n    int32_t numColsToAdd;\n    int32_t numColsToKeep;\n    int32_t numColsToMove;\n    int32_t numColsToUpdate;\n    int32_t numColsToCheck;\n    int32_t numColsToCheck2;\n    int32_t numColsToCheck3;\n    int32_t numColsToCheck4;\n    int32_t numColsToCheck5;\n    int32_t numColsToCheck6;\n    int32_t numColsToCheck7;\n    int32_t numColsToCheck8;\n    int32_t numColsToCheck9;\n    int32_t numColsToCheck10;\n    int32_t numColsToCheck11;\n    int32_t numColsToCheck12;\n    int32_t numColsToCheck13;\n    int32_t numColsToCheck14;\n    int32_t numColsToCheck15;\n    int32_t numColsToCheck16;\n    int32_t numColsToCheck17;\n    int32_t numColsToCheck18;\n    int32_t numColsToCheck19;\n    int32_t numColsToCheck20;\n    int32_t numColsToCheck21;\n    int32_t numColsToCheck22;\n    int32_t numColsToCheck23;\n    int32_t numColsToCheck24;\n    int32_t numColsToCheck25;\n    int32_t numColsToCheck26;\n    int32_t numColsToCheck27;\n    int", "CodeBleu_score": 8.604363257078566}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    CallbackData *data = (CallbackData *) callbackData;\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n    return status;\n}", "CodeBleu_score": 73.70234697147241}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status;\n    CallbackData *data = (CallbackData *) callbackData;\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n\n    status = S3StatusOK;\n    return status;\n}", "CodeBleu_score": 71.86959606757965}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    CallbackData *data = (CallbackData *) callbackData;\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n    return status;\n}", "CodeBleu_score": 73.70234697147241}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tint ret;\n\tchar *rsync_path;\n\tchar *rsync_config_file;\n\tchar *rsync_config_path;\n\tchar *rsync_config_file_path;\n\tchar *rsync_daemon_cmd;\n\tchar *rsync_daemon_cmd_path;\n\tchar *rsync_daemon_cmd_args;\n\tchar *rsync_daemon_cmd_args_path;\n\tchar *rsync_daemon_cmd_args_port;\n\tchar *rsync_daemon_cmd_args_config;\n\tchar *rsync_daemon_cmd_args_config_path;\n\tchar *rsync_daemon_cmd_args_pid;\n\tchar *rsync_daemon_cmd_args_pid_path;\n\tchar *rsync_daemon_cmd_args_log;\n\tchar *rsync_daemon_cmd_args_log_path;\n\tchar *rsync_daemon_cmd_args_log_level;\n\tchar *rsync_daemon_cmd_args_log_level_path;\n\tchar *rsync_daemon_cmd_args_log_file;\n\tchar *rsync_daemon_cmd_args_log_file_path;\n\tchar *rsync_daemon_cmd_args_log_file_level;\n\tchar *rsync_daemon_cmd_args_log_file_level_path;\n\tchar *rsync_daemon_cmd_args_daemon;\n\tchar *rsync_daemon_cmd_args_daemon_path;\n\tchar *rsync_daemon_cmd_args_daemon_port;\n\tchar *rsync_daemon_cmd_args_daemon_port_path;\n\tchar *rsync_daemon_cmd_args_daemon_pid;\n\tchar *rsync_daemon_cmd_args_daemon_pid_path;\n\tchar *rsync_daemon_cmd_args_daemon_log;\n\tchar *rsync_daemon_cmd_args_daemon_log_path;\n\tchar *rsync_daemon_cmd_args_daemon", "CodeBleu_score": 2.973625512882621}, {"code": "void startRsync(){\n\t    uDebugLog(\"startRsync\");\n    int ret;\n    int port;\n    char *configFile = NULL;\n    char *configFilePath = NULL;\n    char *rsyncCommand = NULL;\n    char *rsyncConfigFile = NULL;\n    char *rsyncConfigFilePath = NULL;\n    char *rsyncDaemon = NULL;\n    char *rsyncDaemonPath = NULL;\n    char *rsyncLog = NULL;\n    char *rsyncLogPath = NULL;\n    char *rsyncPid = NULL;\n    char *rsyncPidPath = NULL;\n    char *rsyncPort = NULL;\n    char *rsyncPortPath = NULL;\n    char *rsyncSrc = NULL;\n    char *rsyncSrcPath = NULL;\n    char *rsyncTmp = NULL;\n    char *rsyncTmpPath = NULL;\n    char *rsyncTmpPath2 = NULL;\n    char *rsyncTmpPath3 = NULL;\n    char *rsyncTmpPath4 = NULL;\n    char *rsyncTmpPath5 = NULL;\n    char *rsyncTmpPath6 = NULL;\n    char *rsyncTmpPath7 = NULL;\n    char *rsyncTmpPath8 = NULL;\n    char *rsyncTmpPath9 = NULL;\n    char *rsyncTmpPath10 = NULL;\n    char *rsyncTmpPath11 = NULL;\n    char *rsyncTmpPath12 = NULL;\n    char *rsyncTmpPath13 = NULL;\n    char *rsyncTmpPath14 = NULL;\n    char *rsyncTmpPath15 = NULL;\n    char *rsyncTmpPath16 = NULL;\n    char *rsyncTmpPath17 = NULL;\n    char *rsyncTmpPath18 = NULL;\n    char *rsyncTmpPath19 = NULL;\n    char *rsyncTmpPath20 = NULL;\n    char *rsyncTmpPath21 = NULL;\n    char *rsyncTmpPath22 = NULL;\n    char *rsyncTmpPath23 = NULL;\n    char *rsyncT", "CodeBleu_score": 7.599959232678055}, {"code": "void startRsync(){\n\t    char *p;\n    char *p2;\n    char *p3;\n    char *p4;\n    char *p5;\n    char *p6;\n    char *p7;\n    char *p8;\n    char *p9;\n    char *p10;\n    char *p11;\n    char *p12;\n    char *p13;\n    char *p14;\n    char *p15;\n    char *p16;\n    char *p17;\n    char *p18;\n    char *p19;\n    char *p20;\n    char *p21;\n    char *p22;\n    char *p23;\n    char *p24;\n    char *p25;\n    char *p26;\n    char *p27;\n    char *p28;\n    char *p29;\n    char *p30;\n    char *p31;\n    char *p32;\n    char *p33;\n    char *p34;\n    char *p35;\n    char *p36;\n    char *p37;\n    char *p38;\n    char *p39;\n    char *p40;\n    char *p41;\n    char *p42;\n    char *p43;\n    char *p44;\n    char *p45;\n    char *p46;\n    char *p47;\n    char *p48;\n    char *p49;\n    char *p50;\n    char *p51;\n    char *p52;\n    char *p53;\n    char *p54;\n    char *p55;\n    char *p56;\n    char *p57;\n    char *p58;\n    char *p59;\n    char *p60;\n    char *p61;\n    char *p62;\n    char *p63;\n    char *p64;\n    char *p65;\n    char", "CodeBleu_score": 3.323810130410465}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n    dispatcher.shutdownNow();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 66.48994387083516}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n    dispatcher.shutdownNow();\n}", "CodeBleu_score": 62.25768624397865}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n    dispatcher.shutdownNow();\n}", "CodeBleu_score": 62.25768624397865}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        if (parent == null) {\n            return;\n        }\n        TbActorId parentId = parent;\n        if (parent instanceof TbActorRef) {\n            parentId = ((TbActorRef) parent).getId();\n        }\n        Map<TbActorId, TbActorRef> children = childActors.get(parentId);\n        if (children != null) {\n            for (TbActorRef child : children.values()) {\n                if (childFilter.test(child.getId())) {\n                    if (highPriority) {\n                        child.tell(msg, ActorRef.NO_SENDER);\n                    } else {\n                        child.getActor().onMessage(msg);\n                    }\n                }\n            }\n        } else {\n            log.warn(\"[{}] Failed to broadcast message to children of [{}]\", msg, parentId);\n        }\n    }", "CodeBleu_score": 44.093297401099825}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        if (parent == null) {\n            log.warn(\"Parent actor id is null!\");\n            return;\n        }\n        List<TbActorId> children = childActors.get(parent);\n        if (children == null) {\n            log.warn(\"Parent actor id [{}] is not registered!\", parent);\n            return;\n        }\n        if (childFilter == null) {\n            log.warn(\"Child filter is null!\");\n            return;\n        }\n        if (msg == null) {\n            log.warn(\"Message is null!\");\n            return;\n        }\n        for (TbActorId child : children) {\n            if (childFilter.test(child)) {\n                if (highPriority) {\n                    tellWithHighPriority(child, msg);\n                } else {\n                    tell(child, msg);\n                }\n            }\n        }\n    }", "CodeBleu_score": 40.30638956323562}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    if (childrenMap.containsKey(parent)) {\n      for (TbActorId child : childrenMap.get(parent)) {\n        if (childFilter.test(child)) {\n          if (highPriority) {\n            actorContext.tellWithHighPriority(child, msg);\n          } else {\n            actorContext.tell(child, msg);\n          }\n        }\n      }\n    } else {\n      log.warn(\"[{}] Failed to broadcast message to children of parent actor [{}]. No children found.\", actorContext.getTenantId(), parent);\n    }\n  }", "CodeBleu_score": 38.86738817563851}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (destroying) {\n        if (msg.getMsgType() == TbActorMsg.RULE_NODE_UPDATED_MSG) {\n            TbRuleNodeUpdateMsg ruleNodeUpdateMsg = (TbRuleNodeUpdateMsg) msg;\n            if (ruleNodeUpdateMsg.getNodeId().equals(nodeId)) {\n                if (initActor(ruleNodeUpdateMsg.getNode())) {\n                    msg = getMsgType().createMsg(ruleNodeUpdateMsg.getNodeId(), ruleNodeUpdateMsg.getNode(), ruleNodeUpdateMsg.getRuleChainId());\n                } else {\n                    return;\n                }\n            }\n        }\n        msg.onTbActorStopped(this);\n        return;\n    }\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    tryProcessQueue();\n}", "CodeBleu_score": 52.65951501813604}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    tryProcessQueue();\n}", "CodeBleu_score": 27.409215694083343}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (msg.getMsgType() == TbActorMsg.RULE_NODE_UPDATED_MSG) {\n        if (destroying && highPriority) {\n            if (msg.getId().equals(nodeId)) {\n                if (initActor()) {\n                    try {\n                        getSelf().tell(new TbActorMsg(TbActorMsg.RULE_NODE_INIT_MSG, nodeId), getSelf());\n                    } catch (Exception e) {\n                        log.error(\"[{}] Failed to init actor\", nodeId, e);\n                    }\n                }\n            }\n        } else {\n            msg.onTbActorStopped();\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue();\n    }\n}", "CodeBleu_score": 63.74149814389221}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    // Start of user code processMailbox\n    int throughput = getActorThroughput();\n    int processed = 0;\n    int failed = 0;\n    int processedNormal = 0;\n    int failedNormal = 0;\n    int processedHigh = 0;\n    int failedHigh = 0;\n    boolean stop = false;\n    while (!stop && processed < throughput) {\n        // Process normal messages\n        if (!normalQueue.isEmpty()) {\n            Message message = normalQueue.poll();\n            if (message != null) {\n                try {\n                    process(message);\n                    processedNormal++;\n                } catch (Exception e) {\n                    failedNormal++;\n                    onProcessFailure(e, message);\n                }\n            }\n        }\n        // Process high messages\n        if (!highQueue.isEmpty()) {\n            Message message = highQueue.poll();\n            if (message != null) {\n                try {\n                    process(message);\n                    processedHigh++;\n                } catch (Exception e) {\n                    failedHigh++;\n                    onProcessFailure(e, message);\n                }\n            }\n        }\n        // Process messages\n        if (normalQueue.isEmpty() && highQueue.isEmpty()) {\n            stop = true;\n        }\n        processed += processedNormal + processedHigh;\n        failed += failedNormal + failedHigh;\n    }\n    // End of user code\n}", "CodeBleu_score": 34.3923172965648}, {"code": "private void processMailbox(){\n\t\t\tif (isStop()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (getActorThroughput() > 0) {\n\t\t\tint throughput = getActorThroughput();\n\t\t\tint count = 0;\n\t\t\twhile (count < throughput) {\n\t\t\t\tif (isStop()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (getHighPriorityQueue().isEmpty() && getNormalPriorityQueue().isEmpty()) {\n\t\t\t\t\tsetStatus(ActorStatus.FREE);\n\t\t\t\t\tpoll();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!getHighPriorityQueue().isEmpty()) {\n\t\t\t\t\tMessage msg = getHighPriorityQueue().poll();\n\t\t\t\t\tif (msg != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\texecute(msg);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tonProcessFailure(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!getNormalPriorityQueue().isEmpty()) {\n\t\t\t\t\tMessage msg = getNormalPriorityQueue().poll();\n\t\t\t\t\tif (msg != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\texecute(msg);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tonProcessFailure(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (!getHighPriorityQueue().isEmpty() || !getNormalPriorityQueue().isEmpty()) {\n\t\t\t\tif (isStop()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (getHighPriorityQueue().isEmpty() && getNormalPriorityQueue().isEmpty()) {\n\t\t\t\t\t", "CodeBleu_score": 23.853544590363278}, {"code": "private void processMailbox(){\n\t\t// line 110 \"Actor.ump\"\n\twhile(isStop() == false) {\n\t\t// line 111 \"Actor.ump\"\n\t\tif(getActorThroughput() > 0) {\n\t\t\t// line 112 \"Actor.ump\"\n\t\t\tint processed = 0;\n\t\t\t// line 113 \"Actor.ump\"\n\t\t\tfor(int i = 0; i < getActorThroughput() && i < getHighPriorityQueue().size(); i++) {\n\t\t\t\t// line 114 \"Actor.ump\"\n\t\t\t\tprocess(getHighPriorityQueue().dequeue());\n\t\t\t\t// line 115 \"Actor.ump\"\n\t\t\t\tprocessed++;\n\t\t\t}\n\t\t\t// line 116 \"Actor.ump\"\n\t\t\tfor(int i = 0; i < getActorThroughput() - processed && i < getNormalPriorityQueue().size(); i++) {\n\t\t\t\t// line 117 \"Actor.ump\"\n\t\t\t\tprocess(getNormalPriorityQueue().dequeue());\n\t\t\t}\n\t\t\t// line 118 \"Actor.ump\"\n\t\t\tif(getHighPriorityQueue().isEmpty() && getNormalPriorityQueue().isEmpty()) {\n\t\t\t\t// line 119 \"Actor.ump\"\n\t\t\t\tsetStatus(ActorStatus.FREE);\n\t\t\t\t// line 120 \"Actor.ump\"\n\t\t\t\tgetExecutor().schedule(this, getProcessingInterval());\n\t\t\t}\n\t\t}\n\t\t// line 123 \"Actor.ump\"\n\t\telse {\n\t\t\t// line 124 \"Actor.ump\"\n\t\t\twhile(!getHighPriorityQueue().isEmpty()) {\n\t\t\t\t// line 125 \"Actor.ump\"\n\t\t\t\tprocess(getHighPriorityQueue().dequeue());\n\t\t\t}\n\t\t\t// line 126 \"Actor.ump\"\n", "CodeBleu_score": 17.05709723526933}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = new TbActorStopReason();\n    }\n    stopReason.set(TbActorStopReasonCode.DESTROYED, cause);\n    setReady(false);\n    getExecutor().execute(() -> {\n        try {\n            setReady(false);\n            destroy();\n        } catch (Throwable th) {\n            warn(\"Failed to destroy actor {}\", th);\n        }\n        try {\n            getContext().notifyStopped(this, stopReason);\n        } catch (Throwable th) {\n            warn(\"Failed to notify actor {}\", th);\n        }\n    });\n}", "CodeBleu_score": 41.83248021490892}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = new ActorStopped(cause);\n    }\n    if (isDestroyed) {\n        return;\n    }\n    isDestroyed = true;\n    if (log.isDebugEnabled()) {\n        log.debug(\"Destroying actor with stop reason [{}]\", stopReason);\n    }\n    // Schedule a task to set the actor's readiness to \"not ready\", invoke the actor's destroy method,\n    // and notify all queued messages of the actor's stoppage.\n    getExecutor().execute(() -> {\n        try {\n            setReadiness(false);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Destroying actor with stop reason [{}]\", stopReason);\n            }\n            if (destroyMethod != null) {\n                destroyMethod.accept(stopReason);\n            }\n            notifyAllMessages(stopReason);\n        } catch (Throwable t) {\n            log.warn(\"Exception during actor destruction\", t);\n        }\n    });\n}", "CodeBleu_score": 45.56643438514857}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = new ActorStoppedException(cause);\n    }\n    if (stopReason.getCause() == null) {\n        stopReason.initCause(cause);\n    }\n    if (isReady()) {\n        setReady(false);\n    }\n    if (isStopped()) {\n        return;\n    }\n    try {\n        setStopped(true);\n        getExecutor().execute(() -> {\n            if (!isReady()) {\n                setReady(false);\n            }\n            if (isStopped()) {\n                return;\n            }\n            try {\n                setStopped(true);\n                if (isReady()) {\n                    setReady(false);\n                }\n                if (isStopped()) {\n                    return;\n                }\n                try {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Destroying actor {}\", getActorId());\n                    }\n                    destroy();\n                } catch (Throwable e) {\n                    log.warn(\"Exception during actor destruction\", e);\n                }\n            } catch (Throwable e) {\n                log.warn(\"Exception during actor destruction\", e);\n            }\n            if (isReady()) {\n                setReady(false);\n            }\n            if (isStopped()) {\n                return;\n            }\n            try {\n                setStopped(true);\n                if (isReady()) {\n                    setReady(false);\n                }\n                if (isStopped()) {\n                    return;\n                }\n                try {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Destroyed actor {}\", getActorId());\n                    }\n                    setReady(true);\n                } catch (Throwable e) {\n                    log.warn(\"Exception during actor destruction\", e);\n                }\n            } catch (Throwable e) {\n                log.warn(\"Exception during actor destruction\", e);\n            }\n        });\n    } catch (Throwable e) {\n        log.warn(\"Exception during actor destruction\", e);\n    }\n}", "CodeBleu_score": 39.26915550373789}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (profile == null) {\n        return true;\n    }\n    RateLimitConfiguration limit = get(api, level, profile.getRateLimits());\n    if (limit == null) {\n        return true;\n    }\n    boolean result = builder.check(limit, tenantId);\n    if (!result) {\n        process(api, tenantId, level, limit);\n    }\n    return result;\n}", "CodeBleu_score": 37.93827579101136}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId);\n    if (profile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitConfiguration rateLimit = profile.getRateLimit();\n    if (rateLimit == null) {\n        return true;\n    }\n    if (checkRateLimit(api, rateLimit, level)) {\n        return true;\n    }\n    processRateLimit(tenantId, rateLimit);\n    return false;\n}", "CodeBleu_score": 43.80167456577788}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile profile = getProfileConfiguration(tenantId);\n    if (profile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitConfiguration limit = profile.getRateLimitConfiguration();\n    if (limit == null) {\n        return true;\n    }\n    RateLimit rateLimit = limit.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitExceededException rateLimitExceededException = null;\n    try {\n        checkRateLimit(api, tenantId, rateLimit, level);\n    } catch (RateLimitExceededException e) {\n        rateLimitExceededException = e;\n    }\n    if (rateLimitExceededException != null) {\n        process(rateLimitExceededException);\n    }\n    return rateLimitExceededException == null;\n}", "CodeBleu_score": 52.495536666562245}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\t\tlong now = System.currentTimeMillis();\n\t\tlong expirationTime = now - inactivityTimeout;\n\t\tfor (Map.Entry<String, DTLSConnection> entry : dtlsSessions.entrySet()) {\n\t\t\tString key = entry.getKey();\n\t\t\tDTLSConnection dtlsConnection = entry.getValue();\n\t\t\tlong lastActivityTime = dtlsConnection.getLastActivityTime();\n\t\t\tif (lastActivityTime < expirationTime) {\n\t\t\t\tdtlsSessions.remove(key);\n\t\t\t\ttrace(\"Removed inactive DTLS session: \" + key);\n\t\t\t}\n\t\t}\n\t}", "CodeBleu_score": 35.76337667846197}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSConnection> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            String key = entry.getKey();\n            DTLSConnection dtlsConnection = entry.getValue();\n            dtlsSessions.remove(key);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Removed DTLS session for \" + key + \" due to inactivity timeout\");\n            }\n        }\n    }\n}", "CodeBleu_score": 47.5140141163936}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTimeMillis = System.currentTimeMillis();\n\tlong expirationTime = currentTimeMillis - inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tDtlsSession dtlsSession = entry.getValue();\n\t\tlong lastActivityTime = dtlsSession.getLastActivityTime();\n\t\tif (lastActivityTime < expirationTime) {\n\t\t\tdtlsSessions.remove(key);\n\t\t\tlog.trace(\"Removed DTLS session {} because it has been inactive for {} milliseconds\", key, currentTimeMillis - lastActivityTime);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.50573583054764}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return emptyList();\n    }\n    return timeseries.entrySet().stream().flatMap(e -> {\n        String key = e.getKey();\n        List<JsonNode> values = e.getValue();\n        return values.stream().map(v -> {\n            long ts = v.get(\"t\").asLong();\n            JsonNode value = v.get(\"v\");\n            return new BasicTsKvEntry(ts, parseValue(key, value));\n        });\n    }).collect(Collectors.toList());\n}", "CodeBleu_score": 40.6156619102198}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    } else {\n        List<TsKvEntry> ts = new ArrayList<>(timeseries.size());\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                ts.add(new BasicTsKvEntry(parseLong(key), parseValue(value)));\n            }\n        }\n        return ts;\n    }\n}", "CodeBleu_score": 45.095651239249534}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> result = new ArrayList<>(timeseries.size());\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        for (JsonNode jsonNode : entry.getValue()) {\n            result.add(new BasicTsKvEntry(parseValue(jsonNode.get(\"t\")), new BasicTsKvEntry(entry.getKey(), parseValue(jsonNode.get(\"v\")))));\n        }\n    }\n    return result;\n}", "CodeBleu_score": 43.184609600829354}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<String, String>();\n\trequestMap.put(\"refreshToken\", this.refreshToken);\n\tString responseBody = \"\";\n\ttry {\n\t\tHttpEntity<String> responseEntity = restTemplate.postForEntity(this.authenticationEndpoint, requestMap, String.class);\n\t\tresponseBody = responseEntity.getBody();\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n\tsetTokenInfo(responseBody);\n}", "CodeBleu_score": 43.018825212058964}, {"code": "public void refreshToken(){\n\t    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refresh_token\", tokenInfo.getRefreshToken());\n    requestMap.put(\"grant_type\", \"refresh_token\");\n    requestMap.put(\"client_id\", clientId);\n    requestMap.put(\"client_secret\", clientSecret);\n    HttpEntity<Map<String, String>> request = new HttpEntity<>(requestMap);\n    ResponseEntity<String> response = restTemplate.postForEntity(authEndpoint, request, String.class);\n    tokenInfo.setRefreshToken(response.getBody());\n    tokenInfo.setExpiryTime(currentTimeMillis() + 1000 * 60 * 60 * 24 * 365);\n}", "CodeBleu_score": 48.50011401916701}, {"code": "public void refreshToken(){\n\t\t\tif(tokenInfo.getRefreshToken() == null || tokenInfo.getRefreshToken().equals(\"\")) {\n\t\t\tthrow new IllegalStateException(\"Refresh token is empty\");\n\t\t}\n\t\tMap<String, String> requestMap = new HashMap<String, String>();\n\t\trequestMap.put(\"grant_type\", \"refresh_token\");\n\t\trequestMap.put(\"refresh_token\", tokenInfo.getRefreshToken());\n\t\trequestMap.put(\"client_id\", clientId);\n\t\trequestMap.put(\"client_secret\", clientSecret);\n\t\trequestMap.put(\"redirect_uri\", redirectUri);\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\theaders.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n\t\tHttpEntity<MultiValueMap<String, String>> request = new HttpEntity<MultiValueMap<String, String>>(requestMap, headers);\n\t\ttry {\n\t\t\tResponseEntity<String> response = restTemplate.postForEntity(authEndpoint, request, String.class);\n\t\t\tString body = response.getBody();\n\t\t\ttokenInfo.setToken(body);\n\t\t\ttokenInfo.setRefreshToken(getRefreshToken(body));\n\t\t\ttokenInfo.setTimestamp(currentTimeMillis());\n\t\t} catch (Exception e) {\n\t\t\tthrow new IllegalStateException(\"Error in refreshing token\", e);\n\t\t}\n}", "CodeBleu_score": 37.56494917906378}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\n        // Get the current timestamp\n        long currentTimeMillis = currentTimeMillis();\n\n        // Create a map with the credentials\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n\n        // Send the request to the authentication endpoint\n        ResponseEntity<String> response = postForEntity(AUTHENTICATION_URL, loginRequest);\n\n        // Get the response data\n        String responseBody = getBody(response);\n\n        // Parse the response data\n        JsonObject jsonObject = new JsonParser().parse(responseBody).getAsJsonObject();\n        String token = jsonObject.get(\"token\").getAsString();\n        long expires = jsonObject.get(\"expires\").getAsLong();\n\n        // Update the token information\n        setTokenInfo(token, currentTimeMillis + expires);\n\n        // Print the response data\n        System.out.println(\"Response: \" + responseBody);\n    }", "CodeBleu_score": 50.95164911718445}, {"code": " private void doLogin(){\n\t    try {\n        String timestamp = currentTimeMillis();\n        Map<String, Object> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        loginRequest.put(\"timestamp\", timestamp);\n        HttpEntity<Map<String, Object>> request = new HttpEntity<>(loginRequest);\n        ResponseEntity<Map<String, Object>> response = restTemplate.postForEntity(loginEndpoint, request, Map.class);\n        if (response.getStatusCode() == HttpStatus.OK) {\n            setTokenInfo(response.getBody());\n        } else {\n            throw new RuntimeException(\"Login failed with status: \" + response.getStatusCode());\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(\"Error while logging in\", e);\n    }\n}", "CodeBleu_score": 47.67439063867459}, {"code": " private void doLogin(){\n\t        try {\n            long currentTime = currentTimeMillis();\n            Map<String, String> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", username);\n            loginRequest.put(\"password\", password);\n            HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(loginRequest);\n            ResponseEntity<String> responseEntity = restTemplate.postForEntity(AUTHENTICATION_ENDPOINT, requestEntity, String.class);\n            String response = responseEntity.getBody();\n            setTokenInfo(response, currentTime);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Login failed\", e);\n        }\n    }", "CodeBleu_score": 54.139020511296124}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        return Optional.ofNullable(restTemplate.getForEntity(String.format(DEVICE_URL, deviceId.getId()), Device.class).getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode().equals(HttpStatus.NOT_FOUND)) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 43.009540456984006}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n                \"/api/device/\" + deviceId.getId(), Device.class);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 66.301046526476}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        return Optional.ofNullable(restTemplate.getForEntity(\n                \"http://localhost:8080/api/device/{deviceId}\",\n                Device.class, deviceId.getId()).getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 51.009054455104376}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpEntity<DeviceCredentials> request = new HttpEntity<>(credentials);\n        ResponseEntity<Device> response = restTemplate.postForEntity(\n                \"/api/device-with-credentials\",\n                request,\n                Device.class\n        );\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException.NotFoundException e) {\n        return Optional.empty();\n    }\n}", "CodeBleu_score": 45.764962672788876}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tHttpEntity<Device> entity = new HttpEntity<>(device);\n\tResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", entity, Device.class);\n\t\n\tswitch (response.getStatusCode()) {\n\t\tcase OK:\n\t\t\treturn Optional.of(response.getBody());\n\t\tcase NOT_FOUND:\n\t\t\treturn Optional.empty();\n\t\tdefault:\n\t\t\tthrow new RuntimeException(\"Unexpected HTTP status code: \" + response.getStatusCode());\n\t}\n}", "CodeBleu_score": 41.75470043057954}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(API_DEVICE_WITH_CREDENTIALS, request, Device.class);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode().equals(HttpStatus.NOT_FOUND)) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 60.70343483629301}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n        val = addr;\n        addr = null;\n    }\n    if (addr == null) {\n        for (let i = 0; i < this.length; i++) {\n            this[i].brightness(val);\n        }\n    } else {\n        this[addr].brightness(val);\n    }\n    return this;\n}", "CodeBleu_score": 50.71933070968524}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n        val = addr;\n        addr = null;\n    }\n    if (addr === null) {\n        for (let i = 0; i < this.length; i++) {\n            this.send(i, Math.round(val * 15 / 100));\n        }\n    } else {\n        this.send(addr, Math.round(val * 15 / 100));\n    }\n    return this;\n}", "CodeBleu_score": 54.67721403395949}, {"code": "brightness(addr, val){\n\t    if (arguments.length == 1) {\n        val = addr;\n        for (var i = 0; i < this.devices.length; i++) {\n            this.devices[i].brightness(val);\n        }\n    } else {\n        this.devices[addr].brightness(val);\n    }\n    return this;\n}", "CodeBleu_score": 49.64739757042178}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    const obj = {};\n    Object.getOwnPropertyNames(LedControl.prototype).forEach(key => {\n        obj[key] = this[key].bind(this, addr);\n    });\n    return obj;\n}", "CodeBleu_score": 38.5647372722295}, {"code": "device(addr){\n\t  const bound = {};\n  Object.getOwnPropertyNames(this).forEach(key => {\n    bound[key] = this[key].bind(this, addr);\n  });\n  Object.keys(LedControl.prototype).forEach(key => {\n    bound[key] = this[key].bind(this, addr);\n  });\n  return bound;\n}", "CodeBleu_score": 72.77552487499564}, {"code": "device(addr){\n\t  /**\n   * The function \"device\" creates an object with methods bound to a specific address.\nIt iterates over the keys from the prototype of \"LedControl\" and the own properties of the current object, binding each function to the given address.\nThe resulting object with bound methods is then returned.\n   */\n  const dev = {};\n  Object.keys(LedControl.prototype).forEach(key => {\n    /**\n     * The function \"device\" creates an object with methods bound to a specific address.\nIt iterates over the keys from the prototype of \"LedControl\" and the own properties of the current object, binding each function to the given address.\nThe resulting object with bound methods is then returned.\n     */\n    dev[key] = this[key].bind(this, addr);\n  });\n  Object.keys(this).forEach(key => {\n    /**\n     * The function \"device\" creates an object with methods bound to a specific address.\nIt iterates over the keys from the prototype of \"LedControl\" and the own properties of the current object, binding each function to the given address.\nThe resulting object with bound methods is then returned.\n     */\n    dev[key] = this[key].bind(this, addr);\n  });\n  return dev;\n}", "CodeBleu_score": 62.66484242020765}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\n    /**\n     * The function \"installCallbackReconciliation\" adds callback reconciliation methods to a target object for a given list of methods.\nFor each specified method, it creates a function that schedules the method to be called on each element in the collection, with a specified duration and callback.\nIf the duration is not provided, it defaults to 1000 milliseconds.\nIt ensures the callback is a function, collects promises for each method call, and invokes the callback once all promises are resolved.\n     * @param {Array} methods - the list of methods to add to the target object.\n     */\n    methods.forEach(method => {\n        /**\n         * The function \"installCallbackReconciliation\" adds callback reconciliation methods to a target object for a given list of methods.\nFor each specified method, it creates a function that schedules the method to be called on each element in the collection, with a specified duration and callback.\nIf the duration is not provided, it defaults to 1000 milliseconds.\nIt ensures the callback is a function, collects promises for each method call, and invokes the callback once all promises are resolved.\n         * @param {Number} duration - the duration to wait before calling the method on each element in the collection.\n         * @param {Function} callback - the callback function to invoke once all methods are called.\n         */\n        target[method] = (duration = 1000, callback = () => {}) => {\n            if (typeof callback !== 'function') {\n                callback = () => {};\n            }\n            const signals = [];\n            for (let i = 0; i < this.length; i++) {\n                const el = this[i];\n                const signal = el[method](duration);\n                signals.push(signal);\n            }\n            Promise.all(signals).then(() => {\n                callback();\n            });\n        };\n    });\n}", "CodeBleu_score": 44.62859228232824}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = (duration, callback) => {\n            if (!callback) {\n                callback = duration\n                duration = 1000\n            }\n            callback = typeof callback === 'function' ? callback : () => {}\n            const signals = []\n            this.forEach(i => {\n                signals.push(new Promise(resolve => {\n                    setTimeout(() => {\n                        this[i][method](resolve)\n                    }, duration)\n                }))\n            })\n            Promise.all(signals).then(() => {\n                callback()\n            })\n        }\n    })\n}", "CodeBleu_score": 38.79412151910404}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        const reconcile = (duration, callback) => {\n            const signals = [];\n            this.forEach(element => {\n                const promise = new Promise((resolve, reject) => {\n                    setTimeout(() => {\n                        try {\n                            element[method]();\n                            resolve();\n                        } catch (e) {\n                            reject(e);\n                        }\n                    }, duration);\n                });\n                signals.push(promise);\n            });\n            Promise.all(signals).then(() => callback());\n        };\n        target[method] = reconcile;\n    });\n}", "CodeBleu_score": 31.913260278228663}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t  var input = '';\n  this.io.serialRead(this.port, function(data) {\n    input += data;\n    var sentences = input.split('\\r\n');\n    for (var i = 0; i < sentences.length; i++) {\n      var sentence = sentences[i];\n      if (sentence.length > 0) {\n        this.parseNmeaSentence(sentence);\n      }\n    }\n    input = sentences[sentences.length - 1];\n  }.bind(this));\n}", "CodeBleu_score": 42.32775118510876}, {"code": "listen(){\n\t  let input = \"\";\n  let self = this;\n  this.io.serialRead(this.port, function(data) {\n    input += data.toString();\n    let sentences = input.split(\"\\r\n\");\n    for (let i = 0; i < sentences.length; i++) {\n      let sentence = sentences[i];\n      if (sentence.length > 0) {\n        self.parseNmeaSentence(sentence);\n      }\n    }\n    input = sentences[sentences.length - 1];\n  });\n}", "CodeBleu_score": 51.52047771016309}, {"code": "listen(){\n\t  var input = \"\";\n  var self = this;\n  var read = function() {\n    self.io.serialRead(function(data) {\n      if (data) {\n        input += data;\n        var sentences = input.split(\"\\r\n\");\n        for (var i = 0; i < sentences.length; i++) {\n          var sentence = sentences[i];\n          if (sentence.length > 0) {\n            self.parseNmeaSentence(sentence);\n          }\n        }\n        input = sentences[sentences.length - 1];\n        read();\n      }\n    });\n  };\n  read();\n}", "CodeBleu_score": 42.974157863806404}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tint num_channels = sequence->channels->mask_array[0] + 1;\n\tsize_t needed_buffer_size = num_channels * sizeof(uint16_t);\n\tsize_t buffer_size = sequence->options.extra_samplings * needed_buffer_size;\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size for sequence (%u/%u)\",\n\t\t\tsequence->buffer_size, buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.559573882181425}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_data *data = dev->data;\n\tint num_channels = 0;\n\tint buffer_size = 0;\n\n\tfor (int i = 0; i < sequence->channels->num_channels; i++) {\n\t\tif (sequence->channels->channel_id[i] < data->resolution) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tbuffer_size = num_channels * sequence->resolution;\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.39072703085953}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tint nb_channels = 0;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels->mask_array_size; i++) {\n\t\tif (sequence->channels->mask_array[i]) {\n\t\t\tnb_channels += 32;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < (nb_channels * sequence->resolution)) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->buffer_size = sequence->buffer_size;\n\n\treturn 0;\n}", "CodeBleu_score": 36.04855527571632}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tint ret;\n\tuint32_t channels;\n\tuint32_t resolution;\n\tuint32_t i;\n\tuint32_t j;\n\tuint32_t k;\n\tuint32_t buffer_size;\n\tuint32_t buffer_offset;\n\tuint32_t *buffer;\n\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_ad559x_config *config = dev->config;\n\n\t/* Check if the resolution matches the expected resolution */\n\tresolution = sequence->resolution;\n\tif (resolution != ADC_RESOLUTION) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the channels are valid */\n\tchannels = sequence->channels;\n\tfor (i = 0; i < ADC_NUM_CHANNELS; i++) {\n\t\tif ((channels & BIT(i)) && !(config->channels_bitmask & BIT(i))) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check if the buffer size is sufficient */\n\tbuffer_size = sequence->buffer_size;\n\tif (buffer_size < ADC_NUM_CHANNELS) {\n\t\tLOG_ERR(\"Buffer size insufficient\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Set the buffer */\n\tbuffer = sequence->buffer;\n\n\t/* Start the ADC read context */\n\tadc_context_start_read(&data->ctx, sequence);\n\n\t/* Wait for the ADC read operation to complete */\n\tadc_context_wait_for_completion(&data->ctx);\n\n\t/* Check the result of the ADC read operation */\n\tret = data->ctx.result;\n\tif (ret) {\n\t\tLOG_ERR(\"ADC read failed\");\n\t\treturn ret;\n\t}\n\n\t/* Copy the data to the buffer */\n\tfor (i = 0; i < ADC_NUM_CH", "CodeBleu_score": 49.588175635524806}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *cfg = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint i;\n\tint ret;\n\tuint8_t chan_mask;\n\tuint8_t chan_mask_bit;\n\tuint8_t chan_mask_bit_set;\n\tuint8_t chan_mask_bit_not_set;\n\tuint8_t chan_mask_bit_not_set_mask;\n\tuint8_t chan_mask_bit_set_mask;\n\tuint8_t chan_mask_bit_set_mask_not;\n\tuint8_t chan_mask_bit_set_mask_not_set;\n\tuint8_t chan_mask_bit_set_mask_set;\n\tuint8_t chan_mask_bit_set_mask_set_not;\n\tuint8_t chan_mask_bit_set_mask_set_not_set;\n\tuint8_t chan_mask_bit_set_mask_set_not_set_not;\n\tuint8_t chan_mask_bit_set_mask_set_not_set_not_set;\n\tuint8_t chan_mask_bit_set_mask_set_not_set_not_set_not;\n\tuint8_t chan_mask_bit_set_mask_set_not_set_not_set_not_set;\n\tuint8_t chan_mask_bit_set_mask_set_not_set_not_set_not_set_not;\n\tuint8_t chan_mask_bit_set_mask_set_not_set_not_set_not_set_not_set;\n\tuint8_t chan_mask_bit_set_mask_set_not_set_not_set_not_set_not_set_not;\n\tuint8_t chan_mask_bit_set_mask_set_not_set_not_set_not_set_not_set_not_set;\n\tuint8_t chan_mask_", "CodeBleu_score": 14.073911777469593}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    const struct adc_ad559x_config *cfg = dev->config;\n    struct adc_ad559x_data *data = dev->data;\n    int ret;\n\n    if (sequence->channels != data->channels) {\n        LOG_ERR(\"Channels mismatch\");\n        return -EINVAL;\n    }\n\n    if (sequence->resolution != data->resolution) {\n        LOG_ERR(\"Resolution mismatch\");\n        return -EINVAL;\n    }\n\n    ret = adc_ad559x_validate_buffer_size(sequence);\n    if (ret < 0) {\n        LOG_ERR(\"Buffer too small\");\n        return ret;\n    }\n\n    data->buffer = sequence->buffer;\n    data->buffer_size = sequence->buffer_size;\n\n    adc_context_start_read(&data->ctx, sequence);\n\n    ret = adc_context_wait_for_completion(&data->ctx);\n    if (ret) {\n        return ret;\n    }\n\n    return adc_ad559x_read_raw(dev, sequence);\n}", "CodeBleu_score": 67.72427774879768}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct device *dev = ctx->dev;\n\tstruct adc_data *data = ctx->data;\n\tint i;\n\n\t/* Set the channels to be sampled. */\n\tadc_context_update_buffer_pointers(ctx);\n\n\t/* Initialize the repeat buffer with the data buffer. */\n\tfor (i = 0; i < data->num_channels; i++) {\n\t\tdata->repeat_buffer[i] = data->buffer[i];\n\t}\n\n\t/* Release a semaphore to signal the start of sampling. */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 36.50237609275046}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->data;\n\tu8_t *repeat_buffer = data->repeat_buffer;\n\tu8_t *buffer = data->buffer;\n\tu8_t chan_count = data->chan_count;\n\tu8_t i;\n\n\tfor (i = 0; i < chan_count; i++) {\n\t\tdata->channels[i] = adc_context_get_channel(ctx, i);\n\t}\n\n\tdata->buffer_curr = 0;\n\tdata->repeat_buffer_curr = 0;\n\n\tfor (i = 0; i < chan_count; i++) {\n\t\trepeat_buffer[i] = buffer[i];\n\t}\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 39.81946090031588}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->data;\n\tuint8_t chan_mask = 0;\n\tuint8_t chan_idx;\n\tuint8_t chan_bit;\n\tuint8_t i;\n\tuint8_t j;\n\n\t/* Set channels to be sampled */\n\tfor (i = 0, j = 0; i < data->resolution; i++) {\n\t\tchan_bit = BIT(data->channels[j]);\n\t\tif (chan_mask & chan_bit) {\n\t\t\tj++;\n\t\t} else {\n\t\t\tchan_mask |= chan_bit;\n\t\t}\n\t}\n\n\t/* Initialize the repeat buffer with the data buffer */\n\tfor (i = 0; i < data->resolution; i++) {\n\t\tdata->repeat_buffer[i] = data->buffer[i];\n\t}\n\n\t/* Start sampling */\n\tadc_context_start_read(ctx);\n\n\t/* Set the channels to be sampled */\n\tfor (i = 0; i < ADC_CONTEXT_MAX_SAMPLES; i++) {\n\t\tchan_idx = i % data->resolution;\n\t\tchan_bit = BIT(data->channels[chan_idx]);\n\n\t\tif (chan_mask & chan_bit) {\n\t\t\tadc_context_set_channel(ctx, data->channels[chan_idx]);\n\t\t}\n\t}\n\n\t/* Release the semaphore to signal the start of sampling */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 36.87932255009054}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = &ctx->repeat_buffer[0];\n\t} else {\n\t\tctx->buffer = &ctx->buffer_pool[0];\n\t}\n}", "CodeBleu_score": 33.454263188068765}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = adc_get_data_container(ctx);\n\n\tif (repeat_sampling) {\n\t\tctx->buffer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tctx->buffer = adc_data_container->buffer;\n\t}\n}", "CodeBleu_score": 38.18636413718277}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data *data = ctx->data;\n\tdata->buffer = repeat_sampling ? data->repeat_buffer : data->buffer;\n}", "CodeBleu_score": 40.07461211962075}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_ad559x_channel_data *channel_data;\n\tstruct adc_ad559x_config *config = data->config;\n\tuint8_t channel_mask = 0;\n\tuint16_t channel_idx;\n\tint rc;\n\tint16_t value;\n\tint i;\n\n\twhile (1) {\n\t\t/* Wait for semaphore to be released */\n\t\trc = k_sem_take(&data->sem, K_FOREVER);\n\t\tif (rc != 0) {\n\t\t\tLOG_ERR(\"Failed to acquire semaphore\");\n\t\t\tdata->error_handler(data->dev, rc);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Iterate through active channels */\n\t\tfor (i = 0; i < ADC_AD559X_CHANNEL_COUNT; i++) {\n\t\t\tchannel_data = &data->channels[i];\n\t\t\tif (!channel_data->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchannel_idx = channel_data->channel_idx;\n\t\t\tchannel_mask |= BIT(channel_idx);\n\n\t\t\t/* Read channel */\n\t\t\trc = adc_ad559x_read_channel(data, channel_idx, &value);\n\t\t\tif (rc != 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d\", channel_idx);\n\t\t\t\tdata->error_handler(data->dev, rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Store result in buffer */\n\t\t\tdata->buffer[channel_idx] = value;\n\t\t}\n\n\t\t/* Signal that sampling is done */\n\t\tadc_context_on_sampling_done(&data->ctx, data->dev);\n\n\t\t/* Reset channel mask */\n\t\tchannel_mask = 0;\n\t}\n}", "CodeBleu_score": 38.758025218551936}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_context *ctx = &data->ctx;\n\tstruct adc_ad559x_channel_data *channels = data->channels;\n\tu8_t chan_count = data->chan_count;\n\tu8_t chan_idx;\n\tu8_t chan_mask;\n\tu8_t chan_lsb;\n\tu16_t chan_val;\n\tu16_t chan_val_lsb;\n\tu16_t chan_val_msb;\n\tu16_t chan_val_lsb_lsb;\n\tu16_t chan_val_lsb_msb;\n\tu16_t chan_val_msb_msb;\n\tu16_t chan_val_msb_lsb;\n\tu16_t chan_val_msb_lsb_lsb;\n\tu16_t chan_val_msb_lsb_msb;\n\tu16_t chan_val_lsb_lsb_lsb;\n\tu16_t chan_val_lsb_lsb_msb;\n\tu16_t chan_val_lsb_msb_lsb;\n\tu16_t chan_val_lsb_msb_msb;\n\tu16_t chan_val_msb_lsb_lsb_lsb;\n\tu16_t chan_val_msb_lsb_lsb_msb;\n\tu16_t chan_val_msb_lsb_msb_lsb;\n\tu16_t chan_val_msb_lsb_msb_msb;\n\tu16_t chan_val_lsb_msb_lsb_lsb;\n\tu16_t chan_val_lsb_msb_lsb_msb;\n\tu16_t chan_val_lsb_msb_msb_lsb;\n\tu16_t chan_val_lsb_", "CodeBleu_score": 11.382611030278111}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint8_t channel;\n\tuint8_t channel_num;\n\tuint8_t channel_num_mask;\n\tuint16_t adc_val;\n\tuint16_t adc_val_sum;\n\tuint16_t adc_val_avg;\n\tint ret;\n\tuint8_t i;\n\n\t/*\n\t * Get the channel number mask for all active channels.\n\t */\n\tchannel_num_mask = 0;\n\tfor (i = 0; i < ADC_AD559X_CHANNEL_COUNT; i++) {\n\t\tif (data->channels_active & BIT(i)) {\n\t\t\tchannel_num_mask |= BIT(i);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * Wait for a semaphore to be released.\n\t\t */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/*\n\t\t * Iterate through the active channels.\n\t\t */\n\t\tfor (channel = 0; channel < ADC_AD559X_CHANNEL_COUNT; channel++) {\n\t\t\tif (channel_num_mask & BIT(channel)) {\n\t\t\t\t/*\n\t\t\t\t * Read the ADC value.\n\t\t\t\t */\n\t\t\t\tret = adc_ad559x_read_channel(data, channel, &adc_val);\n\t\t\t\tif (ret) {\n\t\t\t\t\tLOG_ERR(\"Reading channel %d failed\", channel);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Mark the ADC context as complete.\n\t\t\t\t\t */\n\t\t\t\t\tadc_context_complete(&data->ctx, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Store the ADC value in the buffer.\n\t\t\t\t */\n\t\t\t\tdata->buffer[channel] = adc_val;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *", "CodeBleu_score": 40.82045126231265}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint ret;\n\tuint8_t reg_config;\n\tstruct ads1112_data *data = dev->data;\n\tstruct ads1112_config *config = dev->config;\n\n\t/* Wait for the device to be ready for data reading */\n\tk_sleep(K_USEC(config->drdy_delay_usec));\n\n\t/* Read the configuration register */\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_config);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to read configuration register\");\n\t\treturn ret;\n\t}\n\n\t/* Check the status of the device */\n\twhile (!(reg_config & ADS1112_CONFIG_DRDY)) {\n\t\tk_sleep(K_USEC(100));\n\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_config);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to read configuration register\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.30106386408893}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint ret;\n\tuint16_t reg_val;\n\tuint8_t ready_time;\n\tstruct ads1112_data *data = dev->data;\n\tstruct ads1112_config *config = dev->config;\n\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to read config register\");\n\t\treturn ret;\n\t}\n\n\tready_time = (reg_val & ADS1112_CFG_READY_MASK) >> ADS1112_CFG_READY_SHIFT;\n\n\tif (ready_time) {\n\t\tk_sleep(K_USEC(ready_time));\n\t}\n\n\twhile (1) {\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to read config register\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (reg_val & ADS1112_CFG_DRDY) {\n\t\t\tbreak;\n\t\t}\n\n\t\tk_sleep(K_USEC(100));\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 52.04616041634766}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    int ret;\n    uint8_t reg;\n    struct ads1112_data *data = ads1112_data_from_dev(dev);\n\n    /* Wait for the device to be ready for data reading */\n    k_sleep(K_USEC(data->ready_time));\n\n    /* Read the configuration register */\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n    if (ret) {\n        return ret;\n    }\n\n    /* Check the status */\n    if (reg & ADS1112_CONFIG_DRDY) {\n        return 0;\n    }\n\n    /* The device is not ready */\n    while (1) {\n        /* Wait 100 microseconds */\n        k_sleep(K_USEC(100));\n\n        /* Read the configuration register */\n        ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n        if (ret) {\n            return ret;\n        }\n\n        /* Check the status */\n        if (reg & ADS1112_CONFIG_DRDY) {\n            return 0;\n        }\n    }\n}", "CodeBleu_score": 54.12126343453947}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint required_buffer_size;\n\tint buffer_size;\n\tint i;\n\n\trequired_buffer_size = 0;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\trequired_buffer_size += sequence->options;\n\t}\n\n\tbuffer_size = adc_context_buffer_size(&sequence->dependent_channel_context);\n\n\tif (required_buffer_size > buffer_size) {\n\t\tLOG_ERR(\"Buffer size %d is insufficient for %d samplings\", buffer_size, required_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.43381063084704}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint ret = 0;\n\tint required_buffer_size = 0;\n\tint buffer_size = sequence->options.extra_samplings;\n\tint num_samplings = sequence->options.num_samplings;\n\n\trequired_buffer_size = num_samplings * sequence->channels * sizeof(uint32_t);\n\n\tif (buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"ADS1112: Insufficient buffer size (%d < %d)\", buffer_size, required_buffer_size);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 42.746350118075185}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint required_buffer_size = 0;\n\tint buffer_size = sequence->options->extra_samplings + 1;\n\tint num_samplings = sequence->options->extra_samplings + 1;\n\tint i = 0;\n\n\t/*\n\t * The buffer size is sufficient if the buffer size is greater than or equal to the required buffer size.\n\t */\n\tif (buffer_size >= required_buffer_size) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The buffer size is not sufficient.\n\t */\n\n\t/*\n\t * Calculate the required buffer size.\n\t */\n\tfor (i = 0; i < sequence->channels->num_channels; i++) {\n\t\trequired_buffer_size += num_samplings;\n\t}\n\n\t/*\n\t * Log an error message.\n\t */\n\tLOG_ERR(\"The buffer size is not sufficient. The required buffer size is %d.\", required_buffer_size);\n\n\t/*\n\t * Return an error code.\n\t */\n\treturn -EIO;\n}", "CodeBleu_score": 35.51015925296469}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = (struct ads1112_data *)dev->data;\n\tint ret = 0;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret != 0) {\n\t\tLOG_ERR(\"Invalid sequence.\");\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to start read.\");\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 62.80476081180596}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tconst struct ads1112_config *cfg = dev->config;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"ADS1112: Invalid sequence config\");\n\t\treturn ret;\n\t}\n\n\tadc_context_lock(&data->ctx, false, NULL);\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_len = sequence->buffer_length;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(&data->ctx);\n\t} else {\n\t\tret = adc_context_start_read(&data->ctx, sequence);\n\t}\n\n\tadc_context_release(&data->ctx, ret);\n\n\treturn ret;\n}", "CodeBleu_score": 63.83868109169934}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->channels == NULL) {\n\t\tLOG_ERR(\"No channels specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unsupported options\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->extra_samplings > 0) {\n\t\tLOG_ERR(\"Unsupported extra samplings\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling_ratio > 0) {\n\t\tLOG_ERR(\"Unsupported oversampling ratio\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < sequence->num_channels) {\n\t\tLOG_ERR(\"Buffer size is smaller than number of channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Unsupported resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\tLOG_ERR(\"Invalid sequence\");\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to start sampling\");\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 56.40003573292898}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\tstruct audio_codec_properties ac_prop;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tac_prop.gain = strtoul(argv[2], NULL, 0);\n\tac_prop.bias = strtoul(argv[3], NULL, 0);\n\tac_prop.mute = strtoul(argv[4], NULL, 0);\n\tac_prop.mic_mute = strtoul(argv[5], NULL, 0);\n\n\tret = audio_codec_apply_properties(dev, &ac_prop);\n\tif (ret) {\n\t\tshell_error(sh, \"Error applying properties\");\n\t} else {\n\t\tshell_print(sh, \"Properties applied\");\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 58.469006958015676}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\tint i;\n\tstruct audio_codec_properties props;\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -EINVAL;\n\t}\n\n\tprops.gain = (int16_t)atoi(argv[2]);\n\tprops.mute = (bool)atoi(argv[3]);\n\tprops.mic_gain = (int16_t)atoi(argv[4]);\n\tprops.mic_mute = (bool)atoi(argv[5]);\n\n\tfor (i = 6; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"mic_mute\") == 0) {\n\t\t\tprops.mic_mute = true;\n\t\t} else if (strcmp(argv[i], \"mic_gain\") == 0) {\n\t\t\tprops.mic_gain = (int16_t)atoi(argv[i + 1]);\n\t\t\ti++;\n\t\t} else if (strcmp(argv[i], \"mute\") == 0) {\n\t\t\tprops.mute = true;\n\t\t} else if (strcmp(argv[i], \"gain\") == 0) {\n\t\t\tprops.gain = (int16_t)atoi(argv[i + 1]);\n\t\t\ti++;\n\t\t} else {\n\t\t\tshell_error(sh, \"Unknown property %s\", argv[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = audio_codec_apply_properties(dev, &props);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t} else {\n\t\tshell_print(sh, \"Properties applied\");\n\t}\n\n\t", "CodeBleu_score": 49.76164353975507}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret;\n\tstruct device *dev;\n\tstruct audio_codec_properties *prop;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tprop = audio_codec_get_properties(dev);\n\tif (!prop) {\n\t\tshell_error(sh, \"Device %s does not support audio codec properties\", argv[1]);\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = audio_codec_apply_properties(dev, prop);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties to %s\", argv[1]);\n\t\treturn ret;\n\t}\n\n\tshell_print(sh, \"Properties applied to %s\", argv[1]);\n\treturn 0;\n}", "CodeBleu_score": 52.35364649685923}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct dmic_data *data = dev->data;\n\tint ret = 0;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\tret = i2s_trigger(data->i2s, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"DMIC not in configured state\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tret = i2s_trigger(data->i2s, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"DMIC not in active state\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"DMIC trigger command not supported\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 43.99030488119908}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\n\tint ret;\n\tstruct mpxxdtyy_data *data = dev->data;\n\tstruct mpxxdtyy_cfg *cfg = dev->config;\n\tuint8_t cmd_reg;\n\n\tLOG_DBG(\"Triggering device %s with command %d\", dev->name, cmd);\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"DMIC %s already active\", dev->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\t\tcmd_reg = I2S_CMD_START;\n\t\t\tret = i2s_reg_write(dev, I2S_CMD_REG, cmd_reg);\n\t\t\tif (ret != 0) {\n\t\t\t\tLOG_ERR(\"Failed to start device %s\", dev->name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tLOG_DBG(\"Started device %s\", dev->name);\n\t\t} else {\n\t\t\tLOG_ERR(\"DMIC %s not configured\", dev->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t\tcmd_reg = I2S_CMD_STOP;\n\t\t\tret = i2s_reg_write(dev, I2S_CMD_REG, cmd_reg);\n\t\t\tif (ret != 0) {\n\t\t\t\tLOG_ERR(\"Failed to stop device %s\", dev->name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tLOG_DBG(\"Stopped device %s\", dev->name);\n\t\t} else {\n\t\t\tLOG_ERR(\"DMIC %s", "CodeBleu_score": 59.22667339600971}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_dev_data *dev_data = DEV_DATA(dev);\n\tint ret = 0;\n\n\t/*\n\t * The device is in the error state.\n\t */\n\tif (dev_data->state == I2S_STATE_ERROR) {\n\t\tLOG_ERR(\"Device in error state\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * The device is in the idle state.\n\t */\n\tif (dev_data->state == I2S_STATE_IDLE) {\n\t\t/*\n\t\t * The device is being started.\n\t\t */\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\t/*\n\t\t\t * The device is in the configured state.\n\t\t\t */\n\t\t\tif (dev_data->state == I2S_STATE_CONFIGURED) {\n\t\t\t\t/*\n\t\t\t\t * Send the I2S start command.\n\t\t\t\t */\n\t\t\t\tret = mpxxdtyy_i2s_start(dev);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to start device\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Update the device state.\n\t\t\t\t */\n\t\t\t\tdev_data->state = I2S_STATE_ACTIVE;\n\t\t\t}\n\t\t\t/*\n\t\t\t * The device is in the active state.\n\t\t\t */\n\t\t\telse if (dev_data->state == I2S_STATE_ACTIVE) {\n\t\t\t\tLOG_ERR(\"Device already started\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * The device is being stopped.\n\t\t */\n\t\telse if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tLOG_ERR(\"Device already stopped\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\t/*\n\t * The device is in the configured state.", "CodeBleu_score": 43.144389148165565}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct aux_display_hd44780_data *data = dev->data;\n\tuint8_t command;\n\n\tif (aux_display_hd44780_get_config(dev, &data->config) != 0) {\n\t\tLOG_ERR(\"Could not retrieve configuration\");\n\t\treturn;\n\t}\n\n\tif (aux_display_hd44780_get_data(dev, &data->data) != 0) {\n\t\tLOG_ERR(\"Could not retrieve data\");\n\t\treturn;\n\t}\n\n\tcommand = data->config.display_mode;\n\n\tif (enabled) {\n\t\tcommand |= (data->config.cursor_blink ? HD44780_DISPLAY_MODE_CURSOR_BLINK : 0) |\n\t\t\t\t   (data->config.cursor_enabled ? HD44780_DISPLAY_MODE_CURSOR_ENABLED : 0) |\n\t\t\t\t   (data->config.cursor_position ? HD44780_DISPLAY_MODE_CURSOR_POSITION : 0);\n\t}\n\n\tif (aux_display_hd44780_set_command(dev, command) != 0) {\n\t\tLOG_ERR(\"Could not set display mode\");\n\t\treturn;\n\t}\n\n\tdata->display_mode_enabled = enabled;\n}", "CodeBleu_score": 47.2798604734519}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct aux_display_hd44780_data *data = dev->data;\n\tconst struct aux_display_hd44780_config *cfg = dev->config;\n\tuint8_t cmd = 0x00;\n\n\t/* Retrieve the current configuration from the device */\n\tauxdisplay_hd44780_get_config(dev);\n\n\t/* Set the display mode command */\n\tcmd = (data->display_mode & 0x03) | (data->cursor_mode & 0x03) | (data->blink_mode & 0x03);\n\n\t/* Set the display mode command */\n\tif (enabled) {\n\t\tcmd |= 0x04;\n\t}\n\n\t/* Send the command to the device */\n\tdata->write_command(dev, cmd);\n}", "CodeBleu_score": 38.23341680207036}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *cfg = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0x00;\n\tuint8_t display_mode = 0x00;\n\n\tif (enabled) {\n\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (data->blink_enabled) {\n\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_BLINK_ON;\n\t}\n\n\tif (data->cursor_position == AUXDISPLAY_HD44780_CURSOR_POSITION_RIGHT) {\n\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_RIGHT;\n\t}\n\n\tif (data->cursor_position == AUXDISPLAY_HD44780_CURSOR_POSITION_LEFT) {\n\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_LEFT;\n\t}\n\n\tif (data->display_shift == AUXDISPLAY_HD44780_DISPLAY_SHIFT_RIGHT) {\n\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_SHIFT_RIGHT;\n\t}\n\n\tif (data->display_shift == AUXDISPLAY_HD44780_DISPLAY_SHIFT_LEFT) {\n\t\tdisplay_mode |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_SHIFT", "CodeBleu_score": 59.1933603959805}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *cfg = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\n\tif (!cfg->busy_gpio_name) {\n\t\tLOG_ERR(\"Busy GPIO port not defined.\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tdata->busy_gpio = device_get_binding(cfg->busy_gpio_name);\n\tif (!data->busy_gpio) {\n\t\tLOG_ERR(\"Could not get pointer to busy GPIO device.\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tdata->busy_pin = gpio_pin_get_dt(data->busy_gpio, cfg->busy_gpio_pin);\n\tif (data->busy_pin < 0) {\n\t\tLOG_ERR(\"Could not get busy GPIO pin.\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get_dt(data->busy_gpio, cfg->busy_gpio_pin);\n}", "CodeBleu_score": 48.504245005095534}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\n\tif (!config->busy_gpio_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not get status of busy GPIO pin\");\n\t\treturn ret;\n\t}\n\n\tdata->busy = ret;\n\treturn 0;\n}", "CodeBleu_score": 60.98848030873412}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\n\tif (!config->busy_gpio_name) {\n\t\tLOG_ERR(\"busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_gpio_name, &data->busy_gpio);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"failed to get busy GPIO pin %s\", config->busy_gpio_name);\n\t\treturn ret;\n\t}\n\n\treturn gpio_pin_get_dt(config->busy_gpio_name, &data->busy_gpio);\n}", "CodeBleu_score": 57.82691092860468}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = (uint8_t)command;\n\tbuffer[1] = (uint8_t)command;\n\n\tret = i2c_write_dt(config->i2c_master, buffer, sizeof(buffer), config->i2c_slave_addr);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Error %d writing special command %d to LCD device\", ret, command);\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay));\n\n\treturn ret;\n}", "CodeBleu_score": 62.596725814922635}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\tuint8_t *pbuffer = buffer;\n\tint ret;\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tret = i2c_write_dt(data->i2c, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\tLOG_ERR(\"I2C write error: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tk_sleep(config->delay_after_special_command);\n\n\treturn ret;\n}", "CodeBleu_score": 60.206004530656855}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tret = i2c_write(data->i2c, buffer, 2, data->i2c_addr);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to write to I2C device\");\n\t\treturn ret;\n\t}\n\n\tk_sleep(data->special_command_delay);\n\n\treturn ret;\n}", "CodeBleu_score": 51.403502173641826}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = DEV_DATA(dev);\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size", "CodeBleu_score": 37.977669562455496}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_dev_data *dev_data = DEV_DATA(dev);\n\tint ret = 0;\n\n\tif (size > dev_data->size) {\n\t\tLOG_ERR(\"Invalid read size (%zu) requested\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\tLOG_ERR(\"Read operation exceeds memory bounds (offset %zu, size %zu)\",\n\t\t\toffset, size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->mem_size) {\n\t\tLOG_ERR(\"Read operation involves invalid memory (offset %zu, size %zu)\",\n\t\t\toffset, size);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, dev_data->mem + offset, size);\n\n\treturn ret;\n}", "CodeBleu_score": 52.81659743545062}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = DEV_DATA(dev);\n\tint ret = 0;\n\n\tif (offset + size > dev_data->size) {\n\t\tLOG_ERR(\"Read size exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\tLOG_ERR(\"Read size exceeds memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, dev_data->mem + offset, size);\n\n\treturn ret;\n}", "CodeBleu_score": 57.941703093752125}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_dev_cfg *const cfg = DEV_CFG(dev);\n\tstruct bbram_emul_dev_data *const data = DEV_DATA(dev);\n\tint ret = 0;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->bbram_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data->invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data->bbram + offset, data, size);\n\n\treturn ret;\n}", "CodeBleu_score": 60.45442283020057}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *emul = dev->data;\n\tint rc;\n\n\t/* Check if the write size is valid. */\n\trc = bbram_emul_check_write_size(size);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM. */\n\trc = bbram_emul_check_write_offset(dev, offset, size);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* Check if the BBRAM is in an invalid state. */\n\trc = bbram_emul_check_invalid(dev);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory. */\n\tmemcpy(&emul->mem[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 55.55431804722182}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = DEV_DATA(dev);\n\n\tif (size > dev_data->emul_data.size) {\n\t\tLOG_ERR(\"Invalid write size (%d)\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_data->emul_data.size) {\n\t\tLOG_ERR(\"Write out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev_data->emul_data.invalid) {\n\t\tLOG_ERR(\"Invalid BBRAM\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(dev_data->emul_data.mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 56.792442265833834}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint i;\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--device\") == 0) {\n\t\t\tif (i + 1 >= argc) {\n\t\t\t\tshell_error(sh, \"Invalid argument\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\t*bbram_dev = device_get_binding(argv[i + 1]);\n\t\t\tif (*bbram_dev == NULL) {\n\t\t\t\tshell_error(sh, \"Device not found\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tshell_error(sh, \"Missing argument\");\n\treturn -ENODEV;\n}", "CodeBleu_score": 52.9588356082152}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Device not specified\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!(*bbram_dev)) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 77.30380258484901}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\t/*\n\t * The function \"shell_error\" logs an error message and returns an error code.\n\t */\n\tint ret = shell_error(sh, argc, argv);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The function \"device_get_binding\" returns a pointer to the device structure for the device with the specified name.\n\t */\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.30971332992517}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tLOG_ERR\n\tuart_fifo_read\n\n", "CodeBleu_score": 5.5399637308688225}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tLOG_ERR\n\th4_read_hdr\n\n", "CodeBleu_score": 5.539824334738226}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct uart_h4_data *data = DEV_DATA(dev);\n\tuint8_t *hdr = data->hdr;\n\tuint32_t bytes_read = data->hdr_cnt;\n\tuint32_t bytes_to_read = data->hdr_len - bytes_read;\n\tuint32_t bytes_available = uart_fifo_read(dev, hdr + bytes_read, bytes_to_read);\n\n\tif (bytes_available != bytes_to_read) {\n\t\tLOG_ERR(\"Failed to read header data\");\n\t}\n\n\tdata->hdr_cnt += bytes_available;\n}", "CodeBleu_score": 34.22833795878357}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t ret = 0;\n\tsize_t read;\n\t\n\twhile (len > 0) {\n\t\tread = len > sizeof(buf) ? sizeof(buf) : len;\n\t\tret = uart_fifo_read(uart, buf, read);\n\t\tif (ret == 0) {\n\t\t\tLOG_ERR(\"Failed to read UART FIFO buffer\");\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= ret;\n\t}\n\t\n\treturn ret;\n}", "CodeBleu_score": 37.71600303042069}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tchar buf[33];\n\tsize_t read_len;\n\tsize_t i;\n\tuart_fifo_read(uart, buf, sizeof(buf), &read_len);\n\tif (read_len > len) {\n\t\tread_len = len;\n\t}\n\tfor (i = 0; i < read_len; i++) {\n\t\tif (buf[i] == '\\r') {\n\t\t\tread_len--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (read_len > 0) {\n\t\tLOG_ERR(\"Discarded %zu bytes\", read_len);\n\t}\n\treturn read_len;\n}", "CodeBleu_score": 46.97028230894945}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t tmp[33];\n\tsize_t read_bytes = 0;\n\tsize_t ret = 0;\n\twhile (read_bytes < len) {\n\t\tret = uart_fifo_read(uart, tmp, min(len - read_bytes, sizeof(tmp)));\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"h4_discard: uart_fifo_read failed\");\n\t\t\treturn 0;\n\t\t}\n\t\tread_bytes += ret;\n\t}\n\treturn read_bytes;\n}", "CodeBleu_score": 38.51939375826232}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tunsigned int highest = 0;\n\tunsigned int i;\n\tunsigned int count = 0;\n\tunsigned int enabled = 0;\n\tunsigned int prev_enabled = 0;\n\tunsigned int prev_highest = 0;\n\tunsigned int prev_count = 0;\n\n\tfor (i = 0; i < ZBUS_CHANNEL_MAX_OBSERVERS; i++) {\n\t\tif (chan->observers[i].priority == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chan->observers[i].enabled) {\n\t\t\tenabled++;\n\t\t\tif (chan->observers[i].priority < highest) {\n\t\t\t\thighest = chan->observers[i].priority;\n\t\t\t}\n\t\t}\n\n\t\tcount++;\n\t}\n\n\tif (enabled != prev_enabled || count != prev_count || highest != prev_highest) {\n\t\tchan->highest_observer_priority = highest;\n\t\tchan->observer_count = count;\n\t\tchan->enabled_observer_count = enabled;\n\t}\n}", "CodeBleu_score": 36.81436568876384}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tunsigned int i;\n\tunsigned int highest_observer_priority = 0;\n\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\n\tfor (i = 0; i < chan->observer_count; i++) {\n\t\tif (chan->observers[i].enabled) {\n\t\t\tif (chan->observers[i].priority > highest_observer_priority) {\n\t\t\t\thighest_observer_priority = chan->observers[i].priority;\n\t\t\t}\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = highest_observer_priority;\n\n\tk_spin_unlock(&chan->lock, key);\n}", "CodeBleu_score": 25.40156643377974}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint i;\n\tint highest = -1;\n\tstruct zbus_observer *observer;\n\t\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\t\n\tfor (i = 0; i < chan->observer_count; i++) {\n\t\tobserver = &chan->observers[i];\n\t\t\n\t\tif (observer->enabled && observer->priority > highest) {\n\t\t\thighest = observer->priority;\n\t\t}\n\t}\n\t\n\tchan->highest_observer_priority = highest;\n\t\n\tk_spin_unlock(&chan->lock, key);\n}", "CodeBleu_score": 26.348302021585557}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct chan_update_hop *update;\n    struct chan_update_hop *tmp;\n    HASH_ITER(hh, chan_update_hop_hash, update, tmp) {\n        if (obs == update->obs) {\n            update_channel_hop(update->chan, update->obs);\n            HASH_DEL(chan_update_hop_hash, update);\n            free(update);\n        }\n    }\n}", "CodeBleu_score": 22.5716286060857}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tchan_update_hop *chan_update_hop = (chan_update_hop *) obs->chan_update;\n\tchan_update_hop->update_all_channels(obs);\n}", "CodeBleu_score": 16.498146667596973}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel *ch;\n\tchan_update_hop *update;\n\tchan_update_hop *update_next;\n\tchan_update_hop *update_tmp;\n\tchan_update_hop *update_tmp2;\n\n\tchan_update_hop *update_list = NULL;\n\n\tchan_update_hop *update_list_tmp;\n\tchan_update_hop *update_list_tmp2;\n\n\tchan_update_hop *update_list_tmp3;\n\n\tchan_update_hop *update_list_tmp4;\n\n\tchan_update_hop *update_list_tmp5;\n\n\tchan_update_hop *update_list_tmp6;\n\n\tchan_update_hop *update_list_tmp7;\n\n\tchan_update_hop *update_list_tmp8;\n\n\tchan_update_hop *update_list_tmp9;\n\n\tchan_update_hop *update_list_tmp10;\n\n\tchan_update_hop *update_list_tmp11;\n\n\tchan_update_hop *update_list_tmp12;\n\n\tchan_update_hop *update_list_tmp13;\n\n\tchan_update_hop *update_list_tmp14;\n\n\tchan_update_hop *update_list_tmp15;\n\n\tchan_update_hop *update_list_tmp16;\n\n\tchan_update_hop *update_list_tmp17;\n\n\tchan_update_hop *update_list_tmp18;\n\n\tchan_update_hop *update_list_tmp19;\n\n\tchan_update_hop *update_list_tmp20;\n\n\tchan_update_hop *update_list_tmp21;\n\n\tchan_update_hop *update_list_tmp22;\n\n\tchan_update_hop *update_list_tmp23;\n\n\tchan_update_hop *update_list_tmp24;\n\n\tchan_update_hop *update_list_tmp", "CodeBleu_score": 9.231594001698246}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tassert(obs != NULL);\n\tassert(!k_is_in_isr());\n\tK_SPINLOCK_LOCK(obs->lock, K_FOREVER);\n\tobs->priority = K_LOWEST_THREAD_PRIO;\n\tupdate_all_channels_hop(obs);\n\tK_SPINLOCK_UNLOCK(obs->lock);\n\treturn 0;\n}", "CodeBleu_score": 49.68849790856746}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tK_ASSERT(obs != NULL);\n\tK_ASSERT(!k_is_in_isr());\n\n\tk_spinlock_key_t key = k_spin_lock(&_ZBUS_ASSERT);\n\n\tK_ASSERT(obs->priority >= K_LOWEST_THREAD_PRIO);\n\n\tk_spin_unlock(&_ZBUS_ASSERT, key);\n\n\tk_spinlock_key_t key2 = k_spin_lock(&obs->lock);\n\n\tobs->priority = K_LOWEST_THREAD_PRIO;\n\n\tk_spin_unlock(&obs->lock, key2);\n\n\tupdate_all_channels_hop(obs);\n\n\treturn 0;\n}", "CodeBleu_score": 49.392538665138034}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tassert(!k_is_in_isr());\n\tassert(obs != NULL);\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\tobs->priority = K_LOWEST_THREAD_PRIO;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&obs->lock, key);\n\treturn 0;\n}", "CodeBleu_score": 49.21178255486963}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint ret;\n\tk_spinlock_key_t key;\n\tk_timeout_t end;\n\tstruct zbus_chan_ctx *ctx;\n\tstruct zbus_chan_ctx *ctx_next;\n\tstruct zbus_chan_ctx *ctx_prev;\n\tstruct zbus_chan_ctx *ctx_head;\n\tstruct zbus_chan_ctx *ctx_tail;\n\tint is_in_isr;\n\tint is_in_isr_next;\n\tint is_in_isr_prev;\n\tint is_in_isr_head;\n\tint is_in_isr_tail;\n\tk_spinlock_key_t key_next;\n\tk_spinlock_key_t key_prev;\n\tk_spinlock_key_t key_head;\n\tk_spinlock_key_t key_tail;\n\tint is_in_isr_next_head;\n\tint is_in_isr_next_tail;\n\tint is_in_isr_prev_head;\n\tint is_in_isr_prev_tail;\n\tint is_in_isr_head_tail;\n\tint is_in_isr_next_head_tail;\n\tint is_in_isr_prev_head_tail;\n\tint is_in_isr_next_prev_head_tail;\n\tint is_in_isr_next_prev_head_tail_tail;\n\tint is_in_isr_next_prev_head_tail_tail_head;\n\tint is_in_isr_next_prev_head_tail_tail_head_tail;\n\tint is_in_isr_next_prev_head_tail_tail_head_tail_head;\n\tint is_in_isr_next_prev_head_tail_tail_head_tail_head_tail;\n\tint is_in_isr_next_prev_head_tail_tail_head_tail_head_tail_head;\n\tint is_in_isr_next_prev_head_tail_tail_head_tail_head_tail_head_", "CodeBleu_score": 6.872273988200382}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint ret;\n\tk_spinlock_key_t key;\n\tstruct zbus_channel *chan_p;\n\tstruct zbus_channel_notify_context *ctx;\n\tstruct zbus_channel_notify_context *ctx_p;\n\tstruct zbus_channel_notify_context *ctx_tmp;\n\tk_tid_t tid;\n\tstruct zbus_vded_exec_context *vded_ctx;\n\tstruct zbus_vded_exec_context *vded_ctx_p;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp;\n\tstruct zbus_vded_exec_context *vded_ctx_head;\n\tstruct zbus_vded_exec_context *vded_ctx_tail;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_head;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_tail;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_p;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_prev;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_next;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_tail_prev;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_tail_next;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_head_prev;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_head_next;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_tail_prev_p;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_tail_next_p;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_head_prev_p;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_head_next_p;\n\tstruct zbus_vded_exec_context *vded_ctx_tmp_", "CodeBleu_score": 6.4449640585814345}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tZBUS_ASSERT(chan);\n\tif (k_is_in_isr()) {\n\t\ttimeout = ZBUS_MIN(timeout, K_NO_WAIT);\n\t}\n\tstruct zbus_chan_context *ctx = &chan->ctx;\n\tctx->end_time = sys_timepoint_calc(timeout);\n\tctx->priority = k_current_get()->base.prio;\n\tzbus_chan_lock(chan);\n\tint err = zbus_chan_exec(chan);\n\tzbus_chan_unlock(chan);\n\treturn err;\n}", "CodeBleu_score": 37.277966984328856}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    if (enable) {\n        if (Int & IS_ETH_INT_NORMAL) {\n            ETH->INTEN |= Int;\n        } else if (Int & IS_ETH_INT_ABNORMAL) {\n            ETH->INTEN |= Int;\n        } else {\n            assert_param(IS_ETH_INT(Int));\n        }\n    } else {\n        if (Int & IS_ETH_INT_NORMAL) {\n            ETH->INTEN &= ~Int;\n        } else if (Int & IS_ETH_INT_ABNORMAL) {\n            ETH->INTEN &= ~Int;\n        } else {\n            assert_param(IS_ETH_INT(Int));\n        }\n    }\n}", "CodeBleu_score": 52.28221081978418}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t itmask = 0;\n\tuint32_t itmasknormal = 0;\n\tuint32_t itmaskabnormal = 0;\n\tuint32_t itmasknormal_old = 0;\n\tuint32_t itmaskabnormal_old = 0;\n\n\tif (enable) {\n\t\titmask = Int;\n\t} else {\n\t\titmask = ~Int;\n\t}\n\n\titmasknormal = itmask & IS_ETH_INT_NORMAL;\n\titmaskabnormal = itmask & IS_ETH_INT_ABNORMAL;\n\n\titmasknormal_old = ETH->IMR & IS_ETH_INT_NORMAL;\n\titmaskabnormal_old = ETH->IMR & IS_ETH_INT_ABNORMAL;\n\n\tif (itmasknormal) {\n\t\tETH->IMR |= itmasknormal;\n\t} else {\n\t\tETH->IMR &= itmasknormal_old;\n\t}\n\n\tif (itmaskabnormal) {\n\t\tETH->IMR |= itmaskabnormal;\n\t} else {\n\t\tETH->IMR &= itmaskabnormal_old;\n\t}\n\n}", "CodeBleu_score": 34.16586856683117}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    uint32_t itmask = 0;\n    uint32_t itmask_normal = 0;\n    uint32_t itmask_abnormal = 0;\n\n    /* Check the parameters */\n    assert_param(IS_ETH_INT(Int));\n    assert_param(IS_FUNC_STATE(enable));\n\n    itmask = Int;\n    itmask_normal = Int & ETH_INT_NORMAL;\n    itmask_abnormal = Int & ETH_INT_ABNORMAL;\n\n    if (enable) {\n        if (itmask_normal != 0) {\n            ETH->INTEN |= itmask_normal;\n        }\n        if (itmask_abnormal != 0) {\n            ETH->INTEN |= itmask_abnormal;\n        }\n    } else {\n        if (itmask_normal != 0) {\n            ETH->INTEN &= (~itmask_normal);\n        }\n        if (itmask_abnormal != 0) {\n            ETH->INTEN &= (~itmask_abnormal);\n        }\n    }\n}", "CodeBleu_score": 42.497119536624375}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\tpTxDesc = &(ETH_TxDesc[0]);\n\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\tif ((pTxDesc->Status & ETH_TX_DESC_OWN) == (uint32_t)RESET) {\n\t\t\treturn pTxDesc;\n\t\t}\n\n\t\tpTxDesc++;\n\n\t\tif (pTxDesc == (ETH_TX_DESC *)(ETH_TX_DESC_BASE + (ETH_TX_DESC_CNT * sizeof(ETH_TX_DESC)))) {\n\t\t\tpTxDesc = (ETH_TX_DESC *)(ETH_TX_DESC_BASE);\n\t\t}\n\t}\n\n\treturn (ETH_TX_DESC *)0;\n}", "CodeBleu_score": 45.037289256772105}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\tuint32_t status;\n\tpTxDesc = (ETH_TX_DESC *)ETH_BASE_ADDR->TDES0;\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\tstatus = pTxDesc->Status;\n\t\tif ((status & ETH_TX_DESC_OWN) == 0) {\n\t\t\treturn pTxDesc;\n\t\t}\n\t\tpTxDesc = (ETH_TX_DESC *)pTxDesc->NextDescAddr;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 48.9392748179081}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *txDesc;\n\tuint32_t txDescAddr;\n\n\ttxDescAddr = ETH->TX_DESC_LIST.ADDR;\n\ttxDesc = (ETH_TX_DESC *) txDescAddr;\n\n\twhile (txDesc->STATUS.OWN) {\n\t\ttxDescAddr = txDesc->NEXT_DESC_PTR.ADDR;\n\t\ttxDesc = (ETH_TX_DESC *) txDescAddr;\n\t}\n\n\treturn txDesc;\n}", "CodeBleu_score": 45.326978638032266}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n    RT_ASSERT(channel < CY_CSD_IDAC_CHANNEL_COUNT);\n\n    struct cyp_dac *dac = rt_container_of(device, struct cyp_dac, parent);\n    rt_err_t result = RT_EOK;\n\n    if (dac->initialized == RT_FALSE) {\n        result = cyp_dac_init(dac);\n        if (result != RT_EOK) {\n            LOG_E(\"cyp_dac_init failed, result = %d\", result);\n            return result;\n        }\n    }\n\n    result = Cy_CSDIDAC_OutputEnable(dac->base, channel, *value);\n    if (result != CY_CSD_SUCCESS) {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable failed, result = %d\", result);\n        return RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 55.68038179382978}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_err_t result;\n    struct cyp_dac *dac;\n    CY_DAC_CHANNEL_T cy_channel;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    dac = (struct cyp_dac *)device;\n    cy_channel = cyp_dac_get_channel(dac, channel);\n\n    if (cy_channel == CY_DAC_CHANNEL_NONE) {\n        LOG_E(\"Invalid channel number\");\n        return -RT_EINVAL;\n    }\n\n    result = Cy_CSDIDAC_OutputEnable(dac->base, cy_channel, *value);\n    if (result != CY_DAC_SUCCESS) {\n        LOG_E(\"Failed to enable DAC channel\");\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 56.29252001798876}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_err_t result = RT_EOK;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    struct cyp_dac *dac = (struct cyp_dac *)device;\n    struct cyp_dac_channel *channel_data = &dac->channels[channel];\n\n    if (channel_data->state == CYP_DAC_CHANNEL_STATE_DISABLED) {\n        result = RT_EIO;\n        LOG_E(\"dac channel %d is disabled\", channel);\n        goto exit;\n    }\n\n    if (channel_data->state == CYP_DAC_CHANNEL_STATE_CONVERTING) {\n        result = RT_EBUSY;\n        LOG_E(\"dac channel %d is converting\", channel);\n        goto exit;\n    }\n\n    channel_data->state = CYP_DAC_CHANNEL_STATE_CONVERTING;\n\n    if (Cy_CSDIDAC_OutputEnable(dac->base, channel_data->dac_channel, *value) != CY_CSD_SUCCESS) {\n        result = RT_EIO;\n        LOG_E(\"dac channel %d enable failed\", channel);\n        goto exit;\n    }\n\nexit:\n    return result;\n}", "CodeBleu_score": 45.36900948608268}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\n    int ret = 0;\n    int i = 0;\n\n    if (addr >= IFX_FLASH_END_ADDRESS) {\n        LOG_E(\"ifx_flash_read_32k: address is invalid. (0x%08X)\", addr);\n        ret = -RT_EINVAL;\n        goto exit;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *((rt_uint8_t *) addr + i);\n    }\n\n    ret = size;\n\nexit:\n    return ret;\n}", "CodeBleu_score": 50.58045415919161}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    rt_uint32_t *p;\n    rt_uint32_t *p_end;\n    rt_uint32_t *p_start;\n\n    if (addr + size > FLASH_END_ADDRESS) {\n        LOG_E(\"ifx_flash_read_32k: read outrange flash memory size! addr is (0x%p)\n\", (void *)addr);\n        return -RT_EINVAL;\n    }\n\n    p = (rt_uint32_t *)(addr);\n    p_end = p + (size / 4);\n    p_start = p;\n\n    for (i = 0; p < p_end; p++, i++) {\n        *(buf + i) = *p;\n    }\n\n    return i;\n}", "CodeBleu_score": 50.38281913644437}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\n\tint ret;\n\n\tif (addr + size > IFX_FLASH_32K_END_ADDR) {\n\t\tIFX_FLASH_LOG_E(\"Read operation would exceed flash memory's end address.\");\n\t\tret = -RT_EINVAL;\n\t} else {\n\t\tfor (rt_uint32_t i = 0; i < size; i++) {\n\t\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t\t}\n\t\tret = size;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 40.20097158610777}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    RT_ASSERT(cyhal_timer != RT_NULL);\n\n    return cyhal_timer_read(cyhal_timer);\n}", "CodeBleu_score": 60.17344775774032}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != NULL);\n    cyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n    RT_ASSERT(timer_obj != NULL);\n\n    return cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 55.60338906921367}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    RT_ASSERT(timer->parent.user_data != RT_NULL);\n\n    cyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(cyhal_timer);\n}", "CodeBleu_score": 60.3140487239221}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    rt_mutex_take(&dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.552057523136576}, {"code": "void dfs_lock(void){\n\t    rt_mutex_take(&dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.552057523136576}, {"code": "void dfs_lock(void){\n\t    rt_mutex_take(&dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.552057523136576}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fds[i].fd_inuse == 0) {\n            fdt->fds[i].fd_inuse = 1;\n            return i;\n        }\n    }\n    return fd_slot_expand(fdt);\n}", "CodeBleu_score": 30.41541101100338}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fd[i] == NULL) {\n            return i;\n        }\n    }\n\n    return fd_slot_expand(fdt);\n}", "CodeBleu_score": 26.88512446827223}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n    int fd;\n\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fd[i] == NULL) {\n            fd = i;\n            break;\n        }\n    }\n\n    if (i == fdt->maxfd) {\n        fd = fd_slot_expand(fdt);\n    }\n\n    return fd;\n}", "CodeBleu_score": 39.176999847095416}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0)\n        error = -error;\n\n    switch (error) {\n        case RT_EOK:\n            return \"RT_EOK\";\n        case RT_ERROR:\n            return \"RT_ERROR\";\n        case RT_ETIMEOUT:\n            return \"RT_ETIMEOUT\";\n        case RT_EFULL:\n            return \"RT_EFULL\";\n        case RT_EEMPTY:\n            return \"RT_EEMPTY\";\n        case RT_ENOMEM:\n            return \"RT_ENOMEM\";\n        case RT_ENOENT:\n            return \"RT_ENOENT\";\n        case RT_EINTR:\n            return \"RT_EINTR\";\n        case RT_EIO:\n            return \"RT_EIO\";\n        case RT_EINVAL:\n            return \"RT_EINVAL\";\n        case RT_ENOSYS:\n            return \"RT_ENOSYS\";\n        case RT_EBUSY:\n            return \"RT_EBUSY\";\n        case RT_EOK:\n            return \"RT_EOK\";\n        case RT_EBADID:\n            return \"RT_EBADID\";\n        case RT_EUSER:\n            return \"RT_EUSER\";\n        case RT_ENOUSER:\n            return \"RT_ENOUSER\";\n        case RT_TEMP_NOUSER:\n            return \"RT_TEMP_NOUSER\";\n        case RT_EBADDR:\n            return \"RT_EBADADDR\";\n        case RT_ENOTSUPPORT:\n            return \"RT_ENOTSUPPORT\";\n        case RT_ENOSUPPORT:\n            return \"RT_ENOSUPPORT\";\n        case RT_EUNKNOW:\n            return \"RT_EUNKNOW\";\n        default:\n            return \"EUNKNOW\";\n    }\n}", "CodeBleu_score": 35.363841830392005}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n\n    switch (error) {\n        case RT_ERR_NONE:\n            return \"RT_ERR_NONE\";\n        case RT_ERR_UNKNOWN:\n            return \"RT_ERR_UNKNOWN\";\n        case RT_ERR_NO_MEMORY:\n            return \"RT_ERR_NO_MEMORY\";\n        case RT_ERR_NOT_FOUND:\n            return \"RT_ERR_NOT_FOUND\";\n        case RT_ERR_INVALID_ARG:\n            return \"RT_ERR_INVALID_ARG\";\n        case RT_ERR_INVALID_STATE:\n            return \"RT_ERR_INVALID_STATE\";\n        case RT_ERR_INVALID_OPERATION:\n            return \"RT_ERR_INVALID_OPERATION\";\n        case RT_ERR_TIMEOUT:\n            return \"RT_ERR_TIMEOUT\";\n        case RT_ERR_WOULD_BLOCK:\n            return \"RT_ERR_WOULD_BLOCK\";\n        case RT_ERR_NOT_SUPPORTED:\n            return \"RT_ERR_NOT_SUPPORTED\";\n        case RT_ERR_ALREADY_INITIALIZED:\n            return \"RT_ERR_ALREADY_INITIALIZED\";\n        case RT_ERR_NOT_INITIALIZED:\n            return \"RT_ERR_NOT_INITIALIZED\";\n        case RT_ERR_BUSY:\n            return \"RT_ERR_BUSY\";\n        case RT_ERR_INVALID_CONFIG:\n            return \"RT_ERR_INVALID_CONFIG\";\n        case RT_ERR_INVALID_SIZE:\n            return \"RT_ERR_INVALID_SIZE\";\n        case RT_ERR_INVALID_ADDR:\n            return \"RT_ERR_INVALID_ADDR\";\n        case RT_ERR_INVALID_RANGE:\n            return \"RT_ERR_INVALID_RANGE\";\n        case RT_ERR_INVALID_RESOURCE:\n            return \"RT_", "CodeBleu_score": 31.580755226611103}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    switch (error) {\n        case RT_ERR_NONE:\n            return \"RT_ERR_NONE\";\n        case RT_ERR_UNKNOWN:\n            return \"RT_ERR_UNKNOWN\";\n        case RT_ERR_NOMEM:\n            return \"RT_ERR_NOMEM\";\n        case RT_ERR_NOT_FOUND:\n            return \"RT_ERR_NOT_FOUND\";\n        case RT_ERR_INVALID_ARG:\n            return \"RT_ERR_INVALID_ARG\";\n        case RT_ERR_INVALID_STATE:\n            return \"RT_ERR_INVALID_STATE\";\n        case RT_ERR_NOT_INITIALIZED:\n            return \"RT_ERR_NOT_INITIALIZED\";\n        case RT_ERR_NOT_SUPPORTED:\n            return \"RT_ERR_NOT_SUPPORTED\";\n        case RT_ERR_TIMEOUT:\n            return \"RT_ERR_TIMEOUT\";\n        case RT_ERR_BUSY:\n            return \"RT_ERR_BUSY\";\n        case RT_ERR_DRIVER:\n            return \"RT_ERR_DRIVER\";\n        case RT_ERR_DEVICE:\n            return \"RT_ERR_DEVICE\";\n        case RT_ERR_NO_RESOURCE:\n            return \"RT_ERR_NO_RESOURCE\";\n        case RT_ERR_SPI_BUSY:\n            return \"RT_ERR_SPI_BUSY\";\n        case RT_ERR_SPI_ERROR:\n            return \"RT_ERR_SPI_ERROR\";\n        case RT_ERR_SPI_NOT_FOUND:\n            return \"RT_ERR_SPI_NOT_FOUND\";\n        case RT_ERR_SPI_NOT_INITIALIZED:\n            return \"RT_ERR_SPI_NOT_INITIALIZED\";\n        case RT_ERR_SPI_NOT_SUPPORTED:\n            return \"RT_ERR_SPI_NOT", "CodeBleu_score": 31.66360886515229}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_spin_lock_irqsave(&idle_hook_lock);\n    int i;\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            idle_hook_list[i] = hook;\n            rt_spin_unlock_irqrestore(&idle_hook_lock);\n            return RT_EOK;\n        }\n    }\n    rt_spin_unlock_irqrestore(&idle_hook_lock);\n    return -RT_EFULL;\n}", "CodeBleu_score": 62.4919808924547}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_thread_idle_sethook_t *hook_list;\n    rt_thread_idle_sethook_t *hook_list_end;\n\n    hook_list = &_hook_list[0];\n    hook_list_end = &_hook_list[RT_THREAD_IDLE_HOOK_LIST_SIZE];\n    level = rt_hw_interrupt_disable();\n    while (hook_list < hook_list_end) {\n        if (hook_list->hook == RT_NULL) {\n            hook_list->hook = hook;\n            rt_hw_interrupt_enable(level);\n            return RT_EOK;\n        }\n        hook_list ++;\n    }\n    rt_hw_interrupt_enable(level);\n    return -RT_EFULL;\n}", "CodeBleu_score": 45.003686811727995}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_thread_idle_sethook_t *hook_ptr;\n    rt_thread_idle_sethook_t *tmp;\n\n    level = rt_hw_interrupt_disable();\n    hook_ptr = &_idle_hook[0];\n    tmp = &_idle_hook[0];\n    while (hook_ptr < &_idle_hook[RT_IDLE_HOOK_LIST_SIZE]) {\n        if (hook_ptr->hook == RT_NULL) {\n            hook_ptr->hook = hook;\n            break;\n        }\n        tmp++;\n        hook_ptr++;\n    }\n    rt_hw_interrupt_enable(level);\n    if (hook_ptr >= &_idle_hook[RT_IDLE_HOOK_LIST_SIZE]) {\n        return -RT_EFULL;\n    }\n    return RT_EOK;\n}", "CodeBleu_score": 40.14638876522192}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_spin_lock_irqsave(&idle_hook_lock);\n    rt_list_for_each_entry(idle_hook_list, rt_thread_idle_hook_t, node) {\n        if (idle_hook_list->hook == hook) {\n            idle_hook_list->hook = RT_NULL;\n            rt_spin_unlock_irqrestore(&idle_hook_lock);\n            return RT_EOK;\n        }\n    }\n    rt_spin_unlock_irqrestore(&idle_hook_lock);\n    return -RT_ERROR;\n}", "CodeBleu_score": 33.6332044242721}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_thread_idle_sethook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_idle_delhook(hook);\n    rt_thread_", "CodeBleu_score": 12.831814667648894}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_spin_lock_irqsave(&idle_hook_lock);\n    struct rt_thread *tid;\n    tid = rt_thread_self();\n    if (tid->idle_hook == hook) {\n        tid->idle_hook = RT_NULL;\n        rt_spin_unlock_irqrestore(&idle_hook_lock);\n        return RT_EOK;\n    }\n    rt_spin_unlock_irqrestore(&idle_hook_lock);\n    return -RT_ERROR;\n}", "CodeBleu_score": 29.632262254815522}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_list_t *list;\n    rt_list_t *next;\n\n    if (susp_list == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    rt_enter_critical();\n\n    list = susp_list->next;\n    while (list != susp_list) {\n        next = list->next;\n        thread = rt_list_entry(list, struct rt_thread, tlist);\n        list = next;\n\n        /* remove thread from suspend list */\n        rt_list_remove(list);\n\n        /* set error code */\n        thread->error = thread_error;\n\n        /* resume thread */\n        rt_thread_resume(thread);\n    }\n\n    rt_exit_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.502098043831886}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_list_t *susp_list_iter;\n\trt_thread_t thread;\n\n\t/* Lock scheduler */\n\trt_enter_critical();\n\n\t/* Dequeue all suspended threads from the suspension list */\n\twhile ((susp_list_iter = rt_list_pop_front(susp_list)) != RT_NULL) {\n\t\t/* Get thread */\n\t\tthread = rt_list_entry(susp_list_iter, struct rt_thread, tlist);\n\n\t\t/* Clear suspend list */\n\t\tthread->suspend_list = RT_NULL;\n\n\t\t/* Wake up thread */\n\t\trt_thread_resume(thread, thread_error);\n\t}\n\n\t/* Unlock scheduler */\n\trt_exit_critical();\n\n\t/* Return RT_EOK */\n\treturn RT_EOK;\n}", "CodeBleu_score": 37.9285438417133}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_list_t *node;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* Check if the suspension list is empty */\n    if (rt_list_isempty(susp_list)) {\n        return RT_EOK;\n    }\n\n    /* Start by ensuring the scheduler is unlocked */\n    rt_enter_critical();\n\n    /* Dequeue and wake up each suspended thread one by one */\n    for (node = susp_list->next; node != susp_list; node = node->next) {\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n\n        /* Dequeue the thread from the suspension list */\n        rt_list_remove(node);\n\n        /* Wake up the thread */\n        rt_thread_resume(thread, thread_error);\n    }\n\n    /* End by ensuring the scheduler is locked again */\n    rt_exit_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 41.83129830395191}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console;\n    rt_device_t new_console;\n\n    old_console = rt_console_get_device();\n    if (old_console != RT_NULL)\n    {\n        rt_device_close(old_console);\n    }\n\n    new_console = rt_device_find(name);\n    if (new_console != RT_NULL)\n    {\n        if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK)\n        {\n            rt_console_set_device(new_console);\n        }\n    }\n\n    return old_console;\n}", "CodeBleu_score": 55.81180913994317}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console_device;\n    rt_device_t new_console_device;\n    rt_err_t res;\n\n    old_console_device = rt_console_get_device();\n    if (old_console_device == RT_NULL)\n        return RT_NULL;\n\n    new_console_device = rt_device_find(name);\n    if (new_console_device == RT_NULL)\n        return RT_NULL;\n\n    if (old_console_device == new_console_device)\n        return old_console_device;\n\n    res = rt_device_close(old_console_device);\n    if (res != RT_EOK)\n        return RT_NULL;\n\n    res = rt_device_open(new_console_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (res != RT_EOK)\n        return RT_NULL;\n\n    rt_console_set_device(new_console_device);\n\n    return old_console_device;\n}", "CodeBleu_score": 55.01796409813385}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console, new_console;\n\n    old_console = rt_console_get_device();\n    if (old_console == RT_NULL)\n        return RT_NULL;\n\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL)\n        return old_console;\n\n    if (new_console == old_console)\n        return old_console;\n\n    if (old_console->type != RT_Device_Class_Char)\n        return old_console;\n\n    if (rt_device_close(old_console) != RT_EOK)\n        return old_console;\n\n    if (rt_device_open(new_console, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK)\n        return old_console;\n\n    rt_console_set_device(new_console);\n\n    return old_console;\n}", "CodeBleu_score": 54.04290989990096}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int length = 0;\n    rt_spinlock_t lock;\n    rt_object_t object;\n\n    /* get lock */\n    lock = rt_object_get_lock(type);\n    rt_spin_lock_irqsave(&lock);\n\n    /* get object list */\n    object = rt_object_get_first(type);\n    while (object != RT_NULL) {\n        length ++;\n        object = rt_object_get_next(object);\n    }\n\n    /* release lock */\n    rt_spin_unlock_irqrestore(&lock);\n\n    return length;\n}", "CodeBleu_score": 37.238959979734474}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    rt_spinlock_t lock;\n    int length;\n    rt_object_t object;\n    rt_list_t *list;\n\n    /* get the object list according to the object type */\n    list = &_object_list[type];\n\n    /* get the spinlock according to the object type */\n    lock = _object_lock[type];\n\n    /* lock interrupt */\n    rt_spin_lock_irqsave(lock);\n\n    /* get the length of the object list */\n    length = 0;\n    for (object = rt_list_entry(list->next, struct rt_object, list);\n            object != list;\n            object = rt_list_entry(object->list.next, struct rt_object, list))\n    {\n        length ++;\n    }\n\n    /* unlock interrupt */\n    rt_spin_unlock_irqrestore(lock);\n\n    return length;\n}", "CodeBleu_score": 40.92640090879597}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    rt_spinlock_t lock;\n    rt_object_t object;\n    rt_list_t *node;\n    int count = 0;\n\n    /* get spinlock */\n    lock = rt_object_get_spinlock(type);\n    rt_spin_lock_irqsave(&lock);\n\n    /* get the object list */\n    object = rt_object_get_first(type);\n    while (object != RT_NULL) {\n        count ++;\n        object = rt_object_get_next(object);\n    }\n\n    /* release spinlock */\n    rt_spin_unlock_irqrestore(&lock);\n\n    return count;\n}", "CodeBleu_score": 42.40659258199507}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_object_info_t object_info;\n\n    RT_ASSERT(object != RT_NULL);\n\n    /* call detach hook function */\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n    /* get object information */\n    object_info = object->object_info;\n\n    /* lock object */\n    rt_spin_lock_irqsave(&(object_info->spinlock));\n\n    /* remove object */\n    rt_list_remove(&(object->list));\n\n    /* unlock object */\n    rt_spin_unlock_irqrestore(&(object_info->spinlock));\n\n    /* set object type to zero */\n    object->type = 0;\n}", "CodeBleu_score": 51.29093863850209}, {"code": "void rt_object_detach(rt_object_t object){\n\t    RT_ASSERT(object != RT_NULL);\n    RT_OBJECT_HOOK_CALL(RT_OBJECT_DETACH_HOOK, object);\n    rt_object_get_information(object)->object_detach(object);\n}", "CodeBleu_score": 18.77733508484872}, {"code": "void rt_object_detach(rt_object_t object){\n\t    /* check object */\n    RT_ASSERT(object != RT_NULL);\n\n    /* invoke detach hook */\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, object);\n\n    /* get object information */\n    struct rt_object_information *information = &_object_information[object->type];\n\n    /* lock object spinlock */\n    rt_spin_lock_irqsave(&(information->spinlock));\n\n    /* remove object from object list */\n    rt_list_remove(&(object->list));\n\n    /* unlock object spinlock */\n    rt_spin_unlock_irqrestore(&(information->spinlock));\n\n    /* set object type to zero */\n    object->type = RT_Object_Class_Static;\n}", "CodeBleu_score": 49.81182183376324}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result;\n    rt_custom_object_t cobj;\n    rt_bool_t is_valid;\n\n    /* check if the object is valid */\n    is_valid = rt_object_is_valid(obj);\n    if (is_valid == RT_FALSE) return -RT_ERROR;\n\n    /* check if the object is of the custom object class type */\n    if (obj->type != RT_Object_Class_Custom) return -RT_ERROR;\n\n    cobj = (rt_custom_object_t)obj;\n\n    /* call the destroy method if there is one */\n    if (cobj->destroy != RT_NULL) {\n        result = cobj->destroy(cobj);\n    } else {\n        result = RT_EOK;\n    }\n\n    /* delete the object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 48.246344040718455}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_ERR_NONE;\n    rt_custom_object_t cobj = (rt_custom_object_t) obj;\n\n    if (cobj->class != RT_Object_Class_Custom)\n        return RT_ERR_INVALID_ARG;\n\n    if (cobj->destroy)\n        result = cobj->destroy(cobj);\n\n    rt_object_delete(cobj);\n    return result;\n}", "CodeBleu_score": 51.87975407619785}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result;\n\trt_custom_object_t cobj;\n\n\tRT_ASSERT(obj != RT_NULL);\n\tRT_ASSERT(obj->ops != RT_NULL);\n\tRT_ASSERT(obj->ops->type == RT_Object_Class_Custom);\n\n\tcobj = (rt_custom_object_t)obj;\n\n\tif (cobj->ops->destroy != RT_NULL) {\n\t\tresult = cobj->ops->destroy(obj);\n\t\tif (result != RT_EOK) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\trt_object_delete(obj);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 45.77694159272344}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n    rt_ubase_t level;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical */\n    level = rt_enter_critical();\n\n    /* thread cleanup */\n    rt_thread_cleanup(thread);\n\n    /* leave critical */\n    rt_exit_critical(level);\n\n    /* add to defunct thread list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* trigger a context switch to next thread */\n    rt_schedule();\n}", "CodeBleu_score": 66.62495534550649}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t self = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* thread exit */\n    rt_thread_close(self);\n\n    /* exit critical */\n    rt_exit_critical();\n\n    /* trigger a context switch */\n    rt_schedule();\n}", "CodeBleu_score": 25.939119094951472}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t self;\n    rt_ubase_t level;\n\n    self = rt_thread_self();\n    /* enter critical */\n    level = rt_enter_critical();\n\n    /* thread exit */\n    rt_thread_close(self);\n\n    /* leave critical */\n    rt_exit_critical_safe(level);\n\n    /* schedule */\n    rt_schedule();\n}", "CodeBleu_score": 35.49410913332089}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t)parameter;\n    rt_err_t result;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n    /* lock scheduler */\n    result = rt_enter_critical();\n    if (result == RT_EOK) {\n        /* set error number */\n        thread->error = RT_ETIMEOUT;\n\n        /* remove from suspend list */\n        rt_list_remove(&(thread->tlist));\n\n        /* insert to ready list */\n        rt_list_insert_after(&(thread->tlist), &(thread->scheduler->ready_list));\n\n        /* unlock scheduler */\n        rt_exit_critical();\n\n        /* reschedule */\n        rt_schedule();\n    }\n}", "CodeBleu_score": 43.265671569968866}, {"code": "static void _thread_timeout(void *parameter){\n\t\tRT_ASSERT(parameter != RT_NULL);\n\trt_thread_t thread = (rt_thread_t) parameter;\n\tRT_ASSERT(thread->error == RT_EOK);\n\tRT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\trt_sched_lock();\n\tthread->error = -RT_ETIMEOUT;\n\trt_list_remove(&(thread->tlist));\n\trt_sched_insert_thread(thread);\n\trt_sched_unlock_n_resched();\n}", "CodeBleu_score": 49.94914923870673}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread;\n    RT_ASSERT(parameter != RT_NULL);\n    thread = (rt_thread_t)parameter;\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n    thread->error = -RT_ETIMEOUT;\n    rt_sched_lock();\n    rt_list_remove(&(thread->tlist));\n    rt_list_insert_after(&(thread->tlist), &(thread->scheduler->ready_list));\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 44.24337537299584}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_mutex_t mutex;\n\trt_uint8_t state;\n\trt_list_t *l;\n\trt_list_t *l_next;\n\trt_list_t *l_safe;\n\trt_list_t *l_safe_next;\n\trt_base_t level;\n\trt_base_t irq_level;\n\trt_base_t irq_level_old;\n\trt_thread_t t;\n\trt_thread_t t_next;\n\trt_thread_t t_safe;\n\trt_thread_t t_safe_next;\n\trt_thread_t t_self;\n\trt_base_t need_schedule;\n\trt_base_t need_schedule_old;\n\trt_uint8_t mutex_detached;\n\trt_uint8_t mutex_detached_old;\n\trt_uint8_t mutex_detached_all;\n\trt_uint8_t mutex_detached_all_old;\n\trt_uint8_t mutex_detached_all_done;\n\trt_uint8_t mutex_detached_done;\n\trt_uint8_t mutex_detached_done_old;\n\n\tt_self = rt_thread_self();\n\tif (t_self == thread) {\n\t\trt_kprintf(\"thread detach itself", "CodeBleu_score": 16.755119168805084}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_mutex_t mutex;\n    rt_list_t *list;\n    rt_list_t *next;\n    rt_uint32_t state;\n    rt_uint32_t irq_level;\n    RT_DEBUG_NOT_IN_INTERRUPT;\n    /* lock the thread's spinlock */\n    state = rt_spin_lock_irqsave(&(thread->lock));\n    /* is thread waiting on a mutex? */\n    if (thread->state == RT_THREAD_STATE_MUTEX_WAITING) {\n        /* get the mutex object */\n        mutex = thread->waiting_mutex;\n        /* remove the thread from the mutex's waiting list */\n        list = &(mutex->owner_thread);\n        rt_list_remove(list, &(thread->tlist));\n        /* clear the pending object */\n        thread->waiting_mutex = RT_NULL;\n        /* set the thread state */\n        thread->state = RT_THREAD_STATE_READY;\n        /* wakeup thread */\n        rt_thread_wakeup(thread);\n    }\n    /* is thread taking mutexes? */\n    if (!rt_list_isempty(&(thread->holding_mutex))) {\n        /* restore the spinlock */\n        rt_spin_unlock_irqrestore(&(thread->lock), state);\n        /* take the thread's spinlock */\n        irq_level = rt_hw_interrupt_disable();\n        /* detach the thread from all mutexes */\n        for (list = rt_list_get_first(&(thread->holding_mutex)); list != &(thread->holding_mutex); list = next) {\n            next = rt_list_get_next(list);\n            /* get the mutex object */\n            mutex = rt_list_entry(list, struct rt_mutex, holder_thread);\n            /* remove the thread from the mutex's holding list */\n            rt_list_remove(list);\n            /* clear the pending object", "CodeBleu_score": 46.983040675295676}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_mutex_t mutex;\n    rt_spinlock_t lock;\n    rt_uint8_t level;\n    rt_list_t *l;\n    rt_list_t *l_next;\n    rt_thread_t t;\n    rt_thread_t owner;\n    rt_uint8_t owner_level;\n    rt_uint8_t self_level;\n    rt_list_t *wait_list;\n    rt_list_t *wait_list_end;\n    rt_uint8_t wait_list_level;\n    rt_uint8_t wait_list_level_max;\n    rt_uint8_t wait_list_level_min;\n    rt_uint8_t wait_list_level_next;\n    rt_uint8_t wait_list_level_prev;\n    rt_list_t *wait_list_next;\n    rt_list_t *wait_list_prev;\n    rt_list_t *wait_list_start;\n    rt_list_t *wait_list_tail;\n\n    /*\n     * The function \"_thread_detach_from_mutex\" detaches a thread from any mutex it is waiting on or has taken.", "CodeBleu_score": 17.770468425999912}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->type == RT_Object_Class_Thread);\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread: %s, priority: %d\n\", thread->name, thread->current_priority));\n    RT_OBJECT_HOOK_CALL(rt_object_attach_sethook, (thread));\n    /* set thread priority attributes */\n    rt_sched_pri_set(thread);\n    /* reset thread stat */\n    thread->stat = RT_THREAD_SUSPEND;\n    /* resume thread */\n    result = rt_thread_resume(thread);\n    /* start scheduler if enabled */\n    if (result == RT_EOK)\n    {\n        rt_schedule();\n    }\n    return result;\n}", "CodeBleu_score": 50.16047984039126}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"start thread:%.*s with priority:%d\n\", RT_NAME_MAX, thread->name, thread->current_priority));\n    RT_OBJECT_HOOK_CALL(rt_object_attach_sethook, (&(thread->parent.parent)));\n    thread->stat = RT_THREAD_SUSPEND;\n    thread->error = RT_EOK;\n    thread->suspend_tick = 0;\n    thread->remaining_tick = 0;\n    thread->sp = (rt_uint32_t)thread->stack_addr + thread->stack_size;\n    thread->cleanup = RT_NULL;\n    thread->stat = RT_THREAD_READY;\n    result = rt_schedule();\n    return result;\n}", "CodeBleu_score": 43.109852818575746}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"startup thread:%.*s with priority:%d\n\", RT_NAME_MAX, thread->name, thread->current_priority));\n    RT_OBJECT_HOOK_CALL(rt_object_attach_sethook, (&(thread->parent.parent)));\n    thread->stat = RT_THREAD_SUSPEND;\n    thread->sp = (rt_uint8_t *)thread->stack_addr + thread->stack_size;\n    thread->cleanup = RT_NULL;\n    thread->error = RT_EOK;\n    thread->state = RT_THREAD_INIT;\n    thread->remaining_tick = 0;\n    thread->suspend_tick = 0;\n    thread->stat = RT_THREAD_READY;\n    result = rt_schedule();\n    return result;\n}", "CodeBleu_score": 41.920756552118824}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_timer_entry_t timer_entry;\n    rt_timer_entry_t *timer_entry_ptr;\n    rt_list_t *list_ptr;\n    rt_tick_t timeout_tick_temp;\n\n    if (rt_list_isempty(timer_list)) {\n        return -RT_ERROR;\n    }\n\n    list_ptr = timer_list;\n    timer_entry_ptr = rt_list_entry(list_ptr, rt_timer_entry_t, list);\n    timer_entry = *timer_entry_ptr;\n    timeout_tick_temp = timer_entry->timeout_tick;\n\n    while (timeout_tick_temp == 0) {\n        if (list_ptr == timer_list) {\n            return -RT_ERROR;\n        }\n\n        list_ptr = list_ptr->next;\n        timer_entry_ptr = rt_list_entry(list_ptr, rt_timer_entry_t, list);\n        timer_entry = *timer_entry_ptr;\n        timeout_tick_temp = timer_entry->timeout_tick;\n    }\n\n    *timeout_tick = timeout_tick_temp;\n\n    return RT_EOK;\n}", "CodeBleu_score": 41.456376679778884}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *list;\n    rt_timer_entry_t timer;\n    rt_tick_t tick;\n\n    list = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n    timer = list_entry(list->next, struct rt_timer_entry, list);\n    tick = timer->timeout;\n    if (tick < *timeout_tick) {\n        *timeout_tick = tick;\n    }\n    return RT_EOK;\n}", "CodeBleu_score": 49.877596184437955}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_timer_entry_t timer_entry;\n    rt_tick_t timeout;\n\n    if (!rt_list_isempty(timer_list)) {\n        timer_entry = rt_list_entry(timer_list->next, struct rt_timer_entry, list);\n        timeout = timer_entry->timeout;\n        if (timeout < *timeout_tick) {\n            *timeout_tick = timeout;\n        }\n        return RT_EOK;\n    }\n    return -RT_ERROR;\n}", "CodeBleu_score": 52.52376646387725}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n    register rt_ubase_t temp;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    /* allocate object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) return RT_NULL;\n\n    /* initialize object */", "CodeBleu_score": 43.58909350429488}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n    rt_err_t   result;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check name */\n    if (name == RT_NULL) return RT_NULL;\n\n    /* check timeout function */\n    if (timeout == RT_NULL) return RT_NULL;\n\n    /* check time */\n    if (time < RT_TICK_PER_SECOND) return RT_NULL;\n\n    /* create timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) return RT_NULL;\n\n    /* initialize timer object */\n    timer->parent.type = RT_Object_Class_Timer;\n    timer->parent.identifier = RT_Object_Timer;\n    timer->timeout_func = timeout;\n    timer->parent.clean_func = RT_NULL;\n    timer->parent.user_data = parameter;\n    timer->init_tick = time;\n    timer->timeout_tick = time;\n    timer->parent.flag = flag;\n    timer->parent.name = name;\n    timer->parent.blk_obj.flag = RT_BLK_OBJ_FLAG_STATIC;\n\n    /* initialize timer */\n    result = _timer_init(timer);\n    if (result != RT_EOK)\n    {\n        rt_object_delete(&(timer->parent));\n\n        return RT_NULL;\n    }\n\n    return timer;\n}", "CodeBleu_score": 46.37115025094518}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check name */\n    if (name == RT_NULL)\n        return RT_NULL;\n\n    /* check timeout function */\n    if (timeout == RT_NULL)\n        return RT_NULL;\n\n    /* check time */\n    if (time == 0)\n        return RT_NULL;\n\n    /* create timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    /* initialize timer */\n    timer->timeout_func = timeout;\n    timer->parameter    = parameter;\n    timer->init_tick    = time;\n    timer->timeout_tick = time;\n    timer->flag         = flag;\n\n    /* set timer status */\n    timer->parent.flag  = RT_Object_Flag_Static;\n    timer->parent.type  = RT_Object_Class_Timer;\n    timer->parent.ref   = 0;\n    timer->parent.clean_lock = 0;\n\n    return timer;\n}", "CodeBleu_score": 47.86972830669928}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", rec.Code)\n\t\treturn\n\t}\n\thandler := a.router.Handler(req)\n\tif handler == nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\thandler.ServeHTTP(res, req)\n}", "CodeBleu_score": 68.67838086708359}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tstatus := rec.Code\n\tif status == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", status)\n\t\treturn\n\t}\n\tif status != http.StatusOK {\n\t\thttp.Error(res, rec.Body.String(), status)\n\t\treturn\n\t}\n\thandler := a.router.Handler(req.URL.Path)\n\tif handler == nil {\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\thandler.ServeHTTP(res, req)\n}", "CodeBleu_score": 61.24162652867366}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tstatus := rec.Code\n\tif status == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", status)\n\t\treturn\n\t}\n\tres.WriteHeader(status)\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 54.4912693532637}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the requested asset from the URL path.\n\tasset := req.URL.Path[1:]\n\n\t// Check for errors.\n\tif asset == \"\" {\n\t\thttp.Error(res, \"No asset specified.\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Retrieve the asset.\n\tcontent, err := a.assets.Get(asset)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the appropriate Content-Type header based on the file extension.\n\tif strings.HasSuffix(asset, \".js\") {\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\t} else if strings.HasSuffix(asset, \".css\") {\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\t} else if strings.HasSuffix(asset, \".html\") {\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t} else {\n\t\thttp.Error(res, \"Unknown file extension.\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Write the asset content to the response.\n\tres.Write(content)\n}", "CodeBleu_score": 56.478464922245486}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif len(path) > 1 {\n\t\tif path[len(path)-1] == '/' {\n\t\t\tpath = path[:len(path)-1]\n\t\t}\n\t}\n\tif path == \"\" {\n\t\tpath = \"/\"\n\t}\n\tparts := strings.Split(path, \"/\")\n\tif len(parts) > 3 {\n\t\thttp.Error(res, \"404 Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tif len(parts) == 3 {\n\t\tif parts[2] == \"favicon.ico\" {\n\t\t\thttp.Error(res, \"404 Not Found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tif parts[2] == \"robots.txt\" {\n\t\t\thttp.Error(res, \"404 Not Found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t}\n\tif len(parts) == 2 {\n\t\tif parts[1] == \"favicon.ico\" {\n\t\t\thttp.Error(res, \"404 Not Found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tif parts[1] == \"robots.txt\" {\n\t\t\thttp.Error(res, \"404 Not Found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t}\n\tif len(parts) == 1 {\n\t\tif parts[0] == \"favicon.ico\" {\n\t\t\thttp.Error(res, \"404 Not Found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tif parts[0] == \"robots.txt\" {\n\t\t\thttp.Error(res, \"404 Not Found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t}\n\tif len(parts) == 0 {\n\t\thttp.Error(res, \"404 Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tif len(parts) > 3 {\n\t\thttp.Error(res, \"4", "CodeBleu_score": 37.609175091252126}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// get the requested asset\n\tasset, err := a.Asset(req.URL.Path)\n\tif err != nil {\n\t\t// if an error occurs, return a 404 error\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// set the appropriate Content-Type header based on the file extension\n\text := strings.Split(req.URL.Path, \".\")[1]\n\tswitch ext {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t// write the asset content to the response\n\tres.Write(asset)\n}", "CodeBleu_score": 60.206310764842065}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL.\n\trobotName := req.URL.Query().Get(\":robot\")\n\t// Find the robot with the specified name.\n\trobot, found := a.master.Robot(robotName)\n\tif !found {\n\t\t// If the robot is not found, return a JSON error message indicating that no robot was found with the specified name.\n\t\ta.writeJSON(res, http.StatusNotFound, a.newErrorResponse(fmt.Errorf(\"no robot found with name %s\", robotName)))\n\t\treturn\n\t}\n\t// Gather the connections of the robot.\n\tconnections := robot.Connections()\n\t// Convert the connections to JSON format.\n\tconnectionsJSON, err := a.newConnectionsResponse(connections)\n\tif err != nil {\n\t\t// If an error occurs, return a JSON error message indicating that the connections could not be converted to JSON format.\n\t\ta.writeJSON(res, http.StatusInternalServerError, a.newErrorResponse(err))\n\t\treturn\n\t}\n\t// Write the JSON response containing the connections.\n\ta.writeJSON(res, http.StatusOK, connectionsJSON)\n}", "CodeBleu_score": 37.80143850156339}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL.\n\tname := req.URL.Query().Get(\":name\")\n\n\t// Find the robot using the master instance.\n\trobot, err := a.master.Robot(name)\n\tif err != nil {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name.\n\t\ta.writeJSON(res, http.StatusNotFound, gobot.JSON{\n\t\t\t\"error\": \"no robot found with name \" + name,\n\t\t})\n\t\treturn\n\t}\n\n\t// Gather the robot's connections.\n\tconnections := robot.Connections()\n\n\t// Iterate over the connections and append the connection name to the JSON response.\n\tconnectionsJSON := make([]gobot.JSON, len(connections))\n\tfor i, connection := range connections {\n\t\tconnectionsJSON[i] = gobot.JSON{\n\t\t\t\"name\": connection.Name(),\n\t\t}\n\t}\n\n\t// Write the JSON response containing the connections.\n\ta.writeJSON(res, http.StatusOK, gobot.JSON{\n\t\t\"connections\": connectionsJSON,\n\t})\n}", "CodeBleu_score": 50.03705480686856}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\tname := strings.TrimPrefix(req.URL.Path, \"/api/connections/\")\n\n\t// Find the robot using the master instance.\n\trobot, ok := a.master.Robot(name)\n\tif !ok {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name.\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\n\t// Gather the robot's connections.\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format.\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\tlog.Printf(\"error: %v\n\", err)\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": \"could not marshal connections\"})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections.\n\ta.writeJSON(res, http.StatusOK, string(connectionsJSON))\n}", "CodeBleu_score": 35.045822282964835}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif u, p, ok := r.BasicAuth(); !ok || u != username || p != password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.26280602436517}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if the request has an authorization header\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\t// If it doesn't, set the \"WWW-Authenticate\" header and return a 401 response\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\t// If it does, decode the username and password\n\t\tdecoded, err := base64.StdEncoding.DecodeString(r.Header.Get(\"Authorization\"))\n\t\tif err != nil {\n\t\t\t// If we can't decode it, set the \"WWW-Authenticate\" header and return a 401 response\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\t// If we can decode it, split it into a username and password\n\t\tpair := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\t// If we can't split it, set the \"WWW-Authenticate\" header and return a 401 response\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\t// If we can split it, check if the username and password match\n\t\tif secureCompare(pair[0], username) && secureCompare(pair[1], password) {\n\t\t\t// If they do, serve the request\n\t\t\tfmt.Fprintln(w, \"Authorized\")\n\t\t} else {\n\t\t\t// If they don't, set the \"WWW-Authenticate\" header and return a 40", "CodeBleu_score": 47.756777248739}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tu, p, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif secureCompare(u, username) && secureCompare(p, password) {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t} else {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t}\n\t}\n}", "CodeBleu_score": 52.86737891391056}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - (slope * float64(fromMin))\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.86692050330879}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\treturn int(math.Max(math.Min(slope*input+intercept, float64(toMax)), float64(toMin)))\n\t}\n}", "CodeBleu_score": 53.90371109248723}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tvar slope, intercept float64\n\tslope = (toMax - toMin) / (fromMax - fromMin)\n\tintercept = toMin - (slope * fromMin)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 49.26617946662329}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog reading\", a.Connection().Name())\n\t}\n\n\trawValue, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"error reading from analog sensor: %s\", err)\n\t}\n\n\ta.lastRaw = rawValue\n\ta.lastScaled = a.sensorCfg.Scale(rawValue)\n\n\treturn rawValue, a.lastScaled, nil\n}", "CodeBleu_score": 56.337571197518486}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the mutex to ensure thread safety.\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Verify that the connection supports analog reading.\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog reading\", a.Connection().Name())\n\t}\n\n\t// Read the raw value from the specified pin.\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"error reading from pin %d: %v\", a.Pin(), err)\n\t}\n\n\t// Update the last raw and scaled values.\n\ta.lastRaw = raw\n\ta.lastScaled = raw * a.sensorCfg.scale\n\n\t// Return the raw and scaled values.\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 53.42528988345071}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tvar (\n\t\terr   error\n\t\tvalue int\n\t)\n\n\t// Lock the mutex to ensure thread safety.\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Verify that the connection supports analog reading.\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\t// Read the raw value from the specified pin.\n\tvalue, err = a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection analog read failed: %v\", err)\n\t}\n\n\t// Update the last raw and scaled values.\n\ta.lastRawValue = value\n\ta.lastScaledValue = float64(value) * a.sensorCfg.scale\n\n\treturn value, a.lastScaledValue, nil\n}", "CodeBleu_score": 51.56199379700849}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - (m * float64(fromMin))\n\treturn func(value int) float64 {\n\t\treturn m * float64(value) + n\n\t}\n}", "CodeBleu_score": 49.30472869421901}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - (m * float64(fromMin))\n\treturn func(input int) float64 {\n\t\treturn m * float64(input) + n\n\t}\n}", "CodeBleu_score": 51.69324443223275}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - (m * float64(fromMin))\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 49.04155202492407}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\t// Initializes the driver with the provided analog reader, pin, and optional parameters.\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: DefaultName,\n\t\ta:    a,\n\t\tpin:  pin,\n\t\tthreshold: 1000,\n\t}\n\n\t// Sets a default name for the driver.\n\td.SetName(DefaultName)\n\n\t// Adds a vibration event.\n\td.AddEvent(Vibration)\n\n\t// Sets up an event listener for data events that publishes a vibration event if the data exceeds a threshold value of 1000.\n\tif err := d.On(Data, func(data interface{}) {\n\t\t// If an error occurs while setting up the event listener, it panics.\n\t\tif data.(int) > d.threshold {\n\t\t\td.Publish(Vibration, nil)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Returns the initialized driver.\n\treturn d\n}", "CodeBleu_score": 48.69211218496271}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\t// Create the driver.\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: DefaultName,\n\t\ta:    a,\n\t\tpin:  pin,\n\t}\n\n\t// Initialize the driver.\n\td.Init()\n\n\t// Set up the event listener.\n\tif err := d.AddEvent(VibrationEvent, func(data interface{}) {\n\t\tif data.(float64) > 1000 {\n\t\t\td.Publish(VibrationEvent, data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Return the driver.\n\treturn d\n}", "CodeBleu_score": 45.919074160729565}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\t// Create a new driver with specified name and default options.\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.DefaultName = \"Grove Piezo Vibration Sensor\"\n\n\t// Set up event handling.\n\td.AddEvent(Vibration)\n\tif err := d.On(Vibration, func(data interface{}) {\n\t\tif d.Publish(Vibration, data) {\n\t\t\td.Debug(\"busy...\")\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Return the driver.\n\treturn d\n}", "CodeBleu_score": 43.30185911339356}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.IsClosed() {\n\t\treturn errors.New(\"buzzer driver is closed\")\n\t}\n\n\tif hz <= 0 {\n\t\treturn errors.New(\"invalid frequency\")\n\t}\n\n\tif duration <= 0 {\n\t\treturn errors.New(\"invalid duration\")\n\t}\n\n\tperiod := 1000 / hz\n\tif period > 0 {\n\t\td.Tone(hz, duration, period)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 26.021377840899472}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.IsConnected() {\n\t\td.On()\n\t\tdefer d.Off()\n\t\treturn d.tone(hz, duration)\n\t}\n\treturn errors.New(\"Not connected\")\n}", "CodeBleu_score": 12.250821271799628}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif err := d.On(); err != nil {\n\t\treturn err\n\t}\n\tdefer d.Off()\n\ttonePeriod := 1 / hz\n\tbeatsPerMinute := 120\n\ttempo := float64(beatsPerMinute) / 60\n\ttoneDuration := duration / tempo\n\ttime.Sleep(time.Duration(toneDuration) * time.Second)\n\treturn nil\n}", "CodeBleu_score": 40.63211906885251}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.58595756945493}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"Sleep pin not set\")\n\t}\n\n\td.stopIfRunning()\n\n\td.digitalWrite(d.sleepPin, 0)\n\n\td.isSleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 29.497543221775302}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"Sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.isSleeping = true\n\treturn nil\n}", "CodeBleu_score": 29.497543221775302}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"analog pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 55.770752678261736}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 56.39834741802419}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 56.39834741802419}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\ta.pin, err := a.GetPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif a.pin.direction != OUT {\n\t\treturn errors.New(\"Pin \" + id + \" is not an output pin\")\n\t}\n\ta.pin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 55.121746103422545}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\ta.pin, err = a.GetPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif a.pin.SupportedModes[0] != sysfs.OUT {\n\t\treturn errors.New(\"pin does not support digital output\")\n\t}\n\tif err = a.pin.Out(val); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 54.86330480887926}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.GetPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif pin.SupportedModes()[0] != digital {\n\t\treturn errors.New(\"Pin does not support digital mode\")\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 67.00442920184948}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"No pins configured\")\n\t}\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = a.NewDigitalPin(chip, line)\n\t\tif err := a.initialize(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t}\n\tpin.ApplyOptions(opts...)\n\treturn pin, nil\n}", "CodeBleu_score": 55.73808924731439}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.connectedPins) == 0 {\n\t\treturn nil, errors.New(\"No pins connected to DigitalPinsAdaptor\")\n\t}\n\n\tpin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif _, ok := a.connectedPins[pin.id]; !ok {\n\t\tif err := a.initialize(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tpin.ApplyOptions(opts...)\n\n\treturn pin, nil\n}", "CodeBleu_score": 41.07769361713843}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"No pins connected to DigitalPinsAdaptor\")\n\t}\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = a.NewDigitalPin(chip, line)\n\t\tif err := a.initialize(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t}\n\tpin.ApplyOptions(opts...)\n\treturn pin, nil\n}", "CodeBleu_score": 54.31472374394907}]}
