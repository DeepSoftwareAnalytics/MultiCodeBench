{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\tuint8_t desc_len;\n\tuint8_t desc_type;\n\n\tif (desc == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (next_desc->bLength != 0) {\n\t\tdesc_len = next_desc->bLength;\n\t\tdesc_type = next_desc->bDescriptorType;\n\n\t\tif (desc_type == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc + desc_len);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 44.79096585260911}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc + desc->bLength);\n\twhile (next_desc->bDescriptorType != USB_DESC_TYPE_ENDPOINT) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) next_desc + next_desc->bLength);\n\t\tif (next_desc->bDescriptorType == USB_DESC_TYPE_INTERFACE) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 49.64070755564144}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\twhile (next_desc->bDescriptorType != USB_DESC_TYPE_ENDPOINT) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t\t((uint8_t *) next_desc + next_desc->bLength);\n\t\tif (next_desc->bLength == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 43.99210015100811}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (udc_device.conf_desc == NULL)\n\t\treturn false;\n\n\tif (iface_num >= udc_device.conf_desc->bNumInterfaces)\n\t\treturn false;\n\n\tuint8_t *ptr = (uint8_t *) udc_device.conf_desc + udc_device.conf_desc->bLength;\n\tuint8_t *end = (uint8_t *) udc_device.conf_desc + udc_device.conf_desc->wTotalLength;\n\tuint8_t i = 0;\n\n\twhile (ptr < end) {\n\t\tif (ptr[1] == USB_DT_INTERFACE) {\n\t\t\tif (i == iface_num) {\n\t\t\t\tif (setting_num == ptr[2]) {\n\t\t\t\t\tudc_device.iface_desc = (struct usb_interface_descriptor *) ptr;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tptr += ptr[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 37.533220388091024}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    uint8_t *p = g_udc_desc_ptr;\n    uint8_t iface_num_tmp, setting_num_tmp;\n\n    if (g_udc_desc_ptr == NULL) {\n        return false;\n    }\n\n    if (g_udc_desc_ptr[0] != USB_DT_CONFIG || g_udc_desc_ptr[1] < USB_DT_CONFIG_SIZE) {\n        return false;\n    }\n\n    if (iface_num >= g_udc_desc_ptr[4]) {\n        return false;\n    }\n\n    p += g_udc_desc_ptr[1];\n    while (p[0] != USB_DT_INTERFACE) {\n        p += p[0];\n    }\n\n    iface_num_tmp = p[2];\n    setting_num_tmp = p[3];\n\n    while (p[0] == USB_DT_INTERFACE && iface_num_tmp == iface_num && setting_num_tmp <= setting_num) {\n        if (setting_num_tmp == setting_num) {\n            g_udc_desc_ptr = p;\n            return true;\n        }\n        p += p[0];\n        while (p[0] != USB_DT_INTERFACE) {\n            p += p[0];\n        }\n        iface_num_tmp = p[2];\n        setting_num_tmp = p[3];\n    }\n\n    return false;\n}", "CodeBleu_score": 40.31512056617706}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    uint8_t *ptr = udc_device.curr_cfg->descriptors;\n    uint8_t *end = ptr + udc_device.curr_cfg->descriptors_len;\n    uint8_t iface_desc_len = 0;\n    uint8_t iface_desc_type = 0;\n    uint8_t iface_desc_num = 0;\n    uint8_t iface_desc_setting = 0;\n\n    if (!udc_device.curr_cfg) {\n        return false;\n    }\n\n    if (iface_num >= udc_device.curr_cfg->iface_cnt) {\n        return false;\n    }\n\n    while (ptr < end) {\n        iface_desc_len = ptr[0];\n        iface_desc_type = ptr[1];\n        if (iface_desc_type == USB_DT_INTERFACE) {\n            iface_desc_num = ptr[2];\n            iface_desc_setting = ptr[3];\n            if ((iface_desc_num == iface_num) && (iface_desc_setting == setting_num)) {\n                return true;\n            }\n        }\n        ptr += iface_desc_len;\n    }\n\n    return false;\n}", "CodeBleu_score": 41.48406200488076}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (g_scsi_ep_data.req.wLength != 2) {\n\t\treturn false;\n\t}\n\tif (g_scsi_ep_data.req.bmRequestType & USB_REQ_DIR_IN) {\n\t\tif (g_scsi_ep_data.req.wIndex & 0x80) {\n\t\t\tif (udd_ep_is_halted(g_scsi_ep_data.req.wIndex & USB_EP_ADDR_MASK)) {\n\t\t\t\tg_scsi_ep_data.payload[0] = 1;\n\t\t\t} else {\n\t\t\t\tg_scsi_ep_data.payload[0] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (udd_ep_is_halted(g_scsi_ep_data.req.wIndex & USB_EP_ADDR_MASK)) {\n\t\t\t\tg_scsi_ep_data.payload[0] = 1;\n\t\t\t} else {\n\t\t\t\tg_scsi_ep_data.payload[0] = 0;\n\t\t\t}\n\t\t}\n\t\tg_scsi_ep_data.payload[1] = 0;\n\t}\n\treturn true;\n}", "CodeBleu_score": 37.13544523895202}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength != 2) {\n\t\treturn false;\n\t}\n\tudd_set_setup_payload(0, 0);\n\treturn true;\n}", "CodeBleu_score": 15.020944816541645}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (g_scsi_ep_data_dir == USB_REQ_DIR_IN) {\n\t\tif (g_scsi_ep_size != 2) {\n\t\t\treturn false;\n\t\t}\n\t\tg_scsi_ep_data[0] = 0;\n\t\tg_scsi_ep_data[1] = 0;\n\t\tif (udd_ep_is_halted(g_scsi_ep_num)) {\n\t\t\tg_scsi_ep_data[0] = 1;\n\t\t}\n\t\tudd_set_setup_payload(g_scsi_ep_data, g_scsi_ep_size);\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 31.582713476422953}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t alt_set;\n\tuint8_t status;\n\tudc_g_ctrlreq.req.wLength = 0;\n\tif (udd_g_ctrlreq.req.wLength != 0) {\n\t\tudd_g_ctrlreq.payload_size = 0;\n\t\treturn false;\n\t}\n\tiface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n\tif (iface_num >= udc_device.iface_num) {\n\t\tudd_g_ctrlreq.req.wLength = 0;\n\t\tudd_g_ctrlreq.payload_size = 0;\n\t\treturn false;\n\t}\n\tif (udd_g_ctrlreq.req.bRequest == USB_REQ_SET_INTERFACE) {\n\t\talt_set = udd_g_ctrlreq.req.wValue & 0xFF;\n\t\tif (alt_set >= udc_device.iface[iface_num].alt_setting_num) {\n\t\t\tudd_g_ctrlreq.req.wLength = 0;\n\t\t\tudd_g_ctrlreq.payload_size = 0;\n\t\t\treturn false;\n\t\t}\n\t\tstatus = udc_update_iface_desc(iface_num, alt_set);\n\t\tif (status == false) {\n\t\t\tudd_g_ctrlreq.req.wLength = 0;\n\t\t\tudd_g_ctrlreq.payload_size = 0;\n\t\t\treturn false;\n\t\t}\n\t\tudd_g_ctrlreq.req.wLength = 0;\n\t\tudd_g_ctrlreq.payload_size = 0;\n\t\treturn true;\n\t}\n\tif (udd_g_ctrlreq.req.bRequest == USB_REQ_GET_INTERFACE) {\n\t\talt_set = udc_device.iface[iface_num].alt_setting;\n\t\tudd_g_ctrlreq.", "CodeBleu_score": 50.934875356263845}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num = (g_ctrlreq.req.wIndex & 0xFF);\n\tif (iface_num >= udc_device->iface_num) {\n\t\treturn false;\n\t}\n\tif (g_ctrlreq.req.bRequest == USB_REQ_SET_INTERFACE) {\n\t\tif (g_ctrlreq.req.wValue > udc_device->iface[iface_num].desc->bNumSettings) {\n\t\t\treturn false;\n\t\t}\n\t\tif (g_ctrlreq.req.wValue == 0) {\n\t\t\tudc_update_iface_desc(iface_num, 0);\n\t\t} else {\n\t\t\tudc_update_iface_desc(iface_num, g_ctrlreq.req.wValue);\n\t\t}\n\t} else {\n\t\tif (g_ctrlreq.req.wValue != 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tudi_api_t *udi_api = udc_device->iface[iface_num].udi_api;\n\tif (udi_api->setup == NULL) {\n\t\treturn false;\n\t}\n\treturn udi_api->setup(&g_ctrlreq.req);\n}", "CodeBleu_score": 46.327503003393346}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_number = (g_ctrl_req.req.wIndex & 0xFF);\n\tuint8_t iface_alt_set = (g_ctrl_req.req.wValue & 0xFF);\n\tif (!udd_is_configured()) {\n\t\treturn false;\n\t}\n\tif (iface_number >= udc_nb_ifaces) {\n\t\treturn false;\n\t}\n\tif (iface_alt_set >= udc_ifaces[iface_number].nb_alternate) {\n\t\treturn false;\n\t}\n\tif (iface_alt_set == 0) {\n\t\t// Update to default setting\n\t\tif (!udc_update_iface_desc(iface_number)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// Update to current alternate setting\n\tif (!udc_update_iface_desc(iface_number)) {\n\t\treturn false;\n\t}\n\t// Forward request to interface handler\n\treturn udc_ifaces[iface_number].udi_api->setup(&g_ctrl_req);\n}", "CodeBleu_score": 56.80075628195957}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\t// Initialize internal values\n\tudi_msc_b_msc_enable = false;\n\tudi_msc_b_msc_addr_enable = false;\n\tudi_msc_b_cbw_invalid_field = false;\n\tudi_msc_b_cbw_out_of_range = false;\n\tudi_msc_b_sense_key = SBC_SENSE_KEY_NO_SENSE;\n\tudi_msc_b_sense_code = SBC_SENSE_CODE_NONE;\n\tudi_msc_b_sense_qualifier = SBC_SENSE_CODE_NONE;\n\tudi_msc_b_unit_attention = false;\n\tudi_msc_b_state = UDI_MSC_SCSI_CMD_WAIT_CBW;\n\tudi_msc_b_cbw_signature = 0;\n\tudi_msc_b_cbw_tag = 0;\n\tudi_msc_b_cbw_data_transfer_length = 0;\n\tudi_msc_b_cbw_flags = 0;\n\tudi_msc_b_cbw_lun = 0;\n\tudi_msc_b_cbw_cdb_length = 0;\n\tudi_msc_b_sbc_command = 0;\n\tudi_msc_b_sbc_lun = 0;\n\tudi_msc_b_sbc_trans = 0;\n\tudi_msc_b_sbc_xfer_len = 0;\n\tudi_msc_b_sbc_xfer_len_total = 0;\n\tudi_msc_b_sbc_xfer_len_rem = 0;\n\tudi_msc_b_sbc_xfer_len_max = 0;\n\tudi_msc_b_sbc_xfer_len_limit = 0;\n\tudi_msc_b_sbc_xfer_len_limit_max = 0;\n\tudi_msc_b_sbc_", "CodeBleu_score": 23.220744303871157}, {"code": "bool udi_msc_enable(void){\n\t\tbool b_status;\n\n\t// Initialize internal values\n\tudi_msc_b_trans_req = false;\n\tudi_msc_b_trans_running = false;\n\tudi_msc_b_cbw_valid = false;\n\tudi_msc_b_sense_valid = false;\n\tudi_msc_b_stall_req = false;\n\tudi_msc_b_cbw_error = false;\n\tudi_msc_b_unknown_test = false;\n\tudi_msc_b_read_run = false;\n\tudi_msc_b_write_run = false;\n\tudi_msc_b_read_run_led = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_read_blk_addr = 0;\n\tudi_msc_b_read_blk_nb = 0;\n\tudi_msc_b_write_blk_addr = 0;\n\tudi_msc_b_write_blk_nb = 0;\n\tudi_msc_b_read_blk_size = 0;\n\tudi_msc_b_write_blk_size = 0;\n\tudi_msc_b_read_blk_sreg = 0;\n\tudi_msc_b_write_blk_sreg = 0;\n\tudi_msc_b_read_blk_trans = 0;\n\tudi_msc_b_write_blk_trans = 0;\n\tudi_msc_b_read_blk_run = false;\n\tudi_msc_b_write_blk_run = false;\n\tudi_msc_b_read_blk_run_led = false;\n\tudi_msc_b_write_blk_run_led = false;\n\tudi_msc_b_read_blk_run_led_start = 0;\n\tudi_msc_b_write_blk_run_led_start = 0;\n\tudi_msc_b_read_bl", "CodeBleu_score": 11.381725857614002}, {"code": "bool udi_msc_enable(void){\n\t\tbool b_status;\n\tuint8_t u8_i;\n\n\t// Initialize internal values\n\tudi_msc_b_trans_req = false;\n\tudi_msc_b_trans_running = false;\n\tudi_msc_b_cbw_invalid = false;\n\tudi_msc_b_sense_valid = false;\n\tudi_msc_b_read_run = false;\n\tudi_msc_b_read_run_next = false;\n\tudi_msc_b_read_run_led = false;\n\tudi_msc_b_write_run = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_write_run_next = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_read_run_led = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_write_run_next_led = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_read_run_led = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_write_run_next_led = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_read_run_led = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_write_run_next_led = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_read_run_led = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_write_run_next_led = false;\n\tudi_msc_b_write_run_led = false;\n\tudi_msc_b_read_run_led = false;\n\tudi_msc_b_write_run_led", "CodeBleu_score": 27.407010206838894}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    // Check status of transfer\n    if (UDD_EP_TRANSFER_OK != status) {\n        // Transfer aborted then wait a setup reset\n        udi_msc_cbw_invalid();\n        return;\n    }\n\n    // Update sense data\n    udi_msc_sense_pass();\n\n    // Update residue value\n    udi_msc_csw.data_residue -= nb_sent;\n\n    // Process updated CSW\n    udi_msc_csw_process();\n}", "CodeBleu_score": 68.70786233242325}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    UNUSED(ep);\n    // Check status of transfer\n    if (UDD_EP_TRANSFER_OK != status) {\n        // Transfer aborted then wait a reset\n        udi_msc_cbw_invalid();\n        return;\n    }\n    // Transfer complete then update sense data\n    udi_msc_sense_pass();\n    // Update data residue in CSW\n    udi_msc_csw.data_residue -= nb_sent;\n    // Process updated CSW\n    udi_msc_csw_process();\n}", "CodeBleu_score": 75.03990615742804}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    UNUSED(ep);\n    if (UDD_EP_TRANSFER_OK != status) {\n        udi_msc_reset_all();\n        return;\n    }\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n    udi_msc_csw_process();\n}", "CodeBleu_score": 77.99871642540252}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\t// Check if the CSW is valid\n\tif (udi_msc_cbw.dCBWSignature != UDI_MSC_CBW_SIGNATURE) {\n\t\tudi_msc_cbw.dCBWSignature = 0;\n\t\tudi_msc_cbw.dCBWTag = 0;\n\t\tudi_msc_cbw.dCBWDataTransferLength = 0;\n\t\tudi_msc_cbw.bCBWFlags = 0;\n\t\tudi_msc_cbw.bCBWLUN = 0;\n\t\tudi_msc_cbw.bCBWCBLength = 0;\n\t\tudi_msc_cbw.bCBWCB[0] = 0;\n\t\tudi_msc_cbw.bCBWCB[1] = 0;\n\t\tudi_msc_cbw.bCBWCB[2] = 0;\n\t\tudi_msc_cbw.bCBWCB[3] = 0;\n\t\tudi_msc_cbw.bCBWCB[4] = 0;\n\t\tudi_msc_cbw.bCBWCB[5] = 0;\n\t\tudi_msc_cbw.bCBWCB[6] = 0;\n\t\tudi_msc_cbw.bCBWCB[7] = 0;\n\t\tudi_msc_cbw.bCBWCB[8] = 0;\n\t\tudi_msc_cbw.bCBWCB[9] = 0;\n\t\tudi_msc_cbw.bCBWCB[10] = 0;\n\t\tudi_msc_cbw.bCBWCB[11] = 0;\n\t\tudi_msc_cbw.bCBWCB[12] = 0;\n\t\tudi_msc_cbw.bCBWCB[13] = 0;\n\t\tudi_msc_cbw.bCBWCB[14] = 0;\n\t\tudi_msc_cbw.bCBWCB", "CodeBleu_score": 33.600079545403375}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint8_t endpoint;\n\tuint8_t *ptr_cwb;\n\tuint8_t *ptr_csw;\n\tuint8_t direction;\n\tuint32_t data_residue;\n\n\t// Get pointer on CBW\n\tptr_cwb = udi_msc_cbw_buf;\n\t// Get pointer on CSW\n\tptr_csw = udi_msc_csw_buf;\n\t// Get direction\n\tdirection = ptr_cwb[7];\n\t// Compute data residue\n\tdata_residue = le32_to_cpu(ptr_cwb + 8);\n\tif (direction) {\n\t\t// IN direction\n\t\tdata_residue -= udi_msc_trans_req.nb_byte;\n\t} else {\n\t\t// OUT direction\n\t\tdata_residue -= udi_msc_trans_req.nb_byte;\n\t}\n\t// Fill CSW\n\tptr_csw[0] = 0x50;\n\tptr_csw[1] = 0;\n\tptr_csw[2] = 0;\n\tptr_csw[3] = 0;\n\tptr_csw[4] = 0;\n\tptr_csw[5] = 0;\n\tptr_csw[6] = 0;\n\tptr_csw[7] = 0;\n\tptr_csw[8] = 0;\n\tptr_csw[9] = 0;\n\tptr_csw[10] = 0;\n\tptr_csw[11] = 0;\n\tptr_csw[12] = 0;\n\tptr_csw[13] = 0;\n\tptr_csw[14] = 0;\n\tptr_csw[15] = 0;\n\t// Update CSW tag with CBW tag\n\tptr_csw[15] = ptr_cwb[15];\n\t// Update CSW data residue\n\tcpu_to_le32(data_residue,", "CodeBleu_score": 31.362219069767228}, {"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_cbw_t *cbw = &udi_msc_g_cbw;\n\tudi_msc_csw_t *csw = &udi_msc_g_csw;\n\t\n\tif (udi_msc_g_data_residue) {\n\t\tif (udi_msc_g_b_read) {\n\t\t\t// Stall the IN pipe\n\t\t\tudi_msc_ep_in_stall_set();\n\t\t} else {\n\t\t\t// Stall the OUT pipe\n\t\t\tudi_msc_ep_out_stall_set();\n\t\t}\n\t}\n\n\t// Prepare the CSW\n\tcsw->dCSWSignature = cpu_to_le32(UDI_MSC_CSW_SIGNATURE);\n\tcsw->dCSWTag = cbw->dCBWTag;\n\tcsw->dCSWDataResidue = cpu_to_le32(udi_msc_g_data_residue);\n\tcsw->bCSWStatus = udi_msc_g_sense_key;\n\n\t// Send the CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 44.98712730142381}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tstatic uint8_t dtr_count[NUM_OF_PORTS];\n\tstatic bool b_dtr_state[NUM_OF_PORTS];\n\tstatic bool b_dtr_1200[NUM_OF_PORTS];\n\n\tif (b_enable != b_dtr_state[port]) {\n\t\tb_dtr_state[port] = b_enable;\n\t\tif (b_enable) {\n\t\t\tdtr_count[port] = 0;\n\t\t\tb_dtr_1200[port] = false;\n\t\t} else {\n\t\t\tdtr_count[port] = 0;\n\t\t\tb_dtr_1200[port] = false;\n\t\t}\n\t} else {\n\t\tif (b_enable) {\n\t\t\tdtr_count[port]++;\n\t\t\tif (dtr_count[port] == 1200) {\n\t\t\t\tb_dtr_1200[port] = true;\n\t\t\t\tinitiateReset(port);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.33276368120176}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_NUM_PORTS) {\n\t\treturn;\n\t}\n\n\tif (b_enable) {\n\t\t/* DTR has been enabled */\n\t\tusb_dtr_on[port] = true;\n\t\tcancelReset();\n\t} else {\n\t\t/* DTR has been disabled */\n\t\tusb_dtr_on[port] = false;\n\n\t\tif (usb_dtr_rate[port] == 1200) {\n\t\t\t/* The DTR rate is 1200, so schedule a reset */\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 39.43124518109254}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    static uint8_t reset_port = NO_PORT;\n    static uint32_t reset_start_ms = 0;\n\n    if (b_enable) {\n        reset_port = NO_PORT;\n    } else {\n        if (reset_port == NO_PORT) {\n            reset_port = port;\n            reset_start_ms = ticks;\n        } else if (reset_port == port && (ticks - reset_start_ms) >= 1200) {\n            usb_print(\"USB reset\n\");\n            usb_print(\"--scheduling reset--\n\");\n            initiateReset();\n        }\n    }\n}", "CodeBleu_score": 38.026058193744525}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\n    /*\n     * Check if this is a Microsoft vendor specific request.\n     */\n    if (USB_bmRequestType == 0xC0) {\n\n        /*\n         * Check if this is a request for the Microsoft OS 2.0 descriptor.\n         */\n        if (USB_bRequest == 0xEE) {\n\n            /*\n             * Check the descriptor index to determine which descriptor to return.\n             */\n            switch (USB_wValue) {\n\n                /*\n                 * Return the OS 2.0 descriptor.\n                 */\n                case 0x0000:\n                    usb_send_descriptor(USB_MS_OS_20_DESCRIPTOR, sizeof(USB_MS_OS_20_DESCRIPTOR));\n                    return true;\n\n                /*\n                 * Return the Microsoft OS 2.0 compatible ID descriptor.\n                 */\n                case 0x0004:\n                    usb_send_descriptor(USB_MS_OS_20_COMPATIBLE_ID, sizeof(USB_MS_OS_20_COMPATIBLE_ID));\n                    return true;\n\n                /*\n                 * Return the Microsoft OS 2.0 extended properties descriptor.\n                 */\n                case 0x0005:\n                    usb_send_descriptor(USB_MS_OS_20_EXTENDED_PROPERTIES, sizeof(USB_MS_OS_20_EXTENDED_PROPERTIES));\n                    return true;\n\n                /*\n                 * Return the Microsoft OS 2.0 extended properties descriptor.\n                 */\n                case 0x0006:\n                    usb_send_descriptor(USB_MS_OS_20_EXTENDED_PROPERTIES_LEN, sizeof(USB_MS_OS_20_EXTENDED_PROPERTIES_LEN));\n                    return true;\n\n                /*\n                 * Unsupported request.\n                 */\n                default:\n                    return false;\n            }\n        }\n    }\n\n    /*\n    ", "CodeBleu_score": 13.73103324186814}, {"code": "bool usb_task_other_requests(void){\n\t    bool ret_val = false;\n    switch (g_scsi_command[2]) {\n        case 0x04:\n            g_scsi_data_residue = sizeof(usb_microsoft_compatible_id_descriptor);\n            g_scsi_tag_residue = 0;\n            g_scsi_data_buffer = (uint8_t *)&usb_microsoft_compatible_id_descriptor;\n            ret_val = true;\n            break;\n        case 0x05:\n            g_scsi_data_residue = sizeof(usb_microsoft_extended_properties_descriptor);\n            g_scsi_tag_residue = 0;\n            g_scsi_data_buffer = (uint8_t *)&usb_microsoft_extended_properties_descriptor;\n            ret_val = true;\n            break;\n        default:\n            break;\n    }\n    return ret_val;\n}", "CodeBleu_score": 24.809149744192528}, {"code": "bool usb_task_other_requests(void){\n\t    if (usb_setup_type == REQTYPE_VENDOR) {\n        switch (usb_setup_request) {\n            case 0x04: // Microsoft WCID\n                usb_ep0_tx_ptr = (uint8_t*) & usb_microsoft_wcid;\n                usb_ep0_tx_data_size = sizeof(usb_microsoft_wcid);\n                return true;\n\n            case 0x05: // Microsoft Extended Properties\n                usb_ep0_tx_ptr = (uint8_t*) & usb_microsoft_ext_prop;\n                usb_ep0_tx_data_size = sizeof(usb_microsoft_ext_prop);\n                return true;\n\n            default:\n                return false;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 23.8021562184683}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\twhile (nbyte > 1) {\n\t\tSPDR = 0xFF;\n\t\tWHILE_RX;\n\t\t*buf = SPDR;\n\t\tbuf++;\n\t\tnbyte--;\n\t}\n\tspiRec(buf);\n}", "CodeBleu_score": 30.145260727081485}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0) {\n        return;\n    }\n\n    for (uint16_t i = 0; i < nbyte - 1; i++) {\n        while (!(SPI1_S & SPI_S_SPRF));\n        *buf++ = SPI1_DL;\n        SPI1_S |= SPI_S_SPRF;\n        SPI1_DL = 0;\n    }\n\n    spiRec(buf);\n}", "CodeBleu_score": 43.99298523529159}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  uint16_t i;\n  if (nbyte == 0) return;\n  for (i = 0; i < nbyte - 1; i++) {\n    spiRec(buf++);\n  }\n  *buf = spiRec(0xFF);\n}", "CodeBleu_score": 39.977149236415464}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n    CRITICAL_SECTION_START\n    get_relocated_table_addr\n    oldHandler = (pfnISR_Handler) relocated_table[irq];\n    relocated_table[irq] = (uint32_t) newHandler;\n    CRITICAL_SECTION_END\n    return oldHandler;\n}", "CodeBleu_score": 46.994512021728156}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n\n    CRITICAL_SECTION_START\n    get_relocated_table_addr\n    oldHandler = relocated_vector_table[irq + 16];\n    relocated_vector_table[irq + 16] = newHandler;\n    CRITICAL_SECTION_END\n\n    return oldHandler;\n}", "CodeBleu_score": 58.405713783408494}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n    uint32_t *pVectorTable;\n\n    pVectorTable = get_relocated_table_addr();\n\n    CRITICAL_SECTION_START\n    oldHandler = (pfnISR_Handler)pVectorTable[irq];\n    pVectorTable[irq] = (uint32_t)newHandler;\n    CRITICAL_SECTION_END\n\n    return oldHandler;\n}", "CodeBleu_score": 51.56710362029715}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_task_cdc_isenabled()) {\n    uint8_t ch;\n    if (udi_cdc_is_rx_ready()) {\n      udi_cdc_getc(&ch);\n      return ch;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 29.449950639827037}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_task_cdc_isenabled()) {\n    int c;\n    if ((c = udi_cdc_getc()) >= 0) {\n      #if ENABLED(EMERGENCY_PARSER)\n        emergency_parser.update(c);\n      #endif\n      return c;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 39.79724132765969}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready())\n    return udi_cdc_getc();\n  return -1;\n}", "CodeBleu_score": 9.685301782139035}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  int c;\n  if ((c = static_cast<MSerialT1*>(this)->read_char())) return c;\n  if (!usb_task_cdc_isenabled()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  c = udi_cdc_getc();\n  if (emergency_parser.enabled) emergency_parser.update(c);\n  return c;\n}", "CodeBleu_score": 52.83132397522161}, {"code": "int MarlinSerialUSB::read(){\n\t  if (rx_buffer_index_read != rx_buffer_index_write)\n    return rx_buffer[rx_buffer_index_read++];\n\n  if (!usb_task_cdc_isenabled()) return -1;\n\n  if (!udi_cdc_is_rx_ready()) return -1;\n\n  int16_t c = udi_cdc_getc();\n  if (c < 0) return -1;\n\n  #if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(c);\n  #endif\n\n  return c;\n}", "CodeBleu_score": 48.619419632147554}, {"code": "int MarlinSerialUSB::read(){\n\t  int ch = -1;\n  if (rx_buffer_head != rx_buffer_tail) {\n    ch = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n    return ch;\n  }\n  if (!usb_task_cdc_isenabled()) return -1;\n  if (!udi_cdc_is_rx_ready()) return -1;\n  ch = udi_cdc_getc();\n  if (ch >= 0) {\n    emergency_parser.update(ch);\n    return ch;\n  }\n  return -1;\n}", "CodeBleu_score": 51.02263263955378}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (rx_buffer_head == rx_buffer_tail) {\n    if (usb_task_cdc_isenabled()) {\n      usb_task_cdc_rx();\n      return (rx_buffer_head == rx_buffer_tail) ? 0 : 1;\n    }\n    else\n      return 0;\n  }\n  return (rx_buffer_head - rx_buffer_tail) & (RX_BUFFER_SIZE - 1);\n}", "CodeBleu_score": 44.6211577741934}, {"code": "int MarlinSerialUSB::available(){\n\t  if (rx_buffer_head == rx_buffer_tail) {\n    if (usb_task_cdc_isenabled())\n      return -1;\n    else\n      return 0;\n  }\n  return (rx_buffer_head - rx_buffer_tail) & (RX_BUFFER_SIZE - 1);\n}", "CodeBleu_score": 38.16193146351105}, {"code": "int MarlinSerialUSB::available(){\n\t  if (rx_buffer_head == rx_buffer_tail) {\n    // No data available to read\n    if (usb_task_cdc_isenabled())\n      return -1;\n    else\n      return 0;\n  }\n  return (rx_buffer_head - rx_buffer_tail) & (RX_BUFFER_SIZE - 1);\n}", "CodeBleu_score": 38.16193146351105}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint8_t c;\n\n\twhile (size--) {\n\t\tc = ee_Read(pos++);\n\t\tif (writing) *value++ = c;\n\t\t*crc = _crc16_update(*crc, &c, 1);\n\t}\n\treturn false;\n}", "CodeBleu_score": 47.40056081425824}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t    uint8_t c;\n\n    while (size--) {\n        if (writing) *value = ee_Read(pos);\n        c = *value;\n        crc16(crc, &c, 1);\n        value++;\n        pos++;\n    }\n    return false;\n}", "CodeBleu_score": 65.2675647401302}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\n\tuint8_t\tv;\n\n\twhile (size--) {\n\t\tv = ee_Read(pos++);\n\t\tif (writing) {\n\t\t\t*value++ = v;\n\t\t}\n\t\t*crc = _crc_ccitt_update(*crc, v);\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 45.37845511384097}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  // Setup PWM channel\n  const uint8_t ch = get_pwm_channel(pin);\n  if (ch) {\n    ledcWrite(ch, value);\n    return;\n  }\n\n  // Get timer for this pin\n  const uint8_t t = get_pwm_timer(pin);\n  if (t == INVALID_PWM_TIMER) return;\n\n  // Get timer state\n  pwm_data_t &pwm = pwm_data[t];\n\n  // Get slot for this pin\n  uint8_t slot = get_pwm_slot(pin);\n  if (slot == INVALID_PWM_SLOT) {\n    // No existing slot found. Allocate a new one.\n    if (pwm.used >= MAX_PWM_SLOT) return;\n    slot = pwm.used++;\n  }\n\n  // Setup the pin\n  pinMode(pin, OUTPUT);\n\n  // Set PWM value\n  pwm.values[slot] = value;\n\n  // Start the timer if not already running\n  if (!pwm.started) {\n    pwm.started = true;\n    HAL_timer_start(t, freq);\n  }\n}", "CodeBleu_score": 40.4965448832392}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (printer.isSuspended()) return;\n  if (pin == -1) return;\n  if (pin == X_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == Y_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == Z_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == E0_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == E1_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == E2_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == E3_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == E4_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == E5_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == E6_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == E7_ENABLE_PIN) {\n    stepper.setOutputPin(pin, value);\n    return;\n  }\n  if (pin == LED_PIN) {\n    #if PIN_EXISTS(LED)\n      OUT_WRITE(LED_PIN, !value);\n    #endif\n    return;\n  }\n  if (pin == FAN_PIN) {\n    #if PIN_EXISTS(FAN)\n      OUT_WRITE(FAN", "CodeBleu_score": 27.7706983130333}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  // Check if the pin can be used for hardware PWM\n  const uint8_t pwm_channel = get_pwm_channel(pin);\n  if (pwm_channel != 0xFF) {\n    // Use hardware PWM\n    ledcWrite(pwm_channel, value);\n    return;\n  }\n\n  // Check if the pin is already in use\n  const uint8_t pwm_index = get_pwm_index(pin);\n  if (pwm_index != 0xFF) {\n    // Use software PWM\n    const uint8_t pwm_slot = pwm_index >> 1;\n    const uint8_t pwm_bit = pwm_index & 0x01;\n    pwm_slots[pwm_slot].value[pwm_bit] = value;\n    return;\n  }\n\n  // Check if there are any free PWM slots\n  if (pwm_slot_count == PWM_SLOT_COUNT) {\n    // No free PWM slots\n    return;\n  }\n\n  // Allocate a new PWM slot\n  const uint8_t pwm_slot = pwm_slot_count++;\n  pwm_slots[pwm_slot].pin = pin;\n  pwm_slots[pwm_slot].value[0] = 0;\n  pwm_slots[pwm_slot].value[1] = 0;\n\n  // Increment the used PWM count\n  pwm_count++;\n\n  // Set the PWM value\n  pwm_slots[pwm_slot].value[0] = value;\n\n  // Start the timer if this is the first PWM pin\n  if (pwm_count == 1) {\n    HAL_timer_start(PWM_TIMER_NUM, PWM_FREQUENCY);\n  }\n}", "CodeBleu_score": 44.21781676336099}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  static_assert(\n    COUNT(SERVO_DELAY) == SERVO_CHANNEL_LAST,\n    \"SERVO_DELAY table needs to be as long as the number of SERVO_CHANNELs.\"\n  );\n\n  if (attach(SERVO_MIN_PULSE, SERVO_MAX_PULSE)) {\n    write(value);\n    safe_delay(SERVO_DELAY[channel - SERVO_FIRST_CHANNEL]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 44.53989749293585}, {"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(servo_delays) / sizeof(servo_delays[0]) == SERVO_COUNT, \"servo_delays[] must be the same length as SERVO_COUNT\");\n  if (attach(0)) {\n    write(value);\n    safe_delay(servo_delays[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 56.8348056764858}, {"code": "void Servo::move(const int value){\n\t    static_assert(sizeof(SERVO_DELAYS) / sizeof(SERVO_DELAYS[0]) == SERVO_COUNT, \"SERVO_DELAYS must have SERVO_COUNT elements\");\n\n    if (attach()) {\n        write(value);\n        safe_delay(SERVO_DELAYS[servo_index]);\n        #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n          detach();\n        #endif\n    }\n}", "CodeBleu_score": 52.90522008791897}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t  static uint16_t i2s_buffer[I2S_BUFFER_LENGTH];\n  static uint16_t i2s_buffer_position = 0;\n  static uint16_t i2s_buffer_position_half = 0;\n  static uint32_t i2s_tick_count = 0;\n  static uint32_t i2s_tick_count_half = 0;\n  static uint32_t i2s_tick_count_half_prev = 0;\n\n  uint32_t i2s_buffer_position_next = (i2s_buffer_position + 1) % I2S_BUFFER_LENGTH;\n  uint32_t i2s_buffer_position_next_half = (i2s_buffer_position_half + 1) % I2S_BUFFER_LENGTH;\n  uint32_t i2s_buffer_position_next_half_prev = (i2s_buffer_position_half + 2) % I2S_BUFFER_LENGTH;\n\n  if (i2s_tick_count == 0) {\n    i2s_tick_count = I2S_TICKS_PER_SAMPLE;\n\n    i2s_buffer[i2s_buffer_position] = 0;\n    i2s_buffer[i2s_buffer_position_next] = 0;\n\n    for (uint8_t pin = 0; pin < NUM_PINS; pin++) {\n      if (pwm_pins[pin].state) {\n        if (pwm_pins[pin].duty_cycle == 0) {\n          pwm_pins[pin].state = LOW;\n        } else if (pwm_pins[pin].duty_cycle == 100) {\n          pwm_pins[pin].state = HIGH;\n        } else {\n          if (pwm_pins[pin].state == LOW) {\n            if (pwm_pins[pin].duty_cycle > i2s_tick_count)", "CodeBleu_score": 24.549230873758543}, {"code": "void i2s_push_sample(){\n\t    static uint8_t dma_buf[DMA_BUF_LEN];\n    static uint32_t dma_buf_pos = 0;\n\n    static uint32_t pwm_tick_cnt = 0;\n    static uint32_t pwm_tick_max = 0;\n\n    static uint32_t i2s_buf_pos = 0;\n\n    /*\n     * For each pin, evaluate its PWM state. If the PWM tick count reaches zero, toggle the pin state between high and low.\n     */\n    for (uint8_t pin = 0; pin < NUM_PINS; pin++) {\n        if (pwm_tick_cnt == 0) {\n            if (pwm_tick_max == 0) {\n                /*\n                 * If the PWM tick count is zero and the PWM tick maximum is zero, then the pin is not active.\n                 */\n                TEST32(pin) = 0;\n                SBI32(dma_buf[dma_buf_pos], pin);\n            } else {\n                /*\n                 * If the PWM tick count is zero and the PWM tick maximum is not zero, then the pin is active.\n                 */\n                if (TEST32(pin)) {\n                    /*\n                     * If the pin is currently high, then set it low.\n                     */\n                    CBI32(dma_buf[dma_buf_pos], pin);\n                    TEST32(pin) = 0;\n                } else {\n                    /*\n                     * If the pin is currently low, then set it high.\n                     */\n                    SBI32(dma_buf[dma_buf_pos], pin);\n                    TEST32(pin) = 1;\n                }\n\n                /*\n                 * Set the PWM tick count for the next transition.\n                 */\n                pwm_tick_cnt = pwm_tick_max;\n            }\n        }\n    }\n\n    /*\n     * Decrement the PWM tick count.\n     */\n    if (pwm_tick_", "CodeBleu_score": 30.798877419605276}, {"code": "void i2s_push_sample(){\n\t    uint32_t *sample = (uint32_t *) i2s_dma_buffer;\n    uint32_t *end = (uint32_t *) (i2s_dma_buffer + I2S_DMA_BUF_LEN);\n    uint32_t *port_data = (uint32_t *) port_data_buffer;\n\n    // Reset the buffer position\n    i2s_dma_buffer_pos = 0;\n\n    // Fill the DMA buffer with the current port data\n    while (sample < end) {\n        *sample = *port_data;\n        sample++;\n        port_data++;\n    }\n\n    // Reset the port data buffer position\n    port_data_buffer_pos = 0;\n\n    // For each pin, check if it has active PWM and update the PWM states\n    for (uint8_t pin = 0; pin < NUM_PINS; pin++) {\n        if (pwm_active[pin]) {\n            // If the tick count is zero, toggle the pin state and set the tick count for the next transition\n            if (pwm_tick_count[pin] == 0) {\n                pwm_pin_state[pin] = !pwm_pin_state[pin];\n                pwm_tick_count[pin] = pwm_duty_cycle[pin];\n\n                // Update the port data buffer with the new pin state\n                uint32_t *port_data = (uint32_t *) port_data_buffer;\n                uint32_t *end = (uint32_t *) (port_data_buffer + PORT_DATA_BUF_LEN);\n                while (port_data < end) {\n                    if (pwm_pin_state[pin]) {\n                        *port_data |= 1 << pin;\n                    } else {\n                        *port_data &= ~(1 << pin);\n                    }\n                    port_data++;\n                }\n            }\n\n            // Decrement the tick count for the current pin\n            pwm_tick_count[pin", "CodeBleu_score": 26.087363906103413}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t timer_value;\n    switch (timer_num) {\n        case TIMER_0:\n            timer_value = timer_get_counter_value(TIMER0);\n            break;\n        case TIMER_1:\n            timer_value = timer_get_counter_value(TIMER1);\n            break;\n        case TIMER_2:\n            timer_value = timer_get_counter_value(TIMER2);\n            break;\n        case TIMER_3:\n            timer_value = timer_get_counter_value(TIMER3);\n            break;\n        default:\n            timer_value = 0;\n            break;\n    }\n    return timer_value;\n}", "CodeBleu_score": 38.429252762617814}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t count;\n\n    switch (timer_num) {\n        case 0:\n            count = TIMER_0_get_count();\n            break;\n        case 1:\n            count = TIMER_1_get_count();\n            break;\n        case 2:\n            count = TIMER_2_get_count();\n            break;\n        case 3:\n            count = TIMER_3_get_count();\n            break;\n        case 4:\n            count = TIMER_4_get_count();\n            break;\n        case 5:\n            count = TIMER_5_get_count();\n            break;\n        case 6:\n            count = TIMER_6_get_count();\n            break;\n        case 7:\n            count = TIMER_7_get_count();\n            break;\n        default:\n            count = 0;\n            break;\n    }\n\n    return count;\n}", "CodeBleu_score": 26.038828557363775}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t count;\n    switch (timer_num) {\n    case 0:\n        count = timer_get_counter_value(TIMER_0);\n        break;\n    case 1:\n        count = timer_get_counter_value(TIMER_1);\n        break;\n    case 2:\n        count = timer_get_counter_value(TIMER_2);\n        break;\n    case 3:\n        count = timer_get_counter_value(TIMER_3);\n        break;\n    default:\n        count = 0;\n        break;\n    }\n    return count;\n}", "CodeBleu_score": 39.914725854970165}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  if (pos < 0 || pos >= data_end) return false;\n\n  for (uint16_t cnt = 0; cnt < size; ++cnt) {\n    const uint8_t c = eeprom_read_byte((uint8_t*)pos);\n    if (writing) *value = c;\n    crc16(c, crc);\n    if (writing) ++value;\n    ++pos;\n  }\n\n  return false;\n}", "CodeBleu_score": 52.44272211210049}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; ++i) {\n    const uint8_t c = eeprom_read_byte((unsigned char *)pos++);\n    if (writing) *value++ = c;\n    if (crc) *crc = _PST_UPDATE_CRC(*crc, c);\n  }\n  return false;\n}", "CodeBleu_score": 60.002675296351995}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\n  if (pos < 0) return true;\n\n  for (uint8_t c = 0; c < size; c++) {\n    const uint8_t v = eeprom_read_byte((uint8_t*)pos);\n    if (writing) *value++ = v;\n    crc16(crc, v);\n    pos++;\n  }\n\n  return false;\n}", "CodeBleu_score": 51.42254150527735}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tCORE_ASSERT(sdioHandle != NULL);\n\tCORE_ASSERT(src != NULL);\n\n\tbool success = false;\n\tuint8_t retry = 0;\n\twhile (!success && retry < SDIO_WRITE_RETRY_COUNT) {\n\t\tsuccess = SD_WriteBlock(sdioHandle, block, src);\n\t\tif (!success) {\n\t\t\tprintf(\"SDIO_WriteBlock: write failed, retrying (%d/%d)\n\", retry, SDIO_WRITE_RETRY_COUNT);\n\t\t\tretry++;\n\t\t}\n\t}\n\n\tif (!success) {\n\t\tprintf(\"SDIO_WriteBlock: write failed after %d retries\n\", retry);\n\t}\n\n\treturn success;\n}", "CodeBleu_score": 41.151970245046144}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (!sdioHandle) {\n\t\tCORE_ASSERT(false);\n\t\treturn false;\n\t}\n\tif (!src) {\n\t\tCORE_ASSERT(false);\n\t\treturn false;\n\t}\n\tbool success = false;\n\tuint32_t retry = 0;\n\twhile (!success && retry < SDCARD_WRITE_RETRIES) {\n\t\tif (kStatus_Success == SDIO_WriteBlocks(sdioHandle, src, block, 1)) {\n\t\t\tsuccess = true;\n\t\t} else {\n\t\t\tretry++;\n\t\t\tvTaskDelay(SDCARD_WRITE_RETRY_DELAY / portTICK_PERIOD_MS);\n\t\t}\n\t}\n\tif (!success) {\n\t\tprintf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n\t}\n\treturn success;\n}", "CodeBleu_score": 36.105920679518356}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (!sdioHandle) {\n\t\tprintf(\"ERROR: SDIO_WriteBlock: sdioHandle is null\n\");\n\t\treturn false;\n\t}\n\tif (!src) {\n\t\tprintf(\"ERROR: SDIO_WriteBlock: src is null\n\");\n\t\treturn false;\n\t}\n\tuint8_t retry = 0;\n\twhile (retry < SD_MAX_RETRIES) {\n\t\tif (HAL_SD_WriteBlocks(sdioHandle, (uint8_t *) src, block, SD_BLOCK_SIZE, 1) == SD_OK) {\n\t\t\treturn true;\n\t\t}\n\t\tretry++;\n\t}\n\tprintf(\"ERROR: SDIO_WriteBlock: Failed to write block %lu after %d retries\n\", block, retry);\n\treturn false;\n}", "CodeBleu_score": 38.09152011919019}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  if (timer_num == TEMP_TIMER_NUM) {\n    HAL_timer_start_temp(frequency);\n    timer_num->setCallbackPriority(TEMP_TIMER_PRIORITY);\n  }\n  else if (timer_num == STEP_TIMER_NUM) {\n    HAL_timer_start_step(frequency);\n    timer_num->setCallbackPriority(STEP_TIMER_PRIORITY);\n  }\n  else\n    CORE_DEBUG_PRINTF(\"HAL_timer_start: Invalid timer number.\n\");\n}", "CodeBleu_score": 47.97341730143854}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n    case TIMER_CHANNEL_TEMP:\n      TEMP_TIMER_FREQ(frequency);\n      TEMP_TIMER_START();\n      TEMP_TIMER_SET_PRESCALE(TEMP_TIMER_PRESCALE);\n      TEMP_TIMER_SET_CALLBACK_PRIORITY(TEMP_TIMER_PRIORITY);\n      break;\n    case TIMER_CHANNEL_STEP:\n      STEP_TIMER_FREQ(frequency);\n      STEP_TIMER_START();\n      STEP_TIMER_SET_PRESCALE(STEP_TIMER_PRESCALE);\n      STEP_TIMER_SET_CALLBACK_PRIORITY(STEP_TIMER_PRIORITY);\n      break;\n    default:\n      CORE_DEBUG_PRINTF(\"Invalid timer channel: %d\n\", timer_num);\n      CORE_ASSERT_FAIL();\n  }\n}", "CodeBleu_score": 27.564336581907828}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  CORE_DEBUG_ENTER_FUNCTION();\n\n  if (timer_num == TEMP_TIMER_NUM) {\n    temp_timer.start(frequency, TEMP_TIMER_PRESCALE);\n    temp_timer.setCallbackPriority(TEMP_TIMER_PRIORITY);\n  }\n  else if (timer_num == STEP_TIMER_NUM) {\n    step_timer.start(frequency, STEP_TIMER_PRESCALE);\n    step_timer.setCallbackPriority(STEP_TIMER_PRIORITY);\n  }\n  else {\n    CORE_DEBUG_ASSERT_FAIL;\n  }\n\n  CORE_DEBUG_EXIT_FUNCTION();\n}", "CodeBleu_score": 52.26297035727183}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  char *buffer;\n  int file_size;\n  FILE *fp;\n  int i;\n  bool success = false;\n\n  buffer = (char *)malloc(EEPROM_SIZE);\n  if (buffer == NULL) {\n    return false;\n  }\n\n  fp = fopen(EEPROM_FILE, \"rb+\");\n  if (fp == NULL) {\n    fp = fopen(EEPROM_FILE, \"wb+\");\n    if (fp == NULL) {\n      free(buffer);\n      return false;\n    }\n  }\n\n  fseek(fp, 0, SEEK_END);\n  file_size = ftell(fp);\n  fseek(fp, 0, SEEK_SET);\n\n  if (file_size < EEPROM_SIZE) {\n    memset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n    fwrite(buffer, 1, EEPROM_SIZE, fp);\n    fseek(fp, 0, SEEK_SET);\n  }\n\n  i = fread(buffer, 1, EEPROM_SIZE, fp);\n  if (i == EEPROM_SIZE) {\n    success = true;\n  }\n\n  fclose(fp);\n\n  if (success) {\n    this->buffer = buffer;\n  } else {\n    free(buffer);\n  }\n\n  return success;\n}", "CodeBleu_score": 40.59033991238231}, {"code": "bool PersistentStore::access_start(){\n\t  uint8_t * const p = (uint8_t *)&persistentData;\n  const size_t file_size = sizeof(persistentData);\n\n  // Initialize the persistent data by copying defaults into the buffer\n  memcpy(&persistentData, &defaultData, sizeof(persistentData));\n\n  // If the file exists and can be read...\n  FILE *f = fopen(filename, \"r\");\n  if (f != NULL) {\n\n    // Get the file size\n    fseek(f, 0, SEEK_END);\n    const long file_pos = ftell(f);\n    rewind(f);\n\n    // If the file is larger than expected...\n    if (file_pos > file_size) {\n      // Exit, preserving the existing contents\n      fclose(f);\n      return true;\n    }\n\n    // If the file is smaller than expected...\n    if (file_pos < file_size) {\n      // Zero-fill the remainder of the buffer\n      memset(p + file_pos, 0xFF, file_size - file_pos);\n    }\n\n    // Read the file's contents into the buffer\n    size_t bytes_read = fread(p, 1, file_size, f);\n    if (bytes_read != file_size) {\n      // An error occurred. Exit, preserving the existing contents\n      fclose(f);\n      return true;\n    }\n\n    // Close the file\n    fclose(f);\n  }\n\n  // Successful load\n  return true;\n}", "CodeBleu_score": 47.48146225502078}, {"code": "bool PersistentStore::access_start(){\n\t  if (!_access_start()) {\n    return false;\n  }\n\n  if (file_size < EEPROM_SIZE) {\n    memset(buffer + file_size, EEPROM_ERASED_VALUE, EEPROM_SIZE - file_size);\n  }\n\n  fclose(fp);\n  return true;\n}", "CodeBleu_score": 21.08612397479564}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    for (int i = 0; i < 8; i++) {\n        // set clock pin low\n        HAL_SPI_STM32_SpiWrite_Mode_3(0);\n        // write MSB to MOSI\n        HAL_SPI_STM32_SpiWrite_Mode_3((b & 0x80) >> 7);\n        // toggle clock pin high\n        HAL_SPI_STM32_SpiWrite_Mode_3(1);\n        // read bit from MISO\n        r = (r << 1) | HAL_SPI_STM32_SpiRead_Mode_3();\n        // shift byte left\n        b <<= 1;\n    }\n    delaySPIFunc();\n    return r;\n}", "CodeBleu_score": 42.9867249468405}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    for (int i = 0; i < 8; i++) {\n        WRITE(HAL_SPI_STM32_MOSI_PIN, (b & 0x80) ? HIGH : LOW);\n        DELAY_NS(delaySPIFunc);\n        WRITE(HAL_SPI_STM32_SCK_PIN, HIGH);\n        DELAY_NS(delaySPIFunc);\n        if (READ(HAL_SPI_STM32_MISO_PIN)) {\n            r |= (1 << (7 - i));\n        }\n        WRITE(HAL_SPI_STM32_SCK_PIN, LOW);\n        DELAY_NS(delaySPIFunc);\n        b <<= 1;\n    }\n    DELAY_NS(delaySPIFunc);\n    return r;\n}", "CodeBleu_score": 47.07298687910494}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    for (int i = 0; i < 8; i++) {\n        DELAY_NS\n        WRITE(SPI_SCK, 0);\n        DELAY_NS\n        WRITE(SPI_MOSI, (b >> 7) & 0x01);\n        DELAY_NS\n        WRITE(SPI_SCK, 1);\n        DELAY_NS\n        b = b << 1;\n        r = r << 1;\n        r |= READ(SPI_MISO);\n    }\n    DELAY_NS\n    return r;\n}", "CodeBleu_score": 43.36568189750997}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n  /* Enable or disable the AHB peripheral clock by setting the corresponding bit in the AHBENR register */\n  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 79.90054709524316}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tuint32_t tmpreg;\n\n\t/* Check the parameters */\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\ttmpreg = RCC->AHBENR;\n\n\tif (NewState != DISABLE) {\n\t\t/* Enable the selected AHB peripheral */\n\t\ttmpreg |= RCC_AHBPeriph;\n\t} else {\n\t\t/* Disable the selected AHB peripheral */\n\t\ttmpreg &= ~RCC_AHBPeriph;\n\t}\n\n\t/* Store the new value */\n\tRCC->AHBENR = tmpreg;\n}", "CodeBleu_score": 68.31720245689412}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tif (NewState != DISABLE) {\n\t\t/* Enable the selected AHB peripheral clock */\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\t/* Disable the selected AHB peripheral clock */\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 78.26394678944122}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c;\n  if (uart_getc(obj, &c) == 0) {\n    rx_buffer_index_t i = (unsigned int)(obj->rx_head + 1) % RX_BUFFER_SIZE;\n    if (i != obj->rx_tail) {\n      obj->rx_buffer[obj->rx_head] = c;\n      obj->rx_head = i;\n      if (ENABLED(EMERGENCY_PARSER)) emergency_parser.update(c);\n    }\n    else {\n      obj->rx_dropped_bytes++;\n    }\n  }\n}", "CodeBleu_score": 74.9644419739518}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c;\n  if (uart_getc(obj, &c) == 0) {\n    rx_buffer_index_t i = (unsigned int)(rx_buffer_head + 1) % RX_BUFFER_SIZE;\n    if (i != rx_buffer_tail) {\n      rx_buffer[rx_buffer_head] = c;\n      rx_buffer_head = i;\n    }\n    else {\n      // If buffer is full, send an error message to the host\n      if (!emergency_parser.enabled) {\n        emergency_parser.update(PSTR(MSG_BUFFER_FULL));\n        emergency_parser.enable();\n      }\n    }\n    if (enqueued_one_char != c) {\n      enqueued_one_char = c;\n      // If a character is already enqueued, it will not be read.\n      // Instead, flag it as enqueued and return.\n      // The next invocation of this method will continue reading\n      // from the serial port.\n      return;\n    }\n    enqueued_one_char = 0;\n  }\n  // If no character is enqueued, read the next one from the serial port\n  // and enqueue it.\n  c = _rx_fetch_byte();\n  if (c == 0) return;\n  enqueued_one_char = c;\n  emergency_parser.update(c);\n}", "CodeBleu_score": 45.98246456797981}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t c;\n  if (obj->uart->SR & USART_SR_PE) {\n    obj->uart->SR &= ~USART_SR_PE;\n    return;\n  }\n  c = obj->uart->DR;\n  rx_buffer_index_t i = (unsigned int)(obj->rx_buff.head + 1) % SERIAL_RX_BUFFER_SIZE;\n  if (i != obj->rx_buff.tail) {\n    obj->rx_buff.buffer[obj->rx_buff.head] = c;\n    obj->rx_buff.head = i;\n  }\n  if (ENABLED(EMERGENCY_PARSER)) emergency_parser.update(c);\n}", "CodeBleu_score": 54.36813196708301}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (timer_instance[timer_num]->isInitialized() && !timer_instance[timer_num]->hasInterrupt()) {\n    timer_instance[timer_num]->attachInterrupt(timer_num == MF_TIMER_STEP ? Step_Handler : Temp_Handler);\n  }\n}", "CodeBleu_score": 46.7134174221365}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (timer_instance[timer_num]->hasInterrupt == false && timer_instance[timer_num]->initialized == true) {\n    switch (timer_num) {\n      case MF_TIMER_STEP:\n        timer_instance[timer_num]->attachInterrupt(Step_Handler);\n        break;\n      case MF_TIMER_TEMP:\n        timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n        break;\n    }\n    timer_instance[timer_num]->hasInterrupt = true;\n  }\n}", "CodeBleu_score": 80.0152382850648}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (timer_instance[timer_num]->hasInterrupt() == false && HAL_timer_initialized[timer_num] == true) {\n    if (timer_num == MF_TIMER_STEP) {\n      timer_instance[timer_num]->attachInterrupt(Step_Handler);\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n      timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n    }\n  }\n}", "CodeBleu_score": 61.18742481752283}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\n\tsepHash := HashStrRev(sep)\n\tvar (\n\t\tsepHashLast uint32\n\t\tsHash       uint32\n\t\tsHashLast   uint32\n\t\tsLast       = len(s) - len(sep)\n\t)\n\n\tfor i := 0; i < len(sep); i++ {\n\t\tsepHashLast += uint32(sep[i])\n\t\tsHashLast += uint32(s[sLast+i])\n\t}\n\n\tfor i := 0; i < len(s); i++ {\n\t\tsHash += uint32(s[i])\n\t\tif i >= len(sep) {\n\t\t\tsHash -= uint32(s[i-len(sep)])\n\t\t}\n\n\t\tif sHash == sepHash && sHashLast == sepHashLast && s[i-len(sep)+1:i+1] == sep {\n\t\t\treturn i - len(sep) + 1\n\t\t}\n\t}\n\n\treturn -1\n}", "CodeBleu_score": 37.63631236117098}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Check if the substring is empty.\n\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\n\t// Check if the substring is longer than the main string.\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\n\t// Calculate the hash of the substring.\n\thash := HashStrRev(sep)\n\n\t// Start the index at the end of the main string.\n\tindex := len(s)\n\n\t// Iterate over the main string from the end towards the beginning.\n\tfor {\n\t\t// Calculate the hash of the substring in the main string.\n\t\thash2 := HashStrRev(s[index-len(sep) : index])\n\n\t\t// If the hashes match.\n\t\tif hash == hash2 {\n\t\t\t// Check if the substring matches.\n\t\t\tif s[index-len(sep):index] == sep {\n\t\t\t\t// Return the starting index of the substring.\n\t\t\t\treturn index - len(sep)\n\t\t\t}\n\t\t}\n\n\t\t// If the index is at the beginning of the main string, stop iterating.\n\t\tif index == len(sep) {\n\t\t\tbreak\n\t\t}\n\n\t\t// Decrement the index.\n\t\tindex--\n\t}\n\n\t// Return -1 because the substring was not found.\n\treturn -1\n}", "CodeBleu_score": 28.062852870848186}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\t// Rabin-Karp algorithm\n\t// hashStrRev is the hash of the substring\n\thashStrRev := HashStrRev(sep)\n\t// len is the length of the substring\n\tlen := len(sep)\n\n\t// hash is the hash of the current substring of the main string\n\thash := HashStrRev(s[len(s)-len:])\n\n\t// Check if the hashes match\n\tif hash == hashStrRev && bytes.Equal(s[len(s)-len:], sep) {\n\t\treturn len(s) - len\n\t}\n\n\t// Calculate the hash of the next substring\n\tfor i := len(s) - len - 1; i >= 0; i-- {\n\t\t// Remove the first byte of the current substring\n\t\thash -= uint32(s[i]) * pow\n\t\t// Add the next byte of the main string\n\t\thash += uint32(s[i+len]) * pow\n\n\t\t// Check if the hashes match\n\t\tif hash == hashStrRev && bytes.Equal(s[i:i+len], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\n\t// Return -1 if no match was found\n\treturn -1\n}", "CodeBleu_score": 45.999672807404274}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() != 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.29771695006677}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() != 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.29771695006677}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.211916470826246}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(0x00)\n\ti2c.crReg.Set(i2c.crReg.Get() | (1 << 8)) // Start condition\n\ti2c.crReg.Set(i2c.crReg.Get() | (1 << 0)) // Enable I2C\n\n\t// Wait for start condition to be transmitted\n\tfor i2c.crReg.Get()&(1<<11) == 0 {\n\t}\n\n\ti2c.writeByte(address<<1 | (write << 0))\n}", "CodeBleu_score": 36.47352734453497}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.SetBits(i2c.crReg.Mask(i2c.crReg.ClearInterruptFlag, i2c.crReg.StartCondition, i2c.crReg.Enable))\n\tfor !i2c.crReg.HasBits(i2c.crReg.InterruptFlag) {\n\t}\n\ti2c.writeByte(address<<1 | write)\n}", "CodeBleu_score": 36.61805775440623}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(1 << 10) // Clear interrupt flag\n\ti2c.crReg.Set(1 << 8)  // Set start bit\n\ti2c.crReg.Set(1 << 0)  // Enable I2C\n\n\tfor !i2c.srReg.HasBits(1 << 1) {\n\t} // Wait for start condition to be transmitted\n\n\ti2c.writeByte(address<<1 | func() uint8 {\n\t\tif write {\n\t\t\treturn 0\n\t\t}\n\t\treturn 1\n\t}())\n}", "CodeBleu_score": 30.191927713110832}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif len == 0 {\n\t\treturn nil\n\t}\n\tif start < 0 || start+len > int64(len(f.flash))/f.BlockSize {\n\t\treturn errors.New(\"flash: erase out of bounds\")\n\t}\n\tstartAddr := f.flash[start*f.BlockSize : start*f.BlockSize+f.BlockSize]\n\tfor i := 0; i < len; i++ {\n\t\tnrf.NVMC.SetCONFIG_WEN(1)\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(unsafe.Pointer(&startAddr[0])))\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.SetCONFIG_WEN(0)\n\t\tstartAddr = startAddr[f.BlockSize:]\n\t}\n\treturn nil\n}", "CodeBleu_score": 43.92955709513249}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || start >= int64(f.NumBlocks) || len <= 0 || start+len > int64(f.NumBlocks) {\n\t\treturn errors.New(\"flash: invalid start/length\")\n\t}\n\n\t// calculate start address\n\tstartAddr := uint32(f.DataStart) + uint32(start)*f.BlockSize\n\n\t// wait for flash to finish any ongoing operations\n\twaitWhileFlashBusy()\n\n\t// configure flash for erasing\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\n\t// erase one block at a time\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(uintptr(startAddr + uint32(i)*f.BlockSize))\n\t\twaitWhileFlashBusy()\n\t}\n\n\t// set flash back to read mode\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 49.11144024934997}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 || start+len > int64(f.BlockCount) {\n\t\treturn errors.New(\"flash: out of bounds\")\n\t}\n\n\t// Calculate start address.\n\taddr := f.FlashDataStart + uintptr(start*f.BlockSize)\n\n\t// Wait for any ongoing flash operations to complete.\n\twaitWhileFlashBusy()\n\n\t// Configure flash for erasing.\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n\n\t// Erase each block.\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(addr))\n\t\taddr += uintptr(f.BlockSize)\n\t\twaitWhileFlashBusy()\n\t}\n\n\t// Set flash back to read mode.\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 54.566532944144306}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// check if the write operation exceeds the flash memory bounds\n\tif off < 0 || off > int64(FlashDataEnd-FlashDataStart) {\n\t\treturn 0, errors.New(\"flash: out of bounds\")\n\t}\n\n\t// calculate the start address for writing\n\tstartAddr := FlashDataStart + uintptr(off)\n\n\t// pad the byte slice to fit the write block size\n\tp = pad(p, f.WriteBlockSize)\n\n\t// enable write mode on the flash memory controller\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\n\t// write the data in blocks\n\tfor i := 0; i < len(p); i += f.WriteBlockSize {\n\t\t// copy the block to the flash memory\n\t\tbinary.LittleEndian.PutUint32(f.pad[:], binary.LittleEndian.Uint32(p[i:]))\n\t\tcopy((*[f.WriteBlockSize]byte)(unsafe.Pointer(startAddr+uintptr(i)))[:], f.pad[:])\n\n\t\t// wait for the flash memory to be ready\n\t\twaitWhileFlashBusy()\n\t}\n\n\t// return the number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 36.34157907147769}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds.\n\tif off < 0 || off+int64(len(p)) > f.Size {\n\t\treturn 0, errors.New(\"flash: out of bounds\")\n\t}\n\n\t// Calculate the start address for writing.\n\taddr := uintptr(FlashDataStart) + uintptr(off)\n\n\t// Pad the byte slice to fit the write block size.\n\tp = f.pad(p)\n\n\t// Enable write mode on the flash memory controller.\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(p); i += f.WriteBlockSize {\n\t\t// Wait until the flash memory is ready.\n\t\twaitWhileFlashBusy()\n\n\t\t// Write a block.\n\t\tbinary.LittleEndian.PutUint32(f.buf[:], *(*uint32)(unsafe.Pointer(&p[i])))\n\t\tcopy((*[f.WriteBlockSize]byte)(unsafe.Pointer(addr+uintptr(i)))[:], f.buf[:])\n\t}\n\n\t// Wait until the flash memory is ready.\n\twaitWhileFlashBusy()\n\n\t// Return the number of bytes written.\n\treturn len(p), nil\n}", "CodeBleu_score": 38.106614326200074}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, errors.New(\"flash: out of bounds\")\n\t}\n\n\tstartAddr := f.start + uintptr(off)\n\tp = f.pad(p)\n\tn = len(p)\n\n\tnrf.NVMC.SetCONFIG_WEN(1)\n\tdefer nrf.NVMC.SetCONFIG_WEN(0)\n\n\tfor i := 0; i < len(p); i += f.WriteBlockSize {\n\t\twaitWhileFlashBusy()\n\t\tbinary.LittleEndian.PutUint32((*uint32)(unsafe.Pointer(startAddr+uintptr(i))), binary.LittleEndian.Uint32(p[i:i+f.WriteBlockSize]))\n\t}\n\n\twaitWhileFlashBusy()\n\n\treturn n, nil\n}", "CodeBleu_score": 37.73547278781952}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Attempt to open the directory\n\tfor {\n\t\tdirPtr, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dirPtr), \"\", nil\n\t\t} else if err != syscall.EINTR {\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 58.755512407429464}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"Could not duplicate file descriptor\", err\n\t}\n\n\t// Attempt to open the directory\n\tvar dirPtr uintptr\n\tfor {\n\t\tdirPtr, err = syscall.Fdopendir(dupFd)\n\t\tif err == syscall.EINTR {\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\t// Check for errors\n\tif err != nil {\n\t\tsyscall.Close(dupFd)\n\t\treturn 0, \"Could not open directory\", err\n\t}\n\n\treturn dirPtr, \"\", nil\n}", "CodeBleu_score": 65.61039388267038}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar err error\n\tvar dupFd syscallFd\n\tvar dirPtr uintptr\n\n\tdupFd, err = syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, err.Error(), err\n\t}\n\n\tfor {\n\t\tdirPtr, err = syscall.Fdopendir(int(dupFd))\n\t\tif err != nil {\n\t\t\tif err != syscall.EINTR {\n\t\t\t\tsyscall.Close(int(dupFd))\n\t\t\t\treturn 0, err.Error(), err\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn dirPtr, \"\", nil\n}", "CodeBleu_score": 48.24664148483553}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t *running = esp_ota_get_running_partition();\n  esp_image_metadata_t data;\n  const esp_partition_pos_t running_pos = {\n    .offset = running->address,\n    .size = running->size,\n  };\n  esp_err_t err = esp_image_verify(ESP_IMAGE_VERIFY, &running_pos, &data);\n  if (err != ESP_OK) {\n    return 0;\n  }\n  return (response == FREE_SKETCH_SPACE) ? esp_partition_get_free_size(running) : data.image_len;\n}", "CodeBleu_score": 65.41524643690639}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\n\tconst esp_partition_t *running = esp_ota_get_running_partition();\n\tesp_image_metadata_t data;\n\tesp_image_verify(ESP_IMAGE_VERIFY, running, &data);\n\n\treturn (response == sketchSize_t::free) ? running->size - data.image_len : data.image_len;\n}", "CodeBleu_score": 37.94404294391812}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t *running = esp_ota_get_running_partition();\n  esp_image_metadata_t data;\n  const esp_partition_t *part = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, running->label);\n  esp_image_verify(ESP_IMAGE_VERIFY, part, &data);\n  return (response == sketchSize_t::freeSpace) ? part->size - data.image_len : data.image_len;\n}", "CodeBleu_score": 46.89564083193903}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t fat_size;\n    uint32_t total_sectors;\n    uint32_t root_sectors;\n    uint32_t fat_sectors;\n    uint32_t reserved_sectors;\n    uint32_t sectors_per_cluster;\n    uint32_t sector_size;\n    uint32_t sector_count;\n    uint32_t fat_type;\n    uint32_t boot_sector_size;\n    uint32_t fat_sector_size;\n    uint32_t root_sector_size;\n    uint32_t fat_sector_count;\n    uint32_t root_sector_count;\n    uint32_t boot_sector_count;\n    uint32_t data_sector_count;\n    uint32_t data_sector_size;\n    uint32_t boot_sector_offset;\n    uint32_t fat_sector_offset;\n    uint32_t root_sector_offset;\n    uint32_t data_sector_offset;\n    uint32_t boot_sector_index;\n    uint32_t fat_sector_index;\n    uint32_t root_sector_index;\n    uint32_t data_sector_index;\n    uint32_t i;\n    uint32_t j;\n    uint32_t k;\n    uint32_t l;\n    uint32_t m;\n    uint32_t n;\n    uint32_t o;\n    uint32_t p;\n    uint32_t q;\n    uint32_t r;\n    uint32_t s;\n    uint32_t t;\n    uint32_t u;\n    uint32_t v;\n    uint32_t w;\n    uint32_t x;\n    uint32_t y;\n    uint32_t z;\n    uint32_t aa;\n    uint32_t bb;\n   ", "CodeBleu_score": 8.496887224694346}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    uint32_t required_disk_sectors = msc_update_get_required_disk_sectors();\n    uint8_t *disk = calloc(required_disk_sectors, SECTOR_SIZE);\n    if (disk == NULL) {\n        log_e(\"Failed to allocate RAM disk of %d sectors\", required_disk_sectors);\n        return false;\n    }\n\n    fat_add_boot_sector(disk, volume_label, serial_number);\n    fat_add_table(disk);\n    fat_add_root_file(disk);\n\n    msc_update_set_disk(disk, required_disk_sectors);\n    return true;\n}", "CodeBleu_score": 28.477273835906715}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\t// Calculate the required disk sectors\n\tuint32_t required_disk_sectors = msc_update_get_required_disk_sectors(volume_label);\n\t\n\t// Allocate memory for the RAM disk\n\tuint8_t *ram_disk = calloc(required_disk_sectors, SECTOR_SIZE);\n\tif (ram_disk == NULL) {\n\t\tlog_e(\"Failed to allocate memory for RAM disk\");\n\t\treturn false;\n\t}\n\t\n\t// Set up the boot sector and file allocation table\n\tfat_add_boot_sector(ram_disk, volume_label, serial_number);\n\tfat_add_table(ram_disk);\n\t\n\t// Add a root directory entry for a firmware file if a partition is running\n\tif (part_running()) {\n\t\tfat_add_root_file(ram_disk, \"firmware.bin\");\n\t}\n\t\n\treturn true;\n}", "CodeBleu_score": 26.581437224577957}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        log_e(\"offset is not multiple of flash sector size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE) != ESP_OK) {\n        log_e(\"failed to erase partition\");\n        return ESP_ERR_INVALID_STATE;\n    }\n\n    return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 50.030189442826526}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    if (offset % partition->sector_size != 0) {\n        ESP_LOGE(TAG, \"offset must be aligned with sector size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (partition->sector_size > size) {\n        ESP_LOGE(TAG, \"sector size is greater than the data size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    esp_err_t err = esp_partition_erase_range(partition, offset, partition->sector_size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"failed to erase partition (%d)\", err);\n        return err;\n    }\n\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"failed to write partition (%d)\", err);\n    }\n    return err;\n}", "CodeBleu_score": 50.20410156371485}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    uint32_t sector_size = esp_partition_get_sector_size(partition);\n    if (offset % sector_size != 0) {\n        ESP_LOGE(TAG, \"Write offset is not aligned with flash sector size\");\n        return ESP_FAIL;\n    }\n\n    err = esp_partition_erase_range(partition, offset, sector_size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase sector\");\n        return err;\n    }\n\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data\");\n        return err;\n    }\n\n    return ESP_OK;\n}", "CodeBleu_score": 55.157620213954864}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t outlen = 0;\n    while (outlen < maxlen && *in != '\\0') {\n        if (isxdigit(*in)) {\n            *out = hex_char_to_byte(*in);\n            ++out;\n            ++outlen;\n        }\n        ++in;\n    }\n    return outlen;\n}", "CodeBleu_score": 33.9716545692442}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t outlen = 0;\n\twhile (*in != '\\0' && outlen < maxlen) {\n\t\tif (isxdigit(*in)) {\n\t\t\tif (outlen % 2 == 0) {\n\t\t\t\tout[outlen] = (hex_char_to_byte(*in) << 4);\n\t\t\t} else {\n\t\t\t\tout[outlen] |= hex_char_to_byte(*in);\n\t\t\t\toutlen++;\n\t\t\t}\n\t\t}\n\t\tin++;\n\t}\n\treturn outlen;\n}", "CodeBleu_score": 40.95775076767644}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i = 0;\n    size_t j = 0;\n    int tmp;\n\n    while (in[i] != '\\0' && j < maxlen) {\n        tmp = hex_char_to_byte(in[i++]);\n        if (tmp == -1) {\n            continue;\n        }\n        tmp <<= 4;\n        tmp += hex_char_to_byte(in[i++]);\n        if (tmp == -1) {\n            return j;\n        }\n        out[j++] = (unsigned char)tmp;\n    }\n    return j;\n}", "CodeBleu_score": 43.033385283585126}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (_tx_sem == NULL || _tx_ringbuf == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(_tx_sem, _tx_sem_timeout) == pdTRUE) {\n\t\tint free_size = xRingbufferGetCurFreeSize(_tx_ringbuf);\n\t\txSemaphoreGive(_tx_sem);\n\t\treturn free_size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 61.56055334946213}, {"code": "int HWCDC::availableForWrite(void){\n\t    if (txRingBuffer == NULL || txSemaphore == NULL) {\n        return 0;\n    }\n\n    if (xSemaphoreTake(txSemaphore, portMAX_DELAY) != pdTRUE) {\n        return 0;\n    }\n\n    int freeSize = xRingbufferGetCurFreeSize(txRingBuffer);\n\n    xSemaphoreGive(txSemaphore);\n\n    return freeSize;\n}", "CodeBleu_score": 66.9116091993506}, {"code": "int HWCDC::availableForWrite(void){\n\t    if (!txRingBuffer || !txSemaphore) {\n        return 0;\n    }\n    if (xSemaphoreTake(txSemaphore, 100) == pdTRUE) {\n        int ret = xRingbufferGetCurFreeSize(txRingBuffer);\n        xSemaphoreGive(txSemaphore);\n        return ret;\n    }\n    return 0;\n}", "CodeBleu_score": 57.08548191533255}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t    HSERIAL_MUTEX_LOCK\n    _onReceiveCB = function;\n    _rxTimeout = onlyOnTimeout ? 0 : 1;\n    if (function) {\n        _setRxFIFOFullThreshold(1);\n        _createEventTask();\n    }\n    HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 24.34881973335349}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (function) {\n    uartSetRxFIFOFull(uart_num, 1);\n    if (!_rxTimeoutTask) {\n      _rxTimeoutTask = _createEventTask();\n    }\n    uartSetRxTimeout(uart_num, _rxTimeout, onlyOnTimeout);\n  } else {\n    uartSetRxFIFOFull(uart_num, 0);\n    uartSetRxTimeout(uart_num, 0, false);\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 48.009920610936796}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  HSERIAL_MUTEX_LOCK\n  _onReceiveCB = function;\n  if (_onReceiveCB != NULL) {\n    if (onlyOnTimeout) {\n      uartSetRxTimeout(_uart, _rxTimeout);\n    } else {\n      uartSetRxTimeout(_uart, 0);\n    }\n    uartSetRxFIFOFull(_uart, _rxFIFOThreshold);\n    _createEventTask();\n  }\n  HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 53.86585633543919}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if (length < 1) {\n        return 0;\n    }\n\n    size_t index = 0;\n\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) {\n            break;\n        }\n        *buffer++ = (char)c;\n        index++;\n    }\n    *buffer = '\\0';\n    return index;\n}", "CodeBleu_score": 95.11949325145235}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char) c;\n\t\tindex++;\n\t}\n\t*buffer = '\\0';\n\treturn index;\n}", "CodeBleu_score": 84.25797113370915}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\n\tsize_t index = 0;\n\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char) c;\n\t\tindex++;\n\t}\n\t*buffer = '\\0';\n\treturn index;\n}", "CodeBleu_score": 84.25797113370915}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"tone pin=%d, freq=%u, duration=%lu\", pin, frequency, duration);\n  if (pin_in_use[pin]) {\n    log_e(\"tone: pin %d already in use\", pin);\n  } else {\n    pin_in_use[pin] = true;\n    tone_init(pin, frequency);\n    tone_queue_item_t item = {\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n        .start_ms = millis(),\n        .end_ms = millis() + duration,\n    };\n    xQueueSend(tone_queue, &item, 0);\n  }\n}", "CodeBleu_score": 56.643962186514194}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    log_d(\"tone pin:%d freq:%d duration:%d\", pin, frequency, duration);\n    if (pin_in_use[pin] == false) {\n        pin_in_use[pin] = true;\n        tone_init(pin, frequency);\n        tone_cmd_t cmd = {\n            .pin = pin,\n            .frequency = frequency,\n            .duration = duration,\n        };\n        if (xQueueSend(tone_queue, &cmd, 0) != pdPASS) {\n            log_e(\"xQueueSend failed\");\n        }\n    } else {\n        log_e(\"tone: pin %d is already in use\", pin);\n    }\n}", "CodeBleu_score": 56.5726061502046}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"tone(%d, %d, %d)\", pin, frequency, duration);\n  if (pin_in_use[pin]) {\n    log_e(\"Tone on pin %d already in use. Stop the current tone first.\", pin);\n  } else {\n    pin_in_use[pin] = true;\n    pinMode(pin, OUTPUT);\n    tone_init(pin, frequency);\n    xQueueSend(tone_queue, &duration, 0);\n  }\n}", "CodeBleu_score": 35.647728849908624}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if(!_usb_started) {\n        _webusb_enabled = enabled;\n        if(enabled) {\n            _usb_version = 0x0210;\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 42.08947551625582}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!_usb_started) {\n    _webusb_enabled = enabled;\n    if (enabled) {\n      _usb_version = 0x0210;\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 46.0447099598771}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (enabled) {\n\t\tif (!usb_started) {\n\t\t\tusb_webusb_en = true;\n\t\t\tif (usb_version < 0x0210) {\n\t\t\t\tusb_version = 0x0210;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tusb_webusb_en = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!usb_started) {\n\t\t\tusb_webusb_en = false;\n\t\t\treturn true;\n\t\t} else {\n\t\t\tusb_webusb_en = false;\n\t\t\treturn false;\n\t\t}\n\t}\n}", "CodeBleu_score": 50.31520928129806}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t  int n;\n  uint8_t buf[64];\n  while (1) {\n    n = tud_cdc_n_read(buf, sizeof(buf));\n    if (n <= 0) {\n      break;\n    }\n    // Attempt to send each byte to the receive queue\n    for (int i = 0; i < n; i++) {\n      if (!xQueueSend(rxQueue, &buf[i], 0)) {\n        // If the queue is full, post an overflow event with the number of dropped bytes\n        // and log an error\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud_cdc_n_write(buf, n);\n        tud", "CodeBleu_score": 26.5458773212206}, {"code": "void USBCDC::_onRX(){\n\t  uint8_t buf[64];\n  uint32_t len = tud_cdc_n_read(0, buf, sizeof(buf));\n  uint32_t dropped = 0;\n\n  for (uint32_t i = 0; i < len; i++) {\n    if (!xQueueSend(rx_queue, &buf[i], 0)) {\n      dropped++;\n    }\n  }\n\n  if (dropped) {\n    tud_cdc_n_write_flush(0);\n    tud_cdc_n_read(0, NULL, 0);\n    log_e(\"Dropped %d bytes\", dropped);\n    tud_cdc_n_write_str(\"Dropped %d bytes\\r\n\", dropped);\n    tud_cdc_n_write_flush(0);\n    arduino_usb_event_post(ARDUINO_USB_EVENT_SERIAL_RX_OVERFLOW, &dropped, sizeof(dropped));\n  } else {\n    arduino_usb_event_post(ARDUINO_USB_EVENT_SERIAL_RX, &len, sizeof(len));\n  }\n}", "CodeBleu_score": 41.6042149075044}, {"code": "void USBCDC::_onRX(){\n\t  // read data into buffer\n  uint32_t len = tud_cdc_n_available();\n  if (len == 0) return;\n  uint8_t buffer[len];\n  uint32_t read = tud_cdc_n_read(buffer, len);\n  if (read == 0) return;\n\n  // attempt to send each byte to a receive queue\n  for (uint32_t i = 0; i < read; i++) {\n    if (xQueueSend(_rx_queue, &buffer[i], 0) != pdTRUE) {\n      // queue is full\n      tud_cdc_n_read_flush();\n      // post an overflow event\n      USBCDCEvent event(USBCDCEvent::Overflow, read - i);\n      _event_queue->post(event);\n      // log an error\n      Log.Error(F(\"USBCDC::_onRX queue overflow %d\"), event.data);\n      break;\n    } else {\n      // post a receive event\n      USBCDCEvent event(USBCDCEvent::Receive, 1);\n      _event_queue->post(event);\n    }\n  }\n}", "CodeBleu_score": 36.9057372636542}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\":name\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %s not found\", name), http.StatusNotFound)\n\t\treturn\n\t}\n\ta.writeJSON(res, robot.Devices())\n}", "CodeBleu_score": 27.686904410584845}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tif robot := a.master.Robot(robotName); robot != nil {\n\t\tdevices := []map[string]interface{}{}\n\t\trobot.Devices().Each(func(d gobot.Device) {\n\t\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\t\"name\":   d.Name(),\n\t\t\t\t\"driver\": d.Driver().Name(),\n\t\t\t})\n\t\t})\n\t\ta.writeJSON(res, devices)\n\t} else {\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"Error\": \"No robot found with name \" + robotName,\n\t\t})\n\t}\n}", "CodeBleu_score": 57.16102179463599}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(mux.Vars(req)[\"robot\"])\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %v not found\", mux.Vars(req)[\"robot\"]), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices := []*gobot.JSONDevice{}\n\trobot.Devices().Each(func(d gobot.Device) {\n\t\tdevices = append(devices, gobot.NewJSONDevice(d))\n\t})\n\n\ta.writeJSON(res, devices)\n}", "CodeBleu_score": 54.1681592532308}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(gobot.RobotNameFromURL(req.URL))\n\tif robot == nil {\n\t\thttp.Error(res, \"No robot found\", http.StatusNotFound)\n\t\treturn\n\t}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\ta.writeJSON(res, c)\n\t})\n}", "CodeBleu_score": 26.640296668653434}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot '%s' not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tjson.NewEncoder(res).Encode(c)\n\t})\n}", "CodeBleu_score": 30.427750902276983}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\n\tif robot != nil {\n\t\ta.writeJSON(res, robot.Connections())\n\t} else {\n\t\ta.writeJSON(res, map[string]string{\"Error\": \"Could not find robot with name \" + robotName})\n\t}\n}", "CodeBleu_score": 30.36475059185629}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"Error\": \"Robot not found\",\n\t\t})\n\t\treturn\n\t}\n\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"Error\": \"Device not found\",\n\t\t})\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\":command\")\n\tif command == \"\" {\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"Error\": \"Command not found\",\n\t\t})\n\t\treturn\n\t}\n\n\tif err := a.executeCommand(device.(gobot.Commander), command); err != nil {\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"Error\": err.Error(),\n\t\t})\n\t\treturn\n\t}\n\n\ta.writeJSON(res, a.jsonDeviceFor(device))\n}", "CodeBleu_score": 53.88615504138423}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\thttp.Error(res, \"Device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tif commander, ok := device.(gobot.Commander); ok {\n\t\tcommand := req.URL.Query().Get(\":command\")\n\t\tparams := req.URL.Query()[\"params\"]\n\t\tif len(params) > 0 {\n\t\t\tcommand += \" \" + strings.Join(params, \" \")\n\t\t}\n\t\tresult, err := a.executeCommand(robot, commander, command)\n\t\tif err != nil {\n\t\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\t\"Error\": err.Error(),\n\t\t\t})\n\t\t} else {\n\t\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\t\"Message\": result,\n\t\t\t})\n\t\t}\n\t} else {\n\t\thttp.Error(res, \"Device is not a commander\", http.StatusInternalServerError)\n\t}\n}", "CodeBleu_score": 53.99567202831054}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\tcommand := req.URL.Query().Get(\":command\")\n\n\td, err := a.master.Robot(robot).\n\t\tDevice(device)\n\n\tif err != nil {\n\t\ta.writeJSON(res, map[string]string{\"Error\": err.Error()})\n\t\treturn\n\t}\n\n\ta.executeCommand(d.(gobot.Commander), command, res, req)\n}", "CodeBleu_score": 57.33555387380708}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\tuser, pass, ok := req.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tres.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(res, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// continue\n\t}\n}", "CodeBleu_score": 59.84966705559221}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.491049434473936}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.491049434473936}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().HasAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"%s does not support analog reading\", a.Connection().Name())\n\t}\n\n\traw, err := reader.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.sensorCfg.scale(raw)\n\ta.sensorCfg.lastRead = scaled\n\ta.sensorCfg.lastRaw = raw\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 54.878591471163894}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"the sensor %s is not an analog sensor\", a.Name())\n\t}\n\n\traw, err := reader.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.sensorCfg.scale(raw)\n\n\ta.sensorCfg.lastReadRaw = raw\n\ta.sensorCfg.lastReadScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 52.66836327448482}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection().Name() != \"Analog\" {\n\t\treturn 0, 0, fmt.Errorf(\"sensor %q does not support analog reading\", a.Name())\n\t}\n\n\traw, err := reader.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.sensorCfg.scale(raw)\n\n\ta.sensorCfg.lastRawValue = raw\n\ta.sensorCfg.lastScaledValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 53.699400019795306}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(gobot.DefaultName(\"GroveSoundSensor\"))\n\treturn &GroveSoundSensorDriver{d}\n}", "CodeBleu_score": 33.92530933891077}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.Name = gobot.DefaultName(\"GroveSoundSensor\")\n\treturn &GroveSoundSensorDriver{d}\n}", "CodeBleu_score": 47.1950053728355}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(gobot.DefaultName(\"GroveSoundSensor\"))\n\treturn &GroveSoundSensorDriver{d}\n}", "CodeBleu_score": 33.92530933891077}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(d.CommandReg, d.PCD_SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tif d.readByteData(d.CommandReg) != 0 {\n\t\treturn fmt.Errorf(\"The reset did not complete\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 30.907278725430444}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Send the soft reset command to the command register.\n\tif err := d.writeByteData(d.regCommand, d.piccCommandSoftReset); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the soft reset to complete.\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// Check if the device is still in power-down mode.\n\tif powerDown, err := d.readByteData(d.regCommand); err != nil {\n\t\treturn err\n\t} else if (powerDown & 0x01) == 0x01 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.890747692958875}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Send the reset command to the command register\n\terr := d.writeByteData(d.CommandReg, d.PCD_SoftReset)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the device to initialize\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Check if the device is still powered down\n\tif d.readByteData(d.CommandReg) != 0 {\n\t\treturn errors.New(\"device did not initialize\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.16106496907636}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tvar err error\n\tvar length uint8\n\tlength, err = d.readByteData(d.FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif length != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"The number of bytes to read (%d) does not match the length of the byte slice (%d).\", length, len(backData))\n\t}\n\tfor i := uint8(0); i < length; i++ {\n\t\tbackData[i], err = d.readByteData(d.FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn d.readByteData(d.ControlReg)\n}", "CodeBleu_score": 45.973816678304}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Read the number of bytes stored in the FIFO\n\tlength, err := d.readByteData(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// If the number of bytes doesn't match the expected length, return an error\n\tif length != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"Invalid number of bytes: %d\", length)\n\t}\n\n\t// Read each byte from the FIFO into the provided byte slice\n\tfor i := range backData {\n\t\tbackData[i], err = d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tlastBits, err := d.readByteData(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Return the last bits received along with any errors encountered\n\treturn lastBits & 0x07, nil\n}", "CodeBleu_score": 47.87325216567291}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Read the number of bytes stored in the FIFO\n\tn, err := d.readByteData(d.regFifoLevel)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: %w\", err)\n\t}\n\t// If the number of bytes is more than the size of the byte slice, return an error\n\tif n > uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"readFifo: %w\", ErrFifoOverflow)\n\t}\n\t// Read each byte from the FIFO into the byte slice\n\tfor i := uint8(0); i < n; i++ {\n\t\tbackData[i], err = d.readByteData(d.regFifoData)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"readFifo: %w\", err)\n\t\t}\n\t}\n\t// Read the control register to get the last bits received\n\tlastBits, err := d.readByteData(d.regControl)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: %w\", err)\n\t}\n\t// Return the last bits received along with any errors\n\treturn lastBits & 0x07, nil\n}", "CodeBleu_score": 44.73121411795135}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.log.Println(\"Halting PICC\")\n\t// Create a halt command\n\thaltCmd := []byte{d.CommandHalt, 0}\n\t// Calculate CRC for the halt command\n\thaltCmd = d.calculateCRC(haltCmd)\n\t// Send the halt command to the PICC\n\tif err := d.communicateWithPICC(haltCmd); err != nil {\n\t\treturn err\n\t}\n\t// Check if the PICC responded with an error\n\tif d.buffer[0] != d.ResponseOK {\n\t\treturn fmt.Errorf(\"PICC did not respond with an error message\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 31.90681390652855}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.logger.Debug(\"Sending halt command to PICC.\")\n\tcommand := []uint8{d.piccCommand.HaltA, 0}\n\td.calculateCRC(command)\n\tif err := d.communicateWithPICC(command); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 24.992132974297576}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.log.Debug(\"Halting PICC\")\n\n\t// Create halt command\n\tvar haltCommand = []uint8{d.CommandHalt, 0}\n\n\t// Calculate CRC for halt command\n\tvar haltCommandCRC = d.calculateCRC(haltCommand)\n\n\t// Append CRC to halt command\n\thaltCommand = append(haltCommand, haltCommandCRC[:]...)\n\n\t// Send halt command to PICC\n\tvar err = d.communicateWithPICC(haltCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 32.93460294993231}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar buffer []byte\n\tvar err error\n\tbuffer = make([]byte, 3)\n\tbuffer[0] = PICC_READ\n\tbuffer[1] = block\n\tbuffer[2] = d.calculateCRC(buffer[:2])\n\tbuffer, err = d.communicateWithPICC(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buffer, nil\n}", "CodeBleu_score": 29.12095469923839}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare the command to read the block\n\tcmd := []byte{d.piccCmdRead, block}\n\t// Calculate the CRC for the command\n\tcmd = append(cmd, d.calculateCRC(cmd)...)\n\t// Send the command\n\tif err := d.communicateWithPICC(cmd); err != nil {\n\t\treturn nil, err\n\t}\n\t// Read the data from the card\n\tdata := make([]byte, 16)\n\tif err := d.dev.Tx(d.dev.TxAddr, []byte{d.regFIFOData}, data); err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}", "CodeBleu_score": 41.28498553142862}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Make sure we're in the right mode\n\tif err := d.piccSelect(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Prepare the command\n\tcmd := make([]byte, 4)\n\tcmd[0] = PICC_CMD_MF_READ\n\tcmd[1] = block\n\td.calculateCRC(cmd, 2)\n\n\t// Transceive the command\n\tresp, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the CRC\n\tif err := d.checkCRC(resp); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Return the data\n\treturn resp[0 : len(resp)-2], nil\n}", "CodeBleu_score": 39.87400531425936}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too short to receive PICC request\")\n\t}\n\td.clearRegisterBitMask(CollReg, 0x80) // Clear ValuesAfterColl bit\n\td.setRegisterBitMask(CollReg, 0x40)   // ValuesRequested bit = 1\n\td.clearRegisterBitMask(BitFramingReg, 0x80)\n\td.setRegisterBitMask(BitFramingReg, 0x07) // StartSend bit = 1, TxLastBits = BitFramingReg[2..0]\n\n\tif reqMode == 0x30 {\n\t\td.clearRegisterBitMask(BitFramingReg, 0x04) // TxLastBits = BitFramingReg[2..0]\n\t} else {\n\t\td.setRegisterBitMask(BitFramingReg, 0x04) // TxLastBits = BitFramingReg[2..0]\n\t}\n\n\treturn d.communicateWithPICC(reqMode, answer)\n}", "CodeBleu_score": 39.70229354200924}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Check if there is enough room in the answer buffer.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"no room for answer\")\n\t}\n\n\t// Clear the collision register.\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// Set the transmission to use only 7 bits of the last byte.\n\tif reqMode == REQA {\n\t\td.clearRegisterBitMask(TxModeReg, 0x80)\n\t} else {\n\t\td.setRegisterBitMask(TxModeReg, 0x80)\n\t}\n\n\t// Send the request command to the PICC.\n\terr := d.communicateWithPICC(reqMode, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the PICC responded with the correct bit pattern.\n\tif reqMode == REQA {\n\t\tif answer[0]&0x03 != 0x00 || answer[1]&0x03 != 0x00 {\n\t\t\treturn fmt.Errorf(\"wrong pattern\")\n\t\t}\n\t} else if reqMode == WUPA {\n\t\tif answer[0]&0x0F != 0x0A {\n\t\t\treturn fmt.Errorf(\"wrong pattern\")\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 56.809765816936086}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Check for buffer overflow\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too short to hold the expected data\")\n\t}\n\n\t// Clear the collision register\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// Set the transmission to use 7 bits instead of 8 bits\n\tif reqMode == 0x44 {\n\t\td.writeRegister(BitFramingReg, 0x07)\n\t} else {\n\t\td.writeRegister(BitFramingReg, 0x00)\n\t}\n\n\t// Send the request\n\terr := d.communicateWithPICC(reqMode, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the response is valid\n\tif len(answer) == 0 || answer[0]&0x01 == 1 {\n\t\treturn fmt.Errorf(\"invalid response\")\n\t}\n\n\t// Return the response\n\treturn nil\n}", "CodeBleu_score": 55.50298925277919}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\ttime.Sleep(d.getDelayPerStep())\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif d.direction == 0 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\td.valueMutex.Unlock()\n\treturn nil\n}", "CodeBleu_score": 69.06934530034458}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif d.direction == 0 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 74.23290519003234}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\td.digitalWrite(d.stepPin, 0)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, 1)\n\tif d.direction == Clockwise {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 45.488520987587435}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\treturn nil\n}", "CodeBleu_score": 68.21580159749709}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\treturn nil\n}", "CodeBleu_score": 68.21580159749709}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running for '%s'\", d.name)\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\treturn nil\n}", "CodeBleu_score": 69.86408429260153}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, edge string, count uint32, gpio uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tt := time.Now()\n\t\t\tduration := t.Sub(startTimestamp)\n\t\t\td.distanceChannel <- duration\n\t\t\tstartTimestamp = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.185588044062136}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pin int, value time.Duration, edge string, tick uint32, count uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else {\n\t\t\td.EchoChannel <- time.Since(startTimestamp).Microseconds()\n\t\t}\n\t}\n}", "CodeBleu_score": 37.60828807044834}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\treturn func(pin int, value time.Duration, edge string, tick uint32, count uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else {\n\t\t\tduration := time.Since(startTimestamp)\n\t\t\td.EchoChannel <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 38.1841548690283}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\tselect {\n\tcase <-d.measurementDone:\n\t\td.distance = d.timeSinceLastTrigger()\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout waiting for measurement\")\n\t}\n}", "CodeBleu_score": 41.24262834065466}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.triggerPin.Out(gpio.High)\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Out(gpio.Low)\n\n\tfor i := 0; i < 1000; i++ {\n\t\tif d.echoPin.Read() == gpio.High {\n\t\t\td.measureTrigger <- struct{}{}\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(time.Microsecond)\n\t}\n\n\tselect {\n\tcase <-d.measureTrigger:\n\t\treturn nil\n\tcase <-time.After(100 * time.Millisecond):\n\t\treturn errors.New(\"timeout\")\n\t}\n}", "CodeBleu_score": 47.64952479616568}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\td.measureMutex.Unlock()\n\n\t// Wait for the measurement to complete or for a timeout to occur.\n\tselect {\n\tcase <-d.measureDone:\n\tcase <-time.After(d.measureTimeout):\n\t\treturn fmt.Errorf(\"measurement timed out\")\n\t}\n\n\td.measureMutex.Lock()\n\td.measureTime = d.measureTimeMicros\n\treturn nil\n}", "CodeBleu_score": 39.1746009850516}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    # check if token is available in environment variables\n    token = os.getenv('ACCESS_TOKEN')\n    if token:\n        return token\n    # check if token is available in local state\n    state = self.get_state_item('auth')\n    if state:\n        token = state.get('access_token')\n        if token:\n            expires_at = state.get('expires_at')\n            if expires_at:\n                if expires_at > time.time():\n                    return token\n                else:\n                    refresh_token = state.get('refresh_token')\n                    if refresh_token:\n                        response = self.get(\n                            url='https://accounts.spotify.com/api/token',\n                            headers={'Authorization': 'Basic ' + self.get_state_item('auth_header')},\n                            params={'grant_type': 'refresh_token', 'refresh_token': refresh_token},\n                            data=None,\n                            json=None\n                        )\n                        if response.get('access_token'):\n                            state['access_token'] = response.get('access_token')\n                            state['expires_at'] = int(time.time()) + int(response.get('expires_in'))\n                            self.set_state_item('auth', state)\n                            return response.get('access_token')\n    raise AccountNotAuthorized\n\n", "CodeBleu_score": 42.368447497634534}, {"code": "def fetch_authentication_token(self)\n\t\n    access_token = os.getenv('ACCESS_TOKEN')\n    refresh_token = os.getenv('REFRESH_TOKEN')\n    expires_at = os.getenv('EXPIRES_AT')\n    if access_token and refresh_token and expires_at:\n        return access_token\n    access_token = self.get_state_item('access_token')\n    refresh_token = self.get_state_item('refresh_token')\n    expires_at = self.get_state_item('expires_at')\n    if access_token and refresh_token and expires_at:\n        if time.time() < float(expires_at):\n            return access_token\n        else:\n            refresh_token = self.get_state_item('refresh_token')\n            if refresh_token:\n                response = self.get_json_data(\n                    'https://accounts.spotify.com/api/token',\n                    'POST',\n                    {\n                        'grant_type': 'refresh_token',\n                        'refresh_token': refresh_token\n                    },\n                    {\n                        'Authorization': 'Basic ' + self.get_state_item('base64_encoded_client_id_secret')\n                    }\n                )\n                if response['status'] == 200:\n                    access_token = response['data']['access_token']\n                    refresh_token = response['data']['refresh_token']\n                    expires_in = response['data']['expires_in']\n                    expires_at = time.time() + expires_in\n                    self.set_state_item('access_token', access_token)\n                    self.set_state_item('refresh_token', refresh_token)\n                    self.set_state_item('expires_at', str(expires_at))\n                    return access_token\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 38.287303052896384}, {"code": "def fetch_authentication_token(self)\n\t\n    if \"ACCESS_TOKEN\" in os.environ and \"REFRESH_TOKEN\" in os.environ:\n        self.set_state_item(\"access_token\", os.environ[\"ACCESS_TOKEN\"])\n        self.set_state_item(\"refresh_token\", os.environ[\"REFRESH_TOKEN\"])\n        self.set_state_item(\"expiration_time\", os.environ[\"EXPIRATION_TIME\"])\n        self.set_state_item(\"refresh_token_expiration_time\", os.environ[\"REFRESH_TOKEN_EXPIRATION_TIME\"])\n        return os.environ[\"ACCESS_TOKEN\"]\n    if self.get_state_item(\"access_token\") is None or self.get_state_item(\"refresh_token\") is None:\n        raise AccountNotAuthorized(\"No authentication data available.\")\n    access_token = self.get_state_item(\"access_token\")\n    refresh_token = self.get_state_item(\"refresh_token\")\n    expiration_time = self.get_state_item(\"expiration_time\")\n    refresh_token_expiration_time = self.get_state_item(\"refresh_token_expiration_time\")\n    if expiration_time is None or time.time() > float(expiration_time):\n        if refresh_token_expiration_time is None or time.time() > float(refresh_token_expiration_time):\n            raise AccountNotAuthorized(\"No valid authentication data available.\")\n        else:\n            response = self.get(\n                \"https://www.googleapis.com/oauth2/v4/token\",\n                params={\n                    \"client_id\": self.client_id,\n                    \"client_secret\": self.client_secret,\n                    \"refresh_token\": refresh_token,\n                    \"grant_type\": \"refresh_token\",\n                },\n            )\n            if response.status_code == 200:\n                access_token = response.json()[\"access_token\"]\n                expires_in = response.json()[\"expires_in\"]\n                expiration_time = time.time() + expires_in", "CodeBleu_score": 38.387003850382456}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(endpoint=\"/v1/logout\", method=\"POST\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n", "CodeBleu_score": 50.6914653636395}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.post_json_data(\n            \"logout\",\n            {\n                \"refresh_token\": refresh_token,\n            },\n        )\n    except AccountError:\n        pass\n    return True\n", "CodeBleu_score": 56.91564984325008}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.post_json_data(\"/v1/logout\", {\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n", "CodeBleu_score": 48.16672412513786}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.get_packages():\n        if not package.is_optional():\n            item = {\n                'name': package.name,\n                'version': package.version,\n            }\n            if package.is_external():\n                item['source'] = package.source\n            result.append(item)\n    return result\n\n", "CodeBleu_score": 29.63132296838066}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.get_packages():\n        if package.is_optional():\n            continue\n        package_info = {\n            'name': package.get_name(),\n            'version': package.get_version()\n        }\n        if package.is_external():\n            package_info['source_url'] = package.get_source_url()\n        result.append(package_info)\n    return result\n\n", "CodeBleu_score": 32.232491401262976}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.get_packages():\n        if package.is_optional():\n            continue\n        info = {\n            'name': package.get_name(),\n            'version': package.get_version()\n        }\n        if package.is_external():\n            info['source_url'] = package.get_source_url()\n        result.append(info)\n    return result\n\n", "CodeBleu_score": 32.034787866237444}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    config = ProjectConfig.get_instance()\n    p = cls.new(env, config.get('platforms', env), autoinstall=autoinstall)\n    p.configure_project_packages(env, targets)\n    return p\n\n", "CodeBleu_score": 24.944573562467895}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    try:\n        platform = config.get(env)\n    except KeyError:\n        raise UndefinedEnvPlatformError(env)\n    p = cls(platform, autoinstall)\n    p.set_project_environment(env)\n    p.configure_project_packages(targets)\n    return p\n\n", "CodeBleu_score": 35.720578551413546}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = cls.new(env, autoinstall)\n    p.configure_project_packages(env, targets)\n    return p\n\n", "CodeBleu_score": 13.879115691550089}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire1.read();\n  }\n}", "CodeBleu_score": 78.75244164472427}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire1.read();\n  }\n}", "CodeBleu_score": 89.01066891940826}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    *(Buff + i) = Wire1.read();\n  }\n}", "CodeBleu_score": 86.73094092182299}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us > 0) {\n    esp_sleep_enable_timer_wakeup(time_in_us);\n  } else {\n    esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n  }\n  esp_deep_sleep_start();\n}", "CodeBleu_score": 67.55475214296553}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  SetSleep();\n  if (time_in_us > 0) {\n    esp_sleep_enable_timer_wakeup(time_in_us);\n  } else {\n    esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n  }\n  esp_deep_sleep_start();\n}", "CodeBleu_score": 67.55475214296553}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t  if (time_in_us == 0) {\n    // Disable timer wakeup source\n    esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n  } else {\n    // Enable timer wakeup source\n    esp_sleep_enable_timer_wakeup(time_in_us);\n  }\n  // Initiate deep sleep\n  esp_deep_sleep_start();\n}", "CodeBleu_score": 54.10622474181347}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t  int y = _scroll_y;\n  tft.fillRect(_scroll_x, y, _scroll_w, _scroll_h, color);\n  y += _scroll_h;\n  if (y >= _scroll_y_max) {\n    y = _scroll_y_min;\n  }\n  if (y == _scroll_y_min && tteBar) {\n    tft.setScroll(0);\n    tteBar = false;\n  }\n  tft.setScroll(y);\n  return y;\n}", "CodeBleu_score": 20.74390407475708}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = scroll_y;\n  tft.fillRect(0, y, tft.width(), line_h, color);\n  scroll_y += line_h;\n  if (scroll_y >= (tft.height() - line_h)) {\n    scroll_y = 0;\n  }\n  scrollAddress(scroll_y);\n  return y;\n}", "CodeBleu_score": 16.524777316500845}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = _scroll_y;\n  tft.fillRect(_scroll_x, y, _scroll_w, _scroll_h, color);\n  _scroll_y += _scroll_h;\n  if (_scroll_y >= _scroll_h + _scroll_y_fixed_bottom) {\n    _scroll_y = _scroll_y_fixed_top;\n  }\n  scrollAddress(0, _scroll_y);\n  return y;\n}", "CodeBleu_score": 18.896845087580488}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\n  // Set up access points\n  if (!this->setAP(ssids)) {\n    return false;\n  }\n\n  // Set up HTML content\n  if (!this->setHtml(access_points)) {\n    return false;\n  }\n\n  // Start the portal\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 64.80573580198235}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  // Setup access points\n  if (!this->setAP(ssids)) {\n    return false;\n  }\n\n  // Setup HTML content\n  if (!this->setHtml(access_points)) {\n    return false;\n  }\n\n  // Start the portal\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 64.80573580198235}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  Serial.println(\"Starting Portal\");\n  if (ssids == NULL) {\n    Serial.println(\"No SSIDs provided\");\n    return false;\n  }\n  if (access_points == NULL) {\n    Serial.println(\"No Access Points provided\");\n    return false;\n  }\n  if (!this->setAP(ssids)) {\n    Serial.println(\"Setting AP failed\");\n    return false;\n  }\n  if (!this->setHtml(access_points)) {\n    Serial.println(\"Setting HTML failed\");\n    return false;\n  }\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 50.65780401388344}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t  if (this->queue_enabled_flag) {\n    this->flush_queue();\n    this->new_queue = true;\n  }\n  else {\n    this->queue_enabled_flag = true;\n    this->new_queue = true;\n  }\n}", "CodeBleu_score": 22.680596531593316}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<char *>;\n\t\t}\n\t\tif (!text) {\n\t\t\ttext = new char[GPS_TEXT_BUFFER_SIZE];\n\t\t}\n\t\tif (!text_in) {\n\t\t\ttext_in = new char[GPS_TEXT_BUFFER_SIZE];\n\t\t}\n\t} else {\n\t\tflush_queue();\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 13.700656523695498}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tthis->flush_queue();\n\t\tthis->new_queue = true;\n\t}\n\telse {\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 17.885233960477592}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue != NULL) {\n\t\tthis->new_queue = new std::queue<std::string>();\n\t\tdelete this->queue;\n\t\tthis->queue = this->new_queue;\n\t} else {\n\t\tthis->new_queue = new std::queue<std::string>();\n\t\tthis->queue = this->new_queue;\n\t}\n}", "CodeBleu_score": 18.701455801800417}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue != NULL) {\n        this->new_queue = new std::queue<std::string>();\n        delete this->queue;\n        this->queue = this->new_queue;\n    } else {\n        this->new_queue = new std::queue<std::string>();\n        this->queue = this->new_queue;\n    }\n}", "CodeBleu_score": 20.70891875348083}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue != NULL) {\n        this->new_queue = new queue<string>();\n        delete this->queue;\n        this->queue = this->new_queue;\n    } else {\n        this->new_queue = new queue<string>();\n        this->queue = this->new_queue;\n    }\n}", "CodeBleu_score": 23.704545672219734}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n    display_obj.tft.writePixels(color_p, (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1), false, true);\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 53.833421330030816}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    // Start a write transaction to the display\n    display_obj.tft.startWrite();\n\n    // Set the address window to the area being updated\n    display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n\n    // Iterate through each pixel in the area being updated\n    for (int i = 0; i < (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1); i++) {\n      // Write the color data for the current pixel\n      display_obj.tft.writeColor(color_p->full);\n      color_p++;\n    }\n\n    // End the write transaction\n    display_obj.tft.endWrite();\n\n    // Notify that the flush is complete\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 64.5630294386193}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint16_t w = (area->x2 - area->x1 + 1);\n    uint16_t h = (area->y2 - area->y1 + 1);\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n    display_obj.tft.pushColors(&color_p->full, w * h, true);\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 49.82389421501647}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  //Iterate through all menu nodes\n  for (int i = 0; i < menu->list->size(); i++) {\n    //Get the current node\n    MenuNode * node = menu->list->get(i);\n\n    //Print indentation\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\"  \");\n    }\n\n    //Print the node's name\n    Serial.print(node->name);\n\n    //If the node is a menu, print the menu's size\n    if (node->isMenu()) {\n      Serial.print(\" (\");\n      Serial.print(node->asMenu()->list->size());\n      Serial.print(\")\");\n    }\n\n    //Print a newline\n    Serial.println();\n\n    //If the node is a menu, recursively show the menu's list\n    if (node->isMenu()) {\n      showMenuList(node->asMenu(), layer + 1);\n    }\n  }\n}", "CodeBleu_score": 59.99834057936059}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  if (menu == NULL) {\n    return;\n  }\n  int i = 0;\n  for (i = 0; i < menu->list->size(); i++) {\n    MenuNode * node = menu->list->get(i);\n    if (node != NULL) {\n      Serial.print(node->getName());\n      Serial.print(\"\n\");\n    }\n  }\n  Serial.print(\"\n\");\n}", "CodeBleu_score": 52.86809061490103}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  if (menu == NULL) {\n    Serial.println(F(\"The menu is NULL\"));\n    return;\n  }\n  MenuNode * node = menu->getFirstNode();\n  while (node != NULL) {\n    for (int i = 0; i < layer; i++) {\n      Serial.print(F(\"  \"));\n    }\n    Serial.println(node->getName());\n    if (node->hasChildren()) {\n      showMenuList(node->getChildren(), layer + 1);\n    }\n    node = node->getNext();\n  }\n  Serial.println();\n}", "CodeBleu_score": 47.30321537294653}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  Serial.println(\"Generating SSIDs...\");\n  int generated = 0;\n  for (int i = 0; i < count; i++) {\n    char ssid[7];\n    for (int j = 0; j < 6; j++) {\n      ssid[j] = random(97, 122);\n    }\n    ssid[6] = '\\0';\n    int channel = random(1, 11);\n    String mac = generateMAC();\n    ssids->add(new SSID(ssid, channel, mac));\n    Serial.println(ssid);\n    generated++;\n  }\n  Serial.print(\"Generated \");\n  Serial.print(generated);\n  Serial.println(\" SSIDs.\");\n  return generated;\n}", "CodeBleu_score": 42.336444724523524}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int i;\n  for (i = 0; i < count; i++) {\n    char ssid[6];\n    char mac[6];\n    int channel = random(1, 14);\n    for (int j = 0; j < 6; j++) {\n      ssid[j] = random(65, 90);\n      mac[j] = random(65, 90);\n    }\n    ssid[6] = '\\0';\n    mac[6] = '\\0';\n    Serial.println(\"SSID: \" + String(ssid) + \" MAC: \" + String(mac) + \" Channel: \" + String(channel));\n    ssids->add(new SSID(ssid, mac, channel));\n  }\n  return i;\n}", "CodeBleu_score": 42.38913528171978}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  Serial.println(\"Generating SSIDs...\");\n  for (int i = 0; i < count; i++) {\n    char ssid[7];\n    for (int j = 0; j < 6; j++) {\n      ssid[j] = random(65, 90);\n    }\n    ssid[6] = '\\0';\n    Serial.println(ssid);\n    ssids->add(ssid, random(1, 14), random(0x00, 0x7F), random(0x00, 0x7F), random(0x00, 0x7F), random(0x00, 0x7F), random(0x00, 0x7F));\n  }\n  Serial.println(\"Done.\");\n  return ssids->size();\n}", "CodeBleu_score": 48.00863899061719}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print('Topic created: {}'.format(topic))\n    return topic\n\n", "CodeBleu_score": 59.05327604491908}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Created topic: {topic}\")\n\n", "CodeBleu_score": 47.30410687693764}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(f\"Created topic: {topic}\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 47.30410687693764}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    import jwt\n    import datetime\n    import os\n\n    # Set issued time (iat) to current UTC time\n    iat = datetime.datetime.utcnow()\n\n    # Set expiration time (exp) to one hour later\n    exp = iat + datetime.timedelta(hours=1)\n\n    # Set audience (aud) to the provided GCP project ID\n    aud = project_id\n\n    # Read private key from file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create JWT payload\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': aud\n    }\n\n    # Create JWT\n    jwt_token = jwt.encode(payload, private_key, algorithm=algorithm)\n\n    return jwt_token\n\n", "CodeBleu_score": 56.317076086590255}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Message received:\")\n    print(\"Topic: {}\".format(message.topic))\n    print(\"QoS: {}\".format(message.qos))\n    print(\"Payload: {}\".format(message.payload))\n\n    if message.payload == b\"on\":\n        print(\"Capturing preview image...\")\n        preview_capture()\n\n        print(\"Uploading preview image to bucket...\")\n        upload_file()\n\n        print(\"Publishing URL to MQTT event topic...\")\n        unused_client.publish(\"projects/{}/locations/{}/registries/{}/devices/{}:publishEvent\".format(project_id, cloud_region, registry_id, device_id), \"https://storage.googleapis.com/{}/{}/{}\".format(bucket_name, device_id, file_name), qos=1)\n\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 30.14652033769426}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Received message '\" + payload + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos))\n    if payload == \"on\":\n        print(\"Capturing preview image...\")\n        preview_capture()\n        print(\"Uploading file to Cloud Storage...\")\n        upload_file()\n        print(\"Publishing URL to event topic...\")\n        unused_client.publish(\"projects/hermes-47850/topics/event\", payload=format(\"https://storage.googleapis.com/hermes-47850.appspot.com/{}\", file_name), qos=1)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 27.640879835980897}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Message received:\", payload)\n    print(\"Topic:\", message.topic)\n    print(\"QoS:\", message.qos)\n    if payload == \"on\":\n        print(\"Taking preview capture\")\n        preview_capture()\n        print(\"Uploading file\")\n        upload_file()\n        print(\"Publishing file URL\")\n        unused_client.publish(topic=\"events\", payload=payload, qos=1)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 24.79131570174411}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help='GCP cloud project name. If not set, defaults to the value of the '\n             '\"GOOGLE_CLOUD_PROJECT\" environment variable.')\n    parser.add_argument(\n        '--registry_id', required=True, help='Cloud IoT Core registry id')\n    parser.add_argument(\n        '--device_id', required=True, help='Cloud IoT Core device id')\n    parser.add_argument(\n        '--private_key_file',\n        required=True, help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        default='RS256',\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        choices=(8883, 443),\n        default=8883,\n        type=int,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,", "CodeBleu_score": 37.01682640056861}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT example.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--registry_id\", required=True, help=\"Cloud IoT Core registry id\"\n    )\n    parser.add_argument(\n        \"--device_id\", required=True, help=\"Cloud IoT Core device id\"\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        required=True,\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        default=\"RS256\",\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\"\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root certificate from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        choices=(8883, 443),\n        default=8883,\n        type=int,\n        help=\"MQTT bridge port.\",\n    )\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        default=20,\n        type=int,\n        help=\"Expiration time, in minutes, for J", "CodeBleu_score": 36.88263476124929}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT device connection example.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--registry_id\", required=True, help=\"Cloud IoT Core registry id\")\n    parser.add_argument(\"--device_id\", required=True, help=\"Cloud IoT Core device id\")\n    parser.add_argument(\"--private_key_file\", required=True, help=\"Path to private key file.\")\n    parser.add_argument(\"--algorithm\", choices=(\"RS256\", \"ES256\"), default=\"RS256\", help=\"Which encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\")\n    parser.add_argument(\"--ca_certs\", default=None, help=\"CA root certificate file (optional).\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", default=\"mqtt.googleapis.com\", help=\"MQTT bridge hostname.\")\n    parser.add_argument(\"--mqtt_bridge_port\", choices=(8883, 443), default=8883, type=int, help=\"MQTT bridge port.\")\n    parser.add_argument(\"--jwt_expires_minutes\", default=20, type=int, help=\"Expiration time, in minutes, for JWT tokens.\")\n    parser.add_argument(\"--message_type\", choices=(\"event\", \"state\"), default=\"event\", help=\"Indicates whether the message to be published is a telemetry event or a device state message.\")\n    parser.add_argument(\"--mqtt_topic\", default=\"\", help=\"MQTT topic to publish to.\")\n    parser.add_argument(\"--message_data\", default=\"\", help=\"Message data to publish.\")\n    return parser.parse_args()\n\n\n", "CodeBleu_score": 40.02224054675028}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # Define the API scopes and version.\n    scope = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    # Load the service account credentials.\n    credentials = ServiceAccountCredentials.from_service_account_file(\n        service_account_json, scopes=scope\n    )\n    # Build the client.\n    client = googleapiclient.discovery.build(\n        \"cloudiot\",\n        version,\n        discoveryServiceUrl=discovery_url,\n        credentials=credentials,\n    )\n    return client\n\n", "CodeBleu_score": 22.664464915380496}, {"code": "def get_client(service_account_json)\n\t\n\n    # Define the necessary API scopes\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n\n    # Define the version of the API to use\n    version = \"v1\"\n\n    # Define the discovery URL for the Cloud IoT Core API\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n\n    # Load the service account credentials\n    credentials = ServiceAccountCredentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n\n    # Build and return the client for the Cloud IoT Core API\n    return build(\n        \"cloudiot\",\n        version,\n        discoveryServiceUrl=discovery_url,\n        credentials=credentials,\n    )\n\n", "CodeBleu_score": 21.226220909701844}, {"code": "def get_client(service_account_json)\n\t\n    # Get the credentials from the service account JSON file\n    credentials = ServiceAccountCredentials.from_service_account_file(\n        service_account_json\n    )\n    # Define the scopes\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    # Define the discovery URL\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    # Scoping the credentials\n    credentials = credentials.with_scopes(scopes)\n    # Building the client\n    client = discovery.build(\n        \"cloudiot\",\n        \"v1\",\n        credentials=credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n    return client\n\n", "CodeBleu_score": 21.754882407009255}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = hash_method_to_asn1_code(hash_method)\n    if asn1_code == None:\n        raise ValueError('Invalid hash method.')\n    hash_value_with_asn1 = asn1_code + hash_value\n    padded_hash = _pad_for_signing(hash_value_with_asn1)\n    encrypted_signature = priv_key.blinded_encrypt(padded_hash)\n    return encrypted_signature\n\n", "CodeBleu_score": 31.503918755085635}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == \"sha1\":\n        asn1 = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == \"sha256\":\n        asn1 = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    else:\n        raise ValueError(\"Invalid hash method.\")\n    hash_value = asn1 + hash_value\n    hash_value = _pad_for_signing(hash_value)\n    signature = priv_key.blinded_encrypt(hash_value)\n    return signature\n\n", "CodeBleu_score": 27.92707994057929}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = hash_method_to_asn1(hash_method)\n    if hash_method_asn1 == None:\n        raise ValueError(\"Invalid hash method.\")\n    hash_value_asn1 = hash_method_asn1 + hash_value\n    hash_value_asn1_padded = _pad_for_signing(hash_value_asn1)\n    signature = priv_key.blinded_encrypt(hash_value_asn1_padded)\n    return signature\n\n", "CodeBleu_score": 29.675948465183666}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    sig_int = transform.bytes2int(signature)\n\n    # Decrypt the signature\n    clear_sig = core.decrypt_int(sig_int, pub_key)\n\n    # Determine the hash method\n    method_hash = _find_method_hash(clear_sig)\n\n    # Compute the hash of the message\n    message_hash = compute_hash(message, method_hash)\n\n    # Reconstruct the expected padded hash\n    expected_hash = _pad_for_signing(message_hash, method_hash)\n\n    # Check that the expected padded hash matches the clear signature\n    if expected_hash != clear_sig:\n        raise VerificationError(\"Invalid signature\")\n\n    return method_hash\n\n", "CodeBleu_score": 18.777632052291445}, {"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        signature = transform.bytes2int(signature)\n        signature = core.decrypt_int(signature, pub_key)\n        method_hash = _find_method_hash(signature)\n        message_hash = compute_hash(message, method_hash)\n        padded_hash = _pad_for_signing(message_hash, method_hash)\n        if padded_hash != signature:\n            raise VerificationError(\n                \"The signature does not match the message and the public key.\"\n            )\n        return method_hash\n    except VerificationError as e:\n        raise e\n    except Exception as e:\n        raise VerificationError(e)\n\n", "CodeBleu_score": 42.91347796556925}, {"code": "def verify(message, signature, pub_key)\n\t\n    signature = transform.bytes2int(signature)\n    clear_signature = core.decrypt_int(signature, pub_key)\n    method_hash, clear_message_hash = _find_method_hash(clear_signature)\n    message_hash = compute_hash(message, method_hash)\n    if message_hash != clear_message_hash:\n        raise VerificationError(\"Message hash doesn't match the clear signature.\")\n    return method_hash\n\n", "CodeBleu_score": 17.654270042525475}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t    time_t now = time(NULL);\n    if (now > 0) {\n        updateJWT(now);\n    }\n    MQTT_CLIENT_connect();\n    if (MQTT_CLIENT_isConnected()) {\n        debug_print(\"MQTT connection established\n\");\n        mqttSubscribe = true;\n    }\n}", "CodeBleu_score": 34.15260966815968}, {"code": "static void connectMQTT(){\n\t    time_t current_time = time(NULL);\n    if (current_time != -1) {\n        updateJWT(current_time);\n    }\n    MQTT_CLIENT_connect();\n    if (MQTT_CLIENT_isConnected()) {\n        SUBSCRIBE_FLAG = 1;\n    }\n    debug_print(\"MQTT connection attempt\n\");\n}", "CodeBleu_score": 30.823807581978457}, {"code": "static void connectMQTT(){\n\t    time_t currentTime = time(NULL);\n    if (currentTime > 0) {\n        updateJWT(currentTime);\n    }\n    MQTT_CLIENT_connect();\n    send_subscribe = true;\n    debug_print(\"Connecting to MQTT...\n\");\n}", "CodeBleu_score": 44.92266071965552}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tint i;\n\tuint32_t n = 0;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif ((str[i] >= '0') && (str[i] <= '9')) {\n\t\t\tn = (n * 10) + (str[i] - '0');\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 25.715029760806825}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    for (int ii = 0; ii < width; ii++) {\n        uint8_t ch = *str;\n        if (ch < '0' || ch > '9') return str;\n        value = value * 10 + (ch - '0');\n        str++;\n    }\n    *num = value;\n    return str;\n}", "CodeBleu_score": 22.03122655990674}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t i;\n    uint32_t n;\n\n    n = 0;\n    for (i = 0; i < width; i++) {\n        if (str[i] >= '0' && str[i] <= '9') {\n            n = n * 10 + (str[i] - '0');\n        } else {\n            return str;\n        }\n    }\n    *num = n;\n    return str + width;\n}", "CodeBleu_score": 25.617921988042763}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\n    int ret = 0;\n    uint8_t cert_sn_source[32];\n    size_t cert_sn_source_size = 0;\n    uint8_t cert_sn[32];\n    size_t cert_sn_size = 0;\n    uint8_t issue_date[DATEFMT_ISO8601_SEP] = { 0 };\n    uint8_t expire_date[DATEFMT_ISO8601_SEP] = { 0 };\n    atcacert_tm_utc_t issue_date_tm;\n    atcacert_tm_utc_t expire_date_tm;\n    uint8_t tbs_digest[32];\n    size_t tbs_digest_size = sizeof(tbs_digest);\n    uint8_t signature[72];\n    size_t signature_size = sizeof(signature);\n    uint8_t der_encoded_sig[72];\n    size_t der_encoded_sig_size = sizeof(der_encoded_sig);\n    int is_verified = 0;\n\n    if (build_state == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_sn_dev_loc.count > 0) {\n        cert_sn_source_size = sizeof(cert_sn_source);\n        ret = atcacert_read_cert_sn(build_state->cert_sn_dev_loc.cert_def,\n                                    build_state->cert_sn_dev_loc.cert_sn_dev,\n                                    build_state->cert_sn_dev_loc.count,\n                                    cert_sn_source,\n                                    &cert_sn_source_size);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n    } else {\n        cert_sn_source_size = build_state->cert_sn_source_size;\n        memcpy(cert_sn_source, build_state->cert_sn_source, cert_", "CodeBleu_score": 56.67284343459345}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t  int ret = 0;\n  uint8_t cert_sn_digest[32];\n  uint8_t cert_sn_digest_size = 0;\n  uint8_t cert_sn[9];\n  size_t cert_sn_size = sizeof(cert_sn);\n  uint8_t cert_sn_der[32];\n  size_t cert_sn_der_size = sizeof(cert_sn_der);\n  uint8_t cert_sn_der_temp[32];\n  size_t cert_sn_der_temp_size = sizeof(cert_sn_der_temp);\n\n  if (build_state == NULL) {\n    return ATCACERT_E_BAD_PARAMS;\n  }\n\n  // Calculate cert SN\n  ret = atcacert_get_cert_sn_digest(build_state->cert_def, build_state->cert, build_state->cert_size, cert_sn_digest, &cert_sn_digest_size);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  ret = atcacert_cert_sn_der_enc(cert_sn_digest, cert_sn_digest_size, cert_sn, &cert_sn_size);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  ret = atcacert_der_enc_length(cert_sn_size, cert_sn_der_temp, &cert_sn_der_temp_size);\n  if (ret != ATCACERT_E_SUCCESS) {\n    return ret;\n  }\n\n  cert_sn_der[0] = 0x02;  // Integer tag\n  memcpy(&cert_sn_der[1], cert_sn_der_temp, cert_sn_der_temp_size);\n  memcpy(&cert_sn_der[1 + cert_sn_der_temp_size], cert_sn, cert_sn_size);\n  cert_sn_der_size = 1 + cert_sn_der_temp", "CodeBleu_score": 59.830183107513704}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\n\tint ret = 0;\n\tuint8_t cert_sn_raw[36];\n\tsize_t cert_sn_raw_size = sizeof(cert_sn_raw);\n\tuint8_t cert_sn[36];\n\tsize_t cert_sn_size = sizeof(cert_sn);\n\tuint8_t issue_date_raw[13];\n\tsize_t issue_date_raw_size = sizeof(issue_date_raw);\n\tuint8_t expire_date_raw[13];\n\tsize_t expire_date_raw_size = sizeof(expire_date_raw);\n\tuint8_t tbs_digest[32];\n\tsize_t tbs_digest_size = sizeof(tbs_digest);\n\tuint8_t signature[72];\n\tsize_t signature_size = sizeof(signature);\n\tuint8_t signature_raw[72];\n\tsize_t signature_raw_size = sizeof(signature_raw);\n\tuint8_t signature_offset;\n\tsize_t signature_offset_size = sizeof(signature_offset);\n\tuint8_t signature_block_size;\n\tsize_t signature_block_size_size = sizeof(signature_block_size);\n\tuint8_t signature_location[72];\n\tsize_t signature_location_size = sizeof(signature_location);\n\tuint8_t signature_block_size_offset;\n\tsize_t signature_block_size_offset_size = sizeof(signature_block_size_offset);\n\tuint8_t signature_offset_offset;\n\tsize_t signature_offset_offset_size = sizeof(signature_offset_offset);\n\tuint8_t signature_offset_raw;\n\tsize_t signature_offset_raw_size = sizeof(signature_offset_raw);\n\tuint8_t signature_block_size_raw;\n\tsize_t signature_block_size_raw_size = sizeof(signature_block_size_raw);\n\tuint8_t signature_offset_calc;\n\tsize_t signature_offset_calc_size = sizeof(signature_", "CodeBleu_score": 8.341809590771335}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int                  ret = 0;\n    atcacert_device      device;\n    atcacert_cert_type_t cert_type;\n    atcacert_cert_sn_t   cert_sn;\n    uint8_t              tbs_digest[32];\n    uint8_t              signature[64];\n    uint8_t              public_key[72];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_cert_type(cert_def, &cert_type);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    if (cert_type == CERTTYPE_X509) {\n        ret = atcacert_get_device_locs(cert_def, &device);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n\n        ret = atcab_read_pubkey(device.dev_loc, public_key);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n    }\n\n    ret = atcacert_get_cert_sn(cert_def, cert, cert_size, cert_sn);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    if (cert_type == CERTTYPE_X509) {\n        ret = atcab_verify_extern(tbs_digest,", "CodeBleu_score": 73.90821981628007}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int                 ret = 0;\n    uint8_t             tbs_digest[32];\n    uint8_t             signature[64];\n    size_t              tbs_digest_size = sizeof(tbs_digest);\n    size_t              signature_size  = sizeof(signature);\n    atcacert_device     device_ctx;\n    atcacert_cert_loc_t tbs_cert_loc;\n    atcacert_cert_loc_t sig_cert_loc;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the TBS digest and signature from the certificate\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest, &tbs_digest_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature, &signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the TBS digest against the signature using the CA public key\n    device_ctx.cfg_zone.dev_type = ATECC508A;\n    device_ctx.cfg_zone.slot    = 0;\n    device_ctx.cfg_zone.is_genkey = 0;\n    device_ctx.cfg_zone.key_id   = 0;\n    device_ctx.cfg_zone.read_key = ca_public_key;\n    device_ctx.cfg_zone.zone     = DEVZONE_DATA;\n    device_ctx.cfg_zone.is_locked = 0;\n    device_ctx.cfg_zone.gen_key_count = 0;\n    device_ctx.cfg_zone.lock_config = 0;\n    device_ctx.cfg_zone.lock_value = 0;\n", "CodeBleu_score": 65.32843079997474}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n    int                 ret = 0;\n    uint8_t             tbs_digest[32];\n    uint8_t             signature[64];\n    const uint8_t*      tbs_digest_ptr = NULL;\n    const uint8_t*      signature_ptr  = NULL;\n    atcacert_device     device_loc;\n    uint8_t             device_loc_count = 0;\n    uint8_t             device_loc_list[3];\n    uint8_t             device_loc_list_count = 0;\n    uint8_t             device_loc_list_found = 0;\n    uint8_t             device_loc_list_found_count = 0;\n    uint8_t             device_loc_list_found_count_max = 0;\n    uint8_t             device_loc_list_found_count_max_index = 0;\n    uint8_t             device_loc_list_found_count_max_index_max = 0;\n    uint8_t             device_loc_list_found_count_max_index_max_count = 0;\n    uint8_t             device_loc_list_found_count_max_index_max_count_max = 0;\n    uint8_t             device_loc_list_found_count_max_index_max_count_max_index = 0;\n    uint8_t             device_loc_list_found_count_max_index_max_count_max_index_max = 0;\n    uint8_t             device_loc_list_found_count_max_index_max_count_max_index_max_count = 0;\n    uint8_t             device_loc_list_found_count_max_index_max_count_max_index_max_count_max = 0;\n    uint8_t             device_loc_list_found_count_max_index_max_count_max_index_max_count_max_index = 0;\n    uint8_t             device_loc_list_found_count_max_index_max_count_max_index_max", "CodeBleu_score": 18.64991077919522}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *current;\n    timerStruct_t * volatile *previous;\n    timerStruct_t * volatile *next;\n    timerStruct_t * volatile *newList;\n    timerStruct_t * volatile *newListTail;\n    timerStruct_t * volatile *newListHead;\n    timerStruct_t * volatile *newListTailPrev;\n    timerStruct_t * volatile *newListHeadNext;\n    timerStruct_t * volatile *newListTailPrevNext;\n    timerStruct_t * volatile *newListTailPrevNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNextNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNextNextNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNextNextNextNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNextNextNextNextNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext;\n    timerStruct_t * volatile *newListTailPrevNextNextNextNextNextNextNextNextNextNextNextNext", "CodeBleu_score": 8.432907090023967}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t *tmp = *list;\n    timerStruct_t *prev = NULL;\n\n    while(tmp != NULL) {\n        if(tmp == timer) {\n            if(prev != NULL) {\n                prev->next = tmp->next;\n            } else {\n                *list = tmp->next;\n            }\n            return true;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n    return false;\n}", "CodeBleu_score": 36.03512643432952}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t *tmp;\n\ttimerStruct_t *tmp2;\n\ttimerStruct_t *tmp3;\n\ttimerStruct_t *tmp4;\n\ttimerStruct_t *tmp5;\n\ttimerStruct_t *tmp6;\n\ttimerStruct_t *tmp7;\n\ttimerStruct_t *tmp8;\n\ttimerStruct_t *tmp9;\n\ttimerStruct_t *tmp10;\n\ttimerStruct_t *tmp11;\n\ttimerStruct_t *tmp12;\n\ttimerStruct_t *tmp13;\n\ttimerStruct_t *tmp14;\n\ttimerStruct_t *tmp15;\n\ttimerStruct_t *tmp16;\n\ttimerStruct_t *tmp17;\n\ttimerStruct_t *tmp18;\n\ttimerStruct_t *tmp19;\n\ttimerStruct_t *tmp20;\n\ttimerStruct_t *tmp21;\n\ttimerStruct_t *tmp22;\n\ttimerStruct_t *tmp23;\n\ttimerStruct_t *tmp24;\n\ttimerStruct_t *tmp25;\n\ttimerStruct_t *tmp26;\n\ttimerStruct_t *tmp27;\n\ttimerStruct_t *tmp28;\n\ttimerStruct_t *tmp29;\n\ttimerStruct_t *tmp30;\n\ttimerStruct_t *tmp31;\n\ttimerStruct_t *tmp32;\n\ttimerStruct_t *tmp33;\n\ttimerStruct_t *tmp34;\n\ttimerStruct_t *tmp35;\n\ttimerStruct_t *tmp36;\n\ttimerStruct_t *tmp37;\n\ttimerStruct_t *tmp38;\n\ttimerStruct_t *tmp39;\n\ttimerStruct_t *tmp40;\n\ttimerStruct_t *tmp41;\n\ttimerStruct_t *tmp42;\n\ttimerStruct_t *tmp43;\n\ttimerStruct_t *tmp44;\n\ttimerStruct_t *tmp45;\n\ttimerStruct_t *tmp46;\n\ttimerStruct_t *tmp47;\n\ttimerStruct_t", "CodeBleu_score": 6.699345653543761}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tstruct socketInfo *socketInfo;\n\tint ret;\n\n\t/* Get socket info */\n\tsocketInfo = getSocketInfo(socket);\n\tif (socketInfo == NULL) {\n\t\treturn BSD_ERROR;\n\t}\n\n\t/* Set socket state to NOT_A_SOCKET */\n\tsocketInfo->state = NOT_A_SOCKET;\n\n\t/* Call close */\n\tret = close(socket);\n\tif (ret < 0) {\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 28.581659797447273}, {"code": "int BSD_close(int socket){\n\t\tstruct socketInfo *socketInfo;\n\tint status;\n\n\tsocketInfo = getSocketInfo(socket);\n\tif (socketInfo == NULL) {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\treturn BSD_ERROR;\n\t}\n\tsocketInfo->state = NOT_A_SOCKET;\n\n\tstatus = close(socket);\n\tif (status < 0) {\n\t\tbsd_setErrNo(BSD_ENOTCONN);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 32.624676464711044}, {"code": "int BSD_close(int socket){\n\t\tint retval;\n\tstruct socketInfo *socketInfo;\n\n\t/* Get socket info */\n\tsocketInfo = getSocketInfo(socket);\n\tif (socketInfo == NULL) {\n\t\terrno = EBADF;\n\t\treturn BSD_ERROR;\n\t}\n\n\t/* Set socket state to NOT_A_SOCKET */\n\tsocketInfo->state = NOT_A_SOCKET;\n\n\t/* Close socket */\n\tretval = close(socket);\n\tif (retval < 0) {\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 31.89477867926957}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint response;\n\t\n\t/* Set the socket to listen */\n\tresponse = listen(socket, backlog);\n\t\n\t/* If the response is -1, an error occurred */\n\tif (response == -1) {\n\t\t/* Set the error number and return BSD_ERROR */\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\t/* Return BSD_SUCCESS */\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 24.18358157655068}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint response;\n\n\tresponse = listen(socket, backlog);\n\tif (response == -1) {\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 24.18358157655068}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint response;\n\t\n\t/* Set the socket to listen for incoming connections. */\n\tresponse = listen(socket, backlog);\n\t\n\t/* If the response is not equal to 0, an error occurred. */\n\tif (response != 0) {\n\t\t/* Set the error number. */\n\t\tbsd_setErrNo(response);\n\t\t\n\t\t/* Return the error code. */\n\t\treturn BSD_ERROR;\n\t}\n\t\n\t/* Return the success code. */\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 24.46312040454784}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tstruct sockaddr_in * sockaddr_in_ptr;\n\tstruct sockaddr_in6 * sockaddr_in6_ptr;\n\tstruct sockaddr_ll * sockaddr_ll_ptr;\n\tstruct sockaddr_storage sockaddr_storage;\n\tsocklen_t sockaddr_storage_len;\n\tint retval;\n\n\t/*\n\t * If the socket is invalid, set errno accordingly.\n\t */\n\tif (socket < 0 || socket >= MAX_SOCKETS) {\n\t\tbsd_setErrNo(EBADF);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * If the socket is not in the LISTEN state, set errno accordingly.\n\t */\n\tif (socket_table[socket].state != SOCKET_STATE_LISTEN) {\n\t\tbsd_setErrNo(EINVAL);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * If the socket is not stream, set errno accordingly.\n\t */\n\tif (socket_table[socket].type != SOCKET_TYPE_STREAM) {\n\t\tbsd_setErrNo(EOPNOTSUPP);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * If the socket is not bound, set errno accordingly.\n\t */\n\tif (socket_table[socket].bound == 0) {\n\t\tbsd_setErrNo(EINVAL);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * If the socket is not listening, set errno accordingly.\n\t */\n\tif (socket_table[socket].listening == 0) {\n\t\tbsd_setErrNo(EINVAL);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * If the address pointer is NULL, set errno accordingly.\n\t */\n\tif (addr == NULL) {\n\t\tbsd_setErrNo(EFAULT);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * If the address length pointer is NULL, set errno accordingly.\n\t */\n\tif (addrlen == NULL) {\n\t\tb", "CodeBleu_score": 34.6549023967462}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint retval;\n\tstruct sockaddr_in * addr_in;\n\tstruct sockaddr_in6 * addr_in6;\n\tstruct sockaddr_un * addr_un;\n\tstruct sockaddr_ll * addr_ll;\n\tstruct sockaddr_storage * addr_storage;\n\tstruct sockaddr_storage addr_storage_in;\n\tstruct sockaddr_storage addr_storage_in6;\n\tstruct sockaddr_storage addr_storage_un;\n\tstruct sockaddr_storage addr_storage_ll;\n\tsocklen_t addr_len;\n\tsocklen_t addr_len_in;\n\tsocklen_t addr_len_in6;\n\tsocklen_t addr_len_un;\n\tsocklen_t addr_len_ll;\n\tsocklen_t addr_len_storage;\n\tsocklen_t addr_len_storage_in;\n\tsocklen_t addr_len_storage_in6;\n\tsocklen_t addr_len_storage_un;\n\tsocklen_t addr_len_storage_ll;\n\n\tif (addr == NULL) {\n\t\tbsd_setErrNo(EFAULT);\n\t\treturn -1;\n\t}\n\n\tswitch (addr->sa_family) {\n\t\tcase BSD_AF_INET:\n\t\t\taddr_len = sizeof(struct sockaddr_in);\n\t\t\taddr_len_in = sizeof(struct sockaddr_in);\n\t\t\taddr_len_storage = sizeof(struct sockaddr_storage);\n\t\t\taddr_len_storage_in = sizeof(struct sockaddr_storage);\n\t\t\taddr_in = (struct sockaddr_in *) addr;\n\t\t\taddr_storage = (struct sockaddr_storage *) &addr_storage_in;\n\t\t\tmemcpy(addr_storage, addr_in, addr_len_in);\n\t\t\taddr_len_in6 = sizeof(struct sockaddr_in6);\n\t\t\taddr_len_storage_in6 = sizeof(struct sockaddr_storage);\n\t\t\taddr_in6 = (struct sockaddr_in6", "CodeBleu_score": 27.653715831919452}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tstruct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n\tstruct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *) addr;\n\tint retval;\n\t\n\tif (addr->sa_family == AF_INET) {\n\t\tretval = accept(socket, (struct sockaddr *) addr_in, addrlen);\n\t\tif (retval < 0) {\n\t\t\tbsd_setErrNo(errno);\n\t\t}\n\t} else if (addr->sa_family == AF_INET6) {\n\t\tretval = accept(socket, (struct sockaddr *) addr_in6, addrlen);\n\t\tif (retval < 0) {\n\t\t\tbsd_setErrNo(errno);\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\tretval = -1;\n\t}\n\t\n\treturn retval;\n}", "CodeBleu_score": 37.3091493090692}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t  time_t now;\n  struct tm timeinfo;\n  int rc;\n\n  // Get the current time\n  time(&now);\n\n  // Set the time zone\n  setenv(\"TZ\", \"UTC\", 1);\n  tzset();\n\n  // Get the current time in struct tm format\n  gmtime_r(&now, &timeinfo);\n\n  // Check if the time is valid\n  if (timeinfo.tm_year < (2019 - 1900)) {\n    debug_print(\"Time is not valid, not connecting to MQTT\n\");\n    return;\n  }\n\n  // Update the JWT with the current time offset\n  updateJWT(now);\n\n  // Set the MQTT client parameters\n  MQTT_CLIENT.ipstack = &MQTT_NETWORK;\n  MQTT_CLIENT.id = MQTT_CLIENT_ID;\n  MQTT_CLIENT.username = MQTT_USERNAME;\n  MQTT_CLIENT.password = MQTT_PASSWORD;\n  MQTT_CLIENT.cleansession = true;\n\n  // Connect to the MQTT broker\n  debug_print(\"Connecting to MQTT\n\");\n  rc = MQTT_CLIENT_connect(&MQTT_CLIENT);\n  if (rc != MQTT_SUCCESS) {\n    debug_print(\"Failed to connect to MQTT, return code %d\n\", rc);\n    return;\n  }\n\n  // Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n  mqtt_subscribe_flag = true;\n}", "CodeBleu_score": 43.27097039826929}, {"code": "static void connectMQTT(){\n\t  time_t now;\n  time(&now);\n  if (now > 0) {\n    updateJWT(now);\n    debug_print(\"Connecting to MQTT...\");\n    MQTT_CLIENT_connect();\n    MQTT_CLIENT_set_flag(MQTT_CLIENT_FLAG_SUBSCRIBE);\n  }\n}", "CodeBleu_score": 24.05029553732015}, {"code": "static void connectMQTT(){\n\t\n  time_t now = 0;\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    Serial.println(\"Failed to obtain time\");\n    return;\n  }\n  time(&now);\n  Serial.print(\"Time is now: \");\n  Serial.println(now);\n  if (now < MIN_TIME) {\n    Serial.println(\"Time is not valid, not connecting to MQTT\");\n    return;\n  }\n  updateJWT();\n  debug_print(\"Connecting to MQTT... \");\n  MQTT_CLIENT_connect();\n  debug_println(\"OK\");\n  MQTT_CLIENT_setCallback(mqttCallback);\n  MQTT_CLIENT_subscribe(MQTT_TOPIC_COMMAND);\n}", "CodeBleu_score": 41.75214435815577}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t    debug_printError(\"CLOUD: Disconnecting from the cloud service...\");\n    if (MQTT_GetConnectionState() == CONNECTED) {\n        MQTT_ClientConnectionInfo_t *clientConnectionInfo = MQTT_GetClientConnectionInfo();\n        MQTT_Disconnect(clientConnectionInfo);\n    }\n}", "CodeBleu_score": 66.10646036840807}, {"code": "void CLOUD_disconnect(void){\n\t\tdebug_printError(\"CLOUD_disconnect: Disconnecting from cloud service\");\n\tif (MQTT_GetConnectionState() == MQTT_CONNECTION_STATE_CONNECTED) {\n\t\tMQTT_GetClientConnectionInfo(&mqttConnectionInfo);\n\t\tMQTT_Disconnect(&mqttConnectionInfo);\n\t}\n}", "CodeBleu_score": 56.57114944638448}, {"code": "void CLOUD_disconnect(void){\n\t\tdebug_printInfo(\"CLOUD: Disconnecting from cloud service\");\n\tif (MQTT_GetConnectionState() == CONNECTED) {\n\t\tMQTT_ClientInfo *clientInfo = MQTT_GetClientConnectionInfo();\n\t\tif (clientInfo != NULL) {\n\t\t\tMQTT_Disconnect(clientInfo->client);\n\t\t}\n\t}\n}", "CodeBleu_score": 63.46198283996266}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n\tbool retval = false;\n\n\tif (passed_wifi_creds == 1) {\n\n\t\tif (m2m_wifi_connect(passed_wifi_creds, (char *) wifi_ssid, strlen(wifi_ssid), M2M_WIFI_SEC_WPA_PSK, (char *) wifi_pass, M2M_WIFI_CH_ALL) == M2M_SUCCESS) {\n\n\t\t\tretval = true;\n\n\t\t} else {\n\n\t\t\tdebug_printError(\"wifi_connectToAp: m2m_wifi_connect failed\");\n\t\t\tnetworking_error_status = WIFI_CONNECTION_ERROR;\n\n\t\t}\n\n\t} else {\n\n\t\tif (m2m_wifi_default_connect() == M2M_SUCCESS) {\n\n\t\t\tretval = true;\n\n\t\t} else {\n\n\t\t\tdebug_printError(\"wifi_connectToAp: m2m_wifi_default_connect failed\");\n\t\t\tnetworking_error_status = WIFI_CONNECTION_ERROR;\n\n\t\t}\n\n\t}\n\n\treturn retval;\n\n}", "CodeBleu_score": 43.01341591989993}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t  bool ret = false;\n  if (passed_wifi_creds) {\n    if (M2M_SUCCESS != m2m_wifi_connect((char *)wifi_ssid, strlen(wifi_ssid), wifi_auth, (char *)wifi_pass, strlen(wifi_pass), 0)) {\n      debug_printError(\"m2m_wifi_connect failed\");\n      ret = false;\n    } else {\n      ret = true;\n    }\n  } else {\n    if (M2M_SUCCESS != m2m_wifi_default_connect()) {\n      debug_printError(\"m2m_wifi_default_connect failed\");\n      ret = false;\n    } else {\n      ret = true;\n    }\n  }\n  return ret;\n}", "CodeBleu_score": 46.143966368711176}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif (passed_wifi_creds == 1) {\n\t\t/*\n\t\t * The function \"m2m_wifi_connect\" attempts to connect to an access point using the specified SSID and password.\nIf the connection fails, it logs an error message, updates the networking error status, and returns false.\nIf the connection succeeds, it returns true.\n\t\t */\n\t\tif (!m2m_wifi_connect(wifi_creds.ssid, strlen(wifi_creds.ssid), wifi_creds.auth_type, wifi_creds.passphrase, M2M_WIFI_CH_ALL)) {\n\t\t\tdebug_printError(\"Failed to connect to AP\");\n\t\t\tnetwork_error = 1;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\t/*\n\t\t * The function \"m2m_wifi_default_connect\" attempts to connect to an access point using default credentials.\nIf the connection fails, it logs an error message, updates the networking error status, and returns false.\nIf the connection succeeds, it returns true.\n\t\t */\n\t\tif (!m2m_wifi_default_connect()) {\n\t\t\tdebug_printError(\"Failed to connect to AP\");\n\t\t\tnetwork_error = 1;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 37.84972863217669}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t    const client = generateClient()\n    const response = await client.graphql(\n        `\n            query {\n                listSensors {\n                    id\n                    geo {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        `\n    )\n    console.log(response)\n    if (response.data.listSensors.length > 0) {\n        console.log(`Retrieved ${response.data.listSensors.length} sensors`)\n        response.data.listSensors.forEach(sensor => {\n            const marker = document.createElement('div')\n            marker.className = 'marker'\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map)\n        })\n    }\n}", "CodeBleu_score": 52.24768919284194}, {"code": "async function DisplaySensors(map){\n\t    const client = generateClient();\n    const response = await client.graphql(`\n        {\n            listSensors {\n                id\n                geo {\n                    latitude\n                    longitude\n                }\n            }\n        }\n    `);\n    console.log(response);\n    if (response.data.listSensors.length > 0) {\n        console.log(`Retrieved ${response.data.listSensors.length} sensors.`);\n        response.data.listSensors.forEach((sensor) => {\n            const marker = document.createElement(\"div\");\n            marker.className = \"marker\";\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 56.97774959679084}, {"code": "async function DisplaySensors(map){\n\t    // Generate a client\n    const client = generateClient();\n    // Send a GraphQL query to fetch sensor data\n    const response = await client.graphql(`\n        query {\n            listSensors {\n                id\n                name\n                geo {\n                    latitude\n                    longitude\n                }\n            }\n        }\n    `);\n    // Log the API response\n    console.log(response);\n    // If the response contains data, log the retrieval of sensors\n    if (response.data) {\n        console.log(`Retrieved ${response.data.listSensors.length} sensors`);\n        // Iterate through each sensor\n        response.data.listSensors.forEach(sensor => {\n            // Create a marker\n            const marker = document.createElement('div');\n            marker.className = 'marker';\n            // Create a popup\n            const popup = new mapboxgl.Popup().setText(sensor.name);\n            // Add the marker to the map\n            new mapboxgl.Marker({\n                element: marker,\n                popup: popup\n            }).setLngLat([sensor.geo.longitude, sensor.geo.latitude]).addTo(map);\n        });\n    }\n}", "CodeBleu_score": 48.2618438334545}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"sensor-marker\";\n  marker.style.backgroundColor = sensor.color;\n  marker.style.border = `1px solid ${sensor.color}`;\n  return marker;\n}", "CodeBleu_score": 46.2221404740596}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    let sensorMarker = document.createElement(\"div\");\n    sensorMarker.id = sensor.id;\n    sensorMarker.className = \"sensor-marker\";\n    sensorMarker.style.backgroundColor = \"green\";\n    sensorMarker.style.border = \"1px solid black\";\n    return sensorMarker;\n}", "CodeBleu_score": 48.0249826989185}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    let marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor\";\n    marker.style.backgroundColor = sensor.color;\n    marker.style.border = \"1px solid black\";\n    return marker;\n}", "CodeBleu_score": 46.85940639877829}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.auth.mfa_modules.{module_name}\"\n\n    try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import multi-factor authentication module %s: %s\", module_path, err\n        )\n        raise HomeAssistantError(\n            f\"Unable to import multi-factor authentication module {module_path}\"\n        ) from err\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module_path, module.REQUIREMENTS\n        )\n\n    if not hass.config.skip_pip and hasattr(module, \"REQUIREMENTS_ONLY_ON_CORE\"):\n        await requirements.async_process_requirements(\n            hass, module_path, module.REQUIREMENTS_ONLY_ON_CORE\n        )\n\n    if hasattr(module, \"REQUIREMENTS_CLI\"):\n        await requirements.async_process_requirements(\n            hass, module_path, module.REQUIREMENTS_CLI\n        )\n\n    if hasattr(module, \"REQUIREMENTS_CLI_ONLY_ON_CORE\"):\n        await requirements.async_process_requirements(\n            hass, module_path, module.REQUIREMENTS_CLI_ONLY_ON_CORE\n        )\n\n    return module\n\n", "CodeBleu_score": 47.551197746049965}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.auth.mfa_modules.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Unable to import multi-factor auth module %s: %s\", module_path, err)\n        raise HomeAssistantError(\n            f\"Unable to import multi-factor auth module {module_path}: {err}\"\n        ) from err\n    if not hasattr(module, \"REQUIREMENTS\") or not hass.config.skip_pip:\n        return module\n    processed = hass.data.get(DATA_REQS, set())\n    if module_name in processed:\n        return module\n    requirements.async_process_requirements(hass, module.REQUIREMENTS)\n    processed.add(module_name)\n    hass.data[DATA_REQS] = processed\n    return module\n\n", "CodeBleu_score": 61.913204732089035}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f'homeassistant.components.auth.mfa_modules.{module_name}'\n\n    try:\n        module = await hass.async_add_executor_job(importlib.import_module, module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            'Unable to import multi-factor authentication module %s: %s',\n            module_name,\n            err,\n        )\n        raise HomeAssistantError(\n            f'Unable to import multi-factor authentication module {module_name}: {err}'\n        ) from err\n\n    if hasattr(module, 'REQUIREMENTS') and not hass.config.skip_pip:\n        processed = hass.data.get(DATA_MFA_MODULE_IMPORTS, set())\n\n        if module_name not in processed:\n            await requirements.async_process_requirements(\n                hass, module_name, module.REQUIREMENTS\n            )\n\n            processed.add(module_name)\n            hass.data[DATA_MFA_MODULE_IMPORTS] = processed\n\n    return module\n", "CodeBleu_score": 53.558458833584034}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        raise InvalidSetupData(\"pin is required\")\n    if not isinstance(pin, str):\n        raise InvalidSetupData(\"pin must be a string\")\n    if len(pin) != 4:\n        raise InvalidSetupData(\"pin must be 4 characters long\")\n    if not pin.isnumeric():\n        raise InvalidSetupData(\"pin must be numeric\")\n\n    if user_id in self.data:\n        self.data[user_id] = pin\n        return self.data[user_id]\n\n    self.data.append({\"id\": user_id, \"pin\": pin})\n    return self.data[-1]\n\n", "CodeBleu_score": 36.82674633227319}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        raise SetupError(\"pin is required\")\n    if not isinstance(pin, str):\n        raise SetupError(\"pin must be a string\")\n    if not pin.isdigit():\n        raise SetupError(\"pin must be a number\")\n    pin = int(pin)\n    if pin < 100000 or pin > 999999:\n        raise SetupError(\"pin must be between 100000 and 999999\")\n    if not self.data.get(user_id):\n        self.data[user_id] = {}\n    self.data[user_id][\"pin\"] = pin\n    return {\"pin\": pin}\n\n", "CodeBleu_score": 32.541606004194115}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        raise InvalidSetupData(\"pin not found\")\n    if len(pin) != 6:\n        raise InvalidSetupData(\"pin must be 6 digits\")\n    if not pin.isdigit():\n        raise InvalidSetupData(\"pin must be numeric\")\n    pin = int(pin)\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n    return {\"pin\": pin}\n\n", "CodeBleu_score": 32.07703330272883}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._async_lock:\n        if self._async_loaded:\n            return\n        data = await self._async_load_data()\n        if data is None:\n            data = {}\n        self._async_data = data\n        self._async_loaded = True\n        self._async_update_items()\n\n", "CodeBleu_score": 23.92376857714708}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._lock:\n        if self._loaded:\n            return\n\n        data = await self._store.async_load()\n\n        if data is None:\n            data = {}\n\n        self._items = {\n            item_id: NotifySetting(item_id, item)\n            for item_id, item in data.items()\n        }\n        self._loaded = True\n\n", "CodeBleu_score": 34.39760109768416}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self.data is not None:\n            return\n\n        data = await self._store.async_load()\n        self.data = data if data is not None else {}\n\n        for user_id, user_data in self.data.items():\n            self.items[user_id] = NotifySetting(user_id, user_data)\n\n", "CodeBleu_score": 35.84591952552776}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load(user_id)\n    settings = self._settings.get(user_id)\n    if settings is None:\n        return False\n    otp = user_input[CONF_CODE]\n    if not otp:\n        return False\n    if settings.otp_secret is None:\n        return False\n    return await self.hass.async_add_executor_job(\n        partial(pyotp.TOTP(settings.otp_secret).verify, otp)\n    )\n\n", "CodeBleu_score": 55.21050387055462}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    user_settings = self._user_settings.get(user_id)\n    if not user_settings:\n        return False\n    return await self.hass.async_add_executor_job(\n        self._validate, user_settings, user_input\n    )\n\n", "CodeBleu_score": 43.6299975698601}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    if user_id not in self.data:\n        return False\n    user_settings = self.data[user_id]\n    if user_settings.get(CONF_NOTIFICATIONS) is None:\n        return False\n    if user_input.get(CONF_NOTIFICATIONS) is None:\n        return False\n    if user_input[CONF_NOTIFICATIONS] == user_settings[CONF_NOTIFICATIONS]:\n        return True\n    return await self.hass.async_add_executor_job(\n        self._validate_otp, user_input[CONF_NOTIFICATIONS]\n    )\n\n", "CodeBleu_score": 48.427312815549215}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.async_get_entity(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.async_get_device(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 61.238161503782706}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    if (entity_entry := perm_lookup.async_get_entity(entity_id)) is None:\n        return None\n    if (device_entry := perm_lookup.async_get_device(entity_entry.device_id)) is None:\n        return None\n    if (area_id := device_entry.area_id) is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 47.2493956657827}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    # Fetch the entity entry using the entity ID.\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n    # Fetch the device entry and check if it has an associated area.\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None or device_entry.area_id is None:\n        return None\n    # Return the permissions for the area from the provided area dictionary.\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 72.12790515445224}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = {}\n    seen = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen:\n                seen.add(category)\n                merged_policy[category] = _merge_policies(\n                    [policy.get(category) for policy in policies]\n                )\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 56.357185894408424}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy = {}\n    seen = set()\n    for p in policies:\n        for cat in p:\n            if cat not in seen:\n                seen.add(cat)\n                policy[cat] = {k: v for d in policies for k, v in d[cat].items()}\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 34.01224187307553}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen: set = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen:\n                seen.add(category)\n                merged_policy[category] = merge_categories(\n                    [policy[category] for policy in policies]\n                )\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 59.93992973054381}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await hass.async_add_executor_job(\n            importlib.import_module, f\"homeassistant.auth.{provider}\"\n        )\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to load auth provider module %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Unable to load auth provider module {provider}\"\n        ) from err\n\n    if not hasattr(module, \"CONFIG_SCHEMA\") or not hasattr(\n        module, \"STORAGE_KEY\"\n    ):\n        _LOGGER.error(\n            \"Auth provider module %s is missing required attributes\", provider\n        )\n        raise HomeAssistantError(\n            f\"Auth provider module {provider} is missing required attributes\"\n        )\n\n    processed.add(module.__name__)\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n\n    return module\n", "CodeBleu_score": 47.04252448618219}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    module = await async_import_module(\n        f\"homeassistant.auth.providers.{provider}\",\n        __name__,\n        hass.config.skip_pip,\n    )\n    if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n        raise HomeAssistantError(f\"No AUTH_PROVIDER_SCHEMA defined for {provider}\")\n    if not hasattr(module, \"AUTH_PROVIDER_NAME\"):\n        raise HomeAssistantError(f\"No AUTH_PROVIDER_NAME defined for {provider}\")\n    if not hasattr(module, \"AUTH_PROVIDER_CLASS\"):\n        raise HomeAssistantError(f\"No AUTH_PROVIDER_CLASS defined for {provider}\")\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        raise HomeAssistantError(f\"No CONFIG_SCHEMA defined for {provider}\")\n    if not hasattr(module, \"CONFIG_FLOW\"):\n        raise HomeAssistantError(f\"No CONFIG_FLOW defined for {provider}\")\n    if not hasattr(module, \"STORAGE_KEY\"):\n        raise HomeAssistantError(f\"No STORAGE_KEY defined for {provider}\")\n    if not hasattr(module, \"STORAGE_VERSION\"):\n        raise HomeAssistantError(f\"No STORAGE_VERSION defined for {provider}\")\n    if not hasattr(module, \"STORAGE_ENCRYPT\"):\n        raise HomeAssistantError(f\"No STORAGE_ENCRYPT defined for {provider}\")\n    if not hasattr(module, \"SETTINGS_KEY\"):\n        raise HomeAssistantError(f\"No SETTINGS_KEY defined for {provider}\")\n    if not hasattr(module, \"SETTINGS_SCHEMA\"):\n        raise HomeAssistantError(f\"No SETTINGS_SCHEMA defined for {provider}\")\n    if not hasattr(module, \"SETTINGS_STORAGE_KEY\"):\n        raise HomeAssistantError(f\"No SETTINGS_STORAGE_KEY defined for {provider", "CodeBleu_score": 25.26855748505643}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await hass.async_add_executor_job(\n            importlib.import_module, f\"homeassistant.auth.{provider}\"\n        )\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import auth provider module homeassistant.auth.%s: %s\",\n            provider,\n            err,\n        )\n        raise HomeAssistantError(\n            f\"Unable to load auth provider module homeassistant.auth.{provider}: {err}\"\n        ) from err\n    if not hasattr(module, \"REQUIREMENTS\") or not requirements.SKIP_REQUIREMENTS:\n        return module\n    processed = hass.data.get(requirements.DATA_PIP_LOCK)\n    if processed is None:\n        processed = set()\n        hass.data[requirements.DATA_PIP_LOCK] = processed\n    requirements.async_process_requirements(\n        hass, module.REQUIREMENTS, processed, requirements.RequirementsType.AUTH_PROVIDER\n    )\n    return module\n\n", "CodeBleu_score": 49.45331463417311}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self.store.async_load()\n    except HomeAssistantError:\n        data = {}\n\n    if data is None:\n        data = {}\n\n    self._async_check_for_not_normalized_usernames(data)\n    self.users = UserManager(self, data.get(self.key, {}))\n\n", "CodeBleu_score": 44.1118697908051}, {"code": "async def async_load(self) -> None\n\t\n    self._async_check_for_not_normalized_usernames\n\n", "CodeBleu_score": 1.9780847537680355}, {"code": "async def async_load(self) -> None\n\t\n    self._users = await self.store.async_load()\n    if self._users is None:\n        self._users = {}\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 24.363892708907844}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == normalized_username:\n            password_hash = base64.b64decode(user.password_hash)\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n            raise InvalidAuth\n    bcrypt.checkpw(b\"\", dummy_hash)\n    raise InvalidAuth\n\n", "CodeBleu_score": 39.20837578938621}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == normalized_username:\n            stored_hash = base64.b64decode(user.password)\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise InvalidAuth()\n    # If no matching user is found, perform a dummy hash check to prevent timing attacks\n    bcrypt.checkpw(b\"\", dummy_hash)\n    raise InvalidAuth()\n", "CodeBleu_score": 38.1989897507239}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b'', bcrypt.gensalt())\n    for user in self.users:\n        if self.normalize_username(user.username) == normalized_username:\n            password_hash = base64.b64decode(user.password_hash)\n            if bcrypt.checkpw(password.encode('utf-8'), password_hash):\n                return\n            else:\n                bcrypt.checkpw(b'', dummy_hash)\n                raise InvalidAuth()\n    bcrypt.checkpw(b'', dummy_hash)\n    raise InvalidAuth()\n", "CodeBleu_score": 38.950963650927775}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 37.1802918522876}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 37.1802918522876}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    for index, user in enumerate(self.users):\n        if user.username == normalized_username:\n            del self.users[index]\n            return\n    raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 33.68478592433007}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.async_is_initialized:\n        await self.async_initialize\n    try:\n        await self.async_remove_auth(credentials.username)\n        await self.async_save\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 44.313325995043385}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    self.async_initialize\n    try:\n        async_remove_auth\n    except Exception:\n        pass\n\n", "CodeBleu_score": 20.65172789356266}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    await self.async_initialize()\n    try:\n        self.async_remove_auth(credentials)\n        await self.async_save()\n    except ValueError:\n        pass\n\n", "CodeBleu_score": 37.381519202114966}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout=timeout)\n        except TimeoutError:\n            continue\n        else:\n            joined.add(thread)\n    if log:\n        _log_thread_running_at_shutdown(threads - joined)\n    async_raise(threads - joined, SystemExit)\n    return joined\n\n", "CodeBleu_score": 52.71403451296226}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        with contextlib.suppress(SystemExit):\n            thread.join(timeout=timeout)\n            joined.add(thread)\n    if log:\n        _log_thread_running_at_shutdown(threads - joined)\n    async_raise(threads - joined, SystemExit)\n    return joined\n\n", "CodeBleu_score": 53.40680980670246}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout=timeout)\n        except TimeoutError:\n            continue\n        else:\n            joined.add(thread)\n    if log:\n        _log_thread_running_at_shutdown(threads - joined)\n    async_raise(threads - joined, SystemExit)\n    return joined\n\n", "CodeBleu_score": 53.85386986682021}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [t for t in threading.enumerate() if t != threading.main_thread() and not t.daemon and t.is_alive()]\n    timeout = 0\n    if threads:\n        timeout = shutdown_timeout / len(threads)\n        for thread in threads:\n            try:\n                thread.join(timeout)\n            except Exception:\n                _LOGGER.warning(\n                    \"Failed to join thread %s with id %s\", thread.name, thread.ident\n                )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 33.13532182389959}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread()\n        and not thread.is_daemon()\n        and thread.is_alive()\n    ]\n    timeout = 0.0\n    if threads:\n        timeout = shutdown_timeout / len(threads)\n        for thread in threads:\n            try:\n                thread.join(timeout)\n            except Exception:  # pylint: disable=broad-except\n                _LOGGER.warning(\"Failed to join thread %s\", thread.name)\n\n", "CodeBleu_score": 42.56102234572061}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # The following line is a comment.\n    # Comments are ignored by the interpreter.\n    # Comments are used to explain what the code does.\n    # Comments are not executed by the interpreter.\n    # Comments are not compiled by the compiler.\n    # Comments are not included in the bytecode.\n    # Comments are not included in the executable.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included in the documentation.\n    # Comments are not included", "CodeBleu_score": 0.5}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self.async_dispatcher_send_internal(\n            SIGNAL_SETUP_STARTED, remaining_with_setup_started\n        )\n        self._remaining_with_setup_started = remaining_with_setup_started\n    else:\n        self._remaining_with_setup_started = None\n\n\n async def async_setup(\n    self,\n    hass: HomeAssistant,\n    config: ConfigType,\n    async_reg: Optional[bool] = True,\n    integration: Optional[Integration] = None,\n    **kwargs: Any,", "CodeBleu_score": 45.73230053105297}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self.async_dispatcher_send_internal(\n            SIGNAL_SETUP_STARTED, remaining_with_setup_started\n        )\n        self._setup_started = True\n    else:\n        self._setup_started = False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 42.42424833871687}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self.async_dispatcher_send_internal(\n            SIGNAL_SETUP_STARTED, remaining_with_setup_started\n        )\n        self._remaining_with_setup_started = remaining_with_setup_started\n    else:\n        self._remaining_with_setup_started = None\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 49.12620509569992}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not integrations:\n        return\n\n    bluetooth_path = config.cache_dir / \"bluetooth.py\"\n    bluetooth_template = config.cache_dir / \"bluetooth.py.template\"\n    bluetooth_template.write_text(BLUETOOTH_TEMPLATE)\n\n    if not config.specific_integrations:\n        try:\n            current_content = bluetooth_path.read_text()\n        except FileNotFoundError:\n            pass\n        else:\n            if current_content == BLUETOOTH_TEMPLATE:\n                return\n\n    bluetooth_path.write_text(generate_bluetooth(integrations))\n\n    config.add_error(\n        \"bluetooth\",\n        \"Bluetooth configuration is not up to date\",\n        hint=\"Please run script 'develop' to update it\",\n        fixable=True,\n    )\n\n", "CodeBleu_score": 43.12059645612166}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not integrations:\n        return\n\n    bluetooth_path = config.cache_dir / \"bluetooth.py\"\n    bluetooth_content = generate_bluetooth_content(integrations)\n    if bluetooth_path.is_file():\n        current_content = bluetooth_path.read_text()\n        if current_content != bluetooth_content:\n            config.add_error(\n                \"bluetooth\",\n                \"bluetooth.py is not up to date, run script to update it\",\n                fixable=True,\n                fix_hint=\"Run script again to update bluetooth.py\",\n            )\n    else:\n        bluetooth_path.write_text(bluetooth_content)\n\n", "CodeBleu_score": 44.88298074933037}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.specific_integrations:\n        current_bluetooth = fp.read_text(config.cache_dir / \"bluetooth.py\")\n        generated_bluetooth = generate_bluetooth(integrations)\n        if current_bluetooth != generated_bluetooth:\n            config.add_error(\n                \"bluetooth.py is not up to date. Run script 'develop' to update.\",\n                fix=f\"{config.env_script} develop\",\n            )\n    else:\n        generated_bluetooth = generate_bluetooth(integrations)\n        fp.write_text(config.cache_dir / \"bluetooth.py\", generated_bluetooth)\n\n", "CodeBleu_score": 42.04235533843354}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp := &RefreshTokenResponse{}\n\te := &Error{}\n\tlogger := d.Logger\n\tbase := d.Base\n\n\tif base.RefreshToken == \"\" {\n\t\treturn errors.New(\"refresh token is empty\")\n\t}\n\n\tif base.Debug {\n\t\tlogger.Debug(\"refresh token called\",\n\t\t\tzap.String(\"base\", \"Dropbox\"),\n\t\t)\n\t}\n\n\tif err := base.RefreshTokenIsValid(); err != nil {\n\t\treturn err\n\t}\n\n\tif base.Debug {\n\t\tlogger.Debug(\"refresh token\",\n\t\t\tzap.String(\"base\", \"Dropbox\"),\n\t\t\tzap.String(\"url\", base.Addition.TokenURL),\n\t\t\tzap.String(\"app_key\", base.Addition.AppKey),\n\t\t\tzap.String(\"app_secret\", base.Addition.AppSecret),\n\t\t\tzap.String(\"refresh_token\", base.RefreshToken),\n\t\t)\n\t}\n\n\t_, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": base.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(base.Addition.AppKey, base.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.Addition.TokenURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif e.Error != \"\" {\n\t\tlogger.Info(\"refresh token\",\n\t\t\tzap.String(\"base\", \"Dropbox\"),\n\t\t\tzap.String(\"url\", base.Addition.TokenURL),\n\t\t\tzap.String(\"app_key\", base.Addition.AppKey),\n\t\t\tzap.String(\"app_secret\", base.Addition.AppSecret),\n\t\t\tzap.String(\"refresh_token\", base.RefreshToken),\n\t\t\tzap.String(\"error\", res.String()),\n\t\t)\n\t\t", "CodeBleu_score": 55.1005544455311}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Refresh the access token.\n\tresp := new(oauth2.Token)\n\te := new(error)\n\tbase.RestyClient.R().SetResult(resp).SetError(e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(\"https://api.dropboxapi.com/oauth2/token\")\n\tif *e != nil {\n\t\tlogger.Info(res.String())\n\t\treturn *e\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 53.77319381657142}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp dropboxResp\n\tvar e dropboxError\n\n\t_, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(\"https://api.dropboxapi.com/oauth2/token\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif e.Error != \"\" {\n\t\tlogger.Info(e.ErrorDescription)\n\t\treturn fmt.Errorf(e.ErrorDescription)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 72.39950335483226}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tif d.token == nil {\n\t\treturn nil, fmt.Errorf(\"no token\")\n\t}\n\n\t// Create a request\n\treq := d.client.R().SetError(nil).SetResult(resp)\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\t// Set authorization header\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\n\t// Set query parameters for supporting all drives\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\n\t// Send the request\n\tvar err error\n\tvar respBody []byte\n\tfor i := 0; i < 2; i++ {\n\t\tresp, err := req.Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trespBody = resp.Body()\n\n\t\t// Check the response code\n\t\tif resp.StatusCode() != 401 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Refresh the token if a 401 error occurs\n\t\tif err := d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the response body\n\tif respBody == nil {\n\t\treturn nil, fmt.Errorf(\"no response\")\n\t}\n\n\treturn respBody, nil\n}", "CodeBleu_score": 56.97403467862181}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar body []byte\n\tvar err error\n\tvar req *resty.Request\n\tvar respBody []byte\n\tvar r *base.RestyClient\n\tvar s string\n\tvar statusCode int\n\tvar token string\n\tvar urlStr string\n\n\tr = base.RestyClient.R()\n\tif callback != nil {\n\t\tcallback(r)\n\t}\n\tif resp != nil {\n\t\tr.SetResult(resp)\n\t}\n\tr.SetError(resp)\n\tr.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\tr.SetHeader(\"Accept\", \"application/json\")\n\tr.SetHeader(\"Content-Type\", \"application/json\")\n\tr.SetHeader(\"X-Upload-Content-Type\", \"application/json\")\n\tr.SetHeader(\"X-Upload-Content-Length\", \"0\")\n\tr.SetHeader(\"X-Goog-Upload-Protocol\", \"resumable\")\n\tr.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\tr.SetHeader(\"X-Goog-Upload-Header-Content-Length\", \"0\")\n\tr.SetHeader(\"X-Goog-Upload-Header-Content-Type\", \"application/json\")\n\tr.SetHeader(\"X-Goog-Upload-File-Name\", \"file.json\")\n\tr.SetHeader(\"X-Goog-Upload-Raw-Size\", \"0\")\n\tr.SetHeader(\"X-Goog-Upload-Protocol\", \"resumable\")\n\tr.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\tr.SetHeader(\"X-Goog-Upload-Header-Content-Length\", \"0\")\n\tr.SetHeader(\"X-Goog-Upload-Header-Content-Type\", \"application/json\")\n\tr.SetHeader(\"X-Goog-Upload-File-Name\", \"file.json\")\n\tr.SetHeader(\"X-Goog-Upload-Raw-Size\", \"0\")\n\tr.SetHeader(\"X-Goog-Upload-Protocol\", \"resumable\")\n\tr.SetHeader(\"X-Goog-Upload-Command\", \"start\")\n\tr.", "CodeBleu_score": 33.501935735122075}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tif d.token == nil {\n\t\treturn nil, fmt.Errorf(\"no token\")\n\t}\n\tif d.token.Expired() {\n\t\tif err := d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tclient := base.RestyClient.R()\n\tif callback != nil {\n\t\tcallback(client)\n\t}\n\tclient.SetHeader(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\tclient.SetQueryParam(\"supportsAllDrives\", \"true\")\n\tclient.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\tclient.SetResult(resp)\n\tclient.SetError(resp)\n\tif resp != nil {\n\t\tclient.SetBody(resp)\n\t}\n\tr, err := client.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif r.StatusCode() == http.StatusUnauthorized {\n\t\tif err := d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tclient.SetHeader(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\t\tr, err = client.Execute(method, url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif r.StatusCode() >= 400 {\n\t\treturn nil, fmt.Errorf(\"%s\", r.Body())\n\t}\n\treturn r.Body(), nil\n}", "CodeBleu_score": 63.04702704115633}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(30 * 1024 * 1024)\n\tfinish := int64(0)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tif finish >= stream.GetSize() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif stream.GetSize()-finish < chunkSize {\n\t\t\t\tchunkSize = stream.GetSize() - finish\n\t\t\t}\n\t\t\treq := d.request(ctx).SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize))\n\t\t\tresp, err := req.Post(url)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif resp.StatusCode != 308 {\n\t\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t\t\t}\n\t\t\tfinish += chunkSize\n\t\t}\n\t}\n}", "CodeBleu_score": 59.4623985230106}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(30 * 1024 * 1024)\n\tfinish := int64(0)\n\tfor {\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t\tif stream.GetSize()-finish < chunkSize {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t\treq := d.request().SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\tif _, err := req.Post(url); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 59.82446387288862}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(30 * 1024 * 1024)\n\tfinish := int64(0)\n\tfor {\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t\tif stream.GetSize()-finish < chunkSize {\n\t\t\tchunkSize = stream.GetSize() - finish\n\t\t}\n\t\treq := d.request(ctx, \"PUT\", url, nil).SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize))\n\t\tif _, err := req.SetContext(ctx).Response(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 61.22681726406136}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, make(map[string]interface{}))\n}", "CodeBleu_score": 40.81702607902209}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tmountPoint := ctx.Bind(&common_dto.MountPoint{}).(*common_dto.MountPoint).MountPoint\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_dto.NewResponse(common_dto.BadRequest, \"mount point cannot be empty\"))\n\t}\n\terr := service.MyService.Storage().UnmountStorage(mountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_dto.NewResponse(common_dto.ServerError, err.Error()))\n\t}\n\terr = service.MyService.Storage().DeleteConfigByName(mountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_dto.NewResponse(common_dto.ServerError, err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_dto.NewResponse(common_dto.Success, \"storage unmounted successfully\"))\n}", "CodeBleu_score": 46.43904331075175}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tmount_point := ctx.Bind(&storage.UmountStorageRequest{}).MountPoint\n\tif mount_point == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrBadParam))\n\t}\n\n\terr := service.MyService.Storage().UnmountStorage(mount_point)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrSrvStorageUmount, err.Error()))\n\t}\n\n\terr = service.MyService.Storage().DeleteConfigByName(mount_point)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrSrvStorageDeleteConfig, err.Error()))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ErrSrvSuccess))\n}", "CodeBleu_score": 45.04910982096114}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrNoFilePath))\n\t}\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.72842680453217}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrNoFilePath))\n\t}\n\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.72842680453217}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFilePathMissing))\n\t}\n\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.80277245844459}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\treturn ctx.JSON(http.StatusOK, make(map[string]string))\n}", "CodeBleu_score": 55.100720099445944}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, make(map[string]string))\n}", "CodeBleu_score": 49.665809089051436}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := map[string]string{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\treturn ctx.JSON(http.StatusOK, make(map[string]string))\n}", "CodeBleu_score": 57.22793279086403}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tconnections = append(connections, ws)\n\n\tgo service.SendMeg()\n\n\tfor {\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(msgType, string(msg))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 48.93309028251656}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Ensure that the message sending service is running\n\tgo StartMessageService()\n\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// If the error is a \"close\" error, then the connection has been closed\n\t\t\t// and we can exit the loop\n\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t}\n\t\tfmt.Println(\"Message:\", string(msg))\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.57665707096128}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections\n\tconnections[ws] = true\n\n\t// Ensure that the message sending service is running\n\tgo StartMessageSendingService()\n\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// Remove the WebSocket connection from the list of connections\n\t\t\tdelete(connections, ws)\n\t\t\treturn err\n\t\t}\n\n\t\t// Print the message type and message\n\t\tfmt.Println(\"Message Type:\", msgType, \"Message:\", string(msg))\n\t}\n}", "CodeBleu_score": 41.79305237985397}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\n\t// Gather system hardware information\n\tcpuInfo, err := service.MyService.System().GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(err))\n\t}\n\n\t// Gather system drive information\n\tdriveInfo, err := service.MyService.System().GetDeviceTree()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(err))\n\t}\n\n\t// Create a new struct to store the system hardware information\n\tsysHardwareInfo := struct {\n\t\tCpuInfo  []string `json:\"cpu_info\"`\n\t\tDriveInfo string   `json:\"drive_info\"`\n\t}{\n\t\tCpuInfo:  cpuInfo,\n\t\tDriveInfo: driveInfo,\n\t}\n\n\t// Return the system hardware information as a JSON response\n\treturn ctx.JSON(http.StatusOK, sysHardwareInfo)\n}", "CodeBleu_score": 30.212389082892454}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tcpuInfo, err := service.MyService.System().GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\tdeviceTree, err := service.MyService.System().GetDeviceTree()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\"success\": true,\n\t\t\"data\":    echo.Map{\"cpu\": cpuInfo, \"deviceTree\": deviceTree},\n\t\t\"message\": \"\",\n\t})\n}", "CodeBleu_score": 28.440605445349178}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar response models.GetSystemHardwareInfoResponse\n\tvar err error\n\n\tdriveModel, err := service.MyService.System().GetDriveModel()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, response.SetError(common_err.GetMsg(err)))\n\t}\n\n\tcpuInfo, err := service.MyService.System().GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, response.SetError(common_err.GetMsg(err)))\n\t}\n\n\tdeviceTree, err := service.MyService.System().GetDeviceTree()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, response.SetError(common_err.GetMsg(err)))\n\t}\n\n\tresponse.SystemHardwareInfo = models.SystemHardwareInfo{\n\t\tDriveModel: driveModel,\n\t\tCPUInfo:    cpuInfo,\n\t\tDeviceTree: deviceTree,\n\t}\n\n\treturn ctx.JSON(http.StatusOK, response.SetSuccess())\n}", "CodeBleu_score": 29.37325009213893}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\t// Get the services.\n\tservices, err := s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create the lists.\n\trunningServices := []string{}\n\tnotRunningServices := []string{}\n\n\t// Separate the services into running and not running lists.\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif strings.Contains(service, \"running\") {\n\t\t\t\trunningServices = append(runningServices, service)\n\t\t\t} else {\n\t\t\t\tnotRunningServices = append(notRunningServices, service)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the lists.\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 57.00516182070858}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\t// Call ListServices to get the services.\n\tservices, err := s.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create the return map.\n\tvar running = make([]string, 0)\n\tvar notRunning = make([]string, 0)\n\tret := make(map[bool]*[]string)\n\n\t// Separate the services into running and not running.\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\t// Add the lists to the return map.\n\tret[true] = &running\n\tret[false] = &notRunning\n\n\treturn ret, nil\n}", "CodeBleu_score": 72.16800071491099}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar (\n\t\terr  error\n\t\tlist []string\n\t)\n\n\t// Get the list of services.\n\tlist, err = s.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Separate the services into running and not running lists.\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range list {\n\t\tif s.IsRunning(service) {\n\t\t\trunning = append(running, service)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service)\n\t\t}\n\t}\n\n\t// Return the map.\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 57.977675554174915}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings.\n\tserialized := make(map[string]string)\n\tfor key, value := range message {\n\t\tserialized[key] = fmt.Sprintf(\"%v\", value)\n\t}\n\n\t// Publish the event to the message bus.\n\tresponse, err := i.messageBus.PublishEventWithResponse(name, serialized)\n\tif err != nil {\n\t\ti.logger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Error(err))\n\t\treturn\n\t}\n\n\t// If the response status is not OK, log the failure.\n\tif response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 50.85687601311631}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings.\n\tfor k, v := range message {\n\t\tmessage[k] = json.Marshal(v)\n\t}\n\n\t// Publish the event to the message bus, logging any errors that occur during publishing.\n\tresponse, err := i.messageBus.PublishEventWithResponse(i.ctx, name, message)\n\tif err != nil {\n\t\ti.logger.Error(\n\t\t\t\"Failed to publish event.\",\n\t\t\tzap.String(\"name\", name),\n\t\t\tzap.Any(\"message\", message),\n\t\t\tzap.Error(err))\n\t\treturn\n\t}\n\n\t// If the response status code is not OK, log the failure along with the response details.\n\tif response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\n\t\t\t\"Failed to publish event.\",\n\t\t\tzap.String(\"name\", name),\n\t\t\tzap.Any(\"message\", message),\n\t\t\tzap.Error(errors.New(response.Status)))\n\t}\n}", "CodeBleu_score": 53.12272549277009}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlogger.Error(\"failed to marshal message to JSON\", zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), \"notify.\"+name, jsonMessage)\n\tif err != nil {\n\t\tlogger.Error(\"failed to publish event\", zap.String(\"event\", \"notify.\"+name), zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"failed to publish event\", zap.String(\"event\", \"notify.\"+name), zap.Error(err), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 47.379187099149014}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\treturn message_bus.NewClientWithResponses(c.MessageBusAddress())\n}", "CodeBleu_score": 7.4858381431447185}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tmessageBusAddress := external.GetMessageBusAddress(c.runtimePath)\n\tif messageBusAddress == \"\" {\n\t\tmessageBusAddress = \"http://localhost:8080/api/v1\"\n\t}\n\treturn message_bus.NewClientWithResponses(messageBusAddress)\n}", "CodeBleu_score": 24.214470979881398}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\taddress, err := external.GetMessageBusAddress(c.runtimePath)\n\tif err != nil {\n\t\tc.logger.Error(err, \"failed to get message bus address\")\n\t\tc.logger.Info(\"setting message bus server to default error message\")\n\t\taddress = \"default error message\"\n\t}\n\n\tc.logger.Info(\"setting message bus server to retrieved address\", \"address\", address)\n\treturn message_bus.NewClientWithResponses(address)\n}", "CodeBleu_score": 37.494843435416456}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tvar ip string\n\tif ip = request.Header.Get(\"x-forwarded-for\"); ip != \"\" {\n\t\ti := strings.Index(ip, \", \")\n\t\tif i == -1 {\n\t\t\ti = len(ip)\n\t\t}\n\t\tip = ip[:i]\n\t} else {\n\t\tip, _, _ = net.SplitHostPort(request.RemoteAddr)\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 66.84684248322597}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \":\") {\n\t\tsplitIP := strings.Split(ip, \":\")\n\t\tip = splitIP[len(splitIP)-1]\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 64.60086669392578}, {"code": "func GetIP(request *http.Request) string{\n\t\t// First check the X-Forwarded-For header for requests via proxy.\n\tip := request.Header.Get(\"X-Forwarded-For\")\n\tif ip == \"\" {\n\t\t// If the header is not set, use the remote address.\n\t\tip = request.RemoteAddr\n\t}\n\t// Convert IPv6 addresses to IPv4.\n\tip = strings.Split(ip, \":\")[0]\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = strings.Split(ip, \"::ffff:\")[1]\n\t}\n\treturn ip\n}", "CodeBleu_score": 60.29187704621375}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Set paths for the modules directory and the entry file\n\tmodulesPath := filepath.Join(c.config.BasePath, \"modules\")\n\tentryFilePath := filepath.Join(c.config.BasePath, \"entry.json\")\n\n\t// Ensure the entry file exists\n\tif err := file.IsNotExistCreateFile(entryFilePath); err != nil {\n\t\tlogger.Error(err.Error())\n\t}\n\n\t// Read each module directory for entry.json files\n\tmodules, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t}\n\n\t// Concatenate the contents of each entry.json file into a single JSON array\n\tvar entry []byte\n\tfor _, module := range modules {\n\t\tif module.IsDir() {\n\t\t\t// Set path for the entry file\n\t\t\tmoduleEntryFilePath := filepath.Join(modulesPath, module.Name(), \"entry.json\")\n\n\t\t\t// Read the entry file\n\t\t\tmoduleEntryFile, err := os.ReadFile(moduleEntryFilePath)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err.Error())\n\t\t\t}\n\n\t\t\t// Append the entry file content to the entry array\n\t\t\tentry = append(entry, moduleEntryFile...)\n\t\t}\n\t}\n\n\t// Write the entry array to the entry file path\n\tif err := os.WriteFile(entryFilePath, entry, 0644); err != nil {\n\t\tlogger.Error(err.Error())\n\t}\n}", "CodeBleu_score": 45.051175822641234}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Create the path for the modules directory and the entry file.\n\tmodulesDir := filepath.Join(c.cfg.ModulesDir, \"modules\")\n\tentryFile := filepath.Join(c.cfg.ModulesDir, \"entry.json\")\n\n\t// Ensure the entry file exists.\n\tif err := file.IsNotExistCreateFile(entryFile); err != nil {\n\t\tc.logger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Read each module directory for entry.json files.\n\tentries := []string{}\n\tmoduleDirs, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tc.logger.Error(\"Failed to read modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Concatenate the content of each entry.json file into a single JSON array.\n\tfor _, moduleDir := range moduleDirs {\n\t\tmoduleEntryFile := filepath.Join(modulesDir, moduleDir.Name(), \"entry.json\")\n\t\tmoduleEntryFileContent, err := os.ReadFile(moduleEntryFile)\n\t\tif err != nil {\n\t\t\tc.logger.Error(\"Failed to read module entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tentries = append(entries, string(moduleEntryFileContent))\n\t}\n\n\t// Write the concatenated JSON array to the entry file path.\n\tif err := os.WriteFile(entryFile, []byte(\"[\"+strings.TrimRight(strings.Join(entries, \",\"), \",\")+\"]\"), 0644); err != nil {\n\t\tc.logger.Error(\"Failed to write entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 46.30236768934598}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Define paths for the modules directory and the entry file, ensuring the entry file exists.\n\tmodulesPath := filepath.Join(c.config.ModulesPath, \"modules\")\n\tentryFilePath := filepath.Join(c.config.ModulesPath, \"entry.json\")\n\tfile.IsNotExistCreateFile(entryFilePath)\n\n\t// Read each module directory for entry.json files, concatenate their content into a single JSON array, and write this array to the entry file path.\n\tentryJSON, err := json.Marshal([]string{})\n\tif err != nil {\n\t\tlogger.Error(\"Failed to marshal entry JSON\", zap.Error(err))\n\t}\n\tif err := os.WriteFile(entryFilePath, entryJSON, 0644); err != nil {\n\t\tlogger.Error(\"Failed to write entry JSON file\", zap.Error(err))\n\t}\n\tmodules, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to read modules directory\", zap.Error(err))\n\t}\n\tfor _, module := range modules {\n\t\tif module.IsDir() {\n\t\t\tentryFilePath := filepath.Join(modulesPath, module.Name(), \"entry.json\")\n\t\t\tif _, err := os.ReadFile(entryFilePath); err == nil {\n\t\t\t\tentryFile, err := os.ReadFile(entryFilePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t\t\t}\n\t\t\t\tentryJSON, err := os.ReadFile(entryFilePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t\t\t}\n\t\t\t\tif err := os.WriteFile(entryFilePath, entryJSON, 0644); err != nil {\n\t\t\t\t\tlogger.Error(\"Failed to write entry JSON file\", zap.Error(err))\n\t\t\t\t}\n\t\t\t\tentry := []string{}\n\t\t\t\tif err := json.Un", "CodeBleu_score": 41.41425904219707}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t    interfaces, err := net.Interfaces()\n    if err != nil {\n        return \"\", err\n    }\n\n    networkNames, err := c.GetNet()\n    if err != nil {\n        return \"\", err\n    }\n\n    for _, networkName := range networkNames {\n        for _, iface := range interfaces {\n            if networkName == iface.Name {\n                return iface.HardwareAddr.String(), nil\n            }\n        }\n    }\n\n    return \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 64.19824580388912}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range ifaces {\n\t\tfor _, n := range names {\n\t\t\tif n == i.Name {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 65.21003908225134}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t    interfaces, err := net.Interfaces()\n    if err != nil {\n        return \"\", err\n    }\n\n    names, err := c.GetNetNames()\n    if err != nil {\n        return \"\", err\n    }\n\n    for _, i := range interfaces {\n        for _, n := range names {\n            if i.Name == n {\n                return i.HardwareAddr.String(), nil\n            }\n        }\n    }\n\n    return \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 68.94266890393638}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t ret = 0;\n\t\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\tret = EINVAL;\n\t\tTS_LOG_ERROR(\"%s: Invalid params\n\", __func__);\n\t} else {\n\t\t/* add a reference to the request object */\n\t\ttaosAddRef(pRequest);\n\t\t\n\t\t/* increment the request count for the associated TSC object */\n\t\tatomic_add_fetch_32(&pTscObj->requestCount, 1);\n\t\t\n\t\tif (pTscObj->appInfo != NULL) {\n\t\t\t/* update the application's request summary */\n\t\t\tpTscObj->appInfo->requestCount++;\n\t\t\tpTscObj->appInfo->requestCountCurrent++;\n\t\t}\n\t\t\n\t\t/* log debug information about the new request */\n\t\tTS_LOG_DEBUG(\"%s: Registered request %p for TSC %p\n\", __func__, pRequest, pTscObj);\n\t}\n\t\n\treturn ret;\n}", "CodeBleu_score": 34.353802906802635}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "CodeBleu_score": 3.595962771347859}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\tSAppSummary *pAppSummary = NULL;\n\tuint32_t appId = 0;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\tTSC_LOG_ERROR_MSG(\"Invalid arguments passed to registerRequest.\n\");\n\t\trc = TSC_INVALID_ARGUMENTS;\n\t} else {\n\t\trc = taosAddRef(pRequest);\n\t\tif (rc == TSC_SUCCESS) {\n\t\t\tatomic_add_fetch_32(&pTscObj->requestCount, 1);\n\t\t\tif (pTscObj->appInfo != NULL) {\n\t\t\t\tappId = pRequest->appId;\n\t\t\t\tpAppSummary = pTscObj->appInfo->appSummary;\n\t\t\t\tif (appId < pTscObj->appInfo->appCount) {\n\t\t\t\t\tatomic_add_fetch_32(&pAppSummary[appId].totalRequestCount, 1);\n\t\t\t\t\tatomic_add_fetch_32(&pAppSummary[appId].currentRequestCount, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTSC_LOG_DEBUG_ARGS(\"Registered request %p for TSC %p.\n\", pRequest, pTscObj);\n\t\t}\n\t}\n\treturn rc;\n}", "CodeBleu_score": 44.77112045588896}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (strcmp(pRequest->pstDbInfo->pName, exceptDb) != 0) {\n\t\tint i = 0;\n\t\tfor (i = 0; i < pRequest->dbCount; i++) {\n\t\t\tchar* db = pRequest->dbList[i];\n\t\t\tchar* p = strchr(db, '.');\n\t\t\tif (p != NULL) {\n\t\t\t\tdb = p + 1;\n\t\t\t}\n\t\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 58.787777358727155}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (strcmp(pRequest->pPrimaryDb, exceptDb) != 0) {\n\t\tint i = 0;\n\t\tfor (i = 0; i < pRequest->dbCount; i++) {\n\t\t\tchar *pDb = pRequest->ppDbs[i];\n\t\t\tif (strchr(pDb, '.') != NULL) {\n\t\t\t\tpDb = strchr(pDb, '.') + 1;\n\t\t\t}\n\t\t\tif (strcmp(pDb, exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 54.503637979044726}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (pRequest->pPrimaryDb == NULL) {\n        return true;\n    }\n\n    if (strcmp(pRequest->pPrimaryDb, exceptDb) != 0) {\n        // check all other databases\n        for (int i = 0; i < pRequest->dbCount; i++) {\n            char* db = pRequest->ppDbs[i];\n            char* p = strchr(db, '.');\n            if (p != NULL) {\n                db = p + 1;\n            }\n            if (strcmp(db, exceptDb) == 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 65.95955529980398}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    bool redirect = false;\n\n    switch (code) {\n        case NEED_REDIRECT_ERROR:\n            if (msgType != TMSG_REDIRECT_REQ &&\n                msgType != TMSG_REDIRECT_RESP &&\n                msgType != TMSG_REDIRECT_RESP_ACK &&\n                msgType != TMSG_REDIRECT_REQ_ACK &&\n                msgType != TMSG_REDIRECT_REQ_NACK &&\n                msgType != TMSG_REDIRECT_RESP_NACK) {\n                redirect = true;\n            }\n            break;\n        default:\n            break;\n    }\n\n    return redirect;\n}", "CodeBleu_score": 44.412918325326714}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    bool redirect = false;\n    if (code == NEED_REDIRECT_ERROR) {\n        switch (msgType) {\n            case T_BEGIN:\n            case T_COMMIT:\n            case T_ROLLBACK:\n            case T_PREPARE:\n            case T_ABORT:\n            case T_COMMIT_PREPARED:\n            case T_ROLLBACK_PREPARED:\n            case T_READY:\n            case T_GET_NEXT_CLIENT_MSG_NUMBER:\n            case T_GET_CURRENT_CSN:\n            case T_GET_GLOBAL_SEQUENCE_NUMBER:\n            case T_GET_SERVER_STATUS:\n            case T_GET_SERVER_TIME:\n            case T_GET_SERVER_INFO:\n            case T_GET_SERVER_VERSION:\n            case T_GET_SERVER_HOSTNAME:\n            case T_GET_SERVER_PORT:\n            case T_GET_SERVER_PID:\n            case T_GET_SERVER_SHARED_MEM_SIZE:\n            case T_GET_SERVER_CONNECTION_COUNT:\n            case T_GET_SERVER_UPTIME:\n            case T_GET_SERVER_STATISTICS:\n            case T_GET_SERVER_TRANSACTION_COUNT:\n            case T_GET_SERVER_TRANSACTION_STATISTICS:\n            case T_GET_SERVER_SESSION_COUNT:\n            case T_GET_SERVER_SESSION_STATISTICS:\n            case T_GET_SERVER_LOCK_STATISTICS:\n            case T_GET_SERVER_LOG_STATISTICS:\n            case T_GET_SERVER_LOG_WARNINGS:\n            case T_GET_SERVER_LOG_ERRORS:\n            case T_GET_SERVER_LOG_FATAL_ERRORS:\n            case T_GET_SERVER_LOG_STATISTICS_TOTALS:\n            case T_GET_SERVER_LOG_WARNINGS_TOTALS:\n            case T_GET_SERVER_LOG_ERRORS_TOTALS:\n            case T_GET_SERVER_LOG_FATAL_ERROR", "CodeBleu_score": 27.801763365463678}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    switch (code) {\n        case NEED_REDIRECT_ERROR:\n            if (msgType != MSG_RPC_REDIRECT && msgType != MSG_RPC_REDIRECT_RSP && msgType != MSG_RPC_REDIRECT_RSP_ACK) {\n                return true;\n            }\n            break;\n        default:\n            break;\n    }\n    return false;\n}", "CodeBleu_score": 40.00806107946079}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t    int i;\n    TAOS_RES *res;\n    int requestID;\n    SRequest *request;\n\n    for (i = 0; i < pRequests->size; i++) {\n        taosHashIterate(pRequests, i, &requestID, &request);\n        if (request != NULL) {\n            res = taos_stop_query(request->taos);\n            if (res != NULL) {\n                taos_free_result(res);\n            }\n            acquireRequest(request);\n            releaseRequest(request);\n        }\n    }\n}", "CodeBleu_score": 43.00763782784388}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t    taosHashIterator it;\n    taosHashObj *pRequest;\n    taos_res *res;\n    int requestId;\n\n    for (pRequest = taosHashFirst(pRequests, &it); pRequest; pRequest = taosHashNext(&it)) {\n        requestId = (int)pRequest->key;\n        res = (taos_res *)pRequest->value;\n        if (res != NULL) {\n            taos_stop_query(res);\n        }\n        releaseRequest(pRequests, requestId);\n    }\n}", "CodeBleu_score": 48.16961719983473}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\tif (pRequests->nTableSize == 0) {\n\t\treturn;\n\t}\n\tint i = 0;\n\tfor (i = 0; i < pRequests->nTableSize; i++) {\n\t\tif (pRequests->pHashTable[i] != NULL) {\n\t\t\tacquireRequest(pRequests, pRequests->pHashTable[i]->nRequestID);\n\t\t\tif (pRequests->pHashTable[i]->pRequest != NULL) {\n\t\t\t\ttaos_stop_query(pRequests->pHashTable[i]->pRequest);\n\t\t\t}\n\t\t\treleaseRequest(pRequests, pRequests->pHashTable[i]->nRequestID);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.010660212895125}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t    if (!crashReportEnabled) {\n        return;\n    }\n\n    if (atomic_val_compare_exchange_32(&clientStop, 1, 0) == 0) {\n        while (atomic_load_32(&clientStop) == 1) {\n            taosMsleep(100);\n        }\n    } else {\n        TAOS_LOG_WARN(\"crash report thread is already stopped\");\n    }\n}", "CodeBleu_score": 71.4023772159011}, {"code": "void tscStopCrashReport(){\n\t    if (!tscIsCrashReportEnabled()) {\n        return;\n    }\n    if (!atomic_val_compare_exchange_32(&clientStop, 0, 1)) {\n        tscDebug(\"tscStopCrashReport: crash report thread is already stopped.\n\");\n        return;\n    }\n    while (atomic_load_32(&clientStop) != 0) {\n        taosMsleep(100);\n    }\n}", "CodeBleu_score": 72.7318744374534}, {"code": "void tscStopCrashReport(){\n\t    if (!crashReportingEnabled) {\n        return;\n    }\n\n    if (atomic_val_compare_exchange_32(&clientStop, 0, 1) != 0) {\n        tscDebug(\"crash report thread already stopped\n\");\n        return;\n    }\n\n    while (atomic_load_32(&clientStop) != 0) {\n        taosMsleep(10);\n    }\n}", "CodeBleu_score": 78.27149762101949}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t ret = 0;\n\tint32_t i = 0;\n\tint32_t viewCount = 0;\n\tint32_t columnCount = 0;\n\tint32_t columnIndex = 0;\n\tint32_t columnType = 0;\n\tint32_t columnSize = 0;\n\tint32_t columnPrecision = 0;\n\tint32_t columnScale = 0;\n\tint32_t columnDefaultValueLen = 0;\n\tint32_t columnDefaultValue = 0;\n\tint32_t columnNameLen = 0;\n\tint32_t columnName = 0;\n\tint32_t viewNameLen = 0;\n\tint32_t viewName = 0;\n\tint32_t viewNameLen2 = 0;\n\tint32_t viewName2 = 0;\n\tint32_t viewNameLen3 = 0;\n\tint32_t viewName3 = 0;\n\tint32_t viewNameLen4 = 0;\n\tint32_t viewName4 = 0;\n\tint32_t viewNameLen5 = 0;\n\tint32_t viewName5 = 0;\n\tint32_t viewNameLen6 = 0;\n\tint32_t viewName6 = 0;\n\tint32_t viewNameLen7 = 0;\n\tint32_t viewName7 = 0;\n\tint32_t viewNameLen8 = 0;\n\tint32_t viewName8 = 0;\n\tint32_t viewNameLen9 = 0;\n\tint32_t viewName9 = 0;\n\tint32_t viewNameLen10 = 0;\n\tint32_t viewName10 = 0;\n\tint32_t viewNameLen11 = 0;\n\tint32_t viewName11 = 0;\n\tint32_t viewNameLen12 = 0;\n\tint", "CodeBleu_score": 9.30738077309821}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t viewCnt = 0;\n\tint32_t viewId = 0;\n\tint32_t viewColCnt = 0;\n\tint32_t viewColId = 0;\n\tint32_t viewColType = 0;\n\tint32_t viewColSize = 0;\n\tchar *viewName = NULL;\n\tchar *viewColName = NULL;\n\tchar *viewColTypeName = NULL;\n\tchar *viewColTypeFormat = NULL;\n\tchar *viewColTypeDefault = NULL;\n\tchar *viewColTypeExtra = NULL;\n\tchar *viewColTypeComment = NULL;\n\tchar *viewColTypeTable = NULL;\n\tchar *viewColTypeSchema = NULL;\n\tchar *viewColTypeTs = NULL;\n\tchar *viewColTypeTsFormat = NULL;\n\tchar *viewColTypeTsDefault = NULL;\n\tchar *viewColTypeTsExtra = NULL;\n\tchar *viewColTypeTsComment = NULL;\n\tchar *viewColTypeTsTable = NULL;\n\tchar *viewColTypeTsSchema = NULL;\n\tchar *viewColTypeTsTs = NULL;\n\tchar *viewColTypeTsTsFormat = NULL;\n\tchar *viewColTypeTsTsDefault = NULL;\n\tchar *viewColTypeTsTsExtra = NULL;\n\tchar *viewColTypeTsTsComment = NULL;\n\tchar *viewColTypeTsTsTable = NULL;\n\tchar *viewColTypeTsTsSchema = NULL;\n\tchar *viewColTypeTsTsTs = NULL;\n\tchar *viewColTypeTsTsTsFormat = NULL;\n\tchar *viewColTypeTsTsTsDefault = NULL;\n\tchar *viewColTypeTsTsTsExtra = NULL;\n\tchar *viewColTypeTsTsTsComment = NULL;\n\tchar *viewColTypeTsTsTsTable = NULL;\n\tchar *viewColTypeTsTsTs", "CodeBleu_score": 8.588248623511445}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t i, rc = 0;\n\tstruct SViewMeta *pViewMeta = NULL;\n\tstruct SViewMeta *pViewMetaTmp = NULL;\n\tstruct SViewMeta *pViewMetaNew = NULL;\n\tstruct SViewMeta *pViewMetaUpdate = NULL;\n\tstruct SViewMeta *pViewMetaRemove = NULL;\n\tstruct SViewMeta *pViewMetaRemoveTmp = NULL;\n\tstruct SViewMeta *pViewMetaRemoveNext = NULL;\n\tstruct SViewMeta *pViewMetaRemovePrev = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLast = NULL;\n\tstruct SViewMeta *pViewMetaRemoveFirst = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLastTmp = NULL;\n\tstruct SViewMeta *pViewMetaRemoveFirstTmp = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLastTmp2 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveFirstTmp2 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLastTmp3 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveFirstTmp3 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLastTmp4 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveFirstTmp4 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLastTmp5 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveFirstTmp5 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLastTmp6 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveFirstTmp6 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLastTmp7 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveFirstTmp7 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLastTmp8 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveFirstTmp8 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLastTmp9 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveFirstTmp9 = NULL;\n\tstruct SViewMeta *pViewMetaRemoveLastTmp10 = NULL;\n\tstruct SViewMeta *pViewMeta", "CodeBleu_score": 7.968325228921113}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3_put_object_callback_data *data = (S3_put_object_callback_data *) callbackData;\n\n    int64_t contentLength = 0;\n\n    if (properties) {\n        contentLength = properties->contentLength;\n    }\n\n    // Only update the content length if it is greater than zero\n    if (contentLength > 0) {\n        data->contentLength = contentLength;\n    }\n    else {\n        data->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 61.6105735584713}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3_get_object_callback_data *data = (S3_get_object_callback_data *) callbackData;\n\n    int64_t contentLength = 0;\n\n    if (properties) {\n        contentLength = properties->contentLength;\n    }\n\n    // Only update the content length if it is greater than zero\n    if (contentLength > 0) {\n        data->contentLength = contentLength;\n    }\n    else {\n        // Make sure the content length in the callback data is zero since there is no content\n        data->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 61.6105735584713}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    struct callback_data *data = (struct callback_data *) callbackData;\n\n    data->contentLength = properties->contentLength;\n\n    return S3StatusOK;\n}", "CodeBleu_score": 52.31404942099919}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tint ret;\n\tchar configFilePath[100];\n\tchar rsyncCommand[100];\n\n\t/* Create checkpoint backup directory */\n\tret = taosMulMkDir(g_checkpointBackupDir, 0755);\n\tif (ret < 0) {\n\t\tuError(\"Failed to create checkpoint backup directory: %s\", g_checkpointBackupDir);\n\t}\n\n\t/* Remove empty directories */\n\tremoveEmptyDir(g_checkpointBackupDir);\n\n\t/* Generate Rsync configuration file */\n\tsnprintf(configFilePath, 100, \"%s/rsync.conf\", g_checkpointBackupDir);\n\tret = generateConfigFile(configFilePath);\n\tif (ret < 0) {\n\t\tuError(\"Failed to generate Rsync configuration file: %s\", configFilePath);\n\t}\n\n\t/* Construct and execute Rsync command */\n\tsnprintf(rsyncCommand, 100, \"rsync --daemon --config=%s --port=%d\", configFilePath, g_rsyncPort);\n\tret = system(rsyncCommand);\n\tif (ret < 0) {\n\t\tuError(\"Failed to start Rsync server: %s\", rsyncCommand);\n\t}\n\telse {\n\t\tuDebug(\"Started Rsync server: %s\", rsyncCommand);\n\t}\n}", "CodeBleu_score": 35.8780253550681}, {"code": "void startRsync(){\n\t\tchar *port = getenv(\"TAOS_CK_RPORT\");\n\tchar *dir = getenv(\"TAOS_CK_RDIR\");\n\tchar *cmd = malloc(1024);\n\tchar *conf = malloc(1024);\n\tchar *path = malloc(1024);\n\tchar *err = malloc(1024);\n\tchar *pid = malloc(1024);\n\tchar *pid_file = malloc(1024);\n\tchar *conf_file = malloc(1024);\n\tchar *log_file = malloc(1024);\n\tchar *cmd_file = malloc(1024);\n\n\tif (port == NULL) {\n\t\tport = \"873\";\n\t}\n\n\tif (dir == NULL) {\n\t\tdir = \"/tmp\";\n\t}\n\n\tsnprintf(path, 1024, \"%s/\", dir);\n\tsnprintf(conf, 1024, \"%s/\", dir);\n\tsnprintf(pid, 1024, \"%s/\", dir);\n\tsnprintf(err, 1024, \"%s/\", dir);\n\tsnprintf(conf_file, 1024, \"%s/conf\", dir);\n\tsnprintf(log_file, 1024, \"%s/log\", dir);\n\tsnprintf(cmd_file, 1024, \"%s/cmd\", dir);\n\tsnprintf(pid_file, 1024, \"%s/pid\", dir);\n\n\tif (taosMulMkDir(path) != 0) {\n\t\tuError(\"Failed to create checkpoint backup directory %s\", path);\n\t}\n\n\tremoveEmptyDir(path);\n\n\tgenerateConfigFile(conf, conf_file);\n\n\tsnprintf(cmd, 1024, \"rsync --daemon --no-detach --port=%s --config=%s --log-file=%s --pid-file=%s\", port, conf_file, log_file, pid_file);\n\n\tsystem(cmd);\n\n\tif (uDebug()) {\n\t\tFILE *f", "CodeBleu_score": 32.62811936081209}, {"code": "void startRsync(){\n\t\tchar cmd[1024];\n\tchar configFile[1024];\n\tchar backupDir[1024];\n\tchar port[1024];\n\tchar *checkpointDir;\n\tchar *checkpointPort;\n\n\tcheckpointDir = getenv(\"CHECKPOINT_DIR\");\n\tcheckpointPort = getenv(\"CHECKPOINT_PORT\");\n\tif (checkpointDir == NULL) {\n\t\tcheckpointDir = \"/home/taos/taos_checkpoint\";\n\t}\n\tif (checkpointPort == NULL) {\n\t\tcheckpointPort = \"873\";\n\t}\n\n\tsnprintf(backupDir, sizeof(backupDir), \"%s/backup\", checkpointDir);\n\tif (taosMulMkDir(backupDir) == -1) {\n\t\tuError(\"Failed to create checkpoint backup directory: %s\", backupDir);\n\t}\n\n\tremoveEmptyDir(backupDir);\n\n\tsnprintf(configFile, sizeof(configFile), \"%s/rsync.conf\", checkpointDir);\n\tif (generateConfigFile(configFile, backupDir) == -1) {\n\t\tuError(\"Failed to generate Rsync configuration file: %s\", configFile);\n\t}\n\n\tsnprintf(cmd, sizeof(cmd), \"rsync --daemon --config=%s --port=%s\", configFile, checkpointPort);\n\tif (system(cmd) == -1) {\n\t\tuError(\"Failed to start Rsync server\");\n\t}\n\telse {\n\t\tuDebug(\"Rsync server started\");\n\t}\n}", "CodeBleu_score": 38.77930957627824}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    if (dispatchers.containsKey(dispatcherId)) {\n        Dispatcher dispatcher = dispatchers.get(dispatcherId);\n        dispatcher.getExecutor().shutdownNow();\n        dispatchers.remove(dispatcherId);\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n    }\n}", "CodeBleu_score": 66.47375531007664}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" not registered.\");\n    }\n    dispatcher.shutdownNow();\n}", "CodeBleu_score": 66.2150859298935}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered.\");\n    }\n    dispatcher.shutdownNow();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 65.03338998037013}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    Set<TbActorId> children = childrenMap.get(parent);\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(child -> {\n            try {\n                tell(child, msg, highPriority);\n            } catch (TbActorNotRegisteredException e) {\n                log.warn(\"[{}] Failed to broadcast message to child actor\", child);\n            }\n        });\n    }\n}", "CodeBleu_score": 81.8927802697546}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    List<TbActorId> children = childrenMap.get(parent);\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(child -> {\n            if (highPriority) {\n                tellWithHighPriority(child, msg);\n            } else {\n                tell(child, msg);\n            }\n        });\n    }\n}", "CodeBleu_score": 53.93862430468312}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    Set<TbActorId> children = childrenMap.get(parent);\n    if (children != null) {\n        for (TbActorId child : children) {\n            if (childFilter.test(child)) {\n                try {\n                    tell(child, msg, highPriority);\n                } catch (TbActorNotRegisteredException e) {\n                    log.warn(\"[{}] Failed to broadcast message to child actor [{}]\", parent, child);\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 63.86262645819221}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (destroyInProgress) {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            tryInitActor();\n        } else {\n            msg.onTbActorStopped(this);\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue();\n    }\n}", "CodeBleu_score": 43.33066735109882}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    tryProcessQueue();\n}", "CodeBleu_score": 27.409215694083343}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (destroyInProgress) {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (initTbActorFailed) {\n                initTbActorFailed = false;\n                initActor(context);\n            }\n        } else {\n            msg.onTbActorStopped(this);\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue();\n    }\n}", "CodeBleu_score": 50.74242176125365}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    boolean stop = false;\n    boolean failure = false;\n    boolean throughputLimitReached = false;\n    int throughput = 0;\n    int maxThroughput = getActorThroughput();\n    try {\n        while (!stop && !throughputLimitReached) {\n            if (isHighPriorityQueueEmpty()) {\n                if (isNormalPriorityQueueEmpty()) {\n                    stop = true;\n                } else {\n                    process(getNormalPriorityQueue());\n                    throughput++;\n                    throughputLimitReached = (maxThroughput > 0) && (throughput >= maxThroughput);\n                }\n            } else {\n                process(getHighPriorityQueue());\n                throughput++;\n                throughputLimitReached = (maxThroughput > 0) && (throughput >= maxThroughput);\n            }\n        }\n    } catch (Exception e) {\n        if (e instanceof ActorInitializationException) {\n            setStopReason(e);\n            destroy();\n        } else {\n            logFailure(e);\n            failure = true;\n            onProcessFailure(e);\n        }\n    } finally {\n        if (!failure) {\n            if (!stop) {\n                setStatus(ActorStatus.FREE);\n                scheduleQueueProcessing();\n            } else {\n                setStatus(ActorStatus.IDLE);\n            }\n        }\n    }\n}", "CodeBleu_score": 26.865447363240737}, {"code": "private void processMailbox(){\n\t    if (isStop()) {\n        return;\n    }\n    try {\n        getActorThroughput().reset();\n        while (getActorThroughput().canProcess()) {\n            if (getCause() != null) {\n                // initialization failure\n                destroy();\n                return;\n            }\n            if (getExecutor().getMailbox().isEmpty()) {\n                set(ActorStatus.FREE);\n                getExecutor().scheduleMailboxProcessing(this);\n                return;\n            }\n            Object message = getExecutor().getMailbox().poll();\n            if (message == null) {\n                // mailbox is empty\n                set(ActorStatus.FREE);\n                getExecutor().scheduleMailboxProcessing(this);\n                return;\n            }\n            try {\n                execute(message);\n            } catch (Exception e) {\n                onProcessFailure(e);\n            }\n        }\n    } finally {\n        getActorThroughput().reset();\n    }\n}", "CodeBleu_score": 24.45650032669376}, {"code": "private void processMailbox(){\n\t    int processedMessages = 0;\n    int messagesToProcess = getActorThroughput();\n    while (processedMessages < messagesToProcess && !isStop()) {\n        try {\n            if (getCause() == null && !poll()) {\n                break;\n            }\n            execute();\n            processedMessages++;\n        } catch (ActorInitializationException ex) {\n            set(ex.getCause());\n            destroy();\n            break;\n        } catch (Exception ex) {\n            getLogger().error(\"Failed to process message\", ex);\n            onProcessFailure(ex);\n            if (getCause() != null) {\n                break;\n            }\n        }\n    }\n    if (processedMessages == 0) {\n        setStatus(ActorStatus.FREE);\n        getExecutor().schedule(this, 1000);\n    }\n}", "CodeBleu_score": 25.968196038154534}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (this.stopReason == null) {\n        this.stopReason = cause;\n    }\n    if (this.stopInProgress.compareAndSet(false, true)) {\n        this.executor.execute(new Runnable() {\n            public void run() {\n                try {\n                    ActorCell.this.setReady(false);\n                    ActorCell.this.invoke(ActorCell.this.terminate());\n                    ActorCell.this.stop();\n                    ActorCell.this.postStop();\n                    ActorCell.this.notifyWatchers(ActorCell.this.stopReason);\n                } catch (Throwable var2) {\n                    ActorCell.this.onTbActorStopped(var2);\n                }\n\n            }\n        });\n    }\n}", "CodeBleu_score": 24.7707658238578}, {"code": "public void destroy(Throwable cause){\n\t    if (this.stopReason == null) {\n        this.stopReason = cause;\n    }\n    if (this.isDestroyed()) {\n        return;\n    }\n    this.markDestroyed();\n    this.getExecutor().execute(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                if (TbActor.this.isReady()) {\n                    TbActor.this.setReady(false);\n                }\n                TbActor.this.onTbActorStopped(TbActor.this.stopReason);\n                TbActor.this.onDestroy();\n                TbActor.this.notifyAll();\n            } catch (Throwable t) {\n                TbActor.this.warn(\"onDestroy\", t);\n            }\n        }\n    });\n}", "CodeBleu_score": 27.863097730655856}, {"code": "public void destroy(Throwable cause){\n\t  if (this.stopReason == null) {\n    this.stopReason = cause;\n  }\n  this.isBeingDestroyed = true;\n  this.dispatcher.executor.execute(new Runnable() {\n    @Override\n    public void run() {\n      try {\n        setReady(false);\n        actor.destroy(stopReason);\n        for (Message message : mailbox.queue) {\n          message.notifyOfStoppage(stopReason);\n        }\n      } catch (Exception e) {\n        logger.warn(\"Exception during actor destruction\", e);\n      }\n    }\n  });\n}", "CodeBleu_score": 31.486680404926076}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimitConfiguration.RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api, level);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitResult rateLimitResult = rateLimit.checkRateLimit(api, level);\n    if (rateLimitResult.isExceeded()) {\n        process(rateLimitResult);\n    }\n    return !rateLimitResult.isExceeded();\n}", "CodeBleu_score": 43.0198523364373}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = getRateLimitConfiguration(api, tenantProfile);\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimitLevel rateLimitLevel = getRateLimitLevel(level, rateLimitConfiguration);\n    if (rateLimitLevel == null) {\n        return true;\n    }\n    RateLimitChecker checker = new RateLimitChecker(rateLimitConfiguration, tenantId, rateLimitLevel);\n    if (checker.isRateLimitExceeded()) {\n        processRateLimitNotification(api, tenantId, rateLimitLevel);\n        return false;\n    } else {\n        return true;\n    }\n}", "CodeBleu_score": 45.36997055044269}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimitConfiguration.RateLimitConfigurationBuilder builder = RateLimitConfiguration.builder()\n            .rateLimit(rateLimitConfiguration.getRateLimit())\n            .burstSize(rateLimitConfiguration.getBurstSize())\n            .tenantId(tenantId);\n    RateLimitConfiguration.RateLimitConfigurationBuilder rateLimitConfigurationBuilder = builder\n            .limitLevel(limitLevel(api, level));\n    RateLimitConfiguration rateLimit = rateLimitConfigurationBuilder.build();\n    if (checkRateLimit(rateLimit)) {\n        return true;\n    }\n    process(api, tenantId, rateLimit);\n    return false;\n}", "CodeBleu_score": 48.2684708878988}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = currentTimeMillis() - getValue();\n    for (Map.Entry<String, Long> entry : entrySet()) {\n        if (entry.getValue() < expirationTime) {\n            removeIf(key -> key.equals(entry.getKey()));\n            trace(\"Removed DTLS session with id: \" + entry.getKey() + \" due to inactivity timeout.\");\n        }\n    }\n}", "CodeBleu_score": 42.432778486266024}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = currentTimeMillis() - getInactivityTimeout();\n    for (Iterator<Map.Entry<String, DTLSServerSession>> it = getSessions().entrySet().iterator(); it.hasNext();) {\n        Map.Entry<String, DTLSServerSession> entry = it.next();\n        DTLSServerSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            trace(\"Removing session \" + entry.getKey());\n            it.remove();\n        }\n    }\n}", "CodeBleu_score": 41.201810271079836}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = currentTimeMillis() - inactivityTimeout;\n    trace(\"Evicting sessions older than {}\", expirationTime);\n    for (Map.Entry<String, DTLSConnection> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            trace(\"Removing session {}\", entry.getKey());\n            dtlsSessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 43.625116365621565}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    List<TsKvEntry> result = new ArrayList<>();\n    if (!timeseries.isEmpty()) {\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                if (value.isTextual()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.textValue())));\n                } else if (value.isBoolean()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new BooleanDataEntry(key, value.booleanValue())));\n                } else if (value.isDouble()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new DoubleDataEntry(key, value.doubleValue())));\n                } else if (value.isNumber()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new LongDataEntry(key, value.longValue())));\n                }\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 34.8444030154714}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!timeseries.isEmpty()) {\n        List<TsKvEntry> tsList = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> value = entry.getValue();\n            for (JsonNode node : value) {\n                long ts = node.get(\"ts\").asLong();\n                String dataType = node.get(\"valueType\").asText();\n                switch (dataType) {\n                    case \"STRING\":\n                        tsList.add(new BasicTsKvEntry(ts, new StringDataEntry(key, node.get(\"value\").asText())));\n                        break;\n                    case \"BOOLEAN\":\n                        tsList.add(new BasicTsKvEntry(ts, new BooleanDataEntry(key, node.get(\"value\").asBoolean())));\n                        break;\n                    case \"DOUBLE\":\n                        tsList.add(new BasicTsKvEntry(ts, new DoubleDataEntry(key, node.get(\"value\").asDouble())));\n                        break;\n                    case \"LONG\":\n                        tsList.add(new BasicTsKvEntry(ts, new LongDataEntry(key, node.get(\"value\").asLong())));\n                        break;\n                    case \"JSON\":\n                        tsList.add(new BasicTsKvEntry(ts, new JsonDataEntry(key, node.get(\"value\").toString())));\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n        return tsList;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 33.64506488086428}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (!isEmpty(timeseries)) {\n        return timeseries.entrySet().stream().flatMap(e -> {\n            String key = e.getKey();\n            List<JsonNode> values = e.getValue();\n            return values.stream().map(v -> {\n                long ts = v.get(\"ts\").asLong();\n                Object value = parseValue(v.get(\"value\"));\n                return new TsKvEntry(ts, new KvEntry(key, value));\n            });\n        }).collect(toList());\n    } else {\n        return emptyList();\n    }\n}", "CodeBleu_score": 47.714588719609175}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t    Map<String, String> requestMap = new HashMap<String, String>();\n    requestMap.put(\"refresh_token\", tokenInfo.getRefreshToken());\n\n    HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n\n    HttpEntity<Map<String, String>> request = new HttpEntity<Map<String, String>>(requestMap, headers);\n\n    ResponseEntity<String> response = restTemplate.postForEntity(AUTHENTICATION_ENDPOINT, request, String.class);\n\n    tokenInfo.setTokenTimestamp(currentTimeMillis());\n    tokenInfo.setTokenResponse(response.getBody());\n}", "CodeBleu_score": 39.441576731874584}, {"code": "public void refreshToken(){\n\t    def requestMap = [:]\n    requestMap.put('grant_type', 'refresh_token')\n    requestMap.put('refresh_token', tokenInfo.refresh_token)\n    requestMap.put('client_id', clientId)\n    requestMap.put('client_secret', clientSecret)\n    def response = postForEntity(tokenInfo.token_endpoint, requestMap)\n    tokenInfo.setTokenInfo(response.body)\n    tokenInfo.setTokenInfo(currentTimeMillis())\n}", "CodeBleu_score": 30.847132626681883}, {"code": "public void refreshToken(){\n\t    def requestMap = [\n        refresh_token: tokenInfo.refresh_token\n    ]\n    def response = postForEntity(\n        'https://accounts.spotify.com/api/token',\n        requestMap,\n        Map,\n        'Authorization',\n        'Basic ' + base64Encode(clientId + ':' + clientSecret)\n    )\n    tokenInfo.timestamp = currentTimeMillis()\n    tokenInfo.access_token = response.body.access_token\n    tokenInfo.refresh_token = response.body.refresh_token\n}", "CodeBleu_score": 15.045702391730137}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\t\t\tdef currentTimeMillis = System.currentTimeMillis()\n\t\t\tdef loginRequestMap = [\n\t\t\t\t\t\t\t\t\tusername: username,\n\t\t\t\t\t\t\t\t\tpassword: password\n\t\t\t\t\t\t\t\t]\n\t\t\tdef response = restTemplate.postForEntity(url + \"/api/auth/login\", loginRequestMap, Map.class)\n\t\t\ttokenInfo.token = response.body.token\n\t\t\ttokenInfo.expiryTime = currentTimeMillis + response.body.expiresIn * 1000\n\t\t}", "CodeBleu_score": 30.411010902380266}, {"code": " private void doLogin(){\n\t    currentTimeMillis = System.currentTimeMillis();\n    def loginRequestMap = [\n        username: username,\n        password: password\n    ]\n    def loginResponse = postForEntity('http://' + host + ':' + port + '/api/auth/login', loginRequestMap, Map)\n    tokenInfo = loginResponse.body\n    tokenInfo.time = currentTimeMillis\n}", "CodeBleu_score": 32.351307045434766}, {"code": " private void doLogin(){\n\t        // TODO: Perform a login by sending a POST request with the username and password to the authentication endpoint.\n        // Capture the current timestamp.\n        // Create a login request map with the credentials.\n        // Send the request to the \"/api/auth/login\" URL.\n        // Upon receiving the response, update the token information with the response data and the timestamp.\n\n        // TODO: Remove the following lines.\n        tokenInfo.setToken(\"1234567890\");\n        tokenInfo.setExpiration(currentTimeMillis());\n    }", "CodeBleu_score": 7.373343702347765}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n                baseUrl + \"/api/device/{deviceId}\", Device.class, deviceId);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 68.23265895219004}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 65.49333706838378}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n            \"/api/device/{deviceId}\", Device.class, deviceId);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 65.90096062282629}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\n                \"http://localhost:8080/api/device-with-credentials\",\n                new DeviceWithCredentials(device, credentials),\n                Device.class);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 62.38334519992467}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n\n    try {\n        ResponseEntity<Device> response = restTemplate.postForEntity(\n                \"/api/device-with-credentials\", request, Device.class);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 68.14622335000648}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        return Optional.ofNullable(restTemplate.postForEntity(\n                \"/api/device-with-credentials\",\n                new DeviceWithCredentials(device, credentials),\n                Device.class\n        ).getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 47.961971886553805}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tthis.each(function() {\n\t\t\tthis.brightness(addr);\n\t\t});\n\t} else {\n\t\tthis.send([0x01, addr, Board.map(val, 0, 100, 0, 15)]);\n\t}\n\treturn this;\n}", "CodeBleu_score": 41.26791163038146}, {"code": "brightness(addr, val){\n\t  if (typeof addr === 'undefined') {\n    this.each(function(device) {\n      if (device.type === 'led') {\n        device.brightness = val;\n      }\n    });\n  } else {\n    var device = this.getDevice(addr);\n    if (device && device.type === 'led') {\n      device.brightness = val;\n    }\n  }\n  return this;\n}", "CodeBleu_score": 46.385715184819944}, {"code": "brightness(addr, val){\n\t  if (arguments.length == 1) {\n    this.each(function(device) {\n      device.brightness(addr);\n    });\n  } else if (arguments.length == 2) {\n    this.each(function(device) {\n      device.brightness(addr, val);\n    });\n  }\n  return this;\n}", "CodeBleu_score": 55.737128338047896}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t  var proto = Object.getOwnPropertyNames(LedControl.prototype);\n  var obj = Object.getOwnPropertyNames(this).concat(proto).reduce((obj, key) => {\n    obj[key] = this[key].bind(this, addr);\n    return obj;\n  }, {});\n  return obj;\n}", "CodeBleu_score": 37.04522767305098}, {"code": "device(addr){\n\t  const bound = {}\n  Object.keys(LedControl.prototype).forEach(key => {\n    bound[key] = this[key].bind(this, addr)\n  })\n  Object.keys(this).forEach(key => {\n    bound[key] = this[key].bind(this, addr)\n  })\n  return bound\n}", "CodeBleu_score": 56.762550851242956}, {"code": "device(addr){\n\t  const device = {};\n  Object.keys(LedControl.prototype).forEach((key) => {\n    device[key] = this[key].bind(this, addr);\n  });\n  Object.keys(this).forEach((key) => {\n    device[key] = this[key];\n  });\n  return device;\n}", "CodeBleu_score": 53.27353837815243}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[`${method}Callback`] = (duration, callback) => {\n      if (!callback || typeof callback !== 'function') {\n        callback = () => {}\n      }\n      const signals = []\n      for (let i = 0; i < this.length; i++) {\n        signals.push(this[i][method]())\n      }\n      Promise.all(signals).then(results => {\n        callback(results)\n      })\n    }\n  })\n}", "CodeBleu_score": 34.25070041154048}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach((method) => {\n        target[method + 'Callback'] = function (duration, callback) {\n            if (typeof callback !== 'function') {\n                throw new Error('Callback must be a function');\n            }\n\n            const signals = [];\n            const length = this.length;\n            for (let i = 0; i < length; i++) {\n                const signal = this[i][method](duration);\n                signals.push(signal);\n            }\n\n            Promise.all(signals).then(() => {\n                callback();\n            });\n        };\n    });\n}", "CodeBleu_score": 49.44650940772707}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[`${method}Callback`] = (duration, callback) => {\n      if (!callback) {\n        callback = duration;\n        duration = 1000;\n      }\n      if (typeof callback !== 'function') {\n        throw new Error(`callback must be a function`);\n      }\n      const signals = [];\n      this[i][method]().forEach(item => {\n        signals.push(new Promise(resolve => {\n          setTimeout(() => {\n            resolve(item);\n          }, duration);\n        }));\n      });\n      Promise.all(signals).then(items => callback(items));\n    };\n  });\n}", "CodeBleu_score": 45.24080349857142}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t  this.io.serialRead(this.port, this.baud, this.data, this.status);\n  if (this.status == 0) {\n    var data = new Buffer(this.data).toString();\n    this.input += data;\n    var sentences = this.input.split(\"\\r\n\");\n    for (var i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    this.input = sentences[sentences.length - 1];\n  }\n}", "CodeBleu_score": 49.297446587773116}, {"code": "listen(){\n\t  this.input = \"\";\n  this.io.serialRead(this.serialPort, (data) => {\n    this.input += new Buffer(data).toString();\n    const sentences = this.input.split(\"\\r\n\");\n    this.input = sentences.pop();\n    sentences.forEach(this.parseNmeaSentence);\n  });\n}", "CodeBleu_score": 28.54710853718503}, {"code": "listen(){\n\t    let input = '';\n    this.io.serialRead((data) => {\n        input += new Buffer(data).toString();\n        const sentences = input.split('\\r\n');\n        for (let i = 0; i < sentences.length - 1; i++) {\n            this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n    });\n}", "CodeBleu_score": 56.374555817360104}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels_active = 0;\n\tuint32_t buffer_size;\n\tuint32_t size;\n\n\t/* Check if the buffer size is enough for the sequence */\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tchannels_active++;\n\t\t}\n\t}\n\n\t/* Check if the buffer size is enough for the sequence */\n\tsize = channels_active * sizeof(data->buffer[0]);\n\tif (size > sequence->options) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\tsequence->options, size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.87479480135637}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\tuint32_t chan_mask = BIT_MASK(data->channels);\n\tuint32_t active_channels = 0;\n\tsize_t needed_buffer_size;\n\n\tfor (uint32_t i = 0; i < data->channels; i++) {\n\t\tif (chan_mask & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = active_channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= 2;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\tsequence->buffer_size, needed_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.49417017217801}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t active_channels = 0;\n\tsize_t needed_buffer_size;\n\n\tfor (int i = 0; i < config->channel_count; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = active_channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= 2;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\tsequence->buffer_size, needed_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 46.496205580965835}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    struct adc_ad559x_data *data = dev->data;\n    const struct adc_ad559x_config *config = dev->config;\n    int err;\n    uint8_t channels = 0;\n    uint8_t channel_id;\n    uint8_t i;\n    uint8_t j;\n    uint8_t k;\n    uint8_t n;\n    uint8_t m;\n    uint8_t msb_set;\n    uint8_t resolution;\n    uint8_t buffer_length;\n    uint8_t buffer_bytes;\n    uint8_t buffer_bits;\n    uint8_t buffer_mask;\n    uint8_t buffer_shift;\n    uint8_t buffer_byte;\n    uint8_t buffer_bit;\n    uint8_t buffer_value;\n    uint8_t buffer_index;\n    uint8_t *buffer;\n    uint8_t *buffer_ptr;\n    uint8_t *buffer_end;\n    uint8_t *buffer_data;\n    uint8_t *buffer_data_ptr;\n    uint8_t *buffer_data_end;\n    uint8_t *buffer_data_byte;\n    uint8_t *buffer_data_bit;\n    uint8_t *buffer_data_value;\n    uint8_t *buffer_data_index;\n    uint8_t *buffer_data_index_ptr;\n    uint8_t *buffer_data_index_end;\n    uint8_t *buffer_data_index_byte;\n    uint8_t *buffer_data_index_bit;\n    uint8_t *buffer_data_index_value;\n    uint8_t *buffer_data_index_index;\n    uint8_t *buffer_data_index_index_ptr;\n    uint8_t *buffer_data_index_index_end;\n    uint8_t *buffer_data_index_index_byte;\n    uint8_t *buffer_data_index_index_bit;\n    uint8_t *buffer_data_index_index_value;\n   ", "CodeBleu_score": 15.010267613436579}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    struct adc_ad559x_data *data = dev->data;\n    int error = 0;\n    uint8_t resolution;\n    uint8_t i;\n    uint8_t channel_count = 0;\n    uint8_t channel_index = 0;\n    uint8_t channel_mask = 0;\n    uint8_t channel_mask_index = 0;\n    uint8_t channel_mask_bit_index = 0;\n    uint8_t channel_mask_bit_value = 0;\n    uint8_t channel_mask_bit_position = 0;\n    uint8_t channel_mask_bit_position_index = 0;\n    uint8_t channel_mask_bit_position_bit_value = 0;\n    uint8_t channel_mask_bit_position_bit_position = 0;\n    uint8_t channel_mask_bit_position_bit_position_index = 0;\n    uint8_t channel_mask_bit_position_bit_position_bit_value = 0;\n    uint8_t channel_mask_bit_position_bit_position_bit_position = 0;\n    uint8_t channel_mask_bit_position_bit_position_bit_position_index = 0;\n    uint8_t channel_mask_bit_position_bit_position_bit_position_bit_value = 0;\n    uint8_t channel_mask_bit_position_bit_position_bit_position_bit_position = 0;\n    uint8_t channel_mask_bit_position_bit_position_bit_position_bit_position_index = 0;\n    uint8_t channel_mask_bit_position_bit_position_bit_position_bit_position_bit_value = 0;\n    uint8_t channel_mask_bit_position_bit_position_bit_position_bit_position_bit_position = 0;\n    uint8_t channel_mask_bit_position_bit_position_bit_position_bit_position_bit_position_index = 0;\n    uint8_t channel_mask_bit_position", "CodeBleu_score": 14.227434048039392}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    struct adc_ad559x_data *data = dev->data;\n    int error = 0;\n    uint8_t i;\n    uint8_t channel_count = 0;\n    uint8_t channel_id = 0;\n    uint8_t channel_mask = 0;\n    uint8_t channel_mask_temp = 0;\n    uint8_t resolution = 0;\n    uint8_t resolution_temp = 0;\n    uint8_t buffer_size = 0;\n    uint8_t buffer_size_temp = 0;\n    uint8_t buffer_size_required = 0;\n    uint8_t buffer_size_required_temp = 0;\n    uint8_t channel_count_temp = 0;\n    uint8_t channel_count_required = 0;\n    uint8_t channel_count_required_temp = 0;\n    uint8_t channel_count_buffer = 0;\n    uint8_t channel_count_buffer_temp = 0;\n    uint8_t channel_count_buffer_required = 0;\n    uint8_t channel_count_buffer_required_temp = 0;\n    uint8_t channel_count_buffer_remaining = 0;\n    uint8_t channel_count_buffer_remaining_temp = 0;\n    uint8_t channel_count_buffer_remaining_required = 0;\n    uint8_t channel_count_buffer_remaining_required_temp = 0;\n    uint8_t channel_count_buffer_remaining_required_temp_temp = 0;\n    uint8_t channel_count_buffer_remaining_required_temp_temp_temp = 0;\n    uint8_t channel_count_buffer_remaining_required_temp_temp_temp_temp = 0;\n    uint8_t channel_count_buffer_remaining_required_temp_temp_temp_temp_temp = 0;\n    uint8_t channel_count_buffer_remaining_required_temp_temp_temp_temp_temp_temp = 0;\n    uint8", "CodeBleu_score": 15.089840593789644}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    const struct device *adc_dev = ctx->dev;\n    struct adc_nrfx_data *dev_data = DEV_DATA(adc_dev);\n    struct adc_nrfx_channel_cfg *ch_cfg;\n    int i, err;\n\n    /*\n     * Note: ctx->channels is an array of pointers to the channels to be sampled.\n     */\n    for (i = 0; i < ctx->sequence.channels; i++) {\n        ch_cfg = CONTAINER_OF(ctx->sequence.channels[i],\n                              struct adc_nrfx_channel_cfg,\n                              chan);\n        nrf_saadc_channel_input_set(ch_cfg->input_psel,\n                                    ch_cfg->input_psel_set);\n    }\n\n    nrf_saadc_buffer_init(dev_data->buffer,\n                          ctx->sequence.buffer,\n                          (ctx->sequence.buffer_size * sizeof(uint16_t)));\n\n    err = nrf_saadc_sample();\n    if (err) {\n        nrf_saadc_buffer_init(dev_data->buffer, NULL, 0);\n        LOG_ERR(\"Failed to start ADC sampling (%d)\", err);\n    }\n\n    k_sem_give(&dev_data->acq_sem);\n}", "CodeBleu_score": 28.93225000054086}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tconst struct adc_sequence *sequence = ctx->sequence;\n\tstruct adc_info *info = ctx->info;\n\tstruct adc_samplers *adc_sampler = &info->adc_sampler;\n\tstruct k_sem *sem = &adc_sampler->sem;\n\tint err;\n\n\tadc_sampler->sequence = sequence;\n\tadc_sampler->channels = sequence->channels;\n\tadc_sampler->buffer = sequence->buffer;\n\tadc_sampler->oversampling_buffer = sequence->oversampling_buffer;\n\tadc_sampler->repeat_buffer = sequence->repeat_buffer;\n\tadc_sampler->oversampling_repeat_buffer = sequence->oversampling_repeat_buffer;\n\tadc_sampler->sampling_delay = sequence->sampling_delay;\n\tadc_sampler->options = sequence->options;\n\n\terr = k_sem_give(sem);\n\tif (err) {\n\t\tadc_context_complete(ctx, err);\n\t}\n}", "CodeBleu_score": 43.002855116802166}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    const struct device *dev = ctx->dev;\n    struct adc_info *info = (struct adc_info *)dev->data;\n    struct adc_sequence *sequence = &ctx->sequence;\n    int err;\n\n    /*\n     * The \"adc_context_lock\" function acquires a lock on the ADC context.", "CodeBleu_score": 35.40001201659938}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t}\n}", "CodeBleu_score": 44.32578164190454}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = ctx->single_buffer;\n\t}\n}", "CodeBleu_score": 47.201609323754255}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = ctx->buffer;\n\t}\n}", "CodeBleu_score": 47.04822149301768}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    const struct adc_ad559x_config *config = data->config;\n    struct adc_context *ctx = &data->ctx;\n    const struct adc_sequence *sequence;\n    uint8_t channel_id;\n    uint8_t channels;\n    int ret;\n    int8_t index;\n    uint8_t mask;\n    uint8_t channels_to_read;\n    uint8_t channels_read;\n    uint8_t channel_mask;\n    uint8_t channel_mask_last;\n    uint8_t channel_mask_first;\n    uint8_t channel_mask_diff;\n    uint8_t channel_mask_tmp;\n    uint8_t channel_mask_range;\n    uint8_t channel_mask_range_first;\n    uint8_t channel_mask_range_last;\n    uint8_t channel_mask_range_diff;\n    uint8_t channel_mask_range_tmp;\n    uint8_t channel_mask_range_shift;\n    uint8_t channel_mask_range_shift_tmp;\n    uint8_t channel_mask_range_shift_first;\n    uint8_t channel_mask_range_shift_last;\n    uint8_t channel_mask_range_shift_diff;\n    uint8_t channel_mask_range_shift_tmp;\n    uint8_t channel_mask_range_shift_first;\n    uint8_t channel_mask_range_shift_last;\n    uint8_t channel_mask_range_shift_diff;\n    uint8_t channel_mask_range_shift_tmp;\n    uint8_t channel_mask_range_shift_first;\n    uint8_t channel_mask_range_shift_last;\n    uint8_t channel_mask_range_shift_diff;\n    uint8_t channel_mask_range_shift_tmp;\n    uint8_t channel_mask_range_shift_first;\n    uint8_t channel_mask_range_shift_last;\n    uint8_t channel_mask_range_shift_diff;\n    uint8_t channel_mask", "CodeBleu_score": 12.250946415085236}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct adc_ad559x_config *config = data->dev->config;\n\tstruct adc_context *ctx = &data->ctx;\n\tstruct adc_sequence *sequence;\n\tuint16_t sample;\n\tuint8_t channel;\n\tint err;\n\n\twhile (true) {\n\t\t/* Wait for acquisition to be triggered */\n\t\terr = k_sem_take(&data->acq_sem, K_FOREVER);\n\t\tif (err) {\n\t\t\tLOG_ERR(\"Acquisition thread error (%d)\", err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Iterate through active channels */\n\t\tsequence = ctx->sequence.ri;\n\t\twhile (sequence) {\n\t\t\tfor (channel = 0; channel < config->channel_count; channel++) {\n\t\t\t\tif (sequence->channels & BIT(channel)) {\n\t\t\t\t\terr = adc_ad559x_read_channel(data, channel, &sample);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tLOG_ERR(\"ADC read error (%d)\", err);\n\t\t\t\t\t\tadc_context_complete(ctx, err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Store sample in buffer */\n\t\t\t\t\t*sequence->buffer++ = sample;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsequence = sequence->next;\n\t\t}\n\n\t\t/* Signal that sampling is done */\n\t\tadc_context_on_sampling_done(ctx, data->dev);\n\t}\n}", "CodeBleu_score": 38.485492310945006}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    const struct device *dev = data->dev;\n    const struct adc_ad559x_config *config = dev->config;\n    struct adc_context *ctx = &data->ctx;\n    const struct adc_ad559x_channel_config *channel_config;\n    uint8_t channel_id;\n    int ret;\n\n    while (true) {\n        k_sem_take(&data->acq_sem, K_FOREVER);\n\n        LOG_DBG(\"acquisition thread run\");\n\n        ret = adc_ad559x_read_reg(dev, ADC_AD559X_REG_STATUS, &data->status);\n        if (ret) {\n            LOG_ERR(\"failed to read status register (%d)\", ret);\n            adc_context_complete(ctx, ret);\n            continue;\n        }\n\n        for (channel_id = 0; channel_id < config->channel_count; channel_id++) {\n            channel_config = &config->channels[channel_id];\n\n            if (!(channel_config->acquisition_time)) {\n                continue;\n            }\n\n            ret = adc_ad559x_read_channel(dev, channel_id,\n                                          &data->sample[channel_id]);\n            if (ret) {\n                LOG_ERR(\"failed to read channel %d (%d)\", channel_id, ret);\n                adc_context_complete(ctx, ret);\n                break;\n            }\n        }\n\n        adc_context_on_sampling_done(ctx, dev);\n    }\n}", "CodeBleu_score": 45.005334850645404}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint err;\n\tuint16_t config_reg;\n\tuint8_t status;\n\tuint8_t ready_time;\n\tuint8_t ready_time_u8;\n\tuint8_t ready_time_u100;\n\n\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstatus = (config_reg & ADS1112_CONFIG_STATUS_MASK) >> ADS1112_CONFIG_STATUS_SHIFT;\n\n\tif (status == ADS1112_CONFIG_STATUS_BUSY) {\n\t\tready_time = (config_reg & ADS1112_CONFIG_DR_MASK) >> ADS1112_CONFIG_DR_SHIFT;\n\t\tready_time_u8 = (ready_time * ADS1112_CONFIG_DR_TIME_MULTIPLIER_U8) + ADS1112_CONFIG_DR_TIME_OFFSET_U8;\n\t\tready_time_u100 = (ready_time * ADS1112_CONFIG_DR_TIME_MULTIPLIER_U100) + ADS1112_CONFIG_DR_TIME_OFFSET_U100;\n\t\tk_sleep(K_USEC(ready_time_u100));\n\t\twhile (status == ADS1112_CONFIG_STATUS_BUSY) {\n\t\t\tk_sleep(K_USEC(100));\n\t\t\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n\t\t\tif (err) {\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tstatus = (config_reg & ADS1112_CONFIG_STATUS_MASK) >> ADS1112_CONFIG_STATUS_SHIFT;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 46.64073071452638}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint err;\n\tuint16_t config;\n\tstruct ads1112_data *data = dev->data;\n\tk_timeout_t timeout = K_USEC(data->ready_time);\n\n\terr = k_sleep(timeout);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\twhile (true) {\n\t\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t\tif (!(config & ADS1112_CONFIG_OS_MASK)) {\n\t\t\tbreak;\n\t\t}\n\t\tk_usleep(100);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.59691445453631}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    int err;\n    uint16_t config;\n    uint8_t ready;\n    uint8_t ready_bit = 0x80;\n    uint8_t ready_mask = 0xFF;\n    uint8_t ready_shift = 7;\n\n    /* Sleep for the device's specified ready time */\n    k_sleep(K_USEC(ADS1112_READY_TIME));\n\n    /* Read the configuration register to check the status */\n    err = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n    if (err != 0) {\n        return err;\n    }\n\n    /* Check the status */\n    ready = (config & ready_mask) >> ready_shift;\n    while (ready != ready_bit) {\n        /* Sleep for 100 microseconds */\n        k_sleep(K_USEC(100));\n\n        /* Read the configuration register to check the status */\n        err = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n        if (err != 0) {\n            return err;\n        }\n\n        /* Check the status */\n        ready = (config & ready_mask) >> ready_shift;\n    }\n\n    return 0;\n}", "CodeBleu_score": 54.86775283019079}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_buffer_size = 0;\n\tsize_t buffer_size = sequence->options ? sequence->options->extra_samplings + 1 : 1;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\trequired_buffer_size += sequence->channels;\n\t}\n\n\tif (required_buffer_size > buffer_size) {\n\t\tLOG_ERR(\"Provided buffer size too small. Required: %u, provided: %u\",\n\t\t\trequired_buffer_size, buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.957147949044675}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint required_buffer_size = sequence->channels * (sequence->oversampling + 1);\n\n\tif (required_buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Provided buffer size too small. Required %d, given %d\",\n\t\t\trequired_buffer_size, sequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.94788725393793}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = sequence->buffer_size;\n\tint required_buffer_size = sequence->channels * ads1112_get_samplings(sequence);\n\tif (buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"ADC buffer size %d is less than required %d\", buffer_size, required_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 40.63381721987287}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *drv_data = dev->data;\n\tint err;\n\n\tif (sequence->channels != 1) {\n\t\tLOG_ERR(\"unsupported number of channels\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"unsupported oversampling\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"unsupported resolution\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"unsupported calibration\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < 1) {\n\t\tLOG_ERR(\"unsupported buffer size\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * If there is no buffer, then we can't do a non-blocking read.\n\t */\n\tif (!sequence->buffer && wait == false) {\n\t\tLOG_ERR(\"no buffer available\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * If there is no buffer, then we can't do a non-blocking read.\n\t */\n\tif (!sequence->buffer && wait == false) {\n\t\tLOG_ERR(\"no buffer available\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * If there is no buffer, then we can't do a non-blocking read.\n\t */\n\tif (!sequence->buffer && wait == false) {\n\t\tLOG_ERR(\"no buffer available\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * If there is no buffer, then we can't do a non-blocking read.\n\t */\n\tif (!sequence->buffer && wait == false) {\n\t\tLOG_ERR(\"no buffer available\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * If there is no buffer, then we can't do a non-blocking", "CodeBleu_score": 40.61766556719828}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint err;\n\n\tif (sequence->channels == 0) {\n\t\tLOG_ERR(\"No channels in sequence\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > ADS1112_MAX_CHANNELS) {\n\t\tLOG_ERR(\"Too many channels in sequence\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate sequence */\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t/* Assign sequence buffer */\n\tdata->sequence = sequence;\n\n\t/* Start read */\n\terr = adc_context_start_read(&data->ctx, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t/* Wait for completion if requested */\n\tif (wait) {\n\t\terr = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 58.167672776321844}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint err;\n\n\t/* Validate sequence */\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t/* Assign sequence buffer */\n\tdata->seq_buffer = sequence->buffer;\n\n\t/* Start ADC context */\n\terr = adc_context_start_read(&data->ctx, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t/* Wait for completion if requested */\n\tif (wait) {\n\t\terr = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 65.91149184611875}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Failed: device not found.\");\n\t\treturn -EINVAL;\n\t}\n\treturn audio_codec_apply_properties(dev, &prop_config);\n}", "CodeBleu_score": 61.55414829208784}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\tstruct audio_codec_prop prop;\n\tint ret;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Failed to get device binding\");\n\t\treturn -ENODEV;\n\t}\n\n\tprop.channel = strtol(argv[2], NULL, 16);\n\tprop.volume = strtol(argv[3], NULL, 16);\n\tprop.mute = strtol(argv[4], NULL, 16);\n\n\tret = audio_codec_apply_properties(dev, &prop);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 60.636609350724804}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tconst struct device *dev;\n\tint ret;\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret != 0) {\n\t\tshell_error(sh, \"Failed to apply properties (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.07790311735164}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *drv_data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tswitch (drv_data->state) {\n\t\tcase MPXXDTYY_STATE_CONFIGURED:\n\t\t\tret = i2s_trigger(drv_data->i2s, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdrv_data->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"I2S trigger start error\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tswitch (drv_data->state) {\n\t\tcase MPXXDTYY_STATE_ACTIVE:\n\t\t\tret = i2s_trigger(drv_data->i2s, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdrv_data->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"I2S trigger stop error\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 51.96996255890623}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_dev_data *dev_data = (struct mpxxdtyy_i2s_dev_data *)dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (dev_data->state != MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device not in configured state\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = mpxxdtyy_i2s_start(dev);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to start I2S device\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_data->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (dev_data->state != MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device not in active state\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to stop I2S device\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_data->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 51.107034533939185}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_dev_data *data = dev->data;\n\tstruct mpxxdtyy_i2s_dev_config *config = dev->config;\n\tint ret = 0;\n\n\t/* Check if the device is already in the requested state */\n\tif (data->state == cmd) {\n\t\tLOG_WRN(\"Device already in requested state\");\n\t\treturn 0;\n\t}\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\t\t/* Send I2S command to start the device */\n\t\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_TX, I2S_TRIGGER_START);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"Failed to start device\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t/* Update the device state */\n\t\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\t} else {\n\t\t\tLOG_WRN(\"Device not in configured state\");\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\t/* Send I2S command to stop the device */\n\t\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_TX, I2S_TRIGGER_STOP);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"Failed to stop device\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t/* Update the device state */\n\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_WRN(\"Device not in active state\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported trigger command\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 60.559823051493765}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    struct auxdisplay_hd44780_data *data = dev->data;\n    struct auxdisplay_hd44780_config *config = dev->config;\n    uint8_t cmd;\n\n    cmd = auxdisplay_hd44780_read_config(dev);\n\n    if (enabled) {\n        cmd |= LCD_DISPLAYON;\n    } else {\n        cmd &= ~LCD_DISPLAYON;\n    }\n\n    auxdisplay_hd44780_send_command(dev, cmd);\n}", "CodeBleu_score": 44.824018870067725}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->driver_data;\n\tuint8_t cmd = LCD_DISPLAYON;\n\n\tif (enabled) {\n\t\tcmd |= LCD_DISPLAYON;\n\t} else {\n\t\tcmd |= LCD_DISPLAYOFF;\n\t}\n\n\tauxdisplay_hd44780_command(dev, cmd);\n}", "CodeBleu_score": 37.36170505581009}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = LCD_DISPLAY_ON;\n\n\tif (enabled) {\n\t\tcmd |= LCD_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_mode) {\n\t\tcmd |= LCD_CURSOR_ON;\n\t}\n\n\tif (data->cursor_blink) {\n\t\tcmd |= LCD_CURSOR_BLINK;\n\t}\n\n\tauxdisplay_hd44780_command(dev, cmd);\n}", "CodeBleu_score": 56.83504262186304}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    struct auxdisplay_itron_config *config = dev->config;\n    struct auxdisplay_itron_data *data = dev->data;\n    int ret;\n\n    if (config->busy_port == NULL) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get_dt(config->busy_port, config->busy_pin);\n    if (ret < 0) {\n        return ret;\n    }\n\n    data->busy = ret;\n\n    return 0;\n}", "CodeBleu_score": 62.41260885693074}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\tuint32_t val;\n\n\tif (config->busy_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_port, config->busy_pin, &val);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn val;\n}", "CodeBleu_score": 69.64362848018736}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    struct auxdisplay_itron_config *config = dev->config;\n    int ret;\n\n    if (config->busy_port == -1) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get_dt(config->busy_port, config->busy_pin);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to read GPIO pin %d on port %d\", config->busy_pin, config->busy_port);\n        return ret;\n    }\n\n    return ret;\n}", "CodeBleu_score": 59.35845594609385}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\tint err;\n\n\tbuf[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuf[1] = command;\n\n\terr = i2c_write_dt(&config->bus, buf, sizeof(buf));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay));\n\n\treturn err;\n}", "CodeBleu_score": 69.61497091138017}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint err;\n\n\tbuffer[0] = SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\terr = i2c_write_dt(&config->i2c, buffer, sizeof(buffer));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay));\n\n\treturn err;\n}", "CodeBleu_score": 70.03708876034061}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tstruct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint result;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = (uint8_t)command;\n\n\tresult = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n\tk_sleep(K_MSEC(config->special_command_delay));\n\n\treturn result;\n}", "CodeBleu_score": 66.55354803001728}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_cfg *cfg = dev->config;\n\n\tif (size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(cfg, offset, size)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, cfg->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 62.1744636153573}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\n\tstruct bbram_emul_data *dev_data = dev->data;\n\n\tif (bbram_emul_check_invalid(dev, offset, size)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &dev_data->data[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 58.549133746717544}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_cfg *cfg = dev->config;\n\tconst struct bbram_emul_data *data_ctx = dev->data;\n\n\tif (size > cfg->size) {\n\t\tLOG_ERR(\"Requested read size exceeds memory size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\tLOG_ERR(\"Requested read exceeds memory size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev, offset, size)) {\n\t\tLOG_ERR(\"Requested read involves invalid memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &data_ctx->memory[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 56.89607730903813}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t    struct bbram_emul_data *bbram = dev->data;\n\n    if (bbram_emul_check_invalid(bbram)) {\n\treturn -EIO;\n    }\n\n    if (size > bbram->size) {\n\treturn -EINVAL;\n    }\n\n    if (offset + size > bbram->size) {\n\treturn -EINVAL;\n    }\n\n    memcpy(bbram->data + offset, data, size);\n\n    return 0;\n}", "CodeBleu_score": 66.41529284992545}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = dev->data;\n\tconst struct bbram_emul_cfg *dev_cfg = dev->config;\n\tint ret = 0;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size > dev_cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev_data->invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\n\treturn ret;\n}", "CodeBleu_score": 68.24501993676222}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *dev_data = dev->data;\n\tint rc;\n\n\t/* Check if write size is valid */\n\tif (size > dev_data->size) {\n\t\tLOG_ERR(\"Write size %u is greater than device size %u\", size,\n\t\t\tdev_data->size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if write stays within the bounds of the BBRAM */\n\tif (offset + size > dev_data->size) {\n\t\tLOG_ERR(\"Write size %u at offset %u exceeds device size %u\",\n\t\t\tsize, offset, dev_data->size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if BBRAM is in an invalid state */\n\trc = bbram_emul_check_invalid(dev);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\t/* Copy data to BBRAM */\n\tmemcpy(dev_data->data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 64.00367396256621}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing required argument for device\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = bbram_clear(*bbram_dev);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to clear BBRAM\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.03649562223808}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Device name not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 84.9241820727741}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Device name not provided\");\n\t\treturn -EINVAL;\n\t}\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 81.44791730616359}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_dev *h4 = dev->data;\n\tuint32_t read;\n\tuint32_t to_read;\n\tint err;\n\tuint32_t read_bytes = 0;\n\tuint32_t total_read_bytes = 0;\n\tuint32_t total_read_bytes_hdr = 0;\n\tuint8_t *buf = h4->rx_buf;\n\tuint8_t *hdr = h4->rx_buf;\n\n\tto_read = h4->rx_len - h4->rx_len_allocated;\n\n\twhile (to_read > 0) {\n\t\tread = to_read;\n\t\terr = uart_fifo_read(h4->uart, buf, read);\n\t\tif (err < 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART (%d)\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\tread_bytes = (uint32_t)err;\n\t\ttotal_read_bytes += read_bytes;\n\t\tto_read -= read_bytes;\n\t\tbuf += read_bytes;\n\n\t\tif (read_bytes < read) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (total_read_bytes > 0) {\n\t\ttotal_read_bytes_hdr = MIN(total_read_bytes, H4_HDR_SIZE);\n\t\th4->rx_len_allocated += total_read_bytes_hdr;\n\t\th4->rx_buf += total_read_bytes_hdr;\n\t}\n}", "CodeBleu_score": 39.57372000019513}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct bt_hci_h4_dev_data_t * const dev_data = DEV_DATA(dev);\n\tuint8_t *hdr = dev_data->rx_buf;\n\tint to_read = sizeof(struct bt_hci_acl_hdr) - dev_data->rx_len;\n\tint read;\n\n\tif (to_read > 0) {\n\t\tread = uart_fifo_read(dev_data->uart, hdr + dev_data->rx_len,\n\t\t\t\t      to_read);\n\t\tif (read < 0) {\n\t\t\tLOG_ERR(\"Failed to read ACL header (%d)\", read);\n\t\t\treturn;\n\t\t}\n\n\t\tdev_data->rx_len += read;\n\t}\n}", "CodeBleu_score": 37.03016598772102}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct bt_hci_h4_dev *h4 = dev->driver_data;\n\tint read;\n\tint rd_len = 0;\n\tuint8_t *hdr = h4->rx_buf;\n\tint to_read = h4->rx_len;\n\n\t/* Calculate number of bytes already read */\n\tif (h4->rx_off > 0) {\n\t\trd_len = h4->rx_off;\n\t\tto_read -= rd_len;\n\t}\n\n\t/* Read remaining bytes from FIFO into buffer */\n\tread = uart_fifo_read(h4->uart, hdr + rd_len, to_read);\n\tif (read < 0) {\n\t\tLOG_ERR(\"Failed to read from UART (%d)\", read);\n\t\treturn;\n\t}\n\n\t/* Update number of bytes read */\n\th4->rx_off += read;\n}", "CodeBleu_score": 48.624375839984566}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t read;\n    size_t total = 0;\n    int err;\n\n    while (len) {\n        read = min(len, sizeof(buf));\n        err = uart_fifo_read(uart, buf, read);\n        if (err) {\n            LOG_ERR(\"Failed to discard %zu bytes (%d)\", read, err);\n            return total;\n        }\n\n        len -= read;\n        total += read;\n    }\n\n    return total;\n}", "CodeBleu_score": 43.34076705045834}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t read = 0;\n\n    while (len > 0) {\n        size_t to_read = MIN(len, sizeof(buf));\n        int err;\n\n        err = uart_fifo_read(uart, buf, to_read);\n        if (err < 0) {\n            LOG_ERR(\"Failed to discard %zu bytes (%d)\", to_read, err);\n            return read;\n        }\n\n        read += err;\n        len -= err;\n    }\n\n    return read;\n}", "CodeBleu_score": 43.21386014464108}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t total = 0;\n\n    while (len) {\n        size_t read = MIN(len, sizeof(buf));\n        int err = uart_fifo_read(uart, buf, read);\n\n        if (err) {\n            LOG_ERR(\"Failed to discard %zu bytes (%d)\", len, err);\n            return 0;\n        }\n\n        total += read;\n        len -= read;\n    }\n\n    return total;\n}", "CodeBleu_score": 45.73317985035025}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tint hop = ZBUS_PRIO_MAX;\n\n\tzbus_chan_lock(chan);\n\n\tzbus_for_each_observer(obs, chan) {\n\t\tif (obs->prio < hop && obs->enabled) {\n\t\t\thop = obs->prio;\n\t\t}\n\t}\n\n\tchan->hop = hop;\n\n\tzbus_chan_unlock(chan);\n}", "CodeBleu_score": 14.112314263934852}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    unsigned int hop = 0;\n    struct zbus_observer *obs;\n    unsigned int i;\n\n    spin_lock(&chan->lock);\n\n    for (i = 0; i < chan->num_observers; i++) {\n        obs = chan->observers[i];\n        if (obs->enabled && obs->priority < hop) {\n            hop = obs->priority;\n        }\n    }\n\n    chan->highest_observer_priority = hop;\n\n    spin_unlock(&chan->lock);\n}", "CodeBleu_score": 26.46348649767497}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    unsigned int i;\n    unsigned int hop = 0xffffffff;\n\n    for (i = 0; i < CONFIG_ZBUS_CHAN_OBSERVER_COUNT; i++) {\n        if (chan->observers[i].priority < hop && chan->observers[i].enabled) {\n            hop = chan->observers[i].priority;\n        }\n    }\n\n    chan->highest_observer_priority = hop;\n}", "CodeBleu_score": 22.264712514328185}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_chan_obs *co;\n\tstruct zbus_chan *chan;\n\n\tlist_for_each_entry(co, &zbus_chan_obs_list, list) {\n\t\tchan = co->chan;\n\n\t\tif (chan->observer == obs) {\n\t\t\tchan->update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.390170272145205}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_chan_obs *chan_obs;\n    struct zbus_chan *chan;\n    struct zbus_chan_update_hop_args args = {\n        .obs = obs\n    };\n\n    list_for_each_entry(chan_obs, &chan_obs_list, list) {\n        chan = chan_obs->chan;\n        if (chan->obs != obs) {\n            continue;\n        }\n        chan->update_hop(chan, &args);\n    }\n}", "CodeBleu_score": 21.508088066233235}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_chan_obs *chan_obs = NULL;\n    struct zbus_chan_obs *tmp = NULL;\n    struct zbus_chan *chan = NULL;\n    struct zbus_chan *tmp_chan = NULL;\n    struct zbus_chan_update_hop_data data;\n\n    data.obs = obs;\n\n    list_for_each_entry_safe(chan_obs, tmp, &chan_obs_list, list) {\n        chan = chan_obs->chan;\n        if (chan->obs != obs)\n            continue;\n\n        list_for_each_entry_safe(chan, tmp_chan, &chan->list, list) {\n            update_channel_hop(chan, &data);\n        }\n    }\n}", "CodeBleu_score": 16.91200691450959}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tK_SPINLOCK_KEY_t key;\n\tkey = k_spin_lock(&lock);\n\t_ZBUS_ASSERT(k_is_in_isr() == false);\n\t_ZBUS_ASSERT(obs != NULL);\n\tobs->prio = K_LOWEST_THREAD_PRIO;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&lock, key);\n\treturn 0;\n}", "CodeBleu_score": 52.91113817011528}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    K_SPINLOCK_KEY_t key;\n    key = k_spin_lock(&zbus_obs_lock);\n    K_ASSERT(k_is_in_isr() == false);\n    K_ASSERT(obs != NULL);\n    obs->priority = K_LOWEST_THREAD_PRIO;\n    update_all_channels_hop(obs);\n    k_spin_unlock(&zbus_obs_lock, key);\n    return 0;\n}", "CodeBleu_score": 52.72635389881166}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tK_SPINLOCK_KEY_DECLARE(key);\n\tk_spinlock_key_get(&zbus_lock, &key);\n\t_ZBUS_ASSERT(!k_is_in_isr(), -EINVAL);\n\t_ZBUS_ASSERT(obs != NULL, -EINVAL);\n\tobs->priority = K_LOWEST_THREAD_PRIO;\n\tupdate_all_channels_hop(obs);\n\tk_spinlock_key_put(&zbus_lock, key);\n\treturn 0;\n}", "CodeBleu_score": 52.12461087839373}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    _ZBUS_ASSERT(chan != NULL);\n\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    k_timepoint_t end_time = sys_timepoint_calc(timeout);\n    int err = 0;\n\n    chan_lock(chan);\n    if (chan->ctx_prio > chan->prio) {\n        chan->ctx_prio = chan->prio;\n    }\n    err = _zbus_vded_exec(chan, end_time);\n    chan_unlock(chan);\n\n    return err;\n}", "CodeBleu_score": 60.00273167948647}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    _ZBUS_ASSERT(chan);\n\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    const k_ticks_t end_time = sys_timepoint_calc(timeout);\n    const k_prio_t orig_prio = k_get_prio();\n\n    chan_lock(chan);\n    int ret = _zbus_vded_exec(chan, end_time, orig_prio);\n    chan_unlock(chan);\n\n    return ret;\n}", "CodeBleu_score": 39.126060641219176}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    _ZBUS_ASSERT(chan != NULL);\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    k_timepoint_t end_time = sys_timepoint_calc(timeout);\n    k_priority_t orig_prio = k_get_priority();\n\n    chan_lock(chan);\n    int err = zbus_chan_notify_locked(chan, end_time, orig_prio);\n    chan_unlock(chan);\n\n    return err;\n}", "CodeBleu_score": 44.55771320920173}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (Int & IS_ETH_INT_ABNORMAL) {\n\t\tif (enable) {\n\t\t\tETH->IER |= Int;\n\t\t} else {\n\t\t\tETH->IER &= ~Int;\n\t\t\tif (!(ETH->IER & IS_ETH_INT_NORMAL)) {\n\t\t\t\tETH->IER &= ~IS_ETH_INT_ABNORMAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (enable) {\n\t\t\tETH->IER |= Int;\n\t\t} else {\n\t\t\tETH->IER &= ~Int;\n\t\t\tif (!(ETH->IER & IS_ETH_INT_ABNORMAL)) {\n\t\t\t\tETH->IER &= ~IS_ETH_INT_NORMAL;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.87752678546861}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t temp = 0;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\n\t/* Get the interrupt enable bit */\n\ttemp = (Int & ETH_IER_INT_EN);\n\n\t/* Check if the interrupt is normal or abnormal */\n\tif (Int & ETH_IER_INT_ABNORMAL) {\n\t\t/* Check if the interrupt is enabled or disabled */\n\t\tif (enable) {\n\t\t\t/* Enable the interrupt */\n\t\t\tETH->IER |= temp;\n\t\t} else {\n\t\t\t/* Disable the interrupt */\n\t\t\tETH->IER &= ~temp;\n\t\t}\n\t} else {\n\t\t/* Check if the interrupt is enabled or disabled */\n\t\tif (enable) {\n\t\t\t/* Enable the interrupt */\n\t\t\tETH->IER |= temp;\n\t\t} else {\n\t\t\t/* Disable the interrupt */\n\t\t\tETH->IER &= ~temp;\n\t\t}\n\t}\n}", "CodeBleu_score": 34.19751706254485}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    uint32_t mask = 0;\n    uint32_t reg = 0;\n    uint32_t reg_abnormal = 0;\n    uint32_t reg_normal = 0;\n    uint32_t reg_mask = 0;\n    uint32_t reg_abnormal_mask = 0;\n    uint32_t reg_normal_mask = 0;\n    /* Check the parameters */\n    assert_param(IS_ETH_INT(Int));\n    assert_param(IS_ETH_INT_ABNORMAL(Int));\n    assert_param(IS_ETH_INT_NORMAL(Int));\n    assert_param(IS_BOOL(enable));\n    /* Get the normal interrupt mask */\n    reg_normal_mask = ETH->INT_EN_NORMAL;\n    /* Get the abnormal interrupt mask */\n    reg_abnormal_mask = ETH->INT_EN_ABNORMAL;\n    /* Get the normal interrupt enable bits */\n    reg_normal = Int & reg_normal_mask;\n    /* Get the abnormal interrupt enable bits */\n    reg_abnormal = Int & reg_abnormal_mask;\n    /* Get the interrupt enable bits */\n    reg = Int & (reg_abnormal | reg_normal);\n    /* Set the normal interrupt mask */\n    mask = reg_normal_mask & (~reg_normal);\n    /* Set the abnormal interrupt mask */\n    mask |= reg_abnormal_mask & (~reg_abnormal);\n    /* Set the interrupt enable bits */\n    mask |= reg;\n    /* Check if the interrupt is enabled or disabled */\n    if (enable) {\n        /* Enable the interrupt */\n        ETH->INT_EN_NORMAL |= reg_normal;\n        ETH->INT_EN_ABNORMAL |= reg_abnormal;\n    } else {\n        /* Disable the interrupt */\n        ETH->INT_EN_NORMAL &= mask;\n        ETH->INT_EN_ABNORMAL &= mask;\n    }\n}", "CodeBleu_score": 39.47146854273852}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *pTxDesc;\n    uint32_t i;\n\n    pTxDesc = (ETH_TX_DESC *)ETH_DMATxDescTab;\n\n    for (i = 0; i < ETH_TXBUFNB; i++) {\n        if ((pTxDesc->Status & ETH_DMATxDesc_OWN) == 0) {\n            return pTxDesc;\n        }\n        pTxDesc++;\n    }\n    return 0;\n}", "CodeBleu_score": 37.117906820865905}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *txDesc;\n\tuint32_t idx;\n\n\t/* Get the current transmit descriptor address */\n\tidx = ETH->DMA_TX_DESC_LIST_ADDR->CUR_TX_DESC_ADDR;\n\n\t/* Check if the descriptor is owned by the device */\n\tif (ETH->DMA_TX_DESC_LIST_ADDR->CUR_TX_DESC_ADDR == ETH->DMA_TX_DESC_LIST_ADDR->NEXT_TX_DESC_ADDR) {\n\t\t/* No free descriptor */\n\t\treturn 0;\n\t}\n\n\t/* Loop through the list of transmit descriptors */\n\tdo {\n\t\t/* Get the current transmit descriptor */\n\t\ttxDesc = (ETH_TX_DESC *) idx;\n\n\t\t/* Check if the descriptor is owned by the device */\n\t\tif (txDesc->STATUS & ETH_TX_DESC_OWN_BIT) {\n\t\t\t/* The descriptor is owned by the device */\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Get the next transmit descriptor address */\n\t\tidx = txDesc->NEXT_DESC_ADDR;\n\t} while (idx != ETH->DMA_TX_DESC_LIST_ADDR->NEXT_TX_DESC_ADDR);\n\n\t/* Return the acquired transmit descriptor */\n\treturn (ETH_TX_DESC *) idx;\n}", "CodeBleu_score": 46.99544512891429}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *desc;\n\tuint32_t i;\n\n\t/* Get the current transmit descriptor address */\n\tdesc = (ETH_TX_DESC *) (ETH->DMATDLAR);\n\n\t/* Check if the descriptor is owned by the device */\n\tif (desc->Status & ETH_DMATXDESC_OWN) {\n\t\t/* Loop through all the descriptors in the list */\n\t\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\t\t/* Check if the descriptor is owned by the device */\n\t\t\tif (desc->Status & ETH_DMATXDESC_OWN) {\n\t\t\t\t/* Get the next descriptor */\n\t\t\t\tdesc = (ETH_TX_DESC *) (desc->Buffer1Addr);\n\t\t\t} else {\n\t\t\t\t/* Return the descriptor */\n\t\t\t\treturn desc;\n\t\t\t}\n\t\t}\n\t\t/* Return 0 if no free descriptor is found */\n\t\treturn 0;\n\t} else {\n\t\t/* Return the descriptor */\n\t\treturn desc;\n\t}\n}", "CodeBleu_score": 47.05455125717108}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    struct cyp_adc_device *adc_dev = (struct cyp_adc_device *)device;\n    rt_err_t ret = RT_EOK;\n    CY_ASSERT(adc_dev != NULL);\n    CY_ASSERT(adc_dev->dac_ch != NULL);\n    CY_ASSERT(value != NULL);\n    if (adc_dev == NULL || adc_dev->dac_ch == NULL || value == NULL) {\n        LOG_E(\"adc device or dac channel or value is null!\");\n        return RT_ERROR;\n    }\n    Cy_CSDIDAC_OutputEnable(adc_dev->dac_ch, *value);\n    return ret;\n}", "CodeBleu_score": 44.67197299056951}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    struct rt_dac_device_cypress *dac_dev = (struct rt_dac_device_cypress *)device;\n    CY_ASSERT(dac_dev != NULL);\n    CY_ASSERT(dac_dev->dac_ch != NULL);\n    CY_ASSERT(value != NULL);\n    CY_ASSERT(channel < dac_dev->dac_ch->count);\n    CY_ASSERT(dac_dev->dac_ch->channels[channel] != NULL);\n    CY_ASSERT(dac_dev->dac_ch->channels[channel]->channel != NULL);\n\n    CY_ASSERT(dac_dev->dac_ch->channels[channel]->channel->dacChNum < CY_CSD_MAX_DAC_CHANNELS);\n    CY_ASSERT(dac_dev->dac_ch->channels[channel]->channel->dacChNum < dac_dev->dac_ch->count);\n\n    CY_ASSERT(dac_dev->dac_ch->channels[channel]->channel->dacChNum == channel);\n\n    CY_ASSERT(dac_dev->dac_ch->channels[channel]->channel->dacChNum == dac_dev->dac_ch->channels[channel]->channel->dacChNum);\n\n    CY_ASSERT(dac_dev->dac_ch->channels[channel]->channel->dacChNum == dac_dev->dac_ch->channels[channel]->channel->dacChNum);\n\n    CY_ASSERT(dac_dev->dac_ch->channels[channel]->channel->dacChNum == dac_dev->dac_ch->channels[channel]->channel->dacChNum);\n\n    CY_ASSERT(dac_dev->dac_ch->channels[channel]->channel->dacChNum == dac_dev->dac_ch->channels[channel]->channel->dacChNum);\n\n    CY_ASSERT(dac_dev->dac_ch->channels[", "CodeBleu_score": 34.459130843321475}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    struct cyp_dac_device *dac_dev = (struct cyp_dac_device *)device;\n    struct cyp_dac_channel *dac_channel = dac_dev->channels[channel];\n    RT_ASSERT(dac_dev != RT_NULL);\n    RT_ASSERT(dac_channel != RT_NULL);\n    LOG_E(\"dac_channel->channel = %d\", dac_channel->channel);\n    Cy_CSDIDAC_OutputEnable(dac_dev->base, dac_channel->channel, *value);\n    return RT_EOK;\n}", "CodeBleu_score": 50.21176365775952}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    rt_uint32_t addr_end = addr + size;\n    if (addr_end > IFX_FLASH_32K_END_ADDR) {\n        LOG_E(\"ifx_flash_read_32k: invalid address\");\n        return IFX_I2C_STACK_ERROR_INVALID_ARG;\n    }\n    for (i = 0; i < size; i++) {\n        buf[i] = *((rt_uint8_t *)(addr + i));\n    }\n    return size;\n}", "CodeBleu_score": 51.18886216842482}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > 0x100000) {\n        LOG_E(\"read out of flash size!\");\n        return -RT_EINVAL;\n    }\n\n    rt_memcpy(buf, (void *) addr, size);\n\n    return size;\n}", "CodeBleu_score": 25.99386850662531}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > IFX_FLASH_32K_END_ADDR) {\n        LOG_E(\"Error: Read operation would exceed flash memory's end address.\n\");\n        return -RT_EINVAL;\n    }\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *) (IFX_FLASH_32K_START_ADDR + addr + i);\n    }\n    return size;\n}", "CodeBleu_score": 46.879710770362536}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *cy_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(cy_timer);\n}", "CodeBleu_score": 32.617932447761724}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 32.637116210279046}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *cy_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(cy_timer);\n}", "CodeBleu_score": 32.617932447761724}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    rt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.51441636275613}, {"code": "void dfs_lock(void){\n\t    rt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.51441636275613}, {"code": "void dfs_lock(void){\n\t    rt_mutex_take(dfs_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.536974416339173}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\t/* Search for an empty fd starting from the specified index */\n\tfor (fd = startfd; fd < fdt->max_fds; fd++) {\n\t\tif (fdt->fds[fd].fs == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\t/* Expand the fd table */\n\tif (fd_slot_expand(fdt) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Search again for an empty fd starting from the specified index */\n\tfor (fd = startfd; fd < fdt->max_fds; fd++) {\n\t\tif (fdt->fds[fd].fs == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\t/* Should never reach here */\n\treturn -1;\n}", "CodeBleu_score": 38.3115597951807}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int index;\n    struct dfs_fd *slot;\n\n    /* search for an empty slot */\n    for (index = startfd; index < fdt->maxfd; index++) {\n        slot = &fdt->fds[index];\n        if (slot->fops == NULL) {\n            return index;\n        }\n    }\n\n    /* expand the fd table */\n    if (fd_slot_expand(fdt) == 0) {\n        return fdt->maxfd;\n    }\n\n    return -1;\n}", "CodeBleu_score": 40.87072795707351}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tfd = startfd;\n\twhile (fd < fdt->max_fds) {\n\t\tif (!fdt->fds[fd]) {\n\t\t\tfdt->fds[fd] = DFS_FD_FREE;\n\t\t\treturn fd;\n\t\t}\n\t\tfd++;\n\t}\n\n\tif (fd_slot_expand(fdt) < 0) {\n\t\treturn -1;\n\t}\n\n\tfdt->fds[fd] = DFS_FD_FREE;\n\n\treturn fd;\n}", "CodeBleu_score": 35.10545419408907}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    int i;\n    const char *error_string;\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    for (i = 0; i < RT_ERROR_NUM; i++) {\n        if (error == rt_error_list[i].no) {\n            error_string = rt_error_list[i].error_string;\n            return error_string;\n        }\n    }\n\n    return \"EUNKNOWN\";\n}", "CodeBleu_score": 57.03632716606716}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    static const char *err_str[] = {\n        \"EOK\",\n        \"EPERM\",\n        \"ENOENT\",\n        \"EIO\",\n        \"ENXIO\",\n        \"E2BIG\",\n        \"ENOEXEC\",\n        \"EBADF\",\n        \"ECHILD\",\n        \"EAGAIN\",\n        \"ENOMEM\",\n        \"EACCES\",\n        \"EFAULT\",\n        \"ENOTBLK\",\n        \"EBUSY\",\n        \"EEXIST\",\n        \"EXDEV\",\n        \"ENODEV\",\n        \"ENOTDIR\",\n        \"EISDIR\",\n        \"EINVAL\",\n        \"ENFILE\",\n        \"EMFILE\",\n        \"ENOTTY\",\n        \"ETXTBSY\",\n        \"EFBIG\",\n        \"ENOSPC\",\n        \"ESPIPE\",\n        \"EROFS\",\n        \"EMLINK\",\n        \"EPIPE\",\n        \"EDOM\",\n        \"ERANGE\",\n        \"EDEADLK\",\n        \"ENAMETOOLONG\",\n        \"ENOLCK\",\n        \"ENOSYS\",\n        \"ENOTEMPTY\",\n        \"ELOOP\",\n        \"EWOULDBLOCK\",\n        \"ENOMSG\",\n        \"EIDRM\",\n        \"ECHRNG\",\n        \"EL2NSYNC\",\n        \"EL3HLT\",\n        \"EL3RST\",\n        \"ELNRNG\",\n        \"EUNATCH\",\n        \"ENOCSI\",\n        \"EL2HLT\",\n        \"EBADE\",\n        \"EBADR\",\n        \"EXFULL\",\n        \"ENOANO\",\n        \"EBADRQC\",\n        \"EBADSLT\",\n        \"EDEADLOCK\",\n        \"EBFONT\",\n        \"ENOSTR\",\n        \"ENODATA\",\n        \"ETIME\",\n        \"ENOSR\",\n        \"ENONET\",\n        \"ENOPKG\",\n        \"EREMOTE\",\n        \"ENOLINK\",\n        \"EADV\",\n        \"ESR", "CodeBleu_score": 5.553171696863688}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    static const char *errors[] = {\n        \"EOK\",\n        \"EPERM\",\n        \"ENOENT\",\n        \"ESRCH\",\n        \"EINTR\",\n        \"EIO\",\n        \"ENXIO\",\n        \"E2BIG\",\n        \"ENOEXEC\",\n        \"EBADF\",\n        \"ECHILD\",\n        \"EAGAIN\",\n        \"ENOMEM\",\n        \"EACCES\",\n        \"EFAULT\",\n        \"ENOTBLK\",\n        \"EBUSY\",\n        \"EEXIST\",\n        \"EXDEV\",\n        \"ENODEV\",\n        \"ENOTDIR\",\n        \"EISDIR\",\n        \"EINVAL\",\n        \"ENFILE\",\n        \"EMFILE\",\n        \"ENOTTY\",\n        \"ETXTBSY\",\n        \"EFBIG\",\n        \"ENOSPC\",\n        \"ESPIPE\",\n        \"EROFS\",\n        \"EMLINK\",\n        \"EPIPE\",\n        \"EDOM\",\n        \"ERANGE\",\n        \"EDEADLK\",\n        \"ENAMETOOLONG\",\n        \"ENOLCK\",\n        \"ENOSYS\",\n        \"ENOTEMPTY\",\n        \"ELOOP\",\n        \"EWOULDBLOCK\",\n        \"ENOMSG\",\n        \"EIDRM\",\n        \"ECHRNG\",\n        \"EL2NSYNC\",\n        \"EL3HLT\",\n        \"EL3RST\",\n        \"ELNRNG\",\n        \"EUNATCH\",\n        \"ENOCSI\",\n        \"EL2HLT\",\n        \"EBADE\",\n        \"EBADR\",\n        \"EXFULL\",\n        \"ENOANO\",\n        \"EBADRQC\",\n        \"EBADSLT\",\n        \"EDEADLOCK\",\n        \"EBFONT\",\n        \"ENOSTR\",\n        \"ENODATA\",\n        \"ETIME\",\n        \"ENOSR\",\n        \"ENONET\",\n        \"ENOPKG\",\n        \"EREMOTE\",\n        \"ENOLINK\",", "CodeBleu_score": 5.564398233145816}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_uint32_t i;\n\trt_thread_t thread = rt_thread_self();\n\n\trt_spin_lock_irqsave(&(thread->spinlock));\n\n\tfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == RT_NULL) {\n\t\t\tidle_hook_list[i] = hook;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == RT_IDLE_HOOK_LIST_SIZE) {\n\t\tresult = -RT_EFULL;\n\t}\n\n\trt_spin_unlock_irqrestore(&(thread->spinlock));\n\n\treturn result;\n}", "CodeBleu_score": 65.45201831626146}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result = -RT_EFULL;\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* try to find an empty slot in idle hook list */\n    if (idle_hook_list_available_slot != RT_NULL) {\n        /* fill the hook function and the magic number */\n        *idle_hook_list_available_slot = hook;\n        *(idle_hook_list_available_slot + 1) = (void *)RT_THREAD_IDLE_MAGIC;\n\n        /* move to next available slot */\n        idle_hook_list_available_slot += 2;\n\n        /* change the result */\n        result = RT_EOK;\n    }\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 31.285014655280776}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t ret = RT_EOK;\n    rt_base_t level;\n\n    level = rt_hw_interrupt_disable();\n\n    if (idle_hook_list_available_slots() == 0) {\n        ret = -RT_EFULL;\n    } else {\n        idle_hook_list_add(hook);\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return ret;\n}", "CodeBleu_score": 23.757261051922626}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result = RT_EOK;\n    rt_uint32_t level;\n    rt_thread_idle_hook_list_t *list;\n\n    if (hook == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    level = rt_hw_interrupt_disable();\n\n    list = &rt_thread_idle_hook_list;\n    while (list->next != RT_NULL) {\n        if (list->next->hook == hook) {\n            list->next = list->next->next;\n            break;\n        }\n        list = list->next;\n    }\n\n    if (list->next == RT_NULL) {\n        result = -RT_ERROR;\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 32.26753821946567}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t level;\n    struct idle_hook_list *idle_hook_list_entry;\n\n    /* Lock the spinlock to ensure thread safety */\n    level = rt_spin_lock_irqsave(&idle_hook_list_lock);\n\n    /* Iterate through the idle hook list */\n    idle_hook_list_entry = idle_hook_list_head;\n    while (idle_hook_list_entry != RT_NULL) {\n        /* Check if the specified hook is in the idle hook list */\n        if (idle_hook_list_entry->hook == hook) {\n            /* Set the corresponding entry to null */\n            idle_hook_list_entry->hook = RT_NULL;\n\n            /* Unlock the spinlock to ensure thread safety */\n            rt_spin_unlock_irqrestore(&idle_hook_list_lock, level);\n\n            /* Return a success code */\n            return RT_EOK;\n        }\n        idle_hook_list_entry = idle_hook_list_entry->next;\n    }\n\n    /* Unlock the spinlock to ensure thread safety */\n    rt_spin_unlock_irqrestore(&idle_hook_list_lock, level);\n\n    /* Return an error code indicating that the operation is not supported */\n    return -RT_ERROR;\n}", "CodeBleu_score": 52.27986849773101}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t ret = RT_EOK;\n\trt_ubase_t level;\n\trt_thread_t tid = rt_thread_self();\n\n\tif (tid == RT_NULL) {\n\t\treturn RT_EINVAL;\n\t}\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (rt_list_isempty(&(tid->idle_hook_list))) {\n\t\tret = RT_ERROR;\n\t} else {\n\t\tstruct rt_idle_hook_list *idle_hook;\n\t\trt_list_t *node;\n\t\trt_list_for_each(node, &(tid->idle_hook_list)) {\n\t\t\tidle_hook = rt_list_entry(node, struct rt_idle_hook_list, list);\n\t\t\tif (idle_hook->hook_func == hook) {\n\t\t\t\trt_list_remove(&(idle_hook->list));\n\t\t\t\trt_free(idle_hook);\n\t\t\t\tret = RT_EOK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trt_hw_interrupt_enable(level);\n\treturn ret;\n}", "CodeBleu_score": 35.05293524679771}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_list_t *node;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /*\n     * If the list is empty, just return RT_EOK.\n     */\n    if (rt_list_isempty(susp_list)) {\n        return RT_EOK;\n    }\n\n    /*\n     * Unlock scheduler.\n     */\n    rt_exit_critical();\n\n    /*\n     * Dequeue and resume all threads in the list.\n     */\n    while (!rt_list_isempty(susp_list)) {\n        /*\n         * Get the first thread in the list.\n         */\n        node = susp_list->next;\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n\n        /*\n         * Remove the thread from the list.\n         */\n        rt_list_remove(node);\n\n        /*\n         * Resume the thread.\n         */\n        rt_thread_resume(thread);\n\n        /*\n         * Set the error code of the thread.\n         */\n        thread->error = thread_error;\n    }\n\n    /*\n     * Lock scheduler.\n     */\n    rt_enter_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 34.080618845563336}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\n    rt_thread_t thread;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (\"rt_susp_list_resume_all\n\"));\n\n    /*\n     * The scheduler is unlocked before resuming each thread in the list. This is done to avoid a deadlock in case the thread being resumed is the current thread and the scheduler is locked.\n     */\n    rt_exit_critical();\n\n    while (!rt_list_isempty(susp_list)) {\n\n        /*\n         * The thread is dequeued from the list and then woken up.\n         */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n        rt_susp_list_dequeue(thread);\n        rt_thread_resume(thread);\n        rt_thread_error_reset(thread);\n        rt_thread_error_set(thread, thread_error);\n\n    }\n\n    /*\n     * The scheduler is locked again before returning.\n     */\n    rt_enter_critical();\n\n    return RT_EOK;\n\n}", "CodeBleu_score": 37.95648830728552}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\n    rt_ubase_t  level;\n    struct rt_thread *thread;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* resume all suspended threads */\n    while (!rt_list_isempty(susp_list)) {\n        /* get next suspended thread */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n        /* set error number */\n        thread->error = thread_error;\n\n        /*\n         * resume thread\n         * In function: \"rt_thread_resume\"\n         * It will remove current thread from scheduler list and insert to ready list.\n         */\n        rt_thread_resume(thread);\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 37.10865002873662}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device;\n    rt_device_t new_device;\n\n    /* save current console device */\n    old_device = rt_console_get_device();\n\n    /* find new console device */\n    new_device = rt_device_find(name);\n    if (new_device == RT_NULL)\n        return RT_NULL;\n\n    /* check whether is the same device */\n    if (new_device == old_device)\n        return old_device;\n\n    /* close old console device */\n    if (old_device != RT_NULL)\n        rt_device_close(old_device);\n\n    /* open new console device */\n    if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n        rt_console_set_device(new_device);\n        return old_device;\n    }\n\n    return RT_NULL;\n}", "CodeBleu_score": 67.23030439734026}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device;\n    rt_device_t new_device;\n\n    old_device = rt_console_get_device();\n    if (old_device != RT_NULL && rt_strcmp(old_device->parent.name, name) == 0)\n        return old_device;\n\n    new_device = rt_device_find(name);\n    if (new_device != RT_NULL) {\n        if (old_device != RT_NULL)\n            rt_device_close(old_device);\n\n        if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n            rt_console_set_device(new_device);\n            return old_device;\n        }\n    }\n\n    return RT_NULL;\n}", "CodeBleu_score": 67.26502994846568}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t new_dev, old_dev;\n\n    old_dev = rt_console_get_device();\n    if (old_dev != RT_NULL && rt_strcmp(old_dev->parent.name, name) == 0) {\n        return old_dev;\n    }\n\n    new_dev = rt_device_find(name);\n    if (new_dev == RT_NULL) {\n        return RT_NULL;\n    }\n\n    if (old_dev != RT_NULL) {\n        rt_device_close(old_dev);\n    }\n\n    if (rt_device_open(new_dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return RT_NULL;\n    }\n\n    rt_console_set_device(new_dev);\n    return old_dev;\n}", "CodeBleu_score": 61.70821594785072}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int length;\n    struct rt_object *object;\n    struct rt_list_node *node;\n    rt_ubase_t level;\n    struct rt_object_information *information = rt_object_get_information(type);\n\n    RT_DEBUG_LOG(RT_DEBUG_KERNEL, (\"length type: %d\n\", type));\n\n    level = rt_hw_interrupt_disable();\n\n    length = 0;\n    rt_list_for_each(node, &(information->object_list)) {\n        length ++;\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return length;\n}", "CodeBleu_score": 47.944313504401705}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object *object;\n    int length = 0;\n\n    rt_spin_lock_irqsave(&object_container[type].lock);\n    rt_list_for_each(object, &object_container[type].object_list, list) {\n        length ++;\n    }\n    rt_spin_unlock_irqrestore(&object_container[type].lock);\n\n    return length;\n}", "CodeBleu_score": 33.07363398928421}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object *object;\n    struct rt_list_node *node;\n    int length = 0;\n    rt_ubase_t level;\n\n    /* get object type and lock */\n    level = rt_hw_interrupt_disable();\n    object = rt_object_get_information(type);\n\n    /* try to take semaphore */\n    while (rt_list_isempty(&object->object_list)) {\n        rt_hw_interrupt_enable(level);\n        rt_sem_take(object->semaphore, RT_WAITING_FOREVER);\n        level = rt_hw_interrupt_disable();\n    }\n\n    /* get the first object */\n    node = object->object_list.next;\n\n    /* iterate over them */\n    while (node != &(object->object_list)) {\n        length ++;\n        node = node->next;\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return length;\n}", "CodeBleu_score": 40.81218060167476}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    struct rt_object *obj;\n    rt_list_t *list;\n    rt_uint8_t type;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    obj = (struct rt_object *)object;\n    type = obj->type & ~RT_Object_Class_Static;\n\n    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (object));\n\n    /* get object information */\n    list = &rt_object_container[type];\n\n    rt_enter_critical();\n    /* unlink object from object list */\n    rt_list_remove(&(obj->list));\n    rt_exit_critical();\n\n    /* set object type to RT_Object_Class_None */\n    obj->type = RT_Object_Class_None;\n}", "CodeBleu_score": 46.694586636791435}, {"code": "void rt_object_detach(rt_object_t object){\n\t    struct rt_object *obj;\n\n    obj = (struct rt_object *)object;\n\n    RT_ASSERT(object != RT_NULL);\n    RT_ASSERT(rt_object_get_type(object) != RT_Object_Class_Unknown);\n\n    RT_OBJECT_HOOK_CALL(rt_object_delete_hook, (object));\n\n    rt_object_get_information((rt_object_t)obj);\n    rt_spin_lock_irqsave(&(obj->lock));\n\n    /* remove from object list */\n    rt_list_remove(&(obj->list));\n\n    rt_spin_unlock_irqrestore(&(obj->lock), obj->flag);\n\n    /* set object type to unknown */\n    rt_object_set_type((rt_object_t)obj, RT_Object_Class_Unknown);\n}", "CodeBleu_score": 59.75414710908705}, {"code": "void rt_object_detach(rt_object_t object){\n\t    struct rt_object *obj;\n\n    obj = (struct rt_object *)object;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n    RT_ASSERT(rt_object_get_type(object) != RT_Object_Class_Unknown);\n\n    /* RT_OBJECT_HOOK_CALL(rt_object_delete_hook, (object)); */\n\n    /* get object information */\n    rt_object_get_information(object);\n    rt_spin_lock_irqsave(&(obj->lock));\n\n    /* remove from object list */\n    rt_list_remove(&(obj->list));\n\n    /* unlock spinlock */\n    rt_spin_unlock_irqrestore(&(obj->lock), obj->level);\n\n    /* set object type to unknown */\n    obj->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 55.86130366598285}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_custom_object_t cobj;\n    rt_err_t result;\n\n    /* check parameter */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(rt_object_is_custom(obj) == RT_TRUE);\n\n    cobj = (rt_custom_object_t)obj;\n\n    if (cobj->destroy != RT_NULL) {\n        result = cobj->destroy(cobj);\n    }\n    else {\n        result = RT_EOK;\n    }\n\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 49.821583826962026}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result;\n    struct rt_custom_object *cobj;\n    RT_ASSERT(obj != RT_NULL);\n    cobj = (struct rt_custom_object *)obj;\n    RT_ASSERT(cobj->parent.type == RT_Object_Class_Custom);\n    result = rt_object_delete(&cobj->parent);\n    if (cobj->destroy != RT_NULL) {\n        result = cobj->destroy(cobj);\n    }\n    return result;\n}", "CodeBleu_score": 56.91676852206773}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_custom_object_t cobj;\n    rt_err_t result;\n\n    cobj = (rt_custom_object_t)obj;\n    RT_ASSERT(cobj != RT_NULL);\n    RT_ASSERT(cobj->parent.type == RT_Object_Class_Custom);\n\n    if (cobj->destroy != RT_NULL) {\n        result = cobj->destroy(cobj);\n    }\n    else {\n        result = RT_EOK;\n    }\n\n    rt_object_delete((rt_object_t)cobj);\n\n    return result;\n}", "CodeBleu_score": 48.18980256398156}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    struct rt_thread *thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* close the thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_thread_defunct_enqueue(thread);\n\n    /* exit critical */\n    rt_exit_critical_safe();\n\n    /* switch to next thread */\n    rt_schedule();\n}", "CodeBleu_score": 72.05667766143412}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n    rt_base_t level;\n\n    /* get current thread */\n    thread = rt_thread_self();\n    /* lock scheduler */\n    level = rt_enter_critical();\n    /* close thread */\n    rt_thread_close(thread);\n    /* defunct thread */\n    rt_thread_defunct_enqueue(thread);\n    /* unlock scheduler */\n    rt_exit_critical_safe(level);\n    /* switch to next thread */\n    rt_schedule();\n}", "CodeBleu_score": 71.32217891675856}, {"code": "static void _thread_exit(void){\n\t    struct rt_thread *thread;\n\n    thread = rt_thread_self();\n    RT_ASSERT(thread != RT_NULL);\n\n    rt_enter_critical();\n    rt_thread_close(thread);\n    rt_thread_defunct_enqueue(thread);\n    rt_exit_critical_safe();\n\n    rt_schedule();\n\n    /* never come back */\n    RT_ASSERT(0);\n}", "CodeBleu_score": 73.4907019992518}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t) parameter;\n    rt_base_t level;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n    level = rt_hw_interrupt_disable();\n    rt_sched_lock();\n\n    /* remove from suspend list */\n    RT_ASSERT(thread->scheduler_lock_nest == 0);\n    RT_ASSERT(rt_list_find(&thread->suspend_node, &rt_thread_suspend_list) != RT_NULL);\n    rt_list_remove(&thread->suspend_node);\n\n    /* insert to ready list */\n    RT_ASSERT(rt_list_find(&thread->tlist, &rt_thread_ready_list) == RT_NULL);\n    rt_sched_insert_thread(thread);\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    rt_sched_unlock_n_resched();\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 54.26208145412891}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n    rt_ubase_t level;\n\n    thread = (struct rt_thread *)parameter;\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n    level = rt_hw_interrupt_disable();\n    /* remove from suspend list */\n    rt_list_remove(&(thread->tlist));\n    /* insert to ready list */\n    rt_sched_insert_thread(thread);\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* do schedule */\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 53.099481825806606}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread = (rt_thread_t)parameter;\n    rt_base_t level;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n    level = rt_hw_interrupt_disable();\n    rt_sched_lock();\n\n    /* remove thread from suspend list */\n    RT_ASSERT(rt_list_remove(&(thread->suspend_node)) != RT_NULL);\n\n    /* insert thread to ready list */\n    rt_sched_insert_thread(thread);\n\n    /* set error number */\n    thread->error = -RT_ETIMEOUT;\n\n    rt_sched_unlock_n_resched();\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 54.171255720093214}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_list_t *list;\n    struct rt_mutex *mutex;\n\n    level = rt_hw_interrupt_disable();\n    rt_spin_lock(&(thread->spinlock));\n\n    list = &(thread->tlist);\n    if (rt_list_isempty(list)) {\n        rt_spin_unlock(&(thread->spinlock));\n        rt_hw_interrupt_enable(level);\n        return;\n    }\n\n    mutex = rt_list_entry(list->next, struct rt_mutex, mlist);\n    rt_list_remove(list);\n    rt_list_remove(&(thread->tlist));\n    mutex->owner = RT_NULL;\n    thread->error = -RT_ERROR;\n\n    rt_spin_unlock(&(thread->spinlock));\n    rt_hw_interrupt_enable(level);\n\n    rt_mutex_release(mutex);\n}", "CodeBleu_score": 51.45387381756843}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_list_t *list;\n    rt_mutex_t mutex;\n\n    level = rt_hw_interrupt_disable();\n\n    /* remove thread from mutex wait list */\n    list = &(thread->thread_list);\n    if (rt_list_isempty(list) == RT_FALSE) {\n        mutex = rt_list_entry(list->next, struct rt_mutex, mtx_list);\n        rt_list_remove(list);\n        rt_mutex_release(mutex);\n    }\n\n    /* remove thread from mutex owner list */\n    list = &(thread->hold_mutex_list);\n    while (rt_list_isempty(list) == RT_FALSE) {\n        mutex = rt_list_entry(list->next, struct rt_mutex, owner_list);\n        rt_mutex_release(mutex);\n    }\n\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 45.950351916476166}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_list_t *list;\n    struct rt_mutex *mutex;\n\n    level = rt_hw_interrupt_disable();\n    rt_spin_lock(&(thread->spinlock));\n\n    /* remove thread from mutex's list */\n    list = &(thread->tlist);\n    if (rt_list_isempty(list)) {\n        mutex = rt_list_entry(list->next, struct rt_mutex, mlist);\n\n        rt_list_remove(list);\n\n        rt_mutex_release(mutex);\n    }\n\n    rt_spin_unlock(&(thread->spinlock));\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 34.10833603281852}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->state == RT_THREAD_INIT);\n\n    LOG_D(\"startup thread:%s\", thread->name);\n\n    /* change stat */\n    thread->state = RT_THREAD_SUSPEND;\n    thread->stat  = RT_THREAD_STAT_INIT;\n\n    /* calculate priority attribute */\n    rt_sched_thread_startup(thread);\n\n    /* resume it */\n    rt_thread_resume(thread);\n\n    /* do a schedule */\n    if (rt_thread_self() != RT_NULL) {\n        rt_schedule();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 60.31180453621876}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n    RT_ASSERT(rt_object_is_systemobject(&thread->parent.parent));\n\n    LOG_D(\"thread startup: %s\", thread->name);\n\n    /* change stat */\n    rt_thread_resume(thread);\n\n    /* do scheduler */\n    rt_sched_thread_startup(thread);\n\n    return RT_EOK;\n}", "CodeBleu_score": 47.990131421520985}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t result;\n    register rt_base_t temp;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n    RT_ASSERT(rt_object_is_systemobject(&thread->parent.parent));\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->name,\n                  rt_thread_timeout,\n                  thread,\n                  0,\n                  RT_TIMER_FLAG_ONE_SHOT);\n\n    /* thread state check (RUNNING,READY,SUSPEND) */\n    RT_ASSERT(rt_object_is_init(&(thread->parent.parent)));\n\n    LOG_D(\"thread startup: %s\", thread->name);\n\n    /* set thread to suspend state */\n    temp = rt_hw_interrupt_disable();\n    thread->stat = RT_THREAD_SUSPEND;\n    rt_hw_interrupt_enable(temp);\n\n    /* calculate priority attribute */\n    rt_sched_thread_startup(thread);\n\n    /* resume thread, and check schedule */\n    rt_thread_resume(thread);\n\n    /* do a schedule */\n    if (!rt_thread_self()->stat) {\n        rt_schedule();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 45.98614949191769}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    struct rt_timer *timer;\n    rt_list_t *list;\n\n    /* check timer list is empty */\n    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ERROR;\n    }\n\n    /* get the first timer */\n    list = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n    timer = rt_list_entry(list->next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n    *timeout_tick = timer->timeout_tick;\n    return RT_EOK;\n}", "CodeBleu_score": 74.92456859553168}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ERROR;\n    }\n\n    *timeout_tick = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,\n                                  struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1])->timeout_tick;\n    return RT_EOK;\n}", "CodeBleu_score": 71.41951742249152}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ERROR;\n    }\n\n    *timeout_tick = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,\n                                  rt_timer_t,\n                                  row[RT_TIMER_SKIP_LIST_LEVEL - 1])->timeout_tick;\n    return RT_EOK;\n}", "CodeBleu_score": 65.21036866383842}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t(timer);\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time >= 0);\n\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer != RT_NULL) {\n        timer->parent.flag = flag;\n\n        rt_list_init(&(timer->row[0]));\n        rt_list_init(&(timer->row[1]));\n\n        timer->timeout_func = timeout;\n        timer->parameter = parameter;\n\n        timer->init_tick = 0;\n        timer->timeout_tick = time;\n    }\n\n    return timer;\n}", "CodeBleu_score": 53.164788239453074}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate a timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer != RT_NULL) {\n        /* set flag */\n        timer->parent.flag = flag;\n\n        rt_timer_init(timer, name, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}", "CodeBleu_score": 59.595308285679984}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t(timer);\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time >= 0);\n\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer != RT_NULL) {\n        timer->parent.flag      = flag;\n        timer->timeout_func     = timeout;\n        timer->parameter        = parameter;\n        timer->timeout_tick     = time;\n        timer->init_tick        = rt_tick_get();\n\n        rt_timer_start(timer);\n    }\n\n    return timer;\n}", "CodeBleu_score": 53.347084241144785}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\thandler := func(w http.ResponseWriter, r *http.Request) {\n\t\ta.router.ServeHTTP(rec, req)\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tres.WriteHeader(rec.Code)\n\t}\n\n\tfor _, h := range a.handlers {\n\t\th(handler)(res, req)\n\t\tif res.Header().Get(\"WWW-Authenticate\") != \"\" {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\thandler(res, req)\n}", "CodeBleu_score": 64.43265285687039}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\t\tfor key, values := range rec.Header() {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 66.34037646200859}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\t\tfor key, vals := range rec.Header() {\n\t\t\tres.Header()[key] = vals\n\t\t}\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 83.84928238422057}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif strings.HasPrefix(path, \"/static/\") {\n\t\tpath = path[7:]\n\t}\n\tif path == \"/\" {\n\t\tpath = \"index.html\"\n\t}\n\tasset, err := Asset(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tswitch {\n\tcase strings.HasSuffix(path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase strings.HasSuffix(path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 58.19528892963963}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif strings.HasPrefix(path, \"/assets/\") {\n\t\tpath = path[len(\"/assets/\"):]\n\t}\n\tasset, err := a.Assets.Get(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", asset.ContentType)\n\tres.Write(asset.Content)\n}", "CodeBleu_score": 38.69842179507936}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"index.html\"\n\t}\n\tif strings.HasPrefix(path, \"/static/\") {\n\t\tpath = path[len(\"/static/\"):]\n\t}\n\tasset, err := a.assets.Get(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), 404)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", mime.TypeByExtension(filepath.Ext(path)))\n\tres.Write(asset)\n}", "CodeBleu_score": 37.362823754275645}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot != nil {\n\t\tconnections := make([]map[string]interface{}, len(robot.Connections()))\n\t\ti := 0\n\t\trobot.Connections().Each(func(c gobot.Connection) {\n\t\t\tconnections[i] = map[string]interface{}{\n\t\t\t\t\"name\":   c.Name(),\n\t\t\t\t\"params\": c.Params(),\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"No robot found with name \" + robotName})\n\t}\n}", "CodeBleu_score": 56.384537737803264}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\n\tif robot != nil {\n\t\tconnections := []map[string]interface{}{}\n\t\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\t\"Name\": connection.Name(),\n\t\t\t\t\"Type\": connection.Type(),\n\t\t\t})\n\t\t})\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"Error\": \"No robot found with name \" + robotName,\n\t\t})\n\t}\n}", "CodeBleu_score": 57.16641728823646}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot != nil {\n\t\tconnections := make([]map[string]interface{}, len(robot.Connections()))\n\t\ti := 0\n\t\tfor _, connection := range robot.Connections() {\n\t\t\tconnections[i] = map[string]interface{}{\n\t\t\t\t\"name\":   connection.Name(),\n\t\t\t\t\"type\":   connection.Type(),\n\t\t\t\t\"params\": connection.Params(),\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"Error\": \"No robot found with name \" + robotName,\n\t\t})\n\t}\n}", "CodeBleu_score": 53.846133970703434}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\tuser, pass, ok := req.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tres.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(res, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 60.7180445420265}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\tuser, pass, ok := req.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tres.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(res, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 60.43315720303673}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\tuser, pass, ok := req.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tres.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(res, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 61.48997242768286}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) int {\n\t\toutput := int(slope*input + intercept)\n\t\tif output < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif output > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn output\n\t}\n}", "CodeBleu_score": 71.9401985648436}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tvar slope float64 = (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tvar intercept float64 = float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tif input <= fromMin {\n\t\t\treturn toMin\n\t\t} else if input >= fromMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn int(slope*input + intercept)\n\t}\n}", "CodeBleu_score": 65.81073430767927}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) int {\n\t\tvalue := int(math.Round(slope*input + intercept))\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 55.2354942391419}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"not connected\")\n\t}\n\n\tif !a.Connection().HasAnalogRead {\n\t\treturn 0, 0, fmt.Errorf(\"connection doesn't support analog read\")\n\t}\n\n\traw, err := reader.AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.sensorCfg.lastRaw = raw\n\ta.sensorCfg.lastScaled = (float64(raw) * a.sensorCfg.scale) - a.sensorCfg.offset\n\n\treturn raw, a.sensorCfg.lastScaled, nil\n}", "CodeBleu_score": 55.20181747344213}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().HasCapability(a.Pin, a.sensorCfg.analogCap) {\n\t\treturn 0, 0.0, fmt.Errorf(\"the connection doesn't support analog reading\")\n\t}\n\n\tval, err := reader.AnalogRead(a.Connection(), a.Pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\ta.lastRawValue = val\n\ta.lastScaledValue = float64(val) * a.sensorCfg.scale\n\treturn val, a.lastScaledValue, nil\n}", "CodeBleu_score": 53.63382561381659}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Not connected\")\n\t}\n\n\tif !a.Connection().HasCapability(analog.AnalogReadCapability) {\n\t\treturn 0, 0, fmt.Errorf(\"Connection does not support analog reading\")\n\t}\n\n\traw, err := reader.AnalogRead(a.Pin())\n\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 53.17862694939146}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(val int) float64 {\n\t\treturn math.Max(math.Min(m*float64(val)+n, toMax), toMin)\n\t}\n}", "CodeBleu_score": 35.393232889796934}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(val int) float64 {\n\t\tif val < fromMin {\n\t\t\tval = fromMin\n\t\t} else if val > fromMax {\n\t\t\tval = fromMax\n\t\t}\n\t\treturn m*float64(val) + n\n\t}\n}", "CodeBleu_score": 56.74704054470108}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(input int) float64 {\n\t\toutput := m*float64(input) + n\n\t\tif output < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif output > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn output\n\t}\n}", "CodeBleu_score": 68.8634179788353}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, opts...)\n\n\td.Publish(d.Event(Data), d.Event(Error))\n\n\td.AddEvent(Vibration)\n\n\td.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &GrovePiezoVibrationSensorDriver{d}\n}", "CodeBleu_score": 53.07415490748648}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tv := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tpin:  pin,\n\t\tconnection: a.(gobot.Connection),\n\t}\n\n\tas, err := NewAnalogSensorDriver(a, pin, v.handle, opts...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tv.AnalogSensorDriver = *as\n\n\tv.AddEvent(v.Event(\"vibration\"))\n\tv.AddEvent(v.Event(\"data\"))\n\n\tv.On(v.Event(\"data\"), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tgobot.Publish(v.Event(\"vibration\"), true)\n\t\t} else {\n\t\t\tgobot.Publish(v.Event(\"vibration\"), false)\n\t\t}\n\t})\n\n\treturn v\n}", "CodeBleu_score": 50.89805911281675}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.Publish(d.Event(Data), d.Event(Error))\n\td.AddEvent(Vibration)\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\n\td.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &GrovePiezoVibrationSensorDriver{d}\n}", "CodeBleu_score": 57.18317672173251}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency.\n\tperiod := time.Duration(1 / hz * float64(time.Second))\n\t// Calculate the tempo based on the given beats per minute.\n\ttempo := time.Duration(60 / d.BPM * float64(time.Second))\n\t// Calculate the number of times to toggle the buzzer on and off.\n\tcycles := int(duration / (period / tempo))\n\t// Toggle the buzzer on and off at intervals determined by the tone period.\n\tfor i := 0; i < cycles; i++ {\n\t\t// Turn the buzzer on.\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Sleep for the tone period.\n\t\ttime.Sleep(period / tempo)\n\t\t// Turn the buzzer off.\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Sleep for the tempo.\n\t\ttime.Sleep(period / tempo)\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.45862556587271}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period in seconds.\n\tperiod := 1.0 / hz\n\n\t// Calculate the number of times to toggle the buzzer.\n\tcount := int(duration / period)\n\n\t// Calculate the time to wait between toggles.\n\twait := time.Duration(period*1000) * time.Millisecond\n\n\t// Toggle the buzzer on and off at the calculated intervals.\n\tfor i := 0; i < count; i++ {\n\t\td.On()\n\t\ttime.Sleep(wait)\n\t\td.Off()\n\t\ttime.Sleep(wait)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.679533519274923}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.State != \"on\" {\n\t\treturn errors.New(\"buzzer is not on\")\n\t}\n\n\t// calculate tone period in seconds\n\tperiod := 1.0 / hz\n\n\t// calculate tone tempo in seconds\n\ttempo := 60.0 / d.BeatsPerMinute\n\n\t// calculate number of toggles required\n\ttoggles := int(math.Round(duration / tempo))\n\n\tfor i := 0; i < toggles; i++ {\n\t\ttime.Sleep(time.Duration(period*1000000000.0) * time.Nanosecond)\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period*1000000000.0) * time.Nanosecond)\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 56.23841340926692}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif !d.sleepPinSet {\n\t\treturn errors.New(\"Sleep pin not set\")\n\t}\n\n\td.stopIfRunning()\n\n\td.digitalWrite(d.sleepPin, 0)\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 27.949977077186734}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif !d.sleepPin.Get() {\n\t\treturn fmt.Errorf(\"easydriver: sleep pin is not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.983459993678448}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif !d.sleepPin.IsSet() {\n\t\treturn fmt.Errorf(\"Sleep pin is not set\")\n\t}\n\n\td.stopIfRunning()\n\n\td.sleepPin.Low()\n\td.isSleeping = true\n\treturn nil\n}", "CodeBleu_score": 28.053878681965866}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins map is nil\")\n\t}\n\n\tif val, ok := a.pins[id]; ok {\n\t\treturn val, nil\n\t}\n\n\tpin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin.SetPin(pin.Pin())\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 50.40132926684816}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analog pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err := sysfs.NewAnalogPin(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 52.58367614275316}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map not initialized\")\n\t}\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin = a.sys.NewAnalogPin(path)\n\tpin.SetPinParameters(params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 59.16855691960821}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.20225929251318}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\n\treturn nil\n}", "CodeBleu_score": 64.63496349137081}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsystem.WithPinDirectionOutput(pin, func() {\n\t\tpin.Write(val)\n\t})\n\n\treturn nil\n}", "CodeBleu_score": 68.64673549071823}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"Not connected to any pins\")\n\t}\n\tfor _, pin := range a.pins {\n\t\tif pin.Id() == id {\n\t\t\tfor _, opt := range opts {\n\t\t\t\topt(pin)\n\t\t\t}\n\t\t\treturn pin, nil\n\t\t}\n\t}\n\tchip, line, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := sysfs.NewDigitalPin(chip, line)\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\tif err := pin.ApplyOptions(); err != nil {\n\t\treturn nil, fmt.Errorf(\"Error applying options to pin: %v\", err)\n\t}\n\tif err := pin.Initialize(); err != nil {\n\t\treturn nil, fmt.Errorf(\"Error initializing pin: %v\", err)\n\t}\n\ta.pins = append(a.pins, pin)\n\treturn pin, nil\n}", "CodeBleu_score": 54.2883476410984}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif !a.Connected() {\n\t\treturn nil, errors.New(\"Not Connected\")\n\t}\n\n\tif a.pinMap == nil {\n\t\ta.pinMap = make(map[string]gobot.DigitalPinner)\n\t}\n\n\tif pin, ok := a.pinMap[id]; ok {\n\t\tfor _, opt := range opts {\n\t\t\topt(pin.(gobot.DigitalPinOptioner))\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\tvar pin gobot.DigitalPinner\n\tvar err error\n\tif id, err = a.translate(id); err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err = a.sys.NewDigitalPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin.(gobot.DigitalPinOptioner))\n\t}\n\n\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pinMap[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 50.47447232264295}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"Not connected to any digital pins\")\n\t}\n\tif id == \"\" {\n\t\treturn nil, errors.New(\"Digital pin requires an ID\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\t\treturn pin, nil\n\t}\n\tvar pin *sysfs.DigitalPin\n\tif id[0] == 'P' {\n\t\tpin = sysfs.NewDigitalPin(id)\n\t} else {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = sysfs.NewDigitalPin(chip + \":\" + line)\n\t}\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\tif err := pin.ApplyOptions(); err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 55.561134547562965}]}
