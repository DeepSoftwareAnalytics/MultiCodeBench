{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> files;\n\tstd::vector<std::string> file_list;\n\tstd::string file_path;\n\tstd::string file_name;\n\tstd::string file_ext;\n\tstd::string file_dir;\n\tstd::string file_dir_full;\n\tstd::string file_path_full;\n\tstd::string file_path_local;\n\tstd::string file_path_local_full;\n\tstd::string file_path_local_full_old;\n\tstd::string file_path_local_old;\n\tstd::string file_path_local_new;\n\tstd::string file_path_local_new_full;\n\tstd::string file_path_local_new_full_old;\n\tstd::string file_path_local_new_old;\n\tstd::string file_path_local_old_full;\n\tstd::string file_path_local_old_full_old;\n\tstd::string file_path_local_old_old;\n\tstd::string file_path_local_old_old_full;\n\tstd::string file_path_local_old_old_full_old;\n\tstd::string file_path_local_old_old_old;\n\tstd::string file_path_local_old_old_old_full;\n\tstd::string file_path_local_old_old_old_full_old;\n\tstd::string file_path_local_old_old_old_old;\n\tstd::string file_path_local_old_old_old_old_full;\n\tstd::string file_path_local_old_old_old_old_full_old;\n\tstd::string file_path_local_old_old_old_old_old;\n\tstd::string file_path_local_old_old_old_old_old_full;\n\tstd::string file_path_local_old_old_old_old_old_full_old;\n\tstd::string file_path_local_old_old_old_old_old_old;\n\tstd::string file_path_local_old_old_old_old_old_old", "CodeBleu_score": 14.050165947605148}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> files;\n    std::vector<std::string> required_files;\n\n    // Get the list of files\n    files = _pimpl->CallAndWait<std::vector<std::string>>(&ClientImpl::ListFiles, folder);\n\n    // Get the list of required files\n    for (auto &file : files) {\n        // If the file is required, add it to the list\n        if (IsRequiredFile(file)) {\n            required_files.push_back(file);\n        }\n    }\n\n    // If the download flag is set to true, download the required files\n    if (download) {\n        // For each required file\n        for (auto &file : required_files) {\n            // If the file does not exist locally\n            if (!FileTransfer::FileExists(file)) {\n                // Request the file\n                _pimpl->RequestFile(file);\n\n                // Log the download action\n                log_info(\"Downloaded file \" + file);\n            }\n            else {\n                // Log that the file is found in the cache\n                log_info(\"Found file \" + file + \" in cache\");\n            }\n        }\n    }\n\n    // Return the list of required files\n    return required_files;\n}", "CodeBleu_score": 57.84100861823749}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> required_files;\n\n    // Get a list of files in the specified folder\n    std::vector<std::string> files = _pimpl->GetFilesInFolder(folder);\n\n    // If the download flag is set to true, check if each file exists locally\n    if (download) {\n        // For each file in the list of files\n        for (const auto &file : files) {\n            // If the file exists locally\n            if (FileTransfer::FileExists(file)) {\n                // Log that the file is found in the cache\n                log_info(\"File found in cache: {}\", file);\n            }\n            // Otherwise, if the file does not exist locally\n            else {\n                // Request the file\n                _pimpl->RequestFile(file);\n\n                // Log that the file was downloaded\n                log_info(\"File downloaded: {}\", file);\n            }\n\n            // Add the file to the list of required files\n            required_files.push_back(file);\n        }\n    }\n    // Otherwise, if the download flag is set to false\n    else {\n        // Add each file to the list of required files\n        required_files = files;\n    }\n\n    return required_files;\n}", "CodeBleu_score": 54.93986129185724}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  rpc::Actor actor;\n  actor.description = description;\n  actor.transform = transform;\n  actor.parent_id = parent;\n  actor.attachment_type = attachment_type;\n  actor.attachment_socket_name = socket_name;\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.rotation.IsIdentity()) {\n      if (transform.location.x == 0.0f && transform.location.y == 0.0f) {\n        if (transform.location.z <= 0.0f) {\n          LOG_WARNING(\n              \"The translation is only in the 'z' axis, \"\n              \"but the 'z' component is negative. \"\n              \"This is an ill-formed transformation. \"\n              \"Please use a translation with a positive 'z' component.\");\n        }\n      } else {\n        LOG_WARNING(\n            \"The translation is not only in the 'z' axis. \"\n            \"This is an ill-formed transformation. \"\n            \"Please use a translation only in the 'z' axis.\");\n      }\n    } else {\n      LOG_WARNING(\n          \"The transformation has a rotation component. \"\n          \"This is an ill-formed transformation. \"\n          \"Please use a transformation without a rotation component.\");\n    }\n  }\n  return _pimpl->SpawnActor(actor);\n}", "CodeBleu_score": 44.917993402804605}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  REQUIRE_CARLA_EPISODE();\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    const geom::Vector3D translation = transform.location;\n    const geom::Vector3D up_vector = transform.GetForwardVector();\n    if (std::abs(geom::Math::Dot(translation, up_vector)) >\n        geom::Math::MakeSafeUnitVector(up_vector).z *\n            std::numeric_limits<float>::epsilon()) {\n      log_warning(\"The translation vector is not perpendicular to the up \"\n                  \"vector of the transform. This is not supported for \"\n                  \"SpringArm and SpringArmGhost attachment types.\");\n    }\n  }\n  return _pimpl->SpawnActorWithParent(\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 55.08450497581154}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  REQUIRE_CARLA_EPISODE();\n  auto *Episode = _episode->GetEpisode().get();\n  const auto Parent = Episode->GetActor(parent);\n  if (Parent == nullptr) {\n    throw_exception(std::runtime_error(\"unable to spawn: parent actor not found\"));\n  }\n  if (attachment_type == rpc::AttachmentType::Rigid) {\n    if (Parent->GetTypeId() == \"traffic.traffic_light\") {\n      throw_exception(std::runtime_error(\"unable to attach traffic light\"));\n    }\n  }\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.MakeSafeUnitVector().Z != 0.0f) {\n      log_warning(\"spawned actor with spring arm will be attached in the z-axis\");\n    }\n  }\n  return _pimpl->SpawnActor(description, transform, Parent, attachment_type, socket_name);\n}", "CodeBleu_score": 54.196380265304235}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  \n  // Retrieve the token for the G-buffer.\n  auto token_data = _pimpl->client.GetGBufferToken(ActorId, GBufferId);\n  // Copy the token data.\n  std::vector<unsigned char> token_data_copy(token_data.size());\n  std::memcpy(token_data_copy.data(), token_data.data(), token_data.size());\n  // Subscribe to the streaming client using the provided callback function.\n  _pimpl->streaming_client.Subscribe(std::move(token_data_copy), std::move(callback));\n}", "CodeBleu_score": 60.28116870124097}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n  // Retrieve a token for the G-buffer.\n  auto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\"simulator_get_gbuffer_token\", ActorId, GBufferId);\n\n  // Copy the token data.\n  auto token = std::make_unique<unsigned char[]>(token_data.size());\n  std::memcpy(token.get(), token_data.data(), token_data.size());\n\n  // Subscribe to the streaming client.\n  _pimpl->streaming_client.Subscribe(std::move(token), token_data.size(), callback);\n}", "CodeBleu_score": 65.03328144577986}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n  // Retrieve token for G-buffer\n  auto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\"simulator.get_gbuffer_token\", ActorId, GBufferId);\n\n  // Copy token data\n  std::vector<unsigned char> token(token_data.size());\n  std::memcpy(token.data(), token_data.data(), token_data.size());\n\n  // Subscribe to streaming client\n  _pimpl->streaming_client.Subscribe(std::move(token), std::move(callback));\n}", "CodeBleu_score": 67.55801367220337}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> walker_navigation = _walker_navigation.load();\n  if (walker_navigation != nullptr) {\n    return walker_navigation;\n  }\n  walker_navigation = std::make_shared<WalkerNavigation>(GetWorld());\n  if (_walker_navigation.compare_exchange(walker_navigation, nullptr)) {\n    return walker_navigation;\n  }\n  return _walker_navigation.load();\n}", "CodeBleu_score": 49.688004939975535}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> walker_navigation = _walker_navigation.load();\n  if (walker_navigation == nullptr) {\n    walker_navigation = std::make_shared<WalkerNavigation>(GetEpisodeProxy());\n    std::shared_ptr<WalkerNavigation> expected_null = nullptr;\n    if (_walker_navigation.compare_exchange(expected_null, walker_navigation)) {\n      walker_navigation->SetParent(_parent);\n    } else {\n      walker_navigation = _walker_navigation.load();\n    }\n  }\n  return walker_navigation;\n}", "CodeBleu_score": 54.194409203385106}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> nav = _walker_navigation.load();\n  if (nav == nullptr) {\n    std::shared_ptr<WalkerNavigation> new_nav = std::make_shared<WalkerNavigation>(shared_from_this());\n    if (_walker_navigation.compare_exchange(nav, new_nav)) {\n      nav = new_nav;\n    }\n  }\n  return nav;\n}", "CodeBleu_score": 64.97061460237893}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  time_point start = time_point::max();\n  time_point end = time_point::max();\n  start = time_point::clock::now();\n  end = start + timeout;\n  while (episode.GetState()->GetTimestamp() < frame) {\n    if (time_point::clock::now() > end) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetState()->GetTimestamp();\n  return true;\n}", "CodeBleu_score": 42.192471277874745}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const time_point start = std::chrono::system_clock::now();\n  while (frame > episode.GetState()->GetTimestamp().frame) {\n    std::this_thread::yield();\n    if (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - start) > timeout) {\n      return false;\n    }\n  }\n  episode.GetState()->GetTimestamp().frame = frame;\n  episode.GetState()->GetTimestamp().elapsed_seconds = 0.0f;\n  episode.GetState()->GetTimestamp().delta_seconds = 0.0f;\n  episode.GetState()->GetTimestamp().platform_timestamp = 0u;\n  return true;\n}", "CodeBleu_score": 50.53607093169378}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto end = std::chrono::system_clock::now() + timeout;\n  while (episode.GetState()->GetTimestamp() < frame) {\n    if (std::chrono::system_clock::now() > end) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetState()->GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 39.012763239937996}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  const auto timeout = _client.GetTimeout();\n  auto attempts = timeout.milliseconds() / 100;\n  for (auto i = 0u; i < attempts; ++i) {\n    auto episode = GetCurrentEpisode();\n    if (episode.GetId() != 0) {\n      return episode;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n  }\n\n  throw_exception(std::runtime_error(\"failed to connect to new episode\"));\n}", "CodeBleu_score": 59.124596224839344}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // Get the current episode id.\n  auto episode = GetCurrentEpisode();\n  auto episode_id = episode.GetId();\n  // Send the tick cue to start loading the new episode.\n  _client.SendTickCue();\n  // Set the new episode settings.\n  _client.GetEpisodeSettings(episode).SetMapLayerSettings(map_layers);\n  _client.GetEpisodeSettings(episode).SetMapName(map_name);\n  _client.GetEpisodeSettings(episode).SetResetSettings(reset_settings);\n  // Wait for the new episode to be loaded.\n  bool is_loaded = false;\n  for (auto i = 0; i < _client.GetTimeout().milliseconds(); ++i) {\n    // Check if the episode has changed.\n    episode = GetCurrentEpisode();\n    if (episode_id != episode.GetId()) {\n      // Wait for the new episode to be ready.\n      episode.WaitForState(rpc::EpisodeState::Ready);\n      is_loaded = true;\n      break;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n  }\n  if (!is_loaded) {\n    throw_exception(std::runtime_error(\"failed to connect to the new episode\"));\n  }\n  return episode;\n}", "CodeBleu_score": 58.452401788902186}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  auto timeout = _client.GetTimeout();\n\n  for (auto i = 0; i < timeout.number_of_attempts; ++i) {\n    auto episode = GetCurrentEpisode();\n\n    if (episode.GetId() != 0) {\n      return episode;\n    }\n\n    std::this_thread::sleep_for(timeout.milliseconds);\n  }\n\n  throw_exception(std::runtime_error(\"Failed to connect to episode\"));\n}", "CodeBleu_score": 51.59700397185966}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = GetWalker(controller.GetParent());\n  DEBUG_ASSERT(walker != nullptr);\n  DEBUG_ASSERT(_episode != nullptr);\n  auto nav = _episode->CreateNavigationIfMissing();\n  nav->RegisterWalker(controller.GetId(), walker->GetId());\n}", "CodeBleu_score": 63.37075077230627}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    DEBUG_ASSERT(_episode != nullptr);\n    auto *walker = GetWalker(controller.GetParent());\n    DEBUG_ASSERT(walker != nullptr);\n    if (_episode->GetNavigation() == nullptr) {\n        _episode->CreateNavigationIfMissing();\n    }\n    auto *nav = _episode->GetNavigation();\n    nav->RegisterWalker(controller.GetId(), walker->GetId());\n}", "CodeBleu_score": 58.640182658971}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    DEBUG_ASSERT(_episode != nullptr);\n    auto walker = GetWalker(controller.GetParent());\n    DEBUG_ASSERT(walker != nullptr);\n    DEBUG_ASSERT(walker->GetId() == controller.GetParent());\n    DEBUG_ASSERT(walker->GetDisplayId() == controller.GetDisplayId());\n    DEBUG_ASSERT(walker->GetControllerId() == controller.GetId());\n    _episode->CreateNavigationIfMissing();\n    auto nav = _episode->GetNavigation();\n    DEBUG_ASSERT(nav != nullptr);\n    nav->RegisterWalker(controller.GetId());\n}", "CodeBleu_score": 59.358073542200444}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  REQUIRE_CARLA_EPISODE();\n  auto *Episode = EpisodeProxy.Lock();\n  REQUIRE_CARLA_EPISODE();\n  auto result = Episode->SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n  if (result != nullptr) {\n    _episode->RegisterActor(*result);\n    if (gc == GarbageCollectionPolicy::Inherit) {\n      result->SetGarbageCollection(Parent->GetGarbageCollection());\n    } else {\n      result->SetGarbageCollection(gc);\n    }\n    log_debug(\n        \"spawned actor\",\n        result->GetDisplayId(),\n        \"with parent\",\n        (parent != nullptr ? parent->GetDisplayId() : 0u),\n        \"and transform\",\n        transform);\n  }\n  return result;\n}", "CodeBleu_score": 51.292196676701394}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  REQUIRE_CARLA_EPISODE();\n  auto *Episode = EpisodeProxy.Lock();\n  SharedPtr<Actor> Actor = Episode->SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n  if (Actor != nullptr) {\n    ActorRegistry.Register(Actor);\n  }\n  return Actor;\n}", "CodeBleu_score": 32.703418314413895}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  REQUIRE_CARLA_EPISODE();\n  auto *Episode = EpisodeProxy.Lock();\n  REQUIRE_TRUE(Episode != nullptr);\n  auto Result = Episode->SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n  return Result ? Result->GetActor() : nullptr;\n}", "CodeBleu_score": 32.31734001838898}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  REQUIRE_CARLA_EPISODE();\n  auto ep = GetCurrentEpisode();\n  DEBUG_ASSERT(ep != nullptr);\n  auto token = sensor.GetActorDescription().GetStreamToken();\n  DEBUG_ASSERT(token != nullptr);\n  ep->SubscribeToStream(*token, [cb=std::move(callback), ep, weak_sensor=sensor.GetActor()](auto buffer) {\n    auto data = sensor::Deserializer::Deserialize(buffer);\n    data->SetEpisode(ep);\n    data->_sensor = weak_sensor.lock();\n    cb(std::move(data));\n  });\n}", "CodeBleu_score": 66.09999407516769}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  REQUIRE_CARLA_EPISODE();\n  DEBUG_ASSERT(sensor.GetActorDescription().GetStreamToken().size() > 0u);\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [ep = shared_from_this(), sensor, cb = std::move(callback)](auto buffer) {\n        auto data = sensor::Deserializer::Deserialize(std::move(buffer));\n        data->SetEpisode(ep);\n        cb(std::move(data));\n      });\n}", "CodeBleu_score": 67.27301919595948}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  REQUIRE_CARLA_EPISODE();\n  auto ep = GetCurrentEpisode();\n  DEBUG_ASSERT(ep != nullptr);\n  auto token = sensor.GetActorDescription().GetStreamToken();\n  DEBUG_ASSERT(token != 0u);\n  ep->SubscribeToStream(\n      token,\n      [cb=std::move(callback), ep](auto buffer) {\n        auto data = sensor::Deserializer::Deserialize(std::move(buffer));\n        data->SetEpisode(ep);\n        cb(std::move(data));\n      });\n}", "CodeBleu_score": 70.96512772027248}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  // load walkers\n  std::vector<ActorPtr> walkers;\n  episode->GetActors(walkers);\n  if (walkers.empty()) {\n    return;\n  }\n\n  // remove walkers that no longer exist\n  std::vector<int> walkers_to_remove;\n  for (auto &walker_pair : _walkers) {\n    if (std::find_if(walkers.begin(), walkers.end(), [&walker_pair](auto &&actor) {\n          return walker_pair.first == actor->GetId();\n        }) == walkers.end()) {\n      walkers_to_remove.emplace_back(walker_pair.first);\n    }\n  }\n  for (auto &&walker_id : walkers_to_remove) {\n    UnregisterWalker(walker_id);\n  }\n\n  // update vehicles in crowd\n  UpdateVehiclesInCrowd(episode);\n\n  // update crowd\n  _nav.UpdateCrowd();\n\n  // apply walker states\n  std::vector<crowd::Command> commands;\n  commands.reserve(walkers.size());\n  for (auto &&walker : walkers) {\n    if (CheckIfWalkerExist(walker->GetId())) {\n      auto transform = _nav.GetWalkerTransform(walker->GetId());\n      auto speed = _nav.GetWalkerSpeed(walker->GetId());\n      commands.emplace_back(crowd::Command{\n          walker->GetId(),\n          crowd::Command::Type::ApplyVelocity,\n          transform,\n          speed});\n    }\n  }\n  _simulator.lock()->ApplyBatchSync(std::move(commands), true);\n\n  // remove dead walkers\n  walkers_to_remove.clear();\n  for (auto &&walker_pair : _walkers) {\n    if (!_nav.IsWalkerAlive(walker_pair.first)) {\n      walkers_to_remove.emplace_back(walker_pair.first);\n    }\n  }\n  for (", "CodeBleu_score": 48.17172076146646}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  // Load the current walkers.\n  auto walkers = episode->GetWalkers();\n  if (walkers->empty()) {\n    return;\n  }\n\n  // Remove any walkers that no longer exist.\n  for (auto it = walkers->begin(); it != walkers->end();) {\n    if (!CheckIfWalkerExist(*it)) {\n      it = walkers->erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  // Update the vehicles in the crowd.\n  UpdateVehiclesInCrowd(episode);\n\n  // Update the crowd.\n  _nav.UpdateCrowd();\n\n  // Apply the batch.\n  std::vector<crowd::Command> commands;\n  commands.reserve(walkers->size());\n  for (auto &walker : *walkers) {\n    const auto transform = _nav.GetWalkerTransform(walker);\n    const auto speed = _nav.GetWalkerSpeed(walker);\n    commands.emplace_back(crowd::Command::ApplyVehicleControl, walker, transform, speed);\n  }\n  _simulator.lock()->ApplyBatchSync(std::move(commands), true);\n\n  // Remove any dead walkers.\n  for (auto it = walkers->begin(); it != walkers->end();) {\n    if (!_nav.IsWalkerAlive(*it)) {\n      _simulator.lock()->SetActorDead(*it);\n      _simulator.lock()->DestroyActor(*it);\n      _nav.RemoveAgent(*it);\n      UnregisterWalker(*it);\n      it = walkers->erase(it);\n    } else {\n      ++it;\n    }\n  }\n}", "CodeBleu_score": 53.35526175657546}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  _walkers.Load(episode->GetWalkers());\n  if (_walkers.size() == 0) {\n    return;\n  }\n\n  auto state = episode->GetState();\n  auto walkers_to_remove = _walkers.RemoveIf([&state](auto& walker) {\n    return !state->GetActor(walker.GetActorId());\n  });\n  for (auto& walker : walkers_to_remove) {\n    _nav.RemoveAgent(walker.GetActorId());\n    UnregisterWalker(walker.GetActorId());\n  }\n\n  UpdateVehiclesInCrowd(episode);\n  _nav.UpdateCrowd();\n\n  std::vector<crowd::Command> commands;\n  commands.reserve(_walkers.size());\n\n  for (auto& walker : _walkers) {\n    auto speed = _nav.GetWalkerSpeed(walker.GetActorId());\n    auto transform = _nav.GetWalkerTransform(walker.GetActorId());\n    commands.emplace_back(walker.GetActorId(), transform, speed);\n  }\n\n  _simulator.lock()->ApplyBatchSync(std::move(commands), false);\n\n  for (auto& walker : _walkers) {\n    if (!_nav.IsWalkerAlive(walker.GetActorId())) {\n      _simulator.lock()->SetActorCollisions(walker.GetActorId(), false);\n      _simulator.lock()->SetActorDead(walker.GetActorId());\n      _nav.RemoveAgent(walker.GetActorId());\n      UnregisterWalker(walker.GetActorId());\n    }\n  }\n}", "CodeBleu_score": 48.055603989405604}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = uid;\n  description.id = id;\n  description.attributes.reserve(_attributes.size());\n  for (const auto &attribute : _attributes) {\n    description.attributes.push_back(attribute.first);\n  }\n  return description;\n}", "CodeBleu_score": 79.77042996142904}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.uid = uid;\n    description.id = id;\n    description.attributes.reserve(_attributes.size());\n    for (auto &&attribute : _attributes) {\n        description.attributes.push_back(attribute.first);\n    }\n    return description;\n}", "CodeBleu_score": 72.92156156578027}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.uid = uid;\n  description.id = id;\n  description.attributes.reserve(_attributes.size());\n  for (auto &attribute : _attributes) {\n    description.attributes.push_back(attribute.second->MakeActorAttributeValue());\n  }\n  return description;\n}", "CodeBleu_score": 72.84800872553886}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto &pair : blueprints_) {\n    if (pair.second.ContainsAttribute(name)) {\n      if (pair.second.GetAttribute(name).GetValue().compare(value) == 0) {\n        result->AddBlueprint(pair.first, pair.second);\n      } else {\n        for (const auto &attr_value : pair.second.GetAttribute(name).GetRecommendedValues()) {\n          if (attr_value.compare(value) == 0) {\n            result->AddBlueprint(pair.first, pair.second);\n            break;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 50.860769243695245}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t    SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n    for (const auto &pair : _blueprints) {\n        if (pair.second.ContainsAttribute(name)) {\n            if (pair.second.GetAttribute(name) == value ||\n                pair.second.GetRecommendedValues().Contains(value)) {\n                result->AddBlueprint(pair.second);\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 40.4746731643407}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  result->blueprint_map_.reserve(blueprint_map_.size());\n  for (const auto &pair : blueprint_map_) {\n    if (pair.second.ContainsAttribute(name)) {\n      if (pair.second.GetAttribute(name).GetValue() == value ||\n          pair.second.GetAttribute(name).GetRecommendedValues().Contains(value)) {\n        result->blueprint_map_.emplace(pair.first, pair.second);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 42.99781892113612}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string full_path = base_path + path;\n    if (!ValidateFilePath(full_path)) {\n        return false;\n    }\n    std::ofstream out(full_path, std::ios::binary);\n    if (!out.good()) {\n        return false;\n    }\n    out.write((char*)content.data(), content.size());\n    out.close();\n    return true;\n}", "CodeBleu_score": 42.44936983390739}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string fullPath = baseFolder + \"/\" + carla::version + \"/\" + path;\n    if (!carla::FileSystem::ValidateFilePath(fullPath)) {\n        return false;\n    }\n    std::ofstream out(fullPath, std::ios::binary | std::ios::trunc);\n    if (!out.good()) {\n        out.close();\n        return false;\n    }\n    out.write((char *)content.data(), content.size());\n    out.close();\n    return true;\n}", "CodeBleu_score": 51.12199258024476}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string fullPath = GetFullPath(path);\n  if (!ValidateFilePath(fullPath)) {\n    return false;\n  }\n\n  std::ofstream out(fullPath, std::ios::binary);\n  if (!out.good()) {\n    return false;\n  }\n\n  out.write(reinterpret_cast<const char *>(content.data()), content.size());\n  out.close();\n  return true;\n}", "CodeBleu_score": 42.09738367084247}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n  const geom::Location &parent_loc = parent_bounds_[frame]->GetLocation();\n  const geom::Vector3D &parent_ext = parent_bounds_[frame]->GetExtent();\n  const geom::Vector3D &loc = parent_loc + transform.location;\n  const geom::Vector3D &ext = parent_ext.Rotate(transform.rotation);\n  const geom::Vector3D &corners[] = {\n        loc + geom::Vector3D(-ext.x, -ext.y, 0.0f),\n        loc + geom::Vector3D( ext.x, -ext.y, 0.0f),\n        loc + geom::Vector3D(-ext.x,  ext.y, 0.0f),\n        loc + geom::Vector3D( ext.x,  ext.y, 0.0f),\n  };\n\n  return std::make_shared<const Bounds>(frame, corners);\n}", "CodeBleu_score": 35.66855867597612}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n  const geom::Location location = parent_bounds_->at(frame)->location + transform.location;\n  const geom::Vector3D extents = parent_bounds_->at(frame)->extents;\n  const geom::Vector3D corners[4] = {\n        geom::Vector3D(extents.x, extents.y, 0.0f).Rotate(transform.rotation.yaw),\n        geom::Vector3D(extents.x, -extents.y, 0.0f).Rotate(transform.rotation.yaw),\n        geom::Vector3D(-extents.x, -extents.y, 0.0f).Rotate(transform.rotation.yaw),\n        geom::Vector3D(-extents.x, extents.y, 0.0f).Rotate(transform.rotation.yaw)\n  };\n\n  return std::make_shared<const Bounds>(frame, location, corners);\n}", "CodeBleu_score": 42.24166767035072}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n    const geom::Location parent_location = parent_bounds_->GetLocation(frame);\n    const geom::Location location = parent_location + transform.location;\n\n    const geom::Rotation rotation = transform.rotation + parent_bounds_->GetRotation(frame);\n\n    const geom::Vector3D extents = transform.extent + parent_bounds_->GetExtent(frame);\n\n    const geom::Vector3D x_vector = geom::Vector3D(extents.x, 0.0f, 0.0f).Rotate(rotation);\n    const geom::Vector3D y_vector = geom::Vector3D(0.0f, extents.y, 0.0f).Rotate(rotation);\n\n    const geom::Vector3D v_min = location - x_vector - y_vector;\n    const geom::Vector3D v_max = location + x_vector + y_vector;\n\n    return std::make_shared<const Bounds>(frame, location, rotation, v_min, v_max);\n}", "CodeBleu_score": 36.62981696575622}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n\n  const auto& lights_state = _episode.Lock()->QueryLightsStateToServer();\n\n  for (const auto& light_state : lights_state) {\n    const auto& light_id = light_state.first;\n    const auto& light_general_state = light_state.second;\n    const auto& light_state_color = light_general_state.state;\n\n    // update the state of the light\n    _lights[light_id].Set(light_state_color);\n\n    // if the light doesn't exist, create it\n    if (_lights.find(light_id) == _lights.end()) {\n      _lights.emplace(light_id, Light(light_id, light_state_color));\n    }\n  }\n}", "CodeBleu_score": 44.113124692278824}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    _episode.Lock()->GetLightManager()->UpdateLightsStateToServer(_lights);\n}", "CodeBleu_score": 8.709902881271265}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  _episode.Lock()->GetLightManager()->QueryLightsStateToServer(_lights);\n}", "CodeBleu_score": 10.701598289523396}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\n  _episode.Lock()->UpdateServerLightsState(discard_client);\n}", "CodeBleu_score": 11.840517932109517}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n\n  if (!_lights_changes.empty()) {\n    MessageBuilder builder;\n    builder.WriteToMessage(discard_client);\n    builder.WriteToMessage(_lights_changes.size());\n    for (auto& light_change : _lights_changes) {\n      builder.WriteToMessage(light_change.first);\n      builder.WriteToMessage(light_change.second);\n    }\n    _episode.Lock()->UpdateServerLightsState(builder.GetMessage());\n    _lights_changes.clear();\n    _lights_state_dirty = false;\n  }\n}", "CodeBleu_score": 39.16943739459331}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    if (!_lights_changes.empty()) {\n        if (!discard_client) {\n            auto message = messaging::CreateMessage(MSG_SET_LIGHT_STATE);\n            message->GetMessage().set_id(GetEpisode().GetId());\n            for (auto &change : _lights_changes) {\n                auto light_state = message->GetMessage().add_light_states();\n                light_state->set_light_id(change.first);\n                light_state->set_state(change.second);\n            }\n            GetEpisode().Lock()->SendMessage(std::move(message));\n        }\n        _lights_changes.clear();\n        _lights_changed = false;\n    }\n}", "CodeBleu_score": 44.46431632281562}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  log_debug(\"Sending message to episode: \" + message);\n\n  if (GetActorDescription().GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"Sensor ID is not 'sensor.other.v2x_custom'\");\n    return;\n  }\n\n  GetEpisode().Lock()->Send(GetDisplayId(), message);\n}", "CodeBleu_score": 59.87991716060092}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    log_debug(\"ServerSideSensor::Send called\");\n\n    if (GetSensorId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"Sensor ID does not match\");\n        return;\n    }\n\n    GetEpisode().Lock()->Send(message, GetDisplayId());\n}", "CodeBleu_score": 56.75607855984991}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    log_debug(\"ServerSideSensor::Send called\");\n    if (GetDisplayId() != \"sensor.other.v2x_custom\") {\n        log_warning(\"ServerSideSensor::Send called, but sensor ID is not sensor.other.v2x_custom\");\n        return;\n    }\n    GetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 59.20618877583645}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t  if (enabled) {\n    tm.RegisterVehicles(this, tm_port);\n  } else {\n    tm.UnregisterVehicles(this);\n  }\n}", "CodeBleu_score": 44.91266966441888}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        // Register the vehicle with the traffic manager.\n        tm.RegisterVehicles(this, 1, tm_port);\n    } else {\n        // Unregister the vehicle from the traffic manager.\n        tm.UnregisterVehicles(this, 1, tm_port);\n    }\n}", "CodeBleu_score": 50.07373100169941}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(this, tm_port);\n\t} else {\n\t\ttm.UnregisterVehicles(this);\n\t}\n}", "CodeBleu_score": 41.6393754269472}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t    _walker = GetParent()->GetParent();\n    GetEpisode().Lock()->RegisterAIController(this);\n    _walker->GetLocation(_initial_location);\n    GetEpisode().Lock()->AddWalker(_walker, _initial_location);\n    GetEpisode().Lock()->SetActorCollisions(_walker, false);\n    GetEpisode().Lock()->SetActorSimulatePhysics(_walker, false);\n}", "CodeBleu_score": 47.12450560234029}, {"code": "void WalkerAIController::Start(){\n\t\n  // Retrieve the walker actor.\n  _walker = GetParent()->Cast<Actor>();\n  if (_walker == nullptr) {\n    throw std::runtime_error(\"unable to retrieve walker actor\");\n  }\n\n  // Register the AI controller with the episode.\n  GetEpisode().Lock()->RegisterAIController(this);\n\n  // Retrieve the navigation mesh.\n  const auto &nav = GetEpisode().Lock()->GetNavigation();\n  if (nav == nullptr) {\n    throw std::runtime_error(\"unable to retrieve navigation mesh\");\n  }\n\n  // Add the walker to the navigation mesh.\n  nav->AddWalker(_walker->GetId(), _walker->GetLocation());\n\n  // Disable the walker's physics simulation and collisions.\n  GetEpisode().Lock()->SetActorSimulatePhysics(_walker->GetId(), false);\n  GetEpisode().Lock()->SetActorCollisions(_walker->GetId(), false);\n}", "CodeBleu_score": 54.11180455867199}, {"code": "void WalkerAIController::Start(){\n\t\n  // Retrieve the walker actor.\n  _walker = GetParent()->GetParent();\n  if (_walker == nullptr) {\n    throw std::runtime_error(\"unable to find walker actor\");\n  }\n\n  // Add the walker to the navigation system.\n  GetEpisode().Lock()->GetNavigation()->AddWalker(_walker);\n\n  // Disable the physics simulation and collisions for the walker.\n  GetEpisode().Lock()->SetActorSimulatePhysics(_walker, false);\n  GetEpisode().Lock()->SetActorCollisions(_walker, false);\n}", "CodeBleu_score": 47.067024607309534}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t    auto nav = GetEpisode().Lock()->GetNavigation();\n    if (!nav) {\n        log_warning(\"Failed to set max speed for walker: could not retrieve navigation from episode\");\n        return;\n    }\n\n    auto walker = GetParent();\n    if (!walker) {\n        log_warning(\"Failed to set max speed for walker: could not retrieve parent walker\");\n        return;\n    }\n\n    if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"Failed to set max speed for walker: could not set max speed\");\n    }\n}", "CodeBleu_score": 68.11630841987188}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t    auto nav = GetEpisode().Lock()->GetNavigation();\n    if (nav) {\n        auto walker = GetParent();\n        if (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n            log_warning(\"Failed to set max speed for walker \" + walker->GetId());\n        }\n    } else {\n        log_warning(\"Failed to set max speed, can't find the navigation module.\");\n    }\n}", "CodeBleu_score": 70.42127154979049}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t    auto nav = GetEpisode().Lock()->GetNavigation();\n    if (nav) {\n        auto walker = GetParent();\n        if (walker) {\n            if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n                log_warning(\"Failed to set max speed for walker \" + walker->GetDisplayId());\n            }\n        } else {\n            log_warning(\"Failed to find parent walker for walker controller\");\n        }\n    } else {\n        log_warning(\"Failed to find navigation for walker controller\");\n    }\n}", "CodeBleu_score": 68.72068896803071}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : _parent->GetMap().GetPrevious(this, distance)) {\n    result.emplace_back(std::move(waypoint));\n  }\n  return result;\n}", "CodeBleu_score": 59.25060389113299}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : _parent->GetMap().GetPrevious(this, distance)) {\n    result.emplace_back(std::move(waypoint));\n  }\n  return result;\n}", "CodeBleu_score": 59.25060389113299}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (const auto& waypoint : _parent->GetMap().GetPrevious(id_, distance)) {\n    result.emplace_back(std::move(waypoint));\n  }\n  return result;\n}", "CodeBleu_score": 56.20414390568298}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::unordered_set<std::string> added_signals;\n\n  for (auto &signal : _parent->GetMap().GetSignalsInDistance(_location, distance)) {\n    if (added_signals.count(signal->GetSignalId()) == 0u) {\n      result.emplace_back(new Landmark(signal));\n      added_signals.insert(signal->GetSignalId());\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 34.78813660742798}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n\n  // Retrieve all signals within distance.\n  std::vector<SharedPtr<Waypoint>> signals =\n      _parent->GetMap().GetSignalsInDistance(_position, distance);\n\n  // Check for repeated signals.\n  std::unordered_set<SharedPtr<Waypoint>> added_signals;\n  for (auto &signal : signals) {\n    if (added_signals.count(signal) == 0u) {\n      // Create a new landmark.\n      auto landmark = SharedPtr<Landmark>(new Landmark(signal));\n      result.emplace_back(landmark);\n      added_signals.insert(signal);\n    }\n  }\n\n  // Retrieve all traffic lights within distance.\n  std::vector<SharedPtr<Waypoint>> traffic_lights =\n      _parent->GetMap().GetTrafficLightsInDistance(_position, distance);\n\n  // Check for repeated traffic lights.\n  std::unordered_set<SharedPtr<Waypoint>> added_traffic_lights;\n  for (auto &traffic_light : traffic_lights) {\n    if (added_traffic_lights.count(traffic_light) == 0u) {\n      // Create a new landmark.\n      auto landmark = SharedPtr<Landmark>(new Landmark(traffic_light));\n      result.emplace_back(landmark);\n      added_traffic_lights.insert(traffic_light);\n    }\n  }\n\n  // Retrieve all junctions within distance.\n  std::vector<SharedPtr<Waypoint>> junctions =\n      _parent->GetMap().GetJunctionsInDistance(_position, distance);\n\n  // Check for repeated junctions.\n  std::unordered_set<SharedPtr<Waypoint>> added_junctions;\n  for (auto &junction : junctions) {\n    if (added_junctions.count(junction) == 0u) {\n      // Create a new landmark.\n      auto landmark = SharedPtr<Landmark>(new Landmark(junction));", "CodeBleu_score": 44.82141376821509}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n\n  std::unordered_set<SharedPtr<Signal>> added_signals;\n  std::vector<SharedPtr<Signal>> signals = GetMap().GetSignalsInDistance(\n      GetTransform().location, distance, stop_at_junction);\n  for (auto &signal : signals) {\n    if (added_signals.count(signal) == 0) {\n      SharedPtr<Waypoint> waypoint = GetMap().GetWaypoint(signal->GetTransform().location);\n      SharedPtr<Landmark> landmark =\n          SharedPtr<Landmark>(new Landmark(signal, waypoint));\n      result.emplace_back(landmark);\n      added_signals.insert(signal);\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 51.88584812227861}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  REQUIRE_CARLA_EPISODE();\n  using namespace std::chrono;\n  const auto end = steady_clock::now() + timeout.milliseconds;\n  const auto &current_settings = _episode.Lock()->GetEpisodeSettings();\n  const auto new_settings = settings.has_fixed_delta_seconds() ?\n      settings : current_settings;\n  const auto new_id = _episode.Lock()->SetEpisodeSettings(new_settings);\n  if (settings.has_fixed_delta_seconds()) {\n    const auto delta = new_settings.fixed_delta_seconds.get();\n    const auto current_delta = current_settings.has_fixed_delta_seconds() ?\n        current_settings.fixed_delta_seconds.get() : 0.0f;\n    if (abs(delta - current_delta) > std::numeric_limits<float>::epsilon()) {\n      const auto start = steady_clock::now();\n      auto current_snapshot = _episode.Lock()->GetSnapshot();\n      auto current_timestamp = current_snapshot.GetTimestamp();\n      auto new_snapshot = _episode.Lock()->GetSnapshot();\n      auto new_timestamp = new_snapshot.GetTimestamp();\n      auto attempts = 0u;\n      while (steady_clock::now() < end) {\n        if (++attempts % 100u == 0u) {\n          log_warning(\"failed to apply episode settings after\", attempts, \"attempts\");\n        }\n        if (current_timestamp != new_timestamp) {\n          current_snapshot = new_snapshot;\n          current_timestamp = new_timestamp;\n          new_snapshot = _episode.Lock()->GetSnapshot();\n          new_timestamp = new_snapshot.GetTimestamp();\n          if (new_timestamp != current_timestamp) {\n            break;\n          }\n        }\n      }\n      if (new_timestamp == current_timestamp) {\n        log_warning(\"failed to apply episode settings after\", attempts, \"attempts\");\n      }\n    }\n  }\n  return new_id;\n}", "CodeBleu_score": 49.70679340225939}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  REQUIRE_CARLA_EPISODE();\n  using namespace std::chrono;\n  const auto start = steady_clock::now();\n  const auto end = start + timeout;\n  uint64_t result = 0u;\n  auto current_snapshot = GetSnapshot();\n  while (steady_clock::now() < end) {\n    auto new_settings = settings;\n    if (settings.fixed_delta_seconds.has_value()) {\n      new_settings.fixed_delta_seconds = _episode.Lock()->VerifyFixedDeltaSeconds(\n          *settings.fixed_delta_seconds,\n          current_snapshot.GetTimestamp());\n    }\n    _episode.Lock()->SetEpisodeSettings(new_settings);\n    current_snapshot = GetSnapshot();\n    if (new_settings.fixed_delta_seconds.has_value()) {\n      if (abs(current_snapshot.GetTimestamp().delta_seconds - *new_settings.fixed_delta_seconds) <\n          std::numeric_limits<float>::epsilon()) {\n        result = current_snapshot.GetTimestamp().frame;\n        break;\n      }\n    } else {\n      result = current_snapshot.GetTimestamp().frame;\n      break;\n    }\n  }\n  if (result == 0u) {\n    log_warning(\"failed to apply settings after\", settings.fixed_delta_seconds.has_value() ? \"verifying fixed delta seconds\" : \"a number of attempts\");\n  }\n  return result;\n}", "CodeBleu_score": 51.66152621822996}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  REQUIRE_CARLA_EPISODE();\n  return _episode.Lock()->SetEpisodeSettings(settings, timeout);\n}", "CodeBleu_score": 12.260238063130666}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat lengthSquared = DistanceSquared2D(p1, p2);\n\tfloat length = std::sqrt(lengthSquared);\n\tif (length == 0.0f) {\n\t\treturn std::make_pair(0.0f, Distance2D(p1, point));\n\t}\n\tfloat t = Dot2D(point - p1, p2 - p1) / lengthSquared;\n\tt = Clamp(t, 0.0f, 1.0f);\n\tfloat projection = Lerp(t, p1, p2);\n\treturn std::make_pair(t * length, Distance2D(projection, point));\n}", "CodeBleu_score": 47.670397613287705}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    float segmentLengthSquared = DistanceSquared2D(p1, p2);\n    float segmentLength = std::sqrt(segmentLengthSquared);\n\n    if (segmentLengthSquared == 0.0f) {\n        float d1 = Distance2D(p1, point);\n        float d2 = Distance2D(p2, point);\n\n        if (d1 < d2) {\n            return std::make_pair(0.0f, d1);\n        } else {\n            return std::make_pair(segmentLength, d2);\n        }\n    }\n\n    float t = Dot2D(point - p1, p2 - p1) / segmentLengthSquared;\n    t = Clamp(t, 0.0f, 1.0f);\n\n    float projection = p1 + t * (p2 - p1);\n    float distance = Distance2D(projection, point);\n\n    return std::make_pair(t * segmentLength, distance);\n}", "CodeBleu_score": 46.88858676303854}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    float lengthSquared = DistanceSquared2D(segment.a, segment.b);\n    float length = std::sqrt(lengthSquared);\n    if (lengthSquared == 0.0f) {\n        float distanceA = Distance2D(point, segment.a);\n        float distanceB = Distance2D(point, segment.b);\n        if (distanceA < distanceB) {\n            return std::make_pair(0.0f, distanceA);\n        } else {\n            return std::make_pair(length, distanceB);\n        }\n    }\n\n    float t = Clamp((Dot2D(point, segment.b) - Dot2D(point, segment.a)) / lengthSquared, 0.0f, 1.0f);\n    Vector2 projection = segment.a + t * (segment.b - segment.a);\n    float distance = Distance2D(point, projection);\n    return std::make_pair(t * length, distance);\n}", "CodeBleu_score": 44.00766018554035}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tDEBUG_ASSERT(vertices.size() >= 3);\n\n\tsize_t initial_index = AddVertex(vertices[0]);\n\tfor (size_t i = 1; i < vertices.size() - 1; ++i) {\n\t\tAddIndex(initial_index);\n\t\tAddIndex(AddVertex(vertices[i]));\n\t\tAddIndex(AddVertex(vertices[i + 1]));\n\t}\n}", "CodeBleu_score": 59.10102333506475}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t \tDEBUG_ASSERT(vertices.size() >= 3);\n \tconst size_t initialIndex = AddVertices(vertices);\n \tfor (size_t i = 0; i < vertices.size() - 2; i++) {\n \t\tAddIndex(initialIndex);\n \t\tAddIndex(initialIndex + i + 1);\n \t\tAddIndex(initialIndex + i + 2);\n \t}\n }", "CodeBleu_score": 53.32892290483914}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tDEBUG_ASSERT(vertices.size() >= 3);\n\tconst size_t initialIndex = AddVertices(vertices);\n\tfor (size_t i = 1; i < vertices.size() - 1; ++i) {\n\t\tAddIndex(initialIndex);\n\t\tAddIndex(initialIndex + i);\n\t\tAddIndex(initialIndex + i + 1);\n\t}\n}", "CodeBleu_score": 52.74578818166498}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  DEBUG_ASSERT(message->size() <= carla::streaming::detail::tcp::Message::MAX_SIZE);\n  boost::asio::post(\n      _strand,\n      boost::asio::bind_executor(\n          _strand,\n          [self = shared_from_this(), message]() {\n            if (!self->_socket.is_open()) {\n              log_error(\"socket is not open\");\n              return;\n            }\n            self->_deadline.expires_from_now(boost::posix_time::seconds(30));\n            boost::asio::async_write(\n                self->_socket,\n                message->GetBufferSequence(),\n                boost::asio::bind_executor(\n                    self->_strand,\n                    [self, message](boost::system::error_code ec, size_t) {\n                      if (ec) {\n                        log_error(\"write: \" + ec.message());\n                        self->CloseNow();\n                      }\n                    }));\n          }));\n}", "CodeBleu_score": 49.997202643463524}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  boost::asio::post(\n      _strand,\n      boost::asio::bind_executor(\n          _strand,\n          [this, message]() {\n            if (!_socket.is_open()) {\n              log_error(\"cannot write message, socket is not open\");\n              return;\n            }\n            _deadline.expires_from_now(boost::posix_time::seconds(10));\n            boost::asio::async_write(\n                _socket,\n                message->GetBufferSequence(),\n                boost::asio::bind_executor(\n                    _strand,\n                    [this, weak = std::weak_ptr<Primary>(shared_from_this()), message](\n                        boost::system::error_code ec,\n                        size_t) {\n                      handle_sent(ec, message->size(), weak);\n                    }));\n          }));\n}", "CodeBleu_score": 43.87572735478986}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  DEBUG_ASSERT(message->size() <= 1024u);\n  boost::asio::post(\n      self->_strand,\n      boost::asio::bind_executor(\n          self->_strand,\n          [weak = self->weak_from_this(), message]() {\n            auto self = weak.lock();\n            if (!self) {\n              return;\n            }\n            if (!self->_socket.is_open()) {\n              log_error(\"socket is not open\");\n              return self->CloseNow();\n            }\n            self->_deadline.expires_from_now(boost::posix_time::seconds(10));\n            boost::asio::async_write(\n                self->_socket,\n                message->GetBufferSequence(),\n                boost::asio::bind_executor(\n                    self->_strand,\n                    [weak](boost::system::error_code ec, size_t) {\n                      auto self = weak.lock();\n                      if (!self) {\n                        return;\n                      }\n                      self->_deadline.cancel();\n                      if (ec) {\n                        log_error(\"write error: \" + ec.message());\n                        return self->CloseNow();\n                      }\n                    }));\n          }));\n}", "CodeBleu_score": 53.89914243607181}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n\n    if (!ec && _socket.is_open()) {\n        boost::system::error_code ignored_ec;\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n        _socket.close(ignored_ec);\n    }\n\n    _on_closed();\n\n    log_debug(\"Session closed\");\n}", "CodeBleu_score": 61.366364109360084}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n\n    if (!ec && _socket.is_open()) {\n        boost::system::error_code ignored_ec;\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n        _socket.close(ignored_ec);\n\n        _on_closed();\n\n        log_debug(\"session closed\");\n    }\n}", "CodeBleu_score": 61.46842827082315}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n\n    if (!ec && _socket.is_open()) {\n        boost::system::error_code ignored_ec;\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n        _socket.close(ignored_ec);\n    }\n\n    _on_closed(ec);\n\n    log_debug(\"session closed\");\n}", "CodeBleu_score": 60.994299084524805}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t    std::string msg = \"Are you alive?\";\n    auto buffer = std::make_shared<Buffer>(msg.c_str(), msg.size());\n    log_info(\"Sending message: \" + msg);\n    _router->WriteToNext(buffer, YOU_ALIVE);\n    auto fut = buffer->GetFuture();\n    log_info(\"Waiting for response...\");\n    fut.get();\n    log_info(\"Response received: \" + buffer->GetData());\n}", "CodeBleu_score": 50.522664814706296}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  std::string msg = \"Are you alive?\";\n  auto buffer = std::make_unique<Buffer>(msg.c_str(), msg.size());\n  log_info(\"Sending: \", msg);\n  _router->WriteToNext(std::move(buffer), YOU_ALIVE);\n  auto fut = _router->ReadFromNext();\n  auto response = fut.get();\n  log_info(\"Received: \", response.buffer.data);\n}", "CodeBleu_score": 58.416495759108614}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t  std::string message = \"Are you alive?\";\n  std::unique_ptr<Buffer> buffer = std::make_unique<Buffer>(message);\n  log_info(\"Sending message \\\"\" + message + \"\\\" to the system.\");\n  _router->WriteToNext(std::move(buffer), YOU_ALIVE);\n  log_info(\"Waiting for response from the system.\");\n  std::unique_ptr<Buffer> response = _router->ReadFromNext();\n  log_info(\"Response received from the system: \" + response->buffer.data);\n}", "CodeBleu_score": 50.71174656984986}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    bool found = false;\n    for (auto &server : _servers) {\n        if (server.second.second.find(sensor_id) != server.second.second.end()) {\n            found = true;\n            std::stringstream ss;\n            ss << \"ENABLE_ROS \" << sensor_id;\n            std::string message = ss.str();\n            std::vector<uint8_t> buffer(message.begin(), message.end());\n            auto fut = _router->WriteToOne(server.first, buffer.data(), buffer.size());\n            if (fut.get()) {\n                auto response = fut.get();\n                if (response.status == Status::OK) {\n                    // std::cout << \"Primary: Received response from \" << server.first << std::endl;\n                    if (response.buffer.size() > 0) {\n                        // std::cout << \"Primary: Response buffer size: \" << response.buffer.size() << std::endl;\n                        if (response.buffer.data()[0] == '1') {\n                            // std::cout << \"Primary: ROS enabled on \" << server.first << std::endl;\n                        } else {\n                            // std::cout << \"Primary: ROS not enabled on \" << server.first << std::endl;\n                        }\n                    } else {\n                        // std::cout << \"Primary: Response buffer size: \" << response.buffer.size() << std::endl;\n                    }\n                } else {\n                    // std::cout << \"Primary: Response status: \" << response.status << std::endl;\n                }\n            } else {\n                // std::cout << \"Primary: No response from \" << server.first << std::endl;\n            }\n        }\n    }\n    if (!found) {\n        log_error(\"Primary: Sensor ID \" << sensor_id << \" not found on any secondary server\");\n    }\n}", "CodeBleu_score": 49.745063512441554}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  std::unique_lock<std::mutex> lock(_mutex);\n  // Check if the sensor is already active on any server\n  bool sensor_found = false;\n  for (auto &server : _servers) {\n    if (server.second.active_sensors.find(sensor_id) != server.second.active_sensors.end()) {\n      sensor_found = true;\n      break;\n    }\n  }\n\n  if (!sensor_found) {\n    log_error(\"Sensor ID \" << sensor_id << \" not found on any secondary server\");\n    return;\n  }\n\n  // Create buffer\n  auto buffer = std::make_unique<Buffer>();\n  buffer->data = reinterpret_cast<uint8_t *>(&sensor_id);\n  buffer->size = sizeof(sensor_id);\n\n  // Send command to the server\n  auto fut = _router->WriteToOne(Command::ENABLE_ROS, std::move(buffer));\n  // Wait for response\n  auto response = fut.get();\n  if (response.status != Status::OK) {\n    log_error(\"Could not enable sensor \" << sensor_id << \" on secondary server\");\n    return;\n  }\n\n  // Process response\n  if (response.buffer.size() != sizeof(stream_id)) {\n    log_error(\"Unexpected response size\");\n    return;\n  }\n\n  stream_id response_sensor_id;\n  memcpy(&response_sensor_id, response.buffer.data, sizeof(response_sensor_id));\n  if (response_sensor_id != sensor_id) {\n    log_error(\"Unexpected sensor ID in response\");\n    return;\n  }\n\n  // Add sensor to active sensors\n  _active_sensors.insert(sensor_id);\n}", "CodeBleu_score": 52.29670473089401}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    // Check if the sensor is enabled on any secondary server\n    for (auto &server : _servers) {\n        if (server.second.second.find(sensor_id) != server.second.second.end()) {\n            // Create the buffer\n            uint8_t buffer[2];\n            buffer[0] = sensor_id;\n            buffer[1] = ENABLE_ROS;\n\n            // Send the command to the server\n            auto fut = _router->WriteToOne(server.first, buffer, 2);\n\n            // Wait for the response\n            if (fut.wait_for(std::chrono::milliseconds(100)) == std::future_status::ready) {\n                // Process the response\n                auto response = fut.get();\n                if (response.buffer.size() != 2 || response.buffer[0] != sensor_id || response.buffer[1] != ENABLE_ROS) {\n                    log_error(\"Invalid response for ENABLE_ROS command\");\n                }\n            } else {\n                log_error(\"No response for ENABLE_ROS command\");\n            }\n\n            return;\n        }\n    }\n\n    log_error(\"No sensor found for ENABLE_ROS command\");\n}", "CodeBleu_score": 47.20285724212944}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_debug(\"PrimaryCommands::GetToken: sensor_id \" << sensor_id << \" already active\");\n    return it->second;\n  }\n\n  log_debug(\"PrimaryCommands::GetToken: sensor_id \" << sensor_id << \" not active\");\n\n  // Get a new token from a secondary server.\n  token_type token = _router->GetNextServer()->SendGetToken(sensor_id);\n\n  // Update the maps.\n  _tokens[sensor_id] = token;\n  _sensor_ids[token.get_port()][token.get_stream_id()] = sensor_id;\n\n  log_debug(\"PrimaryCommands::GetToken: sensor_id \" << sensor_id << \" assigned token \" << token);\n\n  return token;\n}", "CodeBleu_score": 55.99502939035429}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // check if sensor is already activated\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    // sensor is already activated\n    log_debug(\"sensor \" << sensor_id << \" is already activated\");\n    return it->second;\n  }\n\n  // sensor is not activated\n  log_debug(\"sensor \" << sensor_id << \" is not activated\");\n  // get the next server\n  auto server = _router->GetNextServer();\n  // get a token from the server\n  auto token = SendGetToken(server, sensor_id);\n  // update the maps\n  _tokens[sensor_id] = token;\n  _servers[sensor_id] = server;\n  // log the action\n  log_debug(\"activated sensor \" << sensor_id << \" on server \" << token.get_port() << \":\" << token.get_stream_id());\n  // return the token\n  return token;\n}", "CodeBleu_score": 69.53694383106796}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  token_type token;\n  std::string sensor_name = _sensor_manager->GetSensorName(sensor_id);\n  std::string server_name = _sensor_manager->GetSensorServer(sensor_id);\n  std::string sensor_port = _sensor_manager->GetSensorPort(sensor_id);\n  std::string sensor_stream_id = _sensor_manager->GetSensorStreamId(sensor_id);\n  std::string sensor_ip = _sensor_manager->GetSensorIp(sensor_id);\n  std::string sensor_mac = _sensor_manager->GetSensorMac(sensor_id);\n  std::string sensor_type = _sensor_manager->GetSensorType(sensor_id);\n  std::string sensor_location = _sensor_manager->GetSensorLocation(sensor_id);\n  std::string sensor_description = _sensor_manager->GetSensorDescription(sensor_id);\n  std::string sensor_owner = _sensor_manager->GetSensorOwner(sensor_id);\n  std::string sensor_owner_email = _sensor_manager->GetSensorOwnerEmail(sensor_id);\n  std::string sensor_owner_phone = _sensor_manager->GetSensorOwnerPhone(sensor_id);\n  std::string sensor_owner_location = _sensor_manager->GetSensorOwnerLocation(sensor_id);\n  std::string sensor_owner_department = _sensor_manager->GetSensorOwnerDepartment(sensor_id);\n  std::string sensor_owner_position = _sensor_manager->GetSensorOwnerPosition(sensor_id);\n  std::string sensor_owner_description = _sensor_manager->GetSensorOwnerDescription(sensor_id);\n\n  if (_tokens.find(sensor_id) != _tokens.end()) {\n    token = _tokens[sensor_id];\n    log_debug(\"GetToken: sensor %s already activated, returning existing token\", sensor_name.c_str());\n  } else {\n    token = SendGetToken(sensor_id", "CodeBleu_score": 34.464245752492694}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f;\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n        return false;\n    }\n    std::vector<unsigned char> data;\n    f.seekg(0, std::ios::end);\n    data.resize(f.tellg());\n    f.seekg(0, std::ios::beg);\n    f.read(reinterpret_cast<char *>(data.data()), data.size());\n    f.close();\n    return Load(data);\n}", "CodeBleu_score": 62.84439065083445}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f(filename, std::ios::binary);\n    if (!f.is_open()) {\n        return false;\n    }\n    std::vector<char> buffer;\n    f.seekg(0, std::ios::end);\n    buffer.resize(f.tellg());\n    f.seekg(0, std::ios::beg);\n    f.read(buffer.data(), buffer.size());\n    f.close();\n    return Load(std::move(buffer));\n}", "CodeBleu_score": 61.386527082329614}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f(filename, std::ios::binary);\n    if (!f.is_open()) {\n        return false;\n    }\n    std::vector<char> buffer(std::istreambuf_iterator<char>(f), {});\n    return Load(buffer);\n}", "CodeBleu_score": 54.72887493468761}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\n  if (!_ready) {\n    return false;\n  }\n\n  // check if the agent is a pedestrian\n  auto it_w = _mapped_walkers_id.find(id);\n  if (it_w != _mapped_walkers_id.end()) {\n    // enter critical section\n    std::lock_guard<std::mutex> lock(_mutex);\n    // remove pedestrian from crowd\n    _crowd->removeAgent(it_w->second);\n    // remove pedestrian from walker manager\n    _walker_manager.RemoveWalker(it_w->second);\n    // remove pedestrian from walker mapping\n    _mapped_walkers_id.erase(it_w);\n    // remove pedestrian from index mapping\n    _mapped_by_index.erase(it_w->second);\n    return true;\n  }\n\n  // check if the agent is a vehicle\n  auto it_v = _mapped_vehicles_id.find(id);\n  if (it_v != _mapped_vehicles_id.end()) {\n    // enter critical section\n    std::lock_guard<std::mutex> lock(_mutex);\n    // remove vehicle from crowd\n    _crowd->removeAgent(it_v->second);\n    // remove vehicle from vehicle manager\n    _vehicle_manager.RemoveVehicle(it_v->second);\n    // remove vehicle from vehicle mapping\n    _mapped_vehicles_id.erase(it_v);\n    // remove vehicle from index mapping\n    _mapped_by_index.erase(it_v->second);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 68.42557400270415}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  if (!_ready) {\n    return false;\n  }\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  bool removed = false;\n  {\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    auto it_walker = _mapped_walkers_id.find(id);\n    if (it_walker != _mapped_walkers_id.end()) {\n      auto index = it_walker->second;\n      _crowd->removeAgent(index);\n      _walker_manager.RemoveWalker(index);\n      _mapped_by_index.erase(index);\n      _mapped_walkers_id.erase(it_walker);\n      removed = true;\n    } else {\n      auto it_vehicle = _mapped_vehicles_id.find(id);\n      if (it_vehicle != _mapped_vehicles_id.end()) {\n        auto index = it_vehicle->second;\n        _crowd->removeAgent(index);\n        _vehicle_manager.RemoveVehicle(index);\n        _mapped_by_index.erase(index);\n        _mapped_vehicles_id.erase(it_vehicle);\n        removed = true;\n      }\n    }\n  }\n\n  return removed;\n}", "CodeBleu_score": 61.813866070869004}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  auto it_walker = _mapped_walkers_id.find(id);\n  if (it_walker != _mapped_walkers_id.end()) {\n    auto index = it_walker->second;\n    auto* agent = _crowd->getAgent(index);\n    if (agent != nullptr) {\n      _crowd->removeAgent(agent);\n    }\n    _walker_manager.RemoveWalker(id);\n    _mapped_by_index.erase(index);\n    _mapped_walkers_id.erase(it_walker);\n    return true;\n  }\n\n  auto it_vehicle = _mapped_vehicles_id.find(id);\n  if (it_vehicle != _mapped_vehicles_id.end()) {\n    auto index = it_vehicle->second;\n    auto* agent = _crowd->getAgent(index);\n    if (agent != nullptr) {\n      _crowd->removeAgent(agent);\n    }\n    _vehicle_manager.RemoveVehicle(id);\n    _mapped_by_index.erase(index);\n    _mapped_vehicles_id.erase(it_vehicle);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 65.3534566079401}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t  std::set<int> current_ids;\n  for (auto &v : vehicles) {\n    current_ids.insert(v.id);\n    AddOrUpdateVehicle(v);\n  }\n  for (auto &v : vehicles_) {\n    if (current_ids.find(v.first) == current_ids.end()) {\n      RemoveAgent(v.first);\n    }\n  }\n  return true;\n}", "CodeBleu_score": 57.664740462286005}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::set<int> ids;\n\tfor (auto v : vehicles) {\n\t\tids.insert(v.id);\n\t\tAddOrUpdateVehicle(v);\n\t}\n\tfor (auto v : this->vehicles) {\n\t\tif (ids.find(v.second.id) == ids.end()) {\n\t\t\tRemoveAgent(v.first);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 51.32752959637132}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t  // TODO: Implement this function\n  std::set<int> updated;\n  for (auto vehicle : vehicles) {\n    updated.insert(vehicle.id);\n    AddOrUpdateVehicle(vehicle);\n  }\n  for (auto vehicle : this->vehicles) {\n    if (updated.find(vehicle.first) == updated.end()) {\n      RemoveAgent(vehicle.first);\n    }\n  }\n  return true;\n}", "CodeBleu_score": 58.32726001375066}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto it = _mapped_walkers_id.find(id);\n  if (it == _mapped_walkers_id.end()) {\n    it = _mapped_vehicles_id.find(id);\n    if (it == _mapped_vehicles_id.end()) {\n      return false;\n    }\n  }\n  const Actor *actor = it->second;\n  const float distance_squared = distance * distance;\n  const auto location = actor->GetLocation();\n  const auto heading = actor->GetTransform().rotation.GetForwardVector();\n  const auto dot = heading.x * direction.x + heading.y * direction.y + heading.z * direction.z;\n  const auto cosine = std::abs(dot);\n  if (cosine < std::cos(1.0f) || dot < 0.0f) {\n    return false;\n  }\n  const auto squared_distance = location.DistanceSquared(direction);\n  if (squared_distance > distance_squared) {\n    return false;\n  }\n  return _crowd->HasVehicleNear(location, squared_distance);\n}", "CodeBleu_score": 66.49498535658192}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n  // Check if the actor is a walker\n  auto it_walker = _mapped_walkers_id.find(id);\n  if (it_walker != _mapped_walkers_id.end()) {\n\n    // Enter a critical section\n    _critical_section.lock();\n\n    // Compute the squared distance\n    float distance_squared = distance * distance;\n\n    // Check if there is a vehicle near the walker\n    bool result = _crowd->hasVehicleNear(it_walker->second, distance_squared, direction);\n\n    // Leave the critical section\n    _critical_section.unlock();\n\n    return result;\n  }\n\n  // Check if the actor is a vehicle\n  auto it_vehicle = _mapped_vehicles_id.find(id);\n  if (it_vehicle != _mapped_vehicles_id.end()) {\n\n    // Enter a critical section\n    _critical_section.lock();\n\n    // Compute the squared distance\n    float distance_squared = distance * distance;\n\n    // Check if there is a vehicle near the vehicle\n    bool result = _crowd->hasVehicleNear(it_vehicle->second, distance_squared, direction);\n\n    // Leave the critical section\n    _critical_section.unlock();\n\n    return result;\n  }\n\n  return false;\n}", "CodeBleu_score": 51.40390037721843}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t    // Find the actor in the mapped walkers and vehicles.\n    auto it = _mapped_walkers_id.find(id);\n    if (it != _mapped_walkers_id.end()) {\n        // Enter a critical section.\n        _mutex.lock();\n        // Compute the squared distance.\n        float squared_distance = distance * distance;\n        // Use the crowd system to determine if a vehicle is nearby.\n        bool result = _crowd->hasVehicleNear(it->second, squared_distance, direction.x, direction.y, direction.z);\n        // Leave the critical section.\n        _mutex.unlock();\n        // Return the result.\n        return result;\n    }\n    // Return false if the actor was not found.\n    return false;\n}", "CodeBleu_score": 57.81367093422259}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    // Get the current route point\n    RoutePoint *point = info.GetRoutePoint();\n    // Create a WalkerEventVisitor with the current context\n    WalkerEventVisitor visitor(this, id, info, point, delta);\n    // Process the event at the current route point\n    return boost::variant2::visit(visitor, info.GetEvent());\n}", "CodeBleu_score": 59.55842318952945}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t    RoutePoint rp = GetCurrentRoutePoint(info);\n    WalkerEventVisitor visitor(id, info, delta);\n    EventResult result = boost::variant2::visit(visitor, rp.event);\n    return result;\n}", "CodeBleu_score": 50.97192752990773}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tRoutePoint &rp = info.route.at(info.current_route_point);\n\tWalkerEventVisitor visitor(this, id, info, delta);\n\treturn boost::variant2::visit(visitor, rp.event);\n}", "CodeBleu_score": 71.3281508284444}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const uint32_t road_id = road_node.attribute(\"id\").as_uint();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      const double s = lane_section_node.attribute(\"s\").as_double();\n      ParseLanes(lane_section_node, s, road_id, map_builder);\n    }\n  }\n}", "CodeBleu_score": 36.83586943216382}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const auto road_id = road_node.attribute(\"id\").as_uint();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n      const auto s = lane_section_node.attribute(\"s\").as_double();\n      ParseLanes(lane_section_node, s, map_builder);\n    }\n  }\n}", "CodeBleu_score": 32.8407990084387}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const uint32_t road_id =\n        road_node.attribute(\"id\").as_uint(std::numeric_limits<uint32_t>::max());\n    for (pugi::xml_node lane_section_node :\n         road_node.child(\"lanes\").children(\"laneSection\")) {\n      const double s =\n          lane_section_node.attribute(\"s\").as_double(std::numeric_limits<double>::max());\n      ParseLanes(s, lane_section_node, map_builder);\n    }\n  }\n}", "CodeBleu_score": 34.310537456862356}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    std::lock_guard<std::mutex> lock(m_mutex);\n    if (info.current_count_change == 1) {\n        if (info.total_count == 1) {\n            m_first_connected = true;\n            m_connected = true;\n            std::cout << \"First connection to \" << writer->get_topic().name() << \" established\" << std::endl;\n        } else {\n            std::cout << \"Connection to \" << writer->get_topic().name() << \" established\" << std::endl;\n        }\n    } else if (info.current_count_change == -1) {\n        if (info.total_count == 0) {\n            m_first_connected = false;\n            m_connected = false;\n            std::cout << \"Last connection to \" << writer->get_topic().name() << \" lost\" << std::endl;\n        } else {\n            std::cout << \"Connection to \" << writer->get_topic().name() << \" lost\" << std::endl;\n        }\n    } else {\n        std::cerr << \"Invalid change in publication matched status received: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 53.94733879695763}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        std::cout << \"Matched.\" << std::endl;\n        publication_matched_ = true;\n        ++publication_matched_count_;\n        if (publication_matched_count_ == 1) {\n            std::cout << \"First connection.\" << std::endl;\n        }\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Unmatched.\" << std::endl;\n        --publication_matched_count_;\n    } else {\n        std::cout << \"Invalid PublicationMatchedStatus current count change \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 55.65245366822865}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        if (info.total_count_change == 1) {\n            matched_ = true;\n            first_connected_ = true;\n            std::cout << \"Publication matched\" << std::endl;\n        }\n        else if (info.total_count_change == 0) {\n            std::cout << \"Publication matched reoccurred\" << std::endl;\n        }\n        else {\n            std::cout << \"Invalid publication matched current count change \" << info.current_count_change << \" total count change \" << info.total_count_change << std::endl;\n        }\n    }\n    else if (info.current_count_change == -1) {\n        if (info.total_count_change == -1) {\n            matched_ = false;\n            std::cout << \"Publication unmatched\" << std::endl;\n        }\n        else if (info.total_count_change == 0) {\n            std::cout << \"Publication unmatched reoccurred\" << std::endl;\n        }\n        else {\n            std::cout << \"Invalid publication unmatched current count change \" << info.current_count_change << \" total count change \" << info.total_count_change << std::endl;\n        }\n    }\n    else {\n        std::cout << \"Invalid publication matched current count change \" << info.current_count_change << \" total count change \" << info.total_count_change << std::endl;\n    }\n}", "CodeBleu_score": 55.1087421772977}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        _matched_count++;\n        if (_matched_count == 1) {\n            _first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        _matched_count--;\n        if (_matched_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::cerr << \"Invalid matched count change\" << std::endl;\n    }\n}", "CodeBleu_score": 64.38687514149957}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        if (info.total_count == 1) {\n            _owner->first_connected = true;\n        }\n        _owner->matched_count++;\n    } else if (info.current_count_change == -1) {\n        _owner->matched_count--;\n        if (_owner->matched_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        // Invalid count change\n        std::cerr << \"Invalid subscription change count received\" << std::endl;\n    }\n}", "CodeBleu_score": 62.86271887519567}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        _matched_count++;\n        if (_matched_count == 1) {\n            _first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        _matched_count--;\n        if (_matched_count == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::stringstream ss;\n        ss << \"Invalid matched count received: \" << info.current_count_change;\n        _owner->Log(ss.str());\n    }\n}", "CodeBleu_score": 63.14646697200016}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if(!key_fields_)\n        return false;\n    if(data == NULL)\n        return false;\n    if(handle == NULL)\n        return false;\n    if(handle->isDefined())\n        return false;\n    if(force_md5) {\n        m_md5.init();\n        size_t key_size = getKeyMaxCdrSerializedSize(data,key_fields_);\n        unsigned char* key_buffer = (unsigned char*)malloc(key_size);\n        if(key_buffer == NULL)\n            return false;\n        FastBuffer cdrbuffer(reinterpret_cast<char*>(key_buffer),key_size);\n        Cdr cdr_ser(cdrbuffer);\n        cdr_ser.serializeKey(static_cast<CarlaCollisionEvent*>(data),key_fields_);\n        m_md5.update(key_buffer,static_cast<unsigned int>(key_size));\n        m_md5.finalize();\n        memcpy(handle->value,m_md5.digest,16);\n        handle->isDefined_ = true;\n        free(key_buffer);\n        return true;\n    }\n    else {\n        size_t key_size = getKeyMaxCdrSerializedSize(data,key_fields_);\n        unsigned char* key_buffer = (unsigned char*)malloc(key_size);\n        if(key_buffer == NULL)\n            return false;\n        memset(key_buffer,0,key_size);\n        FastBuffer cdrbuffer(reinterpret_cast<char*>(key_buffer),key_size);\n        Cdr cdr_ser(cdrbuffer);\n        cdr_ser.serializeKey(static_cast<CarlaCollisionEvent*>(data),key_fields_);\n        memcpy(handle->value,key_buffer,key_size);\n        handle->isDefined_ = true;\n        free(key_buffer);\n        return true;\n    }\n}", "CodeBleu_score": 39.20159390842939}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if(!key_defined_)\n        return false;\n    if(data == NULL || handle == NULL)\n        return false;\n    // Serializing the instance\n    SerializedPayload_t payload(getKeyMaxCdrSerializedSize(data, ROSIDL_TYPESUPPORT_OPENSPLICE_CPP_PUBLIC_carla_msgs));\n    if (!serializeKey(data, &payload, ROSIDL_TYPESUPPORT_OPENSPLICE_CPP_PUBLIC_carla_msgs)) {\n        return false;\n    }\n    if(force_md5 || payload.length > 16) {\n        // Hashing the payload\n        m_md5.init();\n        m_md5.update(payload.data, payload.length);\n        m_md5.finalize();\n        for(uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for(uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = '0';\n        }\n        for(uint8_t i = 0; i < payload.length; ++i) {\n            handle->value[i] = payload.data[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 50.55597235849331}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if(!m_isGetKeyDefined)\n        return false; //No key has been defined\n    if(data == NULL || handle == NULL)\n        return false; //No instance to take the key from or no handle to store the key\n    CarlaCollisionEvent* typedInstance = static_cast<CarlaCollisionEvent*>(data);\n    if(!typedInstance->isKeyDefined())\n        return false; //No key has been defined\n    if(m_keyBuffer != NULL && !force_md5) { //No need to compute the MD5\n        *handle = *static_cast<InstanceHandle_t*>(m_keyBuffer);\n        return true;\n    }\n    MD5 m_md5;\n    unsigned char* keyBuffer = NULL;\n    try {\n        keyBuffer = new unsigned char[getKeyMaxCdrSerializedSize()];\n    } catch(std::bad_alloc& ba) {\n        return false;\n    }\n    m_md5.init();\n    if(m_keyBuffer != NULL) {\n        if(m_is_cdr_deserializer) {\n            deserializeKey(m_cdrDeserializer, m_keyBuffer);\n        } else {\n            m_type->serializeKey(m_keyBuffer, m_keyBuffer);\n        }\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(getKeyMaxCdrSerializedSize()));\n    } else {\n        if(m_is_cdr_deserializer) {\n            deserializeKey(m_cdrDeserializer, keyBuffer);\n        } else {\n            m_type->serializeKey(keyBuffer, data);\n        }\n        m_md5.update(keyBuffer, static_cast<unsigned int>(getKeyMaxCdrSerializedSize()));\n    }\n    m_md5.finalize();\n    memcpy(handle->value, m_md5.digest, 16);\n    handle->isDefined(true);\n    if(m_keyBuffer != NULL) {\n        delete[] keyBuffer;\n    }\n    return true;\n}", "CodeBleu_score": 43.32691153443263}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    // Object that manages a buffer to store serialized data.\n    FastBuffer buffer;\n    // Object that serializes the data.\n    Cdr cdr_ser(buffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    // Object that manages the serialization.\n    CarlaEgoVehicleControlPubSubType::CarlaEgoVehicleControlType* p_type =\n            static_cast<CarlaEgoVehicleControlPubSubType::CarlaEgoVehicleControlType*>(data);\n    // Serialize encapsulation\n    cdr_ser.serialize_encapsulation();\n    // Serialize the object.\n    p_type->serialize(cdr_ser);\n    // Get serialized length\n    payload->length = static_cast<uint32_t>(cdr_ser.getSerializedDataLength());\n    // Allocate memory for the serialized data.\n    payload->data = reinterpret_cast<unsigned char*>(malloc(payload->length));\n    // Copy the serialized data to the payload.\n    memcpy(payload->data, buffer.getBufferPointer(), payload->length);\n    return true;\n}", "CodeBleu_score": 54.51381650671713}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    // Object that manages a buffer that can be dynamically resized.\n    // It is always RTPS aligned.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, ser.endianness()); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        CarlaEgoVehicleControl *p_type = static_cast<CarlaEgoVehicleControl*>(data); // Deserialized data\n        p_type->serialize(ser); // Serialize the object:\n        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); // Get the serialized length\n        return true;\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n}", "CodeBleu_score": 77.0459889969431}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    // Object that manages a buffer of bytes to store the serialized data.\n    FastBuffer fastbuffer;\n    // Object that serializes the data.\n    Cdr cdr_ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n\n    // Object that represents the serialized data.\n    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    // Serialize encapsulation\n    cdr_ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(cdr_ser);\n\n        // Get the serialized length\n        payload->length = static_cast<uint32_t>(cdr_ser.getSerializedDataLength());\n        payload->encapsulation = cdr_ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n\n        // Allocate memory and serialize the object.\n        payload->data = reinterpret_cast<unsigned char*>(malloc(payload->length));\n        memcpy(payload->data, fastbuffer.getBuffer(), payload->length);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 70.36278267715201}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (tracker.g.sysid_target.get() != 0) {\n\t\treturn;\n\t}\n\n\tmavlink_heartbeat_t heartbeat;\n\tmavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n\tif (heartbeat.type != MAV_TYPE_GCS) {\n\t\treturn;\n\t}\n\n\ttracker.g.sysid_target.set(heartbeat.sysid);\n\n\ttracker.gcs().request_datastream_position(tracker.g.sysid_target.get());\n\ttracker.gcs().request_datastream_airpressure(tracker.g.sysid_target.get());\n\n\ttracker.g.target_set.set(true);\n}", "CodeBleu_score": 45.73383035056559}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// check if the target has been set\n\tif (tracker.g.sysid_target.get() != 0) {\n\t\treturn;\n\t}\n\n\t// decode the message\n\tmavlink_heartbeat_t heartbeat;\n\tmavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n\t// check if the message is one that should be tracked\n\tif (heartbeat.type != MAV_TYPE_GCS) {\n\t\treturn;\n\t}\n\n\t// set the target system ID\n\ttracker.g.sysid_target.set(msg.sysid);\n\n\t// request position and air pressure data streams from the target\n\ttracker.gcs().request_datastream_position();\n\ttracker.gcs().request_datastream_airpressure();\n\n\t// flag that the target has been set\n\ttracker.g.target_set.set(true);\n}", "CodeBleu_score": 42.67949189370776}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (tracker.g.sysid_target != 0) {\n        // already tracking a target\n        return;\n    }\n    if (msg.msgid != MAVLINK_MSG_ID_HEARTBEAT) {\n        // not a message we should track\n        return;\n    }\n    mavlink_heartbeat_t hb;\n    mavlink_msg_heartbeat_decode(&msg, &hb);\n    if (hb.type == MAV_TYPE_GCS || hb.type == MAV_TYPE_ONBOARD_CONTROLLER) {\n        // don't track GCS or Onboard Controller\n        return;\n    }\n    tracker.g.sysid_target = hb.sysid;\n    tracker.gcs().request_datastream_position(hb.sysid, hb.compid, true);\n    tracker.gcs().request_datastream_airpressure(hb.sysid, hb.compid, true);\n    tracker.g.tracking_target = true;\n}", "CodeBleu_score": 55.802837513496314}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _calibrating_baro = true;\n    }\n    return result;\n}", "CodeBleu_score": 67.61492876133258}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    if (vehicle->barometer != NULL) {\n        result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n        if (result == MAV_RESULT_ACCEPTED) {\n            vehicle->barometer->set_calibration_needed();\n        }\n    }\n    return result;\n}", "CodeBleu_score": 57.36063065148442}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = MAV_RESULT_DENIED;\n\n    // let the base class handle the message first\n    result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n    if (result == MAV_RESULT_ACCEPTED) {\n        // if the base class accepted the command, we need to do the altitude calibration\n        _altitude_calibration_required = true;\n    }\n\n    return result;\n}", "CodeBleu_score": 64.51155265733422}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    if (packet.param1 == 1.0) {\n        tracker.arm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    } else if (is_zero(packet.param1)) {\n        tracker.disarm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    }\n    return result;\n}", "CodeBleu_score": 68.1855569502565}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    if (is_equal(packet.param1, 1.0)) {\n        tracker.arm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    } else if (is_zero(packet.param1)) {\n        tracker.disarm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    }\n\n    return result;\n}", "CodeBleu_score": 70.87141699306281}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    if (is_equal(packet.param1, 1.0)) {\n        tracker.arm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    } else if (is_zero(packet.param1)) {\n        tracker.disarm_servos();\n        result = MAV_RESULT_ACCEPTED;\n    }\n    return result;\n}", "CodeBleu_score": 70.87141699306281}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i = 0; i < num_gcs; i++) {\n        if (gcs[i].sysid == sysid && gcs[i].compid == compid) {\n            gcs[i].request_datastream_position(10);\n            return;\n        }\n    }\n}", "CodeBleu_score": 34.940803687950186}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i = 0; i < num_gcs; i++) {\n        if (gcs[i].sysid == sysid && gcs[i].compid == compid) {\n            if (HAVE_PAYLOAD_SPACE(gcs[i], MAVLINK_MSG_ID_HIGHRES_IMU, MAVLINK_MSG_ID_HIGHRES_IMU_LEN)) {\n                mavlink_msg_request_data_stream_send(gcs[i].chan,\n                                                     gcs[i].sysid,\n                                                     gcs[i].compid,\n                                                     MAV_DATA_STREAM_POSITION,\n                                                     MAV_DATA_STREAM_POSITION_RATE,\n                                                     1);\n                gcs[i].flags.data_stream_position = true;\n                return;\n            }\n        }\n    }\n}", "CodeBleu_score": 47.4770696051771}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    uint8_t i;\n    uint8_t num_gcs = 0;\n    bool HAVE_PAYLOAD_SPACE = false;\n    for (i = 0; i < MAX_GCS_CHANNELS; i++) {\n        if (gcs_chan[i].sysid == 0 && gcs_chan[i].compid == 0) {\n            num_gcs++;\n            if (gcs_chan[i].payload_space > 0) {\n                HAVE_PAYLOAD_SPACE = true;\n            }\n        }\n    }\n    if (HAVE_PAYLOAD_SPACE) {\n        for (i = 0; i < MAX_GCS_CHANNELS; i++) {\n            if (gcs_chan[i].sysid == 0 && gcs_chan[i].compid == 0) {\n                gcs_chan[i].sysid = sysid;\n                gcs_chan[i].compid = compid;\n                gcs_chan[i].request_stream_time = millis();\n                gcs_chan[i].request_stream_seq = gcs_chan[i].request_stream_seq + 1;\n                mavlink_msg_request_data_stream_send(gcs_chan[i].chan, gcs_chan[i].sysid, gcs_chan[i].compid, gcs_chan[i].request_stream_seq, MAV_DATA_STREAM_POSITION, 10, 1);\n                gcs_chan[i].payload_space = gcs_chan[i].payload_space - 1;\n                break;\n            }\n        }\n    }\n}", "CodeBleu_score": 45.25496141084905}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    AP_AHRS* ahrs = AP_AHRS::get_instance();\n    if (is_zero(ahrs->cos_pitch())) {\n        return false;\n    }\n    ef_pitch = atan2f(ahrs->sin_roll() * sinf(pitch) + ahrs->cos_roll() * cosf(pitch) * sinf(yaw),\n                      ahrs->cos_roll() * cosf(pitch) - ahrs->sin_roll() * sinf(pitch) * sinf(yaw));\n    ef_yaw = atan2f(ahrs->sin_roll() * cosf(pitch) * sinf(yaw) - ahrs->cos_roll() * sinf(pitch),\n                    ahrs->cos_roll() * cosf(pitch) + ahrs->sin_roll() * sinf(pitch) * sinf(yaw));\n    return true;\n}", "CodeBleu_score": 57.79903102614101}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    AP::ahrs.update();\n    if (is_zero(AP::ahrs.cos_pitch)) {\n        return false;\n    }\n    ef_pitch = atan2f(-AP::ahrs.sin_roll * cosf(pitch) + AP::ahrs.cos_roll * sinf(pitch), AP::ahrs.cos_pitch);\n    ef_yaw = atan2f(sinf(yaw) * AP::ahrs.cos_roll, AP::ahrs.cos_pitch * cosf(yaw) - AP::ahrs.sin_roll * sinf(yaw));\n    return true;\n}", "CodeBleu_score": 53.99765016809411}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    AP_AHRS& ahrs = AP_AHRS::get_instance();\n    if (is_zero(ahrs.cos_pitch)) {\n        return false;\n    }\n    ef_pitch = atan2(-ahrs.sin_roll*sin(pitch) + ahrs.cos_roll*sin(yaw),\n                     cos(pitch));\n    ef_yaw = atan2(ahrs.sin_roll*cos(pitch) + ahrs.cos_roll*sin(yaw),\n                   ahrs.cos_roll*cos(pitch) - ahrs.sin_roll*sin(yaw));\n    return true;\n}", "CodeBleu_score": 56.28914997482871}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t  // Get the yaw and pitch from the navigation system\n  tracker.update_yaw_servo();\n  tracker.update_pitch_servo();\n\n  // Get the direction of the yaw servo\n  int8_t yaw_direction = get_ef_yaw_direction();\n\n  // Convert the yaw and pitch from earth frame to body frame\n  float bf_yaw = convert_ef_to_bf(tracker.get_yaw_servo_angle(), yaw_direction);\n  float bf_pitch = convert_ef_to_bf(tracker.get_pitch_servo_angle(), tracker.get_pitch_servo_direction());\n\n  // Get the angle error\n  float angle_error = calc_angle_error(bf_yaw, bf_pitch);\n\n  // If the angle error is greater than the max angle error, set the target yaw and pitch to the current yaw and pitch\n  if (angle_error > tracker.get_max_angle_error()) {\n    tracker.set_target_yaw(tracker.get_yaw_servo_angle());\n    tracker.set_target_pitch(tracker.get_pitch_servo_angle());\n  }\n\n  // If the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n  if (tracker.get_target_distance() >= 0 || tracker.get_min_distance() == 0) {\n    tracker.update_pitch_servo();\n    tracker.update_yaw_servo();\n  }\n}", "CodeBleu_score": 32.00636475042266}, {"code": "void Mode::update_auto(void){\n\t  // If the target is valid, update the yaw and pitch\n  if (tracker.target_valid) {\n    // Update the yaw servo\n    tracker.update_yaw_servo();\n\n    // Update the pitch servo\n    tracker.update_pitch_servo();\n\n    // If the target distance is valid or no minimum distance is set, update the servos\n    if (tracker.target_distance_valid || !tracker.min_distance_set) {\n      // Update the yaw servo\n      tracker.update_yaw_servo();\n\n      // Update the pitch servo\n      tracker.update_pitch_servo();\n    }\n  }\n}", "CodeBleu_score": 13.35256701788595}, {"code": "void Mode::update_auto(void){\n\t  // Update yaw and pitch based on navigation status\n  tracker.update_yaw_servo(nav.get_yaw_cd());\n  tracker.update_pitch_servo(nav.get_pitch_cd());\n\n  // Get the direction of the yaw error\n  tracker.yaw_direction = get_ef_yaw_direction();\n\n  // Convert the yaw and pitch error from earth frame to body frame\n  convert_ef_to_bf();\n\n  // Constrain the yaw and pitch error\n  tracker.yaw_error_cd = constrain_float(tracker.yaw_error_cd, -18000, 18000);\n  tracker.pitch_error_cd = constrain_float(tracker.pitch_error_cd, -9000, 9000);\n\n  // Calculate the angle error\n  tracker.angle_error_cd = calc_angle_error();\n\n  // Update the servos if the target distance is valid or no minimum distance is set\n  if (nav.is_valid_target_distance() || tracker.minimum_distance_cm == 0) {\n    tracker.update_pitch_servo(tracker.pitch_error_cd);\n    tracker.update_yaw_servo(tracker.yaw_error_cd);\n  }\n}", "CodeBleu_score": 25.886434101294746}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t    gps.update();\n    if (gps.last_message_time_ms() != last_message_time_ms) {\n        last_message_time_ms = gps.last_message_time_ms();\n        if (gps.status() >= 3) {\n            if (gps.location().is_valid()) {\n                if (ground_start_countdown > 0) {\n                    ground_start_countdown--;\n                }\n            } else {\n                ground_start_countdown = 5;\n            }\n        }\n    }\n    if (ground_start_countdown == 1) {\n        if (gps.location().is_valid()) {\n            set_home(gps.location());\n            ground_start_countdown = 0;\n        }\n    }\n}", "CodeBleu_score": 54.60353400696935}, {"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time_ms() != last_gps_update) {\n\t\tlast_gps_update = gps.last_message_time_ms();\n\t\tif (gps.status() >= 3) {\n\t\t\tif (gps.location().lat() != 0 && gps.location().lng() != 0) {\n\t\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\t\tset_home(gps.location());\n\t\t\t\t\tground_start_countdown = 100;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tground_start_countdown = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (ground_start_countdown > 0) {\n\t\tground_start_countdown--;\n\t}\n}", "CodeBleu_score": 44.127090282951784}, {"code": "void Tracker::update_GPS(void){\n\t  if (gps.status() >= 3) {\n    if (gps.last_message_time_ms() != gps_last_message_time_ms) {\n      gps_last_message_time_ms = gps.last_message_time_ms();\n      if (gps.location.isValid()) {\n        if (gps_countdown == 0) {\n          set_home(gps.location.lat(), gps.location.lng());\n          gps_countdown = GPS_COUNTDOWN;\n        }\n        else {\n          gps_countdown--;\n        }\n      }\n      else {\n        gps_countdown = GPS_COUNTDOWN;\n      }\n    }\n  }\n}", "CodeBleu_score": 44.48636861762297}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch > 15) {\n        SRV_Channels::set_output_scaled(SRV_Channel_Pitch_OnOff, 1);\n    } else if (pitch < -15) {\n        SRV_Channels::set_output_scaled(SRV_Channel_Pitch_OnOff, -1);\n    } else {\n        SRV_Channels::set_output_scaled(SRV_Channel_Pitch_OnOff, 0);\n    }\n}", "CodeBleu_score": 23.19176825402627}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t  // if (pitch > 10) {\n  //   pitch = 10;\n  // }\n  // if (pitch < -10) {\n  //   pitch = -10;\n  // }\n  // if (pitch < 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch > 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch > 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch < 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch > 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch < 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch > 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch < 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch > 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch < 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch > 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch < 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch > 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch < 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch > 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch < 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch > 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch < 0) {\n  //   pitch = 0;\n  // }\n  // if (pitch > ", "CodeBleu_score": 4.619414654308792}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if(pitch > 0) {\n        pitch_onoff_servo.write(pitch_onoff_servo_on);\n    } else {\n        pitch_onoff_servo.write(pitch_onoff_servo_off);\n    }\n}", "CodeBleu_score": 14.056880272999416}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (!(arming_checks_enabled & ARMING_CHECK_BARO)) {\n        return true;\n    }\n\n    if (!ahrs.barometer_init_flag) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, \"Baro not initialised\");\n        }\n        return false;\n    }\n\n    // check baro reference\n    if (!ahrs.get_barometer().get_reference()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, \"Baro ref not set\");\n        }\n        return false;\n    }\n\n    // check altitude\n    float baro_alt = ahrs.get_barometer().get_altitude();\n    float inav_alt = copter.inertial_nav.get_position_z_up_cm() / 100.0f;\n    if (fabsf(baro_alt - inav_alt) > 2.0f) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, \"Baro alt diff\");\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 52.808250111009826}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call base class function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro\n    if (arming_checks_enabled(ARMING_CHECK_BARO)) {\n        if (barometer.get_state() != AP_Baro::BARO_STATE_STABILIZED) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro not stable\"));\n            }\n            return false;\n        }\n        if (fabsf(barometer.get_altitude() - inertial_nav.get_position_z_up_cm()/100.0f) > 500.0f) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro alt differs too much\"));\n            }\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 48.76086145956352}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\n    // call base class barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // exit immediately if not enabled\n    if (!_arming_checks.get(ARMING_CHECK_BARO)) {\n        return true;\n    }\n\n    // check baro reference\n    if (!_baro.get_reference()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro ref not set\"));\n        }\n        return false;\n    }\n\n    // check baro altitude\n    float baro_alt = _baro.get_altitude();\n    float inav_alt = _ahrs.get_altitude();\n    if (fabsf(baro_alt - inav_alt) > _arming.baro_alt_max_cm) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_WARNING,PSTR(\"Baro alt error %d\"), (int)(baro_alt - inav_alt));\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 50.84752987104431}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == AP_WPNav::TERRAIN_SOURCE_RF) {\n        return false;\n    }\n    if (copter.wp_nav->get_terrain_source() == AP_WPNav::TERRAIN_SOURCE_TERRAINDB &&\n        copter.mode_rtl.get_alt_type() == AP_RTL::RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 76.80277411910875}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (_copter.wp_nav->get_terrain_source() == AP_Waypoint_Navigator::TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    if (_copter.wp_nav->get_terrain_source() == AP_Waypoint_Navigator::TERRAIN_SOURCE_TERRAINDB &&\n        _copter.mode_rtl.get_alt_type() == AP_RTL::RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 72.43597905013773}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == Terrain::RangeFinder) {\n        return false;\n    }\n    if (copter.wp_nav->get_terrain_source() == Terrain::TerrainDatabase &&\n        copter.mode_rtl.get_alt_type() == RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 74.64155795177247}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    // set loop time\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    position_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n    // run attitude controller\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 49.52909131893192}, {"code": "void Copter::run_rate_controller(){\n\t\n    // set dt for attitude controller\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\n    // run attitude controller\n    attitude_control->rate_controller_run();\n\n    // set dt for position controller\n    pos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\n    // run position controller\n    pos_control->update_z_controller();\n\n    // set dt for motors\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n}", "CodeBleu_score": 48.07540606781482}, {"code": "void Copter::run_rate_controller(){\n\t    // set dt for attitude and position controllers\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    motors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n    // run attitude controller\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 44.571189964418124}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (new_loc.same_loc_as(old_loc) || new_loc.get_alt_frame() != old_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\tset_target_location(new_loc);\n\treturn true;\n}", "CodeBleu_score": 51.688448620538594}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n    // if we are not in flight mode or if we're in a landing or takeoff flight mode then we don't change target\n    if (!flightmode.in_auto_flight_mode() || (flightmode.in_landing_mode() || flightmode.in_takeoff_mode())) {\n        return false;\n    }\n\n    // if we're already at the target location then we don't change target\n    if (old_loc.same_loc_as(new_loc)) {\n        return false;\n    }\n\n    // if the altitude frames of the old and new locations are not the same then we don't change target\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set target location\n    set_target_location(new_loc);\n\n    // return true to indicate that we've updated the target\n    return true;\n}", "CodeBleu_score": 65.56426635243362}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n\tif (flightmode->get_wp() != NULL) {\n\t\t// check if we've reached the next waypoint\n\t\tif (old_loc.same_loc_as(flightmode->get_wp()->get_location())) {\n\t\t\t// set target to next waypoint\n\t\t\tset_target_location(flightmode->get_wp()->get_location());\n\n\t\t\t// if we're navigating to a waypoint in a different altitude frame\n\t\t\tif (new_loc.get_alt_frame() != old_loc.get_alt_frame()) {\n\t\t\t\t// reset altitude to target altitude\n\t\t\t\treset_alt();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 50.57599197390113}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AUXSWITCH_HIGH) {\n        copter.set_mode(mode);\n    } else {\n        if (copter.flightmode->mode_number == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 62.324587709536736}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AUXSWITCH_HIGH) {\n        copter.set_mode(mode);\n    } else if (copter.flightmode->mode_number == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 57.90299770191274}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AUX_SWITCH_HIGH) {\n        copter.set_mode(mode);\n    } else if (copter.flightmode->mode_number == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 58.010413010199294}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\n    // save trim\n    channel_roll->get_control_in();\n    channel_pitch->get_control_in();\n\n    // add trim\n    ahrs.add_trim(ToRad(channel_roll->control_in), ToRad(channel_pitch->control_in));\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send message\n    gcs_send_text_P(SEVERITY_INFO,PSTR(\"Saving trim\"));\n}", "CodeBleu_score": 47.40302937500169}, {"code": "void Copter::save_trim(){\n\t    float roll_trim = channel_roll->get_control_in() * ToRad(100.0f);\n    float pitch_trim = channel_pitch->get_control_in() * ToRad(100.0f);\n    ahrs.add_trim(roll_trim, pitch_trim);\n    Log_Write_Event(DATA_SAVE_TRIM);\n    gcs().send_text_P(MAV_SEVERITY_INFO,PSTR(\"Trim Saved\"));\n}", "CodeBleu_score": 62.940830898056}, {"code": "void Copter::save_trim(){\n\t    channel_roll->get_control_in();\n    channel_pitch->get_control_in();\n    ahrs.add_trim(ToRad(channel_roll->control_in), ToRad(channel_pitch->control_in));\n    Log_Write_Event(DATA_SAVE_TRIM);\n    gcs().send_text_P(MAV_SEVERITY_INFO,PSTR(\"Saved trim\"));\n}", "CodeBleu_score": 49.426625517296955}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // retrieve copter's velocity\n    Vector3f vel;\n    vel = copter.inertial_nav.get_velocity_neu_cms();\n\n    // if copter's position is valid and speed exceeds a minimum threshold, update look-ahead yaw angle\n    if (copter.position_ok && vel.xy().length_squared() > 0.5f) {\n        // update look-ahead yaw angle\n        look_ahead_yaw_angle = atan2f(vel.y, vel.x) * RAD_TO_DEG;\n    }\n\n    // return look-ahead yaw angle\n    return look_ahead_yaw_angle;\n}", "CodeBleu_score": 45.554880993999504}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    float speed_sq = copter.velocity_cms.length_squared();\n    if (copter.position_ok && speed_sq > 100000) {\n        float yaw = atan2f(copter.velocity_cms.y, copter.velocity_cms.x);\n        yaw = wrap_PI(yaw);\n        return yaw;\n    }\n    return 0;\n}", "CodeBleu_score": 35.12793706460523}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    float yaw;\n    float speed_sq;\n\n    // get velocity\n    Vector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n    // if velocity is large enough, calculate look-ahead yaw\n    speed_sq = vel.xy().length_squared();\n    if (speed_sq > sq(100.0f) && copter.position_ok) {\n        yaw = atan2f(vel.y, vel.x) * RAD_TO_DEG;\n        // wrap yaw angle to -180 to +180 degrees\n        wrap_PI(yaw);\n    }\n    return yaw;\n}", "CodeBleu_score": 54.071316754729246}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::RUDDER) {\n        if (plane.rudder_arming_disabled() || plane.get_throttle_input() != 0) {\n            return false;\n        }\n    }\n    if (plane.arming.arming_checks_disabled() || hal.util->was_watchdog_armed()) {\n        return true;\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 50.17244533192118}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // rudder arming disabled or throttle not zero\n    if (method == AP_Arming::RUDDER && (plane.get_rudder_arming_type() == AP_Arming::RUDDER_DISABLED || plane.get_throttle_input() != 0)) {\n        return false;\n    }\n\n    // watchdog was armed\n    if (hal.util->was_watchdog_armed()) {\n        return true;\n    }\n\n    // call parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 48.88729283914306}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    // if arming checks are disabled or the watchdog was armed, bypass checks\n    if (!_arming_checks_enabled || hal.util->was_watchdog_armed()) {\n        return true;\n    }\n\n    // check if rudder arming is disabled or throttle is not zero\n    if (method == AP_Arming::RUDDER &&\n        (!_rudder_arming_enabled || !is_zero(plane.get_throttle_input()))) {\n        return false;\n    }\n\n    // perform standard arming checks\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 40.62379652818806}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // perform arming checks if requested\n    if (do_arming_checks && !arming_checks()) {\n        return false;\n    }\n\n    // arm throttle\n    if (method == AP_Arming::METHOD_THROTTLE) {\n        throttle_armed = true;\n    }\n\n    // arm the plane\n    plane.change_arm_state(true);\n    plane.update_home();\n    plane.ahrs.set_home(plane.current_loc);\n    plane.update_current_loc();\n    plane.send_arm_disarm_statustext();\n\n    // set delay arming flag\n    delay_arming = true;\n\n    return true;\n}", "CodeBleu_score": 55.7593802573222}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\n    // perform arming checks\n    if (do_arming_checks && !arming_checks()) {\n        return false;\n    }\n\n    // set home to current location\n    plane.update_home();\n\n    // set home in AHRS\n    plane.ahrs.set_home(plane.gps.location());\n\n    // update current location\n    plane.update_current_loc();\n\n    // change arm state\n    change_arm_state(method);\n\n    // set delay arming flag\n    delay_arming = true;\n\n    // send status text\n    send_arm_disarm_statustext(true);\n\n    return true;\n}", "CodeBleu_score": 51.46896192649232}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // if already armed, return false\n    if (AP_Arming::is_armed()) {\n        return false;\n    }\n\n    // if we are already waiting for a delay, return false\n    if (AP_Arming::is_delaying_arming()) {\n        return false;\n    }\n\n    // if we are already in the process of arming, return false\n    if (AP_Arming::is_arming()) {\n        return false;\n    }\n\n    // if we are in a failsafe mode, return false\n    if (AP_Arming::is_failsafe_mode()) {\n        return false;\n    }\n\n    // if we are in a pre-arm mode, return false\n    if (AP_Arming::is_pre_arm_check()) {\n        return false;\n    }\n\n    // if we are in a pre-arm mode, return false\n    if (AP_Arming::is_pre_arm_check()) {\n        return false;\n    }\n\n    // if we are in a pre-arm mode, return false\n    if (AP_Arming::is_pre_arm_check()) {\n        return false;\n    }\n\n    // if we are in a pre-arm mode, return false\n    if (AP_Arming::is_pre_arm_check()) {\n        return false;\n    }\n\n    // if we are in a pre-arm mode, return false\n    if (AP_Arming::is_pre_arm_check()) {\n        return false;\n    }\n\n    // if we are in a pre-arm mode, return false\n    if (AP_Arming::is_pre_arm_check()) {\n        return false;\n    }\n\n    // if we are in a pre-arm mode, return false\n    if (AP_Arming::is_pre_arm_check()) {\n        return false;\n    }\n\n    // if we are in a pre-arm mode, return false\n    if (AP_Arming::is_pre_arm_check()) {\n        return false;\n    }\n\n    // if we are in a pre-arm mode, return false\n    if (AP", "CodeBleu_score": 23.441955242504402}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if already armed, return true\n    if (armed) {\n        return true;\n    }\n\n    // if disarm button is configured, do standard checks\n    if (has_disarm_function()) {\n        return AP_Arming::pre_arm_checks(display_failure);\n    }\n\n    // disarm button not configured\n    if (display_failure) {\n        gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Disarm button not configured\"));\n    }\n    return false;\n}", "CodeBleu_score": 69.30645787535636}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\n\t/* If the vehicle is already armed, return true */\n\tif (armed) {\n\t\treturn true;\n\t}\n\n\t/* If the vehicle has no disarm button, display a failure message and return false */\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"No Disarm\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t/* Perform the standard pre-arm checks */\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.11247247230388}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if we are already armed we are done\n    if (armed) {\n        return true;\n    }\n\n    // if we have no disarm function we can't arm\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            hal.console->printf(\"No disarm function\n\");\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 76.51046014577345}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.35798259889287}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t  float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n  float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n  x = ne_x;\n  y = ne_y;\n}", "CodeBleu_score": 67.0217903083481}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.35798259889287}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    if (packet.param1 > 36000 || packet.param1 < 0) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param4 > 36000 || packet.param4 < 0) {\n        return MAV_RESULT_DENIED;\n    }\n    sub.mode_auto.set_auto_yaw_look_at_heading(packet.param1 / 100.0f, packet.param4 / 100.0f);\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 49.29492699817618}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    MAV_RESULT res = MAV_RESULT_DENIED;\n    if (packet.param1 == 0) {\n        // absolute angle\n        float target_angle = packet.param4 * 100;\n        if (is_zero(target_angle)) {\n            target_angle = 0;\n        }\n        if (is_equal(target_angle, 36000)) {\n            target_angle = 0;\n        }\n        if (target_angle > 36000 || target_angle < 0) {\n            return res;\n        }\n        set_auto_yaw_look_at_heading(target_angle);\n        res = MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 1) {\n        // relative angle\n        float target_angle = packet.param4 * 100;\n        if (is_zero(target_angle)) {\n            target_angle = 0;\n        }\n        if (is_equal(target_angle, 36000)) {\n            target_angle = 0;\n        }\n        if (target_angle > 36000 || target_angle < -36000) {\n            return res;\n        }\n        set_auto_yaw_look_at_heading(target_angle);\n        res = MAV_RESULT_ACCEPTED;\n    }\n    return res;\n}", "CodeBleu_score": 33.562138524107155}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    float yaw_angle = packet.param1;\n    float yaw_speed = packet.param2;\n    float yaw_direction = packet.param3;\n    float yaw_relative = packet.param4;\n\n    if (!is_zero(yaw_angle) && !is_equal(yaw_angle, 180)) {\n        return MAV_RESULT_DENIED;\n    }\n    if (!is_zero(yaw_speed) && !is_equal(yaw_speed, 180)) {\n        return MAV_RESULT_DENIED;\n    }\n    if (!is_zero(yaw_direction) && !is_equal(yaw_direction, 180)) {\n        return MAV_RESULT_DENIED;\n    }\n    if (!is_zero(yaw_relative) && !is_equal(yaw_relative, 180)) {\n        return MAV_RESULT_DENIED;\n    }\n\n    set_auto_yaw_look_at_heading(yaw_angle);\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 35.344949531883096}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == MAV_MODE_GUIDED_ARMED || control_mode == MAV_MODE_GUIDED_DISARMED || control_mode == MAV_MODE_AUTO) {\n        return wrap_360_cd(wp_bearing_to_destination) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 51.91015803927994}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return wrap_360_cd(get_wp_bearing_to_destination()) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 44.78152470364978}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    uint8_t tgt_heading = 0;\n    if (control_mode == MAV_MODE_GUIDED_ARMED || control_mode == MAV_MODE_AUTO) {\n        tgt_heading = wrap_180_cd(wp_bearing_to_destination) / 2;\n    }\n    return tgt_heading;\n}", "CodeBleu_score": 45.4419255301075}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t  if (should_log(id)) {\n    logger.WriteCriticalBlock(\n        LOG_PACKET_HEADER_INIT(id, sizeof(value)),\n        (uint8_t *)&value, sizeof(value));\n  }\n}", "CodeBleu_score": 34.36196050124809}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t  if (should_log) {\n    LOG_PACKET_HEADER_INIT\n    logger.WriteCriticalBlock\n    should_log\n    AP_HAL::micros64\n  }\n}", "CodeBleu_score": 15.451057828545641}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t  if (should_log) {\n    LOG_PACKET_HEADER_INIT\n    logger.WriteCriticalBlock\n  }\n}", "CodeBleu_score": 6.525209479264984}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set) {\n\t\treturn;\n\t}\n\tif (motors.armed) {\n\t\tset_home_to_current_location();\n\t} else {\n\t\tset_home_to_current_location_inflight();\n\t}\n}", "CodeBleu_score": 31.267894733978018}, {"code": "void Sub::update_home_from_EKF(){\n\t\n  // If the home is already set, exit immediately\n  if (home_is_set) {\n    return;\n  }\n\n  // If the motors are armed, set the home to the current location in-flight\n  if (motors.armed) {\n    set_home_to_current_location_inflight();\n    return;\n  }\n\n  // If the motors are not armed, attempt to set the home to the current EKF location and ignore any failure in this attempt\n  set_home_to_current_location();\n}", "CodeBleu_score": 30.061345552209097}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (ahrs.home_is_set) {\n        return;\n    }\n    if (motors.armed) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location();\n    }\n}", "CodeBleu_score": 40.77333583966955}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t    if (!motors.armed()) {\n        motors.set_throttle_out(0);\n        motors.set_desired_spool_state(Motors::SpoolState::Unlimited);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    motors.set_desired_spool_state(Motors::SpoolState::Unlimited);\n\n    attitude_control->input_rate_bf_roll_pitch_yaw(channel_roll->get_control_in(), channel_pitch->get_control_in(), channel_yaw->get_control_in());\n    attitude_control->set_throttle_out(channel_throttle->norm_input());\n\n    motors.set_forward(channel_lateral->norm_input());\n    motors.set_lateral(channel_forward->norm_input());\n}", "CodeBleu_score": 46.09311093983726}, {"code": "void ModeAcro::run(){\n\t    // exit immediately if not armed\n    if (!motors.armed()) {\n        attitude_control->relax_attitude_controllers();\n        attitude_control->set_throttle_out_unstabilized(0, false);\n        motors.set_desired_spool_state(AP_Motors::SpoolState::IDLE);\n        return;\n    }\n\n    // set motors to unlimited throttle\n    motors.set_desired_spool_state(AP_Motors::SpoolState::UNLIMITED);\n\n    // get pilot's desired roll and pitch rates\n    attitude_control->get_pilot_desired_angle_rates(channel_roll->norm_input(), channel_pitch->norm_input(), channel_yaw->get_control_in());\n\n    // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw();\n\n    // output pilot's throttle input without angle boost\n    attitude_control->set_throttle_out_unstabilized(channel_throttle->norm_input(), false);\n\n    // set forward and lateral motor inputs\n    motors.set_forward(channel_throttle->get_control_in());\n    motors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 48.86042350446205}, {"code": "void ModeAcro::run(){\n\t    // exit immediately if not armed\n    if (!motors.armed()) {\n        // reset throttle and spool state\n        motors.set_throttle_out(0.0f);\n        motors.set_desired_spool_state(AP_Motors::SpoolStateUnlimited);\n\n        // relax attitude controllers\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // set spool state to unlimited throttle\n    motors.set_desired_spool_state(AP_Motors::SpoolStateUnlimited);\n\n    // get pilot's desired roll, pitch and yaw rates\n    float roll_rate = channel_roll->get_control_in();\n    float pitch_rate = channel_pitch->get_control_in();\n    float yaw_rate = channel_yaw->get_control_in();\n\n    // convert pilot inputs to desired body frame rates\n    attitude_control->input_rate_bf_roll_pitch_yaw(roll_rate, pitch_rate, yaw_rate);\n\n    // run attitude controller\n    attitude_control->run();\n\n    // get pilot's desired throttle\n    float throttle = channel_throttle->norm_input();\n\n    // get pilot's desired lateral movement\n    float lateral = channel_lateral->norm_input();\n\n    // get pilot's desired forward movement\n    float forward = channel_forward->norm_input();\n\n    // set motor outputs\n    motors.set_forward(forward);\n    motors.set_lateral(lateral);\n\n    // output pilot's throttle without angle boost\n    motors.set_throttle_out(throttle);\n}", "CodeBleu_score": 52.79467902285248}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // Set guided position control mode\n    set_mode(Guided);\n\n    // Initialize waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // Set stopping point as destination\n    sub.wp_nav.set_wp_destination(sub.wp_nav.get_wp_stopping_point());\n\n    // Set yaw mode\n    set_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 37.56654652334383}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t/* Initialize guided position control mode */\n\tpos_control_mode_set(true);\n\n\t/* Set the current position as the destination for the waypoint controller */\n\tsub.wp_nav.set_wp_destination(sub.current_position);\n\n\t/* Set the stopping point */\n\tsub.wp_nav.set_wp_stopping_point(sub.current_position);\n\n\t/* Initialize the yaw */\n\tsub.wp_nav.set_auto_yaw_mode(sub.wp_nav.get_default_auto_yaw_mode());\n}", "CodeBleu_score": 37.514627318789394}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t/*\n\t * Set the vehicle position controller to position control mode.\n\t */\n\t_pos_control.set_mode(PX4_POSCTRL_MODE_POSITION);\n\n\t/*\n\t * Initialize the waypoint controller.\n\t */\n\tsub.wp_nav.wp_and_spline_init();\n\n\t/*\n\t * Get the stopping point.\n\t */\n\tsub.wp_nav.get_wp_stopping_point();\n\n\t/*\n\t * Set the waypoint destination to the stopping point.\n\t */\n\tsub.wp_nav.set_wp_destination();\n\n\t/*\n\t * Initialize the yaw using the default auto yaw mode.\n\t */\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 36.33625937352354}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\n    // initialize vertical maximum speeds and acceleration\n    position_control->init_xy_controller();\n    position_control->set_max_speed_accel_z();\n    position_control->init_z_controller();\n    position_control->set_correction_speed_accel_z();\n    set_auto_yaw_mode();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control->init_xy_vel_controller();\n\n    // initialize horizontal velocity controller\n    position_control", "CodeBleu_score": 27.542348337733934}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    position_control->init_xy_controller();\n    position_control->set_max_speed_accel_z(wp_nav->get_speed_xy_max(), wp_nav->get_accel_z_max());\n    position_control->init_z_controller();\n    position_control->set_correction_speed_accel_z(wp_nav->get_speed_z_max(), wp_nav->get_accel_z_max());\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 50.627666364972335}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // initialize vertical speeds and accelerations\n    position_control->init_xy_controller();\n    position_control->set_max_speed_accel_z(wp_nav.get_cruising_speed_xy(), wp_nav.get_cruising_throttle_min());\n    position_control->init_z_controller();\n    position_control->set_correction_speed_accel_z(wp_nav.get_cruising_speed_z(), wp_nav.get_cruising_throttle_min());\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n    sub.get_pilot_speed_dn(pilot_velocity_z);\n}", "CodeBleu_score": 51.74090045673142}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have exceeded the guided mode timeout\n    if (millis() - guided_limit.start_time_ms > guided_limit.timeout_ms) {\n        return true;\n    }\n\n    // check if we have exceeded the guided mode altitude limits\n    if (current_loc.alt < guided_limit.min_alt_cm || current_loc.alt > guided_limit.max_alt_cm) {\n        return true;\n    }\n\n    // check if we have exceeded the guided mode horizontal distance limit\n    float horizontal_distance_cm = get_horizontal_distance_cm(guided_limit.start_pos, current_loc);\n    if (horizontal_distance_cm > guided_limit.max_horizontal_distance_cm) {\n        return true;\n    }\n\n    // no limits exceeded\n    return false;\n}", "CodeBleu_score": 43.16216158022482}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    bool ret = false;\n    float dist_cm;\n    float alt_cm;\n    float dist_cm_xy;\n    float alt_cm_start;\n    float alt_cm_end;\n    float alt_cm_max;\n    float alt_cm_min;\n    float alt_cm_range;\n    float time_max;\n    float time_elapsed;\n    float speed_cm;\n    float speed_max;\n    float speed_min;\n    float speed_range;\n    float speed_xy;\n    float speed_xy_max;\n    float speed_xy_min;\n    float speed_xy_range;\n\n    // check timeout\n    if (guided_limit.time_max > 0) {\n        time_max = guided_limit.time_max * 1000000.0f;\n        time_elapsed = (hal.scheduler->millis() - guided_limit.start_time_ms);\n        if (time_elapsed > time_max) {\n            ret = true;\n            guided_limit.status = GUIDED_LIMIT_STATUS_TIMEOUT;\n        }\n    }\n\n    // check altitude\n    if (guided_limit.alt_max > 0 || guided_limit.alt_min > 0) {\n        alt_cm_start = guided_limit.start_pos.alt;\n        alt_cm_end = inertial_nav.get_position_neu_cm(alt_cm_start, curr_pos.alt);\n        alt_cm = alt_cm_end - alt_cm_start;\n        if (guided_limit.alt_max > 0) {\n            alt_cm_max = guided_limit.alt_max * 100.0f;\n            if (alt_cm > alt_cm_max) {\n                ret = true;\n                guided_limit.status = GUIDED_LIMIT_STATUS_ALT_MAX;\n            }\n        }\n        if (guided_limit.alt_min > 0) {\n            alt_cm_min = guided_limit.alt_min * 1", "CodeBleu_score": 32.00511643014227}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    if (millis() > guided_limit.start_time + guided_limit.timeout_ms) {\n        return true;\n    }\n    if (curr_pos.z < guided_limit.min_alt_cm) {\n        return true;\n    }\n    if (curr_pos.z > guided_limit.max_alt_cm) {\n        return true;\n    }\n    if (get_horizontal_distance_cm(guided_limit.start_pos.xy, inertial_nav.get_position_neu_cm()) > guided_limit.horizontal_distance_max_cm) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 41.65584051811934}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t    if (hal.scheduler->micros() - motor_test_last_request_time > 1000000UL) {\n        gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Motor Test timed out\"));\n        motor_test_pass = false;\n        gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Motor Test disabled\"));\n        AP_HAL::analogWrite(motor_test_pin, 0);\n        AP_HAL::analogWrite(motor_test_pin2, 0);\n        AP_HAL::analogWrite(motor_test_pin3, 0);\n        AP_HAL::analogWrite(motor_test_pin4, 0);\n        AP_HAL::analogWrite(motor_test_pin5, 0);\n        AP_HAL::analogWrite(motor_test_pin6, 0);\n        AP_HAL::analogWrite(motor_test_pin7, 0);\n        AP_HAL::analogWrite(motor_test_pin8, 0);\n        AP_HAL::analogWrite(motor_test_pin9, 0);\n        AP_HAL::analogWrite(motor_test_pin10, 0);\n        AP_HAL::analogWrite(motor_test_pin11, 0);\n        AP_HAL::analogWrite(motor_test_pin12, 0);\n        AP_HAL::analogWrite(motor_test_pin13, 0);\n        AP_HAL::analogWrite(motor_test_pin14, 0);\n        AP_HAL::analogWrite(motor_test_pin15, 0);\n        AP_HAL::analogWrite(motor_test_pin16, 0);\n        AP_HAL::analogWrite(motor_test_pin17, 0);\n        AP_HAL::analogWrite(motor_test_pin18, 0);\n        AP", "CodeBleu_score": 34.086448871577915}, {"code": "bool Sub::verify_motor_test(){\n\t    if (hal.scheduler->millis() - motor_test_last_request_ms > 1000) {\n        gcs().send_text(SEVERITY_HIGH,PSTR(\"motor test timed out\"));\n        pass = false;\n        AP::motor_test().disable();\n        AP::arming().disarm();\n        record_failure_time();\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 31.195747091590924}, {"code": "bool Sub::verify_motor_test(){\n\t    if (!hal.scheduler->system_initializing() && hal.scheduler->millis() - motor_test_timeout_ms > 1000) {\n        motor_test_timeout_ms = hal.scheduler->millis();\n        if (motor_test_timeout_count > 0) {\n            motor_test_timeout_count--;\n            if (motor_test_timeout_count == 0) {\n                gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Motor test timeout\"));\n                pass = false;\n                motor_test_enabled = false;\n                AP::arming().disarm();\n                motor_test_failure_time = hal.scheduler->millis();\n                return false;\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 52.38119336375924}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t  //Get roll and pitch targets from wp_nav in centidegrees\n  int16_t roll_target = wp_nav.get_roll();\n  int16_t pitch_target = wp_nav.get_pitch();\n\n  //Constrain targets within a specified maximum angle range\n  roll_target = constrain_int16(roll_target, -1000, 1000);\n  pitch_target = constrain_int16(pitch_target, -1000, 1000);\n\n  //Normalize targets to +/-1.0\n  float roll_target_normalized = (float)roll_target / 1000.0;\n  float pitch_target_normalized = (float)pitch_target / 1000.0;\n\n  //Assign normalized targets to lateral_out and forward_out\n  lateral_out = roll_target_normalized;\n  forward_out = pitch_target_normalized;\n}", "CodeBleu_score": 45.305338718212}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t  // Get the roll and pitch targets from wp_nav\n  int16_t roll_target = wp_nav.get_roll();\n  int16_t pitch_target = wp_nav.get_pitch();\n\n  // Constrain the targets within a specified range\n  roll_target = constrain_int16(roll_target, -1000, 1000);\n  pitch_target = constrain_int16(pitch_target, -1000, 1000);\n\n  // Normalize the targets to [-1, 1]\n  lateral_out = (float)roll_target / 1000.0f;\n  forward_out = (float)pitch_target / 1000.0f;\n}", "CodeBleu_score": 42.685929703915}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t  // get the roll and pitch targets from wp_nav\n  int16_t roll_target = wp_nav.get_roll();\n  int16_t pitch_target = wp_nav.get_pitch();\n\n  // constrain the roll and pitch targets within a specified maximum angle range\n  roll_target = constrain_int16(roll_target, -MAX_RP_ANGLE, MAX_RP_ANGLE);\n  pitch_target = constrain_int16(pitch_target, -MAX_RP_ANGLE, MAX_RP_ANGLE);\n\n  // normalize the roll and pitch targets\n  lateral_out = (float)roll_target / (float)MAX_RP_ANGLE;\n  forward_out = (float)pitch_target / (float)MAX_RP_ANGLE;\n}", "CodeBleu_score": 50.39074215199177}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t  if (barometer.get_altitude() > 0) {\n    barometer.update_calibration();\n  }\n  if (depth_sensor.present()) {\n    depth_sensor.update_health(barometer.healthy());\n  }\n}", "CodeBleu_score": 61.22261337155237}, {"code": "void Sub::read_barometer(){\n\t  if (barometer.get_altitude() > 0) {\n    barometer.update_calibration();\n  }\n  if (depth_sensor.present) {\n    depth_sensor.healthy = barometer.healthy;\n  }\n}", "CodeBleu_score": 61.38630105579611}, {"code": "void Sub::read_barometer(){\n\t  if (barometer.update()) {\n    if (barometer.get_altitude() > 0) {\n      barometer.update_calibration();\n    }\n    if (depth_sensor_present) {\n      if (barometer.healthy()) {\n        depth_sensor_healthy = true;\n      } else {\n        depth_sensor_healthy = false;\n      }\n    }\n  }\n}", "CodeBleu_score": 68.51148748083862}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n    if (!motors.armed()) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status() != INAV_FILTER_STATUS_OK) {\n        return false;\n    }\n    if (inertial_nav.get_position_ok()) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 46.794573420021166}, {"code": "bool Sub::ekf_position_ok(){\n\t    if (!ahrs.have_inertial_nav) {\n        return false;\n    }\n    if (!motors.armed) {\n        return true;\n    }\n    if (!inertial_nav.get_filter_status().flags.optflow) {\n        return false;\n    }\n    if (inertial_nav.get_filter_status().flags.gps) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.gps_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.ev_pos) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.ev_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.baro_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.rng_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.terr_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.gps_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.gps_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.gps_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.gps_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.gps_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags.gps_hgt) {\n        return true;\n    }\n    if (inertial_nav.get_filter_status().flags", "CodeBleu_score": 44.3612736044806}, {"code": "bool Sub::ekf_position_ok(){\n\t    if ( !ahrs.have_inertial_nav ) {\n        return false;\n    }\n    if ( !motors.armed ) {\n        return true;\n    }\n    if ( !inertial_nav.get_filter_status().flags.position_horiz_abs ) {\n        return false;\n    }\n    if ( inertial_nav.get_filter_status().flags.const_pos_mode ) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 40.46832639610641}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // if we don't need position or velocity then we don't need to do any GPS checks\n    if (!control_mode->requires_position() && !control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent class's GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS is ready\n    if (!ahrs.pre_arm_check()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, PSTR(\"PreArm: Compass not ready\"));\n        }\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (ekf_position_ok) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, PSTR(\"PreArm: EKF failsafe active\"));\n        }\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!rover.ekf_position_ok()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, PSTR(\"PreArm: EKF position not valid\"));\n        }\n        return false;\n    }\n\n    // all checks have passed\n    return true;\n}", "CodeBleu_score": 57.190636773693406}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // if we are not in a mode that requires position or velocity, we do not need to do any GPS checks\n    if (!control_mode->requires_position() && !control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ahrs.pre_arm_check()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: Compass not ready\"));\n        }\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (ekf_position_ok()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: EKF failsafe active\"));\n        }\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!ahrs.position_ok()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: Position not valid\"));\n        }\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 56.13223557274405}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // if we don't need position or velocity, pass\n    if (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\n        return true;\n    }\n\n    // call parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ahrs.pre_arm_check()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Pre-Arm: Compass not healthy\"));\n        }\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (!rover.ekf_position_ok) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Pre-Arm: EKF failsafe active\"));\n        }\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!rover.position_ok) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Pre-Arm: No 3D lock\"));\n        }\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 60.87593425104847}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // exit immediately if already armed\n    if (rover.armed.get()) {\n        return true;\n    }\n\n    // perform arming checks if required\n    if (do_arming_checks) {\n        if (!rover.g.arming_checks) {\n            return true;\n        }\n        if (!pre_arm_checks(true)) {\n            return false;\n        }\n    }\n\n    // set arming method\n    rover.armed.set_method(method);\n\n    // set SmartRTL home location\n    rover.g2.smart_rtl.set_home();\n\n    // initialise simple mode heading\n    rover.mode_simple.init_heading();\n\n    // record home heading for sail vehicles\n    rover.g2.windvane.record_home_heading();\n\n    // update soft armed status\n    update_soft_armed();\n\n    // send arm/disarm status text\n    send_arm_disarm_statustext();\n\n    // send event\n    AP_Notify::events.arming_state_changed = true;\n\n    return true;\n}", "CodeBleu_score": 52.61298371364769}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\n    // perform arming checks if required\n    if (do_arming_checks) {\n        if (!pre_arm_checks(method)) {\n            return false;\n        }\n    }\n\n    // arm the vehicle\n    if (!arm_motors(method)) {\n        return false;\n    }\n\n    // set the SmartRTL home location\n    rover.g2.smart_rtl.set_home();\n\n    // initialize the simple mode heading\n    rover.mode_simple.init_heading();\n\n    // record the home heading for sail vehicles\n    rover.g2.windvane.record_home_heading();\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    send_arm_disarm_statustext();\n\n    return true;\n}", "CodeBleu_score": 53.87677817261648}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (rover.arming.arm_disarm(true, method)) {\n        // set SmartRTL home location\n        rover.g2.smart_rtl.set_home();\n\n        // initialize simple mode heading\n        rover.mode_simple.init_heading();\n\n        // record home heading for sail vehicles\n        rover.g2.windvane.record_home_heading();\n\n        // update soft armed status\n        rover.arming.update_soft_armed();\n\n        // send arm/disarm status text\n        rover.arming.send_arm_disarm_statustext();\n\n        // return success\n        return true;\n    }\n\n    // arming failed\n    return false;\n}", "CodeBleu_score": 46.788690576441624}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (!should_charge) {\n      if (!charging_enabled) {\n        charging_enabled = true;\n        charging_disabled_timestamp = millis();\n      }\n      if (millis() - charging_disabled_timestamp > CHARGING_DISABLED_TIMEOUT) {\n        charging_enabled = false;\n        charging_disabled_timestamp = millis();\n      }\n    } else {\n      charging_enabled = true;\n      charging_disabled_timestamp = 0;\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      charging_disabled_timestamp = millis();\n    }\n    if (millis() - charging_disabled_timestamp > CHARGING_DISABLED_TIMEOUT) {\n      charging_enabled = true;\n      charging_disabled_timestamp = 0;\n    }\n  }\n}", "CodeBleu_score": 48.38472151341161}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (!should_charge) {\n      charging_enabled = false;\n      digitalWrite(CHARGE_ENABLE_PIN, LOW);\n      charging_disabled_time = millis();\n    } else if (!charging_enabled) {\n      charging_enabled = true;\n      digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      digitalWrite(CHARGE_ENABLE_PIN, LOW);\n      charging_disabled_time = millis();\n    } else if (millis() - charging_disabled_time > CHARGING_DISABLED_TIMEOUT) {\n      charging_enabled = true;\n      digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n    }\n  }\n}", "CodeBleu_score": 66.5840917661036}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed && !charging_enabled) {\n        charging_enabled = true;\n        digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n        charging_disabled_time = 0;\n    } else if (!charging_allowed && charging_enabled) {\n        charging_enabled = false;\n        digitalWrite(CHARGE_ENABLE_PIN, LOW);\n        charging_disabled_time = millis();\n    } else if (!charging_allowed && charging_enabled && millis() - charging_disabled_time >= CHARGING_DISABLE_DELAY) {\n        charging_enabled = false;\n        digitalWrite(CHARGE_ENABLE_PIN, LOW);\n    }\n}", "CodeBleu_score": 56.698180133601774}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t    if (rosRunning) {\n        if (size >= 4) {\n            uint16_t crc = CRC16.ccitt((uint8_t *)message, size - 2);\n            ((uint8_t *)message)[size - 2] = crc >> 8;\n            ((uint8_t *)message)[size - 1] = crc & 0xFF;\n            packetSerial.send(message, size);\n        }\n    }\n}", "CodeBleu_score": 57.293802244788694}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (rosRunning) {\n        if (size >= 4) {\n            uint16_t crc = CRC16.ccitt((uint8_t *)message, size);\n            ((uint8_t *)message)[size] = crc >> 8;\n            ((uint8_t *)message)[size + 1] = crc & 0xFF;\n            packetSerial.send(message, size + 2);\n        }\n    }\n}", "CodeBleu_score": 53.58663105134627}, {"code": "void sendMessage(void *message, size_t size){\n\t\t// Check if ROS is running\n\tif (ros::master::check()) {\n\t\t// Check if message is at least 4 bytes\n\t\tif (size >= 4) {\n\t\t\t// Calculate CRC\n\t\t\tuint16_t crc = CRC16.ccitt((uint8_t*)message, size);\n\t\t\t// Append CRC to message\n\t\t\tmemcpy((uint8_t*)message + size, &crc, 2);\n\t\t\t// Increment size\n\t\t\tsize += 2;\n\t\t\t// Send message\n\t\t\tpacketSerial.send((uint8_t*)message, size);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.56688345502882}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  soundSerial.flush();\n  delay(100);\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x0F);\n  soundSerial.write(0x01);\n  soundSerial.write(0x00);\n  soundSerial.write(0x01);\n  soundSerial.write(0xEF);\n  delay(100);\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x09);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x01);\n  soundSerial.write(0xEF);\n  delay(100);\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x3F);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0xEF);\n  delay(100);\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x0E);\n  soundSerial.write(0x00);\n  soundSerial.write(0x01);\n  soundSerial.write(0xEF);\n  delay(100);\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0x01);\n  soundSerial.write(0xEF);\n  delay(100);", "CodeBleu_score": 41.52374570830361}, {"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  soundSerial.flush();\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x0F);\n  soundSerial.write(0x01);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0xEF);\n  if (soundSerial.available() > 0) {\n    if (soundSerial.read() == 0x7E) {\n      if (soundSerial.read() == 0xFF) {\n        if (soundSerial.read() == 0x06) {\n          if (soundSerial.read() == 0x0F) {\n            if (soundSerial.read() == 0x01) {\n              if (soundSerial.read() == 0x00) {\n                if (soundSerial.read() == 0x00) {\n                  if (soundSerial.read() == 0x00) {\n                    if (soundSerial.read() == 0x00) {\n                      if (soundSerial.read() == 0xEF) {\n                        numSdTracks = soundSerial.read();\n                        numSdTracks += soundSerial.read() << 8;\n                        return true;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}", "CodeBleu_score": 43.41549819563857}, {"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  soundSerial.setTimeout(100);\n  soundSerial.flush();\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x0F);\n  soundSerial.write(0x01);\n  soundSerial.write(0x00);\n  soundSerial.write(0x01);\n  soundSerial.write(0x00);\n  soundSerial.write(0xEF);\n  soundSerial.flush();\n  if (soundSerial.available()) {\n    byte response[10];\n    soundSerial.readBytes(response, 10);\n    if (response[2] == 0x3F) {\n      numSdTracks = response[3];\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 47.15636400982489}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tint num_active_sounds = active_sounds.size();\n\tif (num_active_sounds == 0 || isPlaying) {\n\t\treturn num_active_sounds;\n\t}\n\tmyMP3 = active_sounds.back();\n\tmyMP3.play();\n\tactive_sounds.pop_back();\n\treturn num_active_sounds;\n}", "CodeBleu_score": 50.48121494306235}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t} else {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.30795718535374}, {"code": "int MP3Sound::processSounds(){\n\t    if (active_sounds.size() == 0 || myMP3.isPlaying()) {\n        return active_sounds.size();\n    }\n    myMP3.play(active_sounds.back());\n    active_sounds.pop_back();\n    return active_sounds.size();\n}", "CodeBleu_score": 46.364279499696224}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *ac = d->pdata;\n  bool command_handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      ac->has_memory_mapped_file = true;\n      ac->memory_mapped_file_request = r;\n      if (ac->memory_mapped_file_request->requested_size > 0) {\n        // cleanup any existing memory-mapped file\n        if (ac->memory_mapped_file) {\n          image_cleanup(ac);\n          ac->memory_mapped_file = NULL;\n          ac->memory_mapped_file_size = 0;\n        }\n\n        // setup new memory-mapped file\n        ac->memory_mapped_file_size = ac->memory_mapped_file_request->requested_size;\n        ac->memory_mapped_file = image_setup(ac);\n        ac->memory_mapped_file_request->requested_size = ac->memory_mapped_file_size;\n        ac->memory_mapped_file_request->file_id = ac->memory_mapped_file_id;\n        ac->memory_mapped_file_request->file_size = ac->memory_mapped_file_size;\n        ac->memory_mapped_file_request->file_requested_size = ac->memory_mapped_file_size;\n        ac->memory_mapped_file_request->file_pointer = ac->memory_mapped_file;\n        ac->memory_mapped_file_request->file_unique_id = ac->memory_mapped_file_unique_id;\n        ac->memory_mapped_file_request->file_actual_size = ac->memory_mapped_file_size;\n        ac->memory_mapped_file_request->file_user_data = ac;\n        ac->memory_mapped_file_request->file_user_data_size = sizeof(WbAbstractCamera);\n        ac->memory_mapped_file_request->file_user_data_type = WB_MEMORY_MAPP", "CodeBleu_score": 44.64141390606957}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *ac = d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      ac->memory_mapped_file_request = r;\n      ac->memory_mapped_file_request_size = request_size(r);\n      ac->memory_mapped_file_request_position = 0;\n      ac->memory_mapped_file_request_done = false;\n      ac->memory_mapped_file_request_command = command;\n      ac->memory_mapped_file_request_position = 0;\n      ac->memory_mapped_file_request_done = false;\n      ac->memory_mapped_file_request_command = command;\n      ac->memory_mapped_file_request_position = 0;\n      ac->memory_mapped_file_request_done = false;\n      ac->memory_mapped_file_request_command = command;\n      ac->memory_mapped_file_request_position = 0;\n      ac->memory_mapped_file_request_done = false;\n      ac->memory_mapped_file_request_command = command;\n      ac->memory_mapped_file_request_position = 0;\n      ac->memory_mapped_file_request_done = false;\n      ac->memory_mapped_file_request_command = command;\n      ac->memory_mapped_file_request_position = 0;\n      ac->memory_mapped_file_request_done = false;\n      ac->memory_mapped_file_request_command = command;\n      ac->memory_mapped_file_request_position = 0;\n      ac->memory_mapped_file_request_done = false;\n      ac->memory_mapped_file_request_command = command;\n      ac->memory_mapped_file_request_position = 0;\n      ac->memory_mapped_file_request_done = false;\n      ac->memory_mapped_file_request_command = command;\n      ac->memory_mapped_file_request_position = 0;\n", "CodeBleu_score": 42.54726974340506}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *ac = d->pdata;\n  bool command_handled = true;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (ac->memory_mapped_file) {\n        wb_abstract_camera_cleanup_memory_mapped_file(ac);\n        ac->memory_mapped_file = NULL;\n      }\n\n      const char *filename = wb_request_read_string(r);\n      ac->memory_mapped_file = wb_abstract_camera_setup_memory_mapped_file(filename);\n      break;\n    }\n    default:\n      command_handled = false;\n      break;\n  }\n\n  return command_handled;\n}", "CodeBleu_score": 65.03252462266643}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  robot_mutex_lock_step();\n  WbAbstractCamera *ac = d->pdata;\n  int result = -1;\n  if (ac->has_get_info)\n    result = ac->info.height;\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 63.402063534974474}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  robot_mutex_lock_step();\n  int result = -1;\n  if (d->pdata && d->pdata->camera) {\n    WbCamera *c = d->pdata->camera;\n    if (c->image)\n      result = c->height;\n  }\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 59.46450985742765}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  robot_mutex_lock_step();\n  AbstractCamera *ac = d->pdata;\n  if (ac) {\n    height = ac->height;\n    ac->height = -1;\n  }\n  robot_mutex_unlock_step();\n  return height;\n}", "CodeBleu_score": 65.51182350129335}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    sampling_period = 0;\n  }\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 53.57889278238173}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  int sampling_period = 0;\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 58.38223230616789}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 59.86505084847994}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result(dms);\n    free(dms);\n    return result;\n}", "CodeBleu_score": 39.817711736096165}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result(dms);\n    free(dms);\n    return result;\n}", "CodeBleu_score": 39.817711736096165}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 39.37179132599584}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n\n    // Ensure the geometry is a box\n    dGeomBoxGetParams(g, plane);\n\n    // Calculate the relative position of the point to the box center\n    dVector3 diff;\n    diff[0] = x - plane[0];\n    diff[1] = y - plane[1];\n    diff[2] = z - plane[2];\n\n    // Check each axis for proximity to the box's surface\n    dReal min = dFabs(diff[0] * plane[4]);\n    plane[4] = diff[0];\n    plane[5] = 0;\n    plane[6] = 0;\n    plane[7] = -min;\n\n    dReal d = dFabs(diff[1] * plane[5]);\n    if (d < min) {\n        min = d;\n        plane[4] = 0;\n        plane[5] = diff[1];\n        plane[6] = 0;\n        plane[7] = -min;\n    }\n\n    d = dFabs(diff[2] * plane[6]);\n    if (d < min) {\n        min = d;\n        plane[4] = 0;\n        plane[5] = 0;\n        plane[6] = diff[2];\n        plane[7] = -min;\n    }\n}", "CodeBleu_score": 32.55992275661737}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n    dGeomBoxGetTangentPlaneFunc(g, x, y, z, plane);\n}", "CodeBleu_score": 7.996070868226779}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dUASSERT(g && g->type == dBoxClass,\"argument not a box\");\n    dReal* R = g->R;\n    dReal* C = g->AABB;\n    dReal* p = g->final_posr->pos;\n    dReal* s = g->side;\n    dReal* q = g->final_posr->R;\n    dReal X = x - (p[0] + q[0]*C[0] + q[4]*C[1] + q[8]*C[2]);\n    dReal Y = y - (p[1] + q[1]*C[0] + q[5]*C[1] + q[9]*C[2]);\n    dReal Z = z - (p[2] + q[2]*C[0] + q[6]*C[1] + q[10]*C[2]);\n    dReal* n = plane;\n    dReal k = 0;\n    dVector3 v;\n    if (dFabs(X) > dFabs(Y)) {\n        if (dFabs(X) > dFabs(Z)) {\n            if (X > 0) {\n                n[0] = 1;\n                n[1] = 0;\n                n[2] = 0;\n                k = s[0];\n            }\n            else {\n                n[0] = -1;\n                n[1] = 0;\n                n[2] = 0;\n                k = -s[0];\n            }\n        }\n        else {\n            if (Z > 0) {\n                n[0] = 0;\n                n[1] = 0;\n                n[2] = 1;\n                k = s[2];\n            }\n            else {\n                n[0] = 0;\n                n[1] = 0;\n                n[2] = -1;\n                k = -s[2];\n            }\n        }\n    }\n    else {\n        if (dFabs(Y) > dFabs(Z)) {\n            if (Y > 0) {\n                n", "CodeBleu_score": 36.17354152070408}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n  // Setup the immersion data\n  sBoxImmersionData data;\n  data.box = box;\n  data.fluidPlane = fluidPlube;\n  data.flags = flags;\n  data.performImmersionChecking = 1;\n\n  // Perform the immersion checking\n  int result = dImmerseBox (&data, immersion);\n\n  // Return the result\n  return result;\n}", "CodeBleu_score": 45.9334717334879}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dUASSERT(box, \"The box must have a value\");\n  dUASSERT(box->body, \"The box must be attached to a body\");\n  dUASSERT(fluidPlane, \"The fluid plane must have a value\");\n  dUASSERT(immersion, \"The immersion must have a value\");\n  dUASSERT(dGeomIsEnabled(box), \"The box must be enabled\");\n  dUASSERT(dGeomIsEnabled(box->body), \"The body must be enabled\");\n  dUASSERT(dGeomIsEnabled(box->fluid), \"The fluid must be enabled\");\n\n  dIASSERT(dGeomGetClass(box) == dBoxClass);\n  dIASSERT(dGeomGetClass(box->body) == dBodyClass);\n  dIASSERT(dGeomGetClass(box->fluid) == dPlaneClass);\n\n  dIASSERT((flags & NUMI_MASK) >= 1);\n  dIASSERT((flags & NUMI_MASK) <= 3);\n\n  dIASSERT(dGeomGetBody(box) == box->body);\n\n  dReal *planes = (dReal *)fluidPlane;\n  dReal *point = box->final_posr->pos;\n  dReal *R = box->final_posr->R;\n  dReal *side = box->side;\n  dReal *p = immersion->g1.plane.p;\n  dReal *n = immersion->g1.plane.n;\n  dReal *depth = &immersion->g1.plane.depth;\n\n  dReal boxPoint[3];\n  dMultiply0_331(boxPoint, R, point);\n\n  dReal boxNormal[3];\n  dMultiply1_331(boxNormal, R, planes);\n\n  dReal boxDepth = dCalcVectorDot3(boxPoint, boxNormal) - planes[3];\n\n  dReal boxP[3];\n  dReal boxN[3];\n  dReal boxDep;\n\n  dImmersionData data;", "CodeBleu_score": 46.598609168517555}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n  // make sure the object is a box\n  dUASSERT(box->type == dBoxClass, \"The object is not a box\");\n\n  // make sure the object has a body\n  dUASSERT(box->body, \"The box does not have a body\");\n\n  // make sure the flags are valid\n  dUASSERT((flags & ~(NUMI_MASK | PENETRATION_ONLY)) == 0, \"Invalid flags\");\n\n  // initialize the immersion data\n  sBoxImmersionData data;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.flags = flags;\n\n  // perform the immersion checking\n  dIASSERT(data.performImmersionChecking(immersion));\n\n  return 1;\n}", "CodeBleu_score": 50.35514399666652}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n  //dIASSERT (o1->type == dBoxClass);\n  //dIASSERT (o2->type == dCapsuleClass);\n  dUASSERT (o1->body && o2->body,\"immersed geometries must all be attached to a body\");\n\n  // get box and capsule\n  dxBox *Box = (dxBox*) o1;\n  dxCapsule *Capsule = (dxCapsule*) o2;\n\n  // get the box rotation matrix\n  dMatrix3 R;\n  dRSetIdentity (R);\n  dRFromEulerAngles (R, Box->body->q[0], Box->body->q[1], Box->body->q[2]);\n\n  // get the capsule rotation matrix\n  dMatrix3 R_Capsule;\n  dRSetIdentity (R_Capsule);\n  dRFromEulerAngles (R_Capsule, Capsule->body->q[0], Capsule->body->q[1], Capsule->body->q[2]);\n\n  // get the capsule position in the box frame\n  dVector3 q;\n  dSubtractVectors3(q,Capsule->body->pos,Box->body->pos);\n  dMultiply0_331 (q,R,q);\n\n  // get the capsule direction in the box frame\n  dVector3 d;\n  dMultiply0_331 (d,R,Capsule->final_posr->R[2]);\n\n  // get the capsule radius\n  dReal r = Capsule->radius;\n\n  // get the box half size\n  dVector3 s;\n  dSubtractVectors3(s,Box->final_posr->R[0],Box->final_posr->R[1]);\n  s[0] = 0.5f * dCalcVectorDot3(s,Box->final_posr->R[0]);\n  s[1] = 0.5f * dCalcVectorDot3(s,Box->final_posr->R[1]);\n  s[2] = 0.", "CodeBleu_score": 38.661600215284054}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    int i;\n    dReal *planes;\n    dReal *planes_tmp;\n    dReal *points;\n    dReal *points_tmp;\n    dReal *normals;\n    dReal *normals_tmp;\n    dReal *buoys;\n    dReal *buoys_tmp;\n    dReal *velocities;\n    dReal *velocities_tmp;\n    dReal *w;\n    dReal *w_tmp;\n    dReal *tmp;\n    dReal *tmp_tmp;\n    int nb_planes;\n    int nb_points;\n    int nb_normals;\n    int nb_buoys;\n    int nb_velocities;\n    int nb_tmp;\n    int ret;\n\n    dIASSERT (o1->type == dBoxClass);\n    dIASSERT (o2->type == dCapsuleClass);\n    dIASSERT ((flags & NUMI_MASK) >= 1);\n\n    // Get the box and the capsule\n    dxBox *Box = (dxBox*) o1;\n    dxCapsule *Capsule = (dxCapsule*) o2;\n\n    // Get the box size\n    dVector3 size;\n    dGeomBoxGetLengths (Box, size);\n\n    // Get the capsule radius and length\n    dReal radius, length;\n    dGeomCapsuleGetParams (Capsule, &radius, &length);\n\n    // Get the box rotation matrix\n    dMatrix3 R;\n    dRSetIdentity (R);\n    dGeomGetRotation (Box, R);\n\n    // Get the capsule rotation matrix\n    dMatrix3 R_tmp;\n    dRSetIdentity (R_tmp);\n    dGeomGetRotation (Capsule, R_tmp);\n\n    // Get the capsule position\n    dVector3 pos;\n    dGeomGetPosition (Capsule, pos);\n\n    // Get the box position\n    dVector3 pos_tmp;\n    dGeomGetPosition (Box, pos_tmp);\n\n    // Get the capsule axis\n   ", "CodeBleu_score": 38.59221809715449}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\n  dIASSERT (o1 && o2 && immersion);\n  dUASSERT (o1->type == dBoxClass && o2->type == dCapsuleClass, \"argument not a box or a capsule\");\n\n  // Check if the capsule is in the box\n  if (dGeomBoxContainsCapsule (o1, o2) == 1) {\n\n    // Set immersion parameters\n    immersion->g1 = o1;\n    immersion->g2 = o2;\n\n    // Set the immersion plane\n    dGeomCapsuleGetImmersionPlane (o2, immersion->plane);\n\n    // Process the immersion of the box in the fluid\n    return dImmerseBox (o1, flags, immersion);\n  }\n\n  return 0;\n}", "CodeBleu_score": 36.275636976883675}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    const dReal sinTheta0 = tanTheta0 / sqrt(tanTheta0 * tanTheta0 + 1);\n    const dReal cosTheta0 = sqrt(1 - sinTheta0 * sinTheta0);\n    const dReal sinTheta1 = sinTheta1;\n    const dReal cosTheta1 = sqrt(1 - sinTheta1 * sinTheta1);\n\n    dReal volume = 0;\n\n    // Integrate from theta0 to theta1\n    const dReal lowerLimit = asin(sinTheta0);\n    const dReal upperLimit = asin(sinTheta1);\n    volume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(lowerLimit, upperLimit, 10, *this);\n\n    // Integrate from theta1 to pi/2\n    const dReal lowerLimit2 = asin(sinTheta1);\n    const dReal upperLimit2 = M_PI_2;\n    volume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(lowerLimit2, upperLimit2, 10, *this);\n\n    return volume;\n}", "CodeBleu_score": 50.44193711357683}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    dReal volume = 0.0;\n\n    // Handle singularity at theta = 0\n    if (tanTheta0 != 0.0) {\n        volume += sSimpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(\n            sHemisphereIntegrationData(zIOverR, tanTheta0, 0.0),\n            sHemisphereIntegrationData(zIOverR, tanTheta0, M_PI_4),\n            sHemisphereIntegrationData(zIOverR, tanTheta0, M_PI_2)\n        );\n    }\n\n    // Handle singularity at theta = pi/2\n    if (sinTheta1 != 0.0) {\n        volume += sSimpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(\n            sHemisphereIntegrationData(zIOverR, tanTheta0, M_PI_2),\n            sHemisphereIntegrationData(zIOverR, tanTheta0, 3.0 * M_PI_4),\n            sHemisphereIntegrationData(zIOverR, tanTheta0, M_PI)\n        );\n    }\n\n    return volume;\n}", "CodeBleu_score": 45.38304711950894}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    // Calculate the volume of the hemisphere above the capsule\n    dReal volumeAbove = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(\n        sHemisphereIntegrationData(zIOverR, tanTheta0, sinTheta1), 0.0, M_PI);\n\n    // Calculate the volume of the hemisphere below the capsule\n    dReal volumeBelow = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(\n        sHemisphereIntegrationData(zIOverR, tanTheta0, sinTheta1), -M_PI, 0.0);\n\n    // Return the total volume\n    return volumeAbove + volumeBelow;\n}", "CodeBleu_score": 47.603527723984875}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  return volume * simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(zIOverR, tanTheta0, sinTheta1);\n}", "CodeBleu_score": 34.05901560312574}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    return volume * simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>\n        (zIOverR, tanTheta0, sinTheta1);\n}", "CodeBleu_score": 34.82529599921821}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t  return volume * simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xBuoyancyCenterIntegrand>(zIOverR, tanTheta0, sinTheta1);\n}", "CodeBleu_score": 34.05901560312574}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dIASSERT (o1->type == dCapsuleClass);\n    dIASSERT (o2->type == dTriMeshClass);\n    dUASSERT(o1->recomputeAABB && o2->recomputeAABB,\"Capsule-TriMesh: Both geoms must have a callback for recomputing the AABB\");\n\n    dxTriMesh *TriMesh = (dxTriMesh*) o2;\n    dxCapsule *Capsule = (dxCapsule*) o1;\n\n    // Get the depth of the capsule\n    dReal depth = dGeomCapsuleGetDepth(o1);\n\n    // Get the radius of the capsule\n    dReal radius = dGeomCapsuleGetRadius(o1);\n\n    // Get the position of the capsule\n    dVector3 pos;\n    dGeomCapsuleGetParams(o1, pos, NULL);\n\n    // Get the orientation of the capsule\n    dMatrix3 R;\n    dGeomCapsuleGetAxes(o1, R);\n\n    // Get the position of the trimesh\n    dVector3 pos2;\n    dGeomGetRelPointPos(o2, pos[0], pos[1], pos[2], pos2);\n\n    // Get the rotation of the trimesh\n    dMatrix3 R2;\n    dGeomGetRelRotation(o2, R2);\n\n    // Get the rotation of the trimesh\n    dMatrix3 R3;\n    dGeomGetRotation(o1, R3);\n\n    // Get the position of the trimesh\n    dVector3 pos3;\n    dGeomGetPosition(o1, pos3);\n\n    // Get the rotation of the trimesh\n    dMatrix3 R4;\n    dGeomGetRotation(o2, R4);\n\n    // Get the rotation of the trimesh\n    dMatrix3 R5;\n    dGeomGetRotation(o1, R5);\n\n    // Get the position of the trimesh\n    dVector3 pos4;\n    dGeomGetPosition(o1, pos4);", "CodeBleu_score": 40.561226808400704}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dIASSERT (o1->type == dCapsuleClass);\n    dIASSERT (o2->type == dTriMeshClass);\n    dUASSERT (o1->body && o2->body, \"immersed bodies must be enabled\");\n\n    dxTriMesh *mesh = (dxTriMesh*) o2;\n    dxCapsule *capsule = (dxCapsule*) o1;\n\n    // get the vertices\n    const dReal *v0 = mesh->fetchVertex (mesh->triangles[immersion->triIndex].v[0]);\n    const dReal *v1 = mesh->fetchVertex (mesh->triangles[immersion->triIndex].v[1]);\n    const dReal *v2 = mesh->fetchVertex (mesh->triangles[immersion->triIndex].v[2]);\n\n    // get the normal\n    const dReal *n = mesh->fetchNormal (mesh->triangles[immersion->triIndex].normalIndex);\n\n    // get the depth\n    dReal depth = immersion->depth;\n\n    // get the radius\n    dReal radius = capsule->radius;\n\n    // calculate the volume of the hemisphere\n    dReal hemisphereVolume = M_PI * radius * radius * depth * 0.5;\n\n    // calculate the tangent of the initial angle\n    dReal tanInitialAngle = depth / radius;\n\n    // calculate the sine of the final angle\n    dReal sinFinalAngle = radius / dSqrt (radius * radius + depth * depth);\n\n    // calculate the x-coordinate of the buoyancy center\n    dReal xBuoyancyCenter = sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter (tanInitialAngle, sinFinalAngle, hemisphereVolume);\n\n    // calculate the buoyancy center\n    immersion->buoyancyCenter[0] = xBuoyancyCenter * radius;\n    immersion->buoyancyCenter[1] = 0.0;\n    immersion->buoyancyCenter[2] = 0.0;\n\n    // calculate the buoyancy force\n    immersion->buoyancyForce[", "CodeBleu_score": 37.52163161657829}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    // dUASSERT (o1->type == dCapsuleClassUser, \"The first argument is not a capsule\");\n    // dUASSERT (o2->type == dTriMeshClass, \"The second argument is not a trimesh\");\n\n    dxTriMesh *mesh = (dxTriMesh *) o2;\n    dxCapsule *capsule = (dxCapsule *) o1;\n\n    // We need to know the radius of the capsule\n    const dReal capsuleRadius = capsule->radius;\n\n    // We need to know the length of the capsule\n    const dReal capsuleLength = capsule->lz;\n\n    // We need to know the radius of the trimesh\n    const dReal meshRadius = mesh->m_p_data->m_fSphereRadius;\n\n    // We need to know the radius of the trimesh\n    const dReal meshRadius2 = meshRadius * meshRadius;\n\n    // We need to know the radius of the trimesh\n    const dReal meshRadius4 = meshRadius2 * meshRadius2;\n\n    // We need to know the radius of the trimesh\n    const dReal meshRadius8 = meshRadius4 * meshRadius4;\n\n    // We need to know the radius of the trimesh\n    const dReal meshRadius12 = meshRadius8 * meshRadius4;\n\n    // We need to know the radius of the trimesh\n    const dReal meshRadius16 = meshRadius12 * meshRadius4;\n\n    // We need to know the radius of the trimesh\n    const dReal meshRadius20 = meshRadius16 * meshRadius4;\n\n    // We need to know the radius of the trimesh\n    const dReal meshRadius24 = meshRadius20 * meshRadius4;\n\n    // We need to know the radius of the trimesh\n    const dReal meshRadius28 = meshRadius24 * meshRadius4;\n\n    // We need to know the radius of the trimesh\n    const dReal meshRadius32 = meshRadius28 * meshRadius4;\n\n    // We need to know the radius of the trimesh\n    const dReal mesh", "CodeBleu_score": 30.19474430319701}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t  // Retrieve the sleep duration in milliseconds from the input.\n  std::chrono::milliseconds sleep_duration = getInput<std::chrono::milliseconds>();\n  if (sleep_duration.count() <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING.\n  setStatus(NodeStatus::RUNNING);\n\n  // Start a timer.\n  timer_.add(sleep_duration, [this]() {\n    // Emit a wake-up signal.\n    emitWakeUpSignal();\n  });\n\n  // Set a callback to emit a wake-up signal when the timer expires.\n  timer_.setCallback(std::bind(&SleepNode::emitWakeUpSignal, this));\n\n  // If the timer is aborted, ensure the timer_waiting_ flag is reset.\n  timer_.setAbortedCallback(std::bind(&SleepNode::onAbort, this));\n\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 45.948529559830156}, {"code": "NodeStatus SleepNode::onStart(){\n\t  // Get the sleep duration in milliseconds from the input\n  std::chrono::milliseconds duration = getInput<std::chrono::milliseconds>();\n  if (!duration.count() || duration.count() < 0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n\n  // Start a timer\n  timer_.add(duration, [this]() {\n    // Emit a wake-up signal\n    emitWakeUpSignal();\n  });\n\n  // Set a callback to ensure the timer_waiting_ flag is reset if the timer is aborted\n  timer_.setAbortedCallback([this]() {\n    timer_waiting_ = false;\n  });\n\n  // Indicate that the timer is waiting\n  timer_waiting_ = true;\n\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 51.75423142328217}, {"code": "NodeStatus SleepNode::onStart(){\n\t  auto input = getInput<std::chrono::milliseconds>(\"sleep_duration\");\n  if (!input) {\n    return NodeStatus::SUCCESS;\n  }\n  if (*input <= std::chrono::milliseconds::zero()) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(Status::RUNNING);\n  timer_.add(*input, [this]() { emitWakeUpSignal(); });\n  timer_waiting_ = true;\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 43.519937593761966}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry\n\tstd::string entry_name = getInput<std::string>(\"entry_name\");\n\tauto entry = config().blackboard->getEntry(entry_name);\n\n\t// Lock the entry's mutex\n\tstd::unique_lock<std::mutex> lock(entry->mutex);\n\n\t// Check if the entry has been updated\n\tif (entry->sequence_id != entry->last_sequence_id) {\n\t\t// Update the last sequence ID\n\t\tentry->last_sequence_id = entry->sequence_id;\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 38.749134889646406}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (blackboard_ == NULL) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Retrieve the entry\n\tstd::string entry_name = getInput<std::string>(\"entry_name\");\n\tBlackboard::Entry entry = blackboard_->getEntry(entry_name);\n\n\t// Lock the entry's mutex\n\tstd::unique_lock<std::mutex> lock(entry.mutex_);\n\n\t// Compare the current sequence ID with the previously stored sequence ID\n\tif (entry.sequence_id_ != last_sequence_id_) {\n\t\t// Update the stored sequence ID\n\t\tlast_sequence_id_ = entry.sequence_id_;\n\n\t\t// Return NodeStatus::SUCCESS\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Return NodeStatus::FAILURE\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 45.12315416545422}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Get the entry from the blackboard\n\tauto entry = config().blackboard->getEntry(config().entry_name);\n\n\t// If the entry is not found, return FAILURE\n\tif (entry == nullptr) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the entry's mutex\n\tstd::lock_guard<std::mutex> lock(entry->mutex);\n\n\t// Compare the current sequence ID with the stored sequence ID\n\tif (entry->sequence_id != sequence_id_) {\n\t\t// Update the stored sequence ID\n\t\tsequence_id_ = entry->sequence_id;\n\n\t\t// Return SUCCESS\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Return FAILURE\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 46.54471104034322}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return std::max(children_nodes_.size() + success_threshold_, 0);\n    }\n    return success_threshold_;\n}", "CodeBleu_score": 55.04940828560257}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  if (success_threshold_ < 0) {\n    size_t child_count = children_nodes_.size();\n    if (child_count == 0) {\n      return 0;\n    }\n    return child_count + success_threshold_;\n  }\n  return success_threshold_;\n}", "CodeBleu_score": 51.60381671694611}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold_ < 0) {\n        return children_nodes_.size() + success_threshold_;\n    } else {\n        return success_threshold_;\n    }\n}", "CodeBleu_score": 58.057933331497004}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        if (this->heartbeat_active) {\n            auto now = std::chrono::system_clock::now();\n            if (now - this->last_heartbeat_time > std::chrono::milliseconds(this->heartbeat_timeout)) {\n                this->heartbeat_active = false;\n                this->enableAllHooks(false);\n            }\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}", "CodeBleu_score": 38.53067249373051}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (this->heartbeat_thread_active) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        if (this->server_status == SERVER_STATUS_ACTIVE) {\n            std::chrono::time_point<std::chrono::system_clock> now = std::chrono::system_clock::now();\n            std::chrono::duration<double> elapsed_seconds = now - this->last_heartbeat_time;\n            if (elapsed_seconds.count() > this->heartbeat_timeout) {\n                this->server_status = SERVER_STATUS_INACTIVE;\n                enableAllHooks(false);\n            }\n        }\n    }\n}", "CodeBleu_score": 33.610852289478636}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::chrono::time_point<std::chrono::system_clock> now = std::chrono::system_clock::now();\n        if (std::chrono::duration_cast<std::chrono::milliseconds>(now - lastHeartbeat).count() > 1000) {\n            if (heartbeatActive) {\n                heartbeatActive = false;\n                enableAllHooks(false);\n            }\n        } else {\n            if (!heartbeatActive) {\n                heartbeatActive = true;\n                enableAllHooks(true);\n            }\n        }\n    }\n}", "CodeBleu_score": 42.237819624309324}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> msgpack_bb_list;\n  std::stringstream ss(bb_list);\n  std::string bb_name;\n  while (std::getline(ss, bb_name, ',')) {\n    if (bb_name.empty()) {\n      continue;\n    }\n    std::unique_lock<std::shared_timed_mutex> lock(_p->subtrees.at(bb_name).mutex);\n    if (_p->subtrees.at(bb_name).subtree) {\n      nlohmann::json bb_json;\n      ExportBlackboardToJSON(_p->subtrees.at(bb_name).subtree->root_node->blackboard, bb_json);\n      msgpack_bb_list.insert(msgpack_bb_list.end(), nlohmann::json::to_msgpack(bb_json).begin(), nlohmann::json::to_msgpack(bb_json).end());\n    }\n  }\n  return msgpack_bb_list;\n}", "CodeBleu_score": 43.10997847697734}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<uint8_t> bb_dump;\n    nlohmann::json bb_json;\n    std::vector<std::string> bb_names = splitString(bb_list, ',');\n    for (const std::string& bb_name : bb_names) {\n        std::lock_guard<std::mutex> lock(this->subtrees_mutex);\n        auto it = this->subtrees.find(bb_name);\n        if (it != this->subtrees.end()) {\n            if (it->second.subtree_valid) {\n                bb_json[bb_name] = ExportBlackboardToJSON(it->second.subtree_ptr->root_node->blackboard);\n            }\n        }\n    }\n    bb_dump = nlohmann::json::to_msgpack(bb_json);\n    return bb_dump;\n}", "CodeBleu_score": 48.06905022554356}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> msgpack_bb;\n  std::vector<std::string> bb_names = splitString(bb_list, ',');\n  nlohmann::json bb_json;\n\n  for (const auto& bb_name : bb_names) {\n    auto it = subtrees.find(bb_name);\n    if (it != subtrees.end()) {\n      std::lock_guard<std::mutex> guard(it->second.lock);\n      if (it->second.valid) {\n        bb_json[bb_name] = ExportBlackboardToJSON(it->second.subtree->root_node->blackboard);\n      }\n    }\n  }\n  msgpack_bb = nlohmann::json::to_msgpack(bb_json);\n\n  return msgpack_bb;\n}", "CodeBleu_score": 53.9116942269413}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::unique_lock<std::mutex> lk(_p->m);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  auto hook = getHook(it->second.hook_uid);\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk2(hook->m);\n  if (hook->status != BREAKPOINT) {\n    return false;\n  }\n  hook->wakeup.setValue(result);\n  hook->remove = remove;\n  hook->status = READY;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 56.46752597215716}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::lock_guard<std::mutex> lk(_p->m);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    RCLCPP_ERROR(get_logger(), \"Node %d not found\", node_uid);\n    return false;\n  }\n  if (it->second.node == nullptr) {\n    RCLCPP_ERROR(get_logger(), \"Node %d is not valid\", node_uid);\n    return false;\n  }\n  auto hook = it->second.node->getHook();\n  if (hook == nullptr) {\n    RCLCPP_ERROR(get_logger(), \"Node %d has no hook\", node_uid);\n    return false;\n  }\n  std::lock_guard<std::mutex> lk2(hook->m);\n  if (hook->mode != BREAKPOINT) {\n    RCLCPP_ERROR(get_logger(), \"Node %d is not in breakpoint mode\", node_uid);\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->mode = READY;\n  hook->wakeup.notify_all();\n  return true;\n}", "CodeBleu_score": 58.1804788913444}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  // Find the node\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    RCLCPP_ERROR(get_logger(), \"Node %u not found\", node_uid);\n    return false;\n  }\n\n  // Get the hook\n  auto hook = getHook(it->second);\n  if (hook == nullptr) {\n    RCLCPP_ERROR(get_logger(), \"Hook not found\");\n    return false;\n  }\n\n  // Lock the hook\n  std::unique_lock<std::mutex> lk(hook->wakeup);\n\n  // Check the hook\n  if (hook->status != HookStatus::BREAKPOINT) {\n    RCLCPP_ERROR(get_logger(), \"Hook not in BREAKPOINT mode\");\n    return false;\n  }\n\n  // Set the desired status and removal flag\n  hook->result = result;\n  hook->remove = remove;\n\n  // Mark the hook as ready and notify all waiting threads\n  hook->status = HookStatus::READY;\n  hook->wakeup.notify_all();\n\n  return true;\n}", "CodeBleu_score": 61.62456447419675}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status_ == IDLE) {\n    setStatus(RUNNING);\n    halt_requested_ = false;\n    std::async(std::launch::async, [this]() {\n      try {\n        tick();\n        if (!halt_requested_) {\n          setStatus(SUCCESS);\n        }\n      } catch (std::exception& e) {\n        std::unique_lock<std::mutex> lock(mutex_);\n        exception_ = std::current_exception();\n        setStatus(IDLE);\n        std::cerr << \"[BT::\" << name_ << \"] \" << e.what() << std::endl;\n      }\n    });\n  }\n  if (exception_) {\n    std::rethrow_exception(exception_);\n  }\n  return status_;\n}", "CodeBleu_score": 47.69518828600745}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status_ == BT::IDLE) {\n    status_ = BT::RUNNING;\n    halt_requested_ = false;\n    std::async(std::launch::async, [&]() {\n      try {\n        tick();\n        if (!halt_requested_) {\n          status_ = BT::SUCCESS;\n        }\n      } catch (std::exception& e) {\n        std::stringstream ss;\n        ss << \"Exception caught in ThreadedAction: \" << e.what();\n        std::cout << ss.str() << std::endl;\n        status_ = BT::IDLE;\n      }\n      if (halt_requested_) {\n        status_ = BT::HALTED;\n      }\n      emitWakeUpSignal();\n    });\n  }\n  if (current_exception_) {\n    std::rethrow_exception(current_exception_);\n  }\n  return status_;\n}", "CodeBleu_score": 48.369092526941834}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    if (status() == IDLE) {\n        setStatus(RUNNING);\n        halt_requested_ = false;\n        std::async(std::launch::async, [this]() {\n            try {\n                tick();\n                if (!halt_requested_) {\n                    setStatus(SUCCESS);\n                }\n            } catch (...) {\n                std::exception_ptr exception = std::current_exception();\n                std::string name = this->name();\n                std::string error_msg = \"Exception caught while executing tick for action \" + name;\n                std::cout << error_msg << std::endl;\n                setStatus(IDLE);\n                std::rethrow_exception(exception);\n            }\n        });\n    }\n    if (halt_requested_) {\n        setStatus(IDLE);\n        halt_requested_ = false;\n    }\n    if (status() != RUNNING) {\n        try {\n            std::rethrow_exception(stored_exception_);\n        } catch (...) {\n            std::cout << \"Exception rethrown\" << std::endl;\n        }\n    }\n    return status();\n}", "CodeBleu_score": 49.735526416968156}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    stream << \"-------------------------------------------------------------------------\n\";\n    const auto recursivePrint = [&stream](const TreeNode* node, int depth) {\n        // indent the output based on the depth\n        for (int i = 0; i < depth; ++i) {\n            stream << \"  \";\n        }\n        stream << node->name() << \"\n\";\n        // recursively print the children\n        if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children()) {\n                recursivePrint(child.get(), depth + 1);\n            }\n        } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            recursivePrint(decorator->child(), depth + 1);\n        }\n    };\n    recursivePrint(root_node, 0);\n    stream << \"-------------------------------------------------------------------------\n\";\n}", "CodeBleu_score": 56.182829595086105}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    // The lambda function that does the printing\n    auto print_node = [&stream](const TreeNode* node, int depth) {\n        // Print the node name\n        stream << std::string(depth * 2, ' ') << node->name() << \"\n\";\n\n        // Print the children\n        if (auto control = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control->children()) {\n                print_node(child.get(), depth + 1);\n            }\n        } else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n            print_node(decorator->child(), depth + 1);\n        }\n    };\n\n    // Print the separator line and the root node\n    stream << \"---------------------------------------------------\n\";\n    print_node(root_node, 0);\n\n    // Print the separator line\n    stream << \"---------------------------------------------------\n\";\n}", "CodeBleu_score": 43.84921247816963}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto print_node = [&stream](const TreeNode* node, int depth) {\n        stream << std::string(depth, '\\t') << node->name() << '\n';\n        if (const auto* control = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control->children()) {\n                print_node(child.get(), depth + 1);\n            }\n        } else if (const auto* decorator = dynamic_cast<const DecoratorNode*>(node)) {\n            print_node(decorator->child(), depth + 1);\n        }\n    };\n\n    stream << \"---------------------------------------------------------------------------------------------------\n\";\n    print_node(root_node, 0);\n    stream << \"---------------------------------------------------------------------------------------------------\n\";\n}", "CodeBleu_score": 43.95785079769339}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t    if (!node) {\n        throw LogicError(\"The given node is null\");\n    }\n    visitor(node);\n    if (const auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n        for (const auto& child : control->children) {\n            applyRecursiveVisitor(child.get(), visitor);\n        }\n    }\n    else if (const auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n        applyRecursiveVisitor(decorator->child, visitor);\n    }\n}", "CodeBleu_score": 70.609907449275}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"applyRecursiveVisitor: nullptr passed as argument\");\n  }\n  visitor(node);\n  if (const auto* control = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : control->children) {\n      applyRecursiveVisitor(child.get(), visitor);\n    }\n  } else if (const auto* decorator = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child, visitor);\n  }\n}", "CodeBleu_score": 64.39195274634396}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"node is nullptr\");\n  }\n  visitor(node);\n  const auto control = dynamic_cast<const ControlNode*>(node);\n  if (control) {\n    for (const auto& child : control->children) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else {\n    const auto decorator = dynamic_cast<const DecoratorNode*>(node);\n    if (decorator) {\n      applyRecursiveVisitor(decorator->child, visitor);\n    }\n  }\n}", "CodeBleu_score": 64.3849986032889}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (_p->builders.find(manifest.registrationID) != _p->builders.end()) {\n        throw BehaviorTreeException(\"Builder with ID \" + manifest.registrationID +\n                                    \" already registered\");\n    }\n    _p->builders.insert(std::make_pair(manifest.registrationID, builder));\n    _p->manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 56.31700485411226}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (builders.find(manifest.registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"A builder with ID \\\"\" + manifest.registrationID + \"\\\" already exists\");\n    }\n    builders.insert(std::make_pair(manifest.registrationID, builder));\n    manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 49.5910626968629}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (_p->builders.find(manifest.registrationID) != _p->builders.end()) {\n        throw BehaviorTreeException(\"The registration ID \" + manifest.registrationID +\n                                    \" is already registered.\");\n    }\n\n    _p->builders.insert(std::make_pair(manifest.registrationID, builder));\n    _p->manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 55.018211410374576}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor](const std::string& name,\n                                      const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest(\n      ID, ActionNode::TYPE, std::move(ports), std::move(builder));\n\n  registerBuilder(manifest);\n}", "CodeBleu_score": 62.58610686434035}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor](const std::string& name,\n                                      const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n  TreeNodeManifest manifest(ActionNode, ID, std::move(ports));\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 67.5853783123302}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  registerBuilder(\n      ID, [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(name, config, tick_functor, ports);\n      });\n}", "CodeBleu_score": 47.589147323024164}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (auto& sub : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tsub->blackboard->cloneInto(bb.back());\n\t}\n\treturn bb;\n}", "CodeBleu_score": 74.27714100867776}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (int i = 0; i < tree.subtrees.size(); i++) {\n\t\tbb.push_back(Blackboard::create());\n\t\ttree.subtrees[i]->blackboard->cloneInto(bb.back());\n\t}\n\treturn bb;\n}", "CodeBleu_score": 68.59607144869197}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> bb;\n    bb.reserve(tree.subtrees.size());\n    for (const auto& sub : tree.subtrees) {\n        bb.push_back(Blackboard::create());\n        sub->blackboard->cloneInto(*bb.back());\n    }\n    return bb;\n}", "CodeBleu_score": 82.79639468928572}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor.value()(env);\n}", "CodeBleu_score": 76.94056569224894}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor.value()(env);\n}", "CodeBleu_score": 76.94056569224894}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (!executor)\n        return nonstd::make_unexpected(executor.error());\n    return executor.value()(env);\n}", "CodeBleu_score": 72.48182483964061}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n    if (loaded_) {\n        throw RuntimeError(\"Shared library already loaded\");\n    }\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle_) {\n        throw RuntimeError(\"Failed to load shared library: \" + std::string(dlerror()));\n    }\n    path_ = path;\n    loaded_ = true;\n}", "CodeBleu_score": 54.4166777652561}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    library_path = path;\n    loaded = true;\n}", "CodeBleu_score": 54.099740850563705}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (handle_) {\n    throw RuntimeError(\"SharedLibrary::load: Library already loaded\");\n  }\n\n  handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!handle_) {\n    throw RuntimeError(\"SharedLibrary::load: dlopen failed: \" + std::string(dlerror()));\n  }\n\n  path_ = path;\n}", "CodeBleu_score": 51.89380746497656}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n  StringView stripped_str = str.trim();\n  if (stripped_str.size() < 3) {\n    return false;\n  }\n  if (stripped_str[0] != '{' || stripped_str[stripped_str.size() - 1] != '}') {\n    return false;\n  }\n  if (stripped_pointer != nullptr) {\n    *stripped_pointer = stripped_str.substr(1, stripped_str.size() - 2);\n  }\n  return true;\n}", "CodeBleu_score": 28.88562017215782}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size < 3) {\n    return false;\n  }\n\n  StringView stripped_str = str.trim();\n\n  if (stripped_str.size < 3) {\n    return false;\n  }\n\n  if (stripped_str.at(0) != '{') {\n    return false;\n  }\n\n  if (stripped_str.at(stripped_str.size - 1) != '}') {\n    return false;\n  }\n\n  if (stripped_pointer != nullptr) {\n    *stripped_pointer = stripped_str.substr(1, stripped_str.size - 2);\n  }\n\n  return true;\n}", "CodeBleu_score": 27.93444804481386}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size < 3) {\n    return false;\n  }\n  StringView stripped = str.trim();\n  if (stripped.size < 3) {\n    return false;\n  }\n  if (stripped[0] != '{' || stripped[stripped.size - 1] != '}') {\n    return false;\n  }\n  if (stripped_pointer != nullptr) {\n    *stripped_pointer = stripped.substr(1, stripped.size - 2);\n  }\n  return true;\n}", "CodeBleu_score": 26.815282825355034}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    double line_cost = 0;\n    LineIterator line(x0, y0, x1, y1);\n    while (!line.isDone()) {\n        double point_cost = pointCost(line.getX(), line.getY());\n        if (point_cost < 0) {\n            return point_cost;\n        }\n        line_cost = std::max(line_cost, point_cost);\n        line.advance();\n    }\n    return line_cost;\n}", "CodeBleu_score": 64.58749124908151}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double lineCost = 0;\n  LineIterator line(x0, x1, y0, y1);\n\n  while (line.isValid()) {\n    double pointCost = pointCost(line.getX(), line.getY());\n    if (pointCost < 0) {\n      return pointCost;\n    }\n    if (pointCost > lineCost) {\n      lineCost = pointCost;\n    }\n    line.advance();\n  }\n  return lineCost;\n}", "CodeBleu_score": 61.71927763902576}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  double lineCost = 0;\n  LineIterator line(x0, x1, y0, y1);\n  while (line.isValid()) {\n    double pointCost = pointCost(line.getX(), line.getY());\n    if (pointCost < 0) {\n      return pointCost;\n    }\n    lineCost = std::max(lineCost, pointCost);\n    line.advance();\n  }\n  return lineCost;\n}", "CodeBleu_score": 58.27821517510896}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif(path.empty())\n\t\treturn;\n\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\tpath_msg.poses.resize(path.size());\n\n\tfor(unsigned int i = 0; i < path.size(); i++)\n\t\tpath_msg.poses[i] = path[i];\n\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 71.93139739050113}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if(path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses.resize(path.size());\n  for(unsigned int i=0; i < path.size(); ++i)\n    gui_path.poses[i] = path[i];\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 87.22883872503337}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if(path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses.resize(path.size());\n  for(unsigned int i=0; i < path.size(); ++i)\n    gui_path.poses[i] = path[i];\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 87.22883872503337}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n  if (base_odom.twist.twist.linear.x <= trans_stopped_velocity &&\n      base_odom.twist.twist.linear.y <= trans_stopped_velocity &&\n      base_odom.twist.twist.linear.z <= trans_stopped_velocity &&\n      base_odom.twist.twist.angular.x <= rot_stopped_velocity &&\n      base_odom.twist.twist.angular.y <= rot_stopped_velocity &&\n      base_odom.twist.twist.angular.z <= rot_stopped_velocity) {\n    return true;\n  }\n  else {\n    return false;\n  }\n}", "CodeBleu_score": 48.06109735791213}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  \n  // Check if the robot is rotating\n  if (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n    // Check if the robot is translating\n    if (abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 57.15625269162972}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n    // Check if the robot is rotating\n    if (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n        // Check if the robot is translating\n        if (abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 57.25410785635745}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\n    // If setup is not yet done, initialize the default limits with the provided configuration and set up the flag.\n    if (!setup) {\n        default_config = config;\n        setup = true;\n    }\n\n    // If setup is done and restore_defaults is requested, reset the configuration to default limits.\n    if (setup && restore_defaults) {\n        config = default_config;\n    }\n\n    // Lock the configuration mutex and update the current limits with the new configuration.\n    std::lock_guard<std::mutex> lock(config_mutex);\n    current_config = config;\n}", "CodeBleu_score": 64.64265425262242}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_) {\n    if (restore_defaults) {\n      config.horizontal_acceleration_limit = default_limits_.horizontal_acceleration_limit;\n      config.horizontal_deceleration_limit = default_limits_.horizontal_deceleration_limit;\n      config.horizontal_speed_limit = default_limits_.horizontal_speed_limit;\n      config.horizontal_backup_speed = default_limits_.horizontal_backup_speed;\n      config.vertical_acceleration_limit = default_limits_.vertical_acceleration_limit;\n      config.vertical_deceleration_limit = default_limits_.vertical_deceleration_limit;\n      config.vertical_speed_limit = default_limits_.vertical_speed_limit;\n      config.vertical_backup_speed = default_limits_.vertical_backup_speed;\n      config.tilt_acceleration_limit = default_limits_.tilt_acceleration_limit;\n      config.tilt_deceleration_limit = default_limits_.tilt_deceleration_limit;\n      config.tilt_speed_limit = default_limits_.tilt_speed_limit;\n      config.tilt_backup_speed = default_limits_.tilt_backup_speed;\n      config.yaw_acceleration_limit = default_limits_.yaw_acceleration_limit;\n      config.yaw_deceleration_limit = default_limits_.yaw_deceleration_limit;\n      config.yaw_speed_limit = default_limits_.yaw_speed_limit;\n      config.yaw_backup_speed = default_limits_.yaw_backup_speed;\n      config.max_roll_pitch_backup_speed = default_limits_.max_roll_pitch_backup_speed;\n      config.max_yaw_backup_speed = default_limits_.max_yaw_backup_speed;\n      config.max_roll_pitch_speed = default_limits_.max_roll_pitch_speed;\n      config.max_yaw_speed = default_limits_.max_", "CodeBleu_score": 27.656348273406927}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (setup && restore_defaults) {\n\t\tconfig.horizontal_speed = DEFAULT_HORIZONTAL_SPEED;\n\t\tconfig.vertical_speed = DEFAULT_VERTICAL_SPEED;\n\t\tconfig.yaw_rate = DEFAULT_YAW_RATE;\n\t\tconfig.upward_speed = DEFAULT_UPWARD_SPEED;\n\t\tconfig.downward_speed = DEFAULT_DOWNWARD_SPEED;\n\t}\n\tif (!setup) {\n\t\tdefault_limits.horizontal_speed = config.horizontal_speed;\n\t\tdefault_limits.vertical_speed = config.vertical_speed;\n\t\tdefault_limits.yaw_rate = config.yaw_rate;\n\t\tdefault_limits.upward_speed = config.upward_speed;\n\t\tdefault_limits.downward_speed = config.downward_speed;\n\t\tsetup = true;\n\t}\n\tlock_guard<mutex> limits_lock(limits_mutex);\n\tcurrent_limits.horizontal_speed = config.horizontal_speed;\n\tcurrent_limits.vertical_speed = config.vertical_speed;\n\tcurrent_limits.yaw_rate = config.yaw_rate;\n\tcurrent_limits.upward_speed = config.upward_speed;\n\tcurrent_limits.downward_speed = config.downward_speed;\n}", "CodeBleu_score": 42.33566226137893}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  // check if the cell is an obstacle or has no information\n  if (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::LETHAL_OBSTACLE) {\n    // if it is, set the target distance to the maximum obstacle cost and return false\n    current_cell->target_dist = obstacleCosts::MAX_OBSTACLE_DIST;\n    return false;\n  }\n\n  // calculate the new target distance\n  float new_target_dist = current_cell->target_dist + calculateDistance(current_cell, check_cell);\n\n  // if the new target distance is shorter, update the cell's target distance\n  if (new_target_dist < current_cell->target_dist) {\n    current_cell->target_dist = new_target_dist;\n  }\n\n  // return true\n  return true;\n}", "CodeBleu_score": 48.948509573602806}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  //check the cost of the cell using the costmap\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\n  //if the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false\n  if(cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION){\n    check_cell->target_dist = obstacleCosts;\n    return false;\n  }\n\n  //otherwise calculate a new target distance and update the cell's target distance if the new distance is shorter\n  double new_target_dist = current_cell->target_dist + (1.0 - ((double) cost / (double) costmap_2d::FREE_SPACE));\n  if(new_target_dist < check_cell->target_dist){\n    check_cell->target_dist = new_target_dist;\n  }\n\n  return true;\n}", "CodeBleu_score": 69.30162164243463}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  // check that the cell is valid\n  if (!check_cell->valid(costmap)) {\n    current_cell->target_dist = costmap.getCost(check_cell->x, check_cell->y);\n    return false;\n  }\n\n  // calculate the target distance of the cell\n  double new_target_dist = current_cell->target_dist + check_cell->dist;\n\n  // check that the new target distance is better than the current target distance\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 53.92316599086552}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  // Initialize the cost and scaling factor\n  double cost = 0.0;\n  double scaling_factor = getScalingFactor(traj);\n\n  // If the footprint spec is empty, log an error and return -9\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"Footprint spec is empty. Cannot calculate footprint cost.\");\n    return -9;\n  }\n\n  // For each point in the trajectory, calculate the footprint cost\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    // Get the point\n    const Point& point = traj.getPoint(i);\n\n    // Calculate the footprint cost\n    double footprint_cost = footprintCost(point.x, point.y, point.theta, scaling_factor);\n\n    // If the footprint cost is negative, return the cost immediately\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    // Otherwise, sum the scores or take the maximum score based on the sum_scores_ flag\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  // Return the total cost\n  return cost;\n}", "CodeBleu_score": 58.05042730685215}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scaling_factor = 1.0;\n  initializeCost(traj, cost, scaling_factor);\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"The footprint spec is empty. Please call setFootprintSpec before using the ObstacleCostFunction.\");\n    return -9;\n  }\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj, i);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += scaling_factor * footprint_cost;\n    } else {\n      cost = std::max(cost, scaling_factor * footprint_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 55.16163241244696}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scaling_factor = 1;\n\n  // Initialize the cost and scaling factor based on the trajectory and speed parameters\n  initTrajectoryCost(traj, cost, scaling_factor);\n\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"The footprint specification is empty. Please set the footprint_specification parameter.\");\n    return -9;\n  }\n\n  // Iterate through each point in the trajectory\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    // Calculate the footprint cost\n    double footprint_cost = footprintCost(traj, i, scaling_factor);\n\n    // If the footprint cost is negative, return the cost immediately\n    if (footprint_cost < 0) {\n      return cost;\n    }\n\n    // Either sum the scores or take the maximum score based on the sum_scores_ flag\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  // Return the total cost\n  return cost;\n}", "CodeBleu_score": 57.241439894112666}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t    // get the map coordinates of the robot\n    unsigned int mx, my;\n    if (!costmap->worldToMap(x, y, mx, my))\n        return -7.0;\n\n    // scale the footprint\n    std::vector<geometry_msgs::Point> scaled_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        geometry_msgs::Point p;\n        p.x = scale * footprint_spec[i].x;\n        p.y = scale * footprint_spec[i].y;\n        scaled_footprint.push_back(p);\n    }\n\n    // calculate the oriented footprint in world coordinates\n    std::vector<geometry_msgs::Point> oriented_footprint;\n    if (!ObstacleCostFunction::rotateFootprint(scaled_footprint, th, oriented_footprint))\n        return -6.0;\n\n    // check if the footprint is outside the map boundary\n    for (unsigned int i = 0; i < oriented_footprint.size(); i++) {\n        unsigned int x0, y0;\n        if (!costmap->worldToMap(oriented_footprint[i].x, oriented_footprint[i].y, x0, y0))\n            return -7.0;\n    }\n\n    // calculate the cost of the footprint\n    double footprint_cost = world_model->footprintCost(oriented_footprint, costmap);\n\n    // calculate the cost of the cell\n    unsigned char cost = costmap->getCost(mx, my);\n\n    // return the maximum of the two\n    return std::max(footprint_cost, cost);\n}", "CodeBleu_score": 64.17711737609544}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  scaled_footprint.push_back(geometry_msgs::Point());\n\n  // scale footprint and rotate\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    scaled_footprint[i].x = footprint_spec[i].x * scale;\n    scaled_footprint[i].y = footprint_spec[i].y * scale;\n    scaled_footprint[i].z = 0.0;\n  }\n\n  // check if the footprint is outside the map boundaries\n  for (unsigned int i = 0; i < scaled_footprint.size(); i++) {\n    unsigned int cell_x, cell_y;\n    if (!costmap->worldToMap(x + scaled_footprint[i].x, y + scaled_footprint[i].y, cell_x, cell_y)) {\n      return -7.0;\n    }\n  }\n\n  // check if the footprint is legal\n  double footprint_cost = world_model->footprintCost(scaled_footprint, x, y, th);\n\n  // check if the cell is legal\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n\n  unsigned char cost = costmap->getCost(mx, my);\n\n  // return the higher cost of footprint or cell\n  return std::max(footprint_cost, cost);\n}", "CodeBleu_score": 65.93947934222291}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  // Scale the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point pt;\n    pt.x = footprint_spec[i].x * scale;\n    pt.y = footprint_spec[i].y * scale;\n    scaled_footprint.push_back(pt);\n  }\n\n  // Rotate the footprint into the map frame\n  std::vector<geometry_msgs::Point> rotated_footprint;\n  if (!rotated_footprint.empty())\n    rotated_footprint.clear();\n  for (unsigned int i = 0; i < scaled_footprint.size(); ++i) {\n    geometry_msgs::Point pt;\n    pt.x = scaled_footprint[i].x * cos(th) - scaled_footprint[i].y * sin(th);\n    pt.y = scaled_footprint[i].x * sin(th) + scaled_footprint[i].y * cos(th);\n    rotated_footprint.push_back(pt);\n  }\n\n  // Translate the footprint into the map frame\n  std::vector<geometry_msgs::Point> translated_footprint;\n  if (!translated_footprint.empty())\n    translated_footprint.clear();\n  for (unsigned int i = 0; i < rotated_footprint.size(); ++i) {\n    geometry_msgs::Point pt;\n    pt.x = rotated_footprint[i].x + x;\n    pt.y = rotated_footprint[i].y + y;\n    translated_footprint.push_back(pt);\n  }\n\n  // Check if the footprint is outside the map boundaries\n  for (unsigned int i = 0; i < translated_footprint.size(); ++i) {\n    if (translated_footprint[i].x < costmap->getOriginX() ||\n        translated_footprint[i].y < costmap->getOriginY() ||\n        translated_", "CodeBleu_score": 48.01275554524283}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic, 10, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 44.5523592842077}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    if (odom_topic != odom_topic_) {\n        odom_topic_ = odom_topic;\n        if (!odom_topic_.empty()) {\n            odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n        } else {\n            odom_sub_.shutdown();\n        }\n    }\n}", "CodeBleu_score": 53.854787677458305}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.90579232493761}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// Calculate the squared distance and the angular difference\n\tEigen::Vector3f diff = pos - prev;\n\tfloat squaredDistance = diff.dot(diff);\n\tfloat angle = acos(fabs(diff.normalized().dot(prev.normalized())));\n\n\t// If the squared distance exceeds a threshold or the angular difference is greater than a set angle, it resets the oscillation flags\n\tif (squaredDistance > oscillationDistanceThreshold * oscillationDistanceThreshold || angle > oscillationAngleThreshold) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 38.91745221448321}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    float dist = (pos - prev).squaredNorm();\n    float angle = acos(pos.normalized().dot(prev.normalized()));\n    if (dist > m_maxDistance || angle > m_maxAngle) {\n        resetOscillationFlags();\n    }\n}", "CodeBleu_score": 30.134721094236976}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    float dist = (pos - prev).squaredNorm();\n    float angle = acos(pos.dot(prev) / (pos.norm() * prev.norm()));\n    if (dist > 1000000000 || angle > M_PI / 4) {\n        resetOscillationFlags();\n    }\n}", "CodeBleu_score": 32.82401893083284}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    // calculate grid coordinates of point\n    int x_coord = (int)((pt.x - x_min) / cell_width);\n    int y_coord = (int)((pt.y - y_min) / cell_width);\n    // check if point is outside grid bounds\n    if (x_coord < 0 || x_coord >= grid_width || y_coord < 0 || y_coord >= grid_height) {\n        return;\n    }\n    // check if point is too close to its nearest neighbor\n    if (nearestNeighborDistance(pt) < min_distance) {\n        return;\n    }\n    // calculate grid index\n    int grid_index = gridIndex(x_coord, y_coord);\n    // insert point into grid\n    cells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 48.240746008699844}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    // Calculate grid coordinates of the point\n    int x = (int)floor((pt.x - x_min_) / grid_size_);\n    int y = (int)floor((pt.y - y_min_) / grid_size_);\n\n    // Check if the point is too close to its nearest neighbor\n    if (nearestNeighborDistance(pt, x, y) < min_dist_) {\n        return;\n    }\n\n    // Check if the point is within the grid bounds\n    if (x < 0 || x >= x_cells_ || y < 0 || y >= y_cells_) {\n        return;\n    }\n\n    // Calculate grid index\n    int grid_index = x + y * x_cells_;\n\n    // Insert point into the corresponding cell\n    cells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 45.97558980991047}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// Calculate the grid coordinates of the point\n\tint x_coord = (int)floor((pt.x - x_min_) / cell_size_);\n\tint y_coord = (int)floor((pt.y - y_min_) / cell_size_);\n\tint z_coord = (int)floor((pt.z - z_min_) / cell_size_);\n\t// If the coordinates are outside the grid bounds, return\n\tif (x_coord < 0 || y_coord < 0 || z_coord < 0 || x_coord >= x_cell_count_ || y_coord >= y_cell_count_ || z_coord >= z_cell_count_) {\n\t\treturn;\n\t}\n\t// If the point is too close to its nearest neighbor, return\n\tif (nearestNeighborDistance(pt) < min_distance_) {\n\t\treturn;\n\t}\n\t// Calculate the grid index\n\tint index = x_coord + y_coord * x_cell_count_ + z_coord * x_cell_count_ * y_cell_count_;\n\t// Insert the point into the corresponding cell\n\tcells_[index].push_back(pt);\n}", "CodeBleu_score": 44.367356949780834}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n    for (int i = 0; i < 3; i++) {\n        if (vel[i] < sample_target_vel[i]) {\n            new_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n        } else if (vel[i] > sample_target_vel[i]) {\n            new_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n        } else {\n            new_vel[i] = vel[i];\n        }\n    }\n\n    return new_vel;\n}", "CodeBleu_score": 77.00401221531709}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n        } else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n        } else {\n            new_vel[i] = vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 78.51011259106136}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n        }\n        else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n        }\n        else {\n            new_vel[i] = vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 77.84251739841056}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  double diff = DBL_MAX;\n  double angle = 0;\n  int goal_x, goal_y;\n  for (int i = (int)global_plan_.size() - 1; i >= 0; i--) {\n    goal_x = (int)global_plan_[i].pose.position.x;\n    goal_y = (int)global_plan_[i].pose.position.y;\n    if (costmap_.worldToMap(goal_x, goal_y, goal_x, goal_y)) {\n      if (costmap_.mapToWorld(cell_x, cell_y, x, y)) {\n        if (lineCost(cell_x, cell_y, goal_x, goal_y) < 100) {\n          angle = angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x));\n          if (fabs(angle) < diff) {\n            diff = fabs(angle);\n          }\n        }\n      }\n    }\n  }\n  return diff;\n}", "CodeBleu_score": 61.81374971990512}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double diff;\n  double x_goal, y_goal;\n  double goal_x, goal_y;\n  int goal_cell_x, goal_cell_y;\n  double angle;\n  double angle_to_goal;\n  double angle_to_goal_difference;\n  double angle_to_goal_difference_absolute;\n  double angle_to_goal_difference_absolute_min = DBL_MAX;\n  double angle_to_goal_difference_absolute_min_angle = 0;\n\n  // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell.\n  for (int i = (int)global_plan_.size() - 1; i >= 0; i--) {\n    // Convert the goal cell coordinates to world coordinates\n    goal_x = global_plan_[i].pose.position.x;\n    goal_y = global_plan_[i].pose.position.y;\n    costmap_.worldToMap(goal_x, goal_y, goal_cell_x, goal_y);\n\n    // If the goal cell is not within the costmap, or if the goal cell is not valid, continue to the next point in the global plan\n    if (!costmap_.cellValid(goal_cell_x, goal_cell_y))\n      continue;\n    if (!costmap_.cellSafe(goal_cell_x, goal_y))\n      continue;\n\n    // If the robot's current cell is not within the costmap, or if the robot's current cell is not valid, return DBL_MAX\n    if (!costmap_.cellValid(cell_x, cell_y))\n      return DBL_MAX;\n    if (!costmap_.cellSafe(cell_x, cell_y))\n      return DBL_MAX;\n\n    // If the goal cell is not within the robot's FOV, continue to the next point in the global plan\n    if (!costmap_.cellInsideFOV(cell_x, cell_y, goal_cell_x, goal_cell_y))\n      continue;\n\n    // If the goal cell is not within the robot's", "CodeBleu_score": 49.170021792324334}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double diff = DBL_MAX;\n  double angle = 0;\n  double diff_angle = 0;\n  double angle_to_goal = 0;\n  double diff_angle_to_goal = 0;\n  double angle_to_goal_rad = 0;\n  double diff_angle_to_goal_rad = 0;\n  double angle_rad = 0;\n  double diff_angle_rad = 0;\n  double goal_x = 0;\n  double goal_y = 0;\n  double goal_x_cell = 0;\n  double goal_y_cell = 0;\n  double goal_x_world = 0;\n  double goal_y_world = 0;\n  double current_x_world = 0;\n  double current_y_world = 0;\n  double current_x_cell = 0;\n  double current_y_cell = 0;\n  double current_x = 0;\n  double current_y = 0;\n  double current_heading = 0;\n  int goal_x_cell_int = 0;\n  int goal_y_cell_int = 0;\n  int goal_index = 0;\n  int goal_index_temp = 0;\n  int goal_index_temp_old = 0;\n  int goal_index_old = 0;\n  int goal_index_old_old = 0;\n  int goal_index_old_old_old = 0;\n  int goal_index_old_old_old_old = 0;\n  int goal_index_old_old_old_old_old = 0;\n  int goal_index_old_old_old_old_old_old = 0;\n  int goal_index_old_old_old_old_old_old_old = 0;\n  int goal_index_old_old_old_old_old_old_old_old = 0;\n  int goal_index_old_old_old_old_old_old_old_old_old = 0;\n  int goal_index_old_old_old_old_old", "CodeBleu_score": 8.966965169778774}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n        ROS_WARN(\"Trajectory is invalid: (%f, %f, %f, %f, %f, %f, %f, %f, %f) cost: %f\",\n                x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 74.46445567063232}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t   double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n   if (cost < 0) {\n      ROS_WARN(\"Trajectory invalid! Cost: %f\", cost);\n      ROS_WARN(\"vx: %f, vy: %f, vtheta: %f\", vx_samp, vy_samp, vtheta_samp);\n      return false;\n   }\n   return true;\n}", "CodeBleu_score": 73.66447884592104}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0) {\n        return true;\n    } else {\n        ROS_WARN(\"Trajectory rejected with cost: %f, sample velocities: [%f, %f, %f]\", cost, vx_samp, vy_samp, vtheta_samp);\n        return false;\n    }\n}", "CodeBleu_score": 77.48748014349441}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  if (global_costmap_ == nullptr) {\n    ROS_ERROR(\"The global_costmap_ pointer is NULL. Make sure you set it to a valid Costmap2DROS object before using this planner\");\n    return;\n  }\n\n  if (local_costmap_ == nullptr) {\n    ROS_ERROR(\"The local_costmap_ pointer is NULL. Make sure you set it to a valid Costmap2DROS object before using this planner\");\n    return;\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing the area outside of the clearing region\");\n  } else {\n    ROS_WARN(\"Clearing the area inside of the clearing region\");\n  }\n\n  if (affected_maps_ == AFFECTED_MAPS_GLOBAL) {\n    global_costmap_->clearNonLethalWindow(clearing_radius_, clearing_center_, invert_area_to_clear_);\n    global_costmap_->updateMap(clearing_center_.x, clearing_center_.y, clearing_radius_, true);\n    ROS_DEBUG(\"Clearing the global costmap took %.3f ms\", (ros::WallTime::now() - t0).toSec() * 1000.0);\n  } else if (affected_maps_ == AFFECTED_MAPS_LOCAL) {\n    local_costmap_->clearNonLethalWindow(clearing_radius_, clearing_center_, invert_area_to_clear_);\n    local_costmap_->updateMap(clearing_center_.x, clearing_center_.y, clearing_radius_, true);\n    ROS_DEBUG(\"Clearing the local costmap took %.3f ms\", (ros::WallTime::now() - t0).toSec() * 1000.0);\n", "CodeBleu_score": 49.17375882458595}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  if (global_costmap_ == nullptr || local_costmap_ == nullptr) {\n    ROS_ERROR(\"The costmap pointer is null. This is probably a bug. Fix it.\");\n    return;\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_ == AFFECTED_MAPS::AFFECTED_MAPS_GLOBAL) {\n    if (invert_area_to_clear_) {\n      ROS_WARN(\"Clearing the global costmap inside the specified area\");\n    } else {\n      ROS_WARN(\"Clearing the global costmap outside the specified area\");\n    }\n\n    global_costmap_->clearNonLethalWindow(x_, y_, width_, height_, invert_area_to_clear_);\n\n    if (force_update_) {\n      global_costmap_->updateMap();\n    }\n\n    ROS_DEBUG(\"Clearing the global costmap took %.3f ms\", (ros::WallTime::now() - t0).toSec() * 1000.0);\n  } else if (affected_maps_ == AFFECTED_MAPS::AFFECTED_MAPS_LOCAL) {\n    if (invert_area_to_clear_) {\n      ROS_WARN(\"Clearing the local costmap inside the specified area\");\n    } else {\n      ROS_WARN(\"Clearing the local costmap outside the specified area\");\n    }\n\n    local_costmap_->clearNonLethalWindow(x_, y_, width_, height_, invert_area_to_clear_);\n\n    if (force_update_) {\n      local_costmap_->updateMap();\n    }\n\n    ROS_DEBUG(\"Clearing the local costmap took %.3f ms\", (ros::WallTime::now() - t0).toSec() * 1000.0);\n  } else if (affected_", "CodeBleu_score": 55.26004605647139}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if(!initialized_){\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if(global_costmap_ == NULL){\n    ROS_ERROR(\"The global costmap must be set before this object can run\");\n    return;\n  }\n\n  if(local_costmap_ == NULL){\n    ROS_ERROR(\"The local costmap must be set before this object can run\");\n    return;\n  }\n\n  if(affected_maps_ == AFFECTED_MAPS_GLOBAL || affected_maps_ == AFFECTED_MAPS_BOTH){\n    if(invert_area_to_clear_){\n      ROS_WARN(\"Clearing the global costmap inside the area specified by the footprint\");\n    }\n    else{\n      ROS_WARN(\"Clearing the global costmap outside the area specified by the footprint\");\n    }\n    ros::WallTime t0 = ros::WallTime::now();\n    global_costmap_->clearNonLethalWindow(global_x_, global_y_, global_width_, global_height_, invert_area_to_clear_, force_update_);\n    ROS_DEBUG(\"It took %.6f seconds to clear the global costmap\", (ros::WallTime::now() - t0).toSec());\n  }\n\n  if(affected_maps_ == AFFECTED_MAPS_LOCAL || affected_maps_ == AFFECTED_MAPS_BOTH){\n    if(invert_area_to_clear_){\n      ROS_WARN(\"Clearing the local costmap inside the area specified by the footprint\");\n    }\n    else{\n      ROS_WARN(\"Clearing the local costmap outside the area specified by the footprint\");\n    }\n    ros::WallTime t0 = ros::WallTime::now();\n    local_costmap_->clearNonLethalWindow(local_x_, local_y_, local_width_, local_height_, invert_area_to_clear_, force_update_);\n    ROS_DEBUG(\"It took %.6f seconds to clear the local cost", "CodeBleu_score": 53.57734913006982}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  polygon_cells.clear();\n  if (polygon.empty())\n    return;\n\n  // Iterate through polygon vertices\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n  }\n\n  // Close the polygon\n  raytraceLine(polygon.back(), polygon.front(), polygon_cells);\n}", "CodeBleu_score": 44.66658323797645}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  polygon_cells.clear();\n\n  if (polygon.empty())\n    return;\n\n  std::vector<MapLocation> polygon_cells_temp;\n  polygon_cells_temp.reserve(polygon.size() * 2);\n\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], polygon_cells_temp);\n  }\n\n  // close the polygon\n  raytraceLine(polygon.back(), polygon.front(), polygon_cells_temp);\n\n  // remove duplicates\n  std::sort(polygon_cells_temp.begin(), polygon_cells_temp.end());\n  std::unique_copy(polygon_cells_temp.begin(), polygon_cells_temp.end(), std::back_inserter(polygon_cells));\n}", "CodeBleu_score": 51.87274495733125}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells polygon_cells_obj;\n  polygon_cells_obj.empty = true;\n  polygon_cells_obj.size = 0;\n\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], polygon_cells_obj);\n  }\n\n  if (!polygon_cells_obj.empty) {\n    raytraceLine(polygon[polygon.size() - 1], polygon[0], polygon_cells_obj);\n  }\n\n  polygon_cells.swap(polygon_cells_obj.cells);\n}", "CodeBleu_score": 56.37388964420629}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  // Set up the grid data\n  prepareGrid();\n\n  // Publish the grid data\n  pub.publish(grid_);\n}", "CodeBleu_score": 98.05533239138548}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  //lock the costmap mutex\n  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n  //get the map resolution\n  double resolution = costmap_->getResolution();\n\n  //set the header information of the grid\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n\n  //set the size of the grid\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  //convert the origin of the costmap to world coords\n  costmap_->mapToWorld(costmap_->getOriginX(), costmap_->getOriginY(), grid_.info.origin.position.x, grid_.info.origin.position.y);\n\n  //save the origin for later use\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n\n  //resize the grid to match the size of the costmap\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  //fill the costmap with the static map\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    grid_.data[i] = costmap_->getCharMap()[i] == costmap_2d::LETHAL_OBSTACLE ? 100 : 0;\n  }\n}", "CodeBleu_score": 62.36872946850603}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // lock the costmap mutex\n  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n  // get the costmap resolution\n  double resolution = costmap_->getResolution();\n\n  // set the grid's header information\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n\n  // set the grid's size\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // convert the map coordinates to world coordinates for the origin\n  costmap_->mapToWorld(0.0, 0.0, grid_.info.origin.position.x, grid_.info.origin.position.y);\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // save the origin coordinates\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n\n  // resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = costmap_->getCharMap()[costmap_->getCharMap()[i]];\n  }\n}", "CodeBleu_score": 64.11554968040899}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  std::lock_guard<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n  // get the map resolution\n  double resolution = costmap_->getResolution();\n\n  // populate the grid\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = resolution;\n\n  unsigned int cells_x = costmap_->getSizeInCellsX(), cells_y = costmap_->getSizeInCellsY();\n  grid_.info.width = cells_x;\n  grid_.info.height = cells_y;\n\n  // get the origin of the costmap\n  double origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n  grid_.info.origin.position.x = origin_x;\n  grid_.info.origin.position.y = origin_y;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // save the origin for later use in the worldToMap function\n  origin_x_ = origin_x;\n  origin_y_ = origin_y;\n\n  // resize the grid's data\n  grid_.data.resize(cells_x * cells_y);\n\n  // copy the costmap data into the grid\n  unsigned char* costmap_array = costmap_->getCharMap();\n  unsigned char* grid_array = &grid_.data[0];\n  for (unsigned int i = 0; i < cells_x * cells_y; i++) {\n    // convert the costmap value to a value for the grid\n    *grid_array = costmap_2_ros::cost_translation_table[*costmap_array];\n    costmap_array++;\n    grid_array++;\n  }\n}", "CodeBleu_score": 62.143868988790565}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // If the footprint and radius are the same, we can skip this\n  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n    return;\n\n  // If the footprint is the same as the old one, we can skip this\n  if (new_config.footprint == old_config.footprint) {\n    makeFootprintFromRadius(new_config.robot_radius);\n    return;\n  }\n\n  // If we have a valid footprint string, we'll use it\n  if (makeFootprintFromString(new_config.footprint))\n    return;\n\n  // If we don't have a valid footprint string, we'll use the radius\n  makeFootprintFromRadius(new_config.robot_radius);\n}", "CodeBleu_score": 48.24824611442817}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint && new_config.footprint_radius == old_config.footprint_radius)\n    return;\n\n  if (!new_config.footprint.empty()) {\n    if (makeFootprintFromString(new_config.footprint)) {\n      ROS_INFO(\"Updated footprint to a polygon with %zu vertices from the parameter server\", footprint_.size());\n    } else {\n      ROS_ERROR(\"The footprint string from the parameter server was unacceptable. Your robot will continue to use its \"\n                \"previous footprint.\");\n    }\n  } else {\n    if (makeFootprintFromRadius(new_config.footprint_radius)) {\n      ROS_INFO(\"Updated footprint to a circle with radius %.2f from the parameter server\",\n               new_config.footprint_radius);\n    } else {\n      ROS_ERROR(\"The footprint radius from the parameter server was unacceptable. Your robot will continue to use its \"\n                \"previous footprint.\");\n    }\n  }\n}", "CodeBleu_score": 53.18346726594611}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n    return;\n\n  if (new_config.footprint.empty()) {\n    if (new_config.robot_radius <= 0) {\n      ROS_ERROR(\"Invalid robot radius specified in the configuration (%f), the robot footprint cannot be determined.\",\n                new_config.robot_radius);\n      return;\n    }\n    makeFootprintFromRadius(new_config.robot_radius, footprint_);\n  } else {\n    if (!makeFootprintFromString(new_config.footprint, footprint_)) {\n      ROS_ERROR(\"Invalid robot footprint specified in the configuration (%s), the robot footprint cannot be determined.\",\n                new_config.footprint.c_str());\n      return;\n    }\n  }\n\n  ROS_DEBUG(\"Setting the robot footprint to a %zu vertex polygon\", footprint_.size());\n\n  // we need to update the costmap's size\n  unsigned int old_size_x = size_x_, old_size_y = size_y_;\n  updateSize();\n  unsigned int new_size_x = size_x_, new_size_y = size_y_;\n\n  // we need to update the origin of the costmap\n  double old_origin_x = origin_x_, old_origin_y = origin_y_;\n  updateOrigin(0.0, 0.0);\n  double new_origin_x = origin_x_, new_origin_y = origin_y_;\n\n  // we need to update the bounds of the costmap\n  updateBounds(min_x_, min_y_, max_x_, max_y_);\n\n  // we need to update the costmap's starting cell\n  unsigned int old_cell_x = start_x_, old_cell_y = start_y_;\n  updateStartCell();\n  unsigned int new_cell_x = start_x_, new_cell_y = start_y_;\n\n  // we need to update the costmap's resolution\n  double old_resolution = resolution_, old_inv_", "CodeBleu_score": 50.11979604842944}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t    if (!getRobotPose()) {\n        ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration.\");\n        cancelReconfigure();\n    }\n}", "CodeBleu_score": 35.13172927519332}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  /*\n   * Get the current robot pose.\n   */\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\n    reconfigure_thread_->cancel();\n    return;\n  }\n\n  /*\n   * If the robot has moved, update the costmap and reconfigure the costmap if necessary.\n   */\n  if (std::fabs(new_pose.x - robot_pose_.x) > 0.001 || std::fabs(new_pose.y - robot_pose_.y) > 0.001 || std::fabs(new_pose.theta - robot_pose_.theta) > 0.001) {\n    robot_pose_ = new_pose;\n    updateMap();\n    reconfigure();\n  }\n}", "CodeBleu_score": 62.08863846904967}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  geometry_msgs::PoseStamped new_pose;\n  try {\n    if (tf_->waitForTransform(global_frame_, robot_base_frame_, ros::Time(0), ros::Duration(1.0))) {\n      tf_->lookupTransform(global_frame_, robot_base_frame_, ros::Time(0), transform_);\n      tf::poseTFToMsg(transform_, new_pose.pose);\n      new_pose.header.frame_id = global_frame_;\n      new_pose.header.stamp = ros::Time::now();\n      robot_pose_ = new_pose;\n    }\n  } catch (tf::TransformException &ex) {\n    ROS_WARN(\"Costmap2DROS: %s\", ex.what());\n    return;\n  }\n}", "CodeBleu_score": 43.70261597207695}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  boost::unique_lock<boost::recursive_mutex> lock(configuration_mutex_);\n  if (stopped_) {\n    ROS_INFO(\"[%s] Resuming costmap updates\", name_.c_str());\n    stopped_ = false;\n    stop_updates_ = false;\n    std::vector<boost::shared_ptr<Layer> >::iterator plugin_iter;\n    for (plugin_iter = plugins_.begin(); plugin_iter != plugins_.end(); ++plugin_iter) {\n      (*plugin_iter)->activate();\n    }\n    while (!initialized_ || !map_update_thread_->isRunning()) {\n      ros::Duration(0.01).sleep();\n    }\n  }\n}", "CodeBleu_score": 48.80716390165247}, {"code": "void Costmap2DROS::start(){\n\t  if (stopped_) {\n    ROS_INFO(\"Reactivating plugins.\");\n    std::vector<boost::shared_ptr<Layer> > plugins = layered_costmap_->getPlugins();\n    for (unsigned int i = 0; i < plugins.size(); ++i) {\n      plugins[i]->activate();\n    }\n    stopped_ = false;\n  }\n  stop_updates_ = false;\n  while (!ros::ok() || !layered_costmap_->isInitialized() || !map_update_thread_) {\n    ros::Duration(0.1).sleep();\n  }\n}", "CodeBleu_score": 58.15887257153185}, {"code": "void Costmap2DROS::start(){\n\t  //re-subscribe to topics if we were stopped\n  if (stopped_) {\n    ROS_DEBUG_NAMED(\"costmap\", \"Reactivating plugins\");\n    plugins_->reconfigurePlugins();\n    plugins_->activate();\n    stopped_ = false;\n  }\n  stop_updates_ = false;\n\n  //wait for the costmap to be initialized\n  while (ros::ok() && !initialized_ && !stopped_) {\n    ros::Duration(0.01).sleep();\n  }\n\n  //wait for the map update thread to start\n  while (ros::ok() && !map_update_thread_ && !stopped_) {\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 51.87405794654521}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0)) {\n    if (observation_list_.size() > 1) {\n      ROS_DEBUG_NAMED(\"global_planner\", \"Purging all old costmap observations\");\n      observation_list_.erase(observation_list_.begin(), --(observation_list_.end()));\n    }\n  } else {\n    ROS_DEBUG_NAMED(\"global_planner\", \"Purging old costmap observations\");\n    for (std::list<Observation>::iterator it = observation_list_.begin(); it != observation_list_.end(); ) {\n      if (ros::Time::now() - it->obs_time_ >= observation_keep_time_) {\n        it = observation_list_.erase(it);\n      } else {\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 49.905782385341965}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    // keep most recent observation\n    if (observation_list_.size() > 1) {\n      observation_list_.erase(observation_list_.begin(),\n                              observation_list_.end() - 1);\n    }\n  } else {\n    // keep observations that are newer than the keep time\n    ros::Time latest_time = ros::Time::now() - observation_keep_time_;\n    for (ObservationList::iterator it = observation_list_.begin();\n         it != observation_list_.end(); ++it) {\n      if (it->header.stamp > latest_time) {\n        // first valid observation, so stop\n        break;\n      }\n      // else, observation is too old, so erase it\n      it = observation_list_.erase(it);\n    }\n  }\n}", "CodeBleu_score": 51.64039192379381}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_.toSec() > 0.0) {\n    ros::Time oldest_allowed_time = ros::Time::now() - observation_keep_time_;\n    for (ObservationList::iterator it = observation_list_.begin(); it != observation_list_.end(); ++it) {\n      if (it->header.stamp > oldest_allowed_time) {\n        break;\n      }\n    }\n    observation_list_.erase(observation_list_.begin(), it);\n  } else {\n    if (!observation_list_.empty()) {\n      observation_list_.erase(observation_list_.begin(), std::prev(observation_list_.end()));\n    }\n  }\n}", "CodeBleu_score": 42.65605599321737}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  if (end_index <= start_index) {\n    return;\n  }\n\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  double angle_increment = angles::shortest_angular_distance(start_yaw, end_yaw) / (end_index - start_index);\n\n  for (int i = start_index; i < end_index; i++) {\n    double angle = start_yaw + angle_increment * (i - start_index);\n    set_angle(path[i], angle);\n  }\n}", "CodeBleu_score": 62.81313481070002}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n    // Get the yaw angle at the start and end indices\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Get the shortest angular distance between the start and end yaw angles\n    double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Calculate the incremental change in angle for each pose\n    double incremental_change = delta_yaw / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index; i <= end_index; i++) {\n        path[i].pose.orientation = set_angle(path[i].pose.orientation, start_yaw + (incremental_change * (i - start_index)));\n    }\n}", "CodeBleu_score": 64.427500756547}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t    ROS_DEBUG_STREAM(\"Interpolating Orientation: \" << start_index << \" to \" << end_index);\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n    double angle_change = angles::shortest_angular_distance(start_yaw, end_yaw);\n    double angle_increment = angle_change / (end_index - start_index);\n    double current_angle = start_yaw;\n\n    for (int i = start_index; i < end_index; i++) {\n        current_angle += angle_increment;\n        set_angle(path[i], current_angle);\n    }\n}", "CodeBleu_score": 62.053652070838375}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\n  ROS_DEBUG(\"makePlanService: start: %.2f, %.2f goal: %.2f %.2f\", req.start.pose.position.x, req.start.pose.position.y, req.goal.pose.position.x, req.goal.pose.position.y);\n\n  // set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // call makePlan to generate a path\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(req.start, req.goal, path);\n\n  // update the response with the success status and the generated path if a plan is found\n  resp.plan_found = success;\n  if (success) {\n    resp.path = path;\n  }\n\n  ROS_DEBUG(\"makePlanService: success: %d\", success);\n\n  return true;\n}", "CodeBleu_score": 74.77684482867988}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    ROS_DEBUG_NAMED(\"make_plan\", \"make_plan: Received a request to make a plan from %f, %f to %f, %f\", req.start.pose.position.x, req.start.pose.position.y, req.goal.pose.position.x, req.goal.pose.position.y);\n    geometry_msgs::PoseStamped start;\n    start.header.frame_id = \"map\";\n    start.pose = req.start.pose;\n    geometry_msgs::PoseStamped goal;\n    goal.header.frame_id = \"map\";\n    goal.pose = req.goal.pose;\n    std::vector<geometry_msgs::PoseStamped> path;\n    bool success = makePlan(start, goal, path);\n    resp.plan_found = success;\n    resp.error_message = error_msg_;\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.poses = path;\n    return true;\n}", "CodeBleu_score": 56.33959734870116}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    geometry_msgs::PoseStamped start, goal;\n\n    start.header.frame_id = \"map\";\n    start.pose = req.start;\n    goal.header.frame_id = \"map\";\n    goal.pose = req.goal;\n\n    std::vector<geometry_msgs::PoseStamped> path;\n    bool success = makePlan(start, goal, path);\n\n    resp.plan_found = success;\n    resp.path = path;\n\n    return true;\n}", "CodeBleu_score": 58.30173864562376}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh.getParam(\"publish_scale\", publish_scale);\n    private_nh.getParam(\"planner_frequency\", planner_frequency);\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 65.8138127092256}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~/\" + name);\n    private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 62.750379988139805}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh.getParam(\"planner_frequency\", planner_frequency);\n    ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap: %s\", name.c_str());\n    private_nh.advertiseService(name, &PlannerWithCostmap::makePlanService, this);\n    private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 57.2263091573901}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  // check if the world coordinate is within the bounds of the costmap\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    return false;\n  }\n\n  // convert world coordinates to map coordinates\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // check if the map coordinates are within the size limits of the costmap\n  if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 50.202101700406075}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  double originX = costmap_->getOriginX(), originY = costmap_->getOriginY();\n  double resolution = costmap_->getResolution();\n\n  mx = (wx - originX) / resolution;\n  my = (wy - originY) / resolution;\n\n  unsigned int sizeX = costmap_->getSizeInCellsX(), sizeY = costmap_->getSizeInCellsY();\n\n  if (mx < sizeX && mx >= 0 && my < sizeY && my >= 0)\n    return true;\n\n  return false;\n}", "CodeBleu_score": 63.90720465881715}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\tif (mx < costmap_->getSizeInCellsX() && mx >= 0 &&\n\t\tmy < costmap_->getSizeInCellsY() && my >= 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "CodeBleu_score": 40.30412079748594}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    // create a Path message\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.stamp = ros::Time::now();\n    gui_path.header.frame_id = frame_id_;\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 93.43992622529296}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.28886764425677}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a path message\n  nav_msgs::Path plan;\n  plan.header.stamp = ros::Time::now();\n  plan.header.frame_id = frame_id_;\n  plan.poses.resize(path.size());\n  plan.poses = path;\n\n  plan_pub_.publish(plan);\n}", "CodeBleu_score": 60.067122250973505}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Wrapping goal into action message.\");\n  move_base_msgs::MoveBaseGoal action_goal;\n  action_goal.target_pose = *goal;\n  action_goal.target_pose.header.stamp = ros::Time::now();\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 60.04115883885138}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Received goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 74.74901562488363}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    ROS_DEBUG_NAMED(\"move_base\", \"Wrapping goal in action message and publishing to action server\");\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 80.8789924261112}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  double current_distance_sq = (robot_pose_->x - start_x_) * (robot_pose_->x - start_x_) + (robot_pose_->y - start_y_) * (robot_pose_->y - start_y_);\n  ROS_INFO(\"Current distance: %f\", current_distance_sq);\n  if (current_distance_sq > distance_sq_) {\n    ROS_INFO(\"Moved far enough, removing speed limit.\");\n    distance_check_timer_.stop();\n    if (remove_limit_thread_ != nullptr) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n  }\n}", "CodeBleu_score": 74.08928123998658}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  ROS_INFO(\"Distance check called\");\n  // Check if the robot has moved a sufficient distance\n  if (getSqDistance(robot_pose_.pose.position, start_pose_.pose.position) > sq_distance_limit_) {\n    ROS_INFO(\"Distance check succeeded\");\n    // If so, log a message, join and delete any existing remove limit thread, start a new thread to remove the speed limit, and stop the distance check timer\n    if (remove_limit_thread_ != NULL) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 73.8007898856709}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  // Check if the robot has moved a sufficient distance\n  if (getSqDistance(robot_pose_.pose.position, initial_pose_.pose.position) > distance_limit_ * distance_limit_) {\n    ROS_INFO(\"Robot has moved far enough. Removing speed limit.\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n    }\n    remove_limit_thread_.reset(new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this)));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 58.59515461376109}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // get the current global pose of the robot\n  rm::PoseStamped global_pose = cmap_->getRobotPose();\n\n  // generate a path from the current pose to the goal pose\n  makePlan(global_pose, *goal, path_);\n}", "CodeBleu_score": 42.799756620917655}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  ROS_INFO_STREAM(\"NavfnWithCostmap::poseCallback\");\n  if (goal->header.frame_id != costmap_ros_->getGlobalFrameID()) {\n    ROS_ERROR(\n        \"NavfnWithCostmap::poseCallback: Goal is in %s, planner is in %s.\",\n        goal->header.frame_id.c_str(), costmap_ros_->getGlobalFrameID().c_str());\n    return;\n  }\n\n  // Convert the pose to the frame of the costmap\n  geometry_msgs::PoseStamped global_pose;\n  costmap_ros_->getRobotPose(global_pose);\n  tf::Stamped<tf::Pose> goal_tf;\n  tf::poseStampedMsgToTF(goal, goal_tf);\n  tf::Stamped<tf::Pose> global_pose_tf;\n  tf::poseStampedMsgToTF(global_pose, global_pose_tf);\n  global_pose_tf.setData(global_pose_tf * goal_tf);\n  global_pose_tf.stamp_ = goal->header.stamp;\n  global_pose_tf.frame_id_ = costmap_ros_->getGlobalFrameID();\n  tf::poseStampedTFToMsg(global_pose_tf, global_pose);\n\n  // Generate a path from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> path;\n  makePlan(global_pose, *goal, path);\n}", "CodeBleu_score": 58.74622364280644}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // get the global pose of the robot\n    rm::PoseStamped global_pose;\n    tf::StampedTransform transform;\n    try {\n        tf_listener_.lookupTransform(\"/map\", \"/base_link\", ros::Time(0), transform);\n    }\n    catch (tf::TransformException ex) {\n        ROS_ERROR(\"%s\",ex.what());\n        return;\n    }\n    global_pose.pose.position.x = transform.getOrigin().x();\n    global_pose.pose.position.y = transform.getOrigin().y();\n    global_pose.pose.position.z = transform.getOrigin().z();\n    global_pose.pose.orientation.x = transform.getRotation().x();\n    global_pose.pose.orientation.y = transform.getRotation().y();\n    global_pose.pose.orientation.z = transform.getRotation().z();\n    global_pose.pose.orientation.w = transform.getRotation().w();\n    global_pose.header.frame_id = \"/map\";\n\n    // generate a path from the current pose to the goal pose\n    std::vector<rm::PoseStamped> path;\n    makePlan(global_pose, *goal, path);\n\n    // publish the path\n    path_pub_.publish(path);\n}", "CodeBleu_score": 54.00431022058427}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\n    // Create a request for the gimbal parameters\n    mavros_msgs::ParamSet param_set_srv;\n\n    // Assign the parameter ID and value\n    param_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value.integer = param_set.value;\n\n    // Call the client\n    this->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 69.40826392952664}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t  // Create a request for the gimbal parameter set service\n  param_set_srv::Request request;\n  request.param_id = param_set.param_id;\n  request.param_value = param_set.param_value;\n  // Call the service\n  if (param_set_client_.call(request)) {\n    ROS_INFO(\"Gimbal parameter set service call successful\");\n  } else {\n    ROS_ERROR(\"Gimbal parameter set service call failed\");\n  }\n}", "CodeBleu_score": 47.094514104488866}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\n  // Create a service request\n  mavros_msgs::ParamSet param_set_srv;\n\n  // Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n  param_set_srv.request.param_id = param_set.param_id;\n  param_set_srv.request.value.integer = param_set.param_value;\n\n  // Call the param_set_client_ to send the request\n  this->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 68.5392836656764}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t    int sockfd, newsockfd, clilen;\n    char buffer[256];\n    struct sockaddr_in serv_addr, cli_addr;\n    int n;\n\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    bzero((char *) &serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    serv_addr.sin_port = htons(this->port);\n    if (bind(sockfd, (struct sockaddr *) &serv_addr,\n             sizeof(serv_addr)) < 0) {\n        perror(\"ERROR on binding\");\n        exit(1);\n    }\n\n    listen(sockfd, 5);\n    clilen = sizeof(cli_addr);\n\n    while (true) {\n        newsockfd = accept(sockfd,\n                           (struct sockaddr *) &cli_addr,\n                           &clilen);\n        if (newsockfd < 0) {\n            perror(\"ERROR on accept\");\n            exit(1);\n        }\n\n        bzero(buffer, 256);\n        n = recv(newsockfd, buffer, 255, 0);\n        if (n > 0) {\n            std::string message = buffer;\n            if (message.length() > 0) {\n                this->decodeMsg(message);\n            } else {\n                ROS_ERROR(\"Received empty message\");\n            }\n        } else if (n == 0) {\n            ROS_ERROR(\"Received empty message\");\n        } else {\n            perror(\"ERROR reading from socket\");\n            exit(1);\n        }\n\n        close(newsockfd);\n    }\n}", "CodeBleu_score": 51.10614756093279}, {"code": "void CommunicationBridge::serverFun(){\n\t\t// Wait for connection from ground station\n\twaitConnectionFromGroundStation();\n\twhile (true) {\n\t\t// Accept connection\n\t\taccept();\n\t\t// Receive data\n\t\trecv();\n\t\t// Decode message\n\t\tdecodeMsg();\n\t\t// Publish message\n\t\tpubMsg();\n\t\t// Close socket\n\t\tclose();\n\t}\n}", "CodeBleu_score": 2.783517093884423}, {"code": "void CommunicationBridge::serverFun(){\n\t  int sockfd, newsockfd, portno, clilen;\n  char buffer[256];\n  struct sockaddr_in serv_addr, cli_addr;\n  int n;\n  sockfd = socket(AF_INET, SOCK_STREAM, 0);\n  if (sockfd < 0) {\n    perror(\"ERROR opening socket\");\n    exit(1);\n  }\n  bzero((char *) &serv_addr, sizeof(serv_addr));\n  portno = 5000;\n  serv_addr.sin_family = AF_INET;\n  serv_addr.sin_addr.s_addr = INADDR_ANY;\n  serv_addr.sin_port = htons(portno);\n  if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n    perror(\"ERROR on binding\");\n    exit(1);\n  }\n  listen(sockfd, 5);\n  clilen = sizeof(cli_addr);\n  while (1) {\n    newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n    if (newsockfd < 0) {\n      perror(\"ERROR on accept\");\n      exit(1);\n    }\n    bzero(buffer, 256);\n    n = read(newsockfd, buffer, 255);\n    if (n < 0) {\n      perror(\"ERROR reading from socket\");\n      close(newsockfd);\n      continue;\n    }\n    if (n == 0) {\n      ROS_ERROR(\"Received message length is 0. Closing socket.\");\n      close(newsockfd);\n      continue;\n    }\n    std::string msg = buffer;\n    std::vector<std::string> decodedMsg = decodeMsg(msg);\n    pubMsg(decodedMsg);\n    close(newsockfd);\n  }\n}", "CodeBleu_score": 51.207517623441355}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (swarm_control_simulation_.empty()) {\n    uav_basic_->uavCmdPub(uav_cmd);\n  } else {\n    std::map<int, UAV*>::iterator it = swarm_control_simulation_.find(uav_cmd.uav_id);\n    if (it != swarm_control_simulation_.end()) {\n      (*it).second->uavCmdPub(uav_cmd);\n    }\n  }\n}", "CodeBleu_score": 46.888054344321155}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    ROS_INFO(\"Received data from UAV %d\", uav_cmd.uav_id);\n\n    if (simulation_mode_) {\n        // Find UAV by ID\n        auto it = swarm_control_simulation_.find(uav_cmd.uav_id);\n        if (it != swarm_control_simulation_.end()) {\n            // Publish command to UAV\n            (*it).second->uavCmdPub.publish(uav_cmd);\n        } else {\n            ROS_ERROR(\"Could not find UAV with ID %d\", uav_cmd.uav_id);\n        }\n    } else {\n        // Publish command to UAV\n        uav_basic_->uavCmdPub.publish(uav_cmd);\n    }\n}", "CodeBleu_score": 49.61941252298567}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->simulation_mode_) {\n        // If in simulation mode, find the corresponding UAV and publish the command to it\n        std::map<int, UAVBasic*>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n        if (it != this->swarm_control_simulation_.end()) {\n            it->second->uavCmdPub(uav_cmd);\n        }\n    } else {\n        // If not in simulation mode, publish the command to the single UAV\n        this->uav_basic_->uavCmdPub(uav_cmd);\n    }\n}", "CodeBleu_score": 53.31796504418311}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t  if (mode_selection.use_mode == REBOOTNX) {\n    // Execute system command to reboot Nintendo Switch\n    system(\"sudo reboot\");\n  } else if (mode_selection.use_mode == EXITNX) {\n    // Execute system command to exit Nintendo Switch\n    system(\"sudo shutdown -h now\");\n  } else if (mode_selection.use_mode == CREATEMODE) {\n    // Execute createMode function\n    createMode(mode_selection);\n  } else if (mode_selection.use_mode == DELETEMODE) {\n    // Execute deleteMode function\n    deleteMode(mode_selection);\n  }\n}", "CodeBleu_score": 62.72145341170555}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch (mode_selection.use_mode) {\n\tcase REBOOTNX:\n\t\tsystem(\"sudo reboot\");\n\t\tbreak;\n\tcase EXITNX:\n\t\tsystem(\"sudo poweroff\");\n\t\tbreak;\n\tcase CREATEMODE:\n\t\tcreateMode(mode_selection.mode_name, mode_selection.mode_file);\n\t\tbreak;\n\tcase DELETEMODE:\n\t\tdeleteMode(mode_selection.mode_name);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 34.3669497550252}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t  if (mode_selection.use_mode == REBOOTNX) {\n    system(\"sudo reboot\");\n  }\n  else if (mode_selection.use_mode == EXITNX) {\n    system(\"sudo shutdown now\");\n  }\n  else if (mode_selection.use_mode == CREATEMODE) {\n    createMode(mode_selection);\n  }\n  else if (mode_selection.use_mode == DELETEMODE) {\n    deleteMode(mode_selection);\n  }\n}", "CodeBleu_score": 63.257020438145716}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (heartbeat_count == 0) {\n        ROS_WARN(\"[CommunicationBridge::checkHeartbeatState]: Heartbeat count is zero.\");\n        heartbeat_count++;\n    }\n    else if (heartbeat_count > 0) {\n        ROS_INFO(\"[CommunicationBridge::checkHeartbeatState]: Heartbeat count is %d.\", heartbeat_count);\n        heartbeat_count++;\n    }\n    else if (heartbeat_count < 0) {\n        ROS_ERROR(\"[CommunicationBridge::checkHeartbeatState]: Heartbeat count is %d.\", heartbeat_count);\n        heartbeat_count++;\n    }\n\n    if (heartbeat_count == heartbeat_attempts) {\n        ROS_ERROR(\"[CommunicationBridge::checkHeartbeatState]: Heartbeat count has reached %d. Disconnecting...\", heartbeat_attempts);\n        disconnect_flag = true;\n    }\n}", "CodeBleu_score": 35.35617664502034}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\n    // Check heartbeat state\n    if (heartbeat_counter == 0) {\n        ROS_ERROR(\"No heartbeat received from %s\", vehicle_type.c_str());\n        disconnect_flag = true;\n        if (vehicle_type == \"UAV\") {\n            triggerUAV = true;\n        } else if (vehicle_type == \"UGV\") {\n            triggerUGV = true;\n        } else if (vehicle_type == \"Swarm\") {\n            triggerSwarmControl = true;\n        }\n    } else {\n        heartbeat_counter--;\n    }\n}", "CodeBleu_score": 21.68137388546587}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (heartbeat_counter == heartbeat_limit) {\n        ROS_ERROR(\"Heartbeat lost, triggering disconnect sequence.\");\n        disconnect_flag = true;\n        heartbeat_counter = 0;\n    }\n    else {\n        heartbeat_counter++;\n    }\n}", "CodeBleu_score": 15.949624963288777}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\n    // ROS_INFO(\"multitrajSubTcpCb\");\n\n    // \u83b7\u53d6\u65e0\u4eba\u673a\u7f16\u53f7\n    int drone_id = msg->drone_id;\n\n    // \u83b7\u53d6\u65e0\u4eba\u673a\u603b\u6570\n    int drone_num = msg->drone_num;\n\n    // \u83b7\u53d6\u6bcf\u4e2a\u65e0\u4eba\u673a\u7684\u8f68\u8ff9\u6570\n    int traj_num = msg->traj_num;\n\n    // \u83b7\u53d6\u6bcf\u4e2a\u65e0\u4eba\u673a\u7684\u8f68\u8ff9\u6570\n    int traj_num = msg->traj_num;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d\u59cb\u5316\u8f68\u8ff9\u5bb9\u5668\n    std::vector<Bspline> bspline_traj;\n\n    // \u521d", "CodeBleu_score": 24.06240215877677}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    int drone_id = msg->drone_id;\n    int traj_num = msg->traj.size();\n    // ROS_INFO(\"drone_id: %d, traj_num: %d\", drone_id, traj_num);\n    for (int i = 0; i < traj_num; i++) {\n        Bspline bspline;\n        bspline.drone_id = drone_id;\n        bspline.traj_id = i;\n        bspline.start_time = msg->traj[i].start_time.toSec();\n        bspline.duration = msg->traj[i].duration.toSec();\n        bspline.knots.resize(msg->traj[i].knots.size());\n        bspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n        bspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n        bspline.pos_pts_dot.resize(msg->traj[i].pos_pts_dot.size());\n        bspline.pos_pts_ddot.resize(msg->traj[i].pos_pts_ddot.size());\n        bspline.yaw_pts_dot.resize(msg->traj[i].yaw_pts_dot.size());\n        bspline.yaw_pts_ddot.resize(msg->traj[i].yaw_pts_ddot.size());\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots[j] = msg->traj[i].knots[j];\n        }\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts[j] = msg->traj[i].pos_pts[j];\n        }\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            b", "CodeBleu_score": 65.1794552231574}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract drone ID from message\n    int drone_id = msg->drone_id;\n    // Extract trajectories from message\n    int traj_size = msg->traj.size();\n    // Iterate through trajectories\n    for (int i = 0; i < traj_size; i++) {\n        // Initialize Bspline struct\n        Bspline bspline;\n        // Set Bspline attributes\n        bspline.drone_id = drone_id;\n        bspline.traj_id = i;\n        bspline.start_time = msg->traj[i].start_time;\n        // Populate Bspline knots\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots.push_back(msg->traj[i].knots[j]);\n        }\n        // Populate Bspline position points\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts.push_back(msg->traj[i].pos_pts[j]);\n        }\n        // Populate Bspline yaw points\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n        }\n        // Encode Bspline data\n        this->communication->encodeMsg(bspline);\n        // Send Bspline data via TCP\n        this->communication->sendMsgByTcp();\n    }\n}", "CodeBleu_score": 60.12020555632872}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    octree_compression.setInputCloud(cloud);\n    octree_compression.encodePointCloud();\n\n    std::vector<uint8_t> compressed_data;\n    compressed_data.str(std::string());\n    std::string compressed_str = octree_compression.getCompressedData();\n    std::memcpy(compressed_data.data(), compressed_str.data(), compressed_str.size());\n\n    sensor_msgs::PointCloud2 compressed_msg;\n    pcl::toROSMsg(*cloud, compressed_msg);\n    compressed_msg.data = compressed_data;\n\n    return compressed_msg;\n}", "CodeBleu_score": 44.80514913280772}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.1);\n    octree.setInputCloud(cloud);\n    std::ostringstream compressed_data;\n    octree.encodePointCloud(compressed_data);\n    std::string compressed_str = compressed_data.str();\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header.stamp = msg.header.stamp;\n    compressed_msg.header.frame_id = msg.header.frame_id;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_str.size();\n    compressed_msg.fields = msg.fields;\n    compressed_msg.is_bigendian = msg.is_bigendian;\n    compressed_msg.point_step = 1;\n    compressed_msg.row_step = compressed_str.size();\n    compressed_msg.is_dense = msg.is_dense;\n    compressed_msg.data.resize(compressed_str.size());\n    std::memcpy(&compressed_msg.data[0], compressed_str.data(), compressed_str.size());\n    return compressed_msg;\n}", "CodeBleu_score": 51.57132252953747}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud_in);\n    octree_compression.setInputCloud(cloud_in);\n    octree_compression.encodePointCloud();\n    std::vector<uint8_t> compressed_data;\n    std::stringstream compressed_str;\n    octree_compression.encodePointCloud(compressed_str);\n    compressed_data.resize(compressed_str.size());\n    std::memcpy(compressed_data.data(), compressed_str.str().c_str(), compressed_str.size());\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.fields = msg.fields;\n    compressed_msg.height = msg.height;\n    compressed_msg.width = msg.width;\n    compressed_msg.point_step = msg.point_step;\n    compressed_msg.row_step = msg.row_step;\n    compressed_msg.is_bigendian = msg.is_bigendian;\n    compressed_msg.is_dense = msg.is_dense;\n    compressed_msg.data = compressed_data;\n    return compressed_msg;\n}", "CodeBleu_score": 47.21798918263497}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\n\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].id == uav_state.id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 76.36251511213194}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\n    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 86.47230218122864}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n        if (uav_state.uav_id == this->multi_uav_state_.uav_state_all[i].uav_id) {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 79.49143470591822}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    // Initialize MultiUGVState message\n    multi_ugv_state.ugv_state_all.clear();\n\n    // Iterate through each UGV state\n    for (int i = 0; i < m_multi_ugv_state.ugv_state_all.size(); i++) {\n        // Populate UGVState message\n        ugv_state.ugv_id = m_multi_ugv_state.ugv_state_all[i].ugv_id;\n        ugv_state.ugv_battery = m_multi_ugv_state.ugv_state_all[i].ugv_battery;\n        ugv_state.ugv_position.x = m_multi_ugv_state.ugv_state_all[i].ugv_position.x;\n        ugv_state.ugv_position.y = m_multi_ugv_state.ugv_state_all[i].ugv_position.y;\n        ugv_state.ugv_position.z = m_multi_ugv_state.ugv_state_all[i].ugv_position.z;\n        ugv_state.ugv_velocity.x = m_multi_ugv_state.ugv_state_all[i].ugv_velocity.x;\n        ugv_state.ugv_velocity.y = m_multi_ugv_state.ugv_state_all[i].ugv_velocity.y;\n        ugv_state.ugv_velocity.z = m_multi_ugv_state.ugv_state_all[i].ugv_velocity.z;\n        ugv_state.ugv_attitude.x = m_multi_ugv_state.ugv_state_all[i].ugv_attitude.x;\n        ugv_state.ugv_attitude.y = m_multi_ugv_state.ugv_state_all[i].ugv_attitude.y;\n        ugv_state.ugv_attitude.z = m_multi_ugv_state.ugv", "CodeBleu_score": 38.15234031753073}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  std_msgs::Header header;\n  header.stamp = ros::Time::now();\n  header.frame_id = \"world\";\n\n  multi_ugv_state.header = header;\n  multi_ugv_state.ugv_state_all.clear();\n  multi_ugv_state.ugv_count = 0;\n\n  for (auto it = m_multi_ugv_state.ugv_state_all.begin();\n       it != m_multi_ugv_state.ugv_state_all.end(); ++it) {\n    UGVState ugv_state;\n    ugv_state.ugv_id = it->ugv_id;\n    ugv_state.battery = it->battery;\n    ugv_state.position = it->position;\n    ugv_state.velocity = it->velocity;\n    ugv_state.attitude = it->attitude;\n    multi_ugv_state.ugv_state_all.push_back(ugv_state);\n    multi_ugv_state.ugv_count++;\n  }\n\n  this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 47.12689854099528}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  // Initialize the MultiUGVState message\n  multi_ugv_state.header.stamp = ros::Time::now();\n  multi_ugv_state.ugv_state_all.clear();\n  multi_ugv_state.ugv_count = 0;\n\n  // Iterate through each UGV state in the MultiUGVState structure\n  for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++) {\n    // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n    ugv_state.ugv_id = it->ugv_id;\n    ugv_state.battery = it->battery;\n    ugv_state.position.x = it->position.x;\n    ugv_state.position.y = it->position.y;\n    ugv_state.position.z = it->position.z;\n    ugv_state.velocity.x = it->velocity.x;\n    ugv_state.velocity.y = it->velocity.y;\n    ugv_state.velocity.z = it->velocity.z;\n    ugv_state.attitude.x = it->attitude.x;\n    ugv_state.attitude.y = it->attitude.y;\n    ugv_state.attitude.z = it->attitude.z;\n    ugv_state.attitude.w = it->attitude.w;\n\n    // Increment the UGV count and add each UGVState to the MultiUGVState message\n    multi_ugv_state.ugv_count++;\n    multi_ugv_state.ugv_state_all.push_back(ugv_state);\n  }\n\n  // Publish the assembled MultiUGVState message\n  this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 51.89246137204745}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  gradient = Eigen::MatrixXd::Zero(q.cols(), q.cols());\n\n  // Iterate through control points of the B-spline\n  for (int i = 0; i < q.cols(); ++i) {\n    // Compute the predicted positions of moving objects\n    std::vector<Eigen::Vector3d> obj_preds;\n    moving_objs_->evaluateConstVel(cps_.points.col(i), obj_preds);\n\n    // Iterate through the predicted positions of moving objects\n    for (int j = 0; j < obj_preds.size(); ++j) {\n      // Evaluate the distance between the control point and the object\n      Eigen::Vector3d obj_prid = obj_preds[j];\n      double dist = (cps_.points.col(i) - obj_prid).norm();\n\n      // If the distance is less than a specified clearance, update the cost and gradient\n      if (dist < moving_obj_clearance_) {\n        double dist_sq = dist * dist;\n        cost += dist_sq;\n        Eigen::Vector3d grad = 2.0 * (cps_.points.col(i) - obj_prid).normalized();\n        gradient.col(i) += grad;\n      }\n    }\n  }\n}", "CodeBleu_score": 47.650892955840966}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  /*\n   * Iterate through control points of the B-spline.\n   */\n  for (int i = 0; i < q.cols(); i++) {\n    /*\n     * Get the predicted positions of moving objects.\n     */\n    std::vector<Eigen::Vector3d> obj_prids;\n    std::vector<double> obj_rads;\n    moving_objs_->evaluateConstVel(q.col(i), obj_prids, obj_rads);\n\n    /*\n     * Iterate through predicted positions of moving objects.\n     */\n    for (int j = 0; j < obj_prids.size(); j++) {\n      /*\n       * Get the distance between the control point and the object.\n       */\n      double dist = (q.col(i) - obj_prids[j]).norm();\n\n      /*\n       * If the distance is less than a specified clearance, update the cost and gradient.\n       */\n      if (dist < obj_rads[j] + cof_->clearance) {\n        double dist_sq = dist * dist;\n        cost += cof_->lambda_obj * (1.0 - exp(-dist_sq / cof_->epsilon_obj));\n        Eigen::Vector3d grad = cof_->lambda_obj * (1.0 - exp(-dist_sq / cof_->epsilon_obj)) * (q.col(i) - obj_prids[j]) / dist;\n        gradient.col(i) += grad;\n      }\n    }\n  }\n}", "CodeBleu_score": 42.41166007436677}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  gradient.setZero(q.cols(), q.rows());\n\n  // iterate through all control points\n  for (int i = 0; i < q.cols(); i++) {\n    // iterate through all moving objects\n    for (int obj_num = 0; obj_num < moving_objs_->getObjNums(); obj_num++) {\n      // calculate the predicted position of the object at the current control point\n      Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(obj_num, ros::Time::now().toSec(), q.col(i)(3));\n\n      // calculate the distance between the current control point and the object\n      double dist = (q.col(i) - obj_prid).norm();\n\n      // if the distance is less than a specified clearance, update the cost and gradient\n      if (dist < moving_objs_->getClearance()) {\n        double dist_error = dist - moving_objs_->getClearance();\n        cost += dist_error * dist_error;\n        gradient.col(i) += 2 * dist_error * (q.col(i) - obj_prid).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 41.17005217156644}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // initialize cost to zero\n  cost = 0;\n  // initialize gradient to zero\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n  // iterate through the control points\n  for (int i = 2; i < q.cols() - 2; i++) {\n    // compute the positional error relative to reference points\n    Eigen::Vector3d x = q.col(i) - ref_pts_[i];\n    // compute the velocity vector\n    Eigen::Vector3d v = (q.col(i) - q.col(i - 1)) / delta_t_ + (q.col(i + 1) - q.col(i)) / delta_t_;\n    // update cost\n    cost += a2_ * x.squaredNorm() + b2_ * v.squaredNorm();\n    // update gradient\n    gradient.col(i) += 2 * a2_ * x + 2 * b2_ * v;\n  }\n  // iterate through the control points\n  for (int i = 2; i < q.cols() - 2; i++) {\n    // compute the positional error relative to reference points\n    Eigen::Vector3d x = q.col(i) - ref_pts_[i];\n    // compute the velocity vector\n    Eigen::Vector3d v = (q.col(i) - q.col(i - 1)) / delta_t_ + (q.col(i + 1) - q.col(i)) / delta_t_;\n    // update cost\n    cost += a2_ * x.squaredNorm() + b2_ * v.squaredNorm();\n    // update gradient\n    gradient.col(i) += 2 * a2_ * x + 2 * b2_ * v;\n  }\n  // iterate through the control points\n  for (int i = 2; i < q.cols() - 2; i++) {\n    // compute the positional error relative to reference points\n    Eigen::Vector3d x = q.col(i) - ref_pts_[i];\n    // compute the velocity vector\n    Eigen::", "CodeBleu_score": 38.88169706453818}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // initialize cost to zero\n  cost = 0.0;\n\n  // initialize gradient to zero\n  gradient.setZero(q.cols(), q.rows());\n\n  // initialize velocity vector\n  Eigen::Vector3d v;\n\n  // initialize positional error vector\n  Eigen::Vector3d e;\n\n  // iterate through each control point\n  for (int i = 2; i < q.rows() - 2; i++) {\n    // compute velocity vector\n    v = (q.block<3, 1>(0, i + 1) - q.block<3, 1>(0, i - 1)).normalized();\n\n    // compute positional error vector\n    e = q.block<3, 1>(0, i) - ref_pts_[i];\n\n    // update cost\n    cost += a2_ * e.dot(e) + b2_ * v.cross(e).squaredNorm();\n\n    // update gradient\n    gradient.block<3, 1>(0, i) += 2 * a2_ * e + 2 * b2_ * v.cross(e).cross(v);\n    gradient.block<3, 1>(0, i + 1) += -2 * b2_ * v.cross(e).cross(v);\n    gradient.block<3, 1>(0, i - 1) += -2 * b2_ * v.cross(e).cross(v);\n  }\n}", "CodeBleu_score": 30.847825980810327}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  gradient.setZero();\n\n  for (int i = 0; i < q.cols(); i++) {\n    Eigen::Vector3d x = q.col(i);\n    Eigen::Vector3d v = (q.col(i) - q.col(i - 2)).normalized();\n\n    Eigen::Vector3d xcrossv = x.cross(v);\n    double xcrossv_norm = xcrossv.norm();\n\n    for (int j = 0; j < ref_pts_.size(); j++) {\n      Eigen::Vector3d ref_pt = ref_pts_[j];\n      double a = (ref_pt - x).squaredNorm();\n      double b = xcrossv_norm;\n      double c = (ref_pt - x).dot(v);\n      cost += a * a2_ + b * b2_ + c * c3_;\n\n      Eigen::Vector3d da = 2.0 * a * a2_ * (ref_pt - x);\n      Eigen::Vector3d db = 2.0 * b * b2_ * xcrossv / xcrossv_norm;\n      Eigen::Vector3d dc = c * c3_ * v;\n\n      gradient.col(i) += da + db + dc;\n    }\n  }\n}", "CodeBleu_score": 47.49192794542104}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t    UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n    double jerk = 0;\n    for (int i = 0; i < jerk_traj.ctrl_pts.cols; i++) {\n        for (int j = 0; j < jerk_traj.ctrl_pts.rows; j++) {\n            jerk += pow(jerk_traj.ctrl_pts(j, i), 2) * (jerk_traj.getKnot(i + 1) - jerk_traj.getKnot(i));\n        }\n    }\n    return jerk;\n}", "CodeBleu_score": 51.88390026259795}, {"code": "double UniformBspline::getJerk(){\n\t  // Calculate the jerk trajectory\n  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  // Get the knot times and control points of the jerk trajectory\n  std::vector<double> knot_times = jerk_traj.getKnotTimes();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPointMatrix();\n\n  // Calculate the jerk value\n  double jerk_val = 0;\n  for (int i = 0; i < ctrl_pts.rows(); i++) {\n    for (int j = 0; j < ctrl_pts.cols(); j++) {\n      jerk_val += pow(ctrl_pts(i, j), 2) * (knot_times[i + 1] - knot_times[i]);\n    }\n  }\n\n  return jerk_val;\n}", "CodeBleu_score": 63.599219289820915}, {"code": "double UniformBspline::getJerk(){\n\t  // Calculate the jerk trajectory\n  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n  // Retrieve the knot times and control points of the jerk trajectory\n  std::vector<double> jerk_times = jerk_traj.getKnotTimes();\n  Eigen::MatrixXd jerk_pts = jerk_traj.getControlPoint();\n\n  // Initialize the jerk value\n  double jerk = 0;\n\n  // Iterate through the control points and dimensions\n  for (int i = 0; i < jerk_pts.cols(); i++) {\n    for (int j = 0; j < jerk_pts.rows(); j++) {\n      // Sum the squared control point values multiplied by the differences in knot times\n      jerk += jerk_pts(j, i) * jerk_pts(j, i) * (jerk_times[j + 1] - jerk_times[j]);\n    }\n  }\n\n  // Return the total jerk value\n  return jerk;\n}", "CodeBleu_score": 68.03893400931489}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n    return pos;\n}", "CodeBleu_score": 49.315525916455506}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    // TODO: Implement this function\n    Eigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n    return pos;\n}", "CodeBleu_score": 49.35302312362254}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1.0;\n    return pos;\n}", "CodeBleu_score": 50.05512292553293}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        int droneID = std::stoi(odom.child_frame_id.substr(1));\n        rcvDroneOdomCallbackBase(odom, droneID);\n    } catch (const std::exception& e) {\n        ROS_ERROR_STREAM(\"[DroneDetector] Error extracting drone ID from odometry message: \" << e.what());\n    }\n}", "CodeBleu_score": 51.04118832621576}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    rcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(1)));\n  } catch (std::exception& e) {\n    ROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n  }\n}", "CodeBleu_score": 41.57055958903176}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(8, odom.child_frame_id.length() - 8));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (std::exception& e) {\n\t\tROS_ERROR(\"Exception: %s\", e.what());\n\t}\n}", "CodeBleu_score": 48.53388594515836}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // Compute the true pose of the drone in the camera frame\n  Eigen::Matrix3f R_true;\n  R_true << 0, 1, 0,\n      -1, 0, 0,\n      0, 0, -1;\n  Eigen::Vector3f t_true;\n  t_true << true_pixel(0), true_pixel(1), 0;\n  Eigen::Matrix4f T_true;\n  T_true.setIdentity();\n  T_true.block<3, 3>(0, 0) = R_true;\n  T_true.block<3, 1>(0, 3) = t_true;\n\n  // Compute the true pose of the drone in the world frame\n  Eigen::Matrix4f T_world_true = T_world_camera_ * T_true;\n\n  // Compute the true pose of the drone in the world frame\n  Eigen::Matrix4f T_world_true = T_world_camera_ * T_true;\n\n  // Check for the presence of the drone\n  bool found = false;\n  Eigen::Vector2i pixel;\n  for (int i = 0; i < 10; i++) {\n    pixel(0) = true_pixel(0) + rand() % 10 - 5;\n    pixel(1) = true_pixel(1) + rand() % 10 - 5;\n    if (pixel(0) >= 0 && pixel(0) < image_width_ && pixel(1) >= 0 && pixel(1) < image_height_) {\n      if (countPixel(pixel, drone_id) > 50) {\n        found = true;\n        break;\n      }\n    }\n  }\n\n  // If the drone was found, compute the pose error and publish it\n  if (found) {\n    // Compute the pose error\n    Eigen::Matrix4f T_world_estimate = T_world_camera_ * T_camera_drone_[drone_id];\n    Eigen::Matrix4f T_error = T_world_", "CodeBleu_score": 35.59210890592759}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // Get the drone's true pose in the camera frame.\n  Eigen::Vector3d true_camera_pose = getTruePose(drone_id);\n\n  // Check for the drone's presence.\n  bool found = checkForDrone(drone_id, true_pixel);\n\n  // If the drone was found, compute the pose error and publish it.\n  if (found) {\n    // Compute the pose error.\n    Eigen::Vector3d pose_error = computePoseError(true_camera_pose, true_pixel);\n\n    // Publish the pose error.\n    drone_pose_err_pub_[drone_id].publish(pose_error);\n\n    // Update the debug result.\n    updateDebugResult(drone_id, true_pixel, true_camera_pose, pose_error, true);\n  }\n\n  // Otherwise, update the debug result to indicate failure.\n  else {\n    updateDebugResult(drone_id, true_pixel, true_camera_pose, Eigen::Vector3d::Zero(), false);\n  }\n}", "CodeBleu_score": 36.03181365194331}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // TODO: Fill in this function\n  // Hint: You can use the functions:\n  // 1. DroneDetector::getDronePose\n  // 2. DroneDetector::countPixel\n  // 3. DroneDetector::drone_pose_err_pub_\n  // 4. DroneDetector::pose_error\n  // 5. DroneDetector::debug_\n\n  // Get the true drone pose in the camera frame\n  Eigen::Matrix4d T_C_D = getDronePose(drone_id);\n\n  // Compute the true pixel position\n  Eigen::Vector3d p_C_D = T_C_D.block<3, 1>(0, 3);\n  Eigen::Vector2d p_C_D_2D = project3Dto2D(p_C_D);\n  Eigen::Vector2i true_pixel_int(round(p_C_D_2D(0)), round(p_C_D_2D(1)));\n\n  // Count the number of pixels in the drone bounding box\n  int count = countPixel(drone_id, true_pixel_int);\n\n  // Check if the drone is in the image\n  if (count > 0) {\n    // Publish the drone pose error\n    pose_error.drone_id = drone_id;\n    pose_error.pixel_error = true_pixel - true_pixel_int;\n    pose_error.pixel_error_norm = pose_error.pixel_error.norm();\n    drone_pose_err_pub_[drone_id].publish(pose_error);\n\n    // Update the debug result\n    debug_.drone_found[drone_id] = true;\n    debug_.drone_pose_gt[drone_id] = true_pixel;\n    debug_.drone_pose_est[drone_id] = true_pixel_int;\n  } else {\n    // Update the debug result\n    debug_.drone_found[drone_id] = false;\n  }\n}", "CodeBleu_score": 43.07973253937891}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom != nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 88.16429241339951}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n}", "CodeBleu_score": 85.55990978531281}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 93.99751622940664}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  // Convert start and end points to indices\n  start_idx = Coord2Index(start_pt);\n  end_idx = Coord2Index(end_pt);\n\n  // Check if start and end points are inside obstacles\n  if (checkOccupancy(start_idx) || checkOccupancy(end_idx)) {\n    // If so, iteratively adjust them until they are not inside obstacles\n    // TODO: This could be optimized by using the fact that the points are on the same line\n    Vector3d direction = (end_pt - start_pt).normalized();\n    double dist_to_obstacle = 0;\n    for (int i = 0; i < 100; i++) {\n      if (checkOccupancy(start_idx)) {\n        start_idx = Coord2Index(start_pt + direction * dist_to_obstacle);\n        dist_to_obstacle += 0.1;\n      } else if (checkOccupancy(end_idx)) {\n        end_idx = Coord2Index(end_pt - direction * dist_to_obstacle);\n        dist_to_obstacle += 0.1;\n      } else {\n        break;\n      }\n    }\n    if (checkOccupancy(start_idx) || checkOccupancy(end_idx)) {\n      // If we still can't find a path, give up\n      return false;\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 48.48156744777863}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\n    /* Convert the 3D coordinates to grid indices. */\n    if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx)) {\n        return false;\n    }\n\n    /* If either start or end point is inside an obstacle, move it away from the other point until it is no longer in an obstacle. */\n    if (!checkOccupancy(start_idx) || !checkOccupancy(end_idx)) {\n        Vector3d direction = (end_pt - start_pt).normalized();\n        double step_size = map_resolution_;\n        double distance_to_obstacle = 0;\n        bool start_in_obstacle = !checkOccupancy(start_idx);\n        bool end_in_obstacle = !checkOccupancy(end_idx);\n\n        while (true) {\n            if (start_in_obstacle) {\n                start_pt = start_pt + step_size * direction;\n                if (!Coord2Index(start_pt, start_idx)) {\n                    return false;\n                }\n                if (checkOccupancy(start_idx)) {\n                    distance_to_obstacle += step_size;\n                }\n            }\n            if (end_in_obstacle) {\n                end_pt = end_pt - step_size * direction;\n                if (!Coord2Index(end_pt, end_idx)) {\n                    return false;\n                }\n                if (checkOccupancy(end_idx)) {\n                    distance_to_obstacle += step_size;\n                }\n            }\n            if (checkOccupancy(start_idx) && checkOccupancy(end_idx)) {\n                break;\n            }\n            step_size = step_size * 1.1;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 56.52960546572938}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// convert 3D coordinates to indices\n\tif (!ConvertToIndex(start_pt, start_idx) || !ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// check if start or end point is inside an obstacle\n\tif (IsOccupied(start_idx) || IsOccupied(end_idx)) {\n\t\t// move the points away from each other until they are no longer in an obstacle\n\t\tif (!AdjustStartEndPoints(start_idx, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 26.901530764339228}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  // set all values to unknown\n  for (Eigen::Array3i::Index x_id = min_pos(0); x_id <= max_pos(0); ++x_id) {\n    for (Eigen::Array3i::Index y_id = min_pos(1); y_id <= max_pos(1); ++y_id) {\n      for (Eigen::Array3i::Index z_id = min_pos(2); z_id <= max_pos(2); ++z_id) {\n        Eigen::Array3i id(x_id, y_id, z_id);\n        if (isValid(id, buffer_)) {\n          buffer_(x_id, y_id, z_id) = 0.0;\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 52.61406599236208}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    // Iterate over the grid cells within the specified limits\n    for (Eigen::Array3i i = min_pos.cast<int>(); i(2) < max_pos(2); i(2)++) {\n        for (i(1) = min_pos(1); i(1) < max_pos(1); i(1)++) {\n            for (i(0) = min_pos(0); i(0) < max_pos(0); i(0)++) {\n                // Get the corresponding index in the buffer\n                int idx = getIndex(i);\n                // Set the element in the buffer to zero\n                occupancy_buffer_inflate_(idx) = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 39.450142124961275}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  // Iterate over the grid cells\n  for (Eigen::Array3i i = min_pos.cast<int>(); i.matrix() <= max_pos.cast<int>(); i += Eigen::Array3i::Ones()) {\n    // Get the corresponding index in the buffer.\n    Eigen::Array3i index;\n    getIndexFromPosition(i.matrix().cast<double>(), index);\n    // Set the element in the buffer to zero.\n    occupancy_buffer_inflate_(index.x(), index.y(), index.z()) = 0.0;\n  }\n}", "CodeBleu_score": 28.905830034902248}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n    // Compute the difference vector between the point and the camera position\n    Eigen::Vector3d diff_vector = pt - camera_pt;\n\n    // Determine the maximum and minimum translation coefficients along each axis\n    double max_x = (diff_vector.x() > 0) ? (map_size_ - camera_pt.x()) / diff_vector.x() : (camera_pt.x() + map_size_) / diff_vector.x();\n    double max_y = (diff_vector.y() > 0) ? (map_size_ - camera_pt.y()) / diff_vector.y() : (camera_pt.y() + map_size_) / diff_vector.y();\n    double max_z = (diff_vector.z() > 0) ? (map_size_ - camera_pt.z()) / diff_vector.z() : (camera_pt.z() + map_size_) / diff_vector.z();\n    double min_x = (diff_vector.x() < 0) ? (map_size_ - camera_pt.x()) / diff_vector.x() : (camera_pt.x() + map_size_) / diff_vector.x();\n    double min_y = (diff_vector.y() < 0) ? (map_size_ - camera_pt.y()) / diff_vector.y() : (camera_pt.y() + map_size_) / diff_vector.y();\n    double min_z = (diff_vector.z() < 0) ? (map_size_ - camera_pt.z()) / diff_vector.z() : (camera_pt.z() + map_size_) / diff_vector.z();\n\n    // Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n    double scale = 1;\n    if (max_x > 0 && max_x < 1) {\n        scale = max_x;\n    }\n    if (max_y > 0 && max_y < scale) {\n        scale = max_y;\n    }\n    if (max_z > 0 && max_z < scale) {\n        scale = max_z", "CodeBleu_score": 38.56785068344597}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n    // Get the difference vector between the point and the camera position\n    Eigen::Vector3d diff_vector = pt - camera_pt;\n\n    // Determine the maximum and minimum translation coefficients along each axis\n    double max_x = std::max(std::abs(diff_vector(0)), std::abs(diff_vector(0) - map_size_x_));\n    double max_y = std::max(std::abs(diff_vector(1)), std::abs(diff_vector(1) - map_size_y_));\n    double max_z = std::max(std::abs(diff_vector(2)), std::abs(diff_vector(2) - map_size_z_));\n\n    // Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n    double scale_factor = 1;\n    if (max_x > 0) {\n        scale_factor = std::min(scale_factor, map_size_x_ / max_x);\n    }\n    if (max_y > 0) {\n        scale_factor = std::min(scale_factor, map_size_y_ / max_y);\n    }\n    if (max_z > 0) {\n        scale_factor = std::min(scale_factor, map_size_z_ / max_z);\n    }\n\n    // Return the adjusted point near the boundary\n    return camera_pt + scale_factor * diff_vector;\n}", "CodeBleu_score": 37.32357437310551}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    double min_scale = 1.0;\n    double max_scale = 1.0;\n    for (int i = 0; i < 3; i++) {\n        double scale = (diff(i) - min_x_ + 1.0) / diff(i);\n        if (scale > 0 && scale < min_scale) {\n            min_scale = scale;\n        }\n        scale = (diff(i) + max_x_ + 1.0) / diff(i);\n        if (scale > 0 && scale < max_scale) {\n            max_scale = scale;\n        }\n    }\n    double scale = std::min(min_scale, max_scale);\n    Eigen::Vector3d closest_pt = camera_pt + scale * diff;\n    return closest_pt;\n}", "CodeBleu_score": 46.81381784408424}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if an update is needed.\n  if (!md_.update_occupancy_)\n    return;\n\n  // Reset update flag.\n  md_.update_occupancy_ = false;\n\n  // Check if odometry is available.\n  if (!md_.odom_available_) {\n    ROS_ERROR(\"Odometry is not available. Stopping occupancy update thread.\");\n    md_.stop_occ_thread_ = true;\n    return;\n  }\n\n  // Check if depth image is available.\n  if (!md_.depth_image_available_) {\n    ROS_ERROR(\"Depth image is not available. Stopping occupancy update thread.\");\n    md_.stop_occ_thread_ = true;\n    return;\n  }\n\n  // Check if depth image is old.\n  if ((ros::Time::now() - md_.last_depth_image_time_).toSec() > md_.max_depth_image_age_) {\n    ROS_ERROR(\"Depth image is too old. Stopping occupancy update thread.\");\n    md_.stop_occ_thread_ = true;\n    return;\n  }\n\n  // Project depth image into points.\n  projectDepthImage();\n\n  // Process points with raycasting.\n  raycastProcess();\n\n  // Clear and inflate local map if needed.\n  if (md_.local_map_updated_) {\n    clearAndInflateLocalMap();\n  }\n}", "CodeBleu_score": 59.62587877685914}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Set last update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // If occupancy needs to be updated, project depth image into points and process them with raycasting.\n  if (md_.occ_need_update_) {\n    // Project depth image into points.\n    PointCloudT::Ptr points_raw(new PointCloudT);\n    projectDepthImage(points_raw);\n\n    // Process points with raycasting.\n    raycastProcess(points_raw);\n\n    // Clear and inflate local map.\n    clearAndInflateLocalMap();\n\n    // Set occupancy updated flag.\n    md_.occ_need_update_ = false;\n  }\n\n  // Handle timeout errors for odometry or depth data.\n  handleTimeoutError();\n}", "CodeBleu_score": 33.58811454372896}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  ROS_DEBUG(\"GridMap::updateOccupancyCallback\");\n  // Update last occupancy update time.\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // If an update is needed, update the occupancy grid.\n  if (md_.update_occupancy_grid_) {\n    // Project depth image into points.\n    ROS_DEBUG(\"GridMap::updateOccupancyCallback: Projecting depth image into points.\");\n    std::vector<Eigen::Vector3d, Eigen::aligned_allocator<Eigen::Vector3d> > points;\n    projectDepthImage(points);\n\n    // Process points with raycasting.\n    ROS_DEBUG(\"GridMap::updateOccupancyCallback: Processing points with raycasting.\");\n    raycastProcess(points);\n\n    // Clear and inflate local map if needed.\n    if (md_.clear_and_inflate_local_map_) {\n      ROS_DEBUG(\"GridMap::updateOccupancyCallback: Clearing and inflating local map.\");\n      clearAndInflateLocalMap();\n    }\n  }\n\n  // Handle timeout errors for odometry or depth data.\n  if (md_.use_depth_data_ && (ros::Time::now() - md_.last_depth_data_update_time_).toSec() > md_.timeout_depth_data_) {\n    ROS_WARN(\"GridMap::updateOccupancyCallback: Timeout for depth data. Resetting map.\");\n    resetMap();\n  }\n  if (md_.use_odometry_data_ && (ros::Time::now() - md_.last_odometry_update_time_).toSec() > md_.timeout_odometry_data_) {\n    ROS_WARN(\"GridMap::updateOccupancyCallback: Timeout for odometry data. Resetting map.\");\n    resetMap();\n  }\n}", "CodeBleu_score": 46.709458662815216}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\n    /*\n     * Initialize the accumulator for the average F-measure.\n     */\n    float avg_f_measure = 0;\n\n    /*\n     * Iterate through the image filenames.\n     */\n    for (int i = 0; i < image_fns.size(); i++) {\n\n        /*\n         * Load the image.\n         */\n        Mat image = imread(image_fns[i]);\n\n        /*\n         * Load the ground truth ellipses.\n         */\n        vector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\n        /*\n         * Load the detected ellipses.\n         */\n        vector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i], gt_angle_radians);\n\n        /*\n         * Evaluate the detection performance for this image.\n         */\n        float f_measure = _ellipse_evaluate_one(image, gt_ellipses, dt_ellipses);\n\n        /*\n         * Accumulate the F-measure.\n         */\n        avg_f_measure += f_measure;\n    }\n\n    /*\n     * Return the average F-measure.\n     */\n    return avg_f_measure / image_fns.size();\n}", "CodeBleu_score": 66.25795383700475}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat avg_fmeasure = 0.0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tMat image = imread(image_fns[i]);\n\t\tif (image.empty()) {\n\t\t\tcerr << \"Error: Could not load image from \" << image_fns[i] << endl;\n\t\t\texit(1);\n\t\t}\n\t\tvector<vector<Point2f> > gt_ellipses = _load_ellipse_GT(gt_fns[i], image.size(), gt_angle_radians);\n\t\tvector<vector<Point2f> > dt_ellipses = _load_ellipse_DT(dt_fns[i], image.size());\n\t\tavg_fmeasure += _ellipse_evaluate_one(image, gt_ellipses, dt_ellipses);\n\t}\n\treturn avg_fmeasure / image_fns.size();\n}", "CodeBleu_score": 60.55968592196758}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat total_f_measure = 0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\t// Load the ground truth ellipses.\n\t\tvector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\t// Load the detected ellipses.\n\t\tvector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i]);\n\t\t// Evaluate the detection performance.\n\t\tfloat f_measure = _ellipse_evaluate_one(image_fns[i], gt_ellipses, dt_ellipses);\n\t\t// Accumulate the F-measure.\n\t\ttotal_f_measure += f_measure;\n\t}\n\t// Return the average F-measure.\n\treturn total_f_measure / image_fns.size();\n}", "CodeBleu_score": 61.17547465706525}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle_diff;\n    float angle_diff_signed;\n    float angle_to_foci[2];\n    float normal_angle;\n\n    if (foci == NULL) {\n        return 0.0;\n    }\n\n    angle_to_foci[0] = atan2(y - foci[1], x - foci[0]);\n    angle_to_foci[1] = atan2(y - foci[3], x - foci[2]);\n    angle_diff = angle_to_foci[0] - angle_to_foci[1];\n    angle_diff_signed = fmod(angle_diff + M_PI, 2 * M_PI) - M_PI;\n    normal_angle = angle_to_foci[0] - angle_diff_signed / 2;\n    normal_angle = fmod(normal_angle + M_PI, 2 * M_PI) - M_PI;\n\n    return normal_angle;\n}", "CodeBleu_score": 51.73926398432589}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle1, angle2, angle_diff;\n\n    if (foci == NULL) {\n        return 0;\n    }\n\n    angle1 = atan2(y - foci[1], x - foci[0]);\n    angle2 = atan2(y - foci[3], x - foci[2]);\n    angle_diff = angle_diff_signed(angle1, angle2);\n\n    if (angle_diff < -M_PI) {\n        angle_diff += 2 * M_PI;\n    }\n    if (angle_diff > M_PI) {\n        angle_diff -= 2 * M_PI;\n    }\n\n    return angle_diff;\n}", "CodeBleu_score": 54.80392893504546}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle_diff = atan2(foci[1] - y, foci[0] - x) - atan2(foci[3] - y, foci[2] - x);\n    angle_diff = angle_diff_signed(angle_diff);\n    return fmodf(angle_diff + M_PI, 2 * M_PI) - M_PI;\n}", "CodeBleu_score": 26.43865409048266}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t  MIN = 1000000000;\n  MAX = 0;\n  int i;\n  for (i = start; i < end; i++) {\n    if (vp1[i].x < MIN)\n      MIN = vp1[i].x;\n    if (vp1[i].x > MAX)\n      MAX = vp1[i].x;\n    if (vp1[i].y < MIN)\n      MIN = vp1[i].y;\n    if (vp1[i].y > MAX)\n      MAX = vp1[i].y;\n  }\n  double integral_above = 0;\n  double integral_below = 0;\n  for (i = MIN; i < MAX; i++) {\n    int j;\n    for (j = start; j < end; j++) {\n      if (vp1[j].x == i) {\n        integral_above += vp1[j].y;\n      }\n      if (vp1[j].x == i + 1) {\n        integral_below += vp1[j].y;\n      }\n    }\n    if (integral_above < integral_below)\n      return false;\n  }\n  return true;\n}", "CodeBleu_score": 34.7660055000664}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t  int min_x = MIN(vp1[start].x, vp1[end].x);\n  int max_x = MAX(vp1[start].x, vp1[end].x);\n  int min_y = MIN(vp1[start].y, vp1[end].y);\n  int max_y = MAX(vp1[start].y, vp1[end].y);\n  int integral_above = 0;\n  int integral_below = 0;\n  for (int i = start; i <= end; i++) {\n    int x = vp1[i].x;\n    int y = vp1[i].y;\n    if (y == min_y) {\n      integral_above += x;\n      integral_below += max_x - x;\n    }\n  }\n  return integral_above > integral_below;\n}", "CodeBleu_score": 39.9816611372649}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint min_x = MIN, max_x = MAX, min_y = MIN, max_y = MAX;\n\tint x_int_above = 0, x_int_below = 0, y_int_above = 0, y_int_below = 0;\n\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tx_int_above += (vp1[i].y - min_y) * (vp1[i].x - min_x);\n\t\t\tx_int_below += (vp1[i].y - max_y) * (vp1[i].x - min_x);\n\t\t}\n\t\telse if (vp1[i].x > max_x) {\n\t\t\tx_int_above += (vp1[i].y - min_y) * (vp1[i].x - max_x);\n\t\t\tx_int_below += (vp1[i].y - max_y) * (vp1[i].x - max_x);\n\t\t}\n\t\telse {\n\t\t\tx_int_above += (vp1[i].y - min_y) * (vp1[i].x - min_x);\n\t\t\tx_int_below += (vp1[i].y - max_y) * (vp1[i].x - max_x);\n\t\t}\n\t}\n\n\tfor (int i = start; i <= end", "CodeBleu_score": 38.77583769181142}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\n    // \u8bc6\u522b\u7b97\u6cd5\u8f93\u51fa\u7684\u76ee\u6807\u6570\u636e\n    ellipse_det.object_name = msg->detected_objects[0].name;\n    ellipse_det.position.x = msg->detected_objects[0].position.x;\n    ellipse_det.position.y = msg->detected_objects[0].position.y;\n    ellipse_det.position.z = msg->detected_objects[0].position.z;\n    ellipse_det.velocity.x = msg->detected_objects[0].velocity.x;\n    ellipse_det.velocity.y = msg->detected_objects[0].velocity.y;\n    ellipse_det.velocity.z = msg->detected_objects[0].velocity.z;\n    ellipse_det.attitude.x = msg->detected_objects[0].attitude.x;\n    ellipse_det.attitude.y = msg->detected_objects[0].attitude.y;\n    ellipse_det.attitude.z = msg->detected_objects[0].attitude.z;\n    ellipse_det.size.x = msg->detected_objects[0].size.x;\n    ellipse_det.size.y = msg->detected_objects[0].size.y;\n    ellipse_det.size.z = msg->detected_objects[0].size.z;\n    ellipse_det.confidence = msg->detected_objects[0].confidence;\n\n    // \u68c0\u6d4b\u662f\u5426\u68c0\u6d4b\u5230\u76ee\u6807\n    if (ellipse_det.object_name == \"T\") {\n        num_regain++;\n        num_lost = 0;\n        is_detected = true;\n    } else {\n        num_regain = 0;\n        num_lost++;\n        is_detected = false;\n    }\n\n    // \u68c0\u6d4b\u662f\u5426\u8fde\u7eed\u4e22\u5931\u76ee\u6807\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n\n    // \ufffd\ufffd", "CodeBleu_score": 51.55851734432425}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  // ROS_INFO(\"ellipse_det_cb\");\n  if (msg->detected_infos.size() == 0) {\n    is_detected = false;\n    num_regain = 0;\n    num_lost = 0;\n    return;\n  }\n\n  for (int i = 0; i < msg->detected_infos.size(); i++) {\n    if (msg->detected_infos[i].name == \"T\") {\n      num_regain++;\n      num_lost = 0;\n      if (num_regain > VISION_THRES) {\n        is_detected = true;\n      }\n    } else {\n      num_lost++;\n      num_regain = 0;\n      if (num_lost > VISION_THRES) {\n        is_detected = false;\n      }\n    }\n  }\n\n  ellipse_det.sight_angle = msg->detected_infos[0].sight_angle;\n  ellipse_det.detected_num = msg->detected_infos.size();\n  ellipse_det.detected_info = msg->detected_infos;\n}", "CodeBleu_score": 64.14946513253959}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    ellipse_det.num_lost = 0;\n    ellipse_det.num_regain = 0;\n    ellipse_det.is_detected = false;\n    for (int i = 0; i < msg->detected_infos.size(); i++) {\n        if (msg->detected_infos[i].detected_objects[0].name == \"T\") {\n            ellipse_det.num_regain++;\n            ellipse_det.num_lost = 0;\n            ellipse_det.is_detected = true;\n        } else {\n            ellipse_det.num_lost++;\n            ellipse_det.num_regain = 0;\n        }\n    }\n    if (ellipse_det.num_lost > VISION_THRES) {\n        ellipse_det.is_detected = false;\n    }\n    if (ellipse_det.num_regain > VISION_THRES) {\n        ellipse_det.is_detected = true;\n    }\n    swap(ellipse_det.sight_angle[0], ellipse_det.sight_angle[1]);\n}", "CodeBleu_score": 42.76143057860421}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    //Check whether the current position is safe\n    Eigen::Vector3i cur_pos_id;\n    grid_map::Position cur_pos_p;\n    cur_pos_p(0) = cur_pos(0);\n    cur_pos_p(1) = cur_pos(1);\n    Occupy_map_ptr->getIndex(cur_pos_p, cur_pos_id);\n    if (Occupy_map_ptr->check_safety(cur_pos_id, safe_distance)) {\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 46.44277638024239}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t  Eigen::Vector3d cur_pos_map;\n  cur_pos_map = pos_body_to_world(cur_pos, cur_yaw);\n  Eigen::Vector3i cur_pos_grid;\n  grid_utility::posToIndex(cur_pos_map, cur_pos_grid);\n  Eigen::Vector3d cur_pos_grid_center;\n  grid_utility::indexToPos(cur_pos_grid, cur_pos_grid_center);\n\n  if (Occupy_map_ptr->check_safety(cur_pos_grid_center, safe_distance)) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 45.2489603343042}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    Eigen::Vector3d cur_pos_map;\n    cur_pos_map = pos_body_to_map(cur_pos);\n    return Occupy_map_ptr->check_safety(cur_pos_map, safe_distance);\n}", "CodeBleu_score": 52.631172961165326}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t  path_nodes_.push_back(end_node);\n  while (end_node->getParent() != nullptr) {\n    end_node = end_node->getParent();\n    path_nodes_.push_back(end_node);\n  }\n  reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 47.43795758815028}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\n  path_nodes_.push_back(end_node);\n  NodePtr current_node = end_node;\n\n  while (current_node->getParent() != nullptr) {\n    current_node = current_node->getParent();\n    path_nodes_.push_back(current_node);\n  }\n\n  std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.369187796473675}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n    while (current_node->parent != NULL) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n    reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 76.18144769446424}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n\n    if (simulation_mode) {\n        if ((start_pos-state_nei[id]).norm() > 5) {\n            get_nei_state = false;\n        } else {\n            get_nei_state = true;\n        }\n    }\n}", "CodeBleu_score": 44.74142994106344}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t  state_nei[id][0] = odom->pose.pose.position.x;\n  state_nei[id][1] = odom->pose.pose.position.y;\n  state_nei[id][2] = odom->pose.pose.position.z;\n\n  if(simulation_mode) {\n    if((start_pos-state_nei[id]).norm() > 5.0) {\n      get_nei_state = false;\n    }\n    else {\n      get_nei_state = true;\n    }\n  }\n}", "CodeBleu_score": 43.49525572251753}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t  if(id >= 0 && id < nei_num) {\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n    if(simulation_mode) {\n      if((start_pos-state_nei[id]).norm() > 5.0) {\n        get_nei_state = false;\n      }\n      else {\n        get_nei_state = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 46.850289678818434}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    sensor_update_counter++;\n    if (sensor_update_counter < 5) {\n        return;\n    }\n    sensor_update_counter = 0;\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*msg, cloud);\n    Astar_ptr->Occupy_map_ptr->map_update_gpcl(cloud, odom_x, odom_y, odom_yaw);\n}", "CodeBleu_score": 60.99354061149606}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  //ROS_INFO(\"PointCloud2 received\");\n  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  update_count++;\n  if (update_count < 5) {\n    return;\n  }\n  update_count = 0;\n  //ROS_INFO(\"PointCloud2 processed\");\n\n  // Convert to PCL\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  pcl::fromROSMsg(*msg, cloud);\n\n  // Update map\n  Astar_ptr->Occupy_map_ptr->map_update_gpcl(cloud);\n}", "CodeBleu_score": 61.38965196920976}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  sensor_update_count++;\n  if (sensor_update_count < 5) {\n    return;\n  }\n  sensor_update_count = 0;\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(*msg, *cloud);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl_ros::transformPointCloud(\"/map\", *cloud, *cloud_transformed, *tf_listener);\n  Astar_ptr->Occupy_map_ptr->map_update_gpcl(cloud_transformed);\n}", "CodeBleu_score": 57.53612207210978}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (get_gpcl) {\n        get_gpcl = false;\n        pcl::fromROSMsg(*global_point, *gpcl);\n        inflate_point_cloud(gpcl, 0.05);\n    }\n}", "CodeBleu_score": 46.532702131705555}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl) {\n    get_gpcl = false;\n    pcl::fromROSMsg(*global_point, *globalmap);\n    inflate_point_cloud(globalmap, globalmap_inflate);\n  }\n}", "CodeBleu_score": 46.44343826203037}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (!get_gpcl) {\n        get_gpcl = true;\n        pcl::fromROSMsg(*global_point, *global_map);\n        inflate_point_cloud(global_map, global_inflate_map);\n    }\n}", "CodeBleu_score": 52.656009256911915}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t  //std::cout << \"map_update_laser\" << std::endl;\n  //std::cout << \"local_point->header.stamp.sec: \" << local_point->header.stamp.sec << std::endl;\n  //std::cout << \"local_point->header.stamp.nsec: \" << local_point->header.stamp.nsec << std::endl;\n  //std::cout << \"odom.header.stamp.sec: \" << odom.header.stamp.sec << std::endl;\n  //std::cout << \"odom.header.stamp.nsec: \" << odom.header.stamp.nsec << std::endl;\n  //std::cout << \"odom.pose.pose.position.x: \" << odom.pose.pose.position.x << std::endl;\n  //std::cout << \"odom.pose.pose.position.y: \" << odom.pose.pose.position.y << std::endl;\n  //std::cout << \"odom.pose.pose.position.z: \" << odom.pose.pose.position.z << std::endl;\n  //std::cout << \"odom.pose.pose.orientation.x: \" << odom.pose.pose.orientation.x << std::endl;\n  //std::cout << \"odom.pose.pose.orientation.y: \" << odom.pose.pose.orientation.y << std::endl;\n  //std::cout << \"odom.pose.pose.orientation.z: \" << odom.pose.pose.orientation.z << std::endl;\n  //std::cout << \"odom.pose.pose.orientation.w: \" << odom.pose.pose.orientation.w << std::endl;\n  //std::cout << \"odom.twist.twist.linear.x: \" << odom.twist.twist.linear.x << std::endl;\n  //std::cout << \"odom.twist.twist.linear.y: \" << odom.twist.twist.linear.y << std::endl;\n  //std::cout << \"odom.twist.twist.", "CodeBleu_score": 9.549665343499083}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n  if (local_point->header.frame_id == \"odom\") {\n    ROS_WARN_STREAM(\"Laser scan frame_id is odom. This is not expected. The local map may not be accurate.\");\n  }\n\n  // Project the laser scan into a PointCloud2 format\n  sensor_msgs::PointCloud2 cloud;\n  projector_.projectLaser(*local_point, cloud);\n\n  // Convert the sensor_msgs::PointCloud2 to pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ> cloud_pcl;\n  pcl::fromROSMsg(cloud, cloud_pcl);\n\n  // If not in simulation mode, merge the local map with the provided odometry data\n  if (!simulation_mode_) {\n    local_map_merge_odom(cloud_pcl, odom);\n  }\n\n  // Update the occupancy map\n  map_update(cloud_pcl);\n}", "CodeBleu_score": 50.603621707124056}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n  // Update the map using the local map and odometry information\n  if (!simulation_) {\n\n    // Project the laser scan into a PointCloud2 format\n    sensor_msgs::PointCloud2 cloud;\n    projector_.projectLaser(*local_point, cloud);\n\n    // Convert the PointCloud2 to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ> local_map_temp;\n    pcl::fromROSMsg(cloud, local_map_temp);\n\n    // Merge the local map with the provided odometry data\n    local_map_merge_odom(local_map_temp, odom);\n\n  }\n\n}", "CodeBleu_score": 47.788304017133854}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    pcl::toROSMsg(*global_env_->pcl_ptr_, global_pcl_pub_);\n    global_pcl_pub_.header.frame_id = \"world\";\n    global_pcl_pub_.header.stamp = ros::Time::now();\n    global_pcl_pub_.height = 1;\n    global_pcl_pub_.width = global_env_->pcl_ptr_->size();\n    global_pcl_pub_.is_dense = false;\n    global_pcl_pub_.is_bigendian = false;\n    global_pcl_pub_.point_step = 16;\n    global_pcl_pub_.row_step = 16 * global_env_->pcl_ptr_->size();\n    global_pcl_pub_.data.resize(global_pcl_pub_.row_step * global_pcl_pub_.height);\n    global_pcl_pub_.fields.resize(4);\n    global_pcl_pub_.fields[0].name = \"x\";\n    global_pcl_pub_.fields[0].offset = 0;\n    global_pcl_pub_.fields[0].count = 1;\n    global_pcl_pub_.fields[0].datatype = 7;\n    global_pcl_pub_.fields[1].name = \"y\";\n    global_pcl_pub_.fields[1].offset = 4;\n    global_pcl_pub_.fields[1].count = 1;\n    global_pcl_pub_.fields[1].datatype = 7;\n    global_pcl_pub_.fields[2].name = \"z\";\n    global_pcl_pub_.fields[2].offset = 8;\n    global_pcl_pub_.fields[2].count = 1;\n    global_pcl_pub_.fields[2].datatype = 7;\n    global_pcl_pub_.fields[3].name = \"rgb\";\n    global_pcl_pub_.fields[3].offset = 12;\n    global_pcl_pub_.fields[3].count = 1;\n    global_pcl_", "CodeBleu_score": 32.15536348385732}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  pcl::PointCloud<pcl::PointXYZ> global_pcl;\n  pcl::PointCloud<pcl::PointXYZ> inflate_pcl;\n  global_pcl.points.clear();\n  inflate_pcl.points.clear();\n  for (int i = 0; i < N_row; ++i) {\n    for (int j = 0; j < N_col; ++j) {\n      if (occupancy_grid_map[i][j] == 1) {\n        pcl::PointXYZ point;\n        point.x = i;\n        point.y = j;\n        point.z = 0;\n        global_pcl.points.push_back(point);\n      }\n      if (occupancy_grid_map[i][j] == 2) {\n        pcl::PointXYZ point;\n        point.x = i;\n        point.y = j;\n        point.z = 0;\n        inflate_pcl.points.push_back(point);\n      }\n    }\n  }\n  pcl::toROSMsg(global_pcl, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n  pcl::toROSMsg(inflate_pcl, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 54.52759313644619}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(*global_pcl_ptr, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(*inflate_pcl_ptr, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 65.00100525627361}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    //ROS_INFO(\"Pointcloud received\");\n    if (!odom_ready) {\n        ROS_WARN(\"Odometry not ready\");\n        return;\n    }\n    sensor_ready = true;\n    Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, odom_x, odom_y, odom_yaw);\n}", "CodeBleu_score": 74.28861824988148}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (odom_ready) {\n        sensor_ready = true;\n        Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, odom_pos_curr);\n    }\n}", "CodeBleu_score": 61.270214707223566}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (odom_ready) {\n    sensor_ready = true;\n  }\n  Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n}", "CodeBleu_score": 49.87093783300298}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Get current time\n  ros::Time current_time = ros::Time::now();\n  // Get time since last control loop\n  ros::Duration dt = current_time - last_control_loop_time_;\n  last_control_loop_time_ = current_time;\n\n  // Get current pose\n  quadKD_->getCurrentPose(current_pose_);\n\n  // Get desired pose\n  quadKD_->getDesiredPose(desired_pose_);\n\n  // Compute target foot positions\n  body_controller_.poseCommand(desired_pose_, current_pose_, dt.toSec(),\n                              target_foot_positions_);\n\n  // Compute velocity commands for legs\n  leg_controller_.velocityCommand(target_foot_positions_, current_pose_,\n                                 current_velocities_, dt.toSec(),\n                                 target_joint_velocities_);\n\n  // Perform inverse kinematics to determine target joint positions\n  kinematics_.inverse(target_joint_positions_, target_foot_positions_);\n\n  // Publish foot contact information\n  publishFootContacts_();\n\n  // Publish joint positions\n  publishJoints_();\n}", "CodeBleu_score": 49.107817627285435}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Get the current time\n  ros::Time current_time = ros::Time::now();\n\n  // Get the duration since the last time this function was called\n  ros::Duration elapsed_time = current_time - last_loop_time_;\n  last_loop_time_ = current_time;\n\n  // Get the current state of the robot\n  quad_utils::QuadKD quad_kd = state_estimate_->getQuadKD();\n\n  // Update the body controller\n  body_controller_.update(quad_kd, elapsed_time);\n\n  // Get the current desired pose from the body controller\n  Eigen::Vector3d desired_position = body_controller_.getDesiredPosition();\n  Eigen::Quaterniond desired_orientation = body_controller_.getDesiredOrientation();\n\n  // Get the current desired twist from the body controller\n  Eigen::Vector3d desired_linear_velocity = body_controller_.getDesiredLinearVelocity();\n  Eigen::Vector3d desired_angular_velocity = body_controller_.getDesiredAngularVelocity();\n\n  // Get the current desired acceleration from the body controller\n  Eigen::Vector3d desired_linear_acceleration = body_controller_.getDesiredLinearAcceleration();\n  Eigen::Vector3d desired_angular_acceleration = body_controller_.getDesiredAngularAcceleration();\n\n  // Get the current desired pose and twist of the body\n  Eigen::Vector3d current_position = quad_kd.getBasePosition();\n  Eigen::Quaterniond current_orientation = quad_kd.getBaseOrientation();\n  Eigen::Vector3d current_linear_velocity = quad_kd.getBaseLinearVelocity();\n  Eigen::Vector3d current_angular_velocity = quad_kd.getBaseAngularVelocity();\n\n  // Get the current desired pose and twist of the body\n  Eigen::Vector3d current_linear_acceleration = quad_kd.getBaseLinearAcceleration();\n  Eigen::Vector3d current_angular_acceleration = quad_kd.getBaseAng", "CodeBleu_score": 36.37465239528347}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // get current time\n    ros::Time current_time = ros::Time::now();\n\n    // get the desired pose\n    geometry_msgs::Pose desired_pose;\n    try {\n        desired_pose = ros::topic::waitForMessage<geometry_msgs::Pose>(desired_pose_topic_, ros::Duration(0.01));\n    }\n    catch (...) {\n        ROS_WARN(\"No desired pose received, using previous pose.\");\n        desired_pose = previous_desired_pose_;\n    }\n\n    // convert the desired pose to the local frame\n    geometry_msgs::Pose desired_pose_local;\n    desired_pose_local.position = desired_pose.position;\n    desired_pose_local.position.x = desired_pose.position.x * cos(desired_pose.orientation.z) - desired_pose.position.y * sin(desired_pose.orientation.z);\n    desired_pose_local.position.y = desired_pose.position.x * sin(desired_pose.orientation.z) + desired_pose.position.y * cos(desired_pose.orientation.z);\n    desired_pose_local.orientation = desired_pose.orientation;\n\n    // store the desired pose for next time\n    previous_desired_pose_ = desired_pose_local;\n\n    // get the desired velocity\n    geometry_msgs::Twist desired_velocity;\n    try {\n        desired_velocity = ros::topic::waitForMessage<geometry_msgs::Twist>(desired_velocity_topic_, ros::Duration(0.01));\n    }\n    catch (...) {\n        ROS_WARN(\"No desired velocity received, using previous velocity.\");\n        desired_velocity = previous_desired_velocity_;\n    }\n\n    // store the desired velocity for next time\n    previous_desired_velocity_ = desired_velocity;\n\n    // calculate the target foot positions\n    geometry_msgs::Pose foot_position_left_front;\n    geometry_msgs::Pose foot_position_left_hind;\n    geometry_msgs::Pose foot_position_right_front;\n", "CodeBleu_score": 32.88584266187494}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_enabled_ && !gazebo_) {\n    quad_msgs::ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.header.frame_id = base_frame_;\n    contacts_msg.contacts.resize(4);\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i] = foot_contacts[i];\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 69.47148206043936}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_enabled_ && !gazebo_mode_) {\n    quad_msgs::ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.header.frame_id = \"odom\";\n    contacts_msg.contacts.resize(4);\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i].contact = foot_contacts[i];\n      contacts_msg.contacts[i].gait_phase = base_.legs[i]->gait_phase;\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 66.48200278634857}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (publish_foot_contacts_ && !gazebo_simulation_) {\n    quad_msgs::ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.header.frame_id = base_frame_id_;\n    contacts_msg.contacts.resize(4);\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i].name = base_.legs[i]->getFootName();\n      contacts_msg.contacts[i].state = foot_contacts[i];\n      contacts_msg.contacts[i].gait_phase = base_.legs[i]->gait_phase;\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 65.15142939309602}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    msg = Joints()\n    msg.name = joints.name\n    msg.position = joints.position[0:12]\n    msg.header.stamp = get_clock().now().to_msg()\n    self.get_logger().info(\"Joints command received\")\n    self.pub_joints.publish(msg)\n    self.pub_traj.publish(self.make_traj(msg.position, 1.0))\n}", "CodeBleu_score": 30.755464012883397}, {"code": "def joints_cmd_callback(self, joints){\n\t    // Create a minimal joints message\n    var msg = Joints()\n    msg.header.stamp = now()\n    msg.header.frame_id = \"base_link\"\n    msg.name = [ \"right_j0\", \"right_j1\", \"right_j2\", \"right_j3\", \"right_j4\", \"right_j5\", \"right_j6\", \"left_j0\", \"left_j1\", \"left_j2\", \"left_j3\", \"left_j4\", \"left_j5\", \"left_j6\" ]\n    msg.position = joints.position[0:12]\n    msg.velocity = []\n    msg.effort = []\n    publish(\"joints\", msg)\n\n    // Create a joint trajectory message\n    var traj = JointTrajectory()\n    traj.header.stamp = now()\n    traj.header.frame_id = \"base_link\"\n    traj.joint_names = [ \"right_j0\", \"right_j1\", \"right_j2\", \"right_j3\", \"right_j4\", \"right_j5\", \"right_j6\", \"left_j0\", \"left_j1\", \"left_j2\", \"left_j3\", \"left_j4\", \"left_j5\", \"left_j6\" ]\n    var point = JointTrajectoryPoint()\n    point.positions = joints.position[0:12]\n    point.velocities = []\n    point.accelerations = []\n    point.effort = []\n    point.time_from_start = duration(0.5)\n    traj.points = [ point ]\n    publish(\"joint_trajectory\", traj)\n}", "CodeBleu_score": 43.041909869054564}, {"code": "def joints_cmd_callback(self, joints){\n\t    self.joints = joints\n    self.joints_msg = Joints()\n    self.joints_msg.name = joints.name\n    self.joints_msg.position = joints.position[0..11]\n    self.joints_msg.velocity = joints.velocity[0..11]\n    self.joints_msg.effort = joints.effort[0..11]\n    self.joints_pub.publish(self.joints_msg)\n\n    self.joint_traj_msg = JointTrajectory()\n    self.joint_traj_msg.header.stamp = getCurrentTime()\n    self.joint_traj_msg.joint_names = joints.name[0..11]\n    self.joint_traj_msg.points = [JointTrajectoryPoint()]\n    self.joint_traj_msg.points[0].positions = joints.position[0..11]\n    self.joint_traj_msg.points[0].velocities = joints.velocity[0..11]\n    self.joint_traj_msg.points[0].accelerations = joints.acceleration[0..11]\n    self.joint_traj_msg.points[0].time_from_start = Duration(0.25)\n    self.joint_traj_pub.publish(self.joint_traj_msg)\n}", "CodeBleu_score": 31.429943795407354}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  // Initialize foot contact states to false\n  foot_contact_states_.left_contact = false;\n  foot_contact_states_.right_contact = false;\n  // Loop through all contacts in the message\n  for (int i = 0; i < _msg->contact_size(); ++i) {\n    // Split the collision1 string into link names\n    std::string link_1 = _msg->contact(i).collision1();\n    std::vector<std::string> link_1_split;\n    boost::split(link_1_split, link_1, boost::is_any_of(\"/\"));\n    // Split the collision2 string into link names\n    std::string link_2 = _msg->contact(i).collision2();\n    std::vector<std::string> link_2_split;\n    boost::split(link_2_split, link_2, boost::is_any_of(\"/\"));\n    // Check if the contact is between a foot link and the ground\n    if (link_1_split.back() == \"l_sole\" && link_2_split.back() == \"world\") {\n      foot_contact_states_.left_contact = true;\n    }\n    if (link_1_split.back() == \"r_sole\" && link_2_split.back() == \"world\") {\n      foot_contact_states_.right_contact = true;\n    }\n  }\n}", "CodeBleu_score": 42.989369033728366}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  // Initialize foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    footContactState_[i] = false;\n  }\n\n  // For each contact in the message, split the collision string to identify the contact link\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::string collision1 = _msg->contact(i).collision1();\n    std::string collision2 = _msg->contact(i).collision2();\n\n    std::size_t found = collision1.find(robotNamespace_);\n    if (found!=std::string::npos) {\n      collision1.replace(found, robotNamespace_.size(), \"\");\n    }\n    found = collision2.find(robotNamespace_);\n    if (found!=std::string::npos) {\n      collision2.replace(found, robotNamespace_.size(), \"\");\n    }\n\n    // Check if the collision is a foot\n    for (int j = 0; j < 4; j++) {\n      if (collision1 == footLinks_[j] || collision2 == footLinks_[j]) {\n        footContactState_[j] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 60.91351974430819}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    // Initialize all foot contacts to false\n    foot_contacts_[0] = false;\n    foot_contacts_[1] = false;\n    foot_contacts_[2] = false;\n    foot_contacts_[3] = false;\n\n    // For each contact\n    for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n        // Split the collision1 string into two strings\n        std::string name1 = _msg->contact(i).collision1();\n        std::string name2 = _msg->contact(i).collision2();\n        std::size_t found = name1.find_last_of(\"/\");\n        std::string link_name1 = name1.substr(found + 1);\n        found = name2.find_last_of(\"/\");\n        std::string link_name2 = name2.substr(found + 1);\n        // Check if the link name matches any of the foot links\n        if (link_name1 == foot_link_names_[0] || link_name2 == foot_link_names_[0]) {\n            foot_contacts_[0] = true;\n        }\n        if (link_name1 == foot_link_names_[1] || link_name2 == foot_link_names_[1]) {\n            foot_contacts_[1] = true;\n        }\n        if (link_name1 == foot_link_names_[2] || link_name2 == foot_link_names_[2]) {\n            foot_contacts_[2] = true;\n        }\n        if (link_name1 == foot_link_names_[3] || link_name2 == foot_link_names_[3]) {\n            foot_contacts_[3] = true;\n        }\n    }\n}", "CodeBleu_score": 45.5771723304812}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  const Eigen::Vector3d desired_acceleration =\n      ComputeDesiredAcceleration(desired_state_.position, desired_state_.velocity,\n                                 odometry_.position, odometry_.velocity);\n\n  const Eigen::Vector3d angular_acceleration_thrust =\n      ComputeDesiredAngularAcc(desired_state_.position, desired_state_.attitude,\n                               odometry_.position, odometry_.orientation);\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  *rotor_velocities = vehicle_parameters_.rotor_configuration_.rotor_direction.transpose() *\n                      (angular_acceleration_thrust +\n                       vehicle_parameters_.rotor_configuration_.inertia.asDiagonal() *\n                           desired_acceleration);\n\n  // Limit the rotor velocities by the physical limitations of the system.\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n  *rotor_velocities = rotor_velocities->cwiseMax(\n      Eigen::VectorXd::Zero(rotor_velocities->rows()));\n}", "CodeBleu_score": 59.214190960129244}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d angular_acceleration_thrust;\n  ComputeDesiredAcceleration(&desired_acceleration, &angular_acceleration_thrust);\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  *rotor_velocities = vehicle_parameters_.rotor_configuration_.rotor_direction.transpose() *\n                      angular_acceleration_thrust +\n                      vehicle_parameters_.rotor_configuration_.rotor_direction.transpose() *\n                      (desired_acceleration.dot(odometry_.orientation.toRotationMatrix().col(2)) *\n                       Eigen::VectorXd::Ones(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()) *\n                                                 vehicle_parameters_.rotor_configuration_.min_rotor_speed);\n}", "CodeBleu_score": 57.508265120174876}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() ==\n         vehicle_parameters_.rotor_configuration_.rotors.size());\n  assert(odometry_.position_W.allFinite());\n  assert(odometry_.orientation.allFinite());\n  assert(odometry_.angular_velocity_B.allFinite());\n  assert(odometry_.linear_velocity_B.allFinite());\n  assert(odometry_.linear_acceleration_B.allFinite());\n  assert(command_.thrust.allFinite());\n  assert(command_.bodyrates.allFinite());\n  assert(command_.collective_thrust.allFinite());\n\n  if (!IsControllerActive()) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Compute the desired acceleration.\n  const Eigen::Vector3d desired_acceleration =\n      ComputeDesiredAcceleration();\n\n  // Compute the desired angular acceleration.\n  const Eigen::Vector3d desired_angular_acceleration =\n      ComputeDesiredAngularAcceleration();\n\n  // Project thrust onto the body z-axis.\n  const Eigen::Vector3d thrust_in_body =\n      odometry_.orientation.toRotationMatrix() *\n      Eigen::Vector3d(0.0, 0.0, command_.thrust.z());\n\n  // Combine thrust and angular acceleration into a single vector.\n  Eigen::Vector3d thrust_and_angular_acceleration =\n      desired_acceleration + thrust_in_body + desired_angular_acceleration;\n\n  // Project thrust and angular acceleration onto the rotor axis.\n  rotor_velocities->resize(\n      vehicle_parameters_.rotor_configuration_.rotors.size());\n  for (int i = 0; i < rotor_velocities->rows(); ++i) {\n    (*rotor_velocities)(i) =\n        vehicle_parameters_.rotor_configuration_.rotors.at(i).direction.dot(\n            thrust_and_angular_acceleration);", "CodeBleu_score": 45.777951857318875}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // TODO(Student): Implement this function\n  // Compute position error\n  Eigen::Vector3d position_error = command_trajectory_.get_position() - odometry_.position;\n\n  // Compute velocity error\n  Eigen::Vector3d velocity_error = command_trajectory_.get_velocity() - odometry_.velocity;\n\n  // Compute acceleration\n  *acceleration = position_error.cwiseProduct(kp_position_) +\n                  velocity_error.cwiseProduct(kp_velocity_) +\n                  odometry_.orientation.toRotationMatrix() * command_trajectory_.get_acceleration() -\n                  kd_velocity_.cwiseProduct(velocity_error) -\n                  mass_ * gravity_ +\n                  mass_ * odometry_.linear_acceleration;\n}", "CodeBleu_score": 40.76141985595989}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration);\n  // Get the current vehicle position.\n  const Eigen::Vector3d position = vehicle_state_provider_->pose().position();\n  const Eigen::Vector3d vehicle_velocity =\n      vehicle_state_provider_->linear_velocity();\n\n  // Get the current vehicle heading.\n  const Eigen::Quaternion<double> orientation =\n      vehicle_state_provider_->pose().heading();\n\n  // Get the current vehicle acceleration.\n  const Eigen::Vector3d current_acceleration =\n      vehicle_state_provider_->linear_acceleration();\n\n  // Get the current vehicle velocity.\n  const Eigen::Vector3d current_velocity =\n      vehicle_state_provider_->linear_velocity();\n\n  // Get the current vehicle angular rate.\n  const Eigen::Vector3d current_angular_rate =\n      vehicle_state_provider_->angular_rate();\n\n  // Get the current timestamp.\n  const double current_timestamp_sec =\n      vehicle_state_provider_->timestamp();\n\n  // Get the current target trajectory.\n  const TrajectoryPoint& trajectory_point =\n      trajectory_analyzer_->trajectory_point();\n\n  // Get the current target acceleration.\n  const Eigen::Vector3d target_acceleration =\n      trajectory_analyzer_->trajectory_point().a();\n\n  // Get the current target velocity.\n  const Eigen::Vector3d target_velocity =\n      trajectory_analyzer_->trajectory_point().v();\n\n  // Get the current target position.\n  const Eigen::Vector3d target_position =\n      trajectory_analyzer_->trajectory_point().path_point().x();\n\n  // Get the current target heading.\n  const Eigen::Quaternion<double> target_orientation =\n      trajectory_analyzer_->trajectory_point().path_point().theta();\n\n  // Get the current target time.\n  const double target_time = trajectory_analyzer_->trajectory_point().relative_time();\n\n  // Compute the position and", "CodeBleu_score": 30.400293399789874}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // TODO(Student): Implement this function\n  // Hint: Use the following variables:\n  //   - this->world_frame_id_\n  //   - this->command_trajectory_\n  //   - this->current_odometry_\n  //   - this->mass_\n  //   - this->gravity_\n  //   - this->commanded_acceleration_\n  //   - this->position_error_gain_\n  //   - this->velocity_error_gain_\n\n  // Get the current odometry\n  const auto& current_odometry = this->current_odometry_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the current time\n  const auto& current_time = this->current_time_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the command trajectory\n  const auto& command_trajectory = this->command_trajectory_;\n\n  // Get the", "CodeBleu_score": 13.765330536030904}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  // Ensure the parameters are valid.\n  assert(attitude_gain_kp_ > 0.0);\n  assert(attitude_gain_ki_ >= 0.0);\n  assert(angular_acceleration_thrust_gain_ > 0.0);\n  assert(angular_acceleration_thrust_gain_i_ >= 0.0);\n  assert(angular_acceleration_thrust_gain_d_ >= 0.0);\n  assert(min_rotor_velocity_ > 0.0);\n  assert(max_rotor_velocity_ > min_rotor_velocity_);\n\n  // Resize the rotor velocities vector to match the number of rotors.\n  rotor_velocities->resize(number_rotors_);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration =\n      CalculateDesiredAngularAcceleration(attitude_gain_kp_, attitude_gain_ki_,\n                                          angular_acceleration_thrust_gain_,\n                                          angular_acceleration_thrust_gain_i_,\n                                          angular_acceleration_thrust_gain_d_,\n                                          control_attitude_thrust_reference_,\n                                          attitude_estimate_);\n\n  // Combine the desired angular acceleration with the thrust reference.\n  Eigen::VectorXd desired_angular_acceleration_thrust =\n      Eigen::VectorXd::Ones(number_rotors_);\n  desired_angular_acceleration_thrust.block<3, 1>(0, 0) =\n      desired_angular_acceleration;\n\n  // Calculate the rotor velocities.\n  *rotor_velocities = rotor_acceleration_matrix_ * desired_angular_acceleration_thrust;\n\n  // Ensure the rotor velocities are at least one.\n  *rotor_velocities = rotor_velocities->", "CodeBleu_score": 43.79265811362134}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == 0);\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(rotor_acceleration_thrust_.rows());\n\n  // Compute the desired angular acceleration.\n  const Eigen::Vector3d angular_acceleration_thrust =\n      ComputeDesiredAngularAcc(control_attitude_thrust_reference_);\n\n  // Combine the desired angular acceleration and thrust reference.\n  Eigen::VectorXd rotor_acceleration_thrust =\n      rotor_acceleration_thrust_.cwiseProduct(angular_acceleration_thrust);\n\n  // Compute the rotor velocities.\n  rotor_acceleration_thrust = rotor_acceleration_thrust + control_attitude_thrust_reference_;\n  *rotor_velocities = rotor_acceleration_thrust.cwiseSqrt();\n\n  // Ensure the rotor velocities are at least one.\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()));\n}", "CodeBleu_score": 55.754079827865034}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == 0 ||\n         rotor_velocities->size() == rotor_count_);\n  assert(rotor_count_ >= 4);\n  assert(rotor_count_ <= 6);\n  assert(kDefaultRotorParameters.size() == rotor_count_);\n  assert(kDefaultRotorParameters[0].size() == 2);\n\n  rotor_velocities->resize(rotor_count_);\n  rotor_velocities->setZero();\n\n  // Calculate desired angular acceleration.\n  Eigen::Vector3d angular_acceleration_thrust;\n  CalculateDesiredAngularAcceleration(&angular_acceleration_thrust);\n\n  // Combine the angular acceleration and thrust reference into a single vector.\n  Eigen::VectorXd angular_acceleration_thrust_reference(rotor_count_);\n  angular_acceleration_thrust_reference.block<3, 1>(0, 0) =\n      angular_acceleration_thrust;\n  angular_acceleration_thrust_reference.block<3, 1>(3, 0) =\n      control_attitude_thrust_reference_.block<3, 1>(3, 0);\n\n  // Compute rotor velocities.\n  *rotor_velocities =\n      kRotorVelocitiesMatrix * angular_acceleration_thrust_reference;\n  rotor_velocities->cwiseSqrt();\n  rotor_velocities->rows(0, 3) =\n      rotor_velocities->rows(0, 3).cwiseMax(Eigen::VectorXd::Ones(3));\n}", "CodeBleu_score": 56.917312693154074}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices corresponding to the start and end times\n    start_index = self.get_next_index(start_time, self.time_index)\n    end_index = self.get_next_index(end_time, self.time_index)\n\n    # Make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n\n    # Slice each attribute of the copied object\n    copied_obj.time_index = self.time_index[start_index:end_index]\n    copied_obj.time = self.time[start_index:end_index]\n    copied_obj.time_units = self.time_units\n    copied_obj.time_label = self.time_label\n    copied_obj.time_step = self.time_step\n    copied_obj.time_step_units = self.time_step_units\n    copied_obj.time_step_label = self.time_step_label\n    copied_obj.time_step_type = self.time_step_type\n    copied_obj.time_step_type_label = self.time_step_type_label\n    copied_obj.time_step_type_units = self.time_step_type_units\n    copied_obj.time_step_type_factor = self.time_step_type_factor\n    copied_obj.time_step_type_factor_units = self.time_step_type_factor_units\n    copied_obj.time_step_type_factor_label = self.time_step_type_factor_label\n    copied_obj.time_step_type_factor_type = self.time_step_type_factor_type\n    copied_obj.time_step_type_factor_type_units = self.time_step_type_factor_type_units\n    copied_obj.time_step_type_factor_type_label = self.time_step_type_factor_type_label\n    copied_obj.time_step_type_factor_type_type = self.time_step_type_factor_type_type\n    copied_obj.time_step_type_factor_type_", "CodeBleu_score": 23.219642800705728}, {"code": "def slice(self, start_time, end_time)\n\t\n    # get the indices corresponding to the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n    # update each attribute of the copied object to contain only the sliced data\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.latitude = copied_obj.latitude[start_index:end_index]\n    copied_obj.longitude = copied_obj.longitude[start_index:end_index]\n    copied_obj.altitude = copied_obj.altitude[start_index:end_index]\n    copied_obj.x = copied_obj.x[start_index:end_index]\n    copied_obj.y = copied_obj.y[start_index:end_index]\n    copied_obj.z = copied_obj.z[start_index:end_index]\n    copied_obj.vx = copied_obj.vx[start_index:end_index]\n    copied_obj.vy = copied_obj.vy[start_index:end_index]\n    copied_obj.vz = copied_obj.vz[start_index:end_index]\n    copied_obj.qw = copied_obj.qw[start_index:end_index]\n    copied_obj.qx = copied_obj.qx[start_index:end_index]\n    copied_obj.qy = copied_obj.qy[start_index:end_index]\n    copied_obj.qz = copied_obj.qz[start_index:end_index]\n    copied_obj.p = copied_obj.p[start_index:end_index]\n    copied_obj.q = copied_obj.q[start_index:end_index]\n    copied_obj.r = copied_obj.r[start_index:end_index]\n    copied_obj.ax = copied_obj.ax[start_index:end_index]\n    copied_obj.ay =", "CodeBleu_score": 22.104117165988352}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_index_from_time(start_time)\n    end_index = self.get_index_from_time(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attribute in self.__dict__:\n        if attribute != \"time\":\n            copied_obj.__setattr__(attribute, copied_obj.__getattribute__(attribute)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 49.10665283040561}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    yaw = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])[2]\n\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint is None or self.last_waypoint != point or self.last_yaw != yaw:\n        # Append the new point, yaw, and times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(yaw)\n        self.append_times(msg_time, bag_time)\n\n        # Update the last waypoint and yaw\n        self.last_waypoint = point\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 25.97260561163801}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n\n    position = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    euler_angles = euler_from_quaternion(quaternion)\n    yaw = euler_angles[2]\n\n    point = Point(position.x, position.y, position.z)\n\n    if self.waypoints:\n        if point != self.waypoints[-1] or yaw != self.yaw[-1]:\n            self.waypoints.append(point)\n            self.yaw.append(yaw)\n            self.waypoint_times.append(msg_time)\n            self.append_times.append(bag_time)\n\n    else:\n        self.waypoints.append(point)\n        self.yaw.append(yaw)\n        self.waypoint_times.append(msg_time)\n        self.append_times.append(bag_time)\n\n    self.append_point = point\n\n", "CodeBleu_score": 29.57474684150072}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    yaw = euler_from_quaternion(rotation.x, rotation.y, rotation.z, rotation.w)[2]\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the waypoint is different from the last one\n    if self.waypoints:\n        if point != self.waypoints[-1] or yaw != self.yaw[-1]:\n            self.append_point(point, yaw, msg_time, bag_time)\n    else:\n        self.append_point(point, yaw, msg_time, bag_time)\n", "CodeBleu_score": 23.221116850817012}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_accel_x.append(msg.linear_acceleration.x)\n        self.imu_accel_y.append(msg.linear_acceleration.y)\n        self.imu_accel_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(to_sec(msg.header.stamp))\n        self.imu_bag_time.append(bag_time)\n", "CodeBleu_score": 29.957212971615316}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.acceleration.x.append(msg.linear_acceleration.x)\n        self.acceleration.y.append(msg.linear_acceleration.y)\n        self.acceleration.z.append(msg.linear_acceleration.z)\n        self.acceleration.time.append(to_sec(msg.header.stamp))\n        self.acceleration.bag_time.append(bag_time)\n    elif topic == \"/imu_2/data\":\n        self.acceleration.x.append(msg.linear_acceleration.x)\n        self.acceleration.y.append(msg.linear_acceleration.y)\n        self.acceleration.z.append(msg.linear_acceleration.z)\n        self.acceleration.time.append(to_sec(msg.header.stamp))\n        self.acceleration.bag_time.append(bag_time)\n\n", "CodeBleu_score": 30.663661199932225}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n\n    # Extracts the IMU message timestamp and converts it to seconds\n    msg_time = msg.header.stamp.secs + msg.header.stamp.nsecs * 10**-9\n\n    # Appends the IMU message timestamp and bag time to the time attributes\n    self.time.append(msg_time)\n    self.bag_time.append(bag_time)\n\n    # If the IMU topic matches, appends the IMU message linear acceleration data to the corresponding x, y, and z attributes\n    if topic == self.imu_topic_x:\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n    elif topic == self.imu_topic_y:\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n    elif topic == self.imu_topic_z:\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n", "CodeBleu_score": 26.980396582296052}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure(figsize=(10, 10))\n    fig.suptitle(\"Acceleration Data\", fontsize=16)\n    ax = fig.add_subplot(111)\n    for i, a_x in enumerate(self.accelerations):\n        ax.plot(a_x, label=f\"x_{i}\")\n        ax.plot(self.accelerations[i], label=f\"y_{i}\")\n        ax.plot(self.accelerations[i], label=f\"z_{i}\")\n    pyplot.ylabel(\"Acceleration (g)\")\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.legend()\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        else:\n            plot_suffix = f\"_{plot_suffix}\"\n        pyplot.savefig(f\"{self.plot_prefix}{plot_suffix}.png\")\n\n", "CodeBleu_score": 35.941568011642175}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure(figsize=(12, 8))\n    fig.suptitle('Acceleration data for ' + self.filename)\n    ax = fig.add_subplot(111)\n    for i, accel_data in enumerate(self.acceleration_data):\n        ax.plot(accel_data['time'], accel_data['x'], color='r', label='x')\n        ax.plot(accel_data['time'], accel_data['y'], color='g', label='y')\n        ax.plot(accel_data['time'], accel_data['z'], color='b', label='z')\n    pyplot.ylabel('Acceleration (g)')\n    pyplot.xlabel('Time (s)')\n    pyplot.legend(loc='lower right')\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        else:\n            plot_suffix = '_' + plot_suffix\n        pyplot.savefig(self.plot_prefix + 'accelerations' + plot_suffix + '.png')\n    pyplot.show()\n\n", "CodeBleu_score": 38.34239265775336}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if plot_suffix is None:\n        plot_suffix = \"\"\n    fig = pyplot.figure(figsize=(12, 8))\n    fig.suptitle(\"Accelerations\" + plot_suffix)\n    ax = fig.add_subplot(111)\n    for i, accel in enumerate(self.accelerations):\n        ax.plot(accel.time, accel.x, label=\"x\" + str(i))\n        ax.plot(accel.time, accel.y, label=\"y\" + str(i))\n        ax.plot(accel.time, accel.z, label=\"z\" + str(i))\n    pyplot.xlabel(\"time (s)\")\n    pyplot.ylabel(\"acceleration (g)\")\n    pyplot.legend()\n    if self.save_plots:\n        pyplot.savefig(\"accelerations\" + plot_suffix + \".png\")\n\n", "CodeBleu_score": 38.84250690949047}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 22.721902746548402}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: This function requires at least two pose indices to perform comparisons.\")\n        return\n    for i, pose_index in enumerate(pose_indeces):\n        for j in range(i+1, len(pose_indeces)):\n            compare_two_xyz(self, pose_index, pose_indeces[j])\n\n", "CodeBleu_score": 41.89032136589089}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # print(pose_indeces)\n    if len(pose_indeces) < 2:\n        raise ValueError(\"At least two pose indices are required for comparison.\")\n    else:\n        for i in range(len(pose_indeces)):\n            for j in range(i+1, len(pose_indeces)):\n                self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 27.718617845916466}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision[0] <= end_time:\n            collision_times.append(collision[0])\n    return collision_times\n\n", "CodeBleu_score": 35.233707661425264}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 38.827983576462124}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is None or collision.time >= start_time:\n            if end_time is None or collision.time <= end_time:\n                collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 45.96368105075696}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    # Calculate the absolute settling time\n    abs_settling_time = start_time + settling_time\n\n    # Call analyze_bag.plot_angular_velocities with the specified start time, end time, settling time, x-axis range, plot suffix, and a fixed y-axis range of [-1.5, 1.5]\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 28.605689571937422}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    # Calculate the absolute settling time by adding the settling time to the start time\n    abs_settling_time = start_time + settling_time\n\n    # Call analyze_bag.plot_angular_velocities with the specified start time, end time, settling time, x-axis range, plot suffix, and a fixed y-axis range of [-1.5, 1.5]\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n", "CodeBleu_score": 28.605689571937422}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    # Calculate the absolute settling time.\n    abs_settling_time = start_time + settling_time\n\n    # Call analyze_bag.plot_angular_velocities with the specified start time, end time, settling time, x-axis range, plot suffix, and a fixed y-axis range of [-1.5, 1.5].\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 28.605689571937422}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (!data) {\n    return;\n  }\n  const float multiplier = 1000.0;\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  const float rms_noise =\n      sqrt(this->dist * this->dist +\n           std::min(this->tanf * this->tanf * multiplier * multiplier,\n                    this->noise * this->noise));\n  const float noise = rms_noise * multiplier;\n  for (int i = 0; i < width * height; i++) {\n    if (InRange(data_vector_map(i))) {\n      data_vector_map(i) += noise * (rand() / float(RAND_MAX));\n    } else {\n      data_vector_map(i) = BAD_POINT;\n    }\n  }\n}", "CodeBleu_score": 48.8966555593941}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n  const float multiplier = 1000.0f / (this->dist * this->dist);\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  const float rms_noise =\n      std::sqrt(std::min(multiplier * this->noise * this->noise, 1.0f));\n  const Eigen::VectorXf noise =\n      Eigen::VectorXf::Random(width * height).cwiseProduct(\n          Eigen::VectorXf::Ones(width * height) * rms_noise);\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (InRange(data_vector_map[i])) {\n      data_vector_map[i] += noise[i];\n    } else {\n      data_vector_map[i] = BAD_POINT;\n    }\n  }\n}", "CodeBleu_score": 56.599540102523804}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (!data)\n    return;\n\n  const float multiplier = 1000.0f;\n\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  data_vector_map *= multiplier;\n\n  const float rms_noise = ComputeRmsNoise(data_vector_map);\n  const float noise = ComputeNoise(data_vector_map, rms_noise);\n\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (InRange(data[i])) {\n      data[i] += noise;\n    } else {\n      data[i] = -1.0f;\n    }\n  }\n}", "CodeBleu_score": 45.70700893504467}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  ros::Time time = ros::Time::now();\n  gazebo_bag_plugin_msgs::Waypoint waypoint_msg;\n  waypoint_msg.header.stamp = time;\n  waypoint_msg.trajectory = *trajectory_msg;\n  waypoint_bag_.write(waypoint_topic_, time, waypoint_msg);\n}", "CodeBleu_score": 46.39472668483056}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Retrieve the current simulation time\n  ros::Time current_time = ros::Time(world_->SimTime().Double());\n\n  // Write the trajectory message to a bag file using the specified namespace\n  // and waypoint topic\n  bag_.write(waypoint_topic_, current_time, *trajectory_msg);\n}", "CodeBleu_score": 39.54466662867544}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time.\n  ros::Time sim_time = ros::Time::now();\n\n  // Convert the simulation time to ROS time.\n  ros::Time ros_time = world_->SimTime();\n\n  // Write the trajectory message to a bag file.\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 53.82880576096738}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Get the simulation time\n  ros::Time sim_time = ros::Time(now.sec, now.nsec);\n\n  // Prepare the message\n  mav_msgs::ActuatorsPtr rot_velocities_msg(new mav_msgs::Actuators);\n  rot_velocities_msg->header.stamp = sim_time;\n  rot_velocities_msg->header.frame_id = \"actuators\";\n\n  // Iterate through the motor joints\n  for (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Calculate the slowed-down rotational velocities\n    double rot_velocity = m->second->GetVelocity(0);\n    rot_velocity = rot_velocity * rotor_velocity_slowdown_sim_;\n\n    // Assign the rotational velocities to the message\n    rot_velocities_msg->angular_velocities.push_back(rot_velocity);\n  }\n\n  // Write the data to a bag file\n  rot_velocities_msg->header.stamp = sim_time;\n  rot_velocities_msg->header.frame_id = \"actuators\";\n  rot_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 55.83604633510822}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // convert simulation time to ROS time\n  ros::Time time_now = ros::Time(now.sec, now.nsec);\n\n  // prepare message for rotational velocities\n  mav_msgs::Actuators rot_velocities_msg;\n  rot_velocities_msg.header.stamp = time_now;\n  rot_velocities_msg.header.frame_id = frame_id_;\n  rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\n  // iterate through motor joints, calculate rotational velocities, and assign them to message\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // calculate rotational velocities\n    double rot_velocity = m->second->GetVelocity(0) / rotor_velocity_slowdown_;\n\n    // assign rotational velocities to message\n    rot_velocities_msg.angular_velocities[m->second->GetIndex()] = rot_velocity;\n  }\n\n  // write data to bag file\n  rot_velocities_bag_.write(motor_topic_, time_now, rot_velocities_msg);\n}", "CodeBleu_score": 66.04477381554315}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Converting simulation time to ROS time\n  ros::Time time_now = ros::Time(now.sec, now.nsec);\n\n  // Preparing message for motor velocities\n  mav_msgs::Actuators rot_velocities_msg;\n  rot_velocities_msg.header.stamp = time_now;\n\n  // Iterating through all the motor joints\n  for (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Calculating the slowed-down rotational velocities\n    double rot_velocity = m->second->GetVelocity(0) / rotor_velocity_slowdown_sim_;\n    // Assigning the rotational velocities to the message\n    rot_velocities_msg.angular_velocities.push_back(rot_velocity);\n  }\n\n  // Setting the message timestamp\n  rot_velocities_msg.header.stamp = time_now;\n  // Writing the data to a bag file\n  motor_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 58.230295464035095}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  // Debug print that this function was called.\n  if (debug_print_)\n    ROS_INFO(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called.\");\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  aileron_left_cmd_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll);\n  elevator_cmd_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch);\n  rudder_cmd_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set the throttle value from the thrust message.\n  throttle_cmd_ = roll_pitch_yawrate_thrust_msg->thrust.x;\n}", "CodeBleu_score": 33.46067844329337}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_printing_) {\n    gzdbg << __FUNCTION__ << \" called.\" << std::endl;\n  }\n  aileron_cmd_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll);\n  elevator_cmd_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch);\n  rudder_cmd_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate);\n  throttle_cmd_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 45.93561172069012}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  // Print that the callback was called.\n  if (debug_printing_) {\n    gzmsg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called.\n\";\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll, &aileron_left_cmd_, &aileron_right_cmd_);\n  NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch, &elevator_cmd_);\n  NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate, &rudder_cmd_);\n\n  // Set the throttle value from the thrust message.\n  throttle_cmd_ = roll_pitch_yawrate_thrust_msg->thrust.x;\n}", "CodeBleu_score": 34.38894485252054}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  struct timeval tv;\n  fd_set fds;\n  int ret;\n\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000UL;\n\n  FD_ZERO(&fds);\n  FD_SET(this->handle, &fds);\n\n  ret = select(this->handle + 1, &fds, NULL, NULL, &tv);\n\n  if (ret == -1) {\n    gzerr << \"select errno: \" << strerror(errno) << \"\n\";\n  } else if (ret) {\n    mavlink_status_t* chan_state = mavlink_get_channel_status(MAVLINK_COMM_0);\n    mavlink_message_t message;\n    uint8_t buf[MAVLINK_MAX_PACKET_LEN];\n\n    // receive bytes from UDP\n    int len = recvfrom(this->handle, buf, MAVLINK_MAX_PACKET_LEN, 0,\n        (struct sockaddr*)&srcaddr, &addrlen);\n\n    // send bytes to serial\n    if (this->serial_enabled) {\n      int len2 = write(this->serial_fd, buf, len);\n      if (len2 < len) {\n        gzerr << \"Failed to write to serial\n\";\n      }\n    }\n\n    // parse bytes into MAVLink messages\n    for (unsigned i = 0; i < len; ++i) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &message, &status)) {\n        // have a message, handle it\n        this->handle_message(&message, chan_state, _dt);\n      }\n    }\n  }\n}", "CodeBleu_score": 57.90758244514891}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Poll the socket for available data\n  struct timeval tv;\n  fd_set fds;\n  int ret;\n\n  // Initialize the file descriptor set\n  FD_ZERO(&fds);\n  FD_SET(this->handle, &fds);\n\n  // Initialize the timeout structure\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000UL;\n\n  // Wait until data is available\n  ret = select(this->handle + 1, &fds, NULL, NULL, &tv);\n\n  if (ret == -1) {\n    gzerr << \"select() error: \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  if (ret == 0) {\n    // Timeout occurred, no data available\n    return;\n  }\n\n  // Receive data\n  int len = recvfrom(this->handle, this->buf, sizeof(this->buf), 0,\n      (struct sockaddr *)&this->srcaddr, &(this->addrlen));\n\n  if (len < 0) {\n    gzerr << \"Failed to receive data: \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  // Parse the received data\n  mavlink_message_t msg;\n  mavlink_status_t status;\n\n  for (unsigned i = 0; i < len; ++i) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, this->buf[i], &msg, &status)) {\n      // Handle message\n      this->handle_message(&msg);\n    }\n  }\n}", "CodeBleu_score": 59.82802285713651}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t\n  struct timeval timeout;\n  fd_set fds;\n  int ret;\n\n  // Convert timeout to timeval\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000UL;\n\n  // Poll for data on the UDP socket\n  FD_ZERO(&fds);\n  FD_SET(this->socketFd, &fds);\n  ret = select(this->socketFd + 1, &fds, NULL, NULL, &timeout);\n\n  // If data is available, read it and parse MAVLink messages\n  if (ret > 0) {\n    ssize_t recsize;\n    unsigned int i;\n    uint8_t buf[MAVLINK_MAX_PACKET_LEN];\n    mavlink_message_t msg;\n    mavlink_status_t status;\n\n    recsize = recvfrom(this->socketFd, buf, MAVLINK_MAX_PACKET_LEN, 0,\n        (struct sockaddr *)&srcaddr, &addrlen);\n\n    if (recsize > 0) {\n      // Handle message\n      for (i = 0; i < recsize; ++i) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status)) {\n          handle_message(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 59.847935529604946}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!is_open_) {\n    return;\n  }\n\n  io_service_.stop();\n  serial_dev_.close();\n\n  if (io_thread_.joinable()) {\n    io_thread_.join();\n  }\n\n  is_open_ = false;\n}", "CodeBleu_score": 68.84654011740552}, {"code": "void GazeboMavlinkInterface::close() {\n\t  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (!is_open_) {\n    return;\n  }\n\n  io_service_.stop();\n  serial_dev_.close();\n\n  if (io_thread_.joinable()) {\n    io_thread_.join();\n  }\n\n  is_open_ = false;\n}", "CodeBleu_score": 68.84654011740552}, {"code": "void GazeboMavlinkInterface::close() {\n\t  std::lock_guard<std::mutex> lock(mutex_);\n\n  if (is_open_) {\n    io_service_.stop();\n    serial_dev_.close();\n\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n\n    is_open_ = false;\n  }\n}", "CodeBleu_score": 67.06381806659496}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    ignition::math::Vector3d point_a,\n    ignition::math::Vector3d point_b,\n    ignition::math::Vector3d value_a,\n    ignition::math::Vector3d value_b,\n    ignition::math::Vector3d position\n}", "CodeBleu_score": 18.7702370637984}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    ignition::math::Vector3d position,\n    ignition::math::Vector3d first_point,\n    ignition::math::Vector3d second_point,\n    ignition::math::Vector3d first_value,\n    ignition::math::Vector3d second_value\n}", "CodeBleu_score": 14.660529673882078}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t    this->time = _time;\n}", "CodeBleu_score": 26.553564377388977}, {"code": "void Animation::SetTime(double _time){\n\t  this->dataPtr->timePos = _time;\n  this->Update();\n}", "CodeBleu_score": 25.707368745431015}, {"code": "void Animation::SetTime(double _time){\n\t  if (this->dataPtr->time != _time) {\n    this->dataPtr->time = _time;\n    this->dataPtr->loop = this->dataPtr->loop &&\n      this->dataPtr->time >= this->dataPtr->length;\n    this->dataPtr->time = this->dataPtr->loop ?\n      fmod(this->dataPtr->time, this->dataPtr->length) :\n      std::max(0.0, std::min(this->dataPtr->time, this->dataPtr->length));\n    this->dataPtr->update = true;\n  }\n}", "CodeBleu_score": 46.988512773912525}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.vehicle.set_coordinate_frame(mavutil.mavlink.MAV_FRAME_GLOBAL)\n    self.vehicle.set_mode(mavutil.mavlink.MAV_MODE_GUIDED_ARMED)\n    self.target = self.vehicle.location.global_frame\n    print(\"Vehicle type: %s\" % self.vehicle.type)\n    print(\"Vehicle ID: %s\" % self.vehicle.id)\n    print(\"Flight mode: %s\" % self.vehicle.mode.name)\n    print(\"Target location: %s\" % self.target)\n\n", "CodeBleu_score": 21.527584551501644}, {"code": "def hover(self)\n\t\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    self.construct_target(self.get_position(), self.get_yaw())\n    print(self.get_type(), self.get_id(), self.get_flight_mode())\n\n", "CodeBleu_score": 12.993625454711108}, {"code": "def hover(self)\n\t\n\n    self.vehicle.set_coordinate_frame(mavutil.mavlink.MAV_FRAME_BODY_NED)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.motion.yaw = self.vehicle.heading\n    self.vehicle.motion.thrust = 0.5\n    self.vehicle.motion.pitch = 0.0\n    self.vehicle.motion.roll = 0.0\n    self.vehicle.motion.x = 0.0\n    self.vehicle.motion.y = 0.0\n    self.vehicle.motion.z = 0.0\n    print(\"Vehicle Type: \" + str(self.vehicle.type))\n    print(\"Vehicle ID: \" + str(self.vehicle.id))\n    print(\"Flight Mode: \" + str(self.vehicle.mode))\n\n", "CodeBleu_score": 22.935159658995445}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        print(\"Mode switched to HOVER\")\n        return True\n    elif self.flightMode == 'MANUAL':\n        self.flightModeService(custom_mode=1)\n        if self.flightMode == 'MANUAL':\n            print(\"Mode switched to MANUAL\")\n            return True\n        else:\n            print(\"Mode switch failed\")\n            return False\n    elif self.flightMode == 'ALT_HOLD':\n        self.flightModeService(custom_mode=2)\n        if self.flightMode == 'ALT_HOLD':\n            print(\"Mode switched to ALT_HOLD\")\n            return True\n        else:\n            print(\"Mode switch failed\")\n            return False\n    elif self.flightMode == 'POS_HOLD':\n        self.flightModeService(custom_mode=3)\n        if self.flightMode == 'POS_HOLD':\n            print(\"Mode switched to POS_HOLD\")\n            return True\n        else:\n            print(\"Mode switch failed\")\n            return False\n    elif self.flightMode == 'AUTO':\n        self.flightModeService(custom_mode=4)\n        if self.flightMode == 'AUTO':\n            print(\"Mode switched to AUTO\")\n            return True\n        else:\n            print(\"Mode switch failed\")\n            return False\n    elif self.flightMode == 'GUIDED':\n        self.flightModeService(custom_mode=5)\n        if self.flightMode == 'GUIDED':\n            print(\"Mode switched to GUIDED\")\n            return True\n        else:\n            print(\"Mode switch failed\")\n            return False\n    elif self.flightMode == 'STABILIZE':\n        self.flightModeService(custom_mode=6)\n        if self.flightMode == 'STABILIZE':\n            print(\"Mode switched to STABILIZE\")\n            return True\n        else:\n            print(\"Mode switch failed\")\n            return False\n    elif self.flight", "CodeBleu_score": 28.026297365429677}, {"code": "def flight_mode_switch(self)\n\t\n\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        print('Hover mode set')\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print('Flight mode set to ' + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print('Service call failed: %s' % e)\n            return False\n", "CodeBleu_score": 55.03085986545121}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService.response.mode_sent:\n        self.flightModeService.request.base_mode = 0\n        self.flightModeService.request.custom_mode = 0\n        self.flightModeService.request.mode = self.flightModeService.request.MODE_HOVER\n        self.flightModeService.request.mode_sent = True\n        self.flightModeService.request.base_mode = 192\n        self.flightModeService.request.custom_mode = 0\n        self.flightModeService.request.mode = self.flightModeService.request.MODE_HOVER\n        self.flightModeService.request.mode_sent = True\n        self.flightModeService.request.base_mode = 192\n        self.flightModeService.request.custom_mode = 0\n        self.flightModeService.request.mode = self.flightModeService.request.MODE_HOVER\n        self.flightModeService.request.mode_sent = True\n        self.flightModeService.request.base_mode = 192\n        self.flightModeService.request.custom_mode = 0\n        self.flightModeService.request.mode = self.flightModeService.request.MODE_HOVER\n        self.flightModeService.request.mode_sent = True\n        self.flightModeService.request.base_mode = 192\n        self.flightModeService.request.custom_mode = 0\n        self.flightModeService.request.mode = self.flightModeService.request.MODE_HOVER\n        self.flightModeService.request.mode_sent = True\n        self.flightModeService.request.base_mode = 192\n        self.flightModeService.request.custom_mode = 0\n        self.flightModeService.request.mode = self.flightModeService.request.MODE_HOVER\n        self.flightModeService.request.mode_sent = True\n        self.flightModeService.request.base_mode = 192\n        self.flightModeService.request.", "CodeBleu_score": 27.237908505118906}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_flag = False\n    self.hold_flag = False\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n", "CodeBleu_score": 48.5379336379196}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.cmd_vel_enu_msg = msg\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n", "CodeBleu_score": 35.13104987558153}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n", "CodeBleu_score": 35.54321307011656}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (x > 0.02 or x < -0.02 or y > 0.02 or y < -0.02 or z > 0.02 or z < -0.02 or w > 0.005 or w < -0.005):\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n    else:\n        if (self.hover_flag == 0):\n            self.hover_flag = 1\n            self.set_mode(\"HOVER\")\n            self.hover()\n\n", "CodeBleu_score": 38.25173949582758}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005) and self.hover_flag == 1:\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n    elif self.hover_flag == 0:\n        self.hover_flag = 1\n        self.set_mode(\"HOVER\")\n        self.hover()\n\n", "CodeBleu_score": 50.300995770223665}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02) or (abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n        self.hover()\n    elif (self.mode != \"HOVER\") and (self.hover_flag == 1):\n        self.hover_flag = 1\n        self.set_mode(\"HOVER\")\n        self.hover()\n\n", "CodeBleu_score": 40.293724224601355}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 38.689044969360964}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 38.689044969360964}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 27.52863807726429}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = MAV_FRAME_BODY_NED\n    self.motion_type = MAV_CMD_NAV_WAYPOINT\n    self.construct_target()\n    self.flight_mode = MAV_MODE_FLAG_CUSTOM_MODE_ENABLED | MAV_MODE_FLAG_AUTO_ENABLED | MAV_MODE_FLAG_STABILIZE_ENABLED\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 21.863950602263937}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.construct_target(self.coordinate_frame, self.motion_type)\n    print(\"Vehicle Type: {}", "CodeBleu_score": 25.31915225117799}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = self.vehicle.attitude.frame\n    self.motion_type = \"hover\"\n    self.construct_target()\n    print(self.vehicle_type, self.vehicle_id, \"hover\")\n\n", "CodeBleu_score": 10.981662053160916}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print 'Flight mode switched to: ' + self.flightMode\n            return True\n        except rospy.ServiceException, e:\n            print \"Service call failed: %s\"%e\n            return False\n\n", "CodeBleu_score": 31.577754472446024}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover = True\n        self.hover()\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print(f'Flight mode switched to {self.flightMode}')\n            return True\n        except rospy.ServiceException as e:\n            print('Service call failed: %s' % e)\n            return False\n\n", "CodeBleu_score": 43.50065056915281}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print('Flight mode switched to:', self.flight_mode)\n            return True\n        except:\n            print('Flight mode switch failed.')\n            return False\n", "CodeBleu_score": 49.05257655254217}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.uav_id:\n        self.local_pose = msg\n        self.global_pose.pose.position.x = msg.pose.position.x + self.bias_x\n        self.global_pose.pose.position.y = msg.pose.position.y + self.bias_y\n        self.global_pose.pose.position.z = msg.pose.position.z + self.bias_z\n        self.global_pose.pose.orientation = msg.pose.orientation\n        if self.gcs_command == 1:\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n            self.takeoff_target_pose.pose.position.z = self.takeoff_height\n        elif self.gcs_command == 2:\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n            self.hover_target_pose.pose.position.z = self.hover_height\n\n", "CodeBleu_score": 28.860270896214985}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.uav_id:\n        self.local_pose = msg\n        if self.gcs_cmd == \"takeoff\":\n            self.takeoff_target_pose = msg\n        elif self.gcs_cmd == \"hover\":\n            self.hover_target_pose = msg\n        self.global_pose.pose.position.x = msg.pose.position.x + self.global_pose_offset[0]\n        self.global_pose.pose.position.y = msg.pose.position.y + self.global_pose_offset[1]\n        self.global_pose.pose.position.z = msg.pose.position.z + self.global_pose_offset[2]\n        self.global_pose.pose.orientation.x = msg.pose.orientation.x\n        self.global_pose.pose.orientation.y = msg.pose.orientation.y\n        self.global_pose.pose.orientation.z = msg.pose.orientation.z\n        self.global_pose.pose.orientation.w = msg.pose.orientation.w\n        self.global_pose.header.stamp = rospy.Time.now()\n        self.global_pose.header.frame_id = \"global_pose\"\n\n", "CodeBleu_score": 24.102056926601144}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    self.local_pose[i] = msg\n    self.global_pose[i] = self.local_pose[i]\n    self.global_pose[i].pose.position.x += self.bias[i][0]\n    self.global_pose[i].pose.position.y += self.bias[i][1]\n    self.global_pose[i].pose.position.z += self.bias[i][2]\n\n    if self.uav_command[i] == 1:\n        self.takeoff_target_pose[i] = self.local_pose[i]\n    elif self.uav_command[i] == 2:\n        self.hover_target_pose[i] = self.local_pose[i]\n\n", "CodeBleu_score": 22.980276538690212}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.arm_state == \"ARMED\" and self.altitude > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 60.46397890437216}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == \"armed\":\n        return True\n    else:\n        return False\n\n\n", "CodeBleu_score": 62.7551094861517}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.862379601652705}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Create a 2D array of zeros\n    graph = [[0 for x in range(len(orig_formation))] for y in range(len(change_formation))]\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            # Calculate the Euclidean norm\n            norm = ((orig_formation[i][0] - change_formation[j][0]) ** 2 + (orig_formation[i][1] - change_formation[j][1]) ** 2 + (orig_formation[i][2] - change_formation[j][2]) ** 2) ** 0.5\n            # Adjust the norm by subtracting it from 50 and convert it to an integer\n            graph[i][j] = int(50 - norm)\n    return graph\n\n", "CodeBleu_score": 25.816549228090768}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the pairwise distances between UAVs in the original and changed formations using the Euclidean norm\n    distances = np.linalg.norm(orig_formation - change_formation, axis=2)\n    # Adjust the distances by subtracting them from 50 and convert them to integers\n    distances = np.floor(50 - distances).astype(int)\n    return distances\n\n", "CodeBleu_score": 7.4044423755107776}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    # calculate distances between all UAVs in the original and changed formations\n    orig_dist = distance.cdist(orig_formation, orig_formation, 'euclidean')\n    change_dist = distance.cdist(change_formation, change_formation, 'euclidean')\n    # adjust distances by subtracting them from 50\n    orig_dist = 50 - orig_dist\n    change_dist = 50 - change_dist\n    # convert distances to integers\n    orig_dist = orig_dist.astype(int)\n    change_dist = change_dist.astype(int)\n    # return distance matrix\n    return orig_dist, change_dist\n\n", "CodeBleu_score": 16.20310836685525}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.left_visited[i] = True\n    for j in self.left_adj[i]:\n        if self.right_visited[j]:\n            continue\n        self.right_visited[j] = True\n        gap = self.right_label[j] - self.left_label[i]\n        if gap == 0:\n            if self.right_match[j] == -1 or self.find_path(self.right_match[j]):\n                self.right_match[j] = i\n                return True\n        elif self.right_match[j] == -1 and self.slack[j] > gap:\n            self.slack[j] = gap\n    return False\n\n", "CodeBleu_score": 27.40483446784744}, {"code": "def find_path(self, i)\n\t\n    self.left[i] = True\n    for j in self.graph[i]:\n        if self.right[j]:\n            continue\n        self.right[j] = True\n        if self.match[j] == -1 or self.find_path(self.match[j]):\n            self.match[j] = i\n            return True\n        self.slack[j] = min(self.slack[j], self.label[i] + self.label[j] - self.weight[i][j])\n    return False\n\n", "CodeBleu_score": 40.10636253987626}, {"code": "def find_path(self, i)\n\t\n    self.left_visited[i] = True\n    for j in self.left[i]:\n        if self.right_visited[j]:\n            continue\n        gap = self.right_label[j] - self.left_label[i] - self.match_weight[j]\n        if gap == 0:\n            self.right_visited[j] = True\n            if self.right[j] == -1 or self.find_path(self.right[j]):\n                self.right[j] = i\n                self.left[i] = j\n                return True\n        elif self.slack[j] > gap:\n            self.slack[j] = gap\n    return False\n", "CodeBleu_score": 27.30786642302785}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    # Initialize slack variables\n    slack = {}\n    for i in self.right:\n        for j in self.left:\n            slack[i, j] = self.cost[i, j]\n    # Initialize visit arrays\n    visited_left = {}\n    for i in self.left:\n        visited_left[i] = False\n    visited_right = {}\n    for i in self.right:\n        visited_right[i] = False\n    # Iterate over UAVs\n    for uav in self.uavs:\n        # Initialize path variables\n        path = {}\n        for i in self.right:\n            path[i] = None\n        path[uav] = uav\n        # Initialize parent variables\n        parent = {}\n        for i in self.right:\n            parent[i] = None\n        parent[uav] = uav\n        # Initialize unmatched variables\n        unmatched = []\n        for i in self.right:\n            unmatched.append(i)\n        # Initialize slack variables\n        slack_uav = {}\n        for i in self.right:\n            slack_uav[i] = slack[uav, i]\n        # Initialize slack variables\n        slack_uav = {}\n        for i in self.right:\n            slack_uav[i] = slack[uav, i]\n        # Initialize slack variables\n        slack_uav = {}\n        for i in self.right:\n            slack_uav[i] = slack[uav, i]\n        # Initialize slack variables\n        slack_uav = {}\n        for i in self.right:\n            slack_uav[i] = slack[uav, i]\n        # Initialize slack variables\n        slack_uav = {}\n        for i in self.right:\n            slack_uav[i] = slack[uav, i]\n        # Initialize slack variables\n        slack_uav = {}\n        for i in self.right:\n            slack_uav[i] = slack[uav, i]\n        # Initialize slack variables\n        s", "CodeBleu_score": 23.020371999338636}, {"code": "def KM(self)\n\t\n\n    # initialize slack variables\n    slack = [float(\"inf\")] * len(self.right)\n\n    # initialize visit arrays\n    row_visited = [False] * len(self.left)\n    col_visited = [False] * len(self.right)\n\n    # initialize path arrays\n    row_path = [False] * len(self.left)\n    col_path = [False] * len(self.right)\n\n    # initialize results\n    results = [None] * len(self.right)\n\n    # iterate over UAVs\n    for uav in range(len(self.left)):\n\n        # initialize slack variables\n        slack = [float(\"inf\")] * len(self.right)\n\n        # initialize visit arrays\n        row_visited = [False] * len(self.left)\n        col_visited = [False] * len(self.right)\n\n        # initialize path arrays\n        row_path = [False] * len(self.left)\n        col_path = [False] * len(self.right)\n\n        # initialize results\n        results = [None] * len(self.right)\n\n        # initialize slack variables\n        slack = [float(\"inf\")] * len(self.right)\n\n        # initialize visit arrays\n        row_visited = [False] * len(self.left)\n        col_visited = [False] * len(self.right)\n\n        # initialize path arrays\n        row_path = [False] * len(self.left)\n        col_path = [False] * len(self.right)\n\n        # initialize results\n        results = [None] * len(self.right)\n\n        # initialize slack variables\n        slack = [float(\"inf\")] * len(self.right)\n\n        # initialize visit arrays\n        row_visited = [False] * len(self.left)\n        col_visited = [False] * len(self.right)\n\n        # initialize path arrays\n        row_path = [False] * len(self.left)\n        col_path = [False] * len(self.right)\n\n        # initialize results\n        results", "CodeBleu_score": 18.14395100049337}, {"code": "def KM(self)\n\t\n    # Initialize slack variables\n    slack = {}\n    for i in range(self.num_UAVs):\n        for j in range(self.num_targets):\n            slack[i, j] = self.cost_matrix[i, j]\n    # Initialize visit arrays\n    visited_UAVs = [False] * self.num_UAVs\n    visited_targets = [False] * self.num_targets\n    # Iterate over UAVs\n    for i in range(self.num_UAVs):\n        # Initialize path\n        path = []\n        # Initialize path_UAVs\n        path_UAVs = []\n        # Initialize path_targets\n        path_targets = []\n        # Initialize slack variables\n        slack_UAVs = [0] * self.num_UAVs\n        slack_targets = [0] * self.num_targets\n        # Initialize parent\n        parent = {}\n        # Initialize parent_UAVs\n        parent_UAVs = [None] * self.num_UAVs\n        # Initialize parent_targets\n        parent_targets = [None] * self.num_targets\n        # Initialize even\n        even = [False] * self.num_UAVs\n        # Initialize even_UAVs\n        even_UAVs = [False] * self.num_UAVs\n        # Initialize even_targets\n        even_targets = [False] * self.num_targets\n        # Initialize odd\n        odd = [False] * self.num_UAVs\n        # Initialize odd_UAVs\n        odd_UAVs = [False] * self.num_UAVs\n        # Initialize odd_targets\n        odd_targets = [False] * self.num_targets\n        # Initialize unmatched\n        unmatched = [True] * self.num_UAVs\n        # Initialize unmatched_UAVs\n        unmatched_UAVs = [True] * self.num_UAVs\n        # Initialize unmatched_targets\n        unmatched_targets = [True] * self.num_targets\n", "CodeBleu_score": 19.913512795653755}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the Yellow HSV range and create a mask\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([40, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.440086488580548}, {"code": "def yellow_dectection(image)\n\t\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Define the lower and upper bounds for the yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([40, 255, 255])\n    # Create a mask for the yellow color using the lower and upper bounds of the HSV color space\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Bitwise-AND mask and original image\n    image_yellow = cv2.bitwise_and(image, image, mask=mask)\n    return image_yellow\n\n", "CodeBleu_score": 27.706938819522335}, {"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    yellow_mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    yellow_image = cv2.bitwise_and(image, image, mask=yellow_mask)\n    return yellow_image\n\n", "CodeBleu_score": 24.739352929346698}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t  std::map<int, StandaloneTagDescription>::iterator it = standalone_tag_descriptions_.find(id);\n  if (it == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN_THROTTLE(1.0, \"Standalone tag description with ID %d not found\", id);\n    }\n    return false;\n  }\n  descriptionContainer = it->second;\n  return true;\n}", "CodeBleu_score": 47.477950438075524}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  int id,\n  const std::string & frame_id,\n  std::vector<StandaloneTagDescription> & descriptionContainer,\n  bool printWarning = true", "CodeBleu_score": 6.592391257679356}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  uint64_t id = tag_detection_description.id;\n  auto it = standalone_tag_descriptions_.find(id);\n  if (it == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN_THROTTLE(1.0, \"Standalone tag with ID %lu not found in the map. \"\n                        \"Please add it with the 'add_standalone_tag' service.\", id);\n    }\n    return false;\n  }\n  tag_detection_description = it->second;\n  return true;\n}", "CodeBleu_score": 51.75083520963481}]}
