{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len;\n\n\twhile (desc->bDescriptorType!= desc_id) {\n\t\tdesc_len = desc->bLength;\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc_len);\n\t\tif (desc->bLength == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn desc;\n}", "CodeBleu_score": 35.134304023147976}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len;\n\n\twhile (desc!= NULL) {\n\t\tdesc_len = desc->bLength;\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc_len);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 38.18771879266131}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len;\n\tuint8_t desc_type;\n\tusb_conf_desc_t UDC_DESC_STORAGE * desc_next;\n\n\tdesc_next = desc;\n\twhile (desc_next) {\n\t\tdesc_len = desc_next->bLength;\n\t\tdesc_type = desc_next->bDescriptorType;\n\t\tif (desc_type == desc_id) {\n\t\t\treturn desc_next;\n\t\t}\n\t\tdesc_next = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t*)\n\t\t\t\tdesc_next + desc_len);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 44.56758287389505}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t i;\n\tuint8_t *p_desc;\n\tuint16_t desc_len;\n\tuint8_t desc_type;\n\tuint8_t desc_subtype;\n\tuint8_t desc_iface;\n\tuint8_t desc_setting;\n\tbool ret = false;\n\n\tif (usb_configuration_descriptor_valid) {\n\t\tif (iface_num < usb_configuration_descriptor.bNumInterfaces) {\n\t\t\tp_desc = (uint8_t *) usb_configuration_descriptor.bLength;\n\t\t\tdesc_len = usb_configuration_descriptor.wTotalLength;\n\t\t\twhile (desc_len > 0) {\n\t\t\t\tdesc_type = *p_desc;\n\t\t\t\tdesc_len--;\n\t\t\t\tif (desc_type == USB_DESCRIPTOR_TYPE_INTERFACE) {\n\t\t\t\t\tdesc_len -= 2;\n\t\t\t\t\tp_desc += 2;\n\t\t\t\t\tdesc_iface = *p_desc;\n\t\t\t\t\tdesc_len--;\n\t\t\t\t\tp_desc++;\n\t\t\t\t\tdesc_setting = *p_desc;\n\t\t\t\t\tdesc_len--;\n\t\t\t\t\tp_desc++;\n\t\t\t\t\tdesc_subtype = *p_desc;\n\t\t\t\t\tdesc_len--;\n\t\t\t\t\tp_desc++;\n\t\t\t\t\tif (desc_iface == iface_num && desc_setting == setting_num) {\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdesc_len -= *p_desc;\n\t\t\t\t\tp_desc += *p_desc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 35.24229188794853}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (config_desc.bLength == 0) {\n\t\treturn false;\n\t}\n\tif (iface_num >= config_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tuint8_t* desc = (uint8_t*) &config_desc;\n\tuint8_t desc_size = config_desc.bLength;\n\tuint8_t desc_type = 0;\n\tuint8_t desc_num = 0;\n\tuint8_t desc_index = 0;\n\tuint8_t desc_setting = 0;\n\n\twhile (desc_index < desc_size) {\n\t\tdesc_type = desc[desc_index];\n\t\tdesc_index++;\n\t\tdesc_size -= desc_type;\n\n\t\tswitch (desc_type) {\n\t\tcase USB_DT_INTERFACE:\n\t\t\tif (desc_num == iface_num) {\n\t\t\t\tdesc_setting = desc[desc_index];\n\t\t\t\tif (desc_setting == setting_num) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdesc_index += desc[desc_index];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdesc_index += desc[desc_index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 43.258639382170045}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t i;\n\tuint8_t *p_desc = udc_get_conf_desc();\n\n\tif (p_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < p_desc[2]; i++) {\n\t\tif (p_desc[3 + i * 7] == UDC_DESC_TYPE_INTERFACE && p_desc[4 + i * 7] == iface_num && p_desc[5 + i * 7] == setting_num) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 22.614050713407284}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = (udd_g_ctrlreq.req.wIndex & 0x0F);\n\tuint8_t ep_dir = (udd_g_ctrlreq.req.wIndex & 0x80) >> 7;\n\tuint8_t ep_status;\n\tbool ret = true;\n\n\tif (udd_g_ctrlreq.req.wLength!= sizeof(ep_status)) {\n\t\tudd_g_ctrlreq.req.wLength = 0;\n\t\tret = false;\n\t} else {\n\t\tif (ep_dir == UDD_EP_DIR_IN) {\n\t\t\tep_status = udd_ep_is_halted(ep_num);\n\t\t} else {\n\t\t\tep_status = 0;\n\t\t}\n\n\t\tudd_set_setup_payload(ep_status);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 36.82038621225466}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\t// Check if the request length matches the size of the endpoint status variable.\n\tif (udd_g_ctrlreq.req.wLength!= sizeof(udd_ep_status_t)) {\n\t\t// The request length does not match the size of the endpoint status variable.\n\t\t// Return false to indicate that the request is not handled.\n\t\treturn false;\n\t}\n\n\t// Determine the status of the specified endpoint.\n\tudd_ep_status_t status;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\t// The endpoint is halted.\n\t\tstatus = UDD_EP_HALTED;\n\t} else {\n\t\t// The endpoint is not halted.\n\t\tstatus = 0;\n\t}\n\n\t// Set up the response payload with the endpoint status.\n\tudd_set_setup_payload((uint8_t *)&status, sizeof(udd_ep_status_t));\n\n\t// Return true to indicate that the request is handled.\n\treturn true;\n}", "CodeBleu_score": 55.30118942124306}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_addr;\n\tuint16_t ep_status;\n\n\t/* Check if request length matches size of endpoint status variable */\n\tif (udd_g_ctrlreq.req.wLength!= sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\t/* Get endpoint address from the request */\n\tep_addr = udd_g_ctrlreq.req.wIndex;\n\n\t/* Determine the status of the specified endpoint */\n\tif (udd_ep_is_halted(ep_addr)) {\n\t\tep_status = UDC_EP_HALTED;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\t/* Set up response payload with the endpoint status */\n\tudd_set_setup_payload((uint8_t *)&ep_status, sizeof(ep_status));\n\n\treturn true;\n}", "CodeBleu_score": 50.616505443570325}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tif (udc_state!= UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\tif (setup.wIndex!= udc_iface.alt_setting) {\n\t\treturn false;\n\t}\n\tif (udc_update_iface_desc(0) && udc_update_iface_desc(1)) {\n\t\treturn udc_iface.setup(setup);\n\t}\n\treturn false;\n}", "CodeBleu_score": 28.02924406420545}, {"code": "static bool udc_req_iface(void){\n\t\t// if the device is in a configured state and the requested interface number is valid\n\tif ((udc_state == UDC_STATE_CONFIGURED) && (req->wIndex < udc_iface_count)) {\n\t\t// update the interface descriptor to the default setting\n\t\tif (udi_api->update_iface_desc(req->wIndex, udc_iface_desc_default)) {\n\t\t\t// update the interface descriptor to the current alternate setting\n\t\t\tif (udi_api->update_iface_desc(req->wIndex, udc_iface_desc_current)) {\n\t\t\t\t// forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\t\t\t\tif (udi_api->setup(req)) {\n\t\t\t\t\t// return the result of the handler's setup function\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// return false if the device is not in a configured state or if the requested interface number is invalid\n\treturn false;\n}", "CodeBleu_score": 29.25590180945146}, {"code": "static bool udc_req_iface(void){\n\t\tif(udc_update_iface_desc(0, 0) && udc_update_iface_desc(0, udc_iface_desc[0].bAlternateSetting)) {\n\t\treturn udc_api->setup(0, 0);\n\t}\n\treturn false;\n}", "CodeBleu_score": 8.649309748652431}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\tudi_msc_cbw_wait();\n\tmem_unload();\n\tif (get_nb_lun() == 0) {\n\t\treturn false;\n\t}\n\tif (!UDI_MSC_ENABLE_EXT()) {\n\t\treturn false;\n\t}\n\tudi_msc_cbw_wait();\n\treturn true;\n}", "CodeBleu_score": 21.266294381640595}, {"code": "bool udi_msc_enable(void){\n\t\tudi_msc_cbw_wait();\n\tif (get_nb_lun() == 0) {\n\t\treturn false;\n\t}\n\tmem_unload();\n\tUDI_MSC_ENABLE_EXT();\n\treturn true;\n}", "CodeBleu_score": 9.522666484764192}, {"code": "bool udi_msc_enable(void){\n\t\tudi_msc_cbw_wait = false;\n\tudi_msc_cbw_received = false;\n\tudi_msc_cbw_data_received = false;\n\tudi_msc_cbw_data_received_length = 0;\n\tudi_msc_cbw_data_received_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset = 0;\n\tudi_msc_cbw_data_received_total_length = 0;\n\tudi_msc_cbw_data_received_total_offset", "CodeBleu_score": 17.429811855088005}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\tudi_msc_cbw_reset();\n\t\treturn;\n\t}\n\n\tudi_msc_sense_pass();\n\n\tudi_msc_csw_process(nb_sent);\n}", "CodeBleu_score": 48.43829767847993}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\tudi_msc_csw_process(UDI_MSC_CBW_STATUS_FAILED);\n\t\tudi_msc_cbw_reset();\n\t} else {\n\t\tudi_msc_sense_pass();\n\t\tudi_msc_csw_process(UDI_MSC_CBW_STATUS_PASSED);\n\t\tudi_msc_cbw_reset();\n\t}\n}", "CodeBleu_score": 42.17266207530904}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\t/* Check if transfer is successful */\n\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\t/* Wait for setup reset to restart CBW reception */\n\t\tudi_msc_cbw_reset();\n\t\treturn;\n\t}\n\n\t/* Update sense data */\n\tudi_msc_sense_pass();\n\n\t/* Decrease data residue in CSW by the amount of data sent */\n\tudi_msc_csw_process(nb_sent);\n}", "CodeBleu_score": 48.411635743304274}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_cbw_t *cbw = udi_msc_cbw_get();\n\tudi_msc_csw_t *csw = udi_msc_csw_get();\n\tuint32_t data_residue = udi_msc_csw_get_data_residue();\n\tuint8_t ep_addr = udi_msc_cbw_get_ep_addr();\n\tuint8_t ep_dir = udi_msc_cbw_get_ep_dir();\n\tuint8_t ep_type = udi_msc_cbw_get_ep_type();\n\tuint8_t ep_num = udi_msc_cbw_get_ep_num();\n\tuint8_t ep_num_dir = ep_num | ep_dir;\n\tudi_msc_csw_set_tag(csw, udi_msc_cbw_get_tag());\n\tudi_msc_csw_set_data_residue(csw, data_residue);\n\tudi_msc_csw_set_status(csw, UDI_MSC_CSW_STATUS_OK);\n\tif (data_residue!= 0) {\n\t\tudi_msc_ep_set_halt(ep_addr, ep_num_dir, ep_type);\n\t}\n\tudi_msc_csw_send(csw);\n}", "CodeBleu_score": 40.145088233034535}, {"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_csw_t *csw = udi_msc_csw;\n\tuint32_t data_residue = udi_msc_cbw->data_residue;\n\tuint32_t tag = udi_msc_cbw->tag;\n\tuint32_t status = udi_msc_cbw->status;\n\n\tudi_msc_cbw = NULL;\n\n\tif (data_residue) {\n\t\tif (udi_msc_cbw->direction == UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\tudi_msc_ep_set_halt(udi_msc_cbw->lun, UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\tudi_msc_ep_set_halt(udi_msc_cbw->lun, UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\n\tcsw->tag = tag;\n\tcsw->status = status;\n\tcsw->data_residue = cpu_to_le32(data_residue);\n\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 44.761163395332126}, {"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_csw_t *csw = udi_msc_csw;\n\tudi_msc_cbw_t *cbw = udi_msc_cbw;\n\tuint32_t data_residue = udi_msc_data_residue;\n\tuint32_t tag = udi_msc_tag;\n\tuint32_t status = 0;\n\tuint32_t ep_dir;\n\n\tif (data_residue) {\n\t\t/*\n\t\t * If there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n\t\t */\n\t\tep_dir = (cbw->flags & UDI_MSC_CBW_DIRECTION_IN)? UDI_MSC_EP_IN : UDI_MSC_EP_OUT;\n\t\tudi_msc_ep_set_halt(ep_dir);\n\t}\n\n\t/*\n\t * It then prepares the CSW by setting its tag and converting the data residue to little-endian format before sending the CSW.\n\t */\n\tcsw->signature = UDI_MSC_CSW_SIGNATURE;\n\tcsw->tag = tag;\n\tcsw->data_residue = cpu_to_le32(data_residue);\n\tcsw->status = cpu_to_le32(status);\n\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 45.60280279718591}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\t/*\n\t\t * If the DTR signal is enabled, it cancels any scheduled reset by calling \"cancelReset\".\n\t\t */\n\t\tcancelReset();\n\t} else {\n\t\t/*\n\t\t * If the DTR signal is disabled, it schedules a delayed system reset by writing to the reset controller and calling \"initiateReset\".\n\t\t */\n\t\tinitiateReset();\n\t}\n}", "CodeBleu_score": 21.786225828645783}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\t// DTR enabled\n\t\t// Cancel any scheduled reset\n\t\tcancelReset();\n\t} else {\n\t\t// DTR disabled\n\t\t// Check if DTR rate is 1200\n\t\tif (cdc_get_dtr_rate(port) == 1200) {\n\t\t\t// DTR rate is 1200\n\t\t\t// Schedule a delayed system reset\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 27.69724396810683}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\tif (usb_cdc_port_status[port].b_dtr_rate_1200) {\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\tif (usb_cdc_port_status[port].b_dtr_rate_1200) {\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 28.31043970271509}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tbool ret = false;\n\tif (usb_setup_request.bmRequestType == 0x21) {\n\t\tif (usb_setup_request.bRequest == 0x04) {\n\t\t\tif (usb_setup_request.wValue == 0x0000) {\n\t\t\t\tif (usb_setup_request.wIndex == 0x0000) {\n\t\t\t\t\tusb_task_set_id_descriptor_pointers();\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (usb_setup_request.bRequest == 0x05) {\n\t\t\tif (usb_setup_request.wValue == 0x0000) {\n\t\t\t\tif (usb_setup_request.wIndex == 0x0000) {\n\t\t\t\t\tusb_task_set_extended_properties_descriptor_pointers();\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 14.326730619755912}, {"code": "bool usb_task_other_requests(void){\n\t\tif (usb_setup_packet.bmRequestType.Recipient == 0x01) {\n\t\tif (usb_setup_packet.bRequest == 0x04) {\n\t\t\tusb_control_request.payload = &usb_vendor_id_descriptor;\n\t\t\tusb_control_request.size = sizeof(usb_vendor_id_descriptor);\n\t\t\treturn true;\n\t\t} else if (usb_setup_packet.bRequest == 0x05) {\n\t\t\tusb_control_request.payload = &usb_vendor_extended_descriptor;\n\t\t\tusb_control_request.size = sizeof(usb_vendor_extended_descriptor);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 19.12265899043436}, {"code": "bool usb_task_other_requests(void){\n\t\tbool retval = false;\n\tuint8_t *p_data;\n\tuint16_t *p_size;\n\tuint8_t *p_descriptor;\n\tuint16_t *p_descriptor_size;\n\tuint8_t *p_descriptor_type;\n\tuint16_t *p_descriptor_index;\n\tuint8_t *p_descriptor_count;\n\tuint8_t *p_descriptor_type_count;\n\tuint8_t *p_descriptor_type_index;\n\tuint8_t *p_descriptor_type_count_index;\n\tuint8_t *p_descriptor_type_count_count;\n\tuint8_t *p_descriptor_type_count_count_index;\n\tuint8_t *p_descriptor_type_count_count_count;\n\tuint8_t *p_descriptor_type_count_count_count_index;\n\tuint8_t *p_descriptor_type_count_count_count_count;\n\tuint8_t *p_descriptor_type_count_count_count_count_index;\n\tuint8_t *p_descriptor_type_count_count_count_count_count;\n\tuint8_t *p_descriptor_type_count_count_count_count_count_index;\n\tuint8_t *p_descriptor_type_count_count_count_count_count_count;\n\tuint8_t *p_descriptor_type_count_count_count_count_count_count_index;\n\tuint8_t *p_descriptor_type_count_count_count_count_count_count_count;\n\tuint8_t *p_descriptor_type_count_count_count_count_count_count_count_index;\n\tuint8_t *p_descriptor_type_count_count_count_count_count_count_count_count;\n\tuint8_t *p_descriptor_type_count_count_count_count_count_count_count_count_index;\n\tuint8_t *p_descriptor_type_count_count_count_count_count_count_count_count_count;\n\tuint8", "CodeBleu_score": 4.729680680826381}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tuint16_t i = 0;\n\twhile (i < nbyte) {\n\t\tspiSend(0xFF);\n\t\tbuf[i] = spiRec();\n\t\ti++;\n\t}\n\tspiSend(0xFF);\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 48.540063876612145}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\tuint8_t i = 0;\n\tuint8_t dummy = 0xFF;\n\tuint8_t byte = 0;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(dummy);\n\t\tbyte = spiRec();\n\t\tbuf[i] = byte;\n\t}\n\tspiSend(dummy);\n\tbyte = spiRec();\n\tbuf[i] = byte;\n}", "CodeBleu_score": 46.58034171156725}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint8_t i;\n\tif(nbyte == 0) {\n\t\treturn;\n\t}\n\tfor(i = 0; i < nbyte; i++) {\n\t\tspiSend(0x00);\n\t\tspiRec();\n\t\tbuf[i] = spiRec();\n\t}\n\tspiSend(0x00);\n\tspiRec();\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 49.89135135021778}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tCRITICAL_SECTION_START\n\tpfnISR_Handler oldHandler = (pfnISR_Handler)get_relocated_table_addr()[irq];\n\tget_relocated_table_addr()[irq] = (uint32_t)newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 50.25616993405928}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler = 0;\n\tuint32_t *relocatedTableAddr = (uint32_t *)get_relocated_table_addr();\n\tCRITICAL_SECTION_START\n\toldHandler = (pfnISR_Handler)relocatedTableAddr[irq];\n\trelocatedTableAddr[irq] = (uint32_t)newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 50.531866813584536}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tCRITICAL_SECTION_START\n\tpfnISR_Handler oldHandler = get_relocated_table_addr()[irq];\n\tget_relocated_table_addr()[irq] = newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 49.158947313682255}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\tif (enabled) {\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\tint c = udi_cdc_getc();\n\t\t\tif (c >= 0) {\n\t\t\t\tif (emergency_parser) {\n\t\t\t\t\tc = emergency_parser->process_char(c);\n\t\t\t\t}\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 43.12728183645033}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (usb_cdc_enabled && usb_cdc_configured) {\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\treturn udi_cdc_getc();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 10.36250180070701}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (usb_task_cdc_isenabled() && _cdc_is_rx_ready()) {\n\t\tint c = _cdc_getc();\n\t\tif (emergency_parser.enabled) {\n\t\t\temergency_parser.update(c);\n\t\t}\n\t\treturn c;\n\t}\n\treturn -1;\n}", "CodeBleu_score": 31.126981923931808}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char) {\n\t\treturn pending_char;\n\t}\n\tif (usb_cdc_enabled) {\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\treturn udi_cdc_getc();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 18.75635013467523}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char) {\n\t\tint c = pending_char;\n\t\tpending_char = 0;\n\t\treturn c;\n\t}\n\tif (!is_enabled() ||!is_configured()) {\n\t\treturn -1;\n\t}\n\tif (udi_cdc_is_rx_ready()) {\n\t\tint c = udi_cdc_getc();\n\t\tif (emergency_parser) {\n\t\t\temergency_parser->update(c);\n\t\t}\n\t\treturn c;\n\t}\n\treturn -1;\n}", "CodeBleu_score": 53.18201816688346}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char) {\n\t\tint c = pending_char;\n\t\tpending_char = 0;\n\t\treturn c;\n\t}\n\tif (!usb_cdc_enabled) return -1;\n\tif (!udi_cdc_is_rx_ready()) return -1;\n\tint c = udi_cdc_getc();\n\tif (emergency_parser.enabled) emergency_parser.update(c);\n\treturn c;\n}", "CodeBleu_score": 60.518034804510236}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tif (cdc_enabled && cdc_is_rx_ready()) {\n\t\treturn usb_cdc_rx_available();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 18.743549149993967}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_cdc_is_enabled()) {\n\t\treturn usb_cdc_is_rx_ready();\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 19.115119609768023}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_cdc_isenabled()) {\n\t\treturn usb_cdc_is_rx_ready();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 18.514791195716988}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif\n\t(\n\t(pos + size)\n\t>\n\t(int)\n\tm_size\n\t) {\n\t\treturn false;\n\t}\n\tif\n\t(\n\twriting\n\t) {\n\t\tfor\n\t(\n\t\tint i = 0;\n\t\ti\n\t\t<\n\t\tsize;\n\t\ti++\n\t) {\n\t\t\tif\n\t(\n\tcrc\n\t) {\n\t\t\t\t*crc\n\t=\n\t\t\t\tcrc16\n(\n\t\t\t\t\t*crc\n,\n\t\t\t\t\tvalue\n[\n\t\t\t\t\t\ti\n\t\t\t\t\t]\n\t\t\t\t);\n\t\t\t}\n\t\t\tvalue\n[\n\t\t\t\ti\n\t\t\t]\n=\n\t\t\t\tm_data\n[\n\t\t\t\t\tpos\n\t\t\t\t+\n\t\t\t\t\ti\n\t\t\t\t];\n\t\t}\n\t}\n\tpos\n+=\n\t\tsize;\n\treturn true;\n}", "CodeBleu_score": 41.94892785231142}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\t//\n\t//\n\t//\n\tif (size == 0) {\n\t\treturn false;\n\t}\n\t//\n\t//\n\t//\n\tuint8_t *data = (uint8_t *)value;\n\t//\n\t//\n\t//\n\tfor (size_t i = 0; i < size; i++) {\n\t\t//\n\t\t//\n\t\t//\n\t\tuint8_t byte = read_byte(pos);\n\t\t//\n\t\t//\n\t\t//\n\t\tif (writing) {\n\t\t\t*data = byte;\n\t\t\tdata++;\n\t\t}\n\t\t//\n\t\t//\n\t\t//\n\t\tif (crc!= nullptr) {\n\t\t\t*crc = crc16(byte, *crc);\n\t\t}\n\t}\n\t//\n\t//\n\t//\n\treturn true;\n}", "CodeBleu_score": 45.81176822488825}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint8_t data;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (!read_data(pos, &data, 1, crc, writing)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (value) {\n\t\t\tvalue[i] = data;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 41.64949159705812}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin >= NUM_DIGITAL_PINS) {\n\t\treturn;\n\t}\n\n\tconst uint32_t pwm_freq = freq > 0? freq : PWM_FREQUENCY;\n\tconst uint16_t pwm_res = res > 0? res : PWM_RESOLUTION;\n\n\tif (pwm_freq <= 0 || pwm_res <= 0) {\n\t\treturn;\n\t}\n\n\tif (pwm_res > 16) {\n\t\treturn;\n\t}\n\n\tconst uint16_t pwm_channel = get_pwm_channel(pin);\n\n\tif (pwm_channel == PWM_CHANNEL_NONE) {\n\t\treturn;\n\t}\n\n\tconst uint8_t pwm_channel_index = pwm_channel / 8;\n\tconst uint8_t pwm_channel_bit = pwm_channel % 8;\n\n\tif (pwm_channel_index >= PWM_CHANNEL_COUNT) {\n\t\treturn;\n\t}\n\n\tconst uint8_t pwm_channel_mask = 1 << pwm_channel_bit;\n\n\tif (pwm_channel_mask & pwm_channel_mask_used) {\n\t\treturn;\n\t}\n\n\tif (pwm_channel_mask & pwm_channel_mask_used) {\n\t\treturn;\n\t}\n\n\tpwm_channel_mask_used |= pwm_channel_mask;\n\n\tif (pwm_channel_mask_used == 0) {\n\t\tpwm_channel_mask_used = pwm_channel_mask;\n\t}\n\n\tconst uint8_t pwm_channel_count = __builtin_popcount(pwm_channel_mask_used);\n\n\tif (pwm_channel_count >= PWM_CHANNEL_COUNT) {\n\t\treturn;\n\t}\n\n\tif (pwm_channel_count == 1) {\n\t\tconst uint32_t timer_div = pwm_freq / PWM_FREQUENCY;\n\n\t\tif (timer_div > 0) {\n\t\t\tconst uint32_t timer_freq = pwm_freq / timer_div;\n\t\t\tconst uint32_t timer_res = timer_freq / PWM_FREQUENCY;\n\n\t\t\tif (timer_res <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (timer_res >", "CodeBleu_score": 30.020354499849056}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tconst uint8_t channel = get_pwm_channel(pin);\n\tif (channel!= 255) {\n\t\tledcWrite(channel, value);\n\t}\n}", "CodeBleu_score": 12.773593636844616}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\t// Check if the pin is valid\n\tif (pin >= NUM_DIGITAL_PINS) {\n\t\treturn;\n\t}\n\t// Check if the pin is already used for PWM\n\tif (digital_pin_to_pwm_channel[pin]!= -1) {\n\t\t// Set the PWM value\n\t\tledcWrite(digital_pin_to_pwm_channel[pin], value);\n\t\treturn;\n\t}\n\t// Check if the pin is already used for software PWM\n\tif (digital_pin_to_pwm_state[pin]!= NULL) {\n\t\t// Set the PWM value\n\t\tdigital_pin_to_pwm_state[pin]->value = value;\n\t\treturn;\n\t}\n\t// Check if there is a free PWM channel\n\tint channel = -1;\n\tfor (int i = 0; i < PWM_CHANNELS; i++) {\n\t\tif (pwm_channel_to_pin[i] == -1) {\n\t\t\tchannel = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Check if there is a free PWM state\n\tint state = -1;\n\tfor (int i = 0; i < PWM_STATES; i++) {\n\t\tif (pwm_state_to_pin[i] == -1) {\n\t\t\tstate = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Check if there is a free PWM timer\n\tint timer = -1;\n\tfor (int i = 0; i < PWM_TIMERS; i++) {\n\t\tif (pwm_timer_to_pin[i] == -1) {\n\t\t\ttimer = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Check if there is a free PWM channel\n\tif (channel == -1) {\n\t\t// Check if there is a free PWM state\n\t\tif (state == -1) {\n\t\t\t// Check if there is a free PWM timer\n\t\t\tif (timer == -1) {\n\t\t\t\t// There is no free PWM channel, state or timer\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Get the first free PWM timer\n\t\t\ttimer = pwm_timer_to_pin[timer];\n\t\t\t// Start the PWM timer\n\t\t\tledcSetup(timer, freq, res);\n\t\t\tled", "CodeBleu_score": 47.965723563758836}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#if defined(ARDUINO) && ARDUINO >= 100\n    if (servo_delay_array_length!= SERVO_DELAY_ARRAY_LENGTH) {\n        static_assert(servo_delay_array_length == SERVO_DELAY_ARRAY_LENGTH,\n                      \"Servo::move() requires the same number of delay values as the number of servos attached\");\n    }\n#endif\n\n    if (attached) {\n        write(value);\n        safe_delay(servo_delay_array[channel]);\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n    }\n}", "CodeBleu_score": 44.94190352482505}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == SERVO_CHANNEL_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must be equal to SERVO_CHANNEL_COUNT\");\n\tif (this->attach()) {\n\t\tthis->write(value);\n\t\tsafe_delay(SERVO_DELAY_ARRAY[this->channel]);\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) this->detach();\n\t}\n}", "CodeBleu_score": 30.181152041284655}, {"code": "void Servo::move(const int value){\n\t#if defined(ARDUINO) && ARDUINO >= 100\n    static_assert(SERVO_DELAY_COUNT == SERVOS_COUNT, \"SERVO_DELAY_COUNT!= SERVOS_COUNT\");\n#endif\n\n    if (this->servo.attach(this->pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH)) {\n        this->servo.write(value);\n        safe_delay(SERVO_DELAY_COUNT, this->delay);\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n            this->detach();\n        }\n    }\n}", "CodeBleu_score": 38.778826889578966}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tif (i2s_state.dma_buffer_position == i2s_state.dma_buffer_size) {\n\t\ti2s_state.dma_buffer_position = 0;\n\t}\n\tif (i2s_state.dma_buffer_position + 4 > i2s_state.dma_buffer_size) {\n\t\ti2s_state.dma_buffer_position = 0;\n\t}\n\tuint32_t port_data = 0;\n\tfor (uint32_t i = 0; i < 32; i++) {\n\t\tif (i2s_state.pwm_states[i].pin_active) {\n\t\t\ti2s_state.pwm_states[i].tick_count--;\n\t\t\tif (i2s_state.pwm_states[i].tick_count == 0) {\n\t\t\t\tif (i2s_state.pwm_states[i].pin_state == 0) {\n\t\t\t\t\ti2s_state.pwm_states[i].pin_state = 1;\n\t\t\t\t\ti2s_state.pwm_states[i].tick_count = i2s_state.pwm_states[i].duty_cycle;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_state.pwm_states[i].pin_state = 0;\n\t\t\t\t\ti2s_state.pwm_states[i].tick_count = i2s_state.pwm_states[i].duty_cycle;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tport_data |= i2s_state.pwm_states[i].pin_state << i;\n\t}\n\ti2s_state.dma_buffer[i2s_state.dma_buffer_position++] = port_data;\n\ti2s_state.dma_buffer[i2s_state.dma_buffer_position++] = port_data >> 16;\n\ti2s_state.dma_buffer[i2s_state.dma_buffer_position++] = port_data >> 8;\n\ti2s_state.dma_buffer[i2s_state.dma_buffer_position++] = port_data >> 24;\n}", "CodeBleu_score": 46.71358722066831}, {"code": "void i2s_push_sample(){\n\t\tif (i2s_dma_buffer_pos >= i2s_dma_buffer_size) {\n\t\ti2s_dma_buffer_pos = 0;\n\t}\n\tuint32_t data = 0;\n\tuint32_t mask = 0;\n\tuint32_t i;\n\tfor (i = 0; i < I2S_PIN_COUNT; i++) {\n\t\tif (i2s_pins[i].active) {\n\t\t\ti2s_pins[i].tick_count--;\n\t\t\tif (i2s_pins[i].tick_count == 0) {\n\t\t\t\ti2s_pins[i].tick_count = i2s_pins[i].period;\n\t\t\t\tif (i2s_pins[i].state == HIGH) {\n\t\t\t\t\ti2s_pins[i].state = LOW;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pins[i].state = HIGH;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask |= (1 << i);\n\t\t\tif (i2s_pins[i].state == HIGH) {\n\t\t\t\tdata |= (1 << i);\n\t\t\t}\n\t\t}\n\t}\n\ti2s_dma_buffer[i2s_dma_buffer_pos++] = data;\n\ti2s_dma_buffer[i2s_dma_buffer_pos++] = mask;\n}", "CodeBleu_score": 22.932003149256936}, {"code": "void i2s_push_sample(){\n\t\t// Update the PWM states for each pin and write the resulting data to the DMA buffer.\n\tfor (uint8_t i = 0; i < I2S_NUM_PINS; i++) {\n\t\t// Check if the pin has active PWM.\n\t\tif (i2s_pin_pwm_state[i].active) {\n\t\t\t// Check if the PWM tick count has reached zero.\n\t\t\tif (i2s_pin_pwm_state[i].tick_count == 0) {\n\t\t\t\t// Toggle the pin state between high and low.\n\t\t\t\ti2s_pin_pwm_state[i].pin_state = i2s_pin_pwm_state[i].pin_state? 0 : 1;\n\t\t\t\t// Set the tick count for the next transition.\n\t\t\t\ti2s_pin_pwm_state[i].tick_count = i2s_pin_pwm_state[i].period;\n\t\t\t}\n\t\t\t// Decrement the PWM tick count.\n\t\t\ti2s_pin_pwm_state[i].tick_count--;\n\t\t}\n\t\t// Store the updated port data into the current position of the DMA buffer.\n\t\ti2s_dma_buffer[i2s_dma_buffer_position] |= i2s_pin_pwm_state[i].pin_state << i;\n\t}\n\t// Increment the buffer position.\n\ti2s_dma_buffer_position++;\n\t// Check if the buffer position has reached the end of the buffer.\n\tif (i2s_dma_buffer_position == I2S_DMA_BUFFER_SIZE) {\n\t\t// Reset the buffer position.\n\t\ti2s_dma_buffer_position = 0;\n\t\t// Start the DMA transfer.\n\t\ti2s_dma_transfer_start();\n\t}\n}", "CodeBleu_score": 33.99569362528049}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn timer_get_count(timer_num);\n}", "CodeBleu_score": 13.703296291452144}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\t// Check if the timer number is valid\n\tif (timer_num >= HAL_TIMER_NUM_MAX) {\n\t\treturn 0;\n\t}\n\n\t// Check if the timer is configured\n\tif (!HAL_timer_is_configured(timer_num)) {\n\t\treturn 0;\n\t}\n\n\t// Get the timer configuration\n\tconst hal_timer_config_t* config = &HAL_timer_config[timer_num];\n\n\t// Get the timer counter value\n\tuint32_t counter_value = 0;\n\tif (config->timer_type == HAL_TIMER_TYPE_TIMER) {\n\t\tcounter_value = TIM_GetCounter(config->timer_handle);\n\t} else if (config->timer_type == HAL_TIMER_TYPE_WTIMER) {\n\t\tcounter_value = WTIMER_GetCounter(config->wtimer_handle);\n\t}\n\n\t// Return the timer counter value\n\treturn counter_value;\n}", "CodeBleu_score": 46.54662893750272}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn timer_get_count(timer_num);\n}", "CodeBleu_score": 13.703296291452144}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tuint8_t temp[size];\n\tbool result = read_data(pos, temp, size, crc, writing);\n\tif (result) {\n\t\tmemcpy(value, temp, size);\n\t}\n\treturn result;\n}", "CodeBleu_score": 35.69620063023944}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tuint8_t *data = (uint8_t *)value;\n\tif (writing) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tdata[i] = EEPROM.read(pos++);\n\t\t\t*crc = update_crc(*crc, data[i]);\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tdata[i] = EEPROM.read(pos++);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 56.081655900696894}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tuint8_t *data = (uint8_t *)value;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tdata[i] = EEPROM.read(pos + i);\n\t\tif (crc) {\n\t\t\t*crc = update_crc16(*crc, data[i]);\n\t\t}\n\t}\n\tif (writing) {\n\t\tmemcpy(value, data, size);\n\t}\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 60.90649838968012}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (sdio_handle == NULL || src == NULL) {\n\t\tCORE_ASSERT(false, \"SDIO_WriteBlock: invalid handle or source pointer\");\n\t}\n\n\tuint32_t retries = SDIO_WRITE_RETRIES;\n\tbool success = false;\n\tdo {\n\t\tif (HAL_SD_WriteBlocks(sdio_handle, (uint8_t *)src, block, 1, 1000) == HAL_OK) {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\t} while (retries--);\n\n\tif (!success) {\n\t\tPRINTF(\"SDIO_WriteBlock: write failed after %d retries\n\", SDIO_WRITE_RETRIES - retries);\n\t}\n\n\treturn success;\n}", "CodeBleu_score": 41.663390719115625}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (sdio_handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tuint32_t retries = 0;\n\twhile (retries < SDIO_MAX_RETRIES) {\n\t\tif (SDCARD_WriteBlocks(sdio_handle, block, 1, (uint32_t *) src) == true) {\n\t\t\treturn true;\n\t\t}\n\t\tretries++;\n\t}\n\tprintf(\"SDIO_WriteBlock failed after %d retries\n\", retries);\n\treturn false;\n}", "CodeBleu_score": 35.8637234644296}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (sdio_handle == NULL || src == NULL) {\n\t\tCORE_ASSERT(false, \"SDIO_WriteBlock: invalid parameters\");\n\t}\n\n\tuint32_t retry = 0;\n\twhile (retry < SDIO_MAX_RETRY) {\n\t\tif (SDIO_WriteBlocks(block, src, 1) == SDIO_OK) {\n\t\t\treturn true;\n\t\t}\n\t\tretry++;\n\t}\n\tprintf(\"SDIO_WriteBlock: failed to write block %u\n\", block);\n\treturn false;\n}", "CodeBleu_score": 30.12844890839368}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\t// Set the frequency of the timer\n\t\tTIMER_16_1->PRESCALE = (uint16_t) (F_CPU / frequency);\n\t\t// Enable the timer\n\t\tTIMER_16_1->CTRL = (TIMER_CTRL_ENABLE | TIMER_CTRL_MODE_16_BIT);\n\t\t// Set the callback priority for temperature\n\t\tNVIC_SetPriority(TIMER_16_1_IRQn, 2);\n\t\t// Enable the interrupt\n\t\tNVIC_EnableIRQ(TIMER_16_1_IRQn);\n\t} else if (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\t// Set the frequency of the timer\n\t\tTIMER_16_0->PRESCALE = (uint16_t) (F_CPU / frequency);\n\t\t// Enable the timer\n\t\tTIMER_16_0->CTRL = (TIMER_CTRL_ENABLE | TIMER_CTRL_MODE_16_BIT);\n\t\t// Set the callback priority for stepper\n\t\tNVIC_SetPriority(TIMER_16_0_IRQn, 1);\n\t\t// Enable the interrupt\n\t\tNVIC_EnableIRQ(TIMER_16_0_IRQn);\n\t} else {\n\t\tCORE_ASSERT_FAIL(\"Invalid timer channel\");\n\t}\n}", "CodeBleu_score": 41.24338175288721}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tuint32_t prescale;\n\n\t/*\n\t * If the timer channel is invalid, it triggers an assertion failure.\n\t */\n\tCORE_ASSERT_FAIL(timer_num < TIMER_NUM_MAX);\n\n\t/*\n\t * If the timer channel corresponds to the temperature timer, it starts the timer with the given frequency and temperature timer prescale, and sets the callback priority for temperature.\n\t */\n\tif (timer_num == TIMER_NUM_TEMPERATURE) {\n\t\t/*\n\t\t * If the temperature timer prescale is invalid, it triggers an assertion failure.\n\t\t */\n\t\tCORE_ASSERT_FAIL(temperature_timer_prescale > 0U);\n\n\t\t/*\n\t\t * Sets the timer prescale.\n\t\t */\n\t\tprescale = (uint32_t) (HAL_CMU_getHFRCOFreq() / frequency / temperature_timer_prescale);\n\n\t\t/*\n\t\t * If the timer prescale is invalid, it triggers an assertion failure.\n\t\t */\n\t\tCORE_ASSERT_FAIL(prescale > 0U);\n\n\t\t/*\n\t\t * Sets the timer prescale.\n\t\t */\n\t\tTIMER_TOP_REG(TIMER_NUM_TEMPERATURE) = prescale;\n\n\t\t/*\n\t\t * Sets the timer callback priority for temperature.\n\t\t */\n\t\tCORE_DEBUG_PRINTF(\"TIMER_NUM_TEMPERATURE: %d", "CodeBleu_score": 29.55725351178128}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_CHANNEL_0) {\n\t\tHAL_timer_start_channel0(frequency);\n\t} else if (timer_num == TIMER_CHANNEL_1) {\n\t\tHAL_timer_start_channel1(frequency);\n\t} else if (timer_num == TIMER_CHANNEL_2) {\n\t\tHAL_timer_start_channel2(frequency);\n\t} else if (timer_num == TIMER_CHANNEL_3) {\n\t\tHAL_timer_start_channel3(frequency);\n\t} else {\n\t\tCORE_ASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 37.518367697727435}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\t// Open the file\n\tfile = fopen(filename, \"r+\");\n\t// Check if the file was opened successfully\n\tif (file == NULL) {\n\t\treturn false;\n\t}\n\t// Get the file size\n\tfseek(file, 0, SEEK_END);\n\tfile_size = ftell(file);\n\t// If the file is smaller than the EEPROM size, fill the remainder of the buffer with a default erase value\n\tif (file_size < EEPROM_SIZE) {\n\t\tmemset(buffer, erase_value, EEPROM_SIZE - file_size);\n\t\tfile_size = EEPROM_SIZE;\n\t}\n\t// Read the file's contents into the buffer\n\tfseek(file, 0, SEEK_SET);\n\tfread(buffer, file_size, 1, file);\n\t// Close the file\n\tfclose(file);\n\t// Return true to indicate success\n\treturn true;\n}", "CodeBleu_score": 37.936896133582934}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open the file\n\tif( (file = fopen(EEPROM_FILE_NAME, \"r+b\")) == NULL ) {\n\t\t// If the file does not exist, create it\n\t\tif( (file = fopen(EEPROM_FILE_NAME, \"w+b\")) == NULL ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Get the file size\n\tif( fseek(file, 0, SEEK_END) == -1 ) {\n\t\treturn false;\n\t}\n\tsize = ftell(file);\n\n\t// If the file is smaller than the expected EEPROM size, fill the remainder with a default erase value\n\tif( size < EEPROM_SIZE ) {\n\t\t// Fill the remainder of the buffer with the default erase value\n\t\tmemset(buffer + size, EEPROM_ERASE_VALUE, EEPROM_SIZE - size);\n\t\t// Update the file size\n\t\tsize = EEPROM_SIZE;\n\t}\n\n\t// Read the file's contents into the buffer\n\tif( fseek(file, 0, SEEK_SET) == -1 ) {\n\t\treturn false;\n\t}\n\tif( fread(buffer, 1, size, file)!= size ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 39.59710243129638}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open the file\n\tFILE *fp = fopen(EEPROM_FILENAME, \"r+\");\n\tif (fp == NULL) {\n\t\t// File does not exist, so create a new one\n\t\tfp = fopen(EEPROM_FILENAME, \"w+\");\n\t\tif (fp == NULL) {\n\t\t\t// Failed to create the file\n\t\t\treturn false;\n\t\t}\n\t\t// File created, so initialize the buffer\n\t\tmemset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n\t} else {\n\t\t// File exists, so check its size\n\t\tfseek(fp, 0, SEEK_END);\n\t\tsize_t file_size = ftell(fp);\n\t\tif (file_size < EEPROM_SIZE) {\n\t\t\t// File is smaller than the expected size, so fill the remainder of the buffer with a default erase value\n\t\t\tfseek(fp, file_size, SEEK_SET);\n\t\t\tmemset(buffer + file_size, EEPROM_ERASE_VALUE, EEPROM_SIZE - file_size);\n\t\t} else if (file_size > EEPROM_SIZE) {\n\t\t\t// File is larger than the expected size, so truncate it\n\t\t\tfseek(fp, EEPROM_SIZE, SEEK_SET);\n\t\t\tftruncate(fileno(fp), EEPROM_SIZE);\n\t\t}\n\t\t// Read the file's contents into the buffer\n\t\tfseek(fp, 0, SEEK_SET);\n\t\tfread(buffer, 1, EEPROM_SIZE, fp);\n\t}\n\t// Close the file\n\tfclose(fp);\n\treturn true;\n}", "CodeBleu_score": 43.47311474677629}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t ret = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tMOSI_HIGH();\n\t\t} else {\n\t\t\tMOSI_LOW();\n\t\t}\n\t\tdelaySPIFunc();\n\t\tSCK_HIGH();\n\t\tdelaySPIFunc();\n\t\tif (MISO_READ()) {\n\t\t\tret |= 0x01;\n\t\t}\n\t\tSCK_LOW();\n\t\tb <<= 1;\n\t\tret <<= 1;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 37.780810867730075}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\t// set clock low\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\t// write MOSI\n\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin,\n\t\t\t\t(b & (1 << (7 - i)))? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\t// toggle clock\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\t// read MISO\n\t\tret <<= 1;\n\t\tret |= HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin);\n\t}\n\t// delay\n\tdelaySPIFunc();\n\treturn ret;\n}", "CodeBleu_score": 38.6533720482265}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t result = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80)\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_SET);\n\t\telse\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET)\n\t\t\tresult |= 0x01;\n\t\tb <<= 1;\n\t\tresult <<= 1;\n\t}\n\treturn result;\n}", "CodeBleu_score": 35.74930494284799}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73126554935065}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73126554935065}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c = obj->uart->RDR;\n\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\tif (obj->rx_buffer_head == (obj->rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE) {\n\t\t\t// Overflow\n\t\t\tobj->rx_buffer_head = obj->rx_buffer_tail;\n\t\t}\n\t\tobj->rx_buffer[obj->rx_buffer_head] = c;\n\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t}\n\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\tif (obj->rx_buffer_head == (obj->rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE) {\n\t\t\t// Overflow\n\t\t\tobj->rx_buffer_head = obj->rx_buffer_tail;\n\t\t}\n\t\tobj->rx_buffer[obj->rx_buffer_head] = c;\n\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t}\n\tif (obj->emergency_parser.enabled) {\n\t\tobj->emergency_parser.update(c);\n\t}\n}", "CodeBleu_score": 42.58320413400962}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tMSerialT *uart = static_cast<MSerialT*>(obj);\n\tuint8_t c;\n\tuint8_t *rxbuf = uart->rxbuf;\n\tuint8_t *rxhead = uart->rxhead;\n\tuint8_t *rxtail = uart->rxtail;\n\tuint8_t *rxbufend = uart->rxbufend;\n\tuint8_t *rxbufstart = uart->rxbufstart;\n\tuint8_t *rxbufend_1 = uart->rxbufend_1;\n\tuint8_t *rxbufstart_1 = uart->rxbufstart_1;\n\tuint8_t *rxbufend_2 = uart->rxbufend_2;\n\tuint8_t *rxbufstart_2 = uart->rxbufstart_2;\n\tuint8_t *rxbufend_3 = uart->rxbufend_3;\n\tuint8_t *rxbufstart_3 = uart->rxbufstart_3;\n\tuint8_t *rxbufend_4 = uart->rxbufend_4;\n\tuint8_t *rxbufstart_4 = uart->rxbufstart_4;\n\tuint8_t *rxbufend_5 = uart->rxbufend_5;\n\tuint8_t *rxbufstart_5 = uart->rxbufstart_5;\n\tuint8_t *rxbufend_6 = uart->rxbufend_6;\n\tuint8_t *rxbufstart_6 = uart->rxbufstart_6;\n\tuint8_t *rxbufend_7 = uart->rxbufend_7;\n\tuint8_t *rxbufstart_7 = uart->rxbufstart_7;\n\tuint8_t *rxbufend_8 = uart->rxbufend_8;\n\tuint8_t *rxbufstart_8 = uart->rxbufstart_8;\n\tuint8_t *rxbufend_9 = uart->rxbufend_9;\n\tuint8_t *rxbufstart_9 = uart->rxbufstart_9;\n\tuint8_t *rxbufend_10 = uart->rxbufend_10;\n\tuint8_", "CodeBleu_score": 23.858696987737478}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c = obj->uart->uart_read();\n\tif (obj->uart->uart_get_status() & UART_STATUS_PARITY_ERR) {\n\t\t// Parity error, discard byte\n\t\tobj->uart->uart_clear_status(UART_STATUS_PARITY_ERR);\n\t} else {\n\t\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\t\t// Buffer is not full, store received byte\n\t\t\tobj->rx_buffer[obj->rx_buffer_head] = c;\n\t\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t\t}\n\t}\n\t// Update emergency parser\n\temergency_parser.update(c);\n}", "CodeBleu_score": 44.2087814810284}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->initialized &&!timer_instance[timer_num]->hasInterrupt) {\n\t\tswitch (timer_num) {\n\t\tcase MF_TIMER_STEP:\n\t\t\tNVIC_EnableIRQ(TIMER_A0_IRQn);\n\t\t\tbreak;\n\t\tcase MF_TIMER_TEMP:\n\t\t\tNVIC_EnableIRQ(TIMER_A1_IRQn);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 59.374616680267366}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->is_initialized) {\n\t\tif (timer_instance[timer_num]->hasInterrupt == false) {\n\t\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\t\tNVIC_SetPriority(TIMER0_IRQn, 0);\n\t\t\t\tNVIC_EnableIRQ(TIMER0_IRQn);\n\t\t\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\t\tNVIC_SetPriority(TIMER1_IRQn, 0);\n\t\t\t\tNVIC_EnableIRQ(TIMER1_IRQn);\n\t\t\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 48.53520797180021}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]!= NULL && timer_instance[timer_num]->hasInterrupt == false) {\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\tNVIC_EnableIRQ(TIMER0_IRQn);\n\t\t\tNVIC_SetPriority(TIMER0_IRQn, 1);\n\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\tNVIC_EnableIRQ(TIMER1_IRQn);\n\t\t\tNVIC_SetPriority(TIMER1_IRQn, 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 49.440928405998804}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(s) == 0 || len(s) < len(sep) {\n\t\treturn -1\n\t}\n\tif len(s) == len(sep) {\n\t\treturn 0\n\t}\n\tif len(s) == 1 {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\tfor i := len(s) - 1; i >= 0; i-- {\n\t\t\tif s[i] == sep[0] {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\tif len(sep) == 2 {\n\t\tfor i := len(s) - 2; i >= 0; i-- {\n\t\t\tif s[i] == sep[0] && s[i+1] == sep[1] {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\tif len(sep) == 3 {\n\t\tfor i := len(s) - 3; i >= 0; i-- {\n\t\t\tif s[i] == sep[0] && s[i+1] == sep[1] && s[i+2] == sep[2] {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\tif len(sep) == 4 {\n\t\tfor i := len(s) - 4; i >= 0; i-- {\n\t\t\tif s[i] == sep[0] && s[i+1] == sep[1] && s[i+2] == sep[2] && s[i+3] == sep[3] {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\tif len(sep) == 5 {\n\t\tfor i := len(s) - 5; i >= 0; i-- {\n\t\t\tif s[i] == sep[0] && s[i+1] == sep[1] && s[i+2] == sep[2] && s[i+3] == sep[3] && s[i+4] == sep[4] {\n\t\t\t\treturn i\n\t\t\t", "CodeBleu_score": 31.01421046074002}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(sep) == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\treturn LastIndexRabinKarpHash(s, sep, HashStrRev)\n}", "CodeBleu_score": 10.459740555657108}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\treturn LastIndexRabinKarpHash(s, sep)\n}", "CodeBleu_score": 9.674435759632283}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.waitTxc = false\n\tif usbcdc.txBuffer.Get() {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() {\n\t\tusbcdc.waitTxc = true\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 35.4840081521195}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.txBuffer.Get()\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Length() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tusbcdc.waitTxc = false\n\tinterrupt.Restore()\n}", "CodeBleu_score": 40.40530051635589}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.waitTxc = false\n\tif usbcdc.txBuffer.Get()!= 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get()!= 0 {\n\t\tusbcdc.waitTxc = true\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 34.974302866330945}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.Interrupt)\n\ti2c.crReg.SetBits(i2c.crReg.Start)\n\ti2c.crReg.SetBits(i2c.crReg.I2c)\n\tfor!i2c.crReg.HasBits(i2c.crReg.Interrupt) {\n\t}\n\ti2c.writeByte((address << 1) | (uint8(write) << 0))\n}", "CodeBleu_score": 33.49352684159233}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.HasBits(i2c.crReg.IEN) | i2c.crReg.HasBits(i2c.crReg.EN))\n\ti2c.crReg.SetBits(i2c.crReg.HasBits(i2c.crReg.START) | i2c.crReg.HasBits(i2c.crReg.EN))\n\tfor i2c.crReg.HasBits(i2c.crReg.START) {\n\t}\n\ti2c.writeByte(address<<1 | (uint8(write) & 1))\n}", "CodeBleu_score": 34.87505208722417}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.Bits.IEN)\n\ti2c.crReg.SetBits(i2c.crReg.Bits.START)\n\ti2c.crReg.SetBits(i2c.crReg.Bits.IEN)\n\tfor i2c.crReg.HasBits(i2c.crReg.Bits.BUSY) {\n\t}\n\ti2c.writeByte(address << 1)\n\tif write {\n\t\ti2c.crReg.ClearBits(i2c.crReg.Bits.RD)\n\t} else {\n\t\ti2c.crReg.SetBits(i2c.crReg.Bits.RD)\n\t}\n}", "CodeBleu_score": 30.73240910407814}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || start >= f.NumBlocks || len < 0 || len > f.NumBlocks-start {\n\t\treturn errors.New(\"invalid block range\")\n\t}\n\t// Calculate the start address of the first block to erase.\n\tstartAddr := f.FlashDataStart + (f.EraseBlockSize * uint32(start))\n\t// Calculate the number of blocks to erase.\n\tnumBlocks := uint32(len)\n\t// Configure the flash for erasing.\n\tnrf.NVMC.SetCONFIG_WEN\n\t// Wait for any ongoing flash operations to complete.\n\twaitWhileFlashBusy()\n\t// Erase the specified number of blocks.\n\tfor i := uint32(0); i < numBlocks; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(startAddr + (f.EraseBlockSize * i))\n\t\twaitWhileFlashBusy()\n\t}\n\t// Set the flash back to read mode.\n\tnrf.NVMC.SetCONFIG_WEN\n\treturn nil\n}", "CodeBleu_score": 43.99225763376461}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"Invalid start or len\")\n\t}\n\tif start+len > f.NumBlocks {\n\t\treturn errors.New(\"Invalid start or len\")\n\t}\n\t// Calculate the start address of the block to be erased\n\tstartAddr := f.FlashDataStart + (start * f.EraseBlockSize)\n\t// Wait for any ongoing flash operations to complete\n\twaitWhileFlashBusy()\n\t// Configure the flash for erasing\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_WEN_E)\n\t// Erase each block\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(startAddr + (i * f.EraseBlockSize)))\n\t\t// Wait until the flash is no longer busy\n\t\twaitWhileFlashBusy()\n\t}\n\t// Set the flash back to read mode\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_WEN_Disabled)\n\treturn nil\n}", "CodeBleu_score": 44.675917518976114}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address based on the block number and block size.\n\tstartAddr := start * f.EraseBlockSize\n\t// Wait for any ongoing flash operations to complete.\n\twaitWhileFlashBusy()\n\t// Configure the flash for erasing.\n\tnrf.NVMC.SetCONFIG_WEN.Set()\n\t// Erase each block.\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set()\n\t\tnrf.NVMC.ERASEPAGE.Set()\n\t\t// Wait until the flash is no longer busy.\n\t\twaitWhileFlashBusy()\n\t}\n\t// Set the flash back to read mode.\n\tnrf.NVMC.SetCONFIG_WEN.Clear()\n\treturn nil\n}", "CodeBleu_score": 34.701738258982765}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, errors.New(\"flashBlockDevice: negative offset\")\n\t}\n\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"flashBlockDevice: write past end\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tstartAddr := off + f.FlashDataStart\n\tif startAddr%f.WriteBlockSize!= 0 {\n\t\tstartAddr = startAddr + f.WriteBlockSize - (startAddr % f.WriteBlockSize)\n\t}\n\tif startAddr+int64(len(p)) > f.FlashDataEnd {\n\t\treturn 0, errors.New(\"flashBlockDevice: write past end\")\n\t}\n\n\tf.NVMC.SetCONFIG_WEN()\n\tfor len(p) > 0 {\n\t\tf.NVMC.SetCONFIG_WEN()\n\t\tf.NVMC.SetADDR(uint32(startAddr))\n\t\tfor len(p) >= f.WriteBlockSize {\n\t\t\tf.NVMC.SetWDATA(*(*uint32)(unsafe.Pointer(&p[0])))\n\t\t\tf.NVMC.SetCMD(nrf.NVMC_CMD_ERASEWRITE_VALUE)\n\t\t\twaitWhileFlashBusy()\n\t\t\tp = p[f.WriteBlockSize:]\n\t\t\tstartAddr += f.WriteBlockSize\n\t\t}\n\t\tif len(p) > 0 {\n\t\t\tf.NVMC.SetWDATA(*(*uint32)(unsafe.Pointer(&p[0])))\n\t\t\tf.NVMC.SetCMD(nrf.NVMC_CMD_ERASEWRITE_VALUE)\n\t\t\twaitWhileFlashBusy()\n\t\t\tp = p[len(p):]\n\t\t}\n\t}\n\treturn len(p), nil\n}", "CodeBleu_score": 36.56200782515677}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 || off+int64(len(p)) > f.Size() {\nreturn 0, errors.New(\"out of bounds\")\n}\nif f.writeBlockSize == 0 {\nreturn 0, errors.New(\"write block size is zero\")\n}\nstartAddress := FlashDataStart + off\nendAddress := startAddress + int64(len(p))\nif endAddress > FlashDataEnd {\nreturn 0, errors.New(\"out of bounds\")\n}\nif len(p)%int(f.writeBlockSize)!= 0 {\np = f.pad(p, f.writeBlockSize)\n}\nnrf.NVMC.SetCONFIG_WEN(true)\nfor i := 0; i < len(p); i += int(f.writeBlockSize) {\nnrf.NVMC.SetADDR(uint32(startAddress + int64(i)))\nfor j := 0; j < int(f.writeBlockSize); j++ {\nnrf.NVMC.SetPTR(uint32(p[i+j]))\n}\nnrf.NVMC.SetCONFIG_WEN(false)\nnrf.NVMC.SetCONFIG_WEN(true)\nwaitWhileFlashBusy()\n}\nreturn len(p), nil\n}", "CodeBleu_score": 41.414728929058704}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off > f.Size() {\n\t\treturn 0, errors.New(\"write out of bounds\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tstartAddr := f.FlashDataStart + off\n\tif startAddr%f.WriteBlockSize!= 0 {\n\t\treturn 0, errors.New(\"write offset not aligned\")\n\t}\n\tif startAddr+int64(len(p)) > f.FlashDataEnd {\n\t\treturn 0, errors.New(\"write out of bounds\")\n\t}\n\tf.nrf.NVMC.SetCONFIG_WEN()\n\twaitWhileFlashBusy(f.nrf)\n\tfor len(p) > 0 {\n\t\tvar buf [f.WriteBlockSize]byte\n\t\tif len(p) < len(buf) {\n\t\t\tcopy(buf[:], p)\n\t\t\tp = nil\n\t\t} else {\n\t\t\tcopy(buf[:], p[:f.WriteBlockSize])\n\t\t\tp = p[f.WriteBlockSize:]\n\t\t}\n\t\tf.nrf.NVMC.SetERASE_BLOCK(uint32(startAddr))\n\t\twaitWhileFlashBusy(f.nrf)\n\t\tf.nrf.NVMC.SetERASE_PAGE(uint32(startAddr))\n\t\twaitWhileFlashBusy(f.nrf)\n\t\tf.nrf.NVMC.SetWRITE_BYTES(uint32(startAddr), buf[:])\n\t\twaitWhileFlashBusy(f.nrf)\n\t\tstartAddr += int64(f.WriteBlockSize)\n\t\tn += len(buf)\n\t}\n\treturn n, nil\n}", "CodeBleu_score": 32.34994148057144}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// First, duplicate the provided file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(dupFd)\n\n\t// Repeatedly attempt to open the directory using syscall.Fdopendir until it either succeeds or encounters an error other than syscall.EINTR.\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 54.52071732676749}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the provided file descriptor.\n\tdup, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(dup)\n\n\t// Attempt to open the directory using syscall.Fdopendir.\n\tdir, err := syscall.Fdopendir(dup)\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// If an error other than syscall.EINTR was encountered, return the directory pointer with no error.\n\tif err!= syscall.EINTR {\n\t\treturn uintptr(dir), \"\", nil\n\t}\n\n\t// If syscall.EINTR was encountered, close the duplicated file descriptor and attempt to open the directory again.\n\tsyscall.Close(dup)\n\tdir, err = syscall.Fdopendir(dup)\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 52.399781473811814}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor\n\tnewFd, err := syscall.Dup(fd)\n\tif err!= nil {\n\t\treturn 0, err.Error(), err\n\t}\n\t// Attempt to open the directory\n\tdir, err := syscall.Fdopendir(newFd)\n\tif err!= nil {\n\t\t// Close the duplicated file descriptor\n\t\tsyscall.Close(newFd)\n\t\treturn 0, err.Error(), err\n\t}\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 47.045787672645304}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running = esp_ota_get_running_partition();\n\tesp_app_desc_t running_app_info;\n\tesp_ota_get_partition_description(running, &running_app_info);\n\tif (response) {\n\t\treturn running_app_info.app_free;\n\t}\n\treturn running_app_info.app_size;\n}", "CodeBleu_score": 34.3343489623962}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tuint32_t size = 0;\n\tif (response == sketchSize_t::free_space) {\n\t\tesp_partition_t* partition = esp_ota_get_running_partition();\n\t\tif (partition) {\n\t\t\tesp_partition_info_t info;\n\t\t\tif (esp_partition_get_info(partition, &info)) {\n\t\t\t\tsize = info.address - info.address - info.size;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tesp_partition_t* partition = esp_ota_get_running_partition();\n\t\tif (partition) {\n\t\t\tesp_partition_info_t info;\n\t\t\tif (esp_partition_get_info(partition, &info)) {\n\t\t\t\tsize = info.size;\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}", "CodeBleu_score": 41.76065185628261}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tuint32_t size = 0;\n\tuint32_t partition_size = 0;\n\tuint32_t partition_offset = 0;\n\tuint32_t partition_magic = 0;\n\tuint32_t partition_crc = 0;\n\tuint32_t partition_version = 0;\n\tuint32_t partition_type = 0;\n\tuint32_t partition_subtype = 0;\n\tuint32_t partition_data_size = 0;\n\tuint32_t partition_data_crc = 0;\n\tuint32_t partition_data_magic = 0;\n\tesp_partition_info_t partition_info;\n\tesp_image_metadata_t metadata;\n\tesp_image_header_t header;\n\tesp_err_t ret;\n\tif (esp_partition_get_info(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_FACTORY, &partition_info) == ESP_OK) {\n\t\tpartition_size = partition_info.size;\n\t\tpartition_offset = partition_info.offset;\n\t\tpartition_magic = partition_info.magic;\n\t\tpartition_crc = partition_info.crc;\n\t\tpartition_version = partition_info.version;\n\t\tpartition_type = partition_info.type;\n\t\tpartition_subtype = partition_info.subtype;\n\t\tpartition_data_size = partition_info.data_size;\n\t\tpartition_data_crc = partition_info.data_crc;\n\t\tpartition_data_magic = partition_info.data_magic;\n\t\tret = esp_image_verify(partition_offset, partition_magic, &metadata);\n\t\tif (ret == ESP_OK) {\n\t\t\tret = esp_image_load(partition_offset, &header);\n\t\t\tif (ret == ESP_OK) {\n\t\t\t\tif (response == SKETCH_SIZE_AVAILABLE) {\n\t\t\t\t\tsize = partition_size - partition_offset - partition_data_size;\n\t\t\t\t} else {\n\t\t\t\t\tsize = header.size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}", "CodeBleu_score": 35.467110226682806}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\t// Calculate the required disk sectors\n\tuint32_t required_disk_sectors = msc_update_get_required_disk_sectors();\n\t// Allocate memory for the RAM disk\n\tuint8_t *disk = calloc(required_disk_sectors, SECTOR_SIZE);\n\tif (disk == NULL) {\n\t\t// Log an error if allocation fails\n\t\tlog_e(\"Failed to allocate memory for the RAM disk\");\n\t\treturn false;\n\t}\n\t// Set up the boot sector\n\tfat_add_boot_sector(disk, volume_label, serial_number);\n\t// Set up the file allocation table (FAT)\n\tfat_add_table(disk);\n\t// Optionally add a root directory entry for a firmware file if a partition is running\n\tfat_add_root_file(disk);\n\t// Set the disk pointer to the RAM disk\n\tmsc_update_disk = disk;\n\t// Return true upon successful setup\n\treturn true;\n}", "CodeBleu_score": 26.341388302249364}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t required_disk_sectors = msc_update_get_required_disk_sectors(volume_label, serial_number);\n\tif (required_disk_sectors == 0) {\n\t\tlog_e(\"Could not calculate required disk sectors\");\n\t\treturn false;\n\t}\n\tuint8_t *disk_buffer = calloc(required_disk_sectors, MSC_UPDATE_SECTOR_SIZE);\n\tif (disk_buffer == NULL) {\n\t\tlog_e(\"Could not allocate memory for disk\");\n\t\treturn false;\n\t}\n\tfat_add_boot_sector(disk_buffer, volume_label, serial_number);\n\tfat_add_table(disk_buffer);\n\tif (msc_update_partition_running()) {\n\t\tfat_add_root_file(disk_buffer, \"firmware.bin\", 0);\n\t}\n\tmsc_update_set_disk_buffer(disk_buffer, required_disk_sectors);\n\treturn true;\n}", "CodeBleu_score": 28.168645260425446}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t disk_size_in_sectors = msc_update_get_required_disk_sectors(volume_label, serial_number);\n\tif (disk_size_in_sectors == 0) {\n\t\tlog_e(\"Failed to calculate required disk sectors\");\n\t\treturn false;\n\t}\n\n\tmsc_update_disk_buffer = calloc(disk_size_in_sectors, sizeof(uint8_t));\n\tif (msc_update_disk_buffer == NULL) {\n\t\tlog_e(\"Failed to allocate memory for disk buffer\");\n\t\treturn false;\n\t}\n\n\tmsc_update_disk_size_in_sectors = disk_size_in_sectors;\n\tmsc_update_disk_size_in_bytes = disk_size_in_sectors * SECTOR_SIZE;\n\n\tfat_add_boot_sector(msc_update_disk_buffer, volume_label, serial_number);\n\tfat_add_table(msc_update_disk_buffer);\n\n\tif (msc_update_partition_running) {\n\t\tfat_add_root_file(msc_update_disk_buffer, \"firmware.bin\", 0, msc_update_partition_size_in_sectors);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 33.9552977768305}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"offset 0x%08x is not aligned with the partition sector size 0x%08x\", offset, partition->erase_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tesp_err_t ret = ESP_OK;\n\tif (offset >= partition->size) {\n\t\tESP_LOGE(TAG, \"offset 0x%08x is out of partition size 0x%08x\", offset, partition->size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tif (offset + size > partition->size) {\n\t\tESP_LOGE(TAG, \"offset 0x%08x and size 0x%08x exceed partition size 0x%08x\", offset, size, partition->size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tif (offset + size > partition->address + partition->size) {\n\t\tESP_LOGE(TAG, \"offset 0x%08x and size 0x%08x exceed partition address 0x%08x and size 0x%08x\", offset, size, partition->address, partition->size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tif (offset + size > partition->address + partition->size) {\n\t\tESP_LOGE(TAG, \"offset 0x%08x and size 0x%08x exceed partition address 0x%08x and size 0x%08x\", offset, size, partition->address, partition->size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tif (offset + size > partition->address + partition->size) {\n\t\tESP_LOGE(TAG, \"offset 0x%08x and size 0x%08x exceed partition address 0x%08x and size 0x%08x\", offset, size, partition->address, partition->size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tif (offset + size > partition->address + partition->size) {\n\t\tESP_LOGE", "CodeBleu_score": 36.85122310995907}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % partition->erase_size) {\n\t\tESP_LOGW(TAG, \"The offset is not aligned with the flash sector size. The sector will be erased before writing new data.\");\n\t}\n\n\tif (esp_partition_erase_range(partition, offset, size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase the partition.\");\n\t\treturn ESP_ERR_FLASH_OP;\n\t}\n\n\tif (esp_partition_write(partition, offset, data, size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write to the partition.\");\n\t\treturn ESP_ERR_FLASH_OP;\n\t}\n\n\treturn ESP_OK;\n}", "CodeBleu_score": 42.34375743210872}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tif (offset % partition->erase_size == 0) {\n\t\terr = esp_partition_erase_range(partition, offset, size);\n\t\tif (err!= ESP_OK) {\n\t\t\tlog_e(\"Failed to erase sector at 0x%08x: %s\", offset, esp_err_to_name(err));\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tlog_e(\"Failed to write to 0x%08x: %s\", offset, esp_err_to_name(err));\n\t}\n\treturn err;\n}", "CodeBleu_score": 57.50552274958759}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = 0;\n\tfor (size_t i = 0; i < strlen(in) && len < maxlen; i += 2) {\n\t\tunsigned char c = hex_char_to_byte(in[i]);\n\t\tif (c == 255) continue;\n\t\tunsigned char c2 = hex_char_to_byte(in[i + 1]);\n\t\tif (c2 == 255) continue;\n\t\tout[len++] = (c << 4) | c2;\n\t}\n\treturn len;\n}", "CodeBleu_score": 41.8074600806545}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t out_idx = 0;\n\tfor (size_t i = 0; i < strlen(in); i++) {\n\t\tif (isxdigit(in[i])) {\n\t\t\tif (out_idx >= maxlen) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tout[out_idx] = hex_char_to_byte(in[i]);\n\t\t\tout_idx++;\n\t\t}\n\t}\n\treturn out_idx;\n}", "CodeBleu_score": 31.96620617412472}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t out_len = 0;\n\tsize_t in_len = strlen(in);\n\n\tfor (size_t i = 0; i < in_len; i++) {\n\t\tif (out_len < maxlen) {\n\t\t\tif (is_hex_char(in[i])) {\n\t\t\t\tout[out_len] = hex_char_to_byte(in[i]);\n\t\t\t\tout_len++;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn out_len;\n}", "CodeBleu_score": 33.40084392913282}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (xRingbuffer!= NULL && xSemaphore!= NULL) {\n\t\tif (xSemaphoreTake(xSemaphore, (TickType_t) 10) == pdTRUE) {\n\t\t\tuint32_t freeSize = xRingbufferGetCurFreeSize(xRingbuffer);\n\t\t\txSemaphoreGive(xSemaphore);\n\t\t\treturn freeSize;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 53.555626471744375}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (m_xRingbuffer == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(m_xRingbufferLock, (TickType_t) 10) == pdTRUE) {\n\t\tint size = xRingbufferGetCurFreeSize(m_xRingbuffer);\n\t\txSemaphoreGive(m_xRingbufferLock);\n\t\treturn size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 56.33518726419621}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif(xRingbuffer == NULL || xSemaphore == NULL) {\n\t\treturn 0;\n\t}\n\tif(xSemaphoreTake(xSemaphore, 1000) == pdTRUE) {\n\t\tuint32_t freeSize = xRingbufferGetCurFreeSize(xRingbuffer);\n\t\txSemaphoreGive(xSemaphore);\n\t\treturn freeSize;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 61.16453856726045}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\t_rxTimeout = onlyOnTimeout;\n\tif (function!= NULL) {\n\t\tuartSetRxFIFOFull(UART_RX_FIFO_FULL_THRESHOLD);\n\t\tif (_eventTask == NULL) {\n\t\t\t_eventTask = xTaskCreate(eventTask, \"SerialEvent\", SERIAL_EVENT_TASK_STACK_SIZE, this, SERIAL_EVENT_TASK_PRIORITY, NULL);\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 33.74871838310579}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\tif (_onReceiveCB!= NULL) {\n\t\tuartSetRxFIFOFull(_uart, UART_RX_FIFO_FULL_THRESHOLD);\n\t\tif (_eventTask == NULL) {\n\t\t\t_eventTask = xTaskCreate(eventTask, \"uart_event\", 128, this, 2, NULL);\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 39.421804732410614}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\tif (_onReceiveCB!= NULL) {\n\t\tif (_rxTimeout > 0) {\n\t\t\tuartSetRxFIFOFull(true);\n\t\t\tif (!_eventTask) {\n\t\t\t\t_eventTask = new EventTask(this);\n\t\t\t}\n\t\t} else {\n\t\t\tuartSetRxFIFOFull(false);\n\t\t\tif (_eventTask) {\n\t\t\t\tdelete _eventTask;\n\t\t\t\t_eventTask = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 46.92309131673654}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\n\tsize_t n = 0;\n\tfor (;;) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\treturn n;\n\t\t}\n\t\t*buffer++ = c;\n\t\tif (n++ >= length - 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*buffer = 0;\n\treturn n;\n}", "CodeBleu_score": 65.46969175264225}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t n = 0;\n\twhile (n < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\treturn n;\n\t\t}\n\t\t*buffer++ = c;\n\t\tif (c == terminator) {\n\t\t\treturn n + 1;\n\t\t}\n\t\tn++;\n\t}\n\treturn n;\n}", "CodeBleu_score": 55.36374652320835}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\n\tsize_t index = 0;\n\n\twhile (index < length - 1) {\n\t\tint b = timedRead();\n\t\tif (b < 0) {\n\t\t\treturn index;\n\t\t}\n\t\tbuffer[index] = b;\n\t\tif (buffer[index] == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 64.83798097082479}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\t// Log the pin, frequency, and duration.\n\tlog_d(\"tone: pin: %d, frequency: %d, duration: %lu\", pin, frequency, duration);\n\n\t// Check if the pin is available or already in use.\n\tif (is_pin_available(pin)) {\n\t\t// Initialize the tone.\n\t\ttone_init(pin, frequency);\n\n\t\t// Send a start command with the pin, frequency, and duration to a queue.\n\t\txQueueSend(tone_queue, &pin, 0);\n\t} else {\n\t\t// Log an error message instructing to stop the current tone on the pin first.\n\t\tlog_e(\"tone: pin %d is already in use\", pin);\n\t}\n}", "CodeBleu_score": 27.774931793390344}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"tone\", \"pin: %d, frequency: %d, duration: %lu\", pin, frequency, duration);\n\tif (pinAvailable(pin)) {\n\t\ttone_init(pin, frequency);\n\t\tif (xQueueSend(toneQueue, &pin, 0) == pdTRUE) {\n\t\t\tlog_d(\"tone\", \"pin %d started\", pin);\n\t\t} else {\n\t\t\tlog_e(\"tone\", \"pin %d failed to start\", pin);\n\t\t}\n\t} else {\n\t\tlog_e(\"tone\", \"pin %d is in use\", pin);\n\t}\n}", "CodeBleu_score": 37.85887336147573}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"tone: pin: %d, frequency: %d, duration: %lu\", pin, frequency, duration);\n\tif (isAvailable(pin)) {\n\t\ttone_init(pin, frequency, duration);\n\t\txQueueSend(tone_queue, &pin, 0);\n\t} else {\n\t\tlog_e(\"tone: pin: %d is not available\", pin);\n\t}\n}", "CodeBleu_score": 29.357469415229076}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usbStarted) {\n\t\twebUSBEnabled = enabled;\n\t\tif (enabled) {\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 36.795312222997076}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usbStarted) {\n\t\twebUSBEnabled = enabled;\n\t\tif (enabled) {\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\tusbVersion = 0x0210;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 53.65519056704201}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (enabled) {\n\t\tif (usbVersion < 0x0210) {\n\t\t\tusbVersion = 0x0210;\n\t\t}\n\t\twebUSBEnabled = true;\n\t} else {\n\t\twebUSBEnabled = false;\n\t}\n\treturn!usbStarted;\n}", "CodeBleu_score": 49.599036545647444}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t rx_buf[64];\n\tuint32_t rx_len;\n\tuint32_t dropped;\n\tuint32_t remaining;\n\tuint32_t dropped_total = 0;\n\n\t// Read data from the USB endpoint\n\trx_len = tud_cdc_n_read(0, rx_buf, sizeof(rx_buf));\n\tif (rx_len == 0) {\n\t\treturn;\n\t}\n\n\t// Loop through the data and post a receive event for each byte\n\tfor (uint32_t i = 0; i < rx_len; i++) {\n\t\t// Attempt to post the event\n\t\tif (xQueueSend(this->rx_queue, &rx_buf[i], 0)!= pdPASS) {\n\t\t\t// Queue is full\n\t\t\t// Calculate the number of bytes dropped\n\t\t\tdropped = (rx_len - i) - 1;\n\t\t\t// Calculate the number of bytes remaining\n\t\t\tremaining = rx_len - (dropped + i);\n\t\t\t// Log an error\n\t\t\tlog_e(\"USB CDC RX queue full, dropping %d bytes\", dropped);\n\t\t\t// Update the total number of bytes dropped\n\t\t\tdropped_total += dropped;\n\t\t\t// If there are any bytes remaining, post an event for them\n\t\t\tif (remaining > 0) {\n\t\t\t\t// Attempt to post the event\n\t\t\t\tif (xQueueSend(this->rx_queue, &rx_buf[i], 0)!= pdPASS) {\n\t\t\t\t\t// Queue is full\n\t\t\t\t\t// Log an error\n\t\t\t\t\tlog_e(\"USB CDC RX queue full, dropping %d bytes\", remaining);\n\t\t\t\t\t// Update the total number of bytes dropped\n\t\t\t\t\tdropped_total += remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Post an event with the number of bytes dropped\n\t\t\txQueueSend(this->rx_queue, &dropped_total, 0);\n\t\t\t// Reset the total number of bytes dropped\n\t\t\tdropped_total = 0;\n\t\t}\n\t}\n\n\t// Post an event with the length of the received data\n\txQueueSend(this->rx_queue, &rx_len, 0);\n}", "CodeBleu_score": 40.179189575060946}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t buf[64];\n\tuint8_t rx_len = 0;\n\tuint8_t dropped_bytes = 0;\n\tuint8_t i;\n\n\twhile (true) {\n\t\t// Read data from the USB CDC interface\n\t\trx_len = 0;\n\t\twhile (rx_len == 0) {\n\t\t\trx_len = tud_cdc_n_read(buf, sizeof(buf));\n\t\t\tif (rx_len == 0) {\n\t\t\t\t// If no data is read, wait for the next USB event\n\t\t\t\tif (xQueueReceive(usb_event_queue, &usb_event, portMAX_DELAY)!= pdPASS) {\n\t\t\t\t\t// If the USB event queue is empty, it is an error\n\t\t\t\t\tlog_e(\"USB event queue is empty\");\n\t\t\t\t\twhile (1)\n\t\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Attempt to post each byte to the receive queue\n\t\tfor (i = 0; i < rx_len; i++) {\n\t\t\tif (xQueueSend(usb_cdc_rx_queue, &buf[i], 0)!= pdPASS) {\n\t\t\t\t// If the queue is full, post an overflow event and log an error\n\t\t\t\tdropped_bytes += rx_len - i;\n\t\t\t\tlog_e(\"USB CDC receive queue is full\");\n\t\t\t\twhile (1)\n\t\t\t\t\t;\n\t\t\t}\n\t\t}\n\n\t\t// Post a receive event with the number of bytes received\n\t\tusb_cdc_event_post(USB_CDC_EVENT_RX, rx_len);\n\t}\n}", "CodeBleu_score": 33.982306471453605}, {"code": "void USBCDC::_onRX(){\n\t\t// Read data from the USB CDC interface\n\tuint8_t buffer[64];\n\tuint32_t len = arduino_usb_cdc_n_read(buffer, sizeof(buffer));\n\tif (len == 0) {\n\t\treturn;\n\t}\n\t// Post an overflow event if the queue is full\n\tif (xQueueIsQueueFullFromISR(rx_queue) == pdTRUE) {\n\t\tUSB_EVENT_DATA data;\n\t\tdata.overflow.length = len;\n\t\txQueueSendFromISR(event_queue, &data, NULL);\n\t\tlog_e(\"USB CDC RX queue overflow\");\n\t}\n\t// Post a receive event for each byte\n\tfor (uint32_t i = 0; i < len; i++) {\n\t\tUSB_EVENT_DATA data;\n\t\tdata.rx.length = 1;\n\t\tdata.rx.data[0] = buffer[i];\n\t\txQueueSendFromISR(event_queue, &data, NULL);\n\t}\n}", "CodeBleu_score": 33.77698421796547}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the name of the robot from the URL query parameters.\n\tname := req.URL.Query().Get(\"name\")\n\n\t// Check if a robot with the given name exists.\n\tif robot, ok := a.master.Robot(name); ok {\n\t\t// If the robot exists, gather its devices into a JSON format and write this JSON response to the HTTP response writer.\n\t\tdevices := robot.Devices()\n\t\tjson.NewEncoder(res).Encode(devices)\n\t} else {\n\t\t// If the robot does not exist, return a JSON response with an error message indicating that no robot was found with the specified name.\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with name '\" + name + \"'\"})\n\t}\n}", "CodeBleu_score": 30.075530390862838}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the name of the robot from the URL query parameters\n\tname := req.URL.Query().Get(\"name\")\n\n\t// Check if a robot with the given name exists\n\tif robot, ok := a.master.Robot(name); ok {\n\t\t// Gather the devices associated with the robot into a JSON format\n\t\tdevices := robot.Devices().Each(func(d gobot.Device) interface{} {\n\t\t\treturn map[string]interface{}{\n\t\t\t\t\"name\": d.Name(),\n\t\t\t\t\"type\": d.Type(),\n\t\t\t}\n\t\t})\n\n\t\t// Write the JSON response to the HTTP response writer\n\t\ta.writeJSON(res, devices)\n\t} else {\n\t\t// If the robot does not exist, return a JSON response with an error message\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"error\": fmt.Sprintf(\"No robot found with name '%s'\", name),\n\t\t})\n\t}\n}", "CodeBleu_score": 38.499143793838655}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tif req.Method!= \"GET\" {\n\t\ta.writeJSON(res, gobot.NewJSONError(\"Invalid request method\"))\n\t\treturn\n\t}\n\n\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\ta.writeJSON(res, gobot.NewJSONError(\"Invalid request, missing name\"))\n\t\treturn\n\t}\n\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, gobot.NewJSONError(\"Robot not found\"))\n\t\treturn\n\t}\n\n\tdevices := robot.Devices()\n\tjsonDevices := gobot.NewJSONDevice(devices)\n\ta.writeJSON(res, jsonDevices)\n}", "CodeBleu_score": 37.734884532048326}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/v1/robot/\")\n\n\t// Check if the robot exists.\n\trobot, ok := a.master.Robots[robotName]\n\tif!ok {\n\t\ta.writeJSON(res, map[string]string{\"error\": \"Robot not found\"})\n\t\treturn\n\t}\n\n\t// Convert the robot's connections to JSON format and write them to the HTTP response.\n\tconnections := make([]map[string]string, 0, len(robot.Connections()))\n\trobot.Connections().Each(func(key, value interface{}) {\n\t\tconnections = append(connections, map[string]string{\n\t\t\t\"name\": key.(string),\n\t\t\t\"type\": value.(string),\n\t\t})\n\t})\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 47.31613818174327}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\tname := req.URL.Query().Get(\"name\")\n\t// Check if the robot exists.\n\trobot, err := a.master.Robot(name)\n\tif err!= nil {\n\t\t// If the robot is not found, write an error message to the HTTP response.\n\t\ta.writeJSON(res, err)\n\t\treturn\n\t}\n\t// Iterate through the robot's connections and convert them to JSON format.\n\tconnections := make([]string, len(robot.Connections()))\n\ti := 0\n\trobot.Connections().Each(func(key interface{}, value interface{}) {\n\t\tconnections[i] = key.(string)\n\t\ti++\n\t})\n\t// Write the connections to the HTTP response.\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 41.17699381508958}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot, ok := a.master.Robots[robotName]\n\tif!ok {\n\t\ta.writeJSON(res, &struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{\n\t\t\tError: fmt.Sprintf(\"No robot with name %s was found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := make([]map[string]interface{}, len(robot.Connections))\n\ti := 0\n\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\tconnections[i] = connection.JSON()\n\t\ti++\n\t})\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 45.6347150385016}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\n\trobot, ok := a.master.Robot(robotName)\n\tif!ok {\n\t\ta.writeJSON(res, fmt.Sprintf(\"Robot %s does not exist\", robotName))\n\t\treturn\n\t}\n\n\tdevice, ok := robot.Device(deviceName)\n\tif!ok {\n\t\ta.writeJSON(res, fmt.Sprintf(\"Device %s does not exist\", deviceName))\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\":command\")\n\tif err := device.(gobot.Commander).Command(command); err!= nil {\n\t\ta.writeJSON(res, err.Error())\n\t}\n}", "CodeBleu_score": 50.32346311583184}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\tif!a.master.RobotExists(robot) {\n\t\ta.writeJSON(res, gobot.NewError(\"Robot does not exist\", nil))\n\t\treturn\n\t}\n\tif!a.master.Robot(robot).DeviceExists(device) {\n\t\ta.writeJSON(res, gobot.NewError(\"Device does not exist\", nil))\n\t\treturn\n\t}\n\terr := a.master.Robot(robot).Device(device).(gobot.Commander).Command(req.URL.Query().Get(\":command\"))\n\tif err!= nil {\n\t\ta.writeJSON(res, err)\n\t\treturn\n\t}\n\ta.writeJSON(res, gobot.NewSuccess(\"Command executed successfully\", nil))\n}", "CodeBleu_score": 51.344442494182154}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\tdevice, err := a.master.Robot(robotName).Device(deviceName)\n\tif err!= nil {\n\t\ta.writeJSON(res, err.Error())\n\t\treturn\n\t}\n\tcommand := req.URL.Query().Get(\":command\")\n\tif err := device.(gobot.Commander).Command(command); err!= nil {\n\t\ta.writeJSON(res, err.Error())\n\t}\n}", "CodeBleu_score": 53.09647267304134}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s)!= 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Set the user to the username we supplied\n\t\tr.SetBasicAuth(username, password)\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tw.Write([]byte(\"Welcome home!\"))\n\t}\n}", "CodeBleu_score": 49.24379796543836}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s)!= 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"Welcome home!\"))\n\t}\n}", "CodeBleu_score": 48.99722157223895}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s)!= 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Set up context with the authenticated username\n\t\tctx := context.WithValue(r.Context(), ContextKey(\"username\"), username)\n\t\tr = r.WithContext(ctx)\n\n\t\t// Proceed to the next handler in the chain\n\t\tnext(w, r)\n\t}\n}", "CodeBleu_score": 48.65694154390025}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection().AnalogRead == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog read not supported by connection\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.sensorCfg.lastRead = raw\n\ta.sensorCfg.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 48.28677142405905}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif a.Connection() == nil {\n\t\treturn -1, -1, ErrNoConnection\n\t}\n\tif!a.Connection().SupportsAnalogRead() {\n\t\treturn -1, -1, ErrNotSupported\n\t}\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\tscaled := float64(raw) / a.sensorCfg.scale\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 45.492665570961385}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif err := a.mutex.Lock(); err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tdefer a.mutex.Unlock()\n\tif!a.Connection().AnalogRead {\n\t\treturn 0, 0, errors.New(\"analog sensor does not support analog reading\")\n\t}\n\traw, err := reader.AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := a.scale(raw)\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 45.352772046242826}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tvar (\n\t\tname string\n\t\terr  error\n\t)\n\t// set the default name\n\tname = DefaultName\n\t// parse the optional parameters\n\tfor _, o := range opts {\n\t\tswitch value := o.(type) {\n\t\tcase string:\n\t\t\tname = value\n\t\tdefault:\n\t\t\terr = fmt.Errorf(\"invalid parameter type: %T\", o)\n\t\t}\n\t}\n\t// create the driver\n\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tName:               name,\n\t}\n\t// set the default range\n\td.SetRange(0, 1023)\n\t// return the driver\n\treturn d\n}", "CodeBleu_score": 42.05358324371808}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.Name = DefaultName\n\treturn &GroveSoundSensorDriver{AnalogSensorDriver: d}\n}", "CodeBleu_score": 33.713071311422574}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(DefaultName)\n\treturn d\n}", "CodeBleu_score": 21.597155795721935}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(10 * time.Millisecond)\n\tstatus, err := d.readByteData(CommandReg)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status&SoftReset == SoftReset {\n\t\treturn errors.New(\"Soft reset did not complete\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.344165093466586}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tstatus, err := d.readByteData(CommandReg)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif status&SoftReset!= 0 {\n\t\treturn fmt.Errorf(\"SoftReset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.81166047627591}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(time.Millisecond * 10)\n\tif (d.readByteData(CommandReg) & SoftReset)!= 0 {\n\t\treturn fmt.Errorf(\"softReset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 27.24595056310875}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check if the FIFO buffer is empty\n\tfifoSize, err := d.getFifoSize()\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif fifoSize < len(backData) {\n\t\treturn 0, fmt.Errorf(\"FIFO buffer is empty\")\n\t}\n\t// Read the FIFO buffer\n\terr = d.read(backData)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\t// Read the control register\n\treturn d.readControlRegister()\n}", "CodeBleu_score": 31.129717112255438}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// First get the number of bytes available in the FIFO\n\tavailable, err := d.readRegister(FIFOLevelReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// If the number of bytes available is greater than the length of the byte slice, return an error\n\tif available > uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"FIFO buffer overflow\")\n\t}\n\n\t// If the number of bytes available is equal to the length of the byte slice, read each byte from the FIFO into the byte slice\n\tif available == uint8(len(backData)) {\n\t\terr = d.readRegisterBytes(FIFODataReg, backData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Finally, read the control register to get the last bits received\n\tlastBits, err := d.readRegister(ControlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 45.30272255884946}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Get the number of bytes in the FIFO\n\tnumBytes, err := d.fifoSize()\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the number of bytes in the FIFO matches the expected length of the byte slice\n\tif len(backData)!= numBytes {\n\t\treturn 0, fmt.Errorf(\"FIFO size mismatch: expected %d bytes, got %d bytes\", len(backData), numBytes)\n\t}\n\n\t// Read each byte from the FIFO into the byte slice\n\tfor i := range backData {\n\t\tbackData[i], err = d.readByteData(fifoDataReg)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tcontrol, err := d.readByteData(controlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn control, nil\n}", "CodeBleu_score": 43.31278442393287}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.Debug {\n\t\tfmt.Println(\"piccHalt\")\n\t}\n\tvar err error\n\tvar command []byte\n\tcommand = append(command, PICC_CMD_HALT)\n\tcommand = append(command, 0)\n\tcommand = append(command, 0)\n\tcommand = append(command, d.calculateCRC(command)...)\n\terr = d.sendCommand(command)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.39714476851302}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.Debug {\n\t\tfmt.Println(\"piccHalt\")\n\t}\n\t// Build command buffer\n\tcmd := make([]byte, 4)\n\tcmd[0] = piccHalt\n\tcmd[1] = 0\n\tcmd[2] = 0\n\tcmd[3] = 0\n\t// Calculate CRC_A\n\td.calculateCRC(cmd)\n\t// Send the command.\n\t// The standard says:\n\t//\t\tIf two PICCs are not in the field at the same time, the device\n\t//\t\twill select the PICC (s) that is closest to the FIFO.\n\t//\t\tThis does not affect the Auto-Selected functionality.\n\terr := d.communicateWithPICC(cmd)\n\tif err!= nil {\n\t\treturn fmt.Errorf(\"piccHalt: %w\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 24.257943869987987}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.Debug {\n\t\tfmt.Printf(\"piccHalt()\n\")\n\t}\n\tcmd := []byte{PICC_CMD_HALT}\n\tcrc := d.calculateCRC(cmd)\n\tcmd = append(cmd, crc...)\n\terr := d.sendCommand(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 21.86967234297765}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare the read command\n\tcmd := append([]byte{piccRead}, block)\n\t// Calculate the CRC\n\tcrc, err := d.calculateCRC(cmd)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Append the CRC to the command\n\tcmd = append(cmd, crc...)\n\t// Send the command to the RFID card\n\t_, err = d.communicateWithPICC(cmd)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Read the data from the specified block\n\tdata, err := d.communicateWithPICC([]byte{piccRead})\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}", "CodeBleu_score": 43.248730920530036}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\td.command = make([]byte, 2)\n\td.command[0] = PICC_READ\n\td.command[1] = block\n\td.calculateCRC = d.calculateCRC(d.command)\n\td.command = append(d.command, d.calculateCRC...)\n\td.status, d.data = d.communicateWithPICC(d.command)\n\tif d.status!= STATUS_OK {\n\t\treturn nil, fmt.Errorf(\"Error: piccRead, status: %d\", d.status)\n\t}\n\treturn d.data, nil\n}", "CodeBleu_score": 25.86310220224819}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare the command buffer\n\tbuffer := make([]byte, 18)\n\tbuffer[0] = PICC_CMD_MF_READ\n\tbuffer[1] = block\n\t// Calculate CRC_A\n\td.calculateCRC(buffer)\n\t// Transmit the data\n\tstatus, _ := d.communicateWithPICC(buffer)\n\t// Check for success\n\tif status!= STATUS_OK {\n\t\treturn nil, errors.New(\"read error\")\n\t}\n\t// Get the 16 bytes of response\n\treturn d.readRegister(FIFODataReg, 16)\n}", "CodeBleu_score": 22.033340446338173}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Sanity check\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: answer buffer too small\")\n\t}\n\n\t// Reset the collision registers\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// Tell the PICC we want to transmit this request\n\tbuffer := []byte{reqMode}\n\n\t// Start the transmission\n\terr := d.transceive(buffer, answer)\n\n\t// Tell the PICC we want to transmit this request\n\tbuffer = []byte{reqMode}\n\n\t// Start the transmission\n\terr = d.transceive(buffer, answer)\n\n\t// Check for collisions\n\tif d.readRegister(CollReg) & 0x20 == 0x20 {\n\t\treturn fmt.Errorf(\"piccRequest: collision detected\")\n\t}\n\n\treturn err\n}", "CodeBleu_score": 49.5037670197075}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: answer buffer too small\")\n\t}\n\n\t// Clear all bits in the collision register\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// Tell the PICC we want to transmit the last byte of the request\n\tif reqMode == PICC_CMD_TRANSCEIVE {\n\t\td.setRegisterBitMask(BitFramingReg, 0x80)\n\t}\n\n\t// Make sure we have enough space in the buffer for the result\n\tif len(answer) < 1 {\n\t\treturn fmt.Errorf(\"piccRequest: answer buffer too small\")\n\t}\n\n\t// Tell the PICC to start the request\n\tstatus := d.communicateWithPICC(reqMode, []byte{reqMode})\n\tif status!= STATUS_OK {\n\t\treturn fmt.Errorf(\"piccRequest: status %02x\", status)\n\t}\n\n\t// Read the response\n\tstatus = d.communicateWithPICC(PICC_CMD_TRANSCEIVE, []byte{0x00})\n\tif status!= STATUS_OK {\n\t\treturn fmt.Errorf(\"piccRequest: status %02x\", status)\n\t}\n\n\t// Copy the response to the answer buffer\n\tanswer[0] = status\n\tn := len(answer) - 1\n\tif n > 0 {\n\t\tstatus = d.communicateWithPICC(PICC_CMD_TRANSCEIVE, []byte{0x00})\n\t\tif status!= STATUS_OK {\n\t\t\treturn fmt.Errorf(\"piccRequest: status %02x\", status)\n\t\t}\n\n\t\t// Copy the received data into the answer buffer\n\t\tfor i := 0; i < n; i++ {\n\t\t\tanswer[i+1] = d.readRegister(FIFODataReg)\n\t\t}\n\t}\n\n\t// Set the number of bytes returned\n\tanswer[0] = n\n\treturn nil\n}", "CodeBleu_score": 48.33179698706148}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Sanity check\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: Invalid answer buffer\")\n\t}\n\n\t// Reset the collision detection bit\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\t// Tell the PICC we want to transmit the request\n\t// Send the request type\n\terr := d.transceiveData(append([]byte{reqMode}, answer...))\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Get the answer and check the PICC's ACK\n\t_, err = d.communicateWithPICC(answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check for collisions\n\tif d.readRegister(CollReg)&0x20 == 0x20 {\n\t\treturn fmt.Errorf(\"piccRequest: Collisions\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 60.39693478583607}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.digitalWrite(d.stepPin, d.LOW)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.stepPin, d.HIGH)\n\tif d.direction == d.FORWARD {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 42.97440671693681}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else if d.direction == -1 {\n\t\td.stepNumber--\n\t}\n\n\tif err := d.digitalWrite(d.stepPin, d.stepPinState); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.getDelayPerStep())\n\n\tif err := d.digitalWrite(d.stepPin,!d.stepPinState); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 56.356462988786596}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif d.stepPin == 0 {\n\t\treturn errors.New(\"EasyDriver: stepPin is not set\")\n\t}\n\tif err := d.digitalWrite(d.stepPin, false); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\tif err := d.digitalWrite(d.stepPin, true); err!= nil {\n\t\treturn err\n\t}\n\tif d.direction == forward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 68.6444105500856}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name)\n\treturn nil\n}", "CodeBleu_score": 59.63169350838624}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name)\n\treturn nil\n}", "CodeBleu_score": 65.29541840667548}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\treturn nil\n}", "CodeBleu_score": 65.35723344835584}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Duration\n\treturn func(pin int, duration time.Duration, event string, channel uint32, value uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstartTimestamp = d.getDuration(time.Now())\n\t\t} else if event == \"falling\" {\n\t\t\td.channel <- d.getDuration(time.Now()) - startTimestamp\n\t\t\tstartTimestamp = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 45.29907750287114}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := uint32(0)\n\treturn func(pin int, duration time.Duration, eventType string, value uint32, timestamp uint32) {\n\t\tif eventType == \"rising\" {\n\t\t\tstartTimestamp = timestamp\n\t\t} else if eventType == \"falling\" {\n\t\t\td.pulseDurationChannel <- time.Duration(timestamp - startTimestamp) * time.Microsecond\n\t\t\tstartTimestamp = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 46.29333550619905}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp int64\n\treturn func(pin int, duration time.Duration, eventName string, eventTimestamp uint32, eventValue uint32) {\n\t\tif eventName == \"rising\" {\n\t\t\tstartTimestamp = eventTimestamp\n\t\t} else if eventName == \"falling\" {\n\t\t\td.distanceChannel <- d.calculateDistance(startTimestamp, eventTimestamp)\n\t\t}\n\t}\n}", "CodeBleu_score": 38.22528713638636}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\td.emitTrigger()\n\tselect {\n\tcase <-d.measureDone:\n\t\td.distance = float64(d.measureTime) * 0.034 / 2\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 40.31851293247488}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\td.trigger()\n\tselect {\n\tcase <-d.measureComplete:\n\t\td.distance = time.Duration(d.measureTime) * time.Microsecond\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"Timeout\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 42.72564985944872}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor\n\td.emitTrigger()\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\ttimeout := time.After(d.timeout)\n\tfor {\n\t\tselect {\n\t\tcase <-d.measureChan:\n\t\t\t// The measurement is complete, so return\n\t\t\treturn nil\n\t\tcase <-timeout:\n\t\t\t// The timeout occurred, so return an error\n\t\t\treturn fmt.Errorf(\"Timeout occurred while measuring distance\")\n\t\t}\n\t}\n}", "CodeBleu_score": 32.478332310366326}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if \"APP_AUTH_TOKEN\" in os.environ:\n        return os.environ[\"APP_AUTH_TOKEN\"]\n    state = app.get_state_item(self.local_state_key)\n    if state:\n        if time.time() < state[\"expires_at\"]:\n            return state[\"access_token\"]\n        else:\n            if \"refresh_token\" in state:\n                self.fetch_json_data(\n                    \"POST\",\n                    \"https://api.github.com/applications/\" + self.app_id + \"/token\",\n                    json={\"refresh_token\": state[\"refresh_token\"]},\n                )\n                return state[\"access_token\"]\n    raise AccountNotAuthorized()", "CodeBleu_score": 27.06017986309152}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.access_token and self.access_token_expiration_time > time.time():\n        return self.access_token\n    if self.get_state_item('access_token') and self.get_state_item('access_token_expiration_time') > time.time():\n        return self.get_state_item('access_token')\n    if self.refresh_token:\n        self.fetch_authentication_token_using_refresh_token()\n        return self.access_token\n    raise AccountNotAuthorized(\n        'No valid authentication token is available. Please authorize the application first.')\n", "CodeBleu_score": 26.886411057305164}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.getenv('AUTH_TOKEN')\n    if token:\n        return token\n    state = app.get_state_item('state')\n    if state:\n        if state.get('access_token'):\n            if state.get('expires_at') > time.time():\n                return state.get('access_token')\n            elif state.get('refresh_token'):\n                return self.fetch_authentication_token_with_refresh_token(state.get('refresh_token'))\n        elif state.get('refresh_token'):\n            return self.fetch_authentication_token_with_refresh_token(state.get('refresh_token'))\n    raise AccountNotAuthorized\n\n", "CodeBleu_score": 29.716836948760307}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\"/v1/logout\", {\"refresh_token\": refresh_token}, \"POST\")\n        return True\n    except AccountError:\n        return False\n\n", "CodeBleu_score": 54.635321638744905}, {"code": "def logout(self)\n\t\n    self.delete_local_session()\n    refresh_token = self.get_refresh_token()\n    if refresh_token:\n        try:\n            self.fetch_json_data(\n                \"POST\",\n                \"/v1/logout\",\n                json={\"refresh_token\": refresh_token},\n                raise_for_status=False,\n            )\n        except AccountError:\n            pass\n    return True\n\n", "CodeBleu_score": 52.836554013182656}, {"code": "def logout(self)\n\t\n    self.delete_local_session()\n    refresh_token = self.get_refresh_token()\n    if refresh_token is None:\n        return True\n    try:\n        response = self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            data={\"refresh_token\": refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 57.766698731555444}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for item in self.items:\n        if item.options.get('optional', False):\n            continue\n        if item.external:\n            result.append((item.name, item.version, item.url))\n        else:\n            result.append((item.name, item.version))\n    return result\n", "CodeBleu_score": 25.926335230013485}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for item in self.items:\n        if item.is_optional:\n            continue\n        if item.is_external:\n            result.append(item.name + \" (\" + item.source_url + \")\")\n        else:\n            result.append(item.name + \" (\" + item.version + \")\")\n    return result\n\n", "CodeBleu_score": 22.767785326191543}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    items = self.options.get(\"packages\")\n    for item in items:\n        if not item.get(\"optional\"):\n            package = self.get_package(item.get(\"name\"))\n            if package.get(\"external\"):\n                result.append(\"%s %s (%s)\" % (item.get(\"name\"), item.get(\"version\"), package.get(\"source\")))\n            else:\n                result.append(\"%s %s\" % (item.get(\"name\"), item.get(\"version\")))\n    return result\n\n", "CodeBleu_score": 27.630572998894298}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\nProjectEnvironment.from_env", "CodeBleu_score": 5.25733848092013}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    try:\n        platform = config.get('platform', env)\n    except KeyError:\n        raise UndefinedEnvPlatformError(env)\n    p = cls(platform, autoinstall)\n    p.set_env(env)\n    p.configure_project_packages(targets)\n    return p\n", "CodeBleu_score": 37.47796758167033}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    try:\n        platform_spec = config.get(env, 'platform')\n    except KeyError:\n        raise UndefinedEnvPlatformError(env)\n    else:\n        p = cls.new(platform_spec, autoinstall)\n        p.set_project_env(env)\n        p.configure_project_packages(targets)\n        return p\n\n", "CodeBleu_score": 39.1189427848962}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 73.56846672699541}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 73.56846672699541}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 73.56846672699541}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 54.77349151030913}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 64.9342703245996}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 64.9342703245996}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = scrollAddress;\n\ttft.fillRect(0, y, tft.width(), tft.height() - y, color);\n\ty += tft.fontHeight();\n\tif (y >= tft.height() - tft.fontHeight()) {\n\t\ty = 0;\n\t}\n\tif (tteBar) {\n\t\ty = tteBar - tft.fontHeight();\n\t}\n\tscrollAddress = y;\n\treturn y;\n}", "CodeBleu_score": 14.045375458591142}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint prev_y = scrollAddress;\n\tif (tteBar) {\n\t\tprev_y = tteBarHeight;\n\t}\n\ttft.fillRect(0, prev_y, tft.width(), tft.height() - prev_y, color);\n\tscrollAddress += tft.fontHeight();\n\tif (scrollAddress >= tft.height() - tft.fontHeight()) {\n\t\tscrollAddress = 0;\n\t}\n\treturn prev_y;\n}", "CodeBleu_score": 14.252198815626954}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint previous_y = scroll_address.y;\n\ttft.fillRect(scroll_address.x, scroll_address.y, scroll_address.width, scroll_address.height, color);\n\tscroll_address.y += tft.fontHeight(font);\n\tif (scroll_address.y > (tft.height() - tft.fontHeight(font) - tft.fontHeight(font) - 1)) {\n\t\tscroll_address.y = tft.fontHeight(font);\n\t}\n\tif (tteBar) {\n\t\tscroll_address.y = tft.fontHeight(font) + tft.fontHeight(font) + 1;\n\t}\n\tscroll_address.x = 0;\n\treturn previous_y;\n}", "CodeBleu_score": 18.19182456576083}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// Set access points\n\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\n\t// Set HTML content\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\n\t// Start portal\n\treturn this->startPortal();\n}", "CodeBleu_score": 58.61113836755071}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 61.87356687923673}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (this->setAP(access_points) && this->setHtml(ssids)) {\n\t\tthis->startPortal();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 57.60576986921807}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (!this->queue_enabled_flag) {\n\t\tthis->queue_enabled_flag = true;\n\t\tthis->flush_queue();\n\t\tthis->new_queue = \"\";\n\t\tthis->text = \"\";\n\t\tthis->text_in = \"\";\n\t}\n}", "CodeBleu_score": 21.297012379990875}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tthis->flush_queue();\n\t\tthis->text = \"\";\n\t\tthis->text_in = \"\";\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 23.2904067265652}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tif (this->queue.empty()) {\n\t\t\tthis->flush_queue();\n\t\t}\n\t\tif (this->text.empty()) {\n\t\t\tthis->text.assign(this->text_in.begin(), this->text_in.end());\n\t\t}\n\t} else {\n\t\tthis->queue_enabled_flag = true;\n\t\tthis->flush_queue();\n\t}\n}", "CodeBleu_score": 25.26673723437086}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue!= nullptr) {\n\t\tdelete this->queue;\n\t}\n\tthis->queue = new Queue<NmeaSentence>();\n\tthis->new_queue = true;\n}", "CodeBleu_score": 19.217466749361336}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue!= NULL) {\n\t\tdelete this->queue;\n\t}\n\tthis->queue = new Queue<char>();\n}", "CodeBleu_score": 13.054058832874786}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea!= nullptr) {\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = nullptr;\n\t}\n\tthis->queue_nmea = new Queue<char*>();\n}", "CodeBleu_score": 16.235218800685274}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tdisplay_obj.tft.startWrite();\n\tdisplay_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\tfor (int y = area->y1; y <= area->y2; y++) {\n\t\tfor (int x = area->x1; x <= area->x2; x++) {\n\t\t\tdisplay_obj.tft.writeColor(color_p->full);\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\tdisplay_obj.tft.endWrite();\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 65.11860897984992}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\t// Start a write transaction\n\tdisplay_obj.tft.startWrite();\n\t// Set the address window to the specified area\n\tdisplay_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\t// Iterate through each pixel in the area\n\tfor (int y = area->y1; y <= area->y2; y++) {\n\t\tfor (int x = area->x1; x <= area->x2; x++) {\n\t\t\t// Write the corresponding color from the provided color buffer\n\t\t\tdisplay_obj.tft.writeColor(color_p->full);\n\t\t\t// Increment the color pointer\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\t// End the write transaction\n\tdisplay_obj.tft.endWrite();\n\t// Notify that the display flush is complete\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 65.10240169301716}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush_ready(disp);\n\t//  lv_disp_flush", "CodeBleu_score": 3.2016194543729655}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\tSerial.println(\"Menu is NULL\");\n\t\treturn;\n\t}\n\tSerial.println();\n\tfor (int i = 0; i < layer; i++) {\n\t\tSerial.print(\"\\t\");\n\t}\n\tSerial.print(menu->name);\n\tSerial.println();\n\tfor (int i = 0; i < menu->list->size; i++) {\n\t\tMenu * node = (Menu *)menu->list->get(i);\n\t\tshowMenuList(node, layer + 1);\n\t}\n}", "CodeBleu_score": 56.379546771431386}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->list->size; i++) {\n\t\tSerial.print(menu->list->get(i)->name);\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"  \");\n\t\t}\n\t\tSerial.println();\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 64.55109348927638}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\tSerial.println(\"The menu is NULL\");\n\t\treturn;\n\t}\n\tif (menu->list == NULL) {\n\t\tSerial.println(\"The list of nodes is NULL\");\n\t\treturn;\n\t}\n\tif (menu->list->size == 0) {\n\t\tSerial.println(\"The list of nodes is empty\");\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; i < menu->list->size; i++) {\n\t\tSerial.print(menu->list->get(i));\n\t\tint j;\n\t\tfor (j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"  \");\n\t\t}\n\t\tSerial.println();\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 52.91944848607471}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint numSSIDs = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tchar ssid[6];\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid[j] = (char) random(0, 26) + 'a';\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = generateMAC();\n\t\tWiFi.softAP(ssid, \"\", channel, 1);\n\t\tSerial.print(\"Generated SSID: \");\n\t\tSerial.print(ssid);\n\t\tSerial.print(\" on channel \");\n\t\tSerial.print(channel);\n\t\tSerial.print(\" with MAC \");\n\t\tSerial.println(mac);\n\t\tnumSSIDs++;\n\t}\n\treturn numSSIDs;\n}", "CodeBleu_score": 39.382641178013934}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint ssidCount = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char) random(33, 126);\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tmac += (char) random(48, 58);\n\t\t\tif (j == 4) {\n\t\t\t\tmac += ':';\n\t\t\t} else {\n\t\t\t\tmac += '-';\n\t\t\t}\n\t\t}\n\t\tmac += (char) random(48, 58);\n\t\tmac += (char) random(48, 58);\n\t\tmac += (char) random(48, 58);\n\t\tmac += (char) random(48, 58);\n\t\tmac += (char) random(48, 58);\n\t\tSerial.println(\"SSID: \" + ssid + \" Channel: \" + channel + \" MAC: \" + mac);\n\t\tssids->add(new WiFiSSID(ssid, channel, mac));\n\t\tssidCount++;\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 44.80519131814216}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint ssidCount = 0;\n\twhile (ssidCount < count) {\n\t\tString ssid = \"\";\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tssid += (char)random(97, 123);\n\t\t}\n\t\tint channel = random(1, 15);\n\t\tString mac = \"\";\n\t\tfor (int i = 0; i < 17; i++) {\n\t\t\tif (i == 16) {\n\t\t\t\tmac += (char)random(48, 58);\n\t\t\t} else {\n\t\t\t\tmac += (char)random(48, 58);\n\t\t\t\tmac += \":\";\n\t\t\t}\n\t\t}\n\t\tSerial.print(\"SSID: \");\n\t\tSerial.println(ssid);\n\t\tSerial.print(\"Channel: \");\n\t\tSerial.println(channel);\n\t\tSerial.print(\"MAC: \");\n\t\tSerial.println(mac);\n\t\tSerial.println();\n\t\tssids->add(ssid, channel, mac);\n\t\tssidCount++;\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 43.47215396582443}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = pubsub_v1.Topic(name=topic_path)\n    topic = publisher.create_topic(request={\"name\": topic_path, \"topic\": topic})\n    print(f\"Topic {topic.name} created.\")\n", "CodeBleu_score": 47.85826721189811}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = pubsub_v1.Topic(name=topic_path)\n    response = publisher.create_topic(request={\"name\": topic_path, \"topic\": topic})\n    print(\"Topic created: {}\".format(response.name))\n", "CodeBleu_score": 51.991904140221315}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher_client = pubsub_v1.PublisherClient()\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n    topic = publisher_client.create_topic(name=topic_path)\n    print(f\"Topic created: {topic}\")\n", "CodeBleu_score": 36.34151801715455}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.utcnow(),\n        'exp': datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 47.710960380415976}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print('Creating JWT using {} from private key file {}'.format(\n        algorithm, private_key_file))\n    return jwt.encode(token, private_key, algorithm=algorithm)", "CodeBleu_score": 78.88837816894339}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received message on topic '{}': {}\".format(message.topic, message.payload))\n    print(\"QoS: {}\".format(message.qos))\n    if message.payload.decode() == \"on\":\n        preview_capture()\n        upload_file()\n        publish_event()\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 20.522028302612235}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    global preview_capture\n    global preview_file\n    global preview_url\n    global preview_bucket\n    global preview_topic\n    global preview_qos\n    global preview_client\n    global preview_event\n    global preview_event_topic\n    global preview_event_qos\n    global preview_event_payload\n    global preview_event_payload_format\n    global preview_event_payload_decode\n    global preview_event_payload_format_print\n    global preview_event_payload_format_format\n    global preview_event_payload_format_format_print\n    global preview_event_payload_format_format_format\n    global preview_event_payload_format_format_format_print\n    global preview_event_payload_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_format_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_format_format_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_format_format_format_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_format_format_format_format_format_format_format_format_format_print\n    global preview_event_payload_format_format_format_format_format_format_format_format_format_format_format_format_format_", "CodeBleu_score": 5.307103173793529}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Message received:\")\n    print(\"  Topic: \" + message.topic)\n    print(\"  QoS: \" + str(message.qos))\n    print(\"  Payload: \" + str(message.payload.decode(\"utf-8\")))\n    print(\"  Message ID: \" + str(message.mid))\n    if message.payload.decode(\"utf-8\") == \"on\":\n        preview_capture()\n        upload_file()\n        publish_url()\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 25.447803169230937}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT device connection')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP project id')\n    parser.add_argument(\n        '--registry_id',\n        required=True,\n        help='Cloud IoT Core registry id')\n    parser.add_argument(\n        '--device_id',\n        required=True,\n        help='Cloud IoT Core device id')\n    parser.add_argument(\n        '--private_key_file',\n        required=True,\n        help='Path to private key file')\n    parser.add_argument(\n        '--algorithm',\n        choices=['RS256', 'ES256'],\n        default='ES256',\n        help='Which encryption algorithm to use to generate the JWT (\\b'\n             'default: ES256)')\n    parser.add_argument(\n        '--cloud_region',\n        default='us-central1',\n        help='The Cloud IoT Core region')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        default=8883,\n        help='MQTT bridge port')\n    parser.add_argument(\n        '--mqtt_topic',\n        default='/devices/{device}/events',\n        help='MQTT topic to publish data to')\n    parser.add_argument(\n        '--mqtt_bridge_use_tls',\n        action='store_true',\n        help='Use TLS when connecting to the MQTT bridge')\n    parser.add_argument(\n        '--mqtt_bridge_use_ssl',\n        action='store_true',\n        help='Use SSL when connecting to the MQTT bridge')\n    parser.add_argument(\n        '--mqtt_bridge_use_websocket',\n        action='store_true',\n        help='Use websockets when connecting to the MQTT bridge')\n    parser.add_argument(\n        '--mqtt_bridge_use_http',\n        action='store_true',\n        help='Use HTTP when connecting to the MQTT bridge')\n    parser.add_argument(\n        '--mqtt_bridge_use", "CodeBleu_score": 35.885222817403125}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=\"A Google Cloud IoT MQTT device connection\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"Google Cloud project ID\")\n    parser.add_argument(\n        \"--subscription_name\",\n        help=\"Google Cloud Pub/Sub subscription name\")\n    return parser.parse_args()\n\n", "CodeBleu_score": 48.315700574834494}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Project id of the project where the device is located.',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument(\n        '--subscription_name',\n        help='Name of the MQTT subscription to which the device is connected.',\n        default='projects/{project_id}/subscriptions/cloudiot-mqtt-test')\n    parser.add_argument(\n        '--registry_id',\n        help='The id of the device registry.',\n        default='test-registry')\n    parser.add_argument(\n        '--device_id',\n        help='The id of the device.',\n        default='test-device')\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.',\n        default='resources/rsa_private.pem')\n    parser.add_argument(\n        '--algorithm',\n        help='Algorithm used to generate the JWT.',\n        default='RS256')\n    parser.add_argument(\n        '--ca_certs',\n        help='Path to CA root certificate file.',\n        default='resources/roots.pem')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        help='Hostname of the MQTT bridge.',\n        default='mqtt.googleapis.com')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        help='Port of the MQTT bridge.',\n        default=8883)\n    parser.add_argument(\n        '--mqtt_bridge_use_tls',\n        help='Use TLS when connecting to the MQTT bridge.',\n        default=True)\n    parser.add_argument(\n        '--mqtt_bridge_use_websockets',\n        help='Use websockets when connecting to the MQTT bridge.',\n        default=False)\n    parser.add_argument(\n        '--mqtt_bridge_username',\n        help='Username to connect to the MQTT bridge with.',\n        default='unused')\n    parser.add_argument(\n        '--mqtt_bridge_password',\n        help='Password to connect to the MQTT bridge with.',\n        default='unused')\n    return parser.parse_args()\n\n", "CodeBleu_score": 36.3985526899231}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    discovery_url = \"https://cloudiot.googleapis.com/v1/projects/{}/locations/{}/registries/{}\".format(credentials.project_id, \"us-central1\", \"iot-registry\")\n    client = discovery.build(\"cloudiot\", \"v1\", credentials=credentials.with_scopes(scopes), discoveryServiceUrl=discovery_url)\n    return client\n\n", "CodeBleu_score": 34.368351216747406}, {"code": "def get_client(service_account_json)\n\t\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    discovery_url = 'https://cloudiot.googleapis.com/v1/projects/{project_id}/locations/{location}/registries/{registry_id}'.format(project_id=credentials.project_id, location='us-central1', registry_id='my-registry')\n    return discovery.build('cloudiot', 'v1', credentials=credentials.with_scopes(scopes), discoveryServiceUrl=discovery_url)\n", "CodeBleu_score": 26.574760663671576}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/v1/projects/{}/locations/{}/registries/{}/devices:list\".format(\n        project_id, location, registry_id\n    )\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n    credentials = credentials.with_scopes(scopes)\n    client = discovery.build(\"cloudiot\", version, credentials=credentials, discoveryServiceUrl=discovery_url)\n    return client\n\n", "CodeBleu_score": 46.28621573445347}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = HASH_METHODS[hash_method]\n    signature = priv_key.blinded_encrypt(hash_value + hash_method_asn1)\n    return signature\n\n", "CodeBleu_score": 6.256602169524812}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    # Retrieve the ASN1 code for the hash method\n    hash_method_asn1 = hash_method.asn1\n    # Raise an error if the hash method is invalid\n    if hash_method_asn1 is None:\n        raise ValueError(\"Invalid hash method\")\n    # Concatenate the ASN1 code with the hash value\n    hash_value_with_asn1 = hash_method_asn1 + hash_value\n    # Pad the result for signing\n    padded_hash = _pad_for_signing(hash_value_with_asn1)\n    # Encrypt the padded hash using the private key\n    signature = priv_key.blinded_encrypt(padded_hash)\n    return signature\n\n", "CodeBleu_score": 28.68978053128789}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method not in HASH_METHODS:\n        raise ValueError(f\"Invalid hash method: {hash_method}\")\n    hash_method_asn1 = HASH_METHODS[hash_method]\n    hash_value_asn1 = _pad_for_signing(hash_value)\n    hash_value_asn1 += hash_method_asn1\n    return priv_key.blinded_encrypt(hash_value_asn1)\n\n", "CodeBleu_score": 26.289427245940956}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n    # Decrypt the signature to obtain the clear signature\n    clear_signature = core.decrypt_int(signature_int, pub_key)\n    # Determine the hash method used\n    hash_method = _find_method_hash(clear_signature)\n    # Compute the hash of the message\n    hash_message = compute_hash(message, hash_method)\n    # Reconstruct the expected padded hash\n    padded_hash = _pad_for_signing(hash_message, hash_method)\n    # Check if the expected padded hash matches the clear signature\n    if padded_hash!= clear_signature:\n        raise VerificationError(\"The signature is not valid.\")\n    return hash_method\n\n", "CodeBleu_score": 17.59151003484561}, {"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        signature = transform.bytes2int(signature)\n    except:\n        raise VerificationError('Invalid signature')\n\n    try:\n        pub_key = transform.bytes2int(pub_key)\n    except:\n        raise VerificationError('Invalid public key')\n\n    try:\n        pub_key = transform.int2bytes(pub_key)\n    except:\n        raise VerificationError('Invalid public key')\n\n    try:\n        hash_method = _find_method_hash(pub_key)\n    except:\n        raise VerificationError('Invalid public key')\n\n    try:\n        hash_method = getattr(hashlib, hash_method)\n    except:\n        raise VerificationError('Invalid public key')\n\n    try:\n        message = transform.bytes2int(message)\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = transform.int2bytes(message)\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = _pad_for_signing(message, hash_method)\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = hash_method(message).digest()\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = transform.bytes2int(message)\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = transform.int2bytes(message)\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = _pad_for_signing(message, hash_method)\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = hash_method(message).digest()\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = transform.bytes2int(message)\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = transform.int2bytes(message)\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = _pad_for_signing(message, hash_method)\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = hash_method(message).digest()\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = transform.bytes2int(message)\n    except:\n        raise VerificationError('Invalid message')\n\n    try:\n        message = transform.int2bytes(message)\n    except:\n        raise VerificationError('Invalid message')\n\n    try", "CodeBleu_score": 31.421154797332544}, {"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        signature = transform.bytes2int(signature)\n        clear_signature = core.decrypt_int(signature, pub_key)\n        hash_method = _find_method_hash(clear_signature)\n        if hash_method == 'SHA256':\n            padded_hash = _pad_for_signing(compute_hash(message, 'SHA256'), 32)\n        elif hash_method == 'SHA512':\n            padded_hash = _pad_for_signing(compute_hash(message, 'SHA512'), 64)\n        else:\n            raise VerificationError('Invalid hash method')\n        if padded_hash!= clear_signature:\n            raise VerificationError('Signature does not match message')\n        return hash_method\n    except Exception:\n        raise VerificationError('Signature does not match message')\n\n", "CodeBleu_score": 38.12938165487261}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\t// get current time\n\ttime_t currentTime = time(NULL);\n\t// check if the time is valid\n\tif (currentTime!= -1) {\n\t\t// update the JWT\n\t\tupdateJWT(currentTime);\n\t\t// connect to the MQTT client\n\t\tMQTT_CLIENT_connect();\n\t\t// set the flag to send an MQTT SUBSCRIBE packet after the connection is established\n\t\tsendMQTTSubscribe = true;\n\t\t// print a debug message\n\t\tdebug_print(\"MQTT connection established.\n\");\n\t}\n\telse {\n\t\t// print a debug message\n\t\tdebug_print(\"MQTT connection failed.\n\");\n\t}\n}", "CodeBleu_score": 33.28091974758516}, {"code": "static void connectMQTT(){\n\t\tuint32_t currentTime;\n\tcurrentTime = time(NULL);\n\tif (currentTime!= 0) {\n\t\tupdateJWT(currentTime);\n\t\tMQTT_CLIENT_connect();\n\t\tMQTT_CLIENT_subscribe(MQTT_TOPIC);\n\t\tdebug_print(\"MQTT connection established\n\");\n\t} else {\n\t\tdebug_print(\"Failed to retrieve current time\n\");\n\t}\n}", "CodeBleu_score": 29.315005029941766}, {"code": "static void connectMQTT(){\n\t\t// Get the current time\n\ttime_t current_time = time(NULL);\n\tif (current_time!= ((time_t)-1)) {\n\t\t// Update the JWT using the current UNIX time format\n\t\tupdateJWT(current_time);\n\n\t\t// Connect to the MQTT client\n\t\tMQTT_CLIENT_connect();\n\n\t\t// Set a flag to send an MQTT SUBSCRIBE packet after the connection is established\n\t\tMQTT_SUBSCRIBE_flag = 1;\n\n\t\t// Print a debug message indicating the MQTT connection attempt\n\t\tdebug_print(DEBUG_PRINT_MQTT_CONNECTION_ATTEMPT);\n\t}\n}", "CodeBleu_score": 21.608672808286926}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tresult = result * 10 + *str - '0';\n\t\tstr++;\n\t}\n\t*num = result;\n\treturn str;\n}", "CodeBleu_score": 28.160690314543167}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] >= '0' && str[i] <= '9') {\n\t\t\tvalue = value * 10 + (str[i] - '0');\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 25.431881086504415}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t tmp = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (!isdigit(str[i])) {\n\t\t\treturn str;\n\t\t}\n\t\ttmp = tmp * 10 + (str[i] - '0');\n\t}\n\n\t*num = tmp;\n\treturn str + width;\n}", "CodeBleu_score": 25.744272005774306}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint result = ATCACERT_E_SUCCESS;\n\n\tif (build_state == NULL) {\n\t\tresult = ATCACERT_E_BAD_PARAMS;\n\t} else {\n\t\tif (build_state->cert_def == NULL) {\n\t\t\tresult = ATCACERT_E_BAD_PARAMS;\n\t\t} else {\n\t\t\tresult = atcacert_build_cert_finish(build_state);\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 28.300967723669984}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint result = 0;\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint l = 0;\n\tint m = 0;\n\tint n = 0;\n\tint o = 0;\n\tint p = 0;\n\tint q = 0;\n\tint r = 0;\n\tint s = 0;\n\tint t = 0;\n\tint u = 0;\n\tint v = 0;\n\tint w = 0;\n\tint x = 0;\n\tint y = 0;\n\tint z = 0;\n\tint aa = 0;\n\tint bb = 0;\n\tint cc = 0;\n\tint dd = 0;\n\tint ee = 0;\n\tint ff = 0;\n\tint gg = 0;\n\tint hh = 0;\n\tint ii = 0;\n\tint jj = 0;\n\tint kk = 0;\n\tint ll = 0;\n\tint mm = 0;\n\tint nn = 0;\n\tint oo = 0;\n\tint pp = 0;\n\tint qq = 0;\n\tint rr = 0;\n\tint ss = 0;\n\tint tt = 0;\n\tint uu = 0;\n\tint vv = 0;\n\tint ww = 0;\n\tint xx = 0;\n\tint yy = 0;\n\tint zz = 0;\n\tint aaa = 0;\n\tint bbb = 0;\n\tint ccc = 0;\n\tint ddd = 0;\n\tint eee = 0;\n\tint fff = 0;\n\tint ggg = 0;\n\tint hhh = 0;\n\tint iii = 0;\n\tint jjj = 0;\n\tint kkk = 0;\n\tint lll = 0;\n\tint mmm = 0;\n\tint nnn = 0;\n\tint ooo = 0;\n\tint ppp = 0;\n\tint qqq = ", "CodeBleu_score": 5.838020936020596}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint result = 0;\n\tuint8_t* der_cert_data = NULL;\n\tuint8_t* der_cert_data_ptr = NULL;\n\tuint8_t* der_cert_data_end = NULL;\n\tuint8_t* der_cert_data_start = NULL;\n\tuint8_t* der_cert_data_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_end_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_end_end_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_end_end_end_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_end_end_end_end_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_end_end_end_end_end_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_end_end_end_end_end_end_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_end_end_end_end_end_end_end_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_end_end_end_end_end_end_end_end_end_end_end_ptr = NULL;\n\tuint8_t* der_cert_data_start_end_", "CodeBleu_score": 8.793432911304288}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tuint8_t tbs_digest[ATCA_SHA_DIGEST_SIZE];\n\tuint8_t signature[ATCA_SIG_SIZE];\n\tuint8_t tbs_digest_from_signature[ATCA_SHA_DIGEST_SIZE];\n\tint result;\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (cert_size < cert_def->cert_template.size) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t/* get the TBS digest */\n\tresult = atcacert_get_tbs_digest(cert_def, cert, tbs_digest);\n\tif (result!= ATCA_SUCCESS) {\n\t\treturn result;\n\t}\n\n\t/* get the signature */\n\tresult = atcacert_get_signature(cert_def, cert, signature);\n\tif (result!= ATCA_SUCCESS) {\n\t\treturn result;\n\t}\n\n\t/* verify the signature */\n\tresult = atcab_verify_extern(ca_public_key, tbs_digest, signature, tbs_digest_from_signature);\n\tif (result!= ATCA_SUCCESS) {\n\t\treturn result;\n\t}\n\n\t/* verify the TBS digest */\n\tif (memcmp(tbs_digest, tbs_digest_from_signature, ATCA_SHA_DIGEST_SIZE)!= 0) {\n\t\treturn ATCA_VERIFY_FAILED;\n\t}\n\n\treturn ATCA_SUCCESS;\n}", "CodeBleu_score": 60.36806254604632}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t#if defined(ATCA_HW_I2C) || defined(ATCA_HW_SPI)\n    int ret;\n    uint8_t tbs_digest[ATCA_SHA_DIGEST_SIZE];\n    uint8_t signature[ATCA_SIG_SIZE];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    if (cert_size < cert_def->cert_template.cert_size) {\n        return ATCA_BAD_PARAM;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret!= ATCA_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret!= ATCA_SUCCESS) {\n        return ret;\n    }\n\n    return atcab_verify_extern(tbs_digest, signature, ca_public_key);\n#else\n    return ATCA_UNIMPLEMENTED;\n#endif\n}", "CodeBleu_score": 68.97179471111221}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\n\t// Check for null pointers\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\t// Verify the certificate\n\tif ((ret = atcacert_verify_cert_hw_inner(cert_def, cert, cert_size, ca_public_key))!= ATCACERT_E_VERIFY_FAILED) {\n\t\treturn ret;\n\t}\n\n\t// Verify the certificate signature\n\tif ((ret = atcacert_verify_cert_hw_signature(cert_def, cert, cert_size, ca_public_key))!= ATCACERT_E_VERIFY_FAILED) {\n\t\treturn ret;\n\t}\n\n\treturn ATCACERT_E_VERIFY_FAILED;\n}", "CodeBleu_score": 51.17069672574155}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile *list = timer->list;\n\ttimerStruct_t * volatile *prev = timer->prev;\n\ttimerStruct_t * volatile *next = timer->next;\n\n\t*prev = *next;\n\t*next = *prev;\n\t*list = *next;\n\ttimer->list = NULL;\n\ttimer->prev = NULL;\n\ttimer->next = NULL;\n}", "CodeBleu_score": 19.184307894012512}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile *p = list;\n\ttimerStruct_t * volatile *q = NULL;\n\ttimerStruct_t * volatile *r = NULL;\n\ttimerStruct_t * volatile *s = NULL;\n\ttimerStruct_t * volatile *t = NULL;\n\ttimerStruct_t * volatile *u = NULL;\n\ttimerStruct_t * volatile *v = NULL;\n\ttimerStruct_t * volatile *w = NULL;\n\ttimerStruct_t * volatile *x = NULL;\n\ttimerStruct_t * volatile *y = NULL;\n\ttimerStruct_t * volatile *z = NULL;\n\ttimerStruct_t * volatile *a = NULL;\n\ttimerStruct_t * volatile *b = NULL;\n\ttimerStruct_t * volatile *c = NULL;\n\ttimerStruct_t * volatile *d = NULL;\n\ttimerStruct_t * volatile *e = NULL;\n\ttimerStruct_t * volatile *f = NULL;\n\ttimerStruct_t * volatile *g = NULL;\n\ttimerStruct_t * volatile *h = NULL;\n\ttimerStruct_t * volatile *i = NULL;\n\ttimerStruct_t * volatile *j = NULL;\n\ttimerStruct_t * volatile *k = NULL;\n\ttimerStruct_t * volatile *l = NULL;\n\ttimerStruct_t * volatile *m = NULL;\n\ttimerStruct_t * volatile *n = NULL;\n\ttimerStruct_t * volatile *o = NULL;\n\ttimerStruct_t * volatile *p_ = NULL;\n\ttimerStruct_t * volatile *q_ = NULL;\n\ttimerStruct_t * volatile *r_ = NULL;\n\ttimerStruct_t * volatile *s_ = NULL;\n\ttimerStruct_t * volatile *t_ = NULL;\n\ttimerStruct_t * volatile *u_ = NULL;\n\ttimerStruct_t * volatile *v_ = NULL;\n\ttimerStruct_t * volatile *w_ = NULL;\n\ttimerStruct_t * volatile *x_ = NULL;\n\ttimerStruct_t * volatile *y_ = NULL;\n\ttimerStruct_t * volatile *z_ = NULL;\n\ttimerStruct_t * volatile *a_ = NULL;\n\ttimerStruct_t *", "CodeBleu_score": 8.207803194910616}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tif(timer->next!= NULL)\n\t\ttimer->next->prev = timer->prev;\n\tif(timer->prev!= NULL)\n\t\ttimer->prev->next = timer->next;\n\tif(timer == *list)\n\t\t*list = timer->next;\n\ttimer->next = NULL;\n\ttimer->prev = NULL;\n\treturn true;\n}", "CodeBleu_score": 17.140218882333013}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tint result;\n\tBSD_SocketInfo socketInfo;\n\tBSD_SocketInfo *socketInfoPtr;\n\tBSD_SocketInfo *socketInfoPtr2;\n\tBSD_SocketInfo *socketInfoPtr3;\n\tBSD_SocketInfo *socketInfoPtr4;\n\tBSD_SocketInfo *socketInfoPtr5;\n\tBSD_SocketInfo *socketInfoPtr6;\n\tBSD_SocketInfo *socketInfoPtr7;\n\tBSD_SocketInfo *socketInfoPtr8;\n\tBSD_SocketInfo *socketInfoPtr9;\n\tBSD_SocketInfo *socketInfoPtr10;\n\tBSD_SocketInfo *socketInfoPtr11;\n\tBSD_SocketInfo *socketInfoPtr12;\n\tBSD_SocketInfo *socketInfoPtr13;\n\tBSD_SocketInfo *socketInfoPtr14;\n\tBSD_SocketInfo *socketInfoPtr15;\n\tBSD_SocketInfo *socketInfoPtr16;\n\tBSD_SocketInfo *socketInfoPtr17;\n\tBSD_SocketInfo *socketInfoPtr18;\n\tBSD_SocketInfo *socketInfoPtr19;\n\tBSD_SocketInfo *socketInfoPtr20;\n\tBSD_SocketInfo *socketInfoPtr21;\n\tBSD_SocketInfo *socketInfoPtr22;\n\tBSD_SocketInfo *socketInfoPtr23;\n\tBSD_SocketInfo *socketInfoPtr24;\n\tBSD_SocketInfo *socketInfoPtr25;\n\tBSD_SocketInfo *socketInfoPtr26;\n\tBSD_SocketInfo *socketInfoPtr27;\n\tBSD_SocketInfo *socketInfoPtr28;\n\tBSD_SocketInfo *socketInfoPtr29;\n\tBSD_SocketInfo *socketInfoPtr30;\n\tBSD_SocketInfo *socketInfoPtr31;\n\tBSD_SocketInfo *socketInfoPtr32;\n\tBSD_SocketInfo *socketInfoPtr33;\n\tBSD_SocketInfo *socketInfoPtr34;\n\tBSD_SocketInfo *socketInfoPtr35;\n\tBSD_SocketInfo *socketInfoPtr36;\n\tBSD_SocketInfo *socketInfoPtr37;\n\tBSD_SocketInfo *socketInfoPtr38;\n\tBSD_SocketInfo *socketInfoPtr39;\n\tBSD_SocketInfo *socketInfoPtr40;\n\tBSD_SocketInfo *socketInfoPtr41;\n\tBSD_SocketInfo *socketInfoPtr42;\n\tBSD_Socket", "CodeBleu_score": 3.8360624800287173}, {"code": "int BSD_close(int socket){\n\t\tint status;\n\tstruct SocketInfo socketInfo;\n\tstatus = getSocketInfo(socket, &socketInfo);\n\tif (status == BSD_SUCCESS) {\n\t\tsocketInfo.state = NOT_A_SOCKET;\n\t\tstatus = close(socket);\n\t\tif (status == -1) {\n\t\t\tbsd_setErrNo(socketInfo.errNo);\n\t\t}\n\t}\n\treturn status;\n}", "CodeBleu_score": 27.201662538507488}, {"code": "int BSD_close(int socket){\n\t\tif (socket < 0) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tif (socket > MAX_SOCKETS) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tif (socketInfo[socket].state == NOT_A_SOCKET) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tif (socketInfo[socket].state == CLOSED) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tif (close(socket) == -1) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tsocketInfo[socket].state = CLOSED;\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 41.44830610820769}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint result = listen(socket, backlog);\n\tif (result == -1) {\n\t\tBSD_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 19.339564197728908}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tif (listen(socket, backlog) == -1) {\n\t\tBSD_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 21.914519527514052}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint result = listen(socket, backlog);\n\tif (result == -1) {\n\t\tBSD_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 19.339564197728908}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret;\n\tint err;\n\tint len;\n\tint err_code;\n\tint err_code_accept;\n\tstruct bsd_sockaddr_storage addr_storage;\n\tstruct bsd_sockaddr_in * addr_in;\n\tstruct bsd_sockaddr_in6 * addr_in6;\n\tstruct bsd_sockaddr_un * addr_un;\n\tstruct bsd_sockaddr_un * addr_un_storage;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp_tmp_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp_tmp_tmp_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp_tmp_tmp_tmp_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tstruct bsd_sockaddr_un * addr_un_storage_ptr_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n", "CodeBleu_score": 10.05222806079422}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint err;\n\tint ret;\n\tint len;\n\tstruct bsd_sockaddr_storage addr_storage;\n\tstruct bsd_sockaddr_in * addr_in;\n\tstruct bsd_sockaddr_in6 * addr_in6;\n\tstruct bsd_sockaddr_un * addr_un;\n\tstruct bsd_sockaddr_un * addr_un_storage;\n\tstruct bsd_sockaddr_un * addr_un_storage_copy;\n\tstruct bsd_sockaddr_un * addr_un_copy;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage_copy;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage_copy_storage;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage_copy_storage_copy;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage_copy_storage_copy_storage;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage_copy_storage_copy_storage_copy;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage_copy_storage_copy_storage_copy_storage;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage_copy_storage_copy_storage_copy_storage_copy;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage_copy_storage_copy_storage_copy_storage_copy_storage;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage_copy_storage_copy_storage_copy_storage_copy_storage_copy;\n\tstruct bsd_sockaddr_un * addr_un_copy_storage_copy_storage_copy", "CodeBleu_score": 9.49621078291396}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = -1;\n\tint addr_family = -1;\n\tint error = -1;\n\tstruct bsd_sockaddr_storage address;\n\tsocklen_t address_len = sizeof(address);\n\tif (addr!= NULL) {\n\t\taddr_family = addr->sa_family;\n\t\tif (addr_family == AF_INET) {\n\t\t\tstruct sockaddr_in * addr_in = (struct sockaddr_in *)addr;\n\t\t\taddress_len = sizeof(struct sockaddr_in);\n\t\t\tmemcpy(&address, addr_in, address_len);\n\t\t} else if (addr_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6 * addr_in6 = (struct sockaddr_in6 *)addr;\n\t\t\taddress_len = sizeof(struct sockaddr_in6);\n\t\t\tmemcpy(&address, addr_in6, address_len);\n\t\t} else {\n\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tret = accept(socket, (struct sockaddr *)&address, &address_len);\n\tif (ret == -1) {\n\t\terror = bsd_getErrNo();\n\t\tif (error == BSD_ECONNABORTED) {\n\t\t\tbsd_setErrNo(BSD_ECONNABORTED);\n\t\t\treturn -1;\n\t\t} else if (error == BSD_EAGAIN) {\n\t\t\tbsd_setErrNo(BSD_EAGAIN);\n\t\t\treturn -1;\n\t\t} else if (error == BSD_EWOULDBLOCK) {\n\t\t\tbsd_setErrNo(BSD_EWOULDBLOCK);\n\t\t\treturn -1;\n\t\t} else if (error == BSD_EINVAL) {\n\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\treturn -1;\n\t\t} else if (error == BSD_EMFILE) {\n\t\t\tbsd_setErrNo(BSD_EMFILE);\n\t\t\treturn -1;\n\t\t} else if (error == BSD_ENFILE) {\n\t\t\tbsd_setErrNo(BSD_ENFILE);\n\t\t\treturn -1;\n\t\t} else if (error == BSD_ENOBUFS) {\n\t\t\tbsd_setErrNo(BSD_ENOBUFS);\n\t\t\treturn -1;\n\t\t}", "CodeBleu_score": 43.75568324165843}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tif (time_valid) {\n\t\tupdateJWT();\n\t\tMQTT_CLIENT_connect();\n\t\tdebug_print(\"MQTT connection established\n\");\n\t\tMQTT_subscribe = 1;\n\t} else {\n\t\tdebug_print(\"Time is not valid\n\");\n\t}\n}", "CodeBleu_score": 18.394286468544387}, {"code": "static void connectMQTT(){\n\t\t// Get the current time in UNIX format\n\tuint32_t unixTime = time(NULL);\n\n\t// Check if the time is valid\n\tif (unixTime!= 0) {\n\t\t// Update the JWT with the current time offset\n\t\tupdateJWT(unixTime);\n\n\t\t// Initiate the MQTT connection\n\t\tMQTT_CLIENT_connect();\n\n\t\t// Print a debug message to indicate the connection attempt\n\t\tdebug_print(\"MQTT: Connecting...\n\");\n\n\t\t// Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n\t\tsendMQTTSubscribe = true;\n\t}\n}", "CodeBleu_score": 31.557004679215805}, {"code": "static void connectMQTT(){\n\t\t// Get current time in UNIX format\n\ttime_t unix_time = time(NULL);\n\t// Check if time is valid\n\tif (unix_time!= -1) {\n\t\t// Update JWT with current time offset\n\t\tupdateJWT(unix_time);\n\t\t// Initiate MQTT connection\n\t\tMQTT_CLIENT_connect();\n\t\t// Print debug message\n\t\tdebug_print(\"MQTT connection established\n\");\n\t\t// Set flag to send MQTT SUBSCRIBE packet\n\t\tsendSubscribe = 1;\n\t} else {\n\t\t// Print debug message\n\t\tdebug_print(\"MQTT connection failed\n\");\n\t}\n}", "CodeBleu_score": 27.02003913091423}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_GetConnectionState() == CONNECTED) {\n\t\tdebug_printError(\"MQTT_Disconnect\");\n\t\tMQTT_Disconnect();\n\t\tMQTT_GetClientConnectionInfo();\n\t}\n\tdebug_printError(\"CLOUD_disconnect\");\n}", "CodeBleu_score": 67.20054661491204}, {"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_GetConnectionState() == MQTT_CONNECTION_STATE_CONNECTED) {\n\t\tMQTT_GetClientConnectionInfo();\n\t\tMQTT_Disconnect();\n\t}\n\tdebug_printError(\"Disconnected from cloud\");\n}", "CodeBleu_score": 60.09203779068157}, {"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n\t\tMQTT_Disconnect();\n\t\tdebug_printError(DEBUG_ERROR_CLOUD_DISCONNECT);\n\t}\n}", "CodeBleu_score": 51.84249251135684}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tuint8_t ret;\n\tuint8_t wifi_creds = passed_wifi_creds;\n\tuint8_t wifi_creds_default = 0;\n\tuint8_t wifi_creds_new = 1;\n\tuint8_t wifi_creds_invalid = 2;\n\tuint8_t wifi_creds_invalid_pass = 3;\n\tuint8_t wifi_creds_invalid_ssid = 4;\n\tuint8_t wifi_creds_invalid_auth = 5;\n\tuint8_t wifi_creds_invalid_auth_pass = 6;\n\tuint8_t wifi_creds_invalid_auth_ssid = 7;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid = 8;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid_ip = 9;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid_ip_gw = 10;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid_ip_gw_dns = 11;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid_ip_gw_dns_mask = 12;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid_ip_gw_dns_mask_mac = 13;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid_ip_gw_dns_mask_mac_server = 14;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid_ip_gw_dns_mask_mac_server_port = 15;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid_ip_gw_dns_mask_mac_server_port_user = 16;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid_ip_gw_dns_mask_mac_server_port_user_pass = 17;\n\tuint8_t wifi_creds_invalid_auth_pass_ssid_ip_gw_dns_mask_mac_server_port_user_pass_dest = 18;\n\tuint8_", "CodeBleu_score": 5.073856330823588}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif (passed_wifi_creds == 0) {\n\t\tm2m_wifi_default_connect();\n\t\tdebug_printError(m2m_wifi_get_status());\n\t} else {\n\t\tm2m_wifi_connect((char*) SSID, strlen(SSID), AUTH_TYPE, (char*) PASSWORD, NULL, NULL);\n\t\tdebug_printError(m2m_wifi_get_status());\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.43087973814407}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif (passed_wifi_creds) {\n\t\tm2m_wifi_connect(wifi_ssid, sizeof(wifi_ssid), M2M_WIFI_SEC_WPA_PSK, wifi_password, sizeof(wifi_password), NULL, NULL);\n\t} else {\n\t\tm2m_wifi_default_connect();\n\t}\n\treturn true;\n}", "CodeBleu_score": 38.699677979438164}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tsole.log", "CodeBleu_score": 4.146832330789076}, {"code": "async function DisplaySensors(map){\n\t\n * The function \"DisplaySensors\" asynchronously retrieves a list of sensors and displays them on a map.", "CodeBleu_score": 4.029169338234172}, {"code": "async function DisplaySensors(map){\n\tsole.log", "CodeBleu_score": 4.146832330789076}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet sensorMarker = createElement('div')\n\tsensorMarker.id = sensor.id\n\tsensorMarker.className ='sensor-marker'\n\tsensorMarker.style.backgroundColor = sensor.color\n\tsensorMarker.style.borderColor = sensor.color\n\treturn sensorMarker\n}", "CodeBleu_score": 39.62270857672892}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = createElement('div')\n\tmarker.className ='sensor-marker'\n\tmarker.id = sensor.id\n\tmarker.style.borderColor = sensor.color\n\treturn marker\n}", "CodeBleu_score": 33.49854694913586}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\tmarker.style.borderWidth = \"3px\";\n\tmarker.style.borderStyle = \"solid\";\n\tmarker.style.borderRadius = \"50%\";\n\tmarker.style.width = \"10px\";\n\tmarker.style.height = \"10px\";\n\tmarker.style.position = \"absolute\";\n\tmarker.style.top = \"50%\";\n\tmarker.style.left = \"50%\";\n\tmarker.style.transform = \"translate(-50%, -50%)\";\n\treturn marker;\n}", "CodeBleu_score": 39.40395098742259}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    # Construct the module path\n    module_path = f\"homeassistant.components.{module_name}\"\n\n    # Attempt to import the module\n    try:\n        _LOGGER.info(\"Loading MFA module %s\", module_name)\n        module = await async_import_module(hass, module_path)\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Failed to import MFA module %s: %s\", module_name, err)\n        raise err\n    except Exception as err:\n        _LOGGER.error(\"Failed to import MFA module %s: %s\", module_name, err)\n        raise err\n\n    # Process requirements if necessary\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not hass.config.skip_pip:\n            if module_name not in processed:\n                _LOGGER.info(\"Processing requirements for MFA module %s\", module_name)\n                await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n                processed.add(module_name)\n\n    # Return the loaded module\n    return module\n\n", "CodeBleu_score": 48.68235005331384}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = hass.config.path(MFA_MODULES_PATH, module_name)\n    _LOGGER.debug(\"Loading MFA module %s\", module_path)\n    try:\n        module = await hass.async_import_module(module_path)\n    except HomeAssistantError as err:\n        raise MfaModuleImportError(f\"Could not load MFA module {module_name}: {err}\")\n    if not hasattr(module, \"requirements\"):\n        return module\n\n    if not hass.config.skip_pip:\n        requirements = module.requirements\n        if not requirements:\n            _LOGGER.debug(\"No requirements found for MFA module %s\", module_name)\n            return module\n\n        if requirements in processed:\n            return module\n\n        _LOGGER.debug(\"Installing requirements for MFA module %s\", module_name)\n        try:\n            await hass.async_process_requirements(requirements)\n        except HomeAssistantError as err:\n            raise MfaModuleImportError(\n                f\"Could not install requirements for MFA module {module_name}: {err}\"\n            )\n        processed.add(requirements)\n\n    return module\n\n", "CodeBleu_score": 43.60928926501613}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    # Construct the module path\n    module_path = f\"homeassistant.components.{module_name}\"\n    # Attempt to import the module\n    try:\n        module = await async_import_module(hass, module_path)\n    except HomeAssistantError as ex:\n        # Log and raise the error if the import fails\n        _LOGGER.error(\n            \"Error loading multi-factor authentication (MFA) module %s: %s\",\n            module_name,\n            ex,\n        )\n        raise\n    # Process the module's requirements if they exist and pip installation is not skipped\n    if hasattr(module, \"REQUIREMENTS\"):\n        if module.REQUIREMENTS and not hass.config.skip_pip:\n            # Check if the requirements have already been processed\n            if module.REQUIREMENTS not in processed:\n                # Process the requirements\n                requirements.async_process_requirements(hass, module.REQUIREMENTS)\n                # Add the requirements to the processed set\n                processed.add(module.REQUIREMENTS)\n    # Return the loaded module\n    return module\n\n", "CodeBleu_score": 44.96933153909841}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Extract the PIN from the setup data\n    pin = setup_data[\"pin\"]\n    # Check if the user already has an entry in the internal data list\n    if user_id in self.data:\n        # Update the PIN for the existing user\n        self.data[user_id][\"pin\"] = pin\n    else:\n        # Add a new entry for the user with the provided PIN\n        self.data[user_id] = {\"pin\": pin}\n    # Return the setup data\n    return setup_data\n\n", "CodeBleu_score": 37.50703108130836}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if self.data.get(user_id):\n        self.data[user_id][\"pin\"] = setup_data\n    else:\n        self.data[user_id] = {\"pin\": setup_data}\n    return self.data[user_id]\n\n", "CodeBleu_score": 34.70576425600612}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id not in self.data:\n        self.data[user_id] = setup_data\n        return True\n    else:\n        self.data[user_id] = setup_data\n        return True\n\n", "CodeBleu_score": 27.18654606779477}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    self._async_load_lock.acquire()\n    if self._async_load_lock.locked():\n        if self._data is None:\n            self._data = {}\n            self._data[self._user_id] = NotifySetting(self._user_id, self._user_id)\n        self._async_load_lock.release()\n        return\n    self._async_load_lock.release()\n    data = self._store.get(self._user_id)\n    if data is None:\n        self._async_load_lock.acquire()\n        if self._data is None:\n            self._data = {}\n            self._data[self._user_id] = NotifySetting(self._user_id, self._user_id)\n        self._async_load_lock.release()\n        return\n    self._async_load_lock.acquire()\n    if self._data is None:\n        self._data = {}\n    for user_id in data:\n        self._data[user_id] = NotifySetting(user_id, data[user_id])\n    self._async_load_lock.release()", "CodeBleu_score": 26.67573624551337}, {"code": "async def _async_load(self) -> None\n\t\n    async with self.lock:\n        if self.data:\n            return\n        self.data = await self.store.get_all()\n        if not self.data:\n            self.data = {}\n        for user_id in self.data:\n            self.data[user_id] = NotifySetting(self.data[user_id])\n\n", "CodeBleu_score": 25.752687374666504}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._lock:\n        if self._data is None:\n            self._data = await self.data.get() or {}\n            if not self._data:\n                self._data = {\n                    user.id: NotifySetting(\n                        user=user,\n                        notify_enabled=True,\n                        notify_type=NotifyType.BOTH,\n                        notify_channel_id=None,\n                        notify_channel_type=None,\n                    )\n                    for user in await self.bot.get_all_users()\n                }\n\n", "CodeBleu_score": 32.89966840092704}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self._async_load(user_id)\n    settings = self.settings.get(user_id, {})\n    if not settings:\n        return False\n    otp = settings.get(\"otp\", \"\")\n    if not otp:\n        return False\n    if not user_input.get(\"otp\"):\n        return False\n    if not user_input[\"otp\"].isdigit():\n        return False\n    if len(user_input[\"otp\"])!= 6:\n        return False\n    if not self.otp_validator.validate(otp, user_input[\"otp\"]):\n        return False\n    return True", "CodeBleu_score": 46.28267732649114}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self._async_load(user_id)\n    if self.settings.get(user_id) is None:\n        return False\n    otp = user_input.get(\"otp\")\n    if otp is None:\n        return False\n    await async_add_executor_job(self._async_validate_otp, user_id, otp)\n    return True\n\n", "CodeBleu_score": 45.102510258930735}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self._async_load(user_id)\n    if self._notification_settings is None:\n        return False\n    try:\n        await async_add_executor_job(self._async_validate_otp, user_input)\n    except Exception:\n        _LOGGER.exception(\"Error validating OTP\")\n        return False\n    return True\n\n", "CodeBleu_score": 41.71161754164395}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.390134801419954}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.390134801419954}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_dict.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.device_dict.get(entity_entry.device_id)\n    if device_entry is None or device_entry.area_id is None:\n        return None\n    area_id = device_entry.area_id\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 72.53676782302021}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    seen = set()\n    policy = {}\n    for policy in policies:\n        for category, value in policy.items():\n            if category not in seen:\n                seen.add(category)\n                policy[category] = value\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 35.18586925701969}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy = {}\n    seen = set()\n    for policy in policies:\n        for category, value in policy.items():\n            if category not in seen:\n                seen.add(category)\n                if category in merged_policy:\n                    merged_policy[category] = merge_categories(merged_policy[category], value)\n                else:\n                    merged_policy[category] = value\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 45.042367169147305}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy in policies:\n        for category, value in policy.items():\n            if category not in seen:\n                seen.add(category)\n                merged_policy[category] = value\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 50.1699052344835}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if not provider:\n        _LOGGER.error(\"Authentication provider module name is empty\")\n        raise HomeAssistantError(\"Authentication provider module name is empty\")\n    if provider in processed:\n        return hass.async_get_module(provider)\n    try:\n        module = await hass.async_import_module(provider)\n    except Exception as err:\n        _LOGGER.error(\"Error loading authentication provider module %s: %s\", provider, err)\n        raise HomeAssistantError(f\"Error loading authentication provider module {provider}: {err}\") from err\n    if not hasattr(module, \"AUTH_PROVIDER_REQUIREMENTS\"):\n        return module\n    requirements = module.AUTH_PROVIDER_REQUIREMENTS\n    if requirements is None:\n        return module\n    if not requirements:\n        return module\n    await hass.async_process_requirements(requirements)\n    processed.add(provider)\n    return module", "CodeBleu_score": 47.67892475792745}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    _LOGGER.debug(\"Loading authentication provider module %s\", provider)\n    try:\n        module = await hass.async_import_module(provider)\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Error loading authentication provider module %s: %s\", provider, err)\n        raise\n    except ImportError:\n        _LOGGER.error(\"Error loading authentication provider module %s\", provider)\n        raise HomeAssistantError(\n            \"Error loading authentication provider module %s\", provider\n        )\n    if not hasattr(module, \"AUTH_PROVIDERS\"):\n        _LOGGER.error(\n            \"Authentication provider module %s has no AUTH_PROVIDERS attribute\", provider\n        )\n        raise HomeAssistantError(\n            \"Authentication provider module %s has no AUTH_PROVIDERS attribute\", provider\n        )\n    if not module.AUTH_PROVIDERS:\n        _LOGGER.debug(\n            \"Authentication provider module %s has no requirements\", provider\n        )\n        return module\n    if provider in processed:\n        _LOGGER.debug(\n            \"Authentication provider module %s has already been processed\", provider\n        )\n        return module\n    _LOGGER.debug(\n        \"Processing requirements for authentication provider module %s\", provider\n    )\n    await hass.async_process_requirements(module.AUTH_PROVIDERS)\n    processed.add(provider)\n    return module\n\n", "CodeBleu_score": 37.29832063414844}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await hass.async_import_module(provider)\n    except HomeAssistantError as err:\n        _LOGGER.error(\n            \"Error loading authentication provider %s: %s\", provider, err\n        )\n        raise\n    if not hasattr(module, \"AUTH_PROVIDERS\"):\n        return module\n    requirements = module.AUTH_PROVIDERS\n    if requirements is None:\n        return module\n    if not isinstance(requirements, set):\n        requirements = set(requirements)\n    if not requirements:\n        return module\n    async_process_requirements(hass, requirements)\n    processed.add(provider)\n    return module\n\n", "CodeBleu_score": 37.81974055711123}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    try:\n        # Load data from the store\n        data = await self.store.async_load()\n    except StoreError:\n        # If an error occurs, initialize an empty list of users\n        self.users = []\n        return\n\n    # If data is found, initialize a list of users with the loaded data\n    self.users = data\n\n    # Check for non-normalized usernames and normalize them\n    await self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 33.26064721885854}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self.hass.async_add_executor_job(self.store.async_load)\n    except FileNotFoundError:\n        data = []\n\n    if data is None:\n        data = []\n\n    self.users = data\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 38.75427362711608}, {"code": "async def async_load(self) -> None\n\t\n    # Load data from the store.\n    data = await self.async_load_data()\n    # Initialize an empty users list if no data is found.\n    if data is None:\n        data = []\n    # Assign the data to an internal variable.\n    self._users = data\n    # Check for non-normalized usernames within the loaded data and assign the data to an internal variable.\n    await self.async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 28.605856798318385}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n\n    self.normalize_username(username)\n    dummy_hash = self.hash_password(password)\n\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), user.password.encode()):\n                return\n            else:\n                raise InvalidAuth(f\"Invalid credentials for user {username}\")\n\n    raise InvalidAuth(f\"Invalid credentials for user {username}\")\n\n", "CodeBleu_score": 34.02278291383302}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            try:\n                if bcrypt.checkpw(password.encode(), user.password.encode()):\n                    return\n            except ValueError:\n                pass\n    try:\n        bcrypt.checkpw(password.encode(), dummy_hash)\n    except ValueError:\n        pass\n    raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 37.6290797531792}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.checkpw(b\"dummy\", self.dummy_hash)\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), user.password):\n                return\n            else:\n                raise InvalidAuth()\n    raise InvalidAuth()", "CodeBleu_score": 34.59015347616173}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 28.631545422567466}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.normalize_username(username)\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    self.users.remove(username)", "CodeBleu_score": 22.456431156993556}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.normalize_username(username)\n    try:\n        self.users.remove(username)\n    except ValueError:\n        raise InvalidUser(f\"user_not_found\")\n\n", "CodeBleu_score": 22.737841920083056}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n        await self.async_save()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 40.21953204971486}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    try:\n        if not self.async_is_initialized():\n            await self.async_initialize()\n        await self.async_remove_auth(credentials.username)\n        await self.async_save()\n    except Exception:\n        pass\n\n", "CodeBleu_score": 41.77780852276446}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.async_is_initialized():\n        self.async_initialize()\n    try:\n        self.async_remove_auth(credentials.username)\n        self.async_save()\n    except ValueError:\n        pass\n\n", "CodeBleu_score": 43.054472119032724}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            pass\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread)\n        try:\n            async_raise(SystemExit)\n        except RuntimeError:\n            pass\n    return joined\n\n", "CodeBleu_score": 47.596199020571795}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        thread.join(timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread)\n        async_raise(SystemExit, thread)\n    return joined\n\n", "CodeBleu_score": 47.65320684741816}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout)\n        except TimeoutError:\n            thread.interrupt_main()\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread)\n        async_raise(SystemExit, \"Interrupted\")\n    return joined\n\n", "CodeBleu_score": 49.11039372221667}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get the list of all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if not thread.is_alive() and thread.name!= \"MainThread\" and not thread.daemon]\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = SHUTDOWN_TIMEOUT / len(threads)\n    # Attempt to join each thread within the calculated timeout and log a warning if joining a thread fails\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            _LOGGER.warning(f\"Failed to join thread {thread.name}: {e}\")\n\n", "CodeBleu_score": 30.117771042591006}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get the current thread\n    current_thread = threading.current_thread()\n    # Get all alive threads\n    all_threads = threading.enumerate()\n    # Filter out the main thread and daemon threads\n    main_thread = threading.main_thread()\n    non_daemon_threads = [thread for thread in all_threads if thread is not main_thread and not thread.daemon]\n    # Calculate the timeout for each thread\n    total_timeout = 10\n    timeout_per_thread = total_timeout / len(non_daemon_threads)\n    # Attempt to join each thread within the calculated timeout\n    for thread in non_daemon_threads:\n        try:\n            thread.join(timeout_per_thread)\n        except RuntimeError as e:\n            # Log a warning if joining a thread fails\n            _LOGGER.warning(\"Failed to join thread %s: %s\", thread.name, e)\n    # Log a warning if the current thread is not the main thread\n    if current_thread is not main_thread:\n        _LOGGER.warning(\"Current thread is not the main thread: %s\", current_thread.name)\n\n", "CodeBleu_score": 35.00153835393958}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()]\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = shutdown_timeout / len(threads)\n    # Attempt to join each thread within the calculated timeout and log a warning if joining a thread fails\n    for thread in threads:\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            _LOGGER.warning(f\"Failed to join thread {thread.name}: {e}\")\n\n", "CodeBleu_score": 37.69032035996197}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._has_remaining_setups = bool(remaining_with_setup_started)\n", "CodeBleu_score": 50.43239683918297}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._has_remaining_setups = bool(remaining_with_setup_started)", "CodeBleu_score": 50.43239683918297}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    # If there are setups remaining or the previous state was not empty, it sends an internal dispatcher signal with the remaining setups.\n    if remaining_with_setup_started or not self._previous_state_empty:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    # It then updates the internal flag to reflect whether there are remaining setups.\n    self._previous_state_empty = not remaining_with_setup_started", "CodeBleu_score": 58.6193804432877}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # This function is called by the validate command and is not intended to be called directly.\n    # The validate command calls this function with the integrations and config objects.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.py file.\n    # The validate command is responsible for validating the bluetooth.", "CodeBleu_score": 7.494588744588746}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # If the bluetooth.py file is not being validated, it reads the current content of bluetooth.py and compares it with the generated content.\n    if not integrations:\n        # If the contents differ, it adds an error to the configuration indicating that bluetooth.py is not up to date and provides a fixable suggestion.\n        if not config.errors:\n            config.add_error(\n                \"bluetooth\",\n                \"bluetooth.py is not up to date\",\n                \"Please run `ha generate bluetooth` to generate the Bluetooth integration.\",\n            )\n            return\n        return\n    # The function \"generate_and_validate\" generates the Bluetooth content based on provided integrations and stores it in the configuration cache.\n    generate_and_validate(integrations, config)\n\n", "CodeBleu_score": 31.081185550613256}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # The function \"validate\" verifies the correctness of the bluetooth.py file for Home Assistant.", "CodeBleu_score": 7.494588744588746}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\tvar e error\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Addition.TokenEndpoint)\n\tif e!= nil {\n\t\tlogger.Info(fmt.Sprintf(\"refresh token error: %v\", e))\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 65.71027997227765}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp RefreshTokenResponse\n\tvar e error\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post\n\tif e!= nil {\n\t\tlogger.Info(\"refreshToken\", zap.String(\"err\", e.Error()))\n\t\treturn e\n\t}\n\tif resp.AccessToken!= \"\" {\n\t\td.AccessToken = resp.AccessToken\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"refreshToken failed, response: %v\", resp)\n}", "CodeBleu_score": 63.793966296439244}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp base.Response\n\tvar e error\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post\n\tbase.RestyClient.R\n\tif e!= nil {\n\t\tlogger.Info\n\t}\n\tif resp.StatusCode!= http.StatusOK {\n\t\tlogger.Info\n\t}\n\tvar token base.Token\n\tbase.JsonUnmarshal\n\tbase.JsonUnmarshal(&resp.Body, &token)\n\td.AccessToken = token.AccessToken\n\td.TokenType = token.TokenType\n\td.Expiration = token.Expiration\n\td.RefreshToken = token.RefreshToken\n\treturn nil\n}", "CodeBleu_score": 62.036330308935426}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.request(url, method, callback, resp)\n\treturn d.requestBody(req)\n}", "CodeBleu_score": 13.648953852934861}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.NewRequest(method, url)\n\treq.SetHeader(\"Authorization\", \"Bearer \" + d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\tif resp!= nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := d.request(req)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == http.StatusUnauthorized {\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres, err = d.request(req)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif res.StatusCode()!= http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"Request failed with status %d\", res.StatusCode())\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 56.94942132031553}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.NewRestyRequest(d.RestyClient)\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsTeamDrives\", \"true\")\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"fields\", \"*\")\n\treq.SetError(&d.error)\n\treq.SetResult(resp)\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == http.StatusUnauthorized {\n\t\tif d.refreshToken!= \"\" {\n\t\t\tif err := d.refresh(); err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"unauthorized\")\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 60.70428383808911}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := d.chunkSize\n\tif chunkSize == 0 {\n\t\tchunkSize = d.defaultChunkSize\n\t}\n\tfinish := int64(0)\n\tfor finish < stream.GetSize() {\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\treq := d.request.SetMethod(\"PUT\").SetURL(url).SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize))\n\t\tif err := req.Do(ctx); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.84629679509742}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(10 * 1024 * 1024)\n\tfinish := int64(0)\n\tfor {\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tif finish >= stream.GetSize() {\n\t\t\treturn nil\n\t\t}\n\t\tstart := finish\n\t\tfinish += chunkSize\n\t\tif finish > stream.GetSize() {\n\t\t\tfinish = stream.GetSize()\n\t\t}\n\t\treq := d.request.SetMethod(\"PUT\").SetURL(url).SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", start, finish-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize))\n\t\tif err := req.SetContext(ctx).Send(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n}", "CodeBleu_score": 46.83405555032244}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(10 * 1024 * 1024)\n\tif stream.GetSize() < chunkSize {\n\t\tchunkSize = stream.GetSize()\n\t}\n\tfinish := int64(0)\n\tfor finish < stream.GetSize() {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t\treq := d.request.SetMethod(\"PUT\").SetURL(url)\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize))\n\t\tif err := req.Send(ctx); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 55.215798714941755}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar (\n\t\tmountPoint string\n\t)\n\n\tif err := ctx.Bind(&mountPoint); err!= nil {\n\t\treturn common_err.NewClientError(err.Error())\n\t}\n\n\tif mountPoint == \"\" {\n\t\treturn common_err.NewClientError(\"Mount point is empty\")\n\t}\n\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err.Error())\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"Storage unmounted\")\n}", "CodeBleu_score": 37.78740680427818}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar request UmountStorageRequest\n\tif err := ctx.Bind(&request); err!= nil {\n\t\treturn common_err.NewClientError(err)\n\t}\n\tmountPoint := strings.ReplaceAll(request.MountPoint, \"\\\\\", \"/\")\n\tif mountPoint == \"\" {\n\t\treturn common_err.NewClientError(errors.New(\"mount point is empty\"))\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err)\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(request.MountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err)\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.NewSuccessResponse())\n}", "CodeBleu_score": 42.130968454498365}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data\n\tvar req UmountStorageRequest\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn err\n\t}\n\t// Retrieve mount point\n\tmountPoint := req.MountPoint\n\tif mountPoint == \"\" {\n\t\treturn common_err.NewClientErr(ctx, \"mount point cannot be empty\")\n\t}\n\t// Unmount storage\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err!= nil {\n\t\treturn common_err.NewServiceErr(ctx, \"failed to unmount storage\", err)\n\t}\n\t// Delete configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err!= nil {\n\t\treturn common_err.NewServiceErr(ctx, \"failed to delete configuration\", err)\n\t}\n\t// Return success\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 41.406476673254446}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return an error response if the file path is missing\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrMissingParameter))\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// Return an error response if the file does not exist\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 41.8040760687884}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return an error response with an appropriate error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidPath))\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// Return an error response with an appropriate error message\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 41.73902373953745}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\t// Check if the path is provided\n\tif filePath == \"\" {\n\t\t// Return an error response\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrInvalidParameter))\n\t}\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); err!= nil {\n\t\t// Return an error response\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\t// Return the file\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 41.396018452652314}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS))\n}", "CodeBleu_score": 54.5839714442101}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the name parameter from the request context.\n\tname := ctx.Param(\"name\")\n\t// Bind the request body to a message map.\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\t// Send the notification using the \"name\" and \"message\", then return a success response.\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn common_err.NewInternalServerError(err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent successfully.\"})\n}", "CodeBleu_score": 50.19861977596234}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn common_err.NewBadRequestError(err.Error())\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn common_err.NewInternalServerError(err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(http.StatusOK, \"ok\"))\n}", "CodeBleu_score": 61.220920573882}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response, ctx.Request, nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tfmt.Println(\"New Connection\")\n\tsendMeg.Add(ws)\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tsendMeg.Remove(ws)\n\t\t\tfmt.Println(\"Connection closed\")\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(\"Message received: \", string(message))\n\t}\n}", "CodeBleu_score": 38.35261477148718}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP GET request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response, ctx.Request, nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running\n\tif!sendMeg.IsRunning() {\n\t\tsendMeg.Start()\n\t}\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(\"Message Type:\", ws.MessageTypeName(message))\n\t\tfmt.Println(\"Message:\", string(message))\n\t\tfmt.Println(\"Error:\", err)\n\t}\n}", "CodeBleu_score": 42.681185331108175}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections.\n\tsendMeg.AddConnection(ws)\n\t// Ensure that the message sending service is running.\n\tgo sendMeg.Start()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) {\n\t\t\t\tfmt.Println(err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Message type: \", websocket.BinaryMessage)\n\t\tfmt.Println(\"Message: \", string(message))\n\t}\n\treturn nil\n}", "CodeBleu_score": 38.94923109570024}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tcpuInfo, err := service.MyService.System().GetCpuInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.CPU_INFO_ERROR, err))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS, cpuInfo))\n}", "CodeBleu_score": 23.116724185881154}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tinfo, err := service.MyService.System().GetHardwareInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.GetErr(common_err.HardwareInfo)))\n\t}\n\treturn ctx.JSON(http.StatusOK, info)\n}", "CodeBleu_score": 21.803077889011814}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get CPU information\n\tcpuInfo := service.MyService.System().GetCpuInfo()\n\t// Get drive model and architecture\n\tdriveModel, driveArch := service.MyService.System().GetDeviceTree()\n\t// Create JSON response\n\tresponse := make(map[string]interface{})\n\tresponse[\"success\"] = true\n\tresponse[\"message\"] = \"System hardware information retrieved successfully\"\n\tresponse[\"cpu_info\"] = cpuInfo\n\tresponse[\"drive_model\"] = driveModel\n\tresponse[\"drive_architecture\"] = driveArch\n\t// Return JSON response\n\treturn ctx.JSON(http.StatusOK, response)\n}", "CodeBleu_score": 28.582652042193185}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar (\n\t\tservices *[]string\n\t\terr      error\n\t)\n\n\tif services, err = s.ListServices(); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tvar (\n\t\trunningServices  = make([]string, 0)\n\t\tnotRunningServices = make([]string, 0)\n\t)\n\n\tfor _, service := range *services {\n\t\tif isRunning, err := s.IsServiceRunning(service); err!= nil {\n\t\t\treturn nil, err\n\t\t} else if isRunning {\n\t\t\trunningServices = append(runningServices, service)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 47.87834437223286}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar (\n\t\tserviceNames []string\n\t\trunning      []string\n\t\tnotRunning   []string\n\t\tservices     []*service.Service\n\t\terr          error\n\t)\n\n\tif services, err = s.ListServices(); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service.Name, \"casaos\") {\n\t\t\tserviceNames = append(serviceNames, service.Name)\n\t\t\tif service.ActiveState == \"active\" {\n\t\t\t\trunning = append(running, service.Name)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 58.88779449258177}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif s.systemctl.IsServiceRunning(service) {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 61.14960688810456}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tresponse, err := i.MessageBus().PublishEventWithResponse(context.Background(), name, message)\n\tif err!= nil {\n\t\tlogger.Error(\"error publishing event\", zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"error publishing event\", zap.String(\"status\", response.Status), zap.Any(\"details\", response.Body))\n\t}\n}", "CodeBleu_score": 33.41373344166178}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Marshal the message map to JSON strings\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to marshal message map to JSON\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Create a context with a timeout\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Create a new request\n\trequest, err := http.NewRequestWithContext(ctx, \"POST\", fmt.Sprintf(\"http://%s/notify/%s\", i.notifyServerURL, name), bytes.NewBuffer(messageJSON))\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to create request\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Set the request headers\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\trequest.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", i.token))\n\n\t// Send the request\n\tclient := &http.Client{}\n\tresponse, err := client.Do(request)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to send request\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer response.Body.Close()\n\n\t// Log the response status code\n\tlogger.Info(\"Response status code\", zap.String(\"status\", response.Status))\n\n\t// Check if the response status code is not OK\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"Failed to send notification\", zap.String(\"status\", response.Status))\n\t\treturn\n\t}\n\n\t// Log the response body\n\tbody, err := ioutil.ReadAll(response.Body)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to read response body\", zap.Error(err))\n\t\treturn\n\t}\n\tlogger.Info(\"Response body\", zap.String(\"body\", string(body)))\n}", "CodeBleu_score": 37.40419140154675}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tlogger := i.logger.With(zap.String(\"method\", \"SendNotify\"))\n\tlogger.Info(\"Sending notification\", zap.String(\"name\", name), zap.Any(\"message\", message))\n\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to serialize message\", zap.Error(err))\n\t\treturn\n\t}\n\tevent := &model.Event{\n\t\tName: name,\n\t\tData: jsonMessage,\n\t}\n\tresponse, err := i.messageBus.PublishEventWithResponse(context.Background(), event)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.Int(\"status\", response.StatusCode), zap.String(\"message\", response.Status))\n\t\treturn\n\t}\n\tlogger.Info(\"Notification sent successfully\", zap.Int(\"status\", response.StatusCode), zap.String(\"message\", response.Status))\n}", "CodeBleu_score": 38.86616194488227}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\taddress := c.external.GetMessageBusAddress()\n\tif address == \"\" {\n\t\taddress = \"error\"\n\t}\n\tclient.SetServer(address)\n\treturn client\n}", "CodeBleu_score": 23.76453474560467}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\taddress, err := c.external.GetMessageBusAddress()\n\tif err!= nil {\n\t\tc.log.Error(err)\n\t\taddress = message_bus.DefaultError\n\t}\n\tclient := message_bus.NewClientWithResponses(address)\n\treturn client\n}", "CodeBleu_score": 33.915115221914675}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\taddress, err := c.external.GetMessageBusAddress()\n\tif err!= nil {\n\t\treturn message_bus.NewClientWithResponses(c.external.GetMessageBusAddress(), message_bus.NewClientWithResponsesError(err))\n\t}\n\treturn message_bus.NewClientWithResponses(address, nil)\n}", "CodeBleu_score": 30.44971413129386}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\txForwardedFor := request.Header.Get(\"X-FORWARDED-FOR\")\n\tif xForwardedFor!= \"\" {\n\t\treturn strings.Split(xForwardedFor, \",\")[0]\n\t}\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\tif ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 46.25499500120797}, {"code": "func GetIP(request *http.Request) string{\n\t\txForwardedFor := request.Header.Get(\"X-Forwarded-For\")\n\tif xForwardedFor!= \"\" {\n\t\tip := strings.Split(xForwardedFor, \",\")[0]\n\t\treturn strings.TrimSpace(ip)\n\t}\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\tif ip == \"::1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\tif ip == \"::ffff:127.0.0.1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 41.31889609904471}, {"code": "func GetIP(request *http.Request) string{\n\t\tvar ip string\n\tif request.Header.Get(\"X-Forwarded-For\")!= \"\" {\n\t\tip = strings.Split(request.Header.Get(\"X-Forwarded-For\"), \",\")[0]\n\t} else {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 81.13097933452791}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// The function \"GenreateSystemEntry\" generates a consolidated system entry JSON file.\nIt defines paths for the modules directory and the entry file, ensuring the entry file exists.\nIt reads each module directory for entry.json files, concatenates their content into a single JSON array, and writes this array to the entry file path.\nErrors encountered during directory reading, file reading, or file writing are logged accordingly.\n\tlogger.Info(\"Generating system entry\")\n\tentryFile := filepath.Join(c.config.System.Path, \"entry.json\")\n\tif err := file.IsNotExistCreateFile(entryFile); err!= nil {\n\t\tlogger.Error(err.Error())\n\t\treturn\n\t}\n\tentry := []byte(\"[]\")\n\tmodulesDir := filepath.Join(c.config.System.Path, \"modules\")\n\tif err := os.Chdir(modulesDir); err!= nil {\n\t\tlogger.Error(err.Error())\n\t\treturn\n\t}\n\tfiles, err := os.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tlogger.Error(err.Error())\n\t\treturn\n\t}\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tif!strings.HasSuffix(file.Name(), \".json\") {\n\t\t\tcontinue\n\t\t}\n\t\tmoduleFile := filepath.Join(modulesDir, file.Name())\n\t\tmodule, err := os.ReadFile(moduleFile)\n\t\tif err!= nil {\n\t\t\tlogger.Error(err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tentry = append(entry, module...)\n\t\tentry = append(entry, ',')\n\t}\n\tentry = entry[:len(entry)-1]\n\tif err := os.WriteFile(entryFile, entry, 0644); err!= nil {\n\t\tlogger.Error(err.Error())\n\t\treturn\n\t}\n\tlogger.Info(\"System entry generated\")\n}", "CodeBleu_score": 43.71835357713803}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// The function \"GenreateSystemEntry\" generates a consolidated system entry JSON file.", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tc.logger.Info(\"Generating system entry\")\n\tvar modulesDir = filepath.Join(c.config.Root, \"modules\")\n\tvar entryFile = filepath.Join(c.config.Root, \"system-entry.json\")\n\tvar modules []Module\n\tvar err error\n\tif _, err := os.Stat(modulesDir); os.IsNotExist(err) {\n\t\terr = os.MkdirAll(modulesDir, 0777)\n\t\tif err!= nil {\n\t\t\tc.logger.Error(\"Error creating modules directory\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\t_, err = os.Create(entryFile)\n\t\tif err!= nil {\n\t\t\tc.logger.Error(\"Error creating entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\tfiles, err := ioutil.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tc.logger.Error(\"Error reading modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\tfor _, f := range files {\n\t\tvar modulePath = filepath.Join(modulesDir, f.Name())\n\t\tif _, err := os.Stat(modulePath); os.IsNotExist(err) {\n\t\t\tc.logger.Error(\"Error reading module directory\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t\tvar entryFile = filepath.Join(modulePath, \"entry.json\")\n\t\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\t\tc.logger.Error(\"Error reading entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t\tvar module Module\n\t\tcontent, err := ioutil.ReadFile(entryFile)\n\t\tif err!= nil {\n\t\t\tc.logger.Error(\"Error reading entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t\terr = json.Unmarshal(content, &module)\n\t\tif err!= nil {\n\t\t\tc.logger.Error(\"Error unmarshalling entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t\tmodules = append(modules, module)\n\t}\n\tcontent, err := json.Marshal(modules)\n", "CodeBleu_score": 40.082905610329455}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get the list of network interfaces.\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", errors.New(\"Failed to get network interfaces\")\n\t}\n\n\t// Get the list of network names.\n\tnetworkNames, err := c.GetNet()\n\tif err!= nil {\n\t\treturn \"\", errors.New(\"Failed to get network names\")\n\t}\n\n\t// Iterate over the interfaces and network names.\n\tfor _, i := range interfaces {\n\t\tfor _, n := range networkNames {\n\t\t\t// Check if the interface name matches the network name.\n\t\t\tif i.Name == n {\n\t\t\t\t// Return the MAC address of the interface.\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// No matching interface was found.\n\treturn \"\", errors.New(\"No matching interface found\")\n}", "CodeBleu_score": 58.28394315253726}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", errors.New(\"failed to get network interfaces\")\n\t}\n\tfor _, iface := range interfaces {\n\t\taddrs, err := iface.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \"\", errors.New(\"failed to get network addresses\")\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tif ipnet, ok := addr.(*net.IPNet); ok &&!ipnet.IP.IsLoopback() {\n\t\t\t\tif ipnet.IP.To4()!= nil {\n\t\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching network interface found\")\n}", "CodeBleu_score": 54.27475627445318}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get a list of network interfaces\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", errors.New(\"Failed to get network interfaces\")\n\t}\n\n\t// Get a list of network names from the system service\n\tnetNames, err := c.GetNet()\n\tif err!= nil {\n\t\treturn \"\", errors.New(\"Failed to get network names\")\n\t}\n\n\t// Iterate over the interfaces and network names\n\tfor _, iface := range interfaces {\n\t\tfor _, netName := range netNames {\n\t\t\t// Check if the network name matches the interface name\n\t\t\tif netName == iface.Name {\n\t\t\t\t// Return the MAC address of the interface\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// No matching interface was found\n\treturn \"\", errors.New(\"No matching interface found\")\n}", "CodeBleu_score": 54.49228281187095}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\treturn TSC_ERR_INVALID_PARAM;\n\t}\n\n\t/*\n\t * Add a reference to the request object and increment the request count for the associated TSC object.\n\t */\n\trc = taosAddRef(pRequest);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\trc = tscDebug(pTscObj, \"registerRequest: Request %p, refcount %\" PRId32, pRequest, pRequest->refcount);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary, including total and current request counts.\n\t */\n\tif (pTscObj->pApplication!= NULL) {\n\t\t/*\n\t\t * Update the application's request summary.\n\t\t */\n\t\trc = taosAddRequest(pTscObj->pApplication, pRequest);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 37.45782263764783}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\tuint64_t tscStart = 0;\n\tuint64_t tscEnd = 0;\n\tuint64_t tscDiff = 0;\n\tuint64_t tscNow = 0;\n\tuint64_t tscNext = 0;\n\tuint64_t tscNext2 = 0;\n\tuint64_t tscNext3 = 0;\n\tuint64_t tscNext4 = 0;\n\tuint64_t tscNext5 = 0;\n\tuint64_t tscNext6 = 0;\n\tuint64_t tscNext7 = 0;\n\tuint64_t tscNext8 = 0;\n\tuint64_t tscNext9 = 0;\n\tuint64_t tscNext10 = 0;\n\tuint64_t tscNext11 = 0;\n\tuint64_t tscNext12 = 0;\n\tuint64_t tscNext13 = 0;\n\tuint64_t tscNext14 = 0;\n\tuint64_t tscNext15 = 0;\n\tuint64_t tscNext16 = 0;\n\tuint64_t tscNext17 = 0;\n\tuint64_t tscNext18 = 0;\n\tuint64_t tscNext19 = 0;\n\tuint64_t tscNext20 = 0;\n\tuint64_t tscNext21 = 0;\n\tuint64_t tscNext22 = 0;\n\tuint64_t tscNext23 = 0;\n\tuint64_t tscNext24 = 0;\n\tuint64_t tscNext25 = 0;\n\tuint64_t tscNext26 = 0;\n\tuint64_t tscNext27 = 0;\n\tuint64_t tscNext28 = 0;\n\tuint64_t", "CodeBleu_score": 5.461842780589621}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\n\tif (pRequest == NULL) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pTscObj == NULL) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_REGISTERED) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_COMPLETE) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_CANCELLED) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_TIMEOUT) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_ABORTED) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_IN_PROGRESS) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_WAITING) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_QUEUED) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_PENDING) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_SCHEDULED) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_UNKNOWN) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_REJECTED) {\n\t\treturn TSC_RC_INVALID_PARAMETER;\n\t}\n\n\tif (pRequest->requestState == TSC_REQUEST_STATE_REJECT", "CodeBleu_score": 35.28064568519172}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar* db = NULL;\n\tchar* db_end = NULL;\n\tchar* db_start = NULL;\n\tchar* db_end_start = NULL;\n\tbool is_exception_db = false;\n\tif (pRequest == NULL) {\n\t\treturn false;\n\t}\n\tdb = pRequest->pDb;\n\tif (db == NULL) {\n\t\treturn false;\n\t}\n\tdb_end = db + strlen(db);\n\tdb_start = db;\n\tdb_end_start = db_end;\n\tif (db_end_start - db_start == strlen(exceptDb)) {\n\t\tif (memcmp(db_start, exceptDb, db_end_start - db_start) == 0) {\n\t\t\tis_exception_db = true;\n\t\t}\n\t}\n\tif (is_exception_db) {\n\t\treturn false;\n\t}\n\tif (pRequest->pDb == NULL) {\n\t\treturn true;\n\t}\n\tif (pRequest->pDb!= NULL) {\n\t\tif (strcmp(pRequest->pDb, exceptDb)!= 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 38.95654034802434}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar* db = pRequest->db;\n\tif (db!= NULL && strcmp(db, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tchar* pos = pRequest->db;\n\twhile (pos!= NULL) {\n\t\tpos = strchr(pos, '.');\n\t\tif (pos == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tpos++;\n\t\tif (strcmp(pos, exceptDb) == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 45.96773489814038}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb;\n\tchar *pDbEnd;\n\tbool match;\n\tchar *pExceptDb;\n\n\tpDb = pRequest->primaryDb;\n\tpDbEnd = strchr(pDb, '.');\n\tif (pDbEnd == NULL) {\n\t\tpExceptDb = exceptDb;\n\t} else {\n\t\tpExceptDb = pDbEnd + 1;\n\t}\n\n\tmatch = strcmp(pDb, pExceptDb)!= 0;\n\tif (!match) {\n\t\treturn false;\n\t}\n\n\twhile ((pDb = taosArrayGet(pRequest->dbList, pRequest->dbListSize++))!= NULL) {\n\t\tpDbEnd = strchr(pDb, '.');\n\t\tif (pDbEnd == NULL) {\n\t\t\tpExceptDb = exceptDb;\n\t\t} else {\n\t\t\tpExceptDb = pDbEnd + 1;\n\t\t}\n\t\tif (strcmp(pDb, pExceptDb)!= 0) {\n\t\t\tmatch = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn match;\n}", "CodeBleu_score": 43.18837577441622}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool ret = false;\n\n\tif (code == E_NEED_REDIRECT_ERROR) {\n\t\tswitch (msgType) {\n\t\tcase MSG_TYPE_GET_FILE_INFO:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP:\n\t\tcase MSG_TYPE_GET_FILE_INFO_REQ:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_REQ:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_REQ:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_REQ:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_REQ:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP_REQ:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP_RESP:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP_RESP_REQ:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP_RESP_RESP:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP_RESP_RESP_REQ:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP_RESP_RESP_RESP:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP_RESP_RESP_RESP_REQ:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP_RESP_RESP_RESP_RESP:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP_RESP_RESP_RESP_RESP_REQ:\n\t\tcase MSG_TYPE_GET_FILE_INFO_RESP_RESP_RESP_RESP_RESP", "CodeBleu_score": 27.12615084315153}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == E_RPC_REDIRECT_NEEDED) {\n\t\tif (msgType!= MSG_RPC_REQ && msgType!= MSG_RPC_REQ_WITH_DATA && msgType!= MSG_RPC_REQ_WITH_DATA_NO_ACK && msgType!= MSG_RPC_REQ_WITH_DATA_NO_ACK_NO_RSP && msgType!= MSG_RPC_REQ_WITH_DATA_NO_ACK_NO_RSP_NO_RSP_TO_CLIENT) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 47.44349390240809}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == REDIRECT_ERROR) {\n\t\tif (msgType == MSG_TYPE_GET_FILE || msgType == MSG_TYPE_PUT_FILE || msgType == MSG_TYPE_DELETE_FILE || msgType == MSG_TYPE_LIST_FILE) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 48.65970117316657}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint requestID = 0;\n\tint n = 0;\n\tint nRequests = 0;\n\tint nStopped = 0;\n\tint nInvalid = 0;\n\tint nReleased = 0;\n\tint nInvalidReleased = 0;\n\tint nStoppedReleased = 0;\n\tint nStoppedInvalidReleased = 0;\n\tint nStoppedInvalid = 0;\n\tint nStoppedInvalidAcquired = 0;\n\tint nStoppedInvalidReleasedAcquired = 0;\n\tint nStoppedAcquired = 0;\n\tint nStoppedInvalidAcquiredReleased = 0;\n\tint nStoppedInvalidReleasedAcquiredReleased = 0;\n\tint nStoppedAcquiredReleased = 0;\n\tint nStoppedAcquiredReleasedInvalid = 0;\n\tint nStoppedAcquiredReleasedInvalidReleased = 0;\n\tint nStoppedAcquiredReleasedInvalidReleasedAcquired = 0;\n\tint nStoppedAcquiredReleasedInvalidReleasedAcquiredReleased = 0;\n\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\tnRequests = pRequests->nSize;\n\tif (nRequests == 0) {\n\t\treturn;\n\t}\n\n\tfor (n = 0; n < nRequests; n++) {\n\t\trequestID = pRequests->pKeys[n];\n\t\tif (requestID == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (acquireRequest(pRequests, requestID) == 0) {\n\t\t\tnStoppedAcquired++;\n\t\t\tif (stopQuery(pRequests, requestID) == 0) {\n\t\t\t\tnStopped++;\n\t\t\t\tnStoppedAcquiredReleased++;\n\t\t\t\tif (releaseRequest(pRequests, requestID) == 0) {\n\t\t\t\t\tnStoppedAcquiredReleasedReleased++;\n\t\t\t\t} else {\n\t\t\t\t\tnStoppedAcquiredReleasedInvalidReleased++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnStoppedInvalid++;\n\t\t\t\tnStoppedAcquiredReleasedInvalid++;\n\t\t\t\tif (releaseRequest(pRequests, requestID) == 0) {\n\t\t\t\t\tnStoppedAcquiredReleasedInvalidReleased++;\n\t\t\t\t} else {\n\t\t\t\t\tnStoppedAcquiredReleasedInvalidReleasedAcquired++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tnStoppedInvalidAcquired++;\n\t\t\tif (stop", "CodeBleu_score": 19.794788136880886}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\t// Iterate through the hash table and stop each query if it is valid\n\tfor (int i = 0; i < pRequests->size; i++) {\n\t\t// Acquire the request\n\t\tRequest *pRequest = (Request *) taosHashIterate(pRequests, i);\n\t\t// Stop the query if it is valid\n\t\tif (pRequest!= NULL && pRequest->pQuery!= NULL) {\n\t\t\ttaos_stop_query(pRequest->pQuery);\n\t\t}\n\t\t// Release the request\n\t\treleaseRequest(pRequest);\n\t}\n}", "CodeBleu_score": 41.926263402058915}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i;\n\tfor (i = 0; i < pRequests->num_buckets; i++) {\n\t\twhile (pRequests->buckets[i]) {\n\t\t\ttaos_stop_query(pRequests->buckets[i]->data);\n\t\t\treleaseRequest(pRequests, pRequests->buckets[i]->data);\n\t\t}\n\t}\n}", "CodeBleu_score": 32.97595525061476}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tscEnableCrashReport) {\n\t\treturn;\n\t}\n\tint clientStop = 1;\n\tif (atomic_val_compare_exchange_32(&tscClientStop, &clientStop, 0)) {\n\t\twhile (clientStop) {\n\t\t\ttaosMsleep(100);\n\t\t}\n\t} else {\n\t\ttscLog(TSC_LOG_WARN, \"tscStopCrashReport: crash report thread already stopped\");\n\t}\n}", "CodeBleu_score": 50.16376648184331}, {"code": "void tscStopCrashReport(){\n\t\tif (tscDebug) {\n\t\tprintf(\"tscStopCrashReport\n\");\n\t}\n\tif (tscCrashReportingEnabled) {\n\t\tif (atomic_val_compare_exchange_32(&tscClientStop, 0, 1)) {\n\t\t\twhile (tscClientStop) {\n\t\t\t\ttaosMsleep(100);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"tscStopCrashReport: Crash report thread already stopped\n\");\n\t\t}\n\t}\n}", "CodeBleu_score": 55.833813403243894}, {"code": "void tscStopCrashReport(){\n\t\tif (tscDebug) {\n\t\tprintf(\"tscStopCrashReport\n\");\n\t}\n\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&tscCrashReportClientStop, 1, 0) == 1) {\n\t\tprintf(\"tscStopCrashReport: crash report thread already stopped\n\");\n\t\treturn;\n\t}\n\twhile (tscCrashReportClientStop!= 0) {\n\t\ttaosMsleep(1000);\n\t}\n}", "CodeBleu_score": 60.28860966270807}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t i, j;\n\tint32_t *pViewId;\n\tint32_t viewId;\n\tint32_t *pViewNumColumns;\n\tint32_t viewNumColumns;\n\tint32_t *pViewNumRows;\n\tint32_t viewNumRows;\n\tint32_t *pViewNumPartitions;\n\tint32_t viewNumPartitions;\n\tint32_t *pViewNumPartitionsPerNode;\n\tint32_t viewNumPartitionsPerNode;\n\tint32_t *pViewNumNodes;\n\tint32_t viewNumNodes;\n\tint32_t *pViewNumColumnsPerNode;\n\tint32_t viewNumColumnsPerNode;\n\tint32_t *pViewNumRowsPerNode;\n\tint32_t viewNumRowsPerNode;\n\tint32_t *pViewNumPartitionsPerColumn;\n\tint32_t viewNumPartitionsPerColumn;\n\tint32_t *pViewNumPartitionsPerNodePerColumn;\n\tint32_t viewNumPartitionsPerNodePerColumn;\n\tint32_t *pViewNumNodesPerColumn;\n\tint32_t viewNumNodesPerColumn;\n\tint32_t *pViewNumRowsPerNodePerColumn;\n\tint32_t viewNumRowsPerNodePerColumn;\n\tint32_t *pViewNumColumnsPerPartition;\n\tint32_t viewNumColumnsPerPartition;\n\tint32_t *pViewNumRowsPerPartition;\n\tint32_t viewNumRowsPerPartition;\n\tint32_t *pViewNumNodesPerPartition;\n\tint32_t viewNumNodesPerPartition;\n\tint32_t *pViewNumColumnsPerNodePerPartition;\n\tint32_t viewNumColumnsPerNodePerPartition;\n\tint32_t *pViewNumRowsPerNodePerPartition;\n\tint32_t viewNumRowsPerNodePerPartition;\n\tint32_t *pViewNumPartitionsPerColumnPerPartition;\n\tint32_t viewNumPartitionsPerColumnPerPartition;", "CodeBleu_score": 6.6571573745405095}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t numViews = 0;\n\tint32_t numColumns = 0;\n\tint32_t numRows = 0;\n\tint32_t numColumnsInView = 0;\n\tint32_t numRowsInView = 0;\n\tint32_t numRowsInViewPrev = 0;\n\tint32_t numColumnsInViewPrev = 0;\n\tint32_t numRowsInViewCurr = 0;\n\tint32_t numColumnsInViewCurr = 0;\n\tint32_t numRowsInViewPrevCurr = 0;\n\tint32_t numColumnsInViewPrevCurr = 0;\n\tint32_t numRowsInViewCurrCurr = 0;\n\tint32_t numColumnsInViewCurrCurr = 0;\n\tint32_t numRowsInViewCurrPrev = 0;\n\tint32_t numColumnsInViewCurrPrev = 0;\n\tint32_t numRowsInViewCurrCurr = 0;\n\tint32_t numColumnsInViewCurrCurr = 0;\n\tint32_t numRowsInViewCurrPrevCurr = 0;\n\tint32_t numColumnsInViewCurrPrevCurr = 0;\n\tint32_t numRowsInViewCurrCurrCurr = 0;\n\tint32_t numColumnsInViewCurrCurrCurr = 0;\n\tint32_t numRowsInViewCurrCurrPrev = 0;\n\tint32_t numColumnsInViewCurrCurrPrev = 0;\n\tint32_t numRowsInViewCurrCurrCurr = 0;\n\tint32_t numColumnsInViewCurrCurrCurr = 0;\n\tint32_t numRowsInViewCurrCurrPrevCurr = 0;\n\tint32_t numColumnsInViewCurrCurrPrevCurr = 0;\n\tint32_t numRowsInViewCurrCurrCurrCurr = 0;\n\tint32_t numColumnsInViewCurrCurrCurrCurr = 0;", "CodeBleu_score": 8.443292506506332}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = 0;\n\tint32_t viewCount = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t viewId = 0;\n\tint32_t columnCount = 0;\n\tint32_t columnId = 0;\n\tint32_t columnCountInView = 0;\n\tint32_t columnCountInCatalog = 0;\n\tint32_t columnCountInCatalogView = 0;\n\tint32_t columnCountInCatalogViewColumn = 0;\n\tint32_t columnIdInCatalog = 0;\n\tint32_t columnIdInCatalogView = 0;\n\tint32_t columnIdInCatalogViewColumn = 0;\n\tint32_t columnIdInCatalogViewColumnColumn = 0;\n\tint32_t columnIdInCatalogViewColumnColumnId = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValue = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValueLen = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValueLenLen = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValueLenLenLen = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValueLenLenLenLen = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValueLenLenLenLenLen = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValueLenLenLenLenLenLen = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValueLenLenLenLenLenLenLen = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValueLenLenLenLenLenLenLenLen = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValueLenLenLenLenLenLenLenLenLen = 0;\n\tint32_t columnIdInCatalogViewColumnColumnValueLenLenLenLenLenLenLenLenLenLen = 0;\n", "CodeBleu_score": 8.799297483350076}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status retStatus = S3StatusOK;\n\tS3CallbackData *cbData = (S3CallbackData *) callbackData;\n\tif (properties->content_length) {\n\t\tcbData->contentLength = properties->content_length;\n\t} else {\n\t\tcbData->contentLength = 0;\n\t}\n\treturn retStatus;\n}", "CodeBleu_score": 62.63360265155219}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3ResponsePropertiesCallbackData *data = (S3ResponsePropertiesCallbackData *) callbackData;\n\tif (properties->content_length > 0) {\n\t\tdata->contentLength = properties->content_length;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\treturn status;\n}", "CodeBleu_score": 64.90841956842137}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3ResponsePropertiesCallbackData *data = (S3ResponsePropertiesCallbackData *) callbackData;\n\n\tif (properties->content_length!= 0) {\n\t\tdata->content_length = properties->content_length;\n\t} else {\n\t\tdata->content_length = 0;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 63.369454298744984}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tint rc;\n\tchar command[1024];\n\tchar *configFilePath;\n\tchar *configFileName;\n\tchar *configDirPath;\n\tchar *configDirName;\n\tchar *configDir;\n\tchar *configDirWithFileName;\n\tchar *port;\n\tchar *portStr;\n\tchar *rsyncPidFilePath;\n\tchar *rsyncPidFileName;\n\tchar *rsyncPidFileDir;\n\tchar *rsyncPidFileDirWithFileName;\n\tchar *rsyncPidFile;\n\tchar *rsyncPidFileWithFileName;\n\tchar *rsyncPid;\n\tchar *rsyncPidStr;\n\tchar *rsyncPidFilePathWithFileName;\n\tchar *rsyncPidFilePathWithFileNameWithPort;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePath;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePathWithPortStr;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePathWithPortStrWithConfigFileName;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePathWithPortStrWithConfigFileNameWithConfigDirName;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePathWithPortStrWithConfigFileNameWithConfigDirNameWithConfigDir;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePathWithPortStrWithConfigFileNameWithConfigDirNameWithConfigDirWithConfigDirPath;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePathWithPortStrWithConfigFileNameWithConfigDirNameWithConfigDirWithConfigDirPathWithConfigDir;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePathWithPortStrWithConfigFileNameWithConfigDirNameWithConfigDirWithConfigDirPathWithConfigDirWithConfigDirName;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePathWithPortStrWithConfigFileNameWithConfigDirNameWithConfigDirWithConfigDirPathWithConfigDirWithConfigDirNameWithConfigDir;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePathWithPortStrWithConfigFileNameWithConfigDirNameWithConfigDirWithConfigDirPathWithConfigDirWithConfigDirNameWithConfigDirWithConfigDirPath;\n\tchar *rsyncPidFilePathWithFileNameWithPortWithConfigFilePathWithPortStrWithConfigFileNameWithConfigDirNameWithConfigDirWithConfigDirPathWithConfigDir", "CodeBleu_score": 2.2416854132133146}, {"code": "void startRsync(){\n\t\t// Create the checkpoint backup directory\n\tif (taosMulMkDir(checkpointBackupDirectory, 0777)!= 0) {\n\t\tuError(\"Could not create checkpoint backup directory\");\n\t\treturn;\n\t}\n\n\t// Remove empty directories\n\tremoveEmptyDir(checkpointBackupDirectory);\n\n\t// Generate an Rsync configuration file\n\tgenerateConfigFile();\n\n\t// Start the Rsync daemon\n\tchar command[100];\n\tsnprintf(command, 100, \"rsync --daemon --port=%d --config=%s\", rsyncPort, rsyncConfigFile);\n\tsystem(command);\n\n\t// Log whether the Rsync server started successfully or if it encountered an error\n\tif (system(\"pgrep rsync\") == 0) {\n\t\tuDebug(\"Rsync server started successfully\");\n\t} else {\n\t\tuError(\"Could not start Rsync server\");\n\t}\n}", "CodeBleu_score": 24.622849547673287}, {"code": "void startRsync(){\n\t\tchar *cmd;\n\tchar *cmd_start;\n\tchar *cmd_end;\n\tchar *cmd_port;\n\tchar *cmd_config;\n\tchar *cmd_pid;\n\tchar *cmd_pid_path;\n\tchar *cmd_pid_file;\n\tchar *cmd_pid_dir;\n\tchar *cmd_pid_dir_path;\n\tchar *cmd_pid_dir_file;\n\tchar *cmd_pid_dir_path_file;\n\tchar *cmd_pid_dir_path_file_path;\n\tchar *cmd_pid_dir_path_file_path_file;\n\tchar *cmd_pid_dir_path_file_path_file_path;\n\tchar *cmd_pid_dir_path_file_path_file_path_file;\n\tchar *cmd_pid_dir_path_file_path_file_path_file_path;\n\tchar *cmd_pid_dir_path_file_path_file_path_file_path_file;\n\tchar *cmd_pid_dir_path_file_path_file_path_file_path_file_path;\n\tchar *cmd_pid_dir_path_file_path_file_path_file_path_file_path_file;\n\tchar *cmd_pid_dir_path_file_path_file_path_file_path_file_path_file_path;\n\tchar *cmd_pid_dir_path_file_path_file_path_file_path_file_path_file_path_file;\n\tchar *cmd_pid_dir_path_file_path_file_path_file_path_file_path_file_path_file_path;\n\tchar *cmd_pid_dir_path_file_path_file_path_file_path_file_path_file_path_file_path_file;\n\tchar *cmd_pid_dir_path_file_path_file_path_file_path_file_path_file_path_file_path_file_path;\n\tchar *cmd_pid_dir_path_file_path_file_path_file_path_file_path_file_path_file_path", "CodeBleu_score": 1.9239663059673644}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n\tif (dispatcher!= null) {\n\t\tdispatcher.shutdownNow();\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered.\");\n\t}\n}", "CodeBleu_score": 66.21777110800886}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (this.dispatchers.containsKey(dispatcherId)) {\n\t\tthis.dispatchers.get(dispatcherId).shutdownNow();\n\t\tthis.dispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n\t}\n}", "CodeBleu_score": 47.4510441396475}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\t//TODO\n}", "CodeBleu_score": 2.950171161196606}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tTbActorId[] children = this.children.get(parent);\n\tif (children!= null) {\n\t\tfor (TbActorId child : children) {\n\t\t\tif (childFilter.test(child)) {\n\t\t\t\tthis.send(child, msg, highPriority);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tthis.warn(\"No children for \" + parent);\n\t}\n}", "CodeBleu_score": 41.74943570959535}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tTbActorId[] children = this.children.get(parent);\n\tif (children!= null) {\n\t\tfor (TbActorId child : children) {\n\t\t\tif (childFilter.test(child)) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.tell(child, msg, highPriority);\n\t\t\t\t} catch (TbActorException e) {\n\t\t\t\t\tthis.warn(e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 47.67165921105192}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tTbActorId[] children = childrenMap.get(parent);\n\tif (children!= null) {\n\t\tfor (TbActorId child : children) {\n\t\t\tif (childFilter.test(child)) {\n\t\t\t\tif (highPriority) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttell(child, msg, true);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tlog.warn(\"Failed to send message to child actor {} with high priority: {}\", child, e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttell(child, msg, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.warn(\"No children found for parent actor {}\", parent);\n\t}\n}", "CodeBleu_score": 48.006269685804995}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (msg.getMsgType() == TbActorMsg.RULE_NODE_UPDATED_MSG) {\n\t\tif (destructionInProgress) {\n\t\t\tif (highPriority) {\n\t\t\t\thighPriorityMsgs.add(msg);\n\t\t\t} else {\n\t\t\t\tnormalPriorityMsgs.add(msg);\n\t\t\t}\n\t\t\ttryProcessQueue();\n\t\t} else {\n\t\t\tmsg.onTbActorStopped(this);\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\ttryProcessQueue();\n\t}\n}", "CodeBleu_score": 43.13877762557311}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (isDestroyed()) {\nif (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\nif (initFailed()) {\ninitActor();\n}\n} else {\nmsg.onTbActorStopped(this);\n}\n} else {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\ntryProcessQueue();\n}\n}", "CodeBleu_score": 41.141936950122414}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroying) {\nif (msg.getMsgType() == TbActorMsg.RULE_NODE_UPDATED_MSG) {\nif (initialized) {\ninitActor();\n}\n} else {\nmsg.onTbActorStopped();\n}\nreturn;\n}\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\nif (!processing) {\nprocessQueue();\n}\n}", "CodeBleu_score": 35.252216075015774}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t\tif (status == Status.STOPPED) {\n\t\treturn;\n\t}\n\n\t// Process high priority messages\n\tif (highPriorityQueue.size() > 0) {\n\t\tprocessQueue(highPriorityQueue, HIGH_PRIORITY_PROCESSING_LIMIT);\n\t}\n\n\t// Process normal priority messages\n\tif (normalPriorityQueue.size() > 0) {\n\t\tprocessQueue(normalPriorityQueue, NORMAL_PRIORITY_PROCESSING_LIMIT);\n\t}\n\n\t// If the actor is still active, schedule a new processing attempt\n\tif (status == Status.ACTIVE) {\n\t\ttry {\n\t\t\tprocessMailboxScheduler.schedule(processMailbox, PROCESSING_INTERVAL, TimeUnit.MILLISECONDS);\n\t\t} catch (RejectedExecutionException e) {\n\t\t\t// The scheduler is shutting down, so stop the actor\n\t\t\tstop(StopReason.SCHEDULER_SHUTTING_DOWN);\n\t\t}\n\t}\n}", "CodeBleu_score": 10.666001672592316}, {"code": "private void processMailbox(){\n\ttry {\nif (status == ActorStatus.INITIALIZING) {\nif (initFailure!= null) {\nstop(StopReason.INITIALIZATION_FAILURE);\nreturn;\n}\nstatus = ActorStatus.RUNNING;\n}\nif (status == ActorStatus.STOPPING) {\nif (stopReason == StopReason.NORMAL) {\nstatus = ActorStatus.STOPPED;\n} else {\nstatus = ActorStatus.FAILED;\n}\nreturn;\n}\nif (status == ActorStatus.STOPPED) {\nreturn;\n}\nif (status == ActorStatus.FAILED) {\nif (processFailureStrategy == ProcessFailureStrategy.STOP) {\nstop(StopReason.PROCESS_FAILURE);\n}\nreturn;\n}\nif (status == ActorStatus.RUNNING) {\nif (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\nstatus = ActorStatus.FREE;\nreturn;\n}\nint processed = 0;\nwhile (processed < actorThroughput) {\nif (!highPriorityQueue.isEmpty()) {\nMessage message = highPriorityQueue.poll();\ntry {\nif (message!= null) {\nprocess(message);\nprocessed++;\n}\n} catch (Throwable t) {\nlog.error(\"Exception processing message \" + message, t);\nif (processFailureStrategy == ProcessFailureStrategy.STOP) {\nstop(StopReason.PROCESS_FAILURE);\n}\n}\n} else if (!normalPriorityQueue.isEmpty()) {\nMessage message = normalPriorityQueue.poll();\ntry {\nif (message!= null) {\nprocess(message);\nprocessed++;\n}\n} catch (Throwable t) {\nlog.error(\"Exception processing message \" + message, t);\nif (processFailureStrategy == ProcessFailureStrategy.STOP) {\nstop(StopReason.PROCESS_FAILURE);\n}\n}\n} else {\nbreak;\n}\n}\nif (processed > 0) {\nstatus = ActorStatus.FREE;\n}\n} catch (Throwable t) {\nlog.error(\"Exception processing mailbox\", t);\n}\n}\n}", "CodeBleu_score": 31.04643444323819}, {"code": "private void processMailbox(){\n\t\tif (status == Status.STOPPED) {\n\t\treturn;\n\t}\n\tif (status == Status.STOPPING) {\n\t\tstatus = Status.STOPPED;\n\t\tif (stopReason!= null) {\n\t\t\tstopReason.set(new ActorStoppedException(this, stopReason.get()));\n\t\t}\n\t\treturn;\n\t}\n\tif (status == Status.INITIALIZING) {\n\t\tif (initFailure!= null) {\n\t\t\tstatus = Status.STOPPED;\n\t\t\tstopReason.set(new ActorInitializationException(this, initFailure));\n\t\t\treturn;\n\t\t}\n\t\tstatus = Status.RUNNING;\n\t}\n\tif (status!= Status.RUNNING) {\n\t\treturn;\n\t}\n\tif (highPriorityMailbox.isEmpty() && normalPriorityMailbox.isEmpty()) {\n\t\tstatus = Status.FREE;\n\t\ttryProcessQueue();\n\t\treturn;\n\t}\n\tif (highPriorityMailbox.isEmpty()) {\n\t\tprocessMailbox(normalPriorityMailbox);\n\t\treturn;\n\t}\n\tif (normalPriorityMailbox.isEmpty()) {\n\t\tprocessMailbox(highPriorityMailbox);\n\t\treturn;\n\t}\n\tif (highPriorityMailbox.size() > normalPriorityMailbox.size()) {\n\t\tprocessMailbox(highPriorityMailbox);\n\t} else {\n\t\tprocessMailbox(normalPriorityMailbox);\n\t}\n}", "CodeBleu_score": 17.779369611079748}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (cause == null) {\n\t\tthrow new IllegalArgumentException(\"cause must not be null\");\n\t}\n\tif (stopReason == null) {\n\t\tstopReason = cause;\n\t}\n\tif (destroyInProgress) {\n\t\treturn;\n\t}\n\tdestroyInProgress = true;\n\tif (log.isDebugEnabled()) {\n\t\tlog.debug(\"Destroying actor \" + this + \" due to \" + cause);\n\t}\n\tif (executor!= null) {\n\t\texecutor.execute(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tdestroy0(cause);\n\t\t\t}\n\t\t});\n\t}\n}", "CodeBleu_score": 21.799032154497873}, {"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = cause;\n\t}\n\tif (destroyInProgress) {\n\t\treturn;\n\t}\n\tdestroyInProgress = true;\n\texecutor.execute(() -> {\n\t\ttry {\n\t\t\tdestroy(stopReason);\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"Error during actor destruction\", t);\n\t\t}\n\t\ttry {\n\t\t\tdestroyed(stopReason);\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"Error during actor destruction notification\", t);\n\t\t}\n\t});\n}", "CodeBleu_score": 36.94080032748131}, {"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = cause;\n\t}\n\tif (destroyInProgress) {\n\t\treturn;\n\t}\n\tdestroyInProgress = true;\n\tgetExecutor().execute(() -> {\n\t\ttry {\n\t\t\tsetNotReady();\n\t\t\tdestroy(stopReason, cause);\n\t\t\tnotifyStop();\n\t\t} catch (Throwable t) {\n\t\t\twarn(\"Exception during actor destruction\", t);\n\t\t}\n\t});\n}", "CodeBleu_score": 28.56287211163603}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isSysTenantId()) {\n\t\treturn true;\n\t}\n\tProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId);\n\tif (profileConfiguration == null && ignoreTenantNotFound) {\n\t\treturn true;\n\t}\n\tif (profileConfiguration == null) {\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tLimitLevel limitLevel = getLimitLevel(profileConfiguration, level);\n\tif (limitLevel == null) {\n\t\treturn true;\n\t}\n\tboolean rateLimitExceeded = checkRateLimit(api, limitLevel);\n\tif (rateLimitExceeded) {\n\t\tprocessRateLimitNotification(tenantId, api, limitLevel);\n\t}\n\treturn!rateLimitExceeded;\n}", "CodeBleu_score": 41.73604056639019}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isSysTenantId()) {\n\t\treturn true;\n\t}\n\tProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n\tLimitLevel limitLevel = profileConfiguration.getRateLimit().getLimitLevel(api.getLimitLevelEntityName());\n\tif (limitLevel == null) {\n\t\treturn true;\n\t}\n\tboolean isRateLimitExceeded = checkRateLimit(api, tenantId, limitLevel);\n\tif (isRateLimitExceeded) {\n\t\tprocessRateLimitNotification(tenantId, api, limitLevel);\n\t}\n\treturn!isRateLimitExceeded;\n}", "CodeBleu_score": 38.78262242159399}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isSysTenantId()) {\n\t\treturn true;\n\t}\n\tProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId);\n\tif (profileConfiguration == null && ignoreTenantNotFound) {\n\t\treturn true;\n\t}\n\tif (profileConfiguration == null) {\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tLimitLevel limitLevel = getLimitLevel(profileConfiguration, api, level);\n\tif (limitLevel == null) {\n\t\treturn true;\n\t}\n\treturn checkRateLimit(api, tenantId, limitLevel);\n}", "CodeBleu_score": 36.710023312136045}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tfor (Entry<String, DtlsSession> entry : sessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < (currentTimeMillis() - inactivityTimeout)) {\n\t\t\tlog.info(\"Removing DTLS session with ID \" + entry.getKey() + \" because it has been inactive for more than \" + inactivityTimeout + \" milliseconds\");\n\t\t\tsessions.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 31.847673664753223}, {"code": "public void evictTimeoutSessions(){\n\t\t// Remove all sessions that have been inactive for longer than the specified timeout\n\tlong timeout = config.getTimeout();\n\tlong expirationTime = System.currentTimeMillis() - timeout;\n\tfor (Map.Entry<String, DTLSServerSession> entry : sessions.entrySet()) {\n\t\tDTLSServerSession session = entry.getValue();\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\tsessions.remove(entry.getKey());\n\t\t\tlogger.trace(\"Removed DTLS session {} due to timeout\", session);\n\t\t}\n\t}\n}", "CodeBleu_score": 42.06146317334891}, {"code": "public void evictTimeoutSessions(){\n\t\tlong now = System.currentTimeMillis();\n\tlong timeout = now - this.inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : this.dtlsSessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < timeout) {\n\t\t\tthis.dtlsSessions.remove(entry.getKey());\n\t\t\tlogger.trace(\"Removed DTLS session {} due to timeout\", entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 42.03974994590646}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> list = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tfor (JsonNode value : values) {\n\t\t\tlist.add(new TsKvEntry(key, value.asLong()));\n\t\t}\n\t}\n\treturn list;\n}", "CodeBleu_score": 35.154284796121914}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn new ArrayList<TsKvEntry>();\n\t}\n\tList<TsKvEntry> result = new ArrayList<TsKvEntry>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tList<Long> longValues = new ArrayList<Long>();\n\t\tfor (JsonNode value : values) {\n\t\t\tlongValues.add(value.asLong());\n\t\t}\n\t\tTsKvEntry tsKvEntry = new TsKvEntry(key, longValues);\n\t\tresult.add(tsKvEntry);\n\t}\n\treturn result;\n}", "CodeBleu_score": 38.07328219343249}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> result = new ArrayList<>();\n\ttimeseries.forEach((key, values) -> {\n\t\tList<Long> timestamps = values.stream().map(JsonNode::asLong).collect(Collectors.toList());\n\t\tresult.add(new TsKvEntry(key, timestamps));\n\t});\n\treturn result;\n}", "CodeBleu_score": 47.41838764260945}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\t// Create a request map containing the current refresh token\n\tMap<String, Object> requestMap = new HashMap<String, Object>();\n\trequestMap.put(\"refresh_token\", this.refreshToken);\n\n\t// Send a POST request to the authentication endpoint\n\tResponseEntity<String> response = this.restTemplate.postForEntity(this.authenticationEndpoint, requestMap, String.class);\n\n\t// Update the token information with the current timestamp and the response body\n\tthis.setTokenInfo(response.getBody());\n}", "CodeBleu_score": 41.0885625335056}, {"code": "public void refreshToken(){\n\t\t// Create a request map\n\tMap<String, Object> requestMap = new HashMap<>();\n\trequestMap.put(\"refresh_token\", refreshToken);\n\n\t// Send a POST request to the authentication endpoint\n\tResponseEntity<String> response = postForEntity(authenticationEndpoint, requestMap);\n\n\t// Update the token information with the current timestamp and the response body\n\ttokenInfo.setTimestamp(currentTimeMillis());\n\ttokenInfo.setBody(getBody(response));\n}", "CodeBleu_score": 38.650301286155155}, {"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\nrequestMap.put(\"refresh_token\", tokenInfo.getRefreshToken());\nResponseEntity<String> response = postForEntity(refreshTokenEndpoint, requestMap);\ntokenInfo.setTimestamp(currentTimeMillis());\ntokenInfo.setToken(getBody(response));\n}", "CodeBleu_score": 39.79032374805431}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\tString url = \"http://localhost:8080/api/auth/login\";\nRestTemplate restTemplate = new RestTemplate();\nHttpHeaders headers = new HttpHeaders();\nheaders.setContentType(MediaType.APPLICATION_JSON);\nheaders.set(\"Accept\", MediaType.APPLICATION_JSON.toString());\nMultiValueMap<String, String> map = new LinkedMultiValueMap<>();\nmap.add(\"username\", \"admin\");\nmap.add(\"password\", \"\");\nHttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(map, headers);\nResponseEntity<TokenInfo> response = restTemplate.postForEntity(url, request, TokenInfo.class);\ntokenInfo = response.getBody();\ntokenInfo.setTimestamp(System.currentTimeMillis());\n}", "CodeBleu_score": 38.06250466123131}, {"code": " private void doLogin(){\n\t\n// Get the current timestamp\nlong timestamp = System.currentTimeMillis();\n\n// Create the login request map\nMap<String, String> loginRequest = new HashMap<>();\nloginRequest.put(\"username\", username);\nloginRequest.put(\"password\", );\n\n// Send the login request to the authentication endpoint\nResponseEntity<Map<String, Object>> response = postForEntity(\"/api/auth/login\", loginRequest);\n\n// Update the token information with the response data and the timestamp\nupdateTokenInfo(response.getBody(), timestamp);\n}", "CodeBleu_score": 61.47102846994925}, {"code": " private void doLogin(){\n\tlong currentTime = System.currentTimeMillis();\nMap<String, String> loginRequest = new HashMap<>();\nloginRequest.put(\"username\", username);\nloginRequest.put(\"password\", );\n\nResponseEntity<Map<String, Object>> response = postForEntity(\"/api/auth/login\", loginRequest, Map.class);\nif (response.getStatusCode() == HttpStatus.OK) {\ntokenInfo.put(\"token\", response.getBody().get(\"token\").toString());\ntokenInfo.put(\"timestamp\", String.valueOf(currentTime));\n}\n}", "CodeBleu_score": 63.56175522675138}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\tResponseEntity<Device> response = restTemplate.getForEntity(baseUrl + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n\treturn ofNullable(response.getStatusCode()).filter(s -> s == HttpStatus.OK).map(response::getBody);\n}", "CodeBleu_score": 41.4919709766933}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\tResponseEntity<Device> response = restTemplate.getForEntity(deviceUrl + \"/{deviceId}\", Device.class, deviceId);\n\treturn Optional.ofNullable(response.getBody());\n}", "CodeBleu_score": 30.03357194156993}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\tResponseEntity<Device> responseEntity = restTemplate.getForEntity(\n\t\t\"/api/device/{deviceId}\",\n\t\tDevice.class,\n\t\tnew HashMap<String, Object>() {{\n\t\t\tput(\"deviceId\", deviceId.getId());\n\t\t}}\n\t);\n\tif (responseEntity.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\treturn Optional.empty();\n\t}\n\tif (responseEntity.getStatusCode()!= HttpStatus.OK) {\n\t\tthrow new DeviceNotFoundException(deviceId);\n\t}\n\treturn Optional.of(responseEntity.getBody());\n}", "CodeBleu_score": 54.285943381354244}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nRequestEntity<Device> request = RequestEntity.post(new URI(BASE_URL + \"/api/device-with-credentials\"))\n.body(device);\nResponseEntity<Device> response = restTemplate.exchange(request, Device.class);\nreturn Optional.of(response.getBody());\n} catch (HttpStatusCodeException e) {\nif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n}\nthrow e;\n}\n}", "CodeBleu_score": 49.66675633890208}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nreturn Optional.of(postForEntity(device, credentials));\n} catch (HttpStatusCodeException e) {\nif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n}\nthrow e;\n}\n}", "CodeBleu_score": 27.85379314768372}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(\n\t\t\t\t\"http://localhost:8080/api/device-with-credentials\",\n\t\t\t\tnew HttpEntity<>(new DeviceCredentials(device, credentials)),\n\t\t\t\tDevice.class);\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 58.2557880027676}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\tthis.each(function(dev) {\n\t\t\tdev.brightness(addr, val);\n\t\t});\n\t\treturn this;\n\t} else if (arguments.length == 2) {\n\t\tthis.each(function(dev) {\n\t\t\tdev.brightness(addr, val);\n\t\t});\n\t\treturn this;\n\t}\n}", "CodeBleu_score": 48.46628968884512}, {"code": "brightness(addr, val){\n\t\tthis.send(addr, 0x10, val);\n\treturn this;\n}", "CodeBleu_score": 23.866479399367595}, {"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tthis.each(function(dev) {\n\t\t\tdev.brightness(val);\n\t\t});\n\t} else if (arguments.length === 2) {\n\t\tthis.each(function(dev) {\n\t\t\tif (dev.addr === addr) {\n\t\t\t\tdev.brightness(val);\n\t\t\t}\n\t\t});\n\t}\n\treturn this;\n}", "CodeBleu_score": 53.70777593828186}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tvar self = this;\n\tvar obj = {};\n\tObject.keys(LedControl.prototype).forEach(function(key) {\n\t\tobj[key] = LedControl.prototype[key].bind(self);\n\t});\n\tObject.getOwnPropertyNames(this).forEach(function(key) {\n\t\tobj[key] = self[key].bind(self);\n\t});\n\treturn obj;\n}", "CodeBleu_score": 34.93122980233216}, {"code": "device(addr){\n\t\tvar device = {};\n\tObject.keys(LedControl.prototype).forEach(function(key) {\n\t\tdevice[key] = LedControl.prototype[key].bind(this, addr);\n\t});\n\tObject.getOwnPropertyNames(this).forEach(function(key) {\n\t\tdevice[key] = this[key].bind(this, addr);\n\t});\n\treturn device;\n}", "CodeBleu_score": 55.91301423038102}, {"code": "device(addr){\n\t\tvar self = this;\n\tvar obj = {};\n\tObject.keys(LedControl.prototype).forEach(function(key) {\n\t\tobj[key] = LedControl.prototype[key].bind(self);\n\t});\n\tObject.getOwnPropertyNames(this).forEach(function(key) {\n\t\tobj[key] = this[key].bind(self);\n\t});\n\treturn obj;\n}", "CodeBleu_score": 38.32222817217693}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = (...args) => {\n\t\t\tconst promises = []\n\t\t\tconst callback = args.pop()\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('The last argument must be a function')\n\t\t\t}\n\t\t\tconst duration = args.pop() || 1000\n\t\t\tthis.forEach(element => {\n\t\t\t\tconst promise = new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\telement[method](...args)\n\t\t\t\t\t\tresolve()\n\t\t\t\t\t}, duration)\n\t\t\t\t})\n\t\t\t\tpromises.push(promise)\n\t\t\t})\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback()\n\t\t\t})\n\t\t}\n\t})\n}", "CodeBleu_score": 35.34155856790658}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method =>  {\ntarget[method] = (...args) =>  {\nlet promises = []\nthis.forEach(element =>  {\npromises.push(new Promise(resolve =>  {\nsetTimeout(() =>  {\nelement[method](...args)\nresolve()\n},\nduration || 1000)\n}))\n})\nPromise.all(promises).then(() =>  {\ncallback && callback()\n})\n}\n})\n}", "CodeBleu_score": 19.8374166439924}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method =>  {\nconst callbackReconciliationMethod = (duration, callback) =>  {\nif (typeof callback!== 'function')  {\nthrow new TypeError('Callback must be a function')\n}\nconst promises = this.map(element =>  {\nreturn new Promise(resolve =>  {\nsetTimeout(() =>  {\nelement[method]()\nresolve()\n}, duration || 1000)\n})\n})\nPromise.all(promises).then(() =>  {\ncallback()\n})\n}\ntarget[method] = callbackReconciliationMethod\n})\n}", "CodeBleu_score": 33.54801613333594}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\t// this.io.serialRead(this.port, (data) => {\n\t// \tthis.input += data.toString();\n\t// \tlet sentences = this.input.split(\"\\r\n\");\n\t// \tthis.input = sentences.pop();\n\t// \tsentences.forEach(sentence => {\n\t// \t\tthis.parseNmeaSentence(sentence);\n\t// \t});\n\t// });\n}", "CodeBleu_score": 0.9502231254659191}, {"code": "listen(){\n\t\tthis.input = \"\";\n\tthis.io.serialRead(this.port, (data) => {\n\t\tthis.input += new Buffer(data).toString();\n\t\tlet sentences = this.input.split(\"\\r\n\");\n\t\tthis.input = sentences.pop();\n\t\tsentences.forEach((sentence) => {\n\t\t\tthis.parseNmeaSentence(sentence);\n\t\t});\n\t});\n}", "CodeBleu_score": 30.158226723313074}, {"code": "listen(){\n\t\tvar input = \"\";\n\tthis.io.serialRead(this.port, function(data) {\n\t\tinput += new Buffer(data).toString();\n\t\tvar sentences = input.split(\"\\r\n\");\n\t\tinput = sentences.pop();\n\t\tfor (var i = 0; i < sentences.length; i++) {\n\t\t\tthis.parseNmeaSentence(sentences[i]);\n\t\t}\n\t}.bind(this));\n}", "CodeBleu_score": 39.39254492414393}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tsize_t num_active_channels = 0;\n\tsize_t buffer_size;\n\n\t/*\n\t * If the buffer size is not provided, it is assumed to be sufficient.\n\t * If the buffer size is provided, it is validated to be sufficient.\n\t */\n\tif (sequence->options & ADC_SEQUENCE_OPTIONS_UPDATE_BUFFER) {\n\t\tbuffer_size = sequence->buffer_size;\n\t} else {\n\t\tbuffer_size = 0;\n\t}\n\n\t/*\n\t * The buffer size is calculated based on the number of active channels and the size of each data sample.\n\t * The number of active channels is calculated by counting the number of channels that are enabled in the channel mask.\n\t * The size of each data sample is determined by the data type of the data buffer.\n\t * If the data type is 16-bit, the size of each data sample is 2 bytes.\n\t * If the data type is 8-bit, the size of each data sample is 1 byte.\n\t * If the data type is 10-bit, the size of each data sample is 2 bytes.\n\t * If the data type is 12-bit, the size of each data sample is 2 bytes.\n\t * If the data type is 14-bit, the size of each data sample is 2 bytes.\n\t * If the data type is 16-bit, the size of each data sample is 2 bytes.\n\t */\n\tfor (int i = 0; i < config->channels_num; i++) {\n\t\tif (sequence->channels[i]!= ADC_CHANNEL_CONFIG_DISABLED) {\n\t\t\tnum_active_channels++;\n\t\t}\n\t}\n\n\tbuffer_size += num_active_channels * sizeof(uint16_t);\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 59.15222785514598}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tconst struct adc_ad559x_data *data = dev->data;\n\tuint8_t num_channels = 0;\n\tuint32_t buffer_size = 0;\n\n\t/* Calculate the number of active channels */\n\tfor (uint8_t i = 0; i < sequence->channels_size; i++) {\n\t\tif (sequence->channels[i] < config->num_channels) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\t/* Calculate the buffer size based on the number of active channels and the size of each data sample */\n\tbuffer_size = num_channels * sizeof(uint16_t);\n\n\t/* Return an error code if the buffer size is insufficient */\n\tif (buffer_size > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Update the buffer size in the data structure */\n\tdata->buffer_size = buffer_size;\n\n\treturn 0;\n}", "CodeBleu_score": 41.44757349157145}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t num_channels = 0;\n\tuint16_t buffer_size = 0;\n\n\t/*\n\t * Calculate the number of active channels in the sequence.\n\t * If the sequence is NULL, the number of active channels is zero.\n\t */\n\tif (sequence!= NULL) {\n\t\tnum_channels = sequence->channels_length;\n\t}\n\n\t/* Calculate the buffer size based on the number of active channels and the size of each data sample. */\n\tbuffer_size = num_channels * sizeof(uint16_t);\n\n\t/* Check if the buffer size is sufficient. */\n\tif (buffer_size > data->buffer_size) {\n\t\tLOG_ERR(\"Insufficient memory for ADC buffer.\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.81691089380447}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"ADC resolution mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels == NULL || sequence->channels_len == 0) {\n\t\tLOG_ERR(\"No channels specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer == NULL || sequence->buffer_size < sequence->channels_len) {\n\t\tLOG_ERR(\"Buffer size mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_context_start_read(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->read_context = sequence;\n\tadc_context_wait_for_completion(dev, sequence);\n\treturn ret;\n}", "CodeBleu_score": 64.57323975036748}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_channel_cfg *channel_cfg;\n\tint i;\n\tint ret;\n\n\t/* Check if the resolution of the ADC sequence matches the expected resolution */\n\tif (sequence->options & ADC_FLAGS_SINGLE_ENDED) {\n\t\tif (sequence->resolution!= config->resolution_single) {\n\t\t\tLOG_ERR(\"Invalid resolution for single-ended sequence\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (sequence->resolution!= config->resolution_differential) {\n\t\t\tLOG_ERR(\"Invalid resolution for differential sequence\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check if the specified channels are valid */\n\tfor (i = 0; i < sequence->channel_cnt; i++) {\n\t\tchannel_cfg = &sequence->channels[i];\n\n\t\tif (channel_cfg->channel_id >= config->channel_count) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Validate the buffer size for the ADC read */\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Buffer size is too small\");\n\t\treturn ret;\n\t}\n\n\t/* Set the buffer, start the ADC read context, and wait for the read operation to complete */\n\tdata->buffer = sequence->buffer;\n\tret = adc_context_start_read(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to start ADC read context\");\n\t\treturn ret;\n\t}\n\n\tret = adc_context_wait_for_completion(dev);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to wait for ADC read context completion\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.909437588398724}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\tint i;\n\tuint8_t buffer[ADC_AD559X_BUFFER_SIZE];\n\n\tif (sequence->channels == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < sequence->channels_len; i++) {\n\t\tif (sequence->channels[i] >= config->channels_len) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sequence->resolution!= config->resolution) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < sequence->channels_len) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < ADC_AD559X_BUFFER_SIZE) {\n\t\tLOG_ERR(\"Buffer size is too small\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\tret = adc_context_start_read(data->context, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = adc_ad559x_wait_for_completion(data->context, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < sequence->channels_len; i++) {\n\t\tdata->buffer[i] = adc_ad559x_find_msb_set(buffer[i * 2], buffer[i * 2 + 1]);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.5436839545464}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = (struct adc_data *)ctx->data;\n\tadc_set_channels(data->dev, ctx->channels);\n\tadc_set_repeat_buffer(data->dev, data->buffer, data->buffer_size);\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 47.02181544877296}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\t/*\n\t * Retrieve the ADC data structure from the context.\n\t */\n\tstruct adc_data *adc = ctx->adc;\n\n\t/*\n\t * Set the channels to be sampled.\n\t */\n\tadc->channels = ctx->channels;\n\n\t/*\n\t * Initialize the repeat buffer with the data buffer.\n\t */\n\tadc->repeat_buffer = adc->data_buffer;\n\n\t/*\n\t * Release the semaphore to signal the start of sampling.\n\t */\n\tk_sem_give(&adc->start_sampling_sem);\n}", "CodeBleu_score": 53.8407734134286}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\t// Retrieve the ADC data structure from the context\n\tstruct adc_data *data = ctx->data;\n\n\t// Set the channels to be sampled\n\tdata->channels = ctx->channels;\n\n\t// Initialize the repeat buffer with the data buffer\n\tdata->repeat_buffer_size = data->buffer_size;\n\tdata->repeat_buffer = data->buffer;\n\n\t// Release a semaphore to signal the start of sampling\n\tk_sem_give(&data->start_sem);\n}", "CodeBleu_score": 59.085454496336745}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = (struct adc_data_container *)ctx->data_container;\n\n\tif (repeat_sampling) {\n\t\tadc_data_container->buffer_pointer = adc_data_container->repeat_buffer;\n\t}\n}", "CodeBleu_score": 49.702760841121254}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *data_container = ctx->data_container;\n\tdata_container->buffer_pointer = repeat_sampling? data_container->repeat_buffer : data_container->buffer;\n}", "CodeBleu_score": 47.64850275273804}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->adc_data_container = ctx->repeat_buffer;\n\t} else {\n\t\tctx->adc_data_container = ctx->buffer;\n\t}\n}", "CodeBleu_score": 49.050071333376174}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint32_t adc_val;\n\tint32_t ret;\n\tint i;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t\tfor (i = 0; i < data->num_channels; i++) {\n\t\t\tret = adc_context_read_channel(data->ctx, data->channels[i], &adc_val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read ADC channel %d\", data->channels[i]);\n\t\t\t\tadc_context_complete(data->ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdata->buffer[i] = adc_val;\n\t\t}\n\t\tdata->sampling_done = true;\n\t}\n}", "CodeBleu_score": 42.73722506361053}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\t// TODO\n}", "CodeBleu_score": 2.3638457185991397}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint i;\n\tint ret;\n\tint adc_value;\n\tstruct adc_context *ctx;\n\tstruct adc_context_channel_data *channel_data;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t\tfor (i = 0; i < data->active_channels; i++) {\n\t\t\tret = adc_ad559x_read_channel(data, i, &adc_value);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d\", i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tctx = &data->ctx;\n\t\t\tchannel_data = &ctx->channel_data[i];\n\t\t\tchannel_data->result = adc_value;\n\t\t\tchannel_data->status = ADC_CONTEXT_STATUS_VALID;\n\t\t}\n\t\tadc_context_complete(ctx);\n\t}\n}", "CodeBleu_score": 45.33283292274868}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tint ret;\n\tuint8_t status;\n\tuint16_t ready_time;\n\n\tready_time = config->ready_time;\n\twhile (ready_time > 0) {\n\t\tk_sleep(K_USEC(100));\n\t\tready_time -= 100;\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &status);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tif ((status & ADS1112_STATUS_RDY) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EIO;\n}", "CodeBleu_score": 53.21427022112356}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint ret;\n\tuint8_t config;\n\tk_sleep(K_USEC(ADS1112_RDY_TIME));\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\twhile (!(config & ADS1112_CONFIG_RDY)) {\n\t\tk_sleep(K_USEC(100));\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 51.29841558714463}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint ret;\n\tuint8_t config;\n\tint i;\n\n\tfor (i = 0; i < ADS1112_WAIT_DATA_READY_TRIES; i++) {\n\t\tk_sleep(K_MSEC(ADS1112_WAIT_DATA_READY_SLEEP_MS));\n\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif ((config & ADS1112_CONFIG_DRDY_MASK) == ADS1112_CONFIG_DRDY_MASK) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EIO;\n}", "CodeBleu_score": 39.18216452399135}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t required_buffer_size = sequence->options.extra_samplings + sequence->options.samplings + 1;\n\tif (required_buffer_size > sequence->buffer_size) {\n\t\tESP_LOGW(TAG, \"Buffer size is not sufficient for ADC sequence. Required: %d, Actual: %d\", required_buffer_size, sequence->buffer_size);\n\t\treturn ESP_ERR_INVALID_SIZE;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 41.896379889543375}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint required_buffer_size = 0;\n\tint num_samplings = 0;\n\tint num_extra_samplings = 0;\n\tint buffer_size = 0;\n\tint error_code = 0;\n\n\t/* Check if the sequence is valid. */\n\tif (sequence == NULL) {\n\t\treturn ADS1112_ERR_INVALID_SEQUENCE;\n\t}\n\n\t/* Get the number of samplings in the sequence. */\n\tnum_samplings = sequence->options.num_extra_samplings + sequence->options.num_samplings;\n\n\t/* Calculate the required buffer size based on the number of samplings. */\n\trequired_buffer_size = num_samplings * sizeof(uint16_t);\n\n\t/* Get the buffer size. */\n\tbuffer_size = sequence->buffer_size;\n\n\t/* Check if the buffer size is sufficient. */\n\tif (buffer_size < required_buffer_size) {\n\t\t/* Log an error message. */\n\t\tLOG_ERR(\"The buffer size is not sufficient. Required size: %d, Actual size: %d\", required_buffer_size, buffer_size);\n\n\t\t/* Return an error code. */\n\t\terror_code = ADS1112_ERR_INSUFFICIENT_BUFFER_SIZE;\n\t}\n\n\t/* Return the error code. */\n\treturn error_code;\n}", "CodeBleu_score": 42.9323405261973}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint16_t buffer_size = sequence->options & ADC_SEQ_BUF_SIZE_MASK;\n\tuint16_t extra_samples = sequence->options & ADC_SEQ_EXTRA_SAMPLES_MASK;\n\tuint16_t required_buffer_size = (sequence->length + extra_samples) * sizeof(uint16_t);\n\n\tif (buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size is not sufficient to store the ADC sequence. Required size: %u, provided size: %u\", required_buffer_buffer_size, buffer_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.26297167493998}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_adc_context *ctx = dev->data;\n\tstruct ads1112_adc_sequence *seq = sequence->buffer;\n\tint ret;\n\n\tif (sequence->channels_size!= 1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_ASYNC) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tctx->seq = seq;\n\tctx->wait = wait;\n\tctx->read_count = 0;\n\tctx->read_result = 0;\n\n\tret = adc_context_start_read(dev, sequence, ads1112_adc_context_wait_for_completion);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\treturn ads1112_adc_context_wait_for_completion(dev);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.6130960207808}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\tdata->wait = wait;\n\n\treturn adc_context_start_read(dev, sequence, wait);\n}", "CodeBleu_score": 55.51498168804172}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret!= 0) {\n\t\treturn ret;\n\t}\n\n\tdata->adc_sequence = sequence;\n\tdata->wait = wait;\n\tdata->read_result = -EINPROGRESS;\n\n\treturn adc_context_start_read(dev, wait);\n}", "CodeBleu_score": 57.129142856555696}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret;\n\tconst struct device *dev;\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Invalid number of arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Invalid device\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = audio_codec_apply_properties(dev, argv[2]);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 58.50678560562811}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tif (argc < 3) {\n\t\tshell_error(sh, \"Invalid number of arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tconst struct device *dev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tint ret = audio_codec_apply_properties(dev, argv[2]);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 61.04002032931001}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 59.30987632539677}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret = 0;\n\tstruct mpxxdtyy_data *data = dev->data;\n\tstruct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_i2s_cmd *i2s_cmd = &data->i2s_cmd;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\ti2s_cmd->cmd = MPXXDTYY_I2S_CMD_START;\n\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t} else {\n\t\t\tLOG_ERR(\"Device is not configured\");\n\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\ti2s_cmd->cmd = MPXXDTYY_I2S_CMD_STOP;\n\t\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"Device is not active\");\n\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret == 0) {\n\t\tret = mpxxdtyy_i2s_cmd_send(dev, i2s_cmd);\n\t\tif (ret == 0) {\n\t\t\tLOG_DBG(\"I2S command sent\");\n\t\t} else {\n\t\t\tLOG_ERR(\"Failed to send I2S command\");\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 55.77390005519284}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device already active\");\n\t\t\treturn -EALREADY;\n\t\t}\n\t\tret = mpxxdtyy_i2s_start(dev);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to start device\");\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_INACTIVE) {\n\t\t\tLOG_ERR(\"Device already inactive\");\n\t\t\treturn -EALREADY;\n\t\t}\n\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to stop device\");\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = DMIC_STATE_INACTIVE;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.000210460456344}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tuint8_t i2s_cmd;\n\tint err;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_I2S_STATE_STOPPED) {\n\t\t\ti2s_cmd = MPXXDTYY_I2S_CMD_START;\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIG;\n\t\t} else if (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\ti2s_cmd = MPXXDTYY_I2S_CMD_RESTART;\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid state for start\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\ti2s_cmd = MPXXDTYY_I2S_CMD_STOP;\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_STOPPED;\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid state for stop\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = mpxxdtyy_i2s_send_cmd(data, i2s_cmd);\n\tif (err) {\n\t\tLOG_ERR(\"Failed to send I2S command\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 57.6609537235405}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0x00;\n\n\tif (data->display_enabled!= enabled) {\n\t\tcommand = AUXDISPLAY_HD44780_DISPLAY_ON_OFF_CONTROL | AUXDISPLAY_HD44780_DISPLAY_ON | AUXDISPLAY_HD44780_CURSOR_ON | AUXDISPLAY_HD44780_CURSOR_BLINK_ON;\n\t\tif (!enabled) {\n\t\t\tcommand &= ~AUXDISPLAY_HD44780_DISPLAY_ON;\n\t\t}\n\t\tauxdisplay_hd44780_command(dev, command);\n\t\tdata->display_enabled = enabled;\n\t}\n}", "CodeBleu_score": 43.465438511574014}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\n\tuint8_t command = 0x08;\n\n\tif (enabled) {\n\t\tcommand |= 0x04;\n\t}\n\n\tif (data->cursor_blink) {\n\t\tcommand |= 0x01;\n\t}\n\n\tif (data->cursor_position_blink) {\n\t\tcommand |= 0x02;\n\t}\n\n\tauxdisplay_hd44780_command(dev, command);\n}", "CodeBleu_score": 34.66439752031325}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = data->display_mode;\n\n\tif (enabled) {\n\t\tcmd |= 0x08;\n\t} else {\n\t\tcmd &= ~0x08;\n\t}\n\n\tauxdisplay_hd44780_command(dev, cmd);\n}", "CodeBleu_score": 25.92522306214238}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (!config->busy_gpio_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&config->busy_gpio_port, config->busy_gpio_pin);\n\n\treturn ret;\n}", "CodeBleu_score": 70.0270745485275}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\tuint32_t pin_status;\n\n\tif (config->busy_gpio_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&config->busy_gpio_port, config->busy_gpio_pin, &pin_status);\n\tif (ret!= 0) {\n\t\treturn ret;\n\t}\n\n\treturn pin_status;\n}", "CodeBleu_score": 69.2475416750657}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tconst struct device *gpio_dev = device_get_binding(config->gpio_dev_name);\n\tint ret;\n\n\tif (!gpio_dev) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(gpio_dev, config->busy_gpio_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn (ret == 0)? 1 : 0;\n}", "CodeBleu_score": 62.4316989602709}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst struct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tret = i2c_write_dt(&config->i2c, data->i2c_addr, buffer, 2);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"I2C write failed\");\n\t\treturn ret;\n\t}\n\n\tk_msleep(config->special_command_delay);\n\n\treturn ret;\n}", "CodeBleu_score": 61.265977715149454}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tret = i2c_write_dt(&config->i2c, config->i2c_addr, buffer, 2);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_msleep(config->special_command_delay_ms);\n\n\treturn ret;\n}", "CodeBleu_score": 62.58773466651378}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst struct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\tint ret;\n\n\t/* Construct the buffer */\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\t/* Write the buffer to the device */\n\tret = i2c_write_dt(&config->i2c, data->i2c_addr, buffer, 2);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* Introduce a delay before returning */\n\tk_msleep(config->special_command_delay);\n\n\treturn ret;\n}", "CodeBleu_score": 62.11222513304262}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_data *bbram = dev->data;\n\n\tif (offset + size > bbram->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev, offset, size)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(data, bbram->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 67.26927471013582}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tconst struct bbram_emul_data *drv_data = dev->data;\n\tconst uint8_t *mem = drv_data->mem;\n\tint rc;\n\n\tif (!bbram_emul_check_invalid(dev, offset, size)) {\n\t\treturn -EINVAL;\n\t}\n\n\trc = memcpy(data, mem + offset, size);\n\tif (rc!= 0) {\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 64.52627836715956}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tconst struct bbram_emul_data *bbram = dev->data;\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(bbram, offset, size)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(data, &bbram->data[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 69.40782625063159}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_dev_cfg *cfg = dev->config;\n\tuint8_t *ram = cfg->ram;\n\tuint8_t *end = ram + cfg->ram_size;\n\n\tif (size > cfg->ram_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > cfg->ram_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > end) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ram + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 60.89644469537683}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_emul = dev->data;\n\tsize_t size_to_write;\n\n\tif (size > BBRAM_EMUL_MAX_WRITE_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_emul->state!= BBRAM_EMUL_STATE_OK) {\n\t\treturn -EIO;\n\t}\n\n\tsize_to_write = MIN(size, config->size - offset);\n\n\tmemcpy(data_emul->mem + offset, data, size_to_write);\n\n\treturn 0;\n}", "CodeBleu_score": 65.30730179304217}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tstruct bbram_emul_data *data_ = dev->data;\n\tuint8_t *ram = data_->ram;\n\n\tif (size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_->_invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(ram + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 69.09217862488642}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing argument\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = bbram_init(dev);\n\tif (err) {\n\t\tshell_error(sh, \"Device initialization failed\");\n\t\treturn err;\n\t}\n\n\t*bbram_dev = dev;\n\treturn 0;\n}", "CodeBleu_score": 69.46528347710743}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc!= 2) {\n\t\tshell_error(sh, \"Invalid number of arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 75.32245444453302}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Invalid arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = bbram_init(dev);\n\tif (err < 0) {\n\t\tshell_error(sh, \"Failed to initialize device\");\n\t\treturn err;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 68.32344386324635}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_uart_data *data = dev->data;\n\tsize_t bytes_read = 0;\n\tint ret;\n\n\t/* Calculate the number of bytes already read */\n\tbytes_read = data->bytes_read;\n\n\t/* Attempt to read the remaining bytes from the UART FIFO into the header buffer */\n\tret = uart_fifo_read(dev, data->hdr_buf + bytes_read, data->hdr_len - bytes_read, &bytes_read);\n\tif (ret!= 0) {\n\t\tLOG_ERR(\"uart_fifo_read failed\");\n\t} else {\n\t\tdata->bytes_read += bytes_read;\n\t}\n}", "CodeBleu_score": 48.47321460698906}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct uart_fifo_config *cfg = dev->config;\n\tstruct uart_fifo_data *data = dev->data;\n\tsize_t bytes_read = 0;\n\tint ret;\n\n\t/* Read header data from the UART FIFO */\n\tret = uart_fifo_read(dev, data->header + data->bytes_read, data->bytes_to_read, &bytes_read);\n\tif (ret!= 0) {\n\t\tLOG_ERR(\"UART FIFO read error: %d\", ret);\n\t\treturn;\n\t}\n\n\t/* Update the number of bytes read */\n\tdata->bytes_read += bytes_read;\n}", "CodeBleu_score": 47.88066633396531}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct uart_fifo_data *data = dev->data;\n\tuint8_t *hdr = data->hdr;\n\tuint32_t bytes_read = 0;\n\tint ret;\n\n\twhile (bytes_read < H4_HDR_LEN) {\n\t\tret = uart_fifo_read(dev, hdr + bytes_read, H4_HDR_LEN - bytes_read);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"h4_read_hdr: uart_fifo_read failed\");\n\t\t\treturn;\n\t\t}\n\t\tbytes_read += ret;\n\t}\n}", "CodeBleu_score": 37.943635285609204}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t ret = 0;\n\twhile (len) {\n\t\tret += uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n\t\tlen -= ret;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 44.85471666779619}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t temp_buffer[33];\n\tsize_t bytes_read = 0;\n\n\twhile (len > 0) {\n\t\tbytes_read = uart_fifo_read(uart, temp_buffer, len > 33? 33 : len);\n\t\tif (bytes_read == 0) {\n\t\t\tLOG_ERR(\"UART: Discard operation failed\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= bytes_read;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 36.88505000316141}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read = 0;\n\n\twhile (len > 0) {\n\t\tbytes_read = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n\t\tif (bytes_read == 0) {\n\t\t\tLOG_ERR(\"Failed to read %zu bytes from UART FIFO\", len);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= bytes_read;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 54.464615385076385}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obsv;\n\tint32_t new_hop = chan->hop;\n\n\t/*\n\t * Iterate through the channel's observers and check each observer's priority and whether it is enabled.\n\t * If an observer has a higher priority (lower numerical value) than the current highest, it updates the highest observer priority.\n\t */\n\tfor (obsv = chan->obsv_list; obsv!= NULL; obsv = obsv->next) {\n\t\tif (obsv->priority < new_hop && obsv->enabled) {\n\t\t\tnew_hop = obsv->priority;\n\t\t}\n\t}\n\n\t/*\n\t * Set the channel's highest observer priority to the determined value.\n\t * This ensures that the channel will only send messages to observers with a higher priority (lower numerical value) than the channel's highest observer priority.\n\t */\n\tchan->hop = new_hop;\n}", "CodeBleu_score": 18.306094068667466}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t highest_priority = 0;\n\tstruct zbus_observer *observers = chan->observers;\n\tstruct zbus_observer *observer;\n\tuint8_t i;\n\tuint8_t priority;\n\n\tfor (i = 0; i < ZBUS_MAX_OBSERVERS; i++) {\n\t\tobserver = &observers[i];\n\t\tif (observer->enabled) {\n\t\t\tpriority = observer->priority;\n\t\t\tif (priority > highest_priority) {\n\t\t\t\thighest_priority = priority;\n\t\t\t}\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = highest_priority;\n}", "CodeBleu_score": 30.676171450981045}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *chan_data = chan->data;\n\tint highest = chan_data->highest_observer_priority;\n\tint observer_priority;\n\tstruct zbus_observer *observer;\n\tint i;\n\tint new_highest = highest;\n\tfor (i = 0; i < chan_data->num_observers; i++) {\n\t\tobserver = chan_data->observers[i];\n\t\tobserver_priority = observer->priority;\n\t\tif (observer_priority < new_highest) {\n\t\t\tnew_highest = observer_priority;\n\t\t}\n\t}\n\tif (new_highest!= highest) {\n\t\tchan_data->highest_observer_priority = new_highest;\n\t}\n}", "CodeBleu_score": 32.6490608935382}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel *ch;\n\tstruct zbus_channel_observation *ob;\n\tzbus_channel_observation_foreach(ch, ob) {\n\t\tif (ob->obs == obs) {\n\t\t\tupdate_channel_hop(ch);\n\t\t}\n\t}\n}", "CodeBleu_score": 25.518515366336885}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel *ch;\n\tstruct zbus_channel_observation *obs_ch;\n\tstruct zbus_channel_observation *next_obs_ch;\n\tZBUS_STRUCT_SECTION_FOREACH(ch, zbus_channel_list, &zbus_channel_list_head) {\n\t\tZBUS_STRUCT_SECTION_FOREACH_SAFE(obs_ch, &ch->observation_list_head, next_obs_ch) {\n\t\t\tif (obs_ch->observer == obs) {\n\t\t\t\tchan_update_hop(ch);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 19.27852025483111}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tZBUS_STRUCT_SECTION_FOREACH(struct zbus_channel, ch) {\n\t\tif (zbus_observer_is_equal(obs, &ch->observer)) {\n\t\t\tchan_update_hop(ch);\n\t\t}\n\t}\n}", "CodeBleu_score": 23.379781590598437}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tint ret = 0;\n\tif (k_is_in_isr()) {\n\t\t_ZBUS_ASSERT(0);\n\t\treturn -EPERM;\n\t}\n\tif (obs == NULL) {\n\t\t_ZBUS_ASSERT(0);\n\t\treturn -EINVAL;\n\t}\n\tk_spinlock_key_t key = k_spin_lock(&zbus_spinlock);\n\tobs->priority = ZBUS_THREAD_PRIORITY_MIN;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&zbus_spinlock, key);\n\treturn ret;\n}", "CodeBleu_score": 48.54152564247139}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tKASSERT(k_is_user_context(), _ZBUS_ASSERT);\n\tKASSERT(obs!= NULL, _ZBUS_ASSERT);\n\tif (k_is_in_isr()) {\n\t\treturn -EPERM;\n\t}\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\tobs->priority = k_thread_priority_get(k_current_get());\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&zbus_lock, key);\n\treturn 0;\n}", "CodeBleu_score": 49.34115372775084}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (k_is_in_isr()) {\n\t\t_ZBUS_ASSERT(false, \"zbus_obs_attach_to_thread() called from ISR\");\n\t\treturn -EPERM;\n\t}\n\n\tif (obs == NULL) {\n\t\t_ZBUS_ASSERT(false, \"zbus_obs_attach_to_thread() called with NULL observer\");\n\t\treturn -EINVAL;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_spinlock);\n\n\tobs->priority = k_thread_priority_get(k_current_get());\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&zbus_spinlock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 36.28765848405483}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tif (chan == NULL) {\n\t\t_ZBUS_ASSERT(false);\n\t\treturn ZBUS_ERR_NULL_CHAN;\n\t}\n\tif (k_is_in_isr()) {\n\t\tif (timeout == K_FOREVER) {\n\t\t\ttimeout = K_FOREVER;\n\t\t} else {\n\t\t\ttimeout += k_uptime_get();\n\t\t}\n\t}\n\tchan_lock(chan);\n\tif (chan->ctx.priority!= ZBUS_CHAN_PRIORITY_NONE) {\n\t\tchan_unlock(chan);\n\t\treturn ZBUS_ERR_CHAN_BUSY;\n\t}\n\tchan->ctx.priority = ZBUS_CHAN_PRIORITY_NOTIFY;\n\tchan->ctx.end_time = sys_timepoint_calc(timeout);\n\tchan_unlock(chan);\n\t_zbus_vded_exec();\n\tchan_lock(chan);\n\tint err = chan->ctx.err;\n\tchan->ctx.priority = ZBUS_CHAN_PRIORITY_NONE;\n\tchan_unlock(chan);\n\treturn err;\n}", "CodeBleu_score": 45.46949613623858}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err = 0;\n\n\tZBUS_ASSERT(chan!= NULL);\n\tif (k_is_in_isr()) {\n\t\ttimeout = sys_timepoint_calc(K_NO_WAIT, timeout);\n\t}\n\tchan_lock(chan);\n\terr = _zbus_vded_exec(chan, timeout);\n\tchan_unlock(chan);\n\treturn err;\n}", "CodeBleu_score": 34.124358682545996}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t// assert that the channel is not null\n\tZBUS_ASSERT(chan!= NULL);\n\n\t// if the channel is in an ISR, adjust the timeout\n\tif (k_is_in_isr()) {\n\t\ttimeout = sys_timepoint_calc(timeout);\n\t}\n\n\t// calculate the end time based on the timeout\n\tk_timeout_t end_time = k_uptime_get() + timeout;\n\n\t// initialize the context priority\n\tk_thread_priority_set(k_current_get(), chan->priority);\n\n\t// lock the channel\n\tchan_lock(chan);\n\n\t// execute the notification logic\n\tint err = chan_notify(chan, end_time);\n\n\t// unlock the channel\n\tchan_unlock(chan);\n\n\t// return any error encountered during the process\n\treturn err;\n}", "CodeBleu_score": 33.22594295262577}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (enable) {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->MAC_ITR |= ETH_MAC_ITR_NIE;\n\t\t}\n\t\tif (Int & IS_ETH_INT_ABNORMAL) {\n\t\t\tETH->MAC_ITR |= ETH_MAC_ITR_AIE;\n\t\t}\n\t} else {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->MAC_ITR &= ~ETH_MAC_ITR_NIE;\n\t\t}\n\t\tif (Int & IS_ETH_INT_ABNORMAL) {\n\t\t\tETH->MAC_ITR &= ~ETH_MAC_ITR_AIE;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.568579478131824}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT(Int));\n\tassert_param(IS_BOOL(enable));\n\tif (enable) {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->MAC_ITR |= Int;\n\t\t} else {\n\t\t\tETH->MAC_ITR |= Int << 16;\n\t\t}\n\t} else {\n\t\tif (Int & IS_ETH_INT_NORMAL) {\n\t\t\tETH->MAC_ITR &= ~Int;\n\t\t} else {\n\t\t\tETH->MAC_ITR &= ~(Int << 16);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.433090983007745}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT(Int));\n\tif (enable) {\n\t\tETH->ETH_IMR |= Int;\n\t} else {\n\t\tETH->ETH_IMR &= ~Int;\n\t}\n}", "CodeBleu_score": 23.910135389441024}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc;\n\tuint32_t reg_val;\n\tuint32_t reg_val_2;\n\tuint32_t reg_val_3;\n\tuint32_t reg_val_4;\n\tuint32_t reg_val_5;\n\tuint32_t reg_val_6;\n\tuint32_t reg_val_7;\n\tuint32_t reg_val_8;\n\tuint32_t reg_val_9;\n\tuint32_t reg_val_10;\n\tuint32_t reg_val_11;\n\tuint32_t reg_val_12;\n\tuint32_t reg_val_13;\n\tuint32_t reg_val_14;\n\tuint32_t reg_val_15;\n\tuint32_t reg_val_16;\n\tuint32_t reg_val_17;\n\tuint32_t reg_val_18;\n\tuint32_t reg_val_19;\n\tuint32_t reg_val_20;\n\tuint32_t reg_val_21;\n\tuint32_t reg_val_22;\n\tuint32_t reg_val_23;\n\tuint32_t reg_val_24;\n\tuint32_t reg_val_25;\n\tuint32_t reg_val_26;\n\tuint32_t reg_val_27;\n\tuint32_t reg_val_28;\n\tuint32_t reg_val_29;\n\tuint32_t reg_val_30;\n\tuint32_t reg_val_31;\n\tuint32_t reg_val_32;\n\tuint32_t reg_val_33;\n\tuint32_t reg_val_34;\n\tuint32_t reg_val_35;\n\tuint32_t reg_val_36;\n\tuint32_t reg", "CodeBleu_score": 4.674260102614677}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc;\n\tuint32_t temp;\n\tuint32_t i;\n\tuint32_t tx_desc_addr;\n\n\t/* Get the current transmit descriptor address */\n\ttx_desc_addr = ETH->DMATXDESC;\n\n\t/* Check if the descriptor is owned by the device */\n\tif ((ETH->DMATXDESC & ETH_DMATXDESC_OWN) == 0) {\n\t\t/* Get the descriptor */\n\t\ttx_desc = (ETH_TX_DESC *) tx_desc_addr;\n\n\t\t/* Check if the descriptor is owned by the device */\n\t\tif ((tx_desc->status & ETH_DMATXDESC_OWN) == 0) {\n\t\t\t/* Return the descriptor */\n\t\t\treturn tx_desc;\n\t\t}\n\t}\n\n\t/* Loop to the next descriptor */\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\t/* Check if the descriptor is owned by the device */\n\t\tif ((tx_desc_addr & ETH_DMATXDESC_OWN) == 0) {\n\t\t\t/* Get the descriptor */\n\t\t\ttx_desc = (ETH_TX_DESC *) tx_desc_addr;\n\n\t\t\t/* Check if the descriptor is owned by the device */\n\t\t\tif ((tx_desc->status & ETH_DMATXDESC_OWN) == 0) {\n\t\t\t\t/* Return the descriptor */\n\t\t\t\treturn tx_desc;\n\t\t\t}\n\t\t}\n\n\t\t/* Check if the descriptor is the last one */\n\t\tif (i == (ETH_TX_DESC_CNT - 1)) {\n\t\t\t/* Set the current transmit descriptor address to the start address */\n\t\t\tETH->DMATXDESC = ETH_TX_DESC_BASE;\n\t\t} else {\n\t\t\t/* Set the current transmit descriptor address to the next descriptor */\n\t\t\tETH->DMATXDESC = ETH->DMATXDESC + sizeof(ETH_TX_DESC);\n\t\t}\n\n\t\t/* Get the current transmit descriptor address */\n\t\ttx_desc_addr = ETH->DMATXDESC;\n\t}\n\n\t/* Return 0 */\n\treturn 0;\n}", "CodeBleu_score": 42.888113237912094}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *desc;\n\n\tdesc = (ETH_TX_DESC *) (ETH_TX_BASE + (ETH->DMATPDR & ETH_DMATPDR_TPDR));\n\n\twhile (desc->status & ETH_TX_DESC_OWN) {\n\t\tif (desc->status & ETH_TX_DESC_WRAP) {\n\t\t\tdesc = (ETH_TX_DESC *) ETH_TX_BASE;\n\t\t} else {\n\t\t\tdesc++;\n\t\t}\n\t}\n\n\treturn desc;\n}", "CodeBleu_score": 45.625705898129056}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tRT_ASSERT(device!= RT_NULL);\n\tCy_CSD_ADC_Init(device->parent.user_data, &cyp_adc_config);\n\tCy_CSD_ADC_Enable(device->parent.user_data);\n\tCy_CSD_ADC_SetOffset(device->parent.user_data, *value);\n\tCy_CSD_ADC_Start(device->parent.user_data);\n\treturn RT_EOK;\n}", "CodeBleu_score": 42.31165641087296}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\tCy_CSD_Type *csd = (Cy_CSD_Type *)device->parent.user_data;\n\tCy_CSDIDAC_Type *dac = Cy_CSD_GetCSDIDAC(csd);\n\tCy_CSDIDAC_Channel_Type *idac_ch = Cy_CSDIDAC_GetChannel(dac, channel);\n\n\tif (idac_ch!= NULL) {\n\t\tresult = Cy_CSDIDAC_OutputEnable(idac_ch, *value);\n\t\tif (result!= CY_CSDIDAC_STATUS_OK) {\n\t\t\tLOG_E(\"Failed to enable DAC channel %d\", channel);\n\t\t}\n\t} else {\n\t\tLOG_E(\"Failed to get DAC channel %d\", channel);\n\t\tresult = RT_ERROR;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 46.07167597591558}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tif (device == RT_NULL) {\n\t\tLOG_E(\"device is null\");\n\t\treturn RT_ERROR;\n\t}\n\n\t/* Get the DAC channel */\n\tcyp_dac_channel_t *dac_channel = cyp_dac_get_channel(device, channel);\n\tif (dac_channel == RT_NULL) {\n\t\tLOG_E(\"channel is null\");\n\t\treturn RT_ERROR;\n\t}\n\n\t/* Enable the DAC output */\n\tif (Cy_CSDIDAC_OutputEnable(dac_channel->base, dac_channel->channel, value)!= CY_CSDIDAC_STATUS_SUCCESS) {\n\t\tLOG_E(\"Cy_CSDIDAC_OutputEnable failed\");\n\t\treturn RT_ERROR;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 46.46658251598373}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif (addr + size > 0x1FFFF) {\n\t\trt_kprintf(\"ifx_flash_read_32k: address out of range\n\");\n\t\treturn -RT_ERROR;\n\t}\n\n\trt_uint32_t i;\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(volatile rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 40.69073205284085}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif (addr + size > FLASH_END_ADDRESS) {\n\t\trt_kprintf(\"ERROR: Read operation would exceed flash memory's end address.\n\");\n\t\treturn IFX_FLASH_ERR_INVALID_ARG;\n\t}\n\n\trt_uint32_t i;\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *) (addr + i);\n\t}\n\treturn size;\n}", "CodeBleu_score": 49.935486111630404}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif (addr + size > FLASH_END_ADDR) {\n\t\trt_kprintf(\"Error: Flash read exceeds end address!\n\");\n\t\treturn -RT_ERROR;\n\t}\n\trt_uint32_t i;\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *) (addr + i);\n\t}\n\treturn size;\n}", "CodeBleu_score": 45.42361638222498}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(cyhal_timer);\n}", "CodeBleu_score": 29.727987367272256}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(cyhal_timer);\n}", "CodeBleu_score": 29.727987367272256}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(cyhal_timer);\n}", "CodeBleu_score": 29.727987367272256}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\twhile (rt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER)!= RT_EOK) {\n\t\tRT_ASSERT(0);\n\t}\n}", "CodeBleu_score": 30.43110013992419}, {"code": "void dfs_lock(void){\n\t\twhile (rt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER)!= RT_EOK) {\n\t\tRT_ASSERT(0);\n\t}\n}", "CodeBleu_score": 30.43110013992419}, {"code": "void dfs_lock(void){\n\t\twhile (rt_mutex_take(&dfs_lock_mutex, RT_WAITING_FOREVER)!= RT_EOK)\n\t\tRT_ASSERT(0);\n}", "CodeBleu_score": 25.808753347524487}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint ret;\n\n\tfor (i = startfd; i < fdt->fd_max; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\tret = i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = fd_slot_expand(fdt);\n\tif (ret < 0) {\n\t\tgoto out;\n\t}\n\n\tfor (i = startfd; i < fdt->fd_max; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\tret = i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = -1;\n\nout:\n\treturn ret;\n}", "CodeBleu_score": 36.416829682460175}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint fd;\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\n\tfor (i = startfd; i < fdt->fd_count; i++) {\n\t\tif (fdt->fd_table[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (fd_slot_expand(fdt) == 0) {\n\t\tfd = fdt->fd_count;\n\t\tfdt->fd_count++;\n\t\treturn fd;\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 34.36021283538455}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint fd = -1;\n\n\tfor (i = startfd; i < fdt->maxfds; i++) {\n\t\tif (fdt->fds[i].fd == -1) {\n\t\t\tfd = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fd == -1) {\n\t\tfd = fd_slot_expand(fdt);\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 28.211653862477604}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\t// Convert error to positive value if it is negative\n\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\t// Iterate through array of known error strings\n\tfor (int i = 0; i < sizeof(error_strings) / sizeof(error_strings[0]); i++) {\n\t\t// If a match is found, return the corresponding error string\n\t\tif (error == error_strings[i].code) {\n\t\t\treturn error_strings[i].string;\n\t\t}\n\t}\n\n\t// If no match is found, return \"EUNKNOW\"\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 58.75145468509668}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tconst char *error_str;\n\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (error_str = rt_error_strings; *error_str!= '\\0'; error_str += strlen(error_str) + 1) {\n\t\tif (error == *((rt_err_t *) error_str)) {\n\t\t\treturn error_str + strlen(error_str) + 1;\n\t\t}\n\t}\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 44.67254122960498}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < NUM_KNOWN_ERRORS; i++) {\n\t\tif (known_errors[i].code == error) {\n\t\t\treturn known_errors[i].error_string;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 50.44963087511323}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (rt_thread_idle_hook_table[rt_thread_idle_hook_index]!= RT_NULL) {\n\t\tresult = -RT_EFULL;\n\t} else {\n\t\trt_thread_idle_hook_table[rt_thread_idle_hook_index] = hook;\n\t\tresult = RT_EOK;\n\t}\n\trt_hw_interrupt_enable(level);\n\treturn result;\n}", "CodeBleu_score": 27.12091318323334}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (rt_thread_idle_hook_list_num < RT_THREAD_IDLE_HOOK_LIST_NUM) {\n\t\trt_thread_idle_hook_list[rt_thread_idle_hook_list_num] = hook;\n\t\trt_thread_idle_hook_list_num++;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 25.83165803935706}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* Find an empty slot in the hook list */\n\tfor (int i = 0; i < RT_THREAD_IDLE_HOOK_SIZE; i++) {\n\t\tif (rt_thread_idle_hook_list[i] == RT_NULL) {\n\t\t\trt_thread_idle_hook_list[i] = hook;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If no empty slot is found, return an error code */\n\tif (result!= RT_EOK) {\n\t\tresult = -RT_EFULL;\n\t}\n\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 55.92803492278613}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_list_t *list;\n\trt_list_t *next;\n\trt_thread_idle_hook_t *idle_hook;\n\trt_thread_idle_hook_t *idle_hook_next;\n\n\tlevel = rt_hw_interrupt_disable();\n\tlist = &rt_thread_idle_hook_list;\n\tnext = list->next;\n\twhile (next!= list) {\n\t\tidle_hook = rt_list_entry(next, rt_thread_idle_hook_t, list);\n\t\tidle_hook_next = rt_list_entry(idle_hook->list.next, rt_thread_idle_hook_t, list);\n\t\tif (idle_hook->hook == hook) {\n\t\t\trt_list_remove(&idle_hook->list);\n\t\t\tidle_hook->hook = RT_NULL;\n\t\t\trt_hw_interrupt_enable(level);\n\t\t\treturn RT_EOK;\n\t\t}\n\t\tnext = idle_hook_next->list.next;\n\t}\n\trt_hw_interrupt_enable(level);\n\treturn -RT_ENOSYS;\n}", "CodeBleu_score": 37.02910670472651}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_list_t *list;\n\trt_list_t *node;\n\trt_list_t *next;\n\trt_thread_t *thread;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\tif (thread == RT_NULL)\n\t\treturn -RT_ENOSYS;\n\n\t/* get current thread idle hook list */\n\tlist = &thread->idle_hook_list;\n\n\t/* lock the spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* iterate through the list to find the specified hook */\n\trt_list_for_each_entry_safe(node, next, list, rt_list_t, rt_list_t) {\n\t\t/* if the specified hook is found */\n\t\tif (node->next == (rt_list_t *)hook) {\n\t\t\t/* set the corresponding entry to null */\n\t\t\tnode->next = RT_NULL;\n\t\t\t/* unlock the spinlock */\n\t\t\trt_hw_interrupt_enable(level);\n\t\t\t/* return success */\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* unlock the spinlock */\n\trt_hw_interrupt_enable(level);\n\t/* return error */\n\treturn -RT_ENOSYS;\n}", "CodeBleu_score": 28.97532157716202}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\trt_list_t *list;\n\n\tlevel = rt_hw_interrupt_disable();\n\tlist = &rt_thread_idle_list;\n\trt_list_foreach(list, list) {\n\t\trt_thread_idle_hook_t *idle_hook = rt_list_entry(list, rt_thread_idle_hook_t, list);\n\t\tif (idle_hook->hook == hook) {\n\t\t\tidle_hook->hook = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 23.817550625651222}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_base_t level;\n\trt_list_t *node;\n\trt_thread_t *thread;\n\trt_err_t ret = RT_EOK;\n\n\t/* Ensure the scheduler is unlocked */\n\trt_scheduler_unlock();\n\n\t/* Dequeue and wake up each suspended thread from the list */\n\twhile ((node = rt_list_dequeue(susp_list))!= RT_NULL) {\n\t\t/* Get the thread from the list node */\n\t\tthread = rt_list_entry(node, struct rt_thread, tlist);\n\n\t\t/* Set the thread error */\n\t\tthread->error = thread_error;\n\n\t\t/* Wake up the thread */\n\t\trt_thread_wakeup(thread);\n\n\t\t/* Lock the scheduler */\n\t\tlevel = rt_hw_interrupt_disable();\n\n\t\t/* Remove the thread from the suspension list */\n\t\trt_list_remove(&thread->tlist);\n\n\t\t/* Remove the thread from the ready list */\n\t\trt_list_remove(&thread->tlist);\n\n\t\t/* Restore the scheduler */\n\t\trt_hw_interrupt_enable(level);\n\t}\n\n\t/* Return the result */\n\treturn ret;\n}", "CodeBleu_score": 28.808955033666294}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_base_t level;\n\trt_thread_t *thread;\n\n\t/* Ensure the scheduler is unlocked */\n\trt_enter_critical(&level, RT_IPC_LOCK);\n\n\t/* Dequeue and wake up each thread from the list */\n\twhile (rt_list_isempty(susp_list) == 0) {\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\t\trt_thread_resume(thread);\n\t\trt_thread_error(thread, thread_error);\n\t\trt_list_remove(&thread->tlist);\n\t}\n\n\t/* Restore the scheduler lock */\n\trt_exit_critical(&level, RT_IPC_LOCK);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 40.11157133567204}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_base_t level;\n\trt_thread_t *thread;\n\n\t/*\n\t * Ensure the scheduler is unlocked, and then dequeue and wake up each suspended thread from the list one by one until the list is empty.\n\t */\n\tlevel = rt_hw_interrupt_disable();\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n\t\trt_list_remove(&thread->tlist);\n\t\trt_hw_interrupt_enable(level);\n\n\t\trt_thread_wakeup(thread);\n\t\trt_thread_delay(1);\n\n\t\tlevel = rt_hw_interrupt_disable();\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.39224673699408}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = rt_console_get_device();\n\trt_device_t new_console = rt_device_find(name);\n\tif (new_console!= old_console) {\n\t\tif (new_console!= RT_NULL) {\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\trt_console_set_device(new_console);\n\t\t\t\trt_device_close(new_console);\n\t\t\t}\n\t\t}\n\t}\n\treturn old_console;\n}", "CodeBleu_score": 48.78169547110344}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console;\n\n\t/* save the current console device */\n\told_console = rt_console_get_device();\n\n\t/* find the new console device */\n\tif ((rt_device_find(name)!= RT_NULL) && (rt_device_find(name)!= old_console)) {\n\t\t/* close the current console device if it exists */\n\t\tif (old_console!= RT_NULL) {\n\t\t\trt_device_close(old_console);\n\t\t}\n\n\t\t/* open the new console device with read/write and stream flags */\n\t\trt_device_open(rt_device_find(name), RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\n\t\t/* set the new console device as the current console device */\n\t\trt_console_set_device(rt_device_find(name));\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 42.99210473649282}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = rt_console_get_device();\n\trt_device_t new_console = rt_device_find(name);\n\n\tif (new_console!= RT_NULL && new_console!= old_console) {\n\t\tif (old_console!= RT_NULL) {\n\t\t\trt_device_close(old_console);\n\t\t}\n\n\t\trt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\n\t\trt_console_set_device(new_console);\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 45.02872913462831}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint length = 0;\n\tstruct rt_list_head *pos = NULL;\n\tstruct rt_object_information *object_information = NULL;\n\trt_spin_lock_irqsave(&rt_object_information_lock, flags);\n\trt_list_for_each(pos, &rt_object_information_list) {\n\t\tobject_information = rt_list_entry(pos, struct rt_object_information, list);\n\t\tif (object_information->type == type) {\n\t\t\tlength = object_information->length;\n\t\t\tbreak;\n\t\t}\n\t}\n\trt_spin_unlock_irqrestore(&rt_object_information_lock, flags);\n\treturn length;\n}", "CodeBleu_score": 44.40597936362467}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_information *info;\n\tint count = 0;\n\n\tinfo = rt_object_get_information(type);\n\tif (info == NULL)\n\t\treturn -1;\n\n\trt_spin_lock_irqsave(&info->lock, flags);\n\trt_list_for_each(info->list, cur) {\n\t\tcount++;\n\t}\n\trt_spin_unlock_irqrestore(&info->lock, flags);\n\n\treturn count;\n}", "CodeBleu_score": 37.53711417003882}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_list_head *pos;\n\tstruct rt_object_information *obj_info;\n\tint count = 0;\n\trt_spin_lock_irqsave(&rt_object_list_lock, rt_object_list_lock_flags);\n\trt_list_for_each(pos, &rt_object_list) {\n\t\tobj_info = rt_list_entry(pos, struct rt_object_information, list);\n\t\tif (obj_info->type == type) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trt_spin_unlock_irqrestore(&rt_object_list_lock, rt_object_list_lock_flags);\n\treturn count;\n}", "CodeBleu_score": 45.34212252006357}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\t/* call object hook */\n\tif (object->type!= RT_Object_Class_Type) {\n\t\tRT_OBJECT_HOOK_CALL(object, detach);\n\t}\n\t/* get object information */\n\trt_object_information_t info = (rt_object_information_t) object->parent.user_data;\n\t/* lock the spinlock */\n\trt_spin_lock_irqsave(&info->lock);\n\t/* remove the object from list */\n\trt_list_remove(&object->list_node);\n\t/* unlock the spinlock */\n\trt_spin_unlock_irqrestore(&info->lock);\n\t/* set object type to zero */\n\tobject->type = 0;\n}", "CodeBleu_score": 33.22601947672334}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\t/* call the hook function for detachment */\n\tRT_OBJECT_HOOK_CALL(object, detach);\n\t/* get the information of the object */\n\trt_object_information_t info = (rt_object_information_t) object;\n\t/* lock the spinlock of the object */\n\trt_spin_lock_irqsave(&info->lock);\n\t/* remove the object from the list */\n\trt_list_remove(&info->list);\n\t/* unlock the spinlock of the object */\n\trt_spin_unlock_irqrestore(&info->lock);\n\t/* set the type of the object to zero */\n\tinfo->type = RT_Object_Class_Type_None;\n}", "CodeBleu_score": 27.841706570608732}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\n\t/* call object detach hook */\n\tif (object->type & RT_OBJECT_FLAG_DETACHABLE) {\n\t\tRT_OBJECT_HOOK_CALL(object, detach);\n\t}\n\n\t/* get object information */\n\trt_object_information_t info = (rt_object_information_t)object;\n\n\t/* lock spinlock */\n\trt_spin_lock_irqsave(&info->spinlock);\n\n\t/* remove object from list */\n\trt_list_remove(&info->list);\n\n\t/* unlock spinlock */\n\trt_spin_unlock_irqrestore(&info->spinlock);\n\n\t/* set object type to 0 */\n\tobject->type = 0;\n}", "CodeBleu_score": 32.63610863758005}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result;\n\trt_custom_object_t cobj;\n\n\tif (obj == NULL) {\n\t\treturn RT_NULL_PTR;\n\t}\n\n\tcobj = (rt_custom_object_t) obj;\n\tif (cobj->class_type!= RT_CUSTOM_OBJECT) {\n\t\treturn RT_INVALID_OBJECT;\n\t}\n\n\tif (cobj->destroy!= NULL) {\n\t\tresult = cobj->destroy(obj);\n\t} else {\n\t\tresult = RT_SUCCESS;\n\t}\n\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 45.640163474557596}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t ret = RT_EOK;\n\trt_custom_object_t cobj = (rt_custom_object_t)obj;\n\n\tif (cobj->type!= RT_Object_Class_Type_Custom) {\n\t\treturn RT_ERROR;\n\t}\n\n\tif (cobj->destroy!= RT_NULL) {\n\t\tret = cobj->destroy(cobj);\n\t}\n\n\trt_object_delete(cobj);\n\n\treturn ret;\n}", "CodeBleu_score": 50.988818774319}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_custom_object_t cobj = RT_NULL;\n\trt_err_t result = RT_EOK;\n\n\t/* Check if the object is valid */\n\tif (rt_object_get_type(obj)!= RT_Object_Class_Custom) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/* Get the custom object */\n\tcobj = (rt_custom_object_t)obj;\n\n\t/* Check if the object has a destroy method */\n\tif (cobj->destroy!= RT_NULL) {\n\t\t/* Call the destroy method */\n\t\tresult = cobj->destroy(cobj);\n\t}\n\n\t/* Delete the object */\n\trt_object_delete(obj);\n\n\t/* Return the result of the destroy operation */\n\treturn result;\n}", "CodeBleu_score": 47.765426169415}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\trt_thread_t *thread;\n\trt_list_t *thread_list;\n\trt_list_t *next;\n\n\tthread = rt_thread_self();\n\tthread_list = &rt_thread_list;\n\n\trt_enter_critical();\n\n\t/* Remove the thread from the thread list */\n\trt_list_remove(thread_list, thread);\n\n\t/* Enqueue the thread to the defunct thread list */\n\trt_thread_defunct_enqueue(thread);\n\n\trt_exit_critical_safe();\n\n\trt_schedule();\n}", "CodeBleu_score": 37.51681532583528}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t *thread;\n\trt_thread_t *next;\n\n\tthread = rt_thread_self();\n\n\t/*\n\t * Enter critical section\n\t */\n\trt_enter_critical();\n\n\t/*\n\t * Close the thread\n\t */\n\trt_thread_close(thread);\n\n\t/*\n\t * Enqueue the thread to the defunct list\n\t */\n\tnext = thread->next;\n\trt_thread_defunct_enqueue(thread);\n\n\t/*\n\t * Exit critical section safely\n\t */\n\trt_exit_critical_safe();\n\n\t/*\n\t * Trigger a context switch to the next task\n\t */\n\trt_schedule(next);\n}", "CodeBleu_score": 62.22873474586231}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t *thread = rt_thread_self();\n\trt_enter_critical();\n\tthread->status = RT_THREAD_CLOSE;\n\trt_thread_close(thread);\n\trt_thread_defunct_enqueue(thread);\n\trt_exit_critical_safe();\n\trt_schedule();\n}", "CodeBleu_score": 57.21305867695242}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t *thread = (rt_thread_t *)parameter;\n\tRT_ASSERT(thread!= RT_NULL);\n\trt_sched_lock();\n\tif (thread->stat == RT_THREAD_SUSPENDED) {\n\t\tthread->error = -RT_ETIMEOUT;\n\t\trt_list_remove(&thread->tlist);\n\t\trt_list_insert_after(&rt_thread_ready_list, &thread->tlist);\n\t}\n\trt_sched_unlock_n_resched();\n}", "CodeBleu_score": 35.388619688411104}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t *thread = (rt_thread_t *)parameter;\n\tRT_ASSERT(thread!= RT_NULL);\n\n\trt_sched_lock();\n\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\trt_sched_unlock();\n\t\treturn;\n\t}\n\n\tthread->error = -RT_ETIMEOUT;\n\trt_list_remove(&thread->tlist);\n\trt_list_insert_after(&rt_thread_ready_list, &thread->tlist);\n\trt_sched_unlock_n_resched();\n}", "CodeBleu_score": 36.280499298946786}, {"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\n\tRT_ASSERT(parameter!= RT_NULL);\n\n\tthread = (struct rt_thread *) parameter;\n\n\trt_sched_lock();\n\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\trt_sched_unlock();\n\t\treturn;\n\t}\n\n\tthread->error = -RT_ETIMEOUT;\n\trt_list_remove(&thread->tlist);\n\trt_thread_ready(thread);\n\trt_sched_unlock_n_resched();\n}", "CodeBleu_score": 48.5814372003137}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spin_lock_irqsave(&thread->lock);\n\tif (thread->mutex) {\n\t\trt_list_t *node = rt_list_entry(thread->node.next, struct rt_thread, node);\n\t\trt_list_del(&thread->node);\n\t\trt_list_init(node);\n\t\tthread->mutex = RT_NULL;\n\t}\n\trt_spin_unlock_irqrestore(&thread->lock);\n}", "CodeBleu_score": 22.603072815834828}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_list_t *wait_list;\n\trt_object_t obj;\n\trt_mutex_t mutex;\n\trt_list_t *pos;\n\n\t/*\n\t * Lock the thread's spinlock\n\t */\n\trt_spin_lock_irqsave(&thread->lock);\n\n\t/*\n\t * Check if the thread is waiting on a mutex\n\t */\n\tif (thread->wait_obj!= RT_NULL) {\n\t\t/*\n\t\t * Remove the thread from the mutex's waiting list\n\t\t */\n\t\twait_list = thread->wait_obj->parent.wait_list;\n\t\trt_list_remove(wait_list, &thread->wait_node);\n\n\t\t/*\n\t\t * Clear the pending object\n\t\t */\n\t\tthread->wait_obj = RT_NULL;\n\t}\n\n\t/*\n\t * Release all mutexes the thread has taken\n\t */\n\trt_list_for_each_entry(pos, &thread->mutex_list, thread_list) {\n\t\t/*\n\t\t * Get the mutex from the mutex list\n\t\t */\n\t\tmutex = rt_list_entry(pos, rt_mutex_t, thread_list);\n\n\t\t/*\n\t\t * Remove the mutex from the thread's mutex list\n\t\t */\n\t\trt_list_remove(&thread->mutex_list, pos);\n\n\t\t/*\n\t\t * Clear the mutex's pending object\n\t\t */\n\t\tmutex->owner = RT_NULL;\n\t}\n\n\t/*\n\t * Restore the thread's spinlock state\n\t */\n\trt_spin_unlock_irqrestore(&thread->lock);\n}", "CodeBleu_score": 45.397485314996366}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_list_t *node;\n\trt_list_t *n;\n\trt_list_t *p;\n\trt_mutex_t mutex;\n\n\trt_spin_lock_irqsave(&thread->lock);\n\tnode = rt_list_entry(thread->node.next, struct rt_thread, node);\n\trt_list_remove(&thread->node);\n\trt_spin_unlock_irqrestore(&thread->lock);\n\n\tif (node!= RT_NULL) {\n\t\trt_mutex_t mutex = rt_list_entry(node, struct rt_mutex, node);\n\n\t\trt_mutex_release(mutex);\n\t}\n\n\trt_spin_lock_irqsave(&thread->lock);\n\trt_list_for_each_entry_safe(node, n, &thread->taken, struct rt_mutex, node) {\n\t\tmutex = rt_list_entry(node, struct rt_mutex, node);\n\t\trt_list_remove(&mutex->node);\n\t\trt_spin_unlock_irqrestore(&thread->lock);\n\t\trt_mutex_drop_thread(mutex);\n\t\trt_spin_lock_irqsave(&thread->lock);\n\t}\n\trt_spin_unlock_irqrestore(&thread->lock);\n}", "CodeBleu_score": 53.01464081305694}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->init_flag == RT_THREAD_INIT_FLAG);\n\tRT_ASSERT(thread->type == RT_Object_Class_Thread);\n\n\t/* log thread name and priority */\n\tLOG_D(\"thread %s priority = %d\", thread->name, thread->current_priority);\n\n\t/* calculate priority attributes */\n\trt_thread_priority_to_tick(thread);\n\n\t/* reset thread state */\n\tthread->state = RT_THREAD_SUSPEND;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* trigger scheduler if available */\n\tif (rt_thread_self()->system_thread!= RT_NULL) {\n\t\trt_schedule();\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 52.41156079843644}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->init_flag == RT_THREAD_INIT_FLAG);\n\tRT_ASSERT(thread->type == RT_Thread);\n\tLOG_D(\"start thread %s, priority %d\", thread->name, thread->current_priority);\n\trt_sched_thread_startup(thread);\n\trt_thread_resume(thread);\n\tif (rt_thread_self()->system_thread!= RT_NULL) {\n\t\trt_schedule();\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 51.91522946904382}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->init_flag == RT_THREAD_INIT_FLAG);\n\tRT_ASSERT(thread->type == RT_Thread);\n\n\trt_object_log_info(\"thread\", thread->name, thread->priority, thread->stack_size);\n\n\trt_sched_thread_startup(thread);\n\n\trt_thread_resume(thread);\n\n\tif (rt_thread_self()->system_thread == RT_FALSE) {\n\t\trt_schedule();\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 50.44007755492104}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_list_head;\n\trt_tick_t timeout;\n\trt_list_t *timer_entry;\n\trt_list_t *timer_entry_next;\n\trt_list_t *timer_entry_prev;\n\n\ttimer_list_head = &timer_list[0];\n\tif (rt_list_isempty(timer_list_head)!= RT_EOK) {\n\t\treturn RT_ERROR;\n\t}\n\n\ttimer_entry = rt_list_entry(timer_list_head->next, struct rt_timer, list);\n\ttimeout = timer_entry->timeout;\n\t*timeout_tick = timeout;\n\n\ttimer_entry_next = timer_entry->next;\n\ttimer_entry_prev = timer_entry->prev;\n\trt_list_remove(timer_entry);\n\trt_list_init(timer_entry);\n\trt_list_insert_after(timer_list_head, timer_entry);\n\n\twhile (timer_entry_next!= timer_list_head) {\n\t\ttimer_entry = rt_list_entry(timer_entry_next, struct rt_timer, list);\n\t\tif (timer_entry->timeout < timeout) {\n\t\t\ttimeout = timer_entry->timeout;\n\t\t\t*timeout_tick = timeout;\n\t\t}\n\t\ttimer_entry_next = timer_entry_next->next;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 35.91707239454358}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *head_list = &timer_list[0];\n\trt_list_t *timer_entry;\n\trt_tick_t timeout;\n\n\tif (rt_list_isempty(head_list)) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\ttimer_entry = rt_list_entry(head_list->next, struct rt_timer, list);\n\ttimeout = timer_entry->timeout;\n\n\tif (timeout_tick!= RT_NULL) {\n\t\t*timeout_tick = timeout;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 42.9876055164786}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_entry;\n\trt_list_t *timer_list_head;\n\n\t/* get the highest level of the timer skip list */\n\ttimer_list_head = &timer_list[RT_TIMER_SKIP_LIST_MAX_LEVEL - 1];\n\n\t/* check if the highest level of the timer skip list is not empty */\n\tif (rt_list_isempty(timer_list_head)) {\n\t\t/* return an error code if the list is empty */\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get the first timer entry */\n\ttimer_entry = rt_list_entry(timer_list_head->next, struct rt_timer, timer_list);\n\n\t/* set the provided timeout tick to the timer's timeout value */\n\t*timeout_tick = timer_entry->timeout;\n\n\t/* return RT_EOK */\n\treturn RT_EOK;\n}", "CodeBleu_score": 43.87030988727603}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\ttimer = rt_object_allocate(RT_Timer, name, RT_NULL);\n\tif (timer!= RT_NULL) {\n\t\ttimer->flag = flag;\n\t\ttimer->init_tick = time;\n\t\ttimer->timeout_func = timeout;\n\t\ttimer->parameter = parameter;\n\t\t_timer_init(timer);\n\t}\n\treturn timer;\n}", "CodeBleu_score": 49.24875677053347}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer = RT_NULL;\n\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\n\ttimer = (rt_timer_t) rt_object_allocate(&rt_timer_class);\n\tif (timer!= RT_NULL) {\n\t\trt_object_init(timer, RT_Timer, name, 0);\n\t\ttimer->flag = flag;\n\t\ttimer->timeout = timeout;\n\t\ttimer->parameter = parameter;\n\t\ttimer->init_tick = rt_tick_get();\n\t\ttimer->time = time;\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 48.288008455114976}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time >= RT_TIMER_MIN_TIME);\n\tRT_ASSERT(time <= RT_TIMER_MAX_TIME);\n\ttimer = (rt_timer_t) rt_object_allocate(RT_Timer, name);\n\tif (timer!= RT_NULL) {\n\t\trt_timer_init(timer, timeout, parameter, time, flag);\n\t}\n\treturn timer;\n}", "CodeBleu_score": 58.32168204125517}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 10.654331898169428}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\thandler := http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\trec.Header = res.Header()\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t})\n\ta.router.ServeHTTP(rec, req)\n\tres.Header = rec.Header\n\thandler = http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\trec.Header = res.Header()\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t})\n\ta.router.ServeHTTP(rec, req)\n\tres.Header = rec.Header\n\thandler = http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\trec.Header = res.Header()\n\t\thttp.Error(res, \"Internal Server Error\", http.StatusInternalServerError)\n\t})\n\ta.router.ServeHTTP(rec, req)\n\tres.Header = rec.Header\n\thandler = http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\trec.Header = res.Header()\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t})\n\ta.router.ServeHTTP(rec, req)\n\tres.Header = rec.Header\n\thandler = http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\trec.Header = res.Header()\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t})\n\ta.router.ServeHTTP(rec, req)\n\tres.Header = rec.Header\n\thandler = http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\trec.Header = res.Header()\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t})\n\ta.router.ServeHTTP(rec, req)\n\tres.Header = rec.Header\n\thandler = http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\trec.Header = res.Header()\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t})\n\ta.router.Serve", "CodeBleu_score": 37.93155797208914}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a recorder to capture the response.\n\trec := httptest.NewRecorder()\n\n\t// Create a handler chain.\n\thandler := http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\t// The handler chain is a series of handlers that are executed sequentially.\n\t\t// For each handler, it captures the response using a recorder and copies the recorder's headers to the original response.\n\t\t// If any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\n\t\t// If all handlers pass without unauthorized status, it forwards the request to the router for further handling.\n\t\tfor _, h := range a.handlerChain {\n\t\t\th.ServeHTTP(rec, req)\n\n\t\t\t// Copy the recorder's headers to the original response.\n\t\t\tfor k, v := range rec.Header() {\n\t\t\t\tres.Header()[k] = v\n\t\t\t}\n\n\t\t\t// If the handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\n\t\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Forward the request to the router for further handling.\n\t\ta.router.ServeHTTP(res, req)\n\t})\n\n\t// Serve the request using the handler chain.\n\thandler.ServeHTTP(res, req)\n}", "CodeBleu_score": 69.24459391143958}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tasset, err := a.assets.Open(path)\n\tif err!= nil {\n\t\thttp.Error(res, \"404 not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer asset.Close()\n\n\tres.Header().Set(\"Content-Type\", mime.TypeByExtension(filepath.Ext(path)))\n\tif _, err := io.Copy(res, asset); err!= nil {\n\t\tpanic(err)\n\t}\n}", "CodeBleu_score": 46.310728257802964}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tasset := a.Asset(path)\n\tif asset == nil {\n\t\thttp.Error(res, \"Not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", asset.ContentType)\n\tres.Write(asset.Data)\n}", "CodeBleu_score": 29.14864595815955}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Retrieve the requested asset based on the URL path.\n\tasset, err := a.asset(req.URL.Path)\n\tif err!= nil {\n\t\t// If the asset is not found, return a 404 error.\n\t\thttp.Error(res, \"Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the Content-Type header based on the file extension.\n\tres.Header().Set(\"Content-Type\", http.DetectContentType(asset))\n\n\t// Write the asset content to the response.\n\tres.Write(asset)\n}", "CodeBleu_score": 32.86762960133029}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := req.URL.Query().Get(\"robot\")\n\n\t// Find the robot with the specified name\n\trobot, err := a.master.Find(robotName)\n\tif err!= nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\ta.writeJSON(res, http.StatusNotFound, gobot.JSONError{Message: \"Robot not found\"})\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections := make([]gobot.JSONConnection, len(connections))\n\tfor i, connection := range connections {\n\t\tjsonConnections[i] = connection.JSON()\n\t}\n\n\t// Write the JSON response containing the connections\n\ta.writeJSON(res, http.StatusOK, jsonConnections)\n}", "CodeBleu_score": 49.21189227444001}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\tname := req.URL.Query().Get(\"name\")\n\n\t// Find the specified robot using the master instance\n\trobot, ok := a.master.Robot(name)\n\tif!ok {\n\t\t// If the robot is not found, write a JSON error message\n\t\ta.writeJSON(res, map[string]string{\"error\": \"No robot found with name \" + name})\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections := make([]map[string]string, len(connections))\n\tfor i, connection := range connections {\n\t\tjsonConnections[i] = map[string]string{\n\t\t\t\"name\": connection.Name(),\n\t\t\t\"type\": connection.Type(),\n\t\t}\n\t}\n\n\t// Write the JSON response containing the connections\n\ta.writeJSON(res, jsonConnections)\n}", "CodeBleu_score": 49.5880650397067}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := req.URL.Query().Get(\"name\")\n\n\t// Find the robot with the specified name using the master instance\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"error\": \"No robot found with the specified name\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections := make([]map[string]interface{}, len(connections))\n\tfor i, connection := range connections {\n\t\tjsonConnections[i] = map[string]interface{}{\n\t\t\t\"name\":   connection.Name(),\n\t\t\t\"driver\": connection.Driver().Name(),\n\t\t}\n\t}\n\n\t// Write the JSON response containing the connections\n\ta.writeJSON(res, map[string]interface{}{\n\t\t\"connections\": jsonConnections,\n\t})\n}", "CodeBleu_score": 52.700006074626096}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Basic Authentication credentials\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the credentials\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\t// Check if the credentials are valid\n\t\tif len(pair) == 2 && pair[0] == username && pair[1] == password {\n\t\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\t\tw.Write([]byte(\"You are authenticated!\"))\n\t\t} else {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t}\n\t}\n}", "CodeBleu_score": 53.34084269430884}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s)!= 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), 401)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair)!= 2 {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\n\t\tif pair[0]!= username || pair[1]!= password {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 48.86326615827456}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\t// Get the Basic Authentication credentials\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the credentials\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\t// Compare the credentials\n\t\tif subtle.ConstantTimeCompare([]byte(pair[0]), []byte(username)) == 1 && subtle.ConstantTimeCompare([]byte(pair[1]), []byte(password)) == 1 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Set the response\n\t\tw.Write([]byte(\"Authorized\"))\n\t}\n}", "CodeBleu_score": 50.27353254749558}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept for the scaling transformation\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - (slope * fromMin)\n\n\t// Create the scaling function\n\treturn func(input float64) (value int) {\n\t\t// Perform the scaling transformation\n\t\tscaledValue := slope*input + intercept\n\n\t\t// Clamp the output value within the target range\n\t\tif scaledValue < toMin {\n\t\t\tvalue = toMin\n\t\t} else if scaledValue > toMax {\n\t\t\tvalue = toMax\n\t\t} else {\n\t\t\tvalue = int(scaledValue)\n\t\t}\n\n\t\treturn value\n\t}\n}", "CodeBleu_score": 51.570898608952675}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 52.82819711238594}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.980882267028065}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"invalid connection\")\n\t}\n\tif!a.Connection().AnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\traw, err := a.Connection().AnalogReadPin(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := a.scale(raw)\n\ta.mutex.Lock()\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\ta.mutex.Unlock()\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 47.70749016127019}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection() == nil {\n\t\treturn 0, 0, errors.New(\"invalid connection\")\n\t}\n\tif!a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\traw, err := reader.AnalogRead(a.Connection(), a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := raw * a.sensorCfg.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 48.841269390297896}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"invalid connection\")\n\t}\n\n\tif!a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.mutex.Lock()\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\ta.mutex.Unlock()\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 47.57894706641867}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax-fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(val int) float64 {\n\t\treturn m*float64(val) + n\n\t}\n}", "CodeBleu_score": 53.02809011992156}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMax - m*fromMax\n\treturn func(value int) float64 {\n\t\treturn m*float64(value) + n\n\t}\n}", "CodeBleu_score": 42.645635706854925}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(value int) float64 {\n\t\treturn (float64(value)-fromMin)*(toMax-toMin)/(fromMax-fromMin) + toMin\n\t}\n}", "CodeBleu_score": 25.95054833359819}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.Name = DefaultName\n\td.AddEvent(Vibration)\n\td.On(Data, func(e interface{}) {\n\t\tdata := e.(Data)\n\t\tif data.Value > 1000 {\n\t\t\td.Publish(Vibration, data)\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 25.939597564088313}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(DefaultName)\n\td.AddEvent(VibrationEvent)\n\tgo func() {\n\t\tfor {\n\t\t\tdata, err := d.Read()\n\t\t\tif err!= nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tif data > 1000 {\n\t\t\t\td.Publish(VibrationEvent, struct{}{})\n\t\t\t}\n\t\t}\n\t}()\n\treturn d\n}", "CodeBleu_score": 45.01861615908848}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(\"GrovePiezoVibrationSensorDriver\")\n\td.AddEvent(\"vibration\", events.NewEvent())\n\td.AddEvent(\"vibration\", events.NewEvent())\n\td.On(events.Data, func(e events.Event) {\n\t\tif e.GetData().(int) > 1000 {\n\t\t\td.Publish(\"vibration\", e.GetData())\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 27.74823283509934}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\treturn nil\n}", "CodeBleu_score": 2.647339885480281}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\treturn nil\n}", "CodeBleu_score": 2.647339885480281}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn errors.New(\"invalid frequency\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"invalid duration\")\n\t}\n\n\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm)\n\ttonePeriod := time.Duration(1000000000/hz) * time.Nanosecond\n\ttempo := time.Duration(60000000000/duration) * time.Nanosecond\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo\n\tfor {\n\t\td.On()\n\t\ttime.Sleep(tonePeriod)\n\t\td.Off()\n\t\ttime.Sleep(tonePeriod)\n\n\t\tif tempo <= 0 {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(tempo)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 32.04488088089019}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"Sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.537917668950026}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"Sleep pin not configured\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.759406856756932}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"Sleep pin not set\")\n\t}\n\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.537917668950026}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, NewError(\"AnalogPinsAdaptor\", \"Pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin, err := a.sys.NewAnalogPin(path, params)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 51.65508138784667}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor.Pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 53.945054060737405}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 54.13710144823063}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 60.39754526414518}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\ta.digitalPin, err := a.system.WithPinDirectionOutput(a.digitalPin, id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\ta.digitalPin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 55.45315719743884}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 60.39754526414518}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.Connected() {\n\t\treturn nil, errors.New(\"digitalPin: adaptor is not connected\")\n\t}\n\tif len(a.Pins) == 0 {\n\t\treturn nil, errors.New(\"digitalPin: no pins available\")\n\t}\n\tpin, err := a.Pins[id]\n\tif err!= nil {\n\t\tpin, err = a.NewDigitalPin(id, opts...)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.Pins[id] = pin\n\t} else {\n\t\tpin.ApplyOptions(opts...)\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 40.8255021465533}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.connected {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor not connected\")\n\t}\n\tif len(a.Pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor has no pins\")\n\t}\n\tpin, ok := a.Pins[id]\n\tif!ok {\n\t\tpin = gobot.NewDigitalPin(id)\n\t\ta.Pins[id] = pin\n\t}\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\tif err := pin.ApplyOptions(); err!= nil {\n\t\treturn nil, err\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 38.498443074151446}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.connected {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor is not connected to any pins\")\n\t}\n\n\tif len(a.Pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor has no pins\")\n\t}\n\n\tvar pin gobot.DigitalPinner\n\tvar ok bool\n\n\tif pin, ok = a.Pins[id];!ok {\n\t\tvar err error\n\t\tpin, err = a.NewDigitalPin(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.Pins[id] = pin\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 40.41312445723817}]}
