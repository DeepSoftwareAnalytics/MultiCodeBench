{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> requiredFiles;\n\tstd::vector<std::string> files = _pimpl->GetFiles(folder);\n\tfor (const std::string &file : files) {\n\t\tif (download) {\n\t\t\tif (!_pimpl->FileExists(file)) {\n\t\t\t\t_pimpl->RequestFile(file);\n\t\t\t\tlog_info(\"Requested file: \" + file);\n\t\t\t} else {\n\t\t\t\tlog_info(\"File found in cache: \" + file);\n\t\t\t}\n\t\t}\n\t\trequiredFiles.push_back(file);\n\t}\n\treturn requiredFiles;\n}", "CodeBleu_score": 46.14951560359416}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> requiredFiles;\n\tstd::vector<std::string> files = _pimpl->GetFilesInFolder(folder);\n\n\tfor (const auto &file : files) {\n\t\tif (download) {\n\t\t\tif (!FileExists(file)) {\n\t\t\t\tlog_info(\"File %s does not exist. Requesting file...\", file.c_str());\n\t\t\t\tRequestFile(file);\n\t\t\t} else {\n\t\t\t\tlog_info(\"File %s found in cache\", file.c_str());\n\t\t\t}\n\t\t}\n\t\trequiredFiles.push_back(file);\n\t}\n\n\treturn requiredFiles;\n}", "CodeBleu_score": 48.84829852949244}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> required_files;\n\tstd::vector<std::string> files;\n\tstd::vector<std::string> dirs;\n\t// Get the list of files and directories in the specified folder.\n\t_pimpl->CallAndWait<std::vector<std::string>>([&] {\n\t\treturn _pimpl->GetFilesAndDirectories(folder, files, dirs);\n\t});\n\t// If the download flag is set to true, check if each file exists locally.\n\tif (download) {\n\t\tfor (const auto &file : files) {\n\t\t\tif (!_pimpl->FileExists(folder + \"/\" + file)) {\n\t\t\t\t// If the file is not found, request the file.\n\t\t\t\t_pimpl->CallAndWait<void>([&] {\n\t\t\t\t\t_pimpl->RequestFile(folder + \"/\" + file);\n\t\t\t\t});\n\t\t\t\t// Log the download action.\n\t\t\t\tlog_info(\"File \" + folder + \"/\" + file + \" downloaded.\");\n\t\t\t} else {\n\t\t\t\t// If the file exists, log that the file is found in the cache.\n\t\t\t\tlog_info(\"File \" + folder + \"/\" + file + \" found in cache.\");\n\t\t\t}\n\t\t\t// Add the file to the list of required files.\n\t\t\trequired_files.push_back(file);\n\t\t}\n\t} else {\n\t\t// If the download flag is set to false, add all files to the list of required files.\n\t\tfor (const auto &file : files) {\n\t\t\trequired_files.push_back(file);\n\t\t}\n\t}\n\treturn required_files;\n}", "CodeBleu_score": 49.884321424582595}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n/*\n * This function, Client::SpawnActorWithParent, spawns an actor with a specified parent using the provided description, transform, parent ID, attachment type, and socket name.", "CodeBleu_score": 19.986618305810786}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t}", "CodeBleu_score": 8.495909444103484}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n/*\n * This function, Client::SpawnActorWithParent, spawns an actor with a specified parent using the provided description, transform, parent ID, attachment type, and socket name.", "CodeBleu_score": 19.986618305810786}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\t_pimpl->SubscribeToGBuffer(ActorId, GBufferId, std::move(callback));\n}", "CodeBleu_score": 25.576485280749374}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n_pimpl->streaming_client.Subscribe", "CodeBleu_score": 9.186022249643454}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t_pimpl->streaming_client.Subscribe(\n_pimpl->CallAndWait<std::vector<unsigned char>>(\n[=]() {\nreturn _pimpl->streaming_client.GetGBufferToken(ActorId, GBufferId);\n}),\n[=](std::vector<unsigned char> token_data) {\nstd::vector<unsigned char> token_data_copy(token_data.size());\nstd::memcpy(token_data_copy.data(), token_data.data(), token_data.size());\n_pimpl->streaming_client.Subscribe(\ntoken_data_copy,\n[=](Buffer buffer) {\ncallback(std::move(buffer));\n});\n});\n}", "CodeBleu_score": 56.496142575418396}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load(std::memory_order_relaxed);\n\twhile (navigation == nullptr) {\n\t\tstd::shared_ptr<WalkerNavigation> new_navigation = std::make_shared<WalkerNavigation>();\n\t\tif (_walker_navigation.compare_exchange_strong(navigation, new_navigation, std::memory_order_acq_rel, std::memory_order_relaxed)) {\n\t\t\tnavigation = new_navigation;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 49.05749695621846}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\t// This function, Episode::CreateNavigationIfMissing, ensures a WalkerNavigation object is created if it does not already exist.", "CodeBleu_score": 8.428742025583745}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (_walker_navigation == nullptr) {\n\t\t_walker_navigation = std::make_shared<WalkerNavigation>();\n\t\t_walker_navigation->SetEpisode(shared_from_this());\n\t}\n\treturn _walker_navigation;\n}", "CodeBleu_score": 34.24376885834035}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (episode.GetState()->GetTimestamp() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (std::chrono::system_clock::now() > timeout.to_chrono()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tepisode.GetTrafficManager()->Tick();\n\treturn true;\n}", "CodeBleu_score": 26.76893771773986}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tif (episode.GetState()->GetTimestamp() < frame) {\n\t\tstd::this_thread::yield();\n\t\treturn SynchronizeFrame(frame, episode, timeout);\n\t}\n\tif (episode.GetTrafficManager().Tick(std::chrono::duration_cast<std::chrono::milliseconds>(timeout.to_chrono()))) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.92828647810672}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = std::chrono::system_clock::now();\n\twhile (episode.GetState()->GetTimestamp() < frame) {\n\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - start) > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.GetTrafficManager().Tick();\n\treturn true;\n}", "CodeBleu_score": 45.579620190682014}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\t// TODO: implement\n\t// throw std::runtime_error(\"Not implemented\");\n\treturn EpisodeProxy();\n}", "CodeBleu_score": 6.700878717706963}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\t// TODO: implement\n\treturn EpisodeProxy();\n}", "CodeBleu_score": 6.700878717706963}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tauto episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\tauto episode_id = episode.GetId();\n\tauto timeout = _client.GetTimeout();\n\twhile (true) {\n\t\tauto current_episode = GetCurrentEpisode();\n\t\tif (current_episode.GetId()!= episode_id) {\n\t\t\tthrow std::runtime_error(\"Episode ID changed during loading.\");\n\t\t}\n\t\tepisode = current_episode;\n\t\tif (episode.WaitForState(EpisodeState::RUNNING, timeout)) {\n\t\t\treturn episode;\n\t\t}\n\t}\n}", "CodeBleu_score": 47.3495610810698}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// get the walker associated with the controller\n\tauto walker = GetWalker(controller.GetDisplayId());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Simulator::RegisterAIController: Walker not found.\");\n\t}\n\n\t// assert that the episode is not null\n\tDEBUG_ASSERT(_episode!= nullptr);\n\n\t// create navigation if it is missing\n\t_episode->CreateNavigationIfMissing();\n\n\t// register the walker with the controller's ID\n\t_episode->GetNavigation()->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 57.3409413500253}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tDEBUG_ASSERT(_episode!= nullptr)\n\tDEBUG_ASSERT(controller.GetDisplayId()!= nullptr)\n\tDEBUG_ASSERT(controller.GetId()!= nullptr)\n\tDEBUG_ASSERT(controller.GetParent()!= nullptr)\n\tDEBUG_ASSERT(controller.GetParent()->GetId()!= nullptr)\n\n\tWalker *walker = _episode->GetWalker(controller.GetDisplayId());\n\tDEBUG_ASSERT(walker!= nullptr)\n\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\n\tDEBUG_ASSERT(walker->GetId()!= nullptr)\n\tDEBUG_ASSERT(walker->GetParent()!= nullptr)\n\tDEBUG_ASSERT(walker->GetParent()->GetId()!= nullptr)\n\n\t_episode->CreateNavigationIfMissing(walker);\n\tNavigation *nav = walker->GetNavigation();\n\tDEBUG_ASSERT(nav!= nullptr)\n\n\tnav->RegisterWalker(controller.GetId());\n}", "CodeBleu_score": 52.23269695861934}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (_episode == nullptr) {\n\t\tthrow std::runtime_error(\"Episode is null\");\n\t}\n\tif (_episode->GetWalker(controller.GetDisplayId()) == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\tauto nav = _episode->CreateNavigationIfMissing(controller.GetId());\n\tnav->RegisterWalker(controller.GetDisplayId());\n}", "CodeBleu_score": 57.2278146886936}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n_episode->RegisterActor", "CodeBleu_score": 9.313446243714901}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tSharedPtr<Actor> actor = ActorFactory::MakeActor(blueprint, transform, parent, attachment_type, socket_name);\n\tactor->SetGarbageCollectionPolicy(gc);\n\t_client.SpawnActor(actor);\n\t_episode->RegisterActor(actor);\n\tlog_debug(\"Spawned actor {} (id {}) with parent {} (id {})\", actor->GetName(), actor->GetId(), parent? parent->GetName() : \"None\", parent? parent->GetId() : -1);\n\treturn actor;\n}", "CodeBleu_score": 37.69367194797468}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tSharedPtr<Actor> actor = _client.SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n\t_episode->RegisterActor(actor);\n\tactor->SetGarbageCollectionPolicy(gc);\n\tlog_debug(\"Spawned actor {} with transform {} and parent {} with attachment type {} and socket name {}.\", actor->GetId(), transform, parent? parent->GetId() : \"null\", attachment_type, socket_name);\n\treturn actor;\n}", "CodeBleu_score": 38.105901545853605}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t//  if (!episode_ ||!episode_->IsValid()) {", "CodeBleu_score": 10.0429275623611}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n/*\n * This function, Simulator::SubscribeToSensor, subscribes to a sensor's data stream and sets up a callback to handle the incoming sensor data.\n * It first ensures that the episode is valid, then subscribes to the sensor's data stream using the client's SubscribeToStream method.\n * The callback is set to deserialize the incoming data, associate it with the current episode, and then invoke the provided callback with the sensor data.\n */\n  if (episode_ == nullptr) {\n    throw std::runtime_error(\"Episode not started\");\n  }\n\n  auto cb = [this, callback](const sensor::SensorData &data) {\n    auto sensor_data = std::make_shared<sensor::SensorData>(data);\n    sensor_data->SetEpisode(episode_);\n    callback(sensor_data);\n  };\n\n  auto token = client_->SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      cb);\n\n  auto sensor_data_deserializer = std::make_shared<sensor::Deserializer>(token);\n  sensor_data_deserializers_.emplace(token, sensor_data_deserializer);\n}", "CodeBleu_score": 49.2722692451726}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t/*\n * This function, Simulator::SubscribeToSensor, subscribes to a sensor's data stream and sets up a callback to handle the incoming sensor data.", "CodeBleu_score": 15.355771274503288}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// Load walkers from episode\n\tstd::vector<Walker> walkers = episode->GetWalkers();\n\t// Return if walkers list is empty\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get current state of episode\n\tstd::shared_ptr<State> state = episode->GetState();\n\t// Remove walkers that no longer exist\n\tCheckIfWalkerExist(walkers, state);\n\n\t// Update vehicles in crowd and crowd itself\n\tUpdateVehiclesInCrowd(walkers);\n\t_nav.UpdateCrowd();\n\n\t// Apply states to simulator\n\tstd::vector<std::shared_ptr<WalkerCommand>> commands;\n\tcommands.reserve(walkers.size());\n\tfor (auto& walker : walkers) {\n\t\t// Get walker transform and speed\n\t\tTransform walkerTransform = _nav.GetWalkerTransform(walker.id);\n\t\tfloat walkerSpeed = _nav.GetWalkerSpeed(walker.id);\n\n\t\t// Apply states in batch\n\t\tcommands.emplace_back(std::make_shared<WalkerCommand>(\n\t\t\twalker.id,\n\t\t\twalkerTransform,\n\t\t\twalkerSpeed,\n\t\t\twalker.is_alive\n\t\t));\n\t}\n\t_simulator.lock()->ApplyBatchSync(commands);\n\n\t// Check if any walker has been killed\n\tfor (auto& walker : walkers) {\n\t\t// Check if walker is dead\n\t\tif (!walker.is_alive) {\n\t\t\t// Remove walker from crowd\n\t\t\t_nav.RemoveAgent(walker.id);\n\t\t\t// Destroy walker controller\n\t\t\tUnregisterWalker(walker.id);\n\t\t}\n\t}\n}", "CodeBleu_score": 40.12005373005513}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// Load the walkers\n\tstd::vector<Walker> walkers = _nav.GetWalkers();\n\n\t// Check if there are no walkers\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get the current state\n\tState state = episode->GetState();\n\n\t// Remove any walkers that no longer exist\n\tRemoveDeadWalkers(walkers, state);\n\n\t// Update the vehicles in the crowd\n\tUpdateVehiclesInCrowd(walkers, state);\n\n\t// Update the crowd\n\t_nav.UpdateCrowd();\n\n\t// Create a vector of commands to be applied to the simulator\n\tstd::vector<std::pair<std::string, std::string>> commands;\n\n\t// For each walker, get their transform and speed, then apply these states in a batch to the simulator\n\tfor (auto walker : walkers) {\n\t\tcommands.emplace_back(_nav.GetWalkerTransform(walker.id), _nav.GetWalkerSpeed(walker.id));\n\t}\n\n\t// Apply the batch of commands\n\t_simulator.lock()->ApplyBatchSync(commands);\n\n\t// Check if any walker has been killed\n\tCheckIfWalkerExist(walkers, state);\n}", "CodeBleu_score": 30.940089806055372}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// Load the current walkers and check if the list is empty\n\tauto walkers = Load(episode);\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Get the current state of the episode and remove any walkers that no longer exist\n\tauto state = episode->GetState();\n\tRemoveWalkers(walkers, state);\n\n\t// Update the vehicles in the crowd and the crowd itself in the navigation module\n\tUpdateVehiclesInCrowd(walkers);\n\tUpdateCrowd(walkers);\n\n\t// For each walker, get their transform and speed, then apply these states in a batch to the simulator\n\tauto commands = std::vector<std::pair<std::string, std::string>>();\n\tfor (auto walker : walkers) {\n\t\tauto transform = _nav.GetWalkerTransform(walker);\n\t\tauto speed = _nav.GetWalkerSpeed(walker);\n\t\tcommands.emplace_back(\"SetTransform\", transform);\n\t\tcommands.emplace_back(\"SetSpeed\", speed);\n\t}\n\t_simulator.lock()->ApplyBatchSync(commands);\n\n\t// Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead\n\tCheckIfWalkerExist(walkers);\n}", "CodeBleu_score": 34.34379495064092}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = uid;\n\tdescription.id = id;\n\tdescription.attributes.reserve(attributes.size());\n\tfor (auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute.MakeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 70.97865630862688}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = uid;\n\tdescription.id = id;\n\tdescription.attributes.reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute->MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 70.73549164712094}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = uid;\n\tdescription.id = id;\n\tdescription.attributes.reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute->MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 70.73549164712094}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (const auto &blueprint : blueprints) {\n\t\tif (blueprint.second.ContainsAttribute(name)) {\n\t\t\tconst auto &attribute = blueprint.second.GetAttribute(name);\n\t\t\tif (attribute.IsValueValid(value) || attribute.ContainsRecommendedValue(value)) {\n\t\t\t\tresult->AddBlueprint(blueprint.first, blueprint.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 40.488245060933195}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (const auto &blueprint : blueprints) {\n\t\tif (blueprint.second.ContainsAttribute(name)) {\n\t\t\tif (blueprint.second.GetValue(name) == value || blueprint.second.GetRecommendedValues(name).Contains(value)) {\n\t\t\t\tresult->AddBlueprint(blueprint.first, blueprint.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 35.26401309053343}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (const auto &pair : blueprints) {\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\tif (pair.second.GetAttribute(name).GetValue() == value ||\n\t\t\t\tpair.second.GetAttribute(name).GetRecommendedValues().Contains(value)) {\n\t\t\t\tresult->Add(pair.first, pair.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 35.99046902547191}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::ofstream out;\n\tout.open(path, std::ios::binary);\n\tif (!out.is_open()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<char *>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 33.95483422686883}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string file_path = base_folder + path + \".carla\";\n\tstd::ofstream out(file_path, std::ios::binary);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<char*>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 35.90120545996174}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tif (path.empty())\n\t\treturn false;\n\n\tstd::string fullPath = GetFullPath(path);\n\n\tstd::ofstream out(fullPath, std::ios::binary);\n\tif (!out.good())\n\t\treturn false;\n\n\tout.write((char*)content.data(), content.size());\n\tout.close();\n\n\treturn true;\n}", "CodeBleu_score": 34.72709279831173}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\tauto bounds = std::make_shared<Bounds>();\n\tbounds->frame = frame;\n\tbounds->location = transform.location;\n\tbounds->location += parent->GetBounds().location;\n\tbounds->extents = parent->GetBounds().extents;\n\tbounds->extents.Rotate(transform.yaw);\n\tbounds->corners[0] = bounds->location - bounds->extents;\n\tbounds->corners[1] = bounds->location + bounds->extents;\n\treturn bounds;\n}", "CodeBleu_score": 34.3364214204903}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\tstd::shared_ptr<const LaneInvasionCallback::Bounds> bounds = std::make_shared<const LaneInvasionCallback::Bounds>();\n\tbounds->frame = frame;\n\tbounds->corners[0] = transform.location + transform.extent.x * transform.Rotate(geom::Location(0, 0));\n\tbounds->corners[1] = transform.location + transform.extent.x * transform.Rotate(geom::Location(0, 1));\n\tbounds->corners[2] = transform.location + transform.extent.x * transform.Rotate(geom::Location(1, 1));\n\tbounds->corners[3] = transform.location + transform.extent.x * transform.Rotate(geom::Location(1, 0));\n\treturn bounds;\n}", "CodeBleu_score": 34.98202272917022}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\t// Get the location of the parent frame\n\tconst geom::Location parentLocation = transform.GetLocation();\n\t// Get the location of the child frame\n\tconst geom::Location childLocation = parentLocation + transform.GetLocation();\n\t// Get the yaw angle of the child frame\n\tconst double yaw = transform.GetRotation().GetYaw();\n\t// Calculate the extents of the bounding box\n\tconst geom::Location extents = childLocation + this->extents_;\n\t// Calculate the four corners of the bounding box\n\tconst geom::Location corners[4] = {\n\t\tgeom::Location(extents.x, extents.y, extents.z),\n\t\tgeom::Location(extents.x, -extents.y, extents.z),\n\t\tgeom::Location(-extents.x, -extents.y, extents.z),\n\t\tgeom::Location(-extents.x, extents.y, extents.z)\n\t};\n\t// Rotate the four corners of the bounding box\n\tconst geom::Location rotatedCorners[4] = {\n\t\tgeom::Rotate(corners[0], yaw),\n\t\tgeom::Rotate(corners[1], yaw),\n\t\tgeom::Rotate(corners[2], yaw),\n\t\tgeom::Rotate(corners[3], yaw)\n\t};\n\t// Return a shared pointer to a Bounds object containing the frame number and the calculated corners\n\treturn std::make_shared<Bounds>(frame, rotatedCorners);\n}", "CodeBleu_score": 36.55343187547728}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Retrieve the light states from the server\n\tstd::vector<LightState> lightStates = _episode.Lock()->GetLightManager()->GetLightStates();\n\n\t// Update the local light states\n\tfor (const LightState& lightState : lightStates) {\n\t\t// Check if the light already exists in the _lights map\n\t\tauto it = _lights.find(lightState.GetID());\n\t\tif (it!= _lights.end()) {\n\t\t\t// Update the light state\n\t\t\tit->second->UpdateState(lightState);\n\t\t}\n\t\telse {\n\t\t\t// Create a new light object\n\t\t\tLight* light = new Light(lightState);\n\t\t\t// Add the light to the _lights map\n\t\t\t_lights.insert(std::make_pair(lightState.GetID(), light));\n\t\t}\n\t}\n}", "CodeBleu_score": 37.32705967442678}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto lightStates = _episode.Lock()->QueryLightsStateToServer();\n\n\tfor (auto lightState : lightStates) {\n\t\tauto light = _lights.find(lightState.GetLightGroup());\n\t\tif (light == _lights.end()) {\n\t\t\t_lights.insert(std::make_pair(lightState.GetLightGroup(), new Light(lightState)));\n\t\t} else {\n\t\t\tlight->second->UpdateState(lightState);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.970559607996435}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Get the current light states from the server\n\tstd::vector<LightState> lightStates = _episode.Lock()->QueryLightsStateToServer();\n\n\t// Update the local light states\n\tfor (LightState& lightState : lightStates) {\n\t\t// If the light does not already exist in the _lights map, create a new light object\n\t\tif (_lights.find(lightState.GetLightId()) == _lights.end()) {\n\t\t\t_lights[lightState.GetLightId()] = std::make_shared<Light>(lightState);\n\t\t}\n\n\t\t// Update the local light state\n\t\t_lights[lightState.GetLightId()]->UpdateState(lightState);\n\t}\n}", "CodeBleu_score": 34.00438618760598}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\tstd::stringstream message;\n\tmessage << \"lights \";\n\tfor (auto it = _lights_changes.begin(); it!= _lights_changes.end(); it++) {\n\t\tmessage << it->first << \" \" << it->second.GetLocation() << \" \" << it->second.GetColor() << \" \";\n\t}\n\tif (discard_client) {\n\t\tmessage << \"client\";\n\t}\n\t_lights_changes.clear();\n\t_dirty = false;\n\t_server->Send(message.str());\n}", "CodeBleu_score": 28.972106426597072}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_lights_changes_mutex);\n\tif (_lights_changes.size() > 0) {\n\t\tstd::string message = \"UPDATE_LIGHTS\";\n\t\tfor (auto it = _lights_changes.begin(); it!= _lights_changes.end(); ++it) {\n\t\t\tmessage += \"|\" + it->first + \"|\" + it->second.ToString();\n\t\t}\n\t\t_lights_changes.clear();\n\t\t_dirty = false;\n\t\tif (discard_client) {\n\t\t\t_client->Send(message);\n\t\t} else {\n\t\t\t_server->Send(message);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.314468487517196}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_lights_changes_mutex);\n\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\n\tstd::vector<rpc::Light> message;\n\tfor (auto it = _lights_changes.begin(); it!= _lights_changes.end(); ++it) {\n\t\trpc::Light light;\n\t\tlight.set_id(it->first);\n\t\tlight.set_color(it->second.GetColor());\n\t\tlight.set_brightness(it->second.GetBrightness());\n\t\tlight.set_location(it->second.GetLocation());\n\t\tlight.set_dirty(it->second.GetDirty());\n\t\tlight.set_dirty_client(it->second.GetDirtyClient());\n\t\tlight.set_dirty_server(it->second.GetDirtyServer());\n\t\tlight.set_dirty_client_server(it->second.GetDirtyClientServer());\n\t\tlight.set_dirty_client_server_client(it->second.GetDirtyClientServerClient());\n\t\tlight.set_dirty_client_server_server(it->second.GetDirtyClientServerServer());\n\t\tlight.set_dirty_client_server_client_server(it->second.GetDirtyClientServerClientServer());\n\t\tlight.set_dirty_client_server_client_server_client(it->second.GetDirtyClientServerClientServerClient());\n\t\tlight.set_dirty_client_server_client_server_server(it->second.GetDirtyClientServerClientServerServer());\n\t\tlight.set_dirty_client_server_client_server_client_server(it->second.GetDirtyClientServerClientServerClientServer());\n\t\tmessage.push_back(light);\n\t}\n\n\tif (!discard_client) {\n\t\tfor (auto it = _lights_changes.begin(); it!= _lights_changes.end(); ++it) {\n\t\t\tit->second.SetDirtyClient(false);\n\t\t}\n\t}\n\n\t_lights_changes.clear();\n\n\tif (!message.empty()) {\n\t\t_server->SendLightUpdate(message);\n\t}\n}", "CodeBleu_score": 39.70539365968787}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send: Sensor's ID is not \\\"sensor.other.v2x_custom\\\". This sensor is not used to send messages to the episode.\");\n\t}\n\telse {\n\t\tGetEpisode().Lock()->Send(message);\n\t}\n}", "CodeBleu_score": 51.63187228067697}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetEpisode().Lock()->GetActorDescription(GetDisplayId()).GetId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning << \"ServerSideSensor::Send called on non-v2x_custom sensor, ignoring.\";\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(GetDisplayId(), message);\n}", "CodeBleu_score": 53.14302436066649}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"Sensor ID does not match \\\"sensor.other.v2x_custom\\\". Not sending message.\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 51.13926677597246}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(tm_port, this);\n\t} else {\n\t\ttm.UnregisterVehicles(tm_port, this);\n\t}\n}", "CodeBleu_score": 45.59829604802113}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(tm_port, this);\n\t} else {\n\t\ttm.UnregisterVehicles(tm_port, this);\n\t}\n}", "CodeBleu_score": 45.59829604802113}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(this, tm_port);\n\t} else {\n\t\ttm.UnregisterVehicles(this);\n\t}\n}", "CodeBleu_score": 41.6393754269472}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\twalker = GetEpisode().Lock()->GetWalker(id);\n\tGetEpisode().Lock()->RegisterAIController(this);\n\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n\twalker->SetActorLocation(walker->GetLocation());\n\twalker->SetActorSimulatePhysics(false);\n\tGetEpisode().Lock()->GetNavigation()->AddWalker(walker);\n}", "CodeBleu_score": 44.62232946372065}, {"code": "void WalkerAIController::Start(){\n\t\t// Retrieve the walker actor\n\twalker = GetEpisode().Lock()->GetActor(walkerId);\n\t// Add the walker to the navigation system\n\tGetEpisode().Lock()->GetNavigation()->AddWalker(walker);\n\t// Disable the physics simulation and collisions for the walker actor\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n}", "CodeBleu_score": 38.358663325397124}, {"code": "void WalkerAIController::Start(){\n\t\t// Get the walker actor\n\twalker = Cast<AWalker>(GetPawn());\n\n\t// Add the walker to the navigation system\n\tGetEpisode().Lock()->GetNavigation().AddWalker(walker);\n\n\t// Disable physics simulation and collisions\n\twalker->SetActorSimulatePhysics(false);\n\twalker->SetActorEnableCollision(false);\n}", "CodeBleu_score": 26.451304514561535}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (!GetEpisode().Lock()) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: No episode found.\");\n\t\treturn;\n\t}\n\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n\tif (!nav) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: No navigation found.\");\n\t\treturn;\n\t}\n\n\tauto walker = nav->GetWalker(GetWalkerId());\n\tif (!walker) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Walker not found.\");\n\t\treturn;\n\t}\n\n\tif (!nav->SetWalkerMaxSpeed(GetWalkerId(), max_speed)) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Could not set walker speed.\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 49.245953493488905}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\t// Get the current episode\n\tauto episode = GetEpisode();\n\t// Check if the episode is valid\n\tif (!episode) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: No episode found!\");\n\t\treturn;\n\t}\n\t// Get the navigation instance from the episode\n\tauto nav = episode->Lock()->GetNavigation();\n\t// Check if the navigation instance is valid\n\tif (!nav) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: No navigation found!\");\n\t\treturn;\n\t}\n\t// Get the parent walker\n\tauto walker = GetParent();\n\t// Check if the walker is valid\n\tif (!walker) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: No walker found!\");\n\t\treturn;\n\t}\n\t// Attempt to set the maximum speed of the walker\n\tif (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to set maximum speed!\");\n\t}\n}", "CodeBleu_score": 55.81161737894909}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (walker) {\n\t\tif (walker->GetEpisode().Lock()) {\n\t\t\tif (walker->GetEpisode().Lock()->GetNavigation()) {\n\t\t\t\tif (walker->GetParent()) {\n\t\t\t\t\twalker->GetEpisode().Lock()->GetNavigation()->SetWalkerMaxSpeed(walker->GetParent(), max_speed);\n\t\t\t\t} else {\n\t\t\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: walker has no parent\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: walker has no episode\");\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: walker has no episode\");\n\t\t}\n\t} else {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: walker is null\");\n\t}\n}", "CodeBleu_score": 41.8373668564914}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(_parent->GetMap().GetPrevious(this, distance).size());\n\tfor (auto &waypoint : _parent->GetMap().GetPrevious(this, distance)) {\n\t\tresult.emplace_back(std::make_shared<Waypoint>(waypoint));\n\t}\n\treturn result;\n}", "CodeBleu_score": 57.489924414717485}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tauto waypoints = _parent->GetMap().GetPrevious(*this, distance);\n\tresult.reserve(waypoints.size());\n\tfor (auto& waypoint : waypoints) {\n\t\tresult.emplace_back(std::move(waypoint));\n\t}\n\treturn result;\n}", "CodeBleu_score": 59.65065252539395}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(_parent->GetMap().GetPrevious(_parent, distance).size());\n\tfor (auto waypoint : _parent->GetMap().GetPrevious(_parent, distance)) {\n\t\tresult.emplace_back(std::move(waypoint));\n\t}\n\treturn result;\n}", "CodeBleu_score": 55.26794583062723}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t// TODO(all): implement\nstd::vector<SharedPtr<Landmark>> result;\nstd::unordered_set<uint32_t> added_signals;\nfor (auto& signal : _parent->GetMap().GetSignalsInDistance(_parent, distance)) {\n  if (added_signals.count(signal->GetId()) > 0) {\n    continue;\n  }\n  auto waypoint = std::make_shared<Waypoint>(signal, _parent);\n  auto landmark = std::make_shared<Landmark>(waypoint);\n  result.emplace_back(landmark);\n  added_signals.insert(signal->GetId());\n}\nreturn result;\n}", "CodeBleu_score": 50.7389191417269}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::unordered_set<std::string> added_signals;\nstd::vector<SharedPtr<Waypoint>> signals = GetSignalsInDistance(distance, stop_at_junction);\nfor (auto signal : signals) {\nif (added_signals.count(signal->GetId()) == 0) {\nresult.emplace_back(new Landmark(signal));\nadded_signals.insert(signal->GetId());\n}\n}\nreturn result;\n}", "CodeBleu_score": 39.20945260496641}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::set<std::string> added_signals;\nfor (auto signal : GetSignalsInDistance(distance, stop_at_junction)) {\nif (added_signals.count(signal->GetId()) == 0) {\nauto new_landmark = std::make_shared<Landmark>(signal->GetId(), _parent);\nresult.emplace_back(new_landmark);\nadded_signals.insert(signal->GetId());\n}\n}\nreturn result;\n}", "CodeBleu_score": 38.6363596720249}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tif (settings.fixed_delta_seconds.has_value()) {\n\t\t// Apply the fixed delta time.\n\t\t_episode.Lock()->SetEpisodeSettings(settings);\n\t\t// Verify that the fixed delta time is accurate.\n\t\tif (!VerifyFixedDeltaTimeAccuracy(settings.fixed_delta_seconds.value(), timeout)) {\n\t\t\tLOG(WARNING) << \"Fixed delta time is not accurate. Expected: \" << settings.fixed_delta_seconds.value() << \"s, got: \" << _episode.Lock()->GetFixedDeltaTime().count() << \"s.\";\n\t\t}\n\t} else {\n\t\t// Apply the networking timeout.\n\t\t_episode.Lock()->SetEpisodeSettings(settings);\n\t\t// Set the local timeout.\n\t\ttimeout = std::max(timeout, _episode.Lock()->GetNetworkingTimeout());\n\t}\n\treturn _episode.Lock()->GetSettingsIdentifier();\n}", "CodeBleu_score": 26.564920970318234}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\t// Apply the settings to the world\n\t_episode.Lock()->SetEpisodeSettings(settings);\n\n\t// Set a local timeout based on the provided timeout or the episode's networking timeout\n\tconst time_duration local_timeout = (timeout.has_value()? timeout : _episode.Lock()->GetNetworkingTimeout());\n\n\t// If the settings include a fixed delta time, attempt to verify the accuracy of this setting over a series of ticks\n\tif (settings.fixed_delta_seconds.has_value()) {\n\t\t// Initialize a timer\n\t\tauto timer = _timer.Lock();\n\n\t\t// Initialize a snapshot\n\t\tauto curr_snapshot = _episode.Lock()->GetSnapshot();\n\n\t\t// Initialize the number of attempts\n\t\tuint32_t attempts = 0;\n\n\t\t// Initialize the number of ticks\n\t\tuint32_t ticks = 0;\n\n\t\t// Initialize the number of ticks with a fixed delta time\n\t\tuint32_t ticks_with_fixed_delta = 0;\n\n\t\t// Initialize the number of ticks with an exact delta time\n\t\tuint32_t ticks_with_exact_delta = 0;\n\n\t\t// Initialize the number of ticks with an exact delta time\n\t\tuint32_t ticks_with_exact_delta_and_no_fixed_delta = 0;\n\n\t\t// Initialize the number of ticks with an exact delta time\n\t\tuint32_t ticks_with_exact_delta_and_no_fixed_delta_and_no_timeout = 0;\n\n\t\t// Initialize the number of ticks with an exact delta time\n\t\tuint32_t ticks_with_exact_delta_and_no_fixed_delta_and_no_timeout_and_no_timeout_override = 0;\n\n\t\t// Initialize the number of ticks with an exact delta time\n\t\tuint32_t ticks_with_exact_delta_and_no_fixed_delta_and_no_timeout_and_no_timeout_override_and_no_timeout_override_and_no_timeout_override = 0;\n\n\t\t// Initialize the number of ticks with an exact delta time\n\t\tuint32_t ticks_with_exact_delta_and_no_fixed_delta_and_no_timeout_and_no_timeout_override_and_no_timeout_override", "CodeBleu_score": 29.60115046109364}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tstd::lock_guard<std::recursive_mutex> lock(_mutex);\n\tif (_episode.expired()) {\n\t\tlog_warning(\"ApplySettings: Episode is expired.\");\n\t\treturn 0;\n\t}\n\tauto &curr_snapshot = _episode.lock()->GetSnapshot();\n\tauto curr_settings = curr_snapshot.GetEpisodeSettings();\n\tif (curr_settings.fixed_delta_seconds.has_value()) {\n\t\tif (settings.fixed_delta_seconds.has_value()) {\n\t\t\tif (std::abs(curr_settings.fixed_delta_seconds.get() - settings.fixed_delta_seconds.get()) > std::numeric_limits<float>::epsilon()) {\n\t\t\t\tlog_warning(\"ApplySettings: Fixed delta time setting is not equal to the current setting.\");\n\t\t\t}\n\t\t}\n\t}\n\tauto new_settings = settings;\n\tif (new_settings.fixed_delta_seconds.has_value()) {\n\t\tif (new_settings.fixed_delta_seconds.get() <= 0.0f) {\n\t\t\tlog_warning(\"ApplySettings: Fixed delta time setting is not positive.\");\n\t\t\tnew_settings.fixed_delta_seconds.reset();\n\t\t}\n\t}\n\tif (new_settings.fixed_delta_seconds.has_value()) {\n\t\tif (timeout.milliseconds <= 0) {\n\t\t\ttimeout = _episode.lock()->GetNetworkingTimeout();\n\t\t}\n\t\tauto start_time = curr_snapshot.GetTimestamp();\n\t\tauto curr_time = start_time;\n\t\tauto curr_delta = new_settings.fixed_delta_seconds.get();\n\t\tauto delta_sum = 0.0f;\n\t\tauto delta_count = 0;\n\t\twhile (curr_time < start_time + timeout) {\n\t\t\tauto next_time = curr_time + time_duration(curr_delta * 1000.0f);\n\t\t\tauto next_delta = _episode.lock()->ApplySettings(new_settings, next_time);\n\t\t\tif (next_delta <= 0.0f) {\n\t\t\t\tlog_warning(\"ApplySettings: Failed to apply settings.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdelta_sum += next_delta;\n\t\t\tdelta_count++;", "CodeBleu_score": 48.52047641576905}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segmentLengthSquared = (lineSegment.second.x - lineSegment.first.x) * (lineSegment.second.x - lineSegment.first.x) + (lineSegment.second.y - lineSegment.first.y) * (lineSegment.second.y - lineSegment.first.y);\n\tfloat segmentLength = std::sqrt(segmentLengthSquared);\n\tif (segmentLength == 0.0f) {\n\t\treturn std::make_pair(0.0f, Distance2D(lineSegment.first, point));\n\t}\n\tfloat t = (point.x - lineSegment.first.x) * (lineSegment.second.x - lineSegment.first.x) + (point.y - lineSegment.first.y) * (lineSegment.second.y - lineSegment.first.y);\n\tt = Clamp(t, 0.0f, segmentLengthSquared);\n\tfloat projectionX = lineSegment.first.x + t * (lineSegment.second.x - lineSegment.first.x) / segmentLength;\n\tfloat projectionY = lineSegment.first.y + t * (lineSegment.second.y - lineSegment.first.y) / segmentLength;\n\tfloat distanceToProjection = Distance2D(point, { projectionX, projectionY });\n\treturn std::make_pair(distanceToProjection, Distance2D(lineSegment.first, { projectionX, projectionY }));\n}", "CodeBleu_score": 36.26782149602112}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst Vector2& point,\n\tconst Vector2& segmentStart,\n\tconst Vector2& segmentEnd\n}", "CodeBleu_score": 10.922423612407597}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat sqrSegmentLength = Math::DistanceSquared2D(segment.first, segment.second);\n\tif (sqrSegmentLength == 0.0f) {\n\t\treturn std::make_pair(0.0f, Math::Distance2D(point, segment.first));\n\t}\n\tfloat t = Math::Clamp(Math::Dot2D(point - segment.first, segment.second - segment.first) / sqrSegmentLength, 0.0f, 1.0f);\n\treturn std::make_pair(Math::Distance2D(point, segment.first + t * (segment.second - segment.first)), Math::Distance2D(point, segment.first + t * (segment.second - segment.first)));\n}", "CodeBleu_score": 30.07264435390612}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tDEBUG_ASSERT(vertices.size() >= 3)\n\tconst int initial_index = vertices.size() - 1;\n\tAddVertices(vertices);\n\tAddIndex(initial_index);\n\tfor (int i = 1; i < vertices.size() - 1; i++) {\n\t\tAddIndex(i);\n\t\tAddIndex(i + 1);\n\t}\n}", "CodeBleu_score": 55.65313323644927}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT(vertices.size() >= 3);\nAddVertices(vertices);\nconst size_t initial_index = GetVerticesNum() - vertices.size();\nfor (size_t i = 1; i < vertices.size() - 1; ++i) {\nAddIndex(initial_index);\nAddIndex(initial_index + i);\nAddIndex(initial_index + i + 1);\n}\n}", "CodeBleu_score": 57.868284551748026}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tDEBUG_ASSERT(vertices.size() >= 3);\n\tconst size_t initialIndex = vertices.size() - 3;\n\tAddVertices(vertices);\n\tAddIndex(initialIndex);\n\tfor (size_t i = initialIndex + 1; i < vertices.size(); ++i) {\n\t\tAddIndex(i);\n\t\tAddIndex(i - 1);\n\t}\n}", "CodeBleu_score": 58.27241507470189}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tDEBUG_ASSERT(message);\n\tDEBUG_ASSERT(message->empty() == false);\n\tDEBUG_ASSERT(message->GetBufferSequence().size() > 0);\n\tDEBUG_ASSERT(message->GetBufferSequence().size() <= MAX_MESSAGE_SIZE);\n\n\tauto self = shared_from_this();\n\tboost::asio::post(\n\t\tself->_strand,\n\t\t[self, message]() {\n\t\t\tif (self->_socket.is_open()) {\n\t\t\t\tself->_deadline.expires_from_now(boost::posix_time::seconds(30));\n\t\t\t\tboost::asio::async_write(\n\t\t\t\t\tself->_socket,\n\t\t\t\t\tmessage->GetBufferSequence(),\n\t\t\t\t\tboost::asio::bind_executor(\n\t\t\t\t\t\tself->_strand,\n\t\t\t\t\t\tstd::bind(\n\t\t\t\t\t\t\t&Primary::HandleSent,\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\tstd::placeholders::_1,\n\t\t\t\t\t\t\tstd::placeholders::_2,\n\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tself->CloseNow();\n\t\t\t}\n\t\t}\n\t);\n}", "CodeBleu_score": 33.85241297570709}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (message->empty()) {\n\t\tlog_error(\"Cannot send an empty message.\");\n\t\treturn;\n\t}\n\n\tboost::asio::post(self->_strand, [this, message]() {\n\t\tif (!self->_socket.is_open()) {\n\t\t\tlog_error(\"Socket is not open.\");\n\t\t\treturn;\n\t\t}\n\n\t\tself->_deadline.expires_from_now(boost::posix_time::seconds(self->_timeout));\n\n\t\tboost::asio::async_write(self->_socket, message->GetBufferSequence(),\n\t\t\tboost::asio::bind_executor(self->_strand,\n\t\t\t\t[this, message](const boost::system::error_code &ec, std::size_t) {\n\t\t\t\t\tself->handle_sent(ec, message);\n\t\t\t\t})\n\t\t\t);\n\t});\n}", "CodeBleu_score": 34.92505133169472}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\treturn;\n\t}\n\tif (message->empty()) {\n\t\treturn;\n\t}\n\tif (!self->_socket.is_open()) {\n\t\treturn;\n\t}\n\tauto weak = self->shared_from_this();\n\tself->_strand.post([message, weak]() {\n\t\tif (auto self = weak.lock()) {\n\t\t\tif (self->_socket.is_open()) {\n\t\t\t\tself->_deadline.expires_from_now(boost::posix_time::seconds(self->_timeout));\n\t\t\t\tself->_socket.async_write_some(message->GetBufferSequence(), [message, self](const boost::system::error_code &ec, std::size_t bytes_transferred) {\n\t\t\t\t\tself->handle_sent(message, ec, bytes_transferred);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n}", "CodeBleu_score": 40.40320481876413}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer.\n\t_deadline.cancel();\n\n\t// If the socket is open, shutdown and close the socket.\n\tif (_socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t_socket.close(ec);\n\t}\n\n\t// Trigger the on_closed callback.\n\tif (_on_closed) {\n\t\t_on_closed(ec);\n\t}\n\n\t// Log that the session has been closed.\n\tlog_debug(\"Session has been closed\");\n}", "CodeBleu_score": 55.03005145603475}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tlog_debug(\"Closing socket connection\");\n\tif (!_socket.is_open()) {\n\t\tlog_debug(\"Socket is already closed\");\n\t\treturn;\n\t}\n\n\tif (ec) {\n\t\tlog_error(\"Error closing socket: \" + ec.message());\n\t} else {\n\t\t_deadline.cancel();\n\t\tboost::system::error_code ec;\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\tif (ec) {\n\t\t\tlog_error(\"Error shutting down socket: \" + ec.message());\n\t\t}\n\t\t_socket.close();\n\t}\n\n\t_on_closed();\n\tlog_debug(\"Socket connection closed\");\n}", "CodeBleu_score": 51.11484058851731}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer.\n\t_deadline.cancel();\n\n\t// Shut down the socket if it is open.\n\tif (_socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t}\n\n\t// Close the socket if it is open.\n\tif (_socket.is_open()) {\n\t\t_socket.close(ec);\n\t}\n\n\t// Call the on_closed callback if it is defined.\n\tif (_on_closed) {\n\t\t_on_closed(ec);\n\t}\n\n\t// Log that the session has been closed.\n\tif (!ec) {\n\t\tlog_debug(\"Session closed.\");\n\t}\n}", "CodeBleu_score": 57.56688722376987}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create the buffer\n\tstd::string msg = \"Are you alive?\";\n\tstd::vector<char> buffer(msg.begin(), msg.end());\n\tbuffer.push_back('\\0');\n\n\t// Log the sending action\n\tlog_info(\"Sending message: %s\", msg.c_str());\n\n\t// Write the buffer to the next router\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\n\t// Wait for the response\n\tstd::future<std::vector<char>> fut = _router->ReadFromNext();\n\tstd::vector<char> response = fut.get();\n\n\t// Log the response\n\tlog_info(\"Received message: %s\", response.data());\n}", "CodeBleu_score": 50.1350795855543}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tstd::string msg = \"Are you alive?\";\n\tstd::string buffer = CreateBuffer(msg);\n\t// Log the sending action\n\tlog_info(\"Sending message: \" + msg);\n\t// Write the buffer to the next router\n\t_router->WriteToNext(buffer);\n\t// Wait for the response\n\tstd::string response = _router->WaitForResponse();\n\t// Log the response\n\tlog_info(\"Received message: \" + response);\n}", "CodeBleu_score": 46.69639001117976}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::string msg = \"Are you alive?\";\n\tstd::vector<char> buffer(msg.begin(), msg.end());\n\tlog_info(\"Sending Are you alive?\");\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\tstd::string response = _router->WaitForResponse();\n\tlog_info(\"Received response: \" + response);\n}", "CodeBleu_score": 50.387994571200956}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if the sensor has been activated on any secondary server.\n\tif (_servers.find(sensor_id) == _servers.end()) {\n\t\t// Log an error message if the sensor has not been activated.\n\t\tlog_error(\"Sensor not found on any server.\");\n\t\treturn;\n\t}\n\n\t// Create a buffer with the sensor ID.\n\tstd::vector<uint8_t> buffer(1);\n\tbuffer[0] = sensor_id;\n\n\t// Send an ENABLE_ROS command to the server using the router.\n\tauto fut = _router->WriteToOne(buffer);\n\n\t// Wait for and process the server's response.\n\tauto response = fut.get();\n\tif (response.status == Router::Status::SUCCESS) {\n\t\t// Log a success message if the sensor has been activated.\n\t\tlog_success(\"Sensor activated.\");\n\t} else {\n\t\t// Log an error message if the sensor has not been activated.\n\t\tlog_error(\"Sensor not activated.\");\n\t}\n}", "CodeBleu_score": 47.73847908700057}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if sensor has been activated on any server\n\tif (_servers.find(sensor_id) == _servers.end()) {\n\t\tlog_error(\"Sensor \" + std::to_string(sensor_id) + \" is not activated on any server\");\n\t\treturn;\n\t}\n\n\t// Create buffer with sensor ID\n\tstd::vector<uint8_t> buffer;\n\tbuffer.push_back(sensor_id);\n\n\t// Send ENABLE_ROS command to server\n\tauto fut = _router->WriteToOne(buffer, _servers.find(sensor_id)->second);\n\n\t// Wait for and process server's response\n\tif (fut.get()) {\n\t\t// Check if response is valid\n\t\tif (buffer.size() < 2) {\n\t\t\tlog_error(\"Invalid response from server\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if response is valid\n\t\tif (buffer[0]!= sensor_id) {\n\t\t\tlog_error(\"Invalid response from server\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if response is valid\n\t\tif (buffer[1]!= 0) {\n\t\t\tlog_error(\"Invalid response from server\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Log success\n\t\tlog_success(\"Sensor \" + std::to_string(sensor_id) + \" is now activated for ROS\");\n\t}\n\telse {\n\t\tlog_error(\"Failed to send ENABLE_ROS command to server\");\n\t}\n}", "CodeBleu_score": 44.98337033977745}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tauto fut = _router->WriteToOne(\n\t\t_servers.find(sensor_id)->second,\n\t\tCommand::ENABLE_ROS,\n\t\treinterpret_cast<char *>(&sensor_id),\n\t\tsizeof(sensor_id)\n\t);\n\tauto response = fut.get();\n\tif (response.buffer.size() == 0) {\n\t\tlog_error(\"Failed to enable ROS for sensor \" + std::to_string(sensor_id));\n\t}\n}", "CodeBleu_score": 39.172138508020026}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// Check if the sensor is already activated\n\tauto it = _tokens.find(sensor_id);\n\tif (it!= _tokens.end()) {\n\t\t// The sensor is already activated\n\t\tlog_debug(\"Sensor %d is already activated. Returning token %d.\", sensor_id, it->second.get_stream_id);\n\t\treturn it->second.get_token;\n\t}\n\t// The sensor is not activated\n\t// Check if there is a secondary server available\n\tif (_router->GetNextServer() == nullptr) {\n\t\t// There is no secondary server available\n\t\tlog_error(\"No secondary server available.\");\n\t\treturn token_type();\n\t}\n\t// There is a secondary server available\n\t// Send a token request to the secondary server\n\tlog_debug(\"Sending token request to secondary server.\");\n\tauto token = _router->SendGetToken(sensor_id);\n\tif (token.empty()) {\n\t\t// The secondary server could not retrieve a token\n\t\tlog_error(\"Secondary server could not retrieve a token.\");\n\t\treturn token_type();\n\t}\n\t// The secondary server retrieved a token\n\t// Add the sensor to the token map\n\t_tokens.insert(std::make_pair(sensor_id, token_info(token, _router->GetNextServer()->get_port(), sensor_id)));\n\t// Log the action\n\tlog_debug(\"Sensor %d is activated. Returning token %d.\", sensor_id, token);\n\treturn token;\n}", "CodeBleu_score": 50.70203865830938}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// Check if the sensor is already activated\n\ttoken_type token;\n\tif (IsActivated(sensor_id)) {\n\t\ttoken = _tokens[sensor_id];\n\t\tlog_debug(\"Sensor %u already activated, returning token %s\", sensor_id, token.get_token().c_str());\n\t}\n\t// Sensor is not activated, activate it on a secondary server\n\telse {\n\t\t// Get the next server\n\t\tServerInfo server = _router->GetNextServer();\n\t\t// Send the token request\n\t\tSendGetToken(sensor_id, server);\n\t\t// Wait for the token\n\t\ttoken = WaitForToken(sensor_id);\n\t\t// Update the maps\n\t\t_tokens[sensor_id] = token;\n\t\t_activated_sensors[sensor_id] = server;\n\t\t// Log the action\n\t\tlog_debug(\"Activated sensor %u on server %s:%u, returning token %s\", sensor_id, server.get_host().c_str(), server.get_port(), token.get_token().c_str());\n\t}\n\treturn token;\n}", "CodeBleu_score": 48.41022890488275}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tlog_debug(\"GetToken\");\n\tstd::map<stream_id, token_type>::iterator it = _tokens.find(sensor_id);\n\tif (it!= _tokens.end()) {\n\t\tlog_debug(\"Token found\");\n\t\treturn it->second;\n\t}\n\tlog_debug(\"Token not found\");\n\t// Get the next server\n\tServerInfo server = _router->GetNextServer(sensor_id);\n\tlog_debug(\"Next server found\");\n\t// Send a token request\n\ttoken_type token = SendGetToken(server.get_ip(), server.get_port(), sensor_id);\n\tlog_debug(\"Token received\");\n\t// Add the token to the map\n\t_tokens.insert(std::pair<stream_id, token_type>(sensor_id, token));\n\treturn token;\n}", "CodeBleu_score": 48.571643207790345}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open())\n\t\treturn false;\n\tf.seekg(0, std::ios::end);\n\tstd::vector<unsigned char> file(f.tellg());\n\tf.seekg(0, std::ios::beg);\n\tf.read((char *)file.data(), file.size());\n\tf.close();\n\treturn Load(file);\n}", "CodeBleu_score": 56.31754401651528}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\n\tf.seekg(0, std::ios::end);\n\tstd::vector<char> buffer(f.tellg());\n\tf.seekg(0, std::ios::beg);\n\tf.read(&buffer[0], buffer.size());\n\tf.close();\n\n\treturn Load(buffer);\n}", "CodeBleu_score": 67.09811688876115}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<unsigned char> file_data((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());\n\tf.close();\n\treturn Load(file_data);\n}", "CodeBleu_score": 67.52180237722033}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\tDEBUG_ASSERT(_crowd!= nullptr);\n\t{\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t// Remove from crowd\n\t\t_crowd->removeAgent(id);\n\n\t\t// Remove from walker manager\n\t\tif (_walker_manager.RemoveWalker(id)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Remove from vehicle manager\n\t\tauto it = _mapped_vehicles_id.find(id);\n\t\tif (it!= _mapped_vehicles_id.end()) {\n\t\t\t_mapped_vehicles_id.erase(it);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Remove from walker manager\n\t\tit = _mapped_walkers_id.find(id);\n\t\tif (it!= _mapped_walkers_id.end()) {\n\t\t\t_mapped_walkers_id.erase(it);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Remove from by index\n\t\tit = _mapped_by_index.find(id);\n\t\tif (it!= _mapped_by_index.end()) {\n\t\t\t_mapped_by_index.erase(it);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 64.0731211803362}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\tDEBUG_ASSERT(_crowd!= NULL);\n\t{\n\t\t// Remove the agent from the crowd\n\t\t_crowd->removeAgent(id);\n\n\t\t// Remove the agent from the walker manager\n\t\tif (_mapped_walkers_id.find(id)!= _mapped_walkers_id.end()) {\n\t\t\t_walker_manager.RemoveWalker(_mapped_walkers_id[id]);\n\t\t\t_mapped_walkers_id.erase(id);\n\t\t}\n\n\t\t// Remove the agent from the vehicle manager\n\t\tif (_mapped_vehicles_id.find(id)!= _mapped_vehicles_id.end()) {\n\t\t\t_vehicle_manager.RemoveVehicle(_mapped_vehicles_id[id]);\n\t\t\t_mapped_vehicles_id.erase(id);\n\t\t}\n\n\t\t// Remove the agent from the mappings\n\t\t_mapped_by_index.erase(id);\n\t}\n\treturn true;\n}", "CodeBleu_score": 37.779376744570335}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\tDEBUG_ASSERT(_crowd!= nullptr);\n\tif (_crowd == nullptr) {\n\t\treturn false;\n\t}\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\tif (_crowd->getAgentState(id) == crowd::AgentState::INVALID) {\n\t\treturn false;\n\t}\n\tif (_mapped_walkers_id.find(id)!= _mapped_walkers_id.end()) {\n\t\t_crowd->removeAgent(id);\n\t\t_mapped_walkers_id.erase(id);\n\t\t_mapped_by_index.erase(_walker_manager.GetIndex(id));\n\t\treturn true;\n\t}\n\tif (_mapped_vehicles_id.find(id)!= _mapped_vehicles_id.end()) {\n\t\t_crowd->removeAgent(id);\n\t\t_mapped_vehicles_id.erase(id);\n\t\t_mapped_by_index.erase(_vehicle_manager.GetIndex(id));\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 51.04420522014356}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\t// Get the IDs of all currently mapped vehicles\n\tstd::set<std::string> current_ids;\n\tfor (auto& vehicle : vehicles_) {\n\t\tcurrent_ids.insert(vehicle.id);\n\t}\n\n\t// Add or update vehicles from the provided list\n\tfor (auto& vehicle : vehicles) {\n\t\t// If the vehicle is already mapped, update it\n\t\tif (current_ids.find(vehicle.id)!= current_ids.end()) {\n\t\t\tauto& vehicle_info = vehicles_[vehicle.id];\n\t\t\tvehicle_info.updated = true;\n\t\t\tvehicle_info.position = vehicle.position;\n\t\t\tvehicle_info.velocity = vehicle.velocity;\n\t\t\tvehicle_info.acceleration = vehicle.acceleration;\n\t\t\tvehicle_info.heading = vehicle.heading;\n\t\t\tvehicle_info.speed = vehicle.speed;\n\t\t\tvehicle_info.lane = vehicle.lane;\n\t\t\tvehicle_info.lane_offset = vehicle.lane_offset;\n\t\t}\n\t\t// Otherwise, add it\n\t\telse {\n\t\t\tvehicles_.insert(std::make_pair(vehicle.id, vehicle));\n\t\t}\n\t}\n\n\t// Remove vehicles that were not updated\n\tfor (auto it = vehicles_.begin(); it!= vehicles_.end();) {\n\t\tif (!it->second.updated) {\n\t\t\tvehicles_.erase(it++);\n\t\t}\n\t\telse {\n\t\t\tit++;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 48.50435831991241}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::set<int> vehicleIDs;\n\tfor (auto &vehicle : vehicles) {\n\t\tvehicleIDs.insert(vehicle.vehicleID);\n\t}\n\n\tfor (auto &vehicle : vehicles) {\n\t\tif (vehicle.updated) {\n\t\t\tupdated.insert(vehicle.vehicleID);\n\t\t}\n\t\telse {\n\t\t\tupdated.erase(vehicle.vehicleID);\n\t\t}\n\t}\n\n\tfor (auto &vehicle : vehicles) {\n\t\tif (vehicle.updated) {\n\t\t\tAddOrUpdateVehicle(vehicle);\n\t\t}\n\t}\n\n\tfor (auto &vehicle : vehicles) {\n\t\tif (!vehicle.updated) {\n\t\t\tRemoveVehicle(vehicle.vehicleID);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 52.40357005528431}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::set<int> current_ids;\n\tfor (auto &vehicle : vehicles) {\n\t\tcurrent_ids.insert(vehicle.vehicle_id);\n\t}\n\n\tfor (auto &vehicle : vehicles) {\n\t\tif (vehicle.vehicle_id == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vehicle.is_updated) {\n\t\t\tupdated.insert(vehicle.vehicle_id);\n\t\t} else {\n\t\t\tupdated.erase(vehicle.vehicle_id);\n\t\t}\n\n\t\tif (vehicle.is_updated) {\n\t\t\tAddOrUpdateVehicle(vehicle);\n\t\t}\n\t}\n\n\tfor (auto &vehicle_id : current_ids) {\n\t\tif (updated.find(vehicle_id) == updated.end()) {\n\t\t\tRemoveAgent(vehicle_id);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 54.442334420437234}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto it = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\tauto &actor = it->second;\n\t\tif (actor->HasVehicleNear(distance, direction)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tit = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\tauto &actor = it->second;\n\t\tif (actor->HasVehicleNear(distance, direction)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 60.06163755301985}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tif (_crowd->hasVehicleNear(id, distance, direction)) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 15.1679401752458}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// Check if the actor is in the mapped vehicles.\n\tauto it = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\t// Enter critical section.\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t// Compute the squared distance.\n\t\tfloat squared_distance = direction.distance_to_squared(it->second->GetLocation());\n\t\t// Check if there is a vehicle nearby.\n\t\treturn _crowd->hasVehicleNear(it->second->GetActor(), distance, squared_distance);\n\t}\n\t// Check if the actor is in the mapped walkers.\n\tit = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\t// Enter critical section.\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t// Compute the squared distance.\n\t\tfloat squared_distance = direction.distance_to_squared(it->second->GetLocation());\n\t\t// Check if there is a vehicle nearby.\n\t\treturn _crowd->hasVehicleNear(it->second->GetActor(), distance, squared_distance);\n\t}\n\treturn false;\n}", "CodeBleu_score": 58.292174213057635}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// get the current route point\n\tRoutePoint current = info.GetCurrentRoutePoint();\n\n\t// create a visitor\n\tWalkerEventVisitor visitor(info, delta);\n\n\t// execute the event at the current route point\n\tEventResult result = boost::variant2::visit(visitor, current.event);\n\n\t// return the result\n\treturn result;\n}", "CodeBleu_score": 48.48329381370643}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Get the current route point\n\tRoutePoint *rp = info.GetCurrentRoutePoint();\n\n\t// Create a visitor with the current context\n\tWalkerEventVisitor visitor(info, delta);\n\n\t// Execute the event at the current route point\n\tEventResult result = boost::variant2::visit(visitor, rp->GetEvent());\n\n\t// Return the result of the event execution\n\treturn result;\n}", "CodeBleu_score": 46.65938935422143}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tEventResult result;\n\n\tif (info.route.empty()) {\n\t\treturn result;\n\t}\n\n\tWalkerEventVisitor visitor(info, delta);\n\tresult = boost::variant2::visit(visitor, info.route.front());\n\n\treturn result;\n}", "CodeBleu_score": 42.29840823029177}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\t// Iterate through each road node\n\tfor (const auto &road_node : xml.children()) {\n\t\t// Extract the road ID\n\t\tconst auto id = road_node.attribute(\"id\").as_uint();\n\t\t// Process each lane section within the lanes node\n\t\tfor (const auto &lane_section_node : road_node.children()) {\n\t\t\t// Retrieve the left, center, and right lane nodes\n\t\t\tconst auto left_lane_node = lane_section_node.child(\"left\");\n\t\t\tconst auto center_lane_node = lane_section_node.child(\"center\");\n\t\t\tconst auto right_lane_node = lane_section_node.child(\"right\");\n\t\t\t// Parse the lanes\n\t\t\tParseLanes(left_lane_node, map_builder, id, LaneType::LEFT);\n\t\t\tParseLanes(center_lane_node, map_builder, id, LaneType::CENTER);\n\t\t\tParseLanes(right_lane_node, map_builder, id, LaneType::RIGHT);\n\t\t}\n\t}\n}", "CodeBleu_score": 42.44194429802077}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node in the XML document\n  for (const auto &road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\n// Retrieve the road ID from the XML node\n    const auto road_id = road_node.attribute(\"id\").as_uint();\n\n// Iterate through each lane section node in the road node\n    for (const auto &lane_section_node : road_node.children(\"lanes\")) {\n\n// Parse the left, center, and right lane nodes\n      ParseLanes(lane_section_node, map_builder);\n    }\n  }\n}", "CodeBleu_score": 25.124050374839506}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\t// Iterate through each road node\n\tfor (auto road_node : xml.children()) {\n\t\t// Get the road ID\n\t\tconst auto road_id = road_node.attribute(\"id\").as_uint();\n\t\t// Iterate through each lane section within the lanes node\n\t\tfor (auto lane_section_node : road_node.children(\"lanes\")) {\n\t\t\t// Parse the lanes\n\t\t\tParseLanes(lane_section_node, map_builder, road_id);\n\t\t}\n\t}\n}", "CodeBleu_score": 25.024183671234184}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.currentCount <= 0) {\n\t\t// Match lost\n\t\t_matched = false;\n\t\t_matched_count = 0;\n\t} else if (info.currentCount == 1) {\n\t\t// Match found\n\t\t_matched = true;\n\t\t_matched_count = 1;\n\t\t_first_connection = true;\n\t} else if (info.currentCount > 1) {\n\t\t// Multiple matches found\n\t\t_matched = true;\n\t\t_matched_count = info.currentCount;\n\t} else {\n\t\t// Invalid count change\n\t\t_logger->error(\"Invalid publication match count change\");\n\t}\n}", "CodeBleu_score": 57.79222455687609}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.currentCount <= info.totalCount) {\n\t\tif (info.currentCount == 0 && info.totalCount > 0) {\n\t\t\t// match lost\n\t\t\t_matchedCount = info.totalCount;\n\t\t\t_firstConnection = false;\n\t\t} else if (info.currentCount > 0 && info.totalCount > 0) {\n\t\t\t// match added\n\t\t\t_matchedCount = info.totalCount;\n\t\t\t_firstConnection = true;\n\t\t} else {\n\t\t\t// invalid count\n\t\t\t_logger->error(\"Invalid publication count change\");\n\t\t}\n\t} else {\n\t\t// invalid count\n\t\t_logger->error(\"Invalid publication count change\");\n\t}\n}", "CodeBleu_score": 54.835646689508785}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\t// Check if the data writer is the one we are looking for\n\tif (writer == _dataWriter) {\n\t\t// Check if the status is valid\n\t\tif (info.currentCount >= 0) {\n\t\t\t// Check if the count changed\n\t\t\tif (info.currentCount!= _matchedCount) {\n\t\t\t\t// Update the count\n\t\t\t\t_matchedCount = info.currentCount;\n\t\t\t\t// Check if the count is zero\n\t\t\t\tif (_matchedCount == 0) {\n\t\t\t\t\t// Log a message\n\t\t\t\t\tstd::stringstream ss;\n\t\t\t\t\tss << \"No listener connected to the publisher. Matched count: \" << _matchedCount;\n\t\t\t\t\tlog(ss.str());\n\t\t\t\t} else {\n\t\t\t\t\t// Log a message\n\t\t\t\t\tstd::stringstream ss;\n\t\t\t\t\tss << \"Listener connected to the publisher. Matched count: \" << _matchedCount;\n\t\t\t\t\tlog(ss.str());\n\t\t\t\t\t// Set the first connection flag\n\t\t\t\t\t_firstConnection = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Log an error message\n\t\t\tstd::stringstream ss;\n\t\t\tss << \"Received invalid publication matched status. Matched count: \" << _matchedCount;\n\t\t\tlogError(ss.str());\n\t\t}\n\t}\n}", "CodeBleu_score": 37.9919508640836}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tm_matched_count++;\n\t\tif (info.current_count == 1) {\n\t\t\tm_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tm_matched_count--;\n\t\tif (info.current_count == 0) {\n\t\t\tm_subscriber_owner->DestroySubscriber(m_subscriber);\n\t\t}\n\t} else {\n\t\tm_subscriber_owner->LogError(\"on_subscription_matched: invalid change count\");\n\t}\n}", "CodeBleu_score": 53.517238559190325}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\t// Check if the change in subscription status is for the DataReader that we are interested in.\n\tif (reader!= m_dataReader) {\n\t\treturn;\n\t}\n\n\t// Check if the change in subscription status is for a new subscription or an unmatched subscription.\n\tif (info.current_count_change == 1) {\n\t\t// Increment the matched count.\n\t\tm_matched_count++;\n\n\t\t// If the current count is 1, it means that this is the first time that the DataReader has been matched.\n\t\tif (info.current_count == 1) {\n\t\t\t// Set the first_connected flag.\n\t\t\tm_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t// Decrement the matched count.\n\t\tm_matched_count--;\n\t} else {\n\t\t// Log an error message.\n\t\tstd::cout << \"Error: the change in matched count is invalid.\" << std::endl;\n\t}\n\n\t// If the matched count is 0, it means that there are no more active subscriptions.\n\tif (m_matched_count == 0) {\n\t\t// Destroy the subscriber.\n\t\tm_owner->DestroySubscriber();\n\t}\n}", "CodeBleu_score": 52.559345048711336}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\n\tif (info.current_count_change == 0) {\n\t\tlogError(\"on_subscription_matched: current_count_change == 0\");\n\t} else if (info.current_count_change > 0) {\n\t\tm_matched_count += info.current_count_change;\n\t\tif (!m_first_connected) {\n\t\t\tm_first_connected = true;\n\t\t}\n\t} else {\n\t\tm_matched_count += info.current_count_change;\n\t\tif (m_matched_count == 0) {\n\t\t\tif (m_owner->m_subscriber) {\n\t\t\t\tlogInfo(\"on_subscription_matched: m_matched_count == 0, destroying subscriber\");\n\t\t\t\tm_owner->m_subscriber->DestroySubscriber();\n\t\t\t\tm_owner->m_subscriber = nullptr;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 53.04373389524193}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t/*\n * This function, CarlaCollisionEventPubSubType::getKey, retrieves the key for a CarlaCollisionEvent instance.", "CodeBleu_score": 3.9681564232256745}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tCarlaCollisionEvent* m_data = (CarlaCollisionEvent*)data;\n\t// This function, CarlaCollisionEventPubSubType::getKey, retrieves the key for a CarlaCollisionEvent instance.\nIt first checks if key retrieval is defined and returns false if not.\nIt then serializes the key and, depending on conditions, either computes an MD5 hash or directly copies the key into the handle.\nFinally, it returns true indicating successful key retrieval.\n\tif (!m_md5.m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\teprosima::fastcdr::FastBuffer fastbuffer((char*)m_data, CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS, eprosima::fastcdr::Cdr::DDS_CDR);\n\tm_md5.serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n\t\tm_md5.final(fastbuffer.getBuffer());\n\t\tm_md5.getHash((unsigned char*)handle->value);\n\t\treturn true;\n\t}\n\tfor (unsigned int i = 0; i < CarlaCollisionEvent::getKeyMaxCdrSerializedSize(); ++i) {\n\t\thandle->value[i] = fastbuffer[i];\n\t}\n\treturn true;\n}", "CodeBleu_score": 53.09818166780722}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t/*\n * This function, CarlaCollisionEventPubSubType::getKey, retrieves the key for a CarlaCollisionEvent instance.", "CodeBleu_score": 3.9681564232256745}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tpayload->encapsulation = PL_CDR_LE;\n\tpayload->data = data;\n\tpayload->max_size = getSerializedDataLength();\n\tpayload->length = payload->max_size;\n\teprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);\n\t//create a new type object for CDR Serialization\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n\t\t\teprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS?\n\t\t\tPL_CDR_BE : PL_CDR_LE;\n\ttry\n\t{\n\t\tp_type->serialize(ser);\n\t}\n\tcatch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n\t{\n\t\treturn false;\n\t}\n\n\tpayload->length = (uint32_t)ser.getSerializedDataLength();\n\treturn true;\n}", "CodeBleu_score": 71.8751777067279}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tpayload->encapsulation = Endianness::LITTLE_ENDIAN;\n\tpayload->parentBuffer = nullptr;\n\t// Create a FastBuffer\n\tFastBuffer fastBuffer;\n\n\n\t// Create a Cdr serialization type.\n\tCdr ser(&fastBuffer, payload->encapsulation);\n\n\t// Serialize the object.\n\tif (!ser.serialize(*static_cast<CarlaEgoVehicleControl*>(data))) return false;\n\n\t// Get the serialized length.\n\tpayload->length = fastBuffer.getSerializedDataLength();\n\n\t// Copy the serialized data.\n\tpayload->data = fastBuffer.getBufferPointer();\n\treturn true;\n}", "CodeBleu_score": 35.95784854581109}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tauto p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE; // Set the proper encapsulation.\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        // Serialize the object:\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n    \treturn false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 91.48285654607616}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (sysid_target!= 0) {\n\t\treturn;\n\t}\n\n\tmavlink_msg_heartbeat_t heartbeat;\n\tmavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n\tif (heartbeat.type == MAV_TYPE_GCS) {\n\t\tsysid_target = heartbeat.sysid;\n\n\t\t// request data stream\n\t\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, sysid_target, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, sysid_target, MAV_DATA_STREAM_EXTRA1, 1, 1);\n\t}\n}", "CodeBleu_score": 33.8555280227929}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\t\tif (msg.sysid == sysid_target) {\n\t\t\tmavlink_msg_heartbeat_decode(&msg, &target);\n\t\t\tif (target.type == MAV_TYPE_GCS) {\n\t\t\t\ttarget_set = true;\n\t\t\t\trequest_datastream_position();\n\t\t\t\trequest_datastream_airpressure();\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_SYS_STATUS:\n\t\tif (msg.sysid == sysid_target) {\n\t\t\tmavlink_msg_sys_status_decode(&msg, &target);\n\t\t\tif (target.type == MAV_TYPE_GCS) {\n\t\t\t\ttarget_set = true;\n\t\t\t\trequest_datastream_position();\n\t\t\t\trequest_datastream_airpressure();\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_STATUSTEXT:\n\t\tif (msg.sysid == sysid_target) {\n\t\t\tmavlink_msg_statustext_decode(&msg, &target);\n\t\t\tif (target.type == MAV_TYPE_GCS) {\n\t\t\t\ttarget_set = true;\n\t\t\t\trequest_datastream_position();\n\t\t\t\trequest_datastream_airpressure();\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (target_set) {\n\t\tsysid_target = msg.sysid;\n\t}\n}", "CodeBleu_score": 43.5454909065056}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (sysid_target!= 0) {\n\t\treturn;\n\t}\n\n\tmavlink_msg_heartbeat_t heartbeat;\n\tmavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n\tif (heartbeat.type!= MAV_TYPE_GCS) {\n\t\treturn;\n\t}\n\n\tsysid_target = heartbeat.sysid;\n\trequest_datastream_position();\n\trequest_datastream_airpressure();\n\tset_target_set(true);\n}", "CodeBleu_score": 30.65315240333598}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//MAVLINK_DEBUG_PRINT_MSG(msg);\n\t//", "CodeBleu_score": 7.704762978796939}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t//MAVLINK_DEBUG_PRINTF(\"GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro\n\");\n\treturn GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n}", "CodeBleu_score": 21.282418908381242}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT res = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\tif (res == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\treturn res;\n}", "CodeBleu_score": 51.88020697058299}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0f) {\n\t\treturn tracker.arm_servos();\n\t} else if (packet.param1 == 0.0f) {\n\t\treturn tracker.disarm_servos();\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 44.90957489788029}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0f) {\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0f) {\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 70.48613209326406}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0f) {\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0f) {\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 70.48613209326406}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t#if MAVLINK_NEED_BYTE_SWAP ||!MAVLINK_ALIGNED_FIELDS\n    char buf[MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN];\n    _mav_put_uint8_t(buf, 0, sysid);\n    _mav_put_uint8_t(buf, 1, compid);\n    _mav_put_uint8_t(buf, 2, 0);\n    _mav_put_uint8_t(buf, 3, 1);\n    _mav_put_uint16_t(buf, 4, 100);\n    _mav_put_uint8_t(buf, 6, 1);\n    _mav_put_uint8_t(buf, 7, 0);\n    _mav_put_uint8_t(buf, 8, 0);\n    _mav_put_uint8_t(buf, 9, 0);\n    _mav_put_uint8_t(buf, 10, 0);\n    _mav_put_uint8_t(buf, 11, 0);\n    _mav_put_uint8_t(buf, 12, 0);\n    _mav_put_uint8_t(buf, 13, 0);\n    _mav_put_uint8_t(buf, 14, 0);\n    _mav_put_uint8_t(buf, 15, 0);\n    _mav_put_uint8_t(buf, 16, 0);\n    _mav_put_uint8_t(buf, 17, 0);\n    _mav_put_uint8_t(buf, 18, 0);\n    _mav_put_uint8_t(buf, 19, 0);\n    _mav_put_uint8_t(buf, 20, 0);\n    _mav_put_uint8_t(buf, 21, 0);\n    _mav_put_uint8_t(buf, 22, 0);\n    _mav_put_uint8_t(buf, 23, 0);\n    _mav_put_uint8_t(buf, 24,", "CodeBleu_score": 34.21524557913757}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tmavlink_msg_request_data_stream_t msg;\n\tmavlink_msg_request_data_stream_pack_chan(sysid, compid, MAVLINK_COMM_0, &msg, MAV_DATA_STREAM_POSITION, 10, 1);\n\tmavlink_msg_request_data_stream_send_chan(MAVLINK_COMM_0, &msg);\n}", "CodeBleu_score": 30.059439121504806}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tmavlink_msg_request_data_stream_t req;\n\treq.req_stream_id = MAV_DATA_STREAM_POSITION;\n\treq.req_message_rate = 10;\n\treq.start_stop = 1;\n\treq.target_system = sysid;\n\treq.target_component = compid;\n\tmavlink_msg_request_data_stream_encode(_sysid, _compid, &msg, &req);\n\tsend_message(&msg);\n}", "CodeBleu_score": 36.71451201503505}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch == 0.0f) {\n\t\treturn false;\n\t}\n\n\tef_pitch = atan2f(ahrs.sin_roll * sinf(pitch) + ahrs.cos_roll * cosf(pitch) * sinf(yaw), cosf(pitch));\n\tef_yaw = atan2f(sinf(yaw) * cosf(pitch), cosf(yaw));\n\n\treturn true;\n}", "CodeBleu_score": 41.31444872994753}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Get AHRS instance\n\tAP::ahrs* ahrs = AP::ahrs::get_instance();\n\n\t// Check for zero pitch cosine\n\tif (ahrs->cos_pitch == 0) {\n\t\treturn false;\n\t}\n\n\t// Calculate earth frame pitch and yaw\n\tef_pitch = atan2(sin(pitch), cos(pitch) * sin(yaw) - sin(yaw) * cos(pitch) * ahrs->sin_roll);\n\tef_yaw = atan2(sin(yaw) * cos(pitch) + cos(yaw) * sin(pitch) * ahrs->sin_roll, cos(yaw) * cos(pitch) - sin(yaw) * sin(pitch) * ahrs->sin_roll);\n\n\treturn true;\n}", "CodeBleu_score": 48.78167406569677}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch == 0.0f) {\n\t\treturn false;\n\t}\n\tef_pitch = pitch - ahrs.sin_roll * yaw;\n\tef_yaw = yaw * ahrs.cos_pitch + ahrs.sin_roll * ahrs.sin_pitch * pitch;\n\treturn true;\n}", "CodeBleu_score": 45.35621553275273}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\ttracker.update_yaw_servo();\n\tget_ef_yaw_direction();\n\tconvert_ef_to_bf();\n\ttracker.update_pitch_servo();\n\tconstrain_float(&tracker.pitch_error, -100.0f, 100.0f);\n\tcalc_angle_error();\n\tif (tracker.target_distance!= 0.0f || tracker.min_distance == 0.0f) {\n\t\ttracker.update_pitch_servo();\n\t\ttracker.update_yaw_servo();\n\t}\n}", "CodeBleu_score": 16.043368800766686}, {"code": "void Mode::update_auto(void){\n\t\tif (tracker.get_nav_status() == NAV_STATUS_LOITER) {\n\t\ttracker.set_target_yaw(tracker.get_target_yaw() + tracker.get_nav_yaw_rate());\n\t\ttracker.set_target_pitch(tracker.get_target_pitch() + tracker.get_nav_pitch_rate());\n\t}\n\n\ttracker.update_yaw_servo();\n\tget_ef_yaw_direction();\n\tconvert_ef_to_bf();\n\ttracker.update_pitch_servo();\n\tconstrain_float(&tracker.get_target_yaw(), -180.0f, 180.0f);\n\tconstrain_float(&tracker.get_target_pitch(), -180.0f, 180.0f);\n\tcalc_angle_error();\n\n\tif (tracker.get_target_distance() >= tracker.get_min_distance() || tracker.get_min_distance() == 0.0f) {\n\t\ttracker.update_yaw_servo();\n\t\ttracker.update_pitch_servo();\n\t}\n}", "CodeBleu_score": 22.220525365786347}, {"code": "void Mode::update_auto(void){\n\t\ttracker.update_yaw_servo();\n\tget_ef_yaw_direction();\n\tconvert_ef_to_bf();\n\ttracker.update_pitch_servo();\n\tconstrain_float();\n\tcalc_angle_error();\n\tif (tracker.get_target_distance() > 0 || tracker.get_min_distance() == 0) {\n\t\ttracker.update_pitch_servo();\n\t\ttracker.update_yaw_servo();\n\t}\n}", "CodeBleu_score": 14.930194499829044}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tif (gps.update()) {\n\t\t// check if the last message time has changed\n\t\tif (gps.last_message_time_ms!= _last_gps_message_time_ms) {\n\t\t\t_last_gps_message_time_ms = gps.last_message_time_ms;\n\t\t\tif (gps.status >= GPS::GPS_STATUS_3D_FIX) {\n\t\t\t\t// if the GPS status is at least 3D fix\n\t\t\t\tif (_ground_start_countdown > 0) {\n\t\t\t\t\t// if the countdown is not zero\n\t\t\t\t\t// decrease the countdown\n\t\t\t\t\t_ground_start_countdown--;\n\t\t\t\t} else {\n\t\t\t\t\t// if the countdown is zero\n\t\t\t\t\t// set the home location\n\t\t\t\t\tif (set_home()) {\n\t\t\t\t\t\t// if the home location was set\n\t\t\t\t\t\t// reset the countdown\n\t\t\t\t\t\t_ground_start_countdown = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if the GPS status is not at least 3D fix\n\t\t\t\t// reset the countdown\n\t\t\t\t_ground_start_countdown = GROUND_START_COUNTDOWN_MAX;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.33892717049722}, {"code": "void Tracker::update_GPS(void){\n\t\t//Update the GPS\n\tgps.update();\n\n\t//Check if the GPS status is at least 3D fix\n\tif (gps.status() >= 3) {\n\t\t//Check if the last message time has changed\n\t\tif (gps.last_message_time_ms!= last_message_time_ms) {\n\t\t\t//Update the last message time\n\t\t\tlast_message_time_ms = gps.last_message_time_ms;\n\n\t\t\t//Check if the home location has not been set yet\n\t\t\tif (!home_location_set) {\n\t\t\t\t//Check if the ground start countdown has reached one\n\t\t\t\tif (ground_start_countdown == 1) {\n\t\t\t\t\t//Check if the current location is valid\n\t\t\t\t\tif (gps.location.is_valid()) {\n\t\t\t\t\t\t//Set the home location\n\t\t\t\t\t\tset_home();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//Decrement the ground start countdown\n\t\t\t\t\tground_start_countdown--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 33.03122555266575}, {"code": "void Tracker::update_GPS(void){\n\t\t//update the GPS\n\tgps.update();\n\n\t//check if the last message time has changed\n\tif(gps.last_message_time_ms!= _last_message_time_ms) {\n\t\t//set the last message time\n\t\t_last_message_time_ms = gps.last_message_time_ms;\n\n\t\t//check if the GPS status is at least 3D fix\n\t\tif(gps.status >= 3) {\n\t\t\t//set the home location if the current location is valid\n\t\t\tif(gps.location.is_valid()) {\n\t\t\t\t//set the home location\n\t\t\t\tset_home(gps.location);\n\n\t\t\t\t//reset the countdown\n\t\t\t\t_ground_start_countdown = GROUND_START_COUNTDOWN;\n\t\t\t} else {\n\t\t\t\t//reset the countdown\n\t\t\t\t_ground_start_countdown = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t//check if the countdown is valid\n\tif(_ground_start_countdown > 0) {\n\t\t//decrement the countdown\n\t\t_ground_start_countdown--;\n\t}\n}", "CodeBleu_score": 37.820117376238116}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// If the pitch is not set, do nothing\n\tif (pitch == 0.0f) {\n\t\treturn;\n\t}\n\n\t// If the pitch is set, set the pitch\n\telse {\n\t\t// Set the pitch\n\t\t_pitch_onoff_servo.set_scaled(pitch);\n\t}\n}", "CodeBleu_score": 11.952730772428003}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a check for the pitch to be in the range [-1, 1].\n\t// TODO: Add a", "CodeBleu_score": 4.619414654306504}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// TODO: this is a temporary solution to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper way to get the pitch angle\n\t// TODO: this should be replaced by a proper", "CodeBleu_score": 4.619604510974864}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\tif (AP_Param::function_enabled(AP_Param::AP_ARMING_CHECK_BARO)) {\n\t\tif (fabsf(copter.inertial_nav.get_filter_status() - AP_InertialNav::FILTER_OK) > 0.01f) {\n\t\t\tif (display_failure) {\n\t\t\t\t_failure_reason = ARMING_CHECK_BARO;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (fabsf(copter.inertial_nav.get_position_z_up_cm() - copter.barometer.get_reference_pressure_cm()) > 500.0f) {\n\t\t\tif (display_failure) {\n\t\t\t\t_failure_reason = ARMING_CHECK_BARO;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 46.761419206949206}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool rc = AP_Arming::barometer_checks(display_failure);\n\tif (display_failure && _check_enabled(ARMING_CHECK_BARO)) {\n\t\tfloat baro_alt = copter.inertial_nav.get_filter_status().alt_baro_cm;\n\t\tfloat inertial_alt = copter.inertial_nav.get_position_z_up_cm();\n\t\tfloat diff = fabsf(inertial_alt - baro_alt);\n\t\tif (diff > ARMING_BARO_MAX_DIFF_CM) {\n\t\t\tcheck_failed(ARMING_CHECK_BARO, \"Baro altitude disparity\", diff, ARMING_BARO_MAX_DIFF_CM);\n\t\t\trc = false;\n\t\t}\n\t}\n\treturn rc;\n}", "CodeBleu_score": 47.457106044574566}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call base class\n\tbool result = AP_Arming::barometer_checks(display_failure);\n\n\t// check for barometer altitude disparity\n\tif (ARMING_CHECK_BARO &&!result) {\n\t\treturn false;\n\t}\n\n\t// check for barometer altitude disparity\n\tif (ARMING_CHECK_BARO && fabsf(copter.inertial_nav.get_position_z_up_cm() - copter.barometer.get_altitude_cm()) > ARMING_BARO_DISPARITY_CM) {\n\t\t// log failure\n\t\tif (display_failure) {\n\t\t\tcopter.console.printf_P(PSTR(\"BARO DISPARITY FAIL\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// success\n\treturn true;\n}", "CodeBleu_score": 37.921778349062684}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == AP_Terrain::RANGEFINDER) {\n\t\treturn false;\n\t} else if (copter.mode_rtl.get_alt_type() == AP_Mode_RTL::ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 58.42031190605299}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::TERRAIN_RANGEFINDER) {\n\t\treturn false;\n\t}\n\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::TERRAIN_DATABASE && copter.mode_rtl.get_alt_type() == AP_Mode_RTL::ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 73.29117662714044}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == AP_Waypoint::TERRAIN_RANGEFINDER) {\n\t\treturn false;\n\t}\n\tif (copter.mode_rtl.get_alt_type() == AP_Mode_RTL::ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 59.78617519341736}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// set dt\n\tattitude_control->set_dt(scheduler.get_last_loop_time_s());\n\tpos_control->set_dt(scheduler.get_last_loop_time_s());\n\tmotors->set_dt(scheduler.get_last_loop_time_s());\n\n\t// run rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 43.980681966341784}, {"code": "void Copter::run_rate_controller(){\n\t\t// Set the loop time for the rate controllers\n\tattitude_control->set_dt(scheduler.get_last_loop_time_s());\n\tpos_control->set_dt(scheduler.get_last_loop_time_s());\n\tmotors->set_dt(scheduler.get_last_loop_time_s());\n\n\t// Run the low-level rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 43.980681966341784}, {"code": "void Copter::run_rate_controller(){\n\t\t//get the last loop time from the scheduler\n\tfloat last_loop_time_s = AP::scheduler().get_last_loop_time_s();\n\n\t//set the dt for the rate controllers\n\tattitude_control->set_dt(last_loop_time_s);\n\tpos_control->set_dt(last_loop_time_s);\n\tmotors->set_dt(last_loop_time_s);\n\n\t//run the low-level rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 75.20731022218139}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.same_loc_as(new_loc) && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t_target_location = new_loc;\n\n\treturn true;\n}", "CodeBleu_score": 52.14575154891108}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (!old_loc.same_loc_as(new_loc) || old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t_target_location = new_loc;\n\treturn true;\n}", "CodeBleu_score": 55.349495633758664}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.same_loc_as(new_loc) && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t_target_location = new_loc;\n\treturn true;\n}", "CodeBleu_score": 52.14575154891108}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\t// Set the mode\n\t\tif (copter.set_mode(mode)) {\n\t\t\t// Reset the mode switch\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t} else if (copter.flightmode->mode_number == mode) {\n\t\t// Reset the mode switch\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 58.213940013488106}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (copter.flightmode->mode_number == mode) {\n\t\t\tcopter.flightmode->reset_mode_switch();\n\t\t} else {\n\t\t\tcopter.set_mode(mode);\n\t\t}\n\t}\n}", "CodeBleu_score": 49.189102291577555}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode!= copter.get_mode()) {\n\t\t\tcopter.set_mode(mode);\n\t\t}\n\t} else if (copter.get_mode() == mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 55.41514786123163}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\tfloat roll_trim = ToRad(channel_roll->get_control_in() - channel_roll->get_control_in_min());\n\tfloat pitch_trim = ToRad(channel_pitch->get_control_in() - channel_pitch->get_control_in_min());\n\tahrs.add_trim(roll_trim, pitch_trim);\n\tLOGGER_WRITE_EVENT(MAV_SEVERITY_INFO, \"Trimmed roll %f, pitch %f\", roll_trim, pitch_trim);\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trimmed roll %f, pitch %f\", roll_trim, pitch_trim);\n}", "CodeBleu_score": 55.686506885936005}, {"code": "void Copter::save_trim(){\n\t\t// roll and pitch trim values\n\tfloat roll_trim = (channel_roll->get_control_in() - 1500) / 500.0f * M_PI_F;\n\tfloat pitch_trim = (channel_pitch->get_control_in() - 1500) / 500.0f * M_PI_F;\n\n\t// add the trim values to the AHRS trim\n\tahrs.add_trim(roll_trim, pitch_trim, 0.0f);\n\n\t// log the event\n\tLOGGER_WRITE_EVENT(1, \"Trim saved\");\n\n\t// send a confirmation message\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 63.88010666078383}, {"code": "void Copter::save_trim(){\n\t\t/*\n\t * This function, Copter::save_trim, saves the roll and pitch trim values.", "CodeBleu_score": 11.675606791188695}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Retrieve the copter's velocity\n\tVector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n\t// Calculate the speed squared\n\tfloat speed_squared = vel.xy().length_squared();\n\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (copter.position_ok() && speed_squared > MIN_SPEED_SQUARED) {\n\t\t// Calculate the look-ahead yaw angle\n\t\tfloat look_ahead_yaw = atan2f(vel.y(), vel.x());\n\n\t\t// Return the look-ahead yaw angle\n\t\treturn look_ahead_yaw;\n\t}\n\n\t// Otherwise, return the current yaw angle\n\treturn copter.yaw_angle_rad;\n}", "CodeBleu_score": 52.49559976271403}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tif (copter.position_ok && vel.xy().length_squared() > sq(MIN_VEL_FOR_YAW_LOOK_AHEAD)) {\n\t\treturn atan2f(vel.x, vel.y);\n\t}\n\treturn 0.0f;\n}", "CodeBleu_score": 22.484539292915002}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Retrieve the copter's velocity\n\tVector2f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n\t// Calculate the speed squared\n\tfloat speed_squared = vel.length_squared();\n\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (copter.position_ok && speed_squared > look_ahead_yaw_min_speed_squared) {\n\t\t// Calculate the look-ahead yaw angle using the arctangent of the velocity components\n\t\tlook_ahead_yaw_angle = atan2f(vel.y(), vel.x());\n\t}\n\n\t// Return the look-ahead yaw angle\n\treturn look_ahead_yaw_angle;\n}", "CodeBleu_score": 46.96866478326835}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tswitch (method) {\n\t\tcase AP_Arming::Method::RUDDER:\n\t\t\tif (get_rudder_arming_type() == RUDDER_ARMING_DISABLED || plane.get_throttle_input()!= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 34.123117525158385}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\t// RUDDER arming: if rudder arming is disabled, or the throttle is not zero, return false\n\t\tif (!gcs().rudder_arming_enabled ||!plane.get_throttle_input()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// check if arming checks are disabled or the watchdog was armed\n\tif (hal.util->was_watchdog_armed ||!gcs().arming_checks_enabled) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 47.152032529406874}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::Method::RUDDER) {\n\t\tif (gcs().rudder_arming_disabled() || plane.get_throttle_input() == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 37.60080082721677}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// if we are already armed, return immediately\n\tif (state == ARMED) {\n\t\treturn true;\n\t}\n\n\t// if we are already disarmed, return immediately\n\tif (state == DISARMED) {\n\t\treturn false;\n\t}\n\n\t// if we are already arming, return immediately\n\tif (state == ARMING) {\n\t\treturn true;\n\t}\n\n\t// if we are already disarming, return immediately\n\tif (state == DISARMING) {\n\t\treturn true;\n\t}\n\n\t// if we are already arming_hold, return immediately\n\tif (state == ARMING_HOLD) {\n\t\treturn true;\n\t}\n\n\t// if we are already disarming_hold, return immediately\n\tif (state == DISARMING_HOLD) {\n\t\treturn true;\n\t}\n\n\t// if we are already arming_hold_and_disarming, return immediately\n\tif (state == ARMING_HOLD_AND_DISARMING) {\n\t\treturn true;\n\t}\n\n\t// if we are already disarming_hold_and_arming, return immediately\n\tif (state == DISARMING_HOLD_AND_ARMING) {\n\t\treturn true;\n\t}\n\n\t// if we are already arming_and_disarming, return immediately\n\tif (state == ARMING_AND_DISARMING) {\n\t\treturn true;\n\t}\n\n\t// if we are already disarming_and_arming, return immediately\n\tif (state == DISARMING_AND_ARMING) {\n\t\treturn true;\n\t}\n\n\t// if we are already arming_and_disarming_and_arming, return immediately\n\tif (state == ARMING_AND_DISARMING_AND_ARMING) {\n\t\treturn true;\n\t}\n\n\t// if we are already disarming_and_disarming_and_arming, return immediately\n\tif (state == DISARMING_AND_DISARMING_AND_ARMING) {\n\t\treturn true;\n\t}\n\n\t// if we are already arming_and_disarming_and_disarming, return immediately\n\tif (state == ARMING_", "CodeBleu_score": 20.140755649392112}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool success = false;\n\tif (do_arming_checks) {\n\t\t// check if we are already armed\n\t\tif (is_armed()) {\n\t\t\t// we are already armed\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we are already disarmed\n\t\tif (is_disarmed()) {\n\t\t\t// we are already disarmed\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we are already in the process of arming or disarming\n\t\tif (is_arming()) {\n\t\t\t// we are already arming or disarming\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if we are already in the process of changing the arm state\n\t\tif (is_changing_arm_state()) {\n\t\t\t// we are already changing the arm state\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// arm the plane\n\tsuccess = arm_plane(method);\n\n\t// if we are successful, update the home location and set it in the AHRS system\n\tif (success) {\n\t\tupdate_home();\n\t\tahrs.set_home();\n\t}\n\n\t// update the current location\n\tupdate_current_loc();\n\n\t// change the arm state\n\tchange_arm_state(true);\n\n\t// set a delay arming flag\n\tdelay_arming = true;\n\n\t// send a status text indicating that the throttle is armed\n\tsend_arm_disarm_statustext(true);\n\n\t// return the success of the arm process\n\treturn success;\n}", "CodeBleu_score": 45.51039877097873}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (do_arming_checks) {\n\t\tif (method == AP_Arming::Method::ARM_WHEN_STABLE) {\n\t\t\t// only arm when the plane is stable\n\t\t\tif (!_plane.is_stable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (method == AP_Arming::Method::ARM_WHEN_GPS_HOME_SET) {\n\t\t\t// only arm when the plane has a GPS home set\n\t\t\tif (!_plane.gps_home_set()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (method == AP_Arming::Method::ARM_WHEN_GPS_FIX) {\n\t\t\t// only arm when the plane has a GPS fix\n\t\t\tif (!_plane.gps_fix()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (method == AP_Arming::Method::ARM_WHEN_GPS_HOLD) {\n\t\t\t// only arm when the plane has a GPS hold\n\t\t\tif (!_plane.gps_hold()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// arm the plane\n\t_plane.arm();\n\n\t// update the home location\n\t_plane.update_home();\n\n\t// update the current location\n\t_plane.update_current_loc();\n\n\t// change the arm state\n\t_arm_state = ArmState::ARMED;\n\n\t// set a delay arming flag\n\t_delay_arming = true;\n\n\t// send a status text indicating that the throttle is armed\n\t_plane.send_arm_disarm_statustext(true);\n\n\t// set the home location in the AHRS system\n\t_plane.ahrs.set_home();\n\n\treturn true;\n}", "CodeBleu_score": 51.18825699027817}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (_vehicle->armed()) {\n\t\treturn true;\n\t}\n\tif (_vehicle->disarm_button_configured()) {\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t}\n\tif (display_failure) {\n\t\t_vehicle->console->printf_P(PSTR(\"Disarm button not configured\n\"));\n\t}\n\treturn false;\n}", "CodeBleu_score": 58.4338606895891}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// check if we have a disarm button\n\tif (!has_disarm_function()) {\n\t\t// if we don't have a disarm function, and we are required to display a failure message, do so\n\t\tif (display_failure) {\n\t\t\t// display a failure message\n\t\t\t_vehicle->console->printf(\"Disarm button not configured\n\");\n\t\t}\n\t\t// return failure\n\t\treturn false;\n\t}\n\t// call the standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 59.60913117189865}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\tif (disarm_button_configured) {\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t}\n\n\tif (display_failure) {\n\t\tif (disarm_button_configured) {\n\t\t\t_vehicle->console->printf(\"Disarm button not configured, cannot arm.\n\");\n\t\t} else {\n\t\t\t_vehicle->console->printf(\"No disarm button configured, cannot arm.\n\");\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 56.36792840476459}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * ahrs.cos_yaw + y * ahrs.sin_yaw;\n\tfloat ne_y = y * ahrs.cos_yaw - x * ahrs.sin_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 64.76818684010604}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n\tfloat ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 64.97989391078337}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x*ahrs.cos_yaw + y*ahrs.sin_yaw;\n\tfloat ne_y = -x*ahrs.sin_yaw + y*ahrs.cos_yaw;\n\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 65.5836392837163}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t//MAV_RESULT retval = MAV_RESULT_DENIED;\n\n\t//if (is_zero(packet.param1) && is_zero(packet.param2) && is_zero(packet.param3) && is_zero(packet.param4)) {\n\t//\tretval = MAV_RESULT_ACCEPTED;\n\t//}\n\n\t//return retval;\n}", "CodeBleu_score": 3.7009555325471415}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t//MAV_CMD_CONDITION_YAW\n\t//uint16_t target_system\n\t//uint16_t target_component\n\t//float param1_yaw_or_rate\n\t//float param2_yaw_or_pitch_rate\n\t//float param3_pitch_or_throttle\n\t//float param4_roll_or_rpy[4]\n\t//uint16_t command\n\t//uint8_t confirmation\n\t//uint8_t param5_yaw_or_rate_lock\n\t//uint8_t param6_yaw_or_pitch_rate_lock\n\t//uint8_t param7_pitch_or_throttle_lock\n\t//uint8_t param8_roll_or_rpy_lock\n\t//uint8_t param9_yaw_or_rate_lock_source\n\t//uint8_t param10_yaw_or_pitch_rate_lock_source\n\t//uint8_t param11_pitch_or_throttle_lock_source\n\t//uint8_t param12_roll_or_rpy_lock_source\n\t//uint8_t param13_yaw_or_rate_lock_enable\n\t//uint8_t param14_yaw_or_pitch_rate_lock_enable\n\t//uint8_t param15_pitch_or_throttle_lock_enable\n\t//uint8_t param16_roll_or_rpy_lock_enable\n\t//uint8_t param17_yaw_or_rate_lock_enable_source\n\t//uint8_t param18_yaw_or_pitch_rate_lock_enable_source\n\t//uint8_t param19_pitch_or_throttle_lock_enable_source\n\t//uint8_t param20_roll_or_rpy_lock_enable_source\n\t//uint8_t param21_yaw_or_rate_lock_enable_source_override\n\t//uint8_t param22_yaw_or_pitch_rate_lock_enable_source_override\n\t//uint8_t param23_pitch_or_throttle_lock_enable_source_override\n\t//uint8_t", "CodeBleu_score": 3.5541344618733928}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t//MAV_CMD_CONDITION_YAW\n\t//param1, yaw angle in degrees, -180.000000 to +180.000000\n\t//param2, yaw speed in deg/s, -1000 to +1000\n\t//param3, direction: negative: counter clockwise, positive: clockwise, 0: stop\n\t//param4, relative offset in cm from current yaw, -10000 to +10000\n\t//param5, 0: use current yaw, 1: use param1\n\t//param6, 0: use current yaw speed, 1: use param2\n\t//param7, 0: use current direction, 1: use param3\n\n\tif (packet.param5 == 0) {\n\t\tif (packet.param1 < -180.0f || packet.param1 > 180.0f) {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t}\n\n\tif (packet.param6 == 0) {\n\t\tif (packet.param2 < -1000 || packet.param2 > 1000) {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t}\n\n\tif (packet.param7 == 0) {\n\t\tif (packet.param3!= 0 && packet.param3!= 1) {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t}\n\n\tif (packet.param4 < -10000 || packet.param4 > 10000) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (packet.param5 == 1) {\n\t\tif (packet.param1 < -180.0f || packet.param1 > 180.0f) {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t}\n\n\tif (packet.param6 == 1) {\n\t\tif (packet.param2 < -1000 || packet.param2 > 1000) {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t}\n\n\tif (packet", "CodeBleu_score": 44.564091427224525}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _sub.wp_nav.high_latency_tgt_heading;\n}", "CodeBleu_score": 26.800016119540203}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn mavlink_to_int_uint8_t(get_field(HIGH_LATENCY_TGT_HEADING));\n}", "CodeBleu_score": 7.004007615731678}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn (uint8_t)this->sub.wp_nav.get_high_latency_tgt_heading();\n}", "CodeBleu_score": 8.455295547882908}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tLog_Packet_Header header;\n\t\theader.timestamp = AP_HAL::micros64();\n\t\theader.id = id;\n\t\theader.value = value;\n\t\tlogger.WriteCriticalBlock(&header, sizeof(header));\n\t}\n}", "CodeBleu_score": 42.84518711930227}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tAP_HAL::micros64 now = AP_HAL::micros64();\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_OUTPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_INPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_OUTPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_INPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_OUTPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_INPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_OUTPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_INPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_OUTPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_INPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_OUTPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_INPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_OUTPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_INPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_OUTPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_INPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_OUTPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_INPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_OUTPUT);\n\t\tAP_HAL::Pins::PinMode(AP_HAL::Pins::PINMODE_INPUT);\n\t\tAP", "CodeBleu_score": 32.532788983994415}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tAP_HAL::micros64 timestamp = AP_HAL::micros64();\n\t\tLogPacket packet;\n\t\tpacket.header.timestamp = timestamp;\n\t\tpacket.header.id = id;\n\t\tpacket.data = value;\n\t\tlogger.WriteCriticalBlock(packet);\n\t}\n}", "CodeBleu_score": 39.96866922882115}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set) {\n\t\treturn;\n\t}\n\n\tif (motors.armed) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location();\n\t}\n}", "CodeBleu_score": 33.90327014943925}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set) {\n\t\treturn;\n\t}\n\n\tif (motors.armed) {\n\t\tset_home_to_current_location_inflight();\n\t\treturn;\n\t}\n\n\tset_home_to_current_location();\n}", "CodeBleu_score": 27.358841830727187}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set()) {\n\t\treturn;\n\t}\n\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location();\n\t}\n}", "CodeBleu_score": 46.847088140026}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\tif (!_attitude_control->armed()) {\n\t\t_motors->set_throttle(0.0f);\n\t\t_motors->set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\t\t_attitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\t_motors->set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\n\t_attitude_control->set_throttle_out(_channel_throttle->norm_input());\n\t_attitude_control->set_roll_pitch_out(_channel_roll->get_control_in(), _channel_pitch->get_control_in());\n\t_attitude_control->set_yaw_out(_channel_yaw->get_control_in());\n\n\t_motors->set_lateral(_channel_lateral->norm_input());\n\t_motors->set_forward(_channel_forward->norm_input());\n}", "CodeBleu_score": 40.16627624190248}, {"code": "void ModeAcro::run(){\n\t\tif (!_armed) {\n\t\t_motors.set_desired_spool_state(Motor::SPOOL_UNLIMITED);\n\t\t_attitude_control.relax_attitude_controllers();\n\t\t_motors.set_throttle(0.0f);\n\t\t_motors.set_lateral(0.0f);\n\t\t_motors.set_forward(0.0f);\n\t\treturn;\n\t}\n\n\t_motors.set_desired_spool_state(Motor::SPOOL_UNLIMITED);\n\t_attitude_control.set_throttle_out(_channel_throttle->get_control_in());\n\t_attitude_control.set_desired_roll_rate(_channel_roll->get_control_in());\n\t_attitude_control.set_desired_pitch_rate(_channel_pitch->get_control_in());\n\t_attitude_control.set_desired_yaw_rate(_channel_yaw->get_control_in());\n\t_attitude_control.set_desired_lateral_rate(_channel_lateral->get_control_in());\n\t_attitude_control.set_desired_forward_rate(_channel_forward->get_control_in());\n\n\t_attitude_control.run();\n\t_motors.set_lateral(_attitude_control.get_lateral_output());\n\t_motors.set_forward(_attitude_control.get_forward_output());\n}", "CodeBleu_score": 45.2420491394539}, {"code": "void ModeAcro::run(){\n\t\tif (motors.armed()) {\n\t\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\t\tattitude_control->set_throttle_out(channel_throttle->norm_input);\n\t\tattitude_control->input_rate_bf_roll_pitch_yaw(channel_roll->get_control_in(), channel_pitch->get_control_in(), channel_yaw->get_control_in());\n\t\tattitude_control->run();\n\t\tmotors.set_forward(channel_forward->norm_input);\n\t\tmotors.set_lateral(channel_lateral->norm_input);\n\t} else {\n\t\tmotors.set_desired_spool_state(SpoolState::OFF);\n\t\tattitude_control->relax_attitude_controllers();\n\t}\n}", "CodeBleu_score": 35.98230988189602}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\tset_mode_and_arm(GUIDED);\n\twp_nav.set_wp_destination(wp_nav.get_wp_stopping_point());\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n\twp_nav.wp_and_spline_init();\n}", "CodeBleu_score": 29.738599713177283}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set the mode to position control mode\n\tset_mode(GUIDED);\n\t// Initialize the waypoint controller\n\tsub.wp_nav.wp_and_spline_init();\n\t// Get the stopping point\n\tVector3f stopping_point = get_stopping_point();\n\t// Set the stopping point as the waypoint destination\n\tsub.wp_nav.set_wp_destination(stopping_point);\n\t// Set the yaw using the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 43.73514524331135}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set the mode to position control mode\n\tset_mode(GUIDED);\n\n\t// Retrieve the stopping point\n\tVector3f stopping_point = get_wp_stopping_point();\n\n\t// Set the waypoint destination to the stopping point\n\tset_wp_destination(stopping_point);\n\n\t// Set the yaw mode to the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 22.366608212750503}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Initialize vertical maximum speeds and acceleration using pilot-defined parameters.\n\t_position_control->set_max_speed_accel_z(_params.max_vel_z, _params.max_accel_z);\n\n\t// Initialize the vertical velocity controller.\n\t_position_control->init_z_controller();\n\n\t// Initialize the horizontal velocity controller.\n\t_position_control->init_xy_controller();\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw.\n\tset_auto_yaw_mode(true);\n}", "CodeBleu_score": 34.05193128046752}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t//set guided mode to velocity controller\n\t_mode = GUIDED_VELOCITY_CONTROL;\n\n\t//set vertical maximum speeds and acceleration\n\t_params->set_max_speed_accel_z(_params->get_max_speed_z(), _params->get_max_accel_z());\n\n\t//initialize vertical velocity controller\n\t_position_control->init_z_controller();\n\n\t//initialize horizontal velocity controller\n\t_position_control->init_xy_controller();\n\n\t//set yaw control mode to AUTO_YAW_HOLD\n\t_yaw_mode = AUTO_YAW_HOLD;\n}", "CodeBleu_score": 35.561274371223035}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Initialize vertical maximum speeds and acceleration\n\t// using pilot-defined parameters\n\t_vertical_max_speed_accel = _param_v_max_up_dn.get();\n\t_vertical_max_speed_accel_z = _param_v_max_up_dn_z.get();\n\t_vertical_max_speed_accel_z_up = _param_v_max_up_dn_z_up.get();\n\t_vertical_max_speed_accel_z_down = _param_v_max_up_dn_z_down.get();\n\t_vertical_max_speed_accel_z_up_down = _param_v_max_up_dn_z_up_down.get();\n\t_vertical_max_speed_accel_z_up_down_v2 = _param_v_max_up_dn_z_up_down_v2.get();\n\t_vertical_max_speed_accel_z_up_down_v3 = _param_v_max_up_dn_z_up_down_v3.get();\n\n\t// Initialize vertical and horizontal velocity controllers\n\t_position_control->init_z_controller();\n\t_position_control->init_xy_controller();\n\n\t// Set yaw control mode to AUTO_YAW_HOLD, indicating that the\n\t// pilot always controls yaw\n\t_yaw_mode = YawMode::AUTO_YAW_HOLD;\n}", "CodeBleu_score": 28.43617364301948}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\tif (guided_limit.timeout_ms!= 0 && millis() - guided_limit.start_time > guided_limit.timeout_ms) {\n\t\treturn true;\n\t}\n\n\tif (guided_limit.min_alt_cm!= 0 && curr_pos.alt_cm < guided_limit.min_alt_cm) {\n\t\treturn true;\n\t}\n\n\tif (guided_limit.max_alt_cm!= 0 && curr_pos.alt_cm > guided_limit.max_alt_cm) {\n\t\treturn true;\n\t}\n\n\tif (guided_limit.max_horiz_dist_cm!= 0) {\n\t\tfloat dist = get_horizontal_distance_cm(guided_limit.start_pos, curr_pos);\n\t\tif (dist > guided_limit.max_horiz_dist_cm) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 54.345510582910094}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// TODO: Implement guided_limit_check\n\treturn false;\n}", "CodeBleu_score": 2.0176401258941974}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if timeout has been exceeded\n\tif (AP_HAL::millis() - _start_time > _timeout) {\n\t\treturn true;\n\t}\n\n\t// Check if current altitude is below minimum threshold\n\tif (_current_alt < _min_alt) {\n\t\treturn true;\n\t}\n\n\t// Check if current altitude is above maximum threshold\n\tif (_current_alt > _max_alt) {\n\t\treturn true;\n\t}\n\n\t// Check if horizontal distance moved exceeds limit\n\tif (get_horizontal_distance_cm() > _max_dist) {\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false\n\treturn false;\n}", "CodeBleu_score": 17.677792601684956}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\t// if the motor test is enabled\n\tif (motor_test_enabled) {\n\t\t// if the motor test is armed\n\t\tif (motor_test_armed) {\n\t\t\t// if the motor test is running\n\t\t\tif (motor_test_running) {\n\t\t\t\t// if the motor test is done\n\t\t\t\tif (motor_test_done) {\n\t\t\t\t\t// if the motor test is passed\n\t\t\t\t\tif (motor_test_pass) {\n\t\t\t\t\t\t// return true\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor test is not passed\n\t\t\t\t\t\t// if the motor", "CodeBleu_score": 8.143986919493118}, {"code": "bool Sub::verify_motor_test(){\n\t\t// Check if the motor test has been requested\n\tif (gcs().send_text(MAV_SEVERITY_INFO, \"Motor test started\")) {\n\t\t// Set the motor test flag\n\t\tmotor_test_flag = true;\n\t} else {\n\t\t// Set the motor test flag\n\t\tmotor_test_flag = false;\n\t\t// Set the pass flag\n\t\tpass_flag = false;\n\t\t// Disarm the system\n\t\tarming().disarm();\n\t\t// Record the failure time\n\t\tfailure_time = millis();\n\t\t// Send a timeout message\n\t\tgcs().send_text(MAV_SEVERITY_ERROR, \"Motor test timed out\");\n\t\t// Return false\n\t\treturn false;\n\t}\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 47.41123785398915}, {"code": "bool Sub::verify_motor_test(){\n\t\t// If the motor test is not running, return true\n\tif (!motor_test_running) {\n\t\treturn true;\n\t}\n\t// If the motor test is running, check if the time is up\n\tif (AP::millis() - motor_test_start_time > motor_test_timeout) {\n\t\t// If the timeout has occurred, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false\n\t\tgcs().send_text(MAV_SEVERITY_ERROR, \"Motor Test Timeout\");\n\t\tmotor_test_pass = false;\n\t\tmotor_test_running = false;\n\t\tAP::arming().disarm();\n\t\tmotor_test_failure_time = AP::millis();\n\t\treturn false;\n\t}\n\t// If the time is not up, return true\n\treturn true;\n}", "CodeBleu_score": 52.39497144119652}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// roll and pitch are in centidegrees\n\tfloat roll = constrain_int16(wp_nav.get_roll() * 100.0f, -MAX_TILT_ANGLE_DEG * 100.0f, MAX_TILT_ANGLE_DEG * 100.0f);\n\tfloat pitch = constrain_int16(wp_nav.get_pitch() * 100.0f, -MAX_TILT_ANGLE_DEG * 100.0f, MAX_TILT_ANGLE_DEG * 100.0f);\n\n\t// normalize\n\tfloat roll_norm = roll / MAX_TILT_ANGLE_DEG;\n\tfloat pitch_norm = pitch / MAX_TILT_ANGLE_DEG;\n\n\t// constrain\n\troll_norm = constrain(roll_norm, -1.0f, 1.0f);\n\tpitch_norm = constrain(pitch_norm, -1.0f, 1.0f);\n\n\t// assign\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 33.287072664167106}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target_deg = constrain_int16(wp_nav.get_roll(), -max_roll_deg, max_roll_deg);\n\tfloat pitch_target_deg = constrain_int16(wp_nav.get_pitch(), -max_pitch_deg, max_pitch_deg);\n\n\tfloat roll_target_norm = roll_target_deg / max_roll_deg;\n\tfloat pitch_target_norm = pitch_target_deg / max_pitch_deg;\n\n\tlateral_out = roll_target_norm;\n\tforward_out = pitch_target_norm;\n}", "CodeBleu_score": 35.7730772779415}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub\n\t//TODO: this is a stub", "CodeBleu_score": 3.498216049527081}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// Update the barometer data\n\tbarometer.update();\n\n\t// Update the barometer calibration\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\n\t// Update the sensor health\n\tif (depth_sensor.healthy()) {\n\t\tbarometer.set_healthy(true);\n\t} else {\n\t\tbarometer.set_healthy(false);\n\t}\n}", "CodeBleu_score": 66.31764202303607}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (depth_sensor.get_depth() > 0) {\n\t\tbarometer.update_health();\n\t}\n}", "CodeBleu_score": 56.19998175680573}, {"code": "void Sub::read_barometer(){\n\t\tif(barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\n\tif(depth_sensor.get_altitude() > 0) {\n\t\tdepth_sensor.update_health();\n\t}\n}", "CodeBleu_score": 49.4938943552933}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\n\tif (inertial_nav.get_filter_status() == InertialNav::FILTER_STATUS_CONSTANT_POSITION) {\n\t\treturn false;\n\t}\n\n\treturn ahrs.get_position_ok();\n}", "CodeBleu_score": 33.002928078664695}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// if inertial navigation is not available, return false\n\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\t// if the motors are disarmed, accept a predicted horizontal position\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\n\t// if the motors are armed, require a good absolute position\n\tif (ahrs.get_filter_status()!= AHRS_FILTER_OK) {\n\t\treturn false;\n\t}\n\n\t// ensure the EKF is not in constant position mode\n\tif (ekf.get_filter_status() == EKF_FILTER_CONST_POS) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 33.05937700176624}, {"code": "bool Sub::ekf_position_ok(){\n\t\treturn (ahrs.have_inertial_nav && motors.armed) || (motors.armed && ahrs.get_filter_status() == AHRS_FILTER_OK) || (motors.armed && ahrs.get_filter_status() == AHRS_FILTER_IN_CONSTANT_POSITION_MODE);\n}", "CodeBleu_score": 30.594586610517137}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t/*\n * This function, AP_Arming_Rover::gps_checks, performs GPS checks for a rover.", "CodeBleu_score": 4.380059452388209}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\tif (!rover.ahrs.is_healthy()) {\n\t\tif (display_failure) {\n\t\t\tap.console->printf(\"AHRS not healthy\n\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (rover.ekf_position_ok == false) {\n\t\tif (display_failure) {\n\t\t\tap.console->printf(\"EKF position estimate not valid\n\");\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 36.45115875041344}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!rover.ahrs.is_healthy()) {\n\t\tif (display_failure) {\n\t\t\tap.console->printf_P(PSTR(\"AHRS is not ready\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (rover.ekf_position_ok) {\n\t\tif (display_failure) {\n\t\t\tap.console->printf_P(PSTR(\"EKF failsafe is active\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!rover.ekf_position_valid) {\n\t\tif (display_failure) {\n\t\t\tap.console->printf_P(PSTR(\"EKF position estimate is not valid\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 47.859813775508776}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tswitch (method) {\n\tcase AP_Arming::Method::SOFT:\n\t\tif (do_arming_checks) {\n\t\t\tif (rover.g2.windvane.get_home_heading() == 0) {\n\t\t\t\trover.g2.windvane.record_home_heading();\n\t\t\t}\n\t\t}\n\t\trover.g2.smart_rtl.set_home();\n\t\trover.mode_simple.init_heading();\n\t\trover.g2.windvane.record_home_heading();\n\t\trover.g2.update_soft_armed();\n\t\tsend_arm_disarm_statustext();\n\t\treturn true;\n\tcase AP_Arming::Method::HARD:\n\t\tif (do_arming_checks) {\n\t\t\tif (rover.g2.windvane.get_home_heading() == 0) {\n\t\t\t\trover.g2.windvane.record_home_heading();\n\t\t\t}\n\t\t}\n\t\trover.g2.smart_rtl.set_home();\n\t\trover.mode_simple.init_heading();\n\t\trover.g2.windvane.record_home_heading();\n\t\trover.g2.update_soft_armed();\n\t\tsend_arm_disarm_statustext();\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 47.181356386615846}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// if we are already armed, return\n\tif (_armed) {\n\t\treturn false;\n\t}", "CodeBleu_score": 15.269115029178126}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (do_arming_checks &&!check_arming_conditions()) {\n\t\tset_arming_failed();\n\t\treturn false;\n\t}\n\n\tswitch (method) {\n\tcase AP_Arming::Method::RTL:\n\t\tif (!rover.g2.smart_rtl.set_home()) {\n\t\t\tset_arming_failed();\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase AP_Arming::Method::SIMPLE_MODE:\n\t\tif (!rover.mode_simple.init_heading()) {\n\t\t\tset_arming_failed();\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase AP_Arming::Method::SAIL:\n\t\tif (!rover.g2.windvane.record_home_heading()) {\n\t\t\tset_arming_failed();\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase AP_Arming::Method::SOFT:\n\t\tbreak;\n\t}\n\n\trover.g2.smart_rtl.update_soft_armed();\n\trover.mode_simple.init_heading();\n\tsend_arm_disarm_statustext(true);\n\treturn true;\n}", "CodeBleu_score": 51.94713163630673}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (shouldCharge()) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_started = millis();\n\t\t} else {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_started = 0;\n\t\t}\n\t} else {\n\t\tif (millis() - charging_disabled_time > charging_retry_delay) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_started = millis();\n\t\t\tcharging_disabled_time = 0;\n\t\t} else {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_started = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.87372819862683}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!shouldCharge) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_disabled_time = millis();\n\t\t} else {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_disabled_time = 0;\n\t\t}\n\t} else {\n\t\tif (millis() - charging_disabled_time > charging_retry_delay) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_disabled_time = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.24855406078916}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed &&!shouldCharge) {\n\t\tcharging_enabled = false;\n\t\tlast_charging_time = millis();\n\t} else if (!charging_allowed) {\n\t\tif (millis() - last_charging_time > CHARGING_RETRY_DELAY) {\n\t\t\tcharging_enabled = true;\n\t\t\tlast_charging_time = millis();\n\t\t}\n\t}\n}", "CodeBleu_score": 33.77399495463515}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok() && size >= 4) {\n\t\tuint8_t *msg = (uint8_t *) message;\n\t\tuint16_t crc = CRC16.ccitt(msg, size - 2);\n\t\tmsg[size - 2] = crc >> 8;\n\t\tmsg[size - 1] = crc & 0xFF;\n\t\tpacketSerial.send(msg, size);\n\t}\n}", "CodeBleu_score": 53.78037959912332}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok() && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tuint8_t *buffer = (uint8_t *) message;\n\t\tbuffer[size] = crc & 0xFF;\n\t\tbuffer[size + 1] = crc >> 8;\n\t\tpacketSerial.send(buffer, size + 2);\n\t}\n}", "CodeBleu_score": 52.323711903045655}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok() && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tmemcpy((char*)message + size, &crc, sizeof(crc));\n\t\tpacketSerial.send(message, size + sizeof(crc));\n\t}\n}", "CodeBleu_score": 36.78970409611089}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\t// Initialize the serial port for communication with the sound module\n\tsoundSerial.begin(9600);\n\n\t// Clear any existing data in the buffer\n\tsoundSerial.flush();\n\n\t// Initialize the sound module and retrieve the number of sound files available on the SD card\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0xFF);\n\tsoundSerial.write(0x06);\n\tsoundSerial.write(0x04);\n\tsoundSerial.write(0x01);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0xEF);\n\n\t// Wait for the response from the sound module\n\twhile (soundSerial.available() < 6) {\n\t\tdelay(10);\n\t}\n\n\t// Read the response from the sound module\n\tint response = soundSerial.read();\n\tint response1 = soundSerial.read();\n\tint response2 = soundSerial.read();\n\tint response3 = soundSerial.read();\n\tint response4 = soundSerial.read();\n\tint response5 = soundSerial.read();\n\n\t// Check if the response from the sound module is valid\n\tif (response!= 0x7E || response1!= 0xFF || response2!= 0x06 || response3!= 0x00 || response4!= 0xEF) {\n\t\treturn false;\n\t}\n\n\t// Store the number of sound files available on the SD card\n\tnumSdTracks = response5;\n\n\t// Return true if there are one or more sound files available\n\treturn numSdTracks > 0;\n}", "CodeBleu_score": 46.03793153135117}, {"code": "bool MP3Sound::begin(){\n\t\t// initialize the serial communication\n\tsoundSerial.begin(9600);\n\t// clear any existing data in the buffer\n\tsoundSerial.flush();\n\t// initialize the sound module\n\tif (!initialize()) {\n\t\treturn false;\n\t}\n\t// get the number of sound files available on the SD card\n\tnumSdTracks = getNumSdTracks();\n\t// return true if there are one or more sound files available\n\treturn (numSdTracks > 0);\n}", "CodeBleu_score": 37.76299341208556}, {"code": "bool MP3Sound::begin(){\n\t\t// initialize the serial communication\n\tsoundSerial.begin(9600);\n\n\t// clear any existing data in the buffer\n\tsoundSerial.flush();\n\n\t// initialize the sound module\n\tsendCommand(CMD_SEL_DEV, DEV_TF);\n\n\t// retrieve the number of sound files available on the SD card\n\tnumSdTracks = getSdTracks();\n\n\t// return true if there are one or more sound files available\n\treturn numSdTracks > 0;\n}", "CodeBleu_score": 37.86529153684416}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0) {\n\t\tif (myMP3.isPlaying) {\n\t\t\treturn active_sounds.size();\n\t\t}\n\t\telse {\n\t\t\tmyMP3.play(active_sounds.back());\n\t\t\tactive_sounds.pop_back();\n\t\t\treturn active_sounds.size();\n\t\t}\n\t}\n\telse {\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.90368834273028}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tMP3Sound last_sound = active_sounds.back();\n\t\tlast_sound.play();\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 44.74510427511126}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0) {\n\t\treturn 0;\n\t}\n\telse if (!myMP3.isPlaying()) {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n\treturn active_sounds.size();\n}", "CodeBleu_score": 44.90434121141491}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t}", "CodeBleu_score": 6.617871250854342}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t}", "CodeBleu_score": 6.617871250854342}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t}", "CodeBleu_score": 6.617871250854342}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint result = -1;\n\tif (d!= NULL) {\n\t\tWbDeviceTag tag = wb_device_get_tag(d);\n\t\tif (tag!= WB_DEVICE_TAG_ABSTRACT_CAMERA) {\n\t\t\twb_error_set(WB_ERROR_TYPE_INVALID_PARAMETER, \"The device is not an abstract camera\");\n\t\t} else {\n\t\t\tWbAbstractCamera *camera = (WbAbstractCamera *) d;\n\t\t\trobot_mutex_lock(&camera->mutex);\n\t\t\tresult = camera->height;\n\t\t\trobot_mutex_unlock(&camera->mutex);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 46.8108113971179}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint height;\n\tif (!wb_device_is_of_type(d, WB_ABSTRACT_CAMERA_DEVICE))\n\t\treturn -1;\n\trobot_mutex_lock(&d->mutex);\n\theight = d->data.abstract_camera.height;\n\trobot_mutex_unlock(&d->mutex);\n\treturn height;\n}", "CodeBleu_score": 40.150006844564025}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint height;\n\twb_device_mutex_lock(d);\n\theight = d->camera.height;\n\twb_device_mutex_unlock(d);\n\treturn height;\n}", "CodeBleu_score": 37.993333299794436}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\taccelerometer_get_struct(tag);\n\tif (accelerometer_struct!= NULL) {\n\t\treturn accelerometer_struct->sampling_period;\n\t} else {\n\t\tfprintf(stderr, \"ERROR: wb_accelerometer_get_sampling_period: invalid device tag\n\");\n\t\treturn -1;\n\t}\n}", "CodeBleu_score": 16.902652415520432}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\taccelerometer_get_struct(tag);\n\tif (accelerometer->sampling_period!= -1) {\n\t\treturn accelerometer->sampling_period;\n\t} else {\n\t\tfprintf(stderr, \"Error: wb_accelerometer_get_sampling_period: invalid device tag.\n\");\n\t\treturn -1;\n\t}\n}", "CodeBleu_score": 18.343080499136445}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tstruct WbAccelerometer *accelerometer = accelerometer_get_struct(tag);\n\tif (accelerometer == NULL) {\n\t\tfprintf(stderr, \"Error: invalid accelerometer tag.\n\");\n\t\treturn -1;\n\t}\n\trobot_mutex_lock();\n\tint sampling_period = accelerometer->sampling_period;\n\trobot_mutex_unlock();\n\treturn sampling_period;\n}", "CodeBleu_score": 45.88146420759953}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString = dms;\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 43.03590930918887}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tstring dms;\n\tdms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tfree(const_cast<char *>(dms.c_str()));\n\treturn dms;\n}", "CodeBleu_score": 40.78947664033614}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tstring dmsString;\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tdmsString = const_cast<char *>(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 53.21471747234965}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT(0, \"dGeomBoxGetTangentPlane not implemented\");\n}", "CodeBleu_score": 1.4765471852247067}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (0, \"dGeomBoxGetTangentPlane not implemented\");\n}", "CodeBleu_score": 1.5167563455807604}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (0, \"dGeomBoxGetTangentPlane not implemented\");\n}", "CodeBleu_score": 1.5167563455807604}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdUASSERT (box && box->body, \"box has no body\");\n\tdUASSERT (fluidPlane && fluidPlane[3]!= 0, \"invalid fluid plane\");\n\tdUASSERT (flags >= 0 && flags <= 3, \"invalid flags\");\n\tdUASSERT (immersion, \"invalid immersion\");\n\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\tdata.performImmersionChecking = dImmerseBoxPerformImmersionChecking;\n\tdata.dUASSERT = dUASSERT;\n\tdata.dIASSERT = dIASSERT;\n\n\treturn dImmerseGeom (&data);\n}", "CodeBleu_score": 43.222385172402035}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\tdata.performImmersionChecking = 1;\n\treturn dImmerseGeom (box->geom, &data);\n}", "CodeBleu_score": 45.27242915152171}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT(box && fluidPlane, \"dImmerseBox: NULL argument\");\ndUASSERT(box->body, \"dImmerseBox: box has no body\");\ndUASSERT(flags >= 0 && flags <= 3, \"dImmerseBox: invalid flags\");\ndUASSERT(immersion, \"dImmerseBox: NULL immersion\");\n\nsBoxImmersionData data;\ndata.box = box;\ndata.fluidPlane = fluidPlane;\ndata.flags = flags;\ndata.immersion = immersion;\ndata.performImmersionChecking = dImmerseBoxPerformImmersionChecking;\ndata.performImmersionCheckingData = NULL;\ndata.numVertices = 0;\ndata.vertices = NULL;\ndata.numTriangles = 0;\ndata.triangles = NULL;\n\ndata.performImmersionChecking(data.performImmersionCheckingData, &data);\n\nreturn data.immersion->result;\n}", "CodeBleu_score": 44.71977818158211}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdVector3 p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16;\n\tdVector3 normal, normal2;\n\tdVector3 normal3;\n\tdVector3 normal4;\n\tdVector3 normal5;\n\tdVector3 normal6;\n\tdVector3 normal7;\n\tdVector3 normal8;\n\tdVector3 normal9;\n\tdVector3 normal10;\n\tdVector3 normal11;\n\tdVector3 normal12;\n\tdVector3 normal13;\n\tdVector3 normal14;\n\tdVector3 normal15;\n\tdVector3 normal16;\n\tdVector3 normal17;\n\tdVector3 normal18;\n\tdVector3 normal19;\n\tdVector3 normal20;\n\tdVector3 normal21;\n\tdVector3 normal22;\n\tdVector3 normal23;\n\tdVector3 normal24;\n\tdVector3 normal25;\n\tdVector3 normal26;\n\tdVector3 normal27;\n\tdVector3 normal28;\n\tdVector3 normal29;\n\tdVector3 normal30;\n\tdVector3 normal31;\n\tdVector3 normal32;\n\tdVector3 normal33;\n\tdVector3 normal34;\n\tdVector3 normal35;\n\tdVector3 normal36;\n\tdVector3 normal37;\n\tdVector3 normal38;\n\tdVector3 normal39;\n\tdVector3 normal40;\n\tdVector3 normal41;\n\tdVector3 normal42;\n\tdVector3 normal43;\n\tdVector3 normal44;\n\tdVector3 normal45;\n\tdVector3 normal46;\n\tdVector3 normal47;\n\tdVector3 normal48;\n\tdVector3 normal49;\n\tdVector3 normal50;\n\tdVector3 normal51;\n\tdVector3 normal52;", "CodeBleu_score": 4.604205860286395}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (o1 && o2, \"NULL geometry\");\n\tdUASSERT (dGeomGetClass (o1) == dBoxClass && dGeomGetClass (o2) == dCapsuleClass, \"invalid geometry pair\");\n\tdUASSERT (immersion, \"NULL immersion\");\n\tdUASSERT (immersion->fluid, \"NULL fluid\");\n\tdUASSERT (immersion->fluid->density > 0, \"invalid fluid density\");\n\tdUASSERT (immersion->fluid->viscosity >= 0, \"invalid fluid viscosity\");\n\tdUASSERT (immersion->fluid->surfaceTension >= 0, \"invalid fluid surface tension\");\n\tdUASSERT (immersion->fluid->surfaceTension < immersion->fluid->density, \"invalid fluid surface tension\");\n\tdUASSERT (immersion->fluid->gravity[0] == 0 && immersion->fluid->gravity[1] == 0 && immersion->fluid->gravity[2] == 0, \"invalid fluid gravity\");\n\tdUASSERT (immersion->fluid->gravity[0] == 0 && immersion->fluid->gravity[1] == 0 && immersion->fluid->gravity[2] == 0, \"invalid fluid gravity\");\n\tdUASSERT (immersion->fluid->gravity[0] == 0 && immersion->fluid->gravity[1] == 0 && immersion->fluid->gravity[2] == 0, \"invalid fluid gravity\");\n\tdUASSERT (immersion->fluid->gravity[0] == 0 && immersion->fluid->gravity[1] == 0 && immersion->fluid->gravity[2] == 0, \"invalid fluid gravity\");\n\tdUASSERT (immersion->fluid->gravity[0] == 0 && immersion->fluid->gravity[1] == 0 && immersion->fluid->gravity[2] == 0, \"invalid fluid gravity\");\n\tdUASSERT (immersion->fluid->gravity[0] == 0 && immersion->fluid->gravity[1] == 0 && immersion->fluid->gravity[2] == 0, \"invalid fluid gravity\");\n\tdUASSERT (immersion->fluid->gravity[0] == 0 && immersion->fluid->gravity[1] == 0 &&", "CodeBleu_score": 22.500253504927752}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT(o1->type == dBoxClass, \"dImmerseBoxCapsule: first argument must be a box\");\n\tdUASSERT(o2->type == dCapsuleClass, \"dImmerseBoxCapsule: second argument must be a capsule\");\n\tdUASSERT(immersion, \"dImmerseBoxCapsule: immersion parameter must be non-NULL\");\n\tdUASSERT(immersion->capsule, \"dImmerseBoxCapsule: immersion parameter must contain a capsule\");\n\tdUASSERT(immersion->box, \"dImmerseBoxCapsule: immersion parameter must contain a box\");\n\tdUASSERT(immersion->fluid, \"dImmerseBoxCapsule: immersion parameter must contain a fluid\");\n\tdUASSERT(immersion->fluid->fluid, \"dImmerseBoxCapsule: immersion parameter must contain a fluid\");\n\tdUASSERT(immersion->fluid->fluid->density > 0.0, \"dImmerseBoxCapsule: fluid density must be positive\");\n\tdUASSERT(immersion->fluid->fluid->viscosity > 0.0, \"dImmerseBoxCapsule: fluid viscosity must be positive\");\n\tdUASSERT(immersion->fluid->fluid->surfaceTension > 0.0, \"dImmerseBoxCapsule: fluid surfaceTension must be positive\");\n\tdUASSERT(immersion->fluid->fluid->surfaceTension < immersion->fluid->fluid->density, \"dImmerseBoxCapsule: fluid surfaceTension must be less than fluid density\");\n\tdUASSERT(immersion->fluid->fluid->surfaceTension < immersion->fluid->fluid->viscosity, \"dImmerseBoxCapsule: fluid surfaceTension must be less than fluid viscosity\");\n\tdUASSERT(immersion->fluid->fluid->surfaceTension < immersion->fluid->fluid->density * immersion->fluid->fluid->viscosity, \"dImmerseBoxCapsule: fluid surfaceTension must be less than fluid density * fluid viscosity\");\n\tdUASSERT(immersion->fluid->fluid->surfaceTension < immersion->fluid->fluid->density * immersion->fluid->fluid->viscos", "CodeBleu_score": 19.472441081967073}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal zIOverR4 = zIOverR2 * zIOverR2;\n\tdReal zIOverR6 = zIOverR4 * zIOverR2;\n\tdReal zIOverR8 = zIOverR6 * zIOverR2;\n\tdReal zIOverR10 = zIOverR8 * zIOverR2;\n\tdReal zIOverR12 = zIOverR10 * zIOverR2;\n\tdReal zIOverR14 = zIOverR12 * zIOverR2;\n\tdReal zIOverR16 = zIOverR14 * zIOverR2;\n\tdReal zIOverR18 = zIOverR16 * zIOverR2;\n\tdReal zIOverR20 = zIOverR18 * zIOverR2;\n\tdReal zIOverR22 = zIOverR20 * zIOverR2;\n\tdReal zIOverR24 = zIOverR22 * zIOverR2;\n\tdReal zIOverR26 = zIOverR24 * zIOverR2;\n\tdReal zIOverR28 = zIOverR26 * zIOverR2;\n\tdReal zIOverR30 = zIOverR28 * zIOverR2;\n\tdReal zIOverR32 = zIOverR30 * zIOverR2;\n\tdReal zIOverR34 = zIOverR32 * zIOverR2;\n\tdReal zIOverR36 = zIOverR34 * zIOverR2;\n\tdReal zIOverR38 = zIOverR36 * zIOverR2;\n\tdReal zIOverR40 = zIOverR38 * zIOverR2;\n\tdReal zIOverR42 = zIOverR40 * zIOverR2;\n\tdReal zIOverR44 = zIOverR42 * zIO", "CodeBleu_score": 29.454389321239187}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\t// The following code is adapted from the code in the function sCapsuleImmersionData::normalizedImmersedHemisphereVolume.\n\t// It calculates the volume of an immersed hemisphere using Simpson's rule for numerical integration.\n\t// It divides the integration into two parts to handle potential singularities and sums the results to return the total volume.\n\n\t// The following code is adapted from the code in the function sCapsuleImmersionData::normalizedImmersedHemisphereVolume.\n\t// It calculates the volume of an immersed hemisphere using Simpson's rule for numerical integration.\n\t// It divides the integration into two parts to handle potential singularities and sums the results to return the total volume.\n\n\t// The following code is adapted from the code in the function sCapsuleImmersionData::normalizedImmersedHemisphereVolume.\n\t// It calculates the volume of an immersed hemisphere using Simpson's rule for numerical integration.\n\t// It divides the integration into two parts to handle potential singularities and sums the results to return the total volume.\n\n\t// The following code is adapted from the code in the function sCapsuleImmersionData::normalizedImmersedHemisphereVolume.\n\t// It calculates the volume of an immersed hemisphere using Simpson's rule for numerical integration.\n\t// It divides the integration into two parts to handle potential singularities and sums the results to return the total volume.\n\n\t// The following code is adapted from the code in the function sCapsuleImmersionData::normalizedImmersedHemisphereVolume.\n\t// It calculates the volume of an immersed hemisphere using Simpson's rule for numerical integration.\n\t// It divides the integration into two parts to handle potential singularities and sums the results to return the total volume.\n\n\t// The following code is adapted from the code in the function sCapsuleImmersionData::normalizedImmersedHemisphereVolume.\n\t// It calculates the volume of an immersed hemisphere using Simpson's rule for numerical integration.\n\t// It divides the integration into two parts to handle potential singularities and sums the results to return the total volume.\n\n\t// The following code is adapted from the code in the function sCapsuleImmersionData::normalizedImmersedHemisphereVolume.\n\t//", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal sinTheta0 = sqrt(1.0 - tanTheta0 * tanTheta0);\n\tdReal sinTheta2 = sqrt(1.0 - zIOverR * zIOverR);\n\tdReal sinTheta3 = sqrt(1.0 - zIOverR * zIOverR * tanTheta0 * tanTheta0);\n\tdReal sinTheta4 = sqrt(1.0 - zIOverR * zIOverR * tanTheta0 * tanTheta0 * tanTheta0 * tanTheta0);\n\tdReal sinTheta5 = sqrt(1.0 - zIOverR * zIOverR * sinTheta1 * sinTheta1);\n\tdReal sinTheta6 = sqrt(1.0 - zIOverR * zIOverR * sinTheta1 * sinTheta1 * tanTheta0 * tanTheta0);\n\tdReal sinTheta7 = sqrt(1.0 - zIOverR * zIOverR * sinTheta1 * sinTheta1 * tanTheta0 * tanTheta0 * tanTheta0 * tanTheta0);\n\tdReal sinTheta8 = sqrt(1.0 - zIOverR * zIOverR * sinTheta1 * sinTheta1 * sinTheta1 * sinTheta1);\n\tdReal sinTheta9 = sqrt(1.0 - zIOverR * zIOverR * sinTheta1 * sinTheta1 * sinTheta1 * sinTheta1 * tanTheta0 * tanTheta0);\n\tdReal sinTheta10 = sqrt(1.0 - zIOverR * zIOverR * sinTheta1 * sinTheta1 * sinTheta1 * sinTheta1 * tanTheta0 * tanTheta0 * tanTheta0 * tanTheta0);\n\n\tdReal volume1 = simpson<sCapsuleImmersionData, &sCapsuleImmersionData::volumeIntegrand1>(sinTheta0, sinTheta2, this);\n\tdReal volume2 = simpson<sCapsuleImmersionData, &sCapsuleImmersionData::volumeIntegrand2>(sinTheta3, sinTheta4, this);\n\tdReal volume3 = simpson<sCapsuleImmersionData, &sCapsuleImmersionData::volumeIntegrand3>(sinTheta5, sinTheta6, this);\n\tdReal volume4 = simpson<", "CodeBleu_score": 37.74891204969521}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal xBuoyancyCenter = 0;\n\tdReal xCenterOfMass = 0;\n\tdReal xCenterOfMassIntegrand = 0;\n\tdReal xCenterOfMassIntegrandSum = 0;\n\tdReal xCenterOfMassIntegrandSum2 = 0;\n\tdReal xCenterOfMassIntegrandSum3 = 0;\n\tdReal xCenterOfMassIntegrandSum4 = 0;\n\tdReal xCenterOfMassIntegrandSum5 = 0;\n\tdReal xCenterOfMassIntegrandSum6 = 0;\n\tdReal xCenterOfMassIntegrandSum7 = 0;\n\tdReal xCenterOfMassIntegrandSum8 = 0;\n\tdReal xCenterOfMassIntegrandSum9 = 0;\n\tdReal xCenterOfMassIntegrandSum10 = 0;\n\tdReal xCenterOfMassIntegrandSum11 = 0;\n\tdReal xCenterOfMassIntegrandSum12 = 0;\n\tdReal xCenterOfMassIntegrandSum13 = 0;\n\tdReal xCenterOfMassIntegrandSum14 = 0;\n\tdReal xCenterOfMassIntegrandSum15 = 0;\n\tdReal xCenterOfMassIntegrandSum16 = 0;\n\tdReal xCenterOfMassIntegrandSum17 = 0;\n\tdReal xCenterOfMassIntegrandSum18 = 0;\n\tdReal xCenterOfMassIntegrandSum19 = 0;\n\tdReal xCenterOfMassIntegrandSum20 = 0;\n\tdReal xCenterOfMassIntegrandSum21 = 0;\n\tdReal xCenterOfMassIntegrandSum22 = 0;\n\tdReal xCenterOfMassIntegrandSum23 = 0;\n\tdReal xCenterOfMassIntegrandSum24 = 0;\n\tdReal xCenterOfMassIntegrandSum25 = 0;\n\tdReal xCenterOfMassIntegrandSum26 = 0;\n\tdReal xCenterOfMassIntegrandSum27 = 0;\n\tdReal xCenterOfMassIntegrandSum28 = 0;\n\tdReal xCenterOfMass", "CodeBleu_score": 14.16457438993941}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\treturn 1.0 / 3.0 * volume * (zIOverR + (zIOverR + tanTheta0) * sHemisphereIntegrationData::xCenterOfMassIntegrand(0.0, zIOverR, tanTheta0, sinTheta1) + 2.0 * zIOverR * sHemisphereIntegrationData::xCenterOfMassIntegrand(1.0, zIOverR, tanTheta0, sinTheta1));\n}", "CodeBleu_score": 42.36484347462156}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\treturn Simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(zIOverR, tanTheta0, sinTheta1, volume);\n}", "CodeBleu_score": 34.15416423410288}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmersionGeom *immersionGeom;\n\tdImmersionGeom *immersionGeom2;\n\tdGeomID geomID;\n\tdGeomID geomID2;\n\tdGeomID geomID3;\n\tdGeomID geomID4;\n\tdGeomID geomID5;\n\tdGeomID geomID6;\n\tdGeomID geomID7;\n\tdGeomID geomID8;\n\tdGeomID geomID9;\n\tdGeomID geomID10;\n\tdGeomID geomID11;\n\tdGeomID geomID12;\n\tdGeomID geomID13;\n\tdGeomID geomID14;\n\tdGeomID geomID15;\n\tdGeomID geomID16;\n\tdGeomID geomID17;\n\tdGeomID geomID18;\n\tdGeomID geomID19;\n\tdGeomID geomID20;\n\tdGeomID geomID21;\n\tdGeomID geomID22;\n\tdGeomID geomID23;\n\tdGeomID geomID24;\n\tdGeomID geomID25;\n\tdGeomID geomID26;\n\tdGeomID geomID27;\n\tdGeomID geomID28;\n\tdGeomID geomID29;\n\tdGeomID geomID30;\n\tdGeomID geomID31;\n\tdGeomID geomID32;\n\tdGeomID geomID33;\n\tdGeomID geomID34;\n\tdGeomID geomID35;\n\tdGeomID geomID36;\n\tdGeomID geomID37;\n\tdGeomID geomID38;\n\tdGeomID geomID39;\n\tdGeomID geomID40;\n\tdGeomID geomID41;\n\tdGeomID geomID42;\n\tdGeomID geomID43;\n\tdGeomID geomID44;\n\tdGeomID geomID45;\n\tdGeomID geomID46;\n\tdGeomID geomID47;\n\tdGeomID geomID48;\n\tdGeomID geomID49;\n\tdGeomID geomID50;", "CodeBleu_score": 6.248758287728213}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmersionGeom *immersionData = immersion;\n\tdReal *capsuleData = immersionData->capsuleData;\n\tdReal *capsuleParams = immersionData->capsuleParams;\n\tdReal *capsuleCapsuleData = immersionData->capsuleCapsuleData;\n\tdReal *capsuleCapsuleParams = immersionData->capsuleCapsuleParams;\n\tdReal *capsuleTrimeshData = immersionData->capsuleTrimeshData;\n\tdReal *capsuleTrimeshParams = immersionData->capsuleTrimeshParams;\n\tdReal *capsuleTrimeshCapsuleData = immersionData->capsuleTrimeshCapsuleData;\n\tdReal *capsuleTrimeshCapsuleParams = immersionData->capsuleTrimeshCapsuleParams;\n\tdReal *capsuleTrimeshTrimeshData = immersionData->capsuleTrimeshTrimeshData;\n\tdReal *capsuleTrimeshTrimeshParams = immersionData->capsuleTrimeshTrimeshParams;\n\tdReal *capsuleTrimeshTrimeshCapsuleData = immersionData->capsuleTrimeshTrimeshCapsuleData;\n\tdReal *capsuleTrimeshTrimeshCapsuleParams = immersionData->capsuleTrimeshTrimeshCapsuleParams;\n\tdReal *capsuleTrimeshTrimeshTrimeshData = immersionData->capsuleTrimeshTrimeshTrimeshData;\n\tdReal *capsuleTrimeshTrimeshTrimeshParams = immersionData->capsuleTrimeshTrimeshTrimeshParams;\n\tdReal *capsuleTrimeshTrimeshTrimeshCapsuleData = immersionData->capsuleTrimeshTrimeshTrimeshCapsuleData;\n\tdReal *capsuleTrimeshTrimeshTrimeshCapsuleParams = immersionData->capsuleTrimeshTrimeshCapsuleParams;\n\tdReal *capsuleTrimeshTrimeshTrimeshTrimeshData = immersionData->capsuleTrimeshTrimeshTrimeshData;\n\tdReal *capsuleTrimeshTrimeshTrimeshTrimeshParams = immersionData->capsuleTrimeshTrimeshTrimeshParams;\n\tdReal *capsuleTrimeshTrimeshTrimeshTrimeshCapsuleData = immersionData->capsuleTrimeshTrimeshTrimeshCapsuleData;\n\tdReal", "CodeBleu_score": 25.62370499752269}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdImmersionCapsule *capsule = (dImmersionCapsule *) immersion;\n\tdImmersionCapsuleData *capsuleData = capsule->data;\n\tdImmersionCapsuleData *capsuleData2 = capsuleData->next;\n\tdGeomID geom1 = dGeomGetBody(o1)->geom;\n\tdGeomID geom2 = dGeomGetBody(o2)->geom;\n\tdVector3 pos1, pos2, pos3, pos4;\n\tdVector3 pos1_1, pos2_1, pos3_1, pos4_1;\n\tdVector3 pos1_2, pos2_2, pos3_2, pos4_2;\n\tdVector3 pos1_3, pos2_3, pos3_3, pos4_3;\n\tdVector3 pos1_4, pos2_4, pos3_4, pos4_4;\n\tdVector3 pos1_5, pos2_5, pos3_5, pos4_5;\n\tdVector3 pos1_6, pos2_6, pos3_6, pos4_6;\n\tdVector3 pos1_7, pos2_7, pos3_7, pos4_7;\n\tdVector3 pos1_8, pos2_8, pos3_8, pos4_8;\n\tdVector3 pos1_9, pos2_9, pos3_9, pos4_9;\n\tdVector3 pos1_10, pos2_10, pos3_10, pos4_10;\n\tdVector3 pos1_11, pos2_11, pos3_11, pos4_11;\n\tdVector3 pos1_12, pos2_12, pos3_12, pos4_12;\n\tdVector3 pos1_13, pos2_13, pos3_13, pos4_13;\n\tdVector3 pos1_14, pos2_14, pos3_14, pos4_14;\n\tdVector3 pos1_15, pos2_15, pos3_15, pos4_15;\n\t", "CodeBleu_score": 23.442889349579566}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\tif (timer_.isStarted()) {\n\t\ttimer_.stop();\n\t}\n\n\tif (timer_.isAborted()) {\n\t\ttimer_waiting_ = false;\n\t}\n\n\tif (duration_ <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\ttimer_waiting_ = true;\n\ttimer_.start(duration_);\n\ttimer_.addCallback(boost::bind(&SleepNode::emitWakeUpSignal, this));\n\tsetStatus(NodeStatus::RUNNING);\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 48.8288001255641}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get sleep duration from input\n\tstd::chrono::milliseconds duration;\n\ttry {\n\t\tduration = getInput<std::chrono::milliseconds>(0);\n\t}\n\tcatch (const std::exception& e) {\n\t\tsetStatus(NodeStatus::SUCCESS);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Check that duration is positive\n\tif (duration <= std::chrono::milliseconds(0)) {\n\t\tsetStatus(NodeStatus::SUCCESS);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start timer\n\ttimer_.start(duration);\n\n\t// Set callback to emit wake-up signal\n\ttimer_.add(std::bind(&SleepNode::emitWakeUpSignal, this));\n\n\t// Set timer_waiting_ flag to true\n\ttimer_waiting_ = true;\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 44.042787320837284}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// get the sleep duration in milliseconds\n\tauto duration = getInput<std::chrono::milliseconds>(\"duration\");\n\t// if the duration is missing or non-positive, return SUCCESS\n\tif (!duration || *duration <= std::chrono::milliseconds::zero()) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\t// set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\t// start the timer\n\ttimer_.start(*duration);\n\t// set a callback to emit a wake-up signal when the timer expires\n\ttimer_.onTimeout([this] {\n\t\temitWakeUpSignal();\n\t});\n\t// if the timer is aborted, ensure the timer_waiting_ flag is reset\n\ttimer_.onAbort([this] {\n\t\ttimer_waiting_ = false;\n\t});\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 47.03365815389379}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry\n\tconst Entry *entry = config.blackboard->getEntry(entry_id);\n\tif (entry == NULL) {\n\t\treturn FAILURE;\n\t}\n\t// Lock the mutex\n\tentry->lock();\n\t// Check if the sequence ID has changed\n\tif (entry->getSequenceID()!= sequence_id) {\n\t\t// Update the stored sequence ID\n\t\tsequence_id = entry->getSequenceID();\n\t\t// Unlock the mutex\n\t\tentry->unlock();\n\t\t// Return success\n\t\treturn SUCCESS;\n\t}\n\t// Unlock the mutex\n\tentry->unlock();\n\t// Return failure\n\treturn FAILURE;\n}", "CodeBleu_score": 31.98608506398668}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// get the entry\n\tEntry *entry = blackboard->getEntry(entry_name);\n\n\t// if the entry is not found, return failure\n\tif (entry == NULL) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// lock the entry mutex\n\tentry->lock();\n\n\t// compare the sequence IDs\n\tif (entry->getSequenceID()!= last_sequence_id) {\n\t\t// update the stored sequence ID\n\t\tlast_sequence_id = entry->getSequenceID();\n\n\t\t// unlock the entry mutex\n\t\tentry->unlock();\n\n\t\t// return success\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// unlock the entry mutex\n\tentry->unlock();\n\n\t// return failure\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 36.040145824327276}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Get the entry from the blackboard\n\tEntry *entry = config->blackboard->getEntry(entry_name);\n\n\t// If the entry is found\n\tif (entry) {\n\t\t// Lock the entry\n\t\tentry->lock();\n\n\t\t// If the sequence ID has changed\n\t\tif (entry->getSequenceID()!= last_sequence_id) {\n\t\t\t// Update the stored sequence ID\n\t\t\tlast_sequence_id = entry->getSequenceID();\n\n\t\t\t// Unlock the entry\n\t\t\tentry->unlock();\n\n\t\t\t// Return success\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\n\t\t// Unlock the entry\n\t\tentry->unlock();\n\t}\n\n\t// Return failure\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 28.59361378828821}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn std::max(size_t(1), children_nodes_.size());\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 41.212664325799814}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn children_nodes_.size();\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 37.96160823182938}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\tsuccess_threshold_ = std::max(size_t(1), children_nodes_.size() / 2);\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 49.28562381961162}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n\t\tstd::chrono::milliseconds elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - lastHeartbeatTime);\n\t\tif (elapsed.count() > 10000) {\n\t\t\tif (heartbeatActive) {\n\t\t\t\tenableAllHooks();\n\t\t\t\theartbeatActive = false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!heartbeatActive) {\n\t\t\t\tdisableAllHooks();\n\t\t\t\theartbeatActive = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 43.30893700066794}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::chrono::milliseconds ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - lastHeartbeat);\n\t\tif (ms.count() > 1000) {\n\t\t\tif (heartbeatEnabled) {\n\t\t\t\tenableAllHooks();\n\t\t\t\theartbeatEnabled = false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!heartbeatEnabled) {\n\t\t\t\tdisableAllHooks();\n\t\t\t\theartbeatEnabled = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.520807227750225}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tauto now = std::chrono::system_clock::now();\n\t\tauto heartbeatTime = std::chrono::milliseconds(lastHeartbeat);\n\t\tif (now - heartbeatTime > std::chrono::milliseconds(30000)) {\n\t\t\tif (lastHeartbeat == 0) {\n\t\t\t\tenableAllHooks();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisableAllHooks();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 48.819846906856604}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> ret;\n\tstd::vector<std::string> bb_names = BT::splitString(bb_list, \",\");\n\tnlohmann::json json_obj;\n\tfor (auto& bb_name : bb_names) {\n\t\tauto it = _p->subtrees.find(bb_name);\n\t\tif (it!= _p->subtrees.end()) {\n\t\t\tstd::lock_guard<std::mutex> lock(it->second.lock);\n\t\t\tif (it->second.valid) {\n\t\t\t\tExportBlackboardToJSON(bb_name, json_obj);\n\t\t\t}\n\t\t}\n\t}\n\tret = json_obj.dump();\n\treturn ret;\n}", "CodeBleu_score": 53.518843752178235}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> ret;\n\tnlohmann::json j;\n\tstd::vector<std::string> bbs = BT::splitString(bb_list, ',');\n\tfor (const auto& bb : bbs) {\n\t\tauto it = _p->subtrees.find(bb);\n\t\tif (it == _p->subtrees.end()) {\n\t\t\tstd::cerr << \"Blackboard \" << bb << \" not found\" << std::endl;\n\t\t\tcontinue;\n\t\t}\n\t\tauto& subtree = it->second.lock;\n\t\tif (!subtree) {\n\t\t\tstd::cerr << \"Blackboard \" << bb << \" not loaded\" << std::endl;\n\t\t\tcontinue;\n\t\t}\n\t\tj[bb] = ExportBlackboardToJSON(subtree);\n\t}\n\tret = j.dump();\n\treturn ret;\n}", "CodeBleu_score": 49.55001232920678}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// The JSON object to store the blackboard dump\n\tnlohmann::json dump;\n\n\t// Split the input string of blackboard names\n\tstd::vector<std::string> bb_names = BT::splitString(bb_list, ',');\n\n\t// Iterate through the blackboard names\n\tfor (const auto& bb_name : bb_names) {\n\t\t// Find the corresponding subtree\n\t\tauto subtree_it = _p->subtrees.find(bb_name);\n\n\t\t// If the subtree is valid, lock it\n\t\tif (subtree_it!= _p->subtrees.end()) {\n\t\t\tstd::lock_guard<std::mutex> subtree_lock(subtree_it->second.lock);\n\n\t\t\t// Export the blackboard to JSON\n\t\t\tnlohmann::json subtree_json = ExportBlackboardToJSON(subtree_it->second.tree);\n\n\t\t\t// Add the blackboard to the JSON object\n\t\t\tdump[bb_name] = subtree_json;\n\t\t}\n\t}\n\n\t// Convert the JSON object to MessagePack format\n\tstd::vector<uint8_t> msgpack_dump = dump.dump();\n\n\treturn msgpack_dump;\n}", "CodeBleu_score": 54.61522301928879}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\t// Find the node by its UID\n\tauto node_it = _p->nodes_by_uid.find(node_uid);\n\tif (node_it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\n\t// Retrieve the associated hook\n\tauto hook = getHook(pos);\n\tif (hook == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Lock the mutex\n\tstd::unique_lock<std::mutex> lk(hook->lock);\n\n\t// Check if the hook is in BREAKPOINT mode\n\tif (hook->mode!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\t// Set the desired status and removal flag\n\thook->status = result;\n\thook->remove = remove;\n\n\t// Mark it as ready\n\thook->ready = true;\n\n\t// Notify all waiting threads\n\thook->wakeup.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 53.02863079991702}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::lock_guard<std::mutex> lk(this->lock);\n\tauto it = this->nodes_by_uid.find(node_uid);\n\tif (it == this->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\tauto hook = it->second.lock();\n\tif (hook == nullptr) {\n\t\treturn false;\n\t}\n\tif (hook->mode!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->status = result;\n\thook->remove = remove;\n\thook->ready = true;\n\thook->wakeup.notify_all();\n\treturn true;\n}", "CodeBleu_score": 46.1896131437633}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tif (pos == Position::NONE) {\n\t\treturn false;\n\t}\n\n\tstd::lock_guard<std::mutex> lk(_p->mutex);\n\n\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif (it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\n\tauto hook = getHook(pos);\n\tif (hook == nullptr) {\n\t\treturn false;\n\t}\n\n\tstd::lock_guard<std::mutex> lk2(hook->lock);\n\n\tif (hook->mode!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\thook->status = result;\n\thook->remove = remove;\n\thook->ready = true;\n\thook->wakeup.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 55.829125873932824}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\t// If the node is not IDLE, throw an exception.\n\tif (status_!= NodeStatus::IDLE) {\n\t\tthrow BT::Exception(\"The node is not IDLE.\");\n\t}\n\n\t// Set the status to RUNNING.\n\tstatus_ = NodeStatus::RUNNING;\n\n\t// Reset halt_requested_.\n\thalt_requested_ = false;\n\n\t// Start a new asynchronous thread to run the tick function.\n\tstd::async(std::launch::async, [this]() {\n\t\ttry {\n\t\t\t// Run the tick function.\n\t\t\ttick();\n\t\t}\n\t\tcatch (...) {\n\t\t\t// If an exception occurs, log an error and set the node status to IDLE.\n\t\t\tstd::stringstream ss;\n\t\t\tss << \"Exception in tick function of node \" << name_;\n\t\t\tBT::Log::logError(ss.str());\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\n\t\t// Check for any stored exceptions and rethrow them if present.\n\t\tif (std::current_exception()) {\n\t\t\tstd::rethrow_exception(std::current_exception());\n\t\t}\n\n\t\t// If the tick function completes without a halt request, update the node status.\n\t\tif (!halt_requested_) {\n\t\t\tstatus_ = NodeStatus::SUCCESS;\n\t\t}\n\t});\n\n\t// Return the current status of the node.\n\treturn status_;\n}", "CodeBleu_score": 37.370560199243656}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tNodeStatus status = this->status;\n\n\t// If the node is IDLE, set the status to RUNNING and start a new asynchronous thread to run the tick function.\n\tif (status == NodeStatus::IDLE) {\n\t\tthis->status = NodeStatus::RUNNING;\n\t\tthis->halt_requested_ = false;\n\t\tthis->tick_thread_ = std::async(std::launch::async, &BT::ThreadedAction::tick, this);\n\t}\n\t// If the tick function completes without a halt request, update the node status.\n\telse if (status == NodeStatus::RUNNING &&!this->halt_requested_) {\n\t\tthis->status = NodeStatus::SUCCESS;\n\t}\n\n\t// If an exception occurs, catch the exception, log an error, and set the node status to IDLE.\n\ttry {\n\t\tstd::rethrow_exception(this->tick_thread_.get_exception());\n\t} catch (const std::exception &e) {\n\t\tthis->status = NodeStatus::FAILURE;\n\t\tstd::cerr << \"Exception in \" << this->name << \" node: \" << e.what() << std::endl;\n\t}\n\n\t// Check for any stored exceptions and rethrow them if present.\n\tif (this->stored_exception_) {\n\t\tstd::rethrow_exception(this->stored_exception_);\n\t}\n\n\treturn this->status;\n}", "CodeBleu_score": 32.30648609175142}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tNodeStatus status = NodeStatus::IDLE;\n\ttry {\n\t\tif (this->status == NodeStatus::IDLE) {\n\t\t\tthis->setStatus(NodeStatus::RUNNING);\n\t\t\tthis->halt_requested_ = false;\n\t\t\tthis->thread_ = std::async(std::launch::async, [this] {\n\t\t\t\tthis->tick();\n\t\t\t\tthis->setStatus(NodeStatus::SUCCESS);\n\t\t\t});\n\t\t}\n\t\tif (this->halt_requested_) {\n\t\t\tthis->setStatus(NodeStatus::HALTED);\n\t\t}\n\t\tstatus = this->status;\n\t}\n\tcatch (const std::exception& e) {\n\t\tthis->setStatus(NodeStatus::FAILURE);\n\t\tthis->halt_requested_ = true;\n\t\tstd::cerr << \"Exception caught in \" << this->name << \": \" << e.what() << std::endl;\n\t}\n\tif (this->stored_exception_) {\n\t\tstd::rethrow_exception(this->stored_exception_);\n\t}\n\treturn status;\n}", "CodeBleu_score": 30.751057433829732}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\n\tconst std::string separator = \"----------------------------------------\";\n\tstream << separator << std::endl;\n\n\t// Lambda function for printing the tree recursively\n\tauto print_tree = [&](const TreeNode* node, int depth) {\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"|   \";\n\t\t}\n\t\tstream << \"|-> \" << node->name << std::endl;\n\n\t\tif (node->type == TreeNodeType::CONTROL_NODE) {\n\t\t\tconst auto* control = dynamic_cast<const BT::ControlNode*>(node);\n\t\t\tfor (const auto& child : control->children) {\n\t\t\t\tprint_tree(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (node->type == TreeNodeType::DECORATOR_NODE) {\n\t\t\tconst auto* decorator = dynamic_cast<const BT::DecoratorNode*>(node);\n\t\t\tprint_tree(decorator->child, depth + 1);\n\t\t}\n\t};\n\n\tprint_tree(root_node, 0);\n\tstream << separator << std::endl;\n}", "CodeBleu_score": 48.921573040124464}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\tstream << \"----------------------------------------\n\";\n\tauto print_node = [stream](const TreeNode* node, int depth) {\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \" \";\n\t\t}\n\t\tstream << node->name << std::endl;\n\t\tif (dynamic_cast<const BT::ControlNode*>(node)!= nullptr) {\n\t\t\tfor (auto child : dynamic_cast<const BT::ControlNode*>(node)->children) {\n\t\t\t\tprint_node(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (dynamic_cast<const BT::DecoratorNode*>(node)!= nullptr) {\n\t\t\tprint_node(dynamic_cast<const BT::DecoratorNode*>(node)->child, depth + 1);\n\t\t}\n\t};\n\tprint_node(root_node, 0);\n\tstream << \"----------------------------------------\n\";\n}", "CodeBleu_score": 45.76732808666125}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// lambda function to handle printing\n\tauto print_node = [&stream](const TreeNode* node, const std::string& indent) {\n\t\tstream << indent << node->name << std::endl;\n\t\tif (const auto* control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\t\tfor (const auto* child : control->children) {\n\t\t\t\tprint_node(child, indent + \"  \");\n\t\t\t}\n\t\t} else if (const auto* decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\t\tprint_node(decorator->child, indent + \"  \");\n\t\t}\n\t};\n\n\t// print tree\n\tstream << \"----------------------------------------\" << std::endl;\n\tprint_node(root_node, \"\");\n\tstream << \"----------------------------------------\" << std::endl;\n}", "CodeBleu_score": 46.25657227680776}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"node is null\");\n\t}\n\tvisitor(node);\n\tif (const ControlNode* control = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const TreeNode* child : control->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (const DecoratorNode* decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child, visitor);\n\t}\n}", "CodeBleu_score": 57.799190972734024}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"Cannot apply visitor to null node\");\n\t}\n\tvisitor(node);\n\tif (const ControlNode* control = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const TreeNode* child : control->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (const DecoratorNode* decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child, visitor);\n\t}\n}", "CodeBleu_score": 58.01943030262324}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"node is null\");\n\t}\n\tvisitor(node);\n\tif (const ControlNode* control = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const TreeNode* child : control->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (const DecoratorNode* decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child, visitor);\n\t}\n}", "CodeBleu_score": 57.799190972734024}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.find(manifest.registrationId)!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with id \" + manifest.registrationId + \" already registered\");\n\t}\n\t_p->builders.insert(std::make_pair(manifest.registrationId, builder));\n\t_p->manifests.insert(std::make_pair(manifest.registrationId, manifest));\n}", "CodeBleu_score": 55.22229076081091}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.find(manifest.registration_id)!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder for \" + manifest.registration_id + \" already exists.\");\n\t}\n\t_p->builders.insert({manifest.registration_id, builder});\n\t_p->manifests.insert({manifest.registration_id, manifest});\n}", "CodeBleu_score": 55.428801667028594}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.find(manifest.registrationId)!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder already registered with ID: \" + manifest.registrationId);\n\t}\n\t_p->builders.insert(std::make_pair(manifest.registrationId, builder));\n\t_p->manifests.insert(std::make_pair(manifest.registrationId, manifest));\n}", "CodeBleu_score": 54.70721990533042}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\tregisterBuilder(\n\t\t[tick_functor, ports](const TreeNodeManifest& manifest) {\n\t\t\treturn std::make_unique<SimpleActionNode>(tick_functor, ports);\n\t\t},\n\t\tTreeNodeManifest(SimpleActionNode::type(), ID, ports));\n}", "CodeBleu_score": 35.23598895001}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t// 1.\n  auto builder = [tick_functor, ports](const TreeNodeManifest& manifest) {\n    return std::make_unique<SimpleActionNode>(tick_functor, ports);\n  };\n// 2.\n  TreeNodeManifest manifest(SimpleActionNode::type(), ID, ports);\n// 3.\n  registerBuilder(std::move(manifest), std::move(builder));\n}", "CodeBleu_score": 50.0051765682447}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\n// 1. Create a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\nauto builder = [tick_functor, ports]() {\n    return std::make_unique<SimpleActionNode>(tick_functor, ports);\n};\n\n// 2. Create a TreeNodeManifest with the action node type, ID, and ports list.\nTreeNodeManifest manifest(SimpleActionNode::type(), ID, ports);\n\n// 3. Call registerBuilder to register the manifest and builder.\nregisterBuilder(std::move(manifest), std::move(builder));\n}", "CodeBleu_score": 47.16066696508093}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backup;\n\tbb_backup.reserve(tree.subtrees.size());\n\tfor (auto& sub : tree.subtrees) {\n\t\tBlackboard::Ptr bb = Blackboard::create();\n\t\tbb->cloneInto(sub->blackboard);\n\t\tbb_backup.push_back(bb);\n\t}\n\treturn bb_backup;\n}", "CodeBleu_score": 61.806772315028105}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backup;\n\tbb_backup.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tauto bb_backup_ptr = Blackboard::Ptr(new Blackboard);\n\t\tbb_backup_ptr->cloneInto(*subtree.blackboard);\n\t\tbb_backup.push_back(bb_backup_ptr);\n\t}\n\treturn bb_backup;\n}", "CodeBleu_score": 55.83467732758011}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backup;\n\tbb_backup.reserve(tree.subtrees.size());\n\tfor (auto& sub : tree.subtrees) {\n\t\tauto bb = Blackboard::create();\n\t\tbb->cloneInto(sub->blackboard);\n\t\tbb_backup.push_back(bb);\n\t}\n\treturn bb_backup;\n}", "CodeBleu_score": 62.465263945628756}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(env, script);\n\tif (executor.has_value()) {\n\t\treturn executor.value().Execute();\n\t}\n\treturn nonstd::make_unexpected(executor.error());\n}", "CodeBleu_score": 62.660934480543084}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(env, script);\n\tif (!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor.value()();\n}", "CodeBleu_score": 64.70850797194103}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(env, script);\n\tif (executor) {\n\t\treturn executor.value().Execute(env);\n\t}\n\treturn nonstd::make_unexpected(executor.error());\n}", "CodeBleu_score": 64.69674321758808}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tif (loaded) {\n\t\tthrow RuntimeError(\"SharedLibrary already loaded\");\n\t}\n\tstd::unique_lock<std::mutex> lock(mutex);\n\tloaded = true;\n\tthis->path = path;\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n}", "CodeBleu_score": 50.261897287025135}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tif (loaded) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tstd::lock_guard<std::mutex> lock(mutex);\n\tloaded = true;\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tloaded_path = path;\n}", "CodeBleu_score": 49.99230709891609}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\t// Acquire a unique lock on the mutex\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Check if the library is already loaded\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Shared library already loaded\");\n\t}\n\n\t// Attempt to load the library\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\t// Check if the load failed\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\n\t// Store the path of the loaded library\n\tthis->path = path;\n\n\t// Mark the library as loaded\n\tloaded = true;\n}", "CodeBleu_score": 50.000517545903136}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3)\n\t\treturn false;\n\tStringView stripped = str.strip();\n\tif (stripped.startsWith('{') && stripped.endsWith('}')) {\n\t\tif (stripped_pointer)\n\t\t\t*stripped_pointer = stripped.substring(1, stripped.size() - 1);\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 19.753390825499135}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\tstr.strip();\n\n\tif (str[0]!= '{' || str[str.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substring(1, str.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 22.024918527339164}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.startsWith('{') && stripped.endsWith('}')) {\n\t\tif (stripped_pointer!= nullptr) {\n\t\t\t*stripped_pointer = stripped.substring(1, stripped.size() - 1);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 22.498204298047593}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0.0;\n\t// LineIterator is a class that iterates over a line.\n\t// It is used to iterate through each point on the line.\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (int i = 0; i < line.count; ++i) {\n\t\tint x = line.getX();\n\t\tint y = line.getY();\n\t\t// If the point cost is negative, return the point cost immediately.\n\t\tif (pointCost(x, y) < 0) {\n\t\t\treturn pointCost(x, y);\n\t\t}\n\t\t// Otherwise, update the line cost if the point cost is higher.\n\t\telse if (pointCost(x, y) > cost) {\n\t\t\tcost = pointCost(x, y);\n\t\t}\n\t\t// Advance to the next point on the line.\n\t\tline.advance();\n\t}\n\t// Return the total line cost.\n\treturn cost;\n}", "CodeBleu_score": 48.1180119855258}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0.0;\n\t//create a line iterator\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\t//iterate through the line\n\tfor (int i = 0; i < line.count; ++i) {\n\t\t//calculate the point cost\n\t\tdouble point_cost = pointCost(line.getX(i), line.getY(i));\n\t\t//if the point cost is negative, return the point cost immediately\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\t//otherwise, update the line cost if the point cost is higher\n\t\telse if (point_cost > cost) {\n\t\t\tcost = point_cost;\n\t\t}\n\t}\n\t//return the total line cost\n\treturn cost;\n}", "CodeBleu_score": 51.23463061383271}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0;\n\tline_cost += pointCost(x0, y0);\n\tline_cost += pointCost(x1, y1);\n\n\t// Calculate the cost of the line between the two points\n\tLineIterator line(costmap_, Point(x0, y0), Point(x1, y1));\n\tfor (int i = 0; i < line.count; ++i, ++line) {\n\t\tif (line_cost < 0) {\n\t\t\treturn line_cost;\n\t\t}\n\t\tline_cost += pointCost(line.getX(), line.getY());\n\t}\n\n\treturn line_cost;\n}", "CodeBleu_score": 44.838386477806324}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = path[0].header.frame_id;\n\tgui_path.header.stamp = path[0].header.stamp;\n\n\tgui_path.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 81.76717507813974}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\nreturn;\n}\nnav_msgs::Path gui_path;\ngui_path.header.frame_id = path.front().header.frame_id;\ngui_path.header.stamp = path.front().header.stamp;\ngui_path.poses.resize(path.size());\nfor (unsigned int i = 0; i < path.size(); ++i) {\ngui_path.poses[i] = path[i];\n}\npub.publish(gui_path);\n}", "CodeBleu_score": 72.5557168731791}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty())\nreturn;\nnav_msgs::Path gui_path;\ngui_path.header.frame_id = path[0].header.frame_id;\ngui_path.header.stamp = path[0].header.stamp;\ngui_path.poses.resize(path.size());\nfor (unsigned int i = 0; i < path.size(); ++i) {\ngui_path.poses[i] = path[i];\n}\npub.publish(gui_path);\n}", "CodeBleu_score": 82.44649750330937}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (base_odom.twist.twist.angular.z <= rot_stopped_velocity && base_odom.twist.twist.linear.x <= trans_stopped_velocity);\n}", "CodeBleu_score": 44.35390277135415}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tif (fabs(base_odom.twist.twist.angular.z) < rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) < trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 58.6349809345195}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tif(fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 64.78652879646361}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (setup_ && restore_defaults) {\n\t\tconfig.restoreDefaults();\n\t} else if (!setup_) {\n\t\tconfig.setup(config);\n\t\tsetup_ = true;\n\t}\n\tconfig_mutex_.lock();\n\tcurrent_limits_ = config;\n\tconfig_mutex_.unlock();\n}", "CodeBleu_score": 54.49181490589522}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (setup_) {\n\t\tif (restore_defaults) {\n\t\t\tconfig.restoreDefaults();\n\t\t}\n\t} else {\n\t\tsetup_ = true;\n\t\tdefault_limits_ = config;\n\t}\n\tconfig_mutex_.lock();\n\tcurrent_limits_ = config;\n\tconfig_mutex_.unlock();\n}", "CodeBleu_score": 46.280018508110324}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (setup) {\n\t\tif (restore_defaults) {\n\t\t\tconfig = default_limits;\n\t\t} else {\n\t\t\tconfig = default_limits;\n\t\t\tconfig.setup = true;\n\t\t}\n\t} else {\n\t\tdefault_limits = config;\n\t\tdefault_limits.setup = true;\n\t}\n\tconfig_mutex.lock();\n\tcurrent_limits = config;\n\tconfig_mutex.unlock();\n}", "CodeBleu_score": 47.28866322420145}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t//  if (check_cell->state == MapCell::OBSTACLE || check_cell->state == MapCell::NO_INFORMATION) {\n//    return false;\n//  }\n//  double new_target_distance = current_cell->target_distance +\n//      costmap.getCost(check_cell->x, check_cell->y);\n//  if (new_target_distance < check_cell->target_distance) {\n//    check_cell->target_distance = new_target_distance;\n//    return true;\n//  }\n//  return false;\n}", "CodeBleu_score": 6.256796312639722}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// check if the cell is an obstacle or has no information\n\tif (check_cell->isObstacle ||!costmap.getCost(check_cell->x, check_cell->y, current_cell->target_distance)) {\n\t\t// set the target distance of the cell to the maximum obstacle cost\n\t\tcheck_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\n\t\treturn false;\n\t}\n\n\t// calculate a new target distance\n\tdouble new_target_distance = current_cell->target_distance + costmap.getCost(check_cell->x, check_cell->y);\n\n\t// update the target distance of the cell if the new distance is shorter\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 49.52810014251144}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// If the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false.\n\tif (check_cell->cost < 0) {\n\t\tcurrent_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\n\t\treturn false;\n\t}\n\n\t// Calculate a new target distance.\n\tdouble new_target_distance = current_cell->target_distance + costmap.getCost(check_cell->x, check_cell->y);\n\n\t// Update the cell's target distance if the new distance is shorter.\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.93529102745367}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tdouble cost = 0;\n\tdouble scaling_factor = getScalingFactor(traj);\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"Footprint specification is empty. Cannot score trajectory.\");\n\t\treturn -9;\n\t}\n\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); i++) {\n\t\tPoint footprint_point = traj.getPoint(i);\n\t\tdouble footprint_cost = footprintCost(footprint_point, scaling_factor);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t} else {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost;\n\t\t\t} else {\n\t\t\t\tcost = std::max(cost, footprint_cost);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cost;\n}", "CodeBleu_score": 54.98509318546102}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tdouble cost = 0.0;\n\tdouble scaling_factor = getScalingFactor(traj);\n\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"Footprint specification is empty. Cannot score trajectory.\");\n\t\treturn -9.0;\n\t}\n\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); i++) {\n\t\tgeometry_msgs::Point p = traj.getPoint(i);\n\t\tdouble footprint_cost = footprintCost(p, scaling_factor);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t} else {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost;\n\t\t\t} else {\n\t\t\t\tcost = std::max(cost, footprint_cost);\n\t\t\t}\n\t\t}\n\t}\n\treturn cost;\n}", "CodeBleu_score": 53.58854272859224}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tdouble scaling_factor = getScalingFactor(traj);\n\tif (scaling_factor < 0) {\n\t\tROS_ERROR(\"Scaling factor is less than 0. Exiting\");\n\t\treturn -9;\n\t}\n\tdouble cost = 0;\n\tfor (int i = 0; i < traj.getPointsSize(); i++) {\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i), scaling_factor);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn cost;\n\t\t} else {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost;\n\t\t\t} else {\n\t\t\t\tcost = std::max(cost, footprint_cost);\n\t\t\t}\n\t\t}\n\t}\n\treturn cost;\n}", "CodeBleu_score": 43.67194926795016}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t// scale the footprint\n\tstd::vector<geometry_msgs::Point> scaled_footprint;\n\tfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n\t\tgeometry_msgs::Point p = footprint_spec[i];\n\t\tscaled_footprint.push_back(scaleFootprintPoint(p, scale));\n\t}\n\t// get the footprint cost\n\tdouble footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint);\n\t// get the cell cost\n\tunsigned int mx, my;\n\tif (!costmap->worldToMap(x, y, mx, my)) {\n\t\treturn -7.0;\n\t}\n\tunsigned char cell_cost = costmap->getCost(mx, my);\n\t// return the max of the footprint cost and the cell cost\n\treturn std::max(footprint_cost, (double)cell_cost);\n}", "CodeBleu_score": 59.750379266108176}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t/*\n * @param x The x position of the footprint in the world\n * @param y The y position of the footprint in the world\n * @param th The orientation of the footprint in the world\n * @param scale The scale factor to scale the footprint by\n * @param footprint_spec The footprint points of the robot\n * @param costmap The costmap to use for the footprint cost\n * @param world_model The world model to use for the footprint cost\n * @return The footprint cost at the given position and orientation\n */\n\n// Scale the footprint points by the given scale factor\nstd::vector<geometry_msgs::Point> scaled_footprint;\nscaled_footprint.resize(footprint_spec.size());\nfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    scaled_footprint[i].x = footprint_spec[i].x * scale;\n    scaled_footprint[i].y = footprint_spec[i].y * scale;\n}\n\n// Get the footprint cost using the world model\ndouble footprint_cost = world_model->footprintCost(scaled_footprint, x, y, th);\n\n// Check if the footprint cost is negative\nif (footprint_cost < 0) {\n    return -6.0;\n}\n\n// Check if the position is off the map\nif (!costmap->worldToMap(x, y, x_i, y_i)) {\n    return -7.0;\n}\n\n// Get the cell cost at the given position\nunsigned char cell_cost = costmap->getCost(x_i, y_i);\n\n// Return the maximum cost between the footprint cost and the cell cost\nreturn std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 65.28849657983807}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n/*\n * This function, ObstacleCostFunction::footprintCost, calculates the cost of a robot's footprint at a given position and orientation on a costmap.", "CodeBleu_score": 12.283621944358972}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\tif (odom_topic!= \"\") {\n\t\t\todom_sub_.shutdown();\n\t\t\todom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t\todom_topic_ = odom_topic;\n\t}\n}", "CodeBleu_score": 44.3040808307879}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic.compare(odom_topic_)!= 0) {\nodom_topic_ = odom_topic;\nif (!odom_topic_.empty()) {\nodom_sub_.shutdown();\nodom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 10, &OdometryHelperRos::odomCallback, this);\n}\nelse {\nodom_sub_.shutdown();\n}\n}\n}", "CodeBleu_score": 48.05151312900533}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (!odom_topic_.empty()) {\n\t\t\todom_sub_.shutdown();\n\t\t\todom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 10, &OdometryHelperRos::odomCallback, this);\n\t\t}\n\t}\n}", "CodeBleu_score": 40.86683642178129}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat dist = (pos - prev).squaredNorm();\n\tfloat angle = std::acos(prev.dot(pos) / (prev.norm() * pos.norm()));\n\tif (dist > resetDistanceThreshold_ || angle > resetAngleThreshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 32.75997613386316}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat squaredDistance = (pos - prev).squaredNorm();\n\tfloat angle = fabs(acos(pos.dot(prev) / (pos.norm() * prev.norm())));\n\tif (squaredDistance > squaredDistanceThreshold || angle > angleThreshold) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 32.406522464082144}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat dist = (pos - prev).squaredNorm();\n\tif (dist > resetOscillationFlagsDistThreshold) {\n\t\tresetOscillationFlags();\n\t}\n\tfloat angle = fabs(acos(pos.normalized().dot(prev.normalized())));\n\tif (angle > resetOscillationFlagsAngleThreshold) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 34.05721227453413}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// calculate grid coordinates\n\tfloat x = pt.x;\n\tfloat y = pt.y;\n\tfloat z = pt.z;\n\tint gridX = (int)floor((x - minX_) / cellSize_);\n\tint gridY = (int)floor((y - minY_) / cellSize_);\n\tint gridZ = (int)floor((z - minZ_) / cellSize_);\n\n\t// check if point is outside grid bounds\n\tif (gridX < 0 || gridX >= numCellsX_ || gridY < 0 || gridY >= numCellsY_ || gridZ < 0 || gridZ >= numCellsZ_) {\n\t\treturn;\n\t}\n\n\t// check if point is too close to its nearest neighbor\n\tfloat nearestNeighborDistance = 1000000;\n\tint gridIndex = gridX * numCellsY_ * numCellsZ_ + gridY * numCellsZ_ + gridZ;\n\tfor (int i = 0; i < cells_[gridIndex].size(); i++) {\n\t\tfloat distance = sqrt(pow(x - cells_[gridIndex][i].x, 2) + pow(y - cells_[gridIndex][i].y, 2) + pow(z - cells_[gridIndex][i].z, 2));\n\t\tif (distance < nearestNeighborDistance) {\n\t\t\tnearestNeighborDistance = distance;\n\t\t}\n\t}\n\tif (nearestNeighborDistance < minDistance_) {\n\t\treturn;\n\t}\n\n\t// insert point into grid\n\tgeometry_msgs::Point32 gridPoint;\n\tgridPoint.x = x;\n\tgridPoint.y = y;\n\tgridPoint.z = z;\n\tcells_[gridIndex].push_back(gridPoint);\n}", "CodeBleu_score": 39.92084504143074}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tif(pt.x < min_x_ || pt.x > max_x_ || pt.y < min_y_ || pt.y > max_y_ || pt.z < min_z_ || pt.z > max_z_) {\n\t\treturn;\n\t}\n\tint grid_x = (pt.x - min_x_) / cell_size_;\n\tint grid_y = (pt.y - min_y_) / cell_size_;\n\tint grid_z = (pt.z - min_z_) / cell_size_;\n\tint grid_index = grid_x + grid_y * grid_width_ + grid_z * grid_width_ * grid_height_;\n\tif(grid_index < 0 || grid_index >= grid_width_ * grid_height_ * grid_depth_) {\n\t\treturn;\n\t}\n\tif(cells_[grid_index].size() == 0) {\n\t\tcells_[grid_index].push_back(pt);\n\t\treturn;\n\t}\n\tdouble min_dist = std::numeric_limits<double>::max();\n\tint min_index = -1;\n\tfor(int i = 0; i < cells_[grid_index].size(); i++) {\n\t\tdouble dist = distance(pt, cells_[grid_index][i]);\n\t\tif(dist < min_dist) {\n\t\t\tmin_dist = dist;\n\t\t\tmin_index = i;\n\t\t}\n\t}\n\tif(min_dist < min_dist_) {\n\t\treturn;\n\t}\n\tcells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 35.825034370841266}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// Check if point is in grid bounds\n\tif (pt.x < gridBounds_.min_x || pt.x > gridBounds_.max_x ||\n\t\tpt.y < gridBounds_.min_y || pt.y > gridBounds_.max_y ||\n\t\tpt.z < gridBounds_.min_z || pt.z > gridBounds_.max_z) {\n\t\tROS_WARN(\"PointGrid: Point is outside grid bounds\");\n\t\treturn;\n\t}\n\n\t// Check if point is too close to its nearest neighbor\n\tif (nearestNeighborDistance(pt) < min_dist_) {\n\t\tROS_WARN(\"PointGrid: Point is too close to nearest neighbor\");\n\t\treturn;\n\t}\n\n\t// Get grid coordinates\n\tgeometry_msgs::Point32 grid_coords;\n\tgridCoords(pt, grid_coords);\n\n\t// Get grid index\n\tint grid_index = gridIndex(grid_coords);\n\n\t// Insert point into cell\n\tcells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 44.75351940429545}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t\telse {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t}\n\n\treturn new_vel;\n}", "CodeBleu_score": 70.05664833059085}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 71.04321808789405}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 74.14326703147334}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble goal_x = 0.0;\n\tdouble goal_y = 0.0;\n\tint i = global_plan_.size() - 1;\n\twhile (i >= 0) {\n\t\tif (costmap_.getCost(global_plan_[i].x, global_plan_[i].y) == lethal_cost_) {\n\t\t\tgoal_x = global_plan_[i].x;\n\t\t\tgoal_y = global_plan_[i].y;\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t}\n\tif (i < 0)\n\t\treturn DBL_MAX;\n\telse {\n\t\t// Convert goal cell coordinates to world coordinates\n\t\tcostmap_.mapToWorld(goal_x, goal_y, goal_x, goal_y);\n\t\t// Calculate the shortest angular distance between the current heading and the direction to the goal point\n\t\tdouble diff = angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x));\n\t\t// Return the absolute value of the shortest angular distance\n\t\treturn fabs(diff);\n\t}\n}", "CodeBleu_score": 48.70497861592551}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble dx = 0;\n\tdouble dy = 0;\n\tdouble goal_heading = 0;\n\tdouble goal_dist = 0;\n\tdouble min_dist = DBL_MAX;\n\tdouble min_goal_dist = DBL_MAX;\n\tdouble min_goal_heading = DBL_MAX;\n\tdouble min_goal_x = DBL_MAX;\n\tdouble min_goal_y = DBL_MAX;\n\tdouble min_goal_dx = DBL_MAX;\n\tdouble min_goal_dy = DBL_MAX;\n\n\t// Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// Convert the goal cell coordinates to world coordinates\n\t\tcostmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y, dx, dy);\n\n\t\t// Calculate the distance between the current position and the goal point\n\t\tgoal_dist = hypot(x - dx, y - dy);\n\n\t\t// Calculate the shortest angular distance between the current heading and the direction to the goal point\n\t\tgoal_heading = atan2(dy - y, dx - x);\n\t\tif (goal_heading < 0) {\n\t\t\tgoal_heading += 2 * M_PI;\n\t\t}\n\n\t\t// Calculate the difference in heading between the current heading and the direction to the goal point\n\t\tdouble heading_diff = fabs(angles::shortest_angular_distance(goal_heading, heading));\n\n\t\t// Check if the goal point has a clear line of sight from the robot's current cell\n\t\tif (lineCost(cell_x, cell_y, global_plan_[i].x, global_plan_[i].y, costmap_) == 0) {\n\t\t\t// If the goal point has a clear line of sight, check if it is closer than the current closest goal point\n\t\t\tif (goal_dist < min_goal_dist) {\n\t\t\t\t// If the goal point is closer, update the minimum distance, heading, and coordinates\n\t\t\t\tmin_goal_dist = goal_dist;\n\t\t\t\tmin_goal_heading = goal_heading;\n\t\t\t\tmin_goal_x", "CodeBleu_score": 49.911391782134416}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t// iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// convert the goal cell coordinates to world coordinates\n\t\tdouble gx = global_plan_[i].pose.position.x;\n\t\tdouble gy = global_plan_[i].pose.position.y;\n\n\t\t// return the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n\t\treturn fabs(angles::shortest_angular_distance(heading, atan2(gy - y, gx - x)));\n\t}\n\n\t// if no valid point is found, return DBL_MAX\n\treturn DBL_MAX;\n}", "CodeBleu_score": 43.083445317460864}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t// TODO: Fill in\n\t", "CodeBleu_score": 10.045399589204745}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost >= 0) {\n\t\treturn true;\n\t} else {\n\t\tROS_WARN_STREAM(\"The cost for trajectory (\" << vx << \", \" << vy << \", \" << vtheta << \") is \" << cost << \".\");\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 68.5297742521284}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t// TODO: Implement this function\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost >= 0) {\n    return true;\n  } else {\n    ROS_WARN(\"Trajectory cost: %f\", cost);\n    return false;\n  }\n}", "CodeBleu_score": 71.78480091801136}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmap passed to the ClearCostmapRecovery object is NULL. Doing nothing.\");\n\t\treturn;\n\t}\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local costmap passed to the ClearCostmapRecovery object is NULL. Doing nothing.\");\n\t\treturn;\n\t}\n\n\tROS_WARN(\"Clearing %s\", affected_maps_.c_str());\n\n\tros::WallTime t0 = ros::WallTime::now();\n\tif (affected_maps_.find(\"global\")!= std::string::npos) {\n\t\tROS_DEBUG(\"Clearing global costmap\");\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->updateMap();\n\t\t} else {\n\t\t\tglobal_costmap_->clear();\n\t\t}\n\t}\n\tros::WallTime t1 = ros::WallTime::now();\n\tROS_DEBUG(\"Clearing global costmap took %.3f seconds\", (t1 - t0).toSec);\n\n\tt0 = ros::WallTime::now();\n\tif (affected_maps_.find(\"local\")!= std::string::npos) {\n\t\tROS_DEBUG(\"Clearing local costmap\");\n\t\tif (force_update_) {\n\t\t\tlocal_costmap_->updateMap();\n\t\t} else {\n\t\t\tlocal_costmap_->clear();\n\t\t}\n\t}\n\tt1 = ros::WallTime::now();\n\tROS_DEBUG(\"Clearing local costmap took %.3f seconds\", (t1 - t0).toSec);\n}", "CodeBleu_score": 53.324904515001194}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\tif (!global_costmap_ ||!local_costmap_) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n\t\treturn;\n\t}\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing inside the specified area.\");\n\t} else {\n\t\tROS_WARN(\"Clearing outside the specified area.\");\n\t}\n\tROS_DEBUG(\"Clearing costmaps\");\n\tros::WallTime t0 = ros::WallTime::now();\n\tif (affected_maps_.find(\"local\")!= std::string::npos) {\n\t\tif (force_update_) {\n\t\t\tlocal_costmap_->updateMap(true);\n\t\t} else {\n\t\t\tlocal_costmap_->updateMap();\n\t\t}\n\t}\n\tROS_DEBUG(\"Local costmap clear time: %.9f\", (ros::WallTime::now() - t0).toSec());\n\tt0 = ros::WallTime::now();\n\tif (affected_maps_.find(\"global\")!= std::string::npos) {\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->updateMap(true);\n\t\t} else {\n\t\t\tglobal_costmap_->updateMap();\n\t\t}\n\t}\n\tROS_DEBUG(\"Global costmap clear time: %.9f\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 56.22141151300529}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmap passed to the ClearCostmapRecovery object is NULL. Dying.\");\n\t\treturn;\n\t}\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local costmap passed to the ClearCostmapRecovery object is NULL. Dying.\");\n\t\treturn;\n\t}\n\tif (affected_maps_.empty()) {\n\t\tROS_ERROR(\"The affected maps are not set. Dying.\");\n\t\treturn;\n\t}\n\tros::WallTime t0 = ros::WallTime::now();\n\tif (affected_maps_.find(\"global\")!= std::string::npos) {\n\t\tROS_DEBUG(\"Clearing global costmap\");\n\t\tif (invert_area_to_clear_) {\n\t\t\tROS_WARN(\"Clearing inside the area to clear\");\n\t\t} else {\n\t\t\tROS_WARN(\"Clearing outside the area to clear\");\n\t\t}\n\t\tglobal_costmap_->clear(invert_area_to_clear_);\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->updateMap();\n\t\t}\n\t}\n\tif (affected_maps_.find(\"local\")!= std::string::npos) {\n\t\tROS_DEBUG(\"Clearing local costmap\");\n\t\tif (invert_area_to_clear_) {\n\t\t\tROS_WARN(\"Clearing inside the area to clear\");\n\t\t} else {\n\t\t\tROS_WARN(\"Clearing outside the area to clear\");\n\t\t}\n\t\tlocal_costmap_->clear(invert_area_to_clear_);\n\t\tif (force_update_) {\n\t\t\tlocal_costmap_->updateMap();\n\t\t}\n\t}\n\tROS_DEBUG(\"Clearing costmaps took: %f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 54.69445285197606}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (!polygon.empty()) {\n\t\tpolygon_cells.clear();\n\t\tPolygonOutlineCells poly_outline_cells;\n\t\tpoly_outline_cells.polygon = polygon;\n\t\t// Iterate through the polygon vertices\n\t\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\t\t// Get the next vertex\n\t\t\tMapLocation next_vertex = polygon[(i + 1) % polygon.size()];\n\t\t\t// If the polygon is not empty, close it by connecting the last point to the first\n\t\t\tif (!polygon.empty()) {\n\t\t\t\tnext_vertex = polygon[0];\n\t\t\t}\n\t\t\t// Raytrace between the current and next vertex\n\t\t\traytraceLine(polygon[i], next_vertex, poly_outline_cells);\n\t\t}\n\t\t// Copy the cells from the PolygonOutlineCells object to polygon_cells\n\t\tpolygon_cells = poly_outline_cells.cells;\n\t}\n}", "CodeBleu_score": 51.65555270397482}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t// TODO: implement this function\n\tpolygon_cells.clear();\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tPolygonOutlineCells polyOutlineCells(this);\n\tfor (int i = 0; i < polygon.size() - 1; i++) {\n\t\tpolyOutlineCells.raytraceLine(polygon[i], polygon[i + 1]);\n\t}\n\tif (polygon.size() > 2) {\n\t\tpolyOutlineCells.raytraceLine(polygon[polygon.size() - 1], polygon[0]);\n\t}\n\tpolyOutlineCells.getCells(polygon_cells);\n}", "CodeBleu_score": 48.85594485164569}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty()) {\n\t\tpolygon_cells.clear();\n\t\treturn;\n\t}\n\n\tPolygonOutlineCells outline_cells;\n\n\t// Iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points.\n\tfor (int i = 0; i < polygon.size(); i++) {\n\t\toutline_cells.raytraceLine(polygon[i], polygon[(i + 1) % polygon.size()]);\n\t}\n\n\t// If the polygon is not empty, it also closes the polygon by connecting the last point to the first.\n\tif (!polygon.empty()) {\n\t\toutline_cells.raytraceLine(polygon[polygon.size() - 1], polygon[0]);\n\t}\n\n\t// Add the cells to the polygon_cells vector.\n\tpolygon_cells = outline_cells.getPolygonOutlineCells();\n}", "CodeBleu_score": 47.77900771062323}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t//prepareGrid\n\t//pub.publish\n}", "CodeBleu_score": 12.553135460120322}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid);\n}", "CodeBleu_score": 73.1143176438417}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid);\n}", "CodeBleu_score": 73.1143176438417}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tif (costmap_ == NULL) {\n\t\tROS_ERROR(\"Costmap2DPublisher::prepareGrid() - Costmap is NULL.\");\n\t\treturn;\n\t}\n\n\tcostmap_->lock();\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Set the origin of the grid map\n\tdouble origin_x, origin_y;\n\tcostmap_->getOrigin(origin_x, origin_y);\n\tgrid_.info.origin.position.x = origin_x;\n\tgrid_.info.origin.position.y = origin_y;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Resize the data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map\n\tunsigned char* map = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < grid_.data.size(); ++i) {\n\t\tgrid_.data[i] = translation_table_[map[i]];\n\t}\n\n\tcostmap_->unlock();\n}", "CodeBleu_score": 70.14666826588488}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tcostmap_->lock();\n\tresolution_ = costmap_->getResolution();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.info.resolution = resolution_;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\tcostmap_->getOrigin(origin_x_, origin_y_);\n\tgrid_.info.origin.position.x = origin_x_;\n\tgrid_.info.origin.position.y = origin_y_;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\tfor (unsigned int i = 0; i < grid_.data.size(); ++i) {\n\t\tunsigned int index = 0;\n\t\tswitch (costmap_->getCharMap()[i]) {\n\t\tcase lethal_cost:\n\t\t\tindex = 0;\n\t\t\tbreak;\n\t\tcase inscribed_inflated_cost:\n\t\t\tindex = 1;\n\t\t\tbreak;\n\t\tcase free_space:\n\t\t\tindex = 2;\n\t\t\tbreak;\n\t\tcase no_information:\n\t\t\tindex = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tgrid_.data[i] = index;\n\t}\n\tcostmap_->unlock();\n}", "CodeBleu_score": 61.704365546540416}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tdouble resolution = costmap_->getResolution();\n\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\tcostmap_->mapToWorld(0, 0, grid_.info.origin.position.x, grid_.info.origin.position.y);\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\tgrid_.data.resize(grid_.info.width * grid_.info.height, -1);\n\n\tconst unsigned char* charMap = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < grid_.info.width; ++i) {\n\t\tfor (unsigned int j = 0; j < grid_.info.height; ++j) {\n\t\t\tint index = i + (j * grid_.info.width);\n\t\t\tif (charMap[index] == costmap_2d::LETHAL_OBSTACLE) {\n\t\t\t\tgrid_.data[index] = 100;\n\t\t\t} else if (charMap[index] == costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\t\t\tgrid_.data[index] = 100;\n\t\t\t} else if (charMap[index] == costmap_2d::NO_INFORMATION) {\n\t\t\t\tgrid_.data[index] = -1;\n\t\t\t} else {\n\t\t\t\tgrid_.data[index] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 67.76185274901249}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\t// If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\n\t// If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n\tif (new_config.footprint.size() > 0) {\n\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\tif (makeFootprintFromString(new_config.footprint, footprint)) {\n\t\t\tsetRobotFootprint(footprint);\n\t\t} else {\n\t\t\tROS_ERROR(\"The footprint string '%s' is invalid. Using default footprint.\", new_config.footprint.c_str());\n\t\t}\n\t} else {\n\t\t// If the footprint string is invalid, it logs an error.\n\t\tif (new_config.robot_radius <= 0) {\n\t\t\tROS_ERROR(\"The footprint string is empty and the robot radius is invalid. Using default footprint.\");\n\t\t} else {\n\t\t\t// If no valid footprint string is provided, it sets the footprint based on the robot radius.\n\t\t\tmakeFootprintFromRadius(new_config.robot_radius, robot_footprint_);\n\t\t}\n\t}\n}", "CodeBleu_score": 68.5829594798346}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint.size() == old_config.footprint.size() && new_config.inscribed_radius == old_config.inscribed_radius && new_config.circumscribed_radius == old_config.circumscribed_radius) {\n\t\tROS_DEBUG_NAMED(\"costmap_2d\", \"Footprint and robot radius did not change.  Skipping reconfiguration.\");\n\t\treturn;\n\t}\n\n\tif (new_config.footprint.size() > 0) {\n\t\tif (makeFootprintFromString(new_config.footprint, new_config.inscribed_radius, new_config.circumscribed_radius, footprint_)) {\n\t\t\tROS_DEBUG_NAMED(\"costmap_2d\", \"Updated footprint to %d points\", footprint_.size());\n\t\t} else {\n\t\t\tROS_ERROR_NAMED(\"costmap_2d\", \"Could not parse footprint string\");\n\t\t}\n\t} else {\n\t\tmakeFootprintFromRadius(new_config.inscribed_radius, new_config.circumscribed_radius, footprint_);\n\t\tROS_DEBUG_NAMED(\"costmap_2d\", \"Updated footprint to %d points\", footprint_.size());\n\t}\n}", "CodeBleu_score": 48.81596536057132}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\t// If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\n\t// If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n\tif (new_config.footprint.size() > 0) {\n\t\tif (makeFootprintFromString(new_config.footprint, robot_radius_, footprint_)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// If the footprint string is invalid, it logs an error.\n\tROS_ERROR(\"The footprint string is invalid, using default footprint\");\n\n\t// If no valid footprint string is provided, it sets the footprint based on the robot radius.\n\tmakeFootprintFromRadius(robot_radius_, footprint_);\n}", "CodeBleu_score": 52.16789898026213}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (global_frame_!= robot_base_frame_) {\n\t\tif (!getRobotPose(new_pose, global_frame_, robot_base_frame_)) {\n\t\t\tROS_WARN(\"Could not get robot pose, cancelling reconfiguration.\");\n\t\t\tcancelReconfiguration();\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tnew_pose = robot_pose_;\n\t}\n\n\t// Get the robot's current velocity\n\tif (robot_vel_pub_.getNumSubscribers() > 0) {\n\t\tgeometry_msgs::TwistStamped robot_vel_msg;\n\t\trobot_vel_msg.header.stamp = event.current_real;\n\t\trobot_vel_msg.header.frame_id = robot_base_frame_;\n\t\trobot_vel_msg.twist.linear.x = robot_vel_.x;\n\t\trobot_vel_msg.twist.linear.y = robot_vel_.y;\n\t\trobot_vel_pub_.publish(robot_vel_msg);\n\t}\n}", "CodeBleu_score": 50.162828192956546}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// get the current pose of the robot\n\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Could not get robot pose, cancelling reconfiguration\");\n\t\tcancelReconfigure();\n\t\treturn;\n\t}\n\n\t// if the pose is valid, reconfigure the costmap\n\tif (new_pose.header.frame_id!= \"\") {\n\t\treconfigureCB();\n\t}\n}", "CodeBleu_score": 75.39790979462741}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (new_pose_sub_) {\n\t\ttry {\n\t\t\tnew_pose_sub_->copyTo(new_pose);\n\t\t} catch (const tf2::TransformException &ex) {\n\t\t\tROS_WARN(\"Received an exception trying to get the robot's transform: %s\", ex.what());\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tROS_WARN(\"Received a transform callback before the new pose subscriber was created!\");\n\t\treturn;\n\t}\n\treconfigure_timer_.stop();\n\treconfigure_timer_.start();\n}", "CodeBleu_score": 41.83256526486584}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\t// get the list of plugins\n\t\tstd::vector<boost::shared_ptr<Layer> > plugins;\n\t\tlayered_costmap_->getPlugins(plugins);\n\t\t// re-subscribe to topics\n\t\tfor (unsigned int i = 0; i < plugins.size(); i++) {\n\t\t\tplugins[i]->activate();\n\t\t}\n\t\t// set the stopped flag to false\n\t\tstopped_ = false;\n\t\t// set stop_updates_ to false\n\t\tstop_updates_ = false;\n\t\t// wait until ROS is running\n\t\twhile (!ros::ok()) {\n\t\t\tROS_WARN(\"ROS hasn't started, waiting...\");\n\t\t\tros::Duration(0.1).sleep();\n\t\t}\n\t\t// wait until the costmap is initialized\n\t\twhile (!layered_costmap_->isCurrent()) {\n\t\t\tROS_WARN(\"The costmap hasn't been initialized yet, waiting...\");\n\t\t\tros::Duration(0.5).sleep();\n\t\t}\n\t\t// wait until the map update thread is active\n\t\twhile (!map_update_thread_->isAlive()) {\n\t\t\tROS_WARN(\"The map update thread hasn't started yet, waiting...\");\n\t\t\tros::Duration(0.5).sleep();\n\t\t}\n\t}\n}", "CodeBleu_score": 46.54799807496621}, {"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\tROS_INFO(\"Restarting costmap\");\n\t\t// Get the list of plugins\n\t\tstd::vector<boost::shared_ptr<Costmap2DPlugin> > plugins = layered_costmap_->getPlugins();\n\t\t// Check if the costmap was stopped\n\t\tif (stopped_) {\n\t\t\t// Re-subscribe to topics\n\t\t\tfor (std::vector<boost::shared_ptr<Costmap2DPlugin> >::iterator plugin = plugins.begin(); plugin!= plugins.end(); ++plugin) {\n\t\t\t\t(*plugin)->activate();\n\t\t\t}\n\t\t\t// Set the stopped flag to false\n\t\t\tstopped_ = false;\n\t\t}\n\t\t// Wait until ROS is running\n\t\twhile (!ros::isInitialized()) {\n\t\t\tROS_INFO(\"Costmap2DROS: Waiting for ROS to initialize\");\n\t\t\tros::spinOnce();\n\t\t\tloop_rate_.sleep();\n\t\t}\n\t\t// Wait until the costmap is initialized\n\t\twhile (!layered_costmap_->isCurrent()) {\n\t\t\tROS_INFO(\"Costmap2DROS: Waiting for costmap initialization\");\n\t\t\tros::spinOnce();\n\t\t\tloop_rate_.sleep();\n\t\t}\n\t\t// Wait until the map update thread is active\n\t\twhile (!map_update_thread_active_) {\n\t\t\tROS_INFO(\"Costmap2DROS: Waiting for map update thread\");\n\t\t\tros::spinOnce();\n\t\t\tloop_rate_.sleep();\n\t\t}\n\t\t// Set the stop updates flag to false\n\t\tstop_updates_ = false;\n\t}\n}", "CodeBleu_score": 60.12240769918705}, {"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\tstopped_ = false;\n\t\tstd::vector<boost::shared_ptr<Costmap2DROSPlugin> >::iterator plugin_it;\n\t\tfor (plugin_it = plugins_.begin(); plugin_it!= plugins_.end(); ++plugin_it) {\n\t\t\t(*plugin_it)->activate();\n\t\t}\n\t\tstop_updates_ = false;\n\t\twhile (!ros::isInitialized()) {\n\t\t\tros::spinOnce();\n\t\t\tloop_rate_.sleep();\n\t\t}\n\t\twhile (!initialized_) {\n\t\t\tros::spinOnce();\n\t\t\tloop_rate_.sleep();\n\t\t}\n\t\twhile (!map_update_thread_->isAlive()) {\n\t\t\tros::spinOnce();\n\t\t\tloop_rate_.sleep();\n\t\t}\n\t}\n}", "CodeBleu_score": 51.654652347454565}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ > ros::Duration(0.0)) {\n\t\twhile (observation_list_.size() > 1) {\n\t\t\tif (observation_list_.front().header.stamp + observation_keep_time_ < ros::Time::now()) {\n\t\t\t\tobservation_list_.pop_front();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 23.756773454385915}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// TODO: Implement\n}", "CodeBleu_score": 1.543726824886217}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// TODO: Implement\n}", "CodeBleu_score": 1.543726824886217}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\tdouble shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\tdouble angle_increment = shortest_angular_distance / (end_index - start_index);\n\tdouble current_angle = start_yaw;\n\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tcurrent_angle += angle_increment;\n\t\tset_angle(path[i], current_angle);\n\t}\n}", "CodeBleu_score": 62.4209109841122}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (start_index < 0 || end_index < 0 || start_index >= end_index) {\n\t\tROS_ERROR(\"Invalid indices provided to OrientationFilter::interpolate\");\n\t\treturn;\n\t}\n\n\t// Get the yaw angles at the start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Determine the shortest angular distance between the start and end yaw angles\n\tdouble shortest_angular_distance = tf2::angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Calculate the incremental change in angle for each pose\n\tdouble angle_increment = shortest_angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index; i <= end_index; i++) {\n\t\tdouble yaw = start_yaw + i * angle_increment;\n\t\tgeometry_msgs::Quaternion orientation = tf2::createQuaternionMsgFromYaw(yaw);\n\t\tpath[i].pose.orientation = orientation;\n\t}\n}", "CodeBleu_score": 57.20945680948001}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Get yaw angles at start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Determine shortest angular distance between start and end yaw angles\n\tdouble shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute incremental change in angle for each pose\n\tdouble delta_angle = shortest_angular_distance / (end_index - start_index);\n\n\t// Update orientation of each pose in specified range\n\tfor (int i = start_index; i <= end_index; i++) {\n\t\tdouble new_yaw = start_yaw + delta_angle * (i - start_index);\n\t\tset_angle(path[i].pose.orientation, new_yaw);\n\t}\n}", "CodeBleu_score": 64.17227531578278}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn false;\n\t}\n\n\t// set the start and goal coordinates\n\tstart_->set_x(req.start.pose.position.x);\n\tstart_->set_y(req.start.pose.position.y);\n\tgoal_->set_x(req.goal.pose.position.x);\n\tgoal_->set_y(req.goal.pose.position.y);\n\n\t// make sure to set the correct reference frame\n\tstart_->set_frame_id(frame_id_);\n\tgoal_->set_frame_id(frame_id_);\n\n\t// get the plan\n\tif (makePlan(*start_, *goal_, resp.plan.poses)) {\n\t\tROS_DEBUG(\"Found a plan to move from %s to %s\", start_->get_frame_id().c_str(), goal_->get_frame_id().c_str());\n\t\tresp.error_code = resp.error_code.SUCCESS;\n\t} else {\n\t\tROS_ERROR(\"No plan found to move from %s to %s\", start_->get_frame_id().c_str(), goal_->get_frame_id().c_str());\n\t\tresp.error_code = resp.error_code.NO_PLAN_FOUND;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 41.26923087490612}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// call makePlan to generate a path\n\tif (makePlan(req.start, req.goal, resp.plan.poses)) {\n\t\t// update the response with the success status and the generated path if a plan is found\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t\tresp.plan.header.frame_id = \"map\";\n\t\tresp.error_code.val = resp.error_code.SUCCESS;\n\t\treturn true;\n\t}\n\telse {\n\t\t// if no plan is found, update the response with the error status\n\t\tresp.error_code.val = resp.error_code.PLANNING_FAILED;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 45.18013304915763}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_DEBUG(\"Received makePlan request\");\n\tif(!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn false;\n\t}\n\t// first try to make a plan to the exact requested pose\n\tgeometry_msgs::PoseStamped start, goal;\n\tstart.header.frame_id = goal.header.frame_id = frame_id_;\n\tstart.pose = req.start;\n\tgoal.pose = req.goal;\n\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tmakePlan(start, goal, plan);\n\tif(!plan.empty()) {\n\t\tROS_DEBUG(\"Got a plan to the exact goal\");\n\t\tresp.plan.poses.resize(plan.size());\n\t\tfor(unsigned int i = 0; i < plan.size(); i++) {\n\t\t\tresp.plan.poses[i] = plan[i];\n\t\t}\n\t\tresp.plan.header.frame_id = frame_id_;\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t\tresp.error_code = navfn::MakeNavPlan::Response::SUCCESS;\n\t\treturn true;\n\t}\n\n\t// we could not find a plan to the exact goal, we'll make one that is close\n\t// first we'll make the actual plan\n\tmakePlan(start, goal, plan);\n\n\t// if the plan is empty then we couldn't find a path\n\tif(plan.empty()) {\n\t\tROS_ERROR(\"Failed to find a plan to the goal\");\n\t\tresp.error_code = navfn::MakeNavPlan::Response::FAILURE;\n\t\treturn true;\n\t}\n\n\t// next we'll prune the path to remove unnecessary waypoints\n\tstd::vector<geometry_msgs::PoseStamped> pruned_plan;\n\tprunePlan(plan, pruned_plan);\n\n\t// make sure the current costmap is up to date because we could be on the edge of the map\n\tcostmap_2d::Costmap2D* costmap = planner_costmap_ros_->getCostmap();\n\tif(costmap->getOriginX()!= costmap_origin_x_ || costmap->getOrigin", "CodeBleu_score": 34.15120377259381}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tprivate_nh_ = ros::NodeHandle(\"~/\" + name);\n\tmake_plan_service_ = private_nh_.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tgoal_sub_ = private_nh_.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 64.45679371765802}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tprivate_nh = ros::NodeHandle(\"~/\" + name);\n\tmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tgoal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 68.21300488277734}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tprivate_nh = ros::NodeHandle(\"~/\" + name);\n\tmake_plan_service = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tgoal_sub = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 67.46491274114156}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\t// check if the world coordinates are within the bounds of the costmap's origin\n\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n\t\tROS_WARN(\"The world coordinates (%.2f, %.2f) are outside the costmap's bounds.\", wx, wy);\n\t\treturn false;\n\t}\n\n\t// calculate the map coordinates using the costmap's resolution and an offset\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\t// check if the map coordinates are within the costmap's size limits\n\tif (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n\t\tROS_WARN(\"The map coordinates (%.2f, %.2f) are outside the costmap's size limits.\", mx, my);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 46.03334704192358}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n\t\twx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n\t\twy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\tROS_WARN(\"The world coordinates passed to worldToMap are outside the bounds of the costmap. \"\n\t\t\t\"They were: (%.2f, %.2f)\", wx, wy);\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 40.4806117317409}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\t//check if the world coordinates are within the bounds of the costmap's origin\n\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n\t\tROS_WARN(\"The world coordinates (%.2f, %.2f) are out of bounds. The costmap origin is (%.2f, %.2f).\", wx, wy, costmap_->getOriginX(), costmap_->getOriginY());\n\t\treturn false;\n\t}\n\n\t//calculate the map coordinates using the costmap's resolution and an offset\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\t//check if the map coordinates are within the costmap's size limits\n\tif (mx >= 0 && mx < costmap_->getSizeInCellsX() && my >= 0 && my < costmap_->getSizeInCellsY()) {\n\t\treturn true;\n\t}\n\telse {\n\t\tROS_WARN(\"The map coordinates (%.2f, %.2f) are out of bounds. The costmap size is (%d, %d).\", mx, my, costmap_->getSizeInCellsX(), costmap_->getSizeInCellsY());\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 45.76760080059687}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 92.89079784387178}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif(!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 91.43139660729842}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\t// Create a Path message\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = planner_util_->getGlobalFrameID();\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Copy the poses from the input path\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\t// Publish the Path message\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 80.94927534708685}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t/*\n * This function, MoveBase::goalCB, is a callback that processes a new goal in the form of a PoseStamped message.\nIt logs a debug message indicating it is wrapping the goal in an action message.\nThe function creates a MoveBaseActionGoal, sets its timestamp to the current time, assigns the received goal to the target_pose, and publishes the action goal to the action_goal_pub_ topic.\n */\n  ROS_DEBUG_NAMED(\"move_base\", \"Received a goal of x: %f, y: %f, theta: %f\", goal->pose.position.x, goal->pose.position.y, tf2::getYaw(goal->pose.orientation));\n\n  //wrap the goal in an action message\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 71.55038797143412}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\t//wrap the goal in an action message\n\tactionlib_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\t//publish the action goal\n\taction_goal_pub_.publish(action_goal);\n\tROS_DEBUG_NAMED(\"move_base\", \"Sent new goal event (pose)\");\n}", "CodeBleu_score": 69.88269510721663}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED", "CodeBleu_score": 7.3114434983838015}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble sq_dist = getSqDistance();\n\tif (sq_dist > sq_limit_distance_) {\n\t\tROS_INFO(\"Distance check triggered\");\n\t\tif (remove_limit_thread_) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 72.73399063642569}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\t//ROS_INFO(\"distanceCheck\");\n\tif (ros::Duration(e.current_real - e.last_real).toSec() > 0.05) {\n\t\t//ROS_INFO(\"distanceCheck: %f\", (getSqDistance(current_pose_.pose.position, last_pose_.pose.position)));\n\t\tif (getSqDistance(current_pose_.pose.position, last_pose_.pose.position) > sq_limit_distance_) {\n\t\t\t//ROS_INFO(\"distanceCheck: %f\", (getSqDistance(current_pose_.pose.position, last_pose_.pose.position)));\n\t\t\tROS_INFO(\"distanceCheck: %f\", (getSqDistance(current_pose_.pose.position, last_pose_.pose.position)));\n\t\t\tif (remove_limit_thread_!= NULL) {\n\t\t\t\tremove_limit_thread_->join();\n\t\t\t\tdelete remove_limit_thread_;\n\t\t\t\tremove_limit_thread_ = NULL;\n\t\t\t}\n\t\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\t\tdistance_check_timer_.stop();\n\t\t}\n\t}\n}", "CodeBleu_score": 52.21661751478285}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\t// Get the current distance\n\tdouble current_distance = sqrt(pow(current_position_.x, 2) + pow(current_position_.y, 2));\n\n\t// Check if the robot has moved far enough\n\tif (current_distance >= limit_distance_) {\n\t\t// Log the message\n\t\tROS_INFO(\"Distance limit reached!\");\n\n\t\t// Stop the timer\n\t\tdistance_check_timer_.stop();\n\n\t\t// Join and delete any existing remove limit thread\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\n\t\t// Start a new thread to remove the speed limit\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t}\n}", "CodeBleu_score": 59.407236499810764}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG(\"Received a goal pose of (%.2f, %.2f)\", goal->pose.position.x, goal->pose.position.y);\n\n\t//get the global pose of the robot\n\tgeometry_msgs::PoseStamped global_pose;\n\tif (!getRobotPose(global_pose, goal->header)) {\n\t\tROS_ERROR(\"Could not get robot pose\");\n\t\treturn;\n\t}\n\n\t//make a plan from the global pose to the goal pose\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\tif (!makePlan(global_pose, *goal, path)) {\n\t\tROS_ERROR(\"Could not make a plan\");\n\t\treturn;\n\t}\n\n\t//publish the plan\n\tpublishPlan(path);\n}", "CodeBleu_score": 49.30094972881255}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tgeometry_msgs::PoseStamped global_pose;\n\tif (!costmap_ros_->getRobotPose(global_pose)) {\n\t\tROS_WARN(\"Could not get robot pose, cancelling goal\");\n\t\tcancelGoal();\n\t\treturn;\n\t}\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tmakePlan(global_pose, *goal, plan);\n\tif (!plan.empty()) {\n\t\tpublishPlan(plan);\n\t\tgoal_handle_ = ac_.acceptNewGoal(goal);\n\t\tgoal_handle_->setAccepted();\n\t} else {\n\t\tcancelGoal();\n\t\tgoal_handle_->setRejected();\n\t}\n}", "CodeBleu_score": 52.43454512707007}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current pose of the robot\n\tgeometry_msgs::PoseStamped global_pose = tf::transformPose(map_frame_, getRobotPose());\n\n\t// Create a vector to store the plan\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\n\t// Call makePlan to generate a plan from the current pose to the goal pose\n\tmakePlan(global_pose, *goal, plan);\n\n\t// If the plan is not empty, publish it\n\tif (!plan.empty()) {\n\t\t// Create a new navigation goal message\n\t\trm::NavigationGoal navigation_goal;\n\n\t\t// Set the goal pose to the last pose in the plan\n\t\tnavigation_goal.pose = plan.back();\n\n\t\t// Publish the navigation goal message\n\t\tnavigation_goal_pub_.publish(navigation_goal);\n\t}\n}", "CodeBleu_score": 49.725209988664254}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create the service request\n\tmavros_msgs::ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.param_value = param_set.param_value;\n\tsrv.request.param_type = param_set.param_type;\n\t// Call the param_set_client_\n\tthis->param_set_client_.call(srv);\n}", "CodeBleu_score": 73.46692235563937}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create the service request\n\tmavros_msgs::ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.param_value = param_set.param_value;\n\tsrv.request.param_type = param_set.param_type;\n\t// Send the request\n\tif (this->param_set_client_.call(srv)) {\n\t\tROS_INFO(\"AutonomousLanding::gimbalParamSetServer: Parameter set successful\");\n\t} else {\n\t\tROS_ERROR(\"AutonomousLanding::gimbalParamSetServer: Failed to set parameter\");\n\t}\n}", "CodeBleu_score": 64.28341788160897}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// create the request\n\tmavros_msgs::ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.param_value = param_set.param_value;\n\tsrv.request.param_type = 0;\n\n\t// call the param_set_client_ to send the request\n\tthis->param_set_client_.call(srv);\n}", "CodeBleu_score": 75.06615159522096}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\tint server_sockfd, client_sockfd;\n\tint server_len, client_len;\n\tstruct sockaddr_in server_address;\n\tstruct sockaddr_in client_address;\n\tint n;\n\tchar buffer[BUFF_SIZE];\n\tint bytes_recv;\n\tint bytes_sent;\n\tchar *msg;\n\tint msg_len;\n\n\tserver_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (server_sockfd < 0) {\n\t\tperror(\"opening socket\");\n\t\texit(1);\n\t}\n\n\tserver_address.sin_family = AF_INET;\n\tserver_address.sin_addr.s_addr = htonl(INADDR_ANY);\n\tserver_address.sin_port = htons(SERVER_PORT);\n\tserver_len = sizeof(server_address);\n\tif (bind(server_sockfd, (struct sockaddr *) &server_address, server_len) < 0) {\n\t\tperror(\"binding\");\n\t\texit(1);\n\t}\n\n\tlisten(server_sockfd, 5);\n\n\twhile (1) {\n\t\tprintf(\"Waiting for a connection", "CodeBleu_score": 34.67584253809065}, {"code": "void CommunicationBridge::serverFun(){\n\t\tint sockfd, newsockfd, portno, clilen;\n\tchar buffer[256];\n\tstruct sockaddr_in serv_addr, cli_addr;\n\tint n;\n\tsocklen_t clilen;\n\tsockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sockfd < 0) {\n\t\tperror(\"ERROR opening socket\");\n\t\texit(1);\n\t}\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tportno = 5001;\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(portno);\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tperror(\"ERROR on binding\");\n\t\texit(1);\n\t}\n\tlisten(sockfd, 5);\n\tclilen = sizeof(cli_addr);\n\tnewsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\tif (newsockfd < 0) {\n\t\tperror(\"ERROR on accept\");\n\t\texit(1);\n\t}\n\tbzero(buffer, 256);\n\tn = read(newsockfd, buffer, 255);\n\tif (n < 0) {\n\t\tperror(\"ERROR reading from socket\");\n\t\texit(1);\n\t}\n\tprintf(\"Here is the message: %s\n\", buffer);\n\tn = write(newsockfd, \"I got your message\", 18);\n\tif (n < 0) {\n\t\tperror(\"ERROR writing to socket\");\n\t\texit(1);\n\t}\n\tclose(newsockfd);\n\tclose(sockfd);\n}", "CodeBleu_score": 44.03293083808562}, {"code": "void CommunicationBridge::serverFun(){\n\t\tint sockfd, new_sockfd;\n\tsocklen_t clilen;\n\tstruct sockaddr_in serv_addr, cli_addr;\n\n\tsockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sockfd < 0) {\n\t\tperror(\"ERROR opening socket\");\n\t\texit(1);\n\t}\n\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(PORT);\n\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tperror(\"ERROR on binding\");\n\t\texit(1);\n\t}\n\n\tlisten(sockfd, 5);\n\tclilen = sizeof(cli_addr);\n\n\twhile (1) {\n\t\tnew_sockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\t\tif (new_sockfd < 0) {\n\t\t\tperror(\"ERROR on accept\");\n\t\t\texit(1);\n\t\t}\n\n\t\tbzero(buffer, 256);\n\n\t\tint n = recv(new_sockfd, buffer, 255, 0);\n\t\tif (n < 0) {\n\t\t\tperror(\"ERROR reading from socket\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (n == 0) {\n\t\t\tROS_ERROR(\"Received 0 bytes from socket, closing socket\");\n\t\t\tclose(new_sockfd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdecodeMsg(buffer);\n\t\tclose(new_sockfd);\n\t}\n\n\tclose(sockfd);\n}", "CodeBleu_score": 44.796723261343615}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (!this->simulation_mode_) {\n\t\tthis->uav_basic_->uavCmdPub(uav_cmd);\n\t} else {\n\t\tauto it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= this->swarm_control_simulation_.end()) {\n\t\t\tit->second->uavCmdPub(uav_cmd);\n\t\t}\n\t}\n}", "CodeBleu_score": 51.01908074448718}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->simulation_mode_) {\n\t\tif (this->swarm_control_simulation_.find(uav_cmd.uav_id)!= this->swarm_control_simulation_.end()) {\n\t\t\tthis->swarm_control_simulation_[uav_cmd.uav_id]->uavCmdPub.publish(uav_cmd);\n\t\t}\n\t} else {\n\t\tthis->uav_basic_->uavCmdPub.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 30.28614254649632}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (!this->sim_mode_) {\n\t\t// Publish the command to the corresponding UAV.\n\t\tthis->uav_basic_->uavCmdPub.publish(uav_cmd);\n\t}\n\telse {\n\t\t// Find the corresponding UAV by ID.\n\t\tauto it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= this->swarm_control_simulation_.end()) {\n\t\t\t// Publish the command to the corresponding UAV.\n\t\t\tit->second->uavCmdPub.publish(uav_cmd);\n\t\t}\n\t}\n}", "CodeBleu_score": 48.408760214226746}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else if (mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 49.25510717109167}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else if (mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 49.25510717109167}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"reboot -f\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exit\");\n\t} else if (mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETESTMODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 49.2788287244288}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// Check if the heartbeat has been received in the last 10 seconds\n\tif (heartbeat_received == false) {\n\t\t// Increment the heartbeat counter\n\t\theartbeat_counter++;\n\t\t// Check if the heartbeat counter has reached the maximum allowed number of attempts\n\t\tif (heartbeat_counter >= max_heartbeat_attempts) {\n\t\t\t// Print an error message\n\t\t\tROS_ERROR_STREAM(\"Heartbeat has not been received for \" << heartbeat_counter << \" seconds. Disconnecting...\");\n\t\t\t// Set the disconnect flag to true\n\t\t\tdisconnect_flag = true;\n\t\t\t// Trigger the appropriate actions based on the vehicle type\n\t\t\tswitch (vehicle_type) {\n\t\t\t\tcase swarm:\n\t\t\t\t\ttriggerSwarmControl();\n\t\t\t\t\tbreak;\n\t\t\t\tcase UAV:\n\t\t\t\t\ttriggerUAV();\n\t\t\t\t\tbreak;\n\t\t\t\tcase UGV:\n\t\t\t\t\ttriggerUGV();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tROS_ERROR_STREAM(\"Unknown vehicle type: \" << vehicle_type);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Reset the heartbeat counter\n\t\theartbeat_counter = 0;\n\t}\n}", "CodeBleu_score": 34.74971857309998}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (heartbeat_count_ == 0) {\n\t\tROS_INFO(\"Heartbeat lost\");\n\t\tif (vehicle_type_ == \"swarm\") {\n\t\t\ttriggerSwarmControl();\n\t\t} else if (vehicle_type_ == \"uav\") {\n\t\t\ttriggerUAV();\n\t\t} else if (vehicle_type_ == \"ugv\") {\n\t\t\ttriggerUGV();\n\t\t}\n\t}\n\tif (heartbeat_count_ >= 2) {\n\t\tROS_ERROR(\"Heartbeat lost\");\n\t\tif (vehicle_type_ == \"swarm\") {\n\t\t\ttriggerSwarmControl();\n\t\t} else if (vehicle_type_ == \"uav\") {\n\t\t\ttriggerUAV();\n\t\t} else if (vehicle_type_ == \"ugv\") {\n\t\t\ttriggerUGV();\n\t\t}\n\t}\n\tif (heartbeat_count_ > 0) {\n\t\theartbeat_count_--;\n\t}\n}", "CodeBleu_score": 35.99075661507267}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t//ROS_INFO(\"checkHeartbeatState\");\n\tif (heartbeat_count == 0) {\n\t\tif (swarm_vehicle) {\n\t\t\tROS_ERROR(\"Swarm Vehicle Heartbeat Lost\");\n\t\t\ttriggerSwarmControl(true);\n\t\t} else if (uav_vehicle) {\n\t\t\tROS_ERROR(\"UAV Heartbeat Lost\");\n\t\t\ttriggerUAV(true);\n\t\t} else if (ugv_vehicle) {\n\t\t\tROS_ERROR(\"UGV Heartbeat Lost\");\n\t\t\ttriggerUGV(true);\n\t\t}\n\t} else {\n\t\theartbeat_count--;\n\t}\n}", "CodeBleu_score": 16.761764281458618}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Extract the drone ID and trajectory data from the message\n\tint drone_id = msg->drone_id;\n\tstd::vector<prometheus_msgs::Bspline> traj = msg->traj;\n\n\t// Initialize a Bspline struct for each trajectory\n\tprometheus_msgs::Bspline bspline;\n\tstd::vector<double> bspline_knots;\n\tstd::vector<double> bspline_pos_pts;\n\tstd::vector<double> bspline_yaw_pts;\n\n\t// For each trajectory, set its attributes and populate its knots, position points, and yaw points\n\tfor (int i = 0; i < traj.size(); i++) {\n\t\t// Set the attributes of the Bspline struct\n\t\tbspline.drone_id = drone_id;\n\t\tbspline.knots = bspline_knots;\n\t\tbspline.pos_pts = bspline_pos_pts;\n\t\tbspline.yaw_pts = bspline_yaw_pts;\n\t\tbspline.start_time = traj[i].start_time;\n\n\t\t// Populate the knots, position points, and yaw points of the Bspline struct\n\t\tfor (int j = 0; j < traj[i].knots.size(); j++) {\n\t\t\tbspline.knots.push_back(traj[i].knots[j]);\n\t\t}\n\t\tfor (int j = 0; j < traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts.push_back(traj[i].pos_pts[j]);\n\t\t}\n\t\tfor (int j = 0; j < traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts.push_back(traj[i].yaw_pts[j]);\n\t\t}\n\n\t\t// Encode the MultiBsplines data and send it via TCP using the communication module\n\t\tthis->communication->encodeMsg(bspline);\n\t\tthis->communication->sendMsgByTcp();\n\t}\n}", "CodeBleu_score": 42.37568654342038}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tint drone_id;\n\tBspline bspline;\n\tprometheus_msgs::MultiBsplines multi_bsplines_msg;\n\tmulti_bsplines_msg.header.stamp = msg->header.stamp;\n\tmulti_bsplines_msg.header.frame_id = msg->header.frame_id;\n\tmulti_bsplines_msg.header.seq = msg->header.seq;\n\tmulti_bsplines_msg.traj.resize(msg->traj.size());\n\tfor (int i = 0; i < msg->traj.size(); i++) {\n\t\tdrone_id = msg->traj[i].drone_id;\n\t\tbspline.knots.clear();\n\t\tbspline.pos_pts.clear();\n\t\tbspline.yaw_pts.clear();\n\t\tbspline.knots.resize(msg->traj[i].knots.size());\n\t\tbspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n\t\tbspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots[j] = msg->traj[i].knots[j];\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts[j] = msg->traj[i].pos_pts[j];\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n\t\t}\n\t\tbspline.start_time = msg->traj[i].start_time;\n\t\tbspline.end_time = msg->traj[i].end_time;\n\t\tbspline.duration = msg->traj[i].duration;\n\t\tbspline.num_pts = msg->traj[i].num_pts;\n\t\tbspline.num_knots = msg->traj[i].num_knots;\n\t\tbspline.", "CodeBleu_score": 66.59417257854456}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Extract the drone ID and trajectory data from the message.\n\tint drone_id = msg->drone_id;\n\tint num_traj = msg->traj.size();\n\n\t// Initialize a MultiBspline struct.\n\tprometheus_msgs::MultiBspline multi_bspline;\n\tmulti_bspline.drone_id = drone_id;\n\n\t// For each trajectory, initialize a Bspline struct, set its attributes, and populate its knots, position points, and yaw points.\n\tfor (int i = 0; i < num_traj; i++) {\n\t\t// Initialize a Bspline struct.\n\t\tprometheus_msgs::Bspline bspline;\n\t\tbspline.drone_id = drone_id;\n\t\tbspline.traj_id = i;\n\n\t\t// Set the trajectory attributes.\n\t\tbspline.num_knots = msg->traj[i].knots.size();\n\t\tbspline.num_pos_pts = msg->traj[i].pos_pts.size();\n\t\tbspline.num_yaw_pts = msg->traj[i].yaw_pts.size();\n\t\tbspline.start_time = msg->traj[i].start_time;\n\n\t\t// Populate the knots.\n\t\tfor (int j = 0; j < bspline.num_knots; j++) {\n\t\t\tbspline.knots.push_back(msg->traj[i].knots[j]);\n\t\t}\n\n\t\t// Populate the position points.\n\t\tfor (int j = 0; j < bspline.num_pos_pts; j++) {\n\t\t\tbspline.pos_pts.push_back(msg->traj[i].pos_pts[j]);\n\t\t}\n\n\t\t// Populate the yaw points.\n\t\tfor (int j = 0; j < bspline.num_yaw_pts; j++) {\n\t\t\tbspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n\t\t}\n\n\t\t// Add the Bspline struct to the MultiBspline struct.\n\t\tmulti_bspline.bsplines.push_back(bspline);\n\t}\n\n\t// Encode the MultiBspline data.\n\tstd::string encoded_msg = this->communication->encode", "CodeBleu_score": 55.51977910176629}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Compress the point cloud\n\tstd::vector<uint8_t> compressed_data;\n\toctree_compression.encodePointCloud(cloud, compressed_data);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.height = 1;\n\tcompressed_msg.width = compressed_data.size();\n\tcompressed_msg.is_bigendian = false;\n\tcompressed_msg.is_dense = false;\n\tcompressed_msg.point_step = sizeof(uint8_t);\n\tcompressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n\tcompressed_msg.data.resize(compressed_msg.row_step * compressed_msg.height);\n\n\t// Copy the compressed data to the PointCloud2 message\n\tstd::memcpy(&compressed_msg.data[0], &compressed_data[0], compressed_msg.data.size());\n\n\t// Return the compressed PointCloud2 message\n\treturn compressed_msg;\n}", "CodeBleu_score": 31.910863180082444}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Create an octree compression object\n\toctree::OctreePointCloudCompression<pcl::PointXYZ> octree(resolution);\n\n\t// Compress the point cloud\n\tstd::vector<uint8_t> compressed_data;\n\toctree.encodePointCloud(cloud, compressed_data);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.height = 1;\n\tcompressed_msg.width = compressed_data.size();\n\tcompressed_msg.fields.resize(1);\n\tcompressed_msg.fields[0].name = \"compressed_data\";\n\tcompressed_msg.fields[0].offset = 0;\n\tcompressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n\tcompressed_msg.fields[0].count = 1;\n\tcompressed_msg.is_bigendian = false;\n\tcompressed_msg.point_step = 1;\n\tcompressed_msg.row_step = compressed_data.size();\n\tcompressed_msg.data.resize(compressed_data.size());\n\tstd::memcpy(compressed_msg.data.data(), compressed_data.data(), compressed_data.size());\n\n\t// Return the compressed PointCloud2 message\n\treturn compressed_msg;\n}", "CodeBleu_score": 36.461271144386615}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Compress the point cloud using an octree compression technique\n\tstd::vector<uint8_t> compressed_data;\n\toctree_compression.encodePointCloud(cloud, compressed_data);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tcompressed_msg.header = msg.header;\n\tcompressed_msg.height = 1;\n\tcompressed_msg.width = compressed_data.size();\n\tcompressed_msg.is_bigendian = false;\n\tcompressed_msg.is_dense = false;\n\tcompressed_msg.point_step = sizeof(uint8_t);\n\tcompressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n\tcompressed_msg.data = compressed_data;\n\tcompressed_msg.fields.resize(1);\n\tcompressed_msg.fields[0].name = \"data\";\n\tcompressed_msg.fields[0].offset = 0;\n\tcompressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n\tcompressed_msg.fields[0].count = 1;\n\n\t// Return the compressed message\n\treturn compressed_msg;\n}", "CodeBleu_score": 33.425572748468845}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size; i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 77.17147512665198}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.33433920515986}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.33433920515986}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState all_ugv_state;\n\tall_ugv_state.ugv_state_all.clear();\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state_all.size(); i++) {\n\t\tUGVState ugv_state;\n\t\tugv_state.id = m_multi_ugv_state.ugv_state_all[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state_all[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state_all[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state_all[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state_all[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state_all[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state_all[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state_all[i].velocity.z;\n\t\tugv_state.attitude.x = m_multi_ugv_state.ugv_state_all[i].attitude.x;\n\t\tugv_state.attitude.y = m_multi_ugv_state.ugv_state_all[i].attitude.y;\n\t\tugv_state.attitude.z = m_multi_ugv_state.ugv_state_all[i].attitude.z;\n\t\tall_ugv_state.ugv_state_all.push_back(ugv_state);\n\t}\n\tall_ugv_state.ugv_count = m_multi_ugv_state.ugv_count;\n\tall_ugv_state.header.stamp = ros::Time::now();\n\tall", "CodeBleu_score": 44.158184850989926}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize MultiUGVState message\n\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_state_all.begin\n\tmulti_ugv_state.ugv_state_all.end\n\tmulti_ugv_state.ugv_state_all.push_back\n\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state_all.size(); i++) {\n\t\t// Populate UGVState message with ID, battery, position, velocity, and attitude data\n\t\tUGVState ugv_state;\n\t\tugv_state.id = m_multi_ugv_state.ugv_state_all[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state_all[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state_all[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state_all[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state_all[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state_all[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state_all[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state_all[i].velocity.z;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_state_all[i].attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_state_all[i].attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_state_all[i].att", "CodeBleu_score": 43.38857223027802}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize MultiUGVState message\n\tMultiUGVState all_ugv_state;\n\tall_ugv_state.ugv_state_all.clear();\n\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (auto ugv_state : m_multi_ugv_state.ugv_state_all) {\n\t\t// Initialize UGVState message\n\t\tUGVState all_ugv_state_msg;\n\n\t\t// Populate UGVState message with ID, battery, position, velocity, and attitude data\n\t\tall_ugv_state_msg.id = ugv_state.id;\n\t\tall_ugv_state_msg.battery = ugv_state.battery;\n\t\tall_ugv_state_msg.position.x = ugv_state.position.x;\n\t\tall_ugv_state_msg.position.y = ugv_state.position.y;\n\t\tall_ugv_state_msg.position.z = ugv_state.position.z;\n\t\tall_ugv_state_msg.velocity.x = ugv_state.velocity.x;\n\t\tall_ugv_state_msg.velocity.y = ugv_state.velocity.y;\n\t\tall_ugv_state_msg.velocity.z = ugv_state.velocity.z;\n\t\tall_ugv_state_msg.attitude.x = ugv_state.attitude.x;\n\t\tall_ugv_state_msg.attitude.y = ugv_state.attitude.y;\n\t\tall_ugv_state_msg.attitude.z = ugv_state.attitude.z;\n\t\tall_ugv_state_msg.attitude.w = ugv_state.attitude.w;\n\n\t\t// Increment UGV count and add UGVState to MultiUGVState message\n\t\tall_ugv_state.ugv_state_all.push_back(all_ugv_state_msg);\n\t}\n\n\t// Publish assembled MultiUGVState message\n\tthis->all_ugv_state_pub_.publish(all_ugv_state);\n}", "CodeBleu_score": 39.01081506855495}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\ngradient.setZero();\n\n// Predict moving objects' positions\nEigen::MatrixXd obj_prid;\nmoving_objs_->predictObjPrid(q, obj_prid);\n\n// Evaluate the distance between control points and predicted positions of moving objects\nfor (int i = 0; i < cps_.points.cols(); i++) {\nif ((cps_.points.col(i) - obj_prid).norm() < clearance_) {\ncost += pow((cps_.points.col(i) - obj_prid).norm(), 2);\ngradient.col(i) += 2 * (cps_.points.col(i) - obj_prid).normalized();\n}\n}\n}", "CodeBleu_score": 27.326307807471288}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tEigen::MatrixXd obj_prid;", "CodeBleu_score": 3.5798986324843574}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tEigen::MatrixXd obj_prid = Eigen::MatrixXd::Zero(3, moving_objs_->getObjNums());\n\nfor (int i = 0; i < cps_.points.cols(); i++) {\nmoving_objs_->evaluateConstVel(q.col(i), obj_prid.col(i), ros::Time::now().toSec());\n\nfor (int j = 0; j < moving_objs_->getObjNums(); j++) {\nif (obj_prid.col(j).norm() < clearance_) {\ndouble dist = (cps_.points.col(i) - obj_prid.col(j)).norm();\ncost += dist;\ngradient.col(i) += (cps_.points.col(i) - obj_prid.col(j)).normalized() * dist;\n}\n}\n}\n}", "CodeBleu_score": 35.6104079696069}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tEigen::Vector3d xcrossv;\n\tdouble xcrossv_norm;\n\tdouble xdot;\n\tdouble xdot_norm;\n\tdouble xdotv_norm;\n\tdouble xdotv_norm_sq;\n\tdouble xdotv_norm_sq_inv;\n\tdouble xdotv_norm_sq_inv_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq;\n\tdouble xdotv_norm_sq_", "CodeBleu_score": 5.673995205572954}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tdouble a2 = 1.0 / 100.0;\n\tdouble b2 = 1.0 / 100.0;\n\tcost = 0.0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\tfor (int i = 2; i < q.cols() - 2; i++) {\n\t\tEigen::Vector3d x = q.col(i);\n\t\tEigen::Vector3d xcrossv = (x.cross(q.col(i + 1) - x)).normalized();\n\t\tEigen::Vector3d xcrossv_norm = xcrossv.normalized();\n\t\tEigen::Vector3d xcrossv_norm_dot = xcrossv_norm.dot(q.col(i + 1) - x);\n\t\tEigen::Vector3d xcrossv_norm_cross = xcrossv_norm.cross(q.col(i + 1) - x);\n\t\tcost += a2 * xcrossv_norm_dot * xcrossv_norm_dot + b2 * xcrossv_norm_cross.dot(xcrossv_norm_cross);\n\t\tgradient.col(i) += 2.0 * a2 * xcrossv_norm_dot * xcrossv + 2.0 * b2 * xcrossv_norm_cross;\n\t\tEigen::Vector3d xcrossv_norm_dot_2 = xcrossv_norm.dot(q.col(i - 1) - x);\n\t\tEigen::Vector3d xcrossv_norm_cross_2 = xcrossv_norm.cross(q.col(i - 1) - x);\n\t\tgradient.col(i - 1) += 2.0 * a2 * xcrossv_norm_dot_2 * xcrossv + 2.0 * b2 * xcrossv_norm_cross_2;\n\t}\n}", "CodeBleu_score": 39.45601669610498}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tdouble a2 = 1.0 / (a_ * a_);\n\tdouble b2 = 1.0 / (b_ * b_);\n\tcost = 0.0;\n\tgradient.setZero();\n\tfor (int i = 2; i < ref_pts_.size() - 2; i++) {\n\t\tEigen::Vector3d x = q.col(i);\n\t\tEigen::Vector3d xcrossv = (x.cross(v_[i])).normalized();\n\t\tEigen::Vector3d xcrossv_norm = xcrossv.norm();\n\t\tEigen::Vector3d xcrossv_norm2 = xcrossv_norm * xcrossv_norm;\n\t\tEigen::Vector3d xcrossv_norm4 = xcrossv_norm2 * xcrossv_norm2;\n\t\tEigen::Vector3d xcrossv_norm6 = xcrossv_norm4 * xcrossv_norm2;\n\t\tEigen::Vector3d xcrossv_norm8 = xcrossv_norm6 * xcrossv_norm2;\n\t\tEigen::Vector3d xcrossv_norm10 = xcrossv_norm8 * xcrossv_norm2;\n\t\tEigen::Vector3d gradient_col = (2.0 * a2 * xcrossv_norm4 * xcrossv + 2.0 * b2 * xcrossv_norm6 * xcrossv) / xcrossv_norm10;\n\t\tEigen::Vector3d x_cross = (x - ref_pts_[i]).normalized();\n\t\tEigen::Vector3d x_cross2 = x_cross * x_cross;\n\t\tEigen::Vector3d x_cross4 = x_cross2 * x_cross2;\n\t\tEigen::Vector3d x_cross6 = x_cross4 * x_cross2;\n\t\tEigen::Vector3d x_cross8 = x_cross6 * x_cross2;\n\t\tEigen::Vector3d x_cross10 = x_cross8 * x_cross2;\n\t\tEigen::Vector3d gradient_col2 = (2.0 * a2 * x_cross4 * x_cross + 2.0 * b2 * x_cross6 * x_cross) / x_cross10;\n\t", "CodeBleu_score": 34.26300542090641}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\t// Calculate the third derivative of the spline\n\tUniformBspline jerk_traj = this->getDerivative().getDerivative();\n\n\t// Retrieve the knot times and control points of the jerk trajectory\n\tMatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\tVectorXd times = jerk_pts.getKnot();\n\n\t// Calculate the total jerk value\n\tdouble total_jerk = 0.0;\n\tfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows(); j++) {\n\t\t\ttotal_jerk += pow(ctrl_pts(j, i), 2) * (times(i + 1) - times(i));\n\t\t}\n\t}\n\n\treturn total_jerk;\n}", "CodeBleu_score": 55.699931786869016}, {"code": "double UniformBspline::getJerk(){\n\t\t// Calculate the third derivative of the spline\n\tUniformBspline jerk_traj = getDerivative().getDerivative();\n\n\t// Retrieve the knot times and control points of the jerk trajectory\n\tMatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\tVectorXd times = jerk_pts.getKnot();\n\n\t// Initialize the jerk value\n\tdouble jerk = 0;\n\n\t// Iterate through the control points and dimensions\n\tfor (int i = 0; i < ctrl_pts.rows(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.cols(); j++) {\n\t\t\t// Sum the squared control point values multiplied by the differences in knot times\n\t\t\tjerk += pow(ctrl_pts(i, j), 2) * (times(i + 3) - times(i));\n\t\t}\n\t}\n\n\t// Return the jerk value\n\treturn jerk;\n}", "CodeBleu_score": 58.31540194379359}, {"code": "double UniformBspline::getJerk(){\n\t\t// calculate the third derivative of the spline\n\tUniformBspline jerk_traj = getDerivative().getDerivative();\n\n\t// retrieve the knot times and control points of the jerk trajectory\n\tEigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\tEigen::VectorXd times = jerk_pts.getKnot();\n\n\t// calculate the jerk\n\tdouble jerk = 0.0;\n\tfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows(); j++) {\n\t\t\tjerk += ctrl_pts(j, i) * pow(times(i + 1) - times(i), 3);\n\t\t}\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 63.93096373380794}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\t// TODO: implement this function\n\t// TODO: use the intrinsic camera parameters to calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth\n\t// TODO: use the function cv::reprojectImageTo3D to calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth\n\t// TODO: return the 4D position vector in the camera frame\n\t// TODO: use the function cv::reprojectImageTo3D to calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth\n\t// TODO: return the 4D position vector in the camera frame\n\t// TODO: use the function cv::reprojectImageTo3D to calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth\n\t// TODO: return the 4D position vector in the camera frame\n\t// TODO: use the function cv::reprojectImageTo3D to calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth\n\t// TODO: return the 4D position vector in the camera frame\n\t// TODO: use the function cv::reprojectImageTo3D to calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth\n\t// TODO: return the 4D position vector in the camera frame\n\t// TODO: use the function cv::reprojectImageTo3D to calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth\n\t// TODO: return the 4D position vector in the camera frame\n\t// TODO: use the function cv::reprojectImageTo3D to calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth\n\t// TODO: return the 4D position vector in the camera frame\n\t// TODO: use the function cv::reprojectImageTo3D to calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth\n\t// TODO: return the 4D position vector in the camera frame\n\t// TODO: use the function cv::reprojectImageTo3D to calculate the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth\n\t", "CodeBleu_score": 6.117225178051742}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos_in_camera;\n\tpos_in_camera(0) = (u - cx_) * depth / fx_;\n\tpos_in_camera(1) = (v - cy_) * depth / fy_;\n\tpos_in_camera(2) = depth;\n\tpos_in_camera(3) = 1;\n\treturn pos_in_camera;\n}", "CodeBleu_score": 82.80256194523837}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tfloat x = (u - cx_)/fx_;\n\tfloat y = (v - cy_)/fy_;\n\tEigen::Vector4d pos(x, y, depth, 1.0);\n\treturn pos;\n}", "CodeBleu_score": 32.18953656851407}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(7)));\n\t} catch (std::exception& e) {\n\t\tROS_ERROR_STREAM(\"Exception caught: \" << e.what());\n\t}\n}", "CodeBleu_score": 39.109133678409336}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(5)));\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n\t}\n}", "CodeBleu_score": 41.45651420464967}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(5)));\n\t}\n\tcatch (std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 39.45747620483208}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// TODO: Implement this function\n\t// This function should compute the true pose of the drone in the camera frame and check for its presence.\n\t// If found, it should compute the pose error between the camera and world coordinates, update the debug result, and publish the pose error.\n\t// If not found, it should update the debug result to indicate failure.\n\t//\n\t// You may find it useful to use the following functions:\n\t// - getDronePoseInCameraFrame\n\t// - getDronePoseInWorldFrame\n\t// - computePoseError\n\t// - publishPoseError\n\t//\n\t// You may also find it useful to use the following variables:\n\t// - drone_pose_in_camera_frame_\n\t// - drone_pose_in_world_frame_\n\t// - drone_pose_err_pub_\n\t// - drone_pose_err_\n\t// - drone_pose_err_pub_[drone_id]\n\t// - drone_pose_err_pub_[drone_id].publish\n\t// - pose_error\n\n\t// Get the drone pose in the camera frame\n\tEigen::Vector3d drone_pose_in_camera_frame;\n\tgetDronePoseInCameraFrame(drone_id, drone_pose_in_camera_frame);\n\n\t// Check if the drone is in the camera frame\n\tif (drone_pose_in_camera_frame(2) > 0) {\n\t\t// Get the drone pose in the world frame\n\t\tEigen::Vector3d drone_pose_in_world_frame;\n\t\tgetDronePoseInWorldFrame(drone_pose_in_camera_frame, drone_pose_in_world_frame);\n\n\t\t// Compute the pose error\n\t\tEigen::Vector3d pose_error;\n\t\tcomputePoseError(drone_pose_in_world_frame, drone_pose_in_camera_frame, pose_error);\n\n\t\t// Publish the pose error\n\t\tpublishPoseError(drone_id, pose_error);\n\n\t\t// Update the debug result\n\t\tdebug_result_.drone_detected[drone_id] = true;\n\t\tdebug_result_.drone_pose_err[drone_id] = pose_error;\n\t", "CodeBleu_score": 34.90964201197701}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// TODO: Implement\n\t// This function should calculate the true pose of the drone in the camera frame and check for its presence.\n\t// If found, it should compute the pose error between the camera and world coordinates, update the debug result,\n\t// and publish the pose error.\n\t// If not found, it should update the debug result to indicate failure.\n\n\t// Get the drone's true position\n\t// TODO: Implement\n\t// This function should get the drone's true position from the drone's true position map.\n\t// The true position map is stored in the drone_true_position_map_ attribute.\n\t// The drone's true position is stored in the drone_true_position_ attribute.\n\t// The drone's true position is a 3D vector with the x, y, and z coordinates.\n\t// The x, y, and z coordinates are stored in the x, y, and z attributes of the drone_true_position_ attribute.\n\t// The drone's true position is stored in the drone_true_position_ attribute.\n\t// The drone's true position is a 3D vector with the x, y, and z coordinates.\n\t// The x, y, and z coordinates are stored in the x, y, and z attributes of the drone_true_position_ attribute.\n\t// The drone's true position is stored in the drone_true_position_ attribute.\n\t// The drone's true position is a 3D vector with the x, y, and z coordinates.\n\t// The x, y, and z coordinates are stored in the x, y, and z attributes of the drone_true_position_ attribute.\n\t// The drone's true position is stored in the drone_true_position_ attribute.\n\t// The drone's true position is a 3D vector with the x, y, and z coordinates.\n\t// The x, y, and z coordinates are stored in the x, y, and z attributes of the drone_true_position_ attribute.\n\t// The drone's true position is stored in the drone_true_position_ attribute.\n\t// The drone's true position is a 3D vector with the x, y, and z coordinates.\n\t// The x,", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// 1. Calculate the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose = calculateTruePose(drone_id, true_pixel);\n\n\t// 2. Check for its presence\n\tif (checkPresence(drone_id, true_pose)) {\n\t\t// 3. Compute the pose error between the camera and world coordinates\n\t\tEigen::Vector3d pose_error = computePoseError(drone_id, true_pose);\n\n\t\t// 4. Update the debug result\n\t\tupdateDebugResult(drone_id, true_pose, pose_error);\n\n\t\t// 5. Publish the pose error\n\t\tpublishPoseError(drone_id, pose_error);\n\t} else {\n\t\t// 6. Update the debug result to indicate failure\n\t\tupdateDebugResult(drone_id, true_pose, Eigen::Vector3d::Zero());\n\t}\n}", "CodeBleu_score": 26.342570961487823}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\n\twhile (current!= start) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\n\treturn path;\n}", "CodeBleu_score": 69.93685397526156}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tGridNodePtr temp = current;\n\twhile (temp!= start) {\n\t\tpath.push_back(temp);\n\t\ttemp = cameFrom[temp];\n\t}\n\tpath.push_back(start);\n\treverse(path.begin(), path.end());\n\treturn path;\n}", "CodeBleu_score": 46.99605822696231}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start and end points to grid indices\n\tif (!Coord2Index(start_pt, start_idx) ||!Coord2Index(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// If start or end point is inside an obstacle, adjust it\n\tif (checkOccupancy(start_idx)) {\n\t\tstart_idx = start_idx + (start_pt - end_pt).normalized;\n\t\tif (checkOccupancy(start_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (checkOccupancy(end_idx)) {\n\t\tend_idx = end_idx + (end_pt - start_pt).normalized;\n\t\tif (checkOccupancy(end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 41.66698326776923}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// convert start and end points to grid indices\n\tif (!ConvertCoord2Index(start_pt, start_idx)) {\n\t\tROS_WARN_STREAM(\"AStar::ConvertToIndexAndAdjustStartEndPoints: start point is inside an obstacle.\");\n\t\treturn false;\n\t}\n\tif (!ConvertCoord2Index(end_pt, end_idx)) {\n\t\tROS_WARN_STREAM(\"AStar::ConvertToIndexAndAdjustStartEndPoints: end point is inside an obstacle.\");\n\t\treturn false;\n\t}\n\n\t// adjust start and end points if they are inside obstacles\n\tif (checkOccupancy(start_idx, end_idx)) {\n\t\tVector3i start_idx_copy = start_idx;\n\t\tVector3i end_idx_copy = end_idx;\n\t\tVector3d start_pt_copy = start_pt;\n\t\tVector3d end_pt_copy = end_pt;\n\t\twhile (checkOccupancy(start_idx_copy, end_idx_copy)) {\n\t\t\t// move start point\n\t\t\tstart_pt_copy = start_pt_copy + (start_pt_copy - end_pt_copy).normalized();\n\t\t\tif (!ConvertCoord2Index(start_pt_copy, start_idx_copy)) {\n\t\t\t\tROS_WARN_STREAM(\"AStar::ConvertToIndexAndAdjustStartEndPoints: start point is inside an obstacle.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// move end point\n\t\t\tend_pt_copy = end_pt_copy + (end_pt_copy - start_pt_copy).normalized();\n\t\t\tif (!ConvertCoord2Index(end_pt_copy, end_idx_copy)) {\n\t\t\t\tROS_WARN_STREAM(\"AStar::ConvertToIndexAndAdjustStartEndPoints: end point is inside an obstacle.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tstart_idx = start_idx_copy;\n\t\tend_idx = end_idx_copy;\n\t\tstart_pt = start_pt_copy;\n\t\tend_pt = end_pt_copy;\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.15319849066428}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert the start and end points to grid indices\n\tif (!ConvertPointToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertPointToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Check if the start or end point is inside an obstacle\n\tif (checkOccupancy(start_idx)) {\n\t\t// Adjust the start point by moving it away from the end point\n\t\twhile (checkOccupancy(start_idx)) {\n\t\t\tstart_idx += (start_pt - end_pt).normalized;\n\t\t}\n\t}\n\tif (checkOccupancy(end_idx)) {\n\t\t// Adjust the end point by moving it away from the start point\n\t\twhile (checkOccupancy(end_idx)) {\n\t\t\tend_idx += (end_pt - start_pt).normalized;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 39.783661624417135}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// Convert the min and max positions to grid coordinates\n\tEigen::Vector3i min_id = toGrid(min_pos);\n\tEigen::Vector3i max_id = toGrid(max_pos);\n\n\t// Reset the occupancy buffer\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\toccupancy_buffer_inflate_[x][y][z] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.1193025215032}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// get the min and max grid coordinates\n\tEigen::Vector3i min_id = worldToMap(min_pos);\n\tEigen::Vector3i max_id = worldToMap(max_pos);\n\n\t// iterate over the grid coordinates\n\tfor (int x = min_id.x(); x <= max_id.x(); ++x) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); ++y) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); ++z) {\n\t\t\t\t// set the corresponding element in the occupancy_buffer_inflate_ to zero\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.05213189637023}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// TODO: Implement\n\t// std::cout << \"Resetting buffer\" << std::endl;\n\t// std::cout << \"Min position: \" << min_pos << std::endl;\n\t// std::cout << \"Max position: \" << max_pos << std::endl;\n\t// std::cout << \"Min id: \" << min_id << std::endl;\n\t// std::cout << \"Max id: \" << max_id << std::endl;\n\tfor (int i = min_id.x; i < max_id.x; i++) {\n\t\tfor (int j = min_id.y; j < max_id.y; j++) {\n\t\t\tfor (int k = min_id.z; k < max_id.z; k++) {\n\t\t\t\toccupancy_buffer_inflate_[i][j][k] = 0;\n\t\t\t\tdistance_buffer_inflate_[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.85691563790566}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_scale = (diff(0) > 0)? (width_ / diff(0)) : (width_ / fabs(diff(0)));\n\tdouble y_scale = (diff(1) > 0)? (height_ / diff(1)) : (height_ / fabs(diff(1)));\n\tdouble z_scale = (diff(2) > 0)? (depth_ / diff(2)) : (depth_ / fabs(diff(2)));\n\tdouble scale = std::min(x_scale, std::min(y_scale, z_scale));\n\tEigen::Vector3d new_pt = pt - scale * diff;\n\treturn new_pt;\n}", "CodeBleu_score": 30.946755612532012}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_max = std::min(max_x, camera_pt(0) + max_x_range);\n\tdouble x_min = std::max(min_x, camera_pt(0) - max_x_range);\n\tdouble y_max = std::min(max_y, camera_pt(1) + max_y_range);\n\tdouble y_min = std::max(min_y, camera_pt(1) - max_y_range);\n\tdouble z_max = std::min(max_z, camera_pt(2) + max_z_range);\n\tdouble z_min = std::max(min_z, camera_pt(2) - max_z_range);\n\n\tdouble x_scale = 1.0;\n\tdouble y_scale = 1.0;\n\tdouble z_scale = 1.0;\n\n\tif (diff(0) > 0) {\n\t\tx_scale = (x_max - camera_pt(0)) / diff(0);\n\t} else if (diff(0) < 0) {\n\t\tx_scale = (x_min - camera_pt(0)) / diff(0);\n\t}\n\n\tif (diff(1) > 0) {\n\t\ty_scale = (y_max - camera_pt(1)) / diff(1);\n\t} else if (diff(1) < 0) {\n\t\ty_scale = (y_min - camera_pt(1)) / diff(1);\n\t}\n\n\tif (diff(2) > 0) {\n\t\tz_scale = (z_max - camera_pt(2)) / diff(2);\n\t} else if (diff(2) < 0) {\n\t\tz_scale = (z_min - camera_pt(2)) / diff(2);\n\t}\n\n\tdouble scale = std::min(std::min(x_scale, y_scale), z_scale);\n\n\treturn pt + scale * diff;\n}", "CodeBleu_score": 33.58272502355402}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_scale = diff(0) / (map_width / 2.0);\n\tdouble y_scale = diff(1) / (map_height / 2.0);\n\tdouble z_scale = diff(2) / (map_depth / 2.0);\n\tEigen::Vector3d closest_pt;\n\tif (x_scale < 0.0) {\n\t\tclosest_pt(0) = -map_width / 2.0;\n\t} else if (x_scale > 1.0) {\n\t\tclosest_pt(0) = map_width / 2.0;\n\t} else {\n\t\tclosest_pt(0) = pt(0);\n\t}\n\tif (y_scale < 0.0) {\n\t\tclosest_pt(1) = -map_height / 2.0;\n\t} else if (y_scale > 1.0) {\n\t\tclosest_pt(1) = map_height / 2.0;\n\t} else {\n\t\tclosest_pt(1) = pt(1);\n\t}\n\tif (z_scale < 0.0) {\n\t\tclosest_pt(2) = -map_depth / 2.0;\n\t} else if (z_scale > 1.0) {\n\t\tclosest_pt(2) = map_depth / 2.0;\n\t} else {\n\t\tclosest_pt(2) = pt(2);\n\t}\n\treturn closest_pt;\n}", "CodeBleu_score": 33.87203224323433}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update last occupancy update time\n\tmd_.last_occ_update_time_ = ros::Time::now();\n\n\t// Check if update is needed\n\tif (md_.last_occ_update_time_ - md_.last_depth_update_time_ > md_.max_depth_update_delay_ ||\n\t\tmd_.last_occ_update_time_ - md_.last_odom_update_time_ > md_.max_odom_update_delay_ ||\n\t\tmd_.last_occ_update_time_ - md_.last_laser_update_time_ > md_.max_laser_update_delay_ ||\n\t\tmd_.last_occ_update_time_ - md_.last_imu_update_time_ > md_.max_imu_update_delay_) {\n\t\tROS_ERROR(\"GridMap::updateOccupancyCallback: Update not needed.\");\n\t\treturn;\n\t}\n\n\t// Project depth image into points\n\tif (md_.depth_image_sub_!= NULL) {\n\t\tif (projectDepthImage(md_.depth_image_sub_->getDepthImage())) {\n\t\t\t// Process points with raycasting\n\t\t\traycastProcess();\n\t\t} else {\n\t\t\tROS_ERROR(\"GridMap::updateOccupancyCallback: Error while projecting depth image.\");\n\t\t}\n\t}\n\n\t// Update local map\n\tif (md_.local_map_update_needed_) {\n\t\tclearAndInflateLocalMap();\n\t}\n\n\t// Handle timeout errors\n\tif (md_.last_depth_update_time_ == md_.last_depth_update_time_timeout_) {\n\t\tROS_ERROR(\"GridMap::updateOccupancyCallback: Timeout for depth data.\");\n\t\tmd_.depth_image_sub_ = NULL;\n\t}\n\tif (md_.last_odom_update_time_ == md_.last_odom_update_time_timeout_) {\n\t\tROS_ERROR(\"GridMap::updateOccupancyCallback: Timeout for odometry data.\");\n\t\tmd_.odom_sub_ = NULL;\n\t}\n\tif (md_.last_laser_update_time_ == md_.last_laser_update_time_timeout_) {\n\t\tROS_ERROR(\"GridMap::updateOccupancyCallback: Timeout for laser", "CodeBleu_score": 50.03664815247446}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update last occupancy update time\n\tmd_.last_occ_update_time_ = ros::Time::now();\n\n\t// Check if an update is needed\n\tif (md_.last_occ_update_time_.toSec() - md_.last_depth_update_time_.toSec() < md_.depth_update_timeout_ &&\n\t\tmd_.last_occ_update_time_.toSec() - md_.last_odom_update_time_.toSec() < md_.odom_update_timeout_) {\n\t\treturn;\n\t}\n\n\t// Project depth image into points\n\tif (md_.last_depth_update_time_.toSec() < md_.last_occ_update_time_.toSec()) {\n\t\tprojectDepthImage();\n\t}\n\n\t// Process points with raycasting\n\traycastProcess();\n\n\t// Clear and inflate local map\n\tif (md_.last_occ_update_time_.toSec() - md_.last_odom_update_time_.toSec() > md_.odom_update_timeout_) {\n\t\tclearAndInflateLocalMap();\n\t}\n}", "CodeBleu_score": 46.73644390014181}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\n//  if (md_.last_occ_update_time_ + md_.update_interval_ < ros::Time::now()) {\n//    md_.last_occ_update_time_ = ros::Time::now();\n\n    if (md_.last_depth_update_time_ + md_.update_interval_ < ros::Time::now()) {\n      md_.last_depth_update_time_ = ros::Time::now();\n\n      // Check if the depth image is available.\n      if (md_.depth_image_received_) {\n        // Project the depth image into points.\n        projectDepthImage();\n\n        // Process the points with raycasting.\n        raycastProcess();\n\n        // Clear and inflate the local map.\n        clearAndInflateLocalMap();\n      } else {\n        // Set the flag that the depth image is not available.\n        md_.depth_image_received_ = false;\n      }\n    }\n\n    if (md_.last_odom_update_time_ + md_.update_interval_ < ros::Time::now()) {\n      md_.last_odom_update_time_ = ros::Time::now();\n\n      // Check if the odometry is available.\n      if (md_.odom_received_) {\n        // Update the local map.\n        updateLocalMap();\n      } else {\n        // Set the flag that the odometry is not available.\n        md_.odom_received_ = false;\n      }\n    }\n\n    if (md_.last_occ_update_time_ + md_.update_interval_ < ros::Time::now()) {\n      md_.last_occ_update_time_ = ros::Time::now();\n\n      // Check if the occupancy grid is available.\n      if (md_.occ_grid_received_) {\n        // Check if the local map is available.\n        if (md_.local_map_received_) {\n          // Update the occupancy grid.\n          updateOccupancyGrid();\n        } else {\n          // Set the flag that the local map is not available.\n          md_.local_map_received_ = false;\n        }\n      } else {\n        // Set the flag that the occupancy grid is not available.\n        md_.occ_grid_received_ = false;\n      }\n    }\n\n//  }\n}", "CodeBleu_score": 56.155879081446734}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tint num_images = image_fns.size();\n\tfloat f_measure_sum = 0.0;\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load image\n\t\tMat image = _load_ellipse_image(image_fns[i]);\n\t\t// Load ground truth\n\t\tvector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\t// Load detected ellipses\n\t\tvector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i]);\n\t\t// Evaluate detection performance\n\t\tfloat f_measure = _ellipse_evaluate_one(image, gt_ellipses, dt_ellipses);\n\t\t// Accumulate F-measure\n\t\tf_measure_sum += f_measure;\n\t}\n\t// Return average F-measure\n\treturn f_measure_sum / num_images;\n}", "CodeBleu_score": 55.399562890658125}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\t/*\n\t * Initialize the variables used to calculate the average F-measure.\n\t * num_images: The number of images in the dataset.\n\t * num_true_positives: The number of true positives, i.e., ellipses correctly detected in the dataset.\n\t * num_false_positives: The number of false positives, i.e., ellipses incorrectly detected in the dataset.\n\t * num_false_negatives: The number of false negatives, i.e., ellipses not detected in the dataset.\n\t * num_ellipses: The total number of ellipses in the dataset.\n\t */\n\tint num_images = image_fns.size();\n\tint num_true_positives = 0;\n\tint num_false_positives = 0;\n\tint num_false_negatives = 0;\n\tint num_ellipses = 0;\n\n\t/*\n\t * Iterate through the image filenames.\n\t */\n\tfor (int i = 0; i < num_images; i++) {\n\t\t/*\n\t\t * Load the ground truth and detected ellipses for the current image.\n\t\t */\n\t\tvector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i], gt_angle_radians);\n\n\t\t/*\n\t\t * Evaluate the detection performance for the current image.\n\t\t */\n\t\tfloat f_measure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses);\n\n\t\t/*\n\t\t * Update the variables used to calculate the average F-measure.\n\t\t */\n\t\tnum_true_positives += f_measure.true_positives;\n\t\tnum_false_positives += f_measure.false_positives;\n\t\tnum_false_negatives += f_measure.false_negatives;\n\t\tnum_ellipses += f_measure.num_ellipses;\n\t}\n\n\t/*\n\t * Calculate the average F-measure.\n\t */\n\tfloat average_f_measure = 2 * (float)num_true_positives / (2 * num_true_positives + num_false_positives + num_false_negatives", "CodeBleu_score": 47.367868515864394}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tint num_images = image_fns.size();\n\tfloat avg_F = 0;\n\tfor (int i = 0; i < num_images; i++) {\n\t\t// Load the image, ground truth, and detected ellipses for the current image\n\t\tMat image = imread(image_fns[i]);\n\t\tMat gt = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\tMat dt = _load_ellipse_DT(dt_fns[i]);\n\n\t\t// Evaluate the detection performance for the current image\n\t\tfloat F = _ellipse_evaluate_one(image, gt, dt);\n\n\t\t// Accumulate the F-measure\n\t\tavg_F += F;\n\t}\n\n\t// Return the average F-measure\n\treturn avg_F / num_images;\n}", "CodeBleu_score": 53.636506813629126}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle1, angle2;\n\tfloat angle_diff_signed;\n\tfloat angle_diff_adjusted;\n\n\tif (foci!= NULL) {\n\t\tangle1 = atan2(y - foci[1], x - foci[0]);\n\t\tangle2 = atan2(y - foci[3], x - foci[2]);\n\t\tangle_diff_signed = angle1 - angle2;\n\t\tangle_diff_adjusted = angle_diff_signed - M_PI;\n\t\tif (angle_diff_adjusted > M_PI) {\n\t\t\tangle_diff_adjusted -= 2 * M_PI;\n\t\t} else if (angle_diff_adjusted < -M_PI) {\n\t\t\tangle_diff_adjusted += 2 * M_PI;\n\t\t}\n\t} else {\n\t\tangle_diff_adjusted = 0;\n\t}\n\treturn angle_diff_adjusted;\n}", "CodeBleu_score": 52.30260344684458}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = foci[0];\n\tfloat b = foci[1];\n\tfloat c = foci[2];\n\tfloat d = foci[3];\n\tfloat e = foci[4];\n\tfloat f = foci[5];\n\tfloat g = foci[6];\n\tfloat h = foci[7];\n\tfloat i = foci[8];\n\tfloat j = foci[9];\n\tfloat k = foci[10];\n\tfloat l = foci[11];\n\tfloat m = foci[12];\n\tfloat n = foci[13];\n\tfloat o = foci[14];\n\tfloat p = foci[15];\n\tfloat q = foci[16];\n\tfloat r = foci[17];\n\tfloat s = foci[18];\n\tfloat t = foci[19];\n\tfloat u = foci[20];\n\tfloat v = foci[21];\n\tfloat w = foci[22];\n\tfloat x1 = x - a;\n\tfloat y1 = y - b;\n\tfloat x2 = x - c;\n\tfloat y2 = y - d;\n\tfloat x3 = x - e;\n\tfloat y3 = y - f;\n\tfloat x4 = x - g;\n\tfloat y4 = y - h;\n\tfloat x5 = x - i;\n\tfloat y5 = y - j;\n\tfloat x6 = x - k;\n\tfloat y6 = y - l;\n\tfloat x7 = x - m;\n\tfloat y7 = y - n;\n\tfloat x8 = x - o;\n\tfloat y8 = y - p;\n\tfloat x9 = x - q;\n\tfloat y9 = y - r;\n\tfloat x10 = x - s;\n\tfloat y10 = y - t;\n\tfloat x11 = x - u;\n\tfloat y11 = y - v;\n\tfloat x12 = x - w;\n\tfloat y12 = y - x;\n\tfloat x13 = x1 * x1;\n\tfloat y13 = y1 * y", "CodeBleu_score": 27.664480072127777}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat foci_x = foci[0];\n\tfloat foci_y = foci[1];\n\tfloat foci_x_diff = x - foci_x;\n\tfloat foci_y_diff = y - foci_y;\n\tfloat foci_angle_1 = atan2f(foci_y_diff, foci_x_diff);\n\tfloat foci_x_diff_2 = x - foci_x * -1;\n\tfloat foci_y_diff_2 = y - foci_y * -1;\n\tfloat foci_angle_2 = atan2f(foci_y_diff_2, foci_x_diff_2);\n\tfloat angle_diff_signed = foci_angle_2 - foci_angle_1;\n\tfloat angle_diff = fabsf(angle_diff_signed);\n\tfloat normal_angle = angle_diff_signed < 0? angle_diff : -angle_diff;\n\treturn normal_angle;\n}", "CodeBleu_score": 33.6776415730974}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble x_min = vp1[start].x;\n\tdouble x_max = vp1[start].x;\n\tdouble y_min = vp1[start].y;\n\tdouble y_max = vp1[start].y;\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < x_min)\n\t\t\tx_min = vp1[i].x;\n\t\tif (vp1[i].x > x_max)\n\t\t\tx_max = vp1[i].x;\n\t\tif (vp1[i].y < y_min)\n\t\t\ty_min = vp1[i].y;\n\t\tif (vp1[i].y > y_max)\n\t\t\ty_max = vp1[i].y;\n\t}\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tif (i == end - 1) {\n\t\t\tintegral_above += ((vp1[start].x - vp1[end].x) * (vp1[start].y + vp1[end].y)) / 2;\n\t\t\tintegral_below += ((vp1[start].x - vp1[end].x) * (vp1[start].y + vp1[end].y)) / 2;\n\t\t} else {\n\t\t\tintegral_above += ((vp1[i].x - vp1[i + 1].x) * (vp1[i].y + vp1[i + 1].y)) / 2;\n\t\t\tintegral_below += ((vp1[i].x - vp1[i + 1].x) * (vp1[i].y + vp1[i + 1].y)) / 2;\n\t\t}\n\t}\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 35.160564339485425}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_x = vp1[start].x;\n\tdouble max_y = vp1[start].y;\n\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\n\tdouble above = 0;\n\tdouble below = 0;\n\n\tfor (int i = start; i < end; i++) {\n\t\tdouble x1 = vp1[i].x;\n\t\tdouble y1 = vp1[i].y;\n\t\tdouble x2 = vp1[(i + 1) % vp1.size()].x;\n\t\tdouble y2 = vp1[(i + 1) % vp1.size()].y;\n\n\t\tdouble x_min = min(x1, x2);\n\t\tdouble x_max = max(x1, x2);\n\t\tdouble y_min = min(y1, y2);\n\t\tdouble y_max = max(y1, y2);\n\n\t\tif (x_min <= min_x && x_max >= max_x && y_min <= min_y && y_max >= max_y) {\n\t\t\tabove += (x1 * y2 - x2 * y1);\n\t\t\tbelow += (x2 * y1 - x1 * y2);\n\t\t}\n\t}\n\n\treturn above < below;\n}", "CodeBleu_score": 40.82781772529608}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint min_x = vp1[start].x;\n\tint max_x = vp1[start].x;\n\tint min_y = vp1[start].y;\n\tint max_y = vp1[start].y;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\tint integral_above = 0;\n\tint integral_below = 0;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].y > vp1[i + 1].y) {\n\t\t\tintegral_above += (vp1[i].x - vp1[i + 1].x) * (vp1[i].y + vp1[i + 1].y);\n\t\t} else {\n\t\t\tintegral_below += (vp1[i].x - vp1[i + 1].x) * (vp1[i].y + vp1[i + 1].y);\n\t\t}\n\t}\n\tif (integral_above < integral_below) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 39.290008986456876}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->detection_info.size(); i++) {\n\t\tif (msg->detection_info[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\tif (is_detected) {\n\t\tsight_angle = msg->detection_info[0].sight_angle;\n\t} else {\n\t\tsight_angle = 0;\n\t}\n}", "CodeBleu_score": 59.34111335185581}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tint i = 0;\n\tbool is_detected = false;\n\tint num_regain = 0;\n\tint num_lost = 0;\n\tint num_objects = msg->num_objects;\n\t//ROS_INFO(\"num_objects: %d\", num_objects);\n\tfor (i = 0; i < num_objects; i++) {\n\t\tif (msg->objects[i].object_name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\tellipse_det.is_detected = is_detected;\n\tellipse_det.sight_angle = msg->objects[0].sight_angle;\n\t//ROS_INFO(\"is_detected: %d\", ellipse_det.is_detected);\n}", "CodeBleu_score": 64.49561575245485}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tint i;\n\tfor (i = 0; i < msg->detections.size(); i++) {\n\t\tif (msg->detections[i].label == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tstd::swap(ellipse_det.sight_angle[0], ellipse_det.sight_angle[1]);\n\t}\n}", "CodeBleu_score": 58.800068692722284}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tdouble x_min = cur_pos(0) - safe_distance;\n\tdouble x_max = cur_pos(0) + safe_distance;\n\tdouble y_min = cur_pos(1) - safe_distance;\n\tdouble y_max = cur_pos(1) + safe_distance;\n\tdouble z_min = cur_pos(2) - safe_distance;\n\tdouble z_max = cur_pos(2) + safe_distance;\n\tif (Occupy_map_ptr->check_safety(x_min, x_max, y_min, y_max, z_min, z_max)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 39.13161922727556}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tif (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 46.49687078788895}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr node = end_node;\n\twhile (node->getParent()!= nullptr) {\n\t\tpath_nodes_.push_back(node);\n\t\tnode = node->getParent();\n\t}\n\tpath_nodes_.push_back(node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 54.296384060252876}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr curr_node = end_node;\n\twhile (curr_node->parent_!= nullptr) {\n\t\tpath_nodes_.push_back(curr_node);\n\t\tcurr_node = curr_node->parent_;\n\t}\n\tpath_nodes_.push_back(curr_node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.859017559150764}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr current = end_node;\n\twhile (current->getParent()!= nullptr) {\n\t\tpath_nodes_.push_back(current);\n\t\tcurrent = current->getParent();\n\t}\n\tpath_nodes_.push_back(current);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 54.23807348189676}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].get_nei_state = true;\n\tif (sim_mode) {\n\t\tif (sqrt(pow(state_nei[id].x - start_pos.x, 2) + pow(state_nei[id].y - start_pos.y, 2)) > 5) {\n\t\t\tstate_nei[id].get_nei_state = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 34.72543490539917}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\n\tif(sim_mode) {\n\t\tif(get_nei_state) {\n\t\t\tif(dist(start_pos-state_nei[id])>5) {\n\t\t\t\tget_nei_state = false;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state = true;\n\t}\n}", "CodeBleu_score": 39.78546672685594}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif (odom->child_frame_id == \"base_link\") {\n\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\t\tstate_nei[id].y = odom->pose.pose.position.y;\n\t\tstate_nei[id].z = odom->pose.pose.position.z;\n\t\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\t\tstate_nei[id].id = id;\n\t\tstate_nei[id].get_nei_state = true;\n\t\tif (sim_mode) {\n\t\t\tif ((state_nei[id].x - start_pos.x)*(state_nei[id].x - start_pos.x) + (state_nei[id].y - start_pos.y)*(state_nei[id].y - start_pos.y) > 5.0) {\n\t\t\t\tstate_nei[id].get_nei_state = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.14306822331495}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Point cloud callback\");\n\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count == 5) {\n\t\tupdate_count = 0;\n\t\t//ROS_INFO(\"Updating map\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");\n\t\t//ROS_INFO(\"Map update\");", "CodeBleu_score": 36.41193757260745}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb\");\n\tif (this->odom_ready) {\n\t\tthis->sensor_ready = true;\n\t\tthis->update_counter++;\n\t\tif (this->update_counter == 5) {\n\t\t\tthis->update_counter = 0;\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: update_counter = %d\", this->update_counter);\n\t\t\tthis->update_map(msg);\n\t\t}\n\t}\n}", "CodeBleu_score": 21.179449482749526}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Pointcloud_cb\");\n\tif (this->sensor_ready) {\n\t\tthis->sensor_ready = false;\n\t\tthis->update_counter++;\n\t\tif (this->update_counter % 5 == 0) {\n\t\t\t//ROS_INFO(\"update_counter % 5 == 0\");\n\t\t\tthis->update_map(msg);\n\t\t\tthis->update_counter = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 22.363625641015418}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tgpcl = pcl::PointCloud<pcl::PointXYZ>::Ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tgpcl = inflate_point_cloud(gpcl, inflation_radius);\n\t}\n}", "CodeBleu_score": 51.657495751523456}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tROS_INFO(\"Updating global map\");\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr global_point_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(*global_point, *global_point_cloud);\n\t\tglobal_map = global_point_cloud;\n\t\tget_gpcl = true;\n\t}\n\telse {\n\t\tROS_INFO(\"Global map already updated\");\n\t}\n}", "CodeBleu_score": 53.672098431935524}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\t// If the global map has not been updated yet, update the global map\n\tif(!get_gpcl) {\n\t\t// Set the flag\n\t\tget_gpcl = true;\n\t\t// Convert the sensor message to a point cloud\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr global_cloud (new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(*global_point, *global_cloud);\n\t\t// Store the point cloud\n\t\tglobal_map = global_cloud;\n\t\t// Inflate the point cloud\n\t\tinflate_point_cloud(global_map);\n\t}\n}", "CodeBleu_score": 55.06216163945261}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// convert laser scan data to point cloud\n\tpcl::PointCloud<pcl::PointXYZ> local_map_cloud;\n\tpcl::fromROSMsg(*local_point, local_map_cloud);\n\t// project laser scan into map frame\n\tpcl::PointCloud<pcl::PointXYZ> local_map_cloud_projected;\n\tprojector_.projectLaser(local_map_cloud, local_map_cloud_projected, odom);\n\t// merge local map with odometry data\n\tif (!sim_mode_) {\n\t\tmap_merge_odom(local_map_cloud_projected, odom);\n\t}\n\t// update local map\n\tlocal_map_ = local_map_cloud_projected;\n}", "CodeBleu_score": 44.841517964592285}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_", "CodeBleu_score": 9.54836615882347}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// convert laser scan to point cloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*local_point, *cloud_ptr);\n\n\t// project laser scan to map frame\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr_map(new pcl::PointCloud<pcl::PointXYZ>);\n\tprojector_.projectLaser(*cloud_ptr, *cloud_ptr_map);\n\n\t// convert point cloud to map\n\tsensor_msgs::PointCloud2 map_cloud;\n\tpcl::toROSMsg(*cloud_ptr_map, map_cloud);\n\tmap_cloud.header.frame_id = \"map\";\n\tmap_cloud.header.stamp = ros::Time::now();\n\n\t// merge local map with odometry data\n\tif (!sim_mode_) {\n\t\tsensor_msgs::PointCloud2 merged_map;\n\t\tlocal_map_merge_odom(map_cloud, odom, merged_map);\n\t\tmap_cloud = merged_map;\n\t}\n\n\t// update map\n\tmap_pub_.publish(map_cloud);\n}", "CodeBleu_score": 43.57070468516451}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::PointCloud<pcl::PointXYZ> pcl_global_map;\n\tpcl::PointCloud<pcl::PointXYZ> pcl_inflate_map;\n\n\t// Convert the global point cloud map to a ROS message\n\tpcl::toROSMsg(global_map, pcl_global_map);\n\tpcl_global_map.header.frame_id = \"world\";\n\n\t// Convert and publish the inflated point cloud map\n\tpcl::toROSMsg(inflate_map, pcl_inflate_map);\n\tpcl_inflate_map.header.frame_id = \"world\";\n\n\t// Publish the global point cloud map\n\tglobal_pcl_pub.publish(pcl_global_map);\n\n\t// Publish the inflated point cloud map\n\tinflate_pcl_pub.publish(pcl_inflate_map);\n}", "CodeBleu_score": 49.83576198881325}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert the global point cloud map to a ROS message\n\tsensor_msgs::PointCloud2 global_pcl;\n\tpcl::toROSMsg(global_pcl_map, global_pcl);\n\tglobal_pcl.header.frame_id = \"world\";\n\tglobal_pcl.header.stamp = ros::Time::now();\n\n\t// Publish the global point cloud\n\tglobal_pcl_pub.publish(global_pcl);\n\n\t// Convert and publish the inflated point cloud\n\tsensor_msgs::PointCloud2 inflate_pcl;\n\tpcl::toROSMsg(inflate_pcl_map, inflate_pcl);\n\tinflate_pcl.header.frame_id = \"world\";\n\tinflate_pcl.header.stamp = ros::Time::now();\n\tinflate_pcl_pub.publish(inflate_pcl);\n}", "CodeBleu_score": 52.865662899861185}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::toROSMsg(*global_pcl, global_pcl_msg);\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\tpcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 48.88792250278006}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO", "CodeBleu_score": 8.100340493269277}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\tif (msg->header.frame_id == \"map\") {\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"Lpointcloud_cb: %s\", msg->header.frame_id.c_str());\n\t\t//ROS_INFO(\"L", "CodeBleu_score": 36.470351355381744}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO", "CodeBleu_score": 8.100340493269277}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get current time\n\tros::Time current_time = ros::Time::now();\n\n\t// Get current time in champ time\n\tros::Time champ_time = rosTimeToChampTime(current_time);\n\n\t// Get current time in ros time\n\tros::Time ros_time = champTimeToRosTime(champ_time);\n\n\t// Get current time in ros time\n\tros::Time ros_time_2 = champTimeToRosTime(champ_time + ros::Duration(0.001));\n\n\t// Get current time in ros time\n\tros::Time ros_time_3 = champTimeToRosTime(champ_time + ros::Duration(0.002));\n\n\t// Get current time in ros time\n\tros::Time ros_time_4 = champTimeToRosTime(champ_time + ros::Duration(0.003));\n\n\t// Get current time in ros time\n\tros::Time ros_time_5 = champTimeToRosTime(champ_time + ros::Duration(0.004));\n\n\t// Get current time in ros time\n\tros::Time ros_time_6 = champTimeToRosTime(champ_time + ros::Duration(0.005));\n\n\t// Get current time in ros time\n\tros::Time ros_time_7 = champTimeToRosTime(champ_time + ros::Duration(0.006));\n\n\t// Get current time in ros time\n\tros::Time ros_time_8 = champTimeToRosTime(champ_time + ros::Duration(0.007));\n\n\t// Get current time in ros time\n\tros::Time ros_time_9 = champTimeToRosTime(champ_time + ros::Duration(0.008));\n\n\t// Get current time in ros time\n\tros::Time ros_time_10 = champTimeToRosTime(champ_time + ros::Duration(0.009));\n\n\t// Get current time in ros time\n\tros::Time ros_time_11 = champTimeToRosTime(champ_time + ros::Duration(0.01));\n\n\t// Get current time in ros time\n\tros::Time ros_time_12 = champTimeToRosTime(champ_time + ros::Duration(0.011));\n\n\t// Get current time in", "CodeBleu_score": 35.12358272975205}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get the current time\n\tros::Time time = ros::Time::now();\n\n\t// Get the current time in Champ time\n\tros::Time champTime = rosTimeToChampTime(time);\n\n\t// Get the current pose of the body\n\tgeometry_msgs::PoseStamped bodyPose;\n\tbody_controller_.poseCommand.readFrom(bodyPose);\n\n\t// Get the current velocity of the body\n\tgeometry_msgs::TwistStamped bodyVelocity;\n\tbody_controller_.velocityCommand.readFrom(bodyVelocity);\n\n\t// Get the current joint positions\n\tsensor_msgs::JointState jointState;\n\tjointState.header.stamp = time;\n\tjointState.name = jointNames_;\n\tjointState.position = jointPositions_;\n\n\t// Get the current foot contacts\n\tstd_msgs::Bool footContacts;\n\tfootContacts.data = footContacts_;\n\n\t// Get the current foot positions\n\tgeometry_msgs::PoseArray footPoses;\n\tfootPoses.header.stamp = time;\n\tfootPoses.poses = footPoses_;\n\n\t// Compute the target foot positions\n\tgeometry_msgs::PoseArray targetFootPoses = computeTargetFootPoses_(bodyPose, bodyVelocity, champTime);\n\n\t// Compute the target joint positions\n\tsensor_msgs::JointState targetJointState = kinematics_.inverse(targetFootPoses);\n\n\t// Publish the target joint positions\n\tjointState.position = targetJointState.position;\n\tpublishJoints_.publish(jointState);\n\n\t// Publish the target foot positions\n\tfootPoses.poses = targetFootPoses.poses;\n\tpublishFootContacts_.publish(footPoses);\n\n\t// Publish the foot contacts\n\tfootContacts.data = footContacts_;\n\tpublishFootContacts_.publish(footContacts);\n}", "CodeBleu_score": 38.446132278614776}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get the current time\n\tros::Time now = ros::Time::now();\n\n\t// Calculate the current time in Champ time\n\tros::Time champTime = rosTimeToChampTime(now);\n\n\t// Get the current pose of the body\n\tgeometry_msgs::PoseStamped bodyPose;\n\tbody_controller_.poseCommand.readFrom(bodyPose);\n\n\t// Calculate the target foot positions based on the body pose\n\tgeometry_msgs::PoseStamped targetFootPose[num_legs_];\n\tfor (int i = 0; i < num_legs_; i++) {\n\t\ttargetFootPose[i] = bodyPose;\n\t\ttargetFootPose[i].pose.position.z += leg_heights_[i];\n\t}\n\n\t// Calculate the target joint positions based on the target foot positions\n\tstd::vector<double> targetJointPositions;\n\tkinematics_.inverse(targetFootPose, targetJointPositions);\n\n\t// Calculate the target joint velocities based on the target joint positions\n\tstd::vector<double> targetJointVelocities;\n\tfor (int i = 0; i < num_joints_; i++) {\n\t\ttargetJointVelocities.push_back(0.0);\n\t}\n\n\t// Calculate the target joint accelerations based on the target joint velocities\n\tstd::vector<double> targetJointAccelerations;\n\tfor (int i = 0; i < num_joints_; i++) {\n\t\ttargetJointAccelerations.push_back(0.0);\n\t}\n\n\t// Calculate the target joint torques based on the target joint accelerations\n\tstd::vector<double> targetJointTorques;\n\tfor (int i = 0; i < num_joints_; i++) {\n\t\ttargetJointTorques.push_back(0.0);\n\t}\n\n\t// Calculate the target foot contact information\n\tstd::vector<bool> targetFootContacts;\n\tfor (int i = 0; i < num_legs_; i++) {\n\t\ttargetFootContacts.push_back(false);\n\t}\n\n\t// Publish the joint positions\n\tpublishJoints_(targetJointPositions, champTime);\n\n\t// Publish the foot contact information\n\tpublishFootContacts_(targetFootContacts, champTime);\n\n\t", "CodeBleu_score": 44.44762157479739}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (!publish_foot_contacts_ || in_gazebo_) {\n\t\treturn;\n\t}\n\n\t// Create a message to be published\n\tsensor_msgs::Contacts contacts_msg;\n\tcontacts_msg.header.stamp = ros::Time::now();\n\tcontacts_msg.header.frame_id = \"world\";\n\n\t// Populate the message with the current gait phase of each leg\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (foot_contacts[i]) {\n\t\t\tcontacts_msg.contacts.resize(contacts_msg.contacts.size() + 1);\n\t\t\tcontacts_msg.contacts.back().contact_point.header.stamp = ros::Time::now();\n\t\t\tcontacts_msg.contacts.back().contact_point.header.frame_id = \"world\";\n\t\t\tcontacts_msg.contacts.back().contact_point.point.x = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.point.y = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.point.z = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.normal.x = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.normal.y = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.normal.z = 1;\n\t\t\tcontacts_msg.contacts.back().contact_point.depth = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.surface.friction = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.surface.restitution = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.surface.density = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.surface.traction_coef = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.surface.rolling_resistance = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.surface.soft_cfm = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.surface.soft_erp = 0;\n\t\t\tcontacts_msg.contacts.back().contact_point.surface.contact_max_de", "CodeBleu_score": 45.057230562129355}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\t// If foot contact publishing is enabled and the robot is not in Gazebo, create a ContactsStamped message.\n\tif (foot_contacts_enabled_ &&!in_gazebo_) {\n\t\t// Create a ContactsStamped message.\n\t\tContactsStamped contacts_msg;\n\n\t\t// Populate the message with the current gait phase of each leg.\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts[i].phase = foot_contacts_base_.legs[i]->gait_phase;\n\t\t}\n\n\t\t// Publish the message.\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 53.13581056942258}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publishing_enabled_ &&!in_gazebo_) {", "CodeBleu_score": 4.847350041925935}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\tvar joints_msg = new std_msgs/Float64MultiArray()\n\tjoints_msg.data = joints.position\n\tself.pub.publish(joints_msg)\n\n\tvar trajectory_msg = new trajectory_msgs/JointTrajectory()\n\ttrajectory_msg.joint_names = joints.name\n\ttrajectory_msg.points.push(trajectory_msgs/JointTrajectoryPoint())\n\ttrajectory_msg.points[0].positions = joints.position\n\ttrajectory_msg.points[0].time_from_start = rospy.Duration(0.5)\n\tself.pub_traj.publish(trajectory_msg)\n}", "CodeBleu_score": 38.33288698155703}, {"code": "def joints_cmd_callback(self, joints){\n\t\t// create a minimal joints message\n\tvar joints_msg = new std_msgs.msg.Float64MultiArray()\n\t// set the joint positions\n\tjoints_msg.data = joints\n\t// publish the joints message\n\tself.joints_pub.publish(joints_msg)\n\n\t// create a joint trajectory message\n\tvar traj_msg = new trajectory_msgs.msg.JointTrajectory()\n\t// set the joint positions\n\ttraj_msg.joint_names = joints_msg.joint_names\n\ttraj_msg.points = [new trajectory_msgs.msg.JointTrajectoryPoint()]\n\ttraj_msg.points[0].positions = joints_msg.data\n\t// set the duration\n\ttraj_msg.points[0].time_from_start = new ROSLIB.Time(0.1)\n\t// publish the trajectory message\n\tself.traj_pub.publish(traj_msg)\n}", "CodeBleu_score": 35.998391857448745}, {"code": "def joints_cmd_callback(self, joints){\n\t\t// Create a minimal joints message\n\tvar joints_msg = new std_msgs.msg.Float64MultiArray()\n\tjoints_msg.data = joints.position.slice(0, 12)\n\n\t// Publish the joints message\n\tself.joints_pub.publish(joints_msg)\n\n\t// Construct a joint trajectory message\n\tvar trajectory_msg = new trajectory_msgs.msg.JointTrajectory()\n\ttrajectory_msg.joint_names = joints.name\n\ttrajectory_msg.points.push(new trajectory_msgs.msg.JointTrajectoryPoint())\n\ttrajectory_msg.points[0].positions = joints.position\n\ttrajectory_msg.points[0].velocities = joints.velocity\n\ttrajectory_msg.points[0].accelerations = joints.acceleration\n\ttrajectory_msg.points[0].time_from_start = new ROSLIB.Time(0.5)\n\n\t// Publish the joint trajectory message\n\tself.trajectory_pub.publish(trajectory_msg)\n}", "CodeBleu_score": 34.75419142929467}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize foot contact states to false\n\tfootContactStateLeft_ = false;\n\tfootContactStateRight_ = false;\n\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size; i++) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::vector<std::string> split;\n\t\tboost::split(split, _msg->contact(i).collision1, boost::is_any_of(\"/\"));\n\n\t\t// If a contact matches one of the foot links\n\t\tif (split[split.size() - 1] == \"left_foot\" || split[split.size() - 1] == \"right_foot\") {\n\t\t\t// Set the corresponding foot contact state to true\n\t\t\tif (split[split.size() - 1] == \"left_foot\")\n\t\t\t\tfootContactStateLeft_ = true;\n\t\t\telse\n\t\t\t\tfootContactStateRight_ = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.45269415774524}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize foot contact states to false\n\tfootContactState[LEFT_FOOT] = false;\n\tfootContactState[RIGHT_FOOT] = false;\n\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::vector<std::string> collision;\n\t\tboost::split(collision, _msg->contact(i).collision1, boost::is_any_of(\"/\"));\n\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tif (collision[0].compare(footLinkName[LEFT_FOOT]) == 0)\n\t\t\tfootContactState[LEFT_FOOT] = true;\n\t\telse if (collision[0].compare(footLinkName[RIGHT_FOOT]) == 0)\n\t\t\tfootContactState[RIGHT_FOOT] = true;\n\t}\n}", "CodeBleu_score": 47.70560118321641}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize foot contact states to false\n\tleft_foot_contact_ = false;\n\tright_foot_contact_ = false;\n\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); ++i) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::vector<std::string> collision_string_split;\n\t\tboost::split(collision_string_split, _msg->contact(i).collision1, boost::is_any_of(\"/\"));\n\t\tstd::string collision_string_split_last = collision_string_split.back();\n\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tif (collision_string_split_last == \"left_foot\") {\n\t\t\tleft_foot_contact_ = true;\n\t\t} else if (collision_string_split_last == \"right_foot\") {\n\t\t\tright_foot_contact_ = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.925646793609836}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tEigen::Vector3d angular_acceleration_thrust = Eigen::Vector3d::Zero();\n\n// Check if the controller is active.\nif (!controller_active_) {\nrotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\nrotor_velocities->setZero();\nreturn;\n}\n\n// Compute desired acceleration and angular acceleration.\nEigen::Vector3d desired_acceleration = ComputeDesiredAcceleration();\nEigen::Vector3d desired_angular_acceleration = ComputeDesiredAngularAcc();\n\n// Combine angular acceleration and thrust into a single vector.\nangular_acceleration_thrust = desired_acceleration +\nodometry_.orientation.toRotationMatrix().col(2) *\ndesired_angular_acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n// Project thrust onto the body z-axis.\nangular_acceleration_thrust(2) = angular_acceleration_thrust(2) *\nodometry_.orientation.toRotationMatrix().col(2).dot(vehicle_parameters_.gravity_vector_);\n\n// Compute rotor velocities.\nrotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\nfor (int i = 0; i < vehicle_parameters_.rotor_configuration_.rotors.size(); i++) {\nrotor_velocities->coeffRef(i) =\nstd::max(0.0, angular_acceleration_thrust.dot(vehicle_parameters_.rotor_configuration_.rotors[i].thrust_direction)) *\nstd::sqrt(vehicle_parameters_.rotor_configuration_.rotors[i].thrust_direction.dot(vehicle_parameters_.rotor_configuration_.rotors[i].thrust_direction));\n}\n}", "CodeBleu_score": 42.99834506680015}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities->rows() == vehicle_parameters_.rotor_configuration_.rotors.size());\nif (!is_active_) {\nrotor_velocities->setZero();\nreturn;\n}\nEigen::Vector3d acceleration = ComputeDesiredAcceleration();\nEigen::Vector3d angular_acceleration = ComputeDesiredAngularAcc();\nEigen::Vector3d thrust = Eigen::Vector3d::UnitZ() * acceleration.dot(Eigen::Vector3d::UnitZ());\nEigen::VectorXd angular_thrust = angular_acceleration.cross(odometry_.position);\nEigen::VectorXd combined_acceleration = thrust + angular_thrust;\nEigen::VectorXd combined_acceleration_norm = combined_acceleration.cwiseSqrt();\nEigen::VectorXd combined_acceleration_norm_max = combined_acceleration_norm.cwiseMax(Eigen::VectorXd::Zero(combined_acceleration_norm.rows()));\n*rotor_velocities = combined_acceleration_norm_max.array() * vehicle_parameters_.rotor_configuration_.rotors.array();\n}", "CodeBleu_score": 43.855495623385956}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tif (!controller_active_) {\n\t\trotor_velocities->setZero(vehicle_parameters_.rotor_configuration_.rotors.size());\n\t\treturn;\n\t}\n\tassert(rotor_velocities->rows() == vehicle_parameters_.rotor_configuration_.rotors.size());\n\tassert(rotor_velocities->rows() == vehicle_parameters_.rotor_configuration_.rotors.size());\n\tEigen::Vector3d desired_acceleration = ComputeDesiredAcceleration();\n\tEigen::Vector3d desired_angular_acceleration = ComputeDesiredAngularAcc();\n\tEigen::Vector3d angular_acceleration_thrust = desired_angular_acceleration + desired_acceleration;\n\tangular_acceleration_thrust = angular_acceleration_thrust.cwiseProduct(vehicle_parameters_.rotor_configuration_.rotors.col(2));\n\tangular_acceleration_thrust = angular_acceleration_thrust.cwiseSqrt();\n\tangular_acceleration_thrust = angular_acceleration_thrust.cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n\t*rotor_velocities = rotor_velocities_matrix_ * angular_acceleration_thrust;\n}", "CodeBleu_score": 47.57415555626287}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position and velocity errors\n\tEigen::Vector3d position_error = position_command_ - odometry_.position;\n\tEigen::Vector3d velocity_error = velocity_command_ - odometry_.velocity;\n\n\t// Transform the vehicle's velocity to the world frame\n\tEigen::Vector3d velocity_error_world = odometry_.orientation.toRotationMatrix() * velocity_error;\n\n\t// Compute the desired acceleration\n\t*acceleration = (k_p_position_ * position_error) + (k_p_velocity_ * velocity_error_world) + (k_d_velocity_ * velocity_error) - (mass_ * gravity_) + acceleration_command_;\n}", "CodeBleu_score": 35.14787624795518}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d position_error = position_error_;\n\tEigen::Vector3d velocity_error = velocity_error_;\n\tEigen::Vector3d desired_acceleration = desired_acceleration_;\n\n\t// Compute the desired acceleration by incorporating position and velocity gains, adjusting for vehicle mass, gravity, and the commanded acceleration.\n\tdesired_acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error + (mass_ * gravity_ + acceleration_command_) / mass_;\n\n\t// Transform the desired acceleration from the world frame to the vehicle frame.\n\t*acceleration = odometry_.orientation.toRotationMatrix().transpose() * desired_acceleration;\n}", "CodeBleu_score": 31.344068166665817}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d position_error = position_error_;\n\tEigen::Vector3d velocity_error = velocity_error_;\n\tEigen::Vector3d desired_acceleration = Eigen::Vector3d::Zero();\n\n\t// Transform velocity to world frame\n\tEigen::Vector3d velocity_world = odometry_.velocity.cwiseProduct(odometry_.orientation.toRotationMatrix());\n\n\t// Calculate desired acceleration\n\tdesired_acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error + gravity_ + mass_ * command_acceleration_;\n\n\t// Add acceleration due to gravity\n\tdesired_acceleration += gravity_;\n\n\t// Add acceleration due to mass\n\tdesired_acceleration += mass_ * command_acceleration_;\n\n\t// Add acceleration due to velocity\n\tdesired_acceleration += velocity_gain_ * velocity_world;\n\n\t// Add acceleration due to position\n\tdesired_acceleration += position_gain_ * position_error;\n\n\t// Add acceleration due to mass\n\tdesired_acceleration += mass_ * command_acceleration_;\n\n\t// Add acceleration due to velocity\n\tdesired_acceleration += velocity_gain_ * velocity_world;\n\n\t// Add acceleration due to position\n\tdesired_acceleration += position_gain_ * position_error;\n\n\t// Add acceleration due to mass\n\tdesired_acceleration += mass_ * command_acceleration_;\n\n\t// Add acceleration due to velocity\n\tdesired_acceleration += velocity_gain_ * velocity_world;\n\n\t// Add acceleration due to position\n\tdesired_acceleration += position_gain_ * position_error;\n\n\t// Add acceleration due to mass\n\tdesired_acceleration += mass_ * command_acceleration_;\n\n\t// Add acceleration due to velocity\n\tdesired_acceleration += velocity_gain_ * velocity_world;\n\n\t// Add acceleration due to position\n\tdesired_acceleration += position_gain_ * position_error;\n\n\t// Add acceleration due to mass\n\tdesired_acceleration += mass_ * command_acceleration_;\n\n\t// Add acceleration due to velocity\n\tdesired_acceleration += velocity_gain_ * velocity_world;\n\n\t// Add acceleration due to position\n\tdesired_acceleration += position_gain_ * position_error;\n\n\t// Add acceleration due to mass\n\tdesired_acceleration += mass_ * command_acceleration_;\n\n\t// Add acceleration due to velocity\n\tdesired_acceleration += velocity", "CodeBleu_score": 42.99850650283603}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t/*\n * This function, AttitudeControllerSamy::CalculateRotorVelocities, computes the rotor velocities for a vehicle.", "CodeBleu_score": 7.030501333705927}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\t// Ensure the input and parameters are valid\n\tassert(rotor_velocities!= nullptr);\n\tassert(rotor_velocities->rows() == rotor_count_);\n\tassert(control_attitude_thrust_reference_.rows() == 3);\n\tassert(control_attitude_thrust_reference_.cols() == 1);\n\n\t// Resize the rotor velocities vector to match the number of rotors\n\trotor_velocities->resize(rotor_count_);\n\n\t// Calculate the desired angular acceleration\n\tEigen::Vector3d angular_acceleration_thrust = control_attitude_thrust_reference_ - (control_attitude_thrust_reference_.cwiseProduct(rotor_velocities->cwiseSqrt()));\n\n\t// Combine the desired angular acceleration and thrust reference into a single vector\n\tEigen::VectorXd angular_acceleration_thrust_rotor_velocities = Eigen::VectorXd::Ones(rotor_count_ + 3);\n\tangular_acceleration_thrust_rotor_velocities.block<3, 1>(0, 0) = angular_acceleration_thrust;\n\tangular_acceleration_thrust_rotor_velocities.block<3, 1>(3, 0) = control_attitude_thrust_reference_;\n\n\t// Compute the rotor velocities\n\t*rotor_velocities = rotor_velocities_matrix_ * angular_acceleration_thrust_rotor_velocities;\n\n\t// Ensure the rotor velocities are at least one and take the square root of each component\n\trotor_velocities->cwiseMax(1.0);\n\trotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 55.41248261343385}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities!= nullptr);\n\n\t// Ensure the input is valid\n\tassert(rotor_velocities->rows() == rotor_count_);\n\tassert(rotor_velocities->cols() == 1);\n\n\t// Ensure the parameters are valid\n\tassert(rotor_velocities_max_!= nullptr);\n\tassert(rotor_velocities_max_->rows() == rotor_count_);\n\tassert(rotor_velocities_max_->cols() == 1);\n\tassert(rotor_velocities_min_!= nullptr);\n\tassert(rotor_velocities_min_->rows() == rotor_count_);\n\tassert(rotor_velocities_min_->cols() == 1);\n\n\t// Resize the rotor velocities vector\n\trotor_velocities->resize(rotor_count_, 1);\n\n\t// Calculate the desired angular acceleration\n\tEigen::VectorXd angular_acceleration_thrust =\n\t\tcontrol_attitude_thrust_reference_->angular_acceleration_thrust();\n\n\t// Ensure the angular acceleration and thrust reference are valid\n\tassert(angular_acceleration_thrust.rows() == rotor_count_);\n\tassert(angular_acceleration_thrust.cols() == 1);\n\n\t// Combine the desired angular acceleration and thrust reference into a single vector\n\tEigen::VectorXd combined_angular_acceleration_thrust =\n\t\tangular_acceleration_thrust.cwiseProduct(rotor_velocities_max_->cwiseSqrt());\n\n\t// Ensure the combined angular acceleration and thrust reference is valid\n\tassert(combined_angular_acceleration_thrust.rows() == rotor_count_);\n\tassert(combined_angular_acceleration_thrust.cols() == 1);\n\n\t// Compute the rotor velocities\n\t*rotor_velocities = combined_angular_acceleration_thrust.cwiseMax(*rotor_velocities_min_);\n}", "CodeBleu_score": 42.17269532251473}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    copied_obj = copy.deepcopy(self)\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    for attr in dir(copied_obj):\n        if attr.startswith('_'):\n            continue\n        if attr == 'time_array':\n            copied_obj.__setattr__(attr, copied_obj.time_array[start_index:end_index])\n        else:\n            copied_obj.__setattr__(attr, copied_obj.__getattribute__(attr)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 47.90366935786125}, {"code": "def slice(self, start_time, end_time)\n\t\n    if start_time < self.start_time or end_time > self.end_time:\n        raise Exception(\"Start time and end time must be within the object's start time and end time\")\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in copied_obj.__dict__.keys():\n        if attr in self.attributes_with_time_data:\n            copied_obj.__dict__[attr] = copied_obj.__dict__[attr][start_index:end_index]\n    return copied_obj\n\n", "CodeBleu_score": 66.34868549104883}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Create a copy of the object\n    copied_obj = copy.deepcopy(self)\n\n    # Find the indices for the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n\n    # Slice the attributes of the copied object\n    for attribute in copied_obj.__dict__:\n        if attribute == 'time':\n            copied_obj.__setattr__(attribute, copied_obj.__getattribute__(attribute)[start_index:end_index])\n        else:\n            copied_obj.__setattr__(attribute, copied_obj.__getattribute__(attribute)[start_index:end_index, :])\n\n    return copied_obj\n\n", "CodeBleu_score": 49.69827171136314}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    euler = euler_from_quaternion([quaternion.x, quaternion.y, quaternion.z, quaternion.w])\n    # Create Point object\n    point = Point(position.x, position.y, euler[2])\n    # Check if the current waypoint is different from the last one\n    if self.last_point == None:\n        # If the last point is None, then it is the first waypoint\n        self.last_point = point\n        self.last_yaw = point.yaw\n        self.last_time = msg_time\n        self.append_point(point)\n        self.append_yaw(point.yaw)\n        self.append_times(msg_time, bag_time)\n    else:\n        # If the last point is not None, then it is not the first waypoint\n        if self.last_point.position!= point.position or self.last_yaw!= point.yaw:\n            # If the current waypoint is different from the last one, then append it\n            self.last_point = point\n            self.last_yaw = point.yaw\n            self.last_time = msg_time\n            self.append_point(point)\n            self.append_yaw(point.yaw)\n            self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 30.304487648544658}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation\n    position = waypoint_msg.pose.position\n    orientation = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n    yaw = euler[2]\n    # Create Point object\n    point = Point(position.x, position.y, yaw)\n    # Check if waypoint is different from previous one\n    if self.last_point is None:\n        # If first waypoint, append it\n        self.append_point(point)\n        self.append_times(msg_time, bag_time)\n    else:\n        # If waypoint is different, append it\n        if self.last_point.x!= point.x or self.last_point.y!= point.y or self.last_point.yaw!= point.yaw:\n            self.append_point(point)\n            self.append_times(msg_time, bag_time)\n    # Update last_point\n    self.last_point = point\n\n", "CodeBleu_score": 27.550231274710494}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation\n    position = waypoint_msg.pose.position\n    orientation = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    euler = euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])\n    yaw = euler[2]\n    # Create Point object\n    point = Point(position.x, position.y, yaw)\n    # Check if waypoint is different from last one\n    if self.last_point is None:\n        # If last point is None, set current point as last point\n        self.last_point = point\n        # Append new point and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_times(msg_time, bag_time)\n    else:\n        # If last point is not None, check if current point is different from last point\n        if self.last_point.x!= point.x or self.last_point.y!= point.y or self.last_point.yaw!= yaw:\n            # If current point is different from last point, append new point and corresponding times to their respective arrays\n            self.append_point(point)\n            self.append_times(msg_time, bag_time)\n            # Set current point as last point\n            self.last_point = point\n\n", "CodeBleu_score": 27.304099186627624}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.time.append(to_sec(msg.header.stamp, bag_time))\n        self.bag_time.append(bag_time)\n    return\n\n", "CodeBleu_score": 30.350062087161756}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic:\n        self.imu_time.append(to_sec(msg.header.stamp))\n        self.imu_bag_time.append(to_sec(bag_time))\n        self.imu_acc_x.append(msg.linear_acceleration.x)\n        self.imu_acc_y.append(msg.linear_acceleration.y)\n        self.imu_acc_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 30.447378842200816}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    self.append_times(msg, bag_time)\n    if topic == \"/imu/data\":\n        self.append(msg.linear_acceleration.x)\n        self.append(msg.linear_acceleration.y)\n        self.append(msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw\":\n        self.append(msg.linear_acceleration_x)\n        self.append(msg.linear_acceleration_y)\n        self.append(msg.linear_acceleration_z)\n    elif topic == \"/imu/mag\":\n        self.append(msg.magnetic_field.x)\n        self.append(msg.magnetic_field.y)\n        self.append(msg.magnetic_field.z)\n    elif topic == \"/imu/mag_raw\":\n        self.append(msg.magnetic_field_x)\n        self.append(msg.magnetic_field_y)\n        self.append(msg.magnetic_field_z)\n    elif topic == \"/imu/orientation\":\n        self.append(msg.orientation.x)\n        self.append(msg.orientation.y)\n        self.append(msg.orientation.z)\n        self.append(msg.orientation.w)\n    elif topic == \"/imu/orientation_raw\":\n        self.append(msg.orientation_x)\n        self.append(msg.orientation_y)\n        self.append(msg.orientation_z)\n        self.append(msg.orientation_w)\n    elif topic == \"/imu/angular_velocity\":\n        self.append(msg.angular_velocity.x)\n        self.append(msg.angular_velocity.y)\n        self.append(msg.angular_velocity.z)\n    elif topic == \"/imu/angular_velocity_raw\":\n        self.append(msg.angular_velocity_x)\n        self.append(msg.angular_velocity_y)\n        self.append(msg.angular_velocity_z)\n    elif topic == \"/imu/linear_acceleration\":\n        self.append(msg.linear_acceleration.x)\n        self.append(msg.linear_acceleration.y)\n        self.append(msg.linear_acceleration.z)\n    elif topic == \"/imu/linear_acceleration_raw\":\n        self.append(msg.linear_acceleration_x)\n        self.append(msg.linear_acceleration_", "CodeBleu_score": 21.415358851609202}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title and a subplot for accelerations\n    fig = pyplot.figure(figsize=(10, 6))\n    fig.suptitle('Accelerations')\n    ax = fig.add_subplot(111)\n    # For each acceleration dataset, plot the x, y, and z components over time with different colors and labels\n    for i, acceleration in enumerate(self.accelerations):\n        x = acceleration.x\n        y = acceleration.y\n        z = acceleration.z\n        ax.plot(x, label='x')\n        ax.plot(y, label='y')\n        ax.plot(z, label='z')\n    # Add labels for the x and y axes and include a legend\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    ax.legend()\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        filename = 'accelerations' + plot_suffix + '.png'\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 39.471848011686276}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure(figsize=(10, 6))\n    fig.suptitle(\"Accelerations\")\n    ax = fig.add_subplot(111)\n    for i, accel in enumerate(self.accelerations):\n        ax.plot(accel.time, accel.x, label=\"x\")\n        ax.plot(accel.time, accel.y, label=\"y\")\n        ax.plot(accel.time, accel.z, label=\"z\")\n    pyplot.ylabel(\"Acceleration (m/s^2)\")\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.legend()\n    if plot_suffix is None:\n        plot_suffix = \"\"\n    filename = \"accelerations\" + plot_suffix + \".png\"\n    if self.save_plots:\n        pyplot.savefig(filename)\n    pyplot.show()\n    pyplot.close(fig)\n\n", "CodeBleu_score": 44.83467475174818}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    ax = fig.add_subplot(111)\n    for i, accel in enumerate(self.accels):\n        ax.plot(accel.time, accel.x, label=\"x \" + accel.name)\n        ax.plot(accel.time, accel.y, label=\"y \" + accel.name)\n        ax.plot(accel.time, accel.z, label=\"z \" + accel.name)\n    pyplot.ylabel(\"Acceleration (m/s^2)\")\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.legend()\n    if self.save_plots:\n        filename = self.plot_prefix + \"accelerations\"\n        if plot_suffix:\n            filename += \"_\" + plot_suffix\n        pyplot.savefig(filename + \".png\")\n    pyplot.show()\n\n", "CodeBleu_score": 43.51613508779178}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print \"Error: Not enough poses to compare!\"\n        return\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 35.72130138306374}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    #print \"compare_positions\"\n    #print \"pose_indeces: \", pose_indeces\n    #print \"len(pose_indeces): \", len(pose_indeces)\n    if len(pose_indeces) < 2:\n        print \"ERROR: compare_positions: At least two pose indices are required to perform comparisons.\"\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 40.35431179936072}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print \"Error: Must have at least two poses to compare.\"\n        return\n    else:\n        for i in range(len(pose_indeces)):\n            for j in range(i + 1, len(pose_indeces)):\n                self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 27.955560891223524}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 37.93512643360498}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 37.93512643360498}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision_time in self.wrench:\n        if start_time <= collision_time <= end_time:\n            collision_times.append(collision_time)\n    return collision_times\n\n", "CodeBleu_score": 35.17111062920968}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 29.32422071502378}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 27.764541802743594}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    abs_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, abs_settling_time,\n                                        x_range, plot_suffix,\n                                        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 35.047294679396614}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == NULL) {\nreturn;\n}\n\n// Create the Eigen vector.\nEigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n// Compute the RMS noise.\nfloat rms_noise = ComputeRMSNoise(width, height, data);\n\n// Compute the noise values.\nstd::vector<float> noise_values = ComputeNoiseValues(width, height, rms_noise);\n\n// Apply the noise.\nApplyNoise(width, height, data_vector_map, noise_values);\n}", "CodeBleu_score": 28.02070855053972}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\nreturn;\n}\n\nEigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\nconst float rms_noise =\nstd::sqrt(std::min(data_vector_map * 1000.0).array().square().mean());\nconst float noise =\nstd::sqrt(std::max(rms_noise * rms_noise - noise_variance, 0.0f));\n\nfor (uint32_t y = 0; y < height; ++y) {\nfor (uint32_t x = 0; x < width; ++x) {\nconst uint32_t index = y * width + x;\nif (InRange(data_vector_map(index), noise)) {\ndata_vector_map(index) += noise *\nstd::min(std::max(data_vector_map(index), 0.0f), 1.0f);\n} else {\ndata_vector_map(index) = bad_point_value;\n}\n}\n}\n}", "CodeBleu_score": 48.18624413830076}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\nreturn;\n}\n\nEigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\nfloat multiplier = 1.0;\nif (this->dist) {\nmultiplier = 1.0 / (tanf(this->dist * 0.017453292519943295769236907684886) * 2.0);\n}\n\nfloat rms_noise = this->noise * multiplier;\n\nfloat noise_value = 0.0;\nfor (uint32_t i = 0; i < width * height; i++) {\nif (data_vector_map(i) >= this->min_depth &&\ndata_vector_map(i) <= this->max_depth) {\nnoise_value = (float)rand() / (float)RAND_MAX * rms_noise;\ndata_vector_map(i) += noise_value;\n} else {\ndata_vector_map(i) = this->bad_point_value;\n}\n}\n}", "CodeBleu_score": 49.085089731026535}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t//  ROS_INFO(\"WaypointCallback\");\n  // Get the current simulation time\n  gazebo::common::Time current_time = world_->SimTime();\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = ros::Time(current_time.sec, current_time.nsec);\n  // Write the trajectory message to the bag file\n  writeBag(trajectory_msg, ros_time, waypoint_topic_);\n}", "CodeBleu_score": 59.59093476802898}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t//  std::cout << \"WaypointCallback\" << std::endl;\n  // Get the current simulation time.\n  gazebo::common::Time sim_time = world_->SimTime();\n  // Convert the simulation time to ROS time.\n  ros::Time ros_time = ros::Time(sim_time.sec, sim_time.nsec);\n\n  // Write the trajectory message to the bag file.\n  writeBag(ros_time, trajectory_msg);\n}", "CodeBleu_score": 59.565857462030856}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t/*\n * This function, GazeboBagPlugin::WaypointCallback, handles waypoint messages for a trajectory.\nIt retrieves the current simulation time and converts it to ROS time.\nThen, it writes the trajectory message to a bag file using the specified namespace and waypoint topic.\n */\n  ROS_INFO(\"Received trajectory message\");\n\n  // Get current simulation time\n  gazebo::common::Time current_time = this->world_->SimTime();\n\n  // Convert simulation time to ROS time\n  ros::Time ros_time = ros::Time(current_time.sec, current_time.nsec);\n\n  // Write trajectory message to bag file\n  this->writeBag(ros_time, trajectory_msg, this->waypoint_topic_);\n}", "CodeBleu_score": 53.34921835590213}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tros::Time now_ros = ros::Time(now.sec, now.nsec);\nrot_velocities_msg.header.stamp = now_ros;\nfor (auto m : motor_joints_) {\nm->second->GetVelocity(rot_velocities_msg.angular_velocities[m->first]);\n}\nrot_velocities_bag_.write(motor_topic_ + \"/rot_velocities\", now_ros, rot_velocities_msg);\n}", "CodeBleu_score": 31.700749881283258}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert simulation time to ROS time\n\tros::Time ros_time = common::Time(now.sec, now.nsec);\n\n\t// Prepare message for actuator velocities\n\tsensor_msgs::JointState rot_velocities_msg;\n\trot_velocities_msg.header.stamp = ros_time;\n\trot_velocities_msg.header.frame_id = \"world\";\n\trot_velocities_msg.name.resize(motor_joints_.size());\n\trot_velocities_msg.velocity.resize(motor_joints_.size());\n\n\t// Iterate through motor joints, calculate slowed-down rotational velocities, and assign them to the message\n\tfor (std::map<std::string, boost::shared_ptr<physics::Joint> >::iterator m = motor_joints_.begin(); m!= motor_joints_.end(); ++m) {\n\t\t// Calculate slowed-down rotational velocities\n\t\tdouble rot_velocity = m->second->GetVelocity(0);\n\t\trot_velocities_msg.name[m->second->GetIndex()] = m->first;\n\t\trot_velocities_msg.velocity[m->second->GetIndex()] = rot_velocity / motor_slowdown_factor_;\n\t}\n\n\t// Write message to bag file\n\tif (bag_.isOpen()) {\n\t\tbag_.write(motor_topic_, ros_time, rot_velocities_msg);\n\t}\n}", "CodeBleu_score": 56.869671916401096}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\n/*\n * The function converts the simulation time to ROS time and prepares a message for actuator velocities.\n */", "CodeBleu_score": 3.6173457063108136}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINTING\n  if (debug_printing_enabled_) {\n    gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called\n\";\n  }\n#endif\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons,\n  // elevator, and rudder respectively.\n  roll_pitch_yawrate_thrust_msg->roll().x =\n      NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->roll().x);\n  roll_pitch_yawrate_thrust_msg->pitch().x =\n      NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->pitch().x);\n  roll_pitch_yawrate_thrust_msg->yaw_rate().x =\n      NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate().x);\n\n  // Set the throttle value from the thrust message.\n  SetThrottle(roll_pitch_yawrate_thrust_msg->thrust().x);\n}", "CodeBleu_score": 44.00322705548532}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT_ENABLED\n  gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\n\";\n#endif\n  // Convert the normalized input values to control surface angles.\n  double roll_angle = NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  double pitch_angle = NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->pitch());\n  double yaw_rate = NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate());\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust().x;\n\n  // Set the control surface angles.\n  SetControlSurfaceAngle(aileron_left_id_, roll_angle);\n  SetControlSurfaceAngle(aileron_right_id_, roll_angle);\n  SetControlSurfaceAngle(elevator_left_id_, pitch_angle);\n  SetControlSurfaceAngle(elevator_right_id_, pitch_angle);\n  SetControlSurfaceAngle(rudder_id_, yaw_rate);\n\n  // Set the throttle.\n  SetThrottle(throttle);\n}", "CodeBleu_score": 45.6615189513675}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT_CALLBACKS\n  gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\n\";\n#endif\n  // Convert normalized input values to control surface angles.\n  double aileron_angle =\n      normalized_input_to_angle_ * roll_pitch_yawrate_thrust_msg->roll();\n  double elevator_angle =\n      normalized_input_to_angle_ * roll_pitch_yawrate_thrust_msg->pitch();\n  double rudder_angle =\n      normalized_input_to_angle_ * roll_pitch_yawrate_thrust_msg->yaw_rate();\n  // Set the throttle value from the thrust message.\n  double throttle_value = roll_pitch_yawrate_thrust_msg->thrust().x;\n\n  // Set the control surface angles.\n  SetControlSurfaceAngles(aileron_angle, elevator_angle, rudder_angle,\n                          throttle_value);\n}", "CodeBleu_score": 44.59599546301307}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t\t// if (this->mavlink_fd == -1) {\n\t// \treturn;\n\t// }\n\n\t// int ret = poll(this->mavlink_fds, 1, _timeoutMs);\n\n\t// if (ret > 0) {\n\t// \tif (this->mavlink_fds[0].revents & POLLIN) {\n\t// \t\tuint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n\t// \t\tint len = recvfrom(this->mavlink_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0, NULL, NULL);\n\t// \t\tif (len > 0) {\n\t// \t\t\tmavlink_message_t msg;\n\t// \t\t\tmavlink_status_t status;\n\t// \t\t\tint msg_received = 0;\n\n\t// \t\t\t// parse the message\n\t// \t\t\tfor (int i = 0; i < len; i++) {\n\t// \t\t\t\tif (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n\t// \t\t\t\t\tmsg_received = 1;\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\n\t// \t\t\t// handle the message\n\t// \t\t\tif (msg_received) {\n\t// \t\t\t\thandle_message(msg);\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n}", "CodeBleu_score": 1.4726803394282788}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t//  if (this->mavlink_fd == -1) {\n//    gzerr << \"Mavlink connection not initialized.\n\";\n//    return;\n//  }\n\n  // Convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for data\n  int nfds = 1;\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(this->mavlink_fd, &fds);\n  int ret = select(nfds, &fds, NULL, NULL, &timeout);\n\n  // Check if data is available\n  if (ret == 0) {\n    // Timeout\n    return;\n  } else if (ret < 0) {\n    // Error\n    gzerr << \"Error in select: \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  // Receive data\n  char buffer[MAVLINK_MAX_PACKET_LEN];\n  int len = recvfrom(this->mavlink_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0, NULL, NULL);\n  if (len < 0) {\n    gzerr << \"Error in recvfrom: \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  // Parse MAVLink messages\n  mavlink_message_t message;\n  mavlink_status_t status;\n  for (int i = 0; i < len; i++) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &message, &status)) {\n      // Forward message to serial connection\n      if (this->serial_fd!= -1) {\n        send_mavlink_message(this->serial_fd, &message);\n      }\n\n      // Handle message\n      handle_message(&message, _dt);\n    }\n  }\n}", "CodeBleu_score": 50.68947620690882}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 9\n  gzmsg << \"GazeboMavlinkInterface::pollForMAVLinkMessages: Not implemented for Gazebo 9 and above.\" << std::endl;\n#else\n  // Convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Perform poll operation\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(this->socket, &readfds);\n  int ret = select(this->socket + 1, &readfds, NULL, NULL, &timeout);\n  if (ret < 0) {\n    gzerr << \"GazeboMavlinkInterface::pollForMAVLinkMessages: Error while performing select.\" << std::endl;\n    return;\n  }\n\n  // Receive data\n  if (ret > 0) {\n    char buffer[this->bufferSize];\n    int bytesReceived = recv(this->socket, buffer, this->bufferSize, 0);\n    if (bytesReceived < 0) {\n      gzerr << \"GazeboMavlinkInterface::pollForMAVLinkMessages: Error while receiving data.\" << std::endl;\n      return;\n    }\n\n    // Parse MAVLink messages\n    for (int i = 0; i < bytesReceived; i++) {\n      this->mavlink_parse_char(0, buffer[i], &this->mavlink_message);\n      if (this->mavlink_message.msgid!= 0) {\n        // Forward message to serial connection\n        if (this->serialConnection!= NULL) {\n          this->serialConnection->write(buffer[i]);\n        }\n\n        // Handle message\n        this->handle_message(&this->mavlink_message);\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 47.05039871423348}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tif (is_open) {\n\t\tio_service_.stop\n\t\tserial_dev_.close\n\t\tio_thread_.joinable\n\t\tis_open\n\t}\n}", "CodeBleu_score": 39.0018555110183}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tif (is_open_) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 61.98310537141425}, {"code": "void GazeboMavlinkInterface::close() {\n\t\t// Lock the mutex\n\tboost::mutex::scoped_lock lock(mutex_);\n\n\t// Check if the interface is open\n\tif (is_open_) {\n\t\t// Stop the I/O service\n\t\tio_service_.stop();\n\n\t\t// Close the serial device\n\t\tserial_dev_.close();\n\n\t\t// Check if the I/O thread is joinable\n\t\tif (io_thread_.joinable()) {\n\t\t\t// Join the I/O thread to clean up resources\n\t\t\tio_thread_.join();\n\t\t}\n\n\t\t// Set the interface as closed\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 64.71719587066606}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tdouble x1, y1, z1, x2, y2, z2, x, y, z;\n\tdouble dx, dy, dz, d;\n\n\tx1 = wind_data->wind_vector.x;\n\ty1 = wind_data->wind_vector.y;\n\tz1 = wind_data->wind_vector.z;\n\tx2 = wind_data->wind_vector.x;\n\ty2 = wind_data->wind_vector.y;\n\tz2 = wind_data->wind_vector.z;\n\tx = wind_data->wind_vector.x;\n\ty = wind_data->wind_vector.y;\n\tz = wind_data->wind_vector.z;\n\tdx = x2 - x1;\n\tdy = y2 - y1;\n\tdz = z2 - z1;\n\td = sqrt(dx * dx + dy * dy + dz * dz);\n\tif (d == 0) {\n\t\treturn wind_data->wind_vector;\n\t}\n\tx = x1 + (x - x1) * (d / dx);\n\ty = y1 + (y - y1) * (d / dy);\n\tz = z1 + (z - z1) * (d / dz);\n\treturn ignition::math::Vector3d(x, y, z);\n}", "CodeBleu_score": 32.53958252329387}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tconst ignition::math::Vector3d& p1,\n\tconst ignition::math::Vector3d& p2,\n\tconst double& x,\n\tconst double& x1,\n\tconst double& x2\n}", "CodeBleu_score": 21.272841093961}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d p1, p2, p3;\n\tp1 = ignition::math::Vector3d(0, 0, 0);\n\tp2 = ignition::math::Vector3d(0, 0, 0);\n\tp3 = ignition::math::Vector3d(0, 0, 0);\n\n\tdouble t = 0.0;\n\tdouble x = 0.0;\n\tdouble y = 0.0;\n\tdouble z = 0.0;\n\n\tdouble t1 = 0.0;\n\tdouble t2 = 0.0;\n\tdouble t3 = 0.0;\n\n\tdouble x1 = 0.0;\n\tdouble x2 = 0.0;\n\tdouble x3 = 0.0;\n\n\tdouble y1 = 0.0;\n\tdouble y2 = 0.0;\n\tdouble y3 = 0.0;\n\n\tdouble z1 = 0.0;\n\tdouble z2 = 0.0;\n\tdouble z3 = 0.0;\n\n\tdouble a = 0.0;\n\tdouble b = 0.0;\n\tdouble c = 0.0;\n\tdouble d = 0.0;\n\n\tdouble x_i = 0.0;\n\tdouble y_i = 0.0;\n\tdouble z_i = 0.0;\n\n\tignition::math::Vector3d result;\n\tresult = ignition::math::Vector3d(0, 0, 0);\n\n\tt1 = p1.X();\n\tt2 = p2.X();\n\tt3 = p3.X();\n\n\tx1 = p1.Y();\n\tx2 = p2.Y();\n\tx3 = p3.Y();\n\n\ty1 = p1.Z();\n\ty2 = p2.Z();\n\ty3 = p3.Z();\n\n\tz1 = p1.W();\n\tz2 = p2.W();\n\tz3 = p3.W();\n\n\ta = (x2 - x1) / (t2 - t1);\n\tb = (x3 -", "CodeBleu_score": 32.45687698450873}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (m_looping) {\n\t\tm_time = fmod(_time, m_length);\n\t}\n\telse {\n\t\tm_time = std::clamp(_time, 0.0, m_length);\n\t}\n}", "CodeBleu_score": 28.953966200566374}, {"code": "void Animation::SetTime(double _time){\n\t\n}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.set_frame_id(1)\n    self.set_motion_type(0)\n    self.construct_target()\n    print\n    self.print_vehicle_type()\n    print\n    self.print_vehicle_id()\n    print\n    self.print_flight_mode()\n\n", "CodeBleu_score": 12.15418480917274}, {"code": "def hover(self)\n\t\n    self.set_frame(1)\n    self.set_motion_type(0)\n    self.construct_target()\n    print\n    self.print_vehicle_type\n    print\n    self.print_vehicle_id\n    print\n    self.print_flight_mode\n\n", "CodeBleu_score": 11.89389292692065}, {"code": "def hover(self)\n\t\n    self.set_frame(1)\n    self.set_motion_type(0)\n    self.construct_target()\n    print\n    self.print_vehicle_type()\n    print\n    self.print_vehicle_id()\n    print\n    self.print_flight_mode()\n    print\n\n", "CodeBleu_score": 12.275833533730374}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hover = 1\n        self.hover()\n        print(\"Successfully switched to hover mode.\")\n        return True\n    else:\n        try:\n            self.flightModeService.set_mode(self.flightMode)\n            print(\"Successfully switched to \" + self.flightMode + \" mode.\")\n            return True\n        except:\n            print(\"Failed to switch to \" + self.flightMode + \" mode.\")\n            return False\n\n", "CodeBleu_score": 36.78363829352439}, {"code": "def flight_mode_switch(self)\n\t\n    # If the flight mode is 'HOVER', set the hover flag to 1 and call the hover method\n    if self.flightMode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        print('Successfully switched to HOVER mode')\n        return True\n    # Attempt to switch modes using flightModeService\n    else:\n        if self.flightModeService.change_mode(self.flightMode):\n            print('Successfully switched to %s mode' % self.flightMode)\n            return True\n        else:\n            print('Failed to switch to %s mode' % self.flightMode)\n            return False\n\n", "CodeBleu_score": 49.32992167220473}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService.get_flight_mode() == 'HOVER':\n        self.hover = 1\n        self.hover()\n        print 'Hover Mode'\n        return True\n    else:\n        self.hover = 0\n        try:\n            self.flightModeService.set_flight_mode(self.flightModeService.get_flight_mode())\n            print 'Flight Mode:'+ self.flightModeService.get_flight_mode()\n            return True\n        except:\n            print 'Failed to switch flight modes'\n            return False\n\n", "CodeBleu_score": 34.38349563343968}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n", "CodeBleu_score": 35.54321307011656}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag == False:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if self.hold_flag == False:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if self.hover_flag == False and self.hold_flag == False:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n", "CodeBleu_score": 53.70159740548289}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == False:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == False and self.hold_flag == False:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n\n", "CodeBleu_score": 40.00293877805353}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode('OFFBOARD')\n        self.hover_flag = 1\n        self.set_mode('HOVER')\n        self.hover_action()\n    else:\n        self.hover_flag = 0\n\n", "CodeBleu_score": 53.68060358235287}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.set_mode_offboard()\n    elif self.hover_flag == 1 and self.mode!= 'HOVER':\n        self.hover_flag = 0\n        self.set_mode_hover()\n        self.hover()\n\n", "CodeBleu_score": 53.74019434108468}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02) or (w > 0.005):\n        self.hover_flag = 0\n        self.set_mode('OFFBOARD')\n    elif self.mode!= 'HOVER' and self.hover_flag == 1:\n        self.hover_flag = 0\n        self.set_mode('HOVER')\n        self.hover_action()\n\n", "CodeBleu_score": 39.27997847619551}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw()\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        return q.yaw()\n\n", "CodeBleu_score": 35.8466419225069}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw()\n    else:\n        q = Quaternion(q)\n        return q.yaw()\n\n", "CodeBleu_score": 24.533049656991263}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.mode = \"HOVER\"\n    self.coordinate_frame = \"BODY_NED\"\n    self.motion_type = \"VELOCITY_BODY_NED\"\n    self.construct_target()\n    print\n    self.construct_target\n\n", "CodeBleu_score": 17.024245524111883}, {"code": "def hover(self)\n\t\n    # Update the coordinate frame and motion type\n    self.coordinate_frame = \"BODY\"\n    self.motion_type = \"hover\"\n\n    # Construct a target motion using the current position and yaw values\n    self.construct_target()\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"", "CodeBleu_score": 4.491056619371188}, {"code": "def hover(self)\n\t\n    self.update_coordinate_frame()\n    self.update_motion_type()\n    self.construct_target()\n    print(\"Vehicle type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight mode: hover\")\n\n", "CodeBleu_score": 13.896286585478613}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        print 'Hovering'\n        return True\n    else:\n        try:\n            self.flightModeService.set_mode(self.flightMode)\n            print 'Switched to'+ self.flightMode\n            return True\n        except:\n            print 'Failed to switch to'+ self.flightMode\n            return False\n\n", "CodeBleu_score": 35.40479625455993}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.set_mode(self.flightMode)\n            self.flightMode = self.flightModeService.get_mode()\n            print('Flight mode switched to:'+ self.flightMode)\n            return True\n        except:\n            print('Failed to switch flight mode to:'+ self.flightMode)\n            return False\n\n", "CodeBleu_score": 35.16897149699882}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flightModeService.change_mode(self.flightMode):\n            self.flightMode = self.flightModeService.flight_mode\n            print 'Flight Mode:'+ self.flightMode\n            return True\n        else:\n            print 'Failed to switch flight mode.'\n            return False\n\n", "CodeBleu_score": 36.37909359203025}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose.pose.position.x = msg.pose.position.x\n        self.local_pose.pose.position.y = msg.pose.position.y\n        self.local_pose.pose.position.z = msg.pose.position.z\n        self.local_pose.pose.orientation.x = msg.pose.orientation.x\n        self.local_pose.pose.orientation.y = msg.pose.orientation.y\n        self.local_pose.pose.orientation.z = msg.pose.orientation.z\n        self.local_pose.pose.orientation.w = msg.pose.orientation.w\n        self.local_pose.header.stamp = msg.header.stamp\n\n        # If the UAV is taking off, set the takeoff target pose to the current local pose\n        if self.takeoff:\n            self.takeoff_target_pose = self.local_pose\n\n        # If the UAV is hovering, set the hover target pose to the current local pose\n        if self.hover:\n            self.hover_target_pose = self.local_pose\n\n        # Update the global pose by applying the bias to the local pose\n        self.global_pose.pose.position.x = self.local_pose.pose.position.x + self.bias.x\n        self.global_pose.pose.position.y = self.local_pose.pose.position.y + self.bias.y\n        self.global_pose.pose.position.z = self.local_pose.pose.position.z + self.bias.z\n        self.global_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n        self.global_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n        self.global_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n        self.global_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n        self.global_pose.header.stamp = self.local_pose.header.stamp\n\n", "CodeBleu_score": 22.132551632735147}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    # print(\"local_pose_callback\")\n    if msg.header.seq == i:\n        self.local_pose = msg\n        if self.gcs_command == 1:\n            self.takeoff_target_pose = msg\n            self.takeoff_target_pose.position.x = self.takeoff_target_pose.position.x + self.bias_x\n            self.takeoff_target_pose.position.y = self.takeoff_target_pose.position.y + self.bias_y\n            self.takeoff_target_pose.position.z = self.takeoff_target_pose.position.z + self.bias_z\n        elif self.gcs_command == 2:\n            self.hover_target_pose = msg\n            self.hover_target_pose.position.x = self.hover_target_pose.position.x + self.bias_x\n            self.hover_target_pose.position.y = self.hover_target_pose.position.y + self.bias_y\n            self.hover_target_pose.position.z = self.hover_target_pose.position.z + self.bias_z\n        elif self.gcs_command == 3:\n            self.land_target_pose = msg\n            self.land_target_pose.position.x = self.land_target_pose.position.x + self.bias_x\n            self.land_target_pose.position.y = self.land_target_pose.position.y + self.bias_y\n            self.land_target_pose.position.z = self.land_target_pose.position.z + self.bias_z\n        elif self.gcs_command == 4:\n            self.takeoff_target_pose = msg\n            self.takeoff_target_pose.position.x = self.takeoff_target_pose.position.x + self.bias_x\n            self.takeoff_target_pose.position.y = self.takeoff_target_pose.position.y + self.bias_y\n            self.takeoff_target_pose.position.z = self.takeoff_target_pose.position.z + self.bias_z\n            self.hover_target_pose = msg\n            self.hover_target_pose.position.x", "CodeBleu_score": 16.24417114882616}, {"code": "def local_pose_callback(self, msg, i)\n\t\n\n    if i == self.uav_id:\n        self.local_pose = msg\n\n    if self.gcs_command == 1:\n        self.takeoff_target_pose.position.x = msg.position.x\n        self.takeoff_target_pose.position.y = msg.position.y\n        self.takeoff_target_pose.position.z = msg.position.z\n\n    if self.gcs_command == 2:\n        self.hover_target_pose.position.x = msg.position.x\n        self.hover_target_pose.position.y = msg.position.y\n        self.hover_target_pose.position.z = msg.position.z\n\n    self.global_pose.position.x = msg.position.x + self.bias_x\n    self.global_pose.position.y = msg.position.y + self.bias_y\n    self.global_pose.position.z = msg.position.z + self.bias_z\n\n", "CodeBleu_score": 22.945159102393674}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.862379601652705}, {"code": "def takeoff_detection(self)\n\t\n    if self.alt > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.6464041749083}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == 'active':\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.862379601652705}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Create a matrix of zeros\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    # Calculate the pairwise distances\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n    # Adjust the distances\n    dist_matrix = 50 - dist_matrix\n    # Convert the distances to integers\n    dist_matrix = dist_matrix.astype(int)\n    # Return the distance matrix\n    return dist_matrix\n\n", "CodeBleu_score": 27.0001779178207}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Create the distance matrix\n    distances = np.zeros((len(orig_formation), len(change_formation)))\n    # Calculate the pairwise distances between the UAVs\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            # Calculate the distance between the two UAVs\n            distance = np.linalg.norm(orig_formation[i] - change_formation[j])\n            # Adjust the distance by subtracting it from 50\n            distance = 50 - distance\n            # Convert the distance to an integer\n            distance = int(distance)\n            # Store the distance in the distance matrix\n            distances[i, j] = distance\n    return distances\n\n", "CodeBleu_score": 27.639890608202684}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Build the distance matrix for the original formation\n    self.orig_formation = orig_formation\n    self.orig_formation_norm = np.linalg.norm(self.orig_formation, axis=1)\n    self.orig_formation_range = np.max(self.orig_formation_norm)\n    self.orig_formation_norm = np.subtract(50, self.orig_formation_norm)\n    self.orig_formation_norm = np.round(self.orig_formation_norm)\n    self.orig_formation_norm = self.orig_formation_norm.astype(int)\n    self.orig_formation_norm = np.reshape(self.orig_formation_norm, (len(self.orig_formation_norm), 1))\n    self.orig_formation_norm = np.concatenate((self.orig_formation_norm, self.orig_formation_norm), axis=1)\n\n    # Build the distance matrix for the changed formation\n    self.change_formation = change_formation\n    self.change_formation_norm = np.linalg.norm(self.change_formation, axis=1)\n    self.change_formation_range = np.max(self.change_formation_norm)\n    self.change_formation_norm = np.subtract(50, self.change_formation_norm)\n    self.change_formation_norm = np.round(self.change_formation_norm)\n    self.change_formation_norm = self.change_formation_norm.astype(int)\n    self.change_formation_norm = np.reshape(self.change_formation_norm, (len(self.change_formation_norm), 1))\n    self.change_formation_norm = np.concatenate((self.change_formation_norm, self.change_formation_norm), axis=1)\n\n    # Build the distance matrix\n    self.formation_norm = np.subtract(self.change_formation_norm, self.orig_formation_norm)\n    self.formation_norm = np.abs(self.formation_norm)\n    self.formation_norm = np.reshape(self.formation_norm, (len(self.formation_norm), 1))\n    self.formation_norm = np.concatenate((self.formation_norm, self.formation_norm), axis=1)\n\n    # Return the distance matrix", "CodeBleu_score": 14.536841739707013}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visited[i] = True\n    for j in self.adj[i]:\n        if not self.visited[j]:\n            self.visited[j] = True\n            if self.match[j] == -1 or self.find_path(self.match[j]):\n                self.match[j] = i\n                return True\n    return False\n\n", "CodeBleu_score": 31.095751842266868}, {"code": "def find_path(self, i)\n\t\n    self.visited[i] = True\n    for j in self.graph[i]:\n        if not self.visited[self.right[j]]:\n            if self.match[self.right[j]] is None or self.find_path(self.match[self.right[j]]):\n                self.match[self.right[j]] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], self.labels[i] + self.labels[self.right[j]] - self.weights[i][j])\n    return False\n\n", "CodeBleu_score": 34.9553533910962}, {"code": "def find_path(self, i)\n\t\n    self.visited[i] = True\n    for j in self.graph[i]:\n        if not self.visited[j]:\n            self.visited[j] = True\n            if self.match[j] == -1 or self.find_path(self.match[j]):\n                self.match[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], self.label[i] + self.label[j] - self.weight[i][j])\n    return False\n\n", "CodeBleu_score": 41.61242052680561}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    self.slack = numpy.zeros((self.num_uavs, self.num_targets))\n    self.slack_row = numpy.zeros(self.num_uavs)\n    self.slack_col = numpy.zeros(self.num_targets)\n    self.visit_row = numpy.zeros(self.num_uavs, dtype=numpy.int)\n    self.visit_col = numpy.zeros(self.num_targets, dtype=numpy.int)\n    self.match = numpy.zeros((self.num_uavs, self.num_targets), dtype=numpy.int)\n    for uav in range(self.num_uavs):\n        self.find_path(uav)\n    while self.visit_row.sum() < self.num_uavs:\n        self.slack_min = self.slack.min()\n        for uav in range(self.num_uavs):\n            self.slack_row[uav] = self.slack_min\n        for target in range(self.num_targets):\n            self.slack_col[target] = self.slack_min\n        self.find_path(-1)\n    return self.match\n", "CodeBleu_score": 25.189591361477916}, {"code": "def KM(self)\n\t\n    # Initialize slack variables and visit arrays for each UAV\n    self.slack = np.zeros(self.n)\n    self.slack_path = np.zeros(self.n)\n    self.visit_left = np.zeros(self.n, dtype=np.bool)\n    self.visit_right = np.zeros(self.n, dtype=np.bool)\n    # Iterate over UAVs\n    for u in range(self.n):\n        # Reset visit arrays for each UAV\n        self.visit_left = np.zeros(self.n, dtype=np.bool)\n        self.visit_right = np.zeros(self.n, dtype=np.bool)\n        # Find path\n        if self.find_path(u):\n            # Return match results for the right side of the bipartite graph\n            return self.match_right", "CodeBleu_score": 18.37351925637302}, {"code": "def KM(self)\n\t\n    # Initialize slack variables and visit arrays\n    self.slack = np.zeros(len(self.UAVs))\n    self.slack_x = np.zeros(len(self.UAVs))\n    self.slack_y = np.zeros(len(self.UAVs))\n    self.visit_x = np.zeros(len(self.UAVs))\n    self.visit_y = np.zeros(len(self.UAVs))\n    self.match_x = np.zeros(len(self.UAVs))\n    self.match_y = np.zeros(len(self.UAVs))\n    # Iterate over UAVs\n    for i in range(len(self.UAVs)):\n        # Initialize visit arrays for each UAV\n        self.visit_x[i] = 0\n        self.visit_y[i] = 0\n        # Initialize slack variables for each UAV\n        self.slack_x[i] = float('inf')\n        self.slack_y[i] = float('inf')\n        # Find path\n        self.find_path(i)\n        # Adjust labels\n        self.label_adjust()\n    # Return match results\n    return self.match_x, self.match_y\n", "CodeBleu_score": 21.240059568616353}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 26.819339810455766}, {"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 26.819339810455766}, {"code": "def yellow_dectection(image)\n\t\n    # Convert BGR to HSV\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define lower and upper bounds for yellow color\n    lower = np.array([20, 100, 100])\n    upper = np.array([30, 255, 255])\n\n    # Create mask\n    mask = cv2.inRange(hsv, lower, upper)\n\n    # Apply mask to image\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n", "CodeBleu_score": 37.51478398450005}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n/*\n * This function, TagDetector::findTagDescription, searches for a tag description by ID.", "CodeBleu_score": 0.7921946237919061}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tif (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tROS_WARN_THROTTLE(1.0, \"Could not find standalone tag description for id %d.\", id);\n\t\t}\n\t\treturn false;\n\t}\n\tdescriptionContainer = standalone_tag_descriptions_[id];\n\treturn true;\n}", "CodeBleu_score": 32.60453201439525}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t// Check if the tag description is in the map\n\tif (standalone_tag_descriptions_.find(id)!= standalone_tag_descriptions_.end()) {\n\t\t// Set the description container\n\t\tdescriptionContainer = standalone_tag_descriptions_[id];\n\t\t// Return true\n\t\treturn true;\n\t}\n\t// If the tag description is not found and printWarning is true\n\tif (printWarning) {\n\t\t// Log a warning message\n\t\tROS_WARN_THROTTLE(10, \"Tag description for ID %d not found\", id);\n\t}\n\t// Return false\n\treturn false;\n}", "CodeBleu_score": 28.206654313525682}]}
