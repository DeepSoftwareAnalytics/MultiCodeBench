{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = NULL;\n\tuint8_t *ptr = (uint8_t *) desc;\n\tuint8_t *end = (uint8_t *) desc + desc->bLength;\n\n\twhile (ptr < end) {\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ptr;\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tptr += next_desc->bLength;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 42.92283645917273}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * next = NULL;\n\tuint8_t len = 0;\n\n\tif (desc == NULL) {\n\t\treturn NULL;\n\t}\n\n\tlen = desc->bLength;\n\twhile (len > 0) {\n\t\tnext = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc + len);\n\n\t\tif (next->bDescriptorType == desc_id) {\n\t\t\treturn next;\n\t\t}\n\n\t\tlen -= next->bLength;\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 40.39587325100304}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\tuint8_t desc_len;\n\n\tif (desc == NULL) {\n\t\treturn NULL;\n\t}\n\n\tdesc_len = desc->bLength;\n\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) (desc + desc_len);\n\n\twhile (next_desc->bLength!= 0) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\n\t\tdesc_len = next_desc->bLength;\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) (next_desc + desc_len);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 47.327148649231766}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\t// Check if a valid configuration exists\n\tif (!udc_get_config_desc()) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is within bounds\n\tif (iface_num >= udc_get_config_desc()->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the descriptors, starting from the beginning of the configuration descriptor\n\tuint8_t *desc_ptr = (uint8_t *) udc_get_config_desc() + 1;\n\twhile (desc_ptr < udc_get_config_desc()->desc_end) {\n\t\t// Check if the descriptor matches the specified interface number and setting number\n\t\tif (desc_ptr[0] == USB_DESC_INTERFACE && desc_ptr[1] == iface_num && desc_ptr[2] == setting_num) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Advance to the next descriptor\n\t\tdesc_ptr += desc_ptr[0] + 1;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 30.489794688862286}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\t// TODO: Implement this function\n\t//return false;\n\tuint8_t* desc_ptr;\n\tuint8_t* conf_ptr;\n\tuint8_t* iface_ptr;\n\tuint8_t* end_ptr;\n\tuint8_t* cur_ptr;\n\tuint8_t* cur_iface_ptr;\n\tuint8_t* cur_iface_end_ptr;\n\tuint8_t* cur_iface_alt_ptr;\n\tuint8_t* cur_iface_alt_end_ptr;\n\tuint8_t* cur_iface_alt_end_ptr2;\n\tuint8_t* cur_iface_alt_end_ptr3;\n\tuint8_t* cur_iface_alt_end_ptr4;\n\tuint8_t* cur_iface_alt_end_ptr5;\n\tuint8_t* cur_iface_alt_end_ptr6;\n\tuint8_t* cur_iface_alt_end_ptr7;\n\tuint8_t* cur_iface_alt_end_ptr8;\n\tuint8_t* cur_iface_alt_end_ptr9;\n\tuint8_t* cur_iface_alt_end_ptr10;\n\tuint8_t* cur_iface_alt_end_ptr11;\n\tuint8_t* cur_iface_alt_end_ptr12;\n\tuint8_t* cur_iface_alt_end_ptr13;\n\tuint8_t* cur_iface_alt_end_ptr14;\n\tuint8_t* cur_iface_alt_end_ptr15;\n\tuint8_t* cur_iface_alt_end_ptr16;\n\tuint8_t* cur_iface_alt_end_ptr17;\n\tuint8_t* cur_iface_alt_end_ptr18;\n\tuint8_t* cur_iface_alt_end_ptr19;\n\tuint8_t* cur_iface_alt_end_ptr20;\n\tuint8_t* cur_iface_alt_end_ptr21;\n\tuint8_t* cur_iface_alt", "CodeBleu_score": 7.707740139626663}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *p_desc;\n\tuint8_t *p_iface_desc;\n\tuint8_t *p_iface_alt;\n\tuint8_t *p_iface_setting;\n\tuint8_t *p_iface_setting_desc;\n\tuint8_t *p_iface_setting_desc_end;\n\tuint8_t *p_iface_setting_desc_end_alt;\n\tuint8_t *p_iface_setting_desc_end_alt_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end_end_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end_end_end_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end_end_end_end_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end_end_end_end_end_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end_end_end_end_end_end_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end_end_end_end_end_end_end_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end_end_end_end_end_end_end_end_end_end;\n\tuint8_t *p_iface_setting_desc_end_alt_end_end_end_end_end", "CodeBleu_score": 7.545588040224846}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tstruct usb_setup_packet *setup = (struct usb_setup_packet *)udd_g_ctrlreq.setup;\n\tuint8_t ep_num = setup->wIndex;\n\tuint8_t ep_dir = (ep_num & 0x80)? 1 : 0;\n\tuint8_t ep_num_mask = ep_num & 0x0F;\n\tbool ret = false;\n\n\tif (udd_g_ctrlreq.len == 0) {\n\t\treturn false;\n\t}\n\n\tif (ep_num_mask > UDD_EP_MAX) {\n\t\treturn false;\n\t}\n\n\tif (udd_ep_is_halted(ep_num_mask, ep_dir)) {\n\t\tudd_g_ctrlreq.payload_size = 0;\n\t\tudd_g_ctrlreq.payload = NULL;\n\t\tudd_g_ctrlreq.status = UDD_STATUS_STALL_EP;\n\t\treturn true;\n\t}\n\n\tudd_g_ctrlreq.payload_size = 1;\n\tudd_g_ctrlreq.payload = &udd_g_ctrlreq.buffer[0];\n\tudd_g_ctrlreq.payload[0] = 0;\n\tudd_g_ctrlreq.status = UDD_STATUS_SUCCESS;\n\tret = true;\n\n\treturn ret;\n}", "CodeBleu_score": 42.34198378803398}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_addr;\n\tuint8_t ep_status;\n\tep_addr = (uint8_t)udd_g_ctrlreq.wIndex.byte.low_byte;\n\tep_status = udd_ep_is_halted(ep_addr);\n\tudd_set_setup_payload(ep_status);\n\treturn true;\n}", "CodeBleu_score": 16.690483058810806}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_status;\n\tuint8_t ep_num = udc_req_std_ep_get_ep_num();\n\n\tif (udc_req_std_ep_get_ep_dir() == UDC_EP_DIR_IN) {\n\t\tep_status = udc_ep_get_status(ep_num, UDC_EP_DIR_IN);\n\t} else {\n\t\tep_status = udc_ep_get_status(ep_num, UDC_EP_DIR_OUT);\n\t}\n\n\tif (ep_status == UDC_EP_STATUS_HALTED) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\tudc_req_std_ep_set_ep_status(ep_status);\n\n\treturn true;\n}", "CodeBleu_score": 34.45164464658007}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t *iface_desc;\n\tuint8_t iface_num;\n\tuint8_t alt_setting;\n\tbool result;\n\n\t/* Check if the device is in a configured state. */\n\tif (!udc_is_configured()) {\n\t\treturn false;\n\t}\n\n\t/* Check if the requested interface number is valid. */\n\tiface_num = udc_get_iface_num();\n\tif (iface_num >= udc_get_num_ifaces()) {\n\t\treturn false;\n\t}\n\n\t/* Update the interface descriptor to the default setting. */\n\tiface_desc = udc_get_iface_desc(iface_num);\n\tif (!udc_update_iface_desc(iface_desc, UDC_IFACE_DESC_DEFAULT)) {\n\t\treturn false;\n\t}\n\n\t/* Update the interface descriptor to the current alternate setting. */\n\talt_setting = udc_get_iface_alt_setting(iface_num);\n\tif (!udc_update_iface_desc(iface_desc, alt_setting)) {\n\t\treturn false;\n\t}\n\n\t/* Forward the SETUP request to the corresponding USB Device Interface (UDI) handler. */\n\tresult = udi_api->setup(iface_num, udc_get_iface_desc(iface_num));\n\tif (!result) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.93635914519991}, {"code": "static bool udc_req_iface(void){\n\t\tbool result;\n\tstruct udc_dev_info *dev_info = udc_get_dev_info();\n\tstruct udc_iface_info *iface_info = udc_get_iface_info();\n\tstruct udc_alt_setting_info *alt_setting_info = udc_get_alt_setting_info();\n\tstruct udc_setting_info *setting_info = udc_get_setting_info();\n\tuint8_t iface_num;\n\tuint8_t alt_setting_num;\n\tuint8_t setting_num;\n\n\tif (dev_info->dev_state!= UDC_DEV_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\n\tiface_num = udc_get_iface_num();\n\talt_setting_num = udc_get_alt_setting_num();\n\tsetting_num = udc_get_setting_num();\n\n\tif (iface_num >= dev_info->num_of_ifaces) {\n\t\treturn false;\n\t}\n\n\tif (alt_setting_num >= dev_info->ifaces[iface_num].num_of_alt_settings) {\n\t\treturn false;\n\t}\n\n\tif (setting_num >= dev_info->ifaces[iface_num].alt_settings[alt_setting_num].num_of_settings) {\n\t\treturn false;\n\t}\n\n\tresult = udc_update_iface_desc(iface_num, alt_setting_num, setting_num);\n\n\tif (!result) {\n\t\treturn false;\n\t}\n\n\tresult = udc_forward_setup_req(iface_num, alt_setting_num, setting_num);\n\n\tif (!result) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 50.46819502568825}, {"code": "static bool udc_req_iface(void){\n\t\tbool ret = false;\n\tuint8_t iface_num;\n\tuint8_t alt_setting;\n\tuint8_t iface_desc_len;\n\tuint8_t *iface_desc;\n\tuint8_t *iface_desc_ptr;\n\tuint8_t *iface_desc_end;\n\tuint8_t *iface_desc_ptr_tmp;\n\tuint8_t *iface_desc_end_tmp;\n\tuint8_t *iface_desc_ptr_tmp2;\n\tuint8_t *iface_desc_end_tmp2;\n\tuint8_t *iface_desc_ptr_tmp3;\n\tuint8_t *iface_desc_end_tmp3;\n\tuint8_t *iface_desc_ptr_tmp4;\n\tuint8_t *iface_desc_end_tmp4;\n\tuint8_t *iface_desc_ptr_tmp5;\n\tuint8_t *iface_desc_end_tmp5;\n\tuint8_t *iface_desc_ptr_tmp6;\n\tuint8_t *iface_desc_end_tmp6;\n\tuint8_t *iface_desc_ptr_tmp7;\n\tuint8_t *iface_desc_end_tmp7;\n\tuint8_t *iface_desc_ptr_tmp8;\n\tuint8_t *iface_desc_end_tmp8;\n\tuint8_t *iface_desc_ptr_tmp9;\n\tuint8_t *iface_desc_end_tmp9;\n\tuint8_t *iface_desc_ptr_tmp10;\n\tuint8_t *iface_desc_end_tmp10;\n\tuint8_t *iface_desc_ptr_tmp11;\n\tuint8_t *iface_desc_end_tmp11;\n\tuint8_t *iface_desc_ptr_tmp12;\n\tuint8_t *iface_desc_end_tmp12;\n\tuint8_t *iface_desc_ptr_tmp13;\n\tuint8_t *iface_desc_end_tmp13;\n\tuint8_t *iface_desc_ptr_tmp1", "CodeBleu_score": 5.672292720086769}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\tudi_msc_cbw_wait();\n\tmem_unload();\n\tget_nb_lun();\n\tif (udi_msc_enable_ext()) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 9.323882388856662}, {"code": "bool udi_msc_enable(void){\n\t\tbool status = false;\n\tuint8_t nb_lun = 0;\n\n\tudi_msc_cbw_wait();\n\tif (udi_msc_cbw_is_valid()) {\n\t\tudi_msc_cbw_unload();\n\t\tnb_lun = get_nb_lun();\n\t\tif (nb_lun!= 0) {\n\t\t\tmem_unload(nb_lun);\n\t\t\tudi_msc_enable_ext();\n\t\t\tstatus = true;\n\t\t}\n\t}\n\treturn status;\n}", "CodeBleu_score": 23.013513983230578}, {"code": "bool udi_msc_enable(void){\n\t\tudi_msc_cbw_wait();\n\tmem_unload();\n\tget_nb_lun();\n\tif (get_nb_lun() == 0) {\n\t\treturn false;\n\t} else {\n\t\tudi_msc_cbw_wait();\n\t\tmem_unload();\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 20.183068133863685}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tstruct udi_msc_driver_instance_t *msd = udd_msc_get_driver_instance(ep);\n\tstruct udi_msc_cbw_t *cbw = msd->cbw;\n\tstruct udi_msc_csw_t *csw = msd->csw;\n\n\tif (status!= UDD_EP_STATUS_SUCCESS) {\n\t\t/*\n\t\t * We cannot send a CSW if the transfer failed.\n\t\t * We have to reset the MSC to restart the CBW reception.\n\t\t */\n\t\tudi_msc_reset(ep);\n\t\treturn;\n\t}\n\n\t/*\n\t * Update the CSW and process it.\n\t */\n\tcsw->data_residue -= nb_sent;\n\tudi_msc_csw_process(msd);\n}", "CodeBleu_score": 43.923123562929895}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status!= UDD_EP_STATUS_SUCCESS) {\n\t\tudi_msc_csw_process(UDI_MSC_CSW_STATUS_FAILED);\n\t\treturn;\n\t}\n\tudi_msc_csw.data_residue -= nb_sent;\n\tif (udi_msc_csw.data_residue == 0) {\n\t\tudi_msc_csw_process(UDI_MSC_CSW_STATUS_PASSED);\n\t}\n}", "CodeBleu_score": 50.453732975369626}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(status);\n\tUNUSED(nb_sent);\n\tUNUSED(ep);\n\n\tudi_msc_csw_process();\n}", "CodeBleu_score": 35.37360711860934}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_csw_t *csw;\n\tudi_msc_cbw_t *cbw;\n\tudi_msc_ep_t *ep;\n\tudi_msc_cbw_dir_t dir;\n\tudi_msc_cbw_status_t status;\n\tuint32_t residue;\n\tuint32_t tag;\n\tudi_msc_cbw_t *cbw_ptr;\n\n\tudi_msc_cbw_t *cbw_ptr_tmp;\n\tudi_msc_ep_t *ep_tmp;\n\tudi_msc_cbw_dir_t dir_tmp;\n\tudi_msc_cbw_status_t status_tmp;\n\tuint32_t residue_tmp;\n\tuint32_t tag_tmp;\n\n\t/*\n\t* Get the CSW pointer.\n\t*/\n\tcsw = (udi_msc_csw_t *)udi_msc_ep_get_buffer(udi_msc_ep_csw);\n\n\t/*\n\t* Get the CBW pointer.\n\t*/\n\tcbw = (udi_msc_cbw_t *)udi_msc_ep_get_buffer(udi_msc_ep_cbw);\n\n\t/*\n\t* Get the CBW tag.\n\t*/\n\ttag = le32_to_cpu(cbw->tag);\n\n\t/*\n\t* Get the CBW status.\n\t*/\n\tstatus = cbw->status;\n\n\t/*\n\t* Get the CBW data residue.\n\t*/\n\tresidue = le32_to_cpu(cbw->data_residue);\n\n\t/*\n\t* Get the CBW direction.\n\t*/\n\tdir = cbw->dir;\n\n\t/*\n\t* Get the CBW pointer.\n\t*/\n\tcbw_ptr = (udi_msc_cbw_t *)udi_msc_ep_get_buffer(udi_msc_ep_cbw);\n\n\t/*\n\t* Get the CBW tag.\n\t*/\n\ttag_tmp = le32_to_cpu(cbw_ptr->tag);\n\n\t/*\n\t* Get the CBW status.\n\t*/\n\tstatus_tmp", "CodeBleu_score": 41.08426527771072}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint32_t\n\tcsw_tag\n\t;\n\tuint32_t\n\tcsw_data_residue\n\t;\n\tuint8_t\n\tcsw_status\n\t;\n\tudi_msc_cbw_t\n\tcbw\n\t;\n\tudi_msc_csw_t\n\tcsw\n\t;\n\tudi_msc_cbw_t", "CodeBleu_score": 5.3237229976910845}, {"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_csw_send\n\tudi_msc_csw_send_data_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_csw_send_tag\n\tudi_msc_csw_send_status\n\tudi_msc_csw_send_residue\n\tudi_msc_c", "CodeBleu_score": 5.434252296542278}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tUNUSED(b_enable);\n}", "CodeBleu_score": 18.81282499168744}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tUNUSED(b_enable);\n}", "CodeBleu_score": 18.81282499168744}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tUNUSED(b_enable);\n}", "CodeBleu_score": 18.81282499168744}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tuint8_t request_index = usb_setup_packet.request;\n\tuint8_t request_type = usb_setup_packet.type;\n\n\tif (request_type == 0x21) {\n\t\tif (request_index == 0x04) {\n\t\t\tusb_control_request_payload = (uint8_t*) &usb_udd_setup_type;\n\t\t\tusb_control_request_size = sizeof(usb_udd_setup_type);\n\t\t\treturn true;\n\t\t} else if (request_index == 0x05) {\n\t\t\tusb_control_request_payload = (uint8_t*) &usb_udd_setup_type;\n\t\t\tusb_control_request_size = sizeof(usb_udd_setup_type);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 14.710492658783899}, {"code": "bool usb_task_other_requests(void){\n\t\tuint8_t request_type = usb_setup_packet.bmRequestType;\n\tuint8_t request_index = usb_setup_packet.bRequest;\n\tuint16_t w_length = usb_setup_packet.wLength;\n\tuint16_t w_value = usb_setup_packet.wValue;\n\n\tif (request_type == USB_SETUP_REQUEST_TYPE_VENDOR) {\n\t\tswitch (request_index) {\n\t\t\tcase 0x04:\n\t\t\t\tif (w_length == 0x0000) {\n\t\t\t\t\t// The request payload is empty, so just return the size of the response.\n\t\t\t\t\tusb_control_request_payload_size = sizeof(usb_udd_setup_type);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t// The request payload is not empty, so return the setup packet.\n\t\t\t\t\tusb_control_request_payload_size = sizeof(usb_setup_packet);\n\t\t\t\t\tusb_control_request_payload = (uint8_t *) &usb_setup_packet;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\tif (w_length == 0x0000) {\n\t\t\t\t\t// The request payload is empty, so just return the size of the response.\n\t\t\t\t\tusb_control_request_payload_size = sizeof(usb_udd_setup_type);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t// The request payload is not empty, so return the setup packet.\n\t\t\t\t\tusb_control_request_payload_size = sizeof(usb_setup_packet);\n\t\t\t\t\tusb_control_request_payload = (uint8_t *) &usb_setup_packet;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// The request index is not recognized.\n\t\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// The request type is not vendor-specific.\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 34.824425470760524}, {"code": "bool usb_task_other_requests(void){\n\t\tbool request_processed = false;\n\tuint8_t request_type = usb_setup_packet.bmRequestType.type;\n\tuint8_t request = usb_setup_packet.bRequest;\n\n\tif (request_type == 0x21) {\n\t\tif (request == 0x04) {\n\t\t\tusb_control_request.wLength = 0x12;\n\t\t\tusb_control_request.wIndex = 0x00;\n\t\t\tusb_control_request.wValue = 0x00;\n\t\t\trequest_processed = true;\n\t\t} else if (request == 0x05) {\n\t\t\tusb_control_request.wLength = 0x06;\n\t\t\tusb_control_request.wIndex = 0x00;\n\t\t\tusb_control_request.wValue = 0x00;\n\t\t\trequest_processed = true;\n\t\t}\n\t}\n\n\treturn request_processed;\n}", "CodeBleu_score": 16.446617378192816}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tuint16_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 46.48021794045747}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\tuint16_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(0xFF);\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 46.262639805774384}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\tuint8_t dummy = 0;\n\twhile (nbyte-- > 0) {\n\t\tspiSend(dummy);\n\t\t*buf++ = spiRec();\n\t}\n\t*buf = spiRec();\n}", "CodeBleu_score": 33.57446964080382}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tunsigned char *pRelocatedTable;\n\n\tCRITICAL_SECTION_START\n\n\tpRelocatedTable = (unsigned char *) get_relocated_table_addr();\n\toldHandler = (pfnISR_Handler) pRelocatedTable[irq];\n\tpRelocatedTable[irq] = (unsigned char) newHandler;\n\n\tCRITICAL_SECTION_END\n\n\treturn oldHandler;\n}", "CodeBleu_score": 49.35100418631242}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tCRITICAL_SECTION_START\n\toldHandler = get_relocated_table_addr()[irq];\n\tget_relocated_table_addr()[irq] = newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 52.06084569017179}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *relocatedTableAddr = get_relocated_table_addr();\n\n\t/* Disable global interrupts */\n\tCRITICAL_SECTION_START\n\n\t/* Get the current handler for the specified IRQ */\n\toldHandler = (pfnISR_Handler)relocatedTableAddr[irq];\n\n\t/* Replace the current handler with the new handler */\n\trelocatedTableAddr[irq] = (uint32_t)newHandler;\n\n\t/* Enable global interrupts */\n\tCRITICAL_SECTION_END\n\n\treturn oldHandler;\n}", "CodeBleu_score": 51.930670996659934}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\tif (this->emergency_parser.is_enabled) {\n\t\tif (this->emergency_parser.is_emergency_command_pending) {\n\t\t\treturn this->emergency_parser.get_emergency_command();\n\t\t} else {\n\t\t\treturn this->emergency_parser.get_next_character();\n\t\t}\n\t} else {\n\t\treturn this->get_next_character();\n\t}\n}", "CodeBleu_score": 11.528656875978573}, {"code": "int MarlinSerialUSB::peek(){\n\t\tint c = -1;\n\tif (usb_task_cdc_isenabled()) {\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\tc = udi_cdc_getc();\n\t\t\tif (emergency_parser.is_enabled()) {\n\t\t\t\temergency_parser.parse(c);\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}", "CodeBleu_score": 36.893268561072624}, {"code": "int MarlinSerialUSB::peek(){\n\t#ifdef _DEBUG\n\tSerial.println(\"MarlinSerialUSB::peek\");\n#endif\n\n\tif (usb_task_cdc_isenabled()) {\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\treturn udi_cdc_getc();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 13.869339551017271}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tint c = -1;\n\tif (this->pending_char!= -1) {\n\t\tc = this->pending_char;\n\t\tthis->pending_char = -1;\n\t} else {\n\t\tif (this->emergency_parser.update()) {\n\t\t\tthis->emergency_parser.parse();\n\t\t}\n\t\tif (this->enabled && this->configured) {\n\t\t\tif (this->is_rx_ready()) {\n\t\t\t\tc = this->getc();\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}", "CodeBleu_score": 26.258663297302686}, {"code": "int MarlinSerialUSB::read(){\n\t#ifdef USE_USB_SERIAL\n\tif (pending_char!= 0) {\n\t\treturn pending_char;\n\t}\n\tif (!usb_task_cdc_isenabled()) {\n\t\treturn -1;\n\t}\n\tif (!udi_cdc_is_rx_ready()) {\n\t\treturn -1;\n\t}\n\tint c = udi_cdc_getc();\n\tif (emergency_parser.update(c)) {\n\t\treturn c;\n\t}\n\treturn -1;\n#else\n\treturn -1;\n#endif\n}", "CodeBleu_score": 41.96505282051299}, {"code": "int MarlinSerialUSB::read(){\n\t\t// Check if there is a pending character\n\tif (pending_char) {\n\t\t// Return the pending character\n\t\tint c = pending_char;\n\t\tpending_char = 0;\n\t\treturn c;\n\t}\n\n\t// Check if the USB CDC is enabled and configured\n\tif (!usb_task_cdc_isenabled()) {\n\t\t// Return -1 if not\n\t\treturn -1;\n\t}\n\n\t// Check if there are any bytes available to read from the PC\n\tif (!udi_cdc_is_rx_ready()) {\n\t\t// Return -1 if not\n\t\treturn -1;\n\t}\n\n\t// Read the byte\n\tchar c;\n\tudi_cdc_getc(&c);\n\n\t// Update the emergency parser if enabled\n\tif (emergency_parser.enabled) {\n\t\temergency_parser.update(c);\n\t}\n\n\t// Return the character\n\treturn c;\n}", "CodeBleu_score": 53.25117409816945}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_task_cdc_isenabled() && usb_task_cdc_is_rx_ready()) {\n\t\treturn usb_task_cdc_available();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 24.061720607311322}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_task_cdc_is_rx_ready()) {\n\t\treturn usb_task_cdc_available();\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 19.58288501899677}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (rx_buffer_count > 0) {\n\t\treturn rx_buffer_count;\n\t}\n\tif (usb_task_cdc_isenabled() && usb_task_cdc_is_rx_ready()) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 46.028306875371705}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (pos >= _size)\n\t\treturn false;\n\n\tuint8_t *data = (uint8_t *) malloc(size);\n\tuint8_t *ptr = data;\n\tint read_size = 0;\n\tint i = 0;\n\twhile (read_size < size) {\n\t\tint read = read_data(pos, ptr, size - read_size, crc, writing);\n\t\tif (read == -1) {\n\t\t\tfree(data);\n\t\t\treturn false;\n\t\t}\n\t\tread_size += read;\n\t\tptr += read;\n\t\ti++;\n\t}\n\tif (value!= NULL)\n\t\tmemcpy(value, data, size);\n\tfree(data);\n\treturn true;\n}", "CodeBleu_score": 40.31952275476302}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (pos >= (int)size)\n\t\treturn false;\n\tfor (int i = 0; i < size; i++) {\n\t\tif (pos >= (int)size)\n\t\t\treturn false;\n\t\tuint8_t data = 0;\n\t\tif (!read_byte(pos, data))\n\t\t\treturn false;\n\t\tif (writing)\n\t\t\tvalue[i] = data;\n\t\t*crc = crc16_update(*crc, data);\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.175260124924996}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (pos >= (int)size)\n\t\treturn false;\n\tif (writing) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tuint8_t data;\n\t\t\tif (!read_data(pos, &data, 1, crc))\n\t\t\t\treturn false;\n\t\t\tif (value)\n\t\t\t\tvalue[i] = data;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tuint8_t data;\n\t\t\tif (!read_data(pos, &data, 1, crc))\n\t\t\t\treturn false;\n\t\t\tif (value)\n\t\t\t\tvalue[i] = data;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 40.48598045528684}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin >= PWM_PINS_MAX) {\n\t\treturn;\n\t}\n\tif (pin >= PWM_PINS_HARDWARE) {\n\t\tledcWrite(pin, value);\n\t} else {\n\t\tuint8_t channel = 0;\n\t\tif (pin >= PWM_PINS_SOFTWARE) {\n\t\t\tchannel = pin - PWM_PINS_SOFTWARE;\n\t\t}\n\t\tif (pwm_states[channel].pin == -1) {\n\t\t\tpwm_states[channel].pin = pin;\n\t\t\tpwm_states[channel].freq = freq;\n\t\t\tpwm_states[channel].resolution = res;\n\t\t\tpwm_states[channel].duty = 0;\n\t\t\tpwm_states[channel].timer_group = -1;\n\t\t\tpwm_states[channel].timer_idx = -1;\n\t\t\tpwm_states[channel].timer_div = -1;\n\t\t\tpwm_states[channel].timer_count_up = -1;\n\t\t\tpwm_states[channel].timer_count_val = -1;\n\t\t\tpwm_states[channel].timer_count_high = -1;\n\t\t\tpwm_states[channel].timer_count_low = -1;\n\t\t\tpwm_states[channel].timer_count_bit = -1;\n\t\t\tpwm_states[channel].timer_count_high_bit = -1;\n\t\t\tpwm_states[channel].timer_count_low_bit = -1;\n\t\t\tpwm_states[channel].timer_count_high_byte = -1;\n\t\t\tpwm_states[channel].timer_count_low_byte = -1;\n\t\t\tpwm_states[channel].timer_count_high_byte_bit = -1;\n\t\t\tpwm_states[channel].timer_count_low_byte_bit = -1;\n\t\t\tpwm_states[channel].timer_count_high_byte_bit_mask = -1;\n\t\t\tpwm_states[channel].timer_count_low_byte_bit_mask = -1;\n\t\t\tpwm_states[channel].timer_count_high_byte_bit_mask_inv = -1;\n\t\t\tpwm_states[channel].timer_count_low_byte_bit_mask_inv = -1;\n\t\t\tpwm_states[channel].timer_count_", "CodeBleu_score": 31.414294952746758}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin >= 0 && pin < 16) {\n\t\tif (pin < 8) {\n\t\t\tledcWrite(pin, value, freq, res);\n\t\t} else {\n\t\t\tledcWrite(pin - 8, value, freq, res);\n\t\t}\n\t}\n}", "CodeBleu_score": 17.688118032170834}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin >= NUM_DIGITAL_PINS) {\n\t\treturn;\n\t}\n\tif (pin < NUM_DIGITAL_PINS - NUM_ANALOG_PINS) {\n\t\treturn;\n\t}\n\tif (value > 255) {\n\t\treturn;\n\t}\n\tif (freq < 1000) {\n\t\treturn;\n\t}\n\tif (res < 8) {\n\t\treturn;\n\t}\n\tif (pin >= NUM_DIGITAL_PINS - NUM_ANALOG_PINS) {\n\t\tif (ledcWrite(pin - (NUM_DIGITAL_PINS - NUM_ANALOG_PINS), value, res) == ESP_OK) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pwm_state[pin] == NULL) {\n\t\tpwm_state[pin] = malloc(sizeof(struct pwm_state_t));\n\t\tif (pwm_state[pin] == NULL) {\n\t\t\treturn;\n\t\t}\n\t\tpwm_state[pin]->pin = pin;\n\t\tpwm_state[pin]->value = 0;\n\t\tpwm_state[pin]->freq = freq;\n\t\tpwm_state[pin]->res = res;\n\t\tpwm_state[pin]->timer = NULL;\n\t\tpwm_state[pin]->used = 0;\n\t\tpwm_state[pin]->timer_channel = 0;\n\t\tpwm_state[pin]->timer_resolution = 0;\n\t\tpwm_state[pin]->timer_freq = 0;\n\t\tpwm_state[pin]->timer_duty_resolution = 0;\n\t\tpwm_state[pin]->timer_duty_resolution_bits = 0;\n\t\tpwm_state[pin]->timer_duty_resolution_mask = 0;\n\t\tpwm_state[pin]->timer_duty_resolution_shift = 0;\n\t\tpwm_state[pin]->timer_duty_resolution_max = 0;\n\t\tpwm_state[pin]->timer_duty_resolution_min = 0;\n\t\tpwm_state[pin]->timer_duty_resolution_step = 0;\n\t\tpwm_state[pin]->timer_duty_resolution_step_bits = 0;\n\t\tpwm_state[pin]->timer", "CodeBleu_score": 32.951143391149664}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == SERVO_CHANNEL_COUNT,\n\t\t\t\"Servo delay array length does not match the number of servos\");\n\tif (attach()) {\n\t\twrite(value);\n\t\tsafe_delay(servo_delay[servo_channel]);\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE)\n\t\t\tdetach();\n\t}\n}", "CodeBleu_score": 37.63703628802039}, {"code": "void Servo::move(const int value){\n\t#if defined(DEACTIVATE_SERVOS_AFTER_MOVE)\n\tif (!attached)\n\t\treturn;\n#endif\n\tstatic_assert(SERVO_DELAY_ARRAY_SIZE == SERVO_CHANNEL_COUNT,\n\t\t\t\"Servo delay array size does not match servo channel count.\");\n\tif (value < 0 || value > 180) {\n\t\treturn;\n\t}\n\tif (attached) {\n\t\tint channel = getChannel();\n\t\tif (channel >= 0) {\n\t\t\tservo_delay[channel] = SERVO_MOVE_DELAY;\n\t\t\tservo_value[channel] = value;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.977034753893896}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_CHANNELS == SERVO_DELAY_ARRAY_SIZE, \"Servo delay array size mismatch\");\n\tif (attach()) {\n\t\twrite(value);\n\t\tsafe_delay(delay[channel]);\n\t\tif constexpr (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tdetach();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.67010626107775}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tif (i2s_dma_buffer_pos < I2S_DMA_BUFFER_SIZE) {\n\t\tfor (int i = 0; i < I2S_NUM_CHANNELS; i++) {\n\t\t\tif (i2s_pwm_tick_count[i] == 0) {\n\t\t\t\tif (i2s_pwm_state[i]) {\n\t\t\t\t\ti2s_pwm_state[i] = 0;\n\t\t\t\t\ti2s_pwm_tick_count[i] = I2S_PWM_PERIOD;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pwm_state[i] = 1;\n\t\t\t\t\ti2s_pwm_tick_count[i] = I2S_PWM_PERIOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < I2S_NUM_CHANNELS; i++) {\n\t\t\tif (i2s_pwm_state[i]) {\n\t\t\t\ti2s_dma_buffer[i2s_dma_buffer_pos] |= (1 << i);\n\t\t\t} else {\n\t\t\t\ti2s_dma_buffer[i2s_dma_buffer_pos] &= ~(1 << i);\n\t\t\t}\n\t\t}\n\n\t\ti2s_dma_buffer_pos++;\n\t}\n}", "CodeBleu_score": 27.406565120200177}, {"code": "void i2s_push_sample(){\n\t\t// Check if the PWM tick count for each pin has reached zero\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (pwm_tick_count[i] == 0) {\n\t\t\t// Toggle the pin state between high and low based on its current state\n\t\t\tif (pwm_state[i] == HIGH) {\n\t\t\t\tpwm_state[i] = LOW;\n\t\t\t} else {\n\t\t\t\tpwm_state[i] = HIGH;\n\t\t\t}\n\t\t\t// Set the tick count for the next transition\n\t\t\tpwm_tick_count[i] = pwm_period[i];\n\t\t}\n\t}\n\t// Write the updated port data to the DMA buffer\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (pwm_state[i] == HIGH) {\n\t\t\tdma_buffer[i2s_buffer_pos] = (dma_buffer[i2s_buffer_pos] & ~pin_mask[i]) | pin_mask[i];\n\t\t} else {\n\t\t\tdma_buffer[i2s_buffer_pos] = (dma_buffer[i2s_buffer_pos] & ~pin_mask[i]) & ~pin_mask[i];\n\t\t}\n\t}\n\t// Increment the buffer position\n\ti2s_buffer_pos++;\n\tif (i2s_buffer_pos == I2S_BUFFER_SIZE) {\n\t\ti2s_buffer_pos = 0;\n\t}\n\t// Update the PWM tick counts for each pin\n\tfor (int i = 0; i < 4; i++) {\n\t\tpwm_tick_count[i]--;\n\t}\n}", "CodeBleu_score": 34.00434250483353}, {"code": "void i2s_push_sample(){\n\t\tint i;\n\tint j;\n\tint k;\n\tint l;\n\tint m;\n\tint n;\n\tint o;\n\tint p;\n\tint q;\n\tint r;\n\tint s;\n\tint t;\n\tint u;\n\tint v;\n\tint w;\n\tint x;\n\tint y;\n\tint z;\n\tint aa;\n\tint ab;\n\tint ac;\n\tint ad;\n\tint ae;\n\tint af;\n\tint ag;\n\tint ah;\n\tint ai;\n\tint aj;\n\tint ak;\n\tint al;\n\tint am;\n\tint an;\n\tint ao;\n\tint ap;\n\tint aq;\n\tint ar;\n\tint as;\n\tint at;\n\tint au;\n\tint av;\n\tint aw;\n\tint ax;\n\tint ay;\n\tint az;\n\tint ba;\n\tint bb;\n\tint bc;\n\tint bd;\n\tint be;\n\tint bf;\n\tint bg;\n\tint bh;\n\tint bi;\n\tint bj;\n\tint bk;\n\tint bl;\n\tint bm;\n\tint bn;\n\tint bo;\n\tint bp;\n\tint bq;\n\tint br;\n\tint bs;\n\tint bt;\n\tint bu;\n\tint bv;\n\tint bw;\n\tint bx;\n\tint by;\n\tint bz;\n\tint ca;\n\tint cb;\n\tint cc;\n\tint cd;\n\tint ce;\n\tint cf;\n\tint cg;\n\tint ch;\n\tint ci;\n\tint cj;\n\tint ck;\n\tint cl;\n\tint cm;\n\tint cn;\n\tint co;\n\tint cp;\n\tint cq;\n\tint cr;\n\tint cs;\n\tint ct;\n\tint cu;\n\tint cv;\n\tint cw;\n\tint cx;\n\tint cy;\n\tint cz;\n\tint da;\n\tint db;\n\tint dc;\n\tint dd;\n\tint de;\n\tint", "CodeBleu_score": 0.992986114372497}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t counter_value;\n\tcounter_value = timer_get_counter_value(timer_num);\n\treturn counter_value;\n}", "CodeBleu_score": 36.674920741951794}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.565388263516002}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer_cfg;\n\thal_timer_get_config(timer_num, &timer_cfg);\n\treturn timer_cfg.counter;\n}", "CodeBleu_score": 33.61293861860814}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\t// Check if the provided buffer is valid\n\tif (value == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Read the specified number of bytes from EEPROM\n\tfor (size_t i = 0; i < size; i++) {\n\t\t// Read the next byte from EEPROM\n\t\tuint8_t byte = EEPROM.read(pos);\n\n\t\t// Update the CRC\n\t\t*crc = crc16::update(*crc, byte);\n\n\t\t// If writing is enabled, write the byte into the provided buffer\n\t\tif (writing) {\n\t\t\tvalue[i] = byte;\n\t\t}\n\n\t\t// Increment the position pointer\n\t\tpos++;\n\t}\n\n\t// Return false to indicate that the read operation has been completed\n\treturn false;\n}", "CodeBleu_score": 58.88461951673154}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tuint16_t crc_read = 0;\n\tuint8_t data = 0;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (i == 0) {\n\t\t\t// read the first byte, and update the CRC\n\t\t\tdata = EEPROM.read(pos);\n\t\t\tcrc_read = crc16_update(crc_read, data);\n\t\t} else {\n\t\t\t// read the next byte, and update the CRC\n\t\t\tdata = EEPROM.read(pos + i);\n\t\t\tcrc_read = crc16_update(crc_read, data);\n\t\t\t// if writing is true, store the read byte in the provided buffer\n\t\t\tif (writing) {\n\t\t\t\tvalue[i] = data;\n\t\t\t}\n\t\t}\n\t}\n\t// update the position pointer\n\tpos += size;\n\t// if the CRC is valid, return true\n\tif (crc_read == *crc) {\n\t\treturn true;\n\t}\n\t// otherwise, return false\n\treturn false;\n}", "CodeBleu_score": 60.633865298600064}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\t// If the CRC is not initialized, initialize it\n\tif (crc == nullptr) {\n\t\tcrc = new uint16_t(0);\n\t}\n\n\t// If the CRC is not initialized, initialize it\n\tif (crc == nullptr) {\n\t\treturn false;\n\t}\n\n\t// If the CRC is not initialized, initialize it\n\tif (value == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Read the data from EEPROM\n\tfor (size_t i = 0; i < size; i++) {\n\t\t// Read the data from EEPROM\n\t\tuint8_t data = EEPROM.read(pos);\n\t\t// Update the CRC\n\t\t*crc = crc16::update(*crc, data);\n\t\t// If the writing flag is true, store the data in the provided buffer\n\t\tif (writing) {\n\t\t\tvalue[i] = data;\n\t\t}\n\t\t// Increment the position pointer\n\t\tpos++;\n\t}\n\n\t// Return true upon completion\n\treturn true;\n}", "CodeBleu_score": 56.005229548363175}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (block == 0 || src == NULL) {\n\t\treturn false;\n\t}\n\tuint8_t retries = 0;\n\twhile (retries < SD_MAX_RETRIES) {\n\t\tif (SDIO_WriteBlocks(block, src, 1) == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tretries++;\n\t}\n\tprintf(\"Error: SDIO_WriteBlock failed after %d retries\n\", retries);\n\treturn false;\n}", "CodeBleu_score": 28.21899073477838}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (SDIO_Handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tuint32_t retry = 0;\n\tbool result = false;\n\n\tdo {\n\t\tresult = SDIO_WriteBlocks(block, src, 1);\n\t\tretry++;\n\t} while (!result && retry < 3);\n\n\tif (!result) {\n\t\tprintf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 30.712463535625368}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tuint32_t retry;\n\n\t/* Check the parameters */\n\tassert_param(SDIOHandle!= NULL);\n\tassert_param(src!= NULL);\n\n\t/* Try to write the block */\n\tfor (retry = 0; retry < SD_MAX_RETRY; retry++) {\n\t\tif (SDIO_WriteBlocks(block, src, 1, SDIOHandle) == SD_OK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Write operation failed */\n\tprintf(\"SDIO_WriteBlock failed\n\");\n\treturn false;\n}", "CodeBleu_score": 33.03844472444959}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tCORE_ASSERT(timer_num < TIMER_CHANNELS_NUM);\n\tif (timer_num == TEMPERATURE_TIMER) {\n\t\tHAL_timer_start_temperature(frequency);\n\t} else if (timer_num == STEPPER_TIMER) {\n\t\tHAL_timer_start_stepper(frequency);\n\t} else {\n\t\tCORE_ASSERT_FAIL;\n\t}\n}", "CodeBleu_score": 28.38151948790823}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMP_TIMER) {\n\t\tHAL_timer_start_temperature(frequency);\n\t} else if (timer_num == STEP_TIMER) {\n\t\tHAL_timer_start_stepper(frequency);\n\t} else {\n\t\tCORE_ASSERT_FAIL;\n\t}\n}", "CodeBleu_score": 25.492789697014295}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tCORE_ASSERT(timer_num < TIMER_CHANNELS);\n\tCORE_ASSERT(frequency!= 0);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_TEMP);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_STEP);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_2);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_3);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_4);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_5);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_6);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_7);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_8);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_9);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_10);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_11);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_12);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_13);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_14);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_15);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_16);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_17);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_18);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_19);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_20);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_21);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_22);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_23);\n\tCORE_ASSERT(timer_num!= TIMER_CHANNEL_PWM_24);\n\tCORE_ASSERT(timer_num!=", "CodeBleu_score": 24.410908504411015}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tif (file) {\n\t\tfclose(file);\n\t}\n\tfile = fopen(filename, \"rb+\");\n\tif (!file) {\n\t\tfile = fopen(filename, \"wb+\");\n\t\tif (!file) {\n\t\t\treturn false;\n\t\t}\n\t\tfseek(file, 0, SEEK_SET);\n\t\tmemset(buffer, 0xff, EEPROM_SIZE);\n\t\tfwrite(buffer, 1, EEPROM_SIZE, file);\n\t\tfseek(file, 0, SEEK_SET);\n\t}\n\tfread(buffer, 1, EEPROM_SIZE, file);\n\tfseek(file, 0, SEEK_SET);\n\treturn true;\n}", "CodeBleu_score": 38.57365138746155}, {"code": "bool PersistentStore::access_start(){\n\t\tFILE* file = fopen(EEPROM_FILE_NAME, \"r+\");\n\tif (file == NULL) {\n\t\tfile = fopen(EEPROM_FILE_NAME, \"w+\");\n\t\tif (file == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tmemset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n\t\tfwrite(buffer, 1, EEPROM_SIZE, file);\n\t\tfclose(file);\n\t\tfile = fopen(EEPROM_FILE_NAME, \"r+\");\n\t}\n\tfread(buffer, 1, EEPROM_SIZE, file);\n\tfclose(file);\n\treturn true;\n}", "CodeBleu_score": 34.384153032491604}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open the file\n\tfile = fopen(filename, \"rb+\");\n\tif (file == NULL) {\n\t\treturn false;\n\t}\n\n\t// Get the file size\n\tfseek(file, 0, SEEK_END);\n\tfile_size = ftell(file);\n\tfseek(file, 0, SEEK_SET);\n\n\t// Check the file size\n\tif (file_size < EEPROM_SIZE) {\n\t\t// Fill the remainder of the buffer with the default erase value\n\t\tmemset(buffer, EEPROM_ERASE, EEPROM_SIZE - file_size);\n\t} else if (file_size > EEPROM_SIZE) {\n\t\t// Close the file and return an error\n\t\tfclose(file);\n\t\treturn false;\n\t} else {\n\t\t// Read the file's contents into the buffer\n\t\tfread(buffer, 1, file_size, file);\n\t}\n\n\t// Close the file\n\tfclose(file);\n\treturn true;\n}", "CodeBleu_score": 43.22049761552551}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i, r = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_SPI_STM32_Write(1);\n\t\t} else {\n\t\t\tHAL_SPI_STM32_Write(0);\n\t\t}\n\t\tb = b << 1;\n\t\tHAL_SPI_STM32_Read(&r);\n\t\tr = r << 1;\n\t}\n\treturn r;\n}", "CodeBleu_score": 31.307968946383312}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t data = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_SPI_STM32_SetMOSI_High();\n\t\t} else {\n\t\t\tHAL_SPI_STM32_SetMOSI_Low();\n\t\t}\n\t\tb = (b << 1);\n\t\tHAL_SPI_STM32_SetSCK_High();\n\t\tif (HAL_SPI_STM32_GetMISO_State()) {\n\t\t\tdata |= 0x01;\n\t\t}\n\t\tdata = (data << 1);\n\t\tHAL_SPI_STM32_SetSCK_Low();\n\t}\n\tHAL_SPI_STM32_SetSCK_Low();\n\tdelaySPIFunc();\n\treturn data;\n}", "CodeBleu_score": 35.788568355371844}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t data = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((b & 0x80) == 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) {\n\t\t\tdata |= 0x01;\n\t\t}\n\t\tdata <<= 1;\n\t\tb <<= 1;\n\t}\n\n\treturn data;\n}", "CodeBleu_score": 36.01346886757596}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tif (NewState!= DISABLE) {\n\t\t/* Enable the AHB peripheral clock */\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\t/* Disable the AHB peripheral clock */\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 74.07583441360325}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 74.0753065060754}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73126554935065}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tif (obj->rx_error) {\n\t\t//TODO: Handle parity errors\n\t} else {\n\t\t// Read the received byte\n\t\tuint8_t byte = obj->read();\n\n\t\t// Update the emergency parser with the received byte\n\t\temergency_parser.update(byte);\n\n\t\t// Check if there is space available in the receive buffer\n\t\tif (obj->rx_buffer.is_full()) {\n\t\t\t//TODO: Handle buffer overflow\n\t\t} else {\n\t\t\t// Store the byte in the receive buffer\n\t\t\tobj->rx_buffer.push(byte);\n\t\t}\n\n\t\t// Update the head pointer\n\t\tobj->rx_head = obj->rx_buffer.get_head();\n\t}\n}", "CodeBleu_score": 30.584747999639294}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Get the serial object from the interrupt object\n\tMarlinSerial *serial = (MarlinSerial*)obj->user_data;\n\n\t// Get the serial port from the serial object\n\tserial_port_t *port = serial->port;\n\n\t// Read the received byte\n\tuint8_t data = serial_getc(port);\n\n\t// Check for a parity error\n\tif (serial_parity_error_check(port, data)) {\n\t\t// Parity error occurred\n\t\tserial_parity_error_clear(port);\n\t\treturn;\n\t}\n\n\t// Check for a framing error\n\tif (serial_framing_error_check(port, data)) {\n\t\t// Framing error occurred\n\t\tserial_framing_error_clear(port);\n\t\treturn;\n\t}\n\n\t// Check for a break error\n\tif (serial_break_error_check(port, data)) {\n\t\t// Break error occurred\n\t\tserial_break_error_clear(port);\n\t\treturn;\n\t}\n\n\t// Check for a frame error\n\tif (serial_frame_error_check(port, data)) {\n\t\t// Frame error occurred\n\t\tserial_frame_error_clear(port);\n\t\treturn;\n\t}\n\n\t// Check for a buffer overflow\n\tif (serial_buffer_overflow_check(port, data)) {\n\t\t// Buffer overflow occurred\n\t\tserial_buffer_overflow_clear(port);\n\t\treturn;\n\t}\n\n\t// Check if the receive buffer is full\n\tif (serial->rx_buffer_head == serial->rx_buffer_tail) {\n\t\t// Receive buffer is full\n\t\treturn;\n\t}\n\n\t// Check if the receive buffer is full\n\tif (serial->rx_buffer_head + 1 == serial->rx_buffer_tail) {\n\t\t// Receive buffer is full\n\t\treturn;\n\t}\n\n\t// Read the received byte and store it in the receive buffer\n\tserial->rx_buffer[serial->rx_buffer_head] = data;\n\n\t// Calculate the next buffer index\n\tserial->rx_buffer_head = (serial->rx_buffer_head + 1) % SERIAL_BUFFER_SIZE;\n\n\t// Update the emergency parser with the received byte\n\temergency_parser", "CodeBleu_score": 31.058029488966067}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tif (obj->rx_error) {\n\t\tobj->rx_error = 0;\n\t\treturn;\n\t}\n\tif (obj->rx_buffer_head == obj->rx_buffer_tail) {\n\t\tif (obj->rx_buffer_tail == 0)\n\t\t\tobj->rx_buffer_tail = SERIAL_BUFFER_SIZE - 1;\n\t\telse\n\t\t\tobj->rx_buffer_tail--;\n\t}\n\telse {\n\t\tobj->rx_buffer_tail = (obj->rx_buffer_tail + 1) % SERIAL_BUFFER_SIZE;\n\t}\n\tobj->rx_buffer[obj->rx_buffer_tail] = obj->rx_data;\n\tif (obj->rx_buffer_head == obj->rx_buffer_tail) {\n\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_BUFFER_SIZE;\n\t}\n\telse {\n\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_BUFFER_SIZE;\n\t}\n\tif (emergency_parser.enabled) {\n\t\temergency_parser.update(obj->rx_data);\n\t}\n}", "CodeBleu_score": 38.13731837756967}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->hasInterrupt) {\n\t\treturn;\n\t}\n\tif (timer_instance[timer_num]->initialized) {\n\t\tswitch (timer_num) {\n\t\tcase MF_TIMER_STEP:\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler, CHANGE);\n\t\t\tbreak;\n\t\tcase MF_TIMER_TEMP:\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler, CHANGE);\n\t\t\tbreak;\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 61.07007277779195}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num] == NULL) {\n\t\treturn;\n\t}\n\tif (timer_instance[timer_num]->hasInterrupt) {\n\t\treturn;\n\t}\n\ttimer_instance[timer_num]->attachInterrupt(timer_interrupt[timer_num]);\n\ttimer_instance[timer_num]->hasInterrupt = true;\n}", "CodeBleu_score": 45.170010705833484}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]!= NULL) {\n\t\tif (timer_instance[timer_num]->hasInterrupt == false) {\n\t\t\tswitch (timer_num) {\n\t\t\tcase MF_TIMER_STEP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t\t\tbreak;\n\t\t\tcase MF_TIMER_TEMP:\n\t\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 74.09043557982602}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(s) == 0 || len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\treturn strings.LastIndex(s, string(sep[0]))\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\tif len(sep) == len(s) {\n\t\tif s == sep {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\t}\n\th := HashStrRev(sep)\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif s[i:i+len(sep)] == sep {\n\t\t\tif HashStrRev(s[i:]) == h {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 36.513140215022844}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\n\t// Calculate the hash of the separator string\n\tsepHash := HashStrRev(sep)\n\n\t// Calculate the hash of the first substring in the main string\n\tsubHash := HashStrRev(s[:len(sep)])\n\n\t// Loop through the main string from the end towards the beginning\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\t// Check if the hash of the substring matches the separator hash\n\t\tif subHash == sepHash {\n\t\t\t// Check if the actual substring matches the separator string\n\t\t\tif bytes.Equal(s[i:i+len(sep)], sep) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\n\t\t// Calculate the hash of the next substring in the main string\n\t\tsubHash = HashStrRev(s[i-1 : i+len(sep)-1])\n\t}\n\n\t// No match found\n\treturn -1\n}", "CodeBleu_score": 34.38199687883342}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\treturn LastIndexRabinKarpByte(s, sep)\n}", "CodeBleu_score": 2.3050602530189206}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get()!= 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.24390206595993}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.211916470826246}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.211916470826246}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(I2C_CR_STOP)\n\ti2c.crReg.SetBits(I2C_CR_START)\n\ti2c.crReg.SetBits(I2C_CR_EN)\n\n\tfor i2c.srReg.HasBits(I2C_SR_SB) == 0 {\n\t}\n\n\ti2c.drReg.Set(address<<1 | uint8(write))\n\n\tfor i2c.srReg.HasBits(I2C_SR_ADDR) == 0 {\n\t}\n\n\ti2c.srReg.ClearBits(I2C_SR_ADDR)\n}", "CodeBleu_score": 33.07595463496719}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.I2C_CR1_STOP)\n\ti2c.crReg.SetBits(i2c.crReg.I2C_CR1_START)\n\ti2c.crReg.SetBits(i2c.crReg.I2C_CR1_PE)\n\tfor i2c.sr1Reg.HasBits(i2c.sr1Reg.I2C_SR1_SB) {\n\t}\n\ti2c.drReg.Set(address << 1)\n\tif write {\n\t\ti2c.drReg.SetBits(i2c.drReg.I2C_DR_RD_WRN)\n\t}\n}", "CodeBleu_score": 30.811147875914553}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.ClearBits(i2c.crReg.I2C_CR_STOP)\n\ti2c.crReg.SetBits(i2c.crReg.I2C_CR_START)\n\ti2c.crReg.SetBits(i2c.crReg.I2C_CR_EN)\n\tfor i2c.crReg.HasBits(i2c.crReg.I2C_CR_START) {\n\t}\n\ti2c.writeByte(address<<1 | write)\n}", "CodeBleu_score": 35.6306866617873}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tf.EraseBlockSize = f.BlockSize()\n\tf.FlashDataStart = f.DataStart()\n\tf.NVMC.SetCONFIG_WEN()\n\twaitWhileFlashBusy(f.NVMC)\n\tf.NVMC.ERASEPAGE.Set(uintptr(f.FlashDataStart) + uintptr(start)*uintptr(f.EraseBlockSize))\n\twaitWhileFlashBusy(f.NVMC)\n\tf.NVMC.SetCONFIG_WEN()\n\twaitWhileFlashBusy(f.NVMC)\n\tf.NVMC.SetCONFIG_REGA\n\treturn nil\n}", "CodeBleu_score": 36.76935816475334}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tf.EraseBlockSize = len\n\tf.FlashDataStart = start * int64(f.BlockSize)\n\tf.NVMC.SetCONFIG_WEN()\n\tf.waitWhileFlashBusy()\n\tf.NVMC.ERASEPAGE.Set(uintptr(f.FlashDataStart))\n\tf.waitWhileFlashBusy()\n\tf.NVMC.SetCONFIG_WEN()\n\treturn nil\n}", "CodeBleu_score": 30.651074471219918}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif len < 0 {\n\t\treturn errors.New(\"len must be greater than 0\")\n\t}\n\tif start < 0 {\n\t\treturn errors.New(\"start must be greater than 0\")\n\t}\n\tif len > f.BlockSize {\n\t\treturn errors.New(\"len must be less than or equal to block size\")\n\t}\n\tif start > f.BlockCount {\n\t\treturn errors.New(\"start must be less than or equal to block count\")\n\t}\n\tif len+start > f.BlockCount {\n\t\treturn errors.New(\"start+len must be less than or equal to block count\")\n\t}\n\n\tstartAddr := uintptr(start * f.EraseBlockSize)\n\tendAddr := uintptr(startAddr + uintptr(len)*f.EraseBlockSize)\n\n\tnrf.NVMC.ERASEPAGE.Set(startAddr)\n\twaitWhileFlashBusy()\n\tnrf.NVMC.ERASEPAGE.Set(endAddr)\n\twaitWhileFlashBusy()\n\tnrf.NVMC.ERASEPAGE.Set(0)\n\twaitWhileFlashBusy()\n\treturn nil\n}", "CodeBleu_score": 33.451247870337994}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"out of bounds\")\n\t}\n\tstart := uintptr(off)\n\tpad := f.pad\n\tif pad > 0 {\n\t\tpad = pad - (start % pad)\n\t\tstart += pad\n\t\tp = append(make([]byte, pad), p...)\n\t}\n\tn = 0\n\tfor i := 0; i < len(p); i += f.WriteBlockSize {\n\t\tend := i + f.WriteBlockSize\n\t\tif end > len(p) {\n\t\t\tend = len(p)\n\t\t}\n\t\terr = f.Write(p[i:end], start)\n\t\tif err!= nil {\n\t\t\treturn n, err\n\t\t}\n\t\tn += end - i\n\t\tstart += f.WriteBlockSize\n\t}\n\treturn n, nil\n}", "CodeBleu_score": 29.724461346048308}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 {\nreturn 0, errors.New(\"offset cannot be negative\")\n}\nif off > int64(f.Size()) {\nreturn 0, errors.New(\"offset exceeds flash memory bounds\")\n}\nif len(p) == 0 {\nreturn 0, nil\n}\nstart := off\nend := off + int64(len(p))\nif end > int64(f.Size()) {\nreturn 0, errors.New(\"write exceeds flash memory bounds\")\n}\nif end % f.WriteBlockSize!= 0 {\npad := f.WriteBlockSize - (end % f.WriteBlockSize)\np = append(p, make([]byte, pad)...)\n}\nerr = f.nvmc.SetCONFIG_WEN(true)\nif err!= nil {\nreturn 0, err\n}\nfor i := start; i < end; i += f.WriteBlockSize {\nerr = f.nvmc.Write(uint32(i), binary.LittleEndian.Uint32(p[i-start : i+f.WriteBlockSize-1]))\nif err!= nil {\nreturn 0, err\n}\n}\nerr = f.nvmc.SetCONFIG_WEN(false)\nif err!= nil {\nreturn 0, err\n}\nreturn len(p), nil\n}", "CodeBleu_score": 35.96019503648682}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off >= f.Size() {\n\t\treturn 0, errors.New(\"offset out of bounds\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"offset + length out of bounds\")\n\t}\n\t// calculate start address for writing\n\tstartAddr := uintptr(f.FlashDataStart) + uintptr(off)\n\t// pad byte slice to fit write block size\n\tpadLen := (f.WriteBlockSize - (len(p) % f.WriteBlockSize)) % f.WriteBlockSize\n\tpad := make([]byte, padLen)\n\tp = append(p, pad...)\n\t// enable write mode\n\tnrf.NVMC.SetCONFIG_WEN(1)\n\t// write data in blocks\n\tfor i := 0; i < len(p); i += f.WriteBlockSize {\n\t\tif i+f.WriteBlockSize > len(p) {\n\t\t\tnrf.FLASH.SetADDR(startAddr + uintptr(i))\n\t\t\tnrf.FLASH.SetDATA(binary.LittleEndian.Uint32(p[i:]))\n\t\t\tnrf.FLASH.SetCMD(nrf.FLASH_CMD_WRITE_WORD)\n\t\t\twaitWhileFlashBusy()\n\t\t} else {\n\t\t\tnrf.FLASH.SetADDR(startAddr + uintptr(i))\n\t\t\tnrf.FLASH.SetDATA(binary.LittleEndian.Uint32(p[i : i+f.WriteBlockSize]))\n\t\t\tnrf.FLASH.SetCMD(nrf.FLASH_CMD_WRITE_BLOCK)\n\t\t\twaitWhileFlashBusy()\n\t\t}\n\t}\n\t// disable write mode\n\tnrf.NVMC.SetCONFIG_WEN(0)\n\treturn len(p), nil\n}", "CodeBleu_score": 36.95619215692166}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the provided file descriptor and check for errors.\n\tnewFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory using \"syscall.Fdopendir\" until it either succeeds or encounters an error other than \"syscall.EINTR\".\n\tfor {\n\t\tdir, err := syscall.Fdopendir(newFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t} else if err!= syscall.EINTR {\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 49.9275477506235}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdirFd := fd\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dirFd)\n\t\tif err!= nil {\n\t\t\tif err!= syscall.EINTR {\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\t\t} else {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 40.38262180630953}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdirFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(dirFd)\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dirFd)\n\t\tif err == nil {\n\t\t\treturn dir, \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 57.02362378336889}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_app_desc_t app_desc;\n\tesp_err_t err = esp_ota_get_running_partition(&app_desc);\n\tif (err!= ESP_OK) {\n\t\treturn 0;\n\t}\n\tif (response == SZ_FREE) {\n\t\treturn app_desc.app_size;\n\t} else {\n\t\treturn app_desc.size;\n\t}\n}", "CodeBleu_score": 30.94151518631415}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t partition;\n\tesp_ota_get_running_partition(&partition);\n\n\tif (response == sketchSize_t::free) {\n\t\treturn partition.size - partition.data_len;\n\t} else {\n\t\treturn partition.size;\n\t}\n}", "CodeBleu_score": 28.14171406169532}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_ota_img_states_t state;\n\tesp_ota_get_running_partition(&state);\n\tif (response == SIZESKETCH) {\n\t\treturn state.app_size;\n\t} else {\n\t\treturn state.total_size;\n\t}\n}", "CodeBleu_score": 23.193500560566346}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t disk_sectors;\n\tuint32_t disk_size;\n\tuint32_t root_entry_size;\n\tuint32_t root_entry_sector;\n\tuint32_t root_entry_offset;\n\tuint32_t root_entry_index;\n\tuint32_t root_entry_data_size;\n\tuint32_t root_entry_data_offset;\n\tuint32_t root_entry_data_index;\n\tuint32_t root_entry_data_sector;\n\tuint32_t root_entry_data_offset_in_sector;\n\tuint32_t root_entry_data_size_in_sector;\n\tuint32_t root_entry_data_size_in_sector_aligned;\n\tuint32_t root_entry_data_size_in_sector_aligned_aligned;\n\tuint32_t root_entry_data_size_in_sector_aligned_aligned_aligned;\n\tuint32_t root_entry_data_size_in_sector_aligned_aligned_aligned_aligned;\n\tuint32_t root_entry_data_size_in_sector_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t root_entry_data_size_in_sector_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t root_entry_data_size_in_sector_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t root_entry_data_size_in_sector_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t root_entry_data_size_in_sector_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t root_entry_data_size_in_sector_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned;\n\tuint32_t root_entry_data_size_in_sector_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned", "CodeBleu_score": 6.241535548709018}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t required_sectors;\n\tuint32_t disk_sectors;\n\tuint32_t disk_size_sectors;\n\tuint32_t disk_size_sectors_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded;\n\tuint32_t disk_size_sectors_rounded_rounded_rounded_rounded_rounded_rounded", "CodeBleu_score": 7.432020799671236}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t disk_sectors = 0;\n\tuint32_t disk_size_sectors = 0;\n\tuint32_t disk_size_bytes = 0;\n\tuint32_t disk_size_kb = 0;\n\tuint32_t disk_size_mb = 0;\n\tuint32_t disk_size_gb = 0;\n\tuint32_t disk_size_tb = 0;\n\tuint32_t disk_size_pb = 0;\n\tuint32_t disk_size_eb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n\tuint32_t disk_size_yb = 0;\n\tuint32_t disk_size_zb = 0;\n", "CodeBleu_score": 8.984180284649302}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tsize_t sector_size = esp_partition_get_size(partition);\n\tif (offset % sector_size!= 0) {\n\t\tESP_LOGE(TAG, \"Offset %d is not aligned with the sector size %d\", offset, sector_size);\n\t\terr = ESP_ERR_INVALID_ARG;\n\t} else {\n\t\tif (esp_partition_erase_range(partition, offset, sector_size)!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Partition erase failed\");\n\t\t\terr = ESP_ERR_INVALID_ARG;\n\t\t} else {\n\t\t\tif (esp_partition_write(partition, offset, data, size)!= ESP_OK) {\n\t\t\t\tESP_LOGE(TAG, \"Partition write failed\");\n\t\t\t\terr = ESP_ERR_INVALID_ARG;\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}", "CodeBleu_score": 51.1347746048032}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tuint32_t sector_size = esp_partition_get_size(partition);\n\tuint32_t sector_offset = offset & (sector_size - 1);\n\tif (sector_offset + size > sector_size) {\n\t\tESP_LOGE(TAG, \"Write operation is not aligned with flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (esp_partition_erase_range(partition, sector_offset, sector_size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase flash sector\");\n\t\treturn ESP_ERR_INVALID_STATE;\n\t}\n\tif (esp_partition_write(partition, sector_offset, data, size)!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write to flash\");\n\t\treturn ESP_ERR_INVALID_STATE;\n\t}\n\treturn err;\n}", "CodeBleu_score": 44.50556409280003}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tuint32_t sector_size = esp_partition_get_info(partition)->size / esp_partition_get_info(partition)->sector_size;\n\tif (offset % sector_size!= 0) {\n\t\tESP_LOGE(TAG, \"Offset %u is not aligned with sector size %u\", offset, sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\terr = esp_partition_erase_range(partition, offset, sector_size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase sector at offset %u\", offset);\n\t\treturn err;\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write to partition at offset %u\", offset);\n\t}\n\treturn err;\n}", "CodeBleu_score": 54.56452895374696}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = strlen(in);\n\tsize_t outlen = 0;\n\n\tfor (size_t i = 0; i < len; i += 2) {\n\t\tif (outlen >= maxlen) {\n\t\t\tbreak;\n\t\t}\n\t\tunsigned char byte = 0;\n\t\tbyte |= hex_char_to_byte(in[i]);\n\t\tbyte |= (hex_char_to_byte(in[i + 1]) << 4);\n\t\tout[outlen++] = byte;\n\t}\n\n\treturn outlen;\n}", "CodeBleu_score": 36.152216489010655}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = strlen(in);\n\tsize_t outlen = 0;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tif (isxdigit(in[i])) {\n\t\t\tout[outlen++] = hex_char_to_byte(in[i]);\n\t\t\tif (outlen == maxlen)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn outlen;\n}", "CodeBleu_score": 29.98468067201291}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t len = strlen(in);\n\tsize_t i = 0;\n\tsize_t j = 0;\n\tfor (; i < len; i += 2) {\n\t\tif (j >= maxlen) {\n\t\t\tbreak;\n\t\t}\n\t\tunsigned char byte = hex_char_to_byte(in[i]);\n\t\tif (byte == 0xFF) {\n\t\t\tbreak;\n\t\t}\n\t\tout[j++] = byte;\n\t}\n\treturn j;\n}", "CodeBleu_score": 33.63455934595545}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (m_pRingBuffer == NULL || m_pLock == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(m_pLock, 1000) == pdTRUE) {\n\t\tint freeSize = xRingbufferGetCurFreeSize(m_pRingBuffer);\n\t\txSemaphoreGive(m_pLock);\n\t\treturn freeSize;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 63.540661400180085}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (txRingBuffer!= NULL && txRingBufferLock!= NULL) {\n\t\tif (xSemaphoreTake(txRingBufferLock, txRingBufferTimeout) == pdTRUE) {\n\t\t\tuint32_t freeSize = xRingbufferGetCurFreeSize(txRingBuffer);\n\t\t\txSemaphoreGive(txRingBufferLock);\n\t\t\treturn freeSize;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 54.51169296604963}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (m_txRingBuffer == NULL || m_txLock == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(m_txLock, 10) == pdTRUE) {\n\t\tint freeSize = xRingbufferGetCurFreeSize(m_txRingBuffer);\n\t\txSemaphoreGive(m_txLock);\n\t\treturn freeSize;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 63.865508069549236}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\t_rxTimeout = onlyOnTimeout? 0 : 1000;\n\tif (_onReceiveCB!= NULL) {\n\t\t_rxTimeout = 1000;\n\t\t_rxFIFOFullThreshold = 1;\n\t\tif (_rxTaskHandle == NULL) {\n\t\t\t_createEventTask();\n\t\t}\n\t} else {\n\t\t_rxFIFOFullThreshold = 0;\n\t\tif (_rxTaskHandle!= NULL) {\n\t\t\tvTaskDelete(_rxTaskHandle);\n\t\t\t_rxTaskHandle = NULL;\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 46.862571293750754}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\t_rxTimeout.onlyOnTimeout = onlyOnTimeout;\n\tif (_onReceiveCB!= NULL) {\n\t\t_rxTimeout.fifoFullThreshold = _rxBuffer.getFreeSpace();\n\t\tif (_rxTimeout.taskHandle == NULL) {\n\t\t\t_createEventTask();\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 39.69283904247797}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\tif (function!= NULL) {\n\t\t_rxTimeout = _onlyOnTimeout? 0 : 1;\n\t\t_rxTimeout_ms = 0;\n\t\tuartSetRxFIFOFull(_rxFIFOFullThreshold);\n\t\tif (_eventTask == NULL) {\n\t\t\t_eventTask = xTaskCreate(eventTask, \"eventTask\", configMINIMAL_STACK_SIZE, NULL, 1, NULL);\n\t\t}\n\t} else {\n\t\t_rxTimeout = 0;\n\t\t_rxTimeout_ms = 0;\n\t\tuartSetRxFIFOFull(0);\n\t\tif (_eventTask!= NULL) {\n\t\t\tvTaskDelete(_eventTask);\n\t\t\t_eventTask = NULL;\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 45.21376873080774}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t count = 0;\n\twhile (count < length) {\n\t\tint c = timedRead();\n\t\tif (c == -1) break;\n\t\tif (c == terminator) break;\n\t\t*buffer++ = (char)c;\n\t\tcount++;\n\t}\n\t*buffer = 0;\n\treturn count;\n}", "CodeBleu_score": 57.23127699068697}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t len = 0;\n\twhile (len < length) {\n\t\tchar c = timedRead();\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[len] = c;\n\t\tlen++;\n\t}\n\tbuffer[len] = 0;\n\treturn len;\n}", "CodeBleu_score": 53.41939551311903}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t count = 0;\n\twhile (count < length) {\n\t\tchar c = timedRead();\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = c;\n\t\tcount++;\n\t}\n\t*buffer = 0;\n\treturn count;\n}", "CodeBleu_score": 55.71179302928184}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"Tone on pin %d, frequency %d, duration %ld\", pin, frequency, duration);\n\tif (xQueueIsQueueFullFromISR(queue) == pdTRUE) {\n\t\tlog_e(\"Tone on pin %d, frequency %d, duration %ld: queue is full\", pin, frequency, duration);\n\t} else {\n\t\tif (xSemaphoreTake(pin_mutex[pin], portMAX_DELAY) == pdTRUE) {\n\t\t\ttone_init(pin);\n\t\t\txQueueSendFromISR(queue, &tone_command, NULL);\n\t\t} else {\n\t\t\tlog_e(\"Tone on pin %d, frequency %d, duration %ld: pin %d is already in use\", pin, frequency, duration, pin);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.90756473410589}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (xQueueSend(xQueue, &pin, 0) == pdPASS) {\n\t\tlog_d(\"Pin: %d, Frequency: %d, Duration: %ld\", pin, frequency, duration);\n\t\tif (xQueueSend(xQueue, &frequency, 0) == pdPASS) {\n\t\t\tlog_d(\"Frequency: %d\", frequency);\n\t\t\tif (xQueueSend(xQueue, &duration, 0) == pdPASS) {\n\t\t\t\tlog_d(\"Duration: %ld\", duration);\n\t\t\t\tlog_d(\"Starting tone on pin %d\", pin);\n\t\t\t\ttone_init(pin, frequency);\n\t\t\t\ttone_start(pin, frequency, duration);\n\t\t\t\tlog_d(\"Tone on pin %d stopped\", pin);\n\t\t\t} else {\n\t\t\t\tlog_e(\"Could not send duration to queue\");\n\t\t\t}\n\t\t} else {\n\t\t\tlog_e(\"Could not send frequency to queue\");\n\t\t}\n\t} else {\n\t\tlog_e(\"Could not send pin to queue\");\n\t}\n}", "CodeBleu_score": 41.890408119082124}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"tone(%d, %d, %d)\", pin, frequency, duration);\n\tif (pin == 0) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 0\", pin, frequency, duration);\n\t\treturn;\n\t}\n\tif (pin == 1) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 1\", pin, frequency, duration);\n\t\treturn;\n\t}\n\tif (pin == 2) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 2\", pin, frequency, duration);\n\t\treturn;\n\t}\n\tif (pin == 3) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 3\", pin, frequency, duration);\n\t\treturn;\n\t}\n\tif (pin == 4) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 4\", pin, frequency, duration);\n\t\treturn;\n\t}\n\tif (pin == 5) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 5\", pin, frequency, duration);\n\t\treturn;\n\t}\n\tif (pin == 6) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 6\", pin, frequency, duration);\n\t\treturn;\n\t}\n\tif (pin == 7) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 7\", pin, frequency, duration);\n\t\treturn;\n\t}\n\tif (pin == 8) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 8\", pin, frequency, duration);\n\t\treturn;\n\t}\n\tif (pin == 9) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 9\", pin, frequency, duration);\n\t\treturn;\n\t}\n\tif (pin == 10) {\n\t\tlog_e(\"tone(%d, %d, %d) - pin is 10\", pin, frequency, duration);\n\t", "CodeBleu_score": 36.72837467829867}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usb_started) {\n\t\twebusb_enabled = enabled;\n\t\treturn true;\n\t}\n\tif (enabled) {\n\t\tif (usb_version < 0x0210) {\n\t\t\tusb_version = 0x0210;\n\t\t\tusb_set_version(usb_version);\n\t\t}\n\t} else {\n\t\tusb_version = 0x0200;\n\t\tusb_set_version(usb_version);\n\t}\n\twebusb_enabled = enabled;\n\treturn false;\n}", "CodeBleu_score": 57.91071248371917}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usbStarted) {\n\t\tif (enabled) {\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\tusbVersion = 0x0210;\n\t\t\t}\n\t\t\twebUSBEnabled = true;\n\t\t} else {\n\t\t\twebUSBEnabled = false;\n\t\t}\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 43.291228011360026}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usb_started) {\n\t\twebusb_enabled = enabled;\n\t\treturn true;\n\t}\n\tif (enabled) {\n\t\tif (usb_version < 0x0210) {\n\t\t\tusb_version = 0x0210;\n\t\t\tusb_update_version();\n\t\t}\n\t}\n\twebusb_enabled = enabled;\n\treturn false;\n}", "CodeBleu_score": 60.90008837835773}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint16_t rx_len = tud_cdc_n_read(0, _rx_buf, sizeof(_rx_buf));\n\tif (rx_len > 0) {\n\t\tfor (uint16_t i = 0; i < rx_len; i++) {\n\t\t\tif (xQueueSend(_rx_queue, &_rx_buf[i], 0)!= pdPASS) {\n\t\t\t\tlog_e(\"Failed to send to rx queue\");\n\t\t\t\ttud_cdc_n_write(0, _rx_buf, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttud_cdc_n_write(0, _rx_buf, rx_len);\n\t}\n}", "CodeBleu_score": 22.557115369643938}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t rx_buf[64];\n\tint rx_len = tud_cdc_n_read(rx_buf, sizeof(rx_buf));\n\tif (rx_len > 0) {\n\t\tif (xQueueSend(rx_queue, rx_buf, 0)!= pdTRUE) {\n\t\t\tlog_e(\"CDC RX queue overflow\");\n\t\t} else {\n\t\t\ttud_cdc_n_write_flush();\n\t\t}\n\t}\n}", "CodeBleu_score": 11.615468336750121}, {"code": "void USBCDC::_onRX(){\n\t\t/*\n\t * The following code is a modified version of the original code from the TinyUSB library.\n\t * The original code is licensed under the MIT license.\n\t * The original code can be found at: https://github.com/hathach/tinyusb\n\t */\n\n\t// read data\n\tuint32_t rx_bytes = 0;\n\tuint8_t  rx_buffer[64];\n\ttud_cdc_n_read(0, rx_buffer, sizeof(rx_buffer), &rx_bytes);\n\n\t// send data to queue\n\tfor (uint32_t i = 0; i < rx_bytes; i++) {\n\t\tif (xQueueSend(m_rx_queue, &rx_buffer[i], 0)!= pdPASS) {\n\t\t\t// post overflow event\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0);\n\t\t\ttud_cdc_n_write_flush(0", "CodeBleu_score": 24.75997395155658}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\ta.writeJSON(res, http.StatusBadRequest, \"Missing required query parameter: name\")\n\t\treturn\n\t}\n\n\trobot, err := a.master.Robot(name)\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusNotFound, \"No robot found with the specified name\")\n\t\treturn\n\t}\n\n\tdevices := robot.Devices()\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 35.70440001239877}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\tif robotName == \"\" {\n\t\thttp.Error(res, \"No robot name specified\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\ta.writeJSON(res, robot.Devices())\n}", "CodeBleu_score": 34.072689604587794}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintln(res, fmt.Sprintf(\"No robot found with name '%s'\", robotName))\n\t\treturn\n\t}\n\tdevices := robot.Devices()\n\tdevicesJSON, err := json.Marshal(devices)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintln(res, fmt.Sprintf(\"Error marshaling devices: %s\", err.Error()))\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(devicesJSON)\n}", "CodeBleu_score": 38.01256262822128}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL\n\trobotName := req.URL.Path[len(\"/api/robots/\"):]\n\n\t// Check if the robot exists\n\trobot, ok := a.master.Robot(robotName)\n\tif!ok {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot with name %s found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Iterate through the connections of the robot\n\tconnections := robot.Connections()\n\tvar jsonConnections []interface{}\n\tfor _, c := range connections {\n\t\tjsonConnections = append(jsonConnections, c.ToJSON())\n\t}\n\n\t// Convert the connections to JSON format\n\tjsonBytes, err := json.Marshal(jsonConnections)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the JSON response to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonBytes)\n}", "CodeBleu_score": 48.12094412697121}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tif robot, ok := a.master.Robot(robotName); ok {\n\t\tconnections := robot.Connections()\n\t\tconnectionsJSON, err := json.Marshal(connections)\n\t\tif err!= nil {\n\t\t\ta.writeJSON(res, http.StatusInternalServerError, \"Error converting connections to JSON\")\n\t\t\treturn\n\t\t}\n\t\ta.writeJSON(res, http.StatusOK, connectionsJSON)\n\t\treturn\n\t}\n\ta.writeJSON(res, http.StatusNotFound, \"No robot with the name \"+robotName+\" was found\")\n}", "CodeBleu_score": 39.891622546683145}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot, ok := a.master.Robot(robotName)\n\tif!ok {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"No robot with the specified name was found.\"})\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\tif len(connections) == 0 {\n\t\ta.writeJSON(res, http.StatusOK, map[string]string{\"error\": \"This robot has no connections.\"})\n\t\treturn\n\t}\n\n\tvar jsonConnections []map[string]interface{}\n\tfor _, connection := range connections {\n\t\tjsonConnection := map[string]interface{}{\n\t\t\t\"name\":     connection.Name(),\n\t\t\t\"type\":     connection.Type(),\n\t\t\t\"driver\":   connection.Driver(),\n\t\t\t\"protocol\": connection.Protocol(),\n\t\t}\n\t\tjsonConnections = append(jsonConnections, jsonConnection)\n\t}\n\n\ta.writeJSON(res, http.StatusOK, jsonConnections)\n}", "CodeBleu_score": 48.34885960310762}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, fmt.Sprintf(\"Robot %s not found\", req.URL.Query().Get(\":robot\")))\n\t\treturn\n\t}\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, fmt.Sprintf(\"Device %s not found\", req.URL.Query().Get(\":device\")))\n\t\treturn\n\t}\n\tcommand := req.URL.Query().Get(\":command\")\n\tif command == \"\" {\n\t\ta.writeJSON(res, http.StatusNotFound, \"No command specified\")\n\t\treturn\n\t}\n\terr := device.(gobot.Commander).Command(command)\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\ta.writeJSON(res, http.StatusOK, \"OK\")\n}", "CodeBleu_score": 49.45261830124299}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := req.URL.Query().Get(\":robot\")\n\tdevice := req.URL.Query().Get(\":device\")\n\tcommand := req.URL.Query().Get(\":command\")\n\tif robot == \"\" || device == \"\" || command == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"Invalid request: missing robot, device, or command\"))\n\t\treturn\n\t}\n\n\tif device, err := a.master.Robot(robot).Device(device); err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Device %s not found\", device)))\n\t\treturn\n\t} else {\n\t\tif commander, ok := device.(gobot.Commander); ok {\n\t\t\tif err := commander.Command(command); err!= nil {\n\t\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\t\tres.Write([]byte(fmt.Sprintf(\"Error executing command %s: %s\", command, err.Error())))\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tres.WriteHeader(http.StatusNotFound)\n\t\t\tres.Write([]byte(fmt.Sprintf(\"Device %s is not a commander\", device)))\n\t\t\treturn\n\t\t}\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(\"Command executed successfully\"))\n}", "CodeBleu_score": 44.323326858191614}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\ta.writeJSON(res, http.StatusOK, a.executeCommand(req.URL.Query().Get(\":robot\"), req.URL.Query().Get(\":device\"), req.URL.Query().Get(\":command\")))\n}", "CodeBleu_score": 26.850175352465932}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\treturn\n\t\t}\n\t\t// Proceed to the next handler\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.96926090372318}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || user!= username || pass!=  {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Proceed to the next handler.\n\t}\n}", "CodeBleu_score": 50.05767686056767}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Missing Authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!strings.HasPrefix(auth, \"Basic \") {\n\t\t\thttp.Error(w, \"Invalid Authorization header format\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, \"Invalid Authorization header format\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 ||!secureCompare([]byte(username), pair[0]) ||!secureCompare([]byte(password), pair[1]) {\n\t\t\thttp.Error(w, \"Invalid Authorization credentials\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 47.09769708773478}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.sensorCfg.scale(raw)\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 48.19692632937771}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif!a.Connection().SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"Connection does not support analog reading\")\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := a.sensorCfg.scale(raw)\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 47.88898590076857}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection().SupportsAnalogRead() {\n\t\trawValue, err := reader.AnalogRead(a.Pin)\n\t\tif err!= nil {\n\t\t\treturn 0, 0, err\n\t\t}\n\n\t\tscaledValue := a.sensorCfg.scale(rawValue)\n\t\ta.lastRead = scaledValue\n\t\treturn rawValue, scaledValue, nil\n\t}\n\treturn 0, 0, fmt.Errorf(\"Connection does not support analog reading\")\n}", "CodeBleu_score": 48.81534907641568}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(DefaultName)\n\treturn d\n}", "CodeBleu_score": 21.597155795721935}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n}", "CodeBleu_score": 35.85271778311411}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n}", "CodeBleu_score": 35.85271778311411}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(MFRC522_CommandReg, MFRC522_SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tif d.readByteData(MFRC522_CommandReg)&MFRC522_SoftReset!= 0 {\n\t\treturn fmt.Errorf(\"Soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 28.15553562585554}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(MFRC522_CommandReg, MFRC522_SoftReset)\n\ttime.Sleep(2 * time.Millisecond)\n\tif d.readByteData(MFRC522_CommandReg) & MFRC522_Reset!= 0 {\n\t\treturn fmt.Errorf(\"MFRC522 soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.38882126086071}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Reset the MFRC522\n\td.writeByteData(MFRC522_COMMAND_REG, MFRC522_SOFTRESET)\n\n\t// Wait for the PowerDown bit to be cleared\n\tfor i := 0; i < 100; i++ {\n\t\tif d.readByteData(MFRC522_COMMAND_REG)&MFRC522_SOFTRESET!= 0 {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Check if PowerDown bit is cleared\n\tif d.readByteData(MFRC522_COMMAND_REG)&MFRC522_SOFTRESET!= 0 {\n\t\treturn fmt.Errorf(\"MFRC522: SoftReset: Timeout waiting for PowerDown bit to clear\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 34.16161805086127}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Get the number of bytes available in the FIFO buffer\n\tn, err := d.readByteData(MFRC522_FIFOLEVEL)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the FIFO is actually full\n\tif n > 64 {\n\t\treturn 0, fmt.Errorf(\"FIFO overflow\")\n\t}\n\n\t// Check if the FIFO is empty\n\tif n == 0 {\n\t\treturn 0, fmt.Errorf(\"FIFO empty\")\n\t}\n\n\t// Check if the FIFO is not empty and has enough bytes to satisfy the length requirement\n\tif n < len(backData) {\n\t\treturn 0, fmt.Errorf(\"FIFO not enough bytes\")\n\t}\n\n\t// Read the bytes from the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData(MFRC522_FIFODATA)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tcontrol, err := d.readByteData(MFRC522_CONTROL)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn control, nil\n}", "CodeBleu_score": 51.6102980603292}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check that the FIFO has enough bytes to read\n\tn, err := d.readByteData(MFRC522_FIFODataReg, 1)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif n < len(backData) {\n\t\treturn 0, fmt.Errorf(\"not enough bytes in FIFO\")\n\t}\n\n\t// Read the bytes from the FIFO\n\tif err := d.readByteData(MFRC522_FIFODataReg, len(backData), backData); err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Read the control register\n\tn, err = d.readByteData(MFRC522_ControlReg, 1)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn n, nil\n}", "CodeBleu_score": 39.49046214260294}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Get the number of bytes currently in the FIFO\n\tn, err := d.readByteRegister(MFRC522_FIFOLEVEL)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the FIFO is empty\n\tif n == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// Check if the FIFO is not empty and has enough bytes to read\n\tif n < uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"FIFO not empty but has not enough bytes\")\n\t}\n\n\t// Read the data from the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readByteData()\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the last bits received from the FIFO\n\tlastBits, err := d.readByteRegister(MFRC522_CONTROL)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 50.82858289915788}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"Halt command\")\n\t}\n\n\thaltCommand := []byte{PICC_CMD_HLTA}\n\thaltCommand = append(haltCommand, d.calculateCRC(haltCommand)...)\n\n\tif d.debug {\n\t\tfmt.Println(\"Sending halt command:\", hex.EncodeToString(haltCommand))\n\t}\n\n\t_, err := d.communicateWithPICC(haltCommand, nil)\n\tif err!= nil {\n\t\treturn fmt.Errorf(\"piccHalt: %v\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 40.6668493462555}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"piccHalt\")\n\t}\n\n\tcmd := []byte{PICC_CMD_HLTA}\n\n\t// Calculate CRC_A\n\t// This is done by sending the PICC the first byte\n\t// of the command via the CRC_A register and then\n\t// reading back the result from the CRC_A register.\n\t// CRC_A calculation is used because CRC_A is never\n\t// stored in the PICC and cannot be read from the PICC.\n\t// CRC_A is also generated on the PCD.\n\td.calculateCRC(cmd, &cmd[1])\n\n\t// Send the command.\n\t// The PICC will be put to sleep now; sleeping is\n\t// only possible in all other states other than\n\t// state 6 (HALT).\n\tif err := d.communicateWithPICC(cmd, nil, nil); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 24.42832130830375}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Reset the command buffer\n\td.clearBuffer()\n\n\t// Construct an NAK response command\n\td.buffer[0] = 0x50\n\td.buffer[1] = 0x00\n\n\t// Calculate CRC_A\n\tif d.calculateCRC(d.buffer, 2)!= nil {\n\t\treturn fmt.Errorf(\"piccHalt: CRC_A calculation error\")\n\t}\n\n\t// Send the command.\n\t// The standard says:\n\t//\t\tIf the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the\n\t//\t\tcommand, this response is not valid.\n\t// We handle the possibility of a slow PICC by waiting 1 ms before each response.\n\ttime.Sleep(1 * time.Millisecond)\n\tif d.communicateWithPICC(d.buffer, 2, d.buffer, 2)!= nil {\n\t\treturn fmt.Errorf(\"piccHalt: communicateWithPICC error\")\n\t}\n\n\t// Verify CRC_A - return error if the CRC_A is not valid.\n\tif d.buffer[0]!= 0x00 || d.buffer[1]!= 0x00 {\n\t\treturn fmt.Errorf(\"piccHalt: CRC_A invalid\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 27.80737770371105}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Clear the buffers\n\td.clearBuffer()\n\t// Prepare MFRC522\n\td.PCD_WriteRegister(MFRC522_CommandReg, MFRC522_PCD_IDLE) // Stop any active command.\n\t// Prepare the MFRC522\n\td.PCD_WriteRegister(MFRC522_CommandReg, MFRC522_PCD_TRANSCEIVE) // Transceive mode uses the FIFO.\n\t// Write bit-address block\n\td.PCD_WriteRegister(MFRC522_BitFramingReg, 0x00) // TxLastBists = BitFramingReg[2..0]\n\td.PCD_Write(MFRC522_CommandReg, MFRC522_PCD_TRANSCEIVE) // Start the transmission\n\t// Tell the MFRC522 how many bytes to expect: 1 byte address + 16 bytes data\n\td.PCD_Write(MFRC522_BitFramingReg, 0x10) // TxLastBits = BitFramingReg[2..0]\n\t// Start the transmission\n\td.PCD_Write(MFRC522_CommandReg, MFRC522_PCD_TRANSCEIVE)\n\t// Store the received data in a local variable\n\treceivedData := d.PCD_Read(MFRC522_FIFOLevelReg) // Number of bytes received in the FIFO\n\t// Print the data received\n\tfmt.Println(\"Received data: \", receivedData)\n\t// Verify CRC\n\tif!d.calculateCRC(receivedData, receivedData) {\n\t\treturn nil, errors.New(\"CRC is not valid\")\n\t}\n\t// Return data and error\n\treturn receivedData, nil\n}", "CodeBleu_score": 32.682704340867765}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t//\tfmt.Println(\"piccRead\")\n\t//\tfmt.Println(\"block\", block)\n\n\t//\tfmt.Println(\"d.status\", d.status)\n\t//\tfmt.Println(\"d.lastCommand\", d.lastCommand)\n\t//\tfmt.Println(\"d.lastResult\", d.lastResult)\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n\t//\tfmt.Println(\"d.serNumSize\", d.serNumSize)\n\n\t//\tfmt.Println(\"d.serNum\", d.serNum)\n", "CodeBleu_score": 3.922694197772931}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare the MFRC522\n\tif err := d.resetToReadyState(); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Prepare the MFRC522\n\tif err := d.clearBitMask(d.status2Reg, 0x08); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Prepare the buffer to store the returned data\n\tbuffer := make([]byte, 16)\n\n\t// Prepare the command\n\tcmd := []byte{PICC_CMD_MF_READ, block}\n\n\t// Calculate CRC_A\n\tif err := d.calculateCRC(cmd, cmd[2]); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Transmit the command\n\tif err := d.transceive(cmd, buffer, 18); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Verify CRC_A\n\tif err := d.checkCRC(buffer, 16); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn buffer, nil\n}", "CodeBleu_score": 43.83640731895628}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"Answer buffer too short\")\n\t}\n\td.clearRegisterBitMask(registerCollReg, 0x80)\n\tif reqMode == PICC_REQIDL {\n\t\td.writeRegister(registerBitFramingReg, 0x00)\n\t} else if reqMode == PICC_REQALL {\n\t\td.writeRegister(registerBitFramingReg, 0x07)\n\t} else {\n\t\treturn fmt.Errorf(\"Unknown reqMode\")\n\t}\n\treturn d.communicateWithPICC(PICC_CMD_REQA, reqMode, answer)\n}", "CodeBleu_score": 35.474355236294116}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"buffer too small\")\n\t}\n\t// Clear the register bits\n\td.clearRegisterBitMask(MFRC522_CollReg, 0x80)\n\n\t// Clear the buffer by filling it with 0\n\tfor i := range answer {\n\t\tanswer[i] = 0\n\t}\n\n\t// Start the transmission\n\tif err := d.transceive(reqMode, answer, answer); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.2693963241938}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Reset the register\n\td.clearRegisterBitMask(MFRC522_REG_Coll, 0x80)\n\n\t// Auxiliary buffer\n\tbuf := []byte{0x26}\n\n\t// Apply the requested mode.\n\tbuf[0] = reqMode\n\n\t// Perform the PICC request\n\tif err := d.transceive(buf, 1, answer, 0); err!= nil {\n\t\treturn err\n\t}\n\n\t// Error checking\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"PICC response too short: %d bytes\", len(answer))\n\t}\n\n\t// The PICC must be able to support CRC validation\n\tif (answer[0] & 0x04) == 0 {\n\t\treturn fmt.Errorf(\"PICC does not support CRC validation\")\n\t}\n\n\t// Check CRC_A\n\tif err := d.checkCRC(answer[0:1], answer[1]); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.32109498660258}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a step\n\td.stepPin.Low()\n\ttime.Sleep(d.getDelayPerStep())\n\td.stepPin.High()\n\n\t// Increment or decrement the step number\n\tif d.direction == FORWARD {\n\t\td.stepNumber++\n\t} else if d.direction == BACKWARD {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 37.44621505942381}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == 0 {\n\t\treturn errors.New(\"Step pin not set\")\n\t}\n\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.getDelayPerStep())\n\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 69.96975301505893}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif d.direction == FORWARD {\n\t\td.digitalWrite(d.stepPin, LOW)\n\t\ttime.Sleep(d.getDelayPerStep())\n\t\td.digitalWrite(d.stepPin, HIGH)\n\t\td.step++\n\t} else if d.direction == REVERSE {\n\t\td.digitalWrite(d.stepPin, LOW)\n\t\ttime.Sleep(d.getDelayPerStep())\n\t\td.digitalWrite(d.stepPin, HIGH)\n\t\td.step--\n\t}\n\treturn nil\n}", "CodeBleu_score": 43.91213048347831}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.distanceMonitor(\"HCSR04\")\n\treturn nil\n}", "CodeBleu_score": 36.68118795077431}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\treturn nil\n}", "CodeBleu_score": 70.91682385936217}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo d.continuousMeasureDistance()\n\n\treturn nil\n}", "CodeBleu_score": 37.13290469304058}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now().UnixNano()\n\treturn func(channel int, duration time.Duration, name string, id uint32, timestamp uint32) {\n\t\tif channel == 0 {\n\t\t\tstartTimestamp = timestamp\n\t\t\treturn\n\t\t}\n\n\t\t// Calculate the duration of the pulse.\n\t\tduration = time.Duration(timestamp - startTimestamp) * time.Nanosecond\n\n\t\t// Send the duration to a channel.\n\t\td.eventChan <- Event{\n\t\t\tName: name,\n\t\t\tId:   id,\n\t\t\tDuration: duration,\n\t\t}\n\n\t\t// Reset the start timestamp.\n\t\tstartTimestamp = time.Now().UnixNano()\n\t}\n}", "CodeBleu_score": 40.473535066581746}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\treturn func(pin int, duration time.Duration, _ string, _ uint32, _ uint32) {\n\t\tif pin == d.triggerPin {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if pin == d.echoPin {\n\t\t\td.eventChannel <- time.Since(startTimestamp)\n\t\t\tstartTimestamp = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 39.26764111629175}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\treturn func(pin int, duration time.Duration, _ string, _ uint32, _ uint32) {\n\t\tif duration == 0 {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else {\n\t\t\td.durationChannel <- duration\n\t\t\tstartTimestamp = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 40.86473787096424}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\ttimeout := time.After(d.timeout)\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"Timeout while measuring distance\")\n\t\tcase <-d.measurementComplete:\n\t\t\treturn nil\n\t\t}\n\t}\n}", "CodeBleu_score": 32.47714528227679}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor\n\td.emitTrigger()\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measurementComplete:\n\t\t// Measurement completed successfully\n\t\td.measurementComplete = make(chan struct{})\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// Timeout occurred\n\t\treturn fmt.Errorf(\"timeout occurred while measuring distance\")\n\t}\n}", "CodeBleu_score": 39.01669074952141}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.emitTrigger()\n\n\t// Wait for the measurement to complete or for a timeout to occur.\n\tselect {\n\tcase <-d.doneChan:\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout after %d microseconds\", d.timeout)\n\t}\n}", "CodeBleu_score": 30.719998033177166}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if os.environ.get('AUTH_TOKEN'):\n        return os.environ.get('AUTH_TOKEN')\n    try:\n        return self.get_state_item('access_token')\n    except KeyError:\n        pass\n    if self.get_state_item('refresh_token'):\n        try:\n            self.fetch_json_data(\n                'https://api.dropbox.com/oauth2/token',\n                data={\n                    'grant_type':'refresh_token',\n                   'refresh_token': self.get_state_item('refresh_token')\n                }\n            )\n            self.set_state_item('access_token', self.get_state_item('access_token'))\n            self.set_state_item('token_expiration', self.get_state_item('token_expiration'))\n            return self.get_state_item('access_token')\n        except Exception:\n            pass\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 35.314039502874344}, {"code": "def fetch_authentication_token(self)\n\t\n    self.logger.debug('fetch_authentication_token()')\n    try:\n        return self.get_environment_variable('AUTHENTICATION_TOKEN')\n    except KeyError:\n        pass\n    try:\n        return self.get_state_item('AUTHENTICATION_TOKEN')\n    except KeyError:\n        pass\n    try:\n        return self.fetch_refresh_token()\n    except AccountNotAuthorized:\n        pass\n    raise AccountNotAuthorized('Authentication token not found.')\n\n", "CodeBleu_score": 21.85193404074273}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        if self.auth_token:\n            return self.auth_token\n        else:\n            self.auth_token = self.get_state_item(\"auth_token\")\n            if self.auth_token:\n                if self.get_state_item(\"auth_token_expiration_time\") > time.time():\n                    return self.auth_token\n            if self.get_state_item(\"refresh_token\"):\n                self.auth_token = self.fetch_json_data(self.get_state_item(\"refresh_token\"), \"refresh_token\")\n                self.set_state_item(\"auth_token\", self.auth_token)\n                self.set_state_item(\"auth_token_expiration_time\", time.time() + self.auth_token[\"expires_in\"])\n                return self.auth_token\n            raise AccountNotAuthorized\n    except Exception as e:\n        raise AccountNotAuthorized(e)\n\n", "CodeBleu_score": 36.82264633995554}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    self.get_refresh_token\n    self.delete_local_session\n    self.fetch_json_data\n    self.get_refresh_token\n\n", "CodeBleu_score": 15.477796258513376}, {"code": "def logout(self)\n\t\n    self.get_refresh_token\n    self.delete_local_session\n    try:\n        self.fetch_json_data(self.get_url(self.logout_endpoint), self.get_headers(self.get_refresh_token))\n    except AccountError as e:\n        pass\n    return True\n\n", "CodeBleu_score": 33.592904722392305}, {"code": "def logout(self)\n\t\n    self.get_refresh_token\n    self.delete_local_session\n    self.post_json_data\n    return True\n\n", "CodeBleu_score": 12.653987023261164}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result", "CodeBleu_score": 0.4356724253697368}, {"code": "def dump_used_packages(self)\n\t\n    result", "CodeBleu_score": 0.4356724253697368}, {"code": "def dump_used_packages(self)\n\t\n    result", "CodeBleu_score": 0.4356724253697368}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = ProjectConfig.get_instance()\n    if not p.has_env_platform(env):\n        raise UndefinedEnvPlatformError(\"Environment '{}' is not defined\".format(env))\n    platform = p.get_env_platform(env)\n    if targets is None:\n        targets = []\n    return cls(platform, autoinstall, targets)\n\n", "CodeBleu_score": 30.72695274457498}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    try:\n        p = ProjectConfig.get_instance().get(env)\n    except UndefinedEnvPlatformError:\n        return None\n    if targets is None:\n        targets = p.targets\n    return cls.new(p, autoinstall=autoinstall, targets=targets)\n\n", "CodeBleu_score": 32.6807896385252}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = cls.new()\n    p.configure_project_packages(targets=targets, autoinstall=autoinstall)\n    return p\n", "CodeBleu_score": 11.56269444285555}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 64.9342703245996}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us!= 0) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 43.45730378539654}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us!= 0) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 43.45730378539654}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint16_t y = _scrollAddress;\n\tif (y > _height - _fixedAreaHeight) {\n\t\ty = 0;\n\t}\n\ttft.fillRect(_x, y, _width, _fixedAreaHeight, color);\n\tif (y + _fixedAreaHeight < _height) {\n\t\ttft.fillRect(_x, y + _fixedAreaHeight, _width, _height - (y + _fixedAreaHeight), color);\n\t}\n\t_scrollAddress = y + _fixedAreaHeight;\n\treturn y;\n}", "CodeBleu_score": 23.347338010826423}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = scroll_address / tft.height();\n\tif (y > tft.height() - tft.height() / 4) {\n\t\ty = tft.height() - tft.height() / 4;\n\t}\n\ttft.fillRect(0, y, tft.width(), tft.height() / 4, color);\n\tif (y > tft.height() - tft.height() / 4) {\n\t\ty = tft.height() - tft.height() / 4;\n\t}\n\tscroll_address += tft.height() / 4;\n\tif (scroll_address > tft.height() * 3 / 4) {\n\t\tscroll_address = tft.height() / 4;\n\t}\n\treturn y;\n}", "CodeBleu_score": 12.712243188600583}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = tft.getScrollY();\n\ttft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n\ty = (y + tft.fontHeight()) % (tft.height() - tft.fontHeight());\n\tif (y < tft.fontHeight()) {\n\t\ty = tft.fontHeight();\n\t}\n\ttft.setScrollY(y);\n\tscrollAddress = tft.getScrollY();\n\treturn y;\n}", "CodeBleu_score": 15.047208732671265}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (this->setAP(ssids, access_points) == false) {\n\t\treturn false;\n\t}\n\tif (this->setHtml() == false) {\n\t\treturn false;\n\t}\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 61.26578570904242}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\tif (!this->startPortal()) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 60.50206137898023}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// Set up access points\n\tfor (int i = 0; i < ssids->length(); i++) {\n\t\tthis->setAP(ssids->get(i), access_points->get(i));\n\t}\n\n\t// Set up HTML content\n\tthis->setHtml(html_content);\n\n\t// Start the portal\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 52.35291456513554}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tthis->init_queue();\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 18.804292248235193}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag == false) {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 13.49682550352348}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tthis->text.clear();\n\t\tthis->text_in.clear();\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 21.784752399011136}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\tthis->queue->clear();\n\t\tdelete this->queue;\n\t}\n\tthis->queue = new QQueue<QString>();\n}", "CodeBleu_score": 19.806001967625665}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue!= NULL) {\n\t\tthis->queue->clear();\n\t\tdelete this->queue;\n\t\tthis->queue = NULL;\n\t}\n\n\tthis->queue = new queue<string>();\n}", "CodeBleu_score": 20.77698706499494}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue!= NULL) {\n\t\tdelete this->queue;\n\t}\n\tthis->queue = new Queue<NmeaSentence>();\n}", "CodeBleu_score": 16.23533138529949}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tint32_t x;\n\tint32_t y;\n\tint32_t w;\n\tint32_t h;\n\tint32_t i;\n\tint32_t j;\n\tint32_t c;\n\tint32_t size;\n\tuint32_t *buf;\n\n\tlv_disp_flush_ready(disp); /* Indicate you are ready with the flushing */\n\n\t/* Set the address window to the area to be updated */\n\tdisplay_obj.tft.setAddrWindow(area->x1, area->y1, area->x2 - area->x1 + 1, area->y2 - area->y1 + 1);\n\n\t/* Write data to the display */\n\tfor(y = area->y1; y <= area->y2; y++) {\n\t\tfor(x = area->x1; x <= area->x2; x++) {\n\t\t\tc = *(color_p++);\n\t\t\tdisplay_obj.tft.writeColor(c);\n\t\t}\n\t}\n\n\t/* Update the flushing state and inform the driver about the flushing result.\n\t * 'false' means 'ok done' and 'true' means 'error occurred' */\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 61.234403124112355}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\t//LVGL_LOG_TRACE(\"lv_disp_drv_t: %p; area: %p; color_p: %p\", disp, area, color_p);\n\n\t//LVGL_LOG_TRACE(\"area: %d, %d, %d, %d\", area->x1, area->y1, area->x2, area->y2);\n\n\t//LVGL_LOG_TRACE(\"color_p: %d, %d, %d\", color_p->full, color_p->ch.red, color_p->ch.green);\n\n\t//LVGL_LOG_TRACE(\"disp->user_data: %p\", disp->user_data);\n\n\t//LVGL_LOG_TRACE(\"disp->user_data->disp_drv: %p\", disp->user_data->disp_drv);\n\n\t//LVGL_LOG_TRACE(\"disp->user_data->disp_drv->disp_buf: %p\", disp->user_data->disp_drv->disp_buf);\n\n\t//LVGL_LOG_TRACE(\"disp->user_data->disp_drv->disp_buf->buf: %p\", disp->user_data->disp_drv->disp_buf->buf);\n\n\t//LVGL_LOG_TRACE(\"disp->user_data->disp_drv->disp_buf->buf[0]: %d\", disp->user_data->disp_drv->disp_buf->buf[0]);\n\n\t//LVGL_LOG_TRACE(\"disp->user_data->disp_drv->disp_buf->buf[1]: %d\", disp->user_data->disp_drv->disp_buf->buf[1]);\n\n\t//LVGL_LOG_TRACE(\"disp->user_data->disp_drv->disp_buf->buf[2]: %d\", disp->user_data->disp_drv->disp_buf->buf[2]);\n\n\t//LVGL_LOG_TRACE(\"disp->user_data->disp_drv->disp_buf->buf[3]: %d\", disp->user_data->disp_drv->disp_buf->buf[3]);\n\n\t//LVGL_LOG_TRACE(\"disp->user_data->disp_drv->disp_buf->buf[4]: %d\", disp->user_data->disp_drv->disp_", "CodeBleu_score": 3.4626219611586984}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tlv_coord_t x, y, w, h;\n\tlv_color_t c;\n\tlv_disp_t *disp_drv = disp->disp_drv;\n\tdisplay_obj_t *display_obj = (display_obj_t *)disp_drv->user_data;\n\n\t/*Set the address window to the specified area*/\n\tx = area->x1;\n\ty = area->y1;\n\tw = area->x2 - area->x1 + 1;\n\th = area->y2 - area->y1 + 1;\n\tdisplay_obj->tft.setAddrWindow(x, y, w, h);\n\n\t/*Write the color data to the display*/\n\tdisplay_obj->tft.startWrite();\n\tfor (int i = 0; i < w * h; i++) {\n\t\tc = color_p[i];\n\t\tdisplay_obj->tft.writeColor(c.full);\n\t}\n\tdisplay_obj->tft.endWrite();\n\n\t/*Tell the graphics library that flushing is done*/\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 51.4331131453579}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\tSerial.println();\n\tSerial.print(\"Menu: \");\n\tSerial.println(menu->getName());\n\tSerial.println(\"----------------\");\n\tfor (int i = 0; i < menu->list->size; i++) {\n\t\tMenu * m = menu->list->get(i);\n\t\tSerial.print(\"  \");\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"  \");\n\t\t}\n\t\tSerial.println(m->getName());\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 55.27947603183026}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\t// Iterate through all menu nodes\n\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\t// Get the current menu node\n\t\tMenuNode * node = menu->list->get(i);\n\n\t\t// Print the node's name with indentation\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"  \");\n\t\t}\n\t\tSerial.println(node->name);\n\n\t\t// Recursively list the node's submenu\n\t\tif (node->submenu!= NULL) {\n\t\t\tshowMenuList(node->submenu, layer + 1);\n\t\t}\n\t}\n\n\t// Print an empty line after listing all nodes\n\tSerial.println();\n}", "CodeBleu_score": 62.413491451932266}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tSerial.print(layer);\n\tSerial.print(\" \");\n\tmenu->list->print();\n\tSerial.println();\n}", "CodeBleu_score": 30.0555367320656}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint generated = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tchar ssid[6];\n\t\tchar channel[3];\n\t\tchar mac[18];\n\t\trandomString(ssid, 6);\n\t\trandomString(channel, 3);\n\t\trandomString(mac, 17);\n\t\tssid[5] = '\\0';\n\t\tchannel[2] = '\\0';\n\t\tmac[17] = '\\0';\n\t\tSerial.print(\"SSID: \");\n\t\tSerial.println(ssid);\n\t\tSerial.print(\"Channel: \");\n\t\tSerial.println(channel);\n\t\tSerial.print(\"MAC: \");\n\t\tSerial.println(mac);\n\t\tssids->add(new WiFiScanResult(ssid, channel, mac));\n\t\tgenerated++;\n\t}\n\treturn generated;\n}", "CodeBleu_score": 39.64952493959715}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint num = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tchar ssid[6];\n\t\tchar channel = random(1, 13);\n\t\tchar mac[18];\n\t\tchar macPrefix[] = \"00:00:00:00:00:\";\n\t\tchar macSuffix[] = \":00:00\";\n\t\tchar macSuffix2[] = \":00\";\n\t\tchar macSuffix3[] = \":00:00:00\";\n\t\tchar macSuffix4[] = \":00:00:00:00\";\n\t\tchar macSuffix5[] = \":00:00:00:00:00\";\n\t\tchar macSuffix6[] = \":00:00:00:00:00:00\";\n\t\tsprintf(mac, \"%s%d%s\", macPrefix, channel, macSuffix);\n\t\tsprintf(mac, \"%s%d%s\", mac, random(1, 10000), macSuffix2);\n\t\tsprintf(mac, \"%s%d%s\", mac, random(1, 10000), macSuffix3);\n\t\tsprintf(mac, \"%s%d%s\", mac, random(1, 10000), macSuffix4);\n\t\tsprintf(mac, \"%s%d%s\", mac, random(1, 10000), macSuffix5);\n\t\tsprintf(mac, \"%s%d%s\", mac, random(1, 10000), macSuffix6);\n\t\tsprintf(ssid, \"%s\", mac);\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tssid[i] = random(97, 122);\n\t\t}\n\t\tSerial.print(\"SSID: \");\n\t\tSerial.println(ssid);\n\t\tssids->add(ssid);\n\t\tnum++;\n\t}\n\treturn num;\n}", "CodeBleu_score": 40.51751862773354}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint ssidCount = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid.concat(random(97, 122));\n\t\t}\n\t\tssid.concat(random(1, 14));\n\t\tbyte mac[6];\n\t\tWiFi.softAPmacAddress(mac);\n\t\tString macString = \"\";\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tString hex = String(mac[i], HEX);\n\t\t\tif (hex.length() == 1)\n\t\t\t\thex = \"0\" + hex;\n\t\t\tmacString.concat(hex);\n\t\t}\n\t\tmacString.concat(random(1, 14));\n\t\tWiFi.softAP(ssid.c_str(), macString.c_str());\n\t\tSerial.println(ssid);\n\t\tssidCount++;\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 43.373485589422735}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(request={\"name\": topic_path})\n    print(\"Topic created: {}\".format(topic))\n\n", "CodeBleu_score": 53.46263551943253}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    try:\n        publisher.create_topic(topic_path)\n        print(f\"Topic {topic_path} created.\")\n    except Exception as e:\n        print(f\"Error creating topic: {e}\")\n\n", "CodeBleu_score": 43.61576642013736}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    try:\n        publisher.create_topic(topic_path)\n        print(f\"Topic '{topic_path}' created.\")\n    except Exception as e:\n        print(f\"Error creating topic: {e}\")\n\n", "CodeBleu_score": 43.5608965294812}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    now = datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = json.load(f)['private_key']\n    print(private_key)\n    print(jwt.encode(payload, private_key, algorithm=algorithm))\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n", "CodeBleu_score": 49.39783657610214}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    token = {\n        'iat': datetime.utcnow(),\n        'exp': datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 49.51423477642534}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        \"iat\": datetime.datetime.utcnow(),\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        \"aud\": project_id,\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    print(\"Creating JWT using {} from private key file {}\".format(algorithm, private_key_file))\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 62.98617336321609}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print", "CodeBleu_score": 2.4848024316109423}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print(\"Received a new message on topic {0} with QoS {1} and payload {2}\".format(message.topic, message.qos, message.payload))\n    if message.payload == b\"on\":\n        print(\"Capturing preview image...\")\n        preview_capture()\n        print(\"Uploading file to bucket...\")\n        upload_file()\n        print(\"Publishing file URL to event topic...\")\n        payload = \"https://storage.googleapis.com/bucket_name/file_name.jpg\"\n        unused_client.publish(\"topic_name\", payload)\n        print(\"File URL published.\")\n    else:\n        print(\"Message payload is not 'on'.\")\n\n", "CodeBleu_score": 27.328924413422502}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print", "CodeBleu_score": 2.4848024316109423}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection.\")\n    parser.add_argument(\"--project_id\", help=\"GCP project ID\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\"--registry_id\", help=\"GCP registry ID\", required=True)\n    parser.add_argument(\"--device_id\", help=\"GCP device ID\", required=True)\n    parser.add_argument(\"--private_key_file\", help=\"private key file\", required=True)\n    parser.add_argument(\"--algorithm\", help=\"algorithm\", default=\"RS256\", choices=[\"RS256\", \"ES256\"])\n    parser.add_argument(\"--ca_certs\", help=\"CA root certs file\", default=\"/etc/ssl/certs/ca-certificates.crt\")\n    parser.add_argument(\"--cloud_region\", help=\"GCP cloud region\", default=\"us-central1\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", help=\"MQTT bridge hostname\", default=\"mqtt.googleapis.com\")\n    parser.add_argument(\"--mqtt_bridge_port\", help=\"MQTT bridge port\", default=8883, type=int)\n    parser.add_argument(\"--mqtt_bridge_tls_port\", help=\"MQTT bridge TLS port\", default=8884, type=int)\n    parser.add_argument(\"--mqtt_bridge_tls_ca_certs\", help=\"MQTT bridge TLS CA root certs file\", default=\"/etc/ssl/certs/ca-certificates.crt\")\n    parser.add_argument(\"--mqtt_bridge_tls_enabled\", help=\"MQTT bridge TLS enabled\", default=False, action=\"store_true\")\n    parser.add_argument(\"--mqtt_bridge_tls_client_cert_file\", help=\"MQTT bridge TLS client cert file\", default=None)\n    parser.add_argument(\"--mqtt_bridge_tls_client_key_file\", help=\"MQTT bridge TLS client key file\", default=None)\n    parser.add_argument(\"--mqtt_bridge_tls_client_key_algorithm\", help=\"MQTT bridge TLS client key algorithm\", default=None)\n    parser.add_argument(\"--mqtt_bridge_tls_client_key_password\", help=\"MQTT bridge TLS client key password\", default=None)\n    parser.add_argument(\"--mqtt_bridge_tls_client_key_password_algorithm", "CodeBleu_score": 34.25985488666387}, {"code": "def parse_command_line_args()\n\t\n    parser", "CodeBleu_score": 0.7333049639345527}, {"code": "def parse_command_line_args()\n\t\n    parser", "CodeBleu_score": 0.7333049639345527}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    credentials = ServiceAccountCredentials.from_service_account_file(service_account_json)\n    credentials = credentials.with_scopes(SCOPES)\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest?version=v1\"\n    client = discovery.build(\"cloudiot\", \"v1\", credentials=credentials, discoveryServiceUrl=discovery_url)\n    return client\n\n", "CodeBleu_score": 16.4521279533173}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    credentials = ServiceAccountCredentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n    credentials = credentials.with_scopes(scopes)\n    client = discovery.build(\n        \"cloudiot\", version, credentials=credentials, discoveryServiceUrl=discovery_url\n    )\n    return client\n\n", "CodeBleu_score": 23.406338440748574}, {"code": "def get_client(service_account_json)\n\t\n    credentials = ServiceAccountCredentials.from_json_keyfile_name(service_account_json, scopes)\n    credentials = credentials.with_scopes(scopes)\n    discovery = build(\n        \"cloudiot\",\n        \"v1\",\n        credentials=credentials,\n        discoveryServiceUrl=DISCOVERY_URL\n    )\n    return discovery\n\n", "CodeBleu_score": 12.39634878181814}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = hash_method.get_asn1()\n    if hash_method_asn1 is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_value_asn1 = hash_value.get_asn1()\n    if hash_value_asn1 is None:\n        raise ValueError(\"Invalid hash value\")\n    data_to_sign = b\"\".join((hash_method_asn1, hash_value_asn1))\n    data_to_sign = _pad_for_signing(data_to_sign)\n    return priv_key.blinded_encrypt(data_to_sign)\n\n", "CodeBleu_score": 28.301379612291242}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = _get_hash_method_asn1(hash_method)\n    if hash_method_asn1 is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_value_bytes = _pad_for_signing(hash_value, hash_method)\n    return priv_key.blinded_encrypt(hash_value_bytes + hash_method_asn1)\n\n", "CodeBleu_score": 21.35120467448346}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = hash_method.get_asn1_object()\n    if hash_method_asn1 is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_value_asn1 = hash_method_asn1.to_asn1_der(hash_value)\n    padded_hash_value = _pad_for_signing(hash_value_asn1)\n    encrypted_signature = priv_key.blinded_encrypt(padded_hash_value)\n    return encrypted_signature\n\n", "CodeBleu_score": 29.59774270561315}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    clear_signature = decrypt_int(signature, pub_key)\n    hash_method = find_method_hash(clear_signature)\n    hash_message = compute_hash(message, hash_method)\n    padded_hash = pad_for_signing(hash_message, hash_method)\n    if clear_signature!= padded_hash:\n        raise VerificationError\n    return hash_method\n\n", "CodeBleu_score": 13.053614535469999}, {"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        signature = core.decrypt_int(signature)\n    except ValueError:\n        raise VerificationError('Invalid signature')\n    if not isinstance(signature, int):\n        raise VerificationError('Invalid signature')\n    method_hash = _find_method_hash(pub_key)\n    hash_method = transform.bytes2int(method_hash)\n    hash_ = compute_hash(message, hash_method)\n    padded_hash = _pad_for_signing(hash_, hash_method)\n    if signature!= padded_hash:\n        raise VerificationError('Invalid signature')\n    return transform.bytes2int(method_hash)", "CodeBleu_score": 41.13253847245254}, {"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        clear_signature = core.decrypt_int(signature, pub_key)\n    except VerificationError:\n        return False\n    hash_method = _find_method_hash(message)\n    hash_value = hash_method.compute(message)\n    expected_hash = _pad_for_signing(hash_value, hash_method)\n    if clear_signature!= expected_hash:\n        raise VerificationError\n    return True\n\n", "CodeBleu_score": 34.07965310203986}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tdebug_print(\"Connecting to MQTT server...\");\n\ttime_t now = time(NULL);\n\tif (now!= -1) {\n\t\tupdateJWT(now);\n\t}\n\tMQTT_CLIENT_connect();\n\tsendMQTT_SUBSCRIBE = true;\n\tdebug_print(\"Connected to MQTT server.\");\n}", "CodeBleu_score": 53.6519269919261}, {"code": "static void connectMQTT(){\n\t\tuint32_t currentTime = 0;\n\tcurrentTime = time(NULL);\n\n\tif (currentTime!= 0) {\n\t\tupdateJWT(currentTime);\n\t}\n\n\tMQTT_CLIENT_connect();\n\n\tmqtt_send_subscribe = 1;\n\n\tdebug_print(\"MQTT connection attempt\");\n}", "CodeBleu_score": 34.33408899772743}, {"code": "static void connectMQTT(){\n\t\ttime_t t = time(NULL);\n\tif (t!= -1) {\n\t\tchar buffer[33];\n\t\tsprintf(buffer, \"%ld\", t);\n\t\tchar *token = strtok(buffer, \".\");\n\t\tchar *token2 = strtok(NULL, \".\");\n\t\tchar *token3 = strtok(NULL, \".\");\n\t\tchar *token4 = strtok(NULL, \".\");\n\t\tchar *token5 = strtok(NULL, \".\");\n\t\tchar *token6 = strtok(NULL, \".\");\n\t\tchar *token7 = strtok(NULL, \".\");\n\t\tchar *token8 = strtok(NULL, \".\");\n\t\tchar *token9 = strtok(NULL, \".\");\n\t\tchar *token10 = strtok(NULL, \".\");\n\t\tchar *token11 = strtok(NULL, \".\");\n\t\tchar *token12 = strtok(NULL, \".\");\n\t\tchar *token13 = strtok(NULL, \".\");\n\t\tchar *token14 = strtok(NULL, \".\");\n\t\tchar *token15 = strtok(NULL, \".\");\n\t\tchar *token16 = strtok(NULL, \".\");\n\t\tchar *token17 = strtok(NULL, \".\");\n\t\tchar *token18 = strtok(NULL, \".\");\n\t\tchar *token19 = strtok(NULL, \".\");\n\t\tchar *token20 = strtok(NULL, \".\");\n\t\tchar *token21 = strtok(NULL, \".\");\n\t\tchar *token22 = strtok(NULL, \".\");\n\t\tchar *token23 = strtok(NULL, \".\");\n\t\tchar *token24 = strtok(NULL, \".\");\n\t\tchar *token25 = strtok(NULL, \".\");\n\t\tchar *token26 = strtok(NULL, \".\");\n\t\tchar *token27 = strtok(NULL, \".\");\n\t\tchar *token28 = strtok(NULL, \".\");\n\t\tchar *token29 = strtok(NULL, \".\");\n\t\tchar *token30 = strtok(NULL, \".\");\n\t\tchar *token31 = strtok(NULL, \".\");\n\t\tchar *token32 = strtok(NULL, \".\");\n\t\tchar *token33 = strtok(NULL, \".\");\n\t\tchar *token34 = strtok(NULL, \".\");\n\t\tchar *token35", "CodeBleu_score": 11.096065086953077}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tvalue *= 10;\n\t\tvalue += str[i] - '0';\n\t}\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 26.399538993344645}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tuint8_t c = str[i];\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tvalue = value * 10 + (c - '0');\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 24.91082931598151}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tint digit;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (!is_digit(*str))\n\t\t\treturn str;\n\n\t\tdigit = *str++ - '0';\n\t\tif (digit >= 10)\n\t\t\treturn str;\n\n\t\tvalue *= 10;\n\t\tvalue += digit;\n\t}\n\n\t*num = value;\n\treturn str;\n}", "CodeBleu_score": 28.786748299603726}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint rc;\n\tuint8_t cert_sn[ATCACERT_HEADER_CERT_SN_SIZE];\n\tuint8_t cert_sn_size;\n\tuint8_t cert_sn_offset;\n\tuint8_t cert_sn_count;\n\tuint8_t cert_sn_start;\n\tuint8_t cert_sn_end;\n\tuint8_t cert_sn_end_offset;\n\tuint8_t cert_sn_end_count;\n\tuint8_t cert_sn_end_start;\n\tuint8_t cert_sn_end_end;\n\tuint8_t cert_sn_end_end_offset;\n\tuint8_t cert_sn_end_end_count;\n\tuint8_t cert_sn_end_end_start;\n\tuint8_t cert_sn_end_end_end;\n\tuint8_t cert_sn_end_end_end_offset;\n\tuint8_t cert_sn_end_end_end_count;\n\tuint8_t cert_sn_end_end_end_start;\n\tuint8_t cert_sn_end_end_end_end;\n\tuint8_t cert_sn_end_end_end_end_offset;\n\tuint8_t cert_sn_end_end_end_end_count;\n\tuint8_t cert_sn_end_end_end_end_start;\n\tuint8_t cert_sn_end_end_end_end_end;\n\tuint8_t cert_sn_end_end_end_end_end_offset;\n\tuint8_t cert_sn_end_end_end_end_end_count;\n\tuint8_t cert_sn_end_end_end_end_end_start;\n\tuint8_t cert_sn_end_end_end_end_end_end;\n\tuint8_t cert_sn_end_end_end_end_end_end_offset;\n\tuint8_t cert_sn_end_end_end_end_end_end_count;\n\tuint8_t cert_sn_end_end_end_end_", "CodeBleu_score": 5.675422201748385}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint rc = 0;\n\tuint8_t year;\n\tuint8_t month;\n\tuint8_t day;\n\tuint8_t hour;\n\tuint8_t minute;\n\tuint8_t second;\n\tuint8_t day_of_week;\n\tuint8_t month_of_year;\n\tuint8_t year_of_week;\n\tuint8_t day_of_year;\n\tuint8_t hour_of_day;\n\tuint8_t minute_of_hour;\n\tuint8_t second_of_minute;\n\tuint8_t timezone_offset;\n\tuint8_t timezone_sign;\n\tuint8_t timezone_hour;\n\tuint8_t timezone_minute;\n\n\tif (build_state == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (build_state->cert_template.tbs_cert.valid_from.year == 0) {\n\t\tbuild_state->cert_template.tbs_cert.valid_from.year = 2000;\n\t}\n\n\tif (build_state->cert_template.tbs_cert.valid_to.year == 0) {\n\t\tbuild_state->cert_template.tbs_cert.valid_to.year = 2000;\n\t}\n\n\tif (build_state->cert_template.tbs_cert.valid_from.month == 0) {\n\t\tbuild_state->cert_template.tbs_cert.valid_from.month = 1;\n\t}\n\n\tif (build_state->cert_template.tbs_cert.valid_to.month == 0) {\n\t\tbuild_state->cert_template.tbs_cert.valid_to.month = 1;\n\t}\n\n\tif (build_state->cert_template.tbs_cert.valid_from.day == 0) {\n\t\tbuild_state->cert_template.tbs_cert.valid_from.day = 1;\n\t}\n\n\tif (build_state->cert_template.tbs_cert.valid_to.day == 0) {\n\t\tbuild_state->", "CodeBleu_score": 34.296566067502795}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret;\n\tatcacert_date_t date;\n\n\tif (build_state == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (build_state->cert_def == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (build_state->cert_def->cert_template.tbs_header.validity.not_after.year == 0) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tret = atcacert_date_dec_rfc5280_utc(build_state->cert_def->cert_template.tbs_header.validity.not_after.year,\n\t\t\t\t\t\t\t\t\t\tbuild_state->cert_def->cert_template.tbs_header.validity.not_after.month,\n\t\t\t\t\t\t\t\t\t\tbuild_state->cert_def->cert_template.tbs_header.validity.not_after.day,\n\t\t\t\t\t\t\t\t\t\tbuild_state->cert_def->cert_template.tbs_header.validity.not_after.hour,\n\t\t\t\t\t\t\t\t\t\tbuild_state->cert_def->cert_template.tbs_header.validity.not_after.minute,\n\t\t\t\t\t\t\t\t\t\tbuild_state->cert_def->cert_template.tbs_header.validity.not_after.second,\n\t\t\t\t\t\t\t\t\t\t&date);\n\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_set_cert_valid_date(build_state->cert, &date);\n\n\treturn ret;\n}", "CodeBleu_score": 48.76920178454663}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\tuint8_t* tbs_digest_ptr = NULL;\n\tuint8_t* signature_ptr = NULL;\n\tuint8_t* ca_public_key_ptr = NULL;\n\tuint8_t* cert_ptr = NULL;\n\n\tif (cert_def == NULL) {\n\t\tret = ATCA_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\tif (cert == NULL) {\n\t\tret = ATCA_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\tif (cert_size == 0) {\n\t\tret = ATCA_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\tif (ca_public_key == NULL) {\n\t\tret = ATCA_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\tif (cert_def->cert_tbs_size == 0) {\n\t\tret = ATCA_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\tif (cert_def->cert_signature_size == 0) {\n\t\tret = ATCA_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\tif (cert_def->cert_tbs_size > sizeof(tbs_digest)) {\n\t\tret = ATCA_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\tif (cert_def->cert_signature_size > sizeof(signature)) {\n\t\tret = ATCA_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\ttbs_digest_ptr = tbs_digest;\n\tsignature_ptr = signature;\n\tca_public_key_ptr = ca_public_key;\n\tcert_ptr = cert;\n\n\tret = atcacert_get_tbs_digest(cert_def, cert_ptr, cert_size, tbs_digest_ptr);\n\tif (ret!= 0) {\n\t\tgoto exit;\n\t}\n\n\tret = atcacert_get_signature(cert_def, cert_ptr, cert_size, signature_ptr);\n\tif (ret!= 0) {\n\t\tgoto exit;\n\t}\n\n", "CodeBleu_score": 44.957426906337076}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[32];\n\tsize_t tbs_digest_size = 0;\n\tsize_t signature_size = 0;\n\n\tif (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Get the TBS digest of the certificate\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest, &tbs_digest_size);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Get the signature of the certificate\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature, &signature_size);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Verify the TBS digest against the signature using the CA public key\n\tret = atcab_verify_extern(tbs_digest, tbs_digest_size, signature, signature_size, ca_public_key);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ATCA_SUCCESS;\n}", "CodeBleu_score": 68.64224942583621}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t tbs_digest[32] = {0};\n\tuint8_t signature[64] = {0};\n\tuint8_t pub_key[64] = {0};\n\n\tif (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (cert_def->tbs_offset >= cert_size) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (cert_def->signature_offset >= cert_size) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (cert_def->pub_key_offset >= cert_size) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (cert_def->tbs_size > 32) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (cert_def->signature_size > 64) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (cert_def->pub_key_size > 64) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\tif (cert_def->tbs_size!= 0) {\n\t\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\t\tif (ret!= ATCA_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (cert_def->signature_size!= 0) {\n\t\tret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\t\tif (ret!= ATCA_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (cert_def->pub_key_size!= 0) {\n\t\tret = atcacert_get_pub_key(cert_def, cert, cert_size, pub_key);\n\t\tif (ret!= ATCA_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = atcab_verify_extern(tbs_digest, signature, pub_key);\n\t", "CodeBleu_score": 64.28891540156073}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile * volatile *", "CodeBleu_score": 9.522600066047481}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tbool ret = false;\n\tif(timer == NULL)\n\t\treturn false;\n\tif(list == NULL)\n\t\treturn false;\n\tif(*list == NULL)\n\t\treturn false;\n\tif(timer->next == NULL)\n\t\treturn false;\n\tif(timer->prev == NULL)\n\t\treturn false;\n\tif(timer->next->next == NULL)\n\t\treturn false;\n\tif(timer->next->prev == NULL)\n\t\treturn false;\n\tif(timer->prev->next == NULL)\n\t\treturn false;\n\tif(timer->prev->prev == NULL)\n\t\treturn false;\n\tif(timer->next->next->next == NULL)\n\t\treturn false;\n\tif(timer->next->next->prev == NULL)\n\t\treturn false;\n\tif(timer->next->prev->next == NULL)\n\t\treturn false;\n\tif(timer->next->prev->prev == NULL)\n\t\treturn false;\n\tif(timer->prev->next->next == NULL)\n\t\treturn false;\n\tif(timer->prev->next->prev == NULL)\n\t\treturn false;\n\tif(timer->prev->prev->next == NULL)\n\t\treturn false;\n\tif(timer->prev->prev->prev == NULL)\n\t\treturn false;\n\tif(timer->next->next->next->next == NULL)\n\t\treturn false;\n\tif(timer->next->next->next->prev == NULL)\n\t\treturn false;\n\tif(timer->next->next->prev->next == NULL)\n\t\treturn false;\n\tif(timer->next->next->prev->prev == NULL)\n\t\treturn false;\n\tif(timer->next->prev->next->next == NULL)\n\t\treturn false;\n\tif(timer->next->prev->next->prev == NULL)\n\t\treturn false;\n\tif(timer->next->prev->prev->next == NULL)\n\t\treturn false;\n\tif(timer->next->prev->prev->prev == NULL)\n\t\treturn false;\n\tif(timer->prev->next->next->next == NULL)\n\t\treturn false;\n\tif(timer->prev->next->next->prev == NULL)\n\t\treturn false;\n\tif(timer->prev", "CodeBleu_score": 18.605211903389336}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tint i;\n\tfor (i = 0; i < MAX_TIMERS; i++) {\n\t\tif (list[i] == timer) {\n\t\t\tlist[i] = NULL;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 16.005135193627424}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\t//debug_printGOOD\n\tgetSocketInfo(socket);\n\tif (socketInfo[socket].state == NOT_A_SOCKET) {\n\t\treturn BSD_ERROR;\n\t}\n\tsocketInfo[socket].state = NOT_A_SOCKET;\n\tint closeResult = close(socket);\n\tif (closeResult == -1) {\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 28.12627873504394}, {"code": "int BSD_close(int socket){\n\t\tint ret = BSD_SUCCESS;\n\tstruct bsd_socket *bsd_socket = NULL;\n\n\tif (debug_printGOOD) {\n\t\tprintf(\"BSD_close: socket = %d", "CodeBleu_score": 3.282104873821777}, {"code": "int BSD_close(int socket){\n\t\tint status;\n\tstruct bsd_socketInfo *info;\n\tint err;\n\n\tif (bsd_debug_printGOOD) {\n\t\tprintf(\"BSD_close: socket=%d\n\", socket);\n\t}\n\n\tinfo = bsd_getSocketInfo(socket);\n\tif (info == NULL) {\n\t\tbsd_setErrNo(BSD_ERR_INVALID_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\n\tinfo->state = NOT_A_SOCKET;\n\tstatus = close(info->socket);\n\tif (status < 0) {\n\t\terr = errno;\n\t\tif (err == EBADF) {\n\t\t\tbsd_setErrNo(BSD_ERR_INVALID_SOCKET);\n\t\t} else if (err == ENOTSOCK) {\n\t\t\tbsd_setErrNo(BSD_ERR_NOT_A_SOCKET);\n\t\t} else {\n\t\t\tbsd_setErrNo(BSD_ERR_OTHER);\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 52.104112925670876}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint err = listen(socket, backlog);\n\tif (err == -1) {\n\t\tBSD_setErrNo(BSD_ERR_LISTEN);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 19.42375027105516}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret;\n\n\tret = listen(socket, backlog);\n\tif (ret == -1) {\n\t\tBSD_setErrNo(BSD_ERR_LISTEN);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 23.77291528034992}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint error;\n\terror = listen(socket, backlog);\n\tif (error == -1) {\n\t\tBSD_setErrNo(BSD_ERR_LISTEN);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 23.890219234270997}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint result = 0;\n\tint addr_family = 0;\n\tint addr_size = 0;\n\tint addr_size_ret = 0;\n\tint addr_size_ret_ret = 0;\n\tint addr_size_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret_ret = 0;\n\tint addr_size_ret_", "CodeBleu_score": 8.670088882824192}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = 0;\n\tif (addr->sa_family == AF_INET) {\n\t\tstruct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n\t\tret = accept(socket, (struct sockaddr *) addr_in, addrlen);\n\t} else if (addr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *) addr;\n\t\tret = accept(socket, (struct sockaddr *) addr_in6, addrlen);\n\t} else {\n\t\tbsd_setErrNo(EBADF);\n\t\treturn -1;\n\t}\n\tif (ret == -1) {\n\t\tbsd_setErrNo(errno);\n\t\treturn -1;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 37.2225952310242}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret;\n\tint err;\n\tstruct bsd_sockaddr_storage storage;\n\tstruct bsd_sockaddr_storage *storage_ptr = &storage;\n\tstruct bsd_sockaddr_storage *storage_ptr_ptr = &storage_ptr;\n\tstruct bsd_sockaddr *storage_ptr_ptr_ptr = &storage_ptr_ptr;\n\n\tif (addr == NULL) {\n\t\tbsd_setErrNo(EBADF);\n\t\treturn -1;\n\t}\n\n\tif (addrlen == NULL) {\n\t\tbsd_setErrNo(EBADF);\n\t\treturn -1;\n\t}\n\n\tif (addr->sa_family!= AF_UNIX) {\n\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\n\tret = accept(socket, (struct sockaddr *) storage_ptr_ptr_ptr, addrlen);\n\n\tif (ret == -1) {\n\t\terr = errno;\n\t\tif (err == EINVAL) {\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t\treturn -1;\n\t\t}\n\t\tif (err == EBADF) {\n\t\t\tbsd_setErrNo(EBADF);\n\t\t\treturn -1;\n\t\t}\n\t\tif (err == EFAULT) {\n\t\t\tbsd_setErrNo(EFAULT);\n\t\t\treturn -1;\n\t\t}\n\t\tif (err == EINTR) {\n\t\t\tbsd_setErrNo(EINTR);\n\t\t\treturn -1;\n\t\t}\n\t\tif (err == EINVAL) {\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t\treturn -1;\n\t\t}\n\t\tif (err == EMFILE) {\n\t\t\tbsd_setErrNo(EMFILE);\n\t\t\treturn -1;\n\t\t}\n\t\tif (err == ENFILE) {\n\t\t\tbsd_setErrNo(ENFILE);\n\t\t\treturn -1;\n\t\t}\n\t\tif (err == ENOBUFS) {\n\t\t\tbsd_setErrNo(ENOBUFS);\n\t\t\treturn -1;\n\t\t}\n\t\tif (err == ENOMEM) {\n\t\t\tbsd_setErrNo(ENOMEM);\n\t\t\treturn -1;\n\t\t}\n\t\tif (err == ENOTSOCK) {\n\t\t\tbsd_setErrNo(ENOTSOCK", "CodeBleu_score": 39.33379555323224}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\ttime_t now;\n\tstruct tm *timeinfo;\n\tchar strftime_buf[64];\n\n\ttime(&now);\n\ttimeinfo = localtime(&now);\n\tstrftime(strftime_buf, sizeof(strftime_buf), \"%Y-%m-%d %H:%M:%S\", timeinfo);\n\tdebug_print(\"The current date/time is: %s\n\", strftime_buf);\n\n\tif (now == -1) {\n\t\tdebug_print(\"Current time is invalid\n\");\n\t\treturn;\n\t}\n\n\t// Update the JWT with the current time offset\n\tupdateJWT(now);\n\n\t// Connect to the MQTT broker\n\tMQTT_CLIENT_connect();\n\n\t// Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n\tsendSubscribe = true;\n}", "CodeBleu_score": 48.050320983467515}, {"code": "static void connectMQTT(){\n\t\tdebug_print(\"Connecting to MQTT broker...\n\");\n\tchar* time = getTime();\n\tif (time == NULL) {\n\t\tdebug_print(\"Could not retrieve time from NTP server\n\");\n\t\treturn;\n\t}\n\tchar* jwt = updateJWT(time);\n\tif (jwt == NULL) {\n\t\tdebug_print(\"Could not update JWT\n\");\n\t\treturn;\n\t}\n\tMQTT_CLIENT_connect(jwt);\n\tMQTT_CLIENT_subscribe();\n\tfree(jwt);\n\tfree(time);\n}", "CodeBleu_score": 42.600218633631584}, {"code": "static void connectMQTT(){\n\t\t// Get the current time in UNIX format\n\ttime_t currentTime = time(NULL);\n\t// Check if the time is valid\n\tif (currentTime == -1) {\n\t\t// Invalid time, print error message\n\t\tdebug_print(\"Error: Failed to retrieve current time\n\");\n\t\treturn;\n\t}\n\t// Update the JWT with the current time offset\n\tupdateJWT(currentTime);\n\t// Connect to the MQTT broker\n\tint rc = MQTT_CLIENT_connect(MQTT_CLIENT_handle);\n\tif (rc!= 0) {\n\t\t// Connection failed, print error message\n\t\tdebug_print(\"Error: Failed to connect to MQTT broker\n\");\n\t\treturn;\n\t}\n\t// Set the MQTT SUBSCRIBE flag\n\tMQTT_CLIENT_subscribeFlag = 1;\n\t// Print debug message\n\tdebug_print(\"Info: Connected to MQTT broker\n\");\n}", "CodeBleu_score": 50.818064586388125}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_GetConnectionState() == MQTT_CONNECTION_CONNECTED) {\n\t\tdebug_printError(\"MQTT Disconnected\");\n\t\tMQTT_Disconnect();\n\t\tMQTT_GetClientConnectionInfo();\n\t}\n}", "CodeBleu_score": 61.650480245247195}, {"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_GetConnectionState() == MQTT_CONNECTION_CONNECTED) {\n\t\tMQTT_GetClientConnectionInfo(&clientConnectionInfo);\n\t\tMQTT_Disconnect();\n\t\tdebug_printError(\"Disconnected from cloud service\");\n\t}\n}", "CodeBleu_score": 58.4003067205104}, {"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_GetConnectionState() == MQTT_CONNECTION_CONNECTED) {\n\t\tMQTT_GetClientConnectionInfo(&clientConnectionInfo);\n\t\tdebug_printError(\"Disconnecting from the cloud service...\");\n\t\tMQTT_Disconnect();\n\t\tdebug_printError(\"Disconnected from the cloud service!\");\n\t}\n}", "CodeBleu_score": 54.80067026140729}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tuint8_t wifi_creds = passed_wifi_creds;\n\tuint8_t wifi_status = 0;\n\tuint8_t wifi_status_old = 0;\n\tuint8_t wifi_status_new = 0;\n\tuint8_t wifi_status_new_old = 0;\n\tuint8_t wifi_status_new_new = 0;\n\tuint8_t wifi_status_new_new_old = 0;\n\tuint8_t wifi_status_new_new_new = 0;\n\tuint8_t wifi_status_new_new_new_old = 0;\n\tuint8_t wifi_status_new_new_new_new = 0;\n\tuint8_t wifi_status_new_new_new_new_old = 0;\n\tuint8_t wifi_status_new_new_new_new_new = 0;\n\tuint8_t wifi_status_new_new_new_new_new_old = 0;\n\tuint8_t wifi_status_new_new_new_new_new_new = 0;\n\tuint8_t wifi_status_new_new_new_new_new_new_old = 0;\n\tuint8_t wifi_status_new_new_new_new_new_new_new = 0;\n\tuint8_t wifi_status_new_new_new_new_new_new_new_old = 0;\n\tuint8_t wifi_status_new_new_new_new_new_new_new_new = 0;\n\tuint8_t wifi_status_new_new_new_new_new_new_new_new_old = 0;\n\tuint8_t wifi_status_new_new_new_new_new_new_new_new_new = 0;\n\tuint8_t wifi_status_new_new_new_new_new_new_new_new_new_old = 0;\n\tuint8_t wifi_status_new_new_new_new_new_new_new_new_new_new = 0;\n\tuint8", "CodeBleu_score": 4.51578441458418}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tbool result = false;\n\n\tif (passed_wifi_creds == 1) {\n\t\tresult = m2m_wifi_connect(wifi_ssid, wifi_auth, wifi_pass, M2M_WIFI_CH_ALL);\n\t} else {\n\t\tresult = m2m_wifi_connect(NULL, M2M_WIFI_SEC_OPEN, NULL, M2M_WIFI_CH_ALL);\n\t}\n\n\tif (result == M2M_SUCCESS) {\n\t\tdebug_printError(\"Connected to Wi-Fi\");\n\t} else {\n\t\tdebug_printError(\"Failed to connect to Wi-Fi\");\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 42.827619880081556}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tbool success = false;\n\tuint8_t wifi_creds = passed_wifi_creds;\n\tif (wifi_creds == 0) {\n\t\twifi_creds = WIFI_CREDS_DEFAULT;\n\t}\n\tif (wifi_creds == WIFI_CREDS_DEFAULT) {\n\t\tsuccess = m2m_wifi_connect((char*)DEFAULT_SSID, (char*)DEFAULT_PSK, M2M_WIFI_SEC_WPA_PSK, M2M_WIFI_CH_ALL);\n\t} else if (wifi_creds == WIFI_CREDS_NEW) {\n\t\tsuccess = m2m_wifi_connect((char*)NEW_SSID, (char*)NEW_PSK, M2M_WIFI_SEC_WPA_PSK, M2M_WIFI_CH_ALL);\n\t}\n\tif (success == false) {\n\t\tdebug_printError(\"Failed to connect to Wi-Fi\");\n\t\tnetworking_setError(NETWORKING_ERROR_CONNECT);\n\t}\n\treturn success;\n}", "CodeBleu_score": 43.34006535959431}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tst client = new Client({\nuri: 'https://api.openaq.org/graphql',\n})\nconst response = await client.request(`\nquery {\nlistSensors {\nid\nlocation\ngeo {\nlatitude\nlongitude\n}\n}\n}`)\nif (response.data.listSensors) {\nconsole.log('Retrieved Sensors')\nresponse.data.listSensors.forEach(sensor => {\nconst marker = document.createElement('div')\nmarker.style.backgroundImage = 'url(https://cdn.glitch.com/622980a1-8695-460d-9c32-1371216f474b%2Fmarker.svg?1584678641928)'\nmarker.style.width = '30px'\nmarker.style.height = '30px'\nmarker.style.backgroundSize = 'cover'\nnew Marker({element: marker})\n.setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n.addTo(map)\n})\n}\n}", "CodeBleu_score": 42.91011397867868}, {"code": "async function DisplaySensors(map){\n\tst client = new ApolloClient({\n    uri: 'https://api.openaq.org/v1/measurements',\n    cache: new InMemoryCache()\n});\nconst response = await client.query({\n    query: gql`\n        query {\n            listSensors {\n                id\n                location\n                locationName\n                parameter\n                value\n                date\n                geo {\n                    longitude\n                    latitude\n                }\n            }\n        }\n    `\n});\nconsole.log('Retrieving sensors...');\nresponse.data.listSensors.forEach(sensor => {\n    console.log(`Sensor: ${sensor.id}`);\n    const marker = new mapboxgl.Marker({element: document.createElement('div')})\n       .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n       .addTo(map);\n});\n}", "CodeBleu_score": 40.495912502269746}, {"code": "async function DisplaySensors(map){\n\tst client = new Client({\n    url: 'https://api.sensor.io/graphql',\n    fetch: fetch\n});\nconst response = await client.graphql({\n    query: `query {\n    listSensors {\n        id\n        name\n        geo {\n            latitude\n            longitude\n        }\n    }\n}`\n});\nconsole.log(`Retrieved ${response.data.listSensors.length} sensors`);\nresponse.data.listSensors.forEach(sensor => {\n    console.log(`Sensor ${sensor.name} at ${sensor.geo.latitude}, ${sensor.geo.longitude}`);\n    const marker = document.createElement('div');\n    marker.className ='marker';\n    new Marker({element: marker})\n       .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n       .addTo(map);\n});\n}", "CodeBleu_score": 50.650499652728755}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 42.938724561581814}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.classList.add(\"sensor-marker\");\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 43.988397907557484}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst sensorMarker = document.createElement('div');\n\tsensorMarker.id = sensor.id;\n\tsensorMarker.classList.add('sensor-marker');\n\tsensorMarker.style.backgroundColor = sensor.color;\n\tsensorMarker.style.border = `2px solid ${sensor.color}`;\n\treturn sensorMarker;\n}", "CodeBleu_score": 43.99444347037096}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.mfa.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Error loading MFA module %s: %s\", module_name, err)\n        raise\n    except Exception as err:\n        _LOGGER.error(\"Error loading MFA module %s: %s\", module_name, err)\n        raise\n    if module_name not in processed:\n        if module.REQUIREMENTS:\n            await hass.async_add_executor_job(requirements.async_process_requirements, hass, module.REQUIREMENTS)\n        processed.add(module_name)\n    return module\n\n", "CodeBleu_score": 46.03948505342005}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{MODULE_PATH}.{module_name}\"\n    _LOGGER.debug(\"Loading MFA module: %s\", module_path)\n    try:\n        module = await async_import_module(hass, module_path)\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Error loading MFA module: %s\", err)\n        raise err\n    except Exception as err:  # pylint: disable=broad-except\n        _LOGGER.error(\"Error loading MFA module: %s\", err)\n        raise HomeAssistantError(\n            \"Error loading MFA module: %s\", err\n        ) from err\n    if module.REQUIREMENTS:\n        if module.REQUIREMENTS not in processed:\n            _LOGGER.debug(\n                \"Processing MFA module requirements: %s\", module.REQUIREMENTS\n            )\n            await requirements.async_process_requirements(hass, module.REQUIREMENTS)\n            processed.add(module.REQUIREMENTS)\n    return module", "CodeBleu_score": 41.55779395332013}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Unable to load multi-factor authentication (MFA) module: %s\", err)\n        raise\n    if module_name in requirements.async_process_requirements:\n        requirements.async_process_requirements.remove(module_name)\n    return module\n\n", "CodeBleu_score": 32.88085560924377}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self._data:\n        self._data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self._data[user_id] = {\n            \"pin\": setup_data[\"pin\"],\n            \"attempts\": 0,\n        }\n\n", "CodeBleu_score": 37.87389568607441}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.data:\n        self.data[user_id][\"PIN\"] = setup_data[\"PIN\"]\n    else:\n        self.data[user_id] = setup_data\n    await self.async_write_data()\n\n", "CodeBleu_score": 31.047049808779914}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if self._user_id_to_pin.get(user_id) is None:\n        self._user_id_to_pin[user_id] = setup_data[\"pin\"]\n    else:\n        self._user_id_to_pin[user_id] = setup_data[\"pin\"]\n    return self._user_id_to_pin[user_id]\n\n", "CodeBleu_score": 36.545770798808405}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async_with_lock(self._async_lock, self._async_load)\n    if not self._data:\n        self._data = {}\n        for user in self.hass.data[DOMAIN].users:\n            self._data[user.id] = NotifySetting(user)\n        self.hass.data[DOMAIN][DATA_NOTIFY_SETTINGS] = self._data\n\n", "CodeBleu_score": 19.445313349986314}, {"code": "async def _async_load(self) -> None\n\t\n    with self._lock:\n        if not self._loaded:\n            self._loaded = True\n            if self._data is None:\n                self._data = {}\n            for user in self._data:\n                self._data[user] = NotifySetting(self._data[user])\n\n", "CodeBleu_score": 20.329710894256785}, {"code": "async def _async_load(self) -> None\n\t\n    async with self.init_lock:\n        if self.user_settings is None:\n            self.user_settings = {}\n            if self.user_store.data:\n                for user_id, user_data in self.user_store.data.items():\n                    self.user_settings[user_id] = NotifySetting(user_id, user_data)\n            else:\n                self.user_settings[self.user_id] = NotifySetting(self.user_id)\n        await self.user_store.async_save()\n\n", "CodeBleu_score": 31.691962754035842}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self._async_load", "CodeBleu_score": 13.273694853506107}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self._async_load", "CodeBleu_score": 13.273694853506107}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    self._async_load()\n    user_settings", "CodeBleu_score": 13.9352310096292}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get(entity_id)\n    if entity is None:\n        return None\n    device = entity.device\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 46.421840559991814}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device or not device.area_id:\n        return None\n    return area_dict.get(device.area_id)\n\n", "CodeBleu_score": 42.85999847789118}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = entity.device\n    if device is None:\n        return None\n    area = device.area\n    if area is None:\n        return None\n    return area_dict.get(area.id)\n\n", "CodeBleu_score": 49.68123127787501}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    new_policy", "CodeBleu_score": 6.288376068563756}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy = {}\n    seen = set", "CodeBleu_score": 6.99324165341665}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy = {}\n    seen = set", "CodeBleu_score": 6.99324165341665}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, provider)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to load auth provider module %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Unable to load auth provider module {provider}: {err}\"\n        ) from err\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    requirements = module.REQUIREMENTS\n    if requirements is None:\n        return module\n    requirements = set(requirements)\n    requirements.discard(None)\n    if requirements:\n        processed = set()\n        for requirement in requirements:\n            if requirement in processed:\n                continue\n            processed.add(requirement)\n            try:\n                await async_process_requirements(hass, requirement)\n            except HomeAssistantError as err:\n                _LOGGER.error(\n                    \"Unable to process requirement %s: %s\", requirement, err\n                )\n                raise HomeAssistantError(\n                    f\"Unable to process requirement {requirement}: {err}\"\n                ) from err\n    return module\n\n", "CodeBleu_score": 50.359029847106015}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, provider)\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Unable to load auth provider %s: %s\", provider, err)\n        raise\n    requirements = getattr(module, \"REQUIREMENTS\", None)\n    if not requirements:\n        return module\n    processed = set()\n    for requirement in requirements:\n        try:\n            processed.add(requirement)\n            await async_process_requirements(hass, requirement)\n        except HomeAssistantError as err:\n            _LOGGER.error(\n                \"Unable to process auth provider %s requirement %s: %s\",\n                provider,\n                requirement,\n                err,\n            )\n    return module\n\n", "CodeBleu_score": 45.21460986810608}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await hass.async_import_module(provider)\n    except ImportError as err:\n        raise HomeAssistantError(\n            f\"Authentication provider {provider} could not be loaded: {err}\"\n        ) from err\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    requirements = getattr(module, \"REQUIREMENTS\", [])\n    if not requirements:\n        return module\n    processed = set()\n    for requirement in requirements:\n        if requirement in processed:\n            continue\n        processed.add(requirement)\n        try:\n            await hass.async_process_requirements(requirement)\n        except HomeAssistantError as err:\n            _LOGGER.error(\n                \"Authentication provider %s could not be loaded: %s\", provider, err\n            )\n    return module", "CodeBleu_score": 48.25505430872193}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    self._async_load()\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 9.791163259609924}, {"code": "async def async_load(self) -> None\n\t\n    if self._async_check_for_not_normalized_usernames():\n        return\n    self._async_load_from_store()\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 19.38657333223917}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        self._users = await self.async_load_from_store()\n    except (ValueError, TypeError):\n        self._users = []\n\n", "CodeBleu_score": 20.317154679923956}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = password.encode()\n    for user in self.users:\n        if user.username == username:\n            stored_hash = base64.b64decode(user.password)\n            if not bcrypt.checkpw(password.encode(), stored_hash):\n                raise InvalidAuth(\"Invalid password\")\n            return\n    raise InvalidAuth(\"Invalid username\")\n\n", "CodeBleu_score": 39.02727806128163}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    self.hash = \"dummy\"\n    for user in self.users:\n        if user.username == username:\n            self.hash = user.password\n            break\n    else:\n        bcrypt.checkpw(self.hash.encode(), \"dummy\".encode())\n        raise InvalidAuth(\"Invalid credentials\")\n    if not bcrypt.checkpw(password.encode(), self.hash.encode()):\n        raise InvalidAuth(\"Invalid credentials\")\n\n", "CodeBleu_score": 36.70021649184244}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = base64.b64decode(user.password)\n            if not bcrypt.checkpw(password.encode(), stored_hash):\n                raise InvalidAuth(\"Invalid password\")\n            return\n    raise InvalidAuth(\"Invalid username\")\n\n", "CodeBleu_score": 39.93179357848927}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 35.85660537080088}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.username = self.normalize_username(username)\n    for index, user in enumerate(self.users):\n        if user.username == self.username:\n            del self.users[index]\n            break\n    else:\n        raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 37.39730609375492}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.normalize_username\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(f\"user_not_found: {username}\")\n\n", "CodeBleu_score": 33.855699320371315}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n    except ValueError:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 38.16454400444172}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    try:\n        await self.async_remove_auth(credentials.username)\n    except:\n        pass\n    await self.async_initialize()\n    await self.async_save()\n\n", "CodeBleu_score": 36.318856366931186}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    self.async_initialize()\n    try:\n        self.async_remove_auth(credentials.username)\n    except Exception:\n        pass\n    async_save(self)\n\n", "CodeBleu_score": 32.25093344120403}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident:\n                timeout_thread = timeout\n            else:\n                timeout_thread = 0\n            try:\n                thread.join(timeout_thread)\n            except RuntimeError:\n                pass\n            if thread.is_alive():\n                if log:\n                    _log_thread_running_at_shutdown(thread)\n                joined.add(thread)\n    for thread in threads:\n        if thread.is_alive():\n            try:\n                async_raise(thread.ident, SystemExit)\n            except ValueError:\n                pass\n    return joined\n\n", "CodeBleu_score": 43.433677959759244}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread)\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            pass\n        if thread.is_alive():\n            thread.interrupt()\n            try:\n                thread.join(timeout)\n            except RuntimeError:\n                pass\n        if thread.is_alive():\n            joined.add(thread)\n            continue\n        joined.add(thread)\n    for thread in threads:\n        if thread.ident is None:\n            continue\n        async_raise(thread, SystemExit)\n    return joined\n\n", "CodeBleu_score": 48.00201137996493}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        timeout_for_thread = timeout / len(threads)\n        if not thread.join(timeout_for_thread):\n            joined.add(thread)\n            if log:\n                _log_thread_running_at_shutdown(thread)\n    if log:\n        for thread in threads - joined:\n            _log_thread_running_at_shutdown(thread)\n    for thread in threads - joined:\n        async_raise(thread, SystemExit)\n    return joined\n\n", "CodeBleu_score": 52.21772221098907}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    _LOGGER.warning(\"Stopping all threads...\")\n    threads = threading.enumerate()\n    threads = [thread for thread in threads if thread.is_alive()]\n    if not threads:\n        return\n    total_timeout = _SHUTDOWN_TIMEOUT\n    for thread in threads:\n        timeout = total_timeout / len(threads)\n        _LOGGER.warning(f\"Stopping thread {thread.name}...\")\n        thread.join(timeout)\n        if thread.is_alive():\n            _LOGGER.warning(f\"Thread {thread.name} did not stop within {timeout}s. Killing thread...\")\n            thread.terminate()\n            thread.join()\n\n", "CodeBleu_score": 30.856179702112623}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [thread for thread in threading.enumerate() if thread is not threading.main_thread() and not thread.daemon]\n    timeout = 60\n    for thread in threads:\n        timeout = min(timeout, 60 / len(threads))\n    for thread in threads:\n        if not thread.is_alive():\n            continue\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            _LOGGER.warning(f\"Failed to join thread {thread}: {e}\")\n\n", "CodeBleu_score": 37.79306017314333}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = threading.enumerate()\n    threads.remove(threading.current_thread())\n    for thread in threads:\n        if not thread.daemon and thread.is_alive():\n            timeout = SHUTDOWN_TIMEOUT / len(threads)\n            try:\n                thread.join(timeout)\n            except Exception:\n                _LOGGER.warning(\"Failed to join thread %s\", thread)\n\n", "CodeBleu_score": 34.26871026109978}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n        self._remaining_with_setup_started = {}\n\n\n def _async_dispatcher_send_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal\" sends an internal dispatcher signal with the remaining setups.", "CodeBleu_score": 49.419649630305535}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    self._remaining_with_setup_started = {}\n\n\n def _async_dispatcher_send_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal\" sends an internal dispatcher signal with the remaining setups.", "CodeBleu_score": 49.50653393995022}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if (remaining_with_setup_started and not self._remaining_with_setup_started):\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n        self._remaining_with_setup_started = True\n    elif (not remaining_with_setup_started and self._remaining_with_setup_started):\n        self._async_dispatcher_send_internal({})\n        self._remaining_with_setup_started = False\n\n\n def _async_dispatcher_send_internal(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_internal\" sends an internal dispatcher signal with the remaining setups.\"\"\"\n    self._dispatcher_send_internal(remaining_with_setup_started)\n\n\n def _async_dispatcher_send(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send\" sends a dispatcher signal with the remaining setups.\"\"\"\n    self._dispatcher_send(remaining_with_setup_started)\n\n\n def _async_dispatcher_send_with_setup_started(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_with_setup_started\" sends a dispatcher signal with the remaining setups and the setup started flag.\"\"\"\n    self._dispatcher_send_with_setup_started(remaining_with_setup_started)\n\n\n def _async_dispatcher_send_with_setup_started_and_remaining(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_with_setup_started_and_remaining\" sends a dispatcher signal with the remaining setups and the setup started flag.\"\"\"\n    self._dispatcher_send_with_setup_started_and_remaining(remaining_with_setup_started)\n\n\n def _async_dispatcher_send_with_setup_started_and_remaining_and_time(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher_send_with_setup_started_and_remaining_and_time\" sends a dispatcher signal with the remaining setups, the setup started flag and the time.\"\"\"\n    self._dispatcher_send_with", "CodeBleu_score": 47.077005590290625}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # The function \"validate\" verifies the correctness of the bluetooth.py file for Home Assistant.\n    # It generates and validates the Bluetooth content based on provided integrations and stores it in the configuration cache.\n    # If specific integrations are not being validated, it reads the current content of bluetooth.py and compares it with the generated content.\n    # If the contents differ, it adds an error to the configuration indicating that bluetooth.py is not up to date and provides a fixable suggestion.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called by the \"generate_and_validate\" function.\n    # The function \"validate\" is called", "CodeBleu_score": 7.494588744588746}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.integrations is None:\n        return\n    for integration in config.integrations:\n        if integration not in integrations:\n            continue\n        integration_config = integrations[integration]\n        if integration_config.fixable:\n            continue\n        if integration_config.content is None:\n            continue\n        if integration_config.content == config.content:\n            continue\n        config.add_error(\n            f\"The content of {integration} has changed since the last update. Please update the content of bluetooth.py manually.\"\n        )\n\n", "CodeBleu_score": 28.131817894402577}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if integrations is None:\n        return\n    for integration in integrations.values():\n        if integration.config_flow:\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.domain not in config.integrations:\n            continue\n        if integration.domain == \"bluetooth\":\n            continue\n        if integration.", "CodeBleu_score": 19.38145244281411}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp DropboxTokenResponse\n\tvar e error\n\n\t// Send a POST request to the Dropbox OAuth2 token endpoint with the refresh token, app key, and app secret.\n\tif e = base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.TokenEndpoint); e!= nil {\n\t\treturn e\n\t}\n\n\t// If the request succeeds, update the access token.\n\tif resp.AccessToken!= \"\" {\n\t\td.AccessToken = resp.AccessToken\n\t\treturn nil\n\t}\n\n\t// Otherwise, log the response and return an error.\n\tlogger.Info(fmt.Sprintf(\"Failed to refresh Dropbox access token: %s\", e.Error()))\n\treturn e\n}", "CodeBleu_score": 57.974580936721665}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}\n\tvar e error\n\tres := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Endpoint + \"/oauth2/token\")\n\tif res.Error()!= nil {\n\t\tlogger.Error(res.String())\n\t\treturn res.Error()\n\t}\n\tif res.StatusCode()!= 200 {\n\t\tlogger.Error(res.String())\n\t\treturn fmt.Errorf(\"status code: %d\", res.StatusCode())\n\t}\n\td.AccessToken = resp.AccessToken\n\td.TokenType = resp.TokenType\n\td.ExpiresIn = resp.ExpiresIn\n\treturn nil\n}", "CodeBleu_score": 60.09927930382685}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t}\n\n\tvar e error\n\tif _, e = base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.TokenEndpoint); e!= nil {\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\td.ExpiresIn = resp.ExpiresIn\n\td.TokenType = resp.TokenType\n\treturn nil\n}", "CodeBleu_score": 54.48334375658801}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar req *resty.Request\n\tif resp!= nil {\n\t\treq = d.request(url, method, callback)\n\t\treq.SetResult(resp)\n\t} else {\n\t\treq = d.request(url, method, nil)\n\t}\n\tresp, err := req.Execute()\n\tif err!= nil {\n\t\tif resp!= nil {\n\t\t\tif resp.StatusCode() == http.StatusUnauthorized {\n\t\t\t\tif err := d.refreshToken(); err!= nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn d.request(url, method, callback, resp)\n\t\t\t}\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn resp.Body(), nil\n}", "CodeBleu_score": 42.06441704199686}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R().\n\t\tSetError(func(r *resty.Response, err error) error {\n\t\t\tif r.StatusCode() == 401 {\n\t\t\t\td.refreshToken()\n\t\t\t}\n\t\t\treturn err\n\t\t}).\n\t\tSetHeader(\"Authorization\", \"Bearer \"+d.token)\n\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\n\tif resp!= nil {\n\t\treq.SetResult(resp)\n\t}\n\n\treq.SetQueryParam(\"alt\", \"json\")\n\treq.SetQueryParam(\"fields\", \"nextPageToken, files(id, name, mimeType, parents, size, createdTime, modifiedTime, modifiedByMeTime, shared, trashed, version, labels(starred), viewedByMeTime, viewersCanCopyContent)\")\n\n\tvar err error\n\tvar respBody []byte\n\n\tfor i := 0; i < 3; i++ {\n\t\trespBody, err = req.Execute(method, url)\n\t\tif err!= nil {\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn respBody, nil\n}", "CodeBleu_score": 50.79485936194177}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R().SetError(d.err).SetResult(resp)\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetHeader(\"Content-Type\", \"application/json\")\n\treq.SetQueryParam(\"access_token\", d.accessToken)\n\treq.SetQueryParam(\"alt\", \"json\")\n\treq.SetQueryParam(\"fields\", \"nextPageToken, files(id, name, mimeType, parents, size, modifiedTime, createdTime, webViewLink, webContentLink, iconLink, fileExtension, md5Checksum, quotaBytesUsed, headRevisionId, version, labels, capabilities, viewedByMe, viewedByMeTime, createdByMeTime, modifiedByMeTime, sharedWithMeTime, viewedByMeTime, modifiedByMe, sharedWithMe, owners, lastModifyingUser, lastModifyingUserId, owners, lastModifyingUserId, lastModifyingUser, shared, sharedWithMe, explicitShared, trashed, appDataContents, headRevisionId, headRevision, size, fileExtension, md5Checksum, contentHints, viewersCanCopyContent, writersCanShare, userPermission, permissions, capabilities, capabilities.canReadRevisions, capabilities.canAddChildren, capabilities.canAddFolder, capabilities.canAddFile, capabilities.canCopy, capabilities.canDelete, capabilities.canMoveInto, capabilities.canMoveOutOf, capabilities.canMove, capabilities.canReadRevisions, capabilities.canRename, capabilities.canShare, capabilities.canTrash, capabilities.canUntrash, capabilities.canComment, capabilities.canAddPermission, capabilities.canRead, capabilities.canWrite, capabilities.canAddAppPermission, capabilities.canAddUserPermission, capabilities.canDeleteRevisions, capabilities.canRestoreRevision, capabilities.canListRevisions, capabilities.canAddTrashed, capabilities.canDeleteForever, capabilities.canReadDrive, capabilities.canWriteDrive, capabilities.canList, capabilities.canListChildren, capabilities.canReadTeamDrive, capabilities.canWriteTeamDrive, capabilities.canReadAppPermission, capabilities.canWriteAppPermission, capabilities.canReadTeamDrive, capabilities.canWriteTeamDrive, capabilities.canReadTeamDriveMetadata, capabilities.canWriteTeamDriveMetadata, capabilities.canReadTeamDrivePermissions, capabilities.canWriteTeamDrivePermissions, capabilities.canReadTeamDriveMembers, capabilities.", "CodeBleu_score": 19.078188741433955}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tvar err error\n\tchunkSize := int64(d.chunkSize)\n\tfinish := int64(0)\n\tfor {\n\t\tif err = utils.IsCanceled(ctx); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\treq := d.request(url, \"PUT\", stream.GetReadCloser(), stream.GetSize())\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetContext(ctx)\n\t\tif _, err = req.Do(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif finish+chunkSize >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 55.70140440177518}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Set the chunk size to 100 MB.\n\tchunkSize := 100 * 1024 * 1024\n\n\t// Get the size of the file.\n\tsize := stream.GetSize()\n\n\t// Initialize the request with the URL and the context.\n\treq := d.request(url, ctx)\n\n\t// Set the headers for the request.\n\treq.SetHeaders(map[string]string{\n\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", 0, chunkSize-1, size),\n\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize))\n\n\t// Send the request and handle the response.\n\tresp, err := req.Send()\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check for context cancellation.\n\tif utils.IsCanceled(ctx) {\n\t\treturn ctx.Err()\n\t}\n\n\t// Check for the status code.\n\tif resp.StatusCode!= http.StatusCreated {\n\t\treturn fmt.Errorf(\"failed to upload chunk: status code: %d\", resp.StatusCode)\n\t}\n\n\t// Get the response body.\n\tbody, err := io.ReadAll(resp.Body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check for context cancellation.\n\tif utils.IsCanceled(ctx) {\n\t\treturn ctx.Err()\n\t}\n\n\t// Check if the response body is empty.\n\tif len(body) == 0 {\n\t\treturn fmt.Errorf(\"failed to upload chunk: empty response body\")\n\t}\n\n\t// Get the upload URL from the response body.\n\tuploadURL := string(body)\n\n\t// Calculate the remaining size.\n\tremainingSize := size - chunkSize\n\n\t// Upload the remaining chunks.\n\tfor remainingSize > 0 {\n\t\t// Set the chunk size.\n\t\tchunkSize = remainingSize\n\t\tif chunkSize > 100*1024*1024 {\n\t\t\tchunkSize = 100 * 1024 * 1024\n\t\t}\n\n\t\t//", "CodeBleu_score": 54.028095340315076}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size based on the file size and the maximum chunk size limit.\n\tchunkSize := d.chunkSize\n\tif stream.GetSize() < d.chunkSize {\n\t\tchunkSize = stream.GetSize()\n\t}\n\n\t// Upload the file in chunks.\n\tfor finish := 0; finish < stream.GetSize(); finish += chunkSize {\n\t\t// Check for context cancellation.\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn errors.New(\"upload cancelled\")\n\t\t}\n\n\t\t// Create a request for the chunk.\n\t\treq, err := d.request(ctx, url, http.MethodPut)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the headers for the chunk.\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize))\n\n\t\t// Set the context for the request.\n\t\treq.SetContext(ctx)\n\n\t\t// Send the request to Google Drive.\n\t\t_, err = req.Do()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 57.2574414482076}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req MyService_UmountStorageRequest\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn common_err.GetMsg(ctx, err, \"Bind request error\")\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn common_err.GetMsg(ctx, err, \"Mount point is empty\")\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err!= nil {\n\t\treturn common_err.GetMsg(ctx, err, \"Unmount storage error\")\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err!= nil {\n\t\treturn common_err.GetMsg(ctx, err, \"Delete config error\")\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(ctx, nil, \"Success\"))\n}", "CodeBleu_score": 43.17205863844419}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar (\n\t\treq    = new(types.UmountStorageReq)\n\t\tresp   = new(types.UmountStorageResp)\n\t\terr    error\n\t\tconfig *types.StorageConfig\n\t)\n\n\tif err = ctx.Bind(req); err!= nil {\n\t\treturn common_err.GetMsg(ctx, common_err.ErrInvalidParam, err.Error())\n\t}\n\n\tif req.MountPoint == \"\" {\n\t\treturn common_err.GetMsg(ctx, common_err.ErrInvalidParam, \"Mount point cannot be empty\")\n\t}\n\n\tif config, err = service.MyService.Storage().DeleteConfigByName(req.MountPoint); err!= nil {\n\t\treturn common_err.GetMsg(ctx, common_err.ErrStorageUnmount, err.Error())\n\t}\n\n\tif err = service.MyService.Storage().UnmountStorage(config.MountPoint); err!= nil {\n\t\treturn common_err.GetMsg(ctx, common_err.ErrStorageUnmount, err.Error())\n\t}\n\n\tresp.MountPoint = req.MountPoint\n\treturn ctx.JSON(http.StatusOK, resp)\n}", "CodeBleu_score": 30.829552004071314}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar (\n\t\treq  storage.UmountStorageRequest\n\t\tresp *storage.UmountStorageResponse\n\t)\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn common_err.GetMsg(err, \"Failed to bind request body\")\n\t}\n\tif req.MountPoint == \"\" {\n\t\treturn common_err.GetMsg(errors.New(\"Mount point is required\"), \"Failed to unmount storage\")\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err!= nil {\n\t\treturn common_err.GetMsg(err, \"Failed to unmount storage\")\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err!= nil {\n\t\treturn common_err.GetMsg(err, \"Failed to delete config\")\n\t}\n\tresp = &storage.UmountStorageResponse{}\n\treturn ctx.JSON(http.StatusOK, resp)\n}", "CodeBleu_score": 39.04388887029503}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tpath := ctx.QueryParam(\"path\")\n\t// Check if the path is provided\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(\"path_missing\"))\n\t}\n\t// Check if the file exists\n\tif!file.Exists(path) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(\"file_not_found\"))\n\t}\n\t// Return the file to the client\n\treturn ctx.File(path)\n}", "CodeBleu_score": 38.48645705489842}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tpath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing path parameter\"})\n\t}\n\n\t// Check if the file exists\n\tif!file.Exists(path) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\n\t// Read the file contents\n\tfileBytes, err := ioutil.ReadFile(path)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Error reading file\"})\n\t}\n\n\t// Return the file contents as a response\n\treturn ctx.JSON(http.StatusOK, fileBytes)\n}", "CodeBleu_score": 39.32483029354529}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided\n\tif filePath == \"\" {\n\t\treturn common_err.GetMsg(\"No file path provided\")\n\t}\n\n\t// Check if the file exists\n\tif!file.Exists(filePath) {\n\t\treturn common_err.GetMsg(\"File not found\")\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 27.678460414775024}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequestError(err.Error()))\n\t}\n\n\t// Send the notification using the \"name\" and \"message\"\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err.Error()))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.NewSuccessResponse())\n}", "CodeBleu_score": 57.9499230506597}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tvar msg map[string]string\n\tif err := ctx.Bind(&msg); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequestError(err.Error()))\n\t}\n\n\t// Send the notification using the \"name\" and \"message\" from the message map.\n\tif err := service.MyService.Notify().SendNotify(name, msg[\"message\"]); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalError(err.Error()))\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent successfully!\"})\n}", "CodeBleu_score": 52.968833807777486}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tif err := service.MyService.Notify().SendNotify(message[\"name\"], message[\"message\"]); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, \"Notification sent successfully\")\n}", "CodeBleu_score": 45.97862292448274}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Request(), ctx.Response(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service\n\tgo sendMeg(ws)\n\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type and message\n\t\tfmt.Println(\"Message type:\", msg.Type)\n\t\tfmt.Println(\"Message:\", string(msg.Data))\n\t}\n\n\t// Remove the WebSocket connection from the list of connections\n\tfor i, conn := range connections {\n\t\tif conn == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.9012505353347}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP GET request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service.\n\tgo SendMeg(ws)\n\n\t// Enter a loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read the next message from the WebSocket connection.\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Println(\"Message type:\", msgType)\n\t\tfmt.Println(\"Message:\", string(msg))\n\t\tfmt.Println(\"Error:\", err)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\tfor i, connection := range connections {\n\t\tif connection == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.49999528164104}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\n\t// Start a goroutine to send messages to the WebSocket connection.\n\tgo sendMessages(ws)\n\n\t// Read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Message type:\", msgType)\n\t\tfmt.Println(\"Message:\", string(msg))\n\t\tfmt.Println(\"Error:\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.81913304873088}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get drive model\n\tdriveModel, err := common_err.GetMsg(service.MyService.System().GetDriveModel())\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.New(http.StatusInternalServerError, err.Error()))\n\t}\n\n\t// Get CPU information\n\tcpuInfo, err := common_err.GetMsg(service.MyService.System().GetCpuInfo())\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.New(http.StatusInternalServerError, err.Error()))\n\t}\n\n\t// Get device tree\n\tdeviceTree, err := common_err.GetMsg(service.MyService.System().GetDeviceTree())\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.New(http.StatusInternalServerError, err.Error()))\n\t}\n\n\t// Return JSON response\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\": \"Success\",\n\t\t\"data\": map[string]interface{}{\n\t\t\t\"driveModel\": driveModel,\n\t\t\t\"cpuInfo\":    cpuInfo,\n\t\t\t\"deviceTree\": deviceTree,\n\t\t},\n\t})\n}", "CodeBleu_score": 25.656943886488747}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the drive model and architecture\n\tdriveModel, err := common_err.GetMsg(disk.GetDriveModel())\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\tarch, err := common_err.GetMsg(common.GetArch())\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Get CPU information\n\tcpuInfo, err := service.MyService.System().GetCpuInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// If CPU information is available, return it\n\tif cpuInfo!= nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(nil, \"success\", map[string]string{\"cpuInfo\": cpuInfo.String()}))\n\t}\n\n\t// If CPU information is not available, return \"nil\"\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(nil, \"success\", map[string]string{\"cpuInfo\": \"nil\"}))\n}", "CodeBleu_score": 25.887140999299916}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar (\n\t\tdata    map[string]interface{}\n\t\terr     error\n\t\tcpuInfo *common_err.CpuInfo\n\t)\n\tdata = make(map[string]interface{})\n\tdata[\"message\"] = \"success\"\n\tdata[\"data\"] = make(map[string]interface{})\n\tdata[\"data\"].(map[string]interface{})[\"drive\"] = service.MyService.System().GetDriveModel()\n\tdata[\"data\"].(map[string]interface{})[\"arch\"] = service.MyService.System().GetArch()\n\tcpuInfo, err = service.MyService.System().GetCpuInfo()\n\tif err!= nil {\n\t\tdata[\"message\"] = \"error\"\n\t\tdata[\"data\"] = err.Error()\n\t} else {\n\t\tdata[\"data\"].(map[string]interface{})[\"cpu\"] = cpuInfo\n\t}\n\treturn ctx.JSON(http.StatusOK, data)\n}", "CodeBleu_score": 32.615791340999856}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := []*string{}\n\tnotRunningServices := []*string{}\n\n\tfor _, service := range services {\n\t\tif service.Status == \"active\" {\n\t\t\trunningServices = append(runningServices, &service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, &service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 56.99985955226079}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunningServices := make([]*[]string, 0)\n\tnotRunningServices := make([]*[]string, 0)\n\tfor _, service := range services {\n\t\tif strings.Contains(service.Name, \"casaos\") {\n\t\t\tif service.Active {\n\t\t\t\trunningServices = append(runningServices, &service.Name)\n\t\t\t} else {\n\t\t\t\tnotRunningServices = append(notRunningServices, &service.Name)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 56.470727893732416}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar services map[bool]*[]string = make(map[bool]*[]string)\n\tservices[true] = new([]string)\n\tservices[false] = new([]string)\n\n\tservicesMap, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tfor serviceName, serviceStatus := range servicesMap {\n\t\tif serviceStatus.Active {\n\t\t\t*services[true] = append(*services[true], serviceName)\n\t\t} else {\n\t\t\t*services[false] = append(*services[false], serviceName)\n\t\t}\n\t}\n\n\treturn services, nil\n}", "CodeBleu_score": 38.16268619696646}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tlogger := i.logger.With(zap.String(\"name\", name))\n\tlogger.Info(\"Sending notification\")\n\n\t// Serialize the message values to JSON strings\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to serialize message values to JSON\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to a message bus\n\tresponse, err := i.messageBus.PublishEventWithResponse(context.Background(), name, messageJSON)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event to message bus\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Log the response details if the status code is not OK\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event to message bus\",\n\t\t\tzap.String(\"status_code\", response.Status),\n\t\t\tzap.String(\"response_body\", response.Body))\n\t}\n}", "CodeBleu_score": 44.40936175846663}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings.\n\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to serialize message values to JSON\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\tresponse, err := i.messageBus.PublishEventWithResponse(context.Background(), name, string(jsonMessage))\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Check the response status code.\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.String(\"message\", string(jsonMessage)), zap.String(\"response\", response.Status))\n\t\treturn\n\t}\n}", "CodeBleu_score": 41.763708087860714}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tlogger.Info(\"Sending notification\", zap.String(\"name\", name), zap.Any(\"message\", message))\n\tresponse, err := i.MessageBus().PublishEventWithResponse(context.Background(), name, message)\n\tif err!= nil {\n\t\tlogger.Error(\"Error sending notification\", zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"Error sending notification\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.String(\"response\", response.Status))\n\t\treturn\n\t}\n}", "CodeBleu_score": 37.78268175717431}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\treturn message_bus.NewClientWithResponses(c.server)\n}", "CodeBleu_score": 7.130764542958483}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\treturn message_bus.NewClientWithResponses(c.server, c.runtimePath)\n}", "CodeBleu_score": 7.53005120589217}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\treturn message_bus.NewClientWithResponses(c.client)\n}", "CodeBleu_score": 7.136711282175556}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tif ip := request.Header.Get(\"X-Forwarded-For\"); ip!= \"\" {\n\t\treturn strings.Split(ip, \",\")[0]\n\t}\n\tif ip := request.Header.Get(\"X-Real-Ip\"); ip!= \"\" {\n\t\treturn ip\n\t}\n\treturn request.RemoteAddr\n}", "CodeBleu_score": 33.07655220546034}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"X-Forwarded-For\")\n\tif ip!= \"\" {\n\t\tip = strings.Split(ip, \",\")[0]\n\t} else {\n\t\tip = request.RemoteAddr\n\t}\n\n\tif ip!= \"\" {\n\t\tip = strings.TrimSpace(strings.Split(ip, \":\")[0])\n\t}\n\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 72.98289576208728}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"X-Forwarded-For\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip!= \"\" {\n\t\tips := strings.Split(ip, \",\")\n\t\tip = ips[0]\n\t}\n\tif ip == \"\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 60.49820362835865}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Define the modules directory path and entry file path.\n\tmodulesDir := filepath.Join(c.config.ModulesDir, \"system\")\n\tentryFile := filepath.Join(c.config.ModulesDir, \"system\", \"entry.json\")\n\n\t// Open the entry file for writing.\n\tfile, err := os.OpenFile(entryFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)\n\tif err!= nil {\n\t\tlogger.Error(\"Error opening entry file for writing: %v\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Initialize a buffer for writing the JSON array.\n\tbuffer := &bytes.Buffer{}\n\n\t// Iterate over the modules directory and read each entry file.\n\terr = filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"Error reading entry file: %v\", err)\n\t\t\treturn err\n\t\t}\n\t\tif!info.IsDir() && strings.HasSuffix(path, \"entry.json\") {\n\t\t\t// Open the entry file for reading.\n\t\t\tfile, err := os.Open(path)\n\t\t\tif err!= nil {\n\t\t\t\tlogger.Error(\"Error opening entry file for reading: %v\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\t// Read the entry file content.\n\t\t\tcontent, err := io.ReadAll(file)\n\t\t\tif err!= nil {\n\t\t\t\tlogger.Error(\"Error reading entry file content: %v\", err)\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Write the entry file content to the buffer.\n\t\t\t_, err = buffer.Write(content)\n\t\t\tif err!= nil {\n\t\t\t\tlogger.Error(\"Error writing entry file content to buffer: %v\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err!= nil {\n\t\tlogger.Error(\"Error walking the modules directory: %v\", err)\n\t\treturn\n\t}\n\n\t// Write the JSON array to the entry file.\n\t_, err = file.Write(buffer.Bytes())\n\tif err!= nil {\n\t\tlogger.Error(\"Error writing the JSON array to the entry file", "CodeBleu_score": 42.975476608385044}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Define the paths for the modules directory and the entry file\n\tmodulesDir := filepath.Join(c.config.ModulesPath, \"system\")\n\tentryFile := filepath.Join(c.config.ModulesPath, \"system\", \"entry.json\")\n\n\t// Read each module directory for entry.json files\n\tentries := []string{}\n\terr := filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.Contains(path, \"entry.json\") {\n\t\t\t// Read the entry.json file\n\t\t\tentry, err := os.ReadFile(path)\n\t\t\tif err!= nil {\n\t\t\t\tlogger.Error(\"Failed to read entry.json file\", zap.Error(err))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// Append the content of the entry.json file to the entries array\n\t\t\tentries = append(entries, string(entry))\n\t\t}\n\t\treturn nil\n\t})\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to walk the modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Concatenate the entries array into a single JSON array\n\tentry := \"[\" + strings.Join(entries, \",\") + \"]\"\n\n\t// Write the entry file with the concatenated entries\n\terr = os.WriteFile(entryFile, []byte(entry), 0644)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to write entry file\", zap.Error(err))\n\t}\n}", "CodeBleu_score": 50.057262440828396}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Define the path for the modules directory and the entry file\n\tmodulesDir := filepath.Join(c.conf.ModulesDir, c.conf.ModulesSubDir)\n\tentryFile := filepath.Join(c.conf.ModulesDir, c.conf.ModulesSubDir, c.conf.ModulesEntryFile)\n\n\t// Create the entry file if it does not exist\n\tif!file.IsExist(entryFile) {\n\t\terr := file.CreateFile(entryFile)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"Failed to create entry file: \" + err.Error())\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tentries := make([]string, 0)\n\tdirs, err := os.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to read modules directory: \" + err.Error())\n\t\treturn\n\t}\n\tfor _, dir := range dirs {\n\t\tif dir.IsDir() {\n\t\t\tentryPath := filepath.Join(modulesDir, dir.Name(), c.conf.ModulesEntryFile)\n\t\t\tif file.IsExist(entryPath) {\n\t\t\t\tcontent, err := os.ReadFile(entryPath)\n\t\t\t\tif err!= nil {\n\t\t\t\t\tlogger.Error(\"Failed to read entry file: \" + err.Error())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tentries = append(entries, string(content))\n\t\t\t}\n\t\t}\n\t}\n\n\t// Concatenate the content of the entry.json files into a single JSON array\n\tcontent := \"[\" + strings.Join(entries, \",\") + \"]\"\n\n\t// Write the content to the entry file\n\terr := os.WriteFile(entryFile, []byte(content), 0644)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to write to entry file: \" + err.Error())\n\t\treturn\n\t}\n\n\tlogger.Info(\"Entry file generated successfully.\")\n}", "CodeBleu_score": 41.04347271558421}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tnetInterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.System().GetNet()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, netInterface := range netInterfaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif netInterface.Name == netName {\n\t\t\t\treturn netInterface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 57.073695995042904}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 60.19697673223352}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tnetworkNames, err := c.System().GetNet()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range interfaces {\n\t\tfor _, networkName := range networkNames {\n\t\t\tif iface.Name == networkName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 60.668041932144746}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t ret = TSC_OK;\n\tuint32_t old_req_count;\n\tuint32_t old_req_total;\n\tuint32_t old_req_current;\n\n\t/*\n\t * Add a reference to the request object.\n\t */\n\tatomic_add_fetch_64(&pRequest->ref_count, 1);\n\n\t/*\n\t * Increment the request count for the associated TSC object.\n\t */\n\told_req_count = atomic_add_fetch_32(&pTscObj->request_count, 1);\n\tif (old_req_count == 0) {\n\t\t/*\n\t\t * The TSC object's request count was zero.\n\t\t */\n\t\told_req_total = atomic_add_fetch_32(&pTscObj->request_total, 1);\n\t\told_req_current = atomic_add_fetch_32(&pTscObj->request_current, 1);\n\t} else {\n\t\t/*\n\t\t * The TSC object's request count was not zero.\n\t\t */\n\t\told_req_total = atomic_add_fetch_32(&pTscObj->request_total, 1);\n\t\told_req_current = atomic_add_fetch_32(&pTscObj->request_current, 1);\n\t}\n\n\t/*\n\t * Update the application's request summary, including total and current request counts.\n\t */\n\tif (pTscObj->application_id!= 0) {\n\t\t/*\n\t\t * The TSC object has application information.\n\t\t */\n\t\told_req_count = atomic_add_fetch_32(&pTscObj->application->request_count, 1);\n\t\tif (old_req_count == 0) {\n\t\t\t/*\n\t\t\t * The application's request count was zero.\n\t\t\t */\n\t\t\told_req_total = atomic_add_fetch_32(&pTscObj->application->request_total, 1);\n\t\t\told_req_current = atomic_add_fetch_32(&pTscObj->application->request_current, 1);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The application's request count was not zero.\n\t\t\t */\n\t\t\told_req_total = atomic_add_fetch_32(&", "CodeBleu_score": 37.27351002567989}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t ret = 0;\n\tint32_t refCount = 0;\n\n\t// Add a reference to the request object\n\trefCount = atomic_add_fetch_64(&pRequest->refCount, 1);\n\tif (refCount <= 0) {\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t// Increment the request count for the TSC object\n\tatomic_add_fetch_64(&pTscObj->requestCount, 1);\n\tif (pTscObj->applicationId!= 0) {\n\t\tatomic_add_fetch_64(&pTscObj->applicationRequestCount, 1);\n\t}\n\n\t// Update the application summary\n\tif (pTscObj->applicationId!= 0) {\n\t\tatomic_add_fetch_64(&pTscObj->applicationSummary.totalRequestCount, 1);\n\t\tatomic_add_fetch_64(&pTscObj->applicationSummary.currentRequestCount, 1);\n\t}\n\n\t// Log debug information\n\tlogDebug(pRequest, pTscObj, \"Request registered\");\n\ndone:\n\treturn ret;\n}", "CodeBleu_score": 40.70378216319716}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\tuint64_t requestCount = 0;\n\tuint64_t requestCountTotal = 0;\n\tuint64_t requestCountCurrent = 0;\n\tuint64_t requestCountTotalCurrent = 0;\n\tuint64_t requestCountTotalCurrentMax = 0;\n\tuint64_t requestCountTotalCurrentMin = 0;\n\tuint64_t requestCountTotalCurrentAvg = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvg = 0;\n\tuint64_t requestCountTotalCurrentMinAvg = 0;\n\tuint64_t requestCountTotalCurrentMaxAvg = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvg = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgMin = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgMax = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvg = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgMin = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgMax = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgAvgMin = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgAvgMax = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgAvgAvg = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgAvgAvgMin = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgAvgAvgMax = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgAvgAvgAvg = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgAvgAvgAvgMin = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgAvgAvgAvgMax = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgAvgAvgAvgAvg = 0;\n\tuint64_t requestCountTotalCurrentMaxMinAvgAvgAvgAvg", "CodeBleu_score": 5.9698059955070315}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->pPrimaryDb!= NULL) {\n\t\tif (strcmp(pRequest->pPrimaryDb, exceptDb)!= 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tint i;\n\tfor (i = 0; i < pRequest->dbCount; i++) {\n\t\tif (strstr(pRequest->pDbNames[i], exceptDb) == NULL) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 45.83343927323275}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (strcmp(pRequest->db, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tchar *db = pRequest->db;\n\tchar *pos = strchr(db, '.');\n\tif (pos!= NULL) {\n\t\t*pos = '\\0';\n\t}\n\n\twhile (pos!= NULL) {\n\t\tif (strcmp(db, exceptDb)!= 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tpos = strchr(pos + 1, '.');\n\t\tif (pos!= NULL) {\n\t\t\t*pos = '\\0';\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 45.53636942565334}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (strcmp(pRequest->pPrimaryDb, exceptDb)!= 0) {\n\t\tchar *pDb = pRequest->pPrimaryDb;\n\t\twhile ((pDb = strchr(pDb, '.'))!= NULL) {\n\t\t\tpDb++;\n\t\t\tif (strcmp(pDb, exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 39.8724163675986}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool retval = false;\n\n\tif (code == ERROR_CODE_REDIRECT) {\n\t\tswitch (msgType) {\n\t\tcase TMSG_TYPE_CLIENT_RPC_REQUEST:\n\t\tcase TMSG_TYPE_CLIENT_RPC_RESPONSE:\n\t\tcase TMSG_TYPE_CLIENT_RPC_REQUEST_RESPONSE:\n\t\tcase TMSG_TYPE_CLIENT_RPC_REQUEST_RESPONSE_ACK:\n\t\tcase TMSG_TYPE_CLIENT_RPC_REQUEST_RESPONSE_NACK:\n\t\tcase TMSG_TYPE_CLIENT_RPC_REQUEST_RESPONSE_ACK_NACK:\n\t\tcase TMSG_TYPE_CLIENT_RPC_REQUEST_RESPONSE_ACK_NACK_REDIRECT:\n\t\tcase TMSG_TYPE_CLIENT_RPC_REQUEST_RESPONSE_ACK_NACK_REDIRECT_ERROR:\n\t\tcase TMSG_TYPE_CLIENT_RPC_REQUEST_RESPONSE_ACK_NACK_REDIRECT_ERROR_REDIRECT:\n\t\t\tretval = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn retval;\n}", "CodeBleu_score": 29.37392490644118}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == RPC_ERROR_NEED_REDIRECT_ERROR && msgType!= RPC_MSG_TYPE_RESPONSE) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 27.143017916386114}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == RPC_REDIRECT_ERROR) {\n\t\tswitch (msgType) {\n\t\tcase tmsg_t::TMSG_GET_HOST_BY_NAME_R:\n\t\tcase tmsg_t::TMSG_GET_HOST_BY_ADDR_R:\n\t\tcase tmsg_t::TMSG_GET_HOST_BY_ADDR_R_V6:\n\t\tcase tmsg_t::TMSG_GET_HOST_BY_NAME_R_V6:\n\t\tcase tmsg_t::TMSG_GET_HOST_BY_ADDR_R_V4:\n\t\tcase tmsg_t::TMSG_GET_HOST_BY_NAME_R_V4:\n\t\tcase tmsg_t::TMSG_GET_HOST_BY_NAME_R_V4_V6:\n\t\tcase tmsg_t::TMSG_GET_HOST_BY_ADDR_R_V4_V6:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 36.020845185161285}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i;\n\tfor (i = 0; i < pRequests->size; i++) {\n\t\tif (pRequests->table[i]!= NULL) {\n\t\t\tacquireRequest(pRequests, i);\n\t\t\tif (pRequests->table[i]->query!= NULL) {\n\t\t\t\ttaos_stop_query(pRequests->table[i]->query);\n\t\t\t}\n\t\t\treleaseRequest(pRequests, i);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.675188297165576}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint l = 0;\n\tint m = 0;\n\tint n = 0;\n\tint o = 0;\n\tint p = 0;\n\tint q = 0;\n\tint r = 0;\n\tint s = 0;\n\tint t = 0;\n\tint u = 0;\n\tint v = 0;\n\tint w = 0;\n\tint x = 0;\n\tint y = 0;\n\tint z = 0;\n\tint aa = 0;\n\tint ab = 0;\n\tint ac = 0;\n\tint ad = 0;\n\tint ae = 0;\n\tint af = 0;\n\tint ag = 0;\n\tint ah = 0;\n\tint ai = 0;\n\tint aj = 0;\n\tint ak = 0;\n\tint al = 0;\n\tint am = 0;\n\tint an = 0;\n\tint ao = 0;\n\tint ap = 0;\n\tint aq = 0;\n\tint ar = 0;\n\tint as = 0;\n\tint at = 0;\n\tint au = 0;\n\tint av = 0;\n\tint aw = 0;\n\tint ax = 0;\n\tint ay = 0;\n\tint az = 0;\n\tint ba = 0;\n\tint bb = 0;\n\tint bc = 0;\n\tint bd = 0;\n\tint be = 0;\n\tint bf = 0;\n\tint bg = 0;\n\tint bh = 0;\n\tint bi = 0;\n\tint bj = 0;\n\tint bk = 0;\n\tint bl = 0;\n\tint bm = 0;\n\tint bn = 0;\n\tint bo = 0;\n\tint bp = 0;\n\tint bq = 0;\n\tint br = 0;\n\tint bs = 0;\n\tint bt = ", "CodeBleu_score": 5.180423228820835}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i;\n\tfor (i = 0; i < pRequests->size; i++) {\n\t\tif (pRequests->table[i]!= NULL) {\n\t\t\ttaos_stop_query(pRequests->table[i]->reqID);\n\t\t\treleaseRequest(pRequests->table[i]);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.043729758558115}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (crashReportEnabled) {\n\t\tint result = atomic_val_compare_exchange_32(&clientStop, 0, 1);\n\t\tif (result == 0) {\n\t\t\tprintf(\"Warning: Crash report thread is already stopped\n\");\n\t\t\treturn;\n\t\t}\n\t\twhile (clientStop) {\n\t\t\tsleep(1);\n\t\t}\n\t}\n}", "CodeBleu_score": 47.386613264363184}, {"code": "void tscStopCrashReport(){\n\t\tif (crashReportEnabled) {\n\t\tif (atomic_val_compare_exchange_32(&clientStop, 1, 0) == 0) {\n\t\t\twhile (clientStop == 1) {\n\t\t\t\ttaosMsleep(100);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"crash report thread is already stopped\n\");\n\t\t}\n\t}\n}", "CodeBleu_score": 47.03614767700473}, {"code": "void tscStopCrashReport(){\n\t\tif (!crashReportEnabled) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&clientStop, 1, 1)) {\n\t\twhile (clientStop == 1) {\n\t\t\t;\n\t\t}\n\t} else {\n\t\tLOG_ERROR(\"Crash report thread already stopped\");\n\t}\n}", "CodeBleu_score": 43.59284647176459}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t rc = 0;\n\tint32_t i;\n\tint32_t numViews;\n\tint32_t numCols;\n\tint32_t numColsInCatalog;\n\tint32_t numColsInView;\n\tint32_t numColsInViewInCatalog;\n\tint32_t numColsInViewNotInCatalog;\n\tint32_t numColsInViewInCatalog;\n\tint32_t numColsInViewNotInCatalog;\n\tint32_t numColsInViewInCatalogAndNotInCatalog;\n\tint32_t numColsInViewNotInCatalogAndNotInCatalog;\n\tint32_t numColsInViewInCatalogAndInCatalog;\n\tint32_t numColsInViewNotInCatalogAndInCatalog;\n\tint32_t numColsInViewInCatalogAndNotInCatalogAndInCatalog;\n\tint32_t numColsInViewNotInCatalogAndNotInCatalogAndInCatalog;\n\tint32_t numColsInViewInCatalogAndNotInCatalogAndNotInCatalog;\n\tint32_t numColsInViewNotInCatalogAndInCatalogAndNotInCatalog;\n\tint32_t numColsInViewInCatalogAndInCatalogAndInCatalog;\n\tint32_t numColsInViewNotInCatalogAndInCatalogAndInCatalog;\n\tint32_t numColsInViewInCatalogAndInCatalogAndNotInCatalog;\n\tint32_t numColsInViewNotInCatalogAndNotInCatalogAndNotInCatalog;\n\tint32_t numColsInViewInCatalogAndNotInCatalogAndInCatalog;\n\tint32_t numColsInViewNotInCatalogAndNotInCatalogAndInCatalog;\n\tint32_t numColsInViewInCatalogAndNotInCatalogAndNotInCatalogAndInCatalog;\n\tint32_t numColsInViewNotInCatalogAndNotInCatalogAndNotInCatalogAndInCatalog;\n\tint32_t numColsInViewInCatalogAndNotInCatalogAndInCatalogAndNotInCatalog;\n\tint32_t numColsInViewNotInCatalogAndNotInCatalogAndInCatalogAndNotInCatalog;\n\tint32_t numColsInViewInCatalogAndNotInCatalogAndNotInCatalogAndInCatalog;\n\tint32_t numCols", "CodeBleu_score": 7.697634705852263}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t retCode = 0;\n\tstruct SViewMeta *pViewMeta = NULL;\n\tstruct SViewMeta *pViewMetaTemp = NULL;\n\tstruct SViewMeta *pViewMetaTemp2 = NULL;\n\tstruct SViewMeta *pViewMetaTemp3 = NULL;\n\tstruct SViewMeta *pViewMetaTemp4 = NULL;\n\tstruct SViewMeta *pViewMetaTemp5 = NULL;\n\tstruct SViewMeta *pViewMetaTemp6 = NULL;\n\tstruct SViewMeta *pViewMetaTemp7 = NULL;\n\tstruct SViewMeta *pViewMetaTemp8 = NULL;\n\tstruct SViewMeta *pViewMetaTemp9 = NULL;\n\tstruct SViewMeta *pViewMetaTemp10 = NULL;\n\tstruct SViewMeta *pViewMetaTemp11 = NULL;\n\tstruct SViewMeta *pViewMetaTemp12 = NULL;\n\tstruct SViewMeta *pViewMetaTemp13 = NULL;\n\tstruct SViewMeta *pViewMetaTemp14 = NULL;\n\tstruct SViewMeta *pViewMetaTemp15 = NULL;\n\tstruct SViewMeta *pViewMetaTemp16 = NULL;\n\tstruct SViewMeta *pViewMetaTemp17 = NULL;\n\tstruct SViewMeta *pViewMetaTemp18 = NULL;\n\tstruct SViewMeta *pViewMetaTemp19 = NULL;\n\tstruct SViewMeta *pViewMetaTemp20 = NULL;\n\tstruct SViewMeta *pViewMetaTemp21 = NULL;\n\tstruct SViewMeta *pViewMetaTemp22 = NULL;\n\tstruct SViewMeta *pViewMetaTemp23 = NULL;\n\tstruct SViewMeta *pViewMetaTemp24 = NULL;\n\tstruct SViewMeta *pViewMetaTemp25 = NULL;\n\tstruct SViewMeta *pViewMetaTemp26 = NULL;\n\tstruct SViewMeta *pViewMetaTemp27 = NULL;\n\tstruct SViewMeta *pViewMetaTemp28 = NULL;\n\tstruct SViewMeta *pViewMetaTemp29 = NULL;\n\tstruct SViewMeta *pViewMetaTemp30 = NULL;\n\tstruct SViewMeta *pViewMetaTemp31 = NULL;\n", "CodeBleu_score": 8.282393178313711}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t ret = 0;\n\tint32_t i;\n\tint32_t numViews;\n\tint32_t numCols;\n\tint32_t numColsInView;\n\tint32_t numColsInCatalog;\n\tint32_t numColsInCatalog2;\n\tint32_t numColsInCatalog3;\n\tint32_t numColsInCatalog4;\n\tint32_t numColsInCatalog5;\n\tint32_t numColsInCatalog6;\n\tint32_t numColsInCatalog7;\n\tint32_t numColsInCatalog8;\n\tint32_t numColsInCatalog9;\n\tint32_t numColsInCatalog10;\n\tint32_t numColsInCatalog11;\n\tint32_t numColsInCatalog12;\n\tint32_t numColsInCatalog13;\n\tint32_t numColsInCatalog14;\n\tint32_t numColsInCatalog15;\n\tint32_t numColsInCatalog16;\n\tint32_t numColsInCatalog17;\n\tint32_t numColsInCatalog18;\n\tint32_t numColsInCatalog19;\n\tint32_t numColsInCatalog20;\n\tint32_t numColsInCatalog21;\n\tint32_t numColsInCatalog22;\n\tint32_t numColsInCatalog23;\n\tint32_t numColsInCatalog24;\n\tint32_t numColsInCatalog25;\n\tint32_t numColsInCatalog26;\n\tint32_t numColsInCatalog27;\n\tint32_t numColsInCatalog28;\n\tint32_t numColsInCatalog29;\n\tint32_t numColsInCatalog30;\n\tint32_t numColsInCatalog31;\n\tint32_t numColsInCatalog32;\n\tint32_t numColsInCatalog33;\n\tint32_t num", "CodeBleu_score": 7.905049600124116}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3ResponsePropertiesCallbackData *data = (S3ResponsePropertiesCallbackData *)callbackData;\n\n\tif (properties!= NULL) {\n\t\tif (properties->contentLength > 0) {\n\t\t\tdata->contentLength = properties->contentLength;\n\t\t}\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 59.102972356727555}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3ResponsePropertiesCallbackData *callbackDataPtr = (S3ResponsePropertiesCallbackData *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tcallbackDataPtr->contentLength = properties->contentLength;\n\t} else {\n\t\tcallbackDataPtr->contentLength = 0;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 69.69155598748667}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3ResponsePropertiesCallbackData *responsePropertiesCallbackData = (S3ResponsePropertiesCallbackData *)callbackData;\n\tS3_LOG(S3_LOG_TRACE, \"responsePropertiesCallback: %s\n\", properties->resource);\n\n\tif (properties->contentLength > 0) {\n\t\tresponsePropertiesCallbackData->contentLength = properties->contentLength;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 55.88000642415246}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tint status;\n\tchar *checkpointDir = getenv(\"CHECKPOINT_DIR\");\n\tif (checkpointDir == NULL) {\n\t\tuError(\"CHECKPOINT_DIR is not set\");\n\t\treturn;\n\t}\n\tif (taosMulMkDir(checkpointDir, 0755) == -1) {\n\t\tuError(\"Failed to create checkpoint directory: %s\", checkpointDir);\n\t\treturn;\n\t}\n\tremoveEmptyDir(checkpointDir);\n\tgenerateConfigFile();\n\tchar *port = getenv(\"RSYNC_PORT\");\n\tif (port == NULL) {\n\t\tuError(\"RSYNC_PORT is not set\");\n\t\treturn;\n\t}\n\tchar *configFile = getenv(\"RSYNC_CONFIG\");\n\tif (configFile == NULL) {\n\t\tuError(\"RSYNC_CONFIG is not set\");\n\t\treturn;\n\t}\n\tchar *cmd = malloc(sizeof(char) * (strlen(RSYNC_CMD) + strlen(port) + strlen(configFile) + 1));\n\tif (cmd == NULL) {\n\t\tuError(\"Failed to allocate memory for Rsync command\");\n\t\treturn;\n\t}\n\tsnprintf(cmd, strlen(RSYNC_CMD) + strlen(port) + strlen(configFile) + 1, RSYNC_CMD, port, configFile);\n\tstatus = system(cmd);\n\tif (status == -1) {\n\t\tuError(\"Failed to start Rsync server\");\n\t}\n\tfree(cmd);\n}", "CodeBleu_score": 31.67527496470023}, {"code": "void startRsync(){\n\t\tint status;\n\tchar *dirName = \"checkpoint\";\n\tchar *dirPath = (char *) malloc(sizeof(char) * 100);\n\tchar *configFilePath = (char *) malloc(sizeof(char) * 100);\n\tchar *command = (char *) malloc(sizeof(char) * 100);\n\n\t// Initialize variables\n\tstatus = 0;\n\n\t// Create the checkpoint backup directory\n\tstatus = taosMulMkDir(dirName);\n\tif (status!= 0) {\n\t\tuError(\"Failed to create checkpoint backup directory\");\n\t\treturn;\n\t}\n\n\t// Remove empty directories\n\tremoveEmptyDir(dirName);\n\n\t// Generate the Rsync configuration file\n\tstatus = generateConfigFile(configFilePath);\n\tif (status!= 0) {\n\t\tuError(\"Failed to generate Rsync configuration file\");\n\t\treturn;\n\t}\n\n\t// Construct and execute the command to start the Rsync server\n\tsnprintf(command, sizeof(command), \"rsync --daemon --config=%s --port=%d\", configFilePath, rsyncPort);\n\tstatus = system(command);\n\tif (status!= 0) {\n\t\tuError(\"Failed to start Rsync server\");\n\t} else {\n\t\tuDebug(\"Rsync server started successfully\");\n\t}\n\n\t// Free memory\n\tfree(dirPath);\n\tfree(configFilePath);\n\tfree(command);\n}", "CodeBleu_score": 39.60214990197416}, {"code": "void startRsync(){\n\t\tint port = 873;\n\tint i = 0;\n\tchar *cmd = NULL;\n\tchar *configFilePath = NULL;\n\tchar *backupDir = NULL;\n\tchar *logPath = NULL;\n\tchar *log = NULL;\n\tchar *log2 = NULL;\n\tchar *log3 = NULL;\n\tchar *log4 = NULL;\n\tchar *log5 = NULL;\n\tchar *log6 = NULL;\n\tchar *log7 = NULL;\n\tchar *log8 = NULL;\n\tchar *log9 = NULL;\n\tchar *log10 = NULL;\n\tchar *log11 = NULL;\n\tchar *log12 = NULL;\n\tchar *log13 = NULL;\n\tchar *log14 = NULL;\n\tchar *log15 = NULL;\n\tchar *log16 = NULL;\n\tchar *log17 = NULL;\n\tchar *log18 = NULL;\n\tchar *log19 = NULL;\n\tchar *log20 = NULL;\n\tchar *log21 = NULL;\n\tchar *log22 = NULL;\n\tchar *log23 = NULL;\n\tchar *log24 = NULL;\n\tchar *log25 = NULL;\n\tchar *log26 = NULL;\n\tchar *log27 = NULL;\n\tchar *log28 = NULL;\n\tchar *log29 = NULL;\n\tchar *log30 = NULL;\n\tchar *log31 = NULL;\n\tchar *log32 = NULL;\n\tchar *log33 = NULL;\n\tchar *log34 = NULL;\n\tchar *log35 = NULL;\n\tchar *log36 = NULL;\n\tchar *log37 = NULL;\n\tchar *log38 = NULL;\n\tchar *log39 = NULL;\n\tchar *log40 = NULL;\n\tchar *log41 = NULL;\n\tchar *log42 = NULL;\n\tchar *log43 = NULL;\n\tchar *log44 = NULL;\n\tchar *log45 = NULL;\n\tchar *log46 = NULL;\n\tchar *log47 = NULL;", "CodeBleu_score": 2.3331275088568524}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tdispatcherId = dispatcherId.trim();\n\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found!\");\n\t}\n}", "CodeBleu_score": 55.65933106435087}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID: \" + dispatcherId + \" is not registered.\");\n\t}\n}", "CodeBleu_score": 47.219027085914206}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (this.dispatchers.containsKey(dispatcherId)) {\n\t\tthis.dispatchers.get(dispatcherId).shutdownNow();\n\t\tthis.dispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found\");\n\t}\n}", "CodeBleu_score": 44.86389145957941}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t if (parent == null) {\n throw new NullPointerException(\"parent cannot be null\");\n }\n if (msg == null) {\n throw new NullPointerException(\"msg cannot be null\");\n }\n if (childFilter == null) {\n throw new NullPointerException(\"childFilter cannot be null\");\n }\n if (parent.getActor() == null) {\n throw new NullPointerException(\"parent.actor cannot be null\");\n }\n if (parent.getActor().getActorRef() == null) {\n throw new NullPointerException(\"parent.actor.actorRef cannot be null\");\n }\n if (parent.getActor().getActorRef().getActor() == null) {\n throw new NullPointerException(\"parent.actor.actorRef.actor cannot be null\");\n }\n if (parent.getActor().getActorRef().getActor().getActorRef() == null) {\n throw new NullPointerException(\"parent.actor.actorRef.actor.actorRef cannot be null\");\n }\n if (parent.getActor().getActorRef().getActor().getActorRef().getActor() == null) {\n throw new NullPointerException(\"parent.actor.actorRef.actor.actorRef.actor cannot be null\");\n }\n if (parent.getActor().getActorRef().getActor().getActorRef().getActor().getActorRef() == null) {\n throw new NullPointerException(\"parent.actor.actorRef.actor.actorRef.actor.actorRef cannot be null\");\n }\n if (parent.getActor().getActorRef().getActor().getActorRef().getActor().getActorRef().getActor() == null) {\n throw new NullPointerException(\"parent.actor.actorRef.actor.actorRef.actor.actorRef.actor cannot be null\");\n }\n if (parent.getActor().getActorRef().getActor().getActorRef().getActor().getActorRef().getActor().getActorRef() == null) {\n throw new NullPointerException(\"parent.actor.actorRef.actor.actorRef.actor.actorRef.actor.actorRef cannot be null\");\n }\n if (parent.getActor().getActorRef().getActor().getActorRef().getActor().getActorRef().getActor().getActorRef().getActor() == null) {\n throw new NullPointerException(\"parent.actor.actorRef.actor.actorRef.actor.actorRef.actor.actorRef.actor cannot be null", "CodeBleu_score": 25.782258069563223}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t // Get the children of the parent actor\n Map<TbActorId, TbActorId> children = getChildren(parent);\n // Filter the children based on the provided predicate\n Map<TbActorId, TbActorId> filteredChildren = children.entrySet().stream()\n.filter(childFilter)\n.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n // Send the message to each filtered child actor\n for (TbActorId child : filteredChildren.values()) {\n try {\n send(child, msg, highPriority);\n } catch (TbActorNotFoundException e) {\n warn(e.getMessage());\n }\n }\n }", "CodeBleu_score": 47.44537657718042}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t if (childFilter == null) {\n throw new NullPointerException(\"childFilter\");\n }\n if (msg == null) {\n throw new NullPointerException(\"msg\");\n }\n if (parent == null) {\n throw new NullPointerException(\"parent\");\n }\n TbActorId[] children = getChildren(parent);\n if (children == null) {\n return;\n }\n for (TbActorId child : children) {\n if (childFilter.test(child)) {\n send(child, msg, highPriority);\n }\n }\n }", "CodeBleu_score": 41.887248305498446}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (isDestroying()) {\nif (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\nif (msg.getRuleNode()!= null) {\nif (msg.getRuleNode().getRuleNodeStatus() == RuleNodeStatus.FAILED) {\ninitActor();\n}\n}\n}\nmsg.notifyActorStopped();\n} else {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\nif (state == TbActorState.RUNNING) {\ntryProcessQueue();\n}\n}\n}", "CodeBleu_score": 47.985575175175065}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (isDestroying) {\nif (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\nif (msg.getRuleNode().getRuleStatus() == RULE_STATUS_FAILED) {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\n} else {\nmsg.getRuleNode().setRuleStatus(RULE_STATUS_FAILED);\n}\n}\nmsg.setActorStopped(true);\n} else {\nif (highPriority) {\nhighPriorityMsgs.add(msg);\n} else {\nnormalPriorityMsgs.add(msg);\n}\n}\nprocessQueue();\n}", "CodeBleu_score": 51.61517785898223}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n\t\tif (this.destructionInProgress) {\n\t\t\tthis.highPriorityMsgs.add(msg);\n\t\t}\n\t\telse {\n\t\t\tthis.normalPriorityMsgs.add(msg);\n\t\t\tif (this.normalPriorityMsgs.size() >= 100) {\n\t\t\t\tthis.tryProcessQueue();\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (this.destructionInProgress) {\n\t\t\tthis.highPriorityMsgs.add(msg);\n\t\t}\n\t\telse {\n\t\t\tthis.normalPriorityMsgs.add(msg);\n\t\t\tif (this.normalPriorityMsgs.size() >= 100) {\n\t\t\t\tthis.tryProcessQueue();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.49108099703643}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\tif (isStop) {\nreturn\n}\ntry {\nprocessQueue(highPriorityQueue)\nprocessQueue(normalPriorityQueue)\n} catch (Exception e) {\nif (isStop) {\nreturn\n}\nif (e instanceof ActorInitializationException) {\nsetStopReason(e)\ndestroy()\n} else {\nif (isStop) {\nreturn\n}\nlog.error(\"Failure processing mailbox\", e)\nif (processFailureStrategy == ProcessFailureStrategy.STOP) {\nsetStopReason(e)\ndestroy()\n} else if (processFailureStrategy == ProcessFailureStrategy.FAIL) {\nthrow e\n} else if (processFailureStrategy == ProcessFailureStrategy.LOG) {\nlog.error(\"Failure processing mailbox\", e)\n}\n}\n}\nif (isStop) {\nreturn\n}\nif (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\nsetStatus(Status.FREE)\nscheduleProcessMailbox()\n} else {\nprocessMailbox()\n}\n}", "CodeBleu_score": 16.066318952001733}, {"code": "private void processMailbox(){\n\t//    if (isStop()) {\n//        return\n//    }\n//    try {\n//        val actor = self\n//        val throughput = getActorThroughput()\n//        var count = 0\n//        while (count < throughput &&!isStop()) {\n//            count += 1\n//            val message = getHighPriorityMessage()\n//            if (message!= null) {\n//                actor.process(message)\n//            } else {\n//                message = getNormalPriorityMessage()\n//                if (message!= null) {\n//                    actor.process(message)\n//                } else {\n//                    break\n//                }\n//            }\n//        }\n//        if (count == 0) {\n//            setStatus(ActorStatus.Free)\n//            scheduleProcessAttempt()\n//        }\n//    } catch (e: Exception) {\n//        onProcessFailure(e)\n//    }\n}", "CodeBleu_score": 0.8065760456678428}, {"code": "private void processMailbox(){\n\tif (isStop) {", "CodeBleu_score": 1.0771227417417957}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif", "CodeBleu_score": 1.7361956596575807}, {"code": "public void destroy(Throwable cause){\n\t\tif (isDestroyed()) {\n\t\treturn;\n\t}\n\tsetStopReason(cause);\n\tsetDestroyInProgress(true);\n\tgetExecutor().execute(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tsetReadiness(NOT_READY);\n\t\t\ttry {\n\t\t\t\tdestroy(cause);\n\t\t\t} catch (Throwable e) {\n\t\t\t\twarn(e);\n\t\t\t}\n\t\t\tnotifyAllMessages(cause);\n\t\t}\n\t});\n}", "CodeBleu_score": 16.406198070744622}, {"code": "public void destroy(Throwable cause){\n\tif", "CodeBleu_score": 1.7361956596575807}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t// check if the tenant is the system tenant\nif (tenantId.isSysTenantId()) {\nreturn true;\n}\n\n// get the tenant's profile\nTenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n\n// get the rate limit configuration\nRateLimitConfiguration rateLimitConfiguration = profile.getRateLimitConfiguration();\n\n// check the rate limit\nRateLimit rateLimit = rateLimitConfiguration.getRateLimit(level);\nif (rateLimit!= null && rateLimit.isExceeded(api)) {\n// process a rate limit notification\nprocessRateLimitNotification(rateLimit, tenantId);\n}\n\nreturn true;\n}", "CodeBleu_score": 31.025556559805555}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.isSysTenantId()) {\nreturn true;\n}\nTenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\nif (profile == null) {\nreturn true;\n}\nRateLimitConfiguration rateLimitConfiguration = profile.getRateLimitConfiguration();\nif (rateLimitConfiguration == null) {\nreturn true;\n}\nRateLimitEntity rateLimitEntity = rateLimitConfiguration.getRateLimitEntity(level);\nif (rateLimitEntity == null) {\nreturn true;\n}\nRateLimit rateLimit = rateLimitEntity.getRateLimit();\nif (rateLimit == null) {\nreturn true;\n}\nRateLimitCounter counter = rateLimit.getCounter(api);\nif (counter == null) {\nreturn true;\n}\nlong currentCount = counter.getCount();\nif (currentCount >= rateLimit.getMaxCount()) {\nRateLimitNotification rateLimitNotification = new RateLimitNotification(api, tenantId, level, rateLimit.getMaxCount());\nprocess(rateLimitNotification);\nreturn false;\n}\nreturn true;\n}", "CodeBleu_score": 43.14425628959362}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t//tenant", "CodeBleu_score": 5.262946726493438}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlog.trace(\"Removing DTLS session for peer \" + entry.getKey());\n\t\t\tdtlsSessions.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 40.685316577519586}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - this.inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : this.dtlsSessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tthis.logger.info(\"Removing DTLS session for peer \" + entry.getKey() + \" due to inactivity\");\n\t\t\tthis.dtlsSessions.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 39.51453540326161}, {"code": "public void evictTimeoutSessions(){\n\t\tfinal long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\tfinal Iterator<Map.Entry<String, DTLSSession>> iterator = sessions.entrySet().iterator();\n\twhile (iterator.hasNext()) {\n\t\tfinal Map.Entry<String, DTLSSession> entry = iterator.next();\n\t\tfinal DTLSSession session = entry.getValue();\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\titerator.remove();\n\t\t\tlogger.debug(\"Removed DTLS session with ID {} from the map.\", session.getId());\n\t\t}\n\t}\n}", "CodeBleu_score": 41.82075029408353}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn Collections.emptyList();\n}\nreturn timeseries.entrySet().stream().map(entry -> {\ntry {\nreturn new TsKvEntry(entry.getKey(), entry.getValue().stream().map(JsonNode::asLong).collect(Collectors.toList()));\n} catch (JsonProcessingException e) {\nthrow new RuntimeException(e);\n}\n}).collect(Collectors.toList());\n}", "CodeBleu_score": 26.7103282031831}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn Collections.emptyList();\n}\nreturn timeseries.entrySet().stream()\n.map(e -> new TsKvEntry(e.getKey(), e.getValue().stream()\n.map(TsKvEntry::parseValue)\n.collect(Collectors.toList())))\n.collect(Collectors.toList());\n}", "CodeBleu_score": 21.38368624040792}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn Collections.emptyList();\n}\nreturn timeseries.entrySet().stream()\n.map(entry -> new TsKvEntry(entry.getKey(), entry.getValue().stream()\n.map(JsonNode::asLong)\n.collect(Collectors.toList())))\n.collect(Collectors.toList());\n}", "CodeBleu_score": 21.513529342870356}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tString refreshToken = \"\";\n\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refresh_token\", refreshToken);\n\tResponseEntity<String> response = restTemplate.postForEntity(authenticationEndpoint, requestMap, String.class);\n\tif (response.getStatusCode() == HttpStatus.OK) {\n\t\tMap<String, String> responseBody = new Gson().fromJson(response.getBody(), Map.class);\n\t\ttokenInfo.setAccessToken(responseBody.get(\"access_token\"));\n\t\ttokenInfo.setRefreshToken(responseBody.get(\"refresh_token\"));\n\t\ttokenInfo.setExpiresIn(responseBody.get(\"expires_in\"));\n\t\ttokenInfo.setTokenType(responseBody.get(\"token_type\"));\n\t\ttokenInfo.setScope(responseBody.get(\"scope\"));\n\t\ttokenInfo.setIssuedAt(System.currentTimeMillis());\n\t}\n}", "CodeBleu_score": 42.22606167495948}, {"code": "public void refreshToken(){\n\t// Initialize the request map with the current refresh token\nMap<String, String> requestMap = new HashMap<>();\nrequestMap.put(\"refresh_token\", refreshToken);\n\n// Send a POST request to the authentication endpoint\nResponseEntity<String> response = restTemplate.postForEntity(authenticationUrl, requestMap, String.class);\n\n// Update the token information with the current timestamp and the response body\nString responseBody = response.getBody();\ntokenInfo.setAccessToken(responseBody.get(\"access_token\"));\ntokenInfo.setExpiresIn(responseBody.get(\"expires_in\"));\ntokenInfo.setRefreshToken(responseBody.get(\"refresh_token\"));\ntokenInfo.setTokenType(responseBody.get(\"token_type\"));\ntokenInfo.setIssuedAt(System.currentTimeMillis());\n}", "CodeBleu_score": 49.3859898902744}, {"code": "public void refreshToken(){\n\t// Initialize the authentication endpoint\nString authenticationEndpoint = \"https://api.example.com/auth\";\n\n// Initialize the refresh token\nString refreshToken = \"\";\n\n// Create a request map\nMap<String, String> requestMap = new HashMap<>();\nrequestMap.put(\"refresh_token\", refreshToken);\n\n// Send a POST request to the authentication endpoint\nResponseEntity<String> response = restTemplate.postForEntity(authenticationEndpoint, requestMap, String.class);\n\n// Get the response body\nString responseBody = response.getBody();\n\n// Update the token information with the current timestamp and the response body\ntokenInfo.setToken(responseBody);\ntokenInfo.setTimestamp(System.currentTimeMillis());\n}", "CodeBleu_score": 47.42160005517477}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t String username = \"admin\";\n String password = \"\";\n String url = \"http://localhost:8080/api/auth/login\";\n String token = \"\";\n long timestamp = 0;\n Map<String, String> loginRequest = new HashMap<>();\n loginRequest.put(\"username\", username);\n loginRequest.put(\"password\", );\n ResponseEntity<LoginResponse> response = postForEntity(url, loginRequest, LoginResponse.class);\n if (response.getStatusCode() == HttpStatus.OK) {\n LoginResponse loginResponse = response.getBody();\n token = loginResponse.getToken();\n timestamp = System.currentTimeMillis();\n }\n }", "CodeBleu_score": 55.442194405681875}, {"code": " private void doLogin(){\n\t String token = \"\";\n String refreshToken = \"\";\n long currentTime = 0;\n Map<String, Object> loginRequest = new HashMap<>();\n loginRequest.put(\"username\", \"user\");\n loginRequest.put(\"password\", \"\");\n ResponseEntity<TokenInfo> response = null;\n try {\n response = restTemplate.postForEntity(\n \"http://localhost:8080/api/auth/login\", loginRequest, TokenInfo.class);\n token = response.getBody().getToken();\n refreshToken = response.getBody().getRefreshToken();\n currentTime = System.currentTimeMillis();\n } catch (RestClientException e) {\n e.printStackTrace();\n }\n tokenInfo.setToken(token);\n tokenInfo.setRefreshToken(refreshToken);\n tokenInfo.setTokenTime(currentTime);\n }", "CodeBleu_score": 45.286203753339194}, {"code": " private void doLogin(){\n\t\n// Create a login request map with the credentials\nMap<String, String> loginRequest = new HashMap<>();\nloginRequest.put(\"username\", username);\nloginRequest.put(\"password\", );\n\n// Send the request to the \"/api/auth/login\" URL\nResponseEntity<Map<String, String>> response = restTemplate.postForEntity(\n\"http://localhost:8080/api/auth/login\", loginRequest, Map.class);\n\n// Update the token information with the response data and the timestamp\nMap<String, String> tokenInfo = response.getBody();\ntokenInfo.put(\"timestamp\", String.valueOf(System.currentTimeMillis()));\nthis.tokenInfo = tokenInfo;\n}", "CodeBleu_score": 56.62737135322568}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\treturn Optional.ofNullable(this.restTemplate.getForEntity(this.url + \"/api/device/\" + deviceId.getValue(), Device.class).getBody());\n\t} catch (HttpStatusCodeException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 36.47685667926519}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\nResponseEntity<Device> response = restTemplate.getForEntity(\n\"/api/device/{deviceId}\",\nDevice.class,\ndeviceId.getId()\n);\nreturn Optional.ofNullable(response.getBody());\n} catch (HttpClientErrorException e) {\nif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow e;\n}\n}\n}", "CodeBleu_score": 61.849237193641905}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn getForEntity(\"/api/device/\" + deviceId, Device.class).getBody().ofNullable();\n}", "CodeBleu_score": 10.555987567344367}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nreturn Optional.ofNullable(\nrestTemplate.postForEntity(\n\"http://localhost:8080/api/device-with-credentials\",\nnew DeviceWithCredentials(device, credentials),\nDevice.class)\n.getBody());\n} catch (RestClientException e) {\nreturn Optional.empty();\n}\n}", "CodeBleu_score": 26.863751660619183}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\treturn saveDeviceWithCredentials(device, credentials, null);\n}", "CodeBleu_score": 9.595657006565938}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t//TODO: implement this function\nreturn Optional.empty();\n}", "CodeBleu_score": 12.013138032389865}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\tthis.brightness = arguments[0];\n\t\tthis.send();\n\t} else if (arguments.length == 2) {\n\t\tthis.send(addr, val);\n\t}\n\treturn this;\n}", "CodeBleu_score": 48.600663863872526}, {"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\tif (typeof addr == \"number\") {\n\t\t\tthis.send(Board.map(addr, 0, 100, 0, 15));\n\t\t} else {\n\t\t\tthis.send(Board.map(addr, 0, 100, 0, 15));\n\t\t}\n\t} else {\n\t\tthis.send(Board.map(addr, 0, 100, 0, 15));\n\t\tthis.send(val);\n\t}\n\treturn this;\n}", "CodeBleu_score": 46.325598028380746}, {"code": "brightness(addr, val){\n\t\tif (typeof addr === 'number') {\n\t\tif (typeof val === 'number') {\n\t\t\tthis.send(addr, 0x02, [val]);\n\t\t} else {\n\t\t\tthis.send(addr, 0x02, [this.map(val)]);\n\t\t}\n\t} else {\n\t\tfor (let addr in this.devices) {\n\t\t\tthis.send(addr, 0x02, [this.map(val)]);\n\t\t}\n\t}\n\treturn this;\n}", "CodeBleu_score": 44.995253686756975}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tconst device = {};\n\tObject.keys(LedControl.prototype).forEach((key) => {\n\t\tdevice[key] = this[key].bind(addr);\n\t});\n\tObject.getOwnPropertyNames(this).forEach((key) => {\n\t\tdevice[key] = this[key].bind(addr);\n\t});\n\treturn device;\n}", "CodeBleu_score": 41.62029474517336}, {"code": "device(addr){\n\t\tconst obj = {};\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tobj[key] = this[key].bind(addr);\n\t});\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tobj[key] = this[key].bind(addr);\n\t});\n\treturn obj;\n}", "CodeBleu_score": 46.21731620575948}, {"code": "device(addr){\n\t\tlet device = {};\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tdevice[key] = this[key].bind(addr);\n\t});\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tdevice[key] = this[key].bind(addr);\n\t});\n\treturn device;\n}", "CodeBleu_score": 42.39534186249011}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tfor (let method of methods) {\n\t\ttarget[method] = (...args) => {\n\t\t\tlet duration = args.length > 0? args[0] : 1000;\n\t\t\tlet callback = args[1];\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function.');\n\t\t\t}\n\t\t\tlet promises = [];\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tpromises.push(new Promise((resolve) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tlet result = this[i][method](...args.slice(2));\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t}\n\t\t\tPromise.all(promises).then(callback);\n\t\t};\n\t}\n}", "CodeBleu_score": 37.24656164559867}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = (duration = 1000, callback) => {\n\t\t\tif (!isFunction(callback)) {\n\t\t\t\tthrow new Error(\"Callback must be a function.\")\n\t\t\t}\n\t\t\tlet signals = [];\n\t\t\tfor (let i = 0; i < target.length; i++) {\n\t\t\t\tlet signal = new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tlet result = target[i][method]();\n\t\t\t\t\t\tif (result instanceof Promise) {\n\t\t\t\t\t\t\tresult.then(resolve).catch(reject)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(result)\n\t\t\t\t\t\t}\n\t\t\t\t\t}, duration)\n\t\t\t\t})\n\t\t\t\tsignals.push(signal)\n\t\t\t}\n\t\t\tPromise.all(signals).then(callback)\n\t\t}\n\t})\n}", "CodeBleu_score": 36.28095276191541}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = (duration = 1000, callback) => {\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function');\n\t\t\t}\n\n\t\t\tconst signals = [];\n\t\t\tconst resolve = () => {\n\t\t\t\tif (signals.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tPromise.all(signals).then(callback);\n\t\t\t};\n\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tconst signal = new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tthis[i][method]();\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}, duration);\n\t\t\t\t});\n\t\t\t\tsignals.push(signal);\n\t\t\t}\n\n\t\t\tresolve();\n\t\t};\n\t});\n}", "CodeBleu_score": 42.99224439266685}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\tthis.input = '';\n\tthis.io.serialRead(this.port, (data) => {\n\t\tthis.input += data.toString();\n\t\tthis.parseNmeaSentence();\n\t});\n}", "CodeBleu_score": 12.13261939879169}, {"code": "listen(){\n\t\tlet input = \"\";\n\tthis.io.serialRead(function (data) {\n\t\tinput += data;\n\t\tlet sentences = input.split(\"\\r\n\");\n\t\tinput = sentences.pop();\n\t\tfor (let sentence of sentences) {\n\t\t\tthis.parseNmeaSentence(sentence);\n\t\t}\n\t});\n}", "CodeBleu_score": 23.76921130354158}, {"code": "listen(){\n\t\tthis.input = ''\n\tthis.io.serialRead(this.port, (data) => {\n\t\tthis.input += data.toString()\n\t\tthis.input.split('\\r\n').forEach(this.parseNmeaSentence)\n\t})\n}", "CodeBleu_score": 13.334974598230382}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t num_channels = 0;\n\tuint32_t buffer_size = 0;\n\tuint32_t sample_size = 0;\n\tuint32_t i = 0;\n\n\t/*\n\t * Calculate the number of active channels.\n\t * If the channel number is zero, it is assumed that the channel is not active.\n\t */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tif (sequence->channels[i]!= 0) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the buffer size based on the number of active channels and the size of each data sample.\n\t * The size of each data sample depends on the data format.\n\t */\n\tif (config->data_format == ADC_AD559X_DATA_FORMAT_12_BIT) {\n\t\tsample_size = 2;\n\t} else if (config->data_format == ADC_AD559X_DATA_FORMAT_14_BIT) {\n\t\tsample_size = 2;\n\t} else if (config->data_format == ADC_AD559X_DATA_FORMAT_16_BIT) {\n\t\tsample_size = 2;\n\t} else if (config->data_format == ADC_AD559X_DATA_FORMAT_18_BIT) {\n\t\tsample_size = 3;\n\t} else if (config->data_format == ADC_AD559X_DATA_FORMAT_20_BIT) {\n\t\tsample_size = 3;\n\t} else if (config->data_format == ADC_AD559X_DATA_FORMAT_24_BIT) {\n\t\tsample_size = 3;\n\t} else if (config->data_format == ADC_AD559X_DATA_FORMAT_28_BIT) {\n\t\tsample_size = 4;\n\t} else if (config->data_format == ADC_AD559X_DATA_FORMAT_32_BIT) {\n\t\tsample_size = 4;\n\t}\n\n\tbuffer_size =", "CodeBleu_score": 26.449669501383184}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tint num_channels = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < sequence->options; i++) {\n\t\tif (sequence->channels[i]!= ADC_AD559X_CHANNEL_NONE) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (num_channels == 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (num_channels > config->num_channels) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options > config->num_channels) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options == 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options == 1) {\n\t\tif (sequence->channels[0] == ADC_AD559X_CHANNEL_NONE) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t}\n\n\tif (sequence->options == 2) {\n\t\tif (sequence->channels[0] == ADC_AD559X_CHANNEL_NONE ||\n\t\t    sequence->channels[1] == ADC_AD559X_CHANNEL_NONE) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t}\n\n\tif (sequence->options == 3) {\n\t\tif (sequence->channels[0] == ADC_AD559X_CHANNEL_NONE ||\n\t\t    sequence->channels[1] == ADC_AD559X_CHANNEL_NONE ||\n\t\t    sequence->channels[2] == ADC_AD559X_CHANNEL_NONE) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t}\n\n\tif (sequence->options == 4) {\n\t\tif (sequence->channels[0] == ADC_AD559X_CHANNEL_NONE ||\n\t\t    sequence->channels[1] == ADC_AD559X_CHANNEL_NONE ||\n\t\t    sequence->channels[2] == ADC_AD559X_CHANNEL_NONE ||\n\t\t    sequence->channels[3] == ADC_AD559X_CHANNEL_NONE) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t}\n\n\tif", "CodeBleu_score": 28.46630868631572}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tconst struct adc_channel_config *channel_config;\n\tint i;\n\tint n_channels = 0;\n\tint n_samples = 0;\n\tint buffer_size;\n\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tchannel_config = sequence->channels + i;\n\t\tif (channel_config->channel_id >= 0) {\n\t\t\tn_channels++;\n\t\t\tn_samples += channel_config->options & ADC_DIV_10000;\n\t\t}\n\t}\n\n\tbuffer_size = n_channels * n_samples * sizeof(int16_t);\n\n\tif (buffer_size > config->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.31464324356558}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channel_count;\n\tuint8_t channel_index;\n\tuint8_t channel;\n\tuint8_t channel_mask;\n\tuint8_t buffer_size;\n\tuint8_t buffer_index;\n\tuint8_t buffer_index_msb;\n\tuint8_t buffer_index_lsb;\n\tuint8_t buffer_index_mask;\n\tuint8_t buffer_index_mask_msb;\n\tuint8_t buffer_index_mask_lsb;\n\tuint8_t buffer_index_mask_shift;\n\tuint8_t buffer_index_mask_shift_msb;\n\tuint8_t buffer_index_mask_shift_lsb;\n\tuint8_t buffer_index_mask_shift_mask;\n\tuint8_t buffer_index_mask_shift_mask_msb;\n\tuint8_t buffer_index_mask_shift_mask_lsb;\n\tuint8_t buffer_index_mask_shift_mask_shift;\n\tuint8_t buffer_index_mask_shift_mask_shift_msb;\n\tuint8_t buffer_index_mask_shift_mask_shift_lsb;\n\tuint8_t buffer_index_mask_shift_mask_shift_mask;\n\tuint8_t buffer_index_mask_shift_mask_shift_mask_msb;\n\tuint8_t buffer_index_mask_shift_mask_shift_mask_lsb;\n\tuint8_t buffer_index_mask_shift_mask_shift_mask_shift;\n\tuint8_t buffer_index_mask_shift_mask_shift_mask_shift_msb;\n\tuint8_t buffer_index_mask_shift_mask_shift_mask_shift_lsb;\n\tuint8_t buffer_index_mask_shift_mask_shift_mask_shift_mask;\n\tuint8_t buffer_index_mask_shift_mask_shift_mask_shift_mask_msb;\n\tuint8_t buffer_index_mask_shift_mask_shift_mask_shift_mask_", "CodeBleu_score": 13.365436931428368}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t channel_mask = 0;\n\tuint32_t buffer_size;\n\tint err;\n\tint i;\n\tint j;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < sequence->channels_num; i++) {\n\t\tif (sequence->channels[i] >= config->channels_num) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchannel_mask |= (1 << sequence->channels[i]);\n\t}\n\n\tif (sequence->channels_num > config->channels_num) {\n\t\tLOG_ERR(\"Too many channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer_size = sequence->buffer_size * sequence->channels_num;\n\tif (buffer_size < sequence->channels_num) {\n\t\tLOG_ERR(\"Buffer too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc_context_wait_for_completion(config->adc_context);\n\n\tadc_context_start_read(config->adc_context, sequence->buffer, buffer_size, channel_mask);\n\n\tadc_context_wait_for_completion(config->adc_context);\n\n\treturn 0;\n}", "CodeBleu_score": 42.45005123054646}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\tint i;\n\n\tif (sequence->resolution!= data->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < sequence->channels_num; i++) {\n\t\tif (sequence->channels[i] > config->channels_num) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < sequence->channels_num) {\n\t\tLOG_ERR(\"Buffer too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc_ad559x_validate_buffer_size(sequence->buffer_size);\n\n\tdata->sequence = *sequence;\n\tdata->sequence.buffer = sequence->buffer;\n\tadc_context_start_read(&data->ctx);\n\tadc_context_wait_for_completion(&data->ctx);\n\tret = adc_context_get_result(&data->ctx);\n\tadc_context_clear_result(&data->ctx);\n\treturn ret;\n}", "CodeBleu_score": 51.05798649702298}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *adc_data = ctx->adc_data;\n\tadc_data->sampling_state = ADC_SAMPLING_STATE_SAMPLING;\n\tadc_data->repeat_buffer_index = 0;\n\tadc_data->adc_state = ADC_STATE_SAMPLING;\n\tadc_data->repeat_buffer = adc_data->adc_data_buffer;\n\tadc_data->repeat_buffer_length = adc_data->adc_data_buffer_length;\n\tadc_data->adc_channels = ctx->adc_channels;\n\tadc_data->adc_channels_length = ctx->adc_channels_length;\n\tadc_data->adc_channels_index = 0;\n\tk_sem_give(&adc_data->adc_start_sampling_sem);\n}", "CodeBleu_score": 47.73678464513662}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\t// TODO: Implement this function\n\t// Get the data structure from the context\n\tstruct adc_data *adc_data = ctx->adc_data;\n\n\t// Set the channels to be sampled\n\tadc_data->channels = ctx->channels;\n\n\t// Initialize the repeat buffer\n\tadc_data->repeat_buffer = ctx->data;\n\n\t// Release the semaphore\n\tk_sem_give(&adc_data->sem_adc_start_sampling);\n}", "CodeBleu_score": 47.547890720426544}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *adc_data = ctx->adc_data;\n\tadc_data->adc_channels = ctx->adc_channels;\n\tadc_data->adc_repeat_buffer = ctx->adc_repeat_buffer;\n\tadc_data->adc_repeat_buffer_size = ctx->adc_repeat_buffer_size;\n\tadc_data->adc_sample_count = 0;\n\tadc_data->adc_sample_count_max = ctx->adc_sample_count_max;\n\tadc_data->adc_sample_count_max_reached = false;\n\tadc_data->adc_sample_count_max_reached_flag = ctx->adc_sample_count_max_reached_flag;\n\tadc_data->adc_sample_count_max_reached_flag_set = false;\n\tadc_data->adc_sample_count_max_reached_flag_unset = false;\n\tadc_data->adc_sample_count_max_reached_flag_unset_flag = false;\n\tadc_data->adc_sample_count_max_reached_flag_set_flag = false;\n\tadc_data->adc_sample_count_max_reached_flag_unset_flag = false;\n\tadc_data->adc_sample_count_max_reached_flag_set_flag_unset = false;\n\tadc_data->adc_sample_count_max_reached_flag_set_flag_unset_flag = false;\n\tadc_data->adc_sample_count_max_reached_flag_set_flag_unset_flag_unset = false;\n\tadc_data->adc_sample_count_max_reached_flag_set_flag_unset_flag_unset_flag = false;\n\tadc_data->adc_sample_count_max_reached_flag_set_flag_unset_flag_unset_flag_unset = false;\n\tadc_data->adc_sample_count_max_reached_flag_set_flag_unset_flag_unset_flag_unset_flag = false;\n\tadc_data->adc_sample_count_max_reached_flag_set_flag_unset_flag_unset_flag_", "CodeBleu_score": 40.23815980611014}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *data_container = ctx->data_container;\n\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = data_container->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = data_container->buffer;\n\t}\n}", "CodeBleu_score": 38.00389136850247}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = adc_context_get_data_container(ctx);\n\tstruct adc_data_buffer *adc_data_buffer = adc_data_container_get_buffer(adc_data_container);\n\n\tif (repeat_sampling) {\n\t\tadc_data_buffer = adc_data_container_get_repeat_buffer(adc_data_container);\n\t}\n\n\tadc_data_buffer_set_buffer_pointer(adc_data_buffer, ctx->buffer_pointer);\n}", "CodeBleu_score": 31.007535553774407}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data = adc_context_get_adc_data(ctx);\n\tif (repeat_sampling) {\n\t\tadc_data->buffer_pointer = adc_data->repeat_buffer;\n\t} else {\n\t\tadc_data->buffer_pointer = adc_data->buffer;\n\t}\n}", "CodeBleu_score": 48.807473220274574}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_ad559x_channel_data *channel_data;\n\tuint32_t channel_index;\n\tuint32_t channel_count;\n\tuint32_t sample_index;\n\tuint32_t sample_count;\n\tuint32_t channel_sample_count;\n\tuint32_t channel_sample_index;\n\tuint32_t channel_sample_buffer_index;\n\tuint32_t channel_sample_buffer_offset;\n\tuint32_t channel_sample_buffer_size;\n\tuint32_t channel_sample_buffer_address;\n\tuint32_t channel_sample_buffer_size_minus_one;\n\tuint32_t channel_sample_buffer_mask;\n\tuint32_t channel_sample_buffer_index_mask;\n\tuint32_t channel_sample_buffer_index_shift;\n\tuint32_t channel_sample_buffer_address_mask;\n\tuint32_t channel_sample_buffer_address_shift;\n\tuint32_t channel_sample_buffer_address_offset;\n\tuint32_t channel_sample_buffer_address_offset_mask;\n\tuint32_t channel_sample_buffer_address_offset_shift;\n\tuint32_t channel_sample_buffer_address_offset_plus_one;\n\tuint32_t channel_sample_buffer_address_offset_plus_one_mask;\n\tuint32_t channel_sample_buffer_address_offset_plus_one_shift;\n\tuint32_t channel_sample_buffer_address_offset_plus_one_minus_one;\n\tuint32_t channel_sample_buffer_address_offset_plus_one_minus_one_mask;\n\tuint32_t channel_sample_buffer_address_offset_plus_one_minus_one_shift;\n\tuint32_t channel_sample_buffer_address_offset_plus_one_minus_two;\n\tuint32_t channel_sample_buffer_address_offset_plus_one_minus_two_mask;\n\tuint32_t channel_", "CodeBleu_score": 6.311141923796416}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tadc_context_on_sampling_done(data->adc_context);\n\twhile (1) {\n\t\tk_sem_take(&data->adc_sem, K_FOREVER);\n\t\tfor (int i = 0; i < data->num_channels; i++) {\n\t\t\tif (adc_read(data->adc_context, data->channel_ids[i],\n\t\t\t\t\t&data->adc_values[i])!= 0) {\n\t\t\t\tLOG_ERR(\"ADC read failed\");\n\t\t\t\tadc_context_complete(data->adc_context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tadc_context_on_sampling_done(data->adc_context);\n\t}\n}", "CodeBleu_score": 31.912305441403845}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint i;\n\tint err;\n\tuint32_t adc_value;\n\tuint32_t adc_value_2;\n\tuint32_t adc_value_3;\n\tuint32_t adc_value_4;\n\tuint32_t adc_value_5;\n\tuint32_t adc_value_6;\n\tuint32_t adc_value_7;\n\tuint32_t adc_value_8;\n\tuint32_t adc_value_9;\n\tuint32_t adc_value_10;\n\tuint32_t adc_value_11;\n\tuint32_t adc_value_12;\n\tuint32_t adc_value_13;\n\tuint32_t adc_value_14;\n\tuint32_t adc_value_15;\n\tuint32_t adc_value_16;\n\tuint32_t adc_value_17;\n\tuint32_t adc_value_18;\n\tuint32_t adc_value_19;\n\tuint32_t adc_value_20;\n\tuint32_t adc_value_21;\n\tuint32_t adc_value_22;\n\tuint32_t adc_value_23;\n\tuint32_t adc_value_24;\n\tuint32_t adc_value_25;\n\tuint32_t adc_value_26;\n\tuint32_t adc_value_27;\n\tuint32_t adc_value_28;\n\tuint32_t adc_value_29;\n\tuint32_t adc_value_30;\n\tuint32_t adc_value_31;\n\tuint32_t adc_value_32;\n\tuint32_t adc_value_33;\n\tuint32_t adc_value_34;\n\tuint32_t adc_value_35;\n\tuint32_t adc_value_36;\n\tuint32_t adc_value", "CodeBleu_score": 4.674266584070454}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint status = 0;\n\tint retries = 0;\n\tuint8_t config = 0;\n\n\twhile (status == 0) {\n\t\tstatus = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (status!= 0) {\n\t\t\treturn status;\n\t\t}\n\t\tif ((config & ADS1112_CONFIG_DRDY) == 0) {\n\t\t\tk_sleep(K_USEC(ADS1112_DRDY_WAIT_US));\n\t\t\tretries++;\n\t\t\tif (retries > ADS1112_DRDY_WAIT_RETRIES) {\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 48.651549037798645}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint err;\n\tuint8_t config_reg;\n\tuint8_t config_reg_mask = 0x80;\n\n\twhile (1) {\n\t\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n\t\tif (err!= 0) {\n\t\t\treturn err;\n\t\t}\n\t\tif ((config_reg & config_reg_mask) == config_reg_mask) {\n\t\t\treturn 0;\n\t\t}\n\t\tk_sleep(K_USEC(ADS1112_READY_WAIT_US));\n\t}\n}", "CodeBleu_score": 38.91804494191909}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tint ret;\n\tuint16_t reg;\n\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n\tif (ret!= 0) {\n\t\treturn ret;\n\t}\n\n\twhile (!(reg & ADS1112_REG_CONFIG_DRDY)) {\n\t\tk_sleep(config->ready_time);\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n\t\tif (ret!= 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.11837696655706}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint samplings = 0;\n\tint extra_samplings = 0;\n\n\tif (sequence->options & ADC_SEQUENCE_OPTION_EXTRA_SAMPLING) {\n\t\textra_samplings = sequence->options & ADC_SEQUENCE_OPTION_EXTRA_SAMPLING_MASK;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_OPTION_SAMPLING_RATE) {\n\t\tsamplings = sequence->options & ADC_SEQUENCE_OPTION_SAMPLING_RATE_MASK;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING) {\n\t\tsamplings = sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING_MASK;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING) {\n\t\tsamplings = sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING_MASK;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING) {\n\t\tsamplings = sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING_MASK;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING) {\n\t\tsamplings = sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING_MASK;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING) {\n\t\tsamplings = sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING_MASK;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING) {\n\t\tsamplings = sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING_MASK;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING) {\n\t\tsamplings = sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING_MASK;\n\t}\n\n\tif (sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMPLING) {\n\t\tsamplings = sequence->options & ADC_SEQUENCE_OPTION_CONTINUOUS_SAMP", "CodeBleu_score": 36.031308519429274}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint32_t buffer_size = 0;\n\n\tbuffer_size += sequence->options.extra_samplings * 2;\n\tbuffer_size += sequence->options.samplings;\n\n\tif (buffer_size < sequence->options.samplings) {\n\t\tads1112_log_err(\n\t\t\t\"Buffer size is too small. Required buffer size: %d, provided buffer size: %d\",\n\t\t\tbuffer_size,\n\t\t\tsequence->options.samplings);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 43.88542171586741}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint extra_samplings = 0;\n\tint samplings = 0;\n\tint buffer_size = 0;\n\n\tif (sequence->options & ADC_TRIGGER_REPEATED_SINGLE) {\n\t\textra_samplings++;\n\t}\n\tif (sequence->options & ADC_TRIGGER_REPEATED_CONTINUOUS) {\n\t\textra_samplings++;\n\t}\n\tif (sequence->options & ADC_TRIGGER_REPEATED_CONTINUOUS_WITH_WAIT) {\n\t\textra_samplings++;\n\t}\n\n\tsamplings = sequence->samplings + extra_samplings;\n\tbuffer_size = samplings * sequence->channels;\n\n\tif (buffer_size < sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size is insufficient for the specified sequence.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.53078149448852}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t *sequence_buffer;\n\tint ret;\n\n\tif (!adc_sequence_validate(sequence)) {\n\t\treturn -EINVAL;\n\t}\n\n\tsequence_buffer = (uint8_t *)sequence;\n\tret = adc_context_set_sequence_buffer(data->adc_context, sequence_buffer);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = adc_context_start_read(data->adc_context);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(data->adc_context,\n\t\t\t\t\t\t      CONFIG_ADC_CONTEXT_TIMEOUT);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.76488725828421}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tuint8_t adc_sequence_buffer[4];\n\tint ret;\n\n\t/* Validate the ADC sequence */\n\tret = ads1112_validate_sequence(sequence, adc_sequence_buffer);\n\tif (ret!= 0) {\n\t\treturn ret;\n\t}\n\n\t/* Assign the ADC sequence buffer to the device data */\n\tdata->adc_sequence_buffer = adc_sequence_buffer;\n\n\t/* Start the ADC read context */\n\tret = adc_context_start_read(config->adc_dev, &data->adc_read_context,\n\t\t\t\t    data->adc_sequence_buffer);\n\tif (ret!= 0) {\n\t\treturn ret;\n\t}\n\n\t/* Wait for the ADC read context to complete */\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(config->adc_dev,\n\t\t\t\t\t\t       &data->adc_read_context,\n\t\t\t\t\t\t       K_MSEC(100));\n\t\tif (ret!= 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.700495494161096}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tstruct adc_context *ctx = &data->ctx;\n\tint ret;\n\n\tif (!sequence) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPTION_REPEAT) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution!= ADC_RESOLUTION_12BIT) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels_list_len > 1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels_list[0]!= 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < sizeof(int16_t)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->sampling_interval < 1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->sampling_interval > 1000000) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->reference!= ADC_REF_INTERNAL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->gain!= ADC_GAIN_1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->acquisition_time!= ADC_ACQ_TIME_DEFAULT) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->acquisition_time_us < 1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->acquisition_time_us > 1000000) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->acquisition_time_us > config->acquisition_time_us_max) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->acquisition_time_us < config->acquisition_time_us_min) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = ads1112_validate_sequence(sequence);\n\tif (ret", "CodeBleu_score": 44.45067207604205}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tstruct audio_codec_config config = { 0 };\n\tint err;\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Usage: %s <dev_name> <prop_name> <prop_value>\n\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\n\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\terr = audio_codec_apply_properties(dev, argv[2], argv[3], &config);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to apply properties to %s\n\", argv[1]);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 51.85639711098273}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint err;\n\tstruct device *dev;\n\n\tif (argc!= 3) {\n\t\tshell_error(sh, \"usage: %s <device> <property>\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\terr = audio_codec_apply_properties(dev, argv[2]);\n\tif (err < 0) {\n\t\tshell_error(sh, \"Failed to apply properties to %s: %d\", argv[1], err);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 48.94722800841869}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tstruct audio_codec_config *codec_config;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Usage: %s <dev_name> <prop_name> <prop_value> [<prop_name> <prop_value>]\n\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found.\n\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tcodec_config = device_get_binding(AUDIO_CODEC_DEV_NAME);\n\tif (codec_config == NULL) {\n\t\tshell_error(sh, \"Audio codec device not found.\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev, codec_config, argc - 2, (const char * const *) &argv[2]);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties.\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.46036323432536}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_i2s_config *config = dev->config;\n\tint ret;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (config->state!= MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device not in configured state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = mpxxdtyy_i2s_set_state(dev, MPXXDTYY_I2S_STATE_ACTIVE);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to set device state to active\");\n\t\t\treturn ret;\n\t\t}\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (config->state!= MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device not in active state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = mpxxdtyy_i2s_set_state(dev, MPXXDTYY_I2S_STATE_CONFIGURED);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to set device state to configured\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 36.82688438212271}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint err = 0;\n\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *data = dev->data;\n\tstruct mpxxdtyy_i2s_trigger_config i2s_trigger_config = {\n\t\t.cmd = cmd,\n\t\t.data = data\n\t};\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state == MPXXDTYY_STATE_IDLE) {\n\t\t\ti2s_trigger_config.cmd = I2S_TRIGGER_START;\n\t\t\terr = i2s_trigger(&config->i2s, &i2s_trigger_config);\n\t\t\tif (err == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Device is not in idle state\");\n\t\t\terr = -EBUSY;\n\t\t}\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\ti2s_trigger_config.cmd = I2S_TRIGGER_STOP;\n\t\t\terr = i2s_trigger(&config->i2s, &i2s_trigger_config);\n\t\t\tif (err == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_IDLE;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Device is not in active state\");\n\t\t\terr = -EBUSY;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Invalid command\");\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 41.30221147429097}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_i2s_config *config = dev->config;\n\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint err = 0;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state!= MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Invalid state for start command\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = mpxxdtyy_i2s_set_state(dev, MPXXDTYY_I2S_STATE_ACTIVE);\n\t\tif (err!= 0) {\n\t\t\tLOG_ERR(\"Failed to set state to active\");\n\t\t\treturn err;\n\t\t}\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state!= MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Invalid state for stop command\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = mpxxdtyy_i2s_set_state(dev, MPXXDTYY_I2S_STATE_CONFIGURED);\n\t\tif (err!= 0) {\n\t\t\tLOG_ERR(\"Failed to set state to configured\");\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 34.84638167167709}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = 0x00;\n\n\tif (data->display_enabled) {\n\t\treturn;\n\t}\n\n\tif (enabled) {\n\t\tcmd = 0x0C;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= 0x02;\n\t}\n\n\tif (data->blink_enabled) {\n\t\tcmd |= 0x01;\n\t}\n\n\tauxdisplay_hd44780_command(dev, cmd);\n}", "CodeBleu_score": 42.380381471243155}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\n\tif (enabled) {\n\t\tdata->display_enabled = true;\n\t}\n\n\tif (data->display_enabled) {\n\t\tauxdisplay_hd44780_command(dev, HD44780_DISPLAY_ON);\n\t} else {\n\t\tauxdisplay_hd44780_command(dev, HD44780_DISPLAY_OFF);\n\t}\n}", "CodeBleu_score": 27.582809234972107}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = data->command;\n\n\tif (enabled) {\n\t\tcommand |= HD44780_DISPLAY_ON;\n\t} else {\n\t\tcommand &= ~HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_blink) {\n\t\tcommand |= HD44780_CURSOR_BLINK;\n\t} else {\n\t\tcommand &= ~HD44780_CURSOR_BLINK;\n\t}\n\n\tauxdisplay_hd44780_command(dev, command);\n}", "CodeBleu_score": 45.61441055496652}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (!config->busy_gpio_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&config->busy_gpio_port->port);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 68.82598181563728}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = 0;\n\n\tif (!config->busy_gpio_port) {\n\t\tret = -ENOTSUP;\n\t} else {\n\t\tret = gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 63.428846089532506}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = 0;\n\n\tif (!config->busy_gpio_port) {\n\t\tret = -ENOTSUP;\n\t} else {\n\t\tret = gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 63.428846089532506}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t command_prefix = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = command_prefix;\n\tbuffer[1] = command;\n\n\tint ret = i2c_write(config->i2c, config->slave_address, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to send special command to LCD device\");\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->delay_ms));\n\n\treturn 0;\n}", "CodeBleu_score": 66.39182236209258}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t command_buffer[2];\n\n\t/*\n\t * Construct a buffer containing the special command prefix and the command itself.\n\t * The special command prefix is defined in the device configuration.\n\t * The command is the input argument to this function.\n\t */\n\tcommand_buffer[0] = config->special_command_prefix;\n\tcommand_buffer[1] = command;\n\n\t/*\n\t * Write the constructed buffer to the device using the I2C bus.\n\t * After writing the buffer, introduce a delay specified in the device configuration.\n\t */\n\tint error = i2c_write(config->i2c, command_buffer, sizeof(command_buffer),\n\t\t\t      K_MSEC(config->write_delay_ms));\n\n\treturn error;\n}", "CodeBleu_score": 63.3649995135321}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *cfg = dev->config;\n\tint ret;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tret = i2c_write(cfg->i2c, buffer, sizeof(buffer));\n\tif (ret < 0) {\n\t\tLOG_ERR(\"I2C write failed\");\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(cfg->special_command_delay));\n\n\treturn 0;\n}", "CodeBleu_score": 61.369628104608395}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tconst struct bbram_emul_data *data_ptr = dev->data;\n\n\tif (size > config->memory_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->memory_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_ptr->memory_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data_ptr->memory + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 68.03369565881715}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tint ret = 0;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset % config->word_size!= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, config->data + offset, size);\n\n\treturn ret;\n}", "CodeBleu_score": 61.4984164495459}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = DEV_DATA(dev);\n\tint err;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_invalid(data_ptr, offset, size) < 0) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &data_ptr->data[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 57.698314495842354}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_data *data_ptr = dev->data;\n\tint ret;\n\n\tif (size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_ptr->state == BBRAM_EMUL_INVALID) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data_ptr->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 62.810917197606884}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_data *data_dev = dev->data;\n\tint ret;\n\n\tif (size > data_dev->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_dev->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = bbram_emul_check_invalid(dev);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tmemcpy(data_dev->data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 67.27084862330139}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tconst uint8_t *data_ptr_end = data + size;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_ptr->state!= BBRAM_EMUL_STATE_VALID) {\n\t\treturn -EINVAL;\n\t}\n\n\twhile (data < data_ptr_end) {\n\t\tdata_ptr->data[offset++] = *data++;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.02430338244675}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint ret = 0;\n\tconst struct device *dev = device_get_binding(argv[1]);\n\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\tret = -ENODEV;\n\t}\n\n\tif (argc > 2) {\n\t\tshell_error(sh, \"Too many arguments\");\n\t\tret = -EINVAL;\n\t}\n\n\t*bbram_dev = dev;\n\treturn ret;\n}", "CodeBleu_score": 61.699513501741286}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tstruct device *dev;\n\tint err;\n\n\tif (argc < 1) {\n\t\tshell_error(sh, SHELL_EXIT_NOT_ENOUGH_ARGS,\n\t\t\t    \"Missing device name argument\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[0]);\n\tif (!dev) {\n\t\tshell_error(sh, SHELL_EXIT_DEVICE_NOT_FOUND,\n\t\t\t    \"Device not found: %s\", argv[0]);\n\t\treturn -ENODEV;\n\t}\n\n\terr = device_bind(dev);\n\tif (err) {\n\t\tshell_error(sh, SHELL_EXIT_DEVICE_NOT_FOUND,\n\t\t\t    \"Device not found: %s\", argv[0]);\n\t\treturn err;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 52.76765686674552}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 1) {\n\t\tshell_error(sh, SHELL_E_INVALID_ARGS);\n\t\treturn SHELL_E_INVALID_ARGS;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[0]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, SHELL_E_DEVICE_NOT_FOUND);\n\t\treturn SHELL_E_DEVICE_NOT_FOUND;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.89205766990359}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct uart_driver_api *api = UART_DRIVER_GET(dev);\n\tstruct uart_fifo_data *data = dev->data;\n\tstruct uart_fifo_hdr *hdr = &data->hdr;\n\tint32_t bytes_read = 0;\n\tint32_t bytes_remaining = hdr->size - hdr->read;\n\tint32_t bytes_to_read = MIN(bytes_remaining, UART_FIFO_HDR_SIZE);\n\n\tif (bytes_remaining > 0) {\n\t\tbytes_read = api->read(dev, hdr->buf + hdr->read, bytes_to_read);\n\t\tif (bytes_read < 0) {\n\t\t\tLOG_ERR(\"Failed to read header data from UART device\");\n\t\t} else {\n\t\t\thdr->read += bytes_read;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.78567216616925}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;\n\tuint8_t *hdr = (uint8_t *)hdr_buf;\n\tuint16_t hdr_len = sizeof(hdr_buf);\n\tuint16_t hdr_offset = 0;\n\tuint16_t hdr_size = 0;\n\tuint16_t hdr_read = 0;\n\tuint16_t hdr_remain = 0;\n\tuint8_t hdr_buf_remain = 0;\n\tuint8_t hdr_buf_size = 0;\n\tuint8_t hdr_buf_offset = 0;\n\tuint8_t hdr_buf_count = 0;\n\tint err = 0;\n\n\thdr_buf_remain = hdr_len - hdr_offset;\n\thdr_buf_size = uart_fifo_read(dev, hdr, hdr_buf_remain);\n\thdr_buf_offset = 0;\n\thdr_buf_count = hdr_buf_size;\n\thdr_remain = hdr_len - hdr_offset;\n\n\twhile (hdr_remain > 0) {\n\t\tif (hdr_buf_count == 0) {\n\t\t\thdr_buf_remain = hdr_len - hdr_offset;\n\t\t\thdr_buf_size = uart_fifo_read(dev, hdr, hdr_buf_remain);\n\t\t\thdr_buf_offset = 0;\n\t\t\thdr_buf_count = hdr_buf_size;\n\t\t}\n\n\t\thdr_read = hdr_buf_size - hdr_buf_offset;\n\t\thdr_remain -= hdr_read;\n\t\thdr_offset += hdr_read;\n\t\thdr_buf_count -= hdr_read;\n\t\thdr_buf_offset += hdr_read;\n\n\t\tif (hdr_remain > 0) {\n\t\t\tif (hdr_buf_count == 0) {\n\t\t\t\thdr_buf_remain = hdr_len - hdr_offset;\n\t\t\t\thdr_buf_size = uart_fifo_read(dev, hdr, hdr_buf_remain);\n\t\t\t\thdr_buf_offset = 0;\n\t\t\t\thdr_buf_count = hdr_buf_size;\n\t\t\t", "CodeBleu_score": 38.33025432808713}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct uart_fifo_config *config = uart_fifo_config_get(dev);\n\tstruct uart_fifo_data *data = uart_fifo_data_get(dev);\n\tstruct uart_fifo_hdr *hdr = &data->hdr;\n\tuint8_t *hdr_buf = hdr->buf;\n\tuint8_t *buf_ptr = hdr_buf + hdr->buf_idx;\n\tuint8_t *buf_end = hdr_buf + hdr->buf_size;\n\tuint32_t bytes_read = 0;\n\tuint32_t bytes_left = hdr->buf_size - hdr->buf_idx;\n\tuint32_t bytes_to_read = hdr->size - hdr->bytes_read;\n\tint ret;\n\n\tif (bytes_to_read > bytes_left) {\n\t\tbytes_to_read = bytes_left;\n\t}\n\n\tif (bytes_to_read > 0) {\n\t\tret = uart_fifo_read(dev, buf_ptr, bytes_to_read, &bytes_read);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to read from UART FIFO: %d\", ret);\n\t\t\treturn;\n\t\t}\n\n\t\thdr->bytes_read += bytes_read;\n\t\thdr->buf_idx += bytes_read;\n\t\tbuf_ptr += bytes_read;\n\t}\n\n\tif (hdr->bytes_read < hdr->size) {\n\t\treturn;\n\t}\n\n\t/*\n\t * If the header buffer is full, then the header is complete.\n\t * The header is complete when the number of bytes read from the UART FIFO equals the size of the header.\n\t */\n\tLOG_DBG(\"Header complete\");\n\tLOG_HEXDUMP_DBG(hdr_buf, hdr->buf_size, \"Header\");\n\n\t/*\n\t * The header is complete, so the header buffer is now empty.\n\t * This is done by setting the buffer index to 0 and resetting the number of bytes read to 0.\n\t */\n\thdr->buf_idx = 0;\n\thdr->bytes_read = 0;\n}", "CodeBleu_score": 45.504180219972014}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read;\n\tsize_t total_read = 0;\n\tsize_t i;\n\n\tif (uart == NULL) {\n\t\treturn 0;\n\t}\n\n\twhile (len > 0) {\n\t\tread = uart_fifo_read(uart, buf, sizeof(buf));\n\t\tif (read == 0) {\n\t\t\tLOG_ERR(\"uart_fifo_read failed\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < read; i++) {\n\t\t\ttotal_read++;\n\t\t\tlen--;\n\t\t}\n\t}\n\n\treturn total_read;\n}", "CodeBleu_score": 35.69665859014005}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t *buffer = k_malloc(len);\n\tif (buffer == NULL) {\n\t\treturn 0;\n\t}\n\tsize_t ret = uart_fifo_read(uart, buffer, len);\n\tk_free(buffer);\n\treturn ret;\n}", "CodeBleu_score": 26.572229310887767}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t tmp[33];\n\tsize_t read = 0;\n\n\twhile (len > 0) {\n\t\tread = uart_fifo_read(uart, tmp, sizeof(tmp));\n\t\tif (read == 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART\");\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= read;\n\t}\n\n\treturn read;\n}", "CodeBleu_score": 38.095957298323626}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *observer;\n\tuint8_t hop = 0;\n\n\tzbus_spinlock_lock(&chan->lock);\n\n\tfor (observer = chan->observers; observer!= NULL; observer = observer->next) {\n\t\tif (observer->enabled && observer->priority > hop) {\n\t\t\thop = observer->priority;\n\t\t}\n\t}\n\n\tchan->hop = hop;\n\n\tzbus_spinlock_unlock(&chan->lock);\n}", "CodeBleu_score": 25.11513168086606}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tint i;\n\tint hop = 0;\n\tint lock_ret;\n\n\tlock_ret = spinlock_lock(&chan->lock);\n\tif (lock_ret) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < chan->num_observers; i++) {\n\t\tobs = &chan->observers[i];\n\t\tif (obs->enabled && obs->priority > hop) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\n\tchan->hop = hop;\n\n\tspinlock_unlock(&chan->lock);\n}", "CodeBleu_score": 24.994437726088844}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tstruct zbus_observer *highest_obs = NULL;\n\tstruct zbus_observer *next_obs;\n\tstruct zbus_observer *tmp_obs;\n\tstruct zbus_observer *tmp_obs_next;\n\tstruct zbus_observer *tmp_obs_prev;\n\tstruct zbus_observer *tmp_obs_prev_next;\n\tstruct zbus_observer *tmp_obs_prev_prev;\n\tstruct zbus_observer *tmp_obs_prev_prev_next;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_next;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_next;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev_next;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev_prev;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev_prev_next;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev_prev_prev;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev_prev_prev_next;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev_prev_prev_prev;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev_prev_prev_prev_next;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev_prev_prev_prev_prev_next;\n\tstruct zbus_observer *tmp_obs_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev;\n\tstruct zbus", "CodeBleu_score": 10.615307344945899}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tZBUS_STRUCT_SECTION_FOREACH(chan_update_hop)\n\tchan_update_hop(obs);\n\tZBUS_STRUCT_SECTION_END\n}", "CodeBleu_score": 14.816724439638367}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t#if ZBUS_STRUCT_SECTION_FOREACH\nchan_update_all_channels_hop\n#endif\n}", "CodeBleu_score": 12.953427221737659}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *chan_obs;\n\tstruct zbus_channel_observation *tmp;\n\tLIST_FOREACH_SAFE(chan_obs, &obs->chan_obs_list, link, tmp) {\n\t\tif (chan_obs->chan->obs == obs) {\n\t\t\tupdate_channel_hop(chan_obs->chan, chan_obs->chan->obs);\n\t\t}\n\t}\n}", "CodeBleu_score": 20.075042662203423}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tk_is_in_isr();\n\tK_ASSERT(!k_is_in_isr());\n\tK_ASSERT(obs!= NULL);\n\tK_SPINLOCK_LOCK(&obs->lock);\n\tobs->priority = ZBUS_THREAD_PRIORITY_MIN;\n\tupdate_all_channels_hop(obs);\n\tK_SPINLOCK_UNLOCK(&obs->lock);\n\treturn 0;\n}", "CodeBleu_score": 52.05641651630162}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (k_is_in_isr()) {\n\t\tZBUS_ASSERT(0, \"Operation not allowed in ISR\");\n\t}\n\tif (obs == NULL) {\n\t\tZBUS_ASSERT(0, \"Observer is null\");\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\tobs->priority = ZBUS_THREAD_PRIORITY_MIN;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&zbus_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 52.818463156610285}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(k_is_in_isr() == false);\n\t_ZBUS_ASSERT(obs!= NULL);\n\tzbus_spinlock_lock(obs->lock);\n\tobs->priority = ZBUS_MIN_THREAD_PRIORITY;\n\tupdate_all_channels_hop(obs);\n\tzbus_spinlock_unlock(obs->lock);\n\treturn 0;\n}", "CodeBleu_score": 52.056611829448876}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err = 0;\n\n\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = k_timeout_get_remaining_ms(timeout);\n\t\tif (timeout == K_TIMEOUT_INFINITE) {\n\t\t\ttimeout = K_FOREVER;\n\t\t}\n\t}\n\n\tif (timeout!= K_TIMEOUT_INFINITE) {\n\t\tchan->end_time = sys_timepoint_calc(timeout, SYS_TIME_NOW_THREAD);\n\t}\n\n\tchan_lock(chan);\n\n\tif (chan->ctx_priority < ZBUS_CHAN_CTX_PRIORITY_MAX) {\n\t\tchan->ctx_priority++;\n\t}\n\n\tif (chan->ctx_priority == ZBUS_CHAN_CTX_PRIORITY_MAX) {\n\t\terr = zbus_vded_exec(chan);\n\t}\n\n\tchan_unlock(chan);\n\n\treturn err;\n}", "CodeBleu_score": 49.49306837335204}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err = 0;\n\n\t_ZBUS_ASSERT(chan!= NULL);\n\n\tif (k_is_in_isr()) {\n\t\tchan->ctx.timeout = sys_timepoint_calc(timeout, K_SECONDS);\n\t} else {\n\t\tchan->ctx.timeout = sys_timepoint_add(k_uptime_get(), timeout);\n\t}\n\n\tchan_lock(chan);\n\n\tif (chan->ctx.state == ZBUS_CHAN_STATE_ACTIVE) {\n\t\terr = zbus_chan_exec(chan);\n\t}\n\n\tchan_unlock(chan);\n\n\treturn err;\n}", "CodeBleu_score": 37.886036322830364}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint ret = 0;\n\tk_timeout_t end_time = 0;\n\n\tZBUS_ASSERT(chan!= NULL);\n\tif (zbus_k_is_in_isr) {\n\t\tZBUS_ASSERT(timeout!= K_NO_WAIT);\n\t}\n\n\tend_time = sys_timepoint_calc(timeout);\n\n\tzbus_chan_lock(chan);\n\n\tret = zbus_vded_exec(chan, end_time);\n\n\tzbus_chan_unlock(chan);\n\n\treturn ret;\n}", "CodeBleu_score": 32.87638115319619}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t tmpreg;\n\tuint32_t itstatus;\n\tuint32_t itenable;\n\tuint32_t itdisable;\n\tuint32_t itmask;\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\t/* Get the interrupt enable register value */\n\ttmpreg = ETH->MISR;\n\t/* Get the interrupt status register value */\n\titstatus = ETH->MISR;\n\t/* Get the interrupt enable register value */\n\titenable = ETH->IER;\n\t/* Get the interrupt disable register value */\n\titdisable = ETH->IDR;\n\t/* Get the interrupt mask register value */\n\titmask = ETH->IMR;\n\t/* Check if the interrupt is normal or abnormal */\n\tif ((Int & ETH_INT_NORMAL)!= 0) {\n\t\t/* Check if the interrupt is enabled */\n\t\tif ((itenable & Int)!= 0) {\n\t\t\t/* Check if the interrupt is disabled */\n\t\t\tif ((itdisable & Int)!= 0) {\n\t\t\t\t/* Disable the interrupt */\n\t\t\t\titdisable &= ~Int;\n\t\t\t\t/* Update the interrupt disable register */\n\t\t\t\tETH->IDR = itdisable;\n\t\t\t\t/* Check if the interrupt is enabled */\n\t\t\t\tif ((itenable & Int)!= 0) {\n\t\t\t\t\t/* Enable the interrupt */\n\t\t\t\t\titenable &= ~Int;\n\t\t\t\t\t/* Update the interrupt enable register */\n\t\t\t\t\tETH->IER = itenable;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Check if the interrupt is disabled */\n\t\tif ((itdisable & Int) == 0) {\n\t\t\t/* Enable the interrupt */\n\t\t\titenable |= Int;\n\t\t\t/* Update the interrupt enable register */\n\t\t\tETH->IER = itenable;\n\t\t}\n\t} else {\n\t\t/* Check if the interrupt is enabled */\n\t\tif ((itenable & Int)!= 0) {\n\t\t\t/* Check if the interrupt is disabled */\n\t\t\tif ((itdisable & Int)!= 0) {\n\t\t\t\t/* Disable the interrupt */\n\t\t\t\titdisable &= ~Int;\n\t\t\t\t/* Update the interrupt disable register */\n\t\t\t\tETH->IDR = itdisable;\n\t\t\t\t/* Check if the interrupt is enabled */\n\t\t\t\tif ((itenable & Int)", "CodeBleu_score": 37.67264087199283}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT(Int));\n\tif (enable) {\n\t\t/* Enable interrupt */\n\t\tif (Int & ETH_INT_NORMAL) {\n\t\t\tETH->NIE |= Int;\n\t\t} else {\n\t\t\tETH->AIE |= Int;\n\t\t}\n\t} else {\n\t\t/* Disable interrupt */\n\t\tif (Int & ETH_INT_NORMAL) {\n\t\t\tETH->NIE &= ~Int;\n\t\t} else {\n\t\t\tETH->AIE &= ~Int;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.77355851353281}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t tmpreg = 0;\n\tuint32_t tmpreg2 = 0;\n\tuint32_t tmpreg3 = 0;\n\tuint32_t tmpreg4 = 0;\n\tuint32_t tmpreg5 = 0;\n\tuint32_t tmpreg6 = 0;\n\tuint32_t tmpreg7 = 0;\n\tuint32_t tmpreg8 = 0;\n\tuint32_t tmpreg9 = 0;\n\tuint32_t tmpreg10 = 0;\n\tuint32_t tmpreg11 = 0;\n\tuint32_t tmpreg12 = 0;\n\tuint32_t tmpreg13 = 0;\n\tuint32_t tmpreg14 = 0;\n\tuint32_t tmpreg15 = 0;\n\tuint32_t tmpreg16 = 0;\n\tuint32_t tmpreg17 = 0;\n\tuint32_t tmpreg18 = 0;\n\tuint32_t tmpreg19 = 0;\n\tuint32_t tmpreg20 = 0;\n\tuint32_t tmpreg21 = 0;\n\tuint32_t tmpreg22 = 0;\n\tuint32_t tmpreg23 = 0;\n\tuint32_t tmpreg24 = 0;\n\tuint32_t tmpreg25 = 0;\n\tuint32_t tmpreg26 = 0;\n\tuint32_t tmpreg27 = 0;\n\tuint32_t tmpreg28 = 0;\n\tuint32_t tmpreg29 = 0;\n\tuint32_t tmpreg30 = 0;\n\tuint32_t tmpreg31 = 0;\n\tuint32_t tmpreg32 = 0;\n\tuint32_t tmpreg33 = 0;\n\tuint32_t tmpreg34 = 0;\n\tuint32_t tmpreg35 = ", "CodeBleu_score": 4.675985155324098}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *ptxdesc;\n\tuint32_t i;\n\tuint32_t txdesc_addr;\n\tuint32_t txdesc_count;\n\n\ttxdesc_addr = (uint32_t)ETH_TX_DESC_LIST_BASE;\n\ttxdesc_count = (uint32_t)ETH_TX_DESC_LIST_COUNT;\n\n\tdo {\n\t\tptxdesc = (ETH_TX_DESC *)txdesc_addr;\n\t\tif (ptxdesc->Status & ETH_DMATXDESC_OWN) {\n\t\t\tptxdesc = 0;\n\t\t}\n\n\t\ttxdesc_addr += ETH_DMATXDESC_SIZE;\n\t\tif (txdesc_addr >= (uint32_t)ETH_TX_DESC_LIST_BASE + (ETH_DMATXDESC_SIZE * ETH_TX_DESC_LIST_COUNT)) {\n\t\t\ttxdesc_addr = (uint32_t)ETH_TX_DESC_LIST_BASE;\n\t\t}\n\n\t\ti++;\n\t\tif (i >= txdesc_count) {\n\t\t\ti = 0;\n\t\t}\n\t} while (i!= 0);\n\n\treturn ptxdesc;\n}", "CodeBleu_score": 43.70806285391552}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *TxDesc;\n\tuint32_t TempTxDesc;\n\n\t/* Get the current transmit descriptor address */\n\tTempTxDesc = ETH_DMATXDESC_Get(&ETH_DMATxDescTab[0]);\n\n\t/* Check if the descriptor is owned by the device */\n\tif ((TempTxDesc & ETH_DMATXDESC_OWN)!= (uint32_t)RESET) {\n\t\t/* Check if the descriptor is owned by DMA */\n\t\tif ((TempTxDesc & ETH_DMATXDESC_OWN)!= (uint32_t)RESET) {\n\t\t\t/* Increment the descriptor buffer address of the current Tx descriptor */\n\t\t\tTempTxDesc += ETH_DMATXDESC_BUFFER_SIZE;\n\n\t\t\t/* Check if the incremented descriptor buffer address is greater than the last Tx descriptor buffer address */\n\t\t\tif (TempTxDesc > (uint32_t)(&ETH_DMATxDescTab[ETH_DMATXDESC_NUMBER - 1])) {\n\t\t\t\t/* Set the descriptor buffer address to the first Tx descriptor buffer address */\n\t\t\t\tTempTxDesc = (uint32_t)(&ETH_DMATxDescTab[0]);\n\t\t\t}\n\n\t\t\t/* Get the current transmit descriptor address */\n\t\t\tTxDesc = (ETH_TX_DESC *)TempTxDesc;\n\n\t\t\t/* Check if the descriptor is owned by the device */\n\t\t\tif ((TxDesc->Status & ETH_DMATXDESC_OWN)!= (uint32_t)RESET) {\n\t\t\t\t/* Return 0 if no free Tx descriptor is found */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return the found free Tx descriptor */\n\treturn TxDesc;\n}", "CodeBleu_score": 44.327114554249384}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *txDesc;\n\ttxDesc = (ETH_TX_DESC *)ETH_TX_DESC_LIST;\n\twhile (txDesc->Status & ETH_DMATXDESC_OWN) {\n\t\tif (++txDesc == (ETH_TX_DESC *)ETH_TX_DESC_LIST_END) {\n\t\t\ttxDesc = (ETH_TX_DESC *)ETH_TX_DESC_LIST;\n\t\t}\n\t\tif (txDesc == (ETH_TX_DESC *)ETH_TX_DESC_LIST) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (txDesc);\n}", "CodeBleu_score": 45.10214530499246}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tRT_ASSERT(device!= RT_NULL);\n\tRT_ASSERT(value!= RT_NULL);\n\n\tstruct cyp_dac_device *dev = (struct cyp_dac_device *)device;\n\tCy_CSDIDAC_OutputEnable(dev->dac, channel, *value);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 42.49144201127434}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result;\n\trt_uint32_t dac_channel;\n\tCy_CSDIDAC_Type *dac_ptr;\n\n\tRT_ASSERT(device!= RT_NULL);\n\n\tdac_ptr = device->parent.user_data;\n\n\t/* Get the DAC channel. */\n\tdac_channel = cyp_dac_get_channel(device, channel);\n\tif (dac_channel == RT_NULL) {\n\t\tLOG_E(\"DAC channel is null\");\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* Enable the DAC output with the specified value. */\n\tresult = Cy_CSDIDAC_OutputEnable(dac_ptr, dac_channel, *value);\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"DAC output enable failed\");\n\t\treturn -RT_ERROR;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 55.98743787822645}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tRT_ASSERT(device!= RT_NULL);\n\n\t/* Get the DAC channel */\n\tCy_CSDIDAC_Type *dac = (Cy_CSDIDAC_Type *)device->parent.user_data;\n\tRT_ASSERT(dac!= RT_NULL);\n\n\t/* Enable the DAC output with the specified value */\n\trt_err_t result = Cy_CSDIDAC_OutputEnable(dac, channel, *value);\n\n\t/* Check for errors */\n\tif (result!= RT_EOK) {\n\t\tLOG_E(\"Failed to enable the DAC output\");\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 46.52729158710864}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif (addr + size > FLASH_32K_END) {\n\t\tLOG_E(\"Flash address out of range!\");\n\t\treturn -1;\n\t}\n\n\trt_uint32_t i;\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 42.01475500711924}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t *p;\n\trt_uint32_t *q;\n\n\tif (addr + size > IFX_FLASH_32K_SIZE) {\n\t\tLOG_E(\"ifx_flash_read_32k: addr + size > IFX_FLASH_32K_SIZE\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tp = (rt_uint32_t *)buf;\n\tq = (rt_uint32_t *)addr;\n\tfor (i = 0; i < size / 4; i++) {\n\t\t*p = *q;\n\t\tp++;\n\t\tq++;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 46.11111070428639}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif (addr + size > 0x0000FFFF) {\n\t\tLOG_E(\"Flash read error: address + size exceeds flash memory's end address\");\n\t\treturn -RT_EINVAL;\n\t}\n\tif (buf == RT_NULL) {\n\t\tLOG_E(\"Flash read error: buffer is NULL\");\n\t\treturn -RT_EINVAL;\n\t}\n\trt_uint32_t i = 0;\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *) addr;\n\t\taddr++;\n\t}\n\treturn i;\n}", "CodeBleu_score": 50.21996607583992}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\treturn cyhal_timer_read(timer->timer);\n}", "CodeBleu_score": 13.715034688000738}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tRT_ASSERT(timer->user_data!= RT_NULL);\n\n\treturn cyhal_timer_read((cyhal_timer_t *)timer->user_data);\n}", "CodeBleu_score": 47.5457233582811}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer);\n\treturn cyhal_timer_read(timer->timer_obj);\n}", "CodeBleu_score": 10.952455439576681}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n\tRT_ASSERT(dfs_lock_mutex!= RT_NULL);\n}", "CodeBleu_score": 8.70280555805658}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n\tRT_ASSERT\n}", "CodeBleu_score": 5.446218766202625}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(dfs_mutex, RT_WAITING_FOREVER);\n\tRT_ASSERT\n}", "CodeBleu_score": 4.986307310601247}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint slot = -1;\n\n\tfor (i = startfd; i < fdt->max_fds; i++) {\n\t\tif (fdt->fd[i] == NULL) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (slot == -1) {\n\t\tif (fd_slot_expand(fdt) == -1) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn fd_slot_alloc(fdt, startfd);\n\t\t}\n\t} else {\n\t\treturn slot;\n\t}\n}", "CodeBleu_score": 37.40846801554538}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tfor (i = startfd; i < fdt->max_fds; i++) {\n\t\tif (fdt->fd[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tif (fd_slot_expand(fdt)) {\n\t\treturn -1;\n\t}\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 35.41036914088252}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tfor (i = startfd; i < fdt->max_fds; i++) {\n\t\tif (!fdt->fd[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tif (fd_slot_expand(fdt)) {\n\t\treturn -1;\n\t}\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 34.73780717252918}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < RT_ERR_COUNT; i++) {\n\t\tif (error == rt_errors[i].code) {\n\t\t\treturn rt_errors[i].string;\n\t\t}\n\t}\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 47.07450692807909}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tstatic const char *err_strings[] = {\n\t\t\"No error\",\n\t\t\"Invalid argument\",\n\t\t\"Invalid state\",\n\t\t\"Invalid handle\",\n\t\t\"Invalid operation\",\n\t\t\"Invalid value\",\n\t\t\"Invalid format\",\n\t\t\"Invalid file descriptor\",\n\t\t\"Invalid file\",\n\t\t\"Invalid file system\",\n\t\t\"Invalid file system object\",\n\t\t\"Invalid directory\",\n\t\t\"Invalid directory entry\",\n\t\t\"Invalid path\",\n\t\t\"Invalid object\",\n\t\t\"Invalid object type\",\n\t\t\"Invalid object name\",\n\t\t\"Invalid object attribute\",\n\t\t\"Invalid object attribute value\",\n\t\t\"Invalid object attribute value length\",\n\t\t\"Invalid object attribute value type\",\n\t\t\"Invalid object attribute value format\",\n\t\t\"Invalid object attribute value range\",\n\t\t\"Invalid object attribute value access\",\n\t\t\"Invalid object attribute value value\",\n\t\t\"Invalid object attribute value value length\",\n\t\t\"Invalid object attribute value value format\",\n\t\t\"Invalid object attribute value value range\",\n\t\t\"Invalid object attribute value value access\",\n\t\t\"Invalid object attribute value value type\",\n\t\t\"Invalid object attribute value value type length\",\n\t\t\"Invalid object attribute value value type format\",\n\t\t\"Invalid object attribute value value type range\",\n\t\t\"Invalid object attribute value value type access\",\n\t\t\"Invalid object attribute value value type value\",\n\t\t\"Invalid object attribute value value type value length\",\n\t\t\"Invalid object attribute value value type value format\",\n\t\t\"Invalid object attribute value value type value range\",\n\t\t\"Invalid object attribute value value type value access\",\n\t\t\"Invalid object attribute value value type value type\",\n\t\t\"Invalid object attribute value value type value type length\",\n\t\t\"Invalid object attribute value value type value type format\",\n\t\t\"Invalid object attribute value value type value type range\",\n\t\t\"Invalid object attribute value value type value type access\",\n\t\t\"Invalid object attribute value value type value type value\",\n\t\t\"Invalid object attribute value value type value type value length\",\n\t\t\"Invalid object attribute value value type value type value format\",\n\t\t\"Invalid object attribute value value type value type value range\",\n\t\t\"Invalid object attribute value value type value type value access\",\n\t\t\"Invalid object attribute value value type value type value type\",\n\t\t\"Invalid object attribute value value type value type value type length\",\n\t\t\"Invalid object attribute value value", "CodeBleu_score": 4.5007110425465084}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tfor (i = 0; i < RT_ERR_MAX; i++) {\n\t\tif (error == rt_err_strings[i].code) {\n\t\t\treturn rt_err_strings[i].string;\n\t\t}\n\t}\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 39.82022005427027}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\tstruct rt_thread *thread;\n\n\tthread = rt_thread_self();\n\tlevel = rt_hw_interrupt_disable();\n\tif (thread->idle_hook_list_head == RT_NULL) {\n\t\tthread->idle_hook_list_head = hook;\n\t\tresult = RT_EOK;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_hw_interrupt_enable(level);\n\treturn result;\n}", "CodeBleu_score": 24.40844343292044}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_spin_lock_irqsave(&idle_hook_lock);\n\tif (idle_hook_count < RT_THREAD_MAX_IDLE_HOOKS) {\n\t\tidle_hook_list[idle_hook_count++] = hook;\n\t} else {\n\t\tresult = RT_EFULL;\n\t}\n\trt_spin_unlock_irqrestore(&idle_hook_lock);\n\treturn result;\n}", "CodeBleu_score": 27.3647831729462}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = -RT_EFULL;\n\trt_spin_lock_irqsave(&idle_hook_lock);\n\tif (idle_hook_count < RT_THREAD_MAX_IDLE_HOOK) {\n\t\tidle_hook_list[idle_hook_count++] = hook;\n\t\tresult = RT_EOK;\n\t}\n\trt_spin_unlock_irqrestore(&idle_hook_lock);\n\treturn result;\n}", "CodeBleu_score": 28.895171736250713}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_spin_lock_irqsave(&thread_lock);\n\tif (hook!= NULL) {\n\t\tstruct rt_thread_idle_hook *idle_hook = NULL;\n\t\tstruct rt_thread_idle_hook *idle_hook_prev = NULL;\n\t\tidle_hook = idle_hook_list;\n\t\twhile (idle_hook!= NULL) {\n\t\t\tif (idle_hook->hook == hook) {\n\t\t\t\tif (idle_hook_prev == NULL) {\n\t\t\t\t\tidle_hook_list = idle_hook->next;\n\t\t\t\t} else {\n\t\t\t\t\tidle_hook_prev->next = idle_hook->next;\n\t\t\t\t}\n\t\t\t\tidle_hook->next = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidle_hook_prev = idle_hook;\n\t\t\tidle_hook = idle_hook->next;\n\t\t}\n\t\tif (idle_hook == NULL) {\n\t\t\tresult = -RT_ENOSYS;\n\t\t}\n\t}\n\trt_spin_unlock_irqrestore(&thread_lock);\n\treturn result;\n}", "CodeBleu_score": 40.812776167219475}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_spin_lock_irqsave(&idle_hook_list_lock);\n\trt_list_t *list = &idle_hook_list;\n\trt_list_t *node = list->next;\n\twhile (node!= list) {\n\t\tif (node->item.value == hook) {\n\t\t\trt_list_remove(node);\n\t\t\tnode->item.value = RT_NULL;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t\tnode = node->next;\n\t}\n\trt_spin_unlock_irqrestore(&idle_hook_list_lock);\n\treturn result;\n}", "CodeBleu_score": 44.30198915420933}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = -RT_ENOSYS;\n\trt_spin_lock_irqsave(&idle_hook_lock, level);\n\tif (idle_hook_list!= RT_NULL) {\n\t\trt_list_t *p = idle_hook_list;\n\t\twhile (p!= RT_NULL) {\n\t\t\tif (p->next == RT_NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p->next->data == hook) {\n\t\t\t\trt_list_t *tmp = p->next;\n\t\t\t\tp->next = tmp->next;\n\t\t\t\trt_free(tmp);\n\t\t\t\tresult = RT_EOK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = p->next;\n\t\t}\n\t}\n\trt_spin_unlock_irqrestore(&idle_hook_lock, level);\n\treturn result;\n}", "CodeBleu_score": 47.29595301429661}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\tRT_ASSERT(susp_list!= RT_NULL);\n\trt_list_t *list;\n\trt_thread_t thread;\n\trt_err_t result;\n\n\t/* unlock the scheduler */\n\trt_hw_interrupt_disable();\n\n\t/* dequeue each thread in the list */\n\tlist = susp_list;\n\twhile (list!= RT_NULL) {\n\t\t/* get the thread from the list */\n\t\tthread = rt_list_entry(list, struct rt_thread, tlist);\n\n\t\t/* remove the thread from the list */\n\t\trt_list_remove(list);\n\n\t\t/* resume the thread */\n\t\tresult = rt_thread_resume(thread, thread_error);\n\t\tRT_ASSERT(result == RT_EOK);\n\n\t\t/* get the next thread from the list */\n\t\tlist = susp_list;\n\t}\n\n\t/* lock the scheduler */\n\trt_hw_interrupt_enable();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 46.93097627794698}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_err_t result = RT_EOK;\n\trt_list_t *item;\n\trt_thread_t thread;\n\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\trt_enter_critical();\n\twhile (!rt_list_isempty(susp_list)) {\n\t\titem = rt_list_entry(susp_list->next, rt_list_t, list);\n\t\trt_list_remove(item);\n\t\tthread = rt_list_entry(item, rt_thread_t, suspend_list);\n\t\trt_thread_resume(thread, thread_error);\n\t}\n\trt_exit_critical();\n\n\treturn result;\n}", "CodeBleu_score": 34.2534411717253}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_err_t ret = RT_EOK;\n\trt_thread_t thread;\n\tRT_ASSERT(susp_list!= RT_NULL);\n\trt_base_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, suspend_list);\n\t\trt_list_remove(&thread->suspend_list);\n\t\tthread->error = thread_error;\n\t\trt_hw_interrupt_enable(level);\n\t\trt_thread_resume(thread);\n\t\tlevel = rt_hw_interrupt_disable();\n\t}\n\trt_hw_interrupt_enable(level);\n\treturn ret;\n}", "CodeBleu_score": 31.005479294054627}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_device;\n\trt_device_t new_device;\n\trt_device_t new_device_tmp;\n\trt_device_t old_device_tmp;\n\trt_device_t new_device_tmp_tmp;\n\trt_device_t old_device_tmp_tmp;\n\trt_device_t new_device_tmp_tmp;\n\trt_device_t old_device_tmp_tmp_tmp;\n\trt_device_t new_device_tmp_tmp_tmp;\n\trt_device_t old_device_tmp_tmp_tmp_tmp;\n\trt_device_t new_device_tmp_tmp_tmp_tmp;\n\trt_device_t old_device_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t new_device_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t old_device_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t new_device_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t old_device_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t new_device_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t old_device_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t new_device_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t old_device_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t new_device_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t old_device_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t new_device_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt_device_t old_device_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\trt", "CodeBleu_score": 7.627410943265528}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_device = rt_console_get_device();\n\trt_device_t new_device = rt_device_find(name);\n\tif (new_device!= RT_NULL && new_device!= old_device) {\n\t\tif (old_device!= RT_NULL) {\n\t\t\trt_device_close(old_device);\n\t\t}\n\t\trt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_OFLAG_STREAM);\n\t\trt_console_set_device(new_device);\n\t}\n\treturn old_device;\n}", "CodeBleu_score": 51.552031092999805}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t dev = rt_device_find(name);\n\tif (dev == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\tif (dev!= rt_console_get_device()) {\n\t\tif (rt_console_get_device()!= RT_NULL) {\n\t\t\trt_device_close(rt_console_get_device());\n\t\t}\n\t\tif (rt_device_open(dev, RT_DEVICE_FLAG_RDWR)!= RT_EOK) {\n\t\t\treturn RT_NULL;\n\t\t}\n\t\trt_console_set_device(dev);\n\t}\n\treturn rt_console_get_device();\n}", "CodeBleu_score": 46.11275862333277}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_class *object_class = rt_object_class_get(type);\n\tint count = 0;\n\trt_spin_lock_irqsave(&object_class->lock);\n\trt_list_for_each(object_class->object_list, object, list) {\n\t\tcount++;\n\t}\n\trt_spin_unlock_irqrestore(&object_class->lock);\n\treturn count;\n}", "CodeBleu_score": 35.043885416045235}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\trt_spinlock_t *lock = rt_object_get_information(type)->lock;\n\trt_spin_lock_irqsave(lock, flags);\n\trt_list_for_each(pos, &rt_object_get_information(type)->list) {\n\t\tcount++;\n\t}\n\trt_spin_unlock_irqrestore(lock, flags);\n\treturn count;\n}", "CodeBleu_score": 32.803556367581365}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tstruct rt_list_head *list;\n\tstruct rt_object *obj;\n\trt_spin_lock_irqsave(&rt_object_list_lock[type]);\n\tlist = &rt_object_list[type];\n\tlist_for_each(list, obj) {\n\t\tcount++;\n\t}\n\trt_spin_unlock_irqrestore(&rt_object_list_lock[type]);\n\treturn count;\n}", "CodeBleu_score": 34.43036034439928}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\trt_object_information_t *object_info;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\t/* call the object hook function */\n\tRT_OBJECT_HOOK_CALL(object, RT_OBJECT_DETACH_HOOK);\n\n\t/* get the object information */\n\tobject_info = (rt_object_information_t *)object;\n\n\t/* lock the spinlock to ensure thread safety */\n\trt_spin_lock_irqsave(&(object_info->lock), object_info->irq_flag);\n\n\t/* remove the object from its list */\n\trt_list_remove(&(object_info->list));\n\n\t/* unlock the spinlock */\n\trt_spin_unlock_irqrestore(&(object_info->lock), object_info->irq_flag);\n\n\t/* set the object type to zero */\n\tobject_info->type = RT_OBJECT_TYPE_NULL;\n}", "CodeBleu_score": 41.6360465509394}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_object_t object_info;\n\trt_base_t level;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\tobject_info = rt_object_get_information(object);\n\tRT_ASSERT(object_info!= RT_NULL);\n\n\tif (object_info->type!= RT_Object_Class) {\n\t\trt_object_hook_detach(object);\n\t}\n\n\tlevel = rt_spin_lock_irqsave(&object_info->lock);\n\trt_list_remove(&(object_info->parent.list));\n\trt_spin_unlock_irqrestore(&object_info->lock, level);\n\n\tobject_info->type = RT_Object_Class;\n}", "CodeBleu_score": 48.87585202725763}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\tRT_OBJECT_HOOK_CALL(object, RT_OBJECT_DETACH_HOOK);\n\trt_object_t object_information = rt_object_get_information(object);\n\trt_spin_lock_irqsave(&object_information->lock, level);\n\trt_list_remove(&object_information->list);\n\trt_spin_unlock_irqrestore(&object_information->lock, level);\n\tobject_information->type = RT_OBJECT_TYPE_NULL;\n}", "CodeBleu_score": 37.138681187236166}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_custom_object_t cobj = (rt_custom_object_t) obj;\n\trt_err_t result;\n\n\tif (cobj == RT_NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\tif (cobj->class!= RT_CUSTOM_OBJECT) {\n\t\treturn RT_ERROR;\n\t}\n\n\tif (cobj->destroy!= RT_NULL) {\n\t\tresult = cobj->destroy(cobj);\n\t}\n\n\trt_object_delete(cobj);\n\n\treturn result;\n}", "CodeBleu_score": 45.979619818990685}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->class_type == RT_CLASS_CUSTOM);\n\trt_custom_object_t cobj = (rt_custom_object_t)obj;\n\trt_err_t result = RT_EOK;\n\n\tif (cobj->destroy!= RT_NULL) {\n\t\tresult = cobj->destroy(cobj);\n\t}\n\n\trt_object_delete(obj);\n\treturn result;\n}", "CodeBleu_score": 39.919780193638424}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_custom_object_t cobj = (rt_custom_object_t) obj;\n\trt_err_t result = RT_EOK;\n\n\tif (cobj == RT_NULL) {\n\t\treturn RT_EINVAL;\n\t}\n\n\tif (cobj->class!= RT_CUSTOM_OBJECT) {\n\t\treturn RT_EINVAL;\n\t}\n\n\tif (cobj->destroy) {\n\t\tresult = cobj->destroy(cobj);\n\t}\n\n\trt_object_delete(cobj);\n\n\treturn result;\n}", "CodeBleu_score": 47.737143891381116}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\trt_thread_t thread = rt_thread_self();\n\trt_enter_critical();\n\trt_thread_close(thread);\n\trt_thread_defunct_enqueue(thread);\n\trt_schedule();\n\trt_exit_critical();\n}", "CodeBleu_score": 55.20042011061987}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t *thread = rt_thread_self();\n\n\trt_enter_critical();\n\n\trt_thread_close(thread);\n\n\trt_list_insert_after(&rt_thread_defunct_list, &thread->tlist);\n\n\trt_schedule();\n\n\trt_exit_critical();\n}", "CodeBleu_score": 30.22770303342955}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t *thread = rt_thread_self();\n\trt_enter_critical();\n\trt_thread_close(thread);\n\trt_thread_defunct_enqueue(thread);\n\trt_schedule();\n\trt_exit_critical();\n}", "CodeBleu_score": 55.528418939923995}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\tRT_ASSERT(parameter!= NULL);\n\tRT_ASSERT(rt_list_is_in_list((RT_THREAD_LIST_NODE *) parameter));\n\tRT_ASSERT(rt_list_get_parent((RT_THREAD_LIST_NODE *) parameter)!= NULL);\n\n\trt_thread_t thread = (rt_thread_t) parameter;\n\tRT_ASSERT(thread->state == RT_THREAD_STATE_SUSPENDED);\n\n\trt_sched_lock();\n\tRT_ASSERT(rt_list_is_in_list((RT_THREAD_LIST_NODE *) thread));\n\tRT_ASSERT(rt_list_get_parent((RT_THREAD_LIST_NODE *) thread)!= NULL);\n\n\tthread->error_code = RT_ERROR_TIMEOUT;\n\trt_list_remove((RT_THREAD_LIST_NODE *) thread);\n\trt_list_insert_after((RT_THREAD_LIST_NODE *) thread, (RT_THREAD_LIST_NODE *) &rt_thread_list_ready);\n\trt_sched_unlock_n_resched();\n}", "CodeBleu_score": 36.48928836472069}, {"code": "static void _thread_timeout(void *parameter){\n\t\tRT_ASSERT(parameter!= NULL);\n\tRT_ASSERT(rt_thread_is_suspended(parameter));\n\tRT_ASSERT(rt_thread_get_error(parameter) == RT_ETIMEOUT);\n\trt_list_remove(parameter);\n\trt_list_insert_after(rt_thread_get_ready_list(rt_thread_get_scheduler(parameter)), parameter);\n\trt_scheduler_unlock(rt_thread_get_scheduler(parameter));\n}", "CodeBleu_score": 43.28838016113971}, {"code": "static void _thread_timeout(void *parameter){\n\t\tRT_ASSERT(parameter!= NULL);\n\trt_thread_t thread = (rt_thread_t) parameter;\n\tRT_ASSERT(rt_object_get_type(thread) == RT_Object_Thread);\n\tRT_ASSERT(thread->suspend_count!= 0);\n\tRT_ASSERT(thread->state == RT_Thread_State_Suspended);\n\tRT_ASSERT(thread->error == RT_ERROR_TIMEOUT);\n\trt_list_remove(&thread->suspend_list);\n\trt_list_insert_after(&rt_thread_ready_list, &thread->suspend_list);\n\trt_sched_unlock_n_resched();\n}", "CodeBleu_score": 47.67384480840533}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spinlock_t lock = thread->lock;\n\trt_list_t *wait_list = &thread->wait_list;\n\trt_list_t *node;\n\trt_mutex_t mutex;\n\trt_object_t obj;\n\n\trt_spin_lock_irqsave(lock);\n\tif (rt_list_empty(wait_list)) {\n\t\trt_spin_unlock_irqrestore(lock);\n\t\treturn;\n\t}\n\trt_list_for_each_safe(node, wait_list) {\n\t\tmutex = rt_list_entry(node, rt_mutex_t, wait_list);\n\t\trt_mutex_release(mutex);\n\t}\n\trt_spin_unlock_irqrestore(lock);\n}", "CodeBleu_score": 37.073629762117164}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spin_lock_irqsave(&thread->lock);\n\tif (thread->mutex!= RT_NULL) {\n\t\trt_list_del(&thread->mutex_list);\n\t\tthread->mutex = RT_NULL;\n\t}\n\trt_spin_unlock_irqrestore(&thread->lock);\n}", "CodeBleu_score": 19.14769888697629}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spinlock_t *lock = &thread->lock;\n\trt_list_t *list;\n\n\t/* lock the thread's spinlock */\n\trt_spin_lock_irqsave(lock);\n\n\t/* check if the thread is waiting on a mutex */\n\tif (thread->mutex!= RT_NULL) {\n\t\t/* remove the thread from the mutex's waiting list */\n\t\trt_list_del(&thread->list);\n\t\tthread->mutex = RT_NULL;\n\n\t\t/* clear the pending object */\n\t\tthread->pending_object = RT_NULL;\n\t}\n\n\t/* release all mutexes the thread has taken */\n\trt_mutex_release(thread);\n\n\t/* restore the spinlock state */\n\trt_spin_unlock_irqrestore(lock);\n}", "CodeBleu_score": 27.97700665787884}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(rt_object_get_type(thread) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread %s priority %d\", thread->name, thread->current_priority);\n\tthread->stat = RT_THREAD_SUSPEND;\n\trt_list_insert_before(&rt_thread_priority_table[thread->current_priority], &thread->tlist);\n\trt_hw_interrupt_disable();\n\trt_thread_resume(thread);\n\trt_hw_interrupt_enable();\n\treturn RT_EOK;\n}", "CodeBleu_score": 50.07009314931415}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(rt_object_get_type(thread) == RT_Object_Class_Thread);\n\tLOG_D(\"thread %s, priority %d\", thread->name, thread->current_priority);\n\trt_list_insert_after(&rt_thread_priority_table[thread->current_priority], thread);\n\tthread->stat = RT_THREAD_SUSPEND;\n\trt_thread_resume(thread);\n\trt_thread_scheduler_resume();\n\treturn RT_EOK;\n}", "CodeBleu_score": 53.19052049266008}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(rt_object_get_type(thread) == RT_Object_Class_Thread);\n\tLOG_D(\"thread %s startup, priority %d\", thread->name, thread->current_priority);\n\trt_list_init(&thread->tlist);\n\trt_list_insert_after(&thread->tlist, &rt_thread_priority_table[thread->current_priority]);\n\tthread->stat = RT_THREAD_SUSPEND;\n\trt_thread_resume(thread);\n\trt_thread_scheduler_resume();\n\treturn RT_EOK;\n}", "CodeBleu_score": 49.955872421324564}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_uint8_t level = 0;\n\trt_list_t *timer_entry = RT_NULL;\n\n\tfor (level = RT_TIMER_LIST_LEVELS; level > 0; level--) {\n\t\tif (!rt_list_isempty(&timer_list[level - 1])) {\n\t\t\ttimer_entry = rt_list_entry(timer_list[level - 1].next, rt_timer_list_t, list);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (timer_entry!= RT_NULL) {\n\t\t*timeout_tick = timer_entry->timeout;\n\t\treturn RT_EOK;\n\t} else {\n\t\treturn -RT_ERROR;\n\t}\n}", "CodeBleu_score": 42.60222115928675}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\tint i;\n\trt_list_entry_t *timer_entry;\n\n\tfor (i = RT_TIMER_LIST_LEVEL - 1; i >= 0; i--) {\n\t\tif (!rt_list_isempty(&timer_list[i])) {\n\t\t\ttimer_entry = rt_list_entry(rt_list_first(&timer_list[i]), rt_list_entry_t, timer_list);\n\t\t\t*timeout_tick = timer_entry->timeout;\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 37.72416446254026}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_entry_t *entry;\n\trt_list_entry_t *next;\n\trt_list_entry_t *max_entry;\n\trt_list_t *max_list;\n\trt_list_t *list;\n\trt_list_t *next_list;\n\trt_tick_t next_timeout;\n\trt_tick_t timeout;\n\trt_uint8_t level;\n\trt_uint8_t max_level;\n\n\t/* Get the maximum level of the timer skip list. */\n\tmax_level = _timer_list_max_level(timer_list);\n\n\t/* Get the first entry of the maximum level of the timer skip list. */\n\tmax_entry = rt_list_first(timer_list[max_level]);\n\n\t/* If the maximum level of the timer skip list is empty, return an error code. */\n\tif (max_entry == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* Get the timeout tick of the first entry of the maximum level of the timer skip list. */\n\ttimeout = rt_list_entry(max_entry, struct rt_timer, list)->timeout;\n\n\t/* If the timeout tick of the first entry of the maximum level of the timer skip list is zero, return an error code. */\n\tif (timeout == 0) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* Set the provided timeout tick to the timeout tick of the first entry of the maximum level of the timer skip list. */\n\t*timeout_tick = timeout;\n\n\t/* Get the maximum level of the timer skip list. */\n\tmax_level = _timer_list_max_level(timer_list);\n\n\t/* Get the first entry of the maximum level of the timer skip list. */\n\tmax_entry = rt_list_first(timer_list[max_level]);\n\n\t/* Get the timeout tick of the first entry of the maximum level of the timer skip list. */\n\ttimeout = rt_list_entry(max_entry, struct rt_timer, list)->timeout;\n\n\t/* If the timeout tick of the first entry of the maximum level of the timer skip list is zero, return an error code. */\n\tif (timeout == ", "CodeBleu_score": 38.45265749765453}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#if RT_USING_TIMER\n    rt_timer_t timer;\n    RT_ASSERT(timeout!= RT_NULL);\n    RT_ASSERT(time!= 0);\n    RT_ASSERT(time <= RT_TICK_MAX);\n\n    timer = rt_malloc(sizeof(struct rt_timer));\n    if (timer!= RT_NULL) {\n        timer->flag = flag;\n        timer->timeout = timeout;\n        timer->parameter = parameter;\n        timer->time = time;\n        timer->prev = RT_NULL;\n        timer->next = RT_NULL;\n        timer->status = RT_TIMER_INIT;\n\n        rt_list_init(&timer->tlist);\n        rt_list_insert_before(&rt_timer_list, &timer->tlist);\n    }\n\n    return timer;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 46.94014079083109}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#if RT_USING_TIMER_SOFT\n    rt_timer_t timer;\n\n    RT_ASSERT(timeout!= RT_NULL);\n    RT_ASSERT(time > 0);\n\n    timer = rt_malloc(sizeof(struct rt_timer));\n    if (timer!= RT_NULL) {\n        rt_timer_init(timer, name, timeout, parameter, time, flag);\n    }\n\n    return timer;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 59.079241489957454}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_TIMER\n    rt_timer_t timer;\n\n    RT_ASSERT(timeout!= RT_NULL);\n    RT_ASSERT(time!= RT_TICK_MAX);\n\n    timer = rt_malloc(sizeof(struct rt_timer));\n    if (timer!= RT_NULL)\n    {\n        timer->flag = flag;\n        timer->timeout = timeout;\n        timer->parameter = parameter;\n        timer->time = time;\n        timer->flag = flag;\n    }\n\n    return timer;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 50.805225160552595}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(rec.Code)\n\tfor k, v := range rec.HeaderMap {\n\t\tfor _, v := range v {\n\t\t\tres.Header().Add(k, v)\n\t\t}\n\t}\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 43.28250786171518}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder for the response\n\trec := httptest.NewRecorder()\n\n\t// Call the router's ServeHTTP method\n\ta.router.ServeHTTP(rec, req)\n\n\t// Copy the recorder's headers to the original response\n\tfor k, v := range rec.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\n\t// Copy the recorder's status code to the original response\n\tres.WriteHeader(rec.Code)\n\n\t// Copy the recorder's body to the original response\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 37.753521525600355}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\ta.router.ServeHTTP(rec, req)\n\tif rec.Code == 401 {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tfor k, v := range rec.HeaderMap {\n\t\tres.Header().Set(k, v[0])\n\t}\n\tres.WriteHeader(rec.Code)\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 51.55254811868356}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the requested asset based on the URL path.\n\tasset, err := a.Asset(req.URL.Path)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the appropriate Content-Type header based on the file extension.\n\text := filepath.Ext(asset.Name())\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t// Write the asset content to the response.\n\tres.Write(asset.Content)\n}", "CodeBleu_score": 54.93642961104034}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the requested asset based on the URL path\n\tasset, err := a.Asset(req.URL.Path)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the appropriate Content-Type header based on the file extension\n\tswitch filepath.Ext(asset.Name()) {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t// Write the asset content to the response\n\t_, err = res.Write(asset)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 59.15130763867804}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the path from the request URL.\n\tpath := req.URL.Path\n\n\t// Split the path into its components.\n\tparts := strings.Split(path, \"/\")\n\n\t// Check if the path is empty.\n\tif len(parts) == 0 {\n\t\t// If the path is empty, return a 404 error.\n\t\thttp.Error(res, \"Path is empty\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Check if the path is a valid asset.\n\tif len(parts)!= 2 || parts[0]!= \"assets\" ||!a.isAsset(parts[1]) {\n\t\t// If the path is invalid, return a 404 error.\n\t\thttp.Error(res, \"Invalid asset path\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the asset from the path.\n\tasset := a.getAsset(parts[1])\n\n\t// Check if the asset exists.\n\tif asset == nil {\n\t\t// If the asset does not exist, return a 404 error.\n\t\thttp.Error(res, \"Asset does not exist\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the appropriate Content-Type header based on the file extension.\n\tswitch asset.extension {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tdefault:\n\t\tres.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t}\n\n\t// Write the asset content to the response.\n\t_, err := res.Write(asset.content)\n\tif err!= nil {\n\t\t// If an error occurs while writing the asset content, return a 500 error.\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 55.824721442591276}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\ta.writeJSON(res, err)\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 26.93791898210826}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL\n\trobotName := req.URL.Query().Get(\"robot\")\n\n\t// Find the robot using the master instance\n\trobot, err := a.master.Robot(robotName)\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": fmt.Sprintf(\"No robot found with name %s\", robotName)})\n\t\treturn\n\t}\n\n\t// Get the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": fmt.Sprintf(\"Error converting connections to JSON: %s\", err)})\n\t\treturn\n\t}\n\n\t// Write the JSON response\n\ta.writeJSON(res, http.StatusOK, string(jsonConnections))\n}", "CodeBleu_score": 41.16230234431898}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tif robotName == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\ta.writeJSON(res, map[string]string{\"error\": \"robot name is required\"})\n\t\treturn\n\t}\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\ta.writeJSON(res, robot.Connections())\n}", "CodeBleu_score": 37.35191557389017}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\tif!secureCompare(auth, \"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))) {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\t// If we get here, the user is authorized.\n\t}\n}", "CodeBleu_score": 56.82242182130345}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare([]byte(user), []byte(username)) ||!secureCompare([]byte(pass), []byte(password)) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// OK. Proceed.\n\t}\n}", "CodeBleu_score": 53.477281114849696}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare([]byte(user), []byte(username)) ||!secureCompare([]byte(pass), []byte(password)) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// OK\n\t}\n}", "CodeBleu_score": 54.18175073568129}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Round(slope*input + intercept))\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.23422764745814}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Round(slope*input + intercept))\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 55.28657697628552}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\treturn func(input float64) (value int) {\n\t\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\t\tintercept := float64(toMin) - slope * fromMin\n\t\tvalue = int(math.Max(math.Min(slope*input+intercept, float64(toMax)), float64(toMin)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 54.32521691242902}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Connection is not valid\")\n\t}\n\trawValue, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = rawValue\n\ta.lastScale = a.scale(rawValue)\n\treturn rawValue, a.lastScale, nil\n}", "CodeBleu_score": 50.410329754497866}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection is not valid\")\n\t}\n\tvalue, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRawValue = value\n\ta.lastScaledValue = a.scale(value)\n\treturn value, a.lastScaledValue, nil\n}", "CodeBleu_score": 50.55292486223141}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the mutex to ensure thread safety\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the connection is valid\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Connection is not valid\")\n\t}\n\n\t// Read the raw value from the pin\n\trawValue, err := reader.AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Update the last raw and scaled values\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.sensorCfg.scale * float64(rawValue)\n\n\treturn rawValue, a.lastScaledValue, nil\n}", "CodeBleu_score": 55.86967212056555}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m * fromMin\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 43.52982958392711}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(x int) float64 {\n\t\treturn (float64(x) - float64(fromMin)) / float64(fromMax - fromMin) * (toMax - toMin) + toMin\n\t}\n}", "CodeBleu_score": 35.995137157273774}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(input int) float64 {\n\t\treturn (float64(input) - float64(fromMin)) * (toMax - toMin) / (float64(fromMax) - float64(fromMin)) + toMin\n\t}\n}", "CodeBleu_score": 43.060089760599546}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\td.SetName(DefaultName)\n\td.AddEvent(EventVibration)\n\td.On(EventVibration, func(data interface{}) {\n\t\td.Publish(EventVibration, data)\n\t})\n\tgo func() {\n\t\tfor {\n\t\t\tdata := d.A.Read(d.Pin)\n\t\t\tif data > 1000 {\n\t\t\t\td.On(EventVibration, func(data interface{}) {\n\t\t\t\t\td.Publish(EventVibration, data)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}()\n\treturn d\n}", "CodeBleu_score": 34.13798856995584}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tvibrationEvent:     NewEvent(DefaultName),\n\t}\n\td.SetName(DefaultName)\n\td.AddEvent(d.vibrationEvent)\n\n\td.vibrationEvent.AddListener(func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.vibrationEvent, data)\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 45.73294672407312}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := NewGrovePiezoVibrationSensorDriverWithName(\n\t\ta,\n\t\tpin,\n\t\tDefaultName,\n\t\topts...,\n\t)\n\treturn d\n}", "CodeBleu_score": 13.593093412573614}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Set the tone period based on the given frequency and the tempo\n\ttonePeriod := float64(time.Second) / (hz * float64(d.bpm) / 60)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period\n\tfor i := 0; i < int(duration/tonePeriod); i++ {\n\t\terr := d.On()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Second)\n\t\terr = d.Off()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 51.50418026615022}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency and the tempo\n\ttonePeriod := 60 / hz * float64(d.bpm)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period\n\tfor i := 0; i < int(duration*float64(time.Second)/tonePeriod); i++ {\n\t\terr := d.On()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t\terr = d.Off()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.60111693778889}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency and the tempo\n\ttonePeriod := 1 / (hz / float64(d.bpm))\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period\n\tfor i := 0; i < int(duration/tonePeriod); i++ {\n\t\terr := d.On()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod * 1000000000))\n\t\terr = d.Off()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod * 1000000000))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.10739398361431}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 30.540680276369127}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.58595756945493}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, LOW)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.528340806641403}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin, err := a.sys.NewAnalogPin(path, params)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 53.15726416598904}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin, err := a.sys.NewAnalogPin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 45.498397651630846}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin, err := a.sys.NewAnalogPin(path)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 50.124812423469535}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.63907685129997}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.63907685129997}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.63907685129997}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins connected\")\n\t}\n\n\tfor _, opt := range opts {\n\t\tif!opt(a) {\n\t\t\treturn nil, fmt.Errorf(\"invalid option\")\n\t\t}\n\t}\n\n\tfor _, p := range a.pins {\n\t\tif p.ID() == id {\n\t\t\treturn p, nil\n\t\t}\n\t}\n\n\tchip, line, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err := a.NewDigitalPin(chip, line)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.initialize(pin)\n\ta.pins = append(a.pins, pin)\n\n\tfor _, opt := range opts {\n\t\tif!opt(pin) {\n\t\t\treturn nil, fmt.Errorf(\"invalid option\")\n\t\t}\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 49.24618869862888}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins connected to adaptor\")\n\t}\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tpin = a.NewDigitalPin(id, opts...)\n\t\ta.pins[id] = pin\n\t\ta.initialize(pin)\n\t} else {\n\t\tpin.ApplyOptions(opts...)\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 33.38596244534532}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.digitalPins == nil {\n\t\treturn nil, fmt.Errorf(\"no digital pins connected\")\n\t}\n\tvar pin gobot.DigitalPin\n\tfor _, p := range a.digitalPins {\n\t\tif p.ID() == id {\n\t\t\tpin = p\n\t\t\tbreak\n\t\t}\n\t}\n\tif pin == nil {\n\t\tchip, line, err := a.translate(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = a.newDigitalPin(chip, line, opts...)\n\t\ta.digitalPins = append(a.digitalPins, pin)\n\t} else {\n\t\tpin.ApplyOptions(opts...)\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 54.19573336895726}]}
