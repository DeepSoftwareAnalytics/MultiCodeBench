{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> requiredFiles;\n\tfor (const auto &file : _pimpl->GetRequiredFiles(folder)) {\n\t\tif (download) {\n\t\t\tif (_pimpl->FileExists(file)) {\n\t\t\t\tlog_info(\"File exists in cache: \" + file);\n\t\t\t} else {\n\t\t\t\tlog_info(\"File not found in cache: \" + file);\n\t\t\t\t_pimpl->DownloadFile(file);\n\t\t\t\tlog_info(\"File downloaded: \" + file);\n\t\t\t}\n\t\t}\n\t\trequiredFiles.push_back(file);\n\t}\n\treturn requiredFiles;\n}", "CodeBleu_score": 47.91653665128822}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> requiredFiles;\n\tstd::string path = _pimpl->GetPath(folder);\n\tstd::vector<std::string> files = _pimpl->GetFilesInFolder(path);\n\tfor (const auto &file : files) {\n\t\tstd::string fileToGet = _pimpl->GetFileToGet(file);\n\t\tif (download) {\n\t\t\tif (!_pimpl->FileExists(fileToGet)) {\n\t\t\t\t_pimpl->CallAndWait<std::string>(FileTransfer::RequestFile, fileToGet);\n\t\t\t\t_pimpl->LogDownload(fileToGet);\n\t\t\t} else {\n\t\t\t\t_pimpl->LogFoundInCache(fileToGet);\n\t\t\t}\n\t\t}\n\t\trequiredFiles.push_back(fileToGet);\n\t}\n\treturn requiredFiles;\n}", "CodeBleu_score": 45.01846156755222}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> requiredFiles;\n\tstd::vector<std::string> files = _pimpl->GetRequiredFiles(folder, download);\n\tfor (std::string file : files) {\n\t\tif (file.find(folder) == 0) {\n\t\t\trequiredFiles.push_back(file);\n\t\t}\n\t}\n\treturn requiredFiles;\n}", "CodeBleu_score": 38.617704007492335}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n#if!defined(NDEBUG)\n  if (attachment_type == rpc::AttachmentType::SpringArm) {\n    if (transform.location.z!= 0.0f) {\n      std::cerr << \"WARNING: Actor attachment type SpringArm is ill-formed because the translation is only in the z-axis, and the translation is not zero. The translation is ignored.\" << std::endl;\n    }\n  }\n#endif\n\n  return _pimpl->SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 36.8614077701966}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n//  if (attachment_type == rpc::AttachmentType::SPRINGARM || attachment_type == rpc::AttachmentType::SPRINGARM_GHOST) {\n//    if (transform.location.z == 0.0f) {\n//      LOG_WARNING(\"The z-component of the transform is zero, which may cause unexpected behavior.\");\n//    }\n//  }\n\n  return _pimpl->CallAndWait<rpc::Actor>(\n      \"SpawnActorWithParent\",\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 27.42680992276326}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n// Check if the attachment type is SpringArm or SpringArmGhost.\nif (attachment_type == rpc::AttachmentType::SPRING_ARM || attachment_type == rpc::AttachmentType::SPRING_ARM_GHOST) {\n\n// Check if the translation is only in the 'z' axis.\nif (transform.location.z == 0.0f) {\n\n// Issue a warning if necessary.\nLOG_WARN(\"The translation of the attachment is only in the 'z' axis. This may cause issues with the attachment.\");\n}\n}\n\n// Spawn the actor with the provided description, transform, parent ID, attachment type, and socket name.\nrpc::ActorId actor_id = SpawnActor(description, transform, parent, attachment_type, socket_name);\n\n// Return the spawned actor.\nreturn actor_id;\n}", "CodeBleu_score": 38.567418968625965}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\tauto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\n      rpc::Call::SubscribeToGBuffer,\n      ActorId,\n      GBufferId);\n\n\tstd::memcpy(_pimpl->token.data(), token_data.data(), token_data.size());\n\t_pimpl->streaming_client.Subscribe(std::move(_pimpl->token), callback);\n}", "CodeBleu_score": 60.11726221566781}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Create a new token for the G-buffer.\nauto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\n      \"gbuffer.CreateToken\",\n      rpc::GBufferId(ActorId, GBufferId));\n// Copy the token data to a local buffer.\nstd::vector<unsigned char> token_data_copy(token_data.size());\nstd::memcpy(token_data_copy.data(), token_data.data, token_data.size());\n// Subscribe to the streaming client using the provided callback function.\n_pimpl->streaming_client.Subscribe(\n      std::move(token_data_copy),\n      [callback](const std::vector<unsigned char>& buffer) {\n        callback(Buffer(buffer.data(), buffer.size()));\n      });\n}", "CodeBleu_score": 57.94751085292697}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t#ifdef _WIN32\n  std::unique_lock<std::mutex> lock(_pimpl->streaming_client_mutex);\n#endif\n  auto token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\n      \"GetGBufferToken\",\n      rpc::GetGBufferTokenRequest{\n          ActorId,\n          GBufferId,\n      });\n  std::memcpy(_pimpl->streaming_client_token.data(), token_data.data(), token_data.size());\n  _pimpl->streaming_client.Subscribe(\n      _pimpl->streaming_client_token,\n      std::move(callback));\n}", "CodeBleu_score": 52.6206412500962}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> result;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_2;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_2;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_3;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_3;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_4;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_4;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_5;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_5;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_6;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_6;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_7;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_7;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_8;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_8;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_9;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_9;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_10;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_10;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_11;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_11;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_12;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_12;\n\tstd::shared_ptr<WalkerNavigation> new_walker_navigation_13;\n\tstd::shared_ptr<WalkerNavigation> old_walker_navigation_13;\n\t", "CodeBleu_score": 10.158258027928186}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> _walker_navigation;\n\tstd::atomic<bool> _walker_navigation_is_null;\n\tstd::atomic<bool> _walker_navigation_is_null_is_true;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_true;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false_is_true;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false_is_false;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false_is_false_is_true;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false_is_false_is_false;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false_is_false_is_false_is_true;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false_is_false_is_false_is_false;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false_is_false_is_false_is_false_is_true;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false_is_false_is_false_is_false_is_false;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false_is_false_is_false_is_false_is_false_is_true;\n\tstd::atomic<bool> _walker_navigation_is_null_is_false_is_false_is_false_is_false_is_false_is_false_is_false;\n\tstd::atomic<bool> _walker_navigation_is_null_is", "CodeBleu_score": 10.373198551442158}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> _walker_navigation;\n\t_walker_navigation.load\n\t_walker_navigation.compare_exchange\n\n\tif (!_walker_navigation) {\n\t\t_walker_navigation = std::make_shared<WalkerNavigation>();\n\t}\n\n\treturn _walker_navigation;\n}", "CodeBleu_score": 39.96436960458748}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tconst auto &state = episode.GetState();\n\tconst auto &timestamp = state->GetTimestamp();\n\n\t// Check if the frame is already synchronized.\n\tif (frame < timestamp) {\n\t\treturn true;\n\t}\n\n\t// Check if the frame is within the timeout.\n\tif (timestamp + timeout < frame) {\n\t\treturn false;\n\t}\n\n\t// Synchronize the frame.\n\twhile (frame < timestamp) {\n\t\tstd::this_thread::yield();\n\t\tcarla::traffic_manager::TrafficManager::Tick();\n\t\ttimestamp = state->GetTimestamp();\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 39.59330722359208}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (episode.GetState()->GetFrame() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (std::chrono::system_clock::now() - episode.GetState()->GetTimestamp() > timeout.to_chrono()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcarla::traffic_manager::TrafficManager::Tick();\n\treturn true;\n}", "CodeBleu_score": 29.722889600374657}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (true) {\n\t\tif (episode.GetState()->GetFrame() < frame) {\n\t\t\tstd::this_thread::yield();\n\t\t} else {\n\t\t\tif (std.chrono::system_clock::now() > timeout.to_chrono()) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tcarla::traffic_manager::TrafficManager::Tick();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 29.536545511512934}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy episode;\n\tint attempts = 0;\n\twhile (true) {\n\t\ttry {\n\t\t\tepisode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\t\t\tbreak;\n\t\t} catch (std::runtime_error& e) {\n\t\t\tif (attempts >= _client.GetTimeout().milliseconds) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(_client.GetTimeout().milliseconds / 10));\n\t\t\tattempts++;\n\t\t}\n\t}\n\treturn episode;\n}", "CodeBleu_score": 40.470642794976975}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy episode;\n\tint attempts = 0;\n\twhile (true) {\n\t\ttry {\n\t\t\tepisode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\t\t\tbreak;\n\t\t} catch (const std::runtime_error& e) {\n\t\t\tif (attempts++ >= _client.GetTimeout().milliseconds) {\n\t\t\t\tthrow std::runtime_error(\"Failed to load episode\");\n\t\t\t}\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\t}\n\t}\n\treturn episode;\n}", "CodeBleu_score": 36.66835571863777}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy episode;\n\tstd::chrono::milliseconds timeout = _client.GetTimeout();\n\tfor (int i = 0; i < _client.GetMaxAttempts(); i++) {\n\t\ttry {\n\t\t\tepisode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\t\t\tbreak;\n\t\t} catch (std::runtime_error& e) {\n\t\t\tif (i < _client.GetMaxAttempts() - 1) {\n\t\t\t\tstd::this_thread::sleep_for(timeout);\n\t\t\t} else {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\treturn episode;\n}", "CodeBleu_score": 39.381682868879864}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tauto *walker = GetWalker(controller.GetDisplayId());\n\tDEBUG_ASSERT(walker!= nullptr);\n\tauto *episode = GetEpisode();\n\tDEBUG_ASSERT(episode!= nullptr);\n\tauto *nav = episode->CreateNavigationIfMissing();\n\tDEBUG_ASSERT(nav!= nullptr);\n\tnav->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 52.58481721186}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tassert(controller.GetEpisode()!= nullptr);\n\tauto *walker = controller.GetWalker();\n\tassert(walker!= nullptr);\n\tauto *nav = controller.GetEpisode()->CreateNavigationIfMissing();\n\tassert(nav!= nullptr);\n\tnav->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 53.37489700878733}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tstd::shared_ptr<Walker> walker = _episode->GetWalker(controller.GetDisplayId());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found.\");\n\t}\n\tassert(_episode!= nullptr);\n\tif (_episode->GetNavigation() == nullptr) {\n\t\t_episode->CreateNavigationIfMissing();\n\t}\n\twalker->RegisterAIController(controller);\n}", "CodeBleu_score": 55.398521513668356}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tauto result = _episode->SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n\tif (result->GetStatus() == rpc::Status::kSuccess) {\n\t\tlog_debug(\"Spawned actor with id %d\", result->GetDisplayId());\n\t}\n\treturn result;\n}", "CodeBleu_score": 31.100553925383466}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tauto result = MakeActorDescription(blueprint, transform, parent, attachment_type, socket_name);\n\tif (result.has_value()) {\n\t\tauto actor = _client.SpawnActor(result.value());\n\t\tif (actor!= nullptr) {\n\t\t\t_episode->RegisterActor(actor);\n\t\t\tactor->ApplyGarbageCollectionPolicy(gc);\n\t\t\tlog_debug(\"Spawned actor {} with id {} and blueprint {}\", actor->GetBlueprintId(), actor->GetId(), blueprint.GetDescription());\n\t\t\treturn actor;\n\t\t}\n\t}\n\treturn nullptr;\n}", "CodeBleu_score": 42.383929054234315}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\t// Create the actor description.\n\tActorDescription desc = blueprint.MakeActorDescription(transform, parent, attachment_type, socket_name);\n\t// Spawn the actor.\n\tSharedPtr<Actor> result = _client.SpawnActor(desc);\n\t// Register the actor in the current episode.\n\t_episode->RegisterActor(result.get());\n\t// Apply the garbage collection policy.\n\tresult->ApplyGarbageCollectionPolicy(gc);\n\t// Log the creation details.\n\tlog_debug(\"Spawned actor '%s' with id '%d'.\", result->GetName().c_str(), result->GetId());\n\t// Return the actor.\n\treturn result;\n}", "CodeBleu_score": 35.51874241438439}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\t// Make sure the episode is valid\n\tDEBUG_ASSERT(episode_\n\t.TryLock\n\t)\n\t// Subscribe to the sensor's data stream using the client's SubscribeToStream method\n\tsensor_client.SubscribeToStream(sensor.GetActorDescription().GetStreamToken(),\n\t[\n\tthis\n\t,\n\tcallback\n\t]\n\t(\n\tSharedPtr<sensor::SensorData> sensor_data\n\t)\n\t{\n\t// Deserialize the incoming data\n\tSharedPtr<sensor::SensorData> sensor_data_copy\n\t=\n\tstd::move\n\t(\n\tsensor\n\t.Deserializer\n\t(\n\tsensor_data\n\t)\n\t)\n\t;\n\t// Associate the data with the current episode\n\tsensor_data_copy\n\t.\n\tTryLock\n\t(\n\t)\n\t;\n\t// Invoke the provided callback with the sensor data\n\tcallback\n\t(\n\tsensor_data_copy\n\t)\n\t;\n\t}\n\t)\n\t;\n}", "CodeBleu_score": 35.55831701071344}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#if!defined(NDEBUG)\n    DEBUG_ASSERT(sensor.GetActorDescription().GetStreamToken().has_value());\n#endif\n    auto &client = *m_client;\n    auto &ep = *m_current_episode;\n    auto &sensor_data = ep.GetSensorData(sensor);\n    auto cb = [this, sensor, sensor_data, callback = std::move(callback)](\n                  SharedPtr<sensor::SensorData> data) mutable {\n      sensor_data.Deserialize(data);\n      callback(sensor_data);\n    };\n    ep.TryLock();\n    client.SubscribeToStream(sensor.GetActorDescription().GetStreamToken().value(), std::move(cb));\n}", "CodeBleu_score": 50.40701592844383}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\tDEBUG_ASSERT(sensor.GetEpisode()\n\t.IsValid());\n\tauto client = sensor.GetClient();\n\tauto stream_token = sensor.GetActorDescription().GetStreamToken();\n\tauto cb = [this, callback](const sensor::SensorData &sensor_data) {\n\t\tauto ep = sensor.GetEpisode();\n\t\tauto data = sensor::Deserializer::Deserialize(sensor_data);\n\t\tcallback(data);\n\t};\n\tclient->SubscribeToStream(stream_token, std::move(cb));\n}", "CodeBleu_score": 48.92187710659465}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = _simulator.lock()->GetWalkers();\n\tif (walkers->size() == 0) {\n\t\treturn;\n\t}\n\tauto state = episode->GetState();\n\tfor (auto walker : *walkers) {\n\t\tif (!CheckIfWalkerExist(walker)) {\n\t\t\t_nav.RemoveAgent(walker);\n\t\t\t_simulator.lock()->DestroyActor(walker);\n\t\t\tcontinue;\n\t\t}\n\t\tauto transform = _nav.GetWalkerTransform(walker);\n\t\tauto speed = _nav.GetWalkerSpeed(walker);\n\t\t_simulator.lock()->SetActorCollisions(walker, state->GetCollisions());\n\t\t_simulator.lock()->SetActorDead(walker, state->GetDead());\n\t\t_nav.UpdateCrowd(walker, transform, speed);\n\t}\n\t_simulator.lock()->ApplyBatchSync();\n\tfor (auto walker : *walkers) {\n\t\tif (_nav.IsWalkerAlive(walker)) {\n\t\t\tcontinue;\n\t\t}\n\t\t_nav.RemoveAgent(walker);\n\t\t_simulator.lock()->DestroyActor(walker);\n\t}\n}", "CodeBleu_score": 39.727960486387346}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = _simulator.lock()->GetWalkers();\n\tif (walkers->empty()) {\n\t\treturn;\n\t}\n\n\tauto state = episode->GetState();\n\tauto walker_ids = state->GetWalkerIds();\n\tauto walkers_to_remove = std::vector<int>();\n\tfor (auto walker_id : walker_ids) {\n\t\tif (!CheckIfWalkerExist(walker_id)) {\n\t\t\twalkers_to_remove.push_back(walker_id);\n\t\t}\n\t}\n\tfor (auto walker_id : walkers_to_remove) {\n\t\tUnregisterWalker(walker_id);\n\t}\n\n\tUpdateVehiclesInCrowd();\n\t_nav.UpdateCrowd();\n\n\tauto walkers_to_update = std::vector<int>();\n\tfor (auto walker_id : walker_ids) {\n\t\tauto walker = _simulator.lock()->GetWalker(walker_id);\n\t\tauto walker_transform = walker->GetTransform();\n\t\tauto walker_speed = walker->GetSpeed();\n\t\tauto batch_command = BatchCommand();\n\t\tbatch_command.AddCommand(walker_id, walker_transform);\n\t\tbatch_command.AddCommand(walker_id, walker_speed);\n\t\tcommands.emplace_back(std::move(batch_command));\n\t\twalkers_to_update.push_back(walker_id);\n\t}\n\t_simulator.lock()->ApplyBatchSync(commands);\n\tcommands.clear();\n\n\tauto walkers_to_destroy = std::vector<int>();\n\tfor (auto walker_id : walker_ids) {\n\t\tauto walker = _simulator.lock()->GetWalker(walker_id);\n\t\tif (!walker->IsAlive()) {\n\t\t\twalkers_to_destroy.push_back(walker_id);\n\t\t}\n\t}\n\tfor (auto walker_id : walkers_to_destroy) {\n\t\tUnregisterWalker(walker_id);\n\t\t_simulator.lock()->DestroyActor(walker_id);\n\t}\n}", "CodeBleu_score": 39.38608900797054}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = _simulator.lock()->GetWalkers();\n\tif (walkers->empty()) {\n\t\treturn;\n\t}\n\n\tauto state = episode->GetState();\n\tfor (auto walker : *walkers) {\n\t\tif (!CheckIfWalkerExist(walker)) {\n\t\t\t_nav.RemoveAgent(walker);\n\t\t\t_simulator.lock()->DestroyActor(walker);\n\t\t}\n\t}\n\n\t_nav.UpdateCrowd(state);\n\t_nav.UpdateVehiclesInCrowd(state);\n\n\tfor (auto walker : *walkers) {\n\t\tauto transform = _nav.GetWalkerTransform(walker);\n\t\tauto speed = _nav.GetWalkerSpeed(walker);\n\n\t\t_simulator.lock()->ApplyBatchSync(transform, speed, walker);\n\n\t\tif (_nav.IsWalkerAlive(walker)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t_nav.RemoveAgent(walker);\n\t\t_simulator.lock()->DestroyActor(walker);\n\t}\n}", "CodeBleu_score": 38.88265314619998}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\tdescription.attributes.reserve(attributes.size());\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(*attribute);\n\t}\n\treturn description;\n}", "CodeBleu_score": 65.88150300347931}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(this->UID);\n\tdescription.set_id(this->ID);\n\tdescription.attributes.reserve(this->attributes.size());\n\tfor (auto& attribute : this->attributes) {\n\t\trpc::ActorAttribute* attribute_rpc = description.add_attributes();\n\t\tattribute_rpc->set_name(attribute.name);\n\t\tattribute_rpc->set_type(attribute.type);\n\t\tattribute_rpc->set_value(attribute.value);\n\t}\n\treturn description;\n}", "CodeBleu_score": 54.397706327530194}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_id(this->id);\n\tdescription.set_uid(this->uid);\n\tdescription.attributes.reserve(this->attributes.size());\n\tfor (auto attribute : this->attributes) {\n\t\tdescription.attributes.push_back(attribute.MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 61.04253015637558}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\tfor (auto pair : blueprints) {\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\tif (pair.second.GetAttribute(name) == value || pair.second.GetRecommendedValues(name).Contains(value)) {\n\t\t\t\tresult->blueprints.emplace(pair.first, pair.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 37.00450126585122}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n\tfor (const auto& pair : blueprints) {\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\tif (pair.second.GetValue(name) == value ||\n\t\t\t\tpair.second.GetRecommendedValues(name).Contains(value)) {\n\t\t\t\tresult->AddBlueprint(pair.first, pair.second);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 34.89185104841359}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto& pair : blueprints) {\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\tif (pair.second.GetValue(name) == value || pair.second.GetRecommendedValues(name).Contains(value)) {\n\t\t\t\tresult->AddBlueprint(pair.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 34.22441490508467}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = path + \"/\" + version + \"/\";\n\tcarla::FileSystem::ValidateFilePath(full_path);\n\tstd::ofstream out(full_path + path, std::ios::binary);\n\tif (out.good()) {\n\t\tout.write((char*)content.data(), content.size());\n\t\tout.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 44.793261672544126}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = this->base_folder + path;\n\tif (!carla::FileSystem::ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream out(full_path, std::ios::binary);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<const char*>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 42.810321039160236}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = this->GetFullPath(path);\n\tif (!carla::FileSystem::ValidateFilePath(fullPath)) {\n\t\treturn false;\n\t}\n\n\tstd::ofstream out(fullPath, std::ios::binary | std::ios::trunc);\n\tif (!out.is_open()) {\n\t\treturn false;\n\t}\n\n\tout.write(reinterpret_cast<char*>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 46.47975115574481}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\t// Create a shared pointer to a Bounds object.\n\tstd::shared_ptr<const Bounds> bounds = std::make_shared<Bounds>();\n\n\t// Set the frame number.\n\tbounds->frame = frame;\n\n\t// Get the parent's bounding box location.\n\tgeom::Location parentLocation = parent_->GetBoundingBox().GetLocation();\n\n\t// Add the parent's bounding box location to the transform's location.\n\tgeom::Location location = parentLocation + transform.GetLocation();\n\n\t// Compute the four corners of the bounding box.\n\tgeom::Location corner0 = location + transform.GetYaw() * parent_->GetBoundingBox().GetExtents();\n\tgeom::Location corner1 = location - transform.GetYaw() * parent_->GetBoundingBox().GetExtents();\n\tgeom::Location corner2 = location - transform.GetYaw() * parent_->GetBoundingBox().GetExtents() + transform.GetYaw() * parent_->GetBoundingBox().GetExtents();\n\tgeom::Location corner3 = location + transform.GetYaw() * parent_->GetBoundingBox().GetExtents() + transform.GetYaw() * parent_->GetBoundingBox().GetExtents();\n\n\t// Set the corners.\n\tbounds->corners = { corner0, corner1, corner2, corner3 };\n\n\t// Return the shared pointer to the Bounds object.\n\treturn bounds;\n}", "CodeBleu_score": 34.99028627879229}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t//    std::cout << \"MakeBounds\" << std::endl;\n//    std::cout << \"frame: \" << frame << std::endl;\n//    std::cout << \"transform: \" << transform << std::endl;\n    // Calculate the location of the bounding box by adding the parent's bounding box location to the transform's location.\n    geom::Location location = transform.location() + parent_->bounds_.location();\n\n    // Calculate the four corners of the bounding box by rotating the extents based on the yaw angle.\n    geom::Extent extents = parent_->bounds_.extents();\n    const double yaw = transform.rotation().yaw();\n    const double cos_yaw = std::cos(yaw);\n    const double sin_yaw = std::sin(yaw);\n    const double x1 = cos_yaw * extents.x() - sin_yaw * extents.y();\n    const double y1 = sin_yaw * extents.x() + cos_yaw * extents.y();\n    const double x2 = cos_yaw * extents.x() + sin_yaw * extents.y();\n    const double y2 = -sin_yaw * extents.x() + cos_yaw * extents.y();\n    const double x3 = cos_yaw * extents.z() - sin_yaw * extents.w();\n    const double y3 = sin_yaw * extents.z() + cos_yaw * extents.w();\n    const double x4 = cos_yaw * extents.z() + sin_yaw * extents.w();\n    const double y4 = -sin_yaw * extents.z() + cos_yaw * extents.w();\n\n    // Create a new Bounds object with the calculated corners.\n    return std::make_shared<Bounds>(frame, location, x1, y1, x2, y2, x3, y3, x4, y4);\n}", "CodeBleu_score": 38.664302883973775}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\t// Create a bounding box based on the transform's location and the parent's bounding box extents.\n\tconst auto &parent_extents = parent_->GetExtents();\n\tconst auto &parent_location = parent_->GetLocation();\n\tconst auto &yaw_angle = transform.GetYaw();\n\tconst auto &location = transform.GetLocation();\n\tconst auto &extents = parent_extents.GetExtents();\n\tconst auto &size = parent_extents.GetSize();\n\tconst auto &half_size = size / 2;\n\tconst auto &half_extents = extents / 2;\n\tconst auto &min = parent_location + location - half_extents;\n\tconst auto &max = parent_location + location + half_extents;\n\tconst auto &corners = {\n\t\tmin + geom::Vector3(half_size.x, half_size.y, half_size.z),\n\t\tmin + geom::Vector3(half_size.x, -half_size.y, half_size.z),\n\t\tmin + geom::Vector3(-half_size.x, half_size.y, half_size.z),\n\t\tmin + geom::Vector3(-half_size.x, -half_size.y, half_size.z),\n\t\tmin + geom::Vector3(half_size.x, half_size.y, -half_size.z),\n\t\tmin + geom::Vector3(half_size.x, -half_size.y, -half_size.z),\n\t\tmin + geom::Vector3(-half_size.x, half_size.y, -half_size.z),\n\t\tmin + geom::Vector3(-half_size.x, -half_size.y, -half_size.z)\n\t};\n\t// Rotate the corners based on the yaw angle.\n\tfor (auto &corner : corners) {\n\t\tcorner = geom::Rotate(corner, yaw_angle);\n\t}\n\t// Create a shared pointer to a Bounds object containing the frame number and the corners.\n\treturn std::make_shared<Bounds>(frame, corners);\n}", "CodeBleu_score": 30.916027270773295}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::unique_lock<std::mutex> lock(_episode.Lock()->GetLightManager()->_lights_mutex);\n\t_episode.Lock()->QueryLightsStateToServer();\n\tfor (auto& light : _episode.Lock()->GetLightManager()->_lights) {\n\t\tif (light.second->_state == LightState::LightGroup::OFF) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (light.second->_state == LightState::LightGroup::ON) {\n\t\t\tlight.second->_state = LightState::LightGroup::ON;\n\t\t}\n\t\telse if (light.second->_state == LightState::LightGroup::TOGGLE) {\n\t\t\tlight.second->_state = LightState::LightGroup::TOGGLE;\n\t\t}\n\t\telse if (light.second->_state == LightState::LightGroup::FADE_ON) {\n\t\t\tlight.second->_state = LightState::LightGroup::FADE_ON;\n\t\t}\n\t\telse if (light.second->_state == LightState::LightGroup::FADE_OFF) {\n\t\t\tlight.second->_state = LightState::LightGroup::FADE_OFF;\n\t\t}\n\t\telse if (light.second->_state == LightState::LightGroup::FADE_TOGGLE) {\n\t\t\tlight.second->_state = LightState::LightGroup::FADE_TOGGLE;\n\t\t}\n\t\telse {\n\t\t\tlight.second->_state = LightState::LightGroup::OFF;\n\t\t}\n\t}\n}", "CodeBleu_score": 35.2314046682444}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// lock the mutex\n\tstd::lock_guard<std::mutex> lock(_episode.Lock()->GetLightManager()->_mutex);\n\n\t// get the light states from the server\n\tstd::vector<LightState> lightStates = _episode.Lock()->QueryLightsStateToServer();\n\n\t// update the light states\n\tfor (LightState lightState : lightStates) {\n\t\t// check if the light exists\n\t\tif (_lights.find(lightState.GetLightId()) == _lights.end()) {\n\t\t\t// create a new light object\n\t\t\tLight* light = new Light(lightState);\n\t\t\t_lights.insert(std::pair<int, Light*>(lightState.GetLightId(), light));\n\t\t}\n\t\t// update the light state\n\t\t_lights[lightState.GetLightId()]->Update(lightState);\n\t}\n}", "CodeBleu_score": 40.13030139958329}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::unique_lock<std::mutex> lock(_episode.Lock()->GetLightManager()->_mutex);\n\t_episode.Lock()->GetLightManager()->_lights.clear();\n\tstd::vector<LightState> lightStates = _episode.Lock()->QueryLightsStateToServer();\n\tfor (const LightState& lightState : lightStates) {\n\t\tif (_episode.Lock()->GetLightManager()->_lights.find(lightState.GetLightId()) == _episode.Lock()->GetLightManager()->_lights.end()) {\n\t\t\t_episode.Lock()->GetLightManager()->_lights.insert(std::pair<LightId, Light*>(lightState.GetLightId(), new Light(lightState)));\n\t\t}\n\t}\n}", "CodeBleu_score": 35.10716339279058}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_episode.Lock());\n\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\n\tstd::vector<rpc::Color> message;\n\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); ++it_light) {\n\t\tif (discard_client || _episode.GetLocation().GetLightState(it_light->first)) {\n\t\t\tmessage.push_back(it_light->second.GetLocation());\n\t\t}\n\t}\n\t_episode.Lock()->UpdateServerLightsState(message);\n\t_lights_changes.clear();\n\t_dirty = false;\n}", "CodeBleu_score": 42.681719524676446}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_episode.Lock());\n\n\tif (!_lights_changes.empty()) {\n\t\trpc::Message message;\n\t\tmessage.set_type(rpc::Message::LIGHTS_UPDATE);\n\n\t\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); it_light++) {\n\t\t\trpc::Color* color = message.add_light_states();\n\t\t\tcolor->set_r(it_light->second.GetColor().r);\n\t\t\tcolor->set_g(it_light->second.GetColor().g);\n\t\t\tcolor->set_b(it_light->second.GetColor().b);\n\t\t\tcolor->set_a(it_light->second.GetColor().a);\n\t\t\tcolor->set_name(it_light->second.GetName());\n\t\t}\n\n\t\t_episode.Lock()->UpdateServerLightsState(message, discard_client);\n\n\t\t_lights_changes.clear();\n\t\t_dirty = false;\n\t}\n}", "CodeBleu_score": 49.59436859635969}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_episode.Lock());\n\tif (_lights_changes.size() == 0) {\n\t\treturn;\n\t}\n\tstd::vector<rpc::Color> message;\n\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); ++it_light) {\n\t\tif (_lights_changes.find(it_light->first)!= _lights_changes.end()) {\n\t\t\tmessage.push_back(it_light->second.GetLocation());\n\t\t}\n\t}\n\trpc::ColorMessage color_message;\n\tcolor_message.set_message(message);\n\t_episode.Lock()->UpdateServerLightsState(color_message, discard_client);\n\t_lights_changes.clear();\n\t_lights_dirty = false;\n}", "CodeBleu_score": 46.83261487176353}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tGetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 35.99390718428421}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetID()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send: Sensor ID does not match sensor.other.v2x_custom\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 51.96505190187004}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetID()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"This sensor does not have the ID sensor.other.v2x_custom, so it cannot send a message to the episode.\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(message, GetContext());\n}", "CodeBleu_score": 53.94959238007575}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(this);\n\t} else {\n\t\ttm.UnregisterVehicles(this);\n\t}\n}", "CodeBleu_score": 32.64858071138209}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tif (m_tm_port!= tm_port) {\n\t\t\tm_tm_port = tm_port;\n\t\t\tm_tm.RegisterVehicles(this);\n\t\t}\n\t} else {\n\t\tm_tm.UnregisterVehicles(this);\n\t}\n}", "CodeBleu_score": 47.56735986676087}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(shared_from_this());\n\t} else {\n\t\ttm.UnregisterVehicles(shared_from_this());\n\t}\n}", "CodeBleu_score": 48.2133010300425}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\t// Get the walker actor from the episode.\n\twalker = GetEpisode().Lock()->GetWalker();\n\t// Add the walker to the navigation system.\n\tGetEpisode().Lock()->GetNavigation()->AddActor(walker);\n\t// Disable physics simulation and collisions for the walker.\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n}", "CodeBleu_score": 37.75299960314919}, {"code": "void WalkerAIController::Start(){\n\t\twalker = GetActor();\n\twalker->SetActorLocation(GetLocation());\n\tGetEpisode().Lock()->GetNavigation()->AddAgent(walker);\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n}", "CodeBleu_score": 37.65134837699272}, {"code": "void WalkerAIController::Start(){\n\t\twalker = GetOwner();\n\tGetEpisode().Lock()->RegisterAIController(this);\n\tGetEpisode().Lock()->GetNavigation().Lock()->AddActorToNavigation(walker, walker->GetLocation());\n\twalker->GetCollisionComponent()->SetSimulatePhysics(false);\n\twalker->GetCollisionComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}", "CodeBleu_score": 38.239077211079895}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto nav = GetEpisode().Lock()->GetNavigation();\n\tif (nav.IsValid()) {\n\t\tauto walker = GetParent().Lock();\n\t\tif (walker.IsValid()) {\n\t\t\twalker->GetNavigation().SetWalkerMaxSpeed(max_speed);\n\t\t} else {\n\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Could not find walker!\");\n\t\t}\n\t} else {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Could not find navigation!\");\n\t}\n}", "CodeBleu_score": 57.39197132515724}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (GetEpisode().IsValid()) {\n\t\tauto nav = GetEpisode().Lock()->GetNavigation();\n\t\tif (nav.IsValid()) {\n\t\t\tauto walker = GetParent();\n\t\t\tif (walker.IsValid()) {\n\t\t\t\twalker->SetMaxSpeed(nav->SetWalkerMaxSpeed(max_speed));\n\t\t\t} else {\n\t\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Could not retrieve parent walker\");\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Could not retrieve navigation\");\n\t\t}\n\t} else {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Could not retrieve episode\");\n\t}\n}", "CodeBleu_score": 54.5362311428766}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (GetEpisode() == nullptr) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: WalkerAIController does not have a valid episode.\");\n\t\treturn;\n\t}\n\tauto nav = GetEpisode()->GetNavigation();\n\tif (nav == nullptr) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: WalkerAIController does not have a valid navigation.\");\n\t\treturn;\n\t}\n\tauto walker = GetParent();\n\tif (walker == nullptr) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: WalkerAIController does not have a valid walker.\");\n\t\treturn;\n\t}\n\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to set walker maximum speed.\");\n\t}\n}", "CodeBleu_score": 53.487435709465515}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(_parent->GetMap().GetPrevious(distance));\n\tfor (const auto& waypoint : _parent->GetMap().GetPrevious(distance)) {\n\t\tresult.emplace_back(new Waypoint(waypoint));\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.90567766003428}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<Waypoint> previous = _parent->GetMap().GetPrevious(distance);\n\tfor (auto& waypoint : previous) {\n\t\tresult.emplace_back(std::make_shared<Waypoint>(waypoint));\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.98773647577488}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(_parent->GetMap().GetPrevious(distance));\n\tfor (auto& waypoint : _parent->GetMap().GetPrevious(distance)) {\n\t\tresult.emplace_back(std::make_shared<Waypoint>(_parent, waypoint->GetPosition()));\n\t}\n\treturn result;\n}", "CodeBleu_score": 54.45508771629276}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\tstd::set<SharedPtr<Signal>> added_signals;\n\n\tfor (SharedPtr<Signal> signal : signals) {\n\t\tif (added_signals.count(signal) == 0) {\n\t\t\tSharedPtr<Landmark> landmark = signal->GetLandmark();\n\t\t\tif (landmark!= nullptr) {\n\t\t\t\tresult.emplace_back(landmark);\n\t\t\t\tadded_signals.insert(signal);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 38.052007883655854}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::set<SharedPtr<Signal>> added_signals;\n\tfor (SharedPtr<Signal> signal : GetSignalsInDistance(distance)) {\n\t\tif (added_signals.count(signal) == 0) {\n\t\t\tSharedPtr<Landmark> landmark = signal->GetLandmark();\n\t\t\tif (landmark!= nullptr) {\n\t\t\t\tresult.emplace_back(landmark);\n\t\t\t}\n\t\t\tadded_signals.insert(signal);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 34.25084157362837}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\nstd::vector<SharedPtr<Landmark>> result;\n\nstd::unordered_set<SharedPtr<Landmark>> added_landmarks;\n\nfor (SharedPtr<Landmark> landmark : GetSignalsInDistance(distance, stop_at_junction)) {\nif (added_landmarks.count(landmark) == 0) {\nresult.emplace_back(landmark);\nadded_landmarks.insert(landmark);\n}\n}\n\nreturn result;\n}", "CodeBleu_score": 31.375580871067477}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\t_episode.Lock()->SetEpisodeSettings(settings);\n\ttimeout = std::max(timeout, _episode.Lock()->GetNetworkingTimeout());\n\tif (settings.fixed_delta_seconds.has_value()) {\n\t\tfloat fixed_delta_seconds = settings.fixed_delta_seconds.get();\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t_episode.Lock()->SetFixedDeltaSeconds(fixed_delta_seconds);\n\t\t\t_episode.Lock()->SetTimestamp(0.0f);\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t_episode.Lock()->Tick();\n\t\t\t}\n\t\t\tfloat delta_seconds = _episode.Lock()->GetDeltaSeconds();\n\t\t\tfloat error = abs(delta_seconds - fixed_delta_seconds);\n\t\t\tif (error < std::numeric_limits<float>::epsilon) {\n\t\t\t\treturn _episode.Lock()->GetIdentifier();\n\t\t\t}\n\t\t}\n\t\tlog_warning(\"Failed to set fixed delta time to {} in {} attempts\", fixed_delta_seconds, 10);\n\t}\n\treturn _episode.Lock()->GetIdentifier();\n}", "CodeBleu_score": 43.37379520529918}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tauto new_settings = settings;\n\tif (settings.fixed_delta_seconds.has_value()) {\n\t\tauto fixed_delta_seconds = settings.fixed_delta_seconds.value();\n\t\tauto curr_snapshot = GetSnapshot();\n\t\tauto curr_timestamp = curr_snapshot.GetTimestamp();\n\t\tauto curr_delta_seconds = curr_timestamp.time_since_epoch().count() / 1000000000.0;\n\t\tauto delta_seconds = fixed_delta_seconds - curr_delta_seconds;\n\t\tif (delta_seconds > std::numeric_limits<float>::epsilon) {\n\t\t\tlog_warning(\"Failed to apply fixed delta seconds of {}. The current delta is {}. The current timestamp is {}. The current time is {}. The current snapshot is {}.\", fixed_delta_seconds, curr_delta_seconds, curr_timestamp, curr_timestamp.time_since_epoch().count() / 1000000000.0, curr_snapshot);\n\t\t\treturn 0;\n\t\t}\n\t\tnew_settings.fixed_delta_seconds = fixed_delta_seconds;\n\t}\n\tauto settings_id = _episode.Lock()->ApplySettings(new_settings);\n\t_episode.Lock()->SetNetworkingTimeout(timeout);\n\treturn settings_id;\n}", "CodeBleu_score": 51.715296507670786}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tEpisodeSettings new_settings = settings;\n\tif (settings.fixed_delta_seconds.has_value()) {\n\t\tif (settings.fixed_delta_seconds.value() <= 0.0f) {\n\t\t\tlog_warning(\"Fixed delta time must be greater than 0.0f\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (settings.fixed_delta_seconds.value() < std::numeric_limits<float>::epsilon) {\n\t\t\tlog_warning(\"Fixed delta time must be greater than the smallest possible value\");\n\t\t\treturn 0;\n\t\t}\n\t\tnew_settings.fixed_delta_seconds.value() = std::max(new_settings.fixed_delta_seconds.value(), std::numeric_limits<float>::epsilon);\n\t}\n\tEpisodeSettings old_settings = _episode.Lock()->GetEpisodeSettings();\n\t_episode.Lock()->SetEpisodeSettings(new_settings);\n\tif (new_settings.fixed_delta_seconds.has_value()) {\n\t\tconst int num_ticks = 10;\n\t\tfloat time_diff = 0.0f;\n\t\tfloat time_sum = 0.0f;\n\t\tfloat time_avg = 0.0f;\n\t\tfloat time_min = std::numeric_limits<float>::max();\n\t\tfloat time_max = std::numeric_limits<float>::min();\n\t\tfor (int i = 0; i < num_ticks; i++) {\n\t\t\tauto start_time = std::chrono::steady_clock::now();\n\t\t\tTick();\n\t\t\tauto end_time = std::chrono::steady_clock::now();\n\t\t\tauto time_diff_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end_time - start_time).count();\n\t\t\ttime_diff = static_cast<float>(time_diff_ns) / 1000000.0f;\n\t\t\ttime_sum += time_diff;\n\t\t\ttime_avg = time_sum / static_cast<float>(i + 1);\n\t\t\ttime_min = std::min(time_min, time_diff);\n\t\t\ttime_max = std::max(time_max, time_diff);\n\t\t}\n\t\tif (time_avg < new", "CodeBleu_score": 48.98341041075067}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat distanceSquared = DistanceSquared2D(segment.p1, segment.p2);\n\tfloat distance = distanceSquared > 0.0f? std::sqrt(distanceSquared) : 0.0f;\n\tfloat projection = Dot2D(segment.p2 - segment.p1, point - segment.p1);\n\n\tif (projection < 0.0f) {\n\t\treturn std::make_pair(distance, Distance2D(point, segment.p1));\n\t}\n\telse if (projection > distanceSquared) {\n\t\treturn std::make_pair(distance, Distance2D(point, segment.p2));\n\t}\n\telse {\n\t\treturn std::make_pair(distance, std::sqrt(projection));\n\t}\n}", "CodeBleu_score": 36.48705025002396}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat distanceSquared;\n\tfloat distance;\n\tfloat clamped;\n\tfloat projection;\n\tfloat segmentLength;\n\tfloat segmentLengthSquared;\n\tfloat pointX;\n\tfloat pointY;\n\tfloat segmentStartX;\n\tfloat segmentStartY;\n\tfloat segmentEndX;\n\tfloat segmentEndY;\n\tfloat segmentDirectionX;\n\tfloat segmentDirectionY;\n\tfloat segmentDirectionLengthSquared;\n\tfloat segmentDirectionLength;\n\tfloat pointToSegmentStartX;\n\tfloat pointToSegmentStartY;\n\tfloat pointToSegmentEndX;\n\tfloat pointToSegmentEndY;\n\tfloat pointToSegmentStartLengthSquared;\n\tfloat pointToSegmentStartLength;\n\tfloat pointToSegmentEndLengthSquared;\n\tfloat pointToSegmentEndLength;\n\tfloat pointToSegmentStartLength;\n\tfloat pointToSegmentEndLength;\n\tfloat pointToSegmentStartLengthSquared;\n\tfloat pointToSegmentEndLengthSquared;\n\tfloat pointToSegmentStartLength;\n\tfloat pointToSegmentEndLength;\n\tfloat pointToSegmentStartLengthSquared;\n\tfloat pointToSegmentEndLengthSquared;\n\tfloat pointToSegmentStartLength;\n\tfloat pointToSegmentEndLength;\n\tfloat pointToSegmentStartLengthSquared;\n\tfloat pointToSegmentEndLengthSquared;\n\tfloat pointToSegmentStartLength;\n\tfloat pointToSegmentEndLength;\n\tfloat pointToSegmentStartLengthSquared;\n\tfloat pointToSegmentEndLengthSquared;\n\tfloat pointToSegmentStartLength;\n\tfloat pointToSegmentEndLength;\n\tfloat pointToSegmentStartLengthSquared;\n\tfloat pointToSegmentEndLengthSquared;\n\tfloat pointToSegmentStartLength;\n\tfloat pointToSegmentEndLength;\n\tfloat pointToSegmentStartLengthSquared;\n\tfloat pointToSegmentEndLengthSquared;\n\tfloat pointToSegmentStartLength;\n\tfloat pointToSegmentEndLength;\n\tfloat pointToSegmentStartLengthSquared;\n\tfloat pointToSegmentEndLengthSquared;\n\tfloat pointToSegmentStartLength;\n\tfloat pointToSegmentEndLength;\n\tfloat pointToSegmentStartLengthSquared;\n\tfloat pointToSegmentEndLengthSquared;\n\tfloat pointToSegmentStartLength;\n\tfloat pointToSegmentEndLength;\n\tfloat pointToSegmentStartLengthSquared;\n\tfloat", "CodeBleu_score": 19.41575061845045}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat DistanceSquared2D(float x1, float y1, float x2, float y2) {\n\t\treturn std::sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\t}\n\n\tfloat Distance2D(float x1, float y1, float x2, float y2) {\n\t\treturn std::sqrt(DistanceSquared2D(x1, y1, x2, y2));\n\t}\n\n\tfloat DistanceSegmentToPoint(float x1, float y1, float x2, float y2, float x, float y) {\n\t\tfloat distanceSquared = DistanceSquared2D(x1, y1, x2, y2);\n\t\tfloat distance = Distance2D(x1, y1, x2, y2);\n\t\tif (distanceSquared == 0.0f)\n\t\t\treturn std::make_pair(distance, std::abs(x - x1));\n\t\tfloat t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / distanceSquared;\n\t\tif (t < 0.0f)\n\t\t\treturn std::make_pair(distance, std::abs(x - x1));\n\t\tif (t > 1.0f)\n\t\t\treturn std::make_pair(distance, std::abs(x - x2));\n\t\treturn std::make_pair(distance * t, std::abs(x - (x1 + t * (x2 - x1))));\n\t}\n}", "CodeBleu_score": 34.491459652230446}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t DEBUG_ASSERT\n(vertices\n.size\n(\n)\n>\n2\n)\n;\nunsigned int initial_index\n=\nAddVertices\n(\nvertices\n)\n;\nfor\n(\nunsigned int i\n=\n1\n;\ni\n<\nvertices\n.size\n(\n)\n-\n1\n;\ni\n+\n+\n)\n{\nAddIndex\n(\ninitial_index\n+\ni\ninitial_index\n+\ni\n+\n1\ninitial_index\n)\n;\n}\n}", "CodeBleu_score": 35.5070513494201}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t DEBUG_ASSERT", "CodeBleu_score": 5.802778789482653}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tDEBUG_ASSERT\n(\nvertices\n.\nsize\n(\n)\n>\n2\n)\n;\nconst\nsize_t\ninitial_index\n=\nm_indices\n.\nsize\n(\n)\n;\nDEBUG_ASSERT\n(\ninitial_index\n<\nstd\n:\n:\nnumeric_limits\n<\nsize_t\n>\n:\n:\nmax\n(\n)\n)\n;\nfor\n(\nsize_t\ni\n=\n0\n;\ni\n<\nvertices\n.\nsize\n(\n)\n-\n2\n;\n+\n+\ni\n)\n{\nm_indices\n.\npush_back\n(\nvertices\n[\n0\n]\n.\nindex\n)\n;\nm_indices\n.\npush_back\n(\nvertices\n[\ni\n+\n1\n]\n.\nindex\n)\n;\nm_indices\n.\npush_back\n(\nvertices\n[\ni\n+\n2\n]\n.\nindex\n)\n;\n}\n}", "CodeBleu_score": 43.969110327467035}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tDEBUG_ASSERT(message);\n\tDEBUG_ASSERT(message->empty());\n\tauto self = shared_from_this();\n\tboost::asio::post(\n\t\tself->_strand,\n\t\t[self, message] {\n\t\t\tif (!self->_socket.is_open()) {\n\t\t\t\tlog_error(\"Socket is closed, cannot write message.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tself->_deadline.expires_from_now(boost::posix_time::seconds(self->_timeout));\n\t\t\tboost::asio::async_write(\n\t\t\t\tself->_socket,\n\t\t\t\tmessage->GetBufferSequence(),\n\t\t\t\t[self, message](boost::system::error_code ec, std::size_t) {\n\t\t\t\t\tself->handle_sent(ec, message);\n\t\t\t\t});\n\t\t});\n}", "CodeBleu_score": 35.29633198763095}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tDEBUG_ASSERT(message!= nullptr);\n\tDEBUG_ASSERT(message->IsValid());\n\tboost::asio::post(\n\t\t_strand,\n\t\t[self = shared_from_this(), message]() {\n\t\t\tself->HandleWrite(message);\n\t\t}\n\t);\n}", "CodeBleu_score": 18.871267660819978}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tDEBUG_ASSERT(message);\n\tDEBUG_ASSERT(message->IsValid());\n\n\tboost::asio::post(\n\t\t_strand,\n\t\t[this, message]() {\n\t\t\tDEBUG_ASSERT(message);\n\t\t\tDEBUG_ASSERT(message->IsValid());\n\n\t\t\tif (!_socket.is_open()) {\n\t\t\t\tlog_error(\"Write: socket is not open\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_deadline.expires_from_now(boost::posix_time::seconds(30));\n\n\t\t\tboost::asio::async_write(\n\t\t\t\t_socket,\n\t\t\t\tmessage->GetBufferSequence(),\n\t\t\t\tboost::asio::bind_executor(\n\t\t\t\t\t_strand,\n\t\t\t\t\t[this, message](const boost::system::error_code& ec, std::size_t bytes_transferred) {\n\t\t\t\t\t\tDEBUG_ASSERT(message);\n\t\t\t\t\t\tDEBUG_ASSERT(message->IsValid());\n\n\t\t\t\t\t\tif (ec) {\n\t\t\t\t\t\t\tlog_error(\"Write: failed to write message: \", ec.message());\n\t\t\t\t\t\t\tCloseNow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDEBUG_ASSERT(bytes_transferred == message->GetSize());\n\t\t\t\t\t\t\tDEBUG_ASSERT(bytes_transferred == message->GetBufferSequence().size());\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t});\n}", "CodeBleu_score": 38.904712902456076}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!_socket.is_open()) {\n\t\tlog_debug(\"socket is not open, nothing to do\");\n\t\treturn;\n\t}\n\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\tif (ec) {\n\t\tlog_debug(\"shutdown failed: %s\", ec.message().c_str());\n\t\treturn;\n\t}\n\t_socket.close(ec);\n\tif (ec) {\n\t\tlog_debug(\"close failed: %s\", ec.message().c_str());\n\t\treturn;\n\t}\n\t_on_closed(ec);\n\tlog_debug(\"session closed\");\n}", "CodeBleu_score": 51.42663136470313}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tlog_debug\n\t_deadline.cancel\n\tif (ec ||!_socket.is_open) {\n\t\t_on_closed(ec)\n\t} else {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec)\n\t\t_socket.close\n\t\t_on_closed(ec)\n\t}\n\tlog_debug\n}", "CodeBleu_score": 44.12934023830598}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tlog_debug << \"Closing socket \" << _socket.native();\n\t_deadline.cancel();\n\tif (ec == boost::asio::error::operation_aborted) {\n\t\treturn;\n\t}\n\tif (_socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t\t_socket.close();\n\t}\n\t_on_closed(ec);\n\tlog_debug << \"Socket \" << _socket.native() << \" closed.\";\n}", "CodeBleu_score": 50.66424885963614}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::string msg = \"Are you alive?\";\n\tstd::unique_ptr<char[]> buffer = std::make_unique<char[]>(msg.size() + 1);\n\tstd::memcpy(buffer.get(), msg.c_str(), msg.size() + 1);\n\tlog_info(\"Sending: %s\", msg.c_str());\n\t_router->WriteToNext(buffer.get(), msg.size(), YOU_ALIVE);\n\tlog_info(\"Waiting for response...\");\n\tstd::unique_ptr<char[]> response = std::make_unique<char[]>(MAX_MSG_SIZE);\n\tstd::size_t response_size = _router->ReadFromNext(response.get(), MAX_MSG_SIZE);\n\tlog_info(\"Received: %s\", response.get());\n}", "CodeBleu_score": 47.53347664318177}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar buffer[100];\n\tstrcpy(buffer, \"Are you alive?\");\n\tlog_info(LOG_INFO, \"Sending: %s\", buffer);\n\t_router->WriteToNext(std::string(buffer), YOU_ALIVE);\n\tlog_info(LOG_INFO, \"Waiting for response\");\n\tstd::future<std::string> fut = _router->ReadFromNext();\n\tlog_info(LOG_INFO, \"Response: %s\", fut.get().c_str());\n}", "CodeBleu_score": 48.90755132561366}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tchar* buffer = new char[msg.size() + 1];\n\tstrcpy(buffer, msg.c_str());\n\n\t// Log the sending action\n\tlog_info(\"Sending message: %s\", buffer);\n\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\n\t// Wait for and log the response from the system\n\tlog_info(\"Response: %s\", _router->ReadFromNext());\n}", "CodeBleu_score": 37.75353857870518}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tauto fut = _router->WriteToOne(sensor_id, ENABLE_ROS);\n\tauto response = fut.get();\n\tif (response.buffer.data[0] == 0) {\n\t\tlog_error(\"Sensor not found on any server\");\n\t\treturn;\n\t}\n\tlog_info(\"Enabled ROS for sensor %d on server %d\", sensor_id, response.buffer.data[0]);\n}", "CodeBleu_score": 33.099601681607886}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tif (auto server = _servers.find(sensor_id); server!= _servers.end()) {\n\t\tstd::vector<uint8_t> buffer;\n\t\tbuffer.push_back(sensor_id);\n\t\tbuffer.push_back(ENABLE_ROS);\n\t\tauto fut = _router->WriteToOne(server->second, std::move(buffer));\n\t\tauto response = fut.get();\n\t\tif (response.buffer.data[0] == 0x00) {\n\t\t\tlog_info(\"Sensor %d enabled on server %s\", sensor_id, server->second.c_str());\n\t\t} else {\n\t\t\tlog_error(\"Could not enable sensor %d on server %s\", sensor_id, server->second.c_str());\n\t\t}\n\t} else {\n\t\tlog_error(\"Could not find sensor %d\", sensor_id);\n\t}\n}", "CodeBleu_score": 52.09154962431711}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if the sensor is already enabled on any of the secondary servers\n\tfor (auto &server : _servers) {\n\t\tif (server.second->IsSensorEnabled(sensor_id)) {\n\t\t\t// Create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router\n\t\t\tstd::unique_ptr<std::vector<uint8_t>> buffer = std::make_unique<std::vector<uint8_t>>();\n\t\t\tbuffer->push_back(static_cast<uint8_t>(Command::ENABLE_ROS));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(sensor_id));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_back(static_cast<uint8_t>(0));\n\t\t\tbuffer->push_", "CodeBleu_score": 25.978460294070416}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tif (_tokens.find(sensor_id) == _tokens.end()) {\n\t\t// If the sensor is not activated, enable it on a secondary server\n\t\tlog_debug(\"Sensor \" << sensor_id << \" is not activated, enabling it on a secondary server.\");\n\t\tif (EnableSensor(sensor_id) == false) {\n\t\t\tlog_debug(\"Could not enable sensor \" << sensor_id << \" on a secondary server.\");\n\t\t\treturn token_type();\n\t\t}\n\n\t\t// Retrieve a new token\n\t\ttoken_type token = GetToken(sensor_id);\n\n\t\t// Update the maps\n\t\t_tokens[sensor_id] = token;\n\t\t_token_ids[token] = sensor_id;\n\n\t\t// Log the action\n\t\tlog_debug(\"Token for sensor \" << sensor_id << \" retrieved.\");\n\t\treturn token;\n\t} else {\n\t\t// Log the action\n\t\tlog_debug(\"Token for sensor \" << sensor_id << \" already exists.\");\n\t\treturn _tokens[sensor_id];\n\t}\n}", "CodeBleu_score": 47.84679115024636}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// Check if the sensor is already activated\n\tauto it = _tokens.find(sensor_id);\n\tif (it!= _tokens.end()) {\n\t\t// Sensor is already activated\n\t\tlog_debug(\"Sensor %d is already activated\", sensor_id);\n\t\treturn it->second;\n\t}\n\n\t// Sensor is not activated\n\t// Check if a secondary server is available\n\tauto router = _router->GetNextServer();\n\tif (router == nullptr) {\n\t\t// No secondary server available\n\t\tlog_debug(\"No secondary server available\");\n\t\treturn token_type();\n\t}\n\n\t// Secondary server is available\n\t// Retrieve a new token\n\tauto token = SendGetToken(router, sensor_id);\n\tif (token.is_empty()) {\n\t\t// Failed to retrieve a new token\n\t\tlog_debug(\"Failed to retrieve a new token\");\n\t\treturn token_type();\n\t}\n\n\t// New token retrieved\n\t// Update the maps\n\t_tokens[sensor_id] = token;\n\t_servers[sensor_id] = router;\n\tlog_debug(\"New token retrieved for sensor %d\", sensor_id);\n\treturn token;\n}", "CodeBleu_score": 57.559523626991236}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\ttoken_type token;\n\ttoken.set_stream_id(sensor_id);\n\ttoken.set_port(0);\n\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\tif (_tokens.find(sensor_id)!= _tokens.end()) {\n\t\tlog_debug(\"Sensor %d is already activated.\", sensor_id);\n\t\ttoken = _tokens[sensor_id];\n\t} else {\n\t\tlog_debug(\"Sensor %d is not activated.\", sensor_id);\n\t\tstd::pair<std::map<stream_id, token_type>::iterator, bool> ret;\n\t\tret = _tokens.insert(std::pair<stream_id, token_type>(sensor_id, token));\n\t\tif (ret.second == false) {\n\t\t\tlog_error(\"Failed to insert sensor %d.\", sensor_id);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (_router == nullptr) {\n\t\t\tlog_error(\"Router is null.\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Retrieve a new token from the router.\n\t\ttoken = _router->GetNextServer(sensor_id);\n\t\tif (token.get_port() == 0) {\n\t\t\tlog_error(\"Failed to retrieve a token for sensor %d.\", sensor_id);\n\t\t\texit(1);\n\t\t}\n\n\t\t// Update the maps.\n\t\tret.first->second.set_port(token.get_port());\n\t\tret.first->second.set_stream_id(sensor_id);\n\n\t\t// Log the action.\n\t\tlog_debug(\"Sensor %d is activated.\", sensor_id);\n\t}\n\n\treturn token;\n}", "CodeBleu_score": 45.9187531126223}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> buffer((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());\n\tf.close();\n\treturn Load(buffer);\n}", "CodeBleu_score": 60.09886936199873}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\n\tstd::vector<char> data;\n\tdata.resize(std::filesystem::file_size(filename));\n\tf.read(data.data(), data.size());\n\tf.close();\n\treturn Load(data);\n}", "CodeBleu_score": 67.62550398369534}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> file_data{ std::istreambuf_iterator<char>(f), std::istreambuf_iterator<char>() };\n\tf.close();\n\treturn Load(file_data);\n}", "CodeBleu_score": 60.28042179729438}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// Check if the system is ready\n\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\t// Check if the crowd object is null\n\tif (!_crowd) {\n\t\treturn false;\n\t}\n\n\t// Search for the agent id in the walker and vehicle mappings\n\tauto walker_it = _mapped_walkers_id.find(id);\n\tauto vehicle_it = _mapped_vehicles_id.find(id);\n\n\t// If found, enter a critical section to safely remove the agent from the crowd\n\tif (walker_it!= _mapped_walkers_id.end()) {\n\t\tstd::lock_guard<std::mutex> lock(_crowd_mutex);\n\t\t_walker_manager.RemoveWalker(walker_it->second);\n\t\t_mapped_walkers_id.erase(walker_it);\n\t}\n\telse if (vehicle_it!= _mapped_vehicles_id.end()) {\n\t\tstd::lock_guard<std::mutex> lock(_crowd_mutex);\n\t\t_vehicle_manager.RemoveVehicle(vehicle_it->second);\n\t\t_mapped_vehicles_id.erase(vehicle_it);\n\t}\n\n\t// Remove the id from the mappings\n\t_mapped_by_index.erase(id);\n\n\treturn true;\n}", "CodeBleu_score": 58.38420251031332}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// Check if the system is ready\n\tif (!_isReady) {\n\t\treturn false;\n\t}\n\n\t// Check if the crowd object is not null\n\tif (!_crowd) {\n\t\treturn false;\n\t}\n\n\t// Search for the agent id in the walker and vehicle mappings\n\tauto walker_it = _mapped_walkers_id.find(id);\n\tauto vehicle_it = _mapped_vehicles_id.find(id);\n\n\t// If found, enter a critical section to safely remove the agent from the crowd, update the walker or vehicle manager, and remove the id from the mappings\n\tif (walker_it!= _mapped_walkers_id.end()) {\n\t\t// Enter critical section\n\t\t_walker_manager.Lock();\n\n\t\t// Update the walker manager\n\t\t_walker_manager.RemoveWalker(walker_it->second);\n\n\t\t// Remove the id from the mappings\n\t\t_mapped_walkers_id.erase(walker_it);\n\n\t\t// Exit critical section\n\t\t_walker_manager.Unlock();\n\t}\n\telse if (vehicle_it!= _mapped_vehicles_id.end()) {\n\t\t// Enter critical section\n\t\t_vehicle_manager.Lock();\n\n\t\t// Update the vehicle manager\n\t\t_vehicle_manager.RemoveVehicle(vehicle_it->second);\n\n\t\t// Remove the id from the mappings\n\t\t_mapped_vehicles_id.erase(vehicle_it);\n\n\t\t// Exit critical section\n\t\t_vehicle_manager.Unlock();\n\t}\n\telse {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 50.299370720905465}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(_crowd);\n\tif (_crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Search for the agent in the walker and vehicle mappings\n\tauto walker_it = _mapped_walkers_id.find(id);\n\tauto vehicle_it = _mapped_vehicles_id.find(id);\n\n\t// If the agent is found in the walker mapping, remove it from the walker manager\n\tif (walker_it!= _mapped_walkers_id.end()) {\n\t\t_walker_manager.RemoveWalker(walker_it->second);\n\t\t_mapped_walkers_id.erase(walker_it);\n\t}\n\n\t// If the agent is found in the vehicle mapping, remove it from the vehicle manager\n\tif (vehicle_it!= _mapped_vehicles_id.end()) {\n\t\t_vehicle_manager.RemoveVehicle(vehicle_it->second);\n\t\t_mapped_vehicles_id.erase(vehicle_it);\n\t}\n\n\t// If the agent is found in both the walker and vehicle mappings, remove it from the crowd\n\tif (walker_it!= _mapped_walkers_id.end() && vehicle_it!= _mapped_vehicles_id.end()) {\n\t\t_crowd->removeAgent(walker_it->second);\n\t}\n\n\t// Remove the agent's index from the index to id mapping\n\t_mapped_by_index.erase(id);\n\n\treturn true;\n}", "CodeBleu_score": 52.05908815047482}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::set<int> current_vehicles;\n\tfor (auto &vehicle : vehicles) {\n\t\tcurrent_vehicles.insert(vehicle.id);\n\t}\n\n\t// Add or update vehicles\n\tfor (auto &vehicle : vehicles) {\n\t\tauto it = vehicles_updated.find(vehicle.id);\n\t\tif (it!= vehicles_updated.end()) {\n\t\t\t*it->second = vehicle;\n\t\t} else {\n\t\t\tvehicles_updated.insert({vehicle.id, std::make_unique<VehicleCollisionInfo>(vehicle)});\n\t\t}\n\t}\n\n\t// Remove vehicles\n\tfor (auto &vehicle : vehicles_updated) {\n\t\tif (current_vehicles.find(vehicle.first) == current_vehicles.end()) {\n\t\t\tvehicles_updated.erase(vehicle.first);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 52.93931879714783}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\t// TODO: Implement this function\n\tstd::set<int> current_vehicles;\n\tfor (auto& vehicle : vehicles) {\n\t\tcurrent_vehicles.insert(vehicle.id);\n\t}\n\tfor (auto& vehicle : vehicles) {\n\t\tif (vehicle.updated) {\n\t\t\tif (current_vehicles.find(vehicle.id)!= current_vehicles.end()) {\n\t\t\t\tupdated.insert(vehicle);\n\t\t\t} else {\n\t\t\t\tupdated.insert(vehicle);\n\t\t\t}\n\t\t} else {\n\t\t\tif (current_vehicles.find(vehicle.id)!= current_vehicles.end()) {\n\t\t\t\tupdated.erase(vehicle);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 51.676277325344074}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::set<int> currentVehicles;\n\tfor (auto& vehicle : vehicles) {\n\t\tcurrentVehicles.insert(vehicle.id);\n\t}\n\tfor (auto& vehicle : vehicles) {\n\t\tif (currentVehicles.find(vehicle.id) == currentVehicles.end()) {\n\t\t\tAddOrUpdateVehicle(vehicle);\n\t\t}\n\t\telse {\n\t\t\tupdated.insert(vehicle.id);\n\t\t}\n\t}\n\tfor (auto& vehicle : vehicles) {\n\t\tif (currentVehicles.find(vehicle.id)!= currentVehicles.end()) {\n\t\t\tupdated.erase(vehicle.id);\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 55.20466479222554}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::mutex> lock(_crowd_mutex);\n\tauto it_walkers = _mapped_walkers_id.find(id);\n\tif (it_walkers!= _mapped_walkers_id.end()) {\n\t\tauto it_vehicles = _mapped_vehicles_id.find(it_walkers->second);\n\t\tif (it_vehicles!= _mapped_vehicles_id.end()) {\n\t\t\tauto vehicle = it_vehicles->second;\n\t\t\tauto actor = _actors.find(id);\n\t\t\tif (actor!= _actors.end()) {\n\t\t\t\tauto actor_loc = actor->second->GetLocation();\n\t\t\t\tfloat squared_distance = carla::geom::DistanceSquared(actor_loc, vehicle->GetLocation());\n\t\t\t\tif (squared_distance < distance * distance) {\n\t\t\t\t\tif (vehicle->GetVelocity().LengthSquared() > 0.0f) {\n\t\t\t\t\t\tauto vehicle_loc = vehicle->GetLocation();\n\t\t\t\t\t\tauto vehicle_dir = carla::geom::Location(vehicle_loc.X - actor_loc.X, vehicle_loc.Y - actor_loc.Y, 0.0f);\n\t\t\t\t\t\tfloat dot = carla::geom::Dot(vehicle_dir, direction);\n\t\t\t\t\t\tif (dot > 0.0f) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 47.30291685336334}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tbool result = false;\n\tif (id == 0) {\n\t\treturn result;\n\t}\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto it = _mapped_walkers_id.find(id);\n\tif (it!= _mapped_walkers_id.end()) {\n\t\tauto walker = it->second;\n\t\tauto pos = walker->GetLocation();\n\t\tfloat dx = direction.x - pos.x;\n\t\tfloat dy = direction.y - pos.y;\n\t\tfloat dz = direction.z - pos.z;\n\t\tfloat dist = dx * dx + dy * dy + dz * dz;\n\t\tif (dist < distance * distance) {\n\t\t\tresult = _crowd->hasVehicleNear(pos, distance);\n\t\t}\n\t}\n\telse {\n\t\tit = _mapped_vehicles_id.find(id);\n\t\tif (it!= _mapped_vehicles_id.end()) {\n\t\t\tauto vehicle = it->second;\n\t\t\tauto pos = vehicle->GetLocation();\n\t\t\tfloat dx = direction.x - pos.x;\n\t\t\tfloat dy = direction.y - pos.y;\n\t\t\tfloat dz = direction.z - pos.z;\n\t\t\tfloat dist = dx * dx + dy * dy + dz * dz;\n\t\t\tif (dist < distance * distance) {\n\t\t\t\tresult = _crowd->hasVehicleNear(pos, distance);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 59.60786769680014}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tbool result = false;\n\tif (_mapped_walkers_id.find(id)!= _mapped_walkers_id.end()) {\n\t\tstd::lock_guard<std::mutex> lock(_mutex_crowd);\n\t\tresult = _crowd->hasVehicleNear(_mapped_walkers_id.find(id)->second, distance, direction);\n\t}\n\tif (_mapped_vehicles_id.find(id)!= _mapped_vehicles_id.end()) {\n\t\tstd::lock_guard<std::mutex> lock(_mutex_crowd);\n\t\tresult = _crowd->hasVehicleNear(_mapped_vehicles_id.find(id)->second, distance, direction);\n\t}\n\treturn result;\n}", "CodeBleu_score": 54.4804558319952}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tWalkerEventVisitor visitor(info, delta);\n\tauto event = info.events.front();\n\tinfo.events.pop();\n\treturn boost::apply_visitor(visitor, event);\n}", "CodeBleu_score": 38.89574722573911}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tWalkerInfo::WalkerRoutePoint &point = info.route[info.currentRoutePoint];\n\tWalkerEventVisitor visitor(info, delta);\n\treturn boost::variant2::visit(visitor, point.event);\n}", "CodeBleu_score": 52.43313931761274}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tWalkerEventVisitor visitor(id, info, delta);\n\treturn boost::apply_visitor(visitor, info.event);\n}", "CodeBleu_score": 33.083803965110754}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\t// Iterate through each road node and process each lane section within the lanes node.\n\tfor (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"road\")) {\n\t\t// Retrieve the road ID.\n\t\tuint32_t road_id = road_node.attribute(\"id\").as_uint();\n\n\t\t// Iterate through each lane section and process each lane.\n\t\tfor (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n\t\t\t// Retrieve the lane section ID.\n\t\t\tuint32_t lane_section_id = lane_section_node.attribute(\"s\").as_uint();\n\n\t\t\t// Retrieve the left, center, and right lane nodes.\n\t\t\tpugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n\t\t\tpugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n\t\t\tpugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n\t\t\t// Parse the left lane.\n\t\t\tParseLanes(left_lane_node, map_builder, road_id, lane_section_id);\n\n\t\t\t// Parse the center lane.\n\t\t\tParseLanes(center_lane_node, map_builder, road_id, lane_section_id);\n\n\t\t\t// Parse the right lane.\n\t\t\tParseLanes(right_lane_node, map_builder, road_id, lane_section_id);\n\t\t}\n\t}\n}", "CodeBleu_score": 55.909598180874895}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\t// Iterate through each road node.\n\tfor (auto road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\t\t// Retrieve the road ID.\n\t\tuint32_t road_id = road_node.attribute(\"id\").as_uint();\n\n\t\t// Iterate through each lane section.\n\t\tfor (auto lane_section_node : road_node.children(\"lanes\").children(\"laneSection\")) {\n\t\t\t// Retrieve the lane section ID.\n\t\t\tuint32_t lane_section_id = lane_section_node.attribute(\"id\").as_uint();\n\n\t\t\t// Retrieve the left, center, and right lane nodes.\n\t\t\tauto left_lane_node = lane_section_node.child(\"left\");\n\t\t\tauto center_lane_node = lane_section_node.child(\"center\");\n\t\t\tauto right_lane_node = lane_section_node.child(\"right\");\n\n\t\t\t// Parse the left, center, and right lane nodes.\n\t\t\tParseLanes(left_lane_node, map_builder, road_id, lane_section_id, carla::road::LaneType::Left);\n\t\t\tParseLanes(center_lane_node, map_builder, road_id, lane_section_id, carla::road::LaneType::Center);\n\t\t\tParseLanes(right_lane_node, map_builder, road_id, lane_section_id, carla::road::LaneType::Right);\n\t\t}\n\t}\n}", "CodeBleu_score": 49.792508855579634}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\t// Get the open_drive node.\n\tconst auto open_drive_node = xml.child(\"openDRIVE\");\n\n\t// Iterate through each road node.\n\tfor (const auto &road_node : open_drive_node.children(\"road\")) {\n\t\t// Get the road ID.\n\t\tconst auto road_id = road_node.attribute(\"id\").as_uint();\n\n\t\t// Iterate through each lane section node.\n\t\tfor (const auto &lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n\t\t\t// Get the lane section ID.\n\t\t\tconst auto lane_section_id = lane_section_node.attribute(\"id\").as_uint();\n\n\t\t\t// Get the left, center, and right lane nodes.\n\t\t\tconst auto left_lane_node = lane_section_node.child(\"left\");\n\t\t\tconst auto center_lane_node = lane_section_node.child(\"center\");\n\t\t\tconst auto right_lane_node = lane_section_node.child(\"right\");\n\n\t\t\t// Parse the left lane.\n\t\t\tParseLanes(left_lane_node, map_builder, road_id, lane_section_id);\n\n\t\t\t// Parse the center lane.\n\t\t\tParseLanes(center_lane_node, map_builder, road_id, lane_section_id);\n\n\t\t\t// Parse the right lane.\n\t\t\tParseLanes(right_lane_node, map_builder, road_id, lane_section_id);\n\t\t}\n\t}\n}", "CodeBleu_score": 54.66571316744272}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\t// Get the topic name from the writer\n\tstd::string topic_name = writer->GetTopicName();\n\t// Get the matched status\n\tint matched_count = info.get_matched_count();\n\t// Get the status\n\tint status = info.get_status();\n\t// Get the reason\n\tint reason = info.get_reason();\n\t// Get the remote entity name\n\tstd::string remote_entity_name = info.get_remote_entity_name();\n\t// Get the remote entity name\n\tstd::string remote_entity_type = info.get_remote_entity_type();\n\n\t// If the matched count is 1, we have a new match\n\tif (matched_count == 1) {\n\t\t// Set the matched count\n\t\tm_matched_count[topic_name] = matched_count;\n\t\t// Set the first connection\n\t\tm_first_connection[topic_name] = true;\n\t}\n\t// If the matched count is 0, we have a lost match\n\telse if (matched_count == 0) {\n\t\t// Set the matched count\n\t\tm_matched_count[topic_name] = matched_count;\n\t}\n\t// If the matched count is not 1 or 0, it is an invalid change\n\telse {\n\t\t// Log an error message\n\t\tLOG_ERROR(m_logger, \"Invalid matched count change: \" << matched_count << \" for topic: \" << topic_name << \" with status: \" << status << \" and reason: \" << reason << \" and remote entity name: \" << remote_entity_name << \" and remote entity type: \" << remote_entity_type);\n\t}\n}", "CodeBleu_score": 33.92854602165588}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\t// Update the matched count.\n\tif (info.matched_count_change() == 0) {\n\t\tLOG_ERROR(\"Publication matched count change is zero, invalid.\");\n\t\treturn;\n\t}\n\tif (info.matched_count_change() > 0) {\n\t\t++m_matched_publications;\n\t\tif (m_matched_publications == 1) {\n\t\t\tm_first_publication_matched = true;\n\t\t}\n\t} else {\n\t\t--m_matched_publications;\n\t\tif (m_matched_publications < 0) {\n\t\t\tLOG_ERROR(\"Publication matched count is less than zero, invalid.\");\n\t\t}\n\t}\n}", "CodeBleu_score": 38.013641173276234}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\t// If a new match is detected, it sets the matched count and marks the first connection.\n\tif (info.is_new_remote_publication()) {\n\t\tif (info.get_remote_publication_count() == 1) {\n\t\t\tm_matched_count++;\n\t\t\tm_first_connection = true;\n\t\t}\n\t}\n\t// If a match is lost, it updates the matched count.\n\telse if (info.is_remote_publication_lost()) {\n\t\tif (info.get_remote_publication_count() == 0) {\n\t\t\tm_matched_count--;\n\t\t}\n\t}\n\t// For invalid count changes, it logs an error message.\n\telse {\n\t\tLOG_ERROR(\"Invalid publication matched status change.\");\n\t}\n}", "CodeBleu_score": 45.65429618476852}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\t// This is called when a new subscription is matched, or an existing subscription is unmatched.\n\t// If a new subscription is matched, it updates the matched count and sets the first_connected flag.\n\t// If a subscription is unmatched, it updates the matched count and destroys the subscriber if there are no remaining matches.\n\t// If the change count is invalid, it logs an error message.\n\tif (info.status == efd::SubscriptionMatchedStatus::MATCHED) {\n\t\t// The subscription is matched.\n\t\t// Update the matched count and set the first_connected flag.\n\t\tmatched_count_++;\n\t\tif (matched_count_ == 1) {\n\t\t\tfirst_connected_ = true;\n\t\t}\n\t} else if (info.status == efd::SubscriptionMatchedStatus::UNMATCHED) {\n\t\t// The subscription is unmatched.\n\t\t// Update the matched count and destroy the subscriber if there are no remaining matches.\n\t\tmatched_count_--;\n\t\tif (matched_count_ == 0) {\n\t\t\t// The subscriber is no longer needed.\n\t\t\t// Destroy the subscriber.\n\t\t\tDestroySubscriber();\n\t\t}\n\t} else {\n\t\t// The change count is invalid.\n\t\t// Log an error message.\n\t\tstd::cout << \"Invalid subscription change count.\" << std::endl;\n\t}\n}", "CodeBleu_score": 44.937070555587376}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.get_status() == efd::SubscriptionMatchedStatus::MATCHED) {\n\t\t// If the subscription is matched, update the matched count and set the first_connected flag.\n\t\tif (info.get_current_count() > 0) {\n\t\t\tmatched_count++;\n\t\t\tfirst_connected = true;\n\t\t}\n\t} else if (info.get_status() == efd::SubscriptionMatchedStatus::UNMATCHED) {\n\t\t// If the subscription is unmatched, update the matched count and destroy the subscriber if there are no remaining matches.\n\t\tif (info.get_current_count() == 0) {\n\t\t\tmatched_count--;\n\t\t\tif (matched_count == 0) {\n\t\t\t\tif (subscriber_!= NULL) {\n\t\t\t\t\tsubscriber_->DestroySubscriber();\n\t\t\t\t\tsubscriber_ = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// If the change count is invalid, log an error message.\n\t\tLOG_ERROR(\"Invalid change count for subscription.\");\n\t}\n}", "CodeBleu_score": 49.16409878097737}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.total_count_change == 0) {\n\t\tLOG_ERROR(\"Invalid subscription change count: \" << info.total_count_change);\n\t\treturn;\n\t}\n\tif (info.total_count_change < 0) {\n\t\tLOG_ERROR(\"Subscription change count is negative: \" << info.total_count_change);\n\t\treturn;\n\t}\n\tif (info.total_count_change > 0) {\n\t\tif (info.current_count == 0) {\n\t\t\tLOG_ERROR(\"Subscription count is 0 after change: \" << info.total_count_change);\n\t\t\treturn;\n\t\t}\n\t\tif (info.current_count == 1) {\n\t\t\tif (first_connected) {\n\t\t\t\tLOG_ERROR(\"Subscription count is 1 after change, but first_connected is true: \" << info.total_count_change);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfirst_connected = true;\n\t\t\tLOG_INFO(\"Subscription count is 1 after change: \" << info.total_count_change);\n\t\t} else {\n\t\t\tLOG_INFO(\"Subscription count is \" << info.current_count << \" after change: \" << info.total_count_change);\n\t\t}\n\t} else {\n\t\tif (info.current_count == 0) {\n\t\t\tLOG_INFO(\"Subscription count is 0 after change: \" << info.total_count_change);\n\t\t\tif (first_connected) {\n\t\t\t\tfirst_connected = false;\n\t\t\t\tif (info.total_count_change == -1) {\n\t\t\t\t\tLOG_ERROR(\"Subscription count is 0 after change, but first_connected is true: \" << info.total_count_change);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (info.total_count_change == -2) {\n\t\t\t\t\tLOG_ERROR(\"Subscription count is 0 after change, but first_connected is true: \" << info.total_count_change);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (info.total_count_change == -3) {\n\t\t\t\t\tLOG_ERROR(\"Subscription count is 0 after change, but first_connected is true: \" << info.total_count_change);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (info.total_count", "CodeBleu_score": 45.11689114171609}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (m_isKeyDefined) {\n\t\tif (force_md5) {\n\t\t\t// 1. retrieve the MD5 key\n\t\t\tunsigned char* md5_key = NULL;\n\t\t\tunsigned int md5_key_length = 0;\n\t\t\tif (m_key.getKey(&md5_key, &md5_key_length)) {\n\t\t\t\t// 2. set the key in the handle\n\t\t\t\thandle->key = md5_key;\n\t\t\t\thandle->key_length = md5_key_length;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t// 1. retrieve the serialized key\n\t\t\tunsigned char* key = NULL;\n\t\t\tunsigned int key_length = 0;\n\t\t\tif (m_key.getKey(&key, &key_length)) {\n\t\t\t\t// 2. set the key in the handle\n\t\t\t\thandle->key = key;\n\t\t\t\thandle->key_length = key_length;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 28.322360394064177}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);", "CodeBleu_score": 6.8927222716167496}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\nif(p_type->key.is_valid()) {\n    m_md5.init();\n    m_md5.update(p_type->key.data, p_type->key.size);\n    m_md5.finalize();\n\n    unsigned char* hash_ptr = m_md5.digest();\n    memcpy(&handle->value[0], hash_ptr, 16);\n\n    return true;\n}\n\nreturn false;\n}", "CodeBleu_score": 22.602210702313908}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    payload->encapsulation = SerializationEncapsulation::Cdr;\n    payload->max_size = 0;\n    payload->size = 0;\n    payload->data = nullptr;\n\n    try {\n        payload->data = new uint8_t[payload->max_size];\n    } catch(...) {\n        return false;\n    }\n\n    Cdr ser(payload->data, payload->max_size);\n    ser.serialize_encapsulation(static_cast<uint32_t>(payload->encapsulation));\n    payload->size = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 42.85793579526374}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(1024);\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n\t\t\teprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\t// Serialize encapsulation\n\tpayload->encapsulation = CDR_LE;\n\t// Serialize type\n\tpayload->data.resize(ser.getSerializedDataLength());\n\tser.serialize_encapsulation(&payload->data[0]);\n\t// Serialize the object.\n\tser.serialize_type_object(*p_type);\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n\treturn true;\n}", "CodeBleu_score": 64.69383569921371}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n// Object that manages the raw buffer.\nFastBuffer fastbuffer(FASTBUFFER_MAX_SIZE);\n\n// Object that serializes the data.\nEprosima::Fastcdr::Cdr ser(fastbuffer, Eprosima::Fastcdr::Cdr::DEFAULT_ENDIAN, Eprosima::Fastcdr::Cdr::DDS_CDR);\n\n// Serialize encapsulation.\nser.serialize_encapsulation();\n\n// Serialize the data.\np_type->serialize(ser);\n\n// Set the payload length.\npayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\n// Serialize the data:\npayload->data = reinterpret_cast<uint8_t*>(malloc(payload->length));\nmemcpy(payload->data, ser.getSerializedData(), payload->length);\n\nreturn true;\n}", "CodeBleu_score": 59.164901379583604}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// Check if the target has been set\n\tif (tracker.g.sysid_target) {\n\t\treturn;\n\t}\n\n\t// Decode the message\n\tmavlink_heartbeat_t hb;\n\tmavlink_msg_heartbeat_decode(&msg, &hb);\n\n\t// Check if the message is one that should be tracked\n\tif (hb.custom_mode!= MAV_MODE_FLAG_CUSTOM_MODE_ENABLED) {\n\t\treturn;\n\t}\n\n\t// Set the sysid\n\ttracker.g.sysid_target = hb.sysid;\n\n\t// Request position and air pressure data streams from the target\n\ttracker.gcs().request_datastream_position(tracker.g.sysid_target, MAV_DATA_STREAM_ALL, 1);\n\ttracker.gcs().request_datastream_airpressure(tracker.g.sysid_target, MAV_DATA_STREAM_ALL, 1);\n\n\t// Flag that the target has been set\n\ttracker.g.target_set = true;\n}", "CodeBleu_score": 44.63541992090934}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\tif (msg.msgid!= MAVLINK_MSG_ID_HEARTBEAT) {\n\t\treturn;\n\t}\n\n\tmavlink_heartbeat_t heartbeat;\n\tmavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n\tif (heartbeat.custom_mode == MAV_MODE_GUIDED_ARMED) {\n\t\ttarget_sysid = heartbeat.sysid;\n\n\t\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAV_DATA_STREAM_POSITION, 1, 10);\n\t\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAV_DATA_STREAM_AIRSPEED, 1, 10);\n\n\t\ttarget_set = true;\n\t}\n}", "CodeBleu_score": 36.85976769538763}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (tracker.g.sysid_target!= 0) {\n\t\treturn;\n\t}\n\tmavlink_msg_heartbeat_decode(&msg, &tracker.g.heartbeat_target);\n\tif (tracker.g.heartbeat_target.custom_mode!= MAV_MODE_FLAG_CUSTOM_MODE_ENABLED) {\n\t\treturn;\n\t}\n\ttracker.g.sysid_target = msg.sysid;\n\ttracker.g.compid_target = msg.compid;\n\ttracker.g.request_datastream_position = true;\n\ttracker.g.request_datastream_airpressure = true;\n\ttracker.g.target_set = true;\n}", "CodeBleu_score": 36.164074749630885}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\treturn GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n}", "CodeBleu_score": 20.960702083402794}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// Call base class handler\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t// Set flag to indicate that altitude calibration is needed on the next barometer update\n\t\t_alt_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.629422460640484}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\treturn GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n}", "CodeBleu_score": 20.960702083402794}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 70.29383879107523}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// Check if the command is for servos\n\tif (packet.target_system!= 0 || packet.target_component!= 0) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is for servos\n\tif (packet.command!= MAV_CMD_COMPONENT_ARM_DISARM) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is for servos\n\tif (packet.param1!= 1.0f && packet.param1!= 0.0f) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is for servos\n\tif (packet.param1 == 1.0f) {\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\n\t// Check if the command is for servos\n\tif (packet.param1 == 0.0f) {\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\n\t// Check if the command is for servos\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 67.83685699410358}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tmavlink_command_ack_t msg;\n\tmsg.command = packet.command;\n\tmsg.result = MAV_RESULT_UNSUPPORTED;\n\tmsg.target_system = packet.target_system;\n\tmsg.target_component = packet.target_component;\n\n\tif (packet.param1 == 1.0f) {\n\t\tmsg.result = MAV_RESULT_ACCEPTED;\n\t\ttracker.arm_servos();\n\t} else if (packet.param1 == 0.0f) {\n\t\tmsg.result = MAV_RESULT_ACCEPTED;\n\t\ttracker.disarm_servos();\n\t} else {\n\t\tmsg.result = MAV_RESULT_UNSUPPORTED;\n\t}\n\n\tmavlink_msg_command_ack_send(MAVLINK_COMM_0, &msg);\n\n\treturn msg.result;\n}", "CodeBleu_score": 46.534694973073}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tmavlink_msg_request_data_stream_send(mavlink_fd, sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n}", "CodeBleu_score": 18.683964597222598}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over all GCS channels and check if there is available payload space\n\tfor (int i = 0; i < num_gcs; i++) {\n\t\tif (gcs_channels[i].has_available_payload_space()) {\n\t\t\t// Send a request to start streaming position data on the corresponding channel\n\t\t\tmavlink_msg_request_data_stream_send(gcs_channels[i].get_mavlink_channel(), sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.06575431651594}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tif (mavlink_system.num_gcs > 0) {\n\t\tmavlink_system.num_gcs--;\n\t\tmavlink_system.gcs_channels[mavlink_system.num_gcs].sysid = sysid;\n\t\tmavlink_system.gcs_channels[mavlink_system.num_gcs].compid = compid;\n\t\tmavlink_system.gcs_channels[mavlink_system.num_gcs].update_rate = 100;\n\t\tmavlink_system.gcs_channels[mavlink_system.num_gcs].payload_space = 0;\n\t\tmavlink_system.gcs_channels[mavlink_system.num_gcs].payload_index = 0;\n\t\tmavlink_system.gcs_channels[mavlink_system.num_gcs].mavlink_msg_request_data_stream_send = mavlink_msg_request_data_stream_send;\n\t\tmavlink_system.gcs_channels[mavlink_system.num_gcs].mavlink_msg_request_data_stream_send(sysid, compid, 3, 100);\n\t}\n}", "CodeBleu_score": 36.32502695875125}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch!= 0) {\n\t\tef_pitch = asin(ahrs.sin_pitch * pitch + ahrs.cos_pitch * yaw);\n\t\tef_yaw = atan2(-ahrs.sin_roll * pitch + ahrs.cos_roll * yaw, ahrs.cos_roll * pitch + ahrs.sin_roll * yaw);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 48.89722868783281}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch == 0)\n\t\treturn false;\n\tef_pitch = atan2(ahrs.sin_pitch * ahrs.cos_roll, ahrs.cos_pitch);\n\tef_yaw = atan2(ahrs.sin_roll * ahrs.cos_pitch, ahrs.cos_roll);\n\treturn true;\n}", "CodeBleu_score": 31.162511369789314}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t//Retrieve AHRS instance\n\tAP::ahrs ahrs = AP::ahrs::get_instance();\n\t//Check for zero pitch cosine\n\tif (ahrs.cos_pitch!= 0) {\n\t\t//Calculate earth frame pitch and yaw\n\t\tef_pitch = atan2(ahrs.sin_pitch, ahrs.cos_pitch);\n\t\tef_yaw = atan2(ahrs.sin_roll, ahrs.cos_roll);\n\t\t//Return true\n\t\treturn true;\n\t}\n\t//Return false\n\treturn false;\n}", "CodeBleu_score": 34.66807116701968}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// Check if the target distance is valid or no minimum distance is set\n\tif (tracker.target_distance_valid || tracker.min_distance == 0) {\n\t\t// Get the current yaw and pitch angles in centidegrees\n\t\tfloat yaw = tracker.yaw_servo.get_angle_deg();\n\t\tfloat pitch = tracker.pitch_servo.get_angle_deg();\n\n\t\t// Check if the direction is reversed\n\t\tif (tracker.yaw_direction_reversed) {\n\t\t\t// Reverse the yaw angle\n\t\t\tyaw = -yaw;\n\t\t}\n\n\t\t// Get the angle error in centidegrees\n\t\tfloat angle_error = calc_angle_error(yaw, tracker.target_yaw);\n\n\t\t// Convert the angle error from earth frame to body frame\n\t\tfloat error_bf = convert_ef_to_bf(angle_error);\n\n\t\t// Check if the target distance is valid\n\t\tif (tracker.target_distance_valid) {\n\t\t\t// Update the pitch servo\n\t\t\ttracker.update_pitch_servo(error_bf, tracker.pitch_kp, tracker.pitch_ki, tracker.pitch_kd);\n\t\t}\n\n\t\t// Check if the target distance is valid or no minimum distance is set\n\t\tif (tracker.target_distance_valid || tracker.min_distance == 0) {\n\t\t\t// Update the yaw servo\n\t\t\ttracker.update_yaw_servo(error_bf, tracker.yaw_kp, tracker.yaw_ki, tracker.yaw_kd);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.247100470261795}, {"code": "void Mode::update_auto(void){\n\t\t// Get the current navigation status\n\tNavigationStatus nav_status = tracker.get_nav_status();\n\n\t// Get the current target yaw and pitch\n\tfloat target_yaw = tracker.get_target_yaw();\n\tfloat target_pitch = tracker.get_target_pitch();\n\n\t// Get the current target distance\n\tfloat target_distance = tracker.get_target_distance();\n\n\t// Get the current yaw and pitch\n\tfloat yaw = tracker.get_yaw();\n\tfloat pitch = tracker.get_pitch();\n\n\t// Get the current yaw and pitch directions\n\tbool yaw_dir = tracker.get_yaw_dir();\n\tbool pitch_dir = tracker.get_pitch_dir();\n\n\t// Get the current yaw and pitch servo positions\n\tfloat yaw_servo_pos = tracker.get_yaw_servo_pos();\n\tfloat pitch_servo_pos = tracker.get_pitch_servo_pos();\n\n\t// Get the current yaw and pitch servo directions\n\tbool yaw_servo_dir = tracker.get_yaw_servo_dir();\n\tbool pitch_servo_dir = tracker.get_pitch_servo_dir();\n\n\t// Get the current yaw and pitch servo limits\n\tfloat yaw_servo_min = tracker.get_yaw_servo_min();\n\tfloat yaw_servo_max = tracker.get_yaw_servo_max();\n\tfloat pitch_servo_min = tracker.get_pitch_servo_min();\n\tfloat pitch_servo_max = tracker.get_pitch_servo_max();\n\n\t// Get the current yaw and pitch servo limits\n\tfloat yaw_servo_min_cd = tracker.get_yaw_servo_min_cd();\n\tfloat yaw_servo_max_cd = tracker.get_yaw_servo_max_cd();\n\tfloat pitch_servo_min_cd = tracker.get_pitch_servo_min_cd();\n\tfloat pitch_servo_max_cd = tracker.get_pitch_servo_max_cd();\n\n\t// Get the current yaw and pitch servo limits\n\tfloat yaw_servo_min_deg = tracker.get_yaw_servo_min_deg();\n\tfloat yaw_servo_max_deg = tracker.get_yaw_servo_max_deg();\n\tfloat pitch_servo_min_deg", "CodeBleu_score": 17.516978294840836}, {"code": "void Mode::update_auto(void){\n\t\t// Get the current navigation status\n\tauto nav_status = tracker.get_nav_status();\n\n\t// Get the current yaw and pitch in centidegrees\n\tint16_t yaw = tracker.get_yaw_servo();\n\tint16_t pitch = tracker.get_pitch_servo();\n\n\t// Get the current target yaw and pitch in centidegrees\n\tint16_t target_yaw = tracker.get_target_yaw();\n\tint16_t target_pitch = tracker.get_target_pitch();\n\n\t// Get the current target distance in centimeters\n\tint16_t target_dist = tracker.get_target_dist();\n\n\t// Get the current distance in centimeters\n\tint16_t dist = tracker.get_dist();\n\n\t// Get the current yaw direction\n\tint16_t yaw_direction = tracker.get_yaw_direction();\n\n\t// Get the current pitch direction\n\tint16_t pitch_direction = tracker.get_pitch_direction();\n\n\t// Get the current yaw and pitch in radians\n\tfloat yaw_rad = (float)yaw / 100.0;\n\tfloat pitch_rad = (float)pitch / 100.0;\n\n\t// Get the current target yaw and pitch in radians\n\tfloat target_yaw_rad = (float)target_yaw / 100.0;\n\tfloat target_pitch_rad = (float)target_pitch / 100.0;\n\n\t// Get the current target distance in meters\n\tfloat target_dist_m = (float)target_dist / 100.0;\n\n\t// Get the current distance in meters\n\tfloat dist_m = (float)dist / 100.0;\n\n\t// Get the current yaw direction\n\tfloat yaw_direction_rad = (float)yaw_direction / 100.0;\n\n\t// Get the current pitch direction\n\tfloat pitch_direction_rad = (float)pitch_direction / 100.0;\n\n\t// Get the current angle error in radians\n\tfloat angle_error_rad = (float)tracker.get_angle_error() / 100.0;\n\n\t// Get the current angle error in centidegrees", "CodeBleu_score": 30.735174641181402}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time_ms!= last_message_time_ms) {\n\t\tlast_message_time_ms = gps.last_message_time_ms;\n\t\tif (gps.status >= 3) {\n\t\t\tif (countdown_ms > 0) {\n\t\t\t\tcountdown_ms = 0;\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\tset_home();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcountdown_ms = 1000;\n\t\t}\n\t}\n}", "CodeBleu_score": 32.8630586447186}, {"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time_ms!= last_message_time_ms) {\n\t\tlast_message_time_ms = gps.last_message_time_ms;\n\t\tif (gps.status >= 3) {\n\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\tground_start_countdown--;\n\t\t\t} else {\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\tset_home(gps.location);\n\t\t\t\t} else {\n\t\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.45075702404502}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update the GPS\n\tgps.update();\n\n\t// If the last message time has changed, reset the countdown\n\tif (gps.last_message_time_ms!= last_message_time_ms) {\n\t\tlast_message_time_ms = gps.last_message_time_ms;\n\t\tcountdown = 30;\n\t}\n\n\t// If the GPS status is 3D fix, and the countdown has reached 0, and the current location is valid, set the home location\n\tif (gps.status == 3 && countdown == 0 && gps.location.isValid()) {\n\t\tset_home();\n\t}\n\t// If the GPS status is not 3D fix, or the current location is invalid, reset the countdown\n\telse if (gps.status!= 3 ||!gps.location.isValid()) {\n\t\tcountdown = 30;\n\t}\n\n\t// Decrement the countdown\n\tcountdown--;\n}", "CodeBleu_score": 34.440464312245965}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0) {\n\t\t_pitch_servo_on = true;\n\t} else {\n\t\t_pitch_servo_on = false;\n\t}\n}", "CodeBleu_score": 10.708746460386216}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0f) {\n\t\tservo_pitch_on_off.write(pitch);\n\t} else {\n\t\tservo_pitch_on_off.write(0.0f);\n\t}\n}", "CodeBleu_score": 14.423726247595281}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0f) {\n\t\t_pitch_onoff_servo.set_output(1.0f);\n\t} else {\n\t\t_pitch_onoff_servo.set_output(0.0f);\n\t}\n}", "CodeBleu_score": 13.347287720092748}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool ret = true;\n\n\tif (AP_Arming::barometer_checks(display_failure)) {\n\t\t// check barometer\n\t\tif (check_barometer_enabled()) {\n\t\t\tfloat baro_alt_cm = get_barometer_alt_cm();\n\t\t\tfloat inertial_alt_cm = get_inertial_nav_alt_cm();\n\t\t\tfloat disparity_cm = baro_alt_cm - inertial_alt_cm;\n\t\t\tfloat limit_cm = get_barometer_disparity_limit_cm();\n\n\t\t\tif (fabsf(disparity_cm) > limit_cm) {\n\t\t\t\tif (display_failure) {\n\t\t\t\t\tcheck_failed(false, PX4_ERR_BARO_DISPARITY, disparity_cm, limit_cm);\n\t\t\t\t}\n\t\t\t\tret = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 48.0182567579204}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call base class version\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check for barometer altitude disparity\n\tif (check_enabled(ARMING_CHECK_BARO)) {\n\t\t// get the barometer altitude in cm\n\t\tfloat baro_alt_cm = get_barometer_alt_cm();\n\n\t\t// get the inertial navigation altitude in cm\n\t\tfloat inertial_alt_cm = inertial_nav.get_position_z_up_cm();\n\n\t\t// check for disparity\n\t\tif (fabsf(baro_alt_cm - inertial_alt_cm) > ARMING_BARO_ALT_DISPARITY_CM) {\n\t\t\tif (display_failure) {\n\t\t\t\tLOG_ERROR(\n\t\t\t\t\t\t\"Barometer altitude disparity exceeds limit, barometer: %f, inertial: %f\",\n\t\t\t\t\t\tbaro_alt_cm, inertial_alt_cm);\n\t\t\t}\n\t\t\tcheck_failed(ARMING_CHECK_BARO);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 44.47475576109947}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool result = true;\n\n\t// call base class function\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\tresult = false;\n\t}\n\n\t// check barometer altitude\n\tif (AP_Arming::ARMING_CHECK_BARO) {\n\t\tif (fabsf(AP_Arming::baro_alt_cm - copter.inertial_nav.get_position_z_up_cm()) > AP_Arming::BARO_ALT_DISPARITY_CM) {\n\t\t\tif (display_failure) {\n\t\t\t\tcheck_failed();\n\t\t\t}\n\t\t\tresult = false;\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 34.139139147250916}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == AP_Terrain::SOURCE_RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\tif (copter.mode_rtl.get_alt_type() == AP_Mode_RTL::ALT_TYPE_TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 59.92858482019145}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == TerrainSource::Rangefinder) {\n\t\treturn false;\n\t}\n\tif (copter.mode_rtl.get_alt_type() == AltitudeType::Terrain) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 59.012964154126735}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == TerrainSource::Rangefinder) {\n\t\treturn false;\n\t}\n\n\tif (copter.mode_rtl.get_alt_type() == AltitudeType::Terrain) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 59.012964154126735}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// get the time since the last loop\n\tconst float dt = AP::scheduler().get_last_loop_time_s();\n\n\t// set the loop time for the rate controllers\n\tpos_control->set_dt(dt);\n\tattitude_control->set_dt(dt);\n\tmotors->set_dt(dt);\n\n\t// run the rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 67.80363527922775}, {"code": "void Copter::run_rate_controller(){\n\t\t// set loop time\n\tpos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tattitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tmotors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n\t// run low-level rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 51.43459362624547}, {"code": "void Copter::run_rate_controller(){\n\t\t// set loop time for rate controllers\n\tattitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tpos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tmotors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n\t// run low-level rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 47.2679269595788}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (flightmode->get_wp() == NULL) {\n\t\treturn false;\n\t}\n\n\tLocation wp_loc = flightmode->get_wp()->get_location();\n\tif (old_loc.same_loc_as(wp_loc) && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\tset_target_location(new_loc);\n\treturn true;\n}", "CodeBleu_score": 62.20090819928161}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (flightmode->get_wp()!= nullptr) {\n\t\tLocation next_wp = flightmode->get_wp()->get_location();\n\t\tif (old_loc.same_loc_as(next_wp) && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n\t\t\tset_target_location(next_wp);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 54.783019080924554}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (flightmode->get_wp() == nullptr) {\n\t\treturn false;\n\t}\n\n\tLocation next_wp = flightmode->get_wp()->get_location();\n\tif (old_loc.same_loc_as(next_wp) && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n\t\tset_target_location(next_wp);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 57.65801549640626}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tcopter.set_mode(mode);\n\t} else if (copter.flightmode->mode_number == mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 55.412178978737494}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tcopter.set_mode(mode);\n\t} else if (ch_flag == AuxSwitchPos::LOW) {\n\t\tif (copter.flightmode->mode_number == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 59.05744956977931}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tcopter.set_mode(mode);\n\t} else if (copter.flightmode->mode_number == mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 55.412178978737494}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// Get the control input values from the roll and pitch channels\n\tfloat control_roll = channel_roll->get_control_in();\n\tfloat control_pitch = channel_pitch->get_control_in();\n\n\t// Convert the control input values to radians\n\tfloat roll_trim = ToRad(control_roll);\n\tfloat pitch_trim = ToRad(control_pitch);\n\n\t// Add the trim values to the AHRS\n\tahrs.add_trim(roll_trim, pitch_trim);\n\n\t// Log the event\n\tLOGGER_WRITE_EVENT(EVENT_TYPE_TRIM_SAVED);\n\n\t// Send a confirmation message\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 63.451622416695926}, {"code": "void Copter::save_trim(){\n\t\t// Calculate the trim values from the control inputs of the roll and pitch channels\n\tfloat roll_trim = channel_roll->get_control_in() * ToRad;\n\tfloat pitch_trim = channel_pitch->get_control_in() * ToRad;\n\n\t// Add the trim values to the AHRS trim\n\tahrs.add_trim(roll_trim, pitch_trim);\n\n\t// Log the event\n\tLOGGER_WRITE_EVENT(LOGGER_EVENT_TRIM_SAVED);\n\n\t// Send a confirmation message with MAV_SEVERITY_INFO\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 66.162537602515}, {"code": "void Copter::save_trim(){\n\t\tif (channel_roll->get_control_in() == 0 && channel_pitch->get_control_in() == 0) {\n\t\treturn;\n\t}\n\n\t// Convert the control inputs to radians\n\tfloat roll_trim_rad = (float) channel_roll->get_control_in() * M_PI / 1000.0f;\n\tfloat pitch_trim_rad = (float) channel_pitch->get_control_in() * M_PI / 1000.0f;\n\n\t// Add the trim to the AHRS\n\tahrs.add_trim(roll_trim_rad, pitch_trim_rad);\n\n\t// Log the event\n\tLOGGER_WRITE_EVENT(LOGGER_EVENT_ID_TRIM_SAVED);\n\n\t// Send a confirmation message\n\tgcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 59.12020121744148}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat yaw_angle = 0.0f;\n\tif (copter.position_ok && vel.xy().length_squared > 0.0001f) {\n\t\tyaw_angle = atan2f(vel.x, vel.y);\n\t}\n\treturn yaw_angle;\n}", "CodeBleu_score": 26.63782044632001}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tif (!copter.position_ok) {\n\t\treturn 0.0f;\n\t}\n\n\tfloat speed_squared = vel.xy().length_squared;\n\tif (speed_squared < 0.00001f) {\n\t\treturn 0.0f;\n\t}\n\n\tfloat yaw_angle = atan2f(vel.y, vel.x) * 180.0f / M_PI;\n\treturn yaw_angle;\n}", "CodeBleu_score": 31.630033214798065}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat speed_squared = vel.xy().length_squared;\n\tif (copter.position_ok && speed_squared > MIN_SPEED_SQUARED) {\n\t\tfloat look_ahead_angle = atan2f(vel.y, vel.x);\n\t\treturn look_ahead_angle;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 33.845340520224504}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (gcs().is_rudder_arming_disabled()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (plane.get_throttle_input() == 0.0f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (gcs().is_armed() || hal.util->was_watchdog_armed()) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 50.07042686847414}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (gcs().get_rudder_arming_type() == AP_Rudder::ARMING_DISABLED) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (plane.get_throttle_input() == 0.0f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (hal.util->was_watchdog_armed()) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 44.90455201058676}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::Method::RUDDER) {\n\t\t// RUDDER method\n\t\tif (gcs().is_rudder_arming_disabled() || plane.get_throttle_input()!= 0.0f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// check if arming checks are disabled or if watchdog was armed\n\tif (!gcs().is_arming_checks_enabled() || hal.util->was_watchdog_armed()) {\n\t\treturn true;\n\t}\n\n\t// check parent class\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 51.86282928799169}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (do_arming_checks) {\n\t\tif (check_throttle_too_low()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (arming_method == AP_Arming::METHOD_NONE) {\n\t\treturn false;\n\t}\n\n\tif (method == AP_Arming::METHOD_NONE) {\n\t\tmethod = arming_method;\n\t}\n\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\tif (!check_throttle_too_high()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\tif (check_throttle_too_low()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\tif (check_throttle_too_high()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\tif (check_throttle_too_low()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\tif (check_throttle_too_high()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\tif (check_throttle_too_low()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\tif (check_throttle_too_high()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\tif (check_throttle_too_low()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\tif (check_throttle_too_high()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::METHOD_STABILIZE) {\n\t\tif (check_throttle_too_low()) {\n\t\t\treturn", "CodeBleu_score": 35.84641737768307}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// check if we are already armed\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the AHRS system\n\tif (ahrs.is_armed()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the RC system\n\tif (rc_input.is_armed()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the GPS system\n\tif (gps.is_armed()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the external system\n\tif (external_arm_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the magnetometer system\n\tif (mag_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the barometer system\n\tif (baro_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the optical flow system\n\tif (optflow_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the optical flow system\n\tif (optflow_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the optical flow system\n\tif (optflow_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the optical flow system\n\tif (optflow_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the optical flow system\n\tif (optflow_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the optical flow system\n\tif (optflow_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the optical flow system\n\tif (optflow_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the optical flow system\n\tif (optflow_check()) {\n\t\treturn true;\n\t}\n\n\t// check if we are already armed by the optical flow system", "CodeBleu_score": 28.198871470027758}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// first check if we are already armed\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// check if we are in manual mode\n\tif (is_manual()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in failsafe mode\n\tif (is_failsafe()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t\treturn false;\n\t}\n\n\t// check if we are in a transition state\n\tif (is_transitioning()) {\n\t", "CodeBleu_score": 21.903413228085995}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\tif (has_disarm_function) {\n\t\tif (disarm_button.is_configured()) {\n\t\t\tif (disarm_button.is_pressed()) {\n\t\t\t\tif (display_failure) {\n\t\t\t\t\tPX4_ERR(\"Disarming is not allowed\");\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 59.89232881427636}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\tif (has_disarm_function) {\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t}\n\n\tif (display_failure) {\n\t\tPX4_ERR(\"Disarm button not configured\");\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 60.576361482558205}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\tif (disarm_button.is_configured()) {\n\t\tif (display_failure) {\n\t\t\tPX4_ERR(\"Disarm button configured, but not armed\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 62.86821729334247}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tx = temp_x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n\ty = temp_x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n}", "CodeBleu_score": 41.0040255653913}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n\tfloat ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 64.97989391078337}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x, ne_y;\n\tne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n\tne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 59.483076025006795}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tmavlink_command_int_t packet_copy = packet;\n\tmavlink_command_int_t packet_copy_copy = packet_copy;\n\tmavlink_command_int_t packet_copy_copy_copy = packet_copy_copy;\n\tmavlink_command_int_t packet_copy_copy_copy_copy = packet_copy_copy_copy;\n\tmavlink_command_int_t packet_copy_copy_copy_copy_copy = packet_copy_copy_copy_copy;\n\tmavlink_command_int_t packet_copy_copy_copy_copy_copy_copy = packet_copy_copy_copy_copy_copy;\n\tmavlink_command_int_t packet_copy_copy_copy_copy_copy_copy_copy = packet_copy_copy_copy_copy_copy_copy;\n\tmavlink_command_int_t packet_copy_copy_copy_copy_copy_copy_copy_copy = packet_copy_copy_copy_copy_copy_copy_copy;\n\tmavlink_command_int_t packet_copy_copy_copy_copy_copy_copy_copy_copy_copy = packet_copy_copy_copy_copy_copy_copy_copy_copy;\n\tmavlink_command_int_t packet_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = packet_copy_copy_copy_copy_copy_copy_copy_copy_copy;\n\tmavlink_command_int_t packet_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = packet_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy;\n\tmavlink_command_int_t packet_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = packet_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy;\n\tmavlink_command_int_t packet_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = packet_copy_copy_copy_copy_copy_copy_copy_copy_copy", "CodeBleu_score": 10.311527574552972}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tmavlink_command_int_t packet_copy = packet;\n\tmavlink_command_int_t &packet_ref = packet_copy;\n\n\tmavlink_command_int_t::mavlink_command_int_t_mavlink_command_int_t_copy(packet, packet_copy);\n\tmavlink_command_int_t &packet_ref_copy = packet_copy;\n\n\tmavlink_command_int_t::mavlink_command_int_t_mavlink_command_int_t_copy(packet_ref, packet_ref_copy);\n\tmavlink_command_int_t &packet_ref_ref = packet_ref_copy;\n\n\tmavlink_command_int_t::mavlink_command_int_t_mavlink_command_int_t_copy(packet_ref_ref, packet_ref);\n\tmavlink_command_int_t &packet_ref_ref_copy = packet_ref;\n\n\tmavlink_command_int_t::mavlink_command_int_t_mavlink_command_int_t_copy(packet_ref_ref_copy, packet_ref_ref);\n\tmavlink_command_int_t &packet_ref_ref_ref = packet_ref_ref;\n\n\tmavlink_command_int_t::mavlink_command_int_t_mavlink_command_int_t_copy(packet_ref_ref_ref, packet_ref_ref);\n\tmavlink_command_int_t &packet_ref_ref_ref_copy = packet_ref_ref;\n\n\tmavlink_command_int_t::mavlink_command_int_t_mavlink_command_int_t_copy(packet_ref_ref_ref_copy, packet_ref_ref_ref);\n\tmavlink_command_int_t &packet_ref_ref_ref_ref = packet_ref_ref_ref;\n\n\tmavlink_command_int_t::mavlink_command_int_t_mavlink_command_int_t_copy(packet_ref_ref_ref_ref, packet_ref_ref_ref);\n\tmavlink_command_int_t &packet_ref_ref_ref_ref_copy =", "CodeBleu_score": 13.398914060351125}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if the yaw angle and param4 values are within acceptable ranges\n\tif (is_zero(packet.param1) || is_equal(packet.param1, 0.0f) || is_zero(packet.param4) || is_equal(packet.param4, 0.0f)) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading using the provided parameters\n\t_sub_mode_auto.set_auto_yaw_heading(packet.param1, packet.param4);\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 47.25973576721805}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tuint8_t ret = 0;\n\tif (control_mode() == MAV_MODE_AUTO || control_mode() == MAV_MODE_GUIDED) {\n\t\tret = (uint8_t) ((wp_bearing_to_destination() + 18000) % 36000 / 2);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 43.590994480081044}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (mavlink_sub_wp_nav.get_control_mode() == MAV_MODE_AUTO_ARMED || mavlink_sub_wp_nav.get_control_mode() == MAV_MODE_GUIDED_ARMED) {\n\t\treturn (uint8_t) (mavlink_sub_wp_nav.get_wp_nav().get_tgt_heading() / 2);\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 46.28083071484582}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == MAV_MODE_AUTO_ARMED || control_mode == MAV_MODE_GUIDED_ARMED) {\n\t\treturn (uint8_t) (wrap_360_cd(wp_bearing_cd / 2.0f));\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 36.189338640292426}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tLogPacketHeader header;\n\t\theader.timestamp = AP_HAL::micros64();\n\t\theader.log_data_id = id;\n\t\theader.value = value;\n\t\tlogger.WriteCriticalBlock(LOG_PACKET_HEADER_INIT, &header, sizeof(header));\n\t}\n}", "CodeBleu_score": 39.78814894898278}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tlogger.WriteCriticalBlock(Log_Packet_Header(id, value));\n\t}\n}", "CodeBleu_score": 19.34869673324176}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log) {\n\t\tLog_Packet_Header header;\n\t\theader.timestamp = AP_HAL::micros64();\n\t\theader.id = id;\n\t\theader.value = value;\n\t\tlogger.WriteCriticalBlock(header, sizeof(Log_Packet_Header));\n\t}\n}", "CodeBleu_score": 40.10618890444204}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (!ahrs.home_is_set) {\n\t\tif (motors.armed) {\n\t\t\tset_home_to_current_location_inflight();\n\t\t} else {\n\t\t\tset_home_to_current_location();\n\t\t}\n\t}\n}", "CodeBleu_score": 29.68989023886258}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set) return;\n\tif (motors.armed) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location();\n\t}\n}", "CodeBleu_score": 29.857837987234447}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set) {\n\t\treturn;\n\t}\n\tif (motors.armed) {\n\t\tset_home_to_current_location_inflight();\n\t\treturn;\n\t}\n\tif (set_home_to_current_location()) {\n\t\treturn;\n\t}\n}", "CodeBleu_score": 29.288546044391772}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tmotors.set_throttle_out(0);\n\t\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\tattitude_control->input_rate_bf_roll_pitch_yaw = get_pilot_desired_angle_rates();\n\tattitude_control->run();\n\tmotors.set_forward(channel_forward->norm_input);\n\tmotors.set_lateral(channel_lateral->norm_input);\n}", "CodeBleu_score": 35.79287627865509}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tmotors.set_throttle_out(0.0f);\n\t\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\tattitude_control->set_throttle_out(channel_throttle->norm_input);\n\tattitude_control->input_rate_bf_roll_pitch_yaw = get_pilot_desired_angle_rates();\n\tattitude_control->run();\n\tmotors.set_lateral(channel_lateral->norm_input);\n\tmotors.set_forward(channel_forward->norm_input);\n\tmotors.set_yaw(channel_yaw->norm_input);\n}", "CodeBleu_score": 40.777029649012725}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tmotors.set_throttle_out(0);\n\t\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\tattitude_control->input_rate_bf_roll_pitch_yaw(get_pilot_desired_angle_rates());\n\tattitude_control->run();\n\tmotors.set_lateral(channel_lateral->get_control_in());\n\tmotors.set_forward(channel_forward->get_control_in());\n\tmotors.set_yaw(channel_yaw->get_control_in());\n\tmotors.set_throttle_out(channel_throttle->get_control_in());\n}", "CodeBleu_score": 41.929152788335855}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set to position control mode\n\tset_mode(PX4_CUSTOM_MAIN_MODE_POSCTL, PX4_CUSTOM_SUB_MODE_POSCTL_MANUAL);\n\t// retrieve stopping point\n\tget_wp_stopping_point();\n\t// set as waypoint destination\n\tset_wp_destination();\n\t// initialize waypoint controller\n\twp_and_spline_init();\n\t// initialize yaw\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 13.949457088039589}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set mode to position control mode\n\tset_mode(MAV_MODE_FLAG_GUIDED_ENABLED, MAV_MODE_FLAG_SAFETY_ARMED);\n\n\t// retrieve the stopping point\n\tsub.wp_nav.get_wp_stopping_point();\n\n\t// set the waypoint destination as the stopping point\n\tsub.wp_nav.set_wp_destination(sub.wp_nav.wp_stopping_point);\n\n\t// initialize the waypoint controller\n\tsub.wp_nav.wp_and_spline_init();\n\n\t// set the yaw mode to the default yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 40.98625619288135}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\tif (current_state == MODE_GUIDED) {\n\t\treturn;\n\t}\n\n\tcurrent_state = MODE_GUIDED;\n\tset_mode(MODE_POSCTL);\n\twp_nav.set_wp_destination(wp_nav.get_wp_stopping_point());\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 33.08678491266068}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Initialize vertical max speeds and accelerations\n\tposition_control->set_max_speed_accel_z(param_get(param_v_max_speed), param_get(param_v_max_accel));\n\n\t// Initialize vertical velocity controller\n\tposition_control->init_z_controller();\n\n\t// Initialize horizontal velocity controller\n\tposition_control->init_xy_controller();\n\n\t// Set yaw control mode\n\tset_auto_yaw_mode();\n\n\t// Initialize speed correction\n\tposition_control->set_correction_speed_accel_z(0.0f, 0.0f);\n}", "CodeBleu_score": 40.523162809559615}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// TODO: Implement this function\n\t// Initialize the vertical maximum speeds and acceleration\n\tposition_control->set_max_speed_accel_z(param_max_z_speed, param_max_z_accel);\n\t// Initialize the vertical and horizontal velocity controllers\n\tposition_control->init_xy_controller();\n\t// Set the yaw control mode to AUTO_YAW_HOLD\n\tset_auto_yaw_mode();\n}", "CodeBleu_score": 23.705099477030274}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\tposition_control->set_max_speed_accel_z(1.0f, 1.0f);\n\tposition_control->init_z_controller();\n\tposition_control->set_correction_speed_accel_z(1.0f, 1.0f);\n\tposition_control->init_xy_controller();\n\tset_auto_yaw_mode();\n\tsub.get_pilot_speed_dn();\n}", "CodeBleu_score": 34.31096667422203}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// If the timeout has been exceeded, return true\n\tif (AP_HAL::millis() > guided_limit.timeout) {\n\t\treturn true;\n\t}\n\n\t// If the current altitude is below the minimum altitude limit, return true\n\tif (curr_pos.z < guided_limit.min_alt_cm) {\n\t\treturn true;\n\t}\n\n\t// If the current altitude is above the maximum altitude limit, return true\n\tif (curr_pos.z > guided_limit.max_alt_cm) {\n\t\treturn true;\n\t}\n\n\t// If the horizontal distance moved exceeds the maximum horizontal distance limit, return true\n\tif (get_horizontal_distance_cm() > guided_limit.max_dist_cm) {\n\t\treturn true;\n\t}\n\n\t// If we have reached this point, return false\n\treturn false;\n}", "CodeBleu_score": 30.733516256748107}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check for timeout\n\tif (AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout_ms) {\n\t\treturn true;\n\t}\n\n\t// Check altitude limits\n\tif (curr_pos.z < guided_limit.min_alt_m) {\n\t\treturn true;\n\t}\n\n\tif (curr_pos.z > guided_limit.max_alt_m) {\n\t\treturn true;\n\t}\n\n\t// Check horizontal distance moved\n\tif (get_horizontal_distance_cm() > guided_limit.max_dist_cm) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 34.05513821490737}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// If the timeout has been exceeded, return true.\n\tif (AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout_ms) {\n\t\treturn true;\n\t}\n\n\t// If the current altitude is below the minimum altitude threshold, return true.\n\tif (curr_pos.z < guided_limit.min_alt_cm) {\n\t\treturn true;\n\t}\n\n\t// If the current altitude is above the maximum altitude threshold, return true.\n\tif (curr_pos.z > guided_limit.max_alt_cm) {\n\t\treturn true;\n\t}\n\n\t// If the horizontal distance moved exceeds the maximum horizontal distance threshold, return true.\n\tif (get_horizontal_distance_cm() > guided_limit.max_horizontal_distance_cm) {\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false.\n\treturn false;\n}", "CodeBleu_score": 34.654728343800414}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tif (motor_test_requests_received < 10) {\n\t\treturn false;\n\t}\n\tif (motor_test_requests_received >= 10) {\n\t\tif (motor_test_requests_received >= 20) {\n\t\t\tif (motor_test_requests_received >= 30) {\n\t\t\t\tif (motor_test_requests_received >= 40) {\n\t\t\t\t\tif (motor_test_requests_received >= 50) {\n\t\t\t\t\t\tif (motor_test_requests_received >= 60) {\n\t\t\t\t\t\t\tif (motor_test_requests_received >= 70) {\n\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 80) {\n\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 90) {\n\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 100) {\n\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 110) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 120) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 130) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 140) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 150) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 160) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 170) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 180) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 190) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 200) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 210) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 220) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 230) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 240) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 250) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 260) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (motor_test_requests_received >= 270) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "CodeBleu_score": 22.228453336912853}, {"code": "bool Sub::verify_motor_test(){\n\t\tif (AP::arming().armed()) {\n\t\tif (AP::arming().disarmed()) {\n\t\t\tAP::arming().arm();\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (AP::arming().armed()) {\n\t\tif (AP::arming().disarmed()) {\n\t\t\tAP::arming().arm();\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (AP::arming().armed()) {\n\t\tif (AP::arming().disarmed()) {\n\t\t\tAP::arming().arm();\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (AP::arming().armed()) {\n\t\tif (AP::arming().disarmed()) {\n\t\t\tAP::arming().arm();\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (AP::arming().armed()) {\n\t\tif (AP::arming().disarmed()) {\n\t\t\tAP::arming().arm();\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (AP::arming().armed()) {\n\t\tif (AP::arming().disarmed()) {\n\t\t\tAP::arming().arm();\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (AP::arming().armed()) {\n\t\tif (AP::arming().disarmed()) {\n\t\t\tAP::arming().arm();\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (AP::arming().armed()) {\n\t\tif (AP::arming().disarmed()) {\n\t\t\tAP::arming().arm();\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (AP::arming().armed()) {\n\t\tif (AP::arming().disarmed()) {\n\t\t\tAP::arming().arm();\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (AP::arming().armed()) {\n\t\tif (AP::arming().disarmed()) {\n\t\t\tAP::arming().arm();\n\t\t}\n\t} else {\n\t", "CodeBleu_score": 26.861297115224325}, {"code": "bool Sub::verify_motor_test(){\n\t\t// If the motor test is not enabled, return true\n\tif (!motor_test_enabled) {\n\t\treturn true;\n\t}\n\t// If the motor test is not running, return true\n\tif (!motor_test_running) {\n\t\treturn true;\n\t}\n\t// If the motor test is running, check if the motor test has timed out\n\tif (motor_test_timeout_time < AP_HAL::millis()) {\n\t\t// Send a timeout message\n\t\tgcs.send_text(MAV_SEVERITY_WARNING, \"Motor test timed out\");\n\t\t// Set the pass flag to false\n\t\tmotor_test_pass = false;\n\t\t// Disable the motor test\n\t\tmotor_test_enabled = false;\n\t\t// Disarm the system\n\t\tAP::arming().disarm();\n\t\t// Record the failure time\n\t\tmotor_test_fail_time = AP_HAL::millis();\n\t\t// Return false\n\t\treturn false;\n\t}\n\t// If the motor test is running, check if the motor test requests have timed out\n\tif (motor_test_request_timeout_time < AP_HAL::millis()) {\n\t\t// Send a timeout message\n\t\tgcs.send_text(MAV_SEVERITY_WARNING, \"Motor test request timed out\");\n\t\t// Set the pass flag to false\n\t\tmotor_test_pass = false;\n\t\t// Disable the motor test\n\t\tmotor_test_enabled = false;\n\t\t// Disarm the system\n\t\tAP::arming().disarm();\n\t\t// Record the failure time\n\t\tmotor_test_fail_time = AP_HAL::millis();\n\t\t// Return false\n\t\treturn false;\n\t}\n\t// If the motor test is running, return true\n\treturn true;\n}", "CodeBleu_score": 54.96154813620814}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.get_roll() / 100.0;\n\tfloat pitch_target = wp_nav.get_pitch() / 100.0;\n\n\t// constrain the roll and pitch targets\n\troll_target = constrain_int16(roll_target, -1.0, 1.0);\n\tpitch_target = constrain_int16(pitch_target, -1.0, 1.0);\n\n\t// normalize the roll and pitch targets\n\troll_target = normalize_float(roll_target);\n\tpitch_target = normalize_float(pitch_target);\n\n\t// assign the normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 40.22224322687445}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.get_roll();\n\tfloat pitch_target = wp_nav.get_pitch();\n\tfloat roll_norm = constrain_int16(roll_target, -MAX_ROLL, MAX_ROLL);\n\tfloat pitch_norm = constrain_int16(pitch_target, -MAX_PITCH, MAX_PITCH);\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 35.882469202226105}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.get_roll();\n\tfloat pitch_target = wp_nav.get_pitch();\n\n\t// Constrain roll and pitch targets to the specified maximum angle range\n\tfloat roll_max = constrain_int16(roll_target, -1000, 1000);\n\tfloat pitch_max = constrain_int16(pitch_target, -1000, 1000);\n\n\t// Normalize roll and pitch targets\n\tfloat roll_norm = roll_max / 1000;\n\tfloat pitch_norm = pitch_max / 1000;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 37.07878151892393}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// Read the barometer's data\n\tbarometer.update();\n\t// Update the barometer's calibration if the altitude is above zero\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\t// Update the sensor's health status if a depth sensor is present\n\tif (depth_sensor.is_present()) {\n\t\tdepth_sensor.update_health();\n\t}\n}", "CodeBleu_score": 59.17109301041839}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer.update()) {\n\t\tif (barometer.get_altitude() > 0) {\n\t\t\tbarometer.update_calibration();\n\t\t}\n\t\tif (depth_sensor.healthy()) {\n\t\t\tdepth_sensor.update();\n\t\t}\n\t}\n}", "CodeBleu_score": 58.26246607547675}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (depth_sensor.is_present()) {\n\t\tbarometer.update();\n\t\tdepth_sensor.update();\n\t\tdepth_sensor.get_health();\n\t}\n}", "CodeBleu_score": 60.59933714287613}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\t// If inertial navigation is not available, it accepts a predicted horizontal position.\n\tif (!ahrs.have_inertial_nav) {\n\t\treturn true;\n\t}\n\n\t// If the motors are disarmed, it accepts a predicted horizontal position.\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\n\t// If the motors are armed, it requires a good absolute position and ensures the EKF is not in constant position mode.\n\tif (ahrs.have_inertial_nav && motors.armed &&!in_pos_hgt_mode &&!in_pos_hgt_mode_prev) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 25.57195741251971}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\n\tif (params.ekf2_pos_hgt_mode == EKF2_POS_HGT_MODE_PRED) {\n\t\treturn true;\n\t}\n\n\tif (params.ekf2_pos_hgt_mode == EKF2_POS_HGT_MODE_CONST) {\n\t\treturn false;\n\t}\n\n\tif (!in_air_mode) {\n\t\treturn false;\n\t}\n\n\tif (!ahrs.absolute_hgt_ok) {\n\t\treturn false;\n\t}\n\n\tif (ekf2_pos_hgt_status == EKF2_POS_HGT_STATUS_OK) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 28.60345705701687}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (ahrs.have_inertial_nav) {\n\t\tif (motors.armed) {\n\t\t\tif (ekf.healthy) {\n\t\t\t\tif (ekf.in_position_mode) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ekf.healthy) {\n\t\t\t\tif (ekf.in_position_mode) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 37.47196292981292}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!rover.control_mode->requires_position &&!rover.control_mode->requires_velocity) {\n\t\treturn true;\n\t}\n\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!ahrs.is_armed()) {\n\t\treturn false;\n\t}\n\n\tif (ekf.failsafe_active()) {\n\t\treturn false;\n\t}\n\n\tif (!rover.ekf_position_ok) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 34.781220668108254}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tbool gps_checks_passed = true;\n\n\tif (rover.control_mode->requires_position || rover.control_mode->requires_velocity) {\n\t\tif (!AP_Arming_Base::gps_checks(display_failure)) {\n\t\t\tgps_checks_passed = false;\n\t\t}\n\t}\n\n\tif (gps_checks_passed) {\n\t\tif (!rover.ahrs->is_healthy()) {\n\t\t\tif (display_failure) {\n\t\t\t\tAP_HAL::led_flash(AP_HAL::LED_RED, 1, 1000);\n\t\t\t}\n\t\t\tgps_checks_passed = false;\n\t\t}\n\t}\n\n\tif (gps_checks_passed) {\n\t\tif (!rover.ekf_position_ok) {\n\t\t\tif (display_failure) {\n\t\t\t\tAP_HAL::led_flash(AP_HAL::LED_RED, 1, 1000);\n\t\t\t}\n\t\t\tgps_checks_passed = false;\n\t\t}\n\t}\n\n\treturn gps_checks_passed;\n}", "CodeBleu_score": 39.23160735377442}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tbool gps_checks_passed = true;\n\n\t// Check that the AHRS system is ready\n\tif (!ahrs.is_ready()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::panic(\"AHRS not ready\");\n\t\t}\n\t\tgps_checks_passed = false;\n\t}\n\n\t// Check that the EKF is not in failsafe mode\n\tif (ekf_failsafe_active()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::panic(\"EKF failsafe active\");\n\t\t}\n\t\tgps_checks_passed = false;\n\t}\n\n\t// Check that the EKF position estimate is valid\n\tif (!ekf_position_ok()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::panic(\"EKF position estimate invalid\");\n\t\t}\n\t\tgps_checks_passed = false;\n\t}\n\n\t// Check that the current control mode requires position or velocity\n\tif (rover.control_mode->requires_position || rover.control_mode->requires_velocity) {\n\t\t// Call the parent class's GPS checks\n\t\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\t\tgps_checks_passed = false;\n\t\t}\n\t}\n\n\treturn gps_checks_passed;\n}", "CodeBleu_score": 41.53523522179704}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (do_arming_checks) {\n\t\tif (check_arming_checks()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// set the home position\n\tif (rover.g2.smart_rtl.set_home(rover.g2.smart_rtl.home_position)) {\n\t\t// set the simple mode heading\n\t\trover.mode_simple.init_heading();\n\n\t\t// record the home heading for sail vehicles\n\t\tif (rover.g2.windvane.record_home_heading()) {\n\t\t\t// update the soft armed status\n\t\t\tupdate_soft_armed();\n\n\t\t\t// send arm/disarm status text\n\t\t\tsend_arm_disarm_statustext();\n\n\t\t\t// return success\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// set arming failed event\n\trover.events.arming_failed();\n\n\t// return failure\n\treturn false;\n}", "CodeBleu_score": 43.658339742389785}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (do_arming_checks) {\n\t\tif (!check_arming_conditions()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// set the home location\n\tif (rover.g2.smart_rtl.set_home()) {\n\t\t// set the heading\n\t\tif (rover.mode_simple.init_heading()) {\n\t\t\t// record the home heading\n\t\t\tif (rover.g2.windvane.record_home_heading()) {\n\t\t\t\t// update the soft armed status\n\t\t\t\tupdate_soft_armed();\n\t\t\t\t// send an arm/disarm status text\n\t\t\t\tsend_arm_disarm_statustext();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.24332470836404}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (do_arming_checks) {\n\t\tif (!check_arming_conditions()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// set the home location to the current location\n\tif (rover.g2.smart_rtl.set_home()) {\n\t\t// if we have a windvane, record the home heading\n\t\tif (rover.g2.windvane.is_valid()) {\n\t\t\trover.g2.windvane.record_home_heading();\n\t\t}\n\n\t\t// initialize the simple mode heading\n\t\trover.mode_simple.init_heading();\n\n\t\t// update the soft armed status\n\t\trover.update_soft_armed();\n\n\t\t// send an arm/disarm status text\n\t\tsend_arm_disarm_statustext();\n\n\t\treturn true;\n\t} else {\n\t\t// set the arming failed event\n\t\tset_arming_failed_event();\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 43.30480422102351}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tif (millis() - charging_enabled_time > charging_enabled_delay) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_enabled_time = millis();\n\t\t\t\tdigitalWrite(CHARGE_ENABLE, LOW);\n\t\t\t\tSerial.println(\"Charging disabled\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (checkShouldCharge()) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_enabled_time = millis();\n\t\t\t\tdigitalWrite(CHARGE_ENABLE, HIGH);\n\t\t\t\tSerial.println(\"Charging enabled\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_enabled_time = millis();\n\t\t\tdigitalWrite(CHARGE_ENABLE, LOW);\n\t\t\tSerial.println(\"Charging disabled\");\n\t\t}\n\t}\n}", "CodeBleu_score": 60.1188253599438}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\t// Enable charging\n\t\t\tdigitalWrite(CHARGE_EN_PIN, HIGH);\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_disabled_time = millis();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\t// Disable charging\n\t\t\tdigitalWrite(CHARGE_EN_PIN, LOW);\n\t\t\tcharging_enabled = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.29407662831593}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!shouldCharge) {\n\t\t\tdisableCharging();\n\t\t}\n\t} else {\n\t\tif (shouldCharge) {\n\t\t\tenableCharging();\n\t\t}\n\t}\n}", "CodeBleu_score": 13.557857898508828}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok()) {\n\t\tif (size >= 4) {\n\t\t\tuint16_t crc = CRC16.ccitt((uint8_t*) message, size);\n\t\t\tuint8_t *crcBytes = (uint8_t*) &crc;\n\t\t\tuint8_t *messageBytes = (uint8_t*) message;\n\t\t\tuint8_t *crcMessage = new uint8_t[size + 2];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tcrcMessage[i] = messageBytes[i];\n\t\t\t}\n\t\t\tcrcMessage[size] = crcBytes[0];\n\t\t\tcrcMessage[size + 1] = crcBytes[1];\n\t\t\tpacketSerial.send(crcMessage, size + 2);\n\t\t}\n\t}\n}", "CodeBleu_score": 48.7568631374732}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::master::check()) {\n\t\tif (size >= 4) {\n\t\t\tuint16_t crc = CRC16.ccitt((uint8_t*)message, size);\n\t\t\tmemcpy((uint8_t*)message + size, &crc, 2);\n\t\t\tpacketSerial.send(message, size + 2);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.3356428629077}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok()) {\n\t\tif (size >= 4) {\n\t\t\tuint16_t crc = CRC16.ccitt(message, size - 2);\n\t\t\tmemcpy((uint8_t*) message + size - 2, (uint8_t*) &crc, 2);\n\t\t\tpacketSerial.send(message, size);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.0741856946365}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.begin(9600);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.flush();\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x7E);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0xFF);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x06);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x09);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x00);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x00);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x00);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x00);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0xEF);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.flush();\n\tSerial.println(\"MP3Sound::begin\");\n\tdelay(100);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x7E);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0xFF);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x06);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x09);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x00);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x00);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x00);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x00);\n\tSerial.println(\"MP3Sound::begin\");\n\tsoundSerial.write(0x00);\n\tSerial.println", "CodeBleu_score": 39.698038962669294}, {"code": "bool MP3Sound::begin(){\n\t\tif (soundSerial.begin(MP3_BAUD_RATE) == false) {\n\t\treturn false;\n\t}\n\tsoundSerial.flush();\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE, 0, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (sendCommand(CMD_PLAY_FOLDER_FILE,", "CodeBleu_score": 29.836903982264406}, {"code": "bool MP3Sound::begin(){\n\t\tif (soundSerial.available()) {\n\t\tsoundSerial.flush();\n\t}\n\tsoundSerial.begin(9600);\n\tdelay(100);\n\tsoundSerial.println(\"$$$\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100);\n\tsoundSerial.println(\"0,1\");\n\tdelay(100", "CodeBleu_score": 40.91354894317798}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (!isPlaying()) {\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n\treturn active_sounds.size();\n}", "CodeBleu_score": 37.34203673460257}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || isPlaying)\n\t\treturn active_sounds.size();\n\telse {\n\t\tisPlaying = true;\n\t\tactive_sounds.back().play();\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 42.30276175282779}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || isPlaying) {\n\t\treturn active_sounds.size();\n\t}\n\tMP3Sound *mp3 = active_sounds.back();\n\tactive_sounds.pop_back();\n\tmp3->play();\n\treturn active_sounds.size();\n}", "CodeBleu_score": 40.633046772067985}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    wb_abstract_camera_cleanup(d);\n    wb_abstract_camera_setup(d, r);\n    return true;\n  }\n#endif\n  return false;\n}", "CodeBleu_score": 20.886072583885102}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tWbAbstractCamera *camera = (WbAbstractCamera *)d;\n\n\tswitch (command) {\n\t\tcase C_CAMERA_MEMORY_MAPPED_FILE:\n\t\t\tif (camera->memory_mapped_file!= NULL) {\n\t\t\t\twb_abstract_camera_cleanup_memory_mapped_file(camera);\n\t\t\t}\n\t\t\treturn wb_abstract_camera_setup_memory_mapped_file(camera, r);\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}", "CodeBleu_score": 34.94640997548204}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tswitch (command) {\n\t\tcase C_CAMERA_MEMORY_MAPPED_FILE:\n\t\t\twb_abstract_camera_cleanup(d);\n\t\t\treturn wb_abstract_camera_setup(d, r);\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}", "CodeBleu_score": 30.111448542027556}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint height;\n\tif (d == NULL)\n\t\treturn -1;\n\trobot_mutex_lock\n\theight = d->abstract_camera.height;\n\trobot_mutex_unlock\n\treturn height;\n}", "CodeBleu_score": 15.34767165195764}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef ROBOT_HAS_ABSTRACT_CAMERA\n  int height = -1;\n  if (d->abstract_camera) {\n    robot_mutex_lock(d->abstract_camera->mutex);\n    height = d->abstract_camera->height;\n    robot_mutex_unlock(d->abstract_camera->mutex);\n  }\n  return height;\n#else\n  return -1;\n#endif\n}", "CodeBleu_score": 42.55354583522748}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint height;\n\n\trobot_mutex_lock\n\theight = d->abstract_camera_data->height;\n\trobot_mutex_unlock\n\n\treturn height;\n}", "CodeBleu_score": 14.06074543681917}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period = 0;\n\trobot_mutex_lock\n\tif\n\t(\n\taccelerometer_get_struct\n\t)\n\tsampling_period = accelerometer_get_struct\n->\nsampling_period\n;\nelse\nprintf\n(\n\"Error\n:\nthe\ndevice\ntag\n%\nd\nis\ninvalid\n\\\nn\n\"\ntag\n)\n;\nrobot_mutex_unlock\nreturn\nsampling_period\n;\n}", "CodeBleu_score": 23.705818608718683}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tRobot *robot = robot_mutex_lock();\n\tAccelerometer *accelerometer = accelerometer_get_struct(tag);\n\tif (accelerometer) {\n\t\tsampling_period = accelerometer->sampling_period;\n\t} else {\n\t\tprintf(\"Error: invalid accelerometer tag\n\");\n\t\tsampling_period = 0;\n\t}\n\trobot_mutex_unlock(robot);\n\treturn sampling_period;\n}", "CodeBleu_score": 43.6554969243586}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tWbAccelerometer *accelerometer;\n\tint sampling_period;\n\n\trobot_mutex_lock\n\taccelerometer = get_accelerometer_struct(tag);\n\tif (accelerometer == NULL) {\n\t\tprintf(\"Error\n:\nwb_accelerometer_get_sampling_period\n:\ninvalid device tag\n\");\n\t\trobot_mutex_unlock\n\t\treturn 0;\n\t}\n\tsampling_period = accelerometer->sampling_period;\n\trobot_mutex_unlock\n\treturn sampling_period;\n}", "CodeBleu_score": 22.477589823113576}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 39.245249918562564}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = dmsString;\n\tfree(dmsString);\n\treturn result;\n}", "CodeBleu_score": 44.274301524571534}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *degreesMinutesSeconds = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = degreesMinutesSeconds;\n\tfree(degreesMinutesSeconds);\n\treturn result;\n}", "CodeBleu_score": 45.072946881320426}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT(g->type == dBoxClass, \"geom is not a box\");\n\tdGeomBoxData *box = (dGeomBoxData *)g->data;\n\tdVector3 relpos;\n\tdReal dist;\n\tdReal min, max;\n\tdReal *boxsize = box->boxsize;\n\tdReal *boxpos = box->boxpos;\n\tdReal *boxnormal = box->boxnormal;\n\tdReal *boxdist = box->boxdist;\n\tdReal *boxplanes = box->boxplanes;\n\tdReal *boxplanes2 = box->boxplanes2;\n\tdReal *boxplanes3 = box->boxplanes3;\n\tdReal *boxplanes4 = box->boxplanes4;\n\tdReal *boxplanes5 = box->boxplanes5;\n\tdReal *boxplanes6 = box->boxplanes6;\n\tdReal *boxplanes7 = box->boxplanes7;\n\tdReal *boxplanes8 = box->boxplanes8;\n\tdReal *boxplanes9 = box->boxplanes9;\n\tdReal *boxplanes10 = box->boxplanes10;\n\tdReal *boxplanes11 = box->boxplanes11;\n\tdReal *boxplanes12 = box->boxplanes12;\n\tdReal *boxplanes13 = box->boxplanes13;\n\tdReal *boxplanes14 = box->boxplanes14;\n\tdReal *boxplanes15 = box->boxplanes15;\n\tdReal *boxplanes16 = box->boxplanes16;\n\tdReal *boxplanes17 = box->boxplanes17;\n\tdReal *boxplanes18 = box->boxplanes18;\n\tdReal *boxplanes19 = box->boxplanes19;\n\tdReal *boxplanes20 = box->boxplanes20;\n\tdReal *boxplanes21 = box->boxplanes21;\n\tdReal *boxplanes22 = box->boxplanes22;\n\tdReal *boxplanes23 = box->boxplanes23;\n\tdReal *boxplanes24 = box->boxplanes24;\n\tdReal *boxplanes25 = box", "CodeBleu_score": 18.987104002715846}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdGeomBoxData *data = (dGeomBoxData *)dGeomGetData (g);\n\tdUASSERT (data!= NULL, \"dGeomBoxGetTangentPlane: NULL geom\");\n\tdUASSERT (data->type == dBoxClass, \"dGeomBoxGetTangentPlane: not a box\");\n\tdUASSERT (plane!= NULL, \"dGeomBoxGetTangentPlane: NULL plane\");\n\tdVector3 center;\n\tdGeomBoxGetPosition (g, center);\n\tdReal dx = x - center[0];\n\tdReal dy = y - center[1];\n\tdReal dz = z - center[2];\n\tdReal min = dFabs (dx);\n\tdReal max = dFabs (dx);\n\tdReal min_axis = 0;\n\tdReal max_axis = 0;\n\tif (min > dy) {\n\t\tmin = dy;\n\t\tmin_axis = 1;\n\t} else {\n\t\tmax = dy;\n\t\tmax_axis = 1;\n\t}\n\tif (min > dz) {\n\t\tmin = dz;\n\t\tmin_axis = 2;\n\t} else {\n\t\tmax = dz;\n\t\tmax_axis = 2;\n\t}\n\tplane[0] = 0;\n\tplane[1] = 0;\n\tplane[2] = 0;\n\tplane[3] = 0;\n\tif (min_axis == 0) {\n\t\tplane[0] = (dx < 0)? -1 : 1;\n\t} else if (min_axis == 1) {\n\t\tplane[1] = (dy < 0)? -1 : 1;\n\t} else {\n\t\tplane[2] = (dz < 0)? -1 : 1;\n\t}\n\tplane[3] = -dCalcVectorDot3_41 (center, plane);\n}", "CodeBleu_score": 37.350095428060996}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdGeomBoxData *box;\n\tdReal dx, dy, dz, d;\n\tdVector3 normal;\n\n\tdUASSERT (dGeomGetClass (g) == dBoxClass, \"not a box\");\n\tbox = (dGeomBoxData *) dGeomGetData (g);\n\tdx = x - box->pos[0];\n\tdy = y - box->pos[1];\n\tdz = z - box->pos[2];\n\td = dFabs (dx);\n\tif (d > box->size[0]) {\n\t\tif (dx < 0) {\n\t\t\tnormal[0] = -1;\n\t\t} else {\n\t\t\tnormal[0] = 1;\n\t\t}\n\t} else {\n\t\tnormal[0] = 0;\n\t}\n\td = dFabs (dy);\n\tif (d > box->size[1]) {\n\t\tif (dy < 0) {\n\t\t\tnormal[1] = -1;\n\t\t} else {\n\t\t\tnormal[1] = 1;\n\t\t}\n\t} else {\n\t\tnormal[1] = 0;\n\t}\n\td = dFabs (dz);\n\tif (d > box->size[2]) {\n\t\tif (dz < 0) {\n\t\t\tnormal[2] = -1;\n\t\t} else {\n\t\t\tnormal[2] = 1;\n\t\t}\n\t} else {\n\t\tnormal[2] = 0;\n\t}\n\tdCalcVectorDot3_41 (d, normal, normal);\n\tplane[0] = normal[0];\n\tplane[1] = normal[1];\n\tplane[2] = normal[2];\n\tplane[3] = d - normal[0] * box->pos[0] - normal[1] * box->pos[1] - normal[2] * box->pos[2];\n}", "CodeBleu_score": 28.959610951909443}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n// dUASSERT(box, \"dImmerseBox: box is NULL\");\n// dUASSERT(fluidPlane, \"dImmerseBox: fluidPlane is NULL\");\n// dUASSERT(immersion, \"dImmerseBox: immersion is NULL\");\n// dUASSERT(box->body, \"dImmerseBox: box has no body\");\n// dUASSERT((flags & dIMMERSE_BOX_FLAGS_MASK) == flags,\n// \"dImmerseBox: flags are invalid\");\n\ndImmersionData data;\ndata.box = box;\ndata.fluidPlane = fluidPlane;\ndata.immersion = immersion;\ndata.flags = flags;\n\nreturn dPerformImmersionChecking (&data);\n}", "CodeBleu_score": 42.92625879850754}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tsBoxImmersionData data;\n\n\tdUASSERT (box!= NULL, \"dImmerseBox: box is NULL\");\n\tdUASSERT (fluidPlane!= NULL, \"dImmerseBox: fluidPlane is NULL\");\n\tdUASSERT (immersion!= NULL, \"dImmerseBox: immersion is NULL\");\n\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\n\tdPerformImmersionChecking (&data);\n\n\treturn data.result;\n}", "CodeBleu_score": 44.12315156895661}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdUASSERT (box!= NULL, \"dImmerseBox: NULL box\");\n\tdUASSERT (fluidPlane!= NULL, \"dImmerseBox: NULL fluidPlane\");\n\tdUASSERT (flags >= 0, \"dImmerseBox: invalid flags\");\n\tdUASSERT (immersion!= NULL, \"dImmerseBox: NULL immersion\");\n\tdUASSERT (box->body!= NULL, \"dImmerseBox: box has no body\");\n\tdUASSERT (box->body->fluid, \"dImmerseBox: box has no fluid\");\n\tdUASSERT (box->body->fluid->type == dFluidBox, \"dImmerseBox: box has no fluid\");\n\tdUASSERT (box->body->fluid->flags & flags, \"dImmerseBox: box has no fluid\");\n\n\tdReal *p = box->body->fluid->p;\n\tdReal *n = box->body->fluid->n;\n\n\tdReal boxPos[3];\n\tdReal boxVel[3];\n\tdReal boxAngVel[3];\n\n\tdBodyGetPosition (box->body, boxPos);\n\tdBodyGetLinearVel (box->body, boxVel);\n\tdBodyGetAngularVel (box->body, boxAngVel);\n\n\tdReal boxInertia[12];\n\tdBodyGetInertia (box->body, boxInertia);\n\n\tdReal boxInertiaInv[12];\n\tdReal boxInertiaInvDiag[6];\n\tdReal boxInertiaInvDiagSqrt[6];\n\tdReal boxInertiaInvDiagSqrtInv[6];\n\n\tdBodyGetInertiaInv (box->body, boxInertiaInv);\n\tdBodyGetInertiaInvDiag (box->body, boxInertiaInvDiag);\n\tdBodyGetInertiaInvDiagSqrt (box->body, boxInertiaInvDiagSqrt);\n\tdBodyGetInertiaInvDiagSqrtInv (box->body, boxInertiaInvDiagSqrtInv);\n\n\tdReal boxInertiaInvDiagSqrtInvDiag[3];\n\tdReal boxInertiaInvDiagSqrtInvDiagSqrt[3];\n\tdReal boxInertiaInvDiagSqrtInvDiagSqrtInv[3];\n\n\tdBodyGetInertiaInvDiag", "CodeBleu_score": 37.585847784262825}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (0, o1->type == dBoxClass)\n\tdUASSERT (0, o2->type == dCapsuleClass)\n\tdUASSERT (0, immersion)\n\tdUASSERT (0, flags == dGeomGetImmersionFlags (o1, o2))\n\tdUASSERT (0, dGeomGetImmersionFlags (o1, o2) == dGeomGetImmersionFlags (o2, o1))\n\n\tif (dGeomGetImmersionFlags (o1, o2) & dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, dGeomGetImmersionFlags (o1, o2, d", "CodeBleu_score": 25.157409903571626}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (immersion);\n\tdIASSERT (immersion->immersionPlane);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->pos);\n\tdIASSERT (immersion->immersionPlane->pos2);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->immersionPlane->normal);\n\tdIASSERT (immersion->imm", "CodeBleu_score": 15.955496606672048}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdVector3 pos1, pos2;\n\tdMatrix3 R1, R2;\n\tdReal l1, l2;\n\tdReal r1, r2;\n\tdReal r12;\n\tdReal r122;\n\tdReal r1222;\n\tdReal r12222;\n\tdReal r122222;\n\tdReal r1222222;\n\tdReal r12222222;\n\tdReal r122222222;\n\tdReal r1222222222;\n\tdReal r12222222222;\n\tdReal r122222222222;\n\tdReal r1222222222222;\n\tdReal r12222222222222;\n\tdReal r122222222222222;\n\tdReal r1222222222222222;\n\tdReal r12222222222222222;\n\tdReal r122222222222222222;\n\tdReal r1222222222222222222;\n\tdReal r12222222222222222222;\n\tdReal r122222222222222222222;\n\tdReal r1222222222222222222222;\n\tdReal r12222222222222222222222;\n\tdReal r122222222222222222222222;\n\tdReal r1222222222222222222222222;\n\td", "CodeBleu_score": 4.740257461418977}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal zI = zIOverR * r;\n\tdReal zJ = zI + r;\n\tdReal zK = zJ + r;\n\n\tdReal theta0 = atan2(zI, r);\n\tdReal theta1 = atan2(zJ, r);\n\tdReal theta2 = atan2(zK, r);\n\n\tdReal theta01 = theta1 - theta0;\n\tdReal theta12 = theta2 - theta1;\n\n\tdReal sinTheta01 = sin(theta01);\n\tdReal sinTheta12 = sin(theta12);\n\n\tdReal volume = 0;\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(zI, zJ, tanTheta0, sinTheta01);\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(zJ, zK, tanTheta0, sinTheta12);\n\tvolume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(zK, zI, tanTheta0, sinTheta01);\n\treturn volume;\n}", "CodeBleu_score": 53.27626349133726}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal zI = zIOverR * r;\n\tdReal z1 = zI + r;\n\tdReal z2 = zI - r;\n\tdReal z3 = zI + 2.0 * r;\n\tdReal z4 = zI - 2.0 * r;\n\n\tdReal volume1 = (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z1 - zI) * (z", "CodeBleu_score": 20.251429652679168}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal result = 0.0;\n\n\tif (zIOverR > 0.0) {\n\t\tdReal zIOverR_squared = zIOverR * zIOverR;\n\t\tdReal zIOverR_cubed = zIOverR_squared * zIOverR;\n\t\tdReal zIOverR_fourth = zIOverR_squared * zIOverR_squared;\n\t\tdReal zIOverR_fifth = zIOverR_squared * zIOverR_squared * zIOverR;\n\t\tdReal zIOverR_sixth = zIOverR_squared * zIOverR_squared * zIOverR_squared * zIOverR;\n\n\t\tdReal zIOverR_fifth_over_four = zIOverR_fifth / 4.0;\n\t\tdReal zIOverR_sixth_over_six = zIOverR_sixth / 6.0;\n\n\t\tdReal zIOverR_cubed_over_six = zIOverR_cubed / 6.0;\n\t\tdReal zIOverR_fourth_over_four = zIOverR_fourth / 4.0;\n\t\tdReal zIOverR_fifth_over_four = zIOverR_fifth / 4.0;\n\t\tdReal zIOverR_sixth_over_six = zIOverR_sixth / 6.0;\n\n\t\tdReal zIOverR_fifth_over_four_over_six = zIOverR_fifth_over_four / 6.0;\n\t\tdReal zIOverR_sixth_over_six_over_four = zIOverR_sixth_over_six / 4.0;\n\n\t\tdReal zIOverR_cubed_over_six_over_four = zIOverR_cubed_over_six / 4.0;\n\n\t\tdReal zIOverR_cubed_over_six_over_four_over_six = zIOverR_cubed_over_six_over_four / 6.0;\n\n\t\tdReal zIOverR_fifth_over_four_over", "CodeBleu_score": 33.948425878817304}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tsHemisphereIntegrationData data(zIOverR, tanTheta0, sinTheta1);\n\treturn (volume * (dReal) (1.0 / 3.0) * simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(data));\n}", "CodeBleu_score": 35.33546865685909}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tsHemisphereIntegrationData integrationData(zIOverR, tanTheta0, sinTheta1, volume);\n\treturn sSimpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>::integrate(integrationData);\n}", "CodeBleu_score": 28.744283969014983}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tsHemisphereIntegrationData hemisphereIntegrationData;\n\themisphereIntegrationData.zIOverR = zIOverR;\n\themisphereIntegrationData.tanTheta0 = tanTheta0;\n\themisphereIntegrationData.sinTheta1 = sinTheta1;\n\themisphereIntegrationData.volume = volume;\n\n\treturn sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(hemisphereIntegrationData);\n}", "CodeBleu_score": 40.641091441327404}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tint i, j, k;\n\tint num_triangles;\n\tint num_vertices;\n\tint num_indices;\n\tint num_indices_per_triangle;\n\tint num_vertices_per_triangle;\n\tint num_vertices_per_triangle_per_side;\n\tint num_indices_per_triangle_per_side;\n\tint num_vertices_per_triangle_per_side_per_vertex;\n\tint num_indices_per_triangle_per_side_per_vertex;\n\tint num_vertices_per_triangle_per_side_per_vertex_per_side;\n\tint num_indices_per_triangle_per_side_per_vertex_per_side;\n\tint num_vertices_per_triangle_per_side_per_vertex_per_side_per_vertex;\n\tint num_indices_per_triangle_per_side_per_vertex_per_side_per_vertex;\n\tint num_vertices_per_triangle_per_side_per_vertex_per_side_per_vertex_per_side;\n\tint num_indices_per_triangle_per_side_per_vertex_per_side_per_vertex_per_side;\n\tint num_vertices_per_triangle_per_side_per_vertex_per_side_per_vertex_per_side_per_vertex;\n\tint num_indices_per_triangle_per_side_per_vertex_per_side_per_vertex_per_side_per_vertex;\n\tint num_vertices_per_triangle_per_side_per_vertex_per_side_per_vertex_per_side_per_vertex_per_side;\n\tint num_indices_per_triangle_per_side_per_vertex_per_side_per_vertex_per_side_per_vertex_per_side;\n\tint num_vertices_per_triangle_per_side_per_vertex_per_side_per_vertex_per_side_per_vertex_per_side_per_vertex;\n\tint num_indices_per_triangle_per_side_per_vertex_per_side_per_vertex_per_side_per_vertex_per_side_per", "CodeBleu_score": 4.601746336149964}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (o1->type == dCapsuleClass, \"dImmerseCapsuleTrimesh: o1 is not a capsule\");\n\tdUASSERT (o2->type == dTriMeshClass, \"dImmerseCapsuleTrimesh: o2 is not a trimesh\");\n\tdUASSERT (immersion->type == dCapsuleImmersionClass, \"dImmerseCapsuleTrimesh: immersion is not a capsule immersion\");\n\tdUASSERT (immersion->capsuleImmersionData->immersedHemisphereXBuoyancyCenter, \"dImmerseCapsuleTrimesh: immersion->capsuleImmersionData->immersedHemisphereXBuoyancyCenter is NULL\");\n\n\tdCapsuleImmersionData *capsuleImmersionData = immersion->capsuleImmersionData;\n\tdCapsuleData *capsuleData = (dCapsuleData *) o1;\n\tdTriMeshData *triMeshData = (dTriMeshData *) o2;\n\n\tdVector3 immersedHemisphereXBuoyancyCenter;\n\tdVector3 capsuleImmersionPlane;\n\tdVector3 capsuleImmersionPlaneNormal;\n\tdVector3 capsuleImmersionPlanePoint;\n\tdVector3 capsuleImmersionPlanePoint2;\n\tdVector3 capsuleImmersionPlanePoint3;\n\tdVector3 capsuleImmersionPlanePoint4;\n\tdVector3 capsuleImmersionPlanePoint5;\n\tdVector3 capsuleImmersionPlanePoint6;\n\tdVector3 capsuleImmersionPlanePoint7;\n\tdVector3 capsuleImmersionPlanePoint8;\n\tdVector3 capsuleImmersionPlanePoint9;\n\tdVector3 capsuleImmersionPlanePoint10;\n\tdVector3 capsuleImmersionPlanePoint11;\n\tdVector3 capsuleImmersionPlanePoint12;\n\tdVector3 capsuleImmersionPlanePoint13;\n\tdVector3 capsuleImmersionPlanePoint14;\n\tdVector3 capsuleImmersionPlanePoint15;\n\tdVector3 capsuleImmersionPlanePoint16;\n\tdVector3 capsuleImmersionPlanePoint17;\n\tdVector3 capsuleImmersionPlanePoint18;\n", "CodeBleu_score": 27.729060720820435}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (immersion, \"dImmerseCapsuleTrimesh: immersion is NULL\");\n\tdUASSERT (immersion->capsuleImmersionData, \"dImmerseCapsuleTrimesh: immersion->capsuleImmersionData is NULL\");\n\tdUASSERT (immersion->capsuleImmersionData->trimeshImmersionData, \"dImmerseCapsuleTrimesh: immersion->capsuleImmersionData->trimeshImmersionData is NULL\");\n\tdUASSERT (immersion->capsuleImmersionData->trimeshImmersionData->trimesh, \"dImmerseCapsuleTrimesh: immersion->capsuleImmersionData->trimeshImmersionData->trimesh is NULL\");\n\tdUASSERT (immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data, \"dImmerseCapsuleTrimesh: immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data is NULL\");\n\tdUASSERT (immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data->d, \"dImmerseCapsuleTrimesh: immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data->d is NULL\");\n\tdUASSERT (immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data->d->g, \"dImmerseCapsuleTrimesh: immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data->d->g is NULL\");\n\tdUASSERT (immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data->d->g->geom, \"dImmerseCapsuleTrimesh: immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data->d->g->geom is NULL\");\n\tdUASSERT (immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data->d->g->body, \"dImmerseCapsuleTrimesh: immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data->d->g->body is NULL\");\n\tdUASSERT (immersion->capsuleImmersionData->trimeshImmersionData->trimesh->data", "CodeBleu_score": 19.57658446845586}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get the sleep duration from the input\n\tauto sleep_duration = this->getInput<std::chrono::milliseconds>(\"sleep_duration\");\n\n\t// Check if the sleep duration is valid\n\tif (!sleep_duration) {\n\t\tsetStatus(NodeStatus::SUCCESS);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start the timer\n\ttimer_.start(sleep_duration.get());\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_.setCallback([this]() {\n\t\temitWakeUpSignal();\n\t});\n\n\t// Reset the timer_waiting_ flag\n\ttimer_waiting_ = false;\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 45.4777032113227}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (!getSleepDuration(timer_.duration)) {\n\t\tsetStatus(NodeStatus::SUCCESS);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tsetStatus(NodeStatus::RUNNING);\n\ttimer_.start();\n\ttimer_.add(timer_waiting_);\n\ttimer_.setCallback(std::bind(&SleepNode::emitWakeUpSignal, this));\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 38.06536853298405}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// get the sleep duration from the input\n\tconst auto sleep_duration = getInput<std::chrono::milliseconds>(\"sleep_duration\");\n\n\t// check if the duration is valid\n\tif (sleep_duration <= std::chrono::milliseconds(0)) {\n\t\tsetStatus(NodeStatus::SUCCESS);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// start the timer\n\ttimer_.start(sleep_duration);\n\n\t// set the callback to emit a wake-up signal when the timer expires\n\ttimer_.setCallback([this] {\n\t\temitWakeUpSignal();\n\t});\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 44.46854550816379}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tauto entry = config().blackboard->getEntry(config().entry_name);\n\tif (entry == nullptr) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tentry->lock();\n\tif (entry->getSequenceID()!= config().last_sequence_id) {\n\t\tconfig().last_sequence_id = entry->getSequenceID();\n\t\tentry->unlock();\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tentry->unlock();\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 41.46533250657744}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tstd::string entryName = config().entryName;\n\tstd::string entryType = config().entryType;\n\tstd::string entryValue = config().entryValue;\n\tstd::string entrySequenceID = config().entrySequenceID;\n\n\t// Retrieve the entry and lock its mutex\n\tstd::shared_ptr<Entry> entry = blackboard->getEntry(entryName);\n\tif (!entry) {\n\t\t// If the entry is not found, return NodeStatus::FAILURE\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tstd::lock_guard<std::mutex> lock(entry->getMutex());\n\n\t// Compare the current sequence ID with the previously stored sequence ID\n\tif (entry->getSequenceID()!= entrySequenceID) {\n\t\t// If the IDs differ, update the stored sequence ID and return NodeStatus::SUCCESS\n\t\tentrySequenceID = entry->getSequenceID();\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// If the IDs are the same, return NodeStatus::FAILURE\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 46.270024873341285}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (this->config().blackboard->getEntry(this->config().entryName)!= nullptr) {\n\t\tthis->config().blackboard->getEntry(this->config().entryName)->lock();\n\t\tif (this->config().blackboard->getEntry(this->config().entryName)->getSequenceID()!= this->config().sequenceID) {\n\t\t\tthis->config().sequenceID = this->config().blackboard->getEntry(this->config().entryName)->getSequenceID();\n\t\t\tthis->config().blackboard->getEntry(this->config().entryName)->unlock();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t\tthis->config().blackboard->getEntry(this->config().entryName)->unlock();\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 12.097682784485094}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (successThreshold_ < 0) {\n\t\treturn (children_nodes_.size() + successThreshold_ + 1);\n\t}\n\treturn successThreshold_;\n}", "CodeBleu_score": 49.44523047119244}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (successThreshold_ < 0) {\nreturn (size_t) std::max(0, (int) (children_nodes_.size() * successThreshold_));\n}\nreturn (size_t) successThreshold_;\n}", "CodeBleu_score": 52.29214155730961}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold_ < 0) {\nreturn static_cast<size_t>(-success_threshold_ * children_nodes_.size());\n} else {\nreturn static_cast<size_t>(success_threshold_);\n}\n}", "CodeBleu_score": 58.20379005229067}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\tif (heartbeatStatus!= lastHeartbeatStatus) {\n\t\t\tenableAllHooks();\n\t\t\tlastHeartbeatStatus = heartbeatStatus;\n\t\t}\n\t}\n}", "CodeBleu_score": 24.36398221439495}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\tif (this->lastHeartbeatTime.load() == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tauto now = std::chrono::system_clock::now();\n\t\tauto elapsed = now - this->lastHeartbeatTime;\n\t\tauto milliseconds = std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count();\n\n\t\tif (milliseconds > this->heartbeatTimeout) {\n\t\t\tthis->lastHeartbeatTime = 0;\n\t\t\tthis->heartbeatStatus = false;\n\n\t\t\tthis->enableAllHooks(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 42.761315292803445}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\tstd::chrono::time_point<std::chrono::system_clock> lastHeartbeat = std::chrono::system_clock::now();\n\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::chrono::time_point<std::chrono::system_clock> now = std::chrono::system_clock::now();\n\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(now - lastHeartbeat).count() > 10000) {\n\t\t\tif (isHeartbeatActive) {\n\t\t\t\tdisableAllHooks();\n\t\t\t\tisHeartbeatActive = false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isHeartbeatActive) {\n\t\t\t\tenableAllHooks();\n\t\t\t\tisHeartbeatActive = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.63925944934547}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\tstd::vector<std::string> blackboards;\n\tBT::splitString(bb_list, blackboards, \",\");\n\tfor (std::string& bb : blackboards) {\n\t\tstd::string bb_name = bb;\n\t\tif (bb_name.size() > 0 && bb_name[0] == '\"') {\n\t\t\tbb_name = bb_name.substr(1, bb_name.size() - 2);\n\t\t}\n\t\tauto it = _p->subtrees.find(bb_name);\n\t\tif (it!= _p->subtrees.end()) {\n\t\t\tstd::lock_guard<std::mutex> lock(it->second.lock);\n\t\t\tif (it->second.valid) {\n\t\t\t\tnlohmann::json json;\n\t\t\t\tExportBlackboardToJSON(json, it->second.blackboard);\n\t\t\t\tresult.insert(result.end(), json.dump().begin(), json.dump().end());\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 50.27984752245123}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\tstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\tfor (const std::string& bb_name : bb_names) {\n\t\tstd::string bb_name_trimmed = trim(bb_name);\n\t\tif (bb_name_trimmed.empty()) {\n\t\t\tcontinue;\n\t\t}\n\t\tauto it = _p->subtrees.find(bb_name_trimmed);\n\t\tif (it!= _p->subtrees.end()) {\n\t\t\tstd::lock_guard<std::mutex> lock(it->second.lock);\n\t\t\tif (it->second.valid) {\n\t\t\t\tnlohmann::json json_bb = ExportBlackboardToJSON(it->second.blackboard);\n\t\t\t\tresult.insert(result.end(), json_bb.dump().begin(), json_bb.dump().end());\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 51.77461796715497}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\tstd::vector<std::string> bb_names;\n\tBT::splitString(bb_list, bb_names, \",\");\n\tfor (auto const& bb_name : bb_names) {\n\t\tstd::string bb_name_trimmed = bb_name;\n\t\tif (bb_name_trimmed.find_first_of(' ')!= std::string::npos) {\n\t\t\tbb_name_trimmed.erase(bb_name_trimmed.find_first_of(' '));\n\t\t}\n\t\tstd::string bb_name_lower = bb_name_trimmed;\n\t\tstd::transform(bb_name_lower.begin(), bb_name_lower.end(), bb_name_lower.begin(), ::tolower);\n\t\tauto it = _p->subtrees.find(bb_name_lower);\n\t\tif (it!= _p->subtrees.end()) {\n\t\t\tstd::lock_guard<std::mutex> lk(it->second.lock);\n\t\t\tif (it->second.valid) {\n\t\t\t\tnlohmann::json j;\n\t\t\t\tExportBlackboardToJSON(j, it->second.blackboard);\n\t\t\t\tstd::vector<uint8_t> bb_msgpack;\n\t\t\t\tnlohmann::json::to_msgpack(j, bb_msgpack);\n\t\t\t\tresult.insert(result.end(), bb_msgpack.begin(), bb_msgpack.end());\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 48.54355385796725}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::unique_lock<std::mutex> lk(_p->nodes_by_uid_mutex);\n\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif (it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\tNode* node = it->second.get();\n\tlk.unlock();\n\tif (node->is_valid()) {\n\t\tHook* hook = node->getHook();\n\t\tstd::unique_lock<std::mutex> lk2(hook->wakeup);\n\t\tif (hook->mode == HookMode::BREAKPOINT) {\n\t\t\thook->status = result;\n\t\t\thook->remove = remove;\n\t\t\thook->ready = true;\n\t\t\thook->wakeup.notify_all();\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 61.630713702136084}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::lock_guard<std::mutex> lk(_p->nodes_by_uid_mutex);\n\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif (it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\tNode *node = it->second.get();\n\tif (node->getStatus()!= NodeStatus::BREAKPOINT) {\n\t\treturn false;\n\t}\n\tHook *hook = node->getHook();\n\tstd::lock_guard<std::mutex> lk2(hook->mutex);\n\tif (hook->mode!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->status = result;\n\thook->remove = remove;\n\thook->ready = true;\n\thook->wakeup.notify_all();\n\treturn true;\n}", "CodeBleu_score": 61.54596471160361}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::unique_lock<std::mutex> lk(_p->nodes_by_uid_mutex);\n\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif (it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\tauto& node = it->second;\n\tif (node.is_valid == false) {\n\t\treturn false;\n\t}\n\tauto hook = node.hook;\n\tlk.unlock();\n\tstd::unique_lock<std::mutex> lk2(hook->mutex);\n\tif (hook->status!= HookStatus::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->status = HookStatus::READY;\n\thook->result = result;\n\thook->remove = remove;\n\thook->wakeup.notify_all();\n\treturn true;\n}", "CodeBleu_score": 64.83646110276997}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\thalt_requested_ = false;\n\t\tstd::async(std::launch::async, [this]() {\n\t\t\ttry {\n\t\t\t\ttick();\n\t\t\t} catch (const std::exception& e) {\n\t\t\t\tstd::cerr << \"Exception caught in ThreadedAction::executeTick: \" << e.what() << std::endl;\n\t\t\t\tstd::cerr << \"Rethrowing exception...\" << std::endl;\n\t\t\t\tstd::rethrow_exception(std::current_exception());\n\t\t\t} catch (...) {\n\t\t\t\tstd::cerr << \"Unknown exception caught in ThreadedAction::executeTick\" << std::endl;\n\t\t\t}\n\t\t\tif (status == NodeStatus::RUNNING) {\n\t\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t\t}\n\t\t});\n\t\treturn status;\n\t}\n\tif (status == NodeStatus::RUNNING &&!halt_requested_) {\n\t\ttick();\n\t\treturn status;\n\t}\n\tif (status == NodeStatus::RUNNING && halt_requested_) {\n\t\tsetStatus(NodeStatus::IDLE);\n\t\treturn status;\n\t}\n\tif (status == NodeStatus::IDLE) {\n\t\treturn status;\n\t}\n\treturn status;\n}", "CodeBleu_score": 47.69253019780313}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status == NodeStatus::IDLE) {\n\t\tstatus = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::async(std::launch::async, &ThreadedAction::tick, this);\n\t}\n\tif (status == NodeStatus::RUNNING &&!halt_requested_) {\n\t\tstatus = NodeStatus::RUNNING;\n\t}\n\tif (status == NodeStatus::RUNNING && halt_requested_) {\n\t\tstatus = NodeStatus::IDLE;\n\t}\n\tif (status == NodeStatus::RUNNING && std::exception_ptr eptr = std::current_exception()) {\n\t\tstatus = NodeStatus::IDLE;\n\t\tstd::rethrow_exception(eptr);\n\t}\n\tif (status == NodeStatus::RUNNING && stored_exception_) {\n\t\tstatus = NodeStatus::IDLE;\n\t\tstd::rethrow_exception(stored_exception_);\n\t}\n\treturn status;\n}", "CodeBleu_score": 38.44846002293658}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\t// If the node status is IDLE, set the status to RUNNING, reset halt_requested_, and start a new asynchronous thread to run the tick function.\n\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::async(std::launch::async, &ThreadedAction::tick, this);\n\t}\n\t// If the tick function completes without a halt request, update the node status.\n\telse if (!halt_requested_) {\n\t\tstatus_ = NodeStatus::IDLE;\n\t}\n\t// If an exception occurs, catch the exception, log an error, and set the node status to IDLE.\n\telse {\n\t\ttry {\n\t\t\tstd::rethrow_exception(exception_);\n\t\t}\n\t\tcatch (const std::exception& e) {\n\t\t\tROS_ERROR_STREAM(\"Exception caught in tick function: \" << e.what());\n\t\t}\n\t\tcatch (...) {\n\t\t\tROS_ERROR(\"Unknown exception caught in tick function\");\n\t\t}\n\t\tstatus_ = NodeStatus::IDLE;\n\t}\n\t// Check for any stored exceptions and rethrow them if present.\n\tif (exception_) {\n\t\tstd::rethrow_exception(exception_);\n\t}\n\t// Return the current status of the node.\n\treturn status_;\n}", "CodeBleu_score": 39.07692026840114}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\tstd::string indent = \"\";\n\tfor (int i = 0; i < root_node->depth(); i++) {\n\t\tindent += \"  \";\n\t}\n\tstream << indent << \"|-\" << root_node->name() << std::endl;\n\tauto lambda = [&indent, &stream](const TreeNode* node) {\n\t\tfor (int i = 0; i < node->depth(); i++) {\n\t\t\tindent += \"  \";\n\t\t}\n\t\tif (dynamic_cast<const BT::ControlNode*>(node)!= nullptr) {\n\t\t\tstream << indent << \"|-\" << node->name() << std::endl;\n\t\t\tfor (auto child : dynamic_cast<const BT::ControlNode*>(node)->children()) {\n\t\t\t\tlambda(child);\n\t\t\t}\n\t\t} else {\n\t\t\tstream << indent << \"|-\" << node->name() << std::endl;\n\t\t}\n\t};\n\tlambda(root_node);\n\tstream << std::endl;\n}", "CodeBleu_score": 49.000555647783806}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\tauto indent = [&stream](int depth) {\n\t\tfor (int i = 0; i < depth; ++i) {\n\t\t\tstream << \"  \";\n\t\t}\n\t};\n\tauto print = [&stream](const std::string& name) {\n\t\tstream << name << std::endl;\n\t};\n\tauto print_children = [&stream](const TreeNode* node, int depth) {\n\t\tfor (auto child : node->children) {\n\t\t\tindent(depth + 1);\n\t\t\tprint(child->name);\n\t\t\tprint_children(child, depth + 1);\n\t\t}\n\t};\n\tindent(0);\n\tprint(root_node->name);\n\tprint_children(root_node, 1);\n\tindent(0);\n}", "CodeBleu_score": 40.2302674219283}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstream << \"=====================================================\n\";\n\tstream << \"Tree Structure:\n\";\n\tstream << \"=====================================================\n\";\n\n\tstd::function<void(const TreeNode*, int)> print = [&print](const TreeNode* node, int depth) {\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \" \";\n\t\t}\n\t\tstream << node->name << \"\n\";\n\n\t\tif (dynamic_cast<const BT::ControlNode*>(node)!= nullptr) {\n\t\t\tauto control = dynamic_cast<const BT::ControlNode*>(node);\n\t\t\tfor (const auto& child : control->children) {\n\t\t\t\tprint(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (dynamic_cast<const BT::DecoratorNode*>(node)!= nullptr) {\n\t\t\tauto decorator = dynamic_cast<const BT::DecoratorNode*>(node);\n\t\t\tprint(decorator->child, depth + 1);\n\t\t}\n\t};\n\n\tprint(root_node, 0);\n\n\tstream << \"=====================================================\n\";\n}", "CodeBleu_score": 50.25342505999318}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (dynamic_cast<const BT::ControlNode*>(node)!= nullptr) {\n\t\tconst BT::ControlNode* control = dynamic_cast<const BT::ControlNode*>(node);\n\t\tfor (const TreeNode* child : control->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (dynamic_cast<const BT::DecoratorNode*>(node)!= nullptr) {\n\t\tconst BT::DecoratorNode* decorator = dynamic_cast<const BT::DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(decorator->child, visitor);\n\t}\n}", "CodeBleu_score": 58.800522770260464}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"Cannot apply recursive visitor to a null node\");\n\t}\n\tvisitor(node);\n\tif (dynamic_cast<const BT::ControlNode*>(node)!= nullptr) {\n\t\tconst BT::ControlNode* control = dynamic_cast<const BT::ControlNode*>(node);\n\t\tfor (const auto& child : control->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (dynamic_cast<const BT::DecoratorNode*>(node)!= nullptr) {\n\t\tconst BT::DecoratorNode* decorator = dynamic_cast<const BT::DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(decorator->child, visitor);\n\t}\n}", "CodeBleu_score": 59.89116347939899}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"node is null\");\n\t}\n\tvisitor(node);\n\tif (dynamic_cast<const BT::ControlNode*>(node)!= nullptr) {\n\t\tconst BT::ControlNode* control = dynamic_cast<const BT::ControlNode*>(node);\n\t\tfor (const auto& child : control->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (dynamic_cast<const BT::DecoratorNode*>(node)!= nullptr) {\n\t\tconst BT::DecoratorNode* decorator = dynamic_cast<const BT::DecoratorNode*>(node);\n\t\tapplyRecursiveVisitor(decorator->child, visitor);\n\t}\n}", "CodeBleu_score": 60.8151525447841}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\t// TODO: implement\n}", "CodeBleu_score": 4.889503087170041}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.find(manifest.registration_id)!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with ID '\" + manifest.registration_id + \"' already registered.\");\n\t}\n\t_p->builders.insert(std::make_pair(manifest.registration_id, builder));\n\t_p->manifests.insert(std::make_pair(manifest.registration_id, manifest));\n}", "CodeBleu_score": 54.47799863664575}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (_p->builders.find(manifest.registrationId)!= _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder for \" + manifest.registrationId + \" already registered\");\n\t}\n\t_p->builders.insert(std::make_pair(manifest.registrationId, builder));\n\t_p->manifests.insert(std::make_pair(manifest.registrationId, manifest));\n}", "CodeBleu_score": 55.392890045330155}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tregisterBuilder(\n    TreeNodeManifest{ID, SimpleActionNode::type(), ports},\n    [tick_functor](const TreeNodeManifest& manifest,\n                   const std::string& name, const NodeConfiguration& config) {\n      return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n    });\n}", "CodeBleu_score": 53.31936921846789}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\n}", "CodeBleu_score": 10.819337351164709}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t#ifndef BEHAVIORTREE_COMPOSITE_NODES_ONLY\n  registerBuilder(std::make_unique<SimpleActionNode>(ID, tick_functor),\n                  std::make_unique<TreeNodeManifest>(ID, \"SimpleActionNode\", ports));\n#endif\n}", "CodeBleu_score": 35.70695069518536}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tbb.back()->cloneInto(subtree->blackboard);\n\t}\n\treturn bb;\n}", "CodeBleu_score": 72.5133244607394}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (auto subtree : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tsubtree->blackboard->cloneInto(bb.back());\n\t}\n\treturn bb;\n}", "CodeBleu_score": 71.65518946039504}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (int i = 0; i < tree.subtrees.size(); i++) {\n\t\tbb.push_back(Blackboard::create());\n\t\tbb.back()->cloneInto(tree.subtrees[i]->blackboard);\n\t}\n\treturn bb;\n}", "CodeBleu_score": 68.23664788125912}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif (executor.error) {\n\t\treturn nonstd::make_unexpected(executor.error);\n\t}\n\treturn executor.value().Execute(env);\n}", "CodeBleu_score": 64.59396351976818}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tBT::Executor executor;\n\tif (ParseScript(env, script, executor)) {\n\t\treturn executor.value();\n\t} else {\n\t\treturn nonstd::make_unexpected(executor.error);\n\t}\n}", "CodeBleu_score": 58.116747211394646}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tBT::Expected<Executor> executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor.value().Execute(env);\n}", "CodeBleu_score": 64.68507532464534}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\tif (m_path.size()) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tm_path = path;\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tm_handle = handle;\n}", "CodeBleu_score": 51.62696974909436}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == nullptr) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tloaded = true;\n\tthis->path = path;\n}", "CodeBleu_score": 50.36925862082272}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tloaded = true;\n\tthis->path = path;\n}", "CodeBleu_score": 50.98341484852696}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tstr = str.strip();\n\n\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tif (str[0]!= '{') {\n\t\treturn false;\n\t}\n\n\tif (str[str.size - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 22.148235061051107}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) return false;\n\tstr.trim_front_and_back_in_place();\n\tif (str.size < 3) return false;\n\tif (str[0]!= '{') return false;\n\tif (str[str.size - 1]!= '}') return false;\n\tif (stripped_pointer!= nullptr) {\n\t\t*stripped_pointer = StringView(str.data + 1, str.size - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 20.982263810268847}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\tstr = str.trim();\n\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\tif (str.front!= '{' || str.back!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer!= nullptr) {\n\t\t*stripped_pointer = str.subview(1, str.size - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 21.68128959754688}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble lineCost = 0;\n\tLineIterator it(this, x0, y0, x1, y1);\n\tfor (int i = 0; i < it.getCount(); i++) {\n\t\tPoint point = it.getPosition(i);\n\t\tdouble pointCost = getCost(point.x, point.y);\n\t\tif (pointCost < 0) {\n\t\t\treturn pointCost;\n\t\t} else {\n\t\t\tif (pointCost > lineCost) {\n\t\t\t\tlineCost = pointCost;\n\t\t\t}\n\t\t}\n\t}\n\treturn lineCost;\n}", "CodeBleu_score": 42.01172380245845}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\t// TODO: Implement this function!\n\t// If you get stuck, you can view the solution in solution/costmap_model.cpp\n\tdouble totalCost = 0;\n\tLineIterator iterator(this, x0, y0, x1, y1);\n\twhile (iterator.isValid()) {\n\t\tPoint point = iterator.getPoint();\n\t\tdouble pointCost = getCost(point.x, point.y);\n\t\tif (pointCost < 0) {\n\t\t\treturn pointCost;\n\t\t} else {\n\t\t\ttotalCost = std::max(totalCost, pointCost);\n\t\t}\n\t\titerator.advance();\n\t}\n\treturn totalCost;\n}", "CodeBleu_score": 36.23322701917068}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tLineIterator line(x0, y0, x1, y1, *this);\n\tdouble lineCost = 0;\n\tfor (int i = 0; i < line.getCount(); ++i) {\n\t\tPoint point = line.getPosition(i);\n\t\tdouble pointCost = getCost(point.x, point.y);\n\t\tif (pointCost < 0) {\n\t\t\treturn pointCost;\n\t\t}\n\t\tlineCost += pointCost;\n\t}\n\treturn lineCost;\n}", "CodeBleu_score": 40.47146937646738}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN(\"The received path is empty. Nothing to publish.\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\tpath_msg.poses.resize(path.size());\n\n\tfor (size_t i = 0; i < path.size(); ++i) {\n\t\tpath_msg.poses[i] = path[i].pose;\n\t}\n\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 62.86104129963155}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif(path.empty()) {\n\t\tROS_WARN_THROTTLE(1.0, \"The received path is empty, so no plan will be published.\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = ros::Time::now();\n\n\tfor(const auto& pose : path) {\n\t\tpath_msg.poses.push_back(pose.pose);\n\t}\n\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 47.72789926310239}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\t// Check if the path is empty\n    if (path.empty()) {\n        return;\n    }\n\n    // Create a nav_msgs::Path message\n    nav_msgs::Path msg;\n\n    // Initialize the header of the message with the frame_id and timestamp of the first pose in the path\n    msg.header.frame_id = path[0].header.frame_id;\n    msg.header.stamp = path[0].header.stamp;\n\n    // Copy each pose from the input path to the path message\n    for (const auto& pose : path) {\n        msg.poses.push_back(pose.pose);\n    }\n\n    // Publish the path message using the provided ROS publisher\n    pub.publish(msg);\n}", "CodeBleu_score": 51.860083296047655}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// TODO: Implement this function.\n\t// Note that the odometry message contains the robot's position and orientation in the world frame.\n\t// You will need to transform this to the robot's frame of reference.\n\t// The odometry message also contains the robot's linear and angular velocities.\n\t// You will need to use these velocities to determine whether the robot has stopped.\n\t// You will need to use the function tf::transformPose to transform the odometry message from the world frame to the robot's frame of reference.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getYaw to get the robot's yaw from the quaternion.\n\t// You will need to use the function tf::getY", "CodeBleu_score": 7.791454650724491}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// TODO: Implement this function.\n\tdouble angular_velocity = base_odom.twist.twist.angular.z;\n\tdouble linear_velocity = base_odom.twist.twist.linear.x;\n\n\tif (fabs(angular_velocity) <= rot_stopped_velocity && fabs(linear_velocity) <= trans_stopped_velocity) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 50.512720177428285}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// Check if the robot has stopped\n\tbool stopped = true;\n\n\t// Check if the robot has stopped in translation\n\tif (fabs(base_odom.twist.twist.linear.x) > trans_stopped_velocity)\n\t\tstopped = false;\n\n\t// Check if the robot has stopped in rotation\n\tif (fabs(base_odom.twist.twist.angular.z) > rot_stopped_velocity)\n\t\tstopped = false;\n\n\t// Return the result\n\treturn stopped;\n}", "CodeBleu_score": 58.7384553444591}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig.setup = false;\n\t\tconfig.restore_defaults = false;\n\t\tconfig.lock_config = false;\n\t\tconfig.unlock_config = false;\n\t\tconfig.max_vel_x = 1.0;\n\t\tconfig.max_vel_y = 1.0;\n\t\tconfig.max_vel_theta = 1.0;\n\t\tconfig.min_vel_x = 0.0;\n\t\tconfig.min_vel_y = 0.0;\n\t\tconfig.min_vel_theta = 0.0;\n\t\tconfig.max_rot_vel = 1.0;\n\t\tconfig.min_rot_vel = 0.0;\n\t\tconfig.acc_lim_x = 1.0;\n\t\tconfig.acc_lim_y = 1.0;\n\t\tconfig.acc_lim_theta = 1.0;\n\t\tconfig.max_trans_acc = 1.0;\n\t\tconfig.max_trans_vel = 1.0;\n\t\tconfig.min_trans_vel = 0.0;\n\t\tconfig.max_rot_acc = 1.0;\n\t\tconfig.max_rot_vel = 1.0;\n\t\tconfig.min_rot_vel = 0.0;\n\t\tconfig.min_in_place_rot_vel = 0.0;\n\t\tconfig.max_vel_x_backwards = 1.0;\n\t\tconfig.min_vel_x_backwards = 0.0;\n\t\tconfig.max_vel_theta_backwards = 1.0;\n\t\tconfig.min_vel_theta_backwards = 0.0;\n\t\tconfig.max_rot_vel_backwards = 1.0;\n\t\tconfig.min_rot_vel_backwards = 0.0;\n\t\tconfig.max_vel_x_forwards = 1.0;\n\t\tconfig.min_vel_x_forwards = 0.0;\n\t\tconfig.max_vel_theta_forwards = 1.0;\n\t\tconfig.min_vel_theta_forwards = 0.0;\n\t\tconfig.max_rot_vel_forwards", "CodeBleu_score": 20.50796711127258}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// if the setup flag is not set, initialize the configuration and set the setup flag to true\n\tif (!setup) {\n\t\t// initialize the limits\n\t\tlimits.max_vel_x = config.max_vel_x;\n\t\tlimits.min_vel_x = config.min_vel_x;\n\t\tlimits.max_vel_y = config.max_vel_y;\n\t\tlimits.min_vel_y = config.min_vel_y;\n\t\tlimits.max_vel_theta = config.max_vel_theta;\n\t\tlimits.min_vel_theta = config.min_vel_theta;\n\t\tlimits.max_acc_x = config.max_acc_x;\n\t\tlimits.max_acc_y = config.max_acc_y;\n\t\tlimits.max_acc_theta = config.max_acc_theta;\n\t\tlimits.max_jerk_x = config.max_jerk_x;\n\t\tlimits.max_jerk_y = config.max_jerk_y;\n\t\tlimits.max_jerk_theta = config.max_jerk_theta;\n\t\tlimits.max_vel_x_backwards = config.max_vel_x_backwards;\n\t\tlimits.min_vel_x_backwards = config.min_vel_x_backwards;\n\t\tlimits.max_vel_y_backwards = config.max_vel_y_backwards;\n\t\tlimits.min_vel_y_backwards = config.min_vel_y_backwards;\n\t\tlimits.max_vel_theta_backwards = config.max_vel_theta_backwards;\n\t\tlimits.min_vel_theta_backwards = config.min_vel_theta_backwards;\n\t\tlimits.max_acc_x_backwards = config.max_acc_x_backwards;\n\t\tlimits.max_acc_y_backwards = config.max_acc_y_backwards;\n\t\tlimits.max_acc_theta_backwards = config.max_acc_theta_backwards;\n\t\tlimits.max_jerk_x_backwards = config.max_jerk_x_backwards;\n\t\tlimits.max_jerk_y_backwards = config", "CodeBleu_score": 21.575706095188202}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// If the setup flag is not set, initialize the default limits with the provided configuration and set the setup flag.\n\tif (!setup) {\n\t\tdefault_limits = config;\n\t\tsetup = true;\n\t}\n\n\t// If restore_defaults is true, reset the configuration to default limits.\n\tif (restore_defaults) {\n\t\tconfig = default_limits;\n\t}\n\n\t// Lock the configuration mutex.\n\tstd::lock_guard<std::mutex> lock(config_mutex);\n\n\t// Update the current limits with the new configuration.\n\tcurrent_limits = config;\n}", "CodeBleu_score": 53.011443009310824}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\tif (check_cell == NULL) {\n\t\treturn false;\n\t}\n\n\tif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::NO_INFORMATION) {\n\t\tcheck_cell->target_distance = costmap.getCostmap()->getSizeInCellsX()\n\t\t\t\t* costmap.getCostmap()->getSizeInCellsY();\n\t\treturn false;\n\t}\n\n\tdouble new_target_distance = current_cell->target_distance\n\t\t\t+ costmap.getCost(check_cell->x, check_cell->y);\n\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 51.605784808720514}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// check if the cell is an obstacle or has no information\n\tif (check_cell->isObstacle() || check_cell->getCost() == costmap_2d::NO_INFORMATION) {\n\t\t// set the target distance to the maximum obstacle cost\n\t\tcheck_cell->setTargetDistance(costmap_2d::INSCRIBED_INFLATED_OBSTACLE);\n\t\treturn false;\n\t}\n\n\t// calculate the new target distance\n\tdouble new_target_distance = current_cell->getTargetDistance() + costmap.getCost(check_cell->getPoint()) + 1;\n\n\t// update the target distance if the new distance is shorter\n\tif (new_target_distance < check_cell->getTargetDistance()) {\n\t\tcheck_cell->setTargetDistance(new_target_distance);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 46.40537129752512}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false.\n\tif (check_cell->getCost() >= costmap.getCostmapResolution() || check_cell->getCost() == costmap.getLethalCost()) {\n\t\tcheck_cell->setTargetDistance(costmap.getCostmapResolution());\n\t\treturn false;\n\t}\n\n\t// Calculate the new target distance.\n\tdouble new_distance = current_cell->getTargetDistance() + distance(current_cell, check_cell);\n\n\t// If the new distance is shorter, update the cell's target distance.\n\tif (new_distance < check_cell->getTargetDistance()) {\n\t\tcheck_cell->setTargetDistance(new_distance);\n\t\treturn true;\n\t}\n\n\t// Otherwise, return false.\n\treturn false;\n}", "CodeBleu_score": 42.95238884728344}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"Footprint specification is empty!\");\n\t\treturn -9.0;\n\t}\n\n\tif (sum_scores_) {\n\t\tscaling_factor = 1.0 / footprintCost(traj.getPoint(0));\n\t} else {\n\t\tscaling_factor = footprintCost(traj.getPoint(0));\n\t}\n\n\tfor (int i = 0; i < traj.getPointsSize(); i++) {\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i));\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn -1.0 * footprint_cost;\n\t\t}\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost * scaling_factor;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost * scaling_factor);\n\t\t}\n\t}\n\treturn cost;\n}", "CodeBleu_score": 49.497530822833156}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\n\t\t\t\t\"ObstacleCostFunction::scoreTrajectory: No footprint specification is provided. Please set the footprint_spec_ parameter.\");\n\t\treturn -9.0;\n\t}\n\n\t// Get the scaling factor\n\tscaling_factor = getScalingFactor(traj);\n\n\t// Get the cost\n\tif (sum_scores_) {\n\t\tcost = 0.0;\n\t\tfor (int i = 0; i < traj.getPointsSize(); i++) {\n\t\t\tcost += footprintCost(traj.getPoint(i), scaling_factor);\n\t\t}\n\t} else {\n\t\tcost = -9999999.0;\n\t\tfor (int i = 0; i < traj.getPointsSize(); i++) {\n\t\t\tdouble footprint_cost = footprintCost(traj.getPoint(i), scaling_factor);\n\t\t\tif (footprint_cost < 0.0) {\n\t\t\t\treturn footprint_cost;\n\t\t\t} else if (footprint_cost > cost) {\n\t\t\t\tcost = footprint_cost;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cost;\n}", "CodeBleu_score": 46.978802390841615}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tdouble cost = 0;\n\tdouble scaling_factor = 1;\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty\");\n\t\treturn -9;\n\t}\n\n\t// Initialize cost and scaling factor based on the trajectory and speed parameters\n\tcost = getScalingFactor(traj) * getSpeedCost(traj);\n\n\t// For each point in the trajectory, calculate the footprint cost\n\tfor (int i = 0; i < traj.getPointsSize(); i++) {\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i));\n\n\t\t// If the footprint cost is negative, return the cost immediately\n\t\tif (footprint_cost < 0) {\n\t\t\treturn cost;\n\t\t}\n\n\t\t// If the sum_scores_ flag is true, sum the footprint costs\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\t// Otherwise, take the maximum footprint cost\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\t// Return the total cost\n\treturn cost;\n}", "CodeBleu_score": 44.38140341010918}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t// scale the footprint\n\tstd::vector<geometry_msgs::Point> scaled_footprint;\n\tscaled_footprint.reserve(footprint_spec.size());\n\tfor (unsigned int i = 0; i < footprint_spec.size(); i++) {\n\t\tgeometry_msgs::Point p;\n\t\tp.x = footprint_spec[i].x * scale;\n\t\tp.y = footprint_spec[i].y * scale;\n\t\tscaled_footprint.push_back(p);\n\t}\n\n\t// compute the footprint cost\n\tdouble footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint, costmap);\n\n\t// if the footprint is negative, return -6.0\n\tif (footprint_cost < 0) {\n\t\treturn -6.0;\n\t}\n\n\t// if the footprint is off the map, return -7.0\n\tif (!costmap->isWithinBounds(x, y)) {\n\t\treturn -7.0;\n\t}\n\n\t// otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n\treturn std::max(footprint_cost, costmap->getCost(x, y));\n}", "CodeBleu_score": 62.05809140225642}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//  ROS_DEBUG(\"footprintCost: x = %f, y = %f, th = %f, scale = %f\", x, y, th, scale);\n\n  // scale the footprint points\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point scaled_point;\n    scaled_point.x = footprint_spec[i].x * scale;\n    scaled_point.y = footprint_spec[i].y * scale;\n    scaled_footprint.push_back(scaled_point);\n  }\n\n  // compute the footprint cost\n  double footprint_cost = world_model->footprintCost(scaled_footprint, x, y, th, costmap);\n\n  // if the footprint is empty, return -6.0\n  if (footprint_cost < 0.0) {\n    return -6.0;\n  }\n\n  // if the footprint is off the map, return -7.0\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n\n  // otherwise, return the maximum of the footprint cost and the cell cost\n  return std::max(footprint_cost, costmap->getCost(mx, my));\n}", "CodeBleu_score": 66.47567188685186}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//    ROS_DEBUG(\"ObstacleCostFunction::footprintCost\");\n    // Scale the footprint points\n    std::vector<geometry_msgs::Point> scaled_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        scaled_footprint.push_back(scalePoint(footprint_spec[i], scale));\n    }\n\n    // Get the footprint cost\n    double footprint_cost = world_model->footprintCost(scaled_footprint, x, y, th);\n\n    // Get the cell cost\n    double cell_cost = costmap->getCost(x, y);\n\n    // Return the maximum of the two\n    if (footprint_cost < 0) {\n        return -6.0;\n    } else if (cell_cost < 0) {\n        return -7.0;\n    } else {\n        return std::max(footprint_cost, cell_cost);\n    }\n}", "CodeBleu_score": 57.55259051138828}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (odom_topic_.empty()) {\n\t\t\todom_gn.shutdown();\n\t\t} else {\n\t\t\todom_gn.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.9722490779842}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\tif (odom_topic == \"\") {\n\t\t\tROS_INFO(\"OdometryHelperRos: Odometry topic is empty, shutting down odometry subscription.\");\n\t\t\todom_sub_.shutdown();\n\t\t} else {\n\t\t\tROS_INFO(\"OdometryHelperRos: Odometry topic is %s, subscribing to new odometry topic.\", odom_topic.c_str());\n\t\t\todom_sub_ = nh_.subscribe<nav_msgs::Odometry> (odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t}\n\t\todom_topic_ = odom_topic;\n\t}\n}", "CodeBleu_score": 40.37671826702876}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (!odom_topic_.empty()) {\n\t\t\todom_sub_.shutdown();\n\t\t\todom_sub_ = nh_.subscribe<nav_msgs::Odometry>\n\t\t\t(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}", "CodeBleu_score": 48.98440099099494}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// Calculate the squared distance\n\tfloat squaredDistance = (pos - prev).squaredNorm();\n\t// Calculate the angular difference\n\tfloat angularDifference = fabs(angleBetween(pos, prev));\n\t// If the squared distance is greater than the threshold or the angular difference is greater than the threshold, reset the oscillation flags\n\tif (squaredDistance > oscillationThresholdSquared || angularDifference > oscillationThreshold) {\n\t\toscillationFlags = 0;\n\t}\n}", "CodeBleu_score": 27.578895889339865}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tif (pos.squaredNorm() < m_oscillationDistanceThreshold * m_oscillationDistanceThreshold &&\n\t\t\tfabs(pos.dot(prev)) < m_oscillationAngleThreshold) {\n\t\tm_oscillationFlags = 0;\n\t}\n}", "CodeBleu_score": 21.632249363031434}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat distance = (pos - prev).squaredNorm();\n\tfloat angle = fabs(pos.cross(prev).norm());\n\tif (distance > oscillationDistanceThreshold_ || angle > oscillationAngleThreshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 30.88066944681908}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tint pt_index = pt_index_++;\n\tcells_[pt_index].push_back(pt);\n\tif (pt.x < min_x_) {\n\t\tmin_x_ = pt.x;\n\t}\n\tif (pt.x > max_x_) {\n\t\tmax_x_ = pt.x;\n\t}\n\tif (pt.y < min_y_) {\n\t\tmin_y_ = pt.y;\n\t}\n\tif (pt.y > max_y_) {\n\t\tmax_y_ = pt.y;\n\t}\n\tif (pt.z < min_z_) {\n\t\tmin_z_ = pt.z;\n\t}\n\tif (pt.z > max_z_) {\n\t\tmax_z_ = pt.z;\n\t}\n\tif (pt.x == min_x_ || pt.x == max_x_ || pt.y == min_y_ || pt.y == max_y_ || pt.z == min_z_ || pt.z == max_z_) {\n\t\treturn;\n\t}\n\tif (pt.x == nearestNeighborDistance.x && pt.y == nearestNeighborDistance.y && pt.z == nearestNeighborDistance.z) {\n\t\treturn;\n\t}\n\tgridCoords grid_coords = gridCoords(pt.x, pt.y, pt.z);\n\tgridIndex grid_index = gridIndex(grid_coords);\n\tcells_[pt_index].push_back(pt);\n\tcells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 42.93923754157048}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tif (pt.x < min_x_ || pt.x > max_x_ || pt.y < min_y_ || pt.y > max_y_)\nreturn;\n\nif (pt.x == nearestNeighborDistance.x && pt.y == nearestNeighborDistance.y)\nreturn;\n\nint grid_index = getGridIndex(pt);\n\nif (grid_index < 0)\nreturn;\n\ncells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 41.94564841641061}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tgeometry_msgs::Point32 gridCoords;\ngridCoords.x = floor(pt.x / gridSize_);\ngridCoords.y = floor(pt.y / gridSize_);\ngridCoords.z = floor(pt.z / gridSize_);\n\n// If the point is outside the grid bounds or too close to its nearest neighbor, return.\nif (gridCoords.x < 0 || gridCoords.x >= numGridCells_ || gridCoords.y < 0 || gridCoords.y >= numGridCells_ ||\ngridCoords.z < 0 || gridCoords.z >= numGridCells_ ||\n(pt.x - gridCoords.x * gridSize_) < minDistance_ || (pt.x - gridCoords.x * gridSize_) > gridSize_ ||\n(pt.y - gridCoords.y * gridSize_) < minDistance_ || (pt.y - gridCoords.y * gridSize_) > gridSize_ ||\n(pt.z - gridCoords.z * gridSize_) < minDistance_ || (pt.z - gridCoords.z * gridSize_) > gridSize_) {\nreturn;\n}\n\n// Calculate the grid index.\nint gridIndex = gridCoords.x + gridCoords.y * numGridCells_ + gridCoords.z * numGridCells_ * numGridCells_;\n\n// Insert the point into the corresponding cell.\ncells_[gridIndex].push_back(pt);\n}", "CodeBleu_score": 39.76387682830358}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n// TODO: YOUR CODE HERE\n// 1. Initialize the new velocity vector to zero.\nEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n// 2. For each of the three velocity components, increase or decrease the current velocity towards the target velocity within the acceleration limits.\nfor (int i = 0; i < 3; i++) {\n  double vel_diff = sample_target_vel(i) - vel(i);\n  if (vel_diff > acclimits(i)) {\n    new_vel(i) = vel(i) + acclimits(i);\n  } else if (vel_diff < -acclimits(i)) {\n    new_vel(i) = vel(i) - acclimits(i);\n  } else {\n    new_vel(i) = sample_target_vel(i);\n  }\n}\n\nreturn new_vel;\n}", "CodeBleu_score": 52.35026229480801}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n//    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();", "CodeBleu_score": 6.3562041618051275}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t// TODO: Implement this function.\n  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  new_vel[0] = std::min(std::max(vel[0] + acclimits[0] * dt, -sample_target_vel[0]), sample_target_vel[0]);\n  new_vel[1] = std::min(std::max(vel[1] + acclimits[1] * dt, -sample_target_vel[1]), sample_target_vel[1]);\n  new_vel[2] = std::min(std::max(vel[2] + acclimits[2] * dt, -sample_target_vel[2]), sample_target_vel[2]);\n  return new_vel;\n}", "CodeBleu_score": 42.32499871215841}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t// TODO: Implement this function!\n\t// TODO: You can use the costmap_ class to find the distance to obstacles\n\t// TODO: You can use the global_plan_ class to find the heading to the goal\n\t// TODO: You can use the angles::shortest_angular_distance function to find the difference between two angles\n\t// TODO: You can use the angles::normalize_angle function to make sure the angle is between -pi and pi\n\t// TODO: You can use the costmap_ class to find the distance to obstacles\n\t// TODO: You can use the global_plan_ class to find the heading to the goal\n\t// TODO: You can use the angles::shortest_angular_distance function to find the difference between two angles\n\t// TODO: You can use the angles::normalize_angle function to make sure the angle is between -pi and pi\n\t// TODO: You can use the costmap_ class to find the distance to obstacles\n\t// TODO: You can use the global_plan_ class to find the heading to the goal\n\t// TODO: You can use the angles::shortest_angular_distance function to find the difference between two angles\n\t// TODO: You can use the angles::normalize_angle function to make sure the angle is between -pi and pi\n\t// TODO: You can use the costmap_ class to find the distance to obstacles\n\t// TODO: You can use the global_plan_ class to find the heading to the goal\n\t// TODO: You can use the angles::shortest_angular_distance function to find the difference between two angles\n\t// TODO: You can use the angles::normalize_angle function to make sure the angle is between -pi and pi\n\t// TODO: You can use the costmap_ class to find the distance to obstacles\n\t// TODO: You can use the global_plan_ class to find the heading to the goal\n\t// TODO: You can use the angles::shortest_angular_distance function to find the difference between two angles\n\t// TODO: You can use the angles::normalize_angle function to make sure the angle is between -pi and pi\n\t// TODO: You can use the costmap_ class to find the distance to obstacles\n\t// TODO: You can use the global_plan_ class to find the heading to the goal\n\t//", "CodeBleu_score": 3.717784580155612}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = 0.0;\n\tdouble best_dist = DBL_MAX;\n\tdouble best_heading = 0.0;\n\tdouble dist = 0.0;\n\tdouble heading_to_point = 0.0;\n\tdouble heading_to_point_abs = 0.0;\n\tdouble heading_to_point_diff = 0.0;\n\tint x_i = 0;\n\tint y_i = 0;\n\tint x_i_min = 0;\n\tint x_i_max = 0;\n\tint y_i_min = 0;\n\tint y_i_max = 0;\n\tint x_i_best = 0;\n\tint y_i_best = 0;\n\tint x_i_temp = 0;\n\tint y_i_temp = 0;\n\tint x_i_temp_min = 0;\n\tint x_i_temp_max = 0;\n\tint y_i_temp_min = 0;\n\tint y_i_temp_max = 0;\n\tint x_i_temp_best = 0;\n\tint y_i_temp_best = 0;\n\tint x_i_temp_best_min = 0;\n\tint x_i_temp_best_max = 0;\n\tint y_i_temp_best_min = 0;\n\tint y_i_temp_best_max = 0;\n\tint x_i_temp_best_min_min = 0;\n\tint x_i_temp_best_min_max = 0;\n\tint y_i_temp_best_min_min = 0;\n\tint y_i_temp_best_min_max = 0;\n\tint x_i_temp_best_max_min = 0;\n\tint x_i_temp_best_max_max = 0;\n\tint y_i_temp_best_max_min = 0;\n\tint y_i_temp_best_max_max = 0;\n\tint x_i_temp_best_max_min_", "CodeBleu_score": 5.755641150362428}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble min_heading_diff = DBL_MAX;\n\tdouble heading_diff;\n\tfor (int i = global_plan_.size() - 1; i >= 0; --i) {\n\t\theading_diff = angles::shortest_angular_distance(heading, costmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y).theta());\n\t\tif (heading_diff < min_heading_diff && costmap_.getCost(costmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y).x, costmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y).y) == costmap_2d::FREE_SPACE) {\n\t\t\tmin_heading_diff = heading_diff;\n\t\t}\n\t}\n\treturn min_heading_diff;\n}", "CodeBleu_score": 44.749206907204275}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost >= 0) {\n\t\treturn true;\n\t} else {\n\t\tROS_WARN(\"Trajectory cost is negative. x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 69.75762473178692}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t// TODO: Implement this function!\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta);\n\tif (cost < 0) {\n\t\tROS_WARN(\"Trajectory planner: trajectory cost is negative!  x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 61.23958974377916}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t//ROS_WARN(\"TrajectoryPlanner::checkTrajectory\");\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta);\n\tif (cost >= 0) {\n\t\treturn true;\n\t} else {\n\t\tROS_WARN(\"TrajectoryPlanner::checkTrajectory: trajectory cost is negative. vx = %f, vy = %f, vtheta = %f\", vx_samp, vy_samp, vtheta_samp);\n\t\tROS_WARN(\"TrajectoryPlanner::checkTrajectory: trajectory cost is negative. vx = %f, vy = %f, vtheta = %f\", vx, vy, vtheta);\n\t\tROS_WARN(\"TrajectoryPlanner::checkTrajectory: trajectory cost is negative. vx = %f, vy = %f, vtheta = %f\", x, y, theta);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 56.32074376835078}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This object must be initialized before it may be run.\");\n\t\treturn;\n\t}\n\tif (!global_costmap_ ||!local_costmap_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This object must have a valid global and local costmap before it may be run.\");\n\t\treturn;\n\t}\n\tif (affected_maps_.size() == 0) {\n\t\tROS_ERROR(\n\t\t\t\t\"This object must have at least one map to clear before it may be run.\");\n\t\treturn;\n\t}\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\n\t\t\t\t\"This object will clear the area specified by the area_to_clear_ parameter, but will not clear the area specified by the clear_area_ parameter.\");\n\t}\n\tros::WallTime t0 = ros::WallTime::now();\n\tif (affected_maps_.find(\"global\")!= affected_maps_.end()) {\n\t\tROS_DEBUG(\"Clearing global costmap...\");\n\t\tglobal_costmap_->clearCostmap();\n\t\tROS_DEBUG(\"Global costmap cleared in %.2f seconds\",\n\t\t\t\t(ros::WallTime::now() - t0).toSec());\n\t}\n\tif (affected_maps_.find(\"local\")!= affected_maps_.end()) {\n\t\tROS_DEBUG(\"Clearing local costmap...\");\n\t\tlocal_costmap_->clearCostmap();\n\t\tROS_DEBUG(\"Local costmap cleared in %.2f seconds\",\n\t\t\t\t(ros::WallTime::now() - t0).toSec());\n\t}\n}", "CodeBleu_score": 46.03478812160505}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\nROS_ERROR(\"This object must be initialized before it can run a behavior.\");\nreturn;\n}\nif (global_costmap_ == NULL) {\nROS_ERROR(\"The global costmap is not set, unable to clear it.\");\nreturn;\n}\nif (local_costmap_ == NULL) {\nROS_ERROR(\"The local costmap is not set, unable to clear it.\");\nreturn;\n}\nif (affected_maps_.empty()) {\nROS_ERROR(\"No maps were specified to be cleared, unable to clear them.\");\nreturn;\n}\nif (invert_area_to_clear_) {\nROS_WARN(\"The ClearCostmapRecovery object will clear the costmap outside the specified area.\");\n}\n\n// Clear the costmaps\nif (affected_maps_.find(\"global\")!= std::string::npos) {\nROS_DEBUG(\"Clearing the global costmap.\");\nglobal_costmap_->clearCostmap();\n}\nif (affected_maps_.find(\"local\")!= std::string::npos) {\nROS_DEBUG(\"Clearing the local costmap.\");\nlocal_costmap_->clearCostmap();\n}\n\n// Force an update\nif (force_update_) {\nif (affected_maps_.find(\"global\")!= std::string::npos) {\nROS_DEBUG(\"Forcing an update of the global costmap.\");\nglobal_costmap_->updateMap();\n}\nif (affected_maps_.find(\"local\")!= std::string::npos) {\nROS_DEBUG(\"Forcing an update of the local costmap.\");\nlocal_costmap_->updateMap();\n}\n}\n\n// Log the time taken\nif (affected_maps_.find(\"global\")!= std::string::npos) {\nROS_DEBUG(\"Time taken to clear the global costmap: %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n}\nif (affected_maps_.find(\"local\")!= std::string::npos) {\nROS_DEBUG(\"Time taken to clear the local costmap: %.3f seconds\", (ros::WallTime::now() - t0).toSec());\n}\n}", "CodeBleu_score": 48.38164457197458}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before it can run a behavior.\");\n\t\treturn;\n\t}\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"This object must have a global and local costmap before it can run a behavior.\");\n\t\treturn;\n\t}\n\tif (invert_area_to_clear_)\n\t\tROS_WARN(\"This object is clearing inside the specified area, not outside.\");\n\n\tros::WallTime t0 = ros::WallTime::now();\n\tif (affected_maps_.find(\"global\")!= affected_maps_.end()) {\n\t\tROS_DEBUG(\"Clearing global costmap.\");\n\t\tglobal_costmap_->clear();\n\t\tif (force_update_)\n\t\t\tglobal_costmap_->updateMap();\n\t}\n\tif (affected_maps_.find(\"local\")!= affected_maps_.end()) {\n\t\tROS_DEBUG(\"Clearing local costmap.\");\n\t\tlocal_costmap_->clear();\n\t\tif (force_update_)\n\t\t\tlocal_costmap_->updateMap();\n\t}\n\tROS_DEBUG(\"Clearing took %f seconds.\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 46.719334908273524}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells poc;\n\tfor (size_t i = 0; i < polygon.size(); i++) {\n\t\tMapLocation p1 = polygon[i];\n\t\tMapLocation p2 = polygon[(i + 1) % polygon.size()];\n\t\tMapLocation p3 = polygon[(i + 2) % polygon.size()];\n\t\tMapLocation p4 = polygon[(i + 3) % polygon.size()];\n\t\tif (p1.x == p2.x && p1.y == p2.y)\n\t\t\tcontinue;\n\t\tif (p3.x == p4.x && p3.y == p4.y)\n\t\t\tcontinue;\n\t\traytraceLine(p1, p2, poc);\n\t\traytraceLine(p2, p3, poc);\n\t\traytraceLine(p3, p4, poc);\n\t\traytraceLine(p4, p1, poc);\n\t}\n\tpoc.getCells(polygon_cells);\n}", "CodeBleu_score": 46.639904547553705}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\n\tPolygonOutlineCells outline_cells;\n\toutline_cells.init(polygon);\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tMapLocation p1 = polygon[i];\n\t\tMapLocation p2 = polygon[(i + 1) % polygon.size()];\n\t\traytraceLine(p1, p2, outline_cells);\n\t}\n\toutline_cells.closePolygon();\n\toutline_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 46.80820489833134}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells pol;\n\tif (!polygon.empty()) {\n\t\tfor (size_t i = 0; i < polygon.size(); i++) {\n\t\t\tMapLocation p1 = polygon[i];\n\t\t\tMapLocation p2 = polygon[(i + 1) % polygon.size()];\n\t\t\traytraceLine(p1, p2, pol);\n\t\t}\n\t}\n\tpol.closePolygon();\n\tpol.getCells(polygon_cells);\n}", "CodeBleu_score": 41.60078848172085}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tif (pub.getTopic() == \"map\") {\n\t\tif (pub.getNumPublishers() == 1) {\n\t\t\tthis->prepareGrid();\n\t\t\tthis->publish();\n\t\t} else {\n\t\t\tthis->unsubscribe(pub);\n\t\t}\n\t}\n}", "CodeBleu_score": 46.04521248572374}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(costmap_2d_msg_);\n}", "CodeBleu_score": 68.88469395240165}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t// prepareGrid() is called to set up the grid data.\n\tprepareGrid();\n\n\t// The grid data is published using the provided publisher.\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.90268748571795}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// lock the costmap mutex\n\tcostmap_->getMutex().lock();\n\t// get the resolution\n\tresolution_ = costmap_->getResolution();\n\t// set the grid header\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\t// set the grid resolution\n\tgrid_.info.resolution = resolution_;\n\t// set the grid width and height\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\t// set the grid origin\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\t// resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\t// unlock the costmap mutex\n\tcostmap_->getMutex().unlock();\n\t// convert the map coordinates to world coordinates for the origin\n\torigin_x_ = costmap_->mapToWorld(0, 0).x();\n\torigin_y_ = costmap_->mapToWorld(0, 0).y();\n\t// save the origin coordinates\n\torigin_x_ = costmap_->getOriginX();\n\torigin_y_ = costmap_->getOriginY();\n\t// populate the grid data from the costmap's character map using a translation table\n\tfor (int i = 0; i < grid_.info.width; i++) {\n\t\tfor (int j = 0; j < grid_.info.height; j++) {\n\t\t\tgrid_.data[j * grid_.info.width + i] = costmap_->getCharMap()[j * grid_.info.width + i] - '0';\n\t\t}\n\t}\n}", "CodeBleu_score": 60.83445399218571}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the mutex\n\tcostmap_->getMutex().lock();\n\n\t// Get the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\n\t// Set the grid's resolution\n\tgrid_.info.resolution = resolution;\n\n\t// Set the grid's width and height\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Set the grid's origin\n\tdouble origin_x = costmap_->getOriginX();\n\tdouble origin_y = costmap_->getOriginY();\n\tgrid_.info.origin.position.x = origin_x;\n\tgrid_.info.origin.position.y = origin_y;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Unlock the mutex\n\tcostmap_->getMutex().unlock();\n}", "CodeBleu_score": 56.83944144376317}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap mutex\n\tcostmap_->getMutex().lock();\n\n\t// Get the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\n\t// Set the grid's resolution, width, and height\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Set the grid's origin\n\tcostmap_->getOriginX(grid_.info.origin.position.x);\n\tcostmap_->getOriginY(grid_.info.origin.position.y);\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Unlock the costmap mutex\n\tcostmap_->getMutex().unlock();\n}", "CodeBleu_score": 52.35976971157979}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint == old_config.footprint) {\n\t\treturn;\n\t}\n\n\tif (new_config.footprint.size() > 0) {\n\t\tstd::vector<geometry_msgs::Point> points;\n\t\tif (makeFootprintFromString(new_config.footprint, points)) {\n\t\t\tsetUnpaddedRobotFootprint(points);\n\t\t} else {\n\t\t\tROS_ERROR(\"Invalid footprint string specified in configuration file. Footprint will be set to default.\");\n\t\t}\n\t} else {\n\t\tsetUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n\t}\n}", "CodeBleu_score": 64.45924524127342}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.robot_radius == old_config.robot_radius && new_config.footprint.empty() == old_config.footprint.empty())\n\t\treturn;\n\n\tif (!new_config.footprint.empty()) {\n\t\tstd::vector<geometry_msgs::Point> points;\n\t\tif (makeFootprintFromString(new_config.footprint, points)) {\n\t\t\tsetUnpaddedRobotFootprint(points);\n\t\t} else {\n\t\t\tROS_ERROR(\"Invalid robot footprint string: %s\", new_config.footprint.c_str());\n\t\t}\n\t} else {\n\t\tsetUnpaddedRobotFootprint(new_config.robot_radius);\n\t}\n}", "CodeBleu_score": 59.77617101799546}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\t// If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n\t\treturn;\n\n\t// If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n\tif (!new_config.footprint.empty()) {\n\t\ttry {\n\t\t\tsetFootprintFromString(new_config.footprint);\n\t\t} catch (std::runtime_error e) {\n\t\t\tROS_ERROR(\"Invalid footprint string: %s\", new_config.footprint.c_str());\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// If the footprint string is invalid, it logs an error.\n\tif (footprint_.empty()) {\n\t\tROS_ERROR(\"Invalid footprint string: %s\", new_config.footprint.c_str());\n\t\treturn;\n\t}\n\n\t// If no valid footprint string is provided, it sets the footprint based on the robot radius.\n\tif (new_config.footprint.empty()) {\n\t\tsetFootprintFromRadius(new_config.robot_radius);\n\t}\n\n\t// If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n\t\treturn;\n\n\t// If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n\t\treturn;\n\n\tROS_INFO(\"Footprint is now: %s\", getFootprintString().c_str());\n}", "CodeBleu_score": 49.93864788504567}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!initialized_) {\n\t\tROS_WARN_THROTTLE(1.0, \"Costmap2DROS has not been initialized yet, unable to update costmap\");\n\t\treturn;\n\t}\n\n\ttry {\n\t\t// get the robot's current pose\n\t\tgeometry_msgs::PoseStamped current_pose;\n\t\tif (!getRobotPose(current_pose)) {\n\t\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, unable to update costmap\");\n\t\t\treturn;\n\t\t}\n\n\t\t// check if the robot's pose has changed\n\t\tif (current_pose.header.stamp!= new_pose.header.stamp) {\n\t\t\t// get the robot's new pose\n\t\t\tnew_pose = current_pose;\n\t\t\tnew_pose.header.frame_id = global_frame_;\n\n\t\t\t// update the costmap\n\t\t\tupdateCostmap();\n\t\t}\n\t} catch (tf::TransformException &e) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to transform pose into %s frame: %s\", global_frame_.c_str(), e.what());\n\t}\n}", "CodeBleu_score": 51.99831979416317}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (getRobotPose(new_pose)) {\n\t\tif (new_pose.header.frame_id!= robot_base_frame_) {\n\t\t\tROS_WARN_THROTTLE(1.0, \"Robot base frame does not match costmap frame.  Reseting robot pose.\");\n\t\t\tnew_pose.header.frame_id = robot_base_frame_;\n\t\t}\n\t} else {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose.  Cancelling reconfigure request.\");\n\t\tconfig_srv_->request.config.reset();\n\t\treturn;\n\t}\n\tif (new_pose.header.frame_id!= robot_base_frame_) {\n\t\tROS_WARN_THROTTLE(1.0, \"Robot base frame does not match costmap frame.  Reseting robot pose.\");\n\t\tnew_pose.header.frame_id = robot_base_frame_;\n\t}\n\tif (new_pose.header.stamp <= last_published_pose_.header.stamp) {\n\t\tROS_WARN_THROTTLE(1.0, \"Received old robot pose.  Cancelling reconfigure request.\");\n\t\tconfig_srv_->request.config.reset();\n\t\treturn;\n\t}\n\tconfig_srv_->request.config.reset();\n\tconfig_srv_->request.config.update_frequency = update_frequency_;\n\tconfig_srv_->request.config.publish_frequency = publish_frequency_;\n\tconfig_srv_->request.config.global_frame = global_frame_;\n\tconfig_srv_->request.config.robot_base_frame = robot_base_frame_;\n\tconfig_srv_->request.config.robot_base_frame = robot_base_frame_;\n\tconfig_srv_->request.config.robot_base_frame = robot_base_frame_;\n\tconfig_srv_->request.config.footprint = footprint_;\n\tconfig_srv_->request.config.rolling_window = rolling_window_;\n\tconfig_srv_->request.config.width = width_;\n\tconfig_srv_->request.config.height = height_;\n\tconfig_srv_->request.config.resolution = resolution_;\n\tconfig_srv_->request.config.origin_x = origin_x_;\n", "CodeBleu_score": 44.055952066505455}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// Get the robot's current pose\n\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration.\");\n\t\tcancelReconfiguration();\n\t\treturn;\n\t}\n\n\t// If the robot's current pose is different from the previous pose, update the costmap\n\tif (!new_pose.isApprox(old_pose, 1e-3)) {\n\t\told_pose = new_pose;\n\t\tupdateCostmap();\n\t}\n}", "CodeBleu_score": 63.483895812711644}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\tros::V_string plugins;\n\tlayered_costmap_->getPlugins(plugins);\n\tfor (ros::V_string::iterator plugin = plugins.begin(); plugin!= plugins.end(); ++plugin) {\n\t\tif (stopped_) {\n\t\t\t(*plugin)->activate();\n\t\t}\n\t}\n\tstopped_ = false;\n\tstop_updates_ = false;\n\tros::Rate r(30);\n\twhile (!ros::ok()) {\n\t\tr.sleep();\n\t}\n\tif (!initialized_) {\n\t\tROS_WARN(\"Costmap2DROS is waiting for the map to be loaded before starting up.\");\n\t\treturn;\n\t}\n\tif (!update_thread_->isRunning()) {\n\t\tROS_WARN(\"Costmap2DROS is waiting for the map update thread to start before starting up.\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Costmap2DROS started\");\n}", "CodeBleu_score": 50.62349357381456}, {"code": "void Costmap2DROS::start(){\n\t\tros::Time start_time = ros::Time::now();\n\tros::Rate r(10);\n\twhile (!ros::ok()) {\n\t\tr.sleep();\n\t\tif (ros::Time::now() - start_time > ros::Duration(1, 0)) {\n\t\t\tROS_ERROR(\n\t\t\t\t\t\"Costmap2DROS::start: Ros is not running, unable to start the costmap.\");\n\t\t\tros::shutdown();\n\t\t}\n\t}\n\tif (!is_initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"Costmap2DROS::start: The costmap is not initialized yet, unable to start the costmap.\");\n\t\tros::shutdown();\n\t}\n\tif (map_update_thread_.joinable()) {\n\t\tROS_ERROR(\n\t\t\t\t\"Costmap2DROS::start: The costmap is already running, unable to start it again.\");\n\t\tros::shutdown();\n\t}\n\tif (stopped_) {\n\t\tROS_WARN(\n\t\t\t\t\"Costmap2DROS::start: The costmap was stopped, re-activating the plugins.\");\n\t\tfor (auto plugin : plugins_) {\n\t\t\tplugin->activate();\n\t\t}\n\t\tstopped_ = false;\n\t}\n\tstop_updates_ = false;\n\tmap_update_thread_ = std::thread(&Costmap2DROS::mapUpdateLoop, this);\n}", "CodeBleu_score": 41.51970283642517}, {"code": "void Costmap2DROS::start(){\n\t\tros::Time start_time = ros::Time::now();\n\tif (!is_running_) {\n\t\tROS_INFO(\"Starting costmap with %zu plugins on the %zu layers\", plugins_->size(), layers_->size());\n\t\tif (stopped_) {\n\t\t\tfor (std::vector<LayeredCostmap*>::iterator plugin = plugins_->begin(); plugin!= plugins_->end(); plugin++) {\n\t\t\t\t(*plugin)->activate();\n\t\t\t}\n\t\t\tstopped_ = false;\n\t\t}\n\t\tstop_updates_ = false;\n\t\twhile (!ros::ok() &&!map_received_ &&!map_update_thread_->is_running()) {\n\t\t\tros::Duration(0.1).sleep();\n\t\t}\n\t\tif (map_received_) {\n\t\t\tmap_update_thread_->start();\n\t\t\tROS_INFO(\"Costmap started, time elapsed: %.2f seconds\", (ros::Time::now() - start_time).toSec());\n\t\t} else {\n\t\t\tROS_ERROR(\"Could not start costmap, no map received yet...\");\n\t\t}\n\t}\n}", "CodeBleu_score": 48.92393931886209}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == ros::Duration(0.0)) {\n\t\tobservation_list_.clear();\n\t} else {\n\t\t// Iterate through the list and remove observations that are older than the specified keep time\n\t\tfor (std::list<Observation>::iterator it = observation_list_.begin(); it!= observation_list_.end(); ) {\n\t\t\tif ((ros::Time::now() - it->timestamp) > observation_keep_time_) {\n\t\t\t\tit = observation_list_.erase(it);\n\t\t\t} else {\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.828692576707866}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == ros::Duration(0)) {\n\t\tobservation_list_.erase(observation_list_.begin(), observation_list_.end());\n\t} else {\n\t\twhile (observation_list_.size() > 0 && observation_list_.back().time_ - observation_list_.front().time_ > observation_keep_time_) {\n\t\t\tobservation_list_.pop_back();\n\t\t}\n\t}\n}", "CodeBleu_score": 32.09993321704278}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == ros::Duration(0.0)) {\n\t\tobservation_list_.clear();\n\t} else {\n\t\tfor (ObservationList::iterator it = observation_list_.begin(); it!= observation_list_.end(); it++) {\n\t\t\tif (it->time_stamp_ + observation_keep_time_ > ros::Time::now()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tit = observation_list_.erase(it);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.35874975520987}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Get the start and end yaw angles\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\tdouble shortest_angular_distance = shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose in the range\n\tdouble incremental_angle = shortest_angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the range\n\tfor (int i = start_index; i <= end_index; i++) {\n\t\tdouble current_yaw = tf2::getYaw(path[i].pose.orientation);\n\t\tdouble updated_yaw = current_yaw + incremental_angle;\n\t\tpath[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), updated_yaw));\n\t}\n}", "CodeBleu_score": 56.72468946667378}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Calculate the yaw angles at the start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble shortest_yaw_distance = shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose\n\tfor (int i = start_index; i <= end_index; i++) {\n\t\tdouble current_yaw = tf2::getYaw(path[i].pose.orientation);\n\t\tdouble delta_yaw = shortest_yaw_distance / (end_index - start_index);\n\t\tdouble interpolated_yaw = current_yaw + delta_yaw;\n\t\ttf2::Quaternion interpolated_orientation;\n\t\ttf2::convert(tf2::getYaw(interpolated_yaw), interpolated_orientation);\n\t\tpath[i].pose.orientation = tf2::toMsg(interpolated_orientation);\n\t}\n}", "CodeBleu_score": 51.966966471816136}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Get the yaw angles at the start and end indices.\n\tdouble start_angle = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end angles.\n\tdouble delta_angle = shortest_angular_distance(start_angle, end_angle);\n\n\t// Get the incremental change in angle for each pose in the specified range.\n\tdouble delta_angle_per_pose = delta_angle / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range.\n\tfor (int i = start_index; i < end_index; i++) {\n\t\tdouble current_angle = tf2::getYaw(path[i].pose.orientation);\n\t\tdouble new_angle = current_angle + delta_angle_per_pose;\n\t\tpath[i].pose.orientation = tf2::getYaw(new_angle);\n\t}\n}", "CodeBleu_score": 55.77656165504864}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t//set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t//call makePlan to generate a path\n\tbool found_path = makePlan(req.start, req.goal, req.tolerance, resp.plan);\n\n\t//update the response with the success status and the generated path if a plan is found\n\tresp.found_path = found_path;\n\tif(found_path) {\n\t\tresp.plan.header.frame_id = \"map\";\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 60.65258838107819}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tros::Time start_time = ros::Time::now();\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got request to make a plan\");\n\t//ROS_INFO(\"Got", "CodeBleu_score": 6.50323030198746}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"PlannerWithCostmap::makePlanService\");\n\t// set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\t// call makePlan to generate a path\n\tif (makePlan(req.start, req.goal, resp.plan)) {\n\t\tresp.success = true;\n\t\treturn true;\n\t}\n\telse {\n\t\tresp.success = false;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 48.909491900484944}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tprivate_nh = ros::NodeHandle(\"~/\" + name);\n\tmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tgoal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 68.21300488277734}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\t// TODO Auto-generated constructor stub\n\n}", "CodeBleu_score": 18.654488076502528}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tprivate_nh.reset(new ros::NodeHandle(\"~/\" + name));\n\tprivate_nh->param(\"planner_frequency\", planner_frequency, 0.0);\n\tprivate_nh->param(\"escape_vel\", escape_vel, 0.0);\n\tprivate_nh->param(\"escape_angle\", escape_angle, 0.0);\n\tprivate_nh->param(\"escape_radius\", escape_radius, 0.0);\n\tprivate_nh->param(\"escape_angle_threshold\", escape_angle_threshold, 0.0);\n\tprivate_nh->param(\"escape_vel_threshold\", escape_vel_threshold, 0.0);\n\tprivate_nh->param(\"escape_radius_threshold\", escape_radius_threshold, 0.0);\n\tprivate_nh->param(\"escape_angle_threshold_vel\", escape_angle_threshold_vel, 0.0);\n\tprivate_nh->param(\"escape_vel_threshold_vel\", escape_vel_threshold_vel, 0.0);\n\tprivate_nh->param(\"escape_radius_threshold_vel\", escape_radius_threshold_vel, 0.0);\n\tprivate_nh->param(\"escape_angle_threshold_vel_vel\", escape_angle_threshold_vel_vel, 0.0);\n\tprivate_nh->param(\"escape_vel_threshold_vel_vel\", escape_vel_threshold_vel_vel, 0.0);\n\tprivate_nh->param(\"escape_radius_threshold_vel_vel\", escape_radius_threshold_vel_vel, 0.0);\n\tprivate_nh->param(\"escape_angle_threshold_vel_vel_vel\", escape_angle_threshold_vel_vel_vel, 0.0);\n\tprivate_nh->param(\"escape_vel_threshold_vel_vel_vel\", escape_vel_threshold_vel_vel_vel, 0.0);\n\tprivate_nh->param(\"escape_radius_threshold_vel_vel_vel\", escape_radius_threshold_vel_vel_vel, 0.0);\n\tprivate_nh->param(\"escape_angle_threshold_vel_vel_vel_vel\", escape_angle_threshold_vel_vel_vel_vel, ", "CodeBleu_score": 33.36071870473416}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\t// Check if the world coordinates are within the bounds of the costmap's origin\n\tif (wx < costmap_->getOriginX() || wx >= costmap_->getOriginX() + costmap_->getSizeInCellsX() * costmap_->getResolution() || wy < costmap_->getOriginY() || wy >= costmap_->getOriginY() + costmap_->getSizeInCellsY() * costmap_->getResolution()) {\n\t\treturn false;\n\t}\n\n\t// Calculate the map coordinates using the costmap's resolution and an offset\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\t// Check if the map coordinates are within the costmap's size limits\n\tif (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 43.99764203742268}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy < costmap_->getOriginY() || wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\tROS_WARN(\"The point (%f, %f) is not in the costmap\", wx, wy);\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 41.459243363310804}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\tROS_ERROR(\"The point (%f, %f) is not in the costmap's bounds.\", wx, wy);\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 41.418296294381406}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tROS_INFO", "CodeBleu_score": 5.009782618257397}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tgui_path.header.frame_id = global_frame_;\n\tgui_path.header.stamp = ros::Time::now();\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 80.74550311998453}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 82.53666226729315}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In move_base goal callback\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 74.77258275308837}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In move_base goal callback\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.header.frame_id = goal->header.frame_id;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal.goal.target_pose.header.stamp = ros::Time::now();\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 69.1480368532453}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In move_base::goalCB, received a goal of type PoseStamped\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.header.frame_id = goal->header.frame_id;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal.goal.target_pose.header.stamp = ros::Time::now();\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 68.0912755090842}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (distance_check_timer_.is_active()) {\n\t\tdouble squared_distance = 0.0;\n\t\tsquared_distance = (robot_pose_.x - last_robot_pose_.x) * (robot_pose_.x - last_robot_pose_.x) + (robot_pose_.y - last_robot_pose_.y) * (robot_pose_.y - last_robot_pose_.y);\n\t\tif (squared_distance > limited_distance_squared_) {\n\t\t\tROS_INFO(\"Robot has moved %f meters\", sqrt(squared_distance));\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t\tremove_limit_thread_ = NULL;\n\t\t\tdistance_check_timer_.stop();\n\t\t}\n\t}\n}", "CodeBleu_score": 49.49822840300369}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (limit_distance_squared_ > distance_squared_) {\n\t\tROS_INFO(\"Robot has moved far enough, stopping distance check timer\");\n\t\tdistance_check_timer_.stop();\n\t\tremove_limit_thread_->join();\n\t\tdelete remove_limit_thread_;\n\t\tremove_limit_thread_ = NULL;\n\t\tstop_distance_check_ = true;\n\t}\n}", "CodeBleu_score": 36.47264114469985}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\t//ROS_INFO(\"Distance check timer started\");\n\tif (distance_check_timer_.isStarted()) {\n\t\tif (distance_check_timer_.isExpired()) {\n\t\t\tROS_INFO(\"Distance check timer expired\");\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t\tremove_limit_thread_ = NULL;\n\t\t\tdistance_check_timer_.stop();\n\t\t}\n\t}\n}", "CodeBleu_score": 46.98840915834066}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Received a new goal pose\");\n\tcurrent_goal_ = *goal;\n\tmakePlan(current_pose_, current_goal_, plan_);\n}", "CodeBleu_score": 30.19570076617988}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Got new goal pose\");\n\tgoal_ = *goal;\n\t// getRobotPose(robot_pose);\n\t// makePlan(robot_pose, goal_, plan);\n}", "CodeBleu_score": 18.769197013928984}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Goal pose received\");\n\tgoal_pose_ = *goal;\n\tmakePlan(global_pose_, goal_pose_, plan_);\n}", "CodeBleu_score": 32.3216962284313}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create a service request with the provided parameter ID and value\n\tautopilot_msgs::ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.value = param_set.value;\n\n\t// Call the param_set_client_ to send the request\n\tif (this->param_set_client_.call(srv)) {\n\t\tROS_INFO(\"Param Set request sent\");\n\t} else {\n\t\tROS_ERROR(\"Failed to call service param_set\");\n\t}\n}", "CodeBleu_score": 62.66117155680115}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tstd_srvs::SetBool::Request req;\n\tstd_srvs::SetBool::Response res;\n\treq.data = true;\n\n\tswitch (param_set.param_id) {\n\t\tcase 0:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\treq.data = param_set.param_value;\n\t\t\tbreak;\n\t", "CodeBleu_score": 36.862009587957886}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tparam_set_srv_.request.param_id = param_set.param_id;\n\tparam_set_srv_.request.value = param_set.value;\n\tparam_set_client_.call(param_set_srv_);\n}", "CodeBleu_score": 51.020672282766164}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\tint sockfd, newsockfd, portno, clilen;\n\tstruct sockaddr_in serv_addr, cli_addr;\n\tint n;\n\tsocklen_t clilen;\n\tchar buffer[256];\n\tchar *recvMsg;\n\tchar *pubMsg;\n\tint recvMsgLen;\n\tint pubMsgLen;\n\tstruct timeval timeout;\n\ttimeout.tv_sec = 1;\n\ttimeout.tv_usec = 0;\n\n\tROS_INFO(\"Waiting for connection from ground station...\");\n\n\tsockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sockfd < 0) {\n\t\tROS_ERROR(\"ERROR opening socket\");\n\t\texit(1);\n\t}\n\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tportno = 5001;\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(portno);\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tROS_ERROR(\"ERROR on binding\");\n\t\texit(1);\n\t}\n\tlisten(sockfd, 5);\n\tclilen = sizeof(cli_addr);\n\tnewsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\tif (newsockfd < 0) {\n\t\tROS_ERROR(\"ERROR on accept\");\n\t\texit(1);\n\t}\n\n\tROS_INFO(\"Connection from ground station established.\");\n\n\twhile (1) {\n\t\tn = read(newsockfd, buffer, 255);\n\t\tif (n < 0) {\n\t\t\tROS_ERROR(\"ERROR reading from socket\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (n == 0) {\n\t\t\tROS_ERROR(\"Connection closed by ground station.\");\n\t\t\tclose(newsockfd);\n\t\t\texit(0);\n\t\t}\n\n\t\trecvMsg = (char *) malloc(n * sizeof(char));\n\t\tmemcpy(recvMsg, buffer, n);\n\t\trecvMsgLen = n;", "CodeBleu_score": 44.10262851600112}, {"code": "void CommunicationBridge::serverFun(){\n\t\tint serverSocket;\n\tint clientSocket;\n\tstruct sockaddr_in serverAddr;\n\tstruct sockaddr_in clientAddr;\n\tsocklen_t clientAddrLen;\n\n\tserverSocket = socket(AF_INET, SOCK_STREAM, 0);\n\tif (serverSocket < 0) {\n\t\tperror(\"ERROR opening socket\");\n\t\texit(1);\n\t}\n\n\tbzero((char *) &serverAddr, sizeof(serverAddr));\n\tserverAddr.sin_family = AF_INET;\n\tserverAddr.sin_addr.s_addr = INADDR_ANY;\n\tserverAddr.sin_port = htons(PORT);\n\n\tif (bind(serverSocket, (struct sockaddr *) &serverAddr, sizeof(serverAddr)) < 0) {\n\t\tperror(\"ERROR on binding\");\n\t\texit(1);\n\t}\n\n\tlisten(serverSocket, 5);\n\n\tclientAddrLen = sizeof(clientAddr);\n\n\twhile (1) {\n\t\tclientSocket = accept(serverSocket, (struct sockaddr *) &clientAddr, &clientAddrLen);\n\t\tif (clientSocket < 0) {\n\t\t\tperror(\"ERROR on accept\");\n\t\t\texit(1);\n\t\t}\n\n\t\tROS_INFO(\"Connection accepted from client\");\n\n\t\twhile (1) {\n\t\t\tchar buffer[BUFFER_SIZE];\n\t\t\tint n;\n\n\t\t\tn = recv(clientSocket, buffer, BUFFER_SIZE, 0);\n\t\t\tif (n <= 0) {\n\t\t\t\tROS_ERROR(\"ERROR reading from socket\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdecodeMsg(buffer);\n\n\t\t\tbzero(buffer, BUFFER_SIZE);\n\t\t}\n\n\t\tclose(clientSocket);\n\t}\n\n\tclose(serverSocket);\n}", "CodeBleu_score": 44.62029229624387}, {"code": "void CommunicationBridge::serverFun(){\n\t\tint serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n\tif (serverSocket < 0) {\n\t\tperror(\"Error opening socket\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tstruct sockaddr_in serverAddr;\n\tserverAddr.sin_family = AF_INET;\n\tserverAddr.sin_port = htons(port);\n\tserverAddr.sin_addr.s_addr = INADDR_ANY;\n\tif (bind(serverSocket, (struct sockaddr *) &serverAddr, sizeof(serverAddr)) < 0) {\n\t\tperror(\"Error binding\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (listen(serverSocket, 1) < 0) {\n\t\tperror(\"Error listening\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tstruct sockaddr_in clientAddr;\n\tsocklen_t clientAddrLen = sizeof(clientAddr);\n\tint clientSocket;\n\twhile (true) {\n\t\tclientSocket = accept(serverSocket, (struct sockaddr *) &clientAddr, &clientAddrLen);\n\t\tif (clientSocket < 0) {\n\t\t\tperror(\"Error accepting\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tROS_INFO(\"Accepted connection from %s:%d\", inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port));\n\t\tchar buf[1024];\n\t\tint numBytes;\n\t\twhile ((numBytes = recv(clientSocket, buf, 1024, 0)) > 0) {\n\t\t\tdecodeMsg(buf, numBytes);\n\t\t}\n\t\tif (numBytes <= 0) {\n\t\t\tROS_ERROR(\"Error receiving data\");\n\t\t}\n\t\tclose(clientSocket);\n\t}\n\tclose(serverSocket);\n}", "CodeBleu_score": 46.34496605255305}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\n// If not in simulation mode, publish the command to a single UAV using uav_basic_", "CodeBleu_score": 2.751107738278642}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (this->sim_mode_) {\nif (this->swarm_control_simulation_.find(uav_cmd.uav_id)!= this->swarm_control_simulation_.end()) {\nthis->swarm_control_simulation_[uav_cmd.uav_id]->uavCmdPub.publish(uav_cmd);\n}\n} else {\nthis->uav_basic_.uavCmdPub.publish(uav_cmd);\n}\n}", "CodeBleu_score": 29.68389422711155}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->uav_basic_->simulation_mode) {\n\t\t// Find the UAV in the swarm and publish the command\n\t\tstd::map<int, std::shared_ptr<UAVBasic>>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= this->swarm_control_simulation_.end()) {\n\t\t\t(*it).second->uavCmdPub(uav_cmd);\n\t\t}\n\t} else {\n\t\t// Publish the command to the UAV\n\t\tthis->uav_basic_->uavCmdPub(uav_cmd);\n\t}\n}", "CodeBleu_score": 54.61806545225954}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == 1) {\n\t\tdeleteMode(mode_selection.mode);\n\t}\n\telse if (mode_selection.use_mode == 2) {\n\t\tcreateMode(mode_selection.mode);\n\t}\n\telse if (mode_selection.use_mode == 3) {\n\t\tsystem(\"reboot\");\n\t\texit(0);\n\t}\n}", "CodeBleu_score": 36.00963823452395}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch (mode_selection.use_mode) {\n\t\tcase REBOOTNX:\n\t\t\tsystem(\"reboot\");\n\t\t\tbreak;\n\t\tcase EXITNX:\n\t\t\tsystem(\"exit\");\n\t\t\tbreak;\n\t\tcase CREATE:\n\t\t\tcreateMode(mode_selection);\n\t\t\tbreak;\n\t\tcase DELETE:\n\t\t\tdeleteMode(mode_selection);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 35.44468694768237}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exit\");\n\t} else if (mode_selection.use_mode == CREATE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 49.035775407081346}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tros::Time currentTime = ros::Time::now();\n\tros::Duration elapsedTime = currentTime - lastHeartbeatTime;\n\n\t// If the elapsed time is greater than the heartbeat timeout, then the heartbeat has not been received for a specified number of attempts\n\tif (elapsedTime.toSec() > heartbeatTimeout) {\n\t\t// If the heartbeat count has not changed for a specified number of attempts, then the heartbeat has not been received\n\t\tif (heartbeatCount == heartbeatCountThreshold) {\n\t\t\tROS_ERROR(\"Heartbeat timeout. Disconnecting from vehicle.\");\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t\t// Increment the heartbeat count\n\t\theartbeatCount++;\n\t}\n\t// If the elapsed time is less than the heartbeat timeout, then the heartbeat has been received\n\telse {\n\t\t// Reset the heartbeat count\n\t\theartbeatCount = 0;\n\t}\n}", "CodeBleu_score": 28.577805682538436}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t//std::cout << \"checkHeartbeatState\" << std::endl;\n\t//std::cout << \"heartbeat_count: \" << heartbeat_count << std::endl;\n\tif (heartbeat_count == 0) {\n\t\t//std::cout << \"heartbeat_count: \" << heartbeat_count << std::endl;\n\t\t//std::cout << \"heartbeat_count == 0\" << std::endl;\n\t\tif (disconnect_flag == false) {\n\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false\" << std::endl;\n\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\tif (type == \"swarm\") {\n\t\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t\t//std::cout << \"heartbeat_count == 0, disconnect_flag == false, type: \" << type << std::endl;\n\t\t\t", "CodeBleu_score": 3.2248779167340693}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tros::Time current_time = ros::Time::now();\n\tstd::string heartbeat_topic_name;\n\tstd::string heartbeat_topic_type;\n\tstd::string heartbeat_topic_id;\n\tstd::string heartbeat_topic_status;\n\tstd::string heartbeat_topic_time;\n\tstd::string heartbeat_topic_time_string;\n\tstd::string heartbeat_topic_time_string_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted;\n\tstd::string heartbeat_topic_time_string_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted_formatted", "CodeBleu_score": 10.395536493347386}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->traj.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.drone_id = msg->traj[i].drone_id;\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\t\tbspline.knots.resize(msg->traj[i].knots.size());\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots[j] = msg->traj[i].knots[j];\n\t\t}\n\t\tbspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts[j] = msg->traj[i].pos_pts[j];\n\t\t}\n\t\tbspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n\t\t}\n\t\tthis->communication->sendMsgByTcp(this->communication->encodeMsg(bspline));\n\t}\n}", "CodeBleu_score": 54.79314470007952}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->traj.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.id = msg->traj[i].id;\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\t\tbspline.knots.resize(msg->traj[i].knots.size());\n\t\tbspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n\t\tbspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots[j].x = msg->traj[i].knots[j].x;\n\t\t\tbspline.knots[j].y = msg->traj[i].knots[j].y;\n\t\t\tbspline.knots[j].z = msg->traj[i].knots[j].z;\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts[j].x = msg->traj[i].pos_pts[j].x;\n\t\t\tbspline.pos_pts[j].y = msg->traj[i].pos_pts[j].y;\n\t\t\tbspline.pos_pts[j].z = msg->traj[i].pos_pts[j].z;\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n\t\t}\n\t\tthis->communication->sendMsgByTcp(this->communication->encodeMsg(bspline));\n\t}\n}", "CodeBleu_score": 61.406616576181236}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb\");\n\tfor (int i = 0; i < msg->traj.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.id = msg->traj[i].drone_id;\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\t\tbspline.knots.resize(msg->traj[i].knots.size());\n\t\tbspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n\t\tbspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots[j] = msg->traj[i].knots[j];\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts[j] = msg->traj[i].pos_pts[j];\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n\t\t}\n\t\tthis->communication->sendMsgByTcp(this->communication->encodeMsg(bspline));\n\t}\n}", "CodeBleu_score": 54.4723271782014}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out_filtered_downsampled_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\toctree_compression.setInputCloud(cloud);\n\toctree_compression.addPointsFromInputCloud();\n\toctree_compression.setResolution(resolution);\n\toctree_compression.filterPointCloud(*cloud_out);\n\n\tpcl::VoxelGrid<pcl::PointXYZ> voxel_grid;\n\tvoxel_grid.setInputCloud(cloud_out);\n\tvoxel_grid.setLeafSize(leaf_size, leaf_size, leaf_size);\n\tvoxel_grid.filter(*cloud_out_filtered);\n\n\tpcl::VoxelGrid<pcl::PointXYZ> voxel_grid_filtered;\n\tvoxel_grid_filtered.setInputCloud(cloud_out_filtered);\n\tvoxel_grid_filtered.setLeafSize(leaf_size, leaf_size, leaf_size);\n\tvoxel_grid_filtered.filter(*cloud_out_filtered_downsampled);\n\n\tpcl::VoxelGrid<pcl::PointXYZ> voxel_grid_filtered_downsampled;\n\tvoxel_grid_filtered_downsampled.setInputCloud(cloud_out_filtered_downsampled);\n\tvoxel_grid_filtered_downsampled.setLeafSize(leaf_size, leaf_size, leaf_size);\n\tvoxel_grid_filtered_downsampled.filter(*cloud_out_filtered_downsampled_filtered);\n\n\tsensor_msgs::PointCloud2 msg_out;\n\tpcl::toROSMsg(*cloud_out_filtered_downsampled_filtered, msg_out);\n\treturn msg_out;", "CodeBleu_score": 46.34543636279788}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\npcl::fromROSMsg(msg, cloud);\npcl::PointCloud<pcl::PointXYZ> cloud_compressed;\noctree_compression.setInputCloud(cloud);\noctree_compression.setLeafSize(0.01, 0.01, 0.01);\noctree_compression.filter(cloud_compressed);\npcl::toROSMsg(cloud_compressed, compressed_data);\ncompressed_data.header = msg.header;\ncompressed_data.header.frame_id = \"map\";\ncompressed_data.is_bigendian = false;\ncompressed_data.is_dense = true;\ncompressed_data.width = compressed_data.data.size();\ncompressed_data.height = 1;\ncompressed_data.point_step = 3 * sizeof(float);\ncompressed_data.row_step = 3 * sizeof(float);\ncompressed_data.is_bigendian = false;\ncompressed_data.fields.resize(3);\ncompressed_data.fields[0].name = \"x\";\ncompressed_data.fields[0].offset = 0;\ncompressed_data.fields[0].datatype = 7;\ncompressed_data.fields[0].count = 1;\ncompressed_data.fields[1].name = \"y\";\ncompressed_data.fields[1].offset = 4;\ncompressed_data.fields[1].datatype = 7;\ncompressed_data.fields[1].count = 1;\ncompressed_data.fields[2].name = \"z\";\ncompressed_data.fields[2].offset = 8;\ncompressed_data.fields[2].datatype = 7;\ncompressed_data.fields[2].count = 1;\ncompressed_data.data.resize(compressed_data.row_step * compressed_data.height);\nstd::memcpy(&compressed_data.data[0], compressed_str.data(), compressed_str.size());\ncompressed_data.data.resize(compressed_str.size());\nreturn compressed_data;\n}", "CodeBleu_score": 39.31089610003082}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZ> pcl_msg;\n\tpcl::fromROSMsg(msg, pcl_msg);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr pcl_msg_ptr(new pcl::PointCloud<pcl::PointXYZ>(pcl_msg));\n\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr pcl_msg_ptr_compressed(new pcl::PointCloud<pcl::PointXYZ>);\n\toctree_compression.setInputCloud(pcl_msg_ptr);\n\toctree_compression.filter(*pcl_msg_ptr_compressed);\n\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tpcl::toROSMsg(*pcl_msg_ptr_compressed, compressed_msg);\n\treturn compressed_msg;\n}", "CodeBleu_score": 28.662581188461512}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 82.33433920515986}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 91.53973655827699}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 91.53973655827699}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tm_multi_ugv_state.ugv_state_all.clear();\n\tint ugv_count = 0;\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state.size(); i++) {\n\t\tUGVState ugv_state_msg;\n\t\tugv_state_msg.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state_msg.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tugv_state_msg.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tugv_state_msg.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\t\tugv_count++;\n\t\tm_multi_ugv_state.ugv_state_all.push_back(ugv_state_msg);\n\t}\n\tm_multi_ugv_state.ugv_count = ugv_count;\n\tm_all_ugv_state_pub_.publish(m_multi_ugv_state);\n}", "CodeBleu_score": 45.29917606588919}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Initialize a MultiUGVState message\n\tMultiUGVState multi_ugv_state;\n\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state_all.size(); i++) {\n\t\t// Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tUGVState ugv_state;\n\t\tugv_state.ugv_id = m_multi_ugv_state.ugv_state_all[i].ugv_id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state_all[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state_all[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state_all[i].position.y;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state_all[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state_all[i].velocity.y;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_state_all[i].attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_state_all[i].attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_state_all[i].attitude.yaw;\n\n\t\t// Add the UGVState message to the MultiUGVState message\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t}\n\n\t// Increment the UGV count\n\tmulti_ugv_state.ugv_count = m_multi_ugv_state.ugv_state_all.size();\n\n\t// Publish the MultiUGVState message\n\tthis->all_ugv_state_pub_.", "CodeBleu_score": 45.403673078916725}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tm_multi_ugv_state.ugv_state_all.clear();\n\tm_multi_ugv_state.ugv_count = 0;\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state_all.size(); i++) {\n\t\tm_multi_ugv_state.ugv_count++;\n\t\tm_multi_ugv_state.ugv_state_all.push_back(UGVState());\n\t\tm_multi_ugv_state.ugv_state_all.back().ugv_id = m_multi_ugv_state.ugv_state_all[i].ugv_id;\n\t\tm_multi_ugv_state.ugv_state_all.back().battery = m_multi_ugv_state.ugv_state_all[i].battery;\n\t\tm_multi_ugv_state.ugv_state_all.back().position.x = m_multi_ugv_state.ugv_state_all[i].position.x;\n\t\tm_multi_ugv_state.ugv_state_all.back().position.y = m_multi_ugv_state.ugv_state_all[i].position.y;\n\t\tm_multi_ugv_state.ugv_state_all.back().position.z = m_multi_ugv_state.ugv_state_all[i].position.z;\n\t\tm_multi_ugv_state.ugv_state_all.back().velocity.x = m_multi_ugv_state.ugv_state_all[i].velocity.x;\n\t\tm_multi_ugv_state.ugv_state_all.back().velocity.y = m_multi_ugv_state.ugv_state_all[i].velocity.y;\n\t\tm_multi_ugv_state.ugv_state_all.back().velocity.z = m_multi_ugv_state.ugv_state_all[i].velocity.z;\n\t\tm_multi_ugv_state.ugv_state_all.back().attitude.roll = m_multi_ugv_state", "CodeBleu_score": 28.829052269730564}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize cost and gradient\n\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through control points\n\tfor (int i = 0; i < cps_.points.cols(); i++) {\n\t\t// Compute predicted positions of moving objects\n\t\tEigen::MatrixXd obj_prid = moving_objs_->evaluateConstVel(cps_.points.col(i));\n\n\t\t// Iterate through moving objects\n\t\tfor (int j = 0; j < moving_objs_->getObjNums(); j++) {\n\t\t\t// Compute distance between control point and moving object\n\t\t\tdouble dist = (cps_.points.col(i) - obj_prid.col(j)).norm();\n\n\t\t\t// If distance is less than a specified clearance, update cost and gradient\n\t\t\tif (dist < clearance_) {\n\t\t\t\tcost += pow(dist - clearance_, 2);\n\t\t\t\tgradient.col(i) += 2 * (dist - clearance_) * (cps_.points.col(i) - obj_prid.col(j)).normalized();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.38028666288158}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n// Calculate the predicted positions of moving objects\nEigen::MatrixXd obj_preds = moving_objs_->evaluateConstVel(q);\n\n// Iterate through control points\nfor (int i = 0; i < cps_.points.cols(); i++) {\n\n// Compute the predicted position of the moving object\nEigen::Vector3d obj_pred = obj_preds.col(i);\n\n// Compute the distance between the control point and the predicted position\ndouble dist = (cps_.points.col(i) - obj_pred).norm();\n\n// Check if the distance is less than the clearance\nif (dist < clearance_) {\n\n// Update the cost and gradient\ncost += pow(dist - clearance_, 2);\ngradient.col(i) += 2 * (dist - clearance_) * (cps_.points.col(i) - obj_pred).normalized();\n}\n}\n}", "CodeBleu_score": 33.59882915683669}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tgradient.setZero();\n\tfor (int i = 0; i < cps_.points.rows(); i++) {\n\t\tEigen::Vector3d obj_prid;\n\t\tmoving_objs_->evaluateConstVel(cps_.points.col(i), obj_prid);\n\t\tdouble dist = (cps_.points.col(i) - obj_prid).norm();\n\t\tif (dist < moving_objs_->getClearance()) {\n\t\t\tcost += pow(dist - moving_objs_->getClearance(), 2);\n\t\t\tgradient.col(i) = 2 * (dist - moving_objs_->getClearance()) * (cps_.points.col(i) - obj_prid).normalized();\n\t\t}\n\t}\n}", "CodeBleu_score": 34.0835230125572}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0;\n\tgradient.setZero();\n\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\tEigen::Vector3d qi = q.col(i);\n\t\tEigen::Vector3d qi_ref = ref_pts_[i];\n\t\tEigen::Vector3d qi_ref_prev = ref_pts_[i - 1];\n\t\tEigen::Vector3d qi_ref_next = ref_pts_[i + 1];\n\n\t\tEigen::Vector3d v = (qi_ref - qi).normalized();\n\t\tEigen::Vector3d v_prev = (qi_ref_prev - qi).normalized();\n\t\tEigen::Vector3d v_next = (qi_ref_next - qi).normalized();\n\n\t\tdouble a2 = 1.0 / 20000.0;\n\t\tdouble b2 = 1.0 / 1000000.0;\n\n\t\tdouble d = (qi - qi_ref).norm();\n\t\tdouble d_prev = (qi - qi_ref_prev).norm();\n\t\tdouble d_next = (qi - qi_ref_next).norm();\n\n\t\tdouble cost_i = pow(d, 2) * a2 + pow(d_prev, 2) * b2 + pow(d_next, 2) * b2;\n\t\tcost += cost_i;\n\n\t\tEigen::Vector3d gradient_i = 2 * d * v - 2 * d_prev * v_prev - 2 * d_next * v_next;\n\t\tgradient_i *= a2;\n\t\tgradient.col(i) = gradient_i;\n\t}\n}", "CodeBleu_score": 41.019723431221735}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tgradient.setZero(q.rows(), q.cols());\n\n\tfor (int i = 2; i < q.rows(); i++) {\n\t\tEigen::Vector3d v = (q.row(i) - q.row(i - 1)).normalized();\n\t\tEigen::Vector3d v2 = (q.row(i) - q.row(i - 2)).normalized();\n\t\tEigen::Vector3d xcrossv = xcross(v, v2);\n\t\tdouble a2 = pow(v.norm(), 2);\n\t\tdouble b2 = pow(v2.norm(), 2);\n\t\tdouble q_dot = q.row(i).dot(v);\n\t\tdouble q_dot2 = q.row(i).dot(v2);\n\t\tdouble cost_i = (q_dot * q_dot + q_dot2 * q_dot2) / (a2 + b2);\n\t\tcost += cost_i;\n\t\tEigen::Vector3d gradient_i = (2 * q_dot * v + 2 * q_dot2 * v2) / (a2 + b2);\n\t\tgradient.row(i) = gradient_i;\n\t}\n}", "CodeBleu_score": 37.92606698229364}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0;\n\tgradient.setZero();\n\n\t// Iterate through all control points\n\tfor (int i = 0; i < q.rows(); ++i) {\n\t\t// Compute the position error relative to the reference points\n\t\tEigen::Vector3d x = q.row(i) - ref_pts_[i];\n\n\t\t// Compute the velocity vector\n\t\tEigen::Vector3d v = (q.row(i) - q.row(i - 1)) / dt_;\n\n\t\t// Compute the cost function\n\t\tdouble a = pow(x.norm(), 2) / a2_;\n\t\tdouble b = pow(v.norm(), 2) / b2_;\n\t\tdouble c = x.dot(v) / (a2_ * b2_);\n\t\tdouble d = x.cross(v).norm() / (a2_ * b2_);\n\t\tcost += a + b + c + d;\n\n\t\t// Compute the gradient\n\t\tEigen::Vector3d xcrossv = x.cross(v);\n\t\tgradient.row(i) = 2 * x / a2_ + 2 * v / b2_ + 2 * xcrossv / (a2_ * b2_) + 2 * x.dot(v) * xcrossv / (a2_ * b2_ * b2_);\n\t}\n}", "CodeBleu_score": 39.621353214103266}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0;\n\tfor (int i = 0; i < ctrl_pts.cols; i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows; j++) {\n\t\t\tjerk += pow(ctrl_pts(i, j), 2) * (knot_times(i + 1) - knot_times(i));\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 36.49687259753976}, {"code": "double UniformBspline::getJerk(){\n\t\t//get the derivative of the spline\n\tUniformBspline jerk_traj = getDerivative();\n\n\t//get the knot times and control points of the jerk trajectory\n\tvector<double> jerk_knots = jerk_traj.getKnot();\n\tMatrixXd jerk_ctrl_pts = jerk_traj.getControlPoint();\n\n\t//iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n\tdouble total_jerk = 0;\n\tfor (int i = 0; i < jerk_ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < jerk_ctrl_pts.rows(); j++) {\n\t\t\ttotal_jerk += pow(jerk_ctrl_pts(j, i), 2) * (jerk_knots[i + 1] - jerk_knots[i]);\n\t\t}\n\t}\n\n\t//return the total jerk value\n\treturn total_jerk;\n}", "CodeBleu_score": 50.08494713652534}, {"code": "double UniformBspline::getJerk(){\n\t\t// TODO: Implement this function\n\treturn 0;\n}", "CodeBleu_score": 1.2572655050711705}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1.0;\n\treturn pos;\n}", "CodeBleu_score": 38.401332806414366}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1;\n\treturn pos;\n}", "CodeBleu_score": 37.896344210819656}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << (u - cx_) / fx_, (v - cy_) / fy_, depth, 1;\n\treturn pos;\n}", "CodeBleu_score": 33.508683514788885}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(5, 1)));\n\t} catch (std::invalid_argument& e) {\n\t\tROS_ERROR(\"Failed to extract drone ID from odometry message: %s\", e.what());\n\t}\n}", "CodeBleu_score": 38.24156573002085}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint drone_id = std::stoi(odom.child_frame_id.substr(1));\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (std::exception& e) {\n\t\tROS_ERROR_STREAM(e.what());\n\t}\n}", "CodeBleu_score": 53.605616341035166}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, std::stoi(odom.child_frame_id.substr(0, odom.child_frame_id.find_first_of(\"/\"))));\n\t} catch (std::exception& e) {\n\t\tstd::cerr << \"Error extracting drone ID from odometry message: \" << e.what() << std::endl;\n\t}\n}", "CodeBleu_score": 40.82231536822501}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\tEigen::Vector3d true_pose = drone_pose_pub_[drone_id].getPose();\n\tEigen::Vector3d drone_pose = drone_pose_pub_[drone_id].getPose();\n\tEigen::Vector3d drone_pose_error = drone_pose - true_pose;\n\tEigen::Vector3d drone_pose_error_world = drone_pose_pub_[drone_id].getPoseError();\n\tEigen::Vector3d drone_pose_error_world_camera = drone_pose_pub_[drone_id].getPoseErrorCamera();\n\tEigen::Vector2d drone_pose_error_world_camera_2d = drone_pose_pub_[drone_id].getPoseErrorCamera2D();\n\tEigen::Vector2d drone_pose_error_world_camera_2d_world = drone_pose_pub_[drone_id].getPoseErrorCamera2DWorld();\n\tEigen::Vector3d drone_pose_error_world_camera_3d = drone_pose_pub_[drone_id].getPoseErrorCamera3D();\n\tEigen::Vector3d drone_pose_error_world_camera_3d_world = drone_pose_pub_[drone_id].getPoseErrorCamera3DWorld();\n\tEigen::Vector3d drone_pose_error_world_camera_3d_world_2 = drone_pose_pub_[drone_id].getPoseErrorCamera3DWorld2();\n\tEigen::Vector3d drone_pose_error_world_camera_3d_world_2_2 = drone_pose_pub_[drone_id].getPoseErrorCamera3DWorld2_2();\n\tEigen::Vector3d drone_pose_error_world_camera_3d_world_2_2_2 = drone_pose_pub_[drone_id].getPoseErrorCamera3DWorld2_2_2();\n\tEigen::Vector3d drone_pose_error_world_camera_3d_world_2_2_2_2 = drone_pose_pub_[drone_id].getPoseErrorCamera3DWorld2_2_2_2();\n\tEigen::Vector3d dr", "CodeBleu_score": 23.83005627638395}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the drone's true pose in the camera frame\n\tEigen::Vector3d true_pose = drone_pose_cam_pub_[drone_id].getPose();\n\n\t// Get the drone's true pose in the world frame\n\tEigen::Vector3d true_pose_world = drone_pose_world_pub_[drone_id].getPose();\n\n\t// Compute the pose error\n\tEigen::Vector3d pose_error = true_pose_world - true_pose;\n\tpose_error_pub_[drone_id].publish(pose_error);\n\n\t// Update the debug result\n\tif (pose_error.norm() < 0.05) {\n\t\tdebug_result_pub_[drone_id].publish(true);\n\t} else {\n\t\tdebug_result_pub_[drone_id].publish(false);\n\t}\n}", "CodeBleu_score": 32.779349791320904}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the pose of the drone in the camera frame\n\tEigen::Vector3d drone_pose = drone_poses_[drone_id];\n\t// Compute the pose error\n\tEigen::Vector3d pose_error = drone_pose - camera_pose_;\n\t// Update the debug result\n\tdebug_result_[drone_id] = true;\n\t// Publish the pose error\n\tpose_error_[drone_id].publish(pose_error);\n}", "CodeBleu_score": 17.23762768640546}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\n\twhile (current->cameFrom) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\n\treturn path;\n}", "CodeBleu_score": 78.86875382773461}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= NULL) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 86.81384998871748}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\twhile (current!= nullptr) {\n\t\tpath.push_back(current);\n\t\tcurrent = cameFrom[current];\n\t}\n\treturn path;\n}", "CodeBleu_score": 55.76814128926559}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tstart_idx = Coord2Index(start_pt);\n\tend_idx = Coord2Index(end_pt);\n\n\tif (IsOccupied(start_idx)) {\n\t\tVector3d offset = (start_idx - end_idx).normalized();\n\t\twhile (IsOccupied(start_idx)) {\n\t\t\tstart_idx = Coord2Index(start_pt + offset);\n\t\t}\n\t}\n\n\tif (IsOccupied(end_idx)) {\n\t\tVector3d offset = (end_idx - start_idx).normalized();\n\t\twhile (IsOccupied(end_idx)) {\n\t\t\tend_idx = Coord2Index(end_pt + offset);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 36.84169448874716}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tstart_idx = Coord2Index(start_pt);\n\tend_idx = Coord2Index(end_pt);\n\tif (start_idx.x < 0 || start_idx.x >= m_grid_size.x || start_idx.y < 0 || start_idx.y >= m_grid_size.y || start_idx.z < 0 || start_idx.z >= m_grid_size.z) {\n\t\tstart_idx = Coord2Index(AdjustCoord(start_pt, 1));\n\t}\n\tif (end_idx.x < 0 || end_idx.x >= m_grid_size.x || end_idx.y < 0 || end_idx.y >= m_grid_size.y || end_idx.z < 0 || end_idx.z >= m_grid_size.z) {\n\t\tend_idx = Coord2Index(AdjustCoord(end_pt, 1));\n\t}\n\treturn true;\n}", "CodeBleu_score": 31.740805513870583}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\tif (Occupancy(start_idx) == 1) {\n\t\tVector3d tmp = start_pt;\n\t\twhile (Occupancy(start_idx) == 1) {\n\t\t\tstart_pt = tmp + (start_pt - tmp).normalized() * 0.01;\n\t\t\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (Occupancy(end_idx) == 1) {\n\t\tVector3d tmp = end_pt;\n\t\twhile (Occupancy(end_idx) == 1) {\n\t\t\tend_pt = tmp + (end_pt - tmp).normalized() * 0.01;\n\t\t\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 52.231576037016225}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3d min_id = grid_map::positionToIndex(min_pos, resolution_);\n\tEigen::Vector3d max_id = grid_map::positionToIndex(max_pos, resolution_);\n\tresetBuffer(min_id, max_id);\n}", "CodeBleu_score": 22.300717681167477}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = worldToMap(min_pos);\n\tEigen::Vector3i max_id = worldToMap(max_pos);\n\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.74611176687013}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3d min_id = grid_map::positionToIndex(min_pos, resolution_);\n\tEigen::Vector3d max_id = grid_map::positionToIndex(max_pos, resolution_);\n\tresetBuffer(min_id, max_id);\n}", "CodeBleu_score": 22.300717681167477}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_pt = pt - diff.cwiseMin(min_pt_diff);\n\tEigen::Vector3d max_pt = pt - diff.cwiseMax(max_pt_diff);\n\tEigen::Vector3d new_pt;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (min_pt(i) < 0) {\n\t\t\tnew_pt(i) = 0;\n\t\t} else if (max_pt(i) > map_size(i)) {\n\t\t\tnew_pt(i) = map_size(i);\n\t\t} else {\n\t\t\tnew_pt(i) = min_pt(i);\n\t\t}\n\t}\n\treturn new_pt;\n}", "CodeBleu_score": 37.370778087598175}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_scale(0.0, 0.0, 0.0);\n\tEigen::Vector3d max_scale(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 3; i++) {\n\t\tmin_scale(i) = diff(i) / map_size_(i);\n\t\tmax_scale(i) = (map_size_(i) - diff(i)) / map_size_(i);\n\t}\n\tEigen::Vector3d new_pt(pt);\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (min_scale(i) < 0) {\n\t\t\tnew_pt(i) = camera_pt(i) + min_scale(i) * map_size_(i);\n\t\t} else if (max_scale(i) > 0) {\n\t\t\tnew_pt(i) = camera_pt(i) + max_scale(i) * map_size_(i);\n\t\t}\n\t}\n\treturn new_pt;\n}", "CodeBleu_score": 39.71364539254289}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble min_x = std::numeric_limits<double>::max();\n\tdouble min_y = std::numeric_limits<double>::max();\n\tdouble min_z = std::numeric_limits<double>::max();\n\tdouble max_x = -std::numeric_limits<double>::max();\n\tdouble max_y = -std::numeric_limits<double>::max();\n\tdouble max_z = -std::numeric_limits<double>::max();\n\tfor (int i = 0; i < diff.size(); i++) {\n\t\tif (diff[i] < 0) {\n\t\t\tdouble scale = std::floor(diff[i] / grid_size[i]);\n\t\t\tmin_x = std::max(min_x, scale * grid_size[i]);\n\t\t\tmax_x = std::min(max_x, (scale + 1) * grid_size[i]);\n\t\t} else {\n\t\t\tdouble scale = std::ceil(diff[i] / grid_size[i]);\n\t\t\tmin_x = std::max(min_x, scale * grid_size[i]);\n\t\t\tmax_x = std::min(max_x, (scale + 1) * grid_size[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i < diff.size(); i++) {\n\t\tif (diff[i] < 0) {\n\t\t\tdouble scale = std::floor(diff[i] / grid_size[i]);\n\t\t\tmin_y = std::max(min_y, scale * grid_size[i]);\n\t\t\tmax_y = std::min(max_y, (scale + 1) * grid_size[i]);\n\t\t} else {\n\t\t\tdouble scale = std::ceil(diff[i] / grid_size[i]);\n\t\t\tmin_y = std::max(min_y, scale * grid_size[i]);\n\t\t\tmax_y = std::min(max_y, (scale + 1) * grid_size[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i < diff.size(); i++) {\n\t\tif (diff[i] < 0)", "CodeBleu_score": 44.20140596723058}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\tmd_.last_occ_update_time_ = ros::Time::now();\nif (md_.update_needed_) {\nif (!md_.last_odom_update_time_.isZero()) {\nif ((ros::Time::now() - md_.last_odom_update_time_).toSec() > md_.odom_timeout_) {\nROS_ERROR(\"Odometry timeout.\");\nmd_.odom_timeout_error_ = true;\n} else {\nmd_.odom_timeout_error_ = false;\n}\n}\nif (!md_.last_depth_update_time_.isZero()) {\nif ((ros::Time::now() - md_.last_depth_update_time_).toSec() > md_.depth_timeout_) {\nROS_ERROR(\"Depth timeout.\");\nmd_.depth_timeout_error_ = true;\n} else {\nmd_.depth_timeout_error_ = false;\n}\n}\nif (!md_.last_depth_update_time_.isZero() &&!md_.last_odom_update_time_.isZero()) {\nif ((ros::Time::now() - md_.last_occ_update_time_).toSec() > md_.occ_timeout_) {\nROS_ERROR(\"Occupancy timeout.\");\nmd_.occ_timeout_error_ = true;\n} else {\nmd_.occ_timeout_error_ = false;\n}\n}\nif (md_.last_depth_update_time_.isZero() || md_.last_odom_update_time_.isZero() || md_.last_occ_update_time_.isZero()) {\nROS_ERROR(\"No update available.\");\nmd_.occ_timeout_error_ = true;\n}\nif (!md_.last_depth_update_time_.isZero() &&!md_.last_odom_update_time_.isZero() &&!md_.last_occ_update_time_.isZero()) {\nmd_.update_needed_ = false;\nprojectDepthImage(md_.last_depth_update_time_, md_.last_odom_update_time_, md_.last_occ_update_time_);\nclearAndInflateLocalMap();\n}\n}\n}", "CodeBleu_score": 58.54138535188198}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tmd_.last_occ_update_time_ = ros::Time::now();\n\tif (md_.project_depth_image_) {\n\t\tprojectDepthImage();\n\t\tmd_.project_depth_image_ = false;\n\t}\n\tif (md_.local_map_updated_) {\n\t\tclearAndInflateLocalMap();\n\t\tmd_.local_map_updated_ = false;\n\t}\n\tif (md_.timeout_occ_update_) {\n\t\tmd_.timeout_occ_update_ = false;\n\t\tmd_.occ_update_error_ = true;\n\t\tROS_ERROR(\"Occupancy update timed out.\");\n\t}\n\tif (md_.timeout_odom_update_) {\n\t\tmd_.timeout_odom_update_ = false;\n\t\tmd_.odom_update_error_ = true;\n\t\tROS_ERROR(\"Odometry update timed out.\");\n\t}\n\tif (md_.timeout_depth_update_) {\n\t\tmd_.timeout_depth_update_ = false;\n\t\tmd_.depth_update_error_ = true;\n\t\tROS_ERROR(\"Depth image update timed out.\");\n\t}\n}", "CodeBleu_score": 53.81197398308545}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tmd_.last_occ_update_time_ = ros::Time::now();\n\tif (md_.last_occ_update_time_.toSec() - md_.last_occ_update_time_last_update_.toSec() > 0.1) {\n\t\tmd_.last_occ_update_time_last_update_ = md_.last_occ_update_time_;\n\t\tif (md_.depth_image_received_) {\n\t\t\tprojectDepthImage();\n\t\t\tif (md_.local_map_updated_) {\n\t\t\t\tclearAndInflateLocalMap();\n\t\t\t}\n\t\t}\n\t\tif (md_.odometry_received_) {\n\t\t\tif (md_.odometry_timeout_counter_ > 0) {\n\t\t\t\tmd_.odometry_timeout_counter_--;\n\t\t\t\tif (md_.odometry_timeout_counter_ == 0) {\n\t\t\t\t\tmd_.odometry_timeout_ = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (md_.depth_image_received_) {\n\t\t\tif (md_.depth_image_timeout_counter_ > 0) {\n\t\t\t\tmd_.depth_image_timeout_counter_--;\n\t\t\t\tif (md_.depth_image_timeout_counter_ == 0) {\n\t\t\t\t\tmd_.depth_image_timeout_ = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (md_.odometry_timeout_) {\n\t\t\tmd_.odometry_timeout_counter_ = 10;\n\t\t\tmd_.odometry_timeout_ = false;\n\t\t}\n\t\tif (md_.depth_image_timeout_) {\n\t\t\tmd_.depth_image_timeout_counter_ = 10;\n\t\t\tmd_.depth_image_timeout_ = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 47.50196777031642}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat avg_f = 0;\n\tint num_images = image_fns.size();\n\tfor (int i = 0; i < num_images; i++) {\n\t\tMat img = imread(image_fns[i]);\n\t\tMat gt = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\tMat dt = _load_ellipse_DT(dt_fns[i], gt_angle_radians);\n\t\tfloat f = _ellipse_evaluate_one(img, gt, dt);\n\t\tavg_f += f;\n\t}\n\treturn avg_f / num_images;\n}", "CodeBleu_score": 53.74968595758756}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat avg_f = 0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tvector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i], gt_angle_radians);\n\t\tfloat f = _ellipse_evaluate_one(gt_ellipses, dt_ellipses);\n\t\tavg_f += f;\n\t}\n\treturn avg_f / image_fns.size();\n}", "CodeBleu_score": 55.038996388125085}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat f_measure = 0.0f;\n\tint num_images = image_fns.size();\n\tfor (int i = 0; i < num_images; i++) {\n\t\tMat image = imread(image_fns[i]);\n\t\tMat gt = imread(gt_fns[i]);\n\t\tMat dt = imread(dt_fns[i]);\n\t\tf_measure += _ellipse_evaluate_one(image, gt, dt, gt_angle_radians);\n\t}\n\tf_measure /= num_images;\n\treturn f_measure;\n}", "CodeBleu_score": 54.057935324253}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_diff;\n\tif (foci!= NULL) {\n\t\tangle_diff = _angle_diff_signed(atan2(x - foci[0], y), atan2(x - foci[1], y));\n\t\tif (angle_diff > M_PI) {\n\t\t\tangle_diff -= 2 * M_PI;\n\t\t} else if (angle_diff < -M_PI) {\n\t\t\tangle_diff += 2 * M_PI;\n\t\t}\n\t} else {\n\t\tangle_diff = 0;\n\t}\n\treturn angle_diff;\n}", "CodeBleu_score": 33.14172733041806}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_diff;\n\tfloat angle_diff_signed;\n\n\tif (foci == NULL) {\n\t\treturn 0;\n\t}\n\n\tangle_diff = atan2(y - foci[1], x - foci[0]);\n\tangle_diff_signed = angle_diff;\n\tif (angle_diff < 0) {\n\t\tangle_diff_signed = angle_diff + 2 * M_PI;\n\t}\n\n\treturn angle_diff_signed;\n}", "CodeBleu_score": 36.17768365393504}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat x1 = foci[0];\n\tfloat y1 = foci[1];\n\tfloat x2 = foci[2];\n\tfloat y2 = foci[3];\n\tfloat angle1 = atan2(y - y1, x - x1);\n\tfloat angle2 = atan2(y - y2, x - x2);\n\tfloat angle_diff_signed = angle2 - angle1;\n\tif (angle_diff_signed < 0.0f) {\n\t\tangle_diff_signed += 2.0f * PI;\n\t}\n\treturn angle_diff_signed;\n}", "CodeBleu_score": 33.96946206355448}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint min_x = vp1[start].x;\n\tint max_x = vp1[start].x;\n\tint min_y = vp1[start].y;\n\tint max_y = vp1[start].y;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\tint integral_above = 0;\n\tint integral_below = 0;\n\tfor (int i = min_x; i <= max_x; i++) {\n\t\tint y_above = 0;\n\t\tint y_below = 0;\n\t\tfor (int j = start; j <= end; j++) {\n\t\t\tif (vp1[j].x == i) {\n\t\t\t\ty_above += vp1[j].y;\n\t\t\t\ty_below += vp1[j].y;\n\t\t\t} else if (vp1[j].x < i) {\n\t\t\t\ty_above += (vp1[j].y - vp1[j].x * (vp1[j + 1].y - vp1[j].y) / (vp1[j + 1].x - vp1[j].x));\n\t\t\t} else {\n\t\t\t\ty_below += (vp1[j].y - vp1[j].x * (vp1[j + 1].y - vp1[j].y) / (vp1[j + 1].x - vp1[j].x));\n\t\t\t}\n\t\t}\n\t\tintegral_above += y_above;\n\t\tintegral_below += y_below;\n\t}\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 38.109406455022985}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tint i;\n\tfor (i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\tfor (i = start; i <= end; i++) {\n\t\tintegral_above += (vp1[i].x - min_x) * (vp1[(i + 1) % vp1.size()].y - min_y);\n\t\tintegral_below += (vp1[i].x - min_x) * (vp1[(i - 1 + vp1.size()) % vp1.size()].y - min_y);\n\t}\n\tif (integral_above < integral_below)\n\t\treturn false;\n\treturn true;\n}", "CodeBleu_score": 40.57673352095477}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint i = start;\n\tdouble min_x = 0, max_x = 0, min_y = 0, max_y = 0;\n\tdouble integral_above = 0, integral_below = 0;\n\tdouble x1, y1, x2, y2;\n\twhile (i < end) {\n\t\tx1 = vp1[i].x;\n\t\ty1 = vp1[i].y;\n\t\tx2 = vp1[i + 1].x;\n\t\ty2 = vp1[i + 1].y;\n\t\tif (x1 < min_x) min_x = x1;\n\t\tif (x1 > max_x) max_x = x1;\n\t\tif (y1 < min_y) min_y = y1;\n\t\tif (y1 > max_y) max_y = y1;\n\t\tif (x2 < min_x) min_x = x2;\n\t\tif (x2 > max_x) max_x = x2;\n\t\tif (y2 < min_y) min_y = y2;\n\t\tif (y2 > max_y) max_y = y2;\n\t\tintegral_above += (x1 + x2) * (y2 - y1);\n\t\tintegral_below += (x2 + x1) * (y1 - y2);\n\t\ti++;\n\t}\n\tintegral_above += (x1 + x2) * (y2 - y1);\n\tintegral_below += (x2 + x1) * (y1 - y2);\n\tif (integral_above < integral_below)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "CodeBleu_score": 37.32517766404789}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t//ROS_INFO(\"In ellipse_det_cb\");\n\t//ROS_INFO(\"msg->detections.size() = %d\", msg->detections.size());\n\t//ROS_INFO(\"msg->detections[0].name = %s\", msg->detections[0].name.c_str());\n\t//ROS_INFO(\"msg->detections[0].confidence = %f\", msg->detections[0].confidence);\n\t//ROS_INFO(\"msg->detections[0].detection_id = %d\", msg->detections[0].detection_id);\n\t//ROS_INFO(\"msg->detections[0].detection_type = %d\", msg->detections[0].detection_type);\n\t//ROS_INFO(\"msg->detections[0].pose.pose.position.x = %f\", msg->detections[0].pose.pose.position.x);\n\t//ROS_INFO(\"msg->detections[0].pose.pose.position.y = %f\", msg->detections[0].pose.pose.position.y);\n\t//ROS_INFO(\"msg->detections[0].pose.pose.position.z = %f\", msg->detections[0].pose.pose.position.z);\n\t//ROS_INFO(\"msg->detections[0].pose.pose.orientation.x = %f\", msg->detections[0].pose.pose.orientation.x);\n\t//ROS_INFO(\"msg->detections[0].pose.pose.orientation.y = %f\", msg->detections[0].pose.pose.orientation.y);\n\t//ROS_INFO(\"msg->detections[0].pose.pose.orientation.z = %f\", msg->detections[0].pose.pose.orientation.z);\n\t//ROS_INFO(\"msg->detections[0].pose.pose.orientation.w = %f\", msg->detections[0].pose.pose.orientation.w);\n\t//ROS_INFO(\"msg->detections[0].pose.covariance[0] = %f\", msg->detections[0].pose.covariance[0]);\n\t//ROS_INFO(\"msg->detections[0].pose.covariance[1] = %f\", msg->detections[", "CodeBleu_score": 3.2303832737921976}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t//ROS_INFO(\"ellipse_det_cb\");\n\tbool is_detected = false;\n\tint num_regain = 0;\n\tint num_lost = 0;\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\tprometheus_msgs::DetectionInfo det_info = msg->detections[i];\n\t\t//ROS_INFO(\"ellipse_det_cb: %f\", det_info.ellipse.major_axis_length);\n\t\tif (det_info.object_name == \"T\") {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost = 0;\n\t\t\tis_detected = true;\n\t\t\tellipse_det.major_axis_length = det_info.ellipse.major_axis_length;\n\t\t\tellipse_det.minor_axis_length = det_info.ellipse.minor_axis_length;\n\t\t\tellipse_det.orientation = det_info.ellipse.orientation;\n\t\t\tellipse_det.position.x = det_info.position.x;\n\t\t\tellipse_det.position.y = det_info.position.y;\n\t\t\tellipse_det.position.z = det_info.position.z;\n\t\t\tellipse_det.confidence = det_info.confidence;\n\t\t\tellipse_det.sight_angle.pan = det_info.sight_angle.pan;\n\t\t\tellipse_det.sight_angle.tilt = det_info.sight_angle.tilt;\n\t\t\tellipse_det.sight_angle.roll = det_info.sight_angle.roll;\n\t\t} else {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (ellipse_det.sight_angle.pan!= 0) {\n\t\t\tellipse_det.sight_angle.pan = -ellipse_det.sight_angle.pan;\n\t\t}\n\t\tif (ellipse_det.sight_angle.tilt!= 0) {\n\t\t\tellipse_det.sight_angle.tilt = -", "CodeBleu_score": 52.73954533570304}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0].object_name.c_str());\n\t// ROS_INFO(\"I heard: [%s]\", msg->detection_info[0", "CodeBleu_score": 3.208393536344399}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tdouble x, y, z;\n\tx = cur_pos(0);\n\ty = cur_pos(1);\n\tz = cur_pos(2);\n\treturn Occupy_map_ptr->check_safety(x, y, z, safe_distance);\n}", "CodeBleu_score": 49.70407297243234}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node!= start_node_) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tpath_nodes_.push_back(start_node_);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 52.48418003928481}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 52.63619100589134}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\tpath_nodes_.push_back(current_node);\n\twhile (current_node->parent!= nullptr) {\n\t\tcurrent_node = current_node->parent;\n\t\tpath_nodes_.push_back(current_node);\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 63.176737883522826}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id].get_nei_state = true;\n\tstate_nei[id].id = id;\n\t//ROS_INFO(\"nei_odom_cb: %d\", id);\n}", "CodeBleu_score": 27.94873233422545}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.y);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.x);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.z);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.y);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.x);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.w);\n\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.y);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.x);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.z);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.y);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.x);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.orientation.w);\n\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.z);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.y);\n\t//ROS_INFO(\"nei_odom_cb: %f\", odom->pose.pose.position.x);\n\t//ROS_", "CodeBleu_score": 3.1699249080664136}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif(start_pos.norm() < 5.0) {\n\t\tstate_nei[id].set_pos(odom->pose.pose.position);\n\t\tstate_nei[id].set_height(odom->pose.pose.position.z);\n\t\tget_nei_state[id] = true;\n\t}\n\telse {\n\t\tget_nei_state[id] = false;\n\t}\n}", "CodeBleu_score": 34.84703352011482}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count >= 5) {\n\t\tupdate_count = 0;\n\t\tROS_INFO(\"Updating Astar map with new point cloud data\");\n\t\tupdate_Astar_map();\n\t}\n}", "CodeBleu_score": 40.19424883919157}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tif (!sensor_ready) {\n\t\tsensor_ready = true;\n\t\tsensor_update_counter = 0;\n\t\treturn;\n\t}\n\tsensor_update_counter++;\n\tif (sensor_update_counter % 5!= 0) {\n\t\treturn;\n\t}\n\tsensor_update_counter = 0;\n\tsensor_ready = false;\n\tsensor_update_counter = 0;\n\n\t//ROS_INFO(\"Gpointcloud_cb\");\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", msg->width);\n\n\tpcl::PointCloud<pcl::PointXYZI> cloud;\n\tpcl::fromROSMsg(*msg, cloud);\n\n\tif (cloud.points.size() == 0) {\n\t\treturn;\n\t}\n\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", cloud.points.size());\n\n\tpcl::PointCloud<pcl::PointXYZI>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZI>);\n\t*cloud_ptr = cloud;\n\n\tpcl::PointCloud<pcl::PointXYZI>::Ptr cloud_ptr_filtered(new pcl::PointCloud<pcl::PointXYZI>);\n\tpcl::PointCloud<pcl::PointXYZI>::Ptr cloud_ptr_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZI>);\n\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", cloud.points.size());\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", cloud_ptr->points.size());\n\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", cloud.points.size());\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", cloud_ptr->points.size());\n\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", cloud.points.size());\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", cloud_ptr->points.size());\n\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", cloud.points.size());\n\t//ROS_INFO(\"Gpointcloud_cb: %d\", cloud_ptr->points.size());\n\n\t//ROS_INFO(\"Gpoint", "CodeBleu_score": 48.22178606549785}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb\");\n\tif (odom_ready == false) {\n\t\treturn;\n\t}\n\n\tif (sensor_ready == false) {\n\t\tsensor_ready = true;\n\t\tsensor_update_counter = 0;\n\t}\n\tsensor_update_counter++;\n\tif (sensor_update_counter == 5) {\n\t\tsensor_update_counter = 0;\n\t\tsensor_ready = false;\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: Updating Astar map\");\n\t\t//ROS_INFO(\"GlobalPlannerUGV", "CodeBleu_score": 46.870924603748726}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tROS_INFO(\"Global Point Cloud Received\");\n\t\tsensor_msgs::PointCloud2 global_point_cloud;\n\t\tglobal_point_cloud = *global_point;\n\t\tpcl::fromROSMsg(global_point_cloud, global_map);\n\t\tglobal_map.header.frame_id = \"map\";\n\t\tglobal_map.height = 1;\n\t\tglobal_map.width = global_map.points.size();\n\t\tglobal_map.is_dense = false;\n\t\tglobal_map.is_bigendian = false;\n\t\tglobal_map.point_step = 4;\n\t\tglobal_map.row_step = 4 * global_map.width;\n\t\tglobal_map.data.resize(global_map.row_step * global_map.height);\n\t\tglobal_map.data[0] = 100;\n\t\tglobal_map.data[1] = 0;\n\t\tglobal_map.data[2] = 0;\n\t\tglobal_map.data[3] = 255;\n\t\tglobal_map.data[4] = 100;\n\t\tglobal_map.data[5] = 0;\n\t\tglobal_map.data[6] = 0;\n\t\tglobal_map.data[7] = 255;\n\t\tglobal_map.data[8] = 100;\n\t\tglobal_map.data[9] = 0;\n\t\tglobal_map.data[10] = 0;\n\t\tglobal_map.data[11] = 255;\n\t\tglobal_map.data[12] = 100;\n\t\tglobal_map.data[13] = 0;\n\t\tglobal_map.data[14] = 0;\n\t\tglobal_map.data[15] = 255;\n\t\tglobal_map.data[16] = 100;\n\t\tglobal_map.data[17] = 0;\n\t\tglobal_map.data[18] = 0;\n\t\tglobal_map.data[19] = 255;\n\t\tglobal_map", "CodeBleu_score": 42.84491160634452}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\t//ROS_INFO(\"Global point cloud not yet set. Setting global point cloud.\");\n\t\tgpcl = global_point;\n\t\tget_gpcl = true;\n\t\t//ROS_INFO(\"Global point cloud set.\");\n\t} else {\n\t\t//ROS_INFO(\"Global point cloud already set. Updating global point cloud.\");\n\t\tgpcl = global_point;\n\t}\n\t//ROS_INFO(\"Global point cloud updated.\");\n}", "CodeBleu_score": 41.68649143467263}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl) {\n\t\tpcl::fromROSMsg(*global_point, *global_map);\n\t\tget_gpcl = false;\n\t\t//ROS_INFO(\"Global map updated!\");\n\t}\n\tif (global_map->points.size() > 0) {\n\t\tif (inflate_point_cloud) {\n\t\t\tinflate_point_cloud = false;\n\t\t\tinflate_point_cloud_flag = true;\n\t\t\tinflate_point_cloud_flag_2 = true;\n\t\t\tinflate_point_cloud_flag_3 = true;\n\t\t\tinflate_point_cloud_flag_4 = true;\n\t\t\tinflate_point_cloud_flag_5 = true;\n\t\t\tinflate_point_cloud_flag_6 = true;\n\t\t\tinflate_point_cloud_flag_7 = true;\n\t\t\tinflate_point_cloud_flag_8 = true;\n\t\t\tinflate_point_cloud_flag_9 = true;\n\t\t\tinflate_point_cloud_flag_10 = true;\n\t\t\tinflate_point_cloud_flag_11 = true;\n\t\t\tinflate_point_cloud_flag_12 = true;\n\t\t\tinflate_point_cloud_flag_13 = true;\n\t\t\tinflate_point_cloud_flag_14 = true;\n\t\t\tinflate_point_cloud_flag_15 = true;\n\t\t\tinflate_point_cloud_flag_16 = true;\n\t\t\tinflate_point_cloud_flag_17 = true;\n\t\t\tinflate_point_cloud_flag_18 = true;\n\t\t\tinflate_point_cloud_flag_19 = true;\n\t\t\tinflate_point_cloud_flag_20 = true;\n\t\t\tinflate_point_cloud_flag_21 = true;\n\t\t\tinflate_point_cloud_flag_22 = true;\n\t\t\tinflate_point_cloud_flag_23 = true;\n\t\t\tinflate_point_cloud_flag_24 = true;\n\t\t\tinflate_point_cloud_flag_25 = true;\n\t\t\tinflate_point_cloud_flag_26 = true;\n\t\t\tinflate_point_cloud_flag_27 = true;\n\t\t\tinflate_point_cloud_flag_28 = true;\n\t\t\tinflate_point_cloud_flag_29 = true;\n\t\t", "CodeBleu_score": 45.451356540043285}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Create a point cloud from the laser scan\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(*local_point, cloud);\n\n\t// Project the point cloud into the map\n\tprojector_.projectLaser(cloud);\n\n\t// Merge the local map with the odometry\n\tif (!sim_mode_) {\n\t\tmerge_map_with_odom(cloud, odom);\n\t}\n}", "CodeBleu_score": 43.070004713188155}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_update_laser\");\n\t//ROS_INFO(\"map_", "CodeBleu_score": 9.54836615882347}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\tif (local_point->ranges.size() == 0) {\n\t\tROS_WARN(\"Laser scan is empty!\");\n\t\treturn;\n\t}\n\tif (local_point->ranges.size()!= local_point->intensities.size()) {\n\t\tROS_WARN(\"Laser scan intensity size is not equal to range size!\");\n\t\treturn;\n\t}\n\tif (local_point->ranges.size()!= local_point->angle_min) {\n\t\tROS_WARN(\"Laser scan angle min is not equal to range size!\");\n\t\treturn;\n\t}\n\tif (local_point->ranges.size()!= local_point->angle_max) {\n\t\tROS_WARN(\"Laser scan angle max is not equal to range size!\");\n\t\treturn;\n\t}\n\tif (local_point->ranges.size()!= local_point->angle_increment) {\n\t\tROS_WARN(\"Laser scan angle increment is not equal to range size!\");\n\t\treturn;\n\t}\n\tif (local_point->ranges.size()!= local_point->time_increment) {\n\t\tROS_WARN(\"Laser scan time increment is not equal to range size!\");\n\t\treturn;\n\t}\n\tif (local_point->ranges.size()!= local_point->scan_time) {\n\t\tROS_WARN(\"Laser scan scan time is not equal to range size!\");\n\t\treturn;\n\t}\n\tif (local_point->ranges.size()!= local_point->range_min) {\n\t\tROS_WARN(\"Laser scan range min is not equal to range size!\");\n\t\treturn;\n\t}\n\tif (local_point->ranges.size()!= local_point->range_max) {\n\t\tROS_WARN(\"Laser scan range max is not equal to range size!\");\n\t\treturn;\n\t}\n\n\t//ROS_INFO(\"laser scan data: %f\", local_point->ranges[0]);\n\t//ROS_INFO(\"laser scan data: %f\", local_point->intensities[0]);\n\t//ROS_INFO(\"laser scan data: %f\", local_point->angle_min);\n\t//ROS_INFO(\"laser scan data: %f\", local_point->angle_max);\n\t//ROS_", "CodeBleu_score": 28.894359578777074}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert global point cloud map to ROS message\n\tpcl::toROSMsg(*global_cloud_map_, global_pcl_msg_);\n\tglobal_pcl_msg_.header.frame_id = \"world\";\n\tglobal_pcl_msg_.header.stamp = ros::Time::now();\n\tglobal_pcl_pub.publish(global_pcl_msg_);\n\n\t// Convert inflated point cloud map to ROS message\n\tpcl::toROSMsg(*inflate_cloud_map_, inflate_pcl_msg_);\n\tinflate_pcl_msg_.header.frame_id = \"world\";\n\tinflate_pcl_msg_.header.stamp = ros::Time::now();\n\tinflate_pcl_pub.publish(inflate_pcl_msg_);\n}", "CodeBleu_score": 49.9232679437113}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Publish the global point cloud\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl;\n\tglobal_pcl = *global_map;\n\tpcl_conversions::fromPCL(global_pcl, global_pcl_msg);\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// Publish the inflated point cloud\n\tpcl::PointCloud<pcl::PointXYZ> inflate_pcl;\n\tinflate_pcl = *inflate_map;\n\tpcl_conversions::fromPCL(inflate_pcl, inflate_pcl_msg);\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 40.22478008583874}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// convert global point cloud to ROS message\n\tpcl::PointCloud<pcl::PointXYZ> pcl_msg;\n\tpcl_msg = *global_map_ptr;\n\tpcl_msg.header.frame_id = \"world\";\n\tpcl_msg.header.stamp = ros::Time::now();\n\tglobal_pcl_pub.publish(pcl_msg);\n\n\t// convert inflated point cloud to ROS message\n\tpcl::PointCloud<pcl::PointXYZ> inflate_pcl_msg;\n\tinflate_pcl_msg = *inflate_map_ptr;\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 54.95970963230721}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tif (sensor_ready) {\n\t\t\tsensor_ready = false;\n\t\t\tif (first_pointcloud) {\n\t\t\t\tfirst_pointcloud = false;\n\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\tif (first_odom) {\n\t\t\t\t\tfirst_odom = false;\n\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\tif (first_map) {\n\t\t\t\t\t\tfirst_map = false;\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"first pointcloud\");\n\t\t\t\t\t\t//ROS_INFO(\"first odom\");\n\t\t\t\t\t\t//ROS_INFO(\"first map\");\n\t\t\t\t\t\t//ROS_INFO(\"", "CodeBleu_score": 43.51858987503278}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\tif (sensor_ready) {\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\tsensor_ready = false;\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\t", "CodeBleu_score": 34.91699143744408}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb_start\");\n\t//ROS_INFO(\"Lpointcloud_cb_end\");\n\tif (sensor_ready) {\n\t\tsensor_ready = false;\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end\");\n\t\t//ROS_INFO(\"Lpointcloud_cb_sensor_ready_end", "CodeBleu_score": 34.91699143744408}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get the current time.\n\tros::Time current_time = ros::Time::now();\n\n\t// Get the time since the last control loop.\n\tros::Duration dt = current_time - last_control_time_;\n\n\t// Update the last control loop time.\n\tlast_control_time_ = current_time;\n\n\t// Get the current pose of the robot.\n\tQuadrupedPose current_pose = body_controller_.getPose();\n\n\t// Get the current joint positions.\n\tQuadrupedJoints current_joints = kinematics_.inverse(current_pose);\n\n\t// Get the desired foot positions.\n\tQuadrupedFootPositions desired_foot_positions = body_controller_.getDesiredFootPositions();\n\n\t// Get the current foot positions.\n\tQuadrupedFootPositions current_foot_positions = foot_controller_.getFootPositions();\n\n\t// Compute velocity commands for the legs.\n\tQuadrupedLegVelocities desired_leg_velocities = leg_controller_.computeLegVelocities(current_foot_positions, desired_foot_positions, dt);\n\n\t// Compute the desired joint positions.\n\tQuadrupedJoints desired_joints = leg_controller_.computeJointPositions(desired_foot_positions, desired_leg_velocities, dt);\n\n\t// Publish the desired foot positions.\n\tpublishFootPositions_(desired_foot_positions);\n\n\t// Publish the desired joint positions.\n\tpublishJoints_(desired_joints);\n\n\t// Publish the current foot positions.\n\tpublishFootContacts_(current_foot_positions);\n}", "CodeBleu_score": 44.06919075478696}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\tros::Time now = ros::Time::now();\n\tros::Duration dt = now - last_time_;\n\tlast_time_ = now;\n\n\t// Get the current pose of the robot.\n\tEigen::Affine3d pose = body_controller_.poseCommand;\n\n\t// Compute target foot positions.\n\tEigen::Vector3d target_foot_positions[4];\n\tbody_controller_.computeTargetFootPositions(pose, target_foot_positions);\n\n\t// Compute velocity commands for the legs.\n\tEigen::Vector3d velocity_commands[4];\n\tfor (int i = 0; i < 4; ++i) {\n\t\tkinematics_.computeLegVelocityCommand(target_foot_positions[i], velocity_commands[i]);\n\t}\n\n\t// Compute target joint positions.\n\tEigen::Vector3d target_joint_positions[4];\n\tkinematics_.inverse(target_foot_positions, target_joint_positions);\n\n\t// Publish foot contact information.\n\tpublishFootContacts_(target_foot_positions);\n\n\t// Publish joint positions.\n\tpublishJoints_(target_joint_positions);\n}", "CodeBleu_score": 52.68034465780423}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get the current time\n\tros::Time now = ros::Time::now();\n\n\t// Get the current pose of the robot\n\tgeometry_msgs::PoseStamped robot_pose;\n\trobot_pose.header.stamp = now;\n\trobot_pose.header.frame_id = \"odom\";\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t\treturn;\n\t}\n\tif (!ros::ok()) {\n\t", "CodeBleu_score": 33.6299116754299}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\t// Create a message to publish\n\tquadruped_msgs::ContactsStamped contacts_msg;\n\tcontacts_msg.header.stamp = ros::Time::now();\n\t// Populate the message with the current gait phase of each leg\n\tfor (int i = 0; i < 4; i++) {\n\t\tcontacts_msg.contacts.push_back(foot_contacts[i]);\n\t}\n\t// Publish the message\n\tfoot_contacts_publisher_.publish(contacts_msg);\n}", "CodeBleu_score": 50.725300239794905}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\tstd_msgs::Contacts contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (foot_contacts[i]) {\n\t\t\t\tstd_msgs::ContactPoint contact_point;\n\t\t\t\tcontact_point.header.stamp = ros::Time::now();\n\t\t\t\tcontact_point.header.frame_id = \"base_link\";\n\t\t\t\tcontact_point.contact_point.x = 0;\n\t\t\t\tcontact_point.contact_point.y = 0;\n\t\t\t\tcontact_point.contact_point.z = 0;\n\t\t\t\tcontact_point.contact_normal.x = 0;\n\t\t\t\tcontact_point.contact_normal.y = 0;\n\t\t\t\tcontact_point.contact_normal.z = 1;\n\t\t\t\tcontact_point.wrench.force.x = 0;\n\t\t\t\tcontact_point.wrench.force.y = 0;\n\t\t\t\tcontact_point.wrench.force.z = 0;\n\t\t\t\tcontact_point.wrench.torque.x = 0;\n\t\t\t\tcontact_point.wrench.torque.y = 0;\n\t\t\t\tcontact_point.wrench.torque.z = 0;\n\t\t\t\tcontact_point.id = \"foot\" + std::to_string(i);\n\t\t\t\tcontacts_msg.contacts.push_back(contact_point);\n\t\t\t}\n\t\t}\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 42.53782002529633}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\tstd_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts.resize(contacts_msg.contacts.size() + 1);\n\t\t\tcontacts_msg.contacts[contacts_msg.contacts.size() - 1].contact_type = std_msgs::ContactPoint::NO_CONTACT;\n\t\t\tif (foot_contacts[i]) {\n\t\t\t\tcontacts_msg.contacts[contacts_msg.contacts.size() - 1].contact_type = std_msgs::ContactPoint::POINT;\n\t\t\t\tcontacts_msg.contacts[contacts_msg.contacts.size() - 1].position.x = 0;\n\t\t\t\tcontacts_msg.contacts[contacts_msg.contacts.size() - 1].position.y = 0;\n\t\t\t\tcontacts_msg.contacts[contacts_msg.contacts.size() - 1].position.z = 0;\n\t\t\t}\n\t\t}\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 44.37726810394847}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\tif (self.joints_pub == NULL) {\n\t\tROS_ERROR(\"joints_cmd_callback: joints_pub is NULL!\");\n\t\treturn;\n\t}\n\n\t// Create a minimal joints message\n\tjoint_msgs::Joints joints_msg;\n\tjoints_msg.joint_names.resize(12);\n\tjoints_msg.positions.resize(12);\n\n\t// Populate the joints message\n\tfor (int i = 0; i < 12; i++) {\n\t\tjoints_msg.joint_names[i] = \"joint\" + std::to_string(i);\n\t\tjoints_msg.positions[i] = joints.positions[i];\n\t}\n\n\t// Publish the joints message\n\tself.joints_pub.publish(joints_msg);\n\n\t// Create a joint trajectory message\n\ttrajectory_msgs::JointTrajectory joint_trajectory;\n\tjoint_trajectory.joint_names.resize(12);\n\tjoint_trajectory.points.resize(1);\n\n\t// Populate the joint trajectory message\n\tfor (int i = 0; i < 12; i++) {\n\t\tjoint_trajectory.joint_names[i] = \"joint\" + std::to_string(i);\n\t\tjoint_trajectory.points[0].positions.push_back(joints.positions[i]);\n\t}\n\n\tjoint_trajectory.points[0].time_from_start = ros::Duration(1.0);\n\n\t// Publish the joint trajectory message\n\tself.trajectory_pub.publish(joint_trajectory);\n}", "CodeBleu_score": 40.63061156456354}, {"code": "def joints_cmd_callback(self, joints){\n\t\tself.joint_positions = joints.positions\n\tself.joint_names = joints.name\n\tself.joint_names.append(\"gripper_finger_joint\")\n\tself.joint_names.append(\"gripper_finger_tip_joint\")\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_names.append(\"gripper_l_finger_joint\")\n\tself.joint_names.append(\"gripper_l_finger_tip_joint\")\n\tself.joint_names.append(\"gripper_r_finger_joint\")\n\tself.joint_names.append(\"gripper_r_finger_tip_joint\")\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself.joint_positions.append(0.0)\n\tself", "CodeBleu_score": 18.9902080813966}, {"code": "def joints_cmd_callback(self, joints){\n\t\tself.joints_pub.publish(joints)\n\tself.traj_pub.publish(self.joints_to_trajectory(joints))\n}", "CodeBleu_score": 15.282342795611099}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t//std::cout << \"Gazebo Callback\" << std::endl;\n\t//std::cout << _msg->contact_size << std::endl;\n\tfor (int i = 0; i < _msg->contact_size; i++) {\n\t\tstd::string collision = _msg->contact(i).collision1;\n\t\t//std::cout << collision << std::endl;\n\t\tboost::split(split_collision, collision, boost::is_any_of(\"/\"));\n\t\t//std::cout << split_collision[0] << std::endl;\n\t\t//std::cout << split_collision[1] << std::endl;\n\t\tif (split_collision[0] == \"foot_left\") {\n\t\t\t//std::cout << \"Left\" << std::endl;\n\t\t\tfoot_left_contact = true;\n\t\t} else if (split_collision[0] == \"foot_right\") {\n\t\t\t//std::cout << \"Right\" << std::endl;\n\t\t\tfoot_right_contact = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 35.19798036965797}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//std::cout << \"GazeboCallback\" << std::endl;\n\t//", "CodeBleu_score": 1.3983365370963055}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision = _msg->contact(i).collision1;\n\t\tboost::split(split_result, collision, boost::is_any_of(\" \"));\n\t\tif (split_result[1] == \"foot_left\" || split_result[1] == \"foot_right\") {\n\t\t\tif (split_result[1] == \"foot_left\") {\n\t\t\t\tfoot_left_contact = true;\n\t\t\t} else {\n\t\t\t\tfoot_right_contact = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.004957112606164}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n// Check that the controller is active\nif (!active_) {\n\n// If not, set all rotor velocities to zero\nrotor_velocities->setZero();\nreturn;\n}\n\n// Compute the desired acceleration\nEigen::Vector3d acceleration = ComputeDesiredAcceleration();\n\n// Compute the desired angular acceleration\nEigen::Vector3d angular_acceleration = ComputeDesiredAngularAcc();\n\n// Compute the desired thrust\ndouble thrust = ComputeDesiredThrust();\n\n// Project the desired thrust onto the body z-axis\nEigen::Vector3d thrust_body_frame = vehicle_parameters_.rotor_configuration_.rotors[0].rotation_matrix * thrust * vehicle_parameters_.rotor_configuration_.rotors[0].direction;\n\n// Combine the desired angular acceleration and thrust into a single vector\nEigen::Vector3d angular_acceleration_thrust = angular_acceleration + thrust_body_frame;\n\n// Ensure non-negative values\nangular_acceleration_thrust.cwiseMax(0.0);\n\n// Compute the rotor velocities\nrotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\nrotor_velocities->setZero();\nrotor_velocities->noalias() = vehicle_parameters_.rotor_configuration_.rotors[0].direction.transpose() * angular_acceleration_thrust;\nrotor_velocities->cwiseSqrt();\n\n// Check that the rotor velocities are within the maximum rotor speed\nrotor_velocities->cwiseMax(vehicle_parameters_.rotor_configuration_.rotors[0].max_speed);\n\n// Check that the rotor velocities are within the minimum rotor speed\nrotor_velocities->cwiseMin(vehicle_parameters_.rotor_configuration_.rotors[0].min_speed);\n\n}", "CodeBleu_score": 45.27153025196834}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n// Check if the controller is active.\nif (!active_) {\n// If not, set all rotor velocities to zero.\nrotor_velocities->setZero();\nreturn;\n}\n\n// Compute the desired acceleration and angular acceleration.\nEigen::Vector3d acceleration, angular_acceleration;\nComputeDesiredAcceleration(&acceleration);\nComputeDesiredAngularAcc(&angular_acceleration);\n\n// Project thrust onto the body z-axis.\nEigen::Vector3d thrust_body =\nvehicle_parameters_.rotor_configuration_.rotors[0].thrust_direction *\nvehicle_parameters_.rotor_configuration_.rotors[0].thrust_magnitude;\n\n// Combine angular acceleration and thrust into a single vector.\nEigen::Vector3d acceleration_thrust = angular_acceleration + thrust_body;\n\n// Compute the rotor velocities by multiplying with a predefined matrix,\n// ensuring non-negative values, and taking the square root of each component.\nEigen::Matrix3d rotor_velocities_matrix =\nvehicle_parameters_.rotor_configuration_.rotors[0].rotor_velocities_matrix;\nfor (int i = 0; i < 3; i++) {\nacceleration_thrust(i) = std::max(0.0, acceleration_thrust(i));\nrotor_velocities->data()[i] =\nsqrt(acceleration_thrust.transpose() * rotor_velocities_matrix *\nacceleration_thrust);\n}\n}", "CodeBleu_score": 43.962094042492055}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\nassert(vehicle_parameters_.rotor_configuration_.rotors.size == 4);\n\nif (active_) {\n\nComputeDesiredAcceleration(&acceleration_);\nComputeDesiredAngularAcc(&angular_acceleration_thrust_);\n\nrotor_velocities->resize(4);\nrotor_velocities->setZero();\n\nrotor_velocities->block<3, 1>(0, 0) = acceleration_.block<3, 1>(0, 0) + angular_acceleration_thrust_.block<3, 1>(0, 0);\nrotor_velocities->block<3, 1>(0, 0).cwiseMax(0.0);\nrotor_velocities->cwiseSqrt();\n\n} else {\n\nrotor_velocities->resize(4);\nrotor_velocities->setZero();\n\n}\n\n}", "CodeBleu_score": 30.509893551807377}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position and velocity errors\n\tEigen::Vector3d position_error = current_odometry_.position - command_trajectory_.position;\n\tEigen::Vector3d velocity_error = current_odometry_.velocity - command_trajectory_.velocity;\n\n\t// Transform the velocity error to the world frame\n\tEigen::Vector3d velocity_error_world = odometry_.orientation.toRotationMatrix() * velocity_error;\n\n\t// Compute the desired acceleration\n\tEigen::Vector3d desired_acceleration = velocity_gains_ * velocity_error_world + position_gains_ * position_error;\n\n\t// Add gravity to the desired acceleration\n\tdesired_acceleration += gravity_;\n\n\t// Add mass to the desired acceleration\n\tdesired_acceleration += mass_ * acceleration_gains_ * (acceleration->cwiseQuotient(desired_acceleration));\n\n\t// Set the desired acceleration\n\t*acceleration = desired_acceleration;\n}", "CodeBleu_score": 42.5895566743837}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d desired_acceleration;\n\tEigen::Vector3d world_velocity;\n\n\tposition_error = command_trajectory_.position - odometry_.position;\n\tvelocity_error = command_trajectory_.velocity - odometry_.velocity;\n\n\tworld_velocity = odometry_.orientation.toRotationMatrix() * odometry_.velocity;\n\n\tdesired_acceleration = (position_gain_ * position_error) + (velocity_gain_ * velocity_error) + (acceleration_gain_ * world_velocity);\n\n\tdesired_acceleration = desired_acceleration / (vehicle_mass_ + commanded_acceleration_ + gravity_acceleration_);\n\n\t*acceleration = desired_acceleration;\n}", "CodeBleu_score": 46.80754531629683}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d desired_acceleration;\n\tEigen::Vector3d commanded_acceleration;\n\tEigen::Vector3d gravity;\n\n\t// Get the position error\n\tposition_error = command_trajectory_.GetPositionError(odometry_.position);\n\n\t// Get the velocity error\n\tvelocity_error = command_trajectory_.GetVelocityError(odometry_.velocity);\n\n\t// Get the desired acceleration\n\tdesired_acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error;\n\n\t// Get the commanded acceleration\n\tcommanded_acceleration = command_trajectory_.GetAcceleration();\n\n\t// Get the gravity\n\tgravity = Eigen::Vector3d(0, 0, -9.81);\n\n\t// Calculate the desired acceleration\n\t*acceleration = (desired_acceleration + commanded_acceleration) + mass_ * gravity;\n}", "CodeBleu_score": 47.99315205891517}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n// Check if the input is valid", "CodeBleu_score": 3.965771328574471}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n// Check input parameters\nassert(rotor_velocities!= nullptr);\nassert(rotor_velocities->size() == 3);\nassert(control_attitude_thrust_reference_!= nullptr);\nassert(control_attitude_thrust_reference_->size() == 3);\n\n// Resize the rotor velocities vector\nrotor_velocities->resize(3);\n\n// Calculate desired angular acceleration\nEigen::Vector3d desired_angular_acceleration = rotor_velocities_matrix_ * (*control_attitude_thrust_reference_);\n\n// Combine desired angular acceleration with thrust reference\nEigen::Vector3d angular_acceleration_thrust = desired_angular_acceleration.cwiseMax(Eigen::Vector3d::Ones());\n\n// Compute rotor velocities\nrotor_velocities->block<3, 1>(0, 0) = angular_acceleration_thrust.block<3, 1>(0, 0).cwiseSqrt();\n}", "CodeBleu_score": 44.51738303847147}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\n// Check that the input and parameters are valid\nassert(rotor_velocities!= nullptr);\nassert(rotor_velocities->rows() == num_rotors_);\nassert(control_attitude_thrust_reference_!= nullptr);\nassert(control_attitude_thrust_reference_->rows() == 3);\nassert(control_attitude_thrust_reference_->cols() == 1);\nassert(control_attitude_thrust_reference_->minCoeff() >= 0);\nassert(control_attitude_thrust_reference_->maxCoeff() <= 1);\nassert(control_attitude_thrust_reference_->sum() > 0);\nassert(control_attitude_thrust_reference_->sum() < 1);\nassert(control_attitude_thrust_reference_->sum() <= 1);\n\n// Resize the rotor velocities vector to match the number of rotors\nrotor_velocities->resize(num_rotors_);\n\n// Calculate the desired angular acceleration\nEigen::Vector3d angular_acceleration_thrust = ComputeDesiredAngularAcc();\n\n// Combine the desired angular acceleration with the thrust reference\nangular_acceleration_thrust += *control_attitude_thrust_reference_;\n\n// Ensure the rotor velocities are at least one\nangular_acceleration_thrust.cwiseMax(Eigen::VectorXd::Ones(3));\n\n// Compute the rotor velocities\n*rotor_velocities = angular_acceleration_thrust.block<3, 1>(0, 0).cwiseSqrt();\n}", "CodeBleu_score": 44.176112428857}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.time_list = self.time_list[start_index:end_index]\n    copied_obj.data_list = self.data_list[start_index:end_index]\n    copied_obj.time_list = self.time_list[start_index:end_index]\n    copied_obj.data_list = self.data_list[start_index:end_index]\n    return copied_obj\n", "CodeBleu_score": 26.239043919681293}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = self.__deepcopy__(self)\n    copied_obj.timestamps = self.timestamps[start_index:end_index]\n    copied_obj.data = self.data[start_index:end_index]\n    return copied_obj\n", "CodeBleu_score": 37.27355330634259}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in self.__dict__:\n        if attr not in ['get_index', 'get_next_index', 'get_next_time', 'get_next_value', 'get_time', 'get_value', 'get_value_at_index', 'get_value_at_time', 'get_value_at_time_index','slice', 'time_index_dict', 'time_value_dict']:\n            setattr(copied_obj, attr, self.get_value_at_time_index(attr, start_index, end_index))\n    return copied_obj\n\n", "CodeBleu_score": 26.723480545316963}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    euler = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    yaw = euler[2]\n    point = Point(position.x, position.y, position.z, yaw)\n    if self.last_point is None:\n        self.last_point = point\n        self.append_times.append(msg_time)\n        self.append_point.append(point)\n        return\n    if point!= self.last_point:\n        self.append_times.append(msg_time)\n        self.append_point.append(point)\n        self.last_point = point\n    return\n\n", "CodeBleu_score": 25.925781028729507}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Check if the current waypoint is different from the last one\n    if (self.last_point.position!= waypoint_msg.pose.pose.position) or (self.last_yaw!= waypoint_msg.pose.pose.orientation.y):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point.append(Point(waypoint_msg.pose.pose.position.x, waypoint_msg.pose.pose.position.y, waypoint_msg.pose.pose.position.z))\n        self.append_times.append(msg_time)\n        self.append_yaw.append(waypoint_msg.pose.pose.orientation.y)\n        self.last_point = Point(waypoint_msg.pose.pose.position.x, waypoint_msg.pose.pose.position.y, waypoint_msg.pose.pose.position.z)\n        self.last_yaw = waypoint_msg.pose.pose.orientation.y\n\n", "CodeBleu_score": 23.80531885499894}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    point = Point", "CodeBleu_score": 1.40135813774455}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic:\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.time.append(to_sec(msg.header.stamp))\n        self.bag_time.append(bag_time)\n\n", "CodeBleu_score": 29.965653115965445}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.time.append(to_sec(msg.header.stamp))\n        self.bag_time.append(to_sec(bag_time))\n\n", "CodeBleu_score": 29.552885063506462}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic:\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.time.append(msg.header.stamp.to_sec())\n        self.bag_time.append(bag_time)\n\n", "CodeBleu_score": 31.595422787491916}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.accelerations_enabled:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        fig = pyplot.figure()\n        fig.suptitle(self.accelerations_title + plot_suffix)\n        ax_x = fig.add_subplot(3, 1, 1)\n        ax_y = fig.add_subplot(3, 1, 2)\n        ax_z = fig.add_subplot(3, 1, 3)\n        for index, accel in enumerate(self.accelerations):\n            ax_x.plot(accel.time, accel.x, color=self.accelerations_colors[index], label=self.accelerations_labels[index])\n            ax_y.plot(accel.time, accel.y, color=self.accelerations_colors[index], label=self.accelerations_labels[index])\n            ax_z.plot(accel.time, accel.z, color=self.accelerations_colors[index], label=self.accelerations_labels[index])\n        ax_x.set_ylabel(self.accelerations_x_label)\n        ax_y.set_ylabel(self.accelerations_y_label)\n        ax_z.set_ylabel(self.accelerations_z_label)\n        ax_x.set_xlabel(\"Time (s)\")\n        ax_y.set_xlabel(\"Time (s)\")\n        ax_z.set_xlabel(\"Time (s)\")\n        pyplot.legend()\n        if self.save_plots:\n            pyplot.savefig(self.accelerations_prefix + plot_suffix + \".png\")\n        pyplot.show()\n", "CodeBleu_score": 33.771931940157316}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle('Acceleration Data')\n    ax_x = fig.add_subplot(3, 1, 1)\n    ax_y = fig.add_subplot(3, 1, 2)\n    ax_z = fig.add_subplot(3, 1, 3)\n    ax_x.set_ylabel('X Acceleration (m/s^2)')\n    ax_y.set_ylabel('Y Acceleration (m/s^2)')\n    ax_z.set_ylabel('Z Acceleration (m/s^2)')\n    ax_z.set_xlabel('Time (s)')\n    for i, accel in enumerate(self.accelerations):\n        ax_x.plot(accel.time, accel.x, label='X Acceleration', color='blue')\n        ax_y.plot(accel.time, accel.y, label='Y Acceleration', color='red')\n        ax_z.plot(accel.time, accel.z, label='Z Acceleration', color='green')\n    pyplot.legend()\n    if self.save_plots:\n        if plot_suffix:\n            pyplot.savefig(self.prefix + '_' + plot_suffix + '.png')\n        else:\n            pyplot.savefig(self.prefix + '.png')\n    pyplot.figure()\n\n", "CodeBleu_score": 42.256104577632335}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.accelerations is None:\n        print(\"No accelerations data to plot\")\n        return\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    plot_num = 1\n    for accel_name, accel_data in self.accelerations.items():\n        accel_x = accel_data[\"x\"]\n        accel_y = accel_data[\"y\"]\n        accel_z = accel_data[\"z\"]\n        ax = fig.add_subplot(3, 1, plot_num)\n        ax.plot(accel_x, color=\"red\", label=\"x\")\n        ax.plot(accel_y, color=\"green\", label=\"y\")\n        ax.plot(accel_z, color=\"blue\", label=\"z\")\n        ax.set_ylabel(accel_name)\n        plot_num += 1\n    fig.add_subplot(3, 1, 3)\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.legend()\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        pyplot.savefig(self.prefix + \"_accelerations\" + plot_suffix + \".png\")\n    pyplot.figure()\n\n", "CodeBleu_score": 35.69446435049983}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: At least two pose indices are required to perform comparisons.\")\n        return\n    for i, index1 in enumerate(pose_indeces):\n        for index2 in pose_indeces[i + 1:]:\n            self.compare_two_xyz(index1, index2)\n\n", "CodeBleu_score": 48.62984060502128}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"You must have at least two pose indices to compare positions\")\n    else:\n        for pose_index in enumerate(pose_indeces):\n            for pose_index_2 in enumerate(pose_indeces):\n                if pose_index[0]!= pose_index_2[0]:\n                    compare_two_xyz(self, pose_index[0], pose_index_2[0])\n\n", "CodeBleu_score": 31.86968697990021}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        raise ValueError(\"At least two pose indices are required to perform comparisons.\")\n    for i, index in enumerate(pose_indeces):\n        if i == 0:\n            continue\n        self.compare_two_xyz(index, pose_indeces[i - 1])\n\n", "CodeBleu_score": 36.94696274573793}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if (start_time <= time <= end_time):\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 32.359316015855704}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time is None or end_time is None:\n            if time not in collision_times:\n                collision_times.append(time)\n        else:\n            if start_time <= time <= end_time:\n                if time not in collision_times:\n                    collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 42.873138710034496}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n\n    settling_time = start_time + settling_time\n\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 33.45415835736383}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    # Calculate absolute settling time\n    abs_settling_time = start_time + settling_time\n\n    # Call analyze_bag.plot_angular_velocities\n    analyze_bag.plot_angular_velocities(analyze_bag, start_time, end_time,\n                                       abs_settling_time, x_range, plot_suffix,\n                                       [-1.5, 1.5])\n\n", "CodeBleu_score": 39.721745391804625}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix,\n                                        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 38.06187577592205}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\n// Check if data is null", "CodeBleu_score": 2.690664713366361}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check if the data pointer is null and return if it is.\n  if (data == nullptr) {\n    return;\n  }\n// Calculate a multiplier based on camera parameters and map the data to an Eigen vector.\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n// Compute the RMS noise and the noise values.\n  float rms_noise = this->dist * this->dist * this->noise;\n  float noise = sqrt(rms_noise);\n// For each pixel, it adds noise if the pixel value is in range, otherwise it sets the pixel to a bad point value.\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_vector_map[i] > 0.0) {\n      data_vector_map[i] += noise * (rand() / (float)RAND_MAX - 0.5f);\n    } else {\n      data_vector_map[i] = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 50.67759657204307}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\tif (data == NULL) {\n\t\treturn;\n\t}\n\tEigen::Map<Eigen::ArrayXf> data_vector_map(data, width * height);\n\tfloat multiplier = (float) (this->focal_length / this->baseline);\n\tEigen::ArrayXf noise = Eigen::ArrayXf::Random(width * height);\n\tnoise = noise.abs();\n\tnoise = noise.array() * multiplier;\n\tEigen::ArrayXf rms_noise = (noise.array() * noise.array()).sqrt();\n\tEigen::ArrayXf noise_values = (data_vector_map * 1000.0).array() + rms_noise.array();\n\tEigen::ArrayXf in_range = (data_vector_map * 1000.0).array();\n\tEigen::ArrayXf out_of_range = (data_vector_map * 1000.0).array();\n\tnoise_values = noise_values.max(out_of_range);\n\tnoise_values = noise_values.min(in_range);\n\tdata_vector_map = noise_values.array();\n}", "CodeBleu_score": 46.40482282008084}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time and convert it to ROS time.\n\tros::Time sim_time = world_->SimTime();\n\tros::Time ros_time = ros::Time::now();\n\n\t// Write the trajectory message to a bag file using the specified namespace and waypoint topic.\n\tstd::string bag_filename = bag_filename_;\n\tstd::string bag_namespace = bag_namespace_;\n\tstd::string bag_topic = bag_topic_;\n\trosbag::Bag bag;\n\tbag.open(bag_filename, rosbag::bagmode::Write);\n\tbag.write(bag_topic, ros_time, *trajectory_msg);\n\tbag.close();\n}", "CodeBleu_score": 44.79850324717243}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\tros::Time time = ros::Time::now();\n\ttime.sec = trajectory_msg->header.stamp.sec;\n\ttime.nsec = trajectory_msg->header.stamp.nsec;\n\trosbag::Bag bag;\n\tbag.open(bag_filename_, rosbag::bagmode::Write);\n\tbag.write(waypoint_topic_, time, *trajectory_msg);\n\tbag.close();\n}", "CodeBleu_score": 46.22033886131762}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\tros::Time time = ros::Time::now();\n\tstd::string trajectory_topic = trajectory_msg->header.frame_id;\n\tstd::string namespace_ = this->world_->Name();\n\tstd::string bag_filename = namespace_ + \"/\" + trajectory_topic + \".bag\";\n\tstd::string bag_filepath = this->world_->Physics()->Base_Directory() + \"/bags/\" + bag_filename;\n\tstd::string bag_filepath_str = bag_filepath.c_str();\n\tstd::string bag_filepath_str_ = bag_filepath_str.c_str();\n\n\t// Check if the bag file exists\n\tif (access(bag_filepath_str, F_OK)!= -1) {\n\t\t// If the bag file exists, open it for writing\n\t\tthis->bag_file_.open(bag_filepath_str_, std::ios::out | std::ios::app);\n\t} else {\n\t\t// If the bag file does not exist, create it\n\t\tthis->bag_file_.open(bag_filepath_str_, std::ios::out);\n\t}\n\n\t// Check if the bag file was opened successfully\n\tif (!this->bag_file_.is_open()) {\n\t\tstd::cerr << \"Error: Unable to open bag file for writing.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Convert the trajectory message to a ROS message\n\trosbag::MessageInstance trajectory_message = rosbag::MessageInstance(trajectory_msg);\n\n\t// Write the trajectory message to the bag file\n\tthis->bag_file_ << trajectory_message << std::endl;\n\n\t// Close the bag file\n\tthis->bag_file_.close();\n}", "CodeBleu_score": 42.46508167133863}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tros::Time ros_now = ros::Time::now();\nros_now += ros::Duration(now.sec, now.nsec);\n\n// prepare message\nsensor_msgs::JointState rot_velocities_msg;\nrot_velocities_msg.header.stamp = ros_now;\nrot_velocities_msg.name.resize(motor_joints_.size());\nrot_velocities_msg.velocity.resize(motor_joints_.size());\n\n// iterate through the motor joints and calculate the slowed-down rotational velocities\nfor (std::map<std::string, boost::shared_ptr<MotorJoint> >::iterator m = motor_joints_.begin(); m!= motor_joints_.end(); m++) {\nm->second->GetVelocity(rot_velocities_msg.velocity[m->second->GetIndex()]);\n}\n\n// write to bag file\nbag_->write(rot_velocities_topic_, ros_now, rot_velocities_msg);\n}", "CodeBleu_score": 53.897157807495034}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tros::Time ros_time = ros::Time(now.sec, now.nsec);\nrot_velocities_msg.header.stamp = ros_time;\nfor (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m!= motor_joints_.end(); m++) {\ndouble rot_vel = m->second->GetVelocity(0);\nrot_vel = rot_vel * slowdown_factor_;\nrot_velocities_msg.angular_velocities.push_back(rot_vel);\n}\nrot_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 42.53858983825065}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert the simulation time to ROS time\n\tros::Time ros_time = ros::Time::now() + ros::Duration(now.Double());\n\n\t// Prepare a message for actuator velocities\n\tsensor_msgs::JointState rot_velocities_msg;\n\trot_velocities_msg.header.stamp = ros_time;\n\trot_velocities_msg.header.frame_id = \"world\";\n\trot_velocities_msg.name.resize(motor_joints_.size());\n\trot_velocities_msg.velocity.resize(motor_joints_.size());\n\n\t// Iterate through the motor joints\n\tfor (std::map<std::string, gazebo::physics::JointPtr>::iterator it = motor_joints_.begin(); it!= motor_joints_.end(); it++) {\n\t\t// Calculate the slowed-down rotational velocities\n\t\tdouble slowed_down_velocity = it->second->GetVelocity(0) * slowdown_factor_;\n\n\t\t// Assign the slowed-down rotational velocities to the message\n\t\trot_velocities_msg.name[it->second->GetScopedName()] = it->first;\n\t\trot_velocities_msg.velocity[it->second->GetScopedName()] = slowed_down_velocity;\n\t}\n\n\t// Set the message timestamp\n\trot_velocities_msg.header.stamp = ros_time;\n\n\t// Write the message to the bag file\n\tbag_.write(motor_topic_ + \"/rot_velocities\", ros_time, rot_velocities_msg);\n}", "CodeBleu_score": 53.2327653094157}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if DEBUG_PRINTING\n  ROS_DEBUG(\"RollPitchYawrateThrustCallback called\");\n#endif\n  roll_pitch_yawrate_thrust_msg->roll_rate =\n      roll_pitch_yawrate_thrust_msg->roll_rate * M_PI / 180;\n  roll_pitch_yawrate_thrust_msg->pitch_rate =\n      roll_pitch_yawrate_thrust_msg->pitch_rate * M_PI / 180;\n  roll_pitch_yawrate_thrust_msg->yaw_rate =\n      roll_pitch_yawrate_thrust_msg->yaw_rate * M_PI / 180;\n  roll_pitch_yawrate_thrust_msg->thrust =\n      roll_pitch_yawrate_thrust_msg->thrust / 100;\n\n  // Convert roll, pitch, yaw rate to control surface angles\n  roll_pitch_yawrate_thrust_msg->aileron =\n      roll_pitch_yawrate_thrust_msg->roll_rate + roll_pitch_yawrate_thrust_msg->pitch_rate;\n  roll_pitch_yawrate_thrust_msg->elevator =\n      roll_pitch_yawrate_thrust_msg->pitch_rate - roll_pitch_yawrate_thrust_msg->roll_rate;\n  roll_pitch_yawrate_thrust_msg->rudder = roll_pitch_yawrate_thrust_msg->yaw_rate;\n\n  // Set the throttle value\n  roll_pitch_yawrate_thrust_msg->throttle = roll_pitch_yawrate_thrust_msg->thrust;\n}", "CodeBleu_score": 31.697602291549774}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINTING\n  ROS_INFO(\"RollPitchYawrateThrustCallback called\");\n#endif\n\n  // Convert normalized input values to control surface angles\n  roll_pitch_yawrate_thrust_msg->roll =\n      roll_pitch_yawrate_thrust_msg->roll_rate * roll_pitch_yawrate_thrust_msg->roll_rate;\n  roll_pitch_yawrate_thrust_msg->pitch =\n      roll_pitch_yawrate_thrust_msg->pitch_rate * roll_pitch_yawrate_thrust_msg->pitch_rate;\n  roll_pitch_yawrate_thrust_msg->yaw_rate =\n      roll_pitch_yawrate_thrust_msg->yaw_rate * roll_pitch_yawrate_thrust_msg->yaw_rate;\n\n  // Set throttle value\n  roll_pitch_yawrate_thrust_msg->thrust =\n      roll_pitch_yawrate_thrust_msg->thrust_rate * roll_pitch_yawrate_thrust_msg->thrust_rate;\n}", "CodeBleu_score": 28.97803696840103}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINTING\n  std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n#endif\n\n  // Convert normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively\n  roll_pitch_yawrate_thrust_msg->roll =\n      (roll_pitch_yawrate_thrust_msg->roll_rate - 1.0) * 0.5 * M_PI;\n  roll_pitch_yawrate_thrust_msg->pitch =\n      (roll_pitch_yawrate_thrust_msg->pitch_rate - 1.0) * 0.5 * M_PI;\n  roll_pitch_yawrate_thrust_msg->yaw_rate =\n      (roll_pitch_yawrate_thrust_msg->yaw_rate - 1.0) * 0.5 * M_PI;\n\n  // Set the throttle value from the thrust message\n  roll_pitch_yawrate_thrust_msg->thrust =\n      roll_pitch_yawrate_thrust_msg->thrust_normalized;\n}", "CodeBleu_score": 34.96772553793885}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#ifdef HAVE_LIBMAVLINK\n  // Convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Perform poll operation\n  int ret = poll(fds, 2, _timeoutMs);\n\n  // If data is available\n  if (ret > 0) {\n    // Receive data\n    ssize_t bytesRead = 0;\n    if (fds[0].revents & POLLIN) {\n      bytesRead = recvfrom(fd, buffer, BUFFER_SIZE, 0, NULL, NULL);\n    }\n\n    // If data was received\n    if (bytesRead > 0) {\n      // Parse MAVLink messages\n      parseMAVLinkMessages(buffer, bytesRead);\n\n      // If a serial connection is defined\n      if (serialConnection!= NULL) {\n        // Forward messages to serial connection\n        sendMAVLinkMessages(serialConnection);\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 42.260286062592215}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if!defined(Q_OS_WIN)\n  // Convert timeout to timeval structure\n  timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Set up the file descriptors\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(fd, &readfds);\n  FD_SET(serial_fd, &readfds);\n\n  // Poll for incoming data\n  int ret = select(FD_SETSIZE, &readfds, NULL, NULL, &tv);\n  if (ret == -1) {\n    gzerr << \"Error polling for incoming MAVLink data.\n\";\n  } else if (ret > 0) {\n    // Data is available\n    // Check if it's from the serial port\n    if (FD_ISSET(serial_fd, &readfds)) {\n      // Read data from the serial port\n      uint8_t buf[1024];\n      ssize_t bytesRead = read(serial_fd, buf, sizeof(buf));\n      if (bytesRead > 0) {\n        // Parse the data\n        for (uint32_t i = 0; i < bytesRead; ++i) {\n          handle_message(buf[i]);\n        }\n      }\n    }\n\n    // Check if it's from the UDP socket\n    if (FD_ISSET(fd, &readfds)) {\n      // Read data from the UDP socket\n      struct sockaddr_in addr;\n      socklen_t addr_len = sizeof(addr);\n      uint8_t buf[1024];\n      ssize_t bytesRead = recvfrom(fd, buf, sizeof(buf), 0,\n                                   (struct sockaddr *)&addr, &addr_len);\n      if (bytesRead > 0) {\n        // Parse the data\n        for (uint32_t i = 0; i < bytesRead; ++i) {\n          handle_message(buf[i]);\n        }\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 53.68165845783627}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 9\n  // Gazebo 9.0 and above\n  mavlink_message_t msg;\n  mavlink_status_t status;\n  uint8_t buf[MAVLINK_MAX_PACKET_LEN];\n  uint8_t len = 0;\n  uint8_t msg_cnt = 0;\n  uint8_t msg_buf[MAVLINK_MAX_PACKET_LEN];\n  uint8_t i = 0;\n  uint8_t j = 0;\n  uint8_t k = 0;\n  uint8_t msg_offset = 0;\n  uint8_t msg_len = 0;\n  uint8_t msg_seq = 0;\n  uint8_t msg_sysid = 0;\n  uint8_t msg_compid = 0;\n  uint8_t msg_sysid_buf[MAVLINK_MAX_PACKET_LEN];\n  uint8_t msg_compid_buf[MAVLINK_MAX_PACKET_LEN];\n  uint8_t msg_sysid_cnt = 0;\n  uint8_t msg_compid_cnt = 0;\n  uint8_t msg_sysid_offset = 0;\n  uint8_t msg_compid_offset = 0;\n  uint8_t msg_sysid_len = 0;\n  uint8_t msg_compid_len = 0;\n  uint8_t msg_sysid_buf_len = 0;\n  uint8_t msg_compid_buf_len = 0;\n  uint8_t msg_sysid_buf_cnt = 0;\n  uint8_t msg_compid_buf_cnt = 0;\n  uint8_t msg_sysid_buf_offset = 0;\n  uint8_t msg_compid_buf_offset = 0;\n  uint8_t msg_sysid_buf_len_cnt = 0;\n  uint8_t msg_compid_buf_len_cnt = 0;\n  uint8_t msg_sysid_buf_len_offset = 0;\n  uint8_t msg_compid_buf_len_offset = 0;\n  uint8_t msg_sys", "CodeBleu_score": 11.341179027955906}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (is_open_) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 65.20811120863829}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(interface_mutex_);\n\tif (is_open_) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 65.21667990653411}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (is_open_) {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 65.20811120863829}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(this->wind_speed_north - this->wind_speed_north_min) / (this->wind_speed_north_max - this->wind_speed_north_min),\n\t(this->wind_speed_east - this->wind_speed_east_min) / (this->wind_speed_east_max - this->wind_speed_east_min),\n\t(this->wind_speed_up - this->wind_speed_up_min) / (this->wind_speed_up_max - this->wind_speed_up_min)\n}", "CodeBleu_score": 4.886861006056156}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(this->wind_pos_1 - this->wind_pos_2) * (this->wind_pos_1 - this->wind_pos_2).Length() / (this->wind_pos_1 - this->wind_pos_2).Length()\n}", "CodeBleu_score": 5.678903682597054}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(this->m_wind_data[this->m_current_wind_data_index + 1].position - this->m_wind_data[this->m_current_wind_data_index].position) / (this->m_wind_data[this->m_current_wind_data_index + 1].time - this->m_wind_data[this->m_current_wind_data_index].time),\n\t(this->m_wind_data[this->m_current_wind_data_index + 1].velocity - this->m_wind_data[this->m_current_wind_data_index].velocity) / (this->m_wind_data[this->m_current_wind_data_index + 1].time - this->m_wind_data[this->m_current_wind_data_index].time),\n\t(this->m_wind_data[this->m_current_wind_data_index + 1].angular_velocity - this->m_wind_data[this->m_current_wind_data_index].angular_velocity) / (this->m_wind_data[this->m_current_wind_data_index + 1].time - this->m_wind_data[this->m_current_wind_data_index].time)\n}", "CodeBleu_score": 5.682024171024561}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (looping) {\n\t\ttime = fmod(_time, length);\n\t} else {\n\t\ttime = std::min(std::max(_time, 0.0), length);\n\t}\n}", "CodeBleu_score": 28.944525621123248}, {"code": "void Animation::SetTime(double _time){\n\t\tif (m_time == _time) {\n\t\treturn;\n\t}\n\n\tm_time = _time;\n\n\tif (m_loop) {\n\t\tif (m_time < 0) {\n\t\t\tm_time = 0;\n\t\t}\n\t\telse if (m_time > m_length) {\n\t\t\tm_time = m_length;\n\t\t}\n\t}\n\telse {\n\t\tif (m_time < 0) {\n\t\t\tm_time = 0;\n\t\t}\n\t\telse if (m_time > m_length) {\n\t\t\tm_time = m_length;\n\t\t}\n\t}\n\n\tUpdate();\n}", "CodeBleu_score": 37.01142354047844}, {"code": "void Animation::SetTime(double _time){\n\t\tif (m_looping) {\n\t\tm_time = fmod(_time, m_length);\n\t} else {\n\t\tm_time = std::min(std::max(_time, 0.0), m_length);\n\t}\n\tm_timeChanged = true;\n}", "CodeBleu_score": 29.768337220126362}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.armed = True\n    self.vehicle.mode = VehicleMode('STABILIZE')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode = VehicleMode('HOLD')\n    self.vehicle.mode = VehicleMode('GUIDED')\n    self.vehicle.mode =", "CodeBleu_score": 17.078859966165886}, {"code": "def hover(self)\n\t\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    self.construct_target()\n    print(self.vehicle_type)\n    print(self.vehicle_id)\n    print(self.flight_mode)\n\n", "CodeBleu_score": 12.488210904436983}, {"code": "def hover(self)\n\t\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    self.construct_target()\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 10.93720612850472}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    print", "CodeBleu_score": 0.4716981132075646}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService.get_mode() == 'HOVER':\n        self.hover(1)\n        print 'HOVER'\n    else:\n        try:\n            self.flightModeService.set_mode('HOVER')\n            print 'HOVER'\n        except:\n            print 'HOVER FAIL'\n            return False\n    return True\n\n", "CodeBleu_score": 26.724322383074522}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover(1)\n        return True\n    else:\n        try:\n            self.flightModeService.set_flight_mode(self.flightMode)\n            return True\n        except:\n            return False\n\n", "CodeBleu_score": 25.248293561357855}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_flag = False\n    self.hold_flag = False\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    if self.hover_flag is False:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z, 'enu')\n    if self.hover_flag is False and self.hold_flag is False:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.angular.z)\n\n", "CodeBleu_score": 47.49374161199665}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    else:\n        self.motion_type = 1\n        self.target_motion = self.construct_target(msg.linear.x, msg.angular.z)\n\n", "CodeBleu_score": 37.77620424833261}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z, 'enu')\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.angular.z)\n\n", "CodeBleu_score": 42.20972174840495}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 0:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover_action()\n    elif self.hover_flag == 1:\n        if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n\n", "CodeBleu_score": 66.35937309241247}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005):\n        self.hover_flag = 0\n        self.flight_mode = \"OFFBOARD\"\n    if (self.flight_mode!= \"HOVER\" and self.hover_flag == 1):\n        self.hover_flag = 1\n        self.flight_mode = \"HOVER\"\n        self.hover()\n    return self.hover_flag\n\n", "CodeBleu_score": 52.558518068231876}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    hover_flag = 0\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or w > 0.005):\n        hover_flag = 0\n    else:\n        hover_flag = 1\n    if hover_flag == 1:\n        self.flight_mode = 'HOVER'\n        self.hover()\n    else:\n        pass\n\n", "CodeBleu_score": 57.951323234808605}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n\n", "CodeBleu_score": 19.528210155997467}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.parameters[\"NAV_YAW_AUTO\"] = 1\n    self.vehicle.parameters[\"NAV_X\"] = self.current_position[0]\n    self.vehicle.parameters[\"NAV_Y\"] = self.current_position[1]\n    self.vehicle.parameters[\"NAV_Z\"] = self.current_position[2]\n    self.vehicle.parameters[\"NAV_HEADING\"] = self.current_yaw\n    self.vehicle.parameters[\"NAV_THR_AUTO\"] = 1\n    self.vehicle.parameters[\"NAV_SPEED_AUTO\"] = 1\n    self.vehicle.parameters[\"NAV_SPEED_X\"] = 0\n    self.vehicle.parameters[\"NAV_SPEED_Y\"] = 0\n    self.vehicle.parameters[\"NAV_SPEED_Z\"] = 0\n    self.vehicle.parameters[\"NAV_MODE\"] = 2\n    self.construct_target()\n    print(\"Vehicle type: \" + self.vehicle.type)\n    print(\"Vehicle ID: \" + self.vehicle.id)\n    print(\"Flight mode: \" + self.vehicle.mode.name)\n\n", "CodeBleu_score": 30.527035269034652}, {"code": "def hover(self)\n\t\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.parameters[\"ARMING_CHECK\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle.parameters[\"NAV_DLL_ENABLE\"] = 0\n    self.vehicle", "CodeBleu_score": 16.406879419759125}, {"code": "def hover(self)\n\t\n    self.set_frame(self.vehicle.CoordinateFrame.BodyNED)\n    self.set_motion_type(self.vehicle.MotionType.Position)\n    self.construct_target()\n    print(\"Vehicle Type: \" + self.vehicle.type)\n    print(\"Vehicle ID: \" + self.vehicle.id)\n    print(\"Flight Mode: \" + self.vehicle.mode.name)\n\n", "CodeBleu_score": 23.88366648457346}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        self.flightModeService.set_flight_mode(self.flightMode)\n        if self.flightMode == self.flightModeService.get_flight_mode():\n            print(f\"Switched to {self.flightMode} mode\")\n            return True\n        else:\n            print(f\"Failed to switch to {self.flightMode} mode\")\n            return False\n\n", "CodeBleu_score": 33.80076772860245}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover = True\n        self.hover()\n        print('Hover mode activated.')\n        return True\n    else:\n        try:\n            self.flightModeService.set_flight_mode('HOVER')\n            print('Flight mode set to HOVER.')\n            return True\n        except:\n            print('Flight mode could not be set to HOVER.')\n            return False\n\n", "CodeBleu_score": 42.629085244959384}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        self.flightModeService.set_flight_mode(self.flightMode)\n        self.flightMode = self.flightModeService.get_flight_mode()\n        if self.flightMode == self.flightMode:\n            print('Flight mode changed to:'+ self.flightMode)\n            return True\n        else:\n            print('Failed to change flight mode.')\n            return False\n\n", "CodeBleu_score": 35.127471833897275}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    if self.visualization:\n        self.visualize()\n    self.get_total_reward()\n\n", "CodeBleu_score": 66.86184075587938}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.index == self.uav_id:\n        self.local_pose = msg.pose\n        self.local_pose.pose.position.z = 0\n        self.local_pose.pose.orientation.w = 1\n        self.local_pose.pose.position.x += self.uav_bias[0]\n        self.local_pose.pose.position.y += self.uav_bias[1]\n        self.local_pose.pose.position.z += self.uav_bias[2]\n        self.global_pose = self.local_pose\n        self.global_pose.pose.position.x = self.local_pose.pose.position.x + self.global_pose_offset[0]\n        self.global_pose.pose.position.y = self.local_pose.pose.position.y + self.global_pose_offset[1]\n        self.global_pose.pose.position.z = self.local_pose.pose.position.z + self.global_pose_offset[2]\n        if self.takeoff_target_pose is not None:\n            self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x + self.takeoff_target_offset[0]\n            self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y + self.takeoff_target_offset[1]\n            self.takeoff_target_pose.pose.position.z = self.local_pose.pose.position.z + self.takeoff_target_offset[2]\n        if self.hover_target_pose is not None:\n            self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x + self.hover_target_offset[0]\n            self.hover_target_pose.pose.position.y = self.local_pose.pose.position.y + self.hover_target_offset[1]\n            self.hover_target_pose.pose.position.z = self.local_pose.pose.position.z + self.hover_target_offset[2]\n\n", "CodeBleu_score": 16.590534107824055}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.uav_id == self.uav_id:\n        self.local_pose = msg.pose\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = msg.pose\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = msg.pose\n        elif self.gcs_command == \"land\":\n            self.land_target_pose = msg.pose\n        elif self.gcs_command == \"stop\":\n            self.stop_target_pose = msg.pose\n        self.global_pose = msg.global_pose\n        self.local_pose.position.x += self.bias_x\n        self.local_pose.position.y += self.bias_y\n        self.local_pose.position.z += self.bias_z\n\n", "CodeBleu_score": 24.011959252628543}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.stamp.secs == 0:\n        return\n\n    if self.id == msg.header.frame_id:\n        self.local_pose = msg\n        self.local_pose.pose.position.x = msg.pose.position.x + self.bias_x\n        self.local_pose.pose.position.y = msg.pose.position.y + self.bias_y\n        self.local_pose.pose.position.z = msg.pose.position.z + self.bias_z\n        self.local_pose.pose.orientation.x = msg.pose.orientation.x\n        self.local_pose.pose.orientation.y = msg.pose.orientation.y\n        self.local_pose.pose.orientation.z = msg.pose.orientation.z\n        self.local_pose.pose.orientation.w = msg.pose.orientation.w\n        self.local_pose.header.stamp = msg.header.stamp\n        self.local_pose.header.frame_id = msg.header.frame_id\n        self.local_pose.child_frame_id = msg.header.frame_id\n\n        if self.takeoff_target_pose.header.frame_id == \"world\":\n            self.takeoff_target_pose = msg\n            self.takeoff_target_pose.pose.position.x = msg.pose.position.x + self.bias_x\n            self.takeoff_target_pose.pose.position.y = msg.pose.position.y + self.bias_y\n            self.takeoff_target_pose.pose.position.z = msg.pose.position.z + self.bias_z\n            self.takeoff_target_pose.pose.orientation.x = msg.pose.orientation.x\n            self.takeoff_target_pose.pose.orientation.y = msg.pose.orientation.y\n            self.takeoff_target_pose.pose.orientation.z = msg.pose.orientation.z\n            self.takeoff_target_pose.pose.orientation.w = msg.pose.orientation.w\n            self.takeoff_target_pose.header.stamp = msg.header.stamp\n            self.takeoff_target_pose.header.frame_id = msg.header.frame_id\n            self.takeoff_target_pose", "CodeBleu_score": 17.528808748111587}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.uav_state.alt > 0.2 and self.uav_state.armed:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 63.84873945785594}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == 1:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.609826728102846}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == 'armed':\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.7551094861517}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n\n    # Initialize the distance matrix\n    dist_mat = np.zeros((len(orig_formation), len(change_formation)))\n\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    for i, orig_uav in enumerate(orig_formation):\n        for j, change_uav in enumerate(change_formation):\n            dist_mat[i, j] = np.linalg.norm(orig_uav.position - change_uav.position)\n\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    for i in range(len(dist_mat)):\n        for j in range(len(dist_mat)):\n            dist_mat[i, j] = int(round(dist_mat[i, j] - 50))\n\n    return dist_mat\n\n", "CodeBleu_score": 25.740237855166708}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Create a distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i, j] = int(np.linalg.norm(orig_formation[i] - change_formation[j]) - 50)\n    return dist_matrix\n\n", "CodeBleu_score": 23.086745309679646}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the distance matrix\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i, j] = int(np.linalg.norm(\n                np.array(orig_formation[i]) - np.array(change_formation[j])) - 50)\n    return distance_matrix\n\n", "CodeBleu_score": 27.517420615238986}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in self.adj[i]:\n        if self.match[j] == -1:\n            return True\n        elif not self.visited[self.match[j]]:\n            self.slack[self.match[j]] = min(self.slack[self.match[j]], self.gap[i] + self.gap[j] - self.weight[i][j])\n            if self.slack[self.match[j]] == 0:\n                self.visited[self.match[j]] = True\n                if self.find_path(self.match[j]):\n                    self.match[j] = i\n                    self.match[i] = j\n                    return True\n    return False\n\n", "CodeBleu_score": 36.33306747395153}, {"code": "def find_path(self, i)\n\t\n    self.visited[i] = True\n    for j in range(self.n):\n        if self.graph[i][j] > 0 and not self.visited[j]:\n            if self.find_path(j):\n                self.parent[j] = i\n                return True\n            elif self.slack[j] > self.graph[i][j] - self.match[i]:\n                self.slack[j] = self.graph[i][j] - self.match[i]\n                if self.slack[j] == 0:\n                    self.parent[j] = i\n                    return True\n    return False\n\n", "CodeBleu_score": 35.02472056214176}, {"code": "def find_path(self, i)\n\t\n    if self.visited[i] == 1:\n        return False\n    self.visited[i] = 1\n    for j in self.graph[i]:\n        if self.match[j] == -1:\n            return True\n        if self.visited[self.match[j]] == 0:\n            if self.gap[j] + self.labels[i] - self.labels[self.match[j]] == 0:\n                self.visited[self.match[j]] = 1\n                if self.find_path(self.match[j]):\n                    self.match[j] = i\n                    self.match[i] = j\n                    return True\n            else:\n                self.slack[j] = min(self.slack[j], self.gap[j] + self.labels[i] - self.labels[self.match[j]])\n    return False\n\n", "CodeBleu_score": 35.890831970628746}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    self.find_path", "CodeBleu_score": 0.2525252525252526}, {"code": "def KM(self)\n\t\n    for uav in self.UAVs:\n        self.slack = numpy.full((self.num_UAVs, self.num_UAVs), numpy.inf)\n        self.visited = numpy.full((self.num_UAVs, self.num_UAVs), False)\n        self.find_path(uav)\n        if self.path is None:\n            self.adjust_labels()\n    return self.match_results\n\n", "CodeBleu_score": 14.901084525373943}, {"code": "def KM(self)\n\t\n    for i in range(self.n):\n        self.slack[i] = self.inf\n        self.slack_row[i] = -1\n        self.slack_col[i] = -1\n        self.U[i] = True\n        self.V[i] = False\n    self.iter = 0\n    while True:\n        self.iter += 1\n        self.unmatched = 0\n        self.augment()\n        if self.unmatched == self.n:\n            break\n        self.find_slack()\n        self.update_labels()\n    return self.match\n", "CodeBleu_score": 18.219257947348844}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower = np.uint8([10, 100, 100])\n    upper = np.uint8([40, 255, 255])\n    mask = cv2.inRange(hsv, lower, upper)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 38.61729550662585}, {"code": "def yellow_dectection(image)\n\t\n    # convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # define range of yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    # create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # apply the mask to the image\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    lower = np.uint8([20, 100, 100])\n    upper = np.uint8([30, 255, 255])\n    mask = cv2.inRange(hsv, lower, upper)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 30.97271543663033}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\tconst int id,", "CodeBleu_score": 0.8212972136006462}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tconst std::string& id,\n\tTagDescriptionContainer& descriptionContainer,\n\tbool printWarning = true\n}", "CodeBleu_score": 1.6784695850104634}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tconst std::string &id,\nbool printWarning,\nTagDescriptionContainer &descriptionContainer\n}", "CodeBleu_score": 1.419368564213325}]}
