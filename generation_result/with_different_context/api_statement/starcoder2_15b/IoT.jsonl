{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t len;\n\tuint8_t *pdesc;\n\n\tpdesc = (uint8_t *) desc;\n\twhile (1) {\n\t\tif (pdesc[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) pdesc;\n\t\t}\n\t\tlen = pdesc[0];\n\t\tif (len == 0 || len > 0x80) {\n\t\t\treturn NULL;\n\t\t}\n\t\tpdesc += len;\n\t\tif (pdesc[1] == USB_DESC_INTERFACE) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.152760110053414}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_iface_desc_t UDC_DESC_STORAGE *iface_desc;\n\tusb_conf_desc_t UDC_DESC_STORAGE *conf_desc;\n\tuint8_t *desc_ptr;\n\tuint16_t desc_len;\n\n\tiface_desc = (usb_iface_desc_t UDC_DESC_STORAGE *) desc;\n\tconf_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) desc;\n\tdesc_ptr = (uint8_t *) desc;\n\n\t/* Check if the descriptor is a valid interface descriptor */\n\tif (iface_desc->bDescriptorType!= USB_DESC_INTERFACE) {\n\t\treturn NULL;\n\t}\n\n\t/* Get the length of the interface descriptor */\n\tdesc_len = iface_desc->bLength;\n\n\t/* Move to the next descriptor */\n\tdesc_ptr += desc_len;\n\n\t/* Loop until the end of the configuration descriptor is reached */\n\twhile (desc_ptr < (uint8_t *) conf_desc + conf_desc->wTotalLength) {\n\t\t/* Check if the current descriptor matches the specified descriptor type */\n\t\tif (((usb_desc_header_t UDC_DESC_STORAGE *) desc_ptr)->bDescriptorType == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\t}\n\n\t\t/* Move to the next descriptor */\n\t\tdesc_ptr += ((usb_desc_header_t UDC_DESC_STORAGE *) desc_ptr)->bLength;\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 47.468332238097844}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *end = (uint8_t *) desc + desc->bLength;\n\tuint8_t *p = (uint8_t *) desc;\n\twhile (p < end) {\n\t\tif (p[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p;\n\t\t}\n\t\tp += p[0];\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.36210746288327}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *p = (uint8_t *)p_config_desc;\n\tuint8_t *p_end = (uint8_t *)p_config_desc + p_config_desc->wTotalLength;\n\tuint8_t *p_desc;\n\tuint8_t *p_desc_end;\n\n\tif (p_config_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= p_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\twhile (p < p_end) {\n\t\tif (p[1] == USB_DESC_INTERFACE) {\n\t\t\tif (p[2] == iface_num && p[3] == setting_num) {\n\t\t\t\tp_iface_desc = (usb_iface_desc_t *)p;\n\t\t\t\tp_desc = (uint8_t *)p_iface_desc + p_iface_desc->bLength;\n\t\t\t\tp_desc_end = (uint8_t *)p_iface_desc + p_iface_desc->wTotalLength;\n\t\t\t\twhile (p_desc < p_desc_end) {\n\t\t\t\t\tif (p_desc[1] == USB_DESC_ENDPOINT) {\n\t\t\t\t\t\tp_ep_desc = (usb_ep_desc_t *)p_desc;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tp_desc += p_desc[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp += p[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 43.50284840676504}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *desc = (uint8_t *) &cfg_desc;\n\tuint8_t *end = desc + cfg_desc.wTotalLength;\n\tuint8_t *desc_end;\n\tuint8_t *desc_start;\n\tuint8_t *iface_desc;\n\tuint8_t *iface_desc_end;\n\tuint8_t *iface_desc_start;\n\tuint8_t *prev_desc;\n\tuint8_t *prev_desc_end;\n\tuint8_t *prev_desc_start;\n\tuint8_t *prev_iface_desc;\n\tuint8_t *prev_iface_desc_end;\n\tuint8_t *prev_iface_desc_start;\n\tuint8_t *prev_setting_desc;\n\tuint8_t *prev_setting_desc_end;\n\tuint8_t *prev_setting_desc_start;\n\tuint8_t *setting_desc;\n\tuint8_t *setting_desc_end;\n\tuint8_t *setting_desc_start;\n\tuint8_t *tmp_desc;\n\tuint8_t *tmp_desc_end;\n\tuint8_t *tmp_desc_start;\n\tuint8_t *tmp_iface_desc;\n\tuint8_t *tmp_iface_desc_end;\n\tuint8_t *tmp_iface_desc_start;\n\tuint8_t *tmp_setting_desc;\n\tuint8_t *tmp_setting_desc_end;\n\tuint8_t *tmp_setting_desc_start;\n\tuint8_t bAlternateSetting;\n\tuint8_t bInterfaceNumber;\n\tuint8_t bNumEndpoints;\n\tuint8_t bNumInterfaces;\n\tuint8_t bEndpointAddress;\n\tuint8_t bEndpointAttributes;\n\tuint16_t wMaxPacketSize;\n\tuint8_t bInterfaceClass;\n\tuint8_t bInterfaceSubClass;\n\tuint8_t bInterfaceProtocol;\n\tuint8_t bLength;\n\tuint8_t bDescriptorType;\n\tuint8_t bDescriptorSubtype;", "CodeBleu_score": 14.064068817244953}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tconst usb_desc_header_t *desc;\n\tconst usb_desc_iface_t *iface;\n\tconst usb_desc_conf_t *conf;\n\tuint8_t i;\n\n\t/* Check that there is a valid configuration */\n\tif (current_config == NULL) {\n\t\treturn false;\n\t}\n\n\t/* Check that the interface number is within bounds */\n\tif (iface_num >= current_config->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t/* Iterate through the descriptors, starting from the beginning of the configuration descriptor */\n\tdesc = (const usb_desc_header_t *)current_config;\n\ti = 0;\n\twhile (i < current_config->bNumInterfaces) {\n\t\t/* Check if the current descriptor is an interface descriptor */\n\t\tif (desc->bDescriptorType == USB_DESC_TYPE_INTERFACE) {\n\t\t\t/* Cast the descriptor to an interface descriptor */\n\t\t\tiface = (const usb_desc_iface_t *)desc;\n\n\t\t\t/* Check if the interface number and setting number match */\n\t\t\tif (iface->bInterfaceNumber == iface_num && iface->bAlternateSetting == setting_num) {\n\t\t\t\t/* Update the interface descriptor */\n\t\t\t\tcurrent_iface_desc = iface;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/* Increment the interface number */\n\t\t\ti++;\n\t\t}\n\n\t\t/* Move to the next descriptor */\n\t\tdesc = (const usb_desc_header_t *)((uint8_t *)desc + desc->bLength);\n\t}\n\n\t/* If we reach this point, the interface descriptor was not found */\n\treturn false;\n}", "CodeBleu_score": 43.10905221056521}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(uint16_t)) {\n\t\treturn false;\n\t}\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\tudd_set_setup_payload(1, (uint8_t) UDPHS_EPT_STAT_STALL);\n\t} else {\n\t\tudd_set_setup_payload(1, 0);\n\t}\n\treturn true;\n}", "CodeBleu_score": 29.09888779165416}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(uint16_t)) {\n\t\treturn false;\n\t}\n\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\tudd_set_setup_payload(1, (uint8_t)UDC_EP_STATUS_HALTED);\n\t} else {\n\t\tudd_set_setup_payload(1, 0);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 29.766643427923313}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (udd_g_ctrlreq.req.wLength!= sizeof(udd_ep_status_t)) {\n\t\treturn false;\n\t}\n\tudd_ep_status_t status = 0;\n\tif (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex)) {\n\t\tstatus = 1;\n\t}\n\tudd_set_setup_payload(status);\n\treturn true;\n}", "CodeBleu_score": 35.947628741230176}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num = udc_get_iface_num(udd_g_ctrlreq.req.wIndex);\n\n\tif (iface_num == UDPHS_IF_NUM_MAX) {\n\t\treturn false;\n\t}\n\n\tif (udc_update_iface_desc(iface_num, 0) == false) {\n\t\treturn false;\n\t}\n\n\tif (udc_update_iface_desc(iface_num, udc_g_dscr_iface[iface_num].bAlternateSetting) == false) {\n\t\treturn false;\n\t}\n\n\tif (udc_g_dscr_iface[iface_num].bInterfaceClass == UDI_CLASS) {\n\t\treturn udi_api[iface_num]->setup(udd_g_ctrlreq.req.bRequest, udd_g_ctrlreq.req.wValue, udd_g_ctrlreq.req.wIndex, udd_g_ctrlreq.req.wLength);\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 54.30840505603653}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface = udc_req.wIndex;\n\tuint8_t alt = udc_req.wValue;\n\tstruct udi_api_req_t req;\n\n\tif (!udc_is_high_speed() || udc_state!= UDC_STATE_ADDRESSED) {\n\t\treturn false;\n\t}\n\tif (iface >= udc_ifaces_nb) {\n\t\treturn false;\n\t}\n\tif (alt >= udc_ifaces[iface].nb_alt) {\n\t\treturn false;\n\t}\n\tif (udc_update_iface_desc(iface, alt)!= UDD_OK) {\n\t\treturn false;\n\t}\n\treq.payload = NULL;\n\treq.payload_size = 0;\n\treq.callback = NULL;\n\treq.valid = true;\n\treturn udi_api[iface]->setup(&req);\n}", "CodeBleu_score": 52.483250004242834}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num = udc_ctrl_req->wIndex;\n\tuint8_t iface_pos = udi_get_iface_position(iface_num);\n\tuint8_t iface_setting;\n\n\tif (iface_pos == UDI_UNKNOWN_IFACE_NUMBER) {\n\t\treturn false;\n\t}\n\n\tif (udc_g_state!= UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\n\tiface_setting = udi_get_current_setting(iface_num);\n\n\tif (iface_setting == UDI_UNKNOWN_SETTING_NUMBER) {\n\t\treturn false;\n\t}\n\n\tif (iface_setting!= udc_ctrl_req->wValue) {\n\t\tif (!udc_update_iface_desc(iface_num, iface_setting)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!udc_update_iface_desc(iface_num, udc_ctrl_req->wValue)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn udi_api[iface_pos].setup(udc_ctrl_req);\n}", "CodeBleu_score": 52.345804879047144}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\t// Set initial states for several flags\n\tudi_msc_enabled = false;\n\tudi_msc_cbw_wait = true;\n\tudi_msc_cbw_received = false;\n\tudi_msc_cbw_sent = false;\n\tudi_msc_cbw_data_received = false;\n\tudi_msc_cbw_data_sent = false;\n\tudi_msc_csw_sent = false;\n\tudi_msc_csw_received = false;\n\tudi_msc_csw_wait = false;\n\tudi_msc_cbw_data_length = 0;\n\tudi_msc_cbw_data_sent_length = 0;\n\tudi_msc_cbw_data_received_length = 0;\n\tudi_msc_cbw_data_length_to_send = 0;\n\tudi_msc_cbw_data_length_to_receive = 0;\n\n\t// Retrieve the number of LUNs\n\tudi_msc_nb_lun = get_nb_lun();\n\n\t// Check if there are any LUNs available\n\tif (udi_msc_nb_lun == 0) {\n\t\treturn false;\n\t}\n\n\t// Check if the external enable function fails\n\tif (!UDI_MSC_ENABLE_EXT()) {\n\t\treturn false;\n\t}\n\n\t// Unload the medium on each LUN\n\tmem_unload();\n\n\t// Start the MSC process by waiting for a CBW reception\n\tudi_msc_cbw_wait = true;\n\n\treturn true;\n}", "CodeBleu_score": 34.434796093758635}, {"code": "bool udi_msc_enable(void){\n\t\t// Initialize the device state\n\tudi_msc_device_state = UDI_MSC_UNATTACHED;\n\t// Initialize the device state\n\tudi_msc_trans_state = UDI_MSC_CBW_WAIT;\n\t// Get the number of LUNs\n\tudi_msc_nb_lun = get_nb_lun();\n\t// Check if there are any LUNs\n\tif (udi_msc_nb_lun == 0) {\n\t\treturn false;\n\t}\n\t// Check if the external enable function fails\n\tif (!UDI_MSC_ENABLE_EXT()) {\n\t\treturn false;\n\t}\n\t// Unload the medium on each LUN\n\tfor (uint8_t i = 0; i < udi_msc_nb_lun; i++) {\n\t\tmem_unload(i);\n\t}\n\t// Start the MSC process by waiting for a CBW reception\n\tudi_msc_cbw_wait();\n\treturn true;\n}", "CodeBleu_score": 48.40871769764363}, {"code": "bool udi_msc_enable(void){\n\t\tbool b_enable = false;\n\n\t// Initialize internal variables\n\tudi_msc_cbw_wait = false;\n\tudi_msc_cbw_state = UDI_MSC_CBW_STATE_WAIT;\n\tudi_msc_cbw_size = 0;\n\tudi_msc_cbw_lun = 0;\n\tudi_msc_cbw_tag = 0;\n\tudi_msc_cbw_data_size = 0;\n\tudi_msc_cbw_data_remaining = 0;\n\tudi_msc_cbw_data_ptr = NULL;\n\tudi_msc_cbw_data_state = UDI_MSC_CBW_DATA_STATE_NONE;\n\tudi_msc_cbw_data_trans = UDI_MSC_CBW_DATA_TRANS_NONE;\n\tudi_msc_cbw_data_trans_state = UDI_MSC_CBW_DATA_TRANS_STATE_NONE;\n\tudi_msc_cbw_data_trans_size = 0;\n\tudi_msc_cbw_data_trans_count = 0;\n\tudi_msc_cbw_data_trans_ptr = NULL;\n\tudi_msc_cbw_data_trans_timeout = 0;\n\tudi_msc_cbw_csw_state = UDI_MSC_CSW_STATE_NONE;\n\tudi_msc_cbw_csw_status = UDI_MSC_CSW_STATUS_GOOD;\n\n\t// Retrieve the number of LUNs\n\tudi_msc_nb_lun = get_nb_lun();\n\n\t// Check if there is at least one LUN\n\tif (udi_msc_nb_lun > 0) {\n\t\t// Check if the external enable function is defined\n\t\tif (UDI_MSC_ENABLE_EXT!= NULL) {\n\t\t\t// Call the external enable function\n\t\t\tb_enable = UDI_MSC_ENABLE_EXT();\n\t\t}\n\t\telse {\n\t\t\t// No external enable function defined\n\t\t\tb_enable = true;\n\t\t}\n\n\t\t// Check if the external enable function succeeded\n\t\tif (b_enable) {\n\t\t\t// Unload the medium on each LUN\n\t\t\tmem_", "CodeBleu_score": 41.9405038445685}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(ep);\n\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\t// Transfer aborted\n\t\tudi_msc_reset_cbw();\n\t\treturn;\n\t}\n\tudi_msc_cbw_data_residue -= nb_sent;\n\tudi_msc_process_csw();\n}", "CodeBleu_score": 55.43278191136369}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\tif (status == UDD_EP_TRANSFER_ABORT) {\n\t\t\treturn;\n\t\t}\n\t\tudi_msc_reset_cbw();\n\t\treturn;\n\t}\n\tudi_msc_csw_process();\n}", "CodeBleu_score": 50.28278614460018}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tUNUSED(ep);\n\tif (status!= UDD_EP_TRANSFER_OK) {\n\t\tudi_msc_wait_setup_reset();\n\t\treturn;\n\t}\n\tudi_msc_update_sense_data(UDI_MSC_SENSE_DATA_SUCCESS);\n\tudi_msc_csw.dCSWDataResidue -= nb_sent;\n\tudi_msc_csw_process();\n}", "CodeBleu_score": 63.76879584375408}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\t/*\n\t * The function \"udi_msc_csw_process\" handles the processing of the Command Status Wrapper (CSW) in a USB Mass Storage Class device.\n\t */\n\tif (udd_g_ctrlreq.payload_size!= sizeof(udi_msc_csw_t)) {\n\t\t/*\n\t\t * If there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n\t\t */\n\t\tif (udd_g_ctrlreq.payload_size > sizeof(udi_msc_csw_t)) {\n\t\t\t/*\n\t\t\t * It then prepares the CSW by setting its tag and converting the data residue to little-endian format before sending the CSW.\n\t\t\t */\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\tudd_ep_set_halt(UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\t/*\n\t * It then prepares the CSW by setting its tag and converting the data residue to little-endian format before sending the CSW.\n\t */\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 65.75620253728233}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint32_t data_residue;\n\tuint32_t csw_tag;\n\tuint8_t  csw_status;\n\n\t/* Check if the CBW is valid */\n\tif (udd_g_ctrlreq.req.wLength!= sizeof(udi_msc_cbw_t)) {\n\t\tcsw_status = UDI_MSC_CSW_PHASE_ERROR;\n\t} else {\n\t\tcsw_status = UDI_MSC_CSW_CMD_PASSED;\n\t}\n\n\t/* Check if the CBW is valid */\n\tif (udi_msc_cbw.dCBWSignature!= UDI_MSC_CBW_SIGNATURE) {\n\t\tcsw_status = UDI_MSC_CSW_PHASE_ERROR;\n\t}\n\n\t/* Check if the CBW is valid */\n\tif (udi_msc_cbw.dCBWTag!= udi_msc_cbw_tag) {\n\t\tcsw_status = UDI_MSC_CSW_PHASE_ERROR;\n\t}\n\n\t/* Check if the CBW is valid */\n\tif (udi_msc_cbw.bCBWLUN!= udi_msc_cbw.bCBWLUN) {\n\t\tcsw_status = UDI_MSC_CSW_PHASE_ERROR;\n\t}\n\n\t/* Check if the CBW is valid */\n\tif (udi_msc_cbw.bCBWCBLength!= sizeof(udi_msc_cbw_t)) {\n\t\tcsw_status = UDI_MSC_CSW_PHASE_ERROR;\n\t}\n\n\t/* Check if the CBW is valid */\n\tif (udi_msc_cbw.bmCBWFlags == UDI_MSC_CBW_DIRECTION_IN) {\n\t\t/* Check if the CBW is valid */\n\t\tif (udi_msc_cbw.dCBWDataTransferLength!= udi_msc_cbw.dCBWDataTransferLength) {\n\t\t\tcsw_status = UDI_MSC_CSW_PHASE_ERROR;\n\t\t}\n\t}\n\n\t/* Check if the CBW is valid */\n\tif (udi_msc_cbw.bmCBWFlags == UDI_MSC_CBW_DIRECTION", "CodeBleu_score": 34.82840561168858}, {"code": "static void udi_msc_csw_process(void){\n\t\tif (udd_g_ctrlreq.payload_size) {\n\t\tudi_msc_csw_send();\n\t\treturn;\n\t}\n\n\tudi_msc_csw_prepare();\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 21.88565818279271}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tif (b_enable) {\n\t\tif (cdc_serial_state.dtr == 0) {\n\t\t\tif (cdc_serial_state.rate == 1200) {\n\t\t\t\tscheduleReset(true);\n\t\t\t}\n\t\t\tcdc_serial_state.dtr = 1;\n\t\t}\n\t} else {\n\t\tif (cdc_serial_state.dtr!= 0) {\n\t\t\tcancelReset();\n\t\t\tcdc_serial_state.dtr = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.55342518710907}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tUNUSED(port);\n\tUNUSED(b_enable);\n\tif (b_enable) {\n\t\tif (CDC_1200_BAUDRATE_ENABLED) {\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\tif (CDC_1200_BAUDRATE_ENABLED) {\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 43.40597351126706}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port == 0) {\n\t\tif (b_enable) {\n\t\t\tif (g_usb_cdc_dtr_rate[port] == 1200) {\n\t\t\t\t/* Schedule a delayed system reset */\n\t\t\t\tg_usb_cdc_dtr_rate[port] = 0;\n\t\t\t\tg_usb_cdc_dtr_enable[port] = false;\n\t\t\t\tg_usb_cdc_reset_delay[port] = 1000;\n\t\t\t\tinitiateReset();\n\t\t\t} else {\n\t\t\t\tg_usb_cdc_dtr_enable[port] = true;\n\t\t\t}\n\t\t} else {\n\t\t\tg_usb_cdc_dtr_enable[port] = false;\n\t\t\tcancelReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 31.495894305628582}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tuint8_t *payload = usb_control_request.payload;\n\tuint16_t size = usb_control_request.size;\n\tuint8_t request = usb_control_request.request;\n\tuint8_t request_type = usb_control_request.request_type;\n\tuint16_t value = usb_control_request.value;\n\tuint16_t index = usb_control_request.index;\n\tuint16_t length = usb_control_request.length;\n\n\tif ((request_type & USB_REQUEST_TYPE_MASK)!= USB_REQUEST_TYPE_VENDOR)\n\t\treturn false;\n\n\tif (request == 0x04) {\n\t\tpayload = (uint8_t*) &microsoft_compatible_id_descriptor;\n\t\tsize = sizeof(microsoft_compatible_id_descriptor);\n\t} else if (request == 0x05) {\n\t\tpayload = (uint8_t*) &microsoft_extended_properties_descriptor;\n\t\tsize = sizeof(microsoft_extended_properties_descriptor);\n\t} else {\n\t\treturn false;\n\t}\n\n\tusb_control_request.payload = payload;\n\tusb_control_request.size = size;\n\n\treturn true;\n}", "CodeBleu_score": 30.618463968718224}, {"code": "bool usb_task_other_requests(void){\n\t\tuint8_t *payload = NULL;\n\tuint16_t size = 0;\n\tbool processed = false;\n\n\tswitch (usb_setup.bRequest) {\n\t\tcase 0x04:\n\t\t\tpayload = (uint8_t *)&udi_hid_ms_vendor_id;\n\t\t\tsize = sizeof(udi_hid_ms_vendor_id);\n\t\t\tprocessed = true;\n\t\t\tbreak;\n\n\t\tcase 0x05:\n\t\t\tpayload = (uint8_t *)&udi_hid_ms_product_id;\n\t\t\tsize = sizeof(udi_hid_ms_product_id);\n\t\t\tprocessed = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (processed) {\n\t\tudi_hid_ms_setup_request(payload, size);\n\t}\n\n\treturn processed;\n}", "CodeBleu_score": 21.159114611217884}, {"code": "bool usb_task_other_requests(void){\n\t\tuint8_t wValueLo = Usb_setup.wValue.8[0];\n\tuint8_t wValueHi = Usb_setup.wValue.8[1];\n\tuint8_t wIndexLo = Usb_setup.wIndex.8[0];\n\tuint8_t wIndexHi = Usb_setup.wIndex.8[1];\n\tuint8_t wLengthLo = Usb_setup.wLength.8[0];\n\tuint8_t wLengthHi = Usb_setup.wLength.8[1];\n\tuint8_t bmRequestType = Usb_setup.bmRequestType;\n\n\tif (bmRequestType == 0x80) {\n\t\tif (wIndexLo == 0x04) {\n\t\t\tUsb_control_request.payload = (uint8_t *)(&msos_descriptor);\n\t\t\tUsb_control_request.size = sizeof(msos_descriptor);\n\t\t\treturn true;\n\t\t}\n\t\tif (wIndexLo == 0x05) {\n\t\t\tUsb_control_request.payload = (uint8_t *)(&msos_ext_prop_descriptor);\n\t\t\tUsb_control_request.size = sizeof(msos_ext_prop_descriptor);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 20.453560295563815}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\twhile (nbyte--) {\n\t\tSPI_TX_DATA = 0xFF;\n\t\twhile (!(SPI_STATUS & SPI_INT_FLAG));\n\t\t*buf++ = SPI_RX_DATA;\n\t}\n\tspiRec();\n}", "CodeBleu_score": 23.809742439451377}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\twhile (nbyte--) {\n\t\tspiRec();\n\t\t*buf++ = spiRec();\n\t}\n\tspiRec();\n}", "CodeBleu_score": 25.383463722216916}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\twhile (nbyte--) {\n\t\tspiSend(0xFF);\n\t\twhile (!SPI_PCS) {\n\t\t\t;\n\t\t}\n\t\t*buf++ = spiRec();\n\t}\n\tspiRec();\n}", "CodeBleu_score": 28.84000308381615}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tCRITICAL_SECTION_START\n\toldHandler = (pfnISR_Handler)g_pfnVectors[irq];\n\tg_pfnVectors[irq] = newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 44.666326139091716}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *pTable;\n\tuint32_t irq_index;\n\n\t/* Get the relocated interrupt vector table */\n\tpTable = get_relocated_table_addr();\n\n\t/* Disable global interrupts */\n\t__disable_irq();\n\n\t/* Get the current handler for the specified IRQ */\n\toldHandler = (pfnISR_Handler)pTable[irq];\n\n\t/* Replace the current handler with the new handler */\n\tirq_index = (uint32_t)irq;\n\tpTable[irq_index] = (uint32_t)newHandler;\n\n\t/* Re-enable global interrupts */\n\t__enable_irq();\n\n\t/* Return the original ISR handler */\n\treturn oldHandler;\n}", "CodeBleu_score": 49.762728476841936}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tCRITICAL_SECTION_START\n\tpfnISR_Handler oldHandler = NULL;\n\tuint32_t *vectorTable = (uint32_t *)get_relocated_table_addr();\n\toldHandler = (pfnISR_Handler)vectorTable[irq];\n\tvectorTable[irq] = (uint32_t)newHandler;\n\tCRITICAL_SECTION_END\n\treturn oldHandler;\n}", "CodeBleu_score": 48.86021163233817}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.available()) {\n    return emergency_parser.read();\n  }\n#endif\n  if (usb_task_cdc_isenabled()) {\n    if (udi_cdc_is_rx_ready()) {\n      char c = udi_cdc_getc();\n      if (c!= -1) {\n        if (c == '\n') c = '\\r';\n        return c;\n      }\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 33.5358576009893}, {"code": "int MarlinSerialUSB::peek(){\n\t\t// If the USB CDC is not enabled or configured on the PC side, or if no bytes are sent from the PC, return -1.\n\tif (!usb_task_cdc_isenabled()) return -1;\n\n\t// If bytes are available, read the next character, process it if the emergency parser is enabled, and return the character.\n\tif (udi_cdc_is_rx_ready()) {\n\t\tchar c = udi_cdc_getc();\n\t\tif (emergency_parser.enabled) {\n\t\t\temergency_parser.process(c);\n\t\t}\n\t\treturn c;\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 41.691438855850485}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (usb_task_cdc_isenabled() && USB_SERIAL_CDC.isConfigured()) {\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\tchar c = udi_cdc_getc();\n\t\t\tif (EMERGENCY_PARSER_ENABLED) emergency_parser.process(c);\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 33.546901247091}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (SerialUSB.available()) {\n\t\tchar c = SerialUSB.read();\n\t\tif (EMERGENCY_PARSER_ENABLED) emergency_parser.update(c);\n\t\treturn c;\n\t}\n\treturn -1;\n}", "CodeBleu_score": 33.079205842379686}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (peek() >= 0) return read();\n\tif (!usb_task_cdc_isenabled()) return -1;\n\tif (!udi_cdc_is_rx_ready()) return -1;\n\tchar c = udi_cdc_getc();\n\tif (emergency_parser.enabled()) emergency_parser.update(c);\n\treturn c;\n}", "CodeBleu_score": 49.22320908802759}, {"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.available())\n    return emergency_parser.read();\n#endif\n\n  if (udi_cdc_is_rx_ready()) {\n    uint8_t c = udi_cdc_getc();\n#if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(c);\n#endif\n    return c;\n  }\n\n  return -1;\n}", "CodeBleu_score": 41.42676357763288}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_configuration) {\n\t\tint count = usb_cdc_available();\n\t\tif (count >= 0) return count;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 48.83244759634666}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_cdc_is_rx_ready())\n\t\treturn usb_cdc_rx_size();\n\telse\n\t\treturn usb_task_cdc_isenabled();\n}", "CodeBleu_score": 21.105463549417976}, {"code": "int MarlinSerialUSB::available(){\n\t\treturn usb_task_cdc_isenabled()? usb_task_cdc_is_rx_ready() : 0;\n}", "CodeBleu_score": 16.623671299572724}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (size == 0) {\n\t\treturn true;\n\t}\n\tif (writing) {\n\t\twhile (size--) {\n\t\t\tuint8_t v = *value++;\n\t\t\tee_Write(pos++, v);\n\t\t\tif (crc) {\n\t\t\t\t*crc = crc16(*crc, v);\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (size--) {\n\t\t\tuint8_t v = ee_Read(pos++);\n\t\t\tif (value) {\n\t\t\t\t*value++ = v;\n\t\t\t}\n\t\t\tif (crc) {\n\t\t\t\t*crc = crc16(*crc, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 45.60748083241959}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\tif (writing) {\n\t\t\t*value = ee_Read(pos);\n\t\t}\n\t\tif (crc) {\n\t\t\t*crc = crc16(*crc, *value);\n\t\t}\n\t\tpos++;\n\t\tif (writing) {\n\t\t\tvalue++;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 51.89166085269633}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\twhile (size--) {\n\t\tif (writing) {\n\t\t\t*value = ee_Read(pos);\n\t\t}\n\t\t*crc = crc16(*crc, *value);\n\t\t++pos;\n\t\t++value;\n\t}\n\treturn false;\n}", "CodeBleu_score": 46.28218857544283}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (value == 0) {\n\t\t// Turn off the LED\n\t\tdigitalWrite(pin, LOW);\n\t\treturn;\n\t}\n\n\t// Use hardware PWM if possible\n\tif (ledcWrite(pin, value)) {\n\t\treturn;\n\t}\n\n\t// Find a free slot\n\tuint8_t slot = 0;\n\tfor (uint8_t i = 0; i < PWM_MAX_CHANNELS; i++) {\n\t\tif (pwm_channels[i].pin == 0) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (slot == 0) {\n\t\t// No free slots\n\t\treturn;\n\t}\n\n\t// Set the pin mode\n\tpinMode(pin, OUTPUT);\n\n\t// Store the pin number\n\tpwm_channels[slot].pin = pin;\n\n\t// Store the PWM value\n\tpwm_channels[slot].value = value;\n\n\t// Store the PWM frequency\n\tpwm_channels[slot].freq = freq;\n\n\t// Store the PWM resolution\n\tpwm_channels[slot].res = res;\n\n\t// Start the timer if this is the first PWM pin used\n\tif (pwm_count == 0) {\n\t\t// Start the timer\n\t\tHAL_timer_start(PWM_TIMER_ID, PWM_TIMER_PERIOD, HAL_timer_callback_t(pwm_timer_isr), NULL);\n\t}\n\n\t// Increment the PWM count\n\tpwm_count++;\n}", "CodeBleu_score": 51.528384469564095}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (value > 0) {\n\t\t// Get the channel for the pin\n\t\tuint8_t channel = get_pwm_channel(pin);\n\n\t\tif (channel == 255) {\n\t\t\t// No hardware PWM available for this pin, so use software PWM\n\t\t\tchannel = get_software_pwm_channel(pin);\n\t\t\tif (channel == 255) {\n\t\t\t\t// No software PWM channel available for this pin, so allocate a new one\n\t\t\t\tchannel = allocate_software_pwm_channel(pin);\n\t\t\t}\n\n\t\t\t// Set the PWM value\n\t\t\tset_software_pwm_value(channel, value);\n\t\t} else {\n\t\t\t// Set the PWM value\n\t\t\tledcWrite(channel, value);\n\t\t}\n\t} else {\n\t\t// Turn off the PWM\n\t\tledcWrite(get_pwm_channel(pin), 0);\n\t}\n}", "CodeBleu_score": 23.665221579568314}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (value == 0) {\n\t\tdigitalWrite(pin, LOW);\n\t\treturn;\n\t}\n\tif (value == 65535) {\n\t\tdigitalWrite(pin, HIGH);\n\t\treturn;\n\t}\n\tif (freq == 0) {\n\t\t// no frequency specified, use the default\n\t\tfreq = PWM_FREQUENCY;\n\t}\n\tif (res == 0) {\n\t\t// no resolution specified, use the default\n\t\tres = PWM_RESOLUTION;\n\t}\n\tif (res > 16) {\n\t\t// maximum resolution is 16 bits\n\t\tres = 16;\n\t}\n\tif (freq > 1000000) {\n\t\t// maximum frequency is 1 MHz\n\t\tfreq = 1000000;\n\t}\n\tif (res > 8) {\n\t\t// for resolutions greater than 8 bits, the value is right-shifted by res-8\n\t\t// this allows the PWM to be set to a higher resolution than the timer can actually achieve\n\t\t// the timer is set to the highest resolution it can achieve\n\t\t// the PWM is then set to a lower resolution than the timer can actually achieve\n\t\t// this allows the PWM to be set to a higher resolution than the timer can actually achieve\n\t\t// this is achieved by setting the PWM to the highest resolution possible and then\n\t\t// setting the PWM value to the desired value right-shifted by res-8\n\t\t// the PWM value is then scaled by the resolution of the timer\n\t\t// the PWM value is then scaled by the resolution of the timer\n\t\t// this is achieved by setting the PWM to the highest resolution possible and then\n\t\t// setting the PWM value to the desired value right-shifted by res-8\n\t\t// the PWM value is then scaled by the resolution of the timer\n\t\t// the PWM value is then scaled by the resolution of the timer\n\t\t// this is achieved by setting the PWM to the highest resolution possible and then\n\t\t// setting the PWM value to the desired value right-shifted by res-8\n\t\t// the PWM value is then scaled by the resolution of the timer\n\t\t// the PWM value is then scaled by the resolution of the timer\n\t\t// this is achieved by setting the PWM to the highest resolution possible and", "CodeBleu_score": 23.940592476102555}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == SERVO_CHANNEL_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must be equal to SERVO_CHANNEL_COUNT\");\n\tif (attach(SERVO_CHANNEL_PIN_MAP[servo_channel_])) {\n\t\twrite(value);\n\t\tsafe_delay(SERVO_DELAY_ARRAY[servo_channel_]);\n\t\t#if DEACTIVATE_SERVOS_AFTER_MOVE\n\t\tdetach();\n\t\t#endif\n\t}\n}", "CodeBleu_score": 46.236181314658445}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_COUNT == sizeof(servo_delays) / sizeof(servo_delays[0]), \"Servo delay array length is incorrect\");\n\n\tif (attach(pin)) {\n\t\twrite(value);\n\t\tsafe_delay(servo_delays[pin]);\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n\t\tdetach();\n#endif\n\t}\n}", "CodeBleu_score": 51.40992672080591}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_COUNT == 2, \"The servo delay array length must be 2\");\n\tif (attach(pin)) {\n\t\twrite(value);\n\t\tsafe_delay(delay);\n\t\tTERN_(detach();)\n\t}\n}", "CodeBleu_score": 26.301437377975155}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\t// 16-bit samples\n\tuint32_t sample = i2s_sample_buffer[i2s_sample_buffer_pos];\n\ti2s_sample_buffer_pos++;\n\tif (i2s_sample_buffer_pos >= I2S_SAMPLE_BUFFER_SIZE) {\n\t\ti2s_sample_buffer_pos = 0;\n\t}\n\n\t// 32-bit samples\n\tuint8_t *sample_bytes = (uint8_t *)&sample;\n\n\tuint8_t i;\n\tfor (i = 0; i < I2S_NUM_PINS; i++) {\n\t\t// Check if the pin has active PWM\n\t\tif (i2s_pin_duty_cycle[i] > 0) {\n\t\t\t// Decrement the tick count\n\t\t\ti2s_pin_tick_count[i]--;\n\n\t\t\t// Check if the tick count has reached zero\n\t\t\tif (i2s_pin_tick_count[i] <= 0) {\n\t\t\t\t// Toggle the pin state\n\t\t\t\tif (i2s_pin_state[i]) {\n\t\t\t\t\ti2s_pin_state[i] = 0;\n\t\t\t\t\ti2s_pin_tick_count[i] = i2s_pin_duty_cycle[i];\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pin_state[i] = 1;\n\t\t\t\t\ti2s_pin_tick_count[i] = I2S_DUTY_CYCLE_MAX - i2s_pin_duty_cycle[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update the port data based on the pin state\n\t\tif (i2s_pin_state[i]) {\n\t\t\ti2s_port_data |= (1 << i2s_pin_bit[i]);\n\t\t} else {\n\t\t\ti2s_port_data &= ~(1 << i2s_pin_bit[i]);\n\t\t}\n\t}\n\n\t// Write the updated port data to the DMA buffer\n\tuint16_t *dma_buffer = (uint16_t *)I2S_DMA_BUFFER_ADDRESS;\n\tdma_buffer[i2s_dma_buffer_pos] = i", "CodeBleu_score": 22.993305758418053}, {"code": "void i2s_push_sample(){\n\t\tuint8_t i;\n\tuint8_t *p = (uint8_t *)&dma_buffer[dma_buffer_pos];\n\tuint8_t pin_state = 0;\n\tuint8_t pin_bit = 1;\n\tfor (i = 0; i < NUM_PINS; i++) {\n\t\tif (pin_duty[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pin_tick[i] == 0) {\n\t\t\tif (pin_state & pin_bit) {\n\t\t\t\tpin_state &= ~pin_bit;\n\t\t\t} else {\n\t\t\t\tpin_state |= pin_bit;\n\t\t\t}\n\t\t\tpin_tick[i] = pin_duty[i];\n\t\t}\n\t\tpin_tick[i]--;\n\t\tpin_bit <<= 1;\n\t}\n\t*p = pin_state;\n\tdma_buffer_pos++;\n\tif (dma_buffer_pos >= DMA_BUFFER_SIZE) {\n\t\tdma_buffer_pos = 0;\n\t}\n}", "CodeBleu_score": 27.157937871270928}, {"code": "void i2s_push_sample(){\n\t\tuint32_t data = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 16; i++) {\n\t\tif (i2s_pin_duty_cycle[i] > 0) {\n\t\t\tif (i2s_pin_tick_count[i] == 0) {\n\t\t\t\tif (i2s_pin_state[i] == 0) {\n\t\t\t\t\ti2s_pin_state[i] = 1;\n\t\t\t\t\ti2s_pin_tick_count[i] = i2s_pin_duty_cycle[i];\n\t\t\t\t\tdata |= (1 << i);\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pin_state[i] = 0;\n\t\t\t\t\ti2s_pin_tick_count[i] = i2s_pin_period - i2s_pin_duty_cycle[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ti2s_pin_tick_count[i]--;\n\t\t\t}\n\t\t}\n\t}\n\ti2s_buffer[i2s_buffer_pos] = data;\n\ti2s_buffer_pos++;\n\tif (i2s_buffer_pos >= I2S_BUFFER_SIZE) {\n\t\ti2s_buffer_pos = 0;\n\t}\n}", "CodeBleu_score": 30.549155489026532}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn hal_timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.918582389390089}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer;\n\n\ttimer = timer_num;\n\treturn timer;\n}", "CodeBleu_score": 26.477339596983402}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tuint32_t counter;\n\tcounter = TIMER_GET_COUNT(timer_num);\n\treturn counter;\n}", "CodeBleu_score": 29.161324977069164}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tfor (int i = 0; i < size; i++) {\n\t\tuint8_t data = EEPROM.read(pos);\n\t\tif (writing) {\n\t\t\tvalue[i] = data;\n\t\t}\n\t\tcrc_update(crc, data);\n\t\tpos++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 57.80361610752032}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t byte = read_byte(pos++);\n\t\tif (writing) {\n\t\t\tvalue[i] = byte;\n\t\t}\n\t\tupdate_crc(crc, byte);\n\t}\n\treturn false;\n}", "CodeBleu_score": 59.496849772339466}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\tif (writing) {\n\t\t\tvalue[i] = EEPROM.read(pos);\n\t\t}\n\t\tpos++;\n\t\tif (crc) {\n\t\t\t*crc = _crc16_update(*crc, EEPROM.read(pos - 1));\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 58.1210337738182}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tCORE_ASSERT(src!= NULL);\n\n\t// Try to write the block up to a defined number of times\n\tfor (uint8_t i = 0; i < WITH_RETRY; i++) {\n\t\t// Write the block\n\t\tif (HAL_SD_WriteBlocks(&hsd, (uint8_t *) src, block, 1, 1000) == HAL_OK) {\n\t\t\t// Wait for the block to be written\n\t\t\tif (HAL_SD_CheckWriteOperation(&hsd, 1000) == HAL_OK) {\n\t\t\t\t// The write operation succeeded\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// The write operation failed\n\tSDCARD_Error();\n\treturn false;\n}", "CodeBleu_score": 33.17363275525028}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tCORE_ASSERT(sdcard_handle);\n\tCORE_ASSERT(src);\n\n\tuint32_t retries = SDCARD_WRITE_RETRIES;\n\twhile (retries--) {\n\t\tif (HAL_SD_WriteBlocks(sdcard_handle, (uint8_t *)src, block, 1, SDCARD_TIMEOUT) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tSDCARD_LOG_ERROR(\"failed to write block %d\", block);\n\treturn false;\n}", "CodeBleu_score": 34.250258596466196}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tCORE_ASSERT(sdio_handle);\n\tCORE_ASSERT(src);\n\tbool result = false;\n\tuint32_t retry = 0;\n\twhile (retry++ < SDCARD_RETRY) {\n\t\tif (HAL_SD_WriteBlocks(sdio_handle, (uint8_t*)src, block, 1, 1000) == HAL_OK) {\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!result) {\n\t\tPRINTF(\"SDIO_WriteBlock failed\n\");\n\t}\n\treturn result;\n}", "CodeBleu_score": 34.77673294548586}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_TEMPERATURE) {\n\t\t// Start the temperature timer with the given frequency and temperature timer prescale, and set the callback priority for temperature\n\t\tHAL_timer_start_temperature(frequency);\n\t\tHAL_timer_setCallbackPriority(TIMER_TEMPERATURE, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY);\n\t} else if (timer_num == TIMER_STEPPER) {\n\t\t// Start the step timer with the given frequency and stepper timer prescale, and set the callback priority for stepper\n\t\tHAL_timer_start_stepper(frequency);\n\t\tHAL_timer_setCallbackPriority(TIMER_STEPPER, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY);\n\t} else {\n\t\t// Trigger an assertion failure if the timer channel is invalid\n\t\tCORE_ASSERT_FAIL();\n\t}\n}", "CodeBleu_score": 40.56947012841752}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tCORE_DEBUG_PRINTF\nCORE_ASSERT(timer_num < NUM_TIMERS)\nCORE_DEBUG_PRINTF\ntimer_num->start(frequency)\nCORE_DEBUG_PRINTF\nCORE_ASSERT_FAIL\ntimer_num->setCallbackPriority\nCORE_DEBUG_PRINTF\n}", "CodeBleu_score": 20.96304400244958}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMP_TIMER_NUM) {\n\t\ttimer_config_t config = {\n\t\t\t.divider = 16,\n\t\t\t.counter_dir = TIMER_COUNT_UP,\n\t\t\t.counter_en = TIMER_PAUSE,\n\t\t\t.alarm_en = TIMER_ALARM_EN,\n\t\t\t.intr_type = TIMER_INTR_LEVEL,\n\t\t\t.auto_reload = true\n\t\t};\n\t\ttimer_init(TEMP_TIMER_GROUP, TEMP_TIMER_NUM, &config);\n\t\ttimer_set_counter_value(TEMP_TIMER_GROUP, TEMP_TIMER_NUM, 0x00000000ULL);\n\t\ttimer_set_alarm_value(TEMP_TIMER_GROUP, TEMP_TIMER_NUM, 80000000 / frequency);\n\t\ttimer_enable_intr(TEMP_TIMER_GROUP, TEMP_TIMER_NUM);\n\t\ttimer_isr_register(TEMP_TIMER_GROUP, TEMP_TIMER_NUM, HAL_timer_temp_isr, NULL, ESP_INTR_FLAG_IRAM, &temp_timer_handle);\n\t\ttimer_set_alarm(TEMP_TIMER_GROUP, TEMP_TIMER_NUM, TIMER_ALARM_EN);\n\t\ttimer_start(TEMP_TIMER_GROUP, TEMP_TIMER_NUM);\n\t\tHAL_timer_setCallbackPriority(TEMP_TIMER_NUM, TEMP_TIMER_PRIORITY);\n\t} else if (timer_num == STEP_TIMER_NUM) {\n\t\ttimer_config_t config = {\n\t\t\t.divider = 16,\n\t\t\t.counter_dir = TIMER_COUNT_UP,\n\t\t\t.counter_en = TIMER_PAUSE,\n\t\t\t.alarm_en = TIMER_ALARM_EN,\n\t\t\t.intr_type = TIMER_INTR_LEVEL,\n\t\t\t.auto_reload = true\n\t\t};\n\t\ttimer_init(STEP_TIMER_GROUP, STEP_TIMER_NUM, &config);\n\t\ttimer_set_counter_value(STEP_TIMER_GROUP, STEP_TIMER_NUM, 0x00000000ULL);\n\t\ttimer_set_alarm_value(STEP_TIMER_GROUP, STEP_TIMER_NUM, 80000000 / frequency);\n\t\ttimer_enable_intr(STEP", "CodeBleu_score": 34.44164048524798}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\t// open file for reading\n\tFILE *fp = fopen(filename, \"r+b\");\n\tif (fp == NULL) {\n\t\t// if file does not exist, create it\n\t\tfp = fopen(filename, \"w+b\");\n\t\tif (fp == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\t// fill file with default erase value\n\t\tmemset(buffer, default_erase_value, size);\n\t\t// write file contents\n\t\tfwrite(buffer, sizeof(char), size, fp);\n\t\t// close file\n\t\tfclose(fp);\n\t\t// open file for reading\n\t\tfp = fopen(filename, \"r+b\");\n\t\tif (fp == NULL) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// read file contents into buffer\n\tfread(buffer, sizeof(char), size, fp);\n\t// close file\n\tfclose(fp);\n\treturn true;\n}", "CodeBleu_score": 35.79330206600686}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open EEPROM file for reading and writing\n\tFILE *eeprom_file = fopen(EEPROM_FILE_NAME, \"r+\");\n\n\t// If the file does not exist or cannot be opened, return false\n\tif (eeprom_file == NULL) {\n\t\treturn false;\n\t}\n\n\t// Get the file size\n\tfseek(eeprom_file, 0, SEEK_END);\n\tint file_size = ftell(eeprom_file);\n\n\t// If the file is smaller than the expected EEPROM size, fill the remainder of the buffer with a default erase value\n\tif (file_size < EEPROM_SIZE) {\n\t\tmemset(buffer + file_size, EEPROM_ERASE_VALUE, EEPROM_SIZE - file_size);\n\t}\n\n\t// Read the file's contents into the buffer\n\tfseek(eeprom_file, 0, SEEK_SET);\n\tfread(buffer, 1, EEPROM_SIZE, eeprom_file);\n\n\t// Close the file and return true\n\tfclose(eeprom_file);\n\treturn true;\n}", "CodeBleu_score": 49.47185716006475}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open EEPROM file\n\tFILE *f = fopen(EEPROM_FILE, \"r+\");\n\tif (f == NULL) {\n\t\t// File does not exist or cannot be opened\n\t\treturn false;\n\t}\n\n\t// Check file size\n\tfseek(f, 0, SEEK_END);\n\tsize_t file_size = ftell(f);\n\tif (file_size < EEPROM_SIZE) {\n\t\t// File is smaller than the expected EEPROM size\n\t\t// Fill the remainder of the buffer with a default erase value\n\t\tmemset(buffer + file_size, EEPROM_DEFAULT_ERASE, EEPROM_SIZE - file_size);\n\t}\n\n\t// Read the file's contents into the buffer\n\tfseek(f, 0, SEEK_SET);\n\tfread(buffer, 1, EEPROM_SIZE, f);\n\n\t// Close the file\n\tfclose(f);\n\n\treturn true;\n}", "CodeBleu_score": 41.91115896162144}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i, ret = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80)? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\tret = ret << 1;\n\t\tret |= HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin);\n\t\tb = b << 1;\n\t}\n\tdelaySPIFunc(SPI_DELAY_NS);\n\treturn ret;\n}", "CodeBleu_score": 38.41028789227394}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i, temp;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\ttemp = b & 0x80;\n\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, temp);\n\t\tb <<= 1;\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin)) {\n\t\t\tb |= 0x01;\n\t\t}\n\t}\n\tdelaySPIFunc();\n\treturn b;\n}", "CodeBleu_score": 44.708566414537884}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t r = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin)) {\n\t\t\tr |= 0x80;\n\t\t}\n\t\tb <<= 1;\n\t\tr >>= 1;\n\t}\n\tdelaySPIFunc();\n\treturn r;\n}", "CodeBleu_score": 40.34263179332164}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Read the received byte\n\tuint8_t c = obj->regs->DR;\n\n\t// Check for parity error\n\tif (obj->regs->SR & USART_SR_PE) {\n\t\t// Clear the parity error flag\n\t\tobj->regs->SR &= ~USART_SR_PE;\n\t\treturn;\n\t}\n\n\t// Get the current head pointer\n\tuint16_t head = obj->rx_head;\n\n\t// Calculate the next head pointer\n\tuint16_t next_head = (head + 1) % SERIAL_BUFFER_SIZE;\n\n\t// Check if there is space in the receive buffer\n\tif (next_head!= obj->rx_tail) {\n\t\t// Store the received byte in the receive buffer\n\t\tobj->rx_buffer[head] = c;\n\n\t\t// Update the head pointer\n\t\tobj->rx_head = next_head;\n\n\t\t// Update the emergency parser with the received byte\n\t\temergency_parser.update(c);\n\t}\n}", "CodeBleu_score": 42.772082540082714}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Check if the receive buffer is full\n\tif (rx_buffer_head == ((rx_buffer_tail - 1) & RX_BUFFER_MASK)) {\n\t\t// Set the overflow flag and return\n\t\trx_buffer_overflow = true;\n\t\treturn;\n\t}\n\n\t// Read the byte from the UART\n\tuint8_t byte = uart_getc(obj);\n\n\t// If no parity error occurred, store the byte in the receive buffer\n\tif (!(byte & UART_SR_PE)) {\n\t\trx_buffer[rx_buffer_head] = byte;\n\t\trx_buffer_head = (rx_buffer_head + 1) & RX_BUFFER_MASK;\n\t}\n\n\t// If enabled, update the emergency parser with the received byte\n\tif (emergency_parser_enabled) {\n\t\temergency_parser.update(byte);\n\t}\n}", "CodeBleu_score": 30.09856150185194}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.update(rx_buffer[rx_buffer_head]))\n#endif\n  {\n    // No parity error, read the byte and store it in the receive buffer\n    rx_buffer[rx_buffer_head] = obj->regs->DR;\n    // Calculate the next buffer index and update the head pointer\n    if (++rx_buffer_head >= RX_BUFFER_SIZE) rx_buffer_head = 0;\n  }\n}", "CodeBleu_score": 27.78610066997317}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->hasInterrupt)\n\t\treturn;\n\tif (!timer_instance[timer_num]->initialized)\n\t\treturn;\n\tswitch (timer_num) {\n\tcase MF_TIMER_STEP:\n\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\tbreak;\n\tcase MF_TIMER_TEMP:\n\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 75.38795316165188}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->hasInterrupt) {\n\t\treturn;\n\t}\n\tif (timer_num == MF_TIMER_STEP) {\n\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t}\n}", "CodeBleu_score": 54.0167099958837}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num]->hasInterrupt) {\n\t\treturn;\n\t}\n\tif (!timer_instance[timer_num]->initialized) {\n\t\treturn;\n\t}\n\ttimer_instance[timer_num]->attachInterrupt(timer_instance[timer_num]->interrupt_handler);\n\ttimer_instance[timer_num]->hasInterrupt = true;\n}", "CodeBleu_score": 46.60073696212017}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tn := len(s)\n\tm := len(sep)\n\tif m > n {\n\t\treturn -1\n\t}\n\thashsep := HashStrRev(sep)\n\tvar h uint32\n\tfor i := 0; i < m; i++ {\n\t\th = h*primeRK + uint32(s[n-m+i])\n\t}\n\tif h == hashsep && s[n-m:] == sep {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\th *= primeRK\n\t\th += uint32(s[i])\n\t\th -= primeRK * uint32(s[i+m])\n\t\tif h == hashsep && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 55.165071258878484}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\tsepHash := HashStrRev(sep)\n\tsHash := HashStrRev(s[n-m:])\n\tif sepHash == sHash && s[n-m:] == sep {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\tsHash = (sHash + (sHash << 8) + uint32(s[i]) - (sHash << 8) - uint32(s[i+m])) % primeRK\n\t\tif sepHash == sHash && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 45.150517445364265}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn 0\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\tif m == 1 {\n\t\treturn lastIndexByte(s, sep[0])\n\t}\n\tif n == m {\n\t\tif string(s) == string(sep) {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\t}\n\n\t// Rabin-Karp search\n\thsep := HashStrRev(sep)\n\th := HashStrRev(s[n-m:])\n\tif h == hsep && string(s[n-m:]) == string(sep) {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\th = h * primeRK + uint32(s[i])\n\t\tif h == hsep && string(s[i:i+m]) == string(sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 48.05690126242967}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Count() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 47.88859101080617}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.04282649496233}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Len() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 47.74822518324097}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(i2c.crReg.HasBits(i2c.crReg.Clear | i2c.crReg.Start | i2c.crReg.Enable))\n\tfor!i2c.crReg.HasBits(i2c.crReg.Interrupt) {\n\t}\n\ti2c.writeByte(address<<1 | uint8(!write))\n}", "CodeBleu_score": 38.571267102370854}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag\n\ti2c.crReg.Set(i2c.crReg.HasBits(i2c.crReg.InterruptFlag))\n\t// Send start condition\n\ti2c.crReg.Set(i2c.crReg.HasBits(i2c.crReg.Start))\n\t// Wait for start condition to be transmitted\n\ti2c.waitForInterrupt()\n\t// Send peripheral address\n\ti2c.writeByte(address<<1 | uint8(!write))\n}", "CodeBleu_score": 36.46112661611852}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(i2c.crReg.HasBits(i2c.crReg.ClearFlag, i2c.crReg.Start, i2c.crReg.Enable))\n\tfor!i2c.isrReg.HasBits(i2c.isrReg.StartF) {\n\t}\n\ti2c.txdrReg.Set(uint32(address << 1))\n\tif!write {\n\t\ti2c.txdrReg.Set(i2c.txdrReg.Get() | 0x1)\n\t}\n}", "CodeBleu_score": 32.39478100323505}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// TODO: check for overflow\n\tstartAddress := uintptr(start) * uintptr(f.EraseBlockSize)\n\tfor i := int64(0); i < len; i++ {\n\t\tf.EraseBlock(startAddress + uintptr(i)*uintptr(f.EraseBlockSize))\n\t}\n\treturn nil\n}", "CodeBleu_score": 30.230728759792928}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif len <= 0 {\n\t\treturn nil\n\t}\n\tif start < 0 || start+len > f.EraseBlockSize {\n\t\treturn errors.New(\"invalid block range\")\n\t}\n\taddr := uintptr(f.StartAddress) + uintptr(start*f.EraseBlockSize)\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\tfor i := int64(0); i < len; i++ {\n\t\tnrf.NVMC.ERASEPAGE.Set\n\t\tuint32\n\t\tuintptr\n\t\taddr\n\t\twaitWhileFlashBusy\n\t\taddr += uintptr(f.EraseBlockSize)\n\t}\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\treturn nil\n}", "CodeBleu_score": 42.26207859785487}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"BlockDevice: Invalid start or length\")\n\t}\n\tif start+len > f.NumBlocks {\n\t\treturn errors.New(\"BlockDevice: Invalid start or length\")\n\t}\n\tstartAddr := uintptr(start * f.EraseBlockSize)\n\tfor i := uintptr(0); i < uintptr(len); i++ {\n\t\tnrf.NVMC.SetCONFIG_WEN\n\t\twaitWhileFlashBusy()\n\t\tnrf.NVMC.ERASEPAGE.Set\n\t\tstartAddr += f.EraseBlockSize\n\t\twaitWhileFlashBusy()\n\t}\n\tnrf.NVMC.SetCONFIG_WEN_R\n\treturn nil\n}", "CodeBleu_score": 41.27992147085342}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"write exceeds flash memory bounds\")\n\t}\n\n\tstartAddress := uintptr(f.FlashDataStart + off)\n\tp = f.pad(p)\n\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tfor len(p) > 0 {\n\t\tf.WriteBlockSize(unsafe.Pointer(startAddress), p)\n\t\twaitWhileFlashBusy()\n\t\tstartAddress += f.WriteBlockSize\n\t\tp = p[f.WriteBlockSize:]\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 32.593314693309175}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 || off > FlashDataEnd {\nreturn 0, errors.New(\"flash: write out of bounds\")\n}\nstart := uintptr(FlashDataStart + off)\nif len(p) > f.WriteBlockSize {\np = p[:f.WriteBlockSize]\n}\np = f.pad(p)\nf.SetCONFIG_WEN(true)\nfor len(p) > 0 {\nf.Write32(start, *(*uint32)(unsafe.Pointer(&p[0])))\np = p[4:]\nstart += 4\nwaitWhileFlashBusy()\n}\nreturn len(p), nil\n}", "CodeBleu_score": 30.474320503693285}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off+int64(len(p)) > FlashDataEnd {\n\t\treturn 0, errors.New(\"invalid write range\")\n\t}\n\tstart := uintptr(FlashDataStart) + uintptr(off)\n\tp = f.pad(p)\n\tnrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n\tfor len(p) > 0 {\n\t\t(*uint32)(unsafe.Pointer(start)).Store(binary.LittleEndian.Uint32(p))\n\t\twaitWhileFlashBusy()\n\t\tstart += f.WriteBlockSize\n\t\tp = p[f.WriteBlockSize:]\n\t}\n\treturn len(p), nil\n}", "CodeBleu_score": 35.573315033858925}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdup, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Attempt to open the directory.\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dup)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\t_ = syscall.Close(dup)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 69.53348545865924}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to dup fd: %v\", err)\n\t}\n\n\t// Open the directory using Fdopendir.\n\t// This call may be interrupted by a signal, so retry it.\n\tvar dir *syscall.Dir\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err!= nil {\n\t\tsyscall.Close(dupFd)\n\t\treturn 0, \"\", fmt.Errorf(\"failed to open dir: %v\", err)\n\t}\n\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 54.05145845170058}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tr0, _, e1 := syscall.Syscall(syscall.SYS_DUP, uintptr(fd), 0, 0)\n\tif e1!= 0 {\n\t\treturn 0, \"\", e1\n\t}\n\tdir, err := syscall.Fdopendir(int(r0))\n\tfor err!= nil {\n\t\tif err == syscall.EINTR {\n\t\t\tdir, err = syscall.Fdopendir(int(r0))\n\t\t\tcontinue\n\t\t}\n\t\tsyscall.Close(int(r0))\n\t\treturn 0, \"\", err\n\t}\n\treturn uintptr(r0), \"\", nil\n}", "CodeBleu_score": 47.664847163929835}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running = esp_ota_get_running_partition();\n\tesp_app_desc_t running_app_info;\n\tesp_image_verify(ESP_IMAGE_VERIFY, running, &running_app_info);\n\tif (response == true) {\n\t\treturn running->size - running_app_info.image_len;\n\t} else {\n\t\treturn running_app_info.image_len;\n\t}\n}", "CodeBleu_score": 41.538719741141506}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_FACTORY, NULL);\n\tif (it == NULL) {\n\t\treturn 0;\n\t}\n\tconst esp_partition_t* partition = esp_partition_get(it);\n\tesp_partition_iterator_release(it);\n\tif (partition == NULL) {\n\t\treturn 0;\n\t}\n\n\tesp_app_desc_t app_desc;\n\tif (esp_ota_get_partition_description(partition, &app_desc)!= ESP_OK) {\n\t\treturn 0;\n\t}\n\n\tif (response == SKETCH_SIZE_FREE) {\n\t\treturn partition->size - app_desc.image_len;\n\t} else {\n\t\treturn app_desc.image_len;\n\t}\n}", "CodeBleu_score": 49.17849796204436}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running = esp_ota_get_running_partition();\n\tesp_app_desc_t running_app_info;\n\tif (esp_ota_get_partition_description(running, &running_app_info) == ESP_OK) {\n\t\tif (response) {\n\t\t\treturn running->size - running_app_info.image_len;\n\t\t} else {\n\t\t\treturn running_app_info.image_len;\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 46.66979605636582}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t required_disk_sectors;\n\tuint8_t *disk_memory;\n\tbool result = false;\n\n\t/* Calculate the required disk sectors. */\n\trequired_disk_sectors = msc_update_get_required_disk_sectors(volume_label, serial_number);\n\tif (required_disk_sectors == 0) {\n\t\tlog_e(\"Failed to calculate required disk sectors.\");\n\t\tgoto exit;\n\t}\n\n\t/* Allocate memory for the RAM disk. */\n\tdisk_memory = calloc(required_disk_sectors, SECTOR_SIZE);\n\tif (disk_memory == NULL) {\n\t\tlog_e(\"Failed to allocate memory for the RAM disk.\");\n\t\tgoto exit;\n\t}\n\n\t/* Set up the boot sector and file allocation table (FAT). */\n\tif (!fat_add_boot_sector(disk_memory, volume_label, serial_number)) {\n\t\tlog_e(\"Failed to set up the boot sector.\");\n\t\tgoto free_disk_memory;\n\t}\n\tif (!fat_add_table(disk_memory, required_disk_sectors)) {\n\t\tlog_e(\"Failed to set up the FAT.\");\n\t\tgoto free_disk_memory;\n\t}\n\n\t/* Add a root directory entry for a firmware file if a partition is running. */\n\tif (partition_get_running()!= NULL) {\n\t\tif (!fat_add_root_file(disk_memory, required_disk_sectors, volume_label, serial_number)) {\n\t\t\tlog_e(\"Failed to add a root directory entry for a firmware file.\");\n\t\t\tgoto free_disk_memory;\n\t\t}\n\t}\n\n\t/* Set up the MSC device. */\n\tmsc_update_init(disk_memory, required_disk_sectors);\n\n\tresult = true;\n\nfree_disk_memory:\n\tfree(disk_memory);\nexit:\n\treturn result;\n}", "CodeBleu_score": 32.60906383071042}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t disk_sectors = msc_update_get_required_disk_sectors(volume_label, serial_number);\n\tif (disk_sectors == 0) {\n\t\tlog_e(\"Failed to calculate required disk sectors.\");\n\t\treturn false;\n\t}\n\tmsc_update_disk = calloc(disk_sectors, SECTOR_SIZE);\n\tif (msc_update_disk == NULL) {\n\t\tlog_e(\"Failed to allocate memory for disk sectors.\");\n\t\treturn false;\n\t}\n\tmsc_update_disk_sectors = disk_sectors;\n\tif (!fat_add_boot_sector(volume_label, serial_number)) {\n\t\tlog_e(\"Failed to add boot sector.\");\n\t\treturn false;\n\t}\n\tif (!fat_add_table()) {\n\t\tlog_e(\"Failed to add FAT.\");\n\t\treturn false;\n\t}\n\tif (msc_update_partition_running &&!fat_add_root_file(msc_update_partition_running)) {\n\t\tlog_e(\"Failed to add root file.\");\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 35.171735934052215}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t disk_sectors;\n\tuint8_t *disk_buffer;\n\n\tdisk_sectors = msc_update_get_required_disk_sectors(volume_label, serial_number);\n\tif (disk_sectors == 0) {\n\t\tlog_e(\"Failed to calculate required disk sectors\");\n\t\treturn false;\n\t}\n\n\tdisk_buffer = calloc(disk_sectors, SECTOR_SIZE);\n\tif (disk_buffer == NULL) {\n\t\tlog_e(\"Failed to allocate memory for disk buffer\");\n\t\treturn false;\n\t}\n\n\tif (!fat_add_boot_sector(disk_buffer, disk_sectors, volume_label, serial_number)) {\n\t\tlog_e(\"Failed to add boot sector\");\n\t\tfree(disk_buffer);\n\t\treturn false;\n\t}\n\n\tif (!fat_add_table(disk_buffer, disk_sectors)) {\n\t\tlog_e(\"Failed to add table\");\n\t\tfree(disk_buffer);\n\t\treturn false;\n\t}\n\n\tif (partition_is_running()) {\n\t\tif (!fat_add_root_file(disk_buffer, disk_sectors)) {\n\t\t\tlog_e(\"Failed to add root file\");\n\t\t\tfree(disk_buffer);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tmsc_update_set_disk(disk_buffer, disk_sectors);\n\treturn true;\n}", "CodeBleu_score": 32.95397487259088}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tESP_LOGV(TAG, \"msc_update_write\");\n\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"offset is not aligned with sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"failed to erase partition\");\n\t\treturn err;\n\t}\n\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 52.25171448354976}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tif (offset % ESP_PARTITION_ALIGN) {\n\t\tESP_LOGE(TAG, \"offset %d is not aligned with flash sector size\", offset);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\terr = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"failed to erase partition, error=%d\", err);\n\t\treturn err;\n\t}\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 56.5990673852879}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"Offset is not aligned with sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase flash partition\");\n\t\treturn err;\n\t}\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 52.051753088070065}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\tsize_t j = 0;\n\twhile (in[i] && j < maxlen) {\n\t\tout[j] = hex_char_to_byte(in[i]);\n\t\tif (out[j] == 0xFF) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t\tout[j] <<= 4;\n\t\tout[j] |= hex_char_to_byte(in[i]);\n\t\tif (out[j] == 0xFF) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\treturn j;\n}", "CodeBleu_score": 38.12830637568452}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i, j;\n\tfor (i = 0, j = 0; j < maxlen && in[i]; i++) {\n\t\tint c = hex_char_to_byte(in[i]);\n\t\tif (c < 0)\n\t\t\tcontinue;\n\t\tif (i & 1) {\n\t\t\tout[j++] |= c;\n\t\t} else {\n\t\t\tout[j] = (unsigned char) (c << 4);\n\t\t}\n\t}\n\treturn j;\n}", "CodeBleu_score": 39.35165135956941}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t outlen = 0;\n\twhile (outlen < maxlen && *in) {\n\t\tunsigned char c = hex_char_to_byte(in);\n\t\tif (c!= 0xff) {\n\t\t\tout[outlen++] = c;\n\t\t}\n\t\tin++;\n\t}\n\treturn outlen;\n}", "CodeBleu_score": 33.62980751094751}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_buffer == NULL) return 0;\n\tif (xSemaphoreTake(tx_lock, 100) == pdTRUE) {\n\t\tint free = xRingbufferGetCurFreeSize(tx_buffer);\n\t\txSemaphoreGive(tx_lock);\n\t\treturn free;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 49.7261199108774}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (xRingBuffer == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(xRingBufferLock, 1000) == pdTRUE) {\n\t\tsize_t freeSize = xRingbufferGetCurFreeSize(xRingBuffer);\n\t\txSemaphoreGive(xRingBufferLock);\n\t\treturn freeSize;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 56.08688545628677}, {"code": "int HWCDC::availableForWrite(void){\n\t\tint freeSize = 0;\n\tif (txRingBuffer!= NULL && txRingBufferLock!= NULL) {\n\t\tif (xSemaphoreTake(txRingBufferLock, 1000 / portTICK_PERIOD_MS) == pdTRUE) {\n\t\t\tfreeSize = xRingbufferGetCurFreeSize(txRingBuffer);\n\t\t\txSemaphoreGive(txRingBufferLock);\n\t\t}\n\t}\n\treturn freeSize;\n}", "CodeBleu_score": 47.88249412259661}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\tif (_onReceiveCB) {\n\t\tif (onlyOnTimeout) {\n\t\t\t_rxTimeout = 0;\n\t\t} else {\n\t\t\t_rxTimeout = 1;\n\t\t}\n\t\tuartSetRxFIFOFull(uart, 1);\n\t\tif (!_rxEventTask) {\n\t\t\t_rxEventTask = _createEventTask();\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 42.71692276035102}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\tif (_onReceiveCB) {\n\t\tif (onlyOnTimeout) {\n\t\t\t// Only trigger on timeout\n\t\t\tuartSetRxTimeout(_uart, _rxTimeout);\n\t\t} else {\n\t\t\t// Trigger on timeout or when FIFO is full\n\t\t\tuartSetRxTimeout(_uart, 0);\n\t\t\tuartSetRxFIFOFull(_uart, 1);\n\t\t}\n\t\tif (!_eventTask) {\n\t\t\t_eventTask = _createEventTask();\n\t\t}\n\t} else {\n\t\tuartSetRxTimeout(_uart, 0);\n\t\tuartSetRxFIFOFull(_uart, 0);\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 45.730239308734404}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\tif (_onReceiveCB) {\n\t\t_rxTimeout = 1000;\n\t\t_rxTimeoutOnly = onlyOnTimeout;\n\t\tuartSetRxFIFOFull(uart, 1);\n\t\tif (!_eventTask) {\n\t\t\t_createEventTask();\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 33.27874868034804}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\tunsigned long startMillis = millis();\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 && millis() - startMillis >= _timeout) return index;\n\t\tif (c == terminator || c < 0) break;\n\t\tbuffer[index++] = (char)c;\n\t}\n\tbuffer[index] = '\\0';\n\treturn index;\n}", "CodeBleu_score": 63.340561974106215}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) break;\n\t\t*buffer++ = (char)c;\n\t\tindex++;\n\t}\n\treturn index;\n}", "CodeBleu_score": 76.20201251609464}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) break;\n\t\t*buffer++ = (char)c;\n\t\tindex++;\n\t}\n\treturn index; // return number of characters, not including null terminator\n}", "CodeBleu_score": 82.83064686881703}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"Tone on pin %d with frequency %d for %d ms\", pin, frequency, duration);\n\n\tif (pin == 1) {\n\t\tif (tone_pin_1_status == 0) {\n\t\t\ttone_pin_1_status = 1;\n\t\t\ttone_init(pin, frequency, duration);\n\t\t\txQueueSend(tone_queue, &tone_start_1, 0);\n\t\t} else {\n\t\t\tlog_e(\"Tone on pin 1 is already in use. Please stop it first.\");\n\t\t}\n\t} else if (pin == 2) {\n\t\tif (tone_pin_2_status == 0) {\n\t\t\ttone_pin_2_status = 1;\n\t\t\ttone_init(pin, frequency, duration);\n\t\t\txQueueSend(tone_queue, &tone_start_2, 0);\n\t\t} else {\n\t\t\tlog_e(\"Tone on pin 2 is already in use. Please stop it first.\");\n\t\t}\n\t} else if (pin == 3) {\n\t\tif (tone_pin_3_status == 0) {\n\t\t\ttone_pin_3_status = 1;\n\t\t\ttone_init(pin, frequency, duration);\n\t\t\txQueueSend(tone_queue, &tone_start_3, 0);\n\t\t} else {\n\t\t\tlog_e(\"Tone on pin 3 is already in use. Please stop it first.\");\n\t\t}\n\t} else if (pin == 4) {\n\t\tif (tone_pin_4_status == 0) {\n\t\t\ttone_pin_4_status = 1;\n\t\t\ttone_init(pin, frequency, duration);\n\t\t\txQueueSend(tone_queue, &tone_start_4, 0);\n\t\t} else {\n\t\t\tlog_e(\"Tone on pin 4 is already in use. Please stop it first.\");\n\t\t}\n\t} else {\n\t\tlog_e(\"Tone on pin %d is not supported.\", pin);\n\t}\n}", "CodeBleu_score": 39.48046534862751}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_d(\"Tone: pin=%d, frequency=%d, duration=%d\", pin, frequency, duration);\n\tif (tone_pin_available(pin)) {\n\t\ttone_init(pin);\n\t\ttone_start(pin, frequency, duration);\n\t} else {\n\t\tlog_e(\"Tone: pin %d is already in use\", pin);\n\t}\n}", "CodeBleu_score": 28.426333635352986}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_i(\"Tone on pin %d with frequency %d and duration %d\", pin, frequency, duration);\n\tif (tone_pin_available(pin)) {\n\t\ttone_init();\n\t\txQueueSend(tone_queue, &tone_cmd_start, 0);\n\t\ttone_pin_set(pin);\n\t\ttone_cmd_start.pin = pin;\n\t\ttone_cmd_start.frequency = frequency;\n\t\ttone_cmd_start.duration = duration;\n\t} else {\n\t\tlog_e(\"Pin %d already in use\", pin);\n\t}\n}", "CodeBleu_score": 42.901011286591185}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (started) {\n\t\tif (enabled) {\n\t\t\tif (usb_version < 0x0210) {\n\t\t\t\tusb_version = 0x0210;\n\t\t\t}\n\t\t\tusb_webusb = true;\n\t\t} else {\n\t\t\tusb_webusb = false;\n\t\t}\n\t\treturn false;\n\t}\n\tif (enabled) {\n\t\tif (usb_version < 0x0210) {\n\t\t\tusb_version = 0x0210;\n\t\t}\n\t\tusb_webusb = true;\n\t} else {\n\t\tusb_webusb = false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 50.27611030576165}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (started) {\n\t\treturn false;\n\t}\n\twebusb = enabled;\n\tif (enabled && usb_version < 0x0210) {\n\t\tusb_version = 0x0210;\n\t}\n\treturn true;\n}", "CodeBleu_score": 64.46317440653006}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usbStarted) {\n\t\treturn false;\n\t}\n\twebUSBEnabled = enabled;\n\tif (enabled) {\n\t\tusbVersion = 0x0210;\n\t}\n\treturn true;\n}", "CodeBleu_score": 34.6509104207332}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t buf[64];\n\tuint32_t len = tud_cdc_n_read(0, buf, sizeof(buf));\n\n\tif (len) {\n\t\tfor (uint32_t i = 0; i < len; i++) {\n\t\t\tif (xQueueSend(m_rxQueue, &buf[i], 0)!= pdTRUE) {\n\t\t\t\tm_overflows++;\n\t\t\t\tm_overflows_total++;\n\t\t\t\tif (m_overflows_total > 10000) {\n\t\t\t\t\tm_overflows_total = 0;\n\t\t\t\t}\n\t\t\t\tif (m_overflows_total % 100 == 0) {\n\t\t\t\t\tLOG_ERROR(\"CDC RX overflow: %d\", m_overflows_total);\n\t\t\t\t}\n\t\t\t\tif (m_overflows > 100) {\n\t\t\t\t\tm_overflows = 0;\n\t\t\t\t\tm_overflows_total = 0;\n\t\t\t\t\tLOG_ERROR(\"CDC RX overflow: %d\", m_overflows_total);\n\t\t\t\t\tusbcdc_event_post(USBCDC_EVENT_RX_OVERFLOW, m_overflows_total);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusbcdc_event_post(USBCDC_EVENT_RX, len);\n\t}\n}", "CodeBleu_score": 35.93700182850954}, {"code": "void USBCDC::_onRX(){\n\t\t// read data into buffer\n\tuint8_t buf[64];\n\tuint32_t count = tud_cdc_n_read(0, buf, sizeof(buf));\n\t// attempt to send each byte to queue\n\tfor (uint32_t i = 0; i < count; i++) {\n\t\t// attempt to send byte to queue\n\t\tif (xQueueSend(rx_queue, &buf[i], 0)!= pdTRUE) {\n\t\t\t// if queue is full, post overflow event\n\t\t\toverflow_event_post(count - i);\n\t\t\t// log error\n\t\t\tlog_e(\"USBCDC::_onRX: RX queue full\");\n\t\t\t// exit loop\n\t\t\tbreak;\n\t\t}\n\t}\n\t// post receive event\n\treceive_event_post(count);\n}", "CodeBleu_score": 23.584003058255536}, {"code": "void USBCDC::_onRX(){\n\t\t// read data into buffer\n\tint len = tud_cdc_n_read(0, _rx_buf, sizeof(_rx_buf));\n\t// send data to queue\n\tfor (int i = 0; i < len; i++) {\n\t\tif (xQueueSend(_rx_queue, &_rx_buf[i], 0)!= pdTRUE) {\n\t\t\t_rx_overflow++;\n\t\t\tlog_e(\"RX overflow: %d\", _rx_overflow);\n\t\t\tif (_rx_overflow > 100) {\n\t\t\t\tlog_e(\"RX overflow: %d\", _rx_overflow);\n\t\t\t\t_rx_overflow = 0;\n\t\t\t}\n\t\t}\n\t}\n\t// post event\n\tif (len > 0) {\n\t\txQueueSend(_rx_queue, &len, 0);\n\t\tarduino_usb_event_post(USB_CDC_RX, len);\n\t}\n}", "CodeBleu_score": 29.11520565376804}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\ta.writeJSON(res, http.StatusBadRequest, map[string]string{\"error\": \"missing name parameter\"})\n\t\treturn\n\t}\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name: \" + name})\n\t\treturn\n\t}\n\tdevices := make([]map[string]interface{}, 0)\n\trobot.Devices().Each(func(d gobot.Device) {\n\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\"name\": d.Name(),\n\t\t\t\"type\": d.Connection().Type(),\n\t\t})\n\t})\n\ta.writeJSON(res, http.StatusOK, map[string]interface{}{\n\t\t\"name\":    robot.Name(),\n\t\t\"devices\": devices,\n\t})\n}", "CodeBleu_score": 50.587995061268586}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name \" + robotName})\n\t\treturn\n\t}\n\tdevices := make([]map[string]interface{}, 0)\n\trobot.Devices().Each(func(device interfaces.Device) {\n\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\"name\":    device.Name(),\n\t\t\t\"type\":    device.Type(),\n\t\t\t\"version\": device.Version(),\n\t\t})\n\t})\n\ta.writeJSON(res, http.StatusOK, map[string]interface{}{\n\t\t\"name\":    robot.Name(),\n\t\t\"version\": robot.Version(),\n\t\t\"devices\": devices,\n\t})\n}", "CodeBleu_score": 51.428589178300044}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := gobot.URLParam(req, \"name\")\n\tif name == \"\" {\n\t\ta.writeJSON(res, http.StatusBadRequest, map[string]string{\"error\": \"missing name\"})\n\t\treturn\n\t}\n\tif robot := a.master.Robot(name); robot!= nil {\n\t\tdevices := make([]map[string]interface{}, len(robot.Devices()))\n\t\ti := 0\n\t\trobot.Devices().Each(func(d gobot.Device) {\n\t\t\tdevices[i] = map[string]interface{}{\n\t\t\t\t\"name\": d.Name(),\n\t\t\t\t\"type\": d.Connection().Type(),\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ta.writeJSON(res, http.StatusOK, map[string]interface{}{\n\t\t\t\"name\":    robot.Name(),\n\t\t\t\"devices\": devices,\n\t\t})\n\t} else {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name \" + name})\n\t}\n}", "CodeBleu_score": 48.82900408016287}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]string{\"error\": \"no robot with name '\" + robotName + \"' found\"})\n\t\treturn\n\t}\n\tvar connections []map[string]interface{}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, c.Connection())\n\t})\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 54.47962318605214}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot named '%s' was found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tvar connections []interface{}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, c.Connection())\n\t})\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 50.98239274359887}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"No robot with name '%s' was found\", robotName)))\n\t\treturn\n\t}\n\n\tvar connections []map[string]interface{}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\":    c.Name(),\n\t\t\t\"type\":    c.Type(),\n\t\t\t\"adaptor\": c.Connection(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 53.31755019356126}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"Device not found\"})\n\t\treturn\n\t}\n\tif commander, ok := device.(gobot.Commander); ok {\n\t\tcommander.Command(req.URL.Query().Get(\":command\"))\n\t}\n\ta.writeJSON(res, http.StatusOK, map[string]string{\"status\": \"success\"})\n}", "CodeBleu_score": 51.360541846574634}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"device not found\"})\n\t\treturn\n\t}\n\n\terr := device.(gobot.Commander).Command(req.URL.Query().Get(\":command\"))\n\tif err!= nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\ta.writeJSON(res, http.StatusOK, a.jsonDeviceFor(device))\n}", "CodeBleu_score": 53.503876118442605}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"device not found\"})\n\t\treturn\n\t}\n\tif commander, ok := device.(gobot.Commander); ok {\n\t\tif err := commander.Command(req.URL.Query().Get(\":command\")); err!= nil {\n\t\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\t}\n\ta.writeJSON(res, http.StatusOK, map[string]string{\"message\": \"command executed\"})\n}", "CodeBleu_score": 52.17595292560551}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\tauth := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\")!= auth {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\"`)\n\t\t\thttp.Error(w, \"unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 61.625038271150714}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\tauth := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\")!= auth {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 61.9052374990587}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || user!= username || password!= pass {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 54.34132077615812}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.Connection().(gobot.AnalogReader).AnalogRead(a.Pin()) {\n\t\treturn 0, 0, errors.New(\"AnalogSensorDriver: Could not read from sensor\")\n\t}\n\n\traw := a.Connection().(gobot.AnalogReader).AnalogRead(a.Pin())\n\tscaled := float64(raw) * a.sensorCfg.scale\n\n\ta.sensorCfg.lastReadRaw = raw\n\ta.sensorCfg.lastReadScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 36.75568073731899}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif!a.Connection().Supports(gobot.AnalogReader) {\n\t\treturn 0, 0.0, errors.New(\"AnalogSensorDriver does not support AnalogReader\")\n\t}\n\tval, err := a.Connection().AnalogRead(a.Pin())\n\tif err!= nil {\n\t\treturn 0, 0.0, err\n\t}\n\tscaled := a.scale(val)\n\ta.lastVal = val\n\ta.lastValScaled = scaled\n\treturn val, scaled, nil\n}", "CodeBleu_score": 43.66640514847629}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif!a.Connection().Supports(gobot.AnalogReader) {\n\t\treturn 0, 0, errors.New(\"AnalogSensorDriver does not support AnalogReader\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) / a.sensorCfg.scale\n\n\ta.lastRawValue = raw\n\ta.lastValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.37737751125301}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n}", "CodeBleu_score": 35.85271778311411}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tgobot.ValidateFritz(a)\n\n\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\tg.SetName(gobot.DefaultName(\"GroveSoundSensor\"))\n\n\treturn g\n}", "CodeBleu_score": 47.299992088988155}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n}", "CodeBleu_score": 35.85271778311411}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.writeByteData(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := d.", "CodeBleu_score": 47.64439073807393}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Perform a soft reset on the MFRC522 device.\n\td.writeByteData(CommandReg, PCD_RESETPHASE)\n\t// Wait for the initialization to complete.\n\ttime.Sleep(500 * time.Microsecond)\n\t// Check the status of the power-down bit.\n\tstatus := d.readByteData(CommandReg)\n\tif status&0x10!= 0 {\n\t\treturn fmt.Errorf(\"MFRC522: Soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 30.306071953144663}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Perform a soft reset on the MFRC522 chip\n\td.writeByteData(CommandReg, PCD_RESETPHASE)\n\t// Wait for the chip to be ready again\n\ttime.Sleep(100 * time.Millisecond)\n\t// Check if the chip is ready\n\tif d.readByteData(CommandReg)&PCD_RESETPHASE!= 0 {\n\t\treturn fmt.Errorf(\"MFRC522 soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 27.415342157687274}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) == 0 {\n\t\treturn 0, fmt.Errorf(\"No data to read\")\n\t}\n\n\tfifoLevel := d.readRegister(fifoLevelReg)\n\tif fifoLevel < uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"Not enough data in FIFO\")\n\t}\n\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i] = d.readRegister(fifoDataReg)\n\t}\n\n\treturn d.readRegister(fifoLevelReg), nil\n}", "CodeBleu_score": 32.39807484881371}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) == 0 {\n\t\treturn 0, errors.New(\"empty backData slice\")\n\t}\n\n\tn, err := d.readFifoLevel()\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif n!= len(backData) {\n\t\treturn 0, fmt.Errorf(\"unexpected number of bytes in FIFO: %d\", n)\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i], err = d.readByteData(d.FIFODataReg)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tlastBits, err := d.readControlReg(d.ControlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tlastBits = lastBits & 0x07\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 44.96226086646288}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) == 0 {\n\t\treturn 0, nil\n\t}\n\tn, err := d.readRegister(FIFOLevelReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif n!= uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"readFifo: expected %d bytes, got %d\", len(backData), n)\n\t}\n\tfor i := range backData {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tlastBits, err := d.readRegister(ControlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tlastBits &= 0x07\n\treturn lastBits, nil\n}", "CodeBleu_score": 46.85171072864114}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"piccHalt\")\n\t}\n\tcmd := []byte{piccCmdHaltA, piccCmdHaltB}\n\td.calculateCRC(cmd)\n\terr := d.communicateWithPICC(cmd)\n\tif err!= nil {\n\t\treturn fmt.Errorf(\"piccHalt: %w\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 24.68518843315869}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Printf(\"piccHalt: Halting communication with PICC\")\n\t}\n\n\thaltCmd := []byte{PICC_CMD_HALT_A}\n\td.calculateCRC(haltCmd)\n\terr := d.communicateWithPICC(PICC_CMD_HALT_A, haltCmd)\n\tif err!= nil {\n\t\treturn fmt.Errorf(\"piccHalt: %v\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 23.502748157711192}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Printf(\"piccHalt\")\n\t}\n\tcmd := []byte{PICC_CMD_HALT}\n\td.calculateCRC(cmd)\n\t_, err := d.communicateWithPICC(cmd, true)\n\tif err!= nil {\n\t\treturn fmt.Errorf(\"piccHalt: %v\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 22.359924663523223}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build command buffer\n\tcmd := []byte{PICC_CMD_MF_READ}\n\tcmd = append(cmd, block)\n\t// Calculate CRC_A\n\tcrc, err := d.calculateCRC(cmd)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Append CRC_A\n\tcmd = append(cmd, crc[0])\n\tcmd = append(cmd, crc[1])\n\t// Transmit the buffer and receive the response, validate CRC_A.\n\tif err := d.communicateWithPICC(cmd, 16); err!= nil {\n\t\treturn nil, err\n\t}\n\t// Copy the received data\n\tdata := make([]byte, 16)\n\tcopy(data, d.buffer[0:16])\n\treturn data, nil\n}", "CodeBleu_score": 42.39314731259004}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif block > 63 {\n\t\treturn nil, fmt.Errorf(\"invalid block number\")\n\t}\n\n\t// Build command buffer\n\tsendBuf := make([]byte, 6)\n\tsendBuf[0] = d.piccReadCmd\n\tsendBuf[1] = block\n\n\t// Calculate CRC\n\tcrc := d.calculateCRC(sendBuf)\n\tsendBuf = append(sendBuf, crc...)\n\n\t// Send command\n\tresp, err := d.communicateWithPICC(sendBuf)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check response\n\tif len(resp) < 2 {\n\t\treturn nil, fmt.Errorf(\"invalid response length\")\n\t}\n\tif resp[len(resp)-2]!= d.statusOk {\n\t\treturn nil, fmt.Errorf(\"invalid status\")\n\t}\n\n\t// Return data\n\treturn resp[len(resp)-16 : len(resp)-2], nil\n}", "CodeBleu_score": 38.189275366721034}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build command buffer\n\tcmd := make([]byte, 3)\n\tcmd[0] = PICC_CMD_MF_READ\n\tcmd[1] = block\n\td.calculateCRC(cmd)\n\n\t// Transmit the buffer and receive the response, validate CRC\n\tif _, err := d.communicateWithPICC(cmd, true); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the response data\n\tresp, err := d.communicateWithPICC(nil, false)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the response is valid\n\tif len(resp) < 16 {\n\t\treturn nil, fmt.Errorf(\"invalid response length: %d\", len(resp))\n\t}\n\n\t// Check if the CRC is valid\n\tif!d.checkCRC(resp[len(resp)-2:]) {\n\t\treturn nil, errors.New(\"invalid CRC in response\")\n\t}\n\n\t// Return the data\n\treturn resp[:len(resp)-2], nil\n}", "CodeBleu_score": 34.58844970314542}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\td.clearRegisterBitMask(MFRC522_CollReg, 0x80)\n\tif reqMode == MFRC522_PICC_REQIDL {\n\t\treturn d.communicateWithPICC(MFRC522_Transceive, []byte{reqMode}, answer)\n\t} else {\n\t\treturn d.communicateWithPICC(MFRC522_Transceive, []byte{reqMode, 0x20}, answer)\n\t}\n}", "CodeBleu_score": 31.051858607377763}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Valid values for the request mode are 0x26, 0x04, 0x07, 0x0A and 0x0D\n\t// We use the request mode 0x26 (0b00100110) for the MFRC522\n\t// The request mode 0x07 (0b00000111) is used for the PICC15693\n\t// The request mode 0x0A (0b00001010) is used for the PICC15693\n\t// The request mode 0x0D (0b00001101) is used for the PICC15693\n\t// The request mode 0x04 (0b00000100) is used for the PICC15693\n\t// The request mode 0x06 (0b00000110) is used for the PICC15693\n\t// The request mode 0x26 (0b00100110) is used for the MFRC522\n\t// The request mode 0x08 (0b00001000) is used for the PICC15693\n\t// The request mode 0x0C (0b00001100) is used for the PICC15693\n\t// The request mode 0x20 (0b00100000) is used for the MFRC522\n\t// The request mode 0x24 (0b00100100) is used for the MFRC522\n\t// The request mode 0x28 (0b00101000) is used for the MFRC522\n\t// The request mode 0x2C (0b00101100) is used for the MFRC522\n\t// The request", "CodeBleu_score": 12.985268184407737}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Clear the collision register\n\td.clearRegisterBitMask(MFRC522_CollReg, 0x80)\n\n\t// Set the request mode\n\tanswer[0] = reqMode\n\n\t// Set the length of the request\n\tanswer[1] = 0x00\n\n\t// Transmit the request\n\terr := d.communicateWithPICC(PCD_Transceive, answer, 2, answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check if the request was accepted\n\tif answer[0]!= reqMode {\n\t\treturn fmt.Errorf(\"PICC did not accept the request\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 49.20796195854727}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif err := d.digitalWrite(d.stepPin, 0); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\tif err := d.digitalWrite(d.stepPin, 1); err!= nil {\n\t\treturn err\n\t}\n\tif d.direction == 1 {\n\t\td.step++\n\t} else {\n\t\td.step--\n\t}\n\treturn nil\n}", "CodeBleu_score": 76.06151396714318}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\ttime.Sleep(d.getDelayPerStep())\n\tif err := d.digitalWrite(d.stepPin, false); err!= nil {\n\t\treturn err\n\t}\n\tif d.direction {\n\t\td.step++\n\t} else {\n\t\td.step--\n\t}\n\tif err := d.digitalWrite(d.stepPin, true); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 67.12614812324982}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\terr := d.digitalWrite(d.stepPin, false)\n\tif err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, true)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif d.direction {\n\t\td.step++\n\t} else {\n\t\td.step--\n\t}\n\treturn nil\n}", "CodeBleu_score": 66.0270778561141}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 60.62337722982243}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 66.27607464871225}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorStopChan!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = new(sync.WaitGroup)\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err!= nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 60.64446235946489}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Duration(0)\n\treturn func(pin int, timestamp time.Duration, state string, value uint32, timestampDelta uint32) {\n\t\tif state == \"rising\" {\n\t\t\tstartTimestamp = timestamp\n\t\t} else if state == \"falling\" {\n\t\t\tduration := timestamp - startTimestamp\n\t\t\td.durationChan <- duration\n\t\t\tstartTimestamp = time.Duration(0)\n\t\t}\n\t}\n}", "CodeBleu_score": 44.661041913430196}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Duration\n\treturn func(pin int, duration time.Duration, state string, timestamp uint32, tick uint32) {\n\t\tif state == \"rising\" {\n\t\t\tstartTimestamp = duration\n\t\t} else if state == \"falling\" {\n\t\t\td.pulseDuration <- calculateDuration(startTimestamp, duration)\n\t\t\tstartTimestamp = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 42.80309169258864}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Duration(0)\n\treturn func(pin int, timestamp time.Duration, event string, value uint32, timestampDelta uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstartTimestamp = timestamp\n\t\t} else if event == \"falling\" {\n\t\t\td.durationChannel <- calculateDuration(startTimestamp, timestamp)\n\t\t\tstartTimestamp = time.Duration(0)\n\t\t}\n\t}\n}", "CodeBleu_score": 46.46888771996794}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access.\n\td.measureMutex.Lock()\n\t// Trigger the sensor.\n\tif err := d.trigger(); err!= nil {\n\t\treturn err\n\t}\n\t// Wait for the measurement to complete or for a timeout to occur.\n\tselect {\n\tcase <-d.measureTrigger:\n\t\t// The measurement is complete.\n\t\t// Unlock the measurement mutex.\n\t\td.measureMutex.Unlock()\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// A timeout occurred.\n\t\t// Unlock the measurement mutex.\n\t\td.measureMutex.Unlock()\n\t\treturn fmt.Errorf(\"HCSR04Driver: timeout measuring distance\")\n\t}\n}", "CodeBleu_score": 46.162830182967106}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\tif err := d.emitTrigger(); err!= nil {\n\t\treturn err\n\t}\n\tif err := d.waitEcho(); err!= nil {\n\t\treturn err\n\t}\n\td.measuredTime = time.Now()\n\treturn nil\n}", "CodeBleu_score": 50.83175813144114}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\tif err := d.emitTrigger(); err!= nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase <-d.measureChan:\n\t\td.measuredTime = time.Since(d.measureStart)\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout measuring distance\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 54.950018788718324}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if not self.token:\n        if self.get_state_item(\"token\") and self.get_state_item(\"token_expires_at\") and self.get_state_item(\"token_expires_at\") > time.time():\n            self.token = self.get_state_item(\"token\")\n            self.token_expires_at = self.get_state_item(\"token_expires_at\")\n        elif self.get_state_item(\"refresh_token\"):\n            self.refresh_authentication_token()\n        else:\n            raise AccountNotAuthorized(\n                \"Please authorize the application to access your account.\"\n            )\n    return self.token\n\n", "CodeBleu_score": 27.679548051036274}, {"code": "def fetch_authentication_token(self)\n\t\n    auth_token = os.environ.get(\"AUTH_TOKEN\")\n    if not auth_token:\n        auth_token = self.get_local_session(\"auth_token\")\n        auth_token_expires = self.get_local_session(\"auth_token_expires\")\n        if auth_token and auth_token_expires and auth_token_expires > time.time():\n            return auth_token\n        refresh_token = self.get_local_session(\"refresh_token\")\n        if refresh_token:\n            auth_token = self.fetch_new_authentication_token(refresh_token)\n            self.set_local_session(\"auth_token\", auth_token)\n            self.set_local_session(\"auth_token_expires\", time.time() + 3600)\n            return auth_token\n    raise AccountNotAuthorized(\"Authentication token not available.\")\n", "CodeBleu_score": 34.35674340663811}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get(\"TOKEN\")\n    if token:\n        return token\n    else:\n        state = app.get_state_item(\"auth\")\n        if state:\n            if state[\"expires_at\"] > time.time():\n                return state[\"access_token\"]\n            elif state.get(\"refresh_token\"):\n                data = self.refresh_authentication_token(state[\"refresh_token\"])\n                if data:\n                    app.set_state_item(\"auth\", data)\n                    return data[\"access_token\"]\n        raise AccountNotAuthorized(\"Account not authorized. Please login again.\")\n\n", "CodeBleu_score": 36.38559203027045}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\n            \"POST\",\n            \"https://api.tdameritrade.com/v1/logout\",\n            data={\"token\": refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 68.02709766694149}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            data=json.dumps({\"refresh_token\": refresh_token}),\n            headers={\"Content-Type\": \"application/json\"},\n        )\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 52.99808157238179}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            f\"{self.base_url}/v1/logout\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 47.53047106715089}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, pkg in self.packages.items():\n        if pkg.optional:\n            continue\n        version = pkg.version\n        if pkg.external:\n            version += \" from \" + pkg.source\n        result.append((name, version))\n    return result\n", "CodeBleu_score": 29.46631363867423}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if not package.is_optional:\n            metadata = self.get_package(package.name).metadata\n            result.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                    \"source\": metadata.source_url if metadata.external else None,\n                }\n            )\n    return result", "CodeBleu_score": 30.554673933261924}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if not package.options.get('optional'):\n            package_info = {'name': package.name,'version': package.version}\n            if package.metadata.get('external'):\n                package_info['url'] = package.metadata['url']\n            result.append(package_info)\n    return result\n", "CodeBleu_score": 31.7976327438149}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_spec = cls.get_instance().config.get(env)\n    if platform_spec is None:\n        raise UndefinedEnvPlatformError(env)\n    p = cls(platform_spec, autoinstall=autoinstall)\n    p.set_project_env(env)\n    p.configure_project_packages(env, targets)\n    return p\n", "CodeBleu_score": 33.003543432689945}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_spec = cls.get_instance().get_platform_spec(env)\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n    return cls.new(platform_spec, autoinstall=autoinstall).configure_project_packages(env, targets=targets)\n\n", "CodeBleu_score": 25.310765934724945}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform = cls.get_instance(env)\n    if platform is None:\n        raise UndefinedEnvPlatformError(env)\n    p = cls(platform, autoinstall=autoinstall)\n    p.configure_project_packages(env, targets)\n    return p\n", "CodeBleu_score": 29.122260036298915}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(AXP192_I2C_ADDRESS);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(AXP192_I2C_ADDRESS, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 64.5107464508203}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 75.95367887679669}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(AXP192_ADDR);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(AXP192_ADDR, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire1.read();\n\t}\n}", "CodeBleu_score": 64.47332335487037}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us)\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\telse\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 43.62739957905214}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us!= 0) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep(time_in_us);\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 68.00176675974596}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 54.77349151030913}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y_coord = scrollAddress;\n\ttft.fillRect(0, y_coord, TFT_WIDTH, text_line_height, color);\n\ty_coord += text_line_height;\n\tif (y_coord >= TFT_HEIGHT - fixed_area_bottom) {\n\t\tif (tteBar) {\n\t\t\ty_coord = fixed_area_top_bar;\n\t\t} else {\n\t\t\ty_coord = fixed_area_top;\n\t\t}\n\t}\n\tscrollAddress = y_coord;\n\treturn y_coord;\n}", "CodeBleu_score": 18.36485218129347}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y_old = scrollAddress;\n\ttft.fillRect(0, scrollAddress, tft.width(), textLineHeight, color);\n\tscrollAddress += textLineHeight;\n\tif (scrollAddress >= tft.height() - bottomFixedArea) {\n\t\tscrollAddress = 0;\n\t}\n\tif (tteBar) {\n\t\tif (scrollAddress >= tft.height() - bottomFixedArea - topFixedArea) {\n\t\t\tscrollAddress = topFixedArea;\n\t\t}\n\t}\n\ttft.setScrollAddress(scrollAddress);\n\treturn y_old;\n}", "CodeBleu_score": 21.98657938151065}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint prev_y = scrollAddress;\n\tint y = scrollAddress;\n\tint h = (tteBar? TTE_FIXED_AREA_TOP : TTE_FIXED_AREA_TOP_ALT);\n\ttft.fillRect(0, y, TTE_DISPLAY_WIDTH, h, color);\n\ty += h;\n\tif (y >= TTE_DISPLAY_HEIGHT) {\n\t\ty = 0;\n\t}\n\tscrollAddress = y;\n\treturn prev_y;\n}", "CodeBleu_score": 17.748355512812818}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 61.87356687923673}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 61.87356687923673}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 61.87356687923673}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tif (this->queue.size() == 0) {\n\t\t\tthis->queue.push_back(this->text);\n\t\t\tthis->queue.push_back(this->text_in);\n\t\t}\n\t} else {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 25.71426052861957}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (this->queue.empty()) {\n\t\t\tthis->queue.push(this->text);\n\t\t}\n\t\tif (this->text_in.empty()) {\n\t\t\tthis->text_in = this->queue.front();\n\t\t}\n\t} else {\n\t\tthis->flush_queue();\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 25.696362192122642}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag) {\n\t\tthis->queue.clear();\n\t\tthis->text.clear();\n\t\tthis->text_in.clear();\n\t}\n\telse {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 23.35114248608978}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea!= NULL) {\n\t\tthis->queue_nmea->flush();\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = NULL;\n\t}\n\tthis->queue_nmea = new Queue<char>();\n}", "CodeBleu_score": 19.066432283851693}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue!= NULL) {\n\t\tif (this->queue->size > 0) {\n\t\t\tthis->new_queue = new_queue_nmea();\n\t\t\tdelete this->queue;\n\t\t}\n\t} else {\n\t\tthis->new_queue = new_queue_nmea();\n\t}\n\tthis->queue = this->new_queue;\n}", "CodeBleu_score": 47.675846639439875}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea) {\n\t\tthis->queue_nmea->flush();\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = NULL;\n\t}\n\tthis->queue_nmea = new Queue<String>();\n}", "CodeBleu_score": 21.897955010246502}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t//    printf(\"flushing %d %d %d %d\n\", area->x1, area->y1, area->x2, area->y2);\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        display_obj.tft.writeColor(*color_p, 1);\n        color_p++;\n      }\n    }\n    display_obj.tft.endWrite();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 70.29393854829202}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint32_t w = (area->x2 - area->x1 + 1);\n\tuint32_t h = (area->y2 - area->y1 + 1);\n\n\tdisplay_obj.tft.startWrite();\n\tdisplay_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n\tdisplay_obj.tft.writePixels(color_p, w * h);\n\tdisplay_obj.tft.endWrite();\n\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 46.70870653461744}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint32_t w = (area->x2 - area->x1 + 1);\n\tuint32_t h = (area->y2 - area->y1 + 1);\n\n\tdisplay_obj.tft.startWrite();\n\tdisplay_obj.tft.setAddrWindow(area->x1, area->y1, w, h);\n\n\tfor (uint32_t y = 0; y < h; y++) {\n\t\tfor (uint32_t x = 0; x < w; x++) {\n\t\t\tdisplay_obj.tft.writeColor(color_p->full, 1);\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\n\tdisplay_obj.tft.endWrite();\n\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 60.19078100646371}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->list->size(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"  \");\n\t\t}\n\t\tSerial.print(i + 1);\n\t\tSerial.print(\" - \");\n\t\tSerial.println(menu->list->get(i)->name);\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 72.54108293178292}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tint i;\n\tint size;\n\tMenu * subMenu;\n\tMenuItem * item;\n\tif (menu!= NULL) {\n\t\tsize = menu->list->size();\n\t\tfor (i = 0; i < size; i++) {\n\t\t\titem = menu->list->get(i);\n\t\t\tif (item!= NULL) {\n\t\t\t\tif (item->type == MENU_ITEM_TYPE_MENU) {\n\t\t\t\t\tsubMenu = (Menu *) item->item;\n\t\t\t\t\tif (subMenu!= NULL) {\n\t\t\t\t\t\tSerial.print(F(\"  \"));\n\t\t\t\t\t\tSerial.print(layer);\n\t\t\t\t\t\tSerial.print(F(\".\"));\n\t\t\t\t\t\tSerial.print(i + 1);\n\t\t\t\t\t\tSerial.print(F(\". \"));\n\t\t\t\t\t\tSerial.println(item->name);\n\t\t\t\t\t\tshowMenuList(subMenu, layer + 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tSerial.print(F(\"  \"));\n\t\t\t\t\tSerial.print(layer);\n\t\t\t\t\tSerial.print(F(\".\"));\n\t\t\t\t\tSerial.print(i + 1);\n\t\t\t\t\tSerial.print(F(\". \"));\n\t\t\t\t\tSerial.println(item->name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSerial.println();\n\t}\n}", "CodeBleu_score": 46.39995917429772}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tint i;\n\tfor (i = 0; i < menu->list->size(); i++) {\n\t\tSerial.print(layer, DEC);\n\t\tSerial.print(\" \");\n\t\tSerial.println(menu->list->get(i)->name);\n\t\tshowMenuList(menu->list->get(i), layer + 1);\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 62.99699361925508}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint channel;\n\tString essid;\n\tString mac;\n\tfor (i = 0; i < count; i++) {\n\t\tchannel = random(1, 14);\n\t\tessid = randomEssid();\n\t\tmac = randomMac();\n\t\tSerial.println(essid);\n\t\tssids->add(new SSID(essid, channel, mac));\n\t}\n\treturn ssids->size();\n}", "CodeBleu_score": 32.30560272055284}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\t//Create a new list to store the generated SSIDs\n\tstd::vector<String> ssids;\n\t//Iterate through the given count\n\tfor (int i = 0; i < count; i++) {\n\t\t//Generate a random SSID\n\t\tString ssid = generateSSID();\n\t\t//Add the SSID to the list\n\t\tssids.push_back(ssid);\n\t\t//Print the SSID to the serial output\n\t\tSerial.println(ssid);\n\t}\n\t//Return the number of generated SSIDs\n\treturn ssids.size();\n}", "CodeBleu_score": 24.346789270815318}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\t// TODO: Implement this function\n\treturn 0;\n}", "CodeBleu_score": 1.661278623159386}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    # TODO(developer): Uncomment these lines before running the sample.\n    # project_id = \"your-project-id\"\n    # topic_name = \"your-topic-name\"\n\n    # Initialize a PublisherClient\n    publisher = pubsub_v1.PublisherClient()\n\n    # Construct the topic path\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    # Print a confirmation message\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 49.33548033251296}, {"code": "def create_topic(project_id, topic_name)\n\t\n    # Initialize a PublisherClient\n    publisher = pubsub_v1.PublisherClient()\n\n    # Construct the topic path using the provided project ID and topic name\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    # Print a confirmation message with the topic details\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 49.33548033251296}, {"code": "def create_topic(project_id, topic_name)\n\t\n    # Initialize a PublisherClient\n    publisher = pubsub_v1.PublisherClient()\n\n    # Construct the topic path\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic\n    try:\n        topic = publisher.create_topic(topic_path)\n        print(f\"Created topic: {topic.name}\")\n    except AlreadyExists:\n        print(f\"Topic {topic_name} already exists\")\n\n", "CodeBleu_score": 49.043468293169276}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    iat = datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    aud = project_id\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    payload = {\n        \"iat\": iat,\n        \"exp\": exp,\n        \"aud\": aud,\n    }\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n    return encoded_jwt\n\n", "CodeBleu_score": 46.96468938518106}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    iat = datetime.datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    payload = {\n        \"iat\": iat,\n        \"exp\": exp,\n        \"aud\": project_id\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 45.767540089715}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    iat = datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n    return encoded_jwt\n", "CodeBleu_score": 54.2682596481218}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message '{}' on topic '{}' with Qos {}\".format(payload, message.topic, str(message.qos)))\n\n    if payload == \"on\":\n        preview_capture()\n        upload_file()\n        publish_event()\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 22.18720599980564}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message '{}' on topic '{}', with QoS {}\".format(payload, message.topic, str(message.qos)))\n\n    if payload == \"on\":\n        preview_capture()\n        upload_file(BUCKET_NAME, FILE_NAME, FILE_PATH)\n        publish_url(MQTT_TOPIC)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 26.219758507860156}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message '{}' on topic '{}' with Qos {}\".format(payload, message.topic, str(message.qos)))\n    if payload == \"on\":\n        preview_capture()\n        upload_file()\n        publish_event()\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 22.18720599980564}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT device connection.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--registry_id',\n        required=True,\n        help='Cloud IoT Core registry id')\n    parser.add_argument(\n        '--device_id',\n        required=True,\n        help='Cloud IoT Core device id')\n    parser.add_argument(\n        '--private_key_file',\n        required=True,\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        default=8883,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--message_type',\n        default='events',\n        choices=('events','state'),\n        help='Indicates whether the message to be sent is a \"event\" or a \"state\".')\n    parser.add_argument(\n        '--num_messages',\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--message_data',\n        default=b'Hello World',\n        help='Message data to publish.')\n    parser.add_argument(\n        '--cloud_region',\n        default='us-central1',\n        help='GCP cloud region')\n    parser.add_argument(\n        '--service_account_json',\n        default=None,\n        help='Path to service account json file.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        help='Expiration time, in minutes, for JWT tokens.')\n\n    return parser.parse_args()\n\n", "CodeBleu_score": 39.009291889870354}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection via MQTT.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region.\"\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        required=True,\n        help=\"Cloud IoT registry ID, e.g.'my-registry'.\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        required=True,\n        help=\"Cloud IoT device ID, e.g.'my-node-001'.\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        default=os.path.join(os.path.dirname(__file__), \"rsa_private.pem\"),\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        required=True,\n        help=\"Which type of message to generate.\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        default=8883,\n        help=\"MQTT bridge port.\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=os.path.join(os.path.dirname(__file__), \"roots.pem\"),\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        required=True,\n        help=\"Which type of message to generate.\",\n    )\n    parser.add_argument(\n        \"--num_messages\",", "CodeBleu_score": 39.489838243107734}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        required=True,\n        help=\"Cloud IoT registry name\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        required=True,\n        help=\"Cloud IoT device id\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        required=True,\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        default=\"us-central1\",\n        help=\"GCP cloud region\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        default=8883,\n        help=\"MQTT bridge port.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Message type (event or state).\",\n    )\n    parser.add_argument(\n        \"--message_data\",\n        default=\"Hello\",\n        help=\"Message data.\",\n    )\n    parser.add_argument(\n        \"--message_num_bytes\",\n        type=int,\n        default=None,\n        help=\"Message size in bytes.\",\n    )\n    parser.add_argument(\n        \"--message_num_messages\",\n        type=int,\n        default=1,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--message_delay", "CodeBleu_score": 38.02355257763955}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json,\n        scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    )\n\n    scoped_credentials = credentials.with_scopes(\n        [\"https://www.googleapis.com/auth/cloud-platform\"]\n    )\n\n    return googleapiclient.discovery.build(\n        \"cloudiot\",\n        \"v1\",\n        credentials=scoped_credentials,\n        discoveryServiceUrl=\"https://cloudiot.googleapis.com/$discovery/rest?version=v1\",\n    )\n\n", "CodeBleu_score": 24.463465047689464}, {"code": "def get_client(service_account_json)\n\t\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(\n        ['https://www.googleapis.com/auth/cloud-platform'])\n    return googleapiclient.discovery.build(\n        'cloudiot', 'v1', credentials=scoped_credentials,\n        discoveryServiceUrl='https://cloudiot.googleapis.com/$discovery/rest?version=v1')\n\n", "CodeBleu_score": 19.483044533323294}, {"code": "def get_client(service_account_json)\n\t\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json,\n        scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    )\n    scoped_credentials = credentials.with_scopes(\n        [\"https://www.googleapis.com/auth/cloud-platform\"]\n    )\n    return googleapiclient.discovery.build(\n        \"cloudiot\", \"v1\", credentials=scoped_credentials, discoveryServiceUrl=API_DISCOVERY_FILE\n    )\n\n", "CodeBleu_score": 21.776175984539176}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_asn1 = hash_method.get_asn1_code()\n    if hash_asn1 is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_value_with_asn1 = hash_asn1 + hash_value\n    pad_for_signing = _pad_for_signing(\n        common.byte_size(hash_value_with_asn1),\n        priv_key.modulus_size,\n        priv_key.blinded_encrypt,\n        priv_key.unblind,\n    )\n    return priv_key.blinded_encrypt(pad_for_signing)", "CodeBleu_score": 31.27374981627309}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == \"sha1\":\n        asn1_code = b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\"\n    elif hash_method == \"sha256\":\n        asn1_code = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    elif hash_method == \"sha512\":\n        asn1_code = b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\"\n    else:\n        raise ValueError(\"Invalid hash method\")\n    hash_with_asn1 = asn1_code + hash_value\n    padded_hash = _pad_for_signing(hash_with_asn1, priv_key)\n    signature = priv_key.blinded_encrypt(padded_hash)\n    return signature\n\n", "CodeBleu_score": 30.518603360794128}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = _get_asn1_code(hash_method)\n    if asn1_code is None:\n        raise ValueError(\"Invalid hash method.\")\n    data = asn1_code + hash_value\n    data = _pad_for_signing(data, priv_key.k)\n    signature = priv_key.blinded_encrypt(data)\n    return signature\n\n", "CodeBleu_score": 28.67568299979305}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(message, bytes):\n        raise TypeError(\"message must be bytes\")\n    if not isinstance(signature, bytes):\n        raise TypeError(\"signature must be bytes\")\n    if not isinstance(pub_key, bytes):\n        raise TypeError(\"public key must be bytes\")\n    if len(signature)!= 256:\n        raise ValueError(\"signature must be 256 bytes\")\n    if len(pub_key)!= 32:\n        raise ValueError(\"public key must be 32 bytes\")\n    sig_int = transform.bytes2int(signature)\n    clear_sig_int = core.decrypt_int(sig_int, pub_key)\n    method_hash = _find_method_hash(clear_sig_int)\n    message_hash = compute_hash(message, method_hash)\n    expected_hash = _pad_for_signing(message_hash, method_hash)\n    if expected_hash!= clear_sig_int:\n        raise VerificationError(\"signature does not match\")\n    return method_hash.name\n", "CodeBleu_score": 40.50744593725284}, {"code": "def verify(message, signature, pub_key)\n\t\n    if not isinstance(signature, int):\n        signature = transform.bytes2int(signature)\n    if not isinstance(message, bytes):\n        message = message.encode()\n    clear_signature = core.decrypt_int(signature, pub_key)\n    hash_method = _find_method_hash(clear_signature)\n    if hash_method is None:\n        raise VerificationError(\"Invalid signature\")\n    message_hash = compute_hash(message, hash_method)\n    expected_padded_hash = _pad_for_signing(message_hash, hash_method)\n    if clear_signature!= expected_padded_hash:\n        raise VerificationError(\"Invalid signature\")\n    return hash_method\n\n", "CodeBleu_score": 44.56696120134384}, {"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        signature = transform.bytes2int(signature)\n    except ValueError:\n        raise VerificationError(\"Invalid signature\")\n    try:\n        clear_signature = core.decrypt_int(signature, pub_key)\n    except ValueError:\n        raise VerificationError(\"Invalid signature\")\n    hash_method = _find_method_hash(clear_signature)\n    if hash_method is None:\n        raise VerificationError(\"Invalid signature\")\n    message_hash = compute_hash(message, hash_method)\n    expected_padded_hash = _pad_for_signing(message_hash, hash_method)\n    if clear_signature!= expected_padded_hash:\n        raise VerificationError(\"Invalid signature\")\n    return hash_method\n\n", "CodeBleu_score": 42.328540900293184}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\ttime_t now = 0;\n\tstruct tm timeinfo = { 0 };\n\tint ret = 0;\n\n\tESP_LOGI(TAG, \"Updating time via NTP\");\n\tsetenv(\"TZ\", TZ, 1);\n\ttzset();\n\tret = getLocalTime(&timeinfo, 10);\n\tif (ret == 0) {\n\t\t// Set is time valid\n\t\tnow = mktime(&timeinfo);\n\t\tlocal_time = now;\n\t\tESP_LOGI(TAG, \"Time is set\");\n\t} else {\n\t\tESP_LOGI(TAG, \"Failed to obtain time\");\n\t}\n\n\t// Update JWT for MQTT client\n\tupdateJWT();\n\n\t// Connect to MQTT Client\n\tMQTT_CLIENT_connect(mqtt_client, mqtt_event_handler, mqtt_event_handler_user_data, 10000);\n\t// Set a flag to send MQTT SUBSCRIBE packet after connection is established\n\tmqtt_subscribe = true;\n\n\tESP_LOGI(TAG, \"MQTT connection attempt\");\n}", "CodeBleu_score": 40.79877837057919}, {"code": "static void connectMQTT(){\n\t\ttime_t now = 0;\n\tstruct tm timeinfo = { 0 };\n\tint ret = 0;\n\n\tret = getLocalTime(&timeinfo, 10000);\n\tif (ret == 0) {\n\t\tESP_LOGI(TAG, \"Failed to obtain time\");\n\t\treturn;\n\t}\n\ttime(&now);\n\tESP_LOGI(TAG, \"The current date/time in UTC is: %s\", ctime(&now));\n\n\tupdateJWT();\n\n\tMQTT_CLIENT_connect(client, MQTT_HOST, MQTT_PORT, MQTT_CLIENT_ID, MQTT_USER, MQTT_PASS, MQTT_KEEPALIVE, MQTT_CLEAN_SESSION);\n\tsend_subscribe = true;\n\tESP_LOGI(TAG, \"MQTT connection attempt\");\n}", "CodeBleu_score": 41.334818462206826}, {"code": "static void connectMQTT(){\n\t\t//get current time\n\ttime_t now;\n\ttime(&now);\n\tif (now > 0) {\n\t\t//update JWT\n\t\tupdateJWT(now);\n\t}\n\t//connect to MQTT client\n\tMQTT_CLIENT_connect(MQTT_CLIENT_ID, MQTT_SERVER_URL, MQTT_SERVER_PORT, MQTT_USERNAME, MQTT_PASSWORD, MQTT_KEEP_ALIVE, MQTT_CLEAN_SESSION, MQTT_KEEP_ALIVE_TIMEOUT, MQTT_CONNECT_TIMEOUT, MQTT_SUBSCRIBE_TIMEOUT, MQTT_RECONNECT_TIMEOUT, MQTT_MAX_RECONNECT_ATTEMPTS);\n\t//set flag to send MQTT SUBSCRIBE packet after connection is established\n\tmqtt_subscribe_flag = 1;\n\t//print debug message\n\tdebug_print(\"MQTT connection attempt\");\n}", "CodeBleu_score": 39.96544644457676}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t value = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (!is_digit(str[i])) {\n\t\t\treturn str;\n\t\t}\n\t\tvalue = value * 10 + (str[i] - '0');\n\t}\n\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 25.808807260879995}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t n = 0;\n\tfor (int i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') return str;\n\t\tn = n * 10 + (str[i] - '0');\n\t}\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 22.903879283620626}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tuint32_t digit;\n\tconst uint8_t* p = str;\n\n\twhile (width-- > 0) {\n\t\tdigit = *p++ - '0';\n\t\tif (digit > 9) {\n\t\t\treturn str;\n\t\t}\n\t\tresult = result * 10 + digit;\n\t}\n\n\t*num = result;\n\treturn p;\n}", "CodeBleu_score": 22.76586804386829}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t* cert_buf = build_state->cert_template;\n\tsize_t cert_size = build_state->cert_template_size;\n\tsize_t cert_offset = build_state->cert_template_offset;\n\tatcacert_cert_loc_t* cert_loc = build_state->cert_loc;\n\tatcacert_t* cert_def = build_state->cert_def;\n\tuint8_t* tbs_buf = build_state->tbs_template;\n\tsize_t tbs_size = build_state->tbs_template_size;\n\tsize_t tbs_offset = build_state->tbs_template_offset;\n\tatcacert_cert_loc_t* tbs_loc = build_state->tbs_loc;\n\tatcacert_t* tbs_def = build_state->tbs_def;\n\tuint8_t* sig_buf = build_state->sig_template;\n\tsize_t sig_size = build_state->sig_template_size;\n\tsize_t sig_offset = build_state->sig_template_offset;\n\tatcacert_cert_loc_t* sig_loc = build_state->sig_loc;\n\tatcacert_t* sig_def = build_state->sig_def;\n\tuint8_t* pub_key = build_state->pub_key;\n\tsize_t pub_key_size = build_state->pub_key_size;\n\tuint8_t* priv_key = build_state->priv_key;\n\tsize_t priv_key_size = build_state->priv_key_size;\n\tuint8_t* ca_public_key = build_state->ca_public_key;\n\tsize_t ca_public_key_size = build_state->ca_public_key_size;\n\tuint8_t* ca_chain = build_state->ca_chain;\n\tsize_t ca_chain_size = build_state->ca_chain_size;\n\tsize_t ca_chain_count = build_state->ca_chain_count;\n", "CodeBleu_score": 11.37825038950513}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tsize_t cert_size = 0;\n\tuint8_t* cert_ptr = NULL;\n\tuint8_t* cert_end = NULL;\n\tuint8_t* cert_start = NULL;\n\tuint8_t* cert_public_key = NULL;\n\tuint8_t* cert_signature = NULL;\n\tuint8_t* cert_template = NULL;\n\tuint8_t* cert_template_end = NULL;\n\tuint8_t* cert_template_start = NULL;\n\tuint8_t* cert_template_public_key = NULL;\n\tuint8_t* cert_template_signature = NULL;\n\tuint8_t* cert_template_public_key_end = NULL;\n\tuint8_t* cert_template_signature_end = NULL;\n\tuint8_t* cert_template_public_key_start = NULL;\n\tuint8_t* cert_template_signature_start = NULL;\n\tuint8_t* cert_template_public_key_size = NULL;\n\tuint8_t* cert_template_signature_size = NULL;\n\tuint8_t* cert_template_public_key_size_end = NULL;\n\tuint8_t* cert_template_signature_size_end = NULL;\n\tuint8_t* cert_template_public_key_size_start = NULL;\n\tuint8_t* cert_template_signature_size_start = NULL;\n\tuint8_t* cert_template_public_key_size_len = NULL;\n\tuint8_t* cert_template_signature_size_len = NULL;\n\tuint8_t* cert_template_public_key_size_len_end = NULL;\n\tuint8_t* cert_template_signature_size_len_end = NULL;\n\tuint8_t* cert_template_public_key_size_len_start = NULL;\n\tuint8_t* cert_template_signature_size_len_start = NULL;\n\tuint8_t* cert_template_public_key_size_len_size = NULL;\n\tuint8_t* cert_template_signature", "CodeBleu_score": 10.832208976773048}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = ATCA_SUCCESS;\n\tatcacert_cert_loc_t* cert_loc = &build_state->cert_loc;\n\tatcacert_cert_loc_t* public_key_loc = &build_state->public_key_loc;\n\tatcacert_cert_loc_t* private_key_loc = &build_state->private_key_loc;\n\tatcacert_cert_loc_t* issue_date_loc = &build_state->issue_date_loc;\n\tatcacert_cert_loc_t* expire_date_loc = &build_state->expire_date_loc;\n\tuint8_t* cert_template = build_state->cert_template;\n\tuint8_t* public_key = build_state->public_key;\n\tuint8_t* private_key = build_state->private_key;\n\tuint8_t* cert_sn = build_state->cert_sn;\n\tuint8_t* cert_sn_size = build_state->cert_sn_size;\n\tuint8_t* cert_sn_source = build_state->cert_sn_source;\n\tuint8_t* cert_sn_source_size = build_state->cert_sn_source_size;\n\tuint8_t* signer_id = build_state->signer_id;\n\tuint8_t* signer_id_size = build_state->signer_id_size;\n\tuint8_t* signer_id_mode = build_state->signer_id_mode;\n\tuint8_t* device_loc = build_state->device_loc;\n\tuint8_t* device_loc_size = build_state->device_loc_size;\n\tuint8_t* device_sn = build_state->device_sn;\n\tuint8_t* device_sn_size = build_state->device_sn_size;\n\tuint8_t* device_sn_source = build_state->device_sn_source;\n\tuint8_t* device_sn_source_size = build_state->device_sn_source_size;\n\tuint8_t* cert_elements = build_state", "CodeBleu_score": 13.211269977354782}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\tsize_t  tbs_size = 0;\n\tsize_t  sig_size = 0;\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Get the TBS digest\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Get the signature\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Verify the signature\n\tret = atcacert_get_tbs_max_size(cert_def, &tbs_size);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = atcacert_get_sig_max_size(cert_def, &sig_size);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = atcab_verify_extern(tbs_digest, tbs_size, signature, sig_size, ca_public_key);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 73.91606291864656}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn atcab_verify_extern(tbs_digest, signature, ca_public_key);\n}", "CodeBleu_score": 66.29093369869574}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = ATCA_SUCCESS;\n\tuint8_t signature[64];\n\tuint8_t tbs_digest[32];\n\n\tdo {\n\t\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\t\tret = ATCA_BAD_PARAM;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\t\tif (ret!= ATCA_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\n\t\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\t\tif (ret!= ATCA_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\n\t\tret = atcab_verify_extern(tbs_digest, signature, ca_public_key);\n\t} while (0);\n\n\treturn ret;\n}", "CodeBleu_score": 57.06883866807587}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimer->next = NULL;\n\ttimer->prev = NULL;\n\ttimer->timeout = 0;\n\ttimer->callback = NULL;\n\ttimer->callback_arg = NULL;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id = 0;\n\ttimer->timer_id =", "CodeBleu_score": 15.56496897179275}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t *volatile *volatile tmp = list;\n\twhile(*tmp!= NULL) {\n\t\tif((*tmp)->id == timer->id) {\n\t\t\t*tmp = timer->next;\n\t\t\tfree(timer);\n\t\t\treturn true;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 19.510553563425418}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t#line 25 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\tif (timer->next == timer) {\n#line 26 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t\ttimer->next = 0;\n#line 27 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t\treturn 1;\n#line 28 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t} else {\n#line 29 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t\ttimerStruct_t *prev = timer->next;\n#line 30 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t\twhile (prev->next!= timer) {\n#line 31 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t\t\tprev = prev->next;\n#line 32 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t\t}\n#line 33 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t\tprev->next = timer->next;\n#line 34 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t\ttimer->next = 0;\n#line 35 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t\treturn 0;\n#line 36 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n\t}\n#line 37 \"/home/david/workspace/atron-firmware/components/hal/src/hal.c\"\n}", "CodeBleu_score": 21.471021575629447}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tint status;\n\tstruct socketInfo *socketInfo;\n\n\tsocketInfo = getSocketInfo(socket);\n\tif (socketInfo == NULL) {\n\t\tbsd_setErrNo(EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\n\tsocketInfo->state = NOT_A_SOCKET;\n\n\tstatus = close(socket);\n\tif (status == -1) {\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 32.46752705292}, {"code": "int BSD_close(int socket){\n\t\tint status = BSD_SUCCESS;\n\tsocketInfo *info = getSocketInfo(socket);\n\tif (info == NULL) {\n\t\tstatus = BSD_ERROR;\n\t\tbsd_setErrNo(EBADF);\n\t} else {\n\t\tif (close(socket) < 0) {\n\t\t\tstatus = BSD_ERROR;\n\t\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\tbsd_setErrNo(EBADF);\n\t\t\t\tbreak;\n\t\t\tcase EINTR:\n\t\t\t\tbsd_setErrNo(EINTR);\n\t\t\t\tbreak;\n\t\t\tcase EIO:\n\t\t\t\tbsd_setErrNo(EIO);\n\t\t\t\tbreak;\n\t\t\tcase EISDIR:\n\t\t\t\tbsd_setErrNo(EISDIR);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbsd_setErrNo(errno);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo->state = NOT_A_SOCKET;\n\t\t}\n\t}\n\treturn status;\n}", "CodeBleu_score": 50.013892803708956}, {"code": "int BSD_close(int socket){\n\t\tstruct socketInfo *info;\n\tint status;\n\n\tinfo = getSocketInfo(socket);\n\tif (info == NULL) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tinfo->state = NOT_A_SOCKET;\n\n\tstatus = close(socket);\n\tif (status == -1) {\n\t\tif (errno == EBADF) {\n\t\t\tbsd_setErrNo(EBADF);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == EINTR) {\n\t\t\tbsd_setErrNo(EINTR);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == EIO) {\n\t\t\tbsd_setErrNo(EIO);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse {\n\t\t\tbsd_setErrNo(errno);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 46.05039400872079}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint result = listen(socket, backlog);\n\tif (result == -1) {\n\t\tbsd_setErrNo\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 11.693527474375456}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint status = listen(socket, backlog);\n\tif (status == -1) {\n\t\tbsd_setErrNo();\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 14.547145881155075}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tif (listen(socket, backlog) == BSD_ERROR) {\n\t\tif (errno == EBADF) {\n\t\t\tBSD_setErrNo(EBADF);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == EDESTADDRREQ) {\n\t\t\tBSD_setErrNo(EDESTADDRREQ);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == EINVAL) {\n\t\t\tBSD_setErrNo(EINVAL);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == ENOBUFS) {\n\t\t\tBSD_setErrNo(ENOBUFS);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == ENOMEM) {\n\t\t\tBSD_setErrNo(ENOMEM);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == ENOTSOCK) {\n\t\t\tBSD_setErrNo(ENOTSOCK);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse if (errno == EOPNOTSUPP) {\n\t\t\tBSD_setErrNo(EOPNOTSUPP);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\telse {\n\t\t\tBSD_setErrNo(0);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\telse {\n\t\treturn BSD_SUCCESS;\n\t}\n}", "CodeBleu_score": 47.1236776744877}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = 0;\n\tstruct sockaddr_in *addr_in;\n\tstruct sockaddr_in6 *addr_in6;\n\tstruct sockaddr_un *addr_un;\n\tint addr_len;\n\tint family;\n\n\tif (addr == NULL) {\n\t\tbsd_setErrNo(EFAULT);\n\t\treturn -1;\n\t}\n\n\tif (addrlen == NULL) {\n\t\tbsd_setErrNo(EFAULT);\n\t\treturn -1;\n\t}\n\n\tif (*addrlen < sizeof(struct bsd_sockaddr)) {\n\t\tbsd_setErrNo(EINVAL);\n\t\treturn -1;\n\t}\n\n\tfamily = addr->sa_family;\n\tif (family == AF_INET) {\n\t\taddr_in = (struct sockaddr_in *) addr;\n\t\taddr_len = sizeof(struct sockaddr_in);\n\t} else if (family == AF_INET6) {\n\t\taddr_in6 = (struct sockaddr_in6 *) addr;\n\t\taddr_len = sizeof(struct sockaddr_in6);\n\t} else if (family == AF_UNIX) {\n\t\taddr_un = (struct sockaddr_un *) addr;\n\t\taddr_len = sizeof(struct sockaddr_un);\n\t} else {\n\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\n\tret = accept(socket, (struct sockaddr *) addr, (socklen_t *) addrlen);\n\tif (ret < 0) {\n\t\tif (errno == EBADF) {\n\t\t\tbsd_setErrNo(EBADF);\n\t\t} else if (errno == ECONNABORTED) {\n\t\t\tbsd_setErrNo(ECONNABORTED);\n\t\t} else if (errno == EFAULT) {\n\t\t\tbsd_setErrNo(EFAULT);\n\t\t} else if (errno == EINTR) {\n\t\t\tbsd_setErrNo(EINTR);\n\t\t} else if (errno == EINVAL) {\n\t\t\tbsd_setErrNo(EINVAL);\n\t\t} else if (errno == EMFILE) {\n\t\t\tbsd_setErrNo(EMFILE);\n\t\t} else if (errno == ENFILE) {\n\t\t\tbsd_setErrNo(ENFILE);\n\t\t} else if (errno ==", "CodeBleu_score": 42.79473483566366}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint error;\n\tstruct sockaddr_storage ss;\n\tstruct sockaddr *sa = (struct sockaddr *)&ss;\n\tsocklen_t sslen = sizeof(ss);\n\tstruct sockaddr_in *sin;\n\tstruct sockaddr_in6 *sin6;\n\tstruct sockaddr_un *sun;\n\n\tif (addr == NULL) {\n\t\tbsd_setErrNo(EINVAL);\n\t\treturn -1;\n\t}\n\n\tif (addrlen == NULL) {\n\t\tbsd_setErrNo(EINVAL);\n\t\treturn -1;\n\t}\n\n\tif (addr->sa_family == AF_INET) {\n\t\tsin = (struct sockaddr_in *)addr;\n\t\tsin->sin_len = sizeof(*sin);\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = ntohs(sin->sin_port);\n\t\tsin->sin_addr.s_addr = ntohl(sin->sin_addr.s_addr);\n\t} else if (addr->sa_family == AF_INET6) {\n\t\tsin6 = (struct sockaddr_in6 *)addr;\n\t\tsin6->sin6_len = sizeof(*sin6);\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = ntohs(sin6->sin6_port);\n\t\tsin6->sin6_flowinfo = ntohl(sin6->sin6_flowinfo);\n\t\tsin6->sin6_scope_id = ntohl(sin6->sin6_scope_id);\n\t} else if (addr->sa_family == AF_UNIX) {\n\t\tsun = (struct sockaddr_un *)addr;\n\t\tsun->sun_len = sizeof(*sun);\n\t\tsun->sun_family = AF_UNIX;\n\t} else {\n\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\n\terror = accept(socket, sa, &sslen);\n\n\tif (error == -1) {\n\t\tbsd_setErrNo(errno);\n\t\treturn -1;\n\t}\n\n\tif (sa->sa_family == AF_INET) {\n\t\tsin = (struct sockaddr_in *)addr;\n\t\tsin->sin_len = sizeof", "CodeBleu_score": 43.38438545220535}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret;\n\tint error;\n\tstruct bsd_sockaddr_in *addr_in = (struct bsd_sockaddr_in *)addr;\n\tstruct bsd_sockaddr_in6 *addr_in6 = (struct bsd_sockaddr_in6 *)addr;\n\n\tif (addrlen == NULL) {\n\t\tbsd_setErrNo(EINVAL);\n\t\treturn -1;\n\t}\n\n\tif (addr->bsd_sa_family == AF_INET) {\n\t\tstruct sockaddr_in addr_in_conv;\n\t\taddr_in_conv.sin_family = addr_in->bsd_sin_family;\n\t\taddr_in_conv.sin_port = addr_in->bsd_sin_port;\n\t\taddr_in_conv.sin_addr.s_addr = addr_in->bsd_sin_addr.bsd_s_addr;\n\t\taddr_in_conv.sin_zero[0] = 0;\n\t\taddr_in_conv.sin_zero[1] = 0;\n\t\taddr_in_conv.sin_zero[2] = 0;\n\t\taddr_in_conv.sin_zero[3] = 0;\n\t\taddr_in_conv.sin_zero[4] = 0;\n\t\taddr_in_conv.sin_zero[5] = 0;\n\t\taddr_in_conv.sin_zero[6] = 0;\n\t\taddr_in_conv.sin_zero[7] = 0;\n\n\t\tret = accept(socket, (struct sockaddr *)&addr_in_conv, addrlen);\n\t} else if (addr->bsd_sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 addr_in6_conv;\n\t\taddr_in6_conv.sin6_family = addr_in6->bsd_sin6_family;\n\t\taddr_in6_conv.sin6_port = addr_in6->bsd_sin6_port;\n\t\taddr_in6_conv.sin6_flowinfo = addr_in6->bsd_sin6_flowinfo;\n\t\taddr_in6_conv.sin6_addr.s6_addr[0] = addr_in6->bsd_sin6_addr", "CodeBleu_score": 39.36771589456357}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\ttime_t now = 0;\n\ttime(&now);\n\tif (now == ((time_t)-1)) {\n\t\t// Get the time failed.\n\t\treturn;\n\t}\n\n\t// Update JWT with the time offset.\n\tupdateJWT(now);\n\n\t// Initiate the MQTT connection.\n\tMQTT_CLIENT_connect(client, &connectParams, NULL, onConnectionEstablished, 10000);\n\tdebug_print(\"MQTT connecting to %s:%d\n\\r\", AWS_IOT_MQTT_HOST, AWS_IOT_MQTT_PORT);\n}", "CodeBleu_score": 36.75871850707211}, {"code": "static void connectMQTT(){\n\t\ttime_t now;\n\tstruct tm timeinfo;\n\ttime(&now);\n\tlocaltime_r(&now, &timeinfo);\n\tif (timeinfo.tm_year < (2016 - 1900)) {\n\t\tESP_LOGE(TAG, \"The current date/time is not valid\");\n\t\treturn;\n\t}\n\tupdateJWT(now);\n\tMQTT_CLIENT_connect(client, &connectParams);\n\tESP_LOGI(TAG, \"Connecting to %s:%d\", connectParams.uri, connectParams.port);\n\tsend_subscribe = true;\n}", "CodeBleu_score": 38.27225677270456}, {"code": "static void connectMQTT(){\n\t\ttime_t now;\n\ttime(&now);\n\tif (now < 1510592825) {\n\t\tupdateJWT();\n\t}\n\tMQTT_CLIENT_connect(client, &connectParams, &params, 0, NULL, 0, 0,\n\t\t\tMQTT_connect_sent);\n\tdebug_print(\"MQTT connecting...\");\n}", "CodeBleu_score": 20.522576980985896}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tdebug_printError(\"CLOUD_disconnect\");\n\tif (MQTT_GetConnectionState() == CONNECTED) {\n\t\tMQTT_ClientConnectionInfo_t clientConnectionInfo;\n\t\tMQTT_GetClientConnectionInfo(&clientConnectionInfo);\n\t\tMQTT_Disconnect(&clientConnectionInfo);\n\t}\n}", "CodeBleu_score": 63.843501371024104}, {"code": "void CLOUD_disconnect(void){\n\t\tdebug_printError(CLOUD_DISCONNECT_LOG);\n\tif (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n\t\tMQTT_ClientConnectionInfo_t clientConnectionInfo;\n\t\tMQTT_GetClientConnectionInfo(&clientConnectionInfo);\n\t\tMQTT_Disconnect(&clientConnectionInfo);\n\t}\n}", "CodeBleu_score": 50.48936176487268}, {"code": "void CLOUD_disconnect(void){\n\t\tdebug_printError(DEBUG_LEVEL_INFO, \"CLOUD_disconnect\", \"Disconnected from the cloud service.\");\n\tif (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n\t\tMQTT_ClientConnectionInfo_t clientConnectionInfo;\n\t\tMQTT_GetClientConnectionInfo(&clientConnectionInfo);\n\t\tMQTT_Disconnect(&clientConnectionInfo);\n\t}\n}", "CodeBleu_score": 50.179139353413916}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif(passed_wifi_creds) {\n\t\tif(!m2m_wifi_connect((char*)ssid, strlen(ssid), auth_type, (char*)password, M2M_WIFI_CH_ALL, NULL)) {\n\t\t\tdebug_printError(\"Failed to connect to Wi-Fi AP.\n\");\n\t\t\tnetworking_error = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif(!m2m_wifi_default_connect()) {\n\t\t\tdebug_printError(\"Failed to connect to Wi-Fi AP.\n\");\n\t\t\tnetworking_error = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 50.03787063543885}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif (passed_wifi_creds) {\n\t\tif (m2m_wifi_connect((char *)WIFI_SSID, strlen(WIFI_SSID), WIFI_AUTH_TYPE, (void *)WIFI_PASSWORD, M2M_WIFI_CH_ALL) == M2M_SUCCESS) {\n\t\t\tdebug_printError(\"Failed to connect to Wi-Fi access point with new credentials.\");\n\t\t\tnetworking_error = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (m2m_wifi_default_connect()!= M2M_SUCCESS) {\n\t\t\tdebug_printError(\"Failed to connect to Wi-Fi access point with default credentials.\");\n\t\t\tnetworking_error = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 47.488504199129736}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif (passed_wifi_creds) {\n\t\tif (m2m_wifi_connect((char*)wifi_ssid, strlen(wifi_ssid), wifi_security_type, (void*)wifi_password, M2M_WIFI_CH_ALL) == M2M_SUCCESS) {\n\t\t\tdebug_printError(\"Wi-Fi connection failed\");\n\t\t\tnetworking_error = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (m2m_wifi_default_connect()!= M2M_SUCCESS) {\n\t\t\tdebug_printError(\"Wi-Fi connection failed\");\n\t\t\tnetworking_error = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 49.3170436076585}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tnst client = await generateClient();\n\tconst response = await client.graphql({\n\t\tquery: `query ListSensors {\n\t\t\tlistSensors {\n\t\t\t\titems {\n\t\t\t\t\tid\n\t\t\t\t\tname\n\t\t\t\t\tgeo {\n\t\t\t\t\t\tlatitude\n\t\t\t\t\t\tlongitude\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}`\n\t});\n\tconsole.log(response);\n\tif (response.data.listSensors) {\n\t\tconsole.log('Retrieved sensors:', response.data.listSensors.items);\n\t\tresponse.data.listSensors.items.forEach(sensor => {\n\t\t\tconst marker = CreateSensorMarker(sensor.name);\n\t\t\tnew Marker({element: marker})\n\t\t\t\t.setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n\t\t\t\t.addTo(map);\n\t\t});\n\t}\n}", "CodeBleu_score": 52.36481819852502}, {"code": "async function DisplaySensors(map){\n\tnst client = generateClient();\n\tconst response = await client.graphql(\n\t\t`{\n\t\t\tlistSensors {\n\t\t\t\titems {\n\t\t\t\t\tsensorId\n\t\t\t\t\tgeo {\n\t\t\t\t\t\tlatitude\n\t\t\t\t\t\tlongitude\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}`\n\t);\n\tconsole.log(response);\n\tif (response.data.listSensors) {\n\t\tconsole.log('Retrieved sensors:');\n\t\tresponse.data.listSensors.forEach((sensor) => {\n\t\t\tconst marker = CreateSensorMarker(sensor.sensorId);\n\t\t\tnew mapboxgl.Marker({element: marker})\n\t\t\t\t.setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n\t\t\t\t.addTo(map);\n\t\t});\n\t}\n}", "CodeBleu_score": 46.998091272769365}, {"code": "async function DisplaySensors(map){\n\tnst client = generateClient();\n\tconst query = CreateSensorMarker();\n\tconst response = await client.graphql(query);\n\tconsole.log(response);\n\tif (response.data.listSensors) {\n\t\tconsole.log(\"Retrieved sensors\");\n\t\tresponse.data.listSensors.forEach((sensor) => {\n\t\t\tconst marker = document.createElement(\"div\");\n\t\t\tmarker.className = \"marker\";\n\t\t\tnew mapboxgl.Marker({element: marker})\n\t\t\t\t.setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n\t\t\t\t.addTo(map);\n\t\t});\n\t}\n}", "CodeBleu_score": 49.37456014144707}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.border = '1px solid'+ sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 45.911804975764184}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = \"rgb(19, 124, 124)\";\n\tmarker.style.border = \"2px solid rgb(19, 124, 124)\";\n\tmarker.style.borderRadius = \"50%\";\n\tmarker.style.width = \"15px\";\n\tmarker.style.height = \"15px\";\n\tmarker.style.cursor = \"pointer\";\n\tmarker.style.zIndex = \"100\";\n\treturn marker;\n}", "CodeBleu_score": 43.746610126700375}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement('div')\n\tmarker.id = sensor.id\n\tmarker.className ='marker'\n\tmarker.style.backgroundColor = '#000000'\n\tmarker.style.border = '1px solid #000000'\n\treturn marker\n}", "CodeBleu_score": 43.65204690866392}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.auth.mfa.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Failed to import module %s: %s\",\n            module_path,\n            err,\n            exc_info=True,\n        )\n        raise HomeAssistantError(\n            f\"Failed to import module {module_path}: {err}\"\n        ) from err\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        requirements = module.REQUIREMENTS\n        if requirements:\n            processed = hass.data.setdefault(\n                \"auth_mfa_module_requirements\", set()\n            )\n            if requirements not in processed:\n                try:\n                    await async_process_requirements(\n                        hass, requirements, \"auth mfa module\"\n                    )\n                except RequirementsNotFound as err:\n                    _LOGGER.error(\n                        \"Failed to install requirements for module %s: %s\",\n                        module_path,\n                        err,\n                        exc_info=True,\n                    )\n                    raise HomeAssistantError(\n                        f\"Failed to install requirements for module {module_path}: {err}\"\n                    ) from err\n                processed.add(requirements)\n\n    return module\n\n", "CodeBleu_score": 45.48347327756468}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    try:\n        module = importlib.import_module(f\"homeassistant.components.mfa.{module_name}\")\n    except ImportError:\n        _LOGGER.error(\"Unable to import MFA module %s\", module_name)\n        raise HomeAssistantError(f\"Unable to import MFA module {module_name}\")\n\n    if module.REQUIREMENTS and not skip_pip:\n        processed = hass.data.setdefault(DATA_MFA_REQUIREMENTS, set())\n        if module.REQUIREMENTS not in processed:\n            await async_process_requirements(hass, module.REQUIREMENTS)\n            processed.add(module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 37.93700742480451}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    try:\n        module = importlib.import_module(f\"homeassistant.components.auth_mfa.{module_name}\")\n    except ImportError as err:\n        _LOGGER.error(\"Failed to import module %s: %s\", module_name, err)\n        raise HomeAssistantError(f\"Failed to import module {module_name}\") from err\n\n    if module.REQUIREMENTS and not _SKIP_PIP:\n        processed = hass.data.setdefault(\n            f\"{DOMAIN}_processed_requirements\", set()\n        )\n        if module.REQUIREMENTS not in processed:\n            await async_process_requirements(hass, module.REQUIREMENTS, DOMAIN)\n            processed.add(module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 46.6791650106189}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if not isinstance(setup_data, dict):\n        raise InvalidSetupDataError(\n            \"The setup data must be a dictionary with a 'pin' key.\"\n        )\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        raise InvalidSetupDataError(\"The setup data must contain a 'pin' key.\")\n    if not isinstance(pin, str):\n        raise InvalidSetupDataError(\n            \"The 'pin' key must be a string containing the PIN.\"\n        )\n    if len(pin)!= 4:\n        raise InvalidSetupDataError(\"The PIN must be a 4-digit string.\")\n    if not pin.isdigit():\n        raise InvalidSetupDataError(\"The PIN must be a 4-digit string.\")\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n    return self.data[user_id]\n\n", "CodeBleu_score": 29.753306061368924}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    data = await self.async_get_data()\n    if data is None:\n        data = []\n    user_data = next((u for u in data if u[\"user_id\"] == user_id), None)\n    if user_data is None:\n        user_data = {\"user_id\": user_id}\n        data.append(user_data)\n    user_data[\"pin\"] = setup_data[\"pin\"]\n    await self.async_set_data(data)\n    return user_data\n\n", "CodeBleu_score": 37.54904746670814}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self._data:\n        self._data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self._data[user_id] = {\"pin\": setup_data[\"pin\"]}\n    return self._data[user_id]\n\n", "CodeBleu_score": 38.58491164885846}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._loaded:\n            return\n        data = await self.store.get(self.key)\n        if not data:\n            data = {}\n        self._loaded = True\n    self.items = {user_id: NotifySetting(user_id, data.get(user_id, {})) for user_id in data}\n\n", "CodeBleu_score": 34.70921711718034}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self.user_settings is not None:\n            return\n        self.user_settings = {}\n        data = await self.store.get(\"user_settings\")\n        if not data:\n            data = {}\n        for user_id, settings in data.items():\n            self.user_settings[user_id] = NotifySetting(settings)\n\n", "CodeBleu_score": 37.888339849743474}, {"code": "async def _async_load(self) -> None\n\t\n    await self._init_lock.acquire()\n    try:\n        if self._is_loaded:\n            return\n        data = await self.store.get(self.user_id)\n        if data is None:\n            data = {}\n        self._data = data\n        self._is_loaded = True\n    finally:\n        self._init_lock.release()\n    for item in data.items():\n        self._data[item[0]] = NotifySetting(item[1])\n\n", "CodeBleu_score": 34.12020124630897}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load()\n    settings = await self.async_get_settings(user_id)\n    if settings is None:\n        return False\n    return await self._async_validate(settings, user_input)\n\n", "CodeBleu_score": 38.777902732764666}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    settings = await self.async_get_settings(user_id)\n    if not settings:\n        return False\n    return await self.hass.async_add_executor_job(\n        validate_otp,\n        user_input[\"otp\"],\n        settings.secret,\n        settings.digits,\n        settings.period,\n        settings.issuer,\n    )\n\n", "CodeBleu_score": 50.44675641318752}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    settings = self._settings.get(user_id)\n    if not settings:\n        return False\n    return await self.hass.async_add_executor_job(\n        validate_otp, user_input[\"otp\"], settings\n    )\n\n", "CodeBleu_score": 44.39008714069191}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None or entity_entry.device_id is None:\n        return None\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if device_entry is None or device_entry.area_id is None:\n        return None\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 86.25457105561063}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if not entity_entry:\n        return None\n\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if not device_entry:\n        return None\n\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 56.866376498375985}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_entry = entity_entry.device_entry\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 54.50449199589082}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy = {}\n    seen = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen:\n                seen.add(category)\n                policy.update(merge_categories(\n                    [policy[category] for policy in policies]))\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 47.447576239793555}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen:\n                seen.add(category)\n                policy.update(merge_categories(category, [policy[category] for policy in policies]))\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 53.12200215627284}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen:\n                seen.add(category)\n                policy[category] = merge_categories(\n                    [policy[category] for policy in policies]\n                )\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 56.651535722704494}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.components.auth.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\"Unable to import %s auth provider: %s\", provider, err)\n        raise HomeAssistantError() from err\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not hass.config.skip_pip:\n        await async_process_requirements(hass, module.REQUIREMENTS, \"auth provider\")\n    processed.add(provider)\n    return module\n\n", "CodeBleu_score": 42.110842104303494}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.components.auth.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Failed to import auth provider %s: %s\",\n            provider,\n            err,\n            exc_info=True,\n        )\n        raise HomeAssistantError(\n            f\"Failed to import auth provider {provider}: {err}\"\n        ) from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not hass.config.skip_pip:\n        requirements = await async_process_requirements(\n            hass, module.REQUIREMENTS, \"auth provider\"\n        )\n        processed = hass.config.processed_requirements.get(\"auth provider\", set())\n        processed.update(requirements)\n        hass.config.processed_requirements[\"auth provider\"] = processed\n\n    return module", "CodeBleu_score": 54.56270848035911}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.components.auth.{provider}\")\n    except ImportError:\n        _LOGGER.error(\"Unable to import authentication provider %s\", provider)\n        raise HomeAssistantError()\n\n    if not hasattr(module, \"REQUIREMENTS\") or not requirements.async_process_requirements(\n        hass, module.REQUIREMENTS, \"auth provider\"\n    ):\n        return module\n\n    processed.add(module)\n    return module\n\n", "CodeBleu_score": 33.70885390263814}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    self._users = await self._store.async_load() or []\n    await self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 18.561161479518834}, {"code": "async def async_load(self) -> None\n\t\n    data = await self._store.async_load()\n    self._users = data.get(CONF_USERS, [])\n    await self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 21.51857872868482}, {"code": "async def async_load(self) -> None\n\t\n    self._users = await self._store.async_load() or []\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 18.10309638903922}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), base64.b64decode(user.password)):\n                return\n            else:\n                raise InvalidAuth()\n    bcrypt.checkpw(password.encode(), dummy_hash)\n    raise InvalidAuth()", "CodeBleu_score": 36.49230121829803}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), base64.b64decode(user.password_hash)):\n                return\n            else:\n                raise InvalidAuth(\"Invalid username or password\")\n    bcrypt.checkpw(password.encode(), dummy_hash)\n    raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 39.119721308378146}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), base64.b64decode(user.password)):\n                return\n            else:\n                raise InvalidAuth(\"Invalid username or password\")\n    bcrypt.checkpw(password.encode(), dummy_hash)\n    raise InvalidAuth(\"Invalid username or password\")\n", "CodeBleu_score": 39.10839305316066}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for index, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(index)\n            return\n    raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 35.598833594105635}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 37.1802918522876}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    try:\n        self.users.pop(self.users.index(username))\n    except ValueError:\n        raise InvalidUser(f\"user_not_found: {username}\")\n", "CodeBleu_score": 25.55859371268225}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        await self.async_initialize()\n    try:\n        self.data.users.remove(credentials.username)\n    except ValueError:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 45.931732495278034}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.initialized:\n        await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n    except KeyError:\n        pass\n    await self.async_save()\n", "CodeBleu_score": 45.43735546523537}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.initialized:\n        await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.username)\n    except UserInvalid:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 46.00761011814568}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread)\n        thread.join(timeout)\n        if thread.is_alive():\n            async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 51.287481218832866}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        thread.join(timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread)\n        async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 51.382910085643786}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        if timeout:\n            thread.join(timeout)\n        if thread.is_alive():\n            _log_thread_running_at_shutdown(thread, log)\n            async_raise(thread, SystemExit)\n    return joined\n\n", "CodeBleu_score": 46.49951116421748}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon\n    ]\n    if not threads:\n        return\n    timeout = 0.1\n    while threads and timeout <= _SHUTDOWN_TIMEOUT:\n        for thread in threads:\n            thread.join(timeout)\n            if thread.is_alive():\n                threads.remove(thread)\n            else:\n                _LOGGER.warning(\n                    \"Thread %s did not shutdown within %s seconds.\",\n                    thread.name,\n                    timeout,\n                )\n        timeout *= 2\n\n", "CodeBleu_score": 41.45558120608073}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Identify all non-main, non-daemon, alive threads\n    non_main_threads = [\n        thread\n        for thread in threading.enumerate()\n        if not thread.is_daemon() and thread is not threading.main_thread()\n    ]\n    # Calculate the timeout for each thread\n    timeout = _SHUTDOWN_TIMEOUT / len(non_main_threads)\n    # Attempt to join each thread within the calculated timeout\n    for thread in non_main_threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\n                f\"Thread {thread.name} did not terminate in time, continuing anyway\"\n            )", "CodeBleu_score": 34.0807767465962}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    remaining_threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon\n    ]\n    if remaining_threads:\n        timeout = SHUTDOWN_TIMEOUT / len(remaining_threads)\n        for thread in remaining_threads:\n            thread.join(timeout)\n            if thread.is_alive():\n                _LOGGER.warning(\n                    \"Thread %s did not shutdown within %s seconds. \"\n                    \"It will be killed.\",\n                    thread.name,\n                    timeout,\n                )\n                thread.kill()\n\n", "CodeBleu_score": 43.228031650910104}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n\n    # If there are setups remaining or the previous state was not empty,\n    # it sends an internal dispatcher signal with the remaining setups.\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self._async_dispatcher_send_internal(\n            SIGNAL_STATE_CHANGED, remaining_with_setup_started\n        )\n\n    # It then updates the internal flag to reflect whether there are remaining setups.\n    self._remaining_with_setup_started = remaining_with_setup_started\n\n", "CodeBleu_score": 51.494702424323194}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_setups:\n        self._remaining_setups = remaining_with_setup_started\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    else:\n        self._remaining_setups = None\n\n", "CodeBleu_score": 43.7261154807804}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self._remaining_with_setup_started = remaining_with_setup_started\n        self._async_dispatcher_send_internal(remaining_with_setup_started)\n    else:\n        self._remaining_with_setup_started = {}\n\n", "CodeBleu_score": 42.21063882450089}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    def generate_and_validate(integrations: dict[str, Integration], config: Config) -> None:\n        \"\"\"The function \"generate_and_validate\" generates and validates the Bluetooth content based on provided integrations and stores it in the configuration cache.", "CodeBleu_score": 16.204350321878863}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n\n    # Generate and validate the Bluetooth content based on provided integrations\n    generate_and_validate(integrations, config)\n\n    # Read the current content of bluetooth.py\n    with open(config.path(\"bluetooth.py\"), \"r\") as file:\n        current_content = file.read()\n\n    # Compare the generated content with the current content of bluetooth.py\n    if current_content!= config.content(\"bluetooth.py\"):\n        # Add an error to the configuration indicating that bluetooth.py is not up to date\n        config.add_error(\n            {\n                \"domain\": DOMAIN,\n                \"message\": \"bluetooth.py is not up to date\",\n                \"fixable\": True,\n                \"severity\": Severity.ERROR,\n                \"suggestion\": \"Run `python3 -m script.hassfest bluetooth.py` to fix this issue\",\n            }\n        )", "CodeBleu_score": 39.389598336011645}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.is_component_enabled(\"bluetooth\"):\n        _LOGGER.debug(\"Validating bluetooth.py\")\n        integrations_to_validate = {\n            integration\n            for integration in integrations\n            if integration.domain in config.components\n            and integration.domain!= \"bluetooth\"\n        }\n        if not integrations_to_validate:\n            _LOGGER.debug(\"No integrations to validate\")\n            return\n        validate_bluetooth_py(integrations_to_validate, config)\n    else:\n        _LOGGER.debug(\"Skipping bluetooth.py validation\")\n\n", "CodeBleu_score": 33.292005833900944}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp TokenResponse\n\tvar e error\n\tif err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(tokenURL); err!= nil {\n\t\treturn err\n\t}\n\tif e!= nil {\n\t\tlogger.Error(\"refresh token error\", zap.Error(e))\n\t\treturn e\n\t}\n\tif resp.AccessToken!= \"\" {\n\t\td.AccessToken = resp.AccessToken\n\t\td.RefreshToken = resp.RefreshToken\n\t\treturn nil\n\t}\n\tlogger.Info(\"refresh token response\", zap.String(\"response\", resp.String()))\n\treturn fmt.Errorf(\"refresh token failed\")\n}", "CodeBleu_score": 66.74546339200418}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp := struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}{}\n\te := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(tokenURL).Error()\n\tif e!= nil {\n\t\tlogger.Info(\"refresh token error\", zap.Error(e))\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\td.TokenType = resp.TokenType\n\td.ExpiresIn = resp.ExpiresIn\n\treturn nil\n}", "CodeBleu_score": 57.005900657900966}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tresp := struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t}{}\n\te := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(tokenURL)\n\tif e!= nil {\n\t\tlogger.Info(e.Error())\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 58.115215720011506}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R().\n\t\tSetHeader(\"Authorization\", \"Bearer \"+d.accessToken).\n\t\tSetQueryParam(\"supportsAllDrives\", \"true\").\n\t\tSetQueryParam(\"includeItemsFromAllDrives\", \"true\").\n\t\tSetQueryParam(\"corpora\", \"allDrives\")\n\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\n\tif resp!= nil {\n\t\treq.SetResult(resp)\n\t}\n\n\tres, err := req.Execute(method, url)\n\tif err!= nil {\n\t\treturn nil, fmt.Errorf(\"failed to execute request: %v\", err)\n\t}\n\n\tif res.StatusCode() == 401 {\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to refresh token: %v\", err)\n\t\t}\n\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\tif res.StatusCode() >= 400 {\n\t\treturn nil, fmt.Errorf(\"request failed with status code %d\", res.StatusCode())\n\t}\n\n\treturn res.Body(), nil\n}", "CodeBleu_score": 58.18365674469425}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.restyClient.R().SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\tif resp!= nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == 401 {\n\t\tif err := d.refreshToken(); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\tif res.StatusCode() < 200 || res.StatusCode() >= 300 {\n\t\treturn nil, fmt.Errorf(\"failed to send request to %s, status code: %d, body: %s\", url, res.StatusCode(), res.Body())\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 64.27237689475773}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R()\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\treq.SetQueryParam(\"corpora\", \"allDrives\")\n\treq.SetQueryParam(\"includeTeamDriveItems\", \"true\")\n\treq.SetQueryParam(\"enforceSingleParent\", \"true\")\n\treq.SetQueryParam(\"access_token\", d.accessToken)\n\treq.SetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.accessToken))\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\tif resp!= nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == http.StatusUnauthorized {\n\t\terr = d.refreshToken()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\tif res.StatusCode()!= http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed: %s\", res.String())\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 63.361395720468785}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size based on the file size and the maximum chunk size\n\tchunkSize := int64(math.Min(float64(stream.GetSize()), float64(MaxChunkSize)))\n\t// Initialize the start and finish positions for the first chunk\n\tstart := int64(0)\n\tfinish := start + chunkSize - 1\n\t// Loop until the entire file is uploaded\n\tfor start < stream.GetSize() {\n\t\t// Check for context cancellation\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\t// Create a new HTTP request for the current chunk\n\t\treq := d.request(ctx).SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t// Send the request and check for errors\n\t\tif _, err := req.Post(url); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\t// Update the start and finish positions for the next chunk\n\t\tstart += chunkSize\n\t\tfinish += chunkSize\n\t\t// Adjust the chunk size if it exceeds the file size\n\t\tif finish > stream.GetSize() {\n\t\t\tchunkSize = stream.GetSize() - start\n\t\t}\n\t}\n\t// Complete the upload and return nil\n\treturn nil\n}", "CodeBleu_score": 60.35722799518405}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 5\n\tfinish := 0\n\tfor finish < stream.GetSize() {\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\treq := d.request.\n\t\t\tSetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).\n\t\t\tSetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).\n\t\t\tSetContext(ctx)\n\t\tresp, err := req.Post(url)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif resp.StatusCode()!= 200 {\n\t\t\treturn errors.New(resp.String())\n\t\t}\n\t\tfinish += chunkSize\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.62176853955551}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(50 * 1024 * 1024)\n\tif stream.GetSize() < chunkSize {\n\t\tchunkSize = stream.GetSize()\n\t}\n\tfinish := int64(0)\n\tfor finish < stream.GetSize() {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\treq := d.request(ctx, \"PATCH\", url, nil)\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t\tresp, err := req.Send()\n\t\t\tif err!= nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif resp.StatusCode!= 200 {\n\t\t\t\treturn errors.New(resp.String())\n\t\t\t}\n\t\t\tfinish += chunkSize\n\t\t\tif finish+chunkSize > stream.GetSize() {\n\t\t\t\tchunkSize = stream.GetSize() - finish\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 63.230296192019786}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\n\tif err := ctx.Bind(&req); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ClientError{\n\t\t\tMsg: common_err.GetMsg(common_err.InvalidJSON),\n\t\t})\n\t}\n\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ClientError{\n\t\t\tMsg: common_err.GetMsg(common_err.InvalidMountPoint),\n\t\t})\n\t}\n\n\tif err := service.MyService.Storage().UnmountStorage(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ServiceError{\n\t\t\tMsg: common_err.GetMsg(common_err.StorageUnmountError),\n\t\t\tErr: err.Error(),\n\t\t})\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(req.MountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ServiceError{\n\t\t\tMsg: common_err.GetMsg(common_err.StorageDeleteError),\n\t\t\tErr: err.Error(),\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.Success{\n\t\tMsg: common_err.GetMsg(common_err.Success),\n\t})\n}", "CodeBleu_score": 52.38951460159335}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar data struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&data); err!= nil {\n\t\treturn common_err.NewClientError(err.Error())\n\t}\n\tif data.MountPoint == \"\" {\n\t\treturn common_err.NewClientError(\"mount_point is empty\")\n\t}\n\tif err := service.MyService.Storage().UnmountStorage(data.MountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err.Error())\n\t}\n\tif err := service.MyService.Storage().DeleteConfigByName(data.MountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 37.29832890572751}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context\n\tdata := &struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}{}\n\tif err := ctx.Bind(data); err!= nil {\n\t\treturn common_err.NewClientError(err.Error())\n\t}\n\n\t// If the mount point is empty, return a client error response\n\tif data.MountPoint == \"\" {\n\t\treturn common_err.NewClientError(\"mount point cannot be empty\")\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point\n\tif err := service.MyService.Storage().UnmountStorage(data.MountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err.Error())\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(data.MountPoint); err!= nil {\n\t\treturn common_err.NewServiceError(err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(\"storage unmounted\"))\n}", "CodeBleu_score": 37.32876711922356}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(\"Missing file path\"))\n\t}\n\n\tif!file.Exists(path) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(\"File does not exist\"))\n\t}\n\n\treturn ctx.File(path)\n}", "CodeBleu_score": 38.85865426527173}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrMissingFilePath))\n\t}\n\n\t// Check if the file exists\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 38.67390364087163}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrMissingFilePath))\n\t}\n\n\t// Check if the file exists\n\tif!file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(common_err.ErrFileNotFound))\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 39.5607102887726}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]string{\n\t\t\"message\": \"ok\",\n\t})\n}", "CodeBleu_score": 52.94031556986957}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\terr := service.MyService.Notify().SendNotify(name, message)\n\tif err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, \"Success\")\n}", "CodeBleu_score": 52.380584042899635}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrBadRequest, err.Error()))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrInternal, err.Error()))\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ErrSuccess, \"success\"))\n}", "CodeBleu_score": 58.922680139618535}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\tconnections = append(connections, ws)\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv: %s\", message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 44.28864175381177}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running\n\tif!running {\n\t\tgo sendMessages()\n\t}\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\t// If an error occurs, remove the WebSocket connection from the list of connections and break from the loop\n\t\t\tfor i, conn := range connections {\n\t\t\t\tif conn == ws {\n\t\t\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(\"Received message type:\", msgType)\n\t\tfmt.Println(\"Received message:\", string(msg))\n\t\tif err!= nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 41.02208146210041}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\tc := &connection{send: make(chan []byte, 256), ws: ws}\n\th.register <- c\n\tdefer func() { h.unregister <- c }()\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(string(message))\n\t}\n\treturn nil\n}", "CodeBleu_score": 43.382056971038296}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar err error\n\tvar systemHardwareInfo = make(map[string]interface{})\n\tvar cpuInfo = make(map[string]interface{})\n\tvar deviceTree = make(map[string]interface{})\n\tvar cpuInfoAvailable bool\n\n\t// Get CPU information\n\tcpuInfo, cpuInfoAvailable = service.MyService.System().GetCpuInfo()\n\tif cpuInfoAvailable {\n\t\tsystemHardwareInfo[\"cpuInfo\"] = cpuInfo\n\t}\n\n\t// Get device tree\n\tdeviceTree, err = service.MyService.System().GetDeviceTree()\n\tif err!= nil {\n\t\tsystemHardwareInfo[\"deviceTree\"] = nil\n\t} else {\n\t\tsystemHardwareInfo[\"deviceTree\"] = deviceTree\n\t}\n\n\t// Get drive model\n\tsystemHardwareInfo[\"driveModel\"], err = service.MyService.System().GetDriveModel()\n\tif err!= nil {\n\t\tsystemHardwareInfo[\"driveModel\"] = nil\n\t}\n\n\t// Get architecture\n\tsystemHardwareInfo[\"architecture\"], err = service.MyService.System().GetArchitecture()\n\tif err!= nil {\n\t\tsystemHardwareInfo[\"architecture\"] = nil\n\t}\n\n\t// Return JSON response\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\": \"System hardware information retrieved successfully.\",\n\t\t\"data\":    systemHardwareInfo,\n\t})\n}", "CodeBleu_score": 32.916701202044194}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar driveModel string\n\tvar driveArchitecture string\n\tvar cpuInfo *common_err.CPUInfo\n\n\tif runtime.GOOS == \"windows\" {\n\t\tdriveModel, driveArchitecture = GetSystemDriveInfo()\n\t}\n\n\tif runtime.GOOS == \"linux\" {\n\t\tcpuInfo = GetCpuInfo()\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\":           \"System hardware information retrieved successfully\",\n\t\t\"drive_model\":       driveModel,\n\t\t\"drive_architecture\": driveArchitecture,\n\t\t\"cpu_info\":          cpuInfo,\n\t})\n}", "CodeBleu_score": 22.400853107724323}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar err error\n\tvar cpuInfo string\n\tvar cpuInfoAvailable bool\n\tvar cpuInfoErr error\n\n\t// Get CPU information\n\tcpuInfo, cpuInfoErr = service.MyService.System().GetCpuInfo()\n\tif cpuInfoErr!= nil {\n\t\tcpuInfoAvailable = false\n\t} else {\n\t\tcpuInfoAvailable = true\n\t}\n\n\t// Get drive model\n\tdriveModel, driveModelErr := service.MyService.System().GetDriveModel()\n\tif driveModelErr!= nil {\n\t\tdriveModel = \"unknown\"\n\t}\n\n\t// Get architecture\n\tarchitecture, architectureErr := service.MyService.System().GetArchitecture()\n\tif architectureErr!= nil {\n\t\tarchitecture = \"unknown\"\n\t}\n\n\t// Prepare response\n\tif cpuInfoAvailable {\n\t\tresponse := struct {\n\t\t\tMessage string `json:\"message\"`\n\t\t\tCpuInfo string `json:\"cpuInfo\"`\n\t\t\tDrive   string `json:\"drive\"`\n\t\t\tArch    string `json:\"arch\"`\n\t\t}{\n\t\t\tMessage: common_err.GetMsg(\"success\"),\n\t\t\tCpuInfo: cpuInfo,\n\t\t\tDrive:   driveModel,\n\t\t\tArch:    architecture,\n\t\t}\n\t\treturn ctx.JSON(http.StatusOK, response)\n\t} else {\n\t\tresponse := struct {\n\t\t\tMessage string `json:\"message\"`\n\t\t\tCpuInfo string `json:\"cpuInfo\"`\n\t\t\tDrive   string `json:\"drive\"`\n\t\t\tArch    string `json:\"arch\"`\n\t\t}{\n\t\t\tMessage: common_err.GetMsg(\"success\"),\n\t\t\tCpuInfo: \"nil\",\n\t\t\tDrive:   driveModel,\n\t\t\tArch:    architecture,\n\t\t}\n\t\treturn ctx.JSON(http.StatusOK, response)\n\t}\n}", "CodeBleu_score": 31.920835737179093}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif strings.Contains(service, \"active\") {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 60.5972469371378}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tlist, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tvar running, notRunning []string\n\n\tfor _, service := range list {\n\t\tif service.SubState == \"running\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 77.33799912743649}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.listServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 70.97129413663303}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to marshal message\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\n\tresponse, err := i.MessageBus().PublishEventWithResponse(context.Background(), name, jsonMessage)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Int(\"status\", response.StatusCode), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 41.27701369736831}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tlogger := i.logger.With(zap.String(\"name\", name))\n\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to marshal message\", zap.Error(err))\n\t\treturn\n\t}\n\tresponse, err := i.MessageBus().PublishEventWithResponse(name, jsonMessage)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode!= http.StatusOK {\n\t\tlogger.Error(\"Failed to publish event\", zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 41.320035943997574}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Marshal the message values to JSON strings\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\ti.logger.Error(\"Failed to marshal message\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus\n\tresponse, err := i.service.MessageBus().PublishEventWithResponse(context.Background(), \"notify\", name, messageJSON)\n\tif err!= nil {\n\t\ti.logger.Error(\"Failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Log any errors that occur during publishing\n\tif response.StatusCode!= http.StatusOK {\n\t\ti.logger.Error(\"Failed to publish event\", zap.String(\"status\", response.Status), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 43.04891130556072}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Get the message bus address\n\taddress := c.external.GetMessageBusAddress()\n\n\t// Initialize the message bus client\n\tclient := message_bus.NewClientWithResponses(c.ctx)\n\n\t// Set the server address for the message bus client\n\tif address!= \"\" {\n\t\tclient.SetServer(address)\n\t} else {\n\t\tclient.SetServer(\"Error: message bus address not found\")\n\t}\n\n\treturn client\n}", "CodeBleu_score": 25.629117609743158}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.messageBusClient == nil {\n\t\tc.messageBusClient = message_bus.NewClientWithResponses()\n\t\tif address, err := c.external.GetMessageBusAddress(); err!= nil {\n\t\t\tc.messageBusClient.SetServer(fmt.Sprintf(\"error: %v\", err))\n\t\t} else {\n\t\t\tc.messageBusClient.SetServer(address)\n\t\t}\n\t}\n\treturn c.messageBusClient\n}", "CodeBleu_score": 36.552947222198746}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\terr := client.Initialize(c.runtimePath)\n\tif err!= nil {\n\t\tclient.SetServer(err.Error())\n\t}\n\treturn client\n}", "CodeBleu_score": 21.49014067801729}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.44245846638746}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.44245846638746}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.44245846638746}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesDir := filepath.Join(c.config.ModulesDir, \"system\")\n\tentryPath := filepath.Join(modulesDir, \"entry.json\")\n\n\tif _, err := os.Stat(entryPath); os.IsNotExist(err) {\n\t\tif err := os.MkdirAll(modulesDir, 0755); err!= nil {\n\t\t\tlogger.Error(\"failed to create system module directory\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\n\t\tif err := os.WriteFile(entryPath, []byte(\"[]\"), 0644); err!= nil {\n\t\t\tlogger.Error(\"failed to create system entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\tentries := []byte(\"[]\")\n\tif err := filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"failed to walk system module directory\", zap.Error(err))\n\t\t\treturn err\n\t\t}\n\n\t\tif info.IsDir() || info.Name()!= \"entry.json\" {\n\t\t\treturn nil\n\t\t}\n\n\t\tdata, err := os.ReadFile(path)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"failed to read system entry file\", zap.Error(err))\n\t\t\treturn err\n\t\t}\n\n\t\tentries = append(entries, data[1:]...)\n\t\treturn nil\n\t}); err!= nil {\n\t\tlogger.Error(\"failed to walk system module directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\tif err := os.WriteFile(entryPath, entries, 0644); err!= nil {\n\t\tlogger.Error(\"failed to write system entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 42.25907258977949}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesPath := filepath.Join(c.config.ModulesPath, \"system\", \"modules\")\n\tentryFilePath := filepath.Join(c.config.ModulesPath, \"system\", \"entry.json\")\n\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tif err := os.Create(entryFilePath); err!= nil {\n\t\t\tlogger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\tvar entries []byte\n\n\tmodules, err := os.ReadDir(modulesPath)\n\tif err!= nil {\n\t\tlogger.Error(\"Failed to read modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\tfor _, module := range modules {\n\t\tentryPath := filepath.Join(modulesPath, module.Name(), \"entry.json\")\n\t\tentry, err := os.ReadFile(entryPath)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, entry...)\n\t}\n\n\tentries = append(entries, ']')\n\n\tif err := os.WriteFile(entryFilePath, entries, 0644); err!= nil {\n\t\tlogger.Error(\"Failed to write entry file\", zap.Error(err))\n\t}\n}", "CodeBleu_score": 45.493179412004814}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesDir := filepath.Join(c.config.RootDir, \"modules\")\n\tentryFile := filepath.Join(modulesDir, \"entry.json\")\n\tif!file.IsNotExistCreateFile(entryFile) {\n\t\treturn\n\t}\n\tvar entries []map[string]interface{}\n\tdirs, err := os.ReadDir(modulesDir)\n\tif err!= nil {\n\t\tlogger.Error(\"read modules dir error\", zap.Error(err))\n\t\treturn\n\t}\n\tfor _, v := range dirs {\n\t\tif!v.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tentry := filepath.Join(modulesDir, v.Name(), \"entry.json\")\n\t\tcontent, err := os.ReadFile(entry)\n\t\tif err!= nil {\n\t\t\tlogger.Error(\"read entry file error\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tvar entryMap map[string]interface{}\n\t\tif err := json.Unmarshal(content, &entryMap); err!= nil {\n\t\t\tlogger.Error(\"unmarshal entry file error\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tentries = append(entries, entryMap)\n\t}\n\tentryContent, err := json.Marshal(entries)\n\tif err!= nil {\n\t\tlogger.Error(\"marshal entry file error\", zap.Error(err))\n\t\treturn\n\t}\n\tif err := os.WriteFile(entryFile, entryContent, 0644); err!= nil {\n\t\tlogger.Error(\"write entry file error\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 50.20991124545808}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tnetworks, err := c.GetNet()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range ifaces {\n\t\tfor _, network := range networks {\n\t\t\tif iface.Name == network {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 57.28258415904314}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tnetworkNames, err := c.GetNet()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\tif strings.Contains(iface.Name, name) {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 59.284124351344516}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.GetNet()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\tif strings.HasPrefix(iface.Name, name) {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 59.254867719937764}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t ret = TSDB_CODE_SUCCESS;\n\tSAppObj *pAppObj = pTscObj->pAppObj;\n\n\t// add reference\n\tatomic_add_fetch_32(&pRequest->ref, 1);\n\n\t// add request count\n\tatomic_add_fetch_32(&pTscObj->requestCnt, 1);\n\n\t// add application request count\n\tif (pAppObj!= NULL) {\n\t\tatomic_add_fetch_32(&pAppObj->requestCnt, 1);\n\t\tatomic_add_fetch_32(&pAppObj->curRequestCnt, 1);\n\t}\n\n\t// log debug information\n\tif (g_tscDebug) {\n\t\tLOG_INFO(\"register request: %s, %s, %d, %d, %d, %d\", pTscObj->name, pRequest->name, pTscObj->requestCnt, pTscObj->curRequestCnt, pAppObj!= NULL? pAppObj->requestCnt : 0, pAppObj!= NULL? pAppObj->curRequestCnt : 0);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 42.97463070470744}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc;\n\tSApplicationInfo *pAppInfo;\n\n\trc = tscAddRef(pTscObj);\n\tif (rc!= TSDB_CODE_SUCCESS) {\n\t\treturn rc;\n\t}\n\n\tpAppInfo = pTscObj->pAppInfo;\n\tif (pAppInfo!= NULL) {\n\t\tpAppInfo->reqCnt++;\n\t\tpAppInfo->curReqCnt++;\n\t}\n\n\tpRequest->pTscObj = pTscObj;\n\tpRequest->pPrev = NULL;\n\tpRequest->pNext = NULL;\n\n\tif (pTscObj->pFirstRequest == NULL) {\n\t\tpTscObj->pFirstRequest = pRequest;\n\t\tpTscObj->pLastRequest = pRequest;\n\t} else {\n\t\tpTscObj->pLastRequest->pNext = pRequest;\n\t\tpRequest->pPrev = pTscObj->pLastRequest;\n\t\tpTscObj->pLastRequest = pRequest;\n\t}\n\n\ttscDebug(pTscObj, \"new request %p registered\", pRequest);\n\treturn TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 41.234725151691705}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = TSDB_CODE_SUCCESS;\n\n\t/* add a reference to the request object */\n\tatomic_add_fetch_32(&pRequest->refCount, 1);\n\n\t/* update request count for the TSC object */\n\tatomic_add_fetch_32(&pTscObj->requestCount, 1);\n\n\t/* update application request summary */\n\tif (pTscObj->appInfo!= NULL) {\n\t\t/* update total request count */\n\t\tatomic_add_fetch_64(&pTscObj->appInfo->totalRequestCount, 1);\n\n\t\t/* update current request count */\n\t\tatomic_add_fetch_64(&pTscObj->appInfo->currentRequestCount, 1);\n\t}\n\n\t/* log debug information */\n\tif (g_debug) {\n\t\tLOG_INFO(\"register a new request, request id = %d, request count = %d\", pRequest->requestId, pTscObj->requestCount);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 34.6171675959321}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->db && strcmp(pRequest->db, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\tif (pRequest->dbs) {\n\t\tchar *pDb = pRequest->dbs;\n\t\twhile (pDb && *pDb) {\n\t\t\tif (pDb[0] == '@') {\n\t\t\t\tpDb++;\n\t\t\t}\n\t\t\tif (strcmp(pDb, exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpDb += strlen(pDb) + 1;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 47.57284572949335}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb = NULL;\n\tchar *pDbEnd = NULL;\n\tchar *pDbStart = NULL;\n\tchar *pSchema = NULL;\n\tchar *pSchemaEnd = NULL;\n\tchar *pSchemaStart = NULL;\n\tchar *pTmp = NULL;\n\tchar *pTmp2 = NULL;\n\tchar *pTmp3 = NULL;\n\tchar *pTmp4 = NULL;\n\tchar *pTmp5 = NULL;\n\tchar *pTmp6 = NULL;\n\tchar *pTmp7 = NULL;\n\tchar *pTmp8 = NULL;\n\tchar *pTmp9 = NULL;\n\tchar *pTmp10 = NULL;\n\tchar *pTmp11 = NULL;\n\tchar *pTmp12 = NULL;\n\tchar *pTmp13 = NULL;\n\tchar *pTmp14 = NULL;\n\tchar *pTmp15 = NULL;\n\tchar *pTmp16 = NULL;\n\tchar *pTmp17 = NULL;\n\tchar *pTmp18 = NULL;\n\tchar *pTmp19 = NULL;\n\tchar *pTmp20 = NULL;\n\tchar *pTmp21 = NULL;\n\tchar *pTmp22 = NULL;\n\tchar *pTmp23 = NULL;\n\tchar *pTmp24 = NULL;\n\tchar *pTmp25 = NULL;\n\tchar *pTmp26 = NULL;\n\tchar *pTmp27 = NULL;\n\tchar *pTmp28 = NULL;\n\tchar *pTmp29 = NULL;\n\tchar *pTmp30 = NULL;\n\tchar *pTmp31 = NULL;\n\tchar *pTmp32 = NULL;\n\tchar *pTmp33 = NULL;\n\tchar *pTmp34 = NULL;\n\tchar *pTmp35 = NULL;\n\tchar *pTmp36 = NULL;\n\tchar *pTmp37 = NULL;\n\tchar *pTmp38 = NULL;\n\tchar *pTmp39 = NULL;\n\tchar *pTmp40 = NULL;\n\tchar *pTmp41 = NULL;\n\tchar *pTmp42 = NULL;\n\tchar", "CodeBleu_score": 6.056058714897607}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest == NULL) {\n\t\treturn false;\n\t}\n\n\tif (pRequest->pDb!= NULL && strcmp(pRequest->pDb, exceptDb)!= 0) {\n\t\treturn true;\n\t}\n\n\tif (pRequest->pDbList!= NULL) {\n\t\tSRequestDb *pDb = pRequest->pDbList;\n\t\twhile (pDb!= NULL) {\n\t\t\tif (pDb->pDb!= NULL && strcmp(pDb->pDb, exceptDb)!= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tpDb = pDb->next;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 43.02994375115705}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == RPC_NEED_REDIRECT_ERROR) {\n\t\tif (msgType == TMSG_CLIENT_RPC || msgType == TMSG_CLIENT_RPC_NO_ACK || msgType == TMSG_CLIENT_RPC_NO_RESP || msgType == TMSG_CLIENT_RPC_NO_ACK_NO_RESP) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 52.81086026730113}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool ret = false;\n\n\tif (code == REDIRECT_ERROR) {\n\t\tswitch (msgType) {\n\t\tcase tmsg_t::T_RPC_REQUEST:\n\t\tcase tmsg_t::T_RPC_RESPONSE:\n\t\tcase tmsg_t::T_RPC_ERROR:\n\t\tcase tmsg_t::T_RPC_REDIRECT:\n\t\tcase tmsg_t::T_RPC_REDIRECT_ACK:\n\t\tcase tmsg_t::T_RPC_PING:\n\t\tcase tmsg_t::T_RPC_PONG:\n\t\tcase tmsg_t::T_RPC_REDIRECT_ERROR:\n\t\t\tret = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 31.66513312085137}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == E_NEED_REDIRECT_ERROR) {\n\t\tif (msgType == TMSG_RPC_REQUEST || msgType == TMSG_RPC_REQUEST_NO_REPLY || msgType == TMSG_RPC_REQUEST_NO_REPLY_NO_LOCK) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 48.16747377579065}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSRequest *pRequest;\n\tSHashObj *pHash;\n\tSHashCell *pCell;\n\tSHashIter iter;\n\tint id;\n\n\tpHash = pRequests;\n\tif (pHash == NULL)\n\t\treturn;\n\n\thashIterInit(&iter, pHash);\n\twhile ((pCell = hashIterNext(&iter))!= NULL) {\n\t\tid = (int) (size_t) pCell->key;\n\t\tpRequest = (SRequest *) pCell->data;\n\t\tif (pRequest == NULL)\n\t\t\tcontinue;\n\n\t\tif (acquireRequest(pRequests, id) == 0)\n\t\t\tcontinue;\n\n\t\tif (pRequest->pQuery!= NULL)\n\t\t\ttaos_stop_query(pRequest->pQuery);\n\n\t\treleaseRequest(pRequests, id);\n\t}\n}", "CodeBleu_score": 41.845528815725196}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\ttaos_mutex_lock(&pRequests->mutex);\n\n\tSHashEntry *pEntry = NULL;\n\tSHashEntry *pTemp  = NULL;\n\tSHashEntry *pHead  = pRequests->pHead;\n\twhile (pHead!= NULL) {\n\t\tpEntry = pHead;\n\t\twhile (pEntry!= NULL) {\n\t\t\tpTemp = pEntry;\n\t\t\tpEntry = pEntry->pNext;\n\n\t\t\ttaos_mutex_lock(&pTemp->mutex);\n\n\t\t\tif (pTemp->pRequest == NULL) {\n\t\t\t\ttaos_mutex_unlock(&pTemp->mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pTemp->pRequest->pQuery!= NULL) {\n\t\t\t\ttaos_stop_query(pTemp->pRequest->pQuery);\n\t\t\t}\n\n\t\t\ttaos_mutex_unlock(&pTemp->mutex);\n\t\t}\n\n\t\tpHead = pHead->pNext;\n\t}\n\n\ttaos_mutex_unlock(&pRequests->mutex);\n}", "CodeBleu_score": 33.21174426444774}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\tint i = 0;\n\tint n = 0;\n\tint nReqID = 0;\n\tint nReqID2 = 0;\n\tint nReqID3 = 0;\n\tint nReqID4 = 0;\n\tint nReqID5 = 0;\n\tint nReqID6 = 0;\n\tint nReqID7 = 0;\n\tint nReqID8 = 0;\n\tint nReqID9 = 0;\n\tint nReqID10 = 0;\n\tint nReqID11 = 0;\n\tint nReqID12 = 0;\n\tint nReqID13 = 0;\n\tint nReqID14 = 0;\n\tint nReqID15 = 0;\n\tint nReqID16 = 0;\n\tint nReqID17 = 0;\n\tint nReqID18 = 0;\n\tint nReqID19 = 0;\n\tint nReqID20 = 0;\n\tint nReqID21 = 0;\n\tint nReqID22 = 0;\n\tint nReqID23 = 0;\n\tint nReqID24 = 0;\n\tint nReqID25 = 0;\n\tint nReqID26 = 0;\n\tint nReqID27 = 0;\n\tint nReqID28 = 0;\n\tint nReqID29 = 0;\n\tint nReqID30 = 0;\n\tint nReqID31 = 0;\n\tint nReqID32 = 0;\n\tint nReqID33 = 0;\n\tint nReqID34 = 0;\n\tint nReqID35 = 0;\n\tint nReqID36 = 0;\n\tint nReqID37 = 0;\n\tint nReqID38 = 0;\n\tint nReqID39 = 0;\n\tint nReqID40 = 0;\n\tint nReqID41 = ", "CodeBleu_score": 8.64594271337951}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (tsc_crash_report_enabled == 0) {\n\t\treturn;\n\t}\n\n\tint32_t oldVal = 1;\n\tif (atomic_val_compare_exchange_32(&tsc_client_stop, &oldVal, 0) == 0) {\n\t\tprintf(\"tscStopCrashReport: Crash report thread is already stopped.\n\");\n\t\treturn;\n\t}\n\n\twhile (tsc_client_stop!= 0) {\n\t\ttaosMsleep(100);\n\t}\n}", "CodeBleu_score": 49.9673492458939}, {"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportEnabled == 0) {\n\t\treturn;\n\t}\n\tif (atomic_val_compare_exchange_32(&tscCrashReportClientStop, 0, 1) == 0) {\n\t\twhile (tscCrashReportClientStop == 1) {\n\t\t\ttaosMsleep(1000);\n\t\t}\n\t} else {\n\t\ttaosLogInfo(g_crashReportLogger, \"Crash report thread is already stopped\");\n\t}\n}", "CodeBleu_score": 46.13601918188181}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&tscClientStop, 0, 1) == 0) {\n\t\treturn;\n\t}\n\n\twhile (tscClientStop) {\n\t\ttaosMsleep(100);\n\t}\n}", "CodeBleu_score": 48.34880991507067}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t    i;\n\tint32_t    ret;\n\tint32_t    cnt;\n\tint32_t    num;\n\tint32_t    size;\n\tint32_t    numCol;\n\tint32_t    numCol1;\n\tint32_t    numCol2;\n\tint32_t    numCol3;\n\tint32_t    numCol4;\n\tint32_t    numCol5;\n\tint32_t    numCol6;\n\tint32_t    numCol7;\n\tint32_t    numCol8;\n\tint32_t    numCol9;\n\tint32_t    numCol10;\n\tint32_t    numCol11;\n\tint32_t    numCol12;\n\tint32_t    numCol13;\n\tint32_t    numCol14;\n\tint32_t    numCol15;\n\tint32_t    numCol16;\n\tint32_t    numCol17;\n\tint32_t    numCol18;\n\tint32_t    numCol19;\n\tint32_t    numCol20;\n\tint32_t    numCol21;\n\tint32_t    numCol22;\n\tint32_t    numCol23;\n\tint32_t    numCol24;\n\tint32_t    numCol25;\n\tint32_t    numCol26;\n\tint32_t    numCol27;\n\tint32_t    numCol28;\n\tint32_t    numCol29;\n\tint32_t    numCol30;\n\tint32_t    numCol31;\n\tint32_t    numCol32;\n\tint32_t    numCol33;\n\tint32_t    numCol34;\n\tint32_t    numCol35;\n\tint32_", "CodeBleu_score": 7.644652968399315}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t          ret;\n\tSViewMetaArray * pViewMetaArray = NULL;\n\tSViewMeta      * pViewMeta      = NULL;\n\tSMetaField     * pMetaField     = NULL;\n\tSViewMeta      * pViewMetaNew   = NULL;\n\tSMetaField     * pMetaFieldNew  = NULL;\n\tint32_t          i, j;\n\n\tif (value == NULL || valueLen <= 0 || pCatalog == NULL) {\n\t\treturn TSDB_CODE_INVALID_PARAMETER;\n\t}\n\n\tpViewMetaArray = tDeserializeSViewHbRsp(value, valueLen);\n\tif (pViewMetaArray == NULL) {\n\t\treturn TSDB_CODE_DESERIALIZE_FAILED;\n\t}\n\n\tfor (i = 0; i < pViewMetaArray->num; i++) {\n\t\tpViewMeta = &pViewMetaArray->array[i];\n\t\tif (pViewMeta->numFields <= 0) {\n\t\t\tcatalogRemoveViewMeta(pCatalog, pViewMeta->name);\n\t\t} else {\n\t\t\tpViewMetaNew = catalogUpdateViewMeta(pCatalog, pViewMeta->name, pViewMeta->numFields, pViewMeta->fields, pViewMeta->tags);\n\t\t\tif (pViewMetaNew == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < pViewMetaNew->numFields; j++) {\n\t\t\t\tpMetaField     = &pViewMeta->fields[j];\n\t\t\t\tpMetaFieldNew  = &pViewMetaNew->fields[j];\n\n\t\t\t\tif (pMetaField->type!= pMetaFieldNew->type) {\n\t\t\t\t\tpMetaFieldNew->type = pMetaField->type;\n\t\t\t\t}\n\n\t\t\t\tif (pMetaField->flag!= pMetaFieldNew->flag) {\n\t\t\t\t\tpMetaFieldNew->flag = pMetaField->flag;\n\t\t\t\t}\n\n\t\t\t\tif (pMetaField->size!= pMetaFieldNew->size) {\n\t\t\t\t\tpMetaFieldNew->size = pMetaField->size;\n\t\t\t\t}\n\n\t\t\t\tif (pMetaField->scale!= pMetaFieldNew->scale) {\n\t\t\t\t\tpMetaFieldNew->scale = pMetaField->scale;\n\t\t\t\t}\n\t\t\t}\n\t", "CodeBleu_score": 32.83930673628075}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t   ret;\n\tchar      *p;\n\tint32_t   viewCnt;\n\tint32_t   i;\n\tSViewMeta *pViewMeta;\n\tSArray    *pArray;\n\tSViewMeta *pViewMetaRsp;\n\tSMetaInfo *pMetaInfo;\n\n\tpArray = tDeserializeSViewHbRsp(value, valueLen);\n\tif (pArray == NULL) {\n\t\ttsErr(\"Failed to deserialize view heartbeat response\");\n\t\treturn TSDB_CODE_DESERIALIZE_ERR;\n\t}\n\n\tviewCnt = taosArrayGetSize(pArray);\n\tfor (i = 0; i < viewCnt; ++i) {\n\t\tpViewMetaRsp = (SViewMeta *)taosArrayGetP(pArray, i);\n\t\tif (pViewMetaRsp == NULL) {\n\t\t\ttsErr(\"Failed to get view meta from view heartbeat response\");\n\t\t\tret = TSDB_CODE_DESERIALIZE_ERR;\n\t\t\tgoto clean;\n\t\t}\n\n\t\tif (pViewMetaRsp->colCnt == 0) {\n\t\t\tcatalogRemoveViewMeta(pCatalog, pViewMetaRsp->viewName);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpViewMeta = catalogGetViewMeta(pCatalog, pViewMetaRsp->viewName);\n\t\tif (pViewMeta == NULL) {\n\t\t\tpViewMeta = catalogAddViewMeta(pCatalog, pViewMetaRsp);\n\t\t\tif (pViewMeta == NULL) {\n\t\t\t\ttsErr(\"Failed to add view meta\");\n\t\t\t\tret = TSDB_CODE_DESERIALIZE_ERR;\n\t\t\t\tgoto clean;\n\t\t\t}\n\n\t\t\tpMetaInfo = catalogGetMetaInfo(pCatalog, pViewMetaRsp->viewName);\n\t\t\tif (pMetaInfo == NULL) {\n\t\t\t\ttsErr(\"Failed to get meta info\");\n\t\t\t\tret = TSDB_CODE_DESERIALIZE_ERR;\n\t\t\t\tgoto clean;\n\t\t\t}\n\n\t\t\tpMetaInfo->viewMeta = pViewMeta;\n\t\t} else {\n\t\t\tret = catalogUpdateViewMeta(pViewMeta, pViewMetaRsp);\n\t\t\tif (ret!= TSDB_CODE_SUCCESS) {\n\t\t\t\ttsErr(\"Failed to update view meta\");\n\t\t\t\tgoto clean;\n\t\t\t}\n\t", "CodeBleu_score": 33.62589768685371}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tstruct CallbackData *data = (struct CallbackData *) callbackData;\n\tdata->contentLength = properties->contentLength;\n\treturn S3StatusOK;\n}", "CodeBleu_score": 50.504017212735164}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\t((S3CallbackData *)callbackData)->contentLength = properties->contentLength;\n\treturn S3StatusOK;\n}", "CodeBleu_score": 46.01839268594029}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tstruct CallbackData *data = (struct CallbackData *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\n\treturn S3StatusOK;\n}", "CodeBleu_score": 76.2935826066012}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tuDebug(\"Starting Rsync server\");\n\tif (taosMulMkDir(checkpointBackupDir, 0755)!= 0) {\n\t\tuError(\"Failed to create checkpoint backup directory: %s\", checkpointBackupDir);\n\t} else {\n\t\tremoveEmptyDir(checkpointBackupDir);\n\t\tif (generateConfigFile(checkpointBackupDir, RSYNC_CONFIG_FILE) == 0) {\n\t\t\tchar cmd[1024];\n\t\t\tsnprintf(cmd, sizeof(cmd), \"rsync --daemon --config=%s --port=%d\", RSYNC_CONFIG_FILE, RSYNC_PORT);\n\t\t\tif (system(cmd) == 0) {\n\t\t\t\tuDebug(\"Rsync server started successfully\");\n\t\t\t} else {\n\t\t\t\tuError(\"Failed to start Rsync server\");\n\t\t\t}\n\t\t} else {\n\t\t\tuError(\"Failed to generate Rsync configuration file\");\n\t\t}\n\t}\n}", "CodeBleu_score": 29.174445647787316}, {"code": "void startRsync(){\n\t\tint ret;\n\tchar cmd[512];\n\tchar configFile[128];\n\tchar logFile[128];\n\tchar pidFile[128];\n\n\tsnprintf(configFile, sizeof(configFile), \"%s/%s\", g_config.checkpointDir, \"rsyncd.conf\");\n\tsnprintf(logFile, sizeof(logFile), \"%s/%s\", g_config.checkpointDir, \"rsyncd.log\");\n\tsnprintf(pidFile, sizeof(pidFile), \"%s/%s\", g_config.checkpointDir, \"rsyncd.pid\");\n\n\tret = taosMulMkDir(g_config.checkpointDir, 0755);\n\tif (ret!= 0) {\n\t\tuError(\"Failed to create checkpoint backup directory: %s\", g_config.checkpointDir);\n\t\treturn;\n\t}\n\n\tremoveEmptyDir(g_config.checkpointDir);\n\n\tif (!generateConfigFile(configFile)) {\n\t\tuError(\"Failed to generate Rsync configuration file: %s\", configFile);\n\t\treturn;\n\t}\n\n\tsnprintf(cmd, sizeof(cmd), \"rsync --daemon --port=%d --config=%s --log-file=%s --pid-file=%s\", g_config.rsyncPort, configFile, logFile, pidFile);\n\n\tret = system(cmd);\n\tif (ret!= 0) {\n\t\tuError(\"Failed to start Rsync server: %s\", cmd);\n\t} else {\n\t\tuDebug(\"Rsync server started successfully\");\n\t}\n}", "CodeBleu_score": 41.907539183352284}, {"code": "void startRsync(){\n\t\tuDebug(\"Starting Rsync server\");\n\tif (taosMulMkDir(g_backup_dir)!= 0) {\n\t\tuError(\"Failed to create backup directory\");\n\t}\n\tremoveEmptyDir(g_backup_dir);\n\tgenerateConfigFile();\n\tchar cmd[MAX_CMD_LEN] = {0};\n\tsnprintf(cmd, MAX_CMD_LEN, \"rsync --daemon --config=%s --port=%d\", g_rsync_conf_file, g_rsync_port);\n\tsystem(cmd);\n\tif (g_rsync_pid == 0) {\n\t\tuError(\"Failed to start Rsync server\");\n\t} else {\n\t\tuDebug(\"Rsync server started\");\n\t}\n}", "CodeBleu_score": 34.61795282140773}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).getExecutor().shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not registered.\");\n\t}\n}", "CodeBleu_score": 47.66004922682534}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n\tdispatcher.getExecutor().shutdownNow();\n}", "CodeBleu_score": 66.25454516303184}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId)\n\tif (dispatcher!= null) {\n\t\tdispatcher.shutdownNow()\n\t\tdispatchers.remove(dispatcherId)\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" not found\")\n\t}\n}", "CodeBleu_score": 60.40349101264984}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tTbActorId[] children = parent.getChildren();\n\tif (children == null) {\n\t\twarn(\"Parent \" + parent + \" has no children\");\n\t\treturn;\n\t}\n\tfor (TbActorId child : children) {\n\t\tif (childFilter.test(child)) {\n\t\t\ttry {\n\t\t\t\tif (highPriority) {\n\t\t\t\t\tsendHighPriority(child, msg);\n\t\t\t\t} else {\n\t\t\t\t\tsend(child, msg);\n\t\t\t\t}\n\t\t\t} catch (TbActorId.NotRegisteredException e) {\n\t\t\t\twarn(\"Child \" + child + \" is not registered\");\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.76658861002806}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tif (parent == null) {\n\t\tthrow new IllegalArgumentException(\"parent\");\n\t}\n\tif (childFilter == null) {\n\t\tthrow new IllegalArgumentException(\"childFilter\");\n\t}\n\tif (msg == null) {\n\t\tthrow new IllegalArgumentException(\"msg\");\n\t}\n\tSet<TbActorId> children = childrenMap.get(parent);\n\tif (children!= null) {\n\t\tfor (TbActorId child : children) {\n\t\t\tif (childFilter.test(child)) {\n\t\t\t\tif (actors.containsKey(child)) {\n\t\t\t\t\tif (highPriority) {\n\t\t\t\t\t\tactors.get(child).send(msg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactors.get(child).sendLow(msg);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twarn(\"broadcastToChildren: child not registered: \" + child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.839486014853776}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tTbActorId[] children = parent.children.toArray(new TbActorId[0]);\n\tfor (TbActorId child : children) {\n\t\tif (childFilter.test(child)) {\n\t\t\tif (child.registered) {\n\t\t\t\tif (highPriority) {\n\t\t\t\t\tchild.sendHigh(msg);\n\t\t\t\t} else {\n\t\t\t\t\tchild.send(msg);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twarn(\"broadcastToChildren: child not registered: \" + child);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.58270483970297}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (msg.getType() == TbActorMsg.RULE_NODE_UPDATED_MSG &&!highPriority) {\n\t\tif (msg.getRuleNode().getRule()!= null &&!msg.getRuleNode().getRule().isInitialized()) {\n\t\t\tmsg.getRuleNode().getRule().initialize();\n\t\t}\n\t}\n\tif (msg.getType() == TbActorMsg.RULE_NODE_UPDATED_MSG &&!highPriority) {\n\t\tif (msg.getRuleNode().getRule()!= null &&!msg.getRuleNode().getRule().isInitialized()) {\n\t\t\tmsg.getRuleNode().getRule().initialize();\n\t\t}\n\t}\n\tif (msg.getType() == TbActorMsg.RULE_NODE_UPDATED_MSG &&!highPriority) {\n\t\tif (msg.getRuleNode().getRule()!= null &&!msg.getRuleNode().getRule().isInitialized()) {\n\t\t\tmsg.getRuleNode().getRule().initialize();\n\t\t}\n\t}\n\tif (msg.getType() == TbActorMsg.RULE_NODE_UPDATED_MSG &&!highPriority) {\n\t\tif (msg.getRuleNode().getRule()!= null &&!msg.getRuleNode().getRule().isInitialized()) {\n\t\t\tmsg.getRuleNode().getRule().initialize();\n\t\t}\n\t}\n\tif (msg.getType() == TbActorMsg.RULE_NODE_UPDATED_MSG &&!highPriority) {\n\t\tif (msg.getRuleNode().getRule()!= null &&!msg.getRuleNode().getRule().isInitialized()) {\n\t\t\tmsg.getRuleNode().getRule().initialize();\n\t\t}\n\t}\n\tif (msg.getType() == TbActorMsg.RULE_NODE_UPDATED_MSG &&!highPriority) {\n\t\tif (msg.getRuleNode().getRule()!= null &&!msg.getRuleNode().getRule().isInitialized()) {\n\t\t\tmsg.getRuleNode().getRule().initialize();\n\t\t}\n\t}\n\tif (msg.getType() == TbActorMsg.RULE_NODE_UPDATED_MSG &&!highPriority) {\n\t\tif (msg.getRuleNode().getRule()!= null &&!msg.getRuleNode().getRule().isInitialized()) {\n\t\t\tmsg.getRuleNode", "CodeBleu_score": 30.87309279275148}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (destructionInProgress) {\n\t\tif (msg.getMsgType() == TbActorMsg.RULE_NODE_UPDATED_MSG && highPriority) {\n\t\t\tif (initActor) {\n\t\t\t\tinitActor = false;\n\t\t\t\ttry {\n\t\t\t\t\tactor.init();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tmsg.notifyActorStopped(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.notifyActorStopped(new Exception(\"Actor has stopped\"));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t}\n\ttryProcessQueue();\n}", "CodeBleu_score": 47.71412405151629}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (msg == null) {\n\t\treturn;\n\t}\n\tif (msg.getMsgType() == TbActorMsg.RULE_NODE_UPDATED_MSG) {\n\t\tif (isDestroying()) {\n\t\t\tif (highPriority) {\n\t\t\t\tif (msg.getRuleNode()!= null && msg.getRuleNode().isInitFailed()) {\n\t\t\t\t\tmsg.getRuleNode().reinit();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmsg.notifyActorStopped();\n\t\t\t}\n\t\t} else {\n\t\t\tif (highPriority) {\n\t\t\t\thighPriorityMsgs.add(msg);\n\t\t\t} else {\n\t\t\t\tnormalPriorityMsgs.add(msg);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t}\n\ttryProcessQueue();\n}", "CodeBleu_score": 54.02629785130194}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t\t// process high priority messages first\n\twhile (highPriorityQueue.size() > 0 &&!isStop) {\n\t\tdef message = highPriorityQueue.poll()\n\t\tif (message == null) {\n\t\t\tbreak\n\t\t}\n\t\ttry {\n\t\t\tprocess(message)\n\t\t} catch (Exception e) {\n\t\t\t// initialization failure\n\t\t\tif (e instanceof InitializationException) {\n\t\t\t\tstopReason = e.getMessage()\n\t\t\t\tdestroy()\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// other exception\n\t\t\tlog.error(\"Exception caught in actor ${this}\", e)\n\t\t\tonProcessFailure(e)\n\t\t}\n\t}\n\t// process normal priority messages\n\twhile (normalPriorityQueue.size() > 0 &&!isStop) {\n\t\tdef message = normalPriorityQueue.poll()\n\t\tif (message == null) {\n\t\t\tbreak\n\t\t}\n\t\ttry {\n\t\t\tprocess(message)\n\t\t} catch (Exception e) {\n\t\t\t// initialization failure\n\t\t\tif (e instanceof InitializationException) {\n\t\t\t\tstopReason = e.getMessage()\n\t\t\t\tdestroy()\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// other exception\n\t\t\tlog.error(\"Exception caught in actor ${this}\", e)\n\t\t\tonProcessFailure(e)\n\t\t}\n\t}\n\t// if we get here, we've processed all messages\n\t// set status to free and schedule next attempt\n\tstatus = Status.FREE\n\tscheduleProcess()\n}", "CodeBleu_score": 22.199704284117608}, {"code": "private void processMailbox(){\n\t\tint throughput = getActorThroughput();\n\tboolean processNormal = true;\n\twhile (throughput > 0 && (processNormal ||!getHighPriorityQueue().isEmpty())) {\n\t\tMessage msg = null;\n\t\tif (processNormal) {\n\t\t\tmsg = getNormalPriorityQueue().poll();\n\t\t\tif (msg == null) {\n\t\t\t\tprocessNormal = false;\n\t\t\t\tmsg = getHighPriorityQueue().poll();\n\t\t\t}\n\t\t} else {\n\t\t\tmsg = getHighPriorityQueue().poll();\n\t\t}\n\t\tif (msg!= null) {\n\t\t\ttry {\n\t\t\t\tprocess(msg);\n\t\t\t\tthroughput--;\n\t\t\t} catch (InitializationException e) {\n\t\t\t\tsetStopReason(e);\n\t\t\t\tdestroy();\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error(\"Error processing message \" + msg, e);\n\t\t\t\tonProcessFailure(e);\n\t\t\t}\n\t\t} else {\n\t\t\tsetStatus(Status.FREE);\n\t\t\tscheduleProcess();\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 26.507782567728853}, {"code": "private void processMailbox(){\n\t\t// Iterate through the queues, attempting to process each message using the actor's process method.\n\t// If an initialization failure occurs, it sets a stop reason and destroys the actor.\n\t// For other exceptions, it logs the failure and applies the actor's process failure strategy, potentially stopping the actor if required.\n\t// If there are no more messages, it sets the actor's status to free and schedules a queue processing attempt; otherwise, it continues processing the mailbox.\n\twhile (true) {\n\t\t// Iterate through the queues, attempting to process each message using the actor's process method.\n\t\t// If an initialization failure occurs, it sets a stop reason and destroys the actor.\n\t\t// For other exceptions, it logs the failure and applies the actor's process failure strategy, potentially stopping the actor if required.\n\t\ttry {\n\t\t\tif (status == Status.INITIALIZING) {\n\t\t\t\t// If the actor's status is initializing, it attempts to initialize the actor using the initialize method.\n\t\t\t\t// If the initialization fails, it sets the actor's status to failed and destroys the actor.\n\t\t\t\ttry {\n\t\t\t\t\tinitialize()\n\t\t\t\t\tstatus = Status.RUNNING\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tstatus = Status.FAILED\n\t\t\t\t\tdestroy(t)\n\t\t\t\t}\n\t\t\t} else if (status == Status.RUNNING) {\n\t\t\t\t// If the actor's status is running, it attempts to process a message from the high priority queue.\n\t\t\t\t// If there are no more messages, it attempts to process a message from the normal priority queue.\n\t\t\t\t// If there are no more messages, it sets the actor's status to free and schedules a queue processing attempt.\n\t\t\t\t// If the actor's status is not running or free, it continues with the next iteration.\n\t\t\t\tif (highPriorityQueue.poll(null) == null) {\n\t\t\t\t\tif (normalPriorityQueue.poll(null) == null) {\n\t\t\t\t\t\tstatus = Status.FREE\n\t\t\t\t\t\tschedulePoll()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the actor's status is running, it attempts to process a message from the high priority queue.\n\t\t\t\t// If there are no more messages, it attempts to process a message from the normal priority queue.\n\t\t\t\t// If there are no more messages, it sets the actor's status to free and schedules a queue processing attempt.\n\t\t\t\t// If the", "CodeBleu_score": 10.269022846792517}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (isDestroyed()) {\n\t\treturn;\n\t}\n\tif (stopReason == null) {\n\t\tstopReason = cause;\n\t}\n\tif (isDestroyed()) {\n\t\treturn;\n\t}\n\tif (isDestroying()) {\n\t\treturn;\n\t}\n\tdestroying = true;\n\texecutor.execute(new Runnable() {\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tif (isDestroyed()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdestroying = false;\n\t\t\t\tsetReady(false);\n\t\t\t\tdestroy(stopReason);\n\t\t\t\tnotifyStopped(stopReason);\n\t\t\t} catch (Throwable t) {\n\t\t\t\twarn(\"Exception during actor destruction\", t);\n\t\t\t}\n\t\t}\n\t});\n}", "CodeBleu_score": 32.506194934697454}, {"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = cause;\n\t}\n\tif (!destroying) {\n\t\tdestroying = true;\n\t\tdispatcher.executor().execute(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\treadiness.set(false);\n\t\t\t\t\tdestroy(stopReason);\n\t\t\t\t\tnotifyAllMessages(stopReason);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\twarn(t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}", "CodeBleu_score": 29.989250068499686}, {"code": "public void destroy(Throwable cause){\n\t\tif (isDestroyed()) {\n\t\treturn;\n\t}\n\tif (stopReason == null) {\n\t\tstopReason = new StopReason(cause);\n\t}\n\tdestroyInProgress = true;\n\tdispatcher.executor().execute(new Runnable() {\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tsetReadiness(Readiness.NotReady);\n\t\t\t\tdestroy(stopReason);\n\t\t\t\tnotifyAllMessages(stopReason);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tlogger.warn(\"Exception during actor destruction\", t);\n\t\t\t}\n\t\t}\n\t});\n}", "CodeBleu_score": 35.126699048030865}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (isSysTenantId(tenantId)) {\n\t\treturn true;\n\t}\n\tProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n\tif (profileConfiguration == null) {\n\t\treturn true;\n\t}\n\tLimitLevel limitLevel = getLimitLevel(api, profileConfiguration, level);\n\tif (limitLevel == null) {\n\t\treturn true;\n\t}\n\tRateLimitBuilder builder = RateLimitBuilder.builder(limitLevel, api, tenantId);\n\tRateLimit rateLimit = builder.build();\n\tif (rateLimit == null) {\n\t\treturn true;\n\t}\n\tboolean rateLimitExceeded = rateLimit.isExceeded();\n\tif (rateLimitExceeded) {\n\t\tprocessRateLimitNotification(rateLimit);\n\t}\n\treturn!rateLimitExceeded;\n}", "CodeBleu_score": 39.97639618687839}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isSysTenantId()) {\n\t\treturn true;\n\t}\n\n\tTenantProfile tenantProfile = profileService.getProfileConfiguration(tenantId);\n\tif (tenantProfile == null && ignoreTenantNotFound) {\n\t\treturn true;\n\t}\n\tif (tenantProfile == null) {\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\n\tRateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n\tif (rateLimitConfiguration == null) {\n\t\treturn true;\n\t}\n\n\tRateLimit limit = rateLimitConfiguration.getRateLimit(api, level);\n\tif (limit == null) {\n\t\treturn true;\n\t}\n\n\treturn checkRateLimit(limit, tenantId);\n}", "CodeBleu_score": 47.01881757590945}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isSysTenantId()) {\n\t\treturn true;\n\t}\n\tTenantProfile profile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n\tRateLimitConfiguration rateLimitConfiguration = profile.getRateLimitConfiguration();\n\tRateLimit limit = rateLimitConfiguration.getRateLimit(api, level);\n\tif (limit == null) {\n\t\treturn true;\n\t}\n\tboolean success = limit.check();\n\tif (!success) {\n\t\tprocess(api, tenantId, level);\n\t}\n\treturn success;\n}", "CodeBleu_score": 37.795550877410065}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong now = System.currentTimeMillis();\n\tlong expirationTime = now - inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tdtlsSessions.remove(entry.getKey());\n\t\t\tlogger.trace(\"Removed inactive DTLS session with ID: \" + entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 38.52154445973679}, {"code": "public void evictTimeoutSessions(){\n\t\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\tfor (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlogger.trace(\"Removing DTLS session with ID {} due to inactivity timeout\", entry.getKey());\n\t\t\tdtlsSessions.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 49.82158456358364}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - inactivityTimeout;\n\tIterator<Map.Entry<String, DtlsSession>> iter = dtlsSessions.entrySet().iterator();\n\twhile (iter.hasNext()) {\n\t\tMap.Entry<String, DtlsSession> entry = iter.next();\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlogger.trace(\"Removing DTLS session for \" + entry.getKey() + \" due to inactivity timeout\");\n\t\t\titer.remove();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.78219456541365}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\treturn timeseries.entrySet().stream()\n\t\t\t.map(entry -> entry.getValue().stream()\n\t\t\t\t\t.map(value -> new TsKvEntry(entry.getKey(), parseValue(value)))\n\t\t\t\t\t.collect(Collectors.toList()))\n\t\t\t.flatMap(List::stream)\n\t\t\t.collect(Collectors.toList());\n}", "CodeBleu_score": 24.369273452837003}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (!timeseries.isEmpty()) {\n\t\tList<TsKvEntry> tsKvEntryList = new ArrayList<>();\n\t\ttimeseries.forEach((key, value) -> {\n\t\t\ttsKvEntryList.add(new TsKvEntry(key, parseValue(value)));\n\t\t});\n\t\treturn tsKvEntryList;\n\t}\n\treturn Collections.emptyList();\n}", "CodeBleu_score": 29.947624598427325}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\n\tList<TsKvEntry> tsKvEntries = new ArrayList<>();\n\ttimeseries.forEach((key, value) -> {\n\t\tList<TsKvEntry> entries = value.stream()\n\t\t\t\t.map(node -> new TsKvEntry(parseValue(node), key))\n\t\t\t\t.collect(Collectors.toList());\n\t\ttsKvEntries.addAll(entries);\n\t});\n\treturn tsKvEntries;\n}", "CodeBleu_score": 43.96145388388213}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tMap<String, String> request = new HashMap<>();\n\trequest.put(\"grant_type\", \"refresh_token\");\n\trequest.put(\"refresh_token\", this.refreshToken);\n\n\tHttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(request, headers);\n\tResponseEntity<Map> response = restTemplate.postForEntity(authEndpoint, requestEntity, Map.class);\n\n\tthis.tokenInfo = response.getBody();\n\tthis.tokenInfo.put(\"timestamp\", System.currentTimeMillis());\n}", "CodeBleu_score": 49.3866519081902}, {"code": "public void refreshToken(){\n\t\tMap<String, Object> requestMap = new HashMap<>();\n\trequestMap.put(\"refresh_token\", tokenInfo.getRefreshToken());\n\tResponseEntity<Map> response = restTemplate.postForEntity(authEndpoint, requestMap, Map.class);\n\ttokenInfo.setTimestamp(System.currentTimeMillis());\n\ttokenInfo.setToken(response.getBody().get(\"access_token\").toString());\n}", "CodeBleu_score": 46.52047371678185}, {"code": "public void refreshToken(){\n\t\tdef request = [:]\n\trequest.put('grant_type','refresh_token')\n\trequest.put('refresh_token', refreshToken)\n\n\tdef response = restTemplate.postForEntity(authUrl, request, Map)\n\tdef body = response.getBody()\n\n\tlastTokenRefresh = System.currentTimeMillis()\n\ttokenInfo = body\n}", "CodeBleu_score": 32.86468719111003}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t def timestamp = System.currentTimeMillis()\n def loginRequest = [username: username, password: ]\n def response = restTemplate.postForEntity(authEndpoint, loginRequest, String)\n updateTokenInfo(response, timestamp)\n }", "CodeBleu_score": 26.51640187721772}, {"code": " private void doLogin(){\n\t def timestamp = System.currentTimeMillis()\n def loginRequest = [username: username, password: ]\n def response = restTemplate.postForEntity(authUrl, loginRequest, Map)\n updateTokenInfo(response, timestamp)\n }", "CodeBleu_score": 26.006240738654906}, {"code": " private void doLogin(){\n\t long timestamp = System.currentTimeMillis()\n def loginRequest = [\n username: username,\n password:,\n timestamp: timestamp\n ]\n def response = restTemplate.postForEntity(\n \"${baseUrl}/api/auth/login\",\n loginRequest,\n Map\n )\n if (response.statusCode.is2xxSuccessful()) {\n def tokenInfo = response.body\n tokenInfo.timestamp = timestamp\n this.tokenInfo = tokenInfo\n } else {\n throw new RuntimeException(\"Login failed\")\n }\n }", "CodeBleu_score": 34.293526606591215}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> response = restTemplate.getForEntity(\n\t\t\t\t\"http://localhost:8080/api/device/{deviceId}\", Device.class, deviceId.getId());\n\t\tif (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn Optional.ofNullable(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 62.58083142797201}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> responseEntity = restTemplate.getForEntity(\n\t\t\t\t\"http://localhost:8080/api/device/{deviceId}\", Device.class, deviceId.getId());\n\t\tif (responseEntity.getStatusCode() == HttpStatus.OK) {\n\t\t\treturn Optional.of(responseEntity.getBody());\n\t\t} else if (responseEntity.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Unexpected HTTP status code: \" + responseEntity.getStatusCode());\n\t\t}\n\t} catch (RestClientException e) {\n\t\tthrow new RuntimeException(\"Error retrieving device by ID: \" + deviceId.getId(), e);\n\t}\n}", "CodeBleu_score": 54.67583636986911}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn Optional.ofNullable(restTemplate.getForEntity(apiUrl + \"/device/\" + deviceId, Device.class).getBody());\n}", "CodeBleu_score": 12.150207936824147}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(deviceEndpoint + \"/api/device-with-credentials\", new DeviceWithCredentials(device, credentials), Device.class);\n\t\treturn ofNullable(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 46.95572483315411}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\treturn ofNullable(restTemplate.postForEntity(\n\t\t\t\t\"http://localhost:8080/api/device-with-credentials\",\n\t\t\t\tnew HttpEntity<>(new DeviceWithCredentials(device, credentials)),\n\t\t\t\tDevice.class).getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 33.34493526150098}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tString url = \"http://localhost:8080/api/device-with-credentials\";\n\tHttpHeaders headers = new HttpHeaders();\n\theaders.setContentType(MediaType.APPLICATION_JSON);\n\tHttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials), headers);\n\tResponseEntity<Device> response = restTemplate.postForEntity(url, request, Device.class);\n\treturn response.getStatusCode() == HttpStatus.OK? Optional.of(response.getBody()) : Optional.empty();\n}", "CodeBleu_score": 43.70848916470283}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (arguments.length == 1) {\n\t\tthis.send(0x00, 0x00, arguments[0]);\n\t} else if (arguments.length == 2) {\n\t\tthis.send(0x00, arguments[0], arguments[1]);\n\t}\n\treturn this;\n}", "CodeBleu_score": 36.81331781445857}, {"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tthis.send(0x66, [val]);\n\t\tthis.brightness = val;\n\t} else {\n\t\tthis.send(0x66, [this.map(val, 0, 100, 0, 15), addr]);\n\t\tthis.brightness = val;\n\t}\n\treturn this;\n}", "CodeBleu_score": 37.566935005076104}, {"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tthis.each(function(board, address) {\n\t\t\tboard.send(address, 0, 1, [val]);\n\t\t});\n\t} else {\n\t\tthis.send(addr, 0, 1, [val]);\n\t}\n\treturn this;\n}", "CodeBleu_score": 53.810736590858255}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tthis[key] = this[key].bind(this, addr);\n\t});\n\treturn this;\n}", "CodeBleu_score": 17.720673489072553}, {"code": "device(addr){\n\t\tObject.getOwnPropertyNames(LedControl.prototype).forEach(key => {\n\t\tthis[key] = this[key].bind(this, addr);\n\t});\n\tObject.keys(this).forEach(key => {\n\t\tthis[key] = this[key].bind(this, addr);\n\t});\n\treturn this;\n}", "CodeBleu_score": 33.532729108099396}, {"code": "device(addr){\n\t\tObject.getOwnPropertyNames(LedControl.prototype).forEach(key => {\n\t\tthis[key] = this[key].bind(this, addr);\n\t});\n\treturn this;\n}", "CodeBleu_score": 18.830809776668307}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tfor (let i = 0; i < methods.length; i++) {\n\t\tconst method = methods[i];\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tconst signals = [];\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('callback must be a function');\n\t\t\t}\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tsignals.push(this[i][method](duration));\n\t\t\t}\n\t\t\tPromise.all(signals).then(callback);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.78789252614339}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function(duration = 1000, callback) {\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst signals = [];\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tsignals.push(this[i][method](duration));\n\t\t\t}\n\t\t\tPromise.all(signals).then(callback);\n\t\t};\n\t});\n}", "CodeBleu_score": 32.17085660258392}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function');\n\t\t\t}\n\t\t\tconst signals = [];\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tsignals.push(this[i][method](duration));\n\t\t\t}\n\t\t\tPromise.all(signals).then(callback);\n\t\t}\n\t});\n}", "CodeBleu_score": 47.20900360324958}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\tthis.input = ''\n\tthis.io.serialRead(this.serialPort, (data) => {\n\t\tthis.input += data\n\t\tconst sentences = this.input.split('\\r\n')\n\t\tfor (let i = 0; i < sentences.length - 1; i++) {\n\t\t\tconst sentence = sentences[i]\n\t\t\tthis.parseNmeaSentence(sentence)\n\t\t}\n\t\tthis.input = sentences[sentences.length - 1]\n\t})\n}", "CodeBleu_score": 39.05840679345518}, {"code": "listen(){\n\t\tlet input = '';\n\tconst readLoop = () => {\n\t\tthis.io.serialRead((data) => {\n\t\t\tinput += data;\n\t\t\tconst sentences = input.split('\\r\n');\n\t\t\tinput = sentences.pop();\n\t\t\tsentences.forEach(this.parseNmeaSentence);\n\t\t\treadLoop();\n\t\t});\n\t};\n\treadLoop();\n}", "CodeBleu_score": 32.50990135973936}, {"code": "listen(){\n\t\tthis.input = ''\n\tthis.io.serialRead(this.port, (data) => {\n\t\tthis.input += data\n\t\tthis.input.split('\\r\n').forEach((sentence) => {\n\t\t\tif (sentence.length > 0) {\n\t\t\t\tthis.parseNmeaSentence(sentence)\n\t\t\t}\n\t\t})\n\t\tthis.input = this.input.substr(this.input.lastIndexOf('\\r\n') + 2)\n\t})\n}", "CodeBleu_score": 18.511813286053204}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tconst struct adc_ad559x_data *data = dev->data;\n\tuint8_t active_channels = 0;\n\tuint16_t buffer_size = 0;\n\tuint8_t i;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Resolution mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels_list[i].input_positive ==\n\t\t    ADC_AD559X_CHANNEL_INPUT_POSITIVE_GND) {\n\t\t\tLOG_ERR(\"GND input not allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels_list[i].input_negative ==\n\t\t    ADC_AD559X_CHANNEL_INPUT_NEGATIVE_GND) {\n\t\t\tLOG_ERR(\"GND input not allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels_list[i].input_positive ==\n\t\t    ADC_AD559X_CHANNEL_INPUT_POSITIVE_VREF) {\n\t\t\tLOG_ERR(\"VREF input not allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels_list[i].input_negative ==\n\t\t    ADC_AD559X_CHANNEL_INPUT_NEGATIVE_VREF) {\n\t\t\tLOG_ERR(\"VREF input not allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels_list[i].input_positive ==\n\t\t    ADC_AD559X_CHANNEL_INPUT_POSITIVE_AVSS) {\n\t\t\tLOG_ERR(\"AVSS input not allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels_list[i].input_negative ==\n\t\t    ADC_AD559X_CHANNEL_INPUT_NEGATIVE_AVSS) {\n\t\t\tLOG_ERR(\"AVSS input not allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels_list[i].input_positive ==\n\t\t    ADC_AD559X_CHANNEL_INPUT_POSITIVE_AVDD) {\n\t\t\tLOG_ERR(\"AVDD input not allowed\");\n\t\t\treturn -EINVAL;", "CodeBleu_score": 39.97034889298053}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tint channels = 0;\n\tint buffer_size;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i].channel_id < data->num_channels) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tbuffer_size = channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tbuffer_size *= sequence->options->extra_samplings + 1;\n\t}\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 52.39231766353202}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_ad559x_config *cfg = dev->config;\n\tint channels = 0;\n\tint buffer_size = 0;\n\tint i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tchannels++;\n\t\t}\n\t}\n\n\tbuffer_size = channels * sizeof(uint16_t);\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Insufficient memory for ADC sequence\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (data->resolution == 12) {\n\t\tbuffer_size *= 2;\n\t}\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Insufficient memory for ADC sequence\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->channels = channels;\n\tdata->buffer_size = buffer_size;\n\tdata->sequence = sequence;\n\n\treturn 0;\n}", "CodeBleu_score": 41.6829993391816}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= config->channels) {\n\t\tLOG_ERR(\"Invalid channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(sequence->options);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->options->buffer_size;\n\tdata->buffer_index = 0;\n\tdata->sequence = sequence;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = adc_context_wait_for_completion(&data->ctx);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 67.27595801642225}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint16_t channel_mask;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannel_mask = adc_ad559x_get_channel_mask(sequence);\n\tif (channel_mask!= (channel_mask & config->channel_mask)) {\n\t\tLOG_ERR(\"Invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to start ADC read\");\n\t\treturn ret;\n\t}\n\n\tret = adc_context_wait_for_completion(&data->ctx);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to read ADC\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 55.04897406741773}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= BIT(0)) {\n\t\tLOG_ERR(\"Invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->buffer_size < ADC_AD559X_BUFFER_SIZE) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = adc_context_start_read(&data->ctx, dev);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not start read (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}", "CodeBleu_score": 57.89602224145429}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = CONTAINER_OF(ctx, struct adc_data, ctx);\n\tstruct device *dev = data->dev;\n\tstruct adc_config *config = &data->config;\n\tconst struct adc_driver_api *api = dev->driver_api;\n\tuint8_t i;\n\n\tdata->buffer_index = 0;\n\tdata->buffer_repeat_index = 0;\n\tdata->buffer_is_full = false;\n\n\tfor (i = 0; i < config->channel_count; i++) {\n\t\tdata->buffer[i] = config->channels[i].buffer;\n\t}\n\n\tif (config->buffer_count > 1) {\n\t\tdata->buffer_repeat = config->channels[0].buffer;\n\t}\n\n\tapi->channel_setup(dev, config);\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 55.5351071588449}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = CONTAINER_OF(ctx, struct adc_data, ctx);\n\tint ret;\n\n\tdata->channel_id = ctx->channel_id;\n\n\tif (IS_ENABLED(CONFIG_ADC_ASYNC_API)) {\n\t\tret = adc_read_async(data->dev, ctx->channel_id, &data->buffer, 1, adc_callback, data);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to start ADC conversion (err=%d)\", ret);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tret = adc_read(data->dev, ctx->channel_id, &data->buffer);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to start ADC conversion (err=%d)\", ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 57.12769768883143}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = CONTAINER_OF(ctx, struct adc_data, ctx);\n\tint i;\n\n\t/* Set the channels to be sampled */\n\tdata->channels = ctx->channels;\n\n\t/* Initialize the repeat buffer */\n\tdata->repeat_buffer = ctx->repeat_buffer;\n\tdata->repeat_buffer_size = ctx->buffer_size;\n\n\t/* Release the semaphore to signal the start of sampling */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 68.02444434636628}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = CONTAINER_OF(ctx, struct adc_data_container, context);\n\tif (repeat_sampling) {\n\t\tctx->buf = adc_data_container->repeat_buffer;\n\t} else {\n\t\tctx->buf = adc_data_container->buffer;\n\t}\n}", "CodeBleu_score": 45.823397322150385}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *container = CONTAINER_OF(ctx, struct adc_data_container, context);\n\n\tif (repeat_sampling) {\n\t\tctx->buffer_ptr = container->repeat_buffer;\n\t} else {\n\t\tctx->buffer_ptr = container->buffer;\n\t}\n}", "CodeBleu_score": 45.83561646743727}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = CONTAINER_OF(ctx, struct adc_data_container, ctx);\n\n\tif (repeat_sampling) {\n\t\tadc_data_container->buffer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tadc_data_container->buffer = adc_data_container->single_buffer;\n\t}\n}", "CodeBleu_score": 57.83126676666062}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint i;\n\tint ret;\n\tstruct adc_context *ctx = &data->ctx;\n\tstruct adc_ad559x_channel *channel;\n\tstruct adc_sequence *sequence = adc_context_get_sequence(ctx);\n\n\twhile (1) {\n\t\t/* Wait for the semaphore to be released */\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\t\t/* Iterate through the active channels */\n\t\tfor (i = 0; i < sequence->channels; i++) {\n\t\t\tchannel = &data->channels[i];\n\n\t\t\t/* Read the ADC value for the current channel */\n\t\t\tret = adc_ad559x_read_channel(data, channel);\n\t\t\tif (ret < 0) {\n\t\t\t\t/* If reading from a channel fails, log an error and mark the ADC context as complete */\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", i, ret);\n\t\t\t\tadc_context_complete(ctx, ret);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Store the result in the buffer */\n\t\t\tsequence->buffer[i] = channel->value;\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tadc_context_on_sampling_done(ctx, true);\n\t}\n}", "CodeBleu_score": 46.87636364976172}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_context *ctx = &data->ctx;\n\tstruct adc_sequence *sequence = &data->sequence;\n\tstruct adc_ad559x_channel *channel;\n\tint ret;\n\tint i;\n\n\twhile (1) {\n\t\t/* Wait for the semaphore to be released */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Iterate through the active channels */\n\t\tfor (i = 0; i < sequence->channels; i++) {\n\t\t\tchannel = &data->channels[i];\n\n\t\t\t/* Read the ADC value for the current channel */\n\t\t\tret = adc_ad559x_read_channel(data, channel);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel->channel_id, ret);\n\t\t\t\tadc_context_complete(ctx, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Store the result in the buffer */\n\t\t\tsequence->buffer[i] = ret;\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tadc_context_on_sampling_done(ctx, sequence);\n\t}\n}", "CodeBleu_score": 45.97362853519001}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tstruct adc_context *ctx = &data->ctx;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\t\tfor (int i = 0; i < ADC_AD559X_MAX_CHANNELS; i++) {\n\t\t\tif (!data->channel_enabled[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(data, i);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d\", i);\n\t\t\t\tadc_context_complete(ctx, ret);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_on_sampling_done(ctx, true);\n\t}\n}", "CodeBleu_score": 43.411579800539194}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\tuint16_t config;\n\n\t/* Wait for the device to be ready for data reading */\n\tk_sleep(K_MSEC(data->ready_time));\n\n\t/* Read the configuration register to check the status */\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* If the device is not ready, sleep for 100 microseconds and check again */\n\twhile (!(config & ADS1112_CONFIG_RDY)) {\n\t\tk_sleep(K_USEC(100));\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.25958976923884}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\tuint8_t reg_val;\n\n\t/* Wait for the device to be ready for data reading */\n\tk_sleep(data->ready_time);\n\n\t/* Check the status of the device */\n\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val, 1);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* If the device is not ready, wait for 100 microseconds and check again */\n\twhile (!(reg_val & ADS1112_CONFIG_RDY)) {\n\t\tk_sleep(K_USEC(100));\n\n\t\tret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val, 1);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 64.85389602347705}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tstruct ads1112_data *data = dev->data;\n\tint err;\n\tuint8_t config_reg;\n\tuint8_t ready_bit = ADS1112_READY_BIT;\n\n\tk_sleep(K_MSEC(data->ready_time));\n\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg, 1);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\twhile (!(config_reg & ready_bit)) {\n\t\tk_sleep(K_USEC(100));\n\t\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg, 1);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 57.70655424009923}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint required_size = sequence->resolution * sequence->channels * (sequence->extra_samplings + sequence->channels);\n\n\tif (sequence->buffer_size < required_size) {\n\t\tLOG_ERR(\"Buffer size %d is insufficient for %d channels, %d resolution and %d extra samplings\", sequence->buffer_size, sequence->channels, sequence->resolution, sequence->extra_samplings);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.78786626542716}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint16_t required_buffer_size = sequence->resolution * sequence->channels * (sequence->extra_samplings + sequence->sampling_count);\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size is too small, required %d, actual %d\", required_buffer_size, sequence->buffer_size);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 39.819085577508275}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint num_samplings = 0;\n\tint num_extra_samplings = 0;\n\tint required_buffer_size = 0;\n\n\tif (sequence == NULL) {\n\t\tLOG_ERR(\"Sequence is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPT_OVERWRITE) {\n\t\tLOG_ERR(\"Overwrite option not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_samplings = sequence->resolution * sequence->channels;\n\n\tif (sequence->options & ADC_SEQ_OPT_USE_CONTINUOUS) {\n\t\tnum_extra_samplings = ADC_SEQ_MAX_OPTIONS_EXTRA_SAMPLINGS;\n\t} else if (sequence->options & ADC_SEQ_OPT_END_ON_SEQUENCE) {\n\t\tnum_extra_samplings = ADC_SEQ_MAX_OPTIONS_EXTRA_SAMPLINGS;\n\t}\n\n\trequired_buffer_size = num_samplings + num_extra_samplings;\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size is insufficient\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.71991778192071}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (!data->buffer) {\n\t\tLOG_ERR(\"No buffer assigned to device data\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= 1) {\n\t\tLOG_ERR(\"ADS1112 only supports single channel reads\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"ADS1112 does not support calibration\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\tret = adc_context_start_read(&data->ctx, wait);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"ADC context start read failed\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.956041601764944}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (!device_is_ready(data->bus)) {\n\t\tLOG_ERR(\"I2C bus device not ready\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = ads1112_validate_sequence(sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = adc_context_start_read(&data->ctx, wait);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"ADC context start read failed: %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 53.615415493865115}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_adc_cfg *cfg = dev->config;\n\tstruct ads1112_adc_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->channels!= 1) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = ads1112_validate_sequence(sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = adc_context_start_read(&data->ctx, wait);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ads1112_read_channel(dev, cfg->channel);\n}", "CodeBleu_score": 51.06857425175277}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\tstruct audio_codec_properties *codec_props;\n\n\tcodec_props = k_malloc(sizeof(struct audio_codec_properties));\n\tif (!codec_props) {\n\t\tshell_error(sh, \"Unable to allocate memory for codec properties\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Cannot find device: %s\", argv[1]);\n\t\tk_free(codec_props);\n\t\treturn -ENODEV;\n\t}\n\n\tcodec_props->id = (enum audio_codec_id) strtol(argv[2], NULL, 0);\n\tcodec_props->sample_rate = strtol(argv[3], NULL, 0);\n\tcodec_props->channels = strtol(argv[4], NULL, 0);\n\tcodec_props->resolution = strtol(argv[5], NULL, 0);\n\tcodec_props->mode = strtol(argv[6], NULL, 0);\n\tcodec_props->gain = strtol(argv[7], NULL, 0);\n\n\tret = audio_codec_apply_properties(dev, codec_props);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties: %d\", ret);\n\t\tk_free(codec_props);\n\t\treturn ret;\n\t}\n\n\tk_free(codec_props);\n\treturn 0;\n}", "CodeBleu_score": 53.24487019886715}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint rc;\n\tstruct device *dev;\n\tstruct audio_codec_apply_properties prop;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Too few arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tprop.id = 0;\n\tprop.value = 0;\n\n\tif (argc == 3) {\n\t\tprop.id = strtoul(argv[2], NULL, 0);\n\t}\n\n\tif (argc == 4) {\n\t\tprop.value = strtoul(argv[3], NULL, 0);\n\t}\n\n\trc = audio_codec_apply_properties(dev, &prop);\n\tif (rc!= 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.50837829552619}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Too few arguments\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENOEXEC;\n\t}\n\n\terr = device_get_binding(argv[1]);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to get device binding\");\n\t\treturn err;\n\t}\n\n\terr = audio_codec_apply_properties(dev);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn err;\n\t}\n\n\tshell_print(sh, \"Properties applied\");\n\treturn 0;\n}", "CodeBleu_score": 56.25063566352513}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret;\n\n\tLOG_DBG(\"cmd: %d\", cmd);\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_start(dev);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to start I2S\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t}\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to stop I2S\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Unsupported trigger command\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.93554728739985}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tstruct mpxxdtyy_i2s_config *cfg = dev->config;\n\tint ret;\n\n\tif (data->state == MPXXDTYY_I2S_STATE_IDLE) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t\tLOG_DBG(\"I2S configured\");\n\t\t} else {\n\t\t\tLOG_ERR(\"I2S not configured\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else if (data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t\tLOG_DBG(\"I2S started\");\n\t\t} else {\n\t\t\tLOG_ERR(\"I2S not started\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else if (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t\tLOG_DBG(\"I2S stopped\");\n\t\t} else {\n\t\t\tLOG_ERR(\"I2S not stopped\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"I2S in invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tret = i2s_trigger(cfg->i2s_dev, cmd, NULL);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"I2S trigger failed\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.935895942848234}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret = 0;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\tret = mpxxdtyy_i2s_cmd_set(dev, MPXXDTYY_I2S_CMD_START);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to set I2S START command\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tret = mpxxdtyy_i2s_cmd_set(dev, MPXXDTYY_I2S_CMD_STOP);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to set I2S STOP command\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 30.76305990737531}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tstruct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t command = config->display_mode_command;\n\n\tif (enabled) {\n\t\tcommand |= HD44780_DISPLAY_ON;\n\t} else {\n\t\tcommand &= ~HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcommand |= HD44780_CURSOR_ON;\n\t} else {\n\t\tcommand &= ~HD44780_CURSOR_ON;\n\t}\n\n\tif (data->blink_enabled) {\n\t\tcommand |= HD44780_BLINK_ON;\n\t} else {\n\t\tcommand &= ~HD44780_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, command);\n}", "CodeBleu_score": 58.47330739044623}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0;\n\n\tcommand = auxdisplay_hd44780_read_command(dev);\n\tcommand &= ~(HD44780_DISPLAY_ON | HD44780_CURSOR_ON | HD44780_BLINK_ON);\n\n\tif (enabled) {\n\t\tcommand |= HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_on) {\n\t\tcommand |= HD44780_CURSOR_ON;\n\t}\n\n\tif (data->blink_on) {\n\t\tcommand |= HD44780_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, command);\n}", "CodeBleu_score": 55.91516979265222}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0;\n\n\tcommand = auxdisplay_hd44780_read_command(dev);\n\n\tif (enabled) {\n\t\tcommand |= HD44780_DISPLAY_ON;\n\t} else {\n\t\tcommand &= ~HD44780_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, command);\n}", "CodeBleu_score": 37.90412314006177}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (config->busy_gpio.port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&config->busy_gpio);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get busy GPIO status (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 78.99356016883684}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (!config->busy_gpios.port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&config->busy_gpios);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not get busy GPIO pin status\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 70.39443175859421}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint busy_status;\n\n\tif (config->busy_gpio.port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tbusy_status = gpio_pin_get_dt(&config->busy_gpio);\n\tif (busy_status < 0) {\n\t\treturn busy_status;\n\t}\n\n\treturn busy_status;\n}", "CodeBleu_score": 79.3983373617419}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tconst uint8_t command_prefix = AUXDISPLAY_SERLCD_COMMAND_PREFIX;\n\tuint8_t command_buffer[2];\n\tint result;\n\n\tcommand_buffer[0] = command_prefix;\n\tcommand_buffer[1] = command;\n\n\tresult = i2c_write_dt(&config->i2c, command_buffer, sizeof(command_buffer));\n\n\tif (result == 0) {\n\t\tk_msleep(config->command_delay);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 65.71688593032907}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t command_buffer[2];\n\tint ret;\n\n\tcommand_buffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tcommand_buffer[1] = command;\n\n\tret = i2c_write(data->i2c, command_buffer, 2, data->address);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Error sending special command to %s: %d\", dev->name, ret);\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(data->config->special_command_delay));\n\n\treturn ret;\n}", "CodeBleu_score": 48.51208405743424}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2] = { 0x00, 0x00 };\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\treturn i2c_write_dt(&config->i2c, buffer, 2);\n}", "CodeBleu_score": 61.84713126559136}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, config->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.23523771148776}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\n\tif (bbram_emul_check_invalid(dev, offset, size, data)!= 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data_ptr->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 60.098064778440694}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tsize_t mem_size = config->mem_size;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset >= mem_size || size > mem_size - offset) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > mem_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, config->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.64555140847733}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_dev = dev->data;\n\tint ret = 0;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size > BBRAM_EMUL_MAX_WRITE_SIZE) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > data_dev->size) {\n\t\treturn -EIO;\n\t}\n\n\tif (data_dev->state == BBRAM_EMUL_STATE_INVALID) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&data_dev->data[offset], data, size);\n\n\treturn ret;\n}", "CodeBleu_score": 48.79065522916702}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_cfg *config = dev->config;\n\tstruct bbram_emul_data *data_dev = dev->data;\n\n\tif (offset + size > config->size) {\n\t\tLOG_ERR(\"Write size is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_dev->write_offset) {\n\t\tLOG_ERR(\"Write operation is out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_dev->invalid) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&data_dev->data[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 53.74376775867179}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\tint ret;\n\n\tif (bbram_data->invalid) {\n\t\tLOG_ERR(\"BBRAM is invalid\");\n\t\treturn -EIO;\n\t}\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > bbram_data->size) {\n\t\tLOG_ERR(\"BBRAM write size is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = memcpy_to_bbram(bbram_data->mem, offset, size, data);\n\tif (ret) {\n\t\tLOG_ERR(\"BBRAM write failed\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 52.65395651103134}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"missing BBRAM device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"BBRAM device '%s' not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.1977171085804}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device name argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"device '%s' not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 77.81163455522693}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing required argument for device\");\n\t\treturn -ENOARG;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device '%s' not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 78.24053192169094}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct h4_uart_config *config = dev->config;\n\tstruct h4_uart_data *data = dev->data;\n\tint bytes_read = 0;\n\tint bytes_to_read = 0;\n\tint ret = 0;\n\n\tif (data->remaining_bytes_to_read == 0) {\n\t\treturn;\n\t}\n\n\tbytes_to_read = data->remaining_bytes_to_read;\n\tret = uart_fifo_read(config->uart, data->hdr_buf, bytes_to_read);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to read header data from UART FIFO\");\n\t} else {\n\t\tbytes_read = ret;\n\t\tdata->remaining_bytes_to_read -= bytes_read;\n\t}\n}", "CodeBleu_score": 53.14506911939031}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint bytes_read;\n\n\tbytes_read = uart_fifo_read(dev, &h4_hdr[h4_hdr_idx], H4_HDR_LEN - h4_hdr_idx);\n\tif (bytes_read < 0) {\n\t\tLOG_ERR(\"Failed to read header from UART\");\n\t\treturn;\n\t}\n\n\th4_hdr_idx += bytes_read;\n}", "CodeBleu_score": 20.8398914236224}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_dev_data *h4_dev_data = dev->data;\n\tstruct uart_fifo_context *ctx = &h4_dev_data->ctx;\n\tconst struct h4_uart_config *config = dev->config;\n\tuint8_t *buf = h4_dev_data->hdr_buf;\n\tsize_t buf_len = config->hdr_size;\n\tsize_t remaining_bytes = buf_len - h4_dev_data->hdr_buf_cnt;\n\tint ret;\n\n\tif (remaining_bytes == 0) {\n\t\treturn;\n\t}\n\n\tret = uart_fifo_read(ctx, buf + h4_dev_data->hdr_buf_cnt, remaining_bytes);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to read header data from UART FIFO\");\n\t\treturn;\n\t}\n\n\th4_dev_data->hdr_buf_cnt += ret;\n\tremaining_bytes -= ret;\n\n\tif (remaining_bytes == 0) {\n\t\th4_handle_hdr(dev);\n\t}\n}", "CodeBleu_score": 47.01111081979257}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tchar buf[33];\n\tsize_t count = 0;\n\n\twhile (len > 0) {\n\t\tsize_t n = MIN(len, sizeof(buf));\n\n\t\tif (uart_fifo_read(uart, buf, n)!= n) {\n\t\t\tLOG_ERR(\"Failed to read from UART\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= n;\n\t\tcount += n;\n\t}\n\n\treturn count;\n}", "CodeBleu_score": 39.954306885477365}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t cnt = 0;\n\n\twhile (len) {\n\t\tsize_t n = MIN(len, sizeof(buf));\n\n\t\tif (uart_fifo_read(uart, buf, n)!= n) {\n\t\t\tLOG_ERR(\"Failed to read from UART\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= n;\n\t\tcnt += n;\n\t}\n\n\treturn cnt;\n}", "CodeBleu_score": 44.53466421095305}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t n = 0;\n\tsize_t m;\n\n\twhile (len > 0) {\n\t\tm = MIN(len, sizeof(buf));\n\n\t\tif (uart_fifo_read(uart, buf, m)!= m) {\n\t\t\tLOG_ERR(\"failed to read from UART\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= m;\n\t\tn += m;\n\t}\n\n\treturn n;\n}", "CodeBleu_score": 41.76264760440404}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t hop = 0;\n\tstruct zbus_observer *observer;\n\n\tZBUS_SPINLOCK_LOCK(chan);\n\tfor (observer = chan->observers; observer; observer = observer->next) {\n\t\tif (observer->enabled && observer->priority < hop) {\n\t\t\thop = observer->priority;\n\t\t}\n\t}\n\tchan->highest_observer_priority = hop;\n\tZBUS_SPINLOCK_UNLOCK(chan);\n}", "CodeBleu_score": 23.63754974593036}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tint32_t highest = INT32_MAX;\n\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\n\tSYS_SLIST_FOR_EACH_CONTAINER(&chan->observers, obs, node) {\n\t\tif (obs->priority < highest && obs->enabled) {\n\t\t\thighest = obs->priority;\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = highest;\n\n\tk_spin_unlock(&chan->lock, key);\n}", "CodeBleu_score": 17.126676629315753}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tunsigned int hop = 0;\n\tunsigned int i;\n\tstruct zbus_observer *obs;\n\n\t__ASSERT(chan, \"Invalid channel\");\n\n\tzbus_chan_data_lock(chan);\n\tfor (i = 0; i < chan->num_observers; i++) {\n\t\tobs = chan->observers[i];\n\t\tif (obs && obs->enabled && obs->priority < hop) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\tzbus_chan_data_unlock(chan);\n\n\tchan->highest_observer_priority = hop;\n}", "CodeBleu_score": 26.503959502682502}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tint i;\n\tfor (i = 0; i < MAX_CHANNELS; i++) {\n\t\tif (obs == channel_obs[i]) {\n\t\t\tupdate_channel_hop(i);\n\t\t}\n\t}\n}", "CodeBleu_score": 16.881794650433207}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tfor (size_t i = 0; i < ARRAY_SIZE(channels_hop); i++) {\n\t\tif (channels_hop[i].observer == obs) {\n\t\t\tupdate_channel_hop(&channels_hop[i]);\n\t\t}\n\t}\n}", "CodeBleu_score": 16.745060792779302}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_observer_channel_obs *channel_obs;\n\tstruct zbus_channel_obs *channel_obs_it;\n\tstruct zbus_observer_channel_obs_list_head *channel_obs_list_head;\n\n\t// Iterate through each channel observation\n\tZBUS_OBSERVER_CHANNEL_OBS_LIST_FOREACH(channel_obs_list_head, &obs->channel_obs_list) {\n\t\tchannel_obs = container_of(channel_obs_list_head, struct zbus_observer_channel_obs, list);\n\t\tchannel_obs_it = channel_obs->channel_obs;\n\n\t\t// If the observer matches the provided observer, update the channel\n\t\tif (channel_obs_it->observer == obs) {\n\t\t\tupdate_channel_hop(channel_obs_it);\n\t\t}\n\t}\n}", "CodeBleu_score": 15.688763336932732}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tZBUS_ASSERT(obs!= NULL);\n\tZBUS_ASSERT(!k_is_in_isr());\n\tZBUS_SPINLOCK_KEY_INIT(lock_key);\n\tZBUS_SPINLOCK_IRQ_SAVE(&zbus_lock, lock_key);\n\tif (obs->priority > k_thread_priority_get(k_current_get())) {\n\t\tk_thread_priority_set(k_current_get(), obs->priority);\n\t}\n\tupdate_all_channels_hop(obs);\n\tZBUS_SPINLOCK_IRQ_RESTORE(&zbus_lock, lock_key);\n\treturn 0;\n}", "CodeBleu_score": 47.746271799995945}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tint ret = 0;\n\tZBUS_ASSERT(obs!= NULL);\n\tif (k_is_in_isr()) {\n\t\treturn -EPERM;\n\t}\n\tk_spinlock_key_t key = k_spin_lock(&zbus_spinlock);\n\tobs->priority = k_thread_priority_get(k_current_get());\n\tret = update_all_channels_hop(obs, true);\n\tk_spin_unlock(&zbus_spinlock, key);\n\treturn ret;\n}", "CodeBleu_score": 32.07284708071072}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tZBUS_ASSERT(obs!= NULL);\n\tZBUS_ASSERT(!k_is_in_isr());\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\tobs->priority = ZBUS_MIN_PRIORITY;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&zbus_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 53.49889350434856}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tZBUS_ASSERT(chan!= NULL);\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\t/*\n\t * The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout.", "CodeBleu_score": 34.61555903352491}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tZBUS_ASSERT(chan!= NULL);\n\ttimeout = sys_timepoint_calc(timeout);\n\tk_spinlock_key_t key = chan_lock(chan);\n\tint ret = _zbus_chan_notify(chan, timeout);\n\tchan_unlock(chan, key);\n\treturn ret;\n}", "CodeBleu_score": 20.834653585692266}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tZBUS_ASSERT(chan!= NULL);\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tconst struct zbus_timepoint end_time = sys_timepoint_calc(timeout);\n\tconst int priority = k_thread_priority_get(k_current_get());\n\n\tzbus_chan_lock(chan);\n\n\tint ret = zbus_chan_notify_locked(chan, end_time, priority);\n\n\tzbus_chan_unlock(chan);\n\n\treturn ret;\n}", "CodeBleu_score": 39.625923253718675}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT_ABNORMAL(Int) || IS_ETH_INT_NORMAL(Int));\n\tassert_param(IS_ETH_INT(Int));\n\n\tif (enable) {\n\t\tif (Int & ETH_INT_ABNORMAL) {\n\t\t\tETH->IER |= Int;\n\t\t} else {\n\t\t\tETH->IER |= Int;\n\t\t\tETH->IER &= ~(ETH_INT_ABNORMAL);\n\t\t}\n\t} else {\n\t\tETH->IER &= ~(Int);\n\t\tif (ETH->IER & ETH_INT_ABNORMAL) {\n\t\t\tETH->IER |= ETH_INT_ABNORMAL;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.30624107152236}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (IS_ETH_INT(Int)) {\n\t\tif (enable) {\n\t\t\tif (IS_ETH_INT_ABNORMAL(Int)) {\n\t\t\t\tETH_REG_BIT_SET(ETH_REG_IEN_ABN, Int);\n\t\t\t} else {\n\t\t\t\tETH_REG_BIT_SET(ETH_REG_IEN_NOR, Int);\n\t\t\t}\n\t\t} else {\n\t\t\tETH_REG_BIT_CLR(ETH_REG_IEN_ABN, Int);\n\t\t\tETH_REG_BIT_CLR(ETH_REG_IEN_NOR, Int);\n\t\t}\n\t} else {\n\t\tassert_param(IS_ETH_INT(Int));\n\t}\n}", "CodeBleu_score": 30.1533548176223}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT_ABNORMAL(Int));\n\tassert_param(IS_ETH_INT_NORMAL(Int));\n\tassert_param(IS_ETH_INT(Int));\n\n\tif (enable) {\n\t\tETH->IER |= Int;\n\t} else {\n\t\tETH->IER &= ~Int;\n\t}\n}", "CodeBleu_score": 34.08704344622598}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc = pTxDescTail;\n\n\t/* Start from the current descriptor and check if it is owned by the device */\n\twhile (pTxDesc->Status & ETH_TX_DESC_OWN) {\n\t\t/* Move to the next descriptor */\n\t\tpTxDesc = (ETH_TX_DESC *)((uint32_t)pTxDesc + ETH_TX_DESC_SIZE);\n\n\t\t/* Check if the descriptor is the last in the list */\n\t\tif (pTxDesc == pTxDescHead) {\n\t\t\t/* Loop back to the start of the list */\n\t\t\tpTxDesc = pTxDescTail;\n\t\t}\n\n\t\t/* Check if the maximum number of descriptors has been reached */\n\t\tif (pTxDesc == pTxDescTail) {\n\t\t\t/* No free descriptor found */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Update the tail pointer */\n\tpTxDescTail = pTxDesc;\n\n\t/* Return the descriptor */\n\treturn pTxDesc;\n}", "CodeBleu_score": 35.21486103620589}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc;\n\tuint32_t tx_desc_addr;\n\n\ttx_desc_addr = ETH->DMATDLAR;\n\ttx_desc = (ETH_TX_DESC *)tx_desc_addr;\n\n\twhile (tx_desc->status & ETH_DMATxDesc_OWN) {\n\t\ttx_desc++;\n\n\t\tif ((uint32_t)tx_desc == (tx_desc_addr + (ETH_TXBUFNB * sizeof(ETH_TX_DESC)))) {\n\t\t\ttx_desc = (ETH_TX_DESC *)tx_desc_addr;\n\t\t}\n\t}\n\n\treturn tx_desc;\n}", "CodeBleu_score": 47.549328576654894}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\tuint32_t curTxDescAddr;\n\n\tcurTxDescAddr = ETH->ETH_DMATxDescStartAddr;\n\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\tpTxDesc = (ETH_TX_DESC *)curTxDescAddr;\n\t\tif ((pTxDesc->ETH_TDES0 & ETH_TDES0_OWN) == 0) {\n\t\t\treturn pTxDesc;\n\t\t}\n\t\tcurTxDescAddr = (uint32_t)pTxDesc->ETH_TDES3;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.50260034156859}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tstruct cyp_dac_device *dac_device = (struct cyp_dac_device *) device;\n\tcy_rslt_t result;\n\n\tRT_ASSERT(device!= RT_NULL);\n\tRT_ASSERT(value!= RT_NULL);\n\n\tresult = Cy_CSDIDAC_OutputEnable(dac_device->dac_config->dac_base, dac_device->dac_config->dac_channel, *value);\n\tif (result!= CY_CSDIDAC_SUCCESS) {\n\t\tLOG_E(\"Cy_CSDIDAC_OutputEnable failed with error code %d\", result);\n\t\treturn RT_ERROR;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 52.57754596826286}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tcy_stc_csd_context_t *context = (cy_stc_csd_context_t *) device->parent.user_data;\n\tRT_ASSERT(device!= RT_NULL);\n\tRT_ASSERT(value!= RT_NULL);\n\tif (Cy_CSD_IDAC_SetValue(context, channel, *value) == CY_CSD_IDAC_BAD_PARAM) {\n\t\tLOG_E(\"cy_adc_convert: bad parameter\");\n\t\treturn -RT_EINVAL;\n\t}\n\tCy_CSDIDAC_OutputEnable(context, channel);\n\treturn RT_EOK;\n}", "CodeBleu_score": 48.56630352663858}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tcy_stc_csd_idac_config_t idac_config;\n\tcy_en_csd_status_t status;\n\tcy_stc_csd_context_t *context;\n\tcy_stc_csd_config_t *config;\n\tcy_stc_sysint_t *irq_cfg;\n\tcy_stc_sysint_t *irq_cfg_scan;\n\tcy_stc_sysint_t *irq_cfg_comp;\n\tcy_stc_sysint_t *irq_cfg_scan_comp;\n\tcy_stc_sysint_t *irq_cfg_scan_conv;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan_conv;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan_conv_comp;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan_conv_comp_scan;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan_conv_comp_scan_conv;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan_conv_comp_scan_conv_comp;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan_conv_comp_scan_conv_comp_scan;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan_conv_comp_scan_conv_comp_scan_conv;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan_conv_comp_scan_conv_comp_scan_conv_comp;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan_conv_comp_scan_conv_comp_scan_conv_comp_scan;\n\tcy_stc_sysint_t *irq_cfg_scan_conv_comp_scan_conv_", "CodeBleu_score": 17.71841197605755}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tint ret = 0;\n\n\tif ((addr + size) > IFX_FLASH_SIZE_32K) {\n\t\tIFX_LOG_E(\"Invalid address 0x%08x\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (size--) {\n\t\t*buf++ = *(rt_uint8_t *)(addr++);\n\t}\n\n\tret = size;\n\treturn ret;\n}", "CodeBleu_score": 38.27607691603505}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\n\tif ((addr + size) > FLASH_END_ADDR) {\n\t\tLOG_E(\"Invalid address, cannot read from flash memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 55.83751355085981}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tint i;\n\tif (addr + size > IFX_FLASH_MAX_ADDR) {\n\t\tIFX_LOG_E(\"Invalid address 0x%08x\", addr);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\treturn size;\n}", "CodeBleu_score": 43.336218583900475}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tcyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n\tCY_ASSERT(obj!= NULL);\n\treturn cyhal_timer_read(obj);\n}", "CodeBleu_score": 23.570063349603267}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\tRT_ASSERT(timer_obj!= NULL);\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 25.94764061482997}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 24.638117496376843}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\trt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 7.219493466892985}, {"code": "void dfs_lock(void){\n\t\twhile (rt_mutex_take(&dfs_mutex, RT_WAITING_FOREVER)!= RT_EOK) {\n\t\tRT_ASSERT(0);\n\t}\n}", "CodeBleu_score": 30.43110013992419}, {"code": "void dfs_lock(void){\n\t\twhile (dfs_mutex_take(RT_WAITING_FOREVER)!= RT_EOK) {\n\t\trt_assert_handler(RT_ASSERT_LEVEL_ERROR, \"dfs_lock\", __FILE__, __LINE__);\n\t}\n}", "CodeBleu_score": 26.765690911447603}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint newfd;\n\tint ret;\n\n\tif (fdt->maxfd >= FD_MAX) {\n\t\treturn -1;\n\t}\n\n\tfor (i = startfd; i < FD_MAX; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\tfdt->fds[i] = (struct dfs_fd *)kmalloc(sizeof(struct dfs_fd));\n\t\t\tif (fdt->fds[i] == NULL) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmemset(fdt->fds[i], 0, sizeof(struct dfs_fd));\n\t\t\tfdt->fds[i]->fd = i;\n\t\t\tfdt->maxfd = i + 1;\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tret = fd_slot_expand(fdt);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tnewfd = fdt->maxfd;\n\tfdt->fds[newfd] = (struct dfs_fd *)kmalloc(sizeof(struct dfs_fd));\n\tif (fdt->fds[newfd] == NULL) {\n\t\treturn -1;\n\t}\n\tmemset(fdt->fds[newfd], 0, sizeof(struct dfs_fd));\n\tfdt->fds[newfd]->fd = newfd;\n\tfdt->maxfd = newfd + 1;\n\treturn newfd;\n}", "CodeBleu_score": 38.7289491112374}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tfor (i = startfd; i < fdt->maxfd; i++) {\n\t\tif (fdt->fdtable[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tif (fd_slot_expand(fdt) == 0) {\n\t\treturn -1;\n\t}\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 36.81881002360362}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tfor (i = startfd; i < fdt->maxfd; i++) {\n\t\tif (fdt->fd_array[i] == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (fd_slot_expand(fdt) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fdt->maxfd++;\n}", "CodeBleu_score": 32.87613748367736}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\trt_err_t errcode = error;\n\tif (errcode < 0) {\n\t\terrcode = -errcode;\n\t}\n\n\tif (errcode < sizeof(err_string_table) / sizeof(err_string_table[0])) {\n\t\treturn err_string_table[errcode];\n\t} else {\n\t\treturn err_string_table[sizeof(err_string_table) / sizeof(err_string_table[0]) - 1];\n\t}\n}", "CodeBleu_score": 27.085289084009045}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\trt_err_t err;\n\tconst char *err_str;\n\n\tif (error < 0) {\n\t\terr = (rt_err_t) -error;\n\t} else {\n\t\terr = error;\n\t}\n\n\terr_str = \"EUNKNOW\";\n\tswitch (err) {\n\tcase RT_EOK:\n\t\terr_str = \"EOK\";\n\t\tbreak;\n\n\tcase RT_ERROR:\n\t\terr_str = \"ERROR\";\n\t\tbreak;\n\n\tcase RT_ETIMEOUT:\n\t\terr_str = \"ETIMEOUT\";\n\t\tbreak;\n\n\tcase RT_EFULL:\n\t\terr_str = \"EFULL\";\n\t\tbreak;\n\n\tcase RT_EEMPTY:\n\t\terr_str = \"EEMPTY\";\n\t\tbreak;\n\n\tcase RT_ENOMEM:\n\t\terr_str = \"ENOMEM\";\n\t\tbreak;\n\n\tcase RT_ENOSYS:\n\t\terr_str = \"ENOSYS\";\n\t\tbreak;\n\n\tcase RT_EBUSY:\n\t\terr_str = \"EBUSY\";\n\t\tbreak;\n\n\tcase RT_EIO:\n\t\terr_str = \"EIO\";\n\t\tbreak;\n\n\tcase RT_EINTR:\n\t\terr_str = \"EINTR\";\n\t\tbreak;\n\n\tcase RT_EINVAL:\n\t\terr_str = \"EINVAL\";\n\t\tbreak;\n\n\tcase RT_ENOTREADY:\n\t\terr_str = \"ENOTREADY\";\n\t\tbreak;\n\n\tcase RT_ENORESOURCE:\n\t\terr_str = \"ENORESOURCE\";\n\t\tbreak;\n\n\tcase RT_EHEAP:\n\t\terr_str = \"EHEAP\";\n\t\tbreak;\n\n\tcase RT_EFAULT:\n\t\terr_str = \"EFAULT\";\n\t\tbreak;\n\n\tcase RT_EIDLE:\n\t\terr_str = \"EIDLE\";\n\t\tbreak;\n\n\tcase RT_ERWLOCK:\n\t\terr_str = \"ERWLOCK\";\n\t\tbreak;\n\n\tcase RT_EPIP:\n\t\terr_str = \"EPIP\";\n\t\tbreak;\n\n\tcase RT_ENOPRIV:\n\t\terr_str = \"ENOPRIV\";\n\t\tbreak;\n\n\tcase RT_EPRIORITY:\n\t\terr_", "CodeBleu_score": 27.628653227952505}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\trt_err_t err;\n\n\terr = error < 0? -error : error;\n\n\tfor (i = 0; i < sizeof(err_string_tbl) / sizeof(err_string_tbl[0]); i++) {\n\t\tif (err == err_string_tbl[i].num) {\n\t\t\treturn err_string_tbl[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 55.007753188846145}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\tregister rt_base_t temp;\n\tstruct rt_thread *thread;\n\n\t/* get idle thread */\n\tthread = rt_thread_self();\n\n\t/* lock scheduler */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* set idle thread hook */\n\tif (thread->idle_hook_list_item.next == RT_NULL) {\n\t\t/* no hook in list */\n\t\trt_list_insert_after(&(thread->idle_hook_list),\n\t\t\t\t\t\t\t &(thread->idle_hook_list_item));\n\t}\n\n\t/* set hook */\n\tthread->idle_hook = hook;\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(temp);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 19.37519539850172}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\tregister rt_base_t temp;\n\tregister rt_list_t *l;\n\n\ttemp = rt_hw_interrupt_disable();\n\tfor (l = rt_thread_idle_hook.next; l!= &rt_thread_idle_hook; l = l->next) {\n\t\tif (l->next == l) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (l!= &rt_thread_idle_hook) {\n\t\tl->next = (rt_list_t *) hook;\n\t\trt_hw_interrupt_enable(temp);\n\n\t\treturn RT_EOK;\n\t}\n\n\trt_hw_interrupt_enable(temp);\n\n\treturn -RT_EFULL;\n}", "CodeBleu_score": 37.08601347513384}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\tregister rt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tlevel = rt_spin_lock_irqsave(&rt_thread_idle_sethook_lock);\n\tresult = RT_EOK;\n\tif (rt_thread_idle_sethook_list_index >= RT_THREAD_IDLE_HOOK_MAX) {\n\t\tresult = -RT_EFULL;\n\t} else {\n\t\trt_thread_idle_sethook_list[rt_thread_idle_sethook_list_index++] = hook;\n\t}\n\trt_spin_unlock_irqrestore(&rt_thread_idle_sethook_lock, level);\n\n\treturn result;\n}", "CodeBleu_score": 36.72255355443125}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* remove hook */\n\tif (rt_list_isempty(&rt_thread_idle_hook_list)) {\n\t\tresult = -RT_ENOSYS;\n\t} else {\n\t\trt_list_t *list;\n\n\t\tfor (list = rt_thread_idle_hook_list.next; list!= &rt_thread_idle_hook_list; list = list->next) {\n\t\t\tif (list->next == (rt_list_t *)hook) {\n\t\t\t\tlist->next = list->next->next;\n\t\t\t\tlist->next->prev = list;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 39.339304062273456}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\t/* lock scheduler */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* remove hook */\n\tif (rt_list_isempty(&rt_thread_idle_hook_list))\n\t{\n\t\tresult = -RT_ENOSYS;\n\t}\n\telse\n\t{\n\t\trt_list_t *l;\n\t\tfor (l = rt_thread_idle_hook_list.next; l!= &rt_thread_idle_hook_list; l = l->next)\n\t\t{\n\t\t\tif (((struct rt_thread_idle_hook *)l)->hook == hook)\n\t\t\t{\n\t\t\t\t((struct rt_thread_idle_hook *)l)->hook = RT_NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (l == &rt_thread_idle_hook_list)\n\t\t{\n\t\t\tresult = -RT_ENOSYS;\n\t\t}\n\t}\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 39.75139229891065}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\tregister rt_base_t temp;\n\tregister rt_list_t *l;\n\tregister rt_list_t *n;\n\n\t/* disable interrupt */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* search hook */\n\tfor (l = rt_thread_idle_hook.next, n = l->next; l!= &rt_thread_idle_hook; l = n, n = l->next) {\n\t\tif (((struct rt_thread_idle_hook *)l)->hook == hook) {\n\t\t\t/* remove hook */\n\t\t\trt_list_remove(l);\n\t\t\trt_hw_interrupt_enable(temp);\n\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(temp);\n\n\treturn -RT_ENOSYS;\n}", "CodeBleu_score": 34.43528879041504}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\tregister rt_base_t level;\n\tstruct rt_thread *thread;\n\n\t/* ensure the scheduler is unlocked */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* dequeue and resume each thread in the list */\n\twhile ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist))!= RT_NULL) {\n\t\t/* remove the thread from the suspension list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* resume the thread */\n\t\trt_thread_resume(thread);\n\n\t\t/* set the error code */\n\t\tthread->error = thread_error;\n\t}\n\n\t/* resume scheduler */\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 33.39682637649718}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\tregister rt_base_t temp;\n\tregister rt_thread_t thread;\n\n\t/* disable interrupt */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* resume all thread in the suspension list */\n\twhile ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist))!= RT_NULL) {\n\t\t/* get next thread */\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n\t\t/* resume from suspended list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* set error number and resume thread */\n\t\tthread->error = thread_error;\n\t\trt_thread_resume(thread);\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(temp);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 29.998142567298526}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\tregister rt_base_t level;\n\tstruct rt_thread *thread;\n\n\t/* ensure the scheduler is unlocked */\n\tRT_DEBUG_SCHEDULER_UNL(level);\n\n\t/* dequeue and resume each thread from the list */\n\twhile ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist))!= RT_NULL) {\n\t\t/* resume thread */\n\t\trt_thread_resume(thread);\n\n\t\t/* set thread error */\n\t\tthread->error = thread_error;\n\n\t\t/* dequeue thread */\n\t\trt_list_remove(&(thread->tlist));\n\t}\n\n\t/* ensure the scheduler is locked */\n\tRT_DEBUG_SCHEDULER_L(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 35.94944854341759}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old = RT_NULL;\n\trt_device_t device = RT_NULL;\n\n\t/* save the old console device */\n\told = rt_console_device;\n\n\t/* find the new console device */\n\tdevice = rt_device_find(name);\n\n\t/* check if the new console device is valid */\n\tif (device!= RT_NULL)\n\t{\n\t\t/* close the old console device */\n\t\tif (old!= RT_NULL)\n\t\t{\n\t\t\trt_device_close(old);\n\t\t}\n\n\t\t/* open the new console device */\n\t\tif (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK)\n\t\t{\n\t\t\t/* set the new console device */\n\t\t\trt_console_device = device;\n\t\t}\n\t}\n\n\treturn old;\n}", "CodeBleu_score": 52.77091586530109}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console;\n\trt_device_t new_console;\n\n\t/* save old console device */\n\told_console = rt_console_device;\n\n\t/* find new console device */\n\tnew_console = rt_device_find(name);\n\tif (new_console!= RT_NULL) {\n\t\t/* if new console device is different from old one */\n\t\tif (new_console!= old_console) {\n\t\t\t/* close old console device */\n\t\t\tif (old_console!= RT_NULL)\n\t\t\t\trt_device_close(old_console);\n\n\t\t\t/* open new console device */\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\t/* set new console device */\n\t\t\t\trt_console_device = new_console;\n\t\t\t} else {\n\t\t\t\trt_kprintf(\"can not open device %s as console\n\", name);\n\t\t\t}\n\t\t}\n\t} else {\n\t\trt_kprintf(\"can not find device %s\n\", name);\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 52.92001696397204}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old = RT_NULL;\n\n\tif (name == RT_NULL) {\n\t\trt_kprintf(\"console device name is null\n\");\n\t\treturn RT_NULL;\n\t}\n\n\t/* save the old console device */\n\told = rt_console_device;\n\n\t/* find the new console device */\n\trt_console_device = rt_device_find(name);\n\tif (rt_console_device!= RT_NULL) {\n\t\tif (rt_console_device!= old) {\n\t\t\t/* close the old console device */\n\t\t\tif (old!= RT_NULL) {\n\t\t\t\trt_device_close(old);\n\t\t\t}\n\n\t\t\t/* open the new console device */\n\t\t\tif (rt_device_open(rt_console_device, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\t/* set the new console device */\n\t\t\t\trt_console_device = rt_console_device;\n\t\t\t} else {\n\t\t\t\trt_kprintf(\"open %s device failed\n\", name);\n\t\t\t\trt_console_device = RT_NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trt_kprintf(\"find %s device failed\n\", name);\n\t}\n\n\treturn old;\n}", "CodeBleu_score": 56.58752186887246}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tstruct rt_object_information *information;\n\trt_base_t level;\n\n\tinformation = rt_object_get_information(type);\n\tif (information!= RT_NULL) {\n\t\tlevel = rt_spin_lock_irqsave(&(information->object_list_lock));\n\t\tcount = rt_list_len(&(information->object_list));\n\t\trt_spin_unlock_irqrestore(&(information->object_list_lock), level);\n\t}\n\n\treturn count;\n}", "CodeBleu_score": 50.73242378732802}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_information *information;\n\tint length = 0;\n\trt_base_t level;\n\n\tinformation = rt_object_get_information(type);\n\tif (information!= RT_NULL) {\n\t\tlevel = rt_spin_lock_irqsave(&information->object_list_lock);\n\t\tlength = rt_list_len(&information->object_list);\n\t\trt_spin_unlock_irqrestore(&information->object_list_lock, level);\n\t}\n\n\treturn length;\n}", "CodeBleu_score": 41.46981573257101}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\trt_object_information_t *information;\n\trt_spinlock_t *lock;\n\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\tlock = &information->lock;\n\trt_spin_lock_irqsave(lock);\n\n\trt_list_for_each(node, &information->object_list) {\n\t\tcount ++;\n\t}\n\n\trt_spin_unlock_irqrestore(lock);\n\n\treturn count;\n}", "CodeBleu_score": 50.8205367394891}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tstruct rt_object_information *information;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\t/* get object information */\n\tinformation = object->type->information;\n\n\t/* lock object list */\n\trt_spin_lock_irqsave(&(information->list_lock));\n\n\t/* invoke object's detach hook */\n\tif (object->type->detach_hook!= RT_NULL)\n\t\tobject->type->detach_hook(object);\n\n\t/* remove object from object list */\n\trt_list_remove(&(information->object_list), &(object->list));\n\n\t/* unlock object list */\n\trt_spin_unlock_irqrestore(&(information->list_lock));\n\n\t/* set object type to zero */\n\tobject->type = RT_NULL;\n}", "CodeBleu_score": 56.26164085507931}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tstruct rt_object_information *information;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\t/* get object information */\n\tinformation = rt_object_get_information(object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\t/* invoke object's detach hook */\n\tif (information->detach_hook!= RT_NULL)\n\t{\n\t\tinformation->detach_hook(object);\n\t}\n\n\t/* remove object from object list */\n\trt_spin_lock_irqsave(&(information->list_lock));\n\trt_list_remove(&(object->list));\n\trt_spin_unlock_irqrestore(&(information->list_lock));\n\n\t/* set object type to zero */\n\tobject->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 57.80106135021769}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\n\t/* call object detach hook */\n\tRT_OBJECT_HOOK_CALL(object, detach);\n\n\t/* retrieve object information */\n\tstruct rt_object_information *information = rt_object_get_information(object->type);\n\n\t/* lock object spinlock */\n\trt_spin_lock_irqsave(&(information->object_list_lock));\n\n\t/* remove object from list */\n\trt_list_remove(&(object->list));\n\n\t/* unlock object spinlock */\n\trt_spin_unlock_irqrestore(&(information->object_list_lock));\n\n\t/* set object type to zero */\n\tobject->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 39.350359052360254}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t err;\n\trt_object_t cobj;\n\trt_object_t destroy_method;\n\trt_object_t destroy_result;\n\n\tif (obj == NULL)\n\t\treturn RT_ERR_NULL_OBJECT;\n\n\tif (obj->type!= RT_OBJECT_TYPE_CUSTOM)\n\t\treturn RT_ERR_OBJECT_TYPE;\n\n\tcobj = obj->u.custom.cobj;\n\n\tif (cobj->destroy == NULL)\n\t\treturn RT_ERR_OK;\n\n\tdestroy_method = rt_function_create(cobj->destroy, 0);\n\tif (destroy_method == NULL)\n\t\treturn RT_ERR_NULL_OBJECT;\n\n\terr = rt_function_call(destroy_method, obj, &destroy_result);\n\trt_object_delete(destroy_method);\n\tif (err!= RT_ERR_OK)\n\t\treturn err;\n\n\trt_object_delete(obj);\n\treturn err;\n}", "CodeBleu_score": 40.43310653849278}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t err;\n\trt_object_t cobj;\n\trt_method_t method;\n\n\tif ((err = rt_object_check(obj, RT_OBJECT_CUSTOM))!= RT_OK)\n\t\treturn err;\n\n\tcobj = (rt_object_t) obj;\n\tif ((method = cobj->destroy)!= NULL) {\n\t\terr = method(cobj);\n\t\tif (err!= RT_OK)\n\t\t\treturn err;\n\t}\n\n\treturn rt_object_delete(cobj);\n}", "CodeBleu_score": 42.39015923343605}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t err;\n\trt_custom_object_t cobj = (rt_custom_object_t)obj;\n\n\tif (obj == NULL) {\n\t\treturn RT_ERR_NULL;\n\t}\n\tif (obj->class_id!= RT_CUSTOM_OBJECT_CLASS) {\n\t\treturn RT_ERR_INVALID_OBJECT;\n\t}\n\n\tif (cobj->destroy!= NULL) {\n\t\terr = cobj->destroy(cobj);\n\t\tif (err!= RT_ERR_OK) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\trt_object_delete(obj);\n\n\treturn RT_ERR_OK;\n}", "CodeBleu_score": 44.73566290650994}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t\tstruct rt_thread *thread;\n\tstruct rt_thread *current_thread;\n\trt_base_t level;\n\n\t/* get current thread */\n\tcurrent_thread = rt_thread_self();\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* close thread */\n\trt_thread_close(current_thread);\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\t/* schedule */\n\trt_schedule();\n}", "CodeBleu_score": 41.66312196320777}, {"code": "static void _thread_exit(void){\n\t\tstruct rt_thread *thread;\n\n\tthread = rt_thread_self();\n\n\t/* enter critical */\n\trt_enter_critical();\n\n\t/* close thread */\n\trt_thread_close(thread);\n\n\t/* exit critical */\n\trt_exit_critical_safe();\n\n\t/* schedule to next thread */\n\trt_schedule();\n}", "CodeBleu_score": 38.01561884073904}, {"code": "static void _thread_exit(void){\n\t\tstruct rt_thread *thread;\n\trt_base_t level;\n\n\tthread = rt_thread_self();\n\trt_enter_critical();\n\trt_thread_close(thread);\n\trt_schedule();\n\trt_exit_critical_safe();\n}", "CodeBleu_score": 42.69966189197097}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\tstruct rt_thread *thread;\n\n\tthread = (struct rt_thread *)parameter;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* check thread status */\n\tRT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n\t/* set error number */\n\tthread->error = -RT_ETIMEOUT;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* insert thread into ready list */\n\trt_thread_ready(thread);\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* re-schedule */\n\trt_schedule();\n}", "CodeBleu_score": 48.86437537032765}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread;\n\n\tthread = (rt_thread_t)parameter;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* thread is suspended */\n\tif (thread->stat == RT_THREAD_SUSPEND)\n\t{\n\t\t/* set error number */\n\t\tthread->error = -RT_ETIMEOUT;\n\n\t\t/* remove thread from suspend list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* insert thread to ready list */\n\t\trt_list_insert_before(&rt_thread_priority_table[thread->current_priority], &(thread->tlist));\n\n\t\t/* resume thread */\n\t\trt_thread_resume(thread);\n\t}\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* re-schedule */\n\trt_schedule();\n}", "CodeBleu_score": 45.81140240441831}, {"code": "static void _thread_timeout(void *parameter){\n\trt_thread_t thread;\nrt_base_t level;\n\nthread = (rt_thread_t)parameter;\nRT_ASSERT(thread!= RT_NULL);\n\nlevel = rt_hw_interrupt_disable();\nif (thread->stat == RT_THREAD_SUSPEND)\n{\nthread->error = -RT_ETIMEOUT;\nrt_list_remove(&(thread->tlist));\nrt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]), &(thread->tlist));\nrt_schedule();\n}\nrt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 45.77854281504581}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\tregister rt_uint32_t temp;\n\tregister rt_base_t level;\n\n\t/* lock thread's spinlock */\n\tlevel = rt_hw_spin_lock(&thread->spinlock);\n\n\t/* check if thread is waiting on a mutex */\n\tif (thread->pending_object) {\n\t\t/* remove thread from mutex's waiting list */\n\t\trt_list_remove(&thread->tlist);\n\n\t\t/* clear pending object */\n\t\tthread->pending_object = RT_NULL;\n\t}\n\n\t/* unlock thread's spinlock */\n\trt_hw_spin_unlock(&thread->spinlock, level);\n\n\t/* release all mutexes the thread has taken */\n\twhile (thread->mutex_list) {\n\t\t/* get mutex */\n\t\trt_mutex_t mutex = thread->mutex_list;\n\n\t\t/* remove mutex from thread's mutex list */\n\t\tthread->mutex_list = mutex->owner_next;\n\n\t\t/* release mutex */\n\t\trt_mutex_release(mutex);\n\t}\n}", "CodeBleu_score": 40.69018479575876}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\tstruct rt_mutex_waiter *waiter;\n\trt_base_t level;\n\n\t/* lock thread spinlock */\n\tlevel = rt_spin_lock_irqsave(&thread->parent.spinlock);\n\n\t/* check if thread is waiting on a mutex */\n\tif (thread->parent.pending_object) {\n\t\t/* get the mutex waiter */\n\t\twaiter = rt_list_entry(thread->parent.pending_object, struct rt_mutex_waiter, parent);\n\n\t\t/* remove waiter from mutex's waiting list */\n\t\trt_list_remove(&(waiter->list));\n\n\t\t/* clear the thread's pending object */\n\t\tthread->parent.pending_object = RT_NULL;\n\t}\n\n\t/* unlock thread spinlock */\n\trt_spin_unlock_irqrestore(&thread->parent.spinlock, level);\n\n\t/* release all mutexes the thread has taken */\n\t_thread_release_mutex(thread);\n}", "CodeBleu_score": 34.368579474027}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\tregister rt_ubase_t temp;\n\tregister rt_list_t *list;\n\tregister rt_base_t level;\n\tregister rt_object_t object;\n\tregister rt_list_t *list_mutex;\n\n\t/* lock thread */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* get object from thread */\n\tobject = thread->pending_object;\n\n\t/* check if thread is waiting on a mutex */\n\tif (object!= RT_NULL && rt_object_get_type(object) == RT_Object_Class_Mutex) {\n\t\t/* get mutex list */\n\t\tlist_mutex = &((struct rt_mutex *)object)->parent.list;\n\n\t\t/* remove thread from mutex waiting list */\n\t\tlist = rt_list_remove(list_mutex, &thread->tlist);\n\n\t\t/* check if thread is the first thread in the mutex waiting list */\n\t\tif (list == list_mutex) {\n\t\t\t/* get thread from mutex holder list */\n\t\t\tlist = rt_list_remove(&((struct rt_mutex *)object)->holder_list, &thread->tlist);\n\n\t\t\t/* clear mutex holder */\n\t\t\t((struct rt_mutex *)object)->holder = RT_NULL;\n\n\t\t\t/* release all mutexes the thread has taken */\n\t\t\twhile (list!= list_mutex) {\n\t\t\t\t/* get mutex */\n\t\t\t\tstruct rt_mutex *mutex = rt_list_entry(list, struct rt_mutex, holder_list);\n\n\t\t\t\t/* release mutex */\n\t\t\t\trt_mutex_release(mutex);\n\n\t\t\t\t/* get next mutex */\n\t\t\t\tlist = rt_list_remove(list_mutex, &thread->tlist);\n\t\t\t}\n\t\t}\n\n\t\t/* clear pending object */\n\t\tthread->pending_object = RT_NULL;\n\t}\n\n\t/* unlock thread */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 51.297945373072615}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n\tLOG_D(\"%s startup\", thread->parent.name);\n\n\t/* set thread priority */\n\trt_thread_init_priority(thread);\n\n\t/* reset thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* start thread */\n\trt_schedule();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 47.77343135244097}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n\tLOG_D(\"startup thread:%s\", thread->parent.parent.name);\n\n\t/* set the default priority */\n\trt_thread_control(thread, RT_THREAD_CTRL_CHANGE_PRIORITY, (void *)thread->init_priority);\n\n\t/* reset the thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* start thread */\n\trt_thread_resume(thread);\n\n\t/* start scheduler */\n\trt_schedule();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 49.67960845159316}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread \\\"%s\\\" start up\", thread->parent.name);\n\n\t/* reset thread's priority */\n\trt_thread_reset_priority(thread);\n\n\t/* change thread stat */\n\trt_thread_change_stat(thread, RT_THREAD_SUSPEND);\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* start thread */\n\trt_schedule();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 41.14139910516934}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\n\tRT_ASSERT(timer_list!= RT_NULL);\n\n\tlist = timer_list;\n\tif (!rt_list_isempty(list))\n\t{\n\t\trt_timer_t timer;\n\n\t\ttimer = rt_list_entry(list->next, rt_timer_t, row[0]);\n\t\t*timeout_tick = timer->timeout_tick;\n\n\t\treturn RT_EOK;\n\t}\n\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 50.180957817815155}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_timer_t timer;\n\n\t/* get highest level */\n\tlist = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\tif (!rt_list_isempty(list)) {\n\t\t/* get first entry */\n\t\ttimer = rt_list_entry(list->next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\t\t/* set timeout tick */\n\t\t*timeout_tick = timer->timeout_tick;\n\t\treturn RT_EOK;\n\t}\n\n\t/* no timeout */\n\treturn -RT_ETIMEOUT;\n}", "CodeBleu_score": 63.25373299906721}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\tif (!rt_list_isempty(&(timer_list[0]))) {\n\t\trt_timer_t timer;\n\t\ttimer = rt_list_entry(timer_list[0].next, struct rt_timer, row[0]);\n\t\t*timeout_tick = timer->timeout_tick;\n\t\treturn RT_EOK;\n\t}\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 50.75491943577954}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer!= RT_NULL)\n\t{\n\t\t/* initialize timer object */\n\t\ttimer->parent.init = RT_Object_Class_Timer;\n\n\t\t/* set timer static fields */\n\t\ttimer->timeout = timeout;\n\t\ttimer->parameter = parameter;\n\t\ttimer->init_tick = time;\n\t\ttimer->timeout_tick = time;\n\t\ttimer->flag = flag;\n\n\t\t/* initialize timer list */\n\t\trt_list_init(&(timer->row));\n\n\t\t/* insert timer to timer list */\n\t\trt_timer_insert(timer);\n\n\t\treturn timer;\n\t}\n\n\treturn RT_NULL;\n}", "CodeBleu_score": 49.50366299598413}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer!= RT_NULL) {\n\t\ttimer->parent.flag = RT_Object_Class_Timer;\n\t\ttimer->timeout = timeout;\n\t\ttimer->parameter = parameter;\n\t\ttimer->init_tick = time;\n\t\ttimer->timeout_tick = time;\n\t\ttimer->flag = flag;\n\t\ttimer->next = RT_NULL;\n\t\ttimer->prev = RT_NULL;\n\t\trt_list_insert_before(&rt_timer_list, &timer->row);\n\t}\n\treturn timer;\n}", "CodeBleu_score": 48.07672155615308}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\trt_base_t level;\n\n\t/* check parameters */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\n\t/* allocate object */\n\ttimer = rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL) return RT_NULL;\n\n\t/* initialize object */\n\ttimer->parent.init = RT_NULL;\n\ttimer->parent.cleanup = (void (*)(rt_object_t *))rt_timer_detach;\n\n\t/* initialize timer */\n\ttimer->timeout = timeout;\n\ttimer->parameter = parameter;\n\ttimer->init_tick = time;\n\ttimer->parent.flag = flag;\n\n\t/* initialize timer list */\n\tlevel = rt_hw_interrupt_disable();\n\trt_list_insert_before(&(rt_timer_list), &(timer->row));\n\trt_hw_interrupt_enable(level);\n\n\treturn timer;\n}", "CodeBleu_score": 51.044379453233546}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder to capture the response\n\trec := httptest.NewRecorder()\n\t// Pass the request to the first handler\n\ta.firstHandler.ServeHTTP(rec, req)\n\t// Copy the recorder's headers to the original response\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\t// Check if the first handler returned a \"401 Unauthorized\" status\n\tif rec.Code == http.StatusUnauthorized {\n\t\t// Send a \"Not Authorized\" error response\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\t// If all handlers pass without unauthorized status, pass the request to the router\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 69.12918931889274}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tvar (\n\t\trec *httptest.ResponseRecorder\n\t\terr error\n\t)\n\n\tfor _, handler := range a.handlers {\n\t\trec = httptest.NewRecorder()\n\t\thandler.ServeHTTP(rec, req)\n\t\tfor k, v := range rec.HeaderMap {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 65.9336803359595}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 90.02512723963648}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Retrieve the requested asset based on the URL path\n\tasset, err := a.Asset(req.URL.Path)\n\tif err!= nil {\n\t\t// If the asset is not found, return a 404 error\n\t\thttp.Error(res, \"404 Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the appropriate Content-Type header based on the file extension\n\tswitch path.Ext(req.URL.Path) {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t// Write the asset content to the response\n\tres.Write(asset)\n}", "CodeBleu_score": 48.6358184091855}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"\" || path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := a.assets.Asset(\"public\" + path)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", mime.TypeByExtension(filepath.Ext(path)))\n\tres.Write(asset)\n}", "CodeBleu_score": 41.91823074130676}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := a.Asset(req.URL.Path)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\text := strings.ToLower(path.Ext(req.URL.Path))\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(asset)\n}", "CodeBleu_score": 56.276953174905266}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, map[string]string{\"error\": fmt.Sprintf(\"no robot found with name '%s'\", name)}, http.StatusNotFound)\n\t\treturn\n\t}\n\tvar connections []map[string]interface{}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\": c.Name(),\n\t\t\t\"type\": c.Type(),\n\t\t})\n\t})\n\ta.writeJSON(res, connections, http.StatusOK)\n}", "CodeBleu_score": 54.077173375548725}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": fmt.Sprintf(\"No robot found with name '%s'\", robotName)})\n\t\treturn\n\t}\n\tvar connections []map[string]interface{}\n\trobot.Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, map[string]interface{}{\"name\": c.Name(), \"type\": c.ConnectionType()})\n\t})\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 54.39067582801974}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := a.master.Robot(a.getRobotName(req)).Name()\n\tif robotName == \"\" {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with the specified name\"})\n\t\treturn\n\t}\n\n\tvar connections []string\n\ta.master.Robot(robotName).Connections().Each(func(c gobot.Connection) {\n\t\tconnections = append(connections, c.Name())\n\t})\n\n\ta.writeJSON(res, http.StatusOK, map[string]interface{}{\"connections\": connections})\n}", "CodeBleu_score": 51.860269559519026}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\t// Create a base64-encoded string from the username and password\n\tauth := base64.StdEncoding.EncodeToString([]byte(username + \":\" + password))\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check the \"Authorization\" header in the request\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\n\t\t// If the \"Authorization\" header is not set or does not match the expected value, return a \"Not Authorized\" response\n\t\tif authHeader == \"\" ||!secureCompare(authHeader, \"Basic \"+auth) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the \"Authorization\" header is set and matches the expected value, continue with the request\n\t\t//...\n\t}\n}", "CodeBleu_score": 61.15437818853921}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\tauth := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\")!= auth {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 62.56965354117045}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok || secureCompare(user, username)!= nil || secureCompare(pass, password)!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 53.008576120987485}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 55.01031312577146}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 55.01031312577146}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept for the scaling transformation\n\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\t// Apply the scaling transformation\n\t\tscaled := slope*input + intercept\n\n\t\t// Clamp the output within the target range\n\t\tif scaled < float64(toMin) {\n\t\t\tvalue = toMin\n\t\t} else if scaled > float64(toMax) {\n\t\t\tvalue = toMax\n\t\t} else {\n\t\t\tvalue = int(scaled)\n\t\t}\n\n\t\treturn value\n\t}\n}", "CodeBleu_score": 54.03215237352023}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"sensor not connected\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(float64(raw))\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 49.9225991750933}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.Connection() == nil {\n\t\treturn 0, 0, errors.New(\"connection not valid\")\n\t}\n\tif!a.Connection().AnalogReadSupported() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRawValue = raw\n\ta.lastScaledValue = float64(raw) * a.sensorCfg.scale\n\treturn raw, a.lastScaledValue, nil\n}", "CodeBleu_score": 55.27519104238223}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.Connection().(gobot.AnalogReader).AnalogReadSupported() {\n\t\treturn 0, 0, errors.New(\"AnalogReader does not support AnalogRead\")\n\t}\n\n\traw, err := a.Connection().(gobot.AnalogReader).AnalogRead(a.Pin())\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) * a.sensorCfg.scale\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 52.41361989065321}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMax - m * float64(fromMax)\n\treturn func(val int) float64 {\n\t\treturn m * float64(val) + n\n\t}\n}", "CodeBleu_score": 52.046394722009445}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 50.014168640519465}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - (m * float64(fromMin))\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 45.97696961637529}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(d.Pin())\n\td.AddEvent(VibrationEvent)\n\td.On(Data, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(VibrationEvent, true)\n\t\t}\n\t})\n\tif err := d.Connect(); err!= nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 51.83913359057828}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(VibrationEvent)\n\tgo func() {\n\t\tfor {\n\t\t\tdata := d.Read()\n\t\t\tif data > 1000 {\n\t\t\t\td.Publish(VibrationEvent, data)\n\t\t\t}\n\t\t}\n\t}()\n\treturn d\n}", "CodeBleu_score": 42.48984899609346}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(d.Name() + \"-piezo\")\n\td.AddEvent(\"vibration\")\n\td.On(\"data\", func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(\"vibration\", true)\n\t\t}\n\t})\n\tif err := d.Connect(); err!= nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 51.197839371324726}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.On == nil || d.Off == nil {\n\t\treturn errors.New(\"BuzzerDriver does not support Tone\")\n\t}\n\tperiod := 1 / hz\n\ttempo := 60 / d.Bpm\n\tinterval := period * tempo\n\tcount := duration / interval\n\tfor i := 0; i < int(count); i++ {\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(interval/2) * time.Second)\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(interval/2) * time.Second)\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.53221114144403}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.Pin == nil {\n\t\treturn errors.New(\"Pin is not set\")\n\t}\n\tif hz <= 0 {\n\t\treturn errors.New(\"Invalid frequency\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"Invalid duration\")\n\t}\n\tif d.Bpm <= 0 {\n\t\treturn errors.New(\"Invalid BPM\")\n\t}\n\ttonePeriod := 1 / hz\n\ttempoPeriod := 60 / d.Bpm\n\tperiod := tempoPeriod / tonePeriod\n\tfor i := 0; i < int(duration/tempoPeriod); i++ {\n\t\td.On()\n\t\ttime.Sleep(time.Duration(period/2) * time.Second)\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(period/2) * time.Second)\n\t}\n\treturn nil\n}", "CodeBleu_score": 35.978349751776136}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn errors.New(\"frequency must be positive\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"duration must be positive\")\n\t}\n\tif d.Bpm <= 0 {\n\t\treturn errors.New(\"bpm must be positive\")\n\t}\n\n\t// Calculate tone period based on frequency and tempo\n\tperiod := 60.0 / d.Bpm * 1000.0 / hz\n\n\t// Calculate number of toggles based on duration\n\ttoggles := int(duration / period)\n\n\t// Toggle buzzer on and off\n\tfor i := 0; i < toggles; i++ {\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period/2.0) * time.Millisecond)\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period/2.0) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.46297849226527}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.047270859026366}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.540680276369127}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"no sleep pin configured\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.431276611758214}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor not yet initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tif err := a.translate(id); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err := a.sys.NewAnalogPin(a.pin)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 50.62370178121501}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"AnalogPinsAdaptor not yet initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params := a.translate(id)\n\tpin, err := a.sys.NewAnalogPin(path, params)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 51.337760187389115}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.Pins == nil {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor not yet initialized\")\n\t}\n\tif pin, ok := a.Pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params := a.translate(id)\n\tpin := a.sys.NewAnalogPin(path, params)\n\ta.Pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 38.838818918065634}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.63907685129997}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.63907685129997}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 61.63907685129997}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins()) == 0 {\n\t\treturn nil, fmt.Errorf(\"No pins found\")\n\t}\n\n\topts = append(opts, func(o gobot.DigitalPinOptioner) bool {\n\t\to.SetID(id)\n\t\treturn true\n\t})\n\n\tpin, err := a.sys.DigitalPin(opts...)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif pin == nil {\n\t\tid, err := a.translate(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = a.initialize(id)\n\t}\n\n\tif err := pin.ApplyOptions(opts...); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 51.952159738849346}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins()) == 0 {\n\t\treturn nil, fmt.Errorf(\"No pins configured for this adaptor\")\n\t}\n\n\topts = append(opts, gobot.WithPin(id))\n\n\tpin, err := a.Pins().ApplyOptions(opts...)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tif pin == nil {\n\t\tif err := a.translate(id); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = a.initialize(id)\n\n\t\tif err := a.Pins().Add(pin); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif err := pin.ApplyOptions(opts...); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 51.66001048537302}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins()) == 0 {\n\t\treturn nil, fmt.Errorf(\"Adaptor is not connected to any pins\")\n\t}\n\n\topts = append(opts, gobot.WithPinID(id))\n\tpin, err := a.DigitalPins()[0].DigitalPin(opts...)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 30.342959614898206}]}
