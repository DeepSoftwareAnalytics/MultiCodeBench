{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> required_files;\n\tauto files = _pimpl->GetRequiredFiles(folder);\n\tfor (const auto &file : files) {\n\t\tif (download) {\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\t_pimpl->RequestFile(file);\n\t\t\t\tlog_info << \"Requested file: \" << file;\n\t\t\t} else {\n\t\t\t\tlog_info << \"File found in cache: \" << file;\n\t\t\t}\n\t\t}\n\t\trequired_files.push_back(file);\n\t}\n\treturn required_files;\n}", "CodeBleu_score": 47.13754602983201}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> required_files;\n\tstd::vector<std::string> files;\n\tif (download) {\n\t\tfiles = _pimpl->CallAndWait<std::vector<std::string>>([&]() {\n\t\t\treturn _pimpl->GetFiles(folder);\n\t\t});\n\t} else {\n\t\tfiles = _pimpl->CallAndWait<std::vector<std::string>>([&]() {\n\t\t\treturn _pimpl->GetFiles(folder, false);\n\t\t});\n\t}\n\tfor (const auto &file : files) {\n\t\tif (download) {\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\t_pimpl->RequestFile(file);\n\t\t\t\tlog_info(\"File not found in cache: \" + file);\n\t\t\t} else {\n\t\t\t\tlog_info(\"File found in cache: \" + file);\n\t\t\t}\n\t\t}\n\t\trequired_files.emplace_back(file);\n\t}\n\treturn required_files;\n}", "CodeBleu_score": 51.19006212908407}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> files;\n\tauto folder_files = _pimpl->GetFolderFiles(folder);\n\tfor (const auto &file : folder_files) {\n\t\tif (download) {\n\t\t\tif (!_pimpl->FileExists(file)) {\n\t\t\t\t_pimpl->RequestFile(file);\n\t\t\t\tlog_info << \"Requested file: \" << file;\n\t\t\t} else {\n\t\t\t\tlog_info << \"Found file in cache: \" << file;\n\t\t\t}\n\t\t}\n\t\tfiles.push_back(file);\n\t}\n\treturn files;\n}", "CodeBleu_score": 43.77524124163072}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n/*\n * This function, Client::SpawnActorWithParent, spawns an actor with a specified parent using the provided description, transform, parent ID, attachment type, and socket name.", "CodeBleu_score": 19.986618305810786}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\tif (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n\t\tif (transform.location.x == 0.0 && transform.location.y == 0.0 && transform.location.z!= 0.0) {\n\t\t\tstd::cout << \"Warning: A SpringArm or SpringArmGhost attachment with a translation only in the 'z' axis is ill-formed. \"\n\t\t\t\t\"The actor will be spawned but the attachment will not work as expected.\" << std::endl;\n\t\t}\n\t}\n\n\treturn _pimpl->SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 44.52490031223076}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\tif (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n\t\tif (transform.location.x == 0 && transform.location.y == 0 && transform.location.z!= 0) {\n\t\t\tLOGW << \"Warning: The translation of the transform is only in the 'z' axis. \"\n\t\t\t\t\t\"This may cause the actor to be spawned in an unexpected location.\";\n\t\t}\n\t}\n\treturn _pimpl->SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 39.45921226781538}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n// Get the token for the G-buffer", "CodeBleu_score": 7.0841249375052024}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n/*\n * This function, Client::SubscribeToGBuffer, subscribes to a G-buffer for a given ActorId and GBufferId.", "CodeBleu_score": 23.302736463177443}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n/*\n * This function, Client::SubscribeToGBuffer, subscribes to a G-buffer for a given ActorId and GBufferId.", "CodeBleu_score": 23.302736463177443}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation;\n\tdo {\n\t\tnavigation = _walker_navigation.load();\n\t\tif (navigation!= nullptr) {\n\t\t\tbreak;\n\t\t}\n\t\tnavigation = std::make_shared<WalkerNavigation>();\n\t} while (!_walker_navigation.compare_exchange_weak(navigation, nullptr));\n\treturn navigation;\n}", "CodeBleu_score": 54.071333543672594}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation;\n\tdo {\n\t\tnavigation = _walker_navigation.load();\n\t\tif (navigation!= nullptr) {\n\t\t\treturn navigation;\n\t\t}\n\t} while (!_walker_navigation.compare_exchange_weak(navigation, std::make_shared<WalkerNavigation>()));\n\treturn navigation;\n}", "CodeBleu_score": 53.74096574871088}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tauto nav = _walker_navigation.load();\n\tif (nav) return nav;\n\tnav = std::make_shared<WalkerNavigation>();\n\twhile (!_walker_navigation.compare_exchange_weak(nav, nullptr))\n\t\tnav = std::make_shared<WalkerNavigation>();\n\treturn nav;\n}", "CodeBleu_score": 57.44756887875878}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\t// Check if the current frame of the episode state is less than the given frame.\n\twhile (episode.GetState()->GetFrame() < frame) {\n\t\t// If the timeout duration is exceeded, return false.\n\t\tif (timeout.to_chrono() < std::chrono::system_clock::now()) {\n\t\t\treturn false;\n\t\t}\n\t\t// Yield control to the operating system.\n\t\tstd::this_thread::yield();\n\t}\n\t// Trigger a tick in the TrafficManager.\n\tTrafficManager::Tick();\n\t// Return true if synchronization is successful.\n\treturn true;\n}", "CodeBleu_score": 25.70823953199507}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto timeout_chrono = timeout.to_chrono();\n\tauto start_time = std::chrono::system_clock::now();\n\twhile (episode.GetState()->GetTimestamp() < frame) {\n\t\tstd::this_thread::yield();\n\t\tif (std::chrono::system_clock::now() - start_time > timeout_chrono) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcarla::traffic_manager::TrafficManager::Tick();\n\treturn true;\n}", "CodeBleu_score": 44.90082509006864}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\n//    std::cout << \"SynchronizeFrame\" << std::endl;\n    const auto start = std::chrono::system_clock::now();\n    const auto timeout_chrono = std::chrono::duration_cast<std::chrono::milliseconds>(timeout.to_chrono());\n\n    while (episode.GetState()->GetTimestamp() < frame) {\n        std::this_thread::yield();\n        if (std::chrono::system_clock::now() - start > timeout_chrono) {\n            return false;\n        }\n    }\n\n    // Tick the traffic manager.\n    TrafficManager::Tick();\n\n    return true;\n}", "CodeBleu_score": 52.40162179802071}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy episode;\n\tepisode.Load(map_name, reset_settings, map_layers);\n\treturn episode;\n}", "CodeBleu_score": 14.558845005765363}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy episode;\n\n\t// Load episode\n\t_client.LoadEpisode(map_name, reset_settings, map_layers);\n\n\t// Wait for episode to connect\n\tepisode = WaitForEpisode(episode);\n\n\treturn episode;\n}", "CodeBleu_score": 17.666468293029506}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\t_client.LoadEpisode(map_name, reset_settings, map_layers);\n\t_client.GetEpisodeSettings();\n\tGetCurrentEpisode().WaitForState(EpisodeState::Running);\n\treturn GetCurrentEpisode();\n}", "CodeBleu_score": 25.010216386294537}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Retrieve the walker associated with the controller\n\tauto walker = GetWalker(controller.GetWalkerId());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\n\t// Register the walker with the controller's ID\n\tcontroller.GetId().Register(*walker);\n}", "CodeBleu_score": 41.24623284057273}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Retrieve the walker associated with the controller\n\tauto walker = GetWalker(controller.GetWalkerId());\n\n\t// Throw an exception if the walker is not found\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\n\t// Assert that the episode is not null\n\tDEBUG_ASSERT(_episode!= nullptr);\n\n\t// Create navigation if it is missing\n\t_episode->CreateNavigationIfMissing();\n\n\t// Register the walker with the controller's ID\n\t_episode->GetNavigation()->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 55.8215940964423}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tDEBUG_ASSERT(controller.GetEpisode()!= nullptr, \"Controller has no episode\");\n\tauto walker = controller.GetEpisode()->GetWalker(controller.GetDisplayId());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\n\tauto nav = controller.GetEpisode()->CreateNavigationIfMissing();\n\tnav->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 57.75674924967276}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\t// Check if the actor is already in the episode\n\tif (episode->HasActor(blueprint.GetId())) {\n\t\t// If so, log a warning and return nullptr\n\t\tlog_warning(\"Actor {} already exists in episode {}\", blueprint.GetId(), episode->GetId());\n\t\treturn nullptr;\n\t}\n\n\t// Create the actor\n\tauto actor = blueprint.MakeActor(transform);\n\n\t// If the actor is not valid, log a warning and return nullptr\n\tif (!actor) {\n\t\tlog_warning(\"Failed to create actor {}\", blueprint.GetId());\n\t\treturn nullptr;\n\t}\n\n\t// Register the actor in the episode\n\tepisode->RegisterActor(actor);\n\n\t// Apply the garbage collection policy\n\tactor->SetGarbageCollectionPolicy(gc);\n\n\t// Log the creation details\n\tlog_debug(\"Created actor {} with blueprint {}\", actor->GetId(), blueprint.GetId());\n\n\t// If a parent actor is provided, attach the new actor to it\n\tif (parent) {\n\t\tparent->AttachChild(actor, attachment_type, socket_name);\n\t}\n\n\t// Return the shared pointer to the new actor\n\treturn actor;\n}", "CodeBleu_score": 40.87327621992466}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\t// create the actor\n\tauto actor = blueprint.MakeActor(transform);\n\t// register the actor\n\t_episode->RegisterActor(actor, gc);\n\t// log the creation\n\tlog_debug(\"Spawned actor {} at {}.\", actor->GetId(), transform);\n\t// if there is a parent\n\tif (parent) {\n\t\t// attach the actor to the parent\n\t\tparent->AddChild(actor, attachment_type, socket_name);\n\t}\n\t// return the actor\n\treturn actor;\n}", "CodeBleu_score": 30.209846365346742}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\t// Get the current episode\n\tauto episode = GetCurrentEpisode();\n\n\t// Create the actor\n\tauto actor = blueprint.MakeActor();\n\n\t// Set the actor's transform\n\tactor->SetTransform(transform);\n\n\t// If a parent is provided, attach the actor as a child\n\tif (parent) {\n\t\tparent->AddChild(actor, attachment_type, socket_name);\n\t}\n\n\t// Register the actor in the current episode\n\tepisode->RegisterActor(actor);\n\n\t// Apply the garbage collection policy\n\tactor->SetGarbageCollectionPolicy(gc);\n\n\t// Log the creation details\n\tlog_debug(\n\t\t\"Spawned actor with ID {} at ({}, {}, {}) and rotation ({}, {}, {}, {})\",\n\t\tactor->GetId(),\n\t\ttransform.GetPosition().x,\n\t\ttransform.GetPosition().y,\n\t\ttransform.GetPosition().z,\n\t\ttransform.GetRotation().x,\n\t\ttransform.GetRotation().y,\n\t\ttransform.GetRotation().z,\n\t\ttransform.GetRotation().w\n\t);\n\n\t// Return the newly created actor\n\treturn actor;\n}", "CodeBleu_score": 41.88158211923425}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t//   DEBUG_ASSERT(episode_!= nullptr, \"Episode is null\");\n//   DEBUG_ASSERT(episode_->IsLocked(), \"Episode is not locked\");\n//   DEBUG_ASSERT(episode_->IsRunning(), \"Episode is not running\");\n//   DEBUG_ASSERT(episode_->IsConnected(), \"Episode is not connected\");\n//   DEBUG_ASSERT(episode_->GetClient()!= nullptr, \"Client is null\");\n//   DEBUG_ASSERT(episode_->GetClient()->IsConnected(), \"Client is not connected\");\n//   DEBUG_ASSERT(sensor.GetActorDescription().GetStreamToken()!= 0,\n//                \"Sensor stream token is 0\");\n//   DEBUG_ASSERT(callback!= nullptr, \"Callback is null\");\n//   auto cb = [this, callback](const std::string &data) {\n//     auto sensor_data = sensor::Deserializer::Deserialize(data);\n//     if (sensor_data!= nullptr) {\n//       sensor_data->SetEpisode(episode_);\n//       callback(std::move(sensor_data));\n//     }\n//   };\n//   episode_->GetClient()->SubscribeToStream(\n//       sensor.GetActorDescription().GetStreamToken(),\n//       shared_from_this(),\n//       std::move(cb));\n}", "CodeBleu_score": 10.221038326534257}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n/*\n * This function, Simulator::SubscribeToSensor, subscribes to a sensor's data stream and sets up a callback to handle the incoming sensor data.", "CodeBleu_score": 15.33103935284914}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n/*\n * This function, Simulator::SubscribeToSensor, subscribes to a sensor's data stream and sets up a callback to handle the incoming sensor data.", "CodeBleu_score": 15.33103935284914}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = episode->GetWalkers();\n\tif (walkers->empty()) {\n\t\treturn;\n\t}\n\tauto state = episode->GetState();\n\tRemoveDeadWalkers(state, walkers);\n\n\t_nav.UpdateVehiclesInCrowd(state);\n\t_nav.UpdateCrowd();\n\n\tfor (auto walker : *walkers) {\n\t\tauto transform = _nav.GetWalkerTransform(walker);\n\t\tauto speed = _nav.GetWalkerSpeed(walker);\n\t\tstate->ApplyWalkerState(walker, transform, speed);\n\t}\n\n\tfor (auto walker : *walkers) {\n\t\tif (!_nav.IsWalkerAlive(walker)) {\n\t\t\t_simulator.lock()->SetActorCollisions(walker, false);\n\t\t\t_nav.RemoveAgent(walker);\n\t\t\tUnregisterWalker(walker);\n\t\t\t_simulator.lock()->DestroyActor(walker);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.67265511360832}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = episode->GetWalkers();\n\tif (walkers->empty()) {\n\t\treturn;\n\t}\n\tauto state = episode->GetState();\n\tRemoveDeadWalkers(walkers, state);\n\tUpdateVehiclesInCrowd(walkers);\n\t_nav.UpdateCrowd();\n\tfor (auto walker : *walkers) {\n\t\tauto transform = _nav.GetWalkerTransform(walker->GetId());\n\t\tauto speed = _nav.GetWalkerSpeed(walker->GetId());\n\t\tstd::vector<std::pair<std::string, std::any>> commands;\n\t\tcommands.emplace_back(\"transform\", transform);\n\t\tcommands.emplace_back(\"speed\", speed);\n\t\tepisode->ApplyBatchSync(walker->GetId(), commands);\n\t}\n\tfor (auto walker : *walkers) {\n\t\tif (!_nav.IsWalkerAlive(walker->GetId())) {\n\t\t\t_nav.RemoveAgent(walker->GetId());\n\t\t\tUnregisterWalker(walker);\n\t\t\t_simulator.lock()->DestroyActor(walker->GetId());\n\t\t}\n\t}\n}", "CodeBleu_score": 43.789052005771445}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = episode->GetWalkers();\n\tif (walkers->empty()) {\n\t\treturn;\n\t}\n\tauto state = episode->GetState();\n\tRemoveDeadWalkers(walkers, state);\n\tUpdateVehiclesInCrowd(walkers, state);\n\t_nav.UpdateCrowd();\n\tfor (auto walker : *walkers) {\n\t\tauto transform = _nav.GetWalkerTransform(walker);\n\t\tauto speed = _nav.GetWalkerSpeed(walker);\n\t\tstd::vector<Command> commands;\n\t\tcommands.emplace_back(walker, transform, speed);\n\t\t_simulator.lock()->ApplyBatchSync(commands);\n\t}\n\tfor (auto walker : *walkers) {\n\t\tif (!_nav.IsWalkerAlive(walker)) {\n\t\t\t_nav.RemoveAgent(walker);\n\t\t\tUnregisterWalker(walker);\n\t\t\t_simulator.lock()->DestroyActor(walker);\n\t\t}\n\t}\n}", "CodeBleu_score": 42.184854559244236}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = uid;\n\tdescription.id = id;\n\tdescription.attributes.reserve(attributes.size());\n\tfor (auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute.MakeAttributeDescription());\n\t}\n\treturn description;\n}", "CodeBleu_score": 70.33867656713994}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(uid_);\n\tdescription.set_id(id_);\n\tdescription.set_blueprint_id(blueprint_id_);\n\tdescription.set_blueprint_name(blueprint_name_);\n\tdescription.set_blueprint_file_name(blueprint_file_name_);\n\tdescription.set_blueprint_file_name_hash(blueprint_file_name_hash_);\n\tdescription.set_blueprint_file_name_hash_64(blueprint_file_name_hash_64_);\n\tdescription.set_blueprint_file_name_hash_64_2(blueprint_file_name_hash_64_2_);\n\tdescription.set_blueprint_file_name_hash_64_3(blueprint_file_name_hash_64_3_);\n\tdescription.set_blueprint_file_name_hash_64_4(blueprint_file_name_hash_64_4_);\n\tdescription.set_blueprint_file_name_hash_64_5(blueprint_file_name_hash_64_5_);\n\tdescription.set_blueprint_file_name_hash_64_6(blueprint_file_name_hash_64_6_);\n\tdescription.set_blueprint_file_name_hash_64_7(blueprint_file_name_hash_64_7_);\n\tdescription.set_blueprint_file_name_hash_64_8(blueprint_file_name_hash_64_8_);\n\tdescription.set_blueprint_file_name_hash_64_9(blueprint_file_name_hash_64_9_);\n\tdescription.set_blueprint_file_name_hash_64_10(blueprint_file_name_hash_64_10_);\n\tdescription.set_blueprint_file_name_hash_64_11(blueprint_file_name_hash_64_11_);\n\tdescription.set_blueprint_file_name_hash_64_12(blueprint_file_name_hash_64_12_);\n\tdescription.set_blueprint_file_name_hash_64_13(blueprint_file_name_hash_64_", "CodeBleu_score": 37.83170698547885}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.uid = uid;\n\tdescription.id = id;\n\tdescription.attributes.reserve(attributes.size());\n\tfor (auto& attribute : attributes) {\n\t\tdescription.attributes.push_back(attribute);\n\t}\n\treturn description;\n}", "CodeBleu_score": 76.68226916518906}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\nSharedPtr<BlueprintLibrary> result = MakeSharedPtr<BlueprintLibrary>();\n\nfor (const auto &pair : *this) {\nif (pair.second.ContainsAttribute(name)) {\nconst auto &attribute = pair.second.GetAttribute(name);\n\nif (attribute.GetValue() == value) {\nresult->emplace(pair.first, pair.second);\n} else {\nconst auto &recommendedValues = attribute.GetRecommendedValues();\nif (std::find(recommendedValues.begin(), recommendedValues.end(), value)!= recommendedValues.end()) {\nresult->emplace(pair.first, pair.second);\n}\n}\n}\n}\n\nreturn result;\n}", "CodeBleu_score": 51.08632672839582}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result = MakeSharedPtr<BlueprintLibrary>();\nfor (const auto &pair : *this) {\nif (pair.second.ContainsAttribute(name)) {\nconst auto &attr = pair.second.GetAttribute(name);\nif (attr.GetValue() == value || attr.GetRecommendedValues().contains(value)) {\nresult->emplace(pair.first, pair.second);\n}\n}\n}\nreturn result;\n}", "CodeBleu_score": 39.88658458161945}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result = MakeSharedPtr<BlueprintLibrary>();\nfor (const auto& pair : *this) {\n  if (pair.second.ContainsAttribute(name)) {\n    const auto& attr = pair.second.GetAttribute(name);\n    if (attr.GetValue() == value) {\n      result->emplace(pair);\n    } else {\n      for (const auto& recValue : attr.GetRecommendedValues()) {\n        if (recValue == value) {\n          result->emplace(pair);\n          break;\n        }\n      }\n    }\n  }\n}\nreturn result;\n}", "CodeBleu_score": 55.782762555060074}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = carla::FileSystem::GetFullFilePath(path);\n\tif (!carla::FileSystem::ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write((const char *)&content[0], content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 47.00852937680453}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// carla::FileSystem::ValidateFilePath\n\tstd::string full_path = GetFullFilePath(path);\n\tstd::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<char *>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 41.56840351230906}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = GetFullPath(path);\n\tif (!carla::FileSystem::ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream out(full_path, std::ios::binary);\n\tif (!out.good()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<const char *>(&content[0]), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 42.408185630870484}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\t// Get the parent's bounding box.\n\tconst auto &parent_bounds = parent_actor_->GetBoundingBox(frame);\n\n\t// Calculate the location by adding the parent's bounding box location to the transform's location.\n\tconst auto location = parent_bounds.location + transform.location;\n\n\t// Compute the four corners of the bounding box by rotating the extents based on the yaw angle.\n\tconst auto yaw = transform.rotation.yaw;\n\tconst auto extents = parent_bounds.extents;\n\tconst auto corner1 = location + geom::Location(extents.x, extents.y, extents.z).Rotate(yaw);\n\tconst auto corner2 = location + geom::Location(extents.x, -extents.y, extents.z).Rotate(yaw);\n\tconst auto corner3 = location + geom::Location(-extents.x, extents.y, extents.z).Rotate(yaw);\n\tconst auto corner4 = location + geom::Location(-extents.x, -extents.y, extents.z).Rotate(yaw);\n\n\t// Return a shared pointer to a Bounds object containing the frame number and the calculated corners.\n\treturn std::make_shared<Bounds>(frame, corner1, corner2, corner3, corner4);\n}", "CodeBleu_score": 52.44459684481899}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\t// Get the parent's bounding box.\n\tconst auto &parent_bounds = parent_bounds_[frame];\n\t// Calculate the location of the bounding box.\n\tconst auto location = transform.location + parent_bounds->location;\n\t// Compute the four corners of the bounding box.\n\tconst auto yaw = transform.rotation.yaw;\n\tconst auto extents = parent_bounds->extents;\n\tconst auto x = extents.x;\n\tconst auto y = extents.y;\n\tconst auto z = extents.z;\n\tconst auto corners = std::vector<geom::Location>{\n\t\t{x, y, z},\n\t\t{x, -y, z},\n\t\t{-x, -y, z},\n\t\t{-x, y, z},\n\t\t{x, y, -z},\n\t\t{x, -y, -z},\n\t\t{-x, -y, -z},\n\t\t{-x, y, -z},\n\t};\n\t// Rotate the corners based on the yaw angle.\n\tconst auto cos_yaw = std::cos(yaw);\n\tconst auto sin_yaw = std::sin(yaw);\n\tstd::vector<geom::Location> rotated_corners;\n\tfor (const auto &corner : corners) {\n\t\tconst auto x = corner.x * cos_yaw - corner.y * sin_yaw;\n\t\tconst auto y = corner.x * sin_yaw + corner.y * cos_yaw;\n\t\trotated_corners.push_back({x, y, corner.z});\n\t}\n\t// Return a shared pointer to a Bounds object containing the frame number and the calculated corners.\n\treturn std::make_shared<Bounds>(frame, rotated_corners);\n}", "CodeBleu_score": 45.071830049844166}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n// Create a new Bounds object.\nauto bounds = std::make_shared<Bounds>();\nbounds->frame = frame;\n\n// Get the location of the parent bounding box.\nconst auto &parent_bounds = parent_bounds_map_.at(frame);\nconst auto parent_location = parent_bounds->location;\n\n// Get the location of the transform.\nconst auto &location = transform.location();\n\n// Get the extents of the bounding box.\nconst auto &extents = transform.extents();\n\n// Get the yaw angle of the transform.\nconst auto &yaw = transform.yaw();\n\n// Calculate the location of the bounding box.\nbounds->location = parent_location + location;\n\n// Calculate the four corners of the bounding box.\nbounds->corners[0] = bounds->location + geom::Rotate(extents, yaw);\nbounds->corners[1] = bounds->location + geom::Rotate(geom::Vector2d(-extents.x(), extents.y()), yaw);\nbounds->corners[2] = bounds->location + geom::Rotate(geom::Vector2d(-extents.x(), -extents.y()), yaw);\nbounds->corners[3] = bounds->location + geom::Rotate(geom::Vector2d(extents.x(), -extents.y()), yaw);\n\n// Return the bounds.\nreturn bounds;\n}", "CodeBleu_score": 41.49366849216244}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::unique_lock<std::mutex> lock(_mutex);\n\n\t// Retrieve the light states from the server\n\tstd::vector<LightState> lightStates = _episode.Lock()->GetLightManager()->GetLightStates();\n\n\t// Update the local light states\n\tfor (auto& lightState : lightStates) {\n\t\t_lights[lightState.GetId()] = lightState;\n\t}\n\n\t// Create new light objects if they do not already exist in the _lights map\n\tfor (auto& light : _lights) {\n\t\tif (!light.second.GetLight()) {\n\t\t\tlight.second.SetLight(new Light(light.second));\n\t\t}\n\t}\n}", "CodeBleu_score": 32.79218000320508}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::unique_lock<std::mutex> lock(_mutex);\n\n\t// Retrieve the light states from the server\n\tauto lightStates = _server.GetLightStates();\n\n\t// Update the local light states\n\tfor (auto& lightState : lightStates) {\n\t\t_lights[lightState.first] = lightState.second;\n\t}\n\n\t// Create new light objects if they do not already exist in the _lights map\n\tfor (auto& lightState : _lights) {\n\t\tif (lightState.second.first == LightState::LightGroup::None) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (_episode.Lock()->GetLightManager()->GetLight(lightState.first) == nullptr) {\n\t\t\t_episode.Lock()->GetLightManager()->CreateLight(lightState.first);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.53874832495813}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::unique_lock<std::mutex> lock(_mutex);\n\n\t// Retrieve the light states from the server\n\tstd::vector<LightState> lightStates;\n\tif (Server::GetInstance().GetLightStates(lightStates)) {\n\t\t// Update the local light states\n\t\tfor (auto& lightState : lightStates) {\n\t\t\t_lights[lightState.GetId()] = lightState;\n\t\t}\n\n\t\t// Create new light objects if they do not already exist in the _lights map\n\t\tfor (auto& light : _lights) {\n\t\t\tif (!light.second.IsCreated()) {\n\t\t\t\tlight.second.Create();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 29.65847896406069}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_lights_changes_mutex);\n\n\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\n\tstd::vector<uint8_t> message;\n\tmessage.push_back(rpc::LightManagerUpdate);\n\n\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); ++it_light) {\n\t\tit_light->second.GetLocation(message);\n\t\tmessage.push_back(it_light->second.GetColor());\n\t}\n\n\tmessage.push_back(0);\n\n\tif (discard_client) {\n\t\t_lights_changes.clear();\n\t}\n\n\t_lights_dirty = false;\n\n\t_episode.Lock()->UpdateServerLightsState(message);\n}", "CodeBleu_score": 42.75463636042118}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\n\tstd::lock_guard<std::mutex> lock(_lights_mutex);\n\n\tstd::string message;\n\tmessage.push_back(rpc::LIGHTS_STATE_UPDATE);\n\tmessage.push_back(discard_client? 1 : 0);\n\n\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); ++it_light) {\n\t\tif (_lights_changes.find(it_light->first)!= _lights_changes.end()) {\n\t\t\tmessage.push_back(it_light->first);\n\t\t\tmessage.push_back(it_light->second.GetLocation());\n\t\t\tmessage.push_back(it_light->second.GetColor());\n\t\t}\n\t}\n\n\t_lights_changes.clear();\n\t_dirty = false;\n\n\t_episode.Lock()->UpdateServerLightsState(message);\n}", "CodeBleu_score": 47.26663033303774}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (discard_client) {\n\t\t_lights_changes.clear();\n\t\t_dirty = false;\n\t\treturn;\n\t}\n\tif (!_dirty)\n\t\treturn;\n\tstd::vector<char> message;\n\tmessage.push_back(rpc::LIGHTS);\n\tfor (auto it_light = _lights.begin(); it_light!= _lights.end(); it_light++) {\n\t\tmessage.push_back(it_light->first);\n\t\tmessage.push_back(it_light->second.GetColor().r);\n\t\tmessage.push_back(it_light->second.GetColor().g);\n\t\tmessage.push_back(it_light->second.GetColor().b);\n\t}\n\t_episode.Lock()->UpdateServerLightsState(message);\n\t_lights_changes.clear();\n\t_dirty = false;\n}", "CodeBleu_score": 44.164190833487396}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send: Sensor ID does not match.\");\n\t\treturn;\n\t}\n\tlog_debug(\"ServerSideSensor::Send: Sending message.\");\n\tGetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 54.178804846783834}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"This sensor is not the v2x_custom sensor\");\n\t\treturn;\n\t}\n\tlog_debug(\"Sending message to episode\");\n\tGetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 53.74446697520767}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId()!= \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send() called with wrong sensor ID\");\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 51.77025235222386}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicle(this, tm_port);\n\t} else {\n\t\ttm.UnregisterVehicle(this);\n\t}\n}", "CodeBleu_score": 41.057286307485775}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicle(this, tm_port);\n\t} else {\n\t\ttm.UnregisterVehicle(this);\n\t}\n}", "CodeBleu_score": 41.057286307485775}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicle(this, tm_port);\n\t} else {\n\t\ttm.UnregisterVehicle(this);\n\t}\n}", "CodeBleu_score": 41.057286307485775}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\tGetEpisode().Lock()->RegisterAIController(this);\n\twalker = GetEpisode().Lock()->GetActorById(walkerId);\n\tGetEpisode().Lock()->GetNavigation()->AddWalker(walker, walker->GetLocation());\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walkerId, false);\n\tGetEpisode().Lock()->SetActorCollisions(walkerId, false);\n}", "CodeBleu_score": 48.835177123770904}, {"code": "void WalkerAIController::Start(){\n\t\tGetEpisode().Lock()->RegisterAIController(this);\n\twalker = GetEpisode().Lock()->GetActor(GetId());\n\tGetEpisode().Lock()->GetNavigation()->AddWalker(walker, walker->GetLocation());\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n}", "CodeBleu_score": 46.828632604636134}, {"code": "void WalkerAIController::Start(){\n\t\tGetEpisode().Lock()->RegisterAIController(this);\n\twalker = GetParent()->GetActor<Walker>();\n\tGetEpisode().Lock()->GetNavigation()->AddWalker(walker, walker->GetLocation());\n\tGetEpisode().Lock()->SetActorSimulatePhysics(walker, false);\n\tGetEpisode().Lock()->SetActorCollisions(walker, false);\n}", "CodeBleu_score": 47.050528248588}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto nav = GetEpisode().Lock()->GetNavigation();\n\tif (!nav) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed(): no navigation instance\");\n\t\treturn;\n\t}\n\tauto walker = GetParent().Lock();\n\tif (!walker) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed(): no parent walker\");\n\t\treturn;\n\t}\n\tnav->SetWalkerMaxSpeed(walker, max_speed);\n}", "CodeBleu_score": 53.15634100476719}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\t// Get the current episode\n\tEpisode* episode = GetEpisode().Lock();\n\n\t// Check if the episode is valid\n\tif (!episode) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Episode is invalid.\");\n\t\treturn;\n\t}\n\n\t// Retrieve the parent walker\n\tWalker* walker = GetParent();\n\n\t// Check if the walker is valid\n\tif (!walker) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Walker is invalid.\");\n\t\treturn;\n\t}\n\n\t// Set the walker's maximum speed using the episode's navigation instance\n\tif (!episode->GetNavigation()->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to set walker's maximum speed.\");\n\t}\n}", "CodeBleu_score": 50.55867468139474}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto nav = GetEpisode().Lock()->GetNavigation();\n\tif (nav) {\n\t\tauto walker = GetParent().Lock();\n\t\tif (walker) {\n\t\t\tnav->SetWalkerMaxSpeed(walker, max_speed);\n\t\t} else {\n\t\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: walker not found\");\n\t\t}\n\t} else {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: navigation not found\");\n\t}\n}", "CodeBleu_score": 59.82472743339535}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> waypoints = _parent->GetMap().GetPrevious(_id, distance);\n\tfor (auto waypoint : waypoints) {\n\t\tresult.emplace_back(new Waypoint(waypoint->GetId(), waypoint->GetLatitude(), waypoint->GetLongitude(), waypoint->GetElevation(), waypoint->GetParent()));\n\t}\n\treturn result;\n}", "CodeBleu_score": 59.827638919507464}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(10);\n\tSharedPtr<Waypoint> previous = _parent->GetMap().GetPrevious(*this, distance);\n\twhile (previous!= nullptr) {\n\t\tresult.emplace_back(previous);\n\t\tprevious = _parent->GetMap().GetPrevious(*previous, distance);\n\t}\n\treturn result;\n}", "CodeBleu_score": 50.84950352595686}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> waypoints = _parent->GetMap().GetPrevious(*this, distance);\n\tfor (auto waypoint : waypoints) {\n\t\tresult.emplace_back(new Waypoint(waypoint, _parent));\n\t}\n\treturn result;\n}", "CodeBleu_score": 59.82142932530125}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::set<SharedPtr<Signal>> added_signals;\nauto signals = GetSignalsInDistance(distance, stop_at_junction);\nfor (auto signal : signals) {\nif (added_signals.count(signal) == 0) {\nadded_signals.insert(signal);\nresult.emplace_back(new Landmark(signal, _parent->GetMap()));\n}\n}\nreturn result;\n}", "CodeBleu_score": 38.602664540893684}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::set<SharedPtr<Signal>> added_signals;\nstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\nfor (SharedPtr<Signal> signal : signals) {\nif (added_signals.count(signal) == 0) {\nadded_signals.insert(signal);\nSharedPtr<Waypoint> waypoint = SharedPtr<Waypoint>(new Waypoint(signal));\nSharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(waypoint));\nresult.emplace_back(landmark);\n}\n}\nreturn result;\n}", "CodeBleu_score": 45.76410972415651}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nauto signals = GetSignalsInDistance(distance, stop_at_junction);\nstd::unordered_set<SharedPtr<Signal>> added_signals;\nfor (const auto& signal : signals) {\nif (added_signals.count(signal) == 0) {\nadded_signals.insert(signal);\nresult.emplace_back(new Landmark(signal));\n}\n}\nreturn result;\n}", "CodeBleu_score": 40.74224823869182}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\tauto curr_snapshot = _episode.Lock()->GetSnapshot();\n\tauto curr_timestamp = curr_snapshot.GetTimestamp();\n\tauto curr_delta = curr_snapshot.GetDelta();\n\tauto curr_time = curr_snapshot.GetTime();\n\n\tauto new_settings = settings;\n\tauto new_timeout = timeout;\n\n\tif (new_timeout.milliseconds() == 0) {\n\t\tnew_timeout = _episode.Lock()->GetNetworkingTimeout();\n\t}\n\n\tif (new_settings.fixed_delta_seconds.has_value()) {\n\t\tauto fixed_delta = new_settings.fixed_delta_seconds.get();\n\t\tauto fixed_delta_milliseconds = fixed_delta * 1000.0f;\n\t\tauto fixed_delta_duration = milliseconds(fixed_delta_milliseconds);\n\n\t\tif (abs(fixed_delta - curr_delta) > std::numeric_limits<float>::epsilon()) {\n\t\t\tauto attempts = 0;\n\t\t\tauto max_attempts = 10;\n\t\t\tauto curr_time_milliseconds = curr_time * 1000.0f;\n\t\t\tauto curr_time_duration = milliseconds(curr_time_milliseconds);\n\t\t\tauto curr_time_point = curr_timestamp + curr_time_duration;\n\n\t\t\twhile (abs(fixed_delta - curr_delta) > std::numeric_limits<float>::epsilon()) {\n\t\t\t\tTick(fixed_delta_duration);\n\t\t\t\tcurr_snapshot = _episode.Lock()->GetSnapshot();\n\t\t\t\tcurr_timestamp = curr_snapshot.GetTimestamp();\n\t\t\t\tcurr_delta = curr_snapshot.GetDelta();\n\t\t\t\tcurr_time = curr_snapshot.GetTime();\n\t\t\t\tcurr_time_milliseconds = curr_time * 1000.0f;\n\t\t\t\tcurr_time_duration = milliseconds(curr_time_milliseconds);\n\t\t\t\tcurr_time_point = curr_timestamp + curr_time_duration;\n\n\t\t\t\tif (attempts >= max_attempts) {\n\t\t\t\t\tlog_warning(\"Failed to apply fixed delta time setting after %d attempts.\", max_attempts);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (curr_time_point > curr_timestamp + new_timeout) {\n\t\t\t\t\tlog_warning(\"Failed to apply fixed delta time setting after %d attempts.\", attempts);\n\t\t\t\t\t", "CodeBleu_score": 46.88739538515991}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\t// lock the episode\n\tauto episode = _episode.Lock();\n\n\t// set a local timeout based on the provided timeout or the episode's networking timeout\n\ttime_duration local_timeout = timeout.milliseconds == 0? episode->GetNetworkingTimeout() : timeout;\n\n\t// if the settings include a fixed delta time, attempt to verify the accuracy of this setting over a series of ticks\n\tif (settings.fixed_delta_seconds.has_value()) {\n\t\t// get the current snapshot\n\t\tauto curr_snapshot = episode->GetSnapshot();\n\n\t\t// get the current time\n\t\tauto start_time = curr_snapshot->GetTimestamp();\n\n\t\t// get the current time plus the fixed delta time\n\t\tauto end_time = start_time + settings.fixed_delta_seconds.value();\n\n\t\t// get the current time plus the fixed delta time plus an epsilon\n\t\tauto end_time_plus_epsilon = end_time + std::numeric_limits<float>::epsilon();\n\n\t\t// get the current time plus the fixed delta time minus an epsilon\n\t\tauto end_time_minus_epsilon = end_time - std::numeric_limits<float>::epsilon();\n\n\t\t// set the episode settings\n\t\tepisode->SetEpisodeSettings(settings);\n\n\t\t// get the current snapshot\n\t\tcurr_snapshot = episode->GetSnapshot();\n\n\t\t// get the current time\n\t\tstart_time = curr_snapshot->GetTimestamp();\n\n\t\t// get the current time plus the fixed delta time\n\t\tend_time = start_time + settings.fixed_delta_seconds.value();\n\n\t\t// get the current time plus the fixed delta time plus an epsilon\n\t\tend_time_plus_epsilon = end_time + std::numeric_limits<float>::epsilon();\n\n\t\t// get the current time plus the fixed delta time minus an epsilon\n\t\tend_time_minus_epsilon = end_time - std::numeric_limits<float>::epsilon();\n\n\t\t// set the episode settings\n\t\tepisode->SetEpisodeSettings(settings);\n\n\t\t// get the current snapshot\n\t\tcurr_snapshot = episode->GetSnapshot();\n\n\t\t// get the current time\n\t\tstart_time = curr_snapshot->GetTimestamp();\n\n\t\t// get the current time plus the fixed delta time\n\t\tend_time = start_time + settings.fixed_delta_seconds.value();\n\n\t\t// get the current time", "CodeBleu_score": 44.917480171958225}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\t// Get the current snapshot\n\tauto curr_snapshot = _episode.Lock()->GetSnapshot();\n\n\t// If the timeout is not set, use the episode's networking timeout\n\tif (!timeout.is_special()) {\n\t\ttimeout = _episode.Lock()->GetNetworkingTimeout();\n\t}\n\n\t// If the settings include a fixed delta time, attempt to verify its accuracy\n\tif (settings.fixed_delta_seconds.has_value()) {\n\t\t// Set the local timeout to 10% of the fixed delta time\n\t\tauto local_timeout = timeout_duration(std::chrono::duration<float>(settings.fixed_delta_seconds.value()) * 0.1f);\n\n\t\t// Tick the world for a number of iterations\n\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\t// Tick the world\n\t\t\tTick(local_timeout);\n\n\t\t\t// Get the current snapshot\n\t\t\tauto new_snapshot = _episode.Lock()->GetSnapshot();\n\n\t\t\t// If the timestamps are not equal, the fixed delta time is not accurate\n\t\t\tif (abs(new_snapshot.GetTimestamp() - curr_snapshot.GetTimestamp()) > std::numeric_limits<float>::epsilon()) {\n\t\t\t\t// Log a warning\n\t\t\t\tlog_warning(\"The fixed delta time setting is not accurate. The actual fixed delta time is %f seconds.\", (new_snapshot.GetTimestamp() - curr_snapshot.GetTimestamp()) / 1000.0f);\n\n\t\t\t\t// Break the loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the episode settings\n\t_episode.Lock()->SetEpisodeSettings(settings);\n\n\t// Return the identifier of the applied settings\n\treturn _episode.Lock()->GetSettingsIdentifier();\n}", "CodeBleu_score": 45.56066445161167}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst float segmentLengthSquared = DistanceSquared2D(segment.start, segment.end);\n\tconst float segmentLength = std::sqrt(segmentLengthSquared);\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn { 0.0f, Distance2D(point, segment.start) };\n\t}\n\tconst float projection = Dot2D(point - segment.start, segment.end - segment.start) / segmentLengthSquared;\n\treturn { Clamp(projection, 0.0f, 1.0f), Distance2D(point, segment.start + (segment.end - segment.start) * Clamp(projection, 0.0f, 1.0f)) };\n}", "CodeBleu_score": 35.76008494010316}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat lengthSquared = DistanceSquared2D(a, b);\n\tif (lengthSquared == 0.0f) {\n\t\treturn {0.0f, Distance2D(a, p)};\n\t}\n\tfloat t = Dot2D(p - a, b - a) / lengthSquared;\n\tt = Clamp(t, 0.0f, 1.0f);\n\treturn {t, Distance2D(p, a + t * (b - a))};\n}", "CodeBleu_score": 33.24271577028143}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segmentLengthSquared = DistanceSquared2D(segment.first, segment.second);\n\tfloat segmentLength = std::sqrt(segmentLengthSquared);\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn std::make_pair(0.0f, Distance2D(point, segment.first));\n\t}\n\tfloat projection = Dot2D(point - segment.first, segment.second - segment.first) / segmentLengthSquared;\n\tfloat clampedProjection = Clamp(projection, 0.0f, 1.0f);\n\treturn std::make_pair(clampedProjection * segmentLength, Distance2D(point, segment.first + (segment.second - segment.first) * clampedProjection));\n}", "CodeBleu_score": 36.73839841368099}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tDEBUG_ASSERT(vertices.size() >= 3);\n\tconst size_t initial_index = GetVerticesNum();\n\tAddVertices(vertices);\n\tfor (size_t i = 1; i < vertices.size() - 1; ++i) {\n\t\tAddIndex(initial_index);\n\t\tAddIndex(initial_index + i);\n\t\tAddIndex(initial_index + i + 1);\n\t}\n}", "CodeBleu_score": 58.480371432592634}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tDEBUG_ASSERT(vertices.size() >= 3);\n\tconst size_t initialIndex = m_vertices.size();\n\tAddVertices(vertices);\n\tfor (size_t i = 0; i < vertices.size() - 2; i++) {\n\t\tAddIndex(initialIndex);\n\t\tAddIndex(initialIndex + i + 1);\n\t\tAddIndex(initialIndex + i + 2);\n\t}\n}", "CodeBleu_score": 53.30914185240133}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tDEBUG_ASSERT(vertices.size() >= 3);\n\n\tconst size_t initial_index = vertices.size();\n\n\tfor (size_t i = 0; i < vertices.size(); i++) {\n\t\tAddVertex(vertices[i]);\n\t}\n\n\tfor (size_t i = 0; i < vertices.size() - 2; i++) {\n\t\tAddIndex(initial_index);\n\t\tAddIndex(initial_index + i + 1);\n\t\tAddIndex(initial_index + i + 2);\n\t}\n}", "CodeBleu_score": 53.487048070829665}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t#ifdef DEBUG_ASSERT\n  DEBUG_ASSERT(message->IsValid());\n#endif // DEBUG_ASSERT\n\n  boost::asio::post(\n      _strand,\n      [self = shared_from_this(), message]() {\n        if (self->_socket.is_open()) {\n          self->_deadline.expires_from_now(boost::posix_time::seconds(10));\n          boost::asio::async_write(\n              self->_socket,\n              message->GetBufferSequence(),\n              boost::asio::bind_executor(\n                  self->_strand,\n                  [self, message](const boost::system::error_code &ec, std::size_t) {\n                    if (ec) {\n                      self->log_error(ec.message());\n                      self->CloseNow();\n                    }\n                  }));\n        }\n      });\n}", "CodeBleu_score": 40.056906195388756}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\n#ifdef DEBUG_ASSERT\n  DEBUG_ASSERT(message!= nullptr && message->IsValid());\n#endif // DEBUG_ASSERT\n\n  boost::asio::post(self->_strand, [self, message] {\n    if (self->_socket.is_open()) {\n      self->_deadline.expires_from_now(boost::posix_time::seconds(self->_timeout_seconds));\n      self->_socket.async_write_some(message->GetBufferSequence(), [self, message](const boost::system::error_code &ec, std::size_t) {\n        if (!ec) {\n          self->_deadline.expires_at(boost::posix_time::pos_infin);\n        } else {\n          self->CloseNow();\n          log_error(\"Primary::Write\", ec.message());\n        }\n      });\n    }\n  });\n}", "CodeBleu_score": 38.939116076044314}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\n#ifdef DEBUG_ASSERT\n  DEBUG_ASSERT(message!= nullptr);\n  DEBUG_ASSERT(message->IsValid());\n#endif // DEBUG_ASSERT\n\n  boost::asio::post(self->_strand, [self, message]() {\n    if (self->_socket.is_open()) {\n      // Set a deadline for the asynchronous operation.\n      self->_deadline.expires_from_now(boost::posix_time::seconds(60));\n\n      // Initiate the asynchronous operation itself.\n      boost::asio::async_write(\n          self->_socket,\n          message->GetBufferSequence(),\n          boost::asio::bind_executor(\n              self->_strand,\n              [self, message](const boost::system::error_code &ec, std::size_t) {\n                // Handle the result.\n                if (ec) {\n                  self->log_error(ec.message());\n                  self->CloseNow();\n                }\n              }));\n    } else {\n      self->log_error(\"Write: socket is not open.\");\n      self->CloseNow();\n    }\n  });\n}", "CodeBleu_score": 42.05244205363245}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!ec && _socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t_socket.close(ec);\n\t}\n\tshared_from_this()->_on_closed(ec);\n\tlog_debug(\"Session closed\");\n}", "CodeBleu_score": 48.09988684108206}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!ec && _socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t_socket.close(ec);\n\t}\n\t_on_closed(ec);\n\tlog_debug(\"Session closed\");\n}", "CodeBleu_score": 45.74010471736975}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t_deadline.cancel();\n\tif (!ec && _socket.is_open()) {\n\t\t_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t_socket.close(ec);\n\t}\n\t_on_closed();\n\tlog_debug(\"Session closed\");\n}", "CodeBleu_score": 46.261537597180734}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::string msg = \"Are you alive?\";\n\tstd::vector<char> buffer(msg.begin(), msg.end());\n\tlog_info(\"Sending IsAlive message\");\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\tstd::future<std::vector<char>> fut = _router->ReadFromNext();\n\tstd::vector<char> response = fut.get();\n\tlog_info(\"Response: \" + std::string(response.begin(), response.end()));\n}", "CodeBleu_score": 52.08684841826958}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::string msg = \"Are you alive?\";\n\tBuffer buffer(msg.size());\n\tbuffer.data = msg.c_str();\n\tlog_info(\"Sending message: %s\", msg.c_str());\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\tlog_info(\"Waiting for response...\");\n\tBuffer response = _router->ReadFromNext();\n\tlog_info(\"Response received: %s\", response.data);\n}", "CodeBleu_score": 51.60555783466616}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tstd::string msg = \"Are you alive?\";\n\tstd::unique_ptr<Buffer> buffer = std::make_unique<Buffer>(msg.size());\n\tmemcpy(buffer->data(), msg.c_str(), msg.size());\n\tlog_info(\"Sending message to check if system is alive.\");\n\t_router->WriteToNext(std::move(buffer), YOU_ALIVE);\n\tlog_info(\"Waiting for response.\");\n\tauto fut = _router->ReadFromNext();\n\tauto msg = fut.get();\n\tlog_info(\"Received message: \" + msg);\n}", "CodeBleu_score": 53.788599829884774}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t//Check if sensor is activated on any secondary server\n\tauto it = _servers.find(sensor_id);\n\tif (it!= _servers.end()) {\n\t\t//Create buffer with sensor ID\n\t\tstd::vector<uint8_t> buffer;\n\t\tbuffer.push_back(sensor_id);\n\t\t//Send ENABLE_ROS command to server using router\n\t\tstd::future<void> fut = _router->WriteToOne(it->second, ENABLE_ROS, buffer);\n\t\t//Wait for and process server's response\n\t\tfut.get();\n\t\t//Check if sensor is activated on any secondary server\n\t\tit = _servers.find(sensor_id);\n\t\tif (it!= _servers.end()) {\n\t\t\t//Log error message\n\t\t\tlog_error(\"Failed to enable sensor %d on server %d\", sensor_id, it->second);\n\t\t}\n\t}\n}", "CodeBleu_score": 47.19105870418359}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if sensor is activated on any secondary server\n\tbool found = false;\n\tfor (auto it = _servers.begin(); it!= _servers.end(); ++it) {\n\t\tif (it->second.find(sensor_id)!= it->second.end()) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tlog_error(\"Sensor not found on any secondary server\");\n\t\treturn;\n\t}\n\n\t// Create buffer with sensor ID\n\tstd::vector<uint8_t> buffer;\n\tbuffer.push_back(static_cast<uint8_t>(sensor_id));\n\n\t// Send ENABLE_ROS command to server\n\tauto fut = _router->WriteToOne(buffer, Command::ENABLE_ROS);\n\tif (fut.wait_for(std::chrono::milliseconds(1000)) == std::future_status::timeout) {\n\t\tlog_error(\"Timeout while waiting for ENABLE_ROS response\");\n\t\treturn;\n\t}\n\n\t// Process response\n\tauto response = fut.get();\n\tif (response.command!= Command::ENABLE_ROS_RESPONSE) {\n\t\tlog_error(\"Unexpected response to ENABLE_ROS\");\n\t\treturn;\n\t}\n\tif (response.buffer.size()!= 1) {\n\t\tlog_error(\"Unexpected response to ENABLE_ROS\");\n\t\treturn;\n\t}\n\tif (response.buffer.data()[0]!= 0) {\n\t\tlog_error(\"Failed to enable sensor for ROS\");\n\t}\n}", "CodeBleu_score": 46.250125610397816}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tstd::vector<uint8_t> buffer;\n\tbuffer.push_back(static_cast<uint8_t>(sensor_id));\n\tbuffer.push_back(static_cast<uint8_t>(Command::ENABLE_ROS));\n\tstd::vector<uint8_t> response;\n\tfor (auto& server : _servers) {\n\t\tif (server.second.find(sensor_id)!= server.second.end()) {\n\t\t\t_router->WriteToOne(server.first, buffer.data(), buffer.size());\n\t\t\tresponse = _router->ReadFromOne(server.first);\n\t\t\tif (response.size() == 1) {\n\t\t\t\tif (response[0] == static_cast<uint8_t>(Command::ENABLE_ROS)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlog_error(\"Sensor not found on any server\");\n}", "CodeBleu_score": 46.711489173252374}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\ttoken_type token;\n\tstd::map<stream_id, token_type>::iterator it = _tokens.find(sensor_id);\n\tif (it!= _tokens.end()) {\n\t\tlog_debug(\"PrimaryCommands::GetToken: Found existing token for sensor %d\", sensor_id);\n\t\treturn it->second;\n\t}\n\telse {\n\t\tlog_debug(\"PrimaryCommands::GetToken: No token found for sensor %d, activating sensor\", sensor_id);\n\t\tstream_id new_stream_id = GetNextServer(sensor_id);\n\t\ttoken = _router->ActivateSensor(sensor_id, new_stream_id);\n\t\t_tokens[sensor_id] = token;\n\t\t_stream_id_to_sensor_id[new_stream_id] = sensor_id;\n\t\tlog_debug(\"PrimaryCommands::GetToken: Activated sensor %d on server %d\", sensor_id, new_stream_id);\n\t\treturn token;\n\t}\n}", "CodeBleu_score": 55.573655071639116}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\ttoken_type token;\n\tstd::map<stream_id, token_type>::iterator it;\n\tit = _tokens.find(sensor_id);\n\tif (it!= _tokens.end()) {\n\t\tlog_debug(\"Sensor %d already activated, returning existing token\", sensor_id);\n\t\treturn it->second;\n\t} else {\n\t\ttoken = GetTokenFromSecondary(sensor_id);\n\t\t_tokens[sensor_id] = token;\n\t\t_stream_ids[token.get_stream_id()] = sensor_id;\n\t\tlog_debug(\"Sensor %d activated, returning new token\", sensor_id);\n\t\treturn token;\n\t}\n}", "CodeBleu_score": 54.1551228138047}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// Check if sensor is already activated\n\tif (this->_tokens.find(sensor_id)!= this->_tokens.end()) {\n\t\tlog_debug(\"PrimaryCommands::GetToken: Sensor already activated, returning existing token\");\n\t\treturn this->_tokens[sensor_id];\n\t}\n\n\t// Sensor is not activated, activate it on a secondary server\n\tSecondaryCommands* secondary = this->GetNextServer();\n\ttoken_type token = secondary->ActivateSensor(sensor_id);\n\n\t// Update maps\n\tthis->_tokens[sensor_id] = token;\n\tthis->_stream_ids[token.get_stream_id()] = sensor_id;\n\n\t// Log action\n\tlog_debug(\"PrimaryCommands::GetToken: Sensor not activated, activated on secondary server and returned new token\");\n\n\treturn token;\n}", "CodeBleu_score": 39.55806603874722}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f(filename, std::ios::binary);\n\tif (!f.is_open())\n\t\treturn false;\n\tstd::vector<char> data;\n\tf.seekg(0, std::ios::end);\n\tdata.resize(f.tellg());\n\tf.seekg(0, std::ios::beg);\n\tf.read(data.data(), data.size());\n\tf.close();\n\treturn Load(data);\n}", "CodeBleu_score": 51.03468841127394}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> data(std::istreambuf_iterator<char>(f), {});\n\tf.close();\n\treturn Load(data);\n}", "CodeBleu_score": 53.97696160070833}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\n\tstd::vector<char> file_data;\n\tf.seekg(0, std::ios::end);\n\tfile_data.resize(f.tellg());\n\tf.seekg(0, std::ios::beg);\n\tf.read(&file_data[0], file_data.size());\n\tf.close();\n\n\treturn Load(file_data);\n}", "CodeBleu_score": 58.007158984397655}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady())\n\t\treturn false;\n\tassert(m_crowd);\n\tauto it = _mapped_vehicles_id.find(id);\n\tif (it!= _mapped_vehicles_id.end()) {\n\t\tm_crowd->removeAgent(it->second);\n\t\t_mapped_vehicles_id.erase(it);\n\t\t_mapped_by_index.erase(it->second);\n\t\t_mapped_vehicles.erase(id);\n\t\treturn true;\n\t}\n\tauto it2 = _mapped_walkers_id.find(id);\n\tif (it2!= _mapped_walkers_id.end()) {\n\t\t_walker_manager.RemoveWalker(it2->second);\n\t\t_mapped_walkers_id.erase(it2);\n\t\t_mapped_by_index.erase(it2->second);\n\t\t_mapped_walkers.erase(id);\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 55.75847291766352}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(IsReady());\n\tDEBUG_ASSERT(m_crowd);\n\n\t// Walker\n\tauto it_walker = _mapped_walkers_id.find(id);\n\tif (it_walker!= _mapped_walkers_id.end()) {\n\t\t_mapped_walkers_id.erase(it_walker);\n\t\tm_crowd->removeAgent(it_walker->second);\n\t\t_walker_manager.RemoveWalker(id);\n\t\treturn true;\n\t}\n\n\t// Vehicle\n\tauto it_vehicle = _mapped_vehicles_id.find(id);\n\tif (it_vehicle!= _mapped_vehicles_id.end()) {\n\t\t_mapped_vehicles_id.erase(it_vehicle);\n\t\tm_crowd->removeAgent(it_vehicle->second);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 50.074231602337434}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(IsReady());\n\tDEBUG_ASSERT(_crowd);\n\tconst auto walker_it = _mapped_walkers_id.find(id);\n\tif (walker_it!= _mapped_walkers_id.end()) {\n\t\t_crowd->removeAgent(walker_it->second);\n\t\t_walker_manager.RemoveWalker(walker_it->second);\n\t\t_mapped_walkers_id.erase(walker_it);\n\t\t_mapped_by_index.erase(walker_it->second);\n\t\treturn true;\n\t}\n\tconst auto vehicle_it = _mapped_vehicles_id.find(id);\n\tif (vehicle_it!= _mapped_vehicles_id.end()) {\n\t\t_crowd->removeAgent(vehicle_it->second);\n\t\t_mapped_vehicles_id.erase(vehicle_it);\n\t\t_mapped_by_index.erase(vehicle_it->second);\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 51.79616092018975}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::set<int> current_ids;\n\tfor (auto& vehicle : vehicles) {\n\t\tcurrent_ids.insert(vehicle.id);\n\t\tif (updated.find(vehicle.id) == updated.end()) {\n\t\t\tAddOrUpdateVehicle(vehicle);\n\t\t}\n\t\telse {\n\t\t\tupdated.insert(vehicle.id);\n\t\t}\n\t}\n\n\tfor (auto& vehicle : vehicles) {\n\t\tif (updated.find(vehicle.id) == updated.end()) {\n\t\t\tRemoveAgent(vehicle.id);\n\t\t}\n\t}\n\tupdated.clear();\n\treturn true;\n}", "CodeBleu_score": 50.32731992497473}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\tstd::set<std::string> current_vehicles;\n\tfor (auto& v : vehicles) {\n\t\tcurrent_vehicles.insert(v.id);\n\t\tif (vehicles_.find(v.id) == vehicles_.end()) {\n\t\t\tvehicles_.insert(std::make_pair(v.id, Vehicle(v)));\n\t\t\tupdated.insert(v.id);\n\t\t}\n\t\telse {\n\t\t\tvehicles_[v.id].Update(v);\n\t\t\tupdated.insert(v.id);\n\t\t}\n\t}\n\tfor (auto& v : vehicles_) {\n\t\tif (updated.find(v.first) == updated.end()) {\n\t\t\tv.second.Remove();\n\t\t}\n\t}\n\tupdated.clear();\n\treturn true;\n}", "CodeBleu_score": 47.07840228036867}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\t// Collect IDs of currently mapped vehicles\n\tstd::set<int> current_ids;\n\tfor (auto& vehicle : m_vehicles) {\n\t\tcurrent_ids.insert(vehicle.first);\n\t}\n\n\t// Add or update vehicles from the provided list\n\tfor (auto& vehicle : vehicles) {\n\t\tauto it = m_vehicles.find(vehicle.id);\n\t\tif (it == m_vehicles.end()) {\n\t\t\t// Add new vehicle\n\t\t\tm_vehicles[vehicle.id] = Vehicle(vehicle);\n\t\t} else {\n\t\t\t// Update existing vehicle\n\t\t\tit->second.Update(vehicle);\n\t\t}\n\t\tcurrent_ids.erase(vehicle.id);\n\t}\n\n\t// Remove vehicles not marked as updated\n\tfor (auto id : current_ids) {\n\t\tm_vehicles.erase(id);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 53.862892175799715}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t#ifdef DEBUG\n  try {\n#endif\n\n    // First check if the actor is a vehicle or a walker\n    auto it_vehicle = _mapped_vehicles_id.find(id);\n    auto it_walker = _mapped_walkers_id.find(id);\n\n    if (it_vehicle!= _mapped_vehicles_id.end() || it_walker!= _mapped_walkers_id.end()) {\n\n      // Enter a critical section\n      std::lock_guard<std::mutex> lock(_mutex);\n\n      // Get the actor location\n      auto location = GetActorLocation(id);\n\n      // Compute the squared distance\n      auto squared_distance = distance * distance;\n\n      // Check if there is a vehicle nearby\n      return _crowd->hasVehicleNear(\n          location,\n          direction,\n          squared_distance);\n    }\n\n    return false;\n\n#ifdef DEBUG\n  } catch (const std::exception &e) {\n    log_error(\"Navigation::HasVehicleNear\", e.what());\n    return false;\n  }\n#endif\n}", "CodeBleu_score": 49.670228480506076}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t#ifdef LIBCARLA_DEBUG\n  debug_log(\n      \"Navigation::HasVehicleNear(ActorId id = %d, float distance = %f, carla::geom::Location direction = %s)\",\n      id, distance, direction.ToString().c_str());\n#endif // LIBCARLA_DEBUG\n  if (id == 0) {\n    return false;\n  }\n\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  auto it_walker = _mapped_walkers_id.find(id);\n  if (it_walker!= _mapped_walkers_id.end()) {\n    auto walker = it_walker->second;\n    auto distance_squared = walker->GetDistanceSquared();\n    if (distance_squared < distance * distance) {\n      return _crowd->hasVehicleNear(walker->GetPosition(), distance, direction);\n    }\n  }\n\n  auto it_vehicle = _mapped_vehicles_id.find(id);\n  if (it_vehicle!= _mapped_vehicles_id.end()) {\n    auto vehicle = it_vehicle->second;\n    auto distance_squared = vehicle->GetDistanceSquared();\n    if (distance_squared < distance * distance) {\n      return _crowd->hasVehicleNear(vehicle->GetPosition(), distance, direction);\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 52.24374381326287}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\n//  auto it_walkers = _mapped_walkers_id.find(id);\n//  if (it_walkers!= _mapped_walkers_id.end()) {\n//    return false;\n//  }\n//\n//  auto it_vehicles = _mapped_vehicles_id.find(id);\n//  if (it_vehicles == _mapped_vehicles_id.end()) {\n//    return false;\n//  }\n//\n//  auto vehicle = it_vehicles->second;\n//  auto vehicle_location = vehicle->GetLocation();\n//  auto vehicle_direction = vehicle->GetTransform().GetForwardVector();\n//\n//  std::lock_guard<std::mutex> lock(_mutex);\n//\n//  auto squared_distance = distance * distance;\n//  return _crowd->hasVehicleNear(\n//      vehicle_location.x,\n//      vehicle_location.y,\n//      vehicle_location.z,\n//      vehicle_direction.x,\n//      vehicle_direction.y,\n//      vehicle_direction.z,\n//      squared_distance);\n}", "CodeBleu_score": 3.6748418807689864}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto &route = info.route;\n\tauto &point = info.point;\n\tauto &context = info.context;\n\tauto &events = info.events;\n\tif (point >= route.size()) {\n\t\treturn EventResult::Finished;\n\t}\n\tauto &event = route[point];\n\tauto result = boost::variant2::visit(WalkerEventVisitor{context, delta}, event);\n\tif (result == EventResult::Finished) {\n\t\t++point;\n\t}\n\treturn result;\n}", "CodeBleu_score": 42.629911414078386}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tif (info.currentRoutePoint == info.route.end()) {\n\t\treturn EventResult::NoEvent;\n\t}\n\n\tauto &event = info.currentRoutePoint->event;\n\tif (event.has_value()) {\n\t\tWalkerEventVisitor visitor{id, info, delta};\n\t\treturn boost::variant2::visit(visitor, *event);\n\t}\n\treturn EventResult::NoEvent;\n}", "CodeBleu_score": 48.7938099666838}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tif (info.currentRoutePoint == nullptr) {\n\t\treturn EventResult::NoEvent;\n\t}\n\n\tWalkerEventVisitor visitor(info, delta);\n\treturn boost::variant2::visit(visitor, info.currentRoutePoint->event);\n}", "CodeBleu_score": 38.540605551023944}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n//Iterate through each road node in the XML document.\nfor (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\n//Extract the road ID from the road node's attributes.\nconst std::string road_id = road_node.attribute(\"id\").as_string();\n\n//Iterate through each lane section node within the lanes node.\nfor (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n\n//Retrieve the left, center, and right lane nodes.\npugi::xml_node left_lane_node = lane_section_node.child(\"left\");\npugi::xml_node center_lane_node = lane_section_node.child(\"center\");\npugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n//Parse the left, center, and right lanes.\nParseLanes(left_lane_node, carla::road::LaneType::LaneType_Driving, map_builder, road_id);\nParseLanes(center_lane_node, carla::road::LaneType::LaneType_Driving, map_builder, road_id);\nParseLanes(right_lane_node, carla::road::LaneType::LaneType_Driving, map_builder, road_id);\n}\n}\n}", "CodeBleu_score": 52.07888748671967}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\t// Iterate through each road node in the XML document\n\tfor (const auto &road_node : xml.children(\"road\")) {\n\t\t// Extract the road ID\n\t\tconst auto road_id = road_node.attribute(\"id\").as_uint();\n\n\t\t// Process each lane section within the lanes node\n\t\tconst auto lanes_node = road_node.child(\"lanes\");\n\t\tfor (const auto &lane_section_node : lanes_node.children(\"laneSection\")) {\n\t\t\t// Retrieve the left, center, and right lane nodes\n\t\t\tconst auto left_lane_node = lane_section_node.child(\"left\");\n\t\t\tconst auto center_lane_node = lane_section_node.child(\"center\");\n\t\t\tconst auto right_lane_node = lane_section_node.child(\"right\");\n\n\t\t\t// Parse the left, center, and right lanes\n\t\t\tParseLanes(left_lane_node, road_id, map_builder);\n\t\t\tParseLanes(center_lane_node, road_id, map_builder);\n\t\t\tParseLanes(right_lane_node, road_id, map_builder);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.77935869791068}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n/*\n * This function, LaneParser::ParseLanes, parses lane nodes from an XML document and updates a MapBuilder object.", "CodeBleu_score": 4.820280652970521}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change > 0) {\n\t\t// A new match has been detected\n\t\tm_matched_count++;\n\t\tm_first_connection = (m_matched_count == 1);\n\t} else if (info.current_count_change < 0) {\n\t\t// A match has been lost\n\t\tm_matched_count--;\n\t} else {\n\t\t// Invalid count change\n\t\tstd::cerr << \"Error: Invalid count change in on_publication_matched\" << std::endl;\n\t}\n}", "CodeBleu_score": 47.184819433398786}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tm_matchedCount++;\n\t\tif (m_matchedCount == 1) {\n\t\t\tm_firstConnection = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tm_matchedCount--;\n\t} else {\n\t\tEFD_ERROR(\"CarlaListenerImpl::on_publication_matched: invalid count change: \" << info.current_count_change);\n\t}\n}", "CodeBleu_score": 54.60740050434403}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tm_matchedCount++;\n\t\tm_firstConnection = true;\n\t} else if (info.current_count_change == -1) {\n\t\tm_matchedCount--;\n\t} else {\n\t\tEFD_FAIL() << \"CarlaListenerImpl::on_publication_matched: invalid count change: \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 57.38480686013175}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t// New subscription\n\t\tm_matchedCount++;\n\t\tm_firstConnected = true;\n\t} else if (info.current_count_change == -1) {\n\t\t// Lost subscription\n\t\tm_matchedCount--;\n\t\tif (m_matchedCount == 0) {\n\t\t\tm_owner->DestroySubscriber();\n\t\t}\n\t} else {\n\t\t// Error\n\t\tCARLA_ERROR(\"CarlaSubscriberListenerImpl::on_subscription_matched - invalid change count\");\n\t}\n}", "CodeBleu_score": 52.88359493088536}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t// A new subscription has been matched\n\t\tm_matchedCount++;\n\t\tm_firstConnected = true;\n\t\tCARLA_ASSERT(m_matchedCount > 0);\n\t} else if (info.current_count_change == -1) {\n\t\t// A subscription has been unmatched\n\t\tm_matchedCount--;\n\t\tif (m_matchedCount == 0) {\n\t\t\t// There are no remaining subscriptions\n\t\t\tm_owner->DestroySubscriber();\n\t\t}\n\t} else {\n\t\tCARLA_ASSERT_INT(info.current_count_change == 1 || info.current_count_change == -1, info.current_count_change);\n\t}\n}", "CodeBleu_score": 61.92269637611463}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change > 0) {\n\t\t// A new subscription has been matched\n\t\tm_matched_count++;\n\t\tif (m_matched_count == 1) {\n\t\t\tm_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change < 0) {\n\t\t// A subscription has been unmatched\n\t\tm_matched_count--;\n\t\tif (m_matched_count == 0) {\n\t\t\t// No subscriptions left, so delete the subscriber\n\t\t\tm_owner->DestroySubscriber();\n\t\t}\n\t} else {\n\t\t// A subscription has been matched, but the change count is invalid\n\t\tELOG(\"CarlaSubscriberListenerImpl::on_subscription_matched - Invalid subscription change count\n\");\n\t}\n}", "CodeBleu_score": 49.883836691263326}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\n/*\n * This function, CarlaCollisionEventPubSubType::getKeyMaxCdrSerializedSize, returns the maximum serialized size of the key of an instance of CarlaCollisionEvent.\n */", "CodeBleu_score": 2.526167472328405}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\nCarlaCollisionEventPubSubType::getKey\n", "CodeBleu_score": 4.776839743375235}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize()>16) {\n\t\tm_md5.init();\n\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t}\n\telse {\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 90.13149542710148}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\nFastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\nCdr ser(fastbuffer, payload->encapsulation);\n\nser.serializeEncapsulation();\n\ntry {\np_type->serialize(ser);\n} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\nreturn false;\n}\n\npayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\nreturn true;\n}", "CodeBleu_score": 67.67455353059195}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\n// Create a FastBuffer and a Cdr object for serialization\nFastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\nCdr ser(fastbuffer);\n\n// Set the payload encapsulation based on endianness\nser.m_endianness = m_endianness;\n\n// Attempt to serialize the object\ntry {\n    // Serialize the object\n    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n    p_type->serialize(ser);\n} catch (std::exception& e) {\n    // If there is a memory exception, return false\n    return false;\n}\n\n// Update the payload length with the serialized data length\npayload->length = static_cast<uint32_t>(fastbuffer.get_position());\n\n// Return true if serialization succeeded\nreturn true;\n}", "CodeBleu_score": 49.41380853339916}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\n// Create a FastBuffer for serialization\nFastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\n// Create a Cdr object for serialization\nCdr ser(fastbuffer);\n\n// Set the payload encapsulation based on endianness\npayload->encapsulation = ser.endianness() == BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\n// Serialize the object\ntry {\n    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    p_type->serialize(ser);\n} catch (std::exception& e) {\n    return false;\n}\n\n// Update the payload length with the serialized data length\npayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\nreturn true;\n}", "CodeBleu_score": 61.041796614937425}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// check if target has already been set\n\tif (g.sysid_target!= 0) {\n\t\t// target already set, exit\n\t\treturn;\n\t}\n\n\t// decode the message\n\tswitch (msg.msgid) {\n\t\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT: {\n\t\t\tmavlink_global_position_int_t packet;\n\t\t\tmavlink_msg_global_position_int_decode(&msg, &packet);\n\n\t\t\t// set target sysid\n\t\t\tg.sysid_target = msg.sysid;\n\n\t\t\t// request data streams\n\t\t\trequest_datastream_position();\n\t\t\trequest_datastream_airpressure();\n\n\t\t\t// flag that target has been set\n\t\t\ttarget_set = true;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase MAVLINK_MSG_ID_GPS_RAW_INT: {\n\t\t\tmavlink_gps_raw_int_t packet;\n\t\t\tmavlink_msg_gps_raw_int_decode(&msg, &packet);\n\n\t\t\t// set target sysid\n\t\t\tg.sysid_target = msg.sysid;\n\n\t\t\t// request data streams\n\t\t\trequest_datastream_position();\n\n\t\t\t// flag that target has been set\n\t\t\ttarget_set = true;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase MAVLINK_MSG_ID_ATTITUDE: {\n\t\t\tmavlink_attitude_t packet;\n\t\t\tmavlink_msg_attitude_decode(&msg, &packet);\n\n\t\t\t// set target sysid\n\t\t\tg.sysid_target = msg.sysid;\n\n\t\t\t// request data streams\n\t\t\trequest_datastream_position();\n\n\t\t\t// flag that target has been set\n\t\t\ttarget_set = true;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault: {\n\t\t\t// message type not supported\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.7653119058091}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (tracker.g.sysid_target!= 0) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_ATTITUDE:\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n\tcase MAVLINK_MSG_ID_VFR_HUD:\n\tcase MAVLINK_MSG_ID_GPS_RAW_INT:\n\tcase MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:\n\tcase MAVLINK_MSG_ID_RC_CHANNELS_RAW:\n\tcase MAVLINK_MSG_ID_SYS_STATUS:\n\tcase MAVLINK_MSG_ID_BATTERY_STATUS:\n\tcase MAVLINK_MSG_ID_RAW_IMU:\n\tcase MAVLINK_MSG_ID_SCALED_PRESSURE:\n\tcase MAVLINK_MSG_ID_SCALED_PRESSURE2:\n\tcase MAVLINK_MSG_ID_SCALED_PRESSURE3:\n\tcase MAVLINK_MSG_ID_SCALED_IMU:\n\tcase MAVLINK_MSG_ID_SCALED_IMU2:\n\tcase MAVLINK_MSG_ID_SCALED_IMU3:\n\tcase MAVLINK_MSG_ID_SCALED_PRESSURE_TEMP:\n\tcase MAVLINK_MSG_ID_SCALED_PRESSURE_TEMP2:\n\tcase MAVLINK_MSG_ID_SCALED_PRESSURE_TEMP3:\n\tcase MAVLINK_MSG_ID_LOCAL_POSITION_NED:\n\tcase MAVLINK_MSG_ID_GPS_STATUS:\n\tcase MAVLINK_MSG_ID_RAW_PRESSURE:\n\tcase MAVLINK_MSG_ID_RAW_PRESSURE2:\n\tcase MAVLINK_MSG_ID_RAW_PRESSURE3:\n\tcase MAVLINK_MSG_ID_ATTITUDE_QUATERNION:\n\tcase MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV:\n\tcase MAVLINK_MSG_ID_ATTITUDE_TARGET:\n\tcase MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV:\n\t", "CodeBleu_score": 15.763934440748942}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_ATTITUDE:\n\t\ttracker.g.sysid_target = msg.sysid;\n\t\ttracker.gcs().request_datastream_position();\n\t\ttracker.gcs().request_datastream_airpressure();\n\t\ttarget_set = true;\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_GPS_RAW_INT:\n\t\ttracker.g.sysid_target = msg.sysid;\n\t\ttracker.gcs().request_datastream_airpressure();\n\t\ttarget_set = true;\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_GPS_STATUS:\n\t\ttracker.g.sysid_target = msg.sysid;\n\t\ttracker.gcs().request_datastream_position();\n\t\ttarget_set = true;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 43.20017408578918}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// call base class handler\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n\t// if the base class handler accepted the command, set a flag to indicate that altitude calibration is needed on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\n\t// return the result of the base class handler\n\treturn result;\n}", "CodeBleu_score": 64.61575297283765}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\tbaro_calibration_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 64.59021083549183}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// Call the base class handler\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n\t// If the base class handler accepted the command, set a flag to indicate that altitude calibration is needed on the next barometer update\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_altitude_calibration_needed = true;\n\t}\n\n\t// Return the result of the base class handler\n\treturn result;\n}", "CodeBleu_score": 65.54291762407973}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// Only accept the command if the system is calibrated and the compass is healthy\n\tif (tracker.is_calibrated() && tracker.is_compass_healthy()) {\n\t\t// If the command parameter is 1.0, arm the servos and return MAV_RESULT_ACCEPTED\n\t\tif (packet.param1 == 1.0) {\n\t\t\ttracker.arm_servos();\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t\t// If the command parameter is 0, disarm the servos and return MAV_RESULT_ACCEPTED\n\t\telse if (packet.param1 == 0) {\n\t\t\ttracker.disarm_servos();\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t\t// For any other parameter value, return MAV_RESULT_UNSUPPORTED\n\t\telse {\n\t\t\treturn MAV_RESULT_UNSUPPORTED;\n\t\t}\n\t}\n\t// If the system is not calibrated or the compass is unhealthy, return MAV_RESULT_FAILED\n\telse {\n\t\treturn MAV_RESULT_FAILED;\n\t}\n}", "CodeBleu_score": 67.172473256739}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0) {\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 70.2721093401741}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// The command is accepted if the component is the system component and the command is either 1.0 (arm) or 0.0 (disarm)\n\tif (packet.target_component == MAV_COMP_ID_SYSTEM_CONTROL && (packet.param1 == 1.0 || packet.param1 == 0.0)) {\n\t\tif (packet.param1 == 1.0) {\n\t\t\ttracker.arm_servos();\n\t\t} else {\n\t\t\ttracker.disarm_servos();\n\t\t}\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 55.555952354360315}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// TODO: check for available payload space\n\t// TODO: iterate over available GCS channels\n\t// TODO: send request to start data stream\n}", "CodeBleu_score": 5.6972778276543705}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i = 0; i < num_gcs; i++) {\n\t\tif (gcs[i].available_payload_space() >= MAVLINK_MSG_REQUEST_DATA_STREAM_LEN) {\n\t\t\tgcs[i].send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, sysid, compid, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 44.84927652041628}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tuint8_t i;\n\tuint8_t num_gcs = 0;\n\n\tfor (i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\tif (gcs[i].initialised && gcs[i].gcs_type!= GCS_TYPE_NONE && gcs[i].gcs_type!= GCS_TYPE_MAVLINK1) {\n\t\t\tnum_gcs++;\n\t\t}\n\t}\n\n\tif (num_gcs == 0) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\tif (gcs[i].initialised && gcs[i].gcs_type!= GCS_TYPE_NONE && gcs[i].gcs_type!= GCS_TYPE_MAVLINK1) {\n\t\t\tif (gcs[i].have_space(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, MAVLINK_MSG_REQUEST_DATA_STREAM_LEN)) {\n\t\t\t\tmavlink_msg_request_data_stream_send(gcs[i].chan, sysid, compid, MAV_DATA_STREAM_POSITION, 100, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.824681999979845}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAP_AHRS_DCM &ahrs = AP_AHRS_DCM::get_DCM_instance();\n\n\tif (ahrs.cos_pitch == 0) {\n\t\treturn false;\n\t}\n\n\tef_pitch = atan2f(ahrs.sin_roll * pitch - ahrs.cos_roll * yaw, ahrs.cos_roll * pitch + ahrs.sin_roll * yaw);\n\tef_yaw = atan2f(ahrs.cos_roll * yaw - ahrs.sin_roll * pitch, ahrs.cos_pitch);\n\n\treturn true;\n}", "CodeBleu_score": 59.77428738780281}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch > 0.001f) {\n\t\tef_pitch = atan2f(ahrs.sin_roll * pitch + ahrs.cos_roll * yaw, ahrs.cos_roll * pitch - ahrs.sin_roll * yaw);\n\t\tef_yaw = atan2f(-ahrs.cos_roll * pitch + ahrs.sin_roll * yaw, ahrs.cos_pitch);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 48.874907323691495}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// get AHRS instance\n\tAP_AHRS_SIM *ahrs = ahrs_sim.get_ahrs();\n\n\t// check for zero pitch cosine\n\tif (ahrs->cos_pitch == 0) {\n\t\treturn false;\n\t}\n\n\t// convert body frame pitch and yaw to earth frame angles\n\tef_pitch = atan2f(ahrs->sin_roll * pitch, ahrs->cos_roll * ahrs->cos_pitch);\n\tef_yaw = yaw + atan2f(ahrs->sin_roll * ahrs->sin_pitch, ahrs->cos_roll);\n\n\treturn true;\n}", "CodeBleu_score": 53.87039319931907}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// get the target yaw and pitch in centidegrees\n\tget_target_yaw_and_pitch_cd();\n\t// check if the direction is reversed\n\tget_ef_yaw_direction();\n\t// convert the errors from earth frame to body frame\n\tconvert_ef_to_bf();\n\t// check if the target distance is valid or no minimum distance is set\n\tif (target_distance_cm >= 0 || min_distance_cm == 0) {\n\t\t// update the pitch servo\n\t\ttracker.update_pitch_servo();\n\t\t// update the yaw servo\n\t\ttracker.update_yaw_servo();\n\t}\n}", "CodeBleu_score": 10.103749708867486}, {"code": "void Mode::update_auto(void){\n\t\t// update target yaw and pitch\n\tif (nav.get_nav_state() == NAV_STATE_OK) {\n\t\t// calculate target yaw and pitch in centidegrees\n\t\tfloat target_yaw = calc_target_yaw();\n\t\tfloat target_pitch = calc_target_pitch();\n\n\t\t// check if direction is reversed\n\t\tif (nav.get_nav_dir() == NAV_DIR_REVERSE) {\n\t\t\ttarget_yaw += 18000;\n\t\t}\n\n\t\t// calculate angle error\n\t\tfloat yaw_error = constrain_float(target_yaw - tracker.get_yaw(), -18000, 18000);\n\t\tfloat pitch_error = constrain_float(target_pitch - tracker.get_pitch(), -9000, 9000);\n\n\t\t// convert from earth frame to body frame\n\t\tfloat bf_yaw_error = convert_ef_to_bf(yaw_error, tracker.get_yaw());\n\t\tfloat bf_pitch_error = convert_ef_to_bf(pitch_error, tracker.get_yaw());\n\n\t\t// if the target distance is valid or no minimum distance is set\n\t\tif (nav.get_dist_valid() || (nav.get_dist_min() == 0)) {\n\t\t\t// update pitch and yaw servos\n\t\t\ttracker.update_pitch_servo(bf_pitch_error);\n\t\t\ttracker.update_yaw_servo(bf_yaw_error);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.78880617193326}, {"code": "void Mode::update_auto(void){\n\t\tfloat yaw_cd, pitch_cd;\n\tbool direction_reversed = false;\n\tfloat angle_error;\n\n\tif (nav_status == NAV_STATUS_OK) {\n\t\tif (nav_bearing_cd!= 0) {\n\t\t\tyaw_cd = nav_bearing_cd;\n\t\t} else {\n\t\t\tyaw_cd = nav_heading_cd;\n\t\t}\n\n\t\tif (nav_distance_m!= 0) {\n\t\t\tpitch_cd = nav_elevation_cd;\n\t\t} else {\n\t\t\tpitch_cd = 0;\n\t\t}\n\n\t\tif (nav_bearing_cd < 0) {\n\t\t\tdirection_reversed = true;\n\t\t}\n\t} else {\n\t\tyaw_cd = 0;\n\t\tpitch_cd = 0;\n\t}\n\n\tangle_error = calc_angle_error(yaw_cd, pitch_cd);\n\n\tif (direction_reversed) {\n\t\tangle_error = -angle_error;\n\t}\n\n\tconvert_ef_to_bf(angle_error, yaw_cd, pitch_cd);\n\n\tif ((nav_distance_m!= 0) || (min_distance_m == 0)) {\n\t\ttracker.update_pitch_servo(pitch_cd);\n\t}\n\n\ttracker.update_yaw_servo(yaw_cd);\n}", "CodeBleu_score": 39.13630273443551}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time_ms!= last_gps_message_time_ms) {\n\t\tlast_gps_message_time_ms = gps.last_message_time_ms;\n\t\tif (gps.status >= 3) {\n\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\tground_start_countdown--;\n\t\t\t\t\tif (ground_start_countdown <= 0) {\n\t\t\t\t\t\tset_home();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.11175816160895}, {"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\n\t// if the last message time has changed and the GPS status is at least 3D fix\n\tif (gps.last_message_time_ms!= last_GPS_message_time_ms && gps.status >= 3) {\n\t\tlast_GPS_message_time_ms = gps.last_message_time_ms;\n\n\t\t// if ground start is enabled\n\t\tif (ground_start_enabled) {\n\t\t\t// if the current location is valid\n\t\t\tif (gps.location.isValid()) {\n\t\t\t\t// if the countdown is not yet started\n\t\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\t\t// start the countdown\n\t\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN_TIME;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// reset the countdown\n\t\t\t\tground_start_countdown = 0;\n\t\t\t}\n\n\t\t\t// if the countdown has reached one\n\t\t\tif (ground_start_countdown == 1) {\n\t\t\t\t// set the home location\n\t\t\t\tset_home();\n\t\t\t}\n\n\t\t\t// if the countdown is running\n\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\t// decrement the countdown\n\t\t\t\tground_start_countdown--;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.388429660762185}, {"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time_ms!= last_gps_time_ms) {\n\t\tlast_gps_time_ms = gps.last_message_time_ms;\n\t\tif (gps.status >= 3) {\n\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\tset_home();\n\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t} else {\n\t\t\t\t\tground_start_countdown = GROUND_START_COUNTDOWN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.12659202116408}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch < 0) {\n\t\t_channels->set_output_scaled(CH_6, 1000);\n\t} else {\n\t\t_channels->set_output_scaled(CH_6, 2000);\n\t}\n}", "CodeBleu_score": 15.857168122947558}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch < 0) {\n\t\tif (pitch < -45) {\n\t\t\tpitch = -45;\n\t\t}\n\t\t_pitch_servo.write(90 - pitch);\n\t} else {\n\t\tif (pitch > 45) {\n\t\t\tpitch = 45;\n\t\t}\n\t\t_pitch_servo.write(90 + pitch);\n\t}\n}", "CodeBleu_score": 15.5780857721573}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0) {\n\t\t// positive pitch\n\t\t_pitch_onoff_servo.write(pitch);\n\t} else {\n\t\t// negative pitch\n\t\t_pitch_onoff_servo.write(180 - pitch);\n\t}\n}", "CodeBleu_score": 14.532560513003082}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// check base class\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check barometer\n\tif (g.arming_check & ARMING_CHECK_BARO) {\n\t\t// check baro reference\n\t\tif (!barometer.reference_valid()) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"Baro reference not valid\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// check baro altitude\n\t\tfloat baro_alt_cm = barometer.get_altitude_cm();\n\t\tfloat baro_alt_diff = fabsf(baro_alt_cm - copter.inertial_nav.get_position_z_cm());\n\t\tif (baro_alt_diff > g.arming_check_alt_max_diff) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"Baro altitude too far from INS\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 48.665613927082774}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call base class barometer check\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check barometer altitude\n\tif (g.arming_check & ARMING_CHECK_BARO) {\n\t\t// check barometer reference\n\t\tif (!barometer_reference_valid()) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"barometer reference not valid\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// check barometer altitude\n\t\tif (fabsf(copter.inertial_nav.get_position_z_cm() - barometer.get_altitude_cm()) > g.arming_baro_min_cms) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"barometer altitude check failed\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 45.26738402508922}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call base class checks\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n#if ARMING_CHECK_BARO == ENABLED\n\t// check barometer reference\n\tif (!barometer.reference_valid()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"baro reference not valid\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check baro altitude vs inertial altitude\n\tfloat baro_alt = barometer.get_altitude();\n\tfloat inertial_alt = inertial_nav.get_position_z_cm();\n\tfloat diff = baro_alt - inertial_alt;\n\tif (fabsf(diff) > g.arming_check_alt_cm) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"baro alt %5.1f inertial alt %5.1f\"), baro_alt, inertial_alt);\n\t\t}\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}", "CodeBleu_score": 45.95190985804476}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::Terrain_Source_Rangefinder) {\n\t\treturn false;\n\t} else if (copter.wp_nav->get_terrain_source() == AP_WPNav::Terrain_Source_Database && copter.mode_rtl.get_alt_type() == AP_RTL::Terrain) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 69.821474437175}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\t// if terrain is from a rangefinder, we don't need a database\n\tif (copter.wp_nav->get_terrain_source() == Terrain::SOURCE_RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\t// if terrain is from the database, and we are using terrain for RTL\n\t// altitude, we need a database\n\tif (copter.wp_nav->get_terrain_source() == Terrain::SOURCE_DATABASE &&\n\t    copter.mode_rtl.get_alt_type() == RTL_ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\n\t// otherwise, defer to the base class implementation\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 72.27225836903459}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::TerrainSource_Rangefinder) {\n\t\treturn false;\n\t}\n\tif (copter.wp_nav->get_terrain_source() == AP_WPNav::TerrainSource_Database && copter.mode_rtl.get_alt_type() == AP_RTL::AltType_Terrain) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 72.61969799238803}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for the attitude, position, and motor controllers\n\t// using the last loop time from the scheduler\n\tfloat dt = AP::scheduler.get_last_loop_time_s();\n\t// run the low-level rate controllers that require only IMU data\n\t// by invoking the rate_controller_run method of the attitude control\n\tattitude_control->set_dt(dt);\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 43.62171472390182}, {"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for the attitude, position, and motor controllers\n\t// from the last loop time from the scheduler\n\tfloat dt = AP::scheduler.get_last_loop_time_s();\n\t// set the loop time for the attitude controller\n\tattitude_control->set_dt(dt);\n\t// set the loop time for the position controller\n\tpos_control->set_dt(dt);\n\t// set the loop time for the motor controller\n\tmotors->set_dt(dt);\n\n\t// run the rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 57.06465929703628}, {"code": "void Copter::run_rate_controller(){\n\t\t// set the dt for the rate controllers\n\tfloat dt = AP::scheduler.get_last_loop_time_s();\n\tattitude_control->set_dt(dt);\n\tpos_control->set_dt(dt);\n\tmotors->set_dt(dt);\n\n\t// run the rate controllers\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 57.06465929703628}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// if the old location matches the new location, then we have not moved\n\tif (old_loc.same_loc_as(new_loc)) {\n\t\treturn false;\n\t}\n\n\t// if the altitude frames do not match, then we cannot use the new location\n\tif (!old_loc.get_alt_frame().same_as(new_loc.get_alt_frame())) {\n\t\treturn false;\n\t}\n\n\t// if we are in auto, then we can use the new location\n\tif (control_mode == AUTO) {\n\t\ttarget_location = new_loc;\n\t\treturn true;\n\t}\n\n\t// if we are in GUIDED mode and the new location is a waypoint, then we can use the new location\n\tif (control_mode == GUIDED) {\n\t\tif (new_loc.is_valid() && new_loc.get_type() == Location::WP) {\n\t\t\ttarget_location = new_loc;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// otherwise we cannot use the new location\n\treturn false;\n}", "CodeBleu_score": 53.90606642238631}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (flightmode->get_wp() == NULL) {\n\t\treturn false;\n\t}\n\n\tif (!old_loc.same_loc_as(flightmode->get_wp()->get_location())) {\n\t\treturn false;\n\t}\n\n\tif (!old_loc.get_alt_frame().same_alt_frame_as(new_loc.get_alt_frame())) {\n\t\treturn false;\n\t}\n\n\tset_target_location(new_loc);\n\treturn true;\n}", "CodeBleu_score": 56.51328756619476}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// if we have a new waypoint, update the target location\n\tif (new_loc.is_valid()) {\n\t\t// if the new location is the same as the old location, don't do anything\n\t\tif (old_loc.same_loc_as(new_loc)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if the altitude frames are different, we need to re-calculate the target altitude\n\t\tif (old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\t\t// set the target altitude to the new altitude\n\t\t\tset_target_altitude(new_loc.alt);\n\t\t}\n\n\t\t// set the target location\n\t\t_target_loc = new_loc;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 53.27447229423085}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AUX_HIGH) {\n\t\tcopter.set_mode(mode);\n\t} else if (mode == copter.flightmode->mode_number) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 50.725846560788334}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (rc().aux_switch_pos(ch_flag) == AUX_HIGH) {\n\t\tcopter.set_mode(mode);\n\t} else if (rc().aux_switch_pos(ch_flag) == AUX_LOW && copter.flightmode->mode_number == mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 57.05358531860563}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\t// Only change the mode if the switch is in the HIGH position\n\tif (ch_flag == AUX_HIGH) {\n\t\t// Attempt to set the mode\n\t\tcopter.set_mode(mode);\n\t} else if (mode == copter.flightmode->mode_number) {\n\t\t// If the switch is not in the HIGH position and the current flight mode matches the given mode,\n\t\t// reset the mode switch\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 50.67882842368522}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// calculate trim values from control inputs\n\tfloat roll_trim = ToRad(channel_roll->get_control_in() * g.rc_3_trim);\n\tfloat pitch_trim = ToRad(channel_pitch->get_control_in() * g.rc_4_trim);\n\n\t// add trim values to AHRS trim\n\tahrs.add_trim(roll_trim, pitch_trim);\n\n\t// log event\n\tLog_Write_Event(DATA_TRIM_SAVE, roll_trim, pitch_trim);\n\n\t// send confirmation message\n\tgcs().send_message(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 63.00050660311649}, {"code": "void Copter::save_trim(){\n\t\t// calculate trim values\n\tfloat roll_trim = ToRad(g.channel_roll->get_control_in()) - ahrs.roll_trim;\n\tfloat pitch_trim = ToRad(g.channel_pitch->get_control_in()) - ahrs.pitch_trim;\n\n\t// add trim values to ahrs\n\tahrs.add_trim(roll_trim, pitch_trim);\n\n\t// log the event\n\tLog_Write_Event(DATA_TRIM_SAVE, roll_trim, pitch_trim);\n\n\t// send a confirmation message\n\tgcs().send_message(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 61.15914827229294}, {"code": "void Copter::save_trim(){\n\t\t// save the current trim values\n\tfloat trim_roll = channel_roll->get_control_in() * 0.01f;\n\tfloat trim_pitch = channel_pitch->get_control_in() * 0.01f;\n\n\t// convert to radians\n\ttrim_roll = ToRad(trim_roll);\n\ttrim_pitch = ToRad(trim_pitch);\n\n\t// add to AHRS trim\n\tahrs.add_trim(trim_roll, trim_pitch, 0);\n\n\t// log the event\n\tLOGGER_WRITE_EVENT(LOG_SUBSYSTEM_AUTOPILOT, LOG_CATEGORY_CONTROL, LOG_LEVEL_INFO, LOG_EVENT_AP_TRIM_SAVE, trim_roll, trim_pitch, 0);\n\n\t// send a confirmation message\n\tgcs().send_message(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 50.428981712329545}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat yaw = 0;\n\tVector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\tfloat speed_squared = vel.xy().length_squared();\n\tif (copter.position_ok && speed_squared > 0.0f) {\n\t\tyaw = atan2f(vel.y, vel.x);\n\t}\n\treturn yaw;\n}", "CodeBleu_score": 46.05943698161923}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// calculate yaw angle to look ahead\n\tVector3f vel = inertial_nav.get_velocity_neu_cms();\n\tfloat speed_squared = vel.length_squared();\n\tif (copter.position_ok && speed_squared > 0) {\n\t\t// update look-ahead yaw angle\n\t\tlook_ahead_yaw_angle = atan2f(vel.y, vel.x);\n\t\treturn look_ahead_yaw_angle;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 40.45688608213891}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// get velocity\n\tVector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n\t// calculate speed squared\n\tfloat speed_squared = vel.xy().length_squared();\n\n\t// if position is valid and speed exceeds a minimum threshold\n\tif (copter.position_ok && speed_squared > 0.1f) {\n\t\t// update look-ahead yaw angle\n\t\t_look_ahead_yaw = atan2f(vel.y, vel.x);\n\t}\n\n\t// return computed look-ahead yaw angle\n\treturn _look_ahead_yaw;\n}", "CodeBleu_score": 53.17127125484473}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\t// if rudder arming is disabled, don't arm\n\t\tif (get_rudder_arming_type() == AP_Arming::RUDDER_DISABLED) {\n\t\t\tgcs().send_text_P(SEVERITY_LOW, PSTR(\"rudder arming disabled\"));\n\t\t\treturn false;\n\t\t}\n\n\t\t// if throttle is not zero, don't arm\n\t\tif (!plane.get_throttle_input()->is_zero()) {\n\t\t\tgcs().send_text_P(SEVERITY_LOW, PSTR(\"throttle not zero\"));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// if arming checks are disabled, bypass them\n\tif (!is_enabled()) {\n\t\treturn true;\n\t}\n\n\t// if the watchdog was armed, bypass checks\n\tif (hal.util->was_watchdog_armed()) {\n\t\tgcs().send_text_P(SEVERITY_LOW, PSTR(\"watchdog armed\"));\n\t\treturn true;\n\t}\n\n\t// perform checks\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 59.75061809206177}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t#if AP_ARMED_RUDDER_DISABLED == ENABLED\n    if (method == AP_Arming::RUDDER) {\n        if (plane.get_rudder_arming_type() == AP_Rudder::RUDDER_ARMING_DISABLED) {\n            gcs().send_text(MAV_SEVERITY_INFO, \"Rudder arming disabled\");\n            return false;\n        }\n        if (!plane.get_throttle_input()->is_zero()) {\n            gcs().send_text(MAV_SEVERITY_INFO, \"Throttle not zero\");\n            return false;\n        }\n    }\n#endif\n    if (method == AP_Arming::DISABLED) {\n        return true;\n    }\n    if (hal.util->was_watchdog_armed()) {\n        return true;\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 66.59115310136698}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (get_rudder_arming_type() == RUDDER_ARMING_DISABLED) {\n\t\t\tgcs().send_text(MAV_SEVERITY_INFO, \"rudder arming disabled\");\n\t\t\treturn false;\n\t\t}\n\t\tif (plane.get_throttle_input()!= 0) {\n\t\t\tgcs().send_text(MAV_SEVERITY_INFO, \"throttle not zero\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (method == AP_Arming::DISABLED || hal.util->was_watchdog_armed()) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 56.81789870367792}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (method == AP_Arming::Method::None) {\n\t\treturn false;\n\t}\n\n\t// check if we are already armed\n\tif (_armed) {\n\t\treturn false;\n\t}\n\n\t// run arming checks\n\tif (do_arming_checks &&!_arming_checks.run_checks(method)) {\n\t\treturn false;\n\t}\n\n\t// set the arm state\n\t_arming_state.arm_state = AP_Arming::ArmingState::Armed;\n\n\t// set the delay arming flag\n\t_arming_state.delay_arming = true;\n\n\t// set the home location\n\t_home = _plane.get_home_location();\n\n\t// set the home location in the AHRS system\n\t_plane.ahrs.set_home(_home);\n\n\t// update the current location\n\t_plane.update_current_loc();\n\n\t// send a status text indicating that the throttle is armed\n\tsend_arm_disarm_statustext();\n\n\treturn true;\n}", "CodeBleu_score": 51.5838683746374}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// don't arm if already armed\n\tif (arming_state.armed) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid GPS lock\n\tif (do_arming_checks &&!ahrs.get_gps().status_flags.have_lock) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid compass\n\tif (do_arming_checks &&!ahrs.compass.is_healthy()) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid airspeed\n\tif (do_arming_checks &&!airspeed.is_healthy()) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid battery\n\tif (do_arming_checks &&!battery.is_healthy()) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid barometer\n\tif (do_arming_checks &&!barometer.is_healthy()) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid sonar\n\tif (do_arming_checks &&!sonar.is_healthy()) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid optflow\n\tif (do_arming_checks &&!optflow.is_healthy()) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid rangefinder\n\tif (do_arming_checks &&!rangefinder.is_healthy()) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid inertial nav\n\tif (do_arming_checks &&!inertial_nav.is_healthy()) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid attitude\n\tif (do_arming_checks &&!ahrs.get_health_flags().attitude) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid position\n\tif (do_arming_checks &&!ahrs.get_health_flags().position) {\n\t\treturn false;\n\t}\n\n\t// check that we have a valid altitude\n\tif (do_arming_checks &&!ahrs.get_health_flags().altitude", "CodeBleu_score": 29.581400591133132}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// sanity check\n\tif (!motors.armed()) {\n\t\t// motors not armed, abort\n\t\treturn false;\n\t}\n\n\t// check for arming checks\n\tif (do_arming_checks) {\n\t\t// do arming checks\n\t\tif (!arming_checks()) {\n\t\t\t// arming checks failed, abort\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// set the arming method\n\tarming_method = method;\n\n\t// set the home location\n\tupdate_home();\n\n\t// set the home location in the AHRS system\n\tahrs.set_home();\n\n\t// update the current location\n\tupdate_current_loc();\n\n\t// change the arm state\n\tchange_arm_state(ARMED);\n\n\t// set the delay arming flag\n\tdelay_arming = true;\n\n\t// send the status text\n\tsend_arm_disarm_statustext();\n\n\t// arming was successful\n\treturn true;\n}", "CodeBleu_score": 44.51728034897775}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (g.arming_check == ARMING_CHECK_NONE) {\n\t\t// no checks to perform\n\t\treturn true;\n\t}\n\n\tif (g.arming_check == ARMING_CHECK_ALL) {\n\t\t// we are not armed, so perform all checks\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t}\n\n\tif (g.arming_check == ARMING_CHECK_DISARM_ONLY) {\n\t\t// we are not armed, so perform only the disarm check\n\t\tif (has_disarm_function()) {\n\t\t\t// disarm button is configured, so perform standard checks\n\t\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t\t}\n\n\t\t// no disarm button configured\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"No disarm button configured\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// should never get here\n\treturn true;\n}", "CodeBleu_score": 56.631853219175724}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tbool\t\tresult;\n\n\tif (is_armed()) {\n\t\t// already armed\n\t\tresult = true;\n\t} else {\n\t\t// not armed\n\t\tif (g.disarm_check == DISARM_CHECK_DISABLED) {\n\t\t\t// disarming not enabled\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"disarming disabled\"));\n\t\t\t}\n\t\t\tresult = false;\n\t\t} else {\n\t\t\t// disarming enabled\n\t\t\tresult = AP_Arming::pre_arm_checks(display_failure);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 46.30405739341348}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (g.arming_check == ARMING_CHECK_NONE) {\n\t\t// don't do any checks\n\t\treturn true;\n\t}\n\n\tif (is_armed()) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\tif (g.arming_check == ARMING_CHECK_ALL) {\n\t\t// do all checks\n\t\treturn pre_arm_checks(display_failure);\n\t}\n\n\t// check for disarm button\n\tif (g.rc_3.control_in == RC_CHANNEL_DISABLED) {\n\t\t// no disarm button\n\t\tif (display_failure) {\n\t\t\tAP_Notify::flags.arming_failure = true;\n\t\t\tnotify.printf_P(PSTR(\"No disarm button\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// do all checks\n\treturn pre_arm_checks(display_failure);\n}", "CodeBleu_score": 53.16161843841757}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat x_temp = x;\n\tfloat y_temp = y;\n\tx = x_temp * ahrs.cos_yaw - y_temp * ahrs.sin_yaw;\n\ty = x_temp * ahrs.sin_yaw + y_temp * ahrs.cos_yaw;\n}", "CodeBleu_score": 41.79856088204119}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * ahrs.cos_yaw + y * ahrs.sin_yaw;\n\tfloat ne_y = -x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 64.50945968382807}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat x_new = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n\tfloat y_new = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n\tx = x_new;\n\ty = y_new;\n}", "CodeBleu_score": 50.072408550337414}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tfloat yaw_angle = packet.param1;\n\tfloat yaw_rate = packet.param2;\n\tfloat direction = packet.param3;\n\tfloat relative = packet.param4;\n\tfloat is_zero = packet.param5;\n\tfloat is_equal = packet.param6;\n\n\t// check if the yaw angle is within acceptable range\n\tif (yaw_angle < -180 || yaw_angle > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if the yaw rate is within acceptable range\n\tif (yaw_rate < 0 || yaw_rate > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if the direction is within acceptable range\n\tif (direction < 0 || direction > 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if the relative is within acceptable range\n\tif (relative < 0 || relative > 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if the is_zero is within acceptable range\n\tif (is_zero < 0 || is_zero > 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// check if the is_equal is within acceptable range\n\tif (is_equal < 0 || is_equal > 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// set the yaw heading using the provided parameters\n\tif (is_zero) {\n\t\tmode_auto.set_auto_yaw_look_at_heading(0);\n\t} else if (is_equal) {\n\t\tmode_auto.set_auto_yaw_look_at_heading(yaw_angle);\n\t} else {\n\t\tmode_auto.set_auto_yaw_look_at_heading(yaw_angle, yaw_rate, direction, relative);\n\t}\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 37.693358680569375}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// TODO: Check if the yaw angle and param4 values are within acceptable ranges.\n\tif (packet.param1 < 0 || packet.param1 > 360 || packet.param4 < 0 || packet.param4 > 360) {\n\t\t// If not valid, return MAV_RESULT_DENIED.\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// If valid, set the yaw heading using the provided parameters.\n\tmode_auto.set_auto_yaw_look_at_heading(packet.param1, packet.param4);\n\n\t// Return MAV_RESULT_ACCEPTED.\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 43.43125224073889}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// check if the yaw angle and param4 values are within acceptable ranges\n\tif (packet.param1 < 0 || packet.param1 > 360 || packet.param4 < -180 || packet.param4 > 180) {\n\t\t// if not valid, return MAV_RESULT_DENIED\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// set the yaw heading using the provided parameters\n\tmode_auto.set_auto_yaw_look_at_heading(packet.param1, packet.param2, packet.param3, packet.param4);\n\n\t// return MAV_RESULT_ACCEPTED\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 51.524113693476814}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _sub.wp_nav.get_wp_bearing_to_destination() / 2;\n}", "CodeBleu_score": 13.558475323744057}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn (uint8_t) (wrap_360_cd(wp_bearing_cd()) / 2);\n}", "CodeBleu_score": 8.270248410718514}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn mavlink_msg_high_latency_wp_sub.wp_nav.get_wp_bearing_to_destination", "CodeBleu_score": 12.908222077604501}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tAP_HAL::micros64 now = AP_HAL::micros64();\n\tlogger.WriteCriticalBlock(LOG_SUBSYSTEM_ID, LOG_SUBSYSTEM_FORMAT_VERSION, now, LOG_SUBSYSTEM_LOG_DATA_ID, id, value);\n}", "CodeBleu_score": 30.32709405786148}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(id)) {\n\t\tlogger.WriteCriticalBlock(AP_HAL::micros64(), id, value);\n\t}\n}", "CodeBleu_score": 28.121026778826852}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (!should_log()) {\n\t\treturn;\n\t}\n\tlogger.WriteCriticalBlock(AP_HAL::micros64(), LOG_PACKET_HEADER_INIT, id, value);\n}", "CodeBleu_score": 23.388538219749073}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set()) {\n\t\treturn;\n\t}\n\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t\treturn;\n\t}\n\n\t// if we are not armed, we can set the home to the EKF location\n\tif (ahrs.ekf_pos_valid()) {\n\t\tahrs.set_home_to_current_location();\n\t}\n}", "CodeBleu_score": 43.17317545108547}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (ahrs.home_is_set) {\n\t\treturn;\n\t}\n\n\tif (motors.armed) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location();\n\t}\n}", "CodeBleu_score": 33.90327014943925}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set()) {\n\t\treturn;\n\t}\n\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location();\n\t}\n}", "CodeBleu_score": 41.70132629158898}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\t// if motors are not armed, set throttle to zero, adjust spool state, relax attitude controllers, and exit\n\tif (!motors.armed) {\n\t\tmotors.set_throttle(0);\n\t\tmotors.set_desired_spool_state(SPOOL_STATE_UNLIMITED_THROTTLE);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\t// set spool state to unlimited throttle\n\tmotors.set_desired_spool_state(SPOOL_STATE_UNLIMITED_THROTTLE);\n\n\t// convert pilot inputs to desired body frame rates\n\tfloat desired_angle_rates[3] = {0, 0, 0};\n\tdesired_angle_rates[0] = get_pilot_desired_angle_rates(0);\n\tdesired_angle_rates[1] = get_pilot_desired_angle_rates(1);\n\tdesired_angle_rates[2] = get_pilot_desired_angle_rates(2);\n\n\t// run the attitude controller with these rates\n\tattitude_control->input_rate_bf_roll_pitch_yaw(desired_angle_rates[0], desired_angle_rates[1], desired_angle_rates[2]);\n\n\t// output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls\n\tmotors.set_throttle(channel_throttle->norm_input());\n\tmotors.set_forward(channel_forward->norm_input());\n\tmotors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 49.12846824692784}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tmotors.set_throttle(0);\n\t\tmotors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);\n\t\trelax_attitude_controllers();\n\t\treturn;\n\t}\n\n\tmotors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);\n\tget_pilot_desired_angle_rates();\n\tattitude_control->input_rate_bf_roll_pitch_yaw(desired_angle_rates.roll, desired_angle_rates.pitch, desired_angle_rates.yaw);\n\tattitude_control->set_throttle_out(channel_throttle->norm_input, false);\n\tmotors.set_forward(channel_forward->norm_input);\n\tmotors.set_lateral(channel_lateral->norm_input);\n}", "CodeBleu_score": 35.42395529501597}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tmotors.set_throttle_out(0);\n\t\tmotors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);\n\t\trelax_attitude_controllers();\n\t\treturn;\n\t}\n\tmotors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);\n\tget_pilot_desired_angle_rates();\n\tattitude_control->input_rate_bf_roll_pitch_yaw(roll_rate_desired, pitch_rate_desired, yaw_rate_desired);\n\tattitude_control->set_throttle_out(channel_throttle->norm_input(), false);\n\tmotors.set_forward(channel_forward->norm_input());\n\tmotors.set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 38.16530475601153}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set to position control mode\n\tset_mode(PX4_MODE_POSCTL);\n\n\t// Initialize waypoint controller\n\t_sub.wp_nav.set_wp_destination(_sub.wp_nav.get_wp_stopping_point());\n\t_sub.wp_nav.wp_and_spline_init();\n\n\t// Set yaw to default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 35.35548848159036}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t/*\n\t * Set the vehicle to position control mode.\n\t */\n\t_vehicle_status.set_nav_state(vehicle_status_s::NAVIGATION_STATE_POSCTL);\n\n\t/*\n\t * Initialize the waypoint controller.\n\t */\n\t_sub_wp_nav.wp_and_spline_init();\n\n\t/*\n\t * Get the stopping point.\n\t */\n\tVector3f stopping_point = _sub_wp_nav.get_wp_stopping_point();\n\n\t/*\n\t * Set the stopping point as the waypoint destination.\n\t */\n\t_sub_wp_nav.set_wp_destination(stopping_point);\n\n\t/*\n\t * Initialize the yaw using the default auto yaw mode.\n\t */\n\t_sub_wp_nav.set_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 45.317372836915446}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set the mode to position control mode\n\tset_mode(PX4_MODE_POSCTL);\n\n\t// initialize the waypoint controller\n\tsub.wp_nav.wp_and_spline_init();\n\n\t// get the stopping point\n\tstruct position_setpoint_s stopping_point;\n\tsub.wp_nav.get_wp_stopping_point(&stopping_point);\n\n\t// set the stopping point as the waypoint destination\n\tsub.wp_nav.set_wp_destination(stopping_point);\n\n\t// initialize the yaw using the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 53.15767316795363}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set max vertical speeds and acceleration using pilot-defined parameters\n\tset_max_speed_accel_z(g.pilot_velocity_z_max, g.pilot_accel_z);\n\n\t// initialize vertical velocity controller\n\tinit_z_controller();\n\n\t// initialize horizontal velocity controller\n\tposition_control->init_xy_controller();\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 29.164247003156046}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set max speed and acceleration\n\tset_max_speed_accel_xy(g.pilot_vel_xy_max, g.pilot_vel_xy_cruise, g.pilot_vel_xy_accel);\n\tset_max_speed_accel_z(g.pilot_vel_z_max, g.pilot_vel_z_cruise, g.pilot_vel_z_accel);\n\tset_correction_speed_accel_z(g.pilot_vel_z_max, g.pilot_vel_z_accel);\n\n\t// initialize velocity controllers\n\tinit_xy_controller();\n\tinit_z_controller();\n\n\t// set yaw control mode\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 33.54880594019365}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set vertical speeds\n\tset_max_speed_accel_z(g.pilot_vel_z_max, g.pilot_vel_z_accel);\n\tset_correction_speed_accel_z(g.pilot_vel_z_max, g.pilot_vel_z_accel);\n\n\t// initialize vertical velocity controller\n\tinit_z_controller();\n\n\t// initialize horizontal velocity controller\n\tinit_xy_controller();\n\n\t// set yaw control mode\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 29.75218529138762}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\tbool ret = false;\n\n\tif (guided_limit.timeout_ms!= 0 && (AP_HAL::millis() - guided_limit.start_time_ms) > guided_limit.timeout_ms) {\n\t\tret = true;\n\t}\n\n\tif (guided_limit.min_altitude_cm!= 0 && guided_limit.min_altitude_cm > inertial_nav.get_altitude_cm()) {\n\t\tret = true;\n\t}\n\n\tif (guided_limit.max_altitude_cm!= 0 && guided_limit.max_altitude_cm < inertial_nav.get_altitude_cm()) {\n\t\tret = true;\n\t}\n\n\tif (guided_limit.max_distance_cm!= 0 && guided_limit.max_distance_cm < get_horizontal_distance_cm(guided_limit.start_pos, inertial_nav.get_position_neu_cm())) {\n\t\tret = true;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 39.986622884180754}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tif (AP_HAL::millis() - guided_limit.start_time > guided_limit.timeout) {\n\t\t// timeout\n\t\treturn true;\n\t}\n\n\tif (guided_limit.start_altitude_cm!= 0) {\n\t\t// check altitude limits\n\t\tif (guided_limit.start_altitude_cm + guided_limit.altitude_min_cm > inertial_nav.get_altitude_cm()) {\n\t\t\t// below min altitude\n\t\t\treturn true;\n\t\t}\n\t\tif (guided_limit.start_altitude_cm + guided_limit.altitude_max_cm < inertial_nav.get_altitude_cm()) {\n\t\t\t// above max altitude\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (guided_limit.start_pos.is_zero()) {\n\t\t// no start position set\n\t\treturn false;\n\t}\n\n\t// check horizontal distance moved\n\tVector2f curr_pos = inertial_nav.get_position_neu_cm();\n\tfloat distance_moved = get_horizontal_distance_cm(guided_limit.start_pos.xy, curr_pos.xy);\n\tif (distance_moved > guided_limit.distance_max_cm) {\n\t\t// exceeded max horizontal distance\n\t\treturn true;\n\t}\n\n\t// no limits exceeded\n\treturn false;\n}", "CodeBleu_score": 61.443038732662146}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tbool ret = false;\n\n\t// check for timeout\n\tif (AP_HAL::millis() - _guided_start_time > _guided_timeout) {\n\t\t// timeout\n\t\tret = true;\n\t}\n\n\t// check for altitude limits\n\tif (_guided_limit.min_altitude_cm!= 0 && _guided_limit.min_altitude_cm > inertial_nav.get_altitude()) {\n\t\t// below min alt\n\t\tret = true;\n\t}\n\tif (_guided_limit.max_altitude_cm!= 0 && _guided_limit.max_altitude_cm < inertial_nav.get_altitude()) {\n\t\t// above max alt\n\t\tret = true;\n\t}\n\n\t// check for horizontal distance limits\n\tif (_guided_limit.max_horizontal_distance_cm!= 0) {\n\t\tVector3f curr_pos;\n\t\tinertial_nav.get_position_neu_cm(&curr_pos);\n\t\tfloat dist = get_horizontal_distance_cm(&curr_pos, &_guided_limit.start_pos);\n\t\tif (dist > _guided_limit.max_horizontal_distance_cm) {\n\t\t\t// exceeded horizontal distance\n\t\t\tret = true;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 44.58157676800045}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tuint32_t start_time = AP_HAL::millis();\n\tuint32_t last_time = start_time;\n\tuint32_t timeout = 10000;\n\tbool pass = true;\n\twhile (AP_HAL::millis() - start_time < timeout) {\n\t\tif (AP_HAL::millis() - last_time > 500) {\n\t\t\tgcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n\t\t\tpass = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (motor_test_request_received) {\n\t\t\tlast_time = AP_HAL::millis();\n\t\t\tmotor_test_request_received = false;\n\t\t}\n\t}\n\tif (pass) {\n\t\tgcs().send_text(MAV_SEVERITY_INFO, \"Motor test passed\");\n\t}\n\tAP::arming().disarm();\n\tmotor_test_enabled = false;\n\tmotor_test_failure_time = AP_HAL::millis();\n\treturn pass;\n}", "CodeBleu_score": 55.49303956188595}, {"code": "bool Sub::verify_motor_test(){\n\t\tif (millis() - last_motor_test_request > 2000) {\n\t\tgcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n\t\tpass = false;\n\t\tAP::arming().disarm();\n\t\tmotor_test_timeout = millis();\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 37.25224465242908}, {"code": "bool Sub::verify_motor_test(){\n\t\t// Check if motor test requests are received at least every 2 Hz\n\tif (millis() - motor_test_last_request_time > 2000) {\n\t\t// Motor test requests timed out\n\t\t// Send timeout message\n\t\tgcs().send_text(MAV_SEVERITY_INFO, \"Motor test timed out\");\n\t\t// Set the pass flag to false\n\t\tmotor_test_pass = false;\n\t\t// Disable the motor test\n\t\tmotor_test_enabled = false;\n\t\t// Disarm the system\n\t\tAP::arming().disarm();\n\t\t// Record the failure time\n\t\tmotor_test_failure_time = millis();\n\t\treturn false;\n\t} else {\n\t\t// Motor test requests are being received\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 39.542353042626765}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.get_roll();\n\tfloat pitch_target = wp_nav.get_pitch();\n\troll_target = constrain_int16(roll_target, -max_angle, max_angle);\n\tpitch_target = constrain_int16(pitch_target, -max_angle, max_angle);\n\tlateral_out = roll_target / max_angle;\n\tforward_out = pitch_target / max_angle;\n}", "CodeBleu_score": 46.42937816089826}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Get the pitch and roll targets from wp_nav.\n\tfloat pitch = wp_nav.get_pitch();\n\tfloat roll = wp_nav.get_roll();\n\n\t// Constrain the pitch and roll targets to a maximum angle range.\n\tpitch = constrain_float(pitch, -max_angle, max_angle);\n\troll = constrain_float(roll, -max_angle, max_angle);\n\n\t// Normalize the pitch and roll targets.\n\tpitch = pitch / max_angle;\n\troll = roll / max_angle;\n\n\t// Assign the normalized pitch and roll targets to lateral_out and forward_out.\n\tlateral_out = roll;\n\tforward_out = pitch;\n}", "CodeBleu_score": 45.67888826172672}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tint16_t roll_target = wp_nav.get_roll();\n\tint16_t pitch_target = wp_nav.get_pitch();\n\troll_target = constrain_int16(roll_target, -wp_nav_max_angle, wp_nav_max_angle);\n\tpitch_target = constrain_int16(pitch_target, -wp_nav_max_angle, wp_nav_max_angle);\n\tlateral_out = (float)roll_target / 100.0f;\n\tforward_out = (float)pitch_target / 100.0f;\n}", "CodeBleu_score": 47.93321206830321}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// update barometer\n\tbarometer.update();\n\t// update barometer calibration\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\t// update depth sensor health\n\tif (depth_sensor_present) {\n\t\tdepth_sensor_healthy = barometer.healthy();\n\t}\n}", "CodeBleu_score": 68.19051467678003}, {"code": "void Sub::read_barometer(){\n\t\tbarometer.update();\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (depth_sensor.present()) {\n\t\tdepth_sensor.update_health();\n\t}\n}", "CodeBleu_score": 58.96321659585997}, {"code": "void Sub::read_barometer(){\n\t\tbarometer.update();\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (depth_sensor_present) {\n\t\tdepth_sensor_healthy = barometer.healthy;\n\t}\n}", "CodeBleu_score": 67.97621211169607}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\treturn ahrs.have_inertial_nav() && (motors.armed() || (ekf_position_prediction_ok() &&!ekf_constant_position_mode()));\n}", "CodeBleu_score": 12.487084199533745}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed) {\n\t\t// if motors are disarmed, allow a predicted horizontal position\n\t\treturn ahrs.get_ekf_pos_horiz_accuracy() < 1.5f;\n\t}\n\n\t// if motors are armed, require a good absolute position and ensure the EKF is not in constant position mode\n\treturn ahrs.get_ekf_pos_horiz_accuracy() < 1.5f &&!ahrs.get_ekf_const_pos_mode();\n}", "CodeBleu_score": 43.65383715062903}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// if we don't have inertial navigation, we can't navigate\n\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\t// if we are disarmed, we can navigate with a predicted position\n\tif (!motors.armed()) {\n\t\treturn true;\n\t}\n\n\t// if we are armed, we need a good absolute position and the EKF must not be in constant position mode\n\treturn ahrs.get_ekf_position_ok() &&!ahrs.get_ekf_const_pos_mode();\n}", "CodeBleu_score": 39.92739972389874}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!rover.control_mode->requires_position() &&!rover.control_mode->requires_velocity()) {\n\t\treturn true;\n\t}\n\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!ahrs.pre_arm_check(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!rover.ekf_position_ok()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::flags.gps_fix_lost = true;\n\t\t\tAP_Notify::flags.ekf_fix_lost = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 45.37259845965569}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\tif (!ahrs.ready_to_arm()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Not ready to arm: AHRS not ready\"));\n\t\t}\n\t\treturn false;\n\t}\n\tif (ahrs.ekf_failsafe_active()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Not ready to arm: EKF failsafe\"));\n\t\t}\n\t\treturn false;\n\t}\n\tif (!rover.ekf_position_ok()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Not ready to arm: EKF position invalid\"));\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 49.874292438680435}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!requires_position() &&!requires_velocity()) {\n\t\treturn true;\n\t}\n\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!ahrs.pre_arm_check(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!rover.ekf_position_ok()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::flags.arming_gps_check_failed = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!rover.control_mode->requires_position()) {\n\t\treturn true;\n\t}\n\n\tif (!rover.ekf_position_ok()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::flags.arming_gps_check_failed = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 51.15449513982426}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// check if we are already armed\n\tif (_armed.armed) {\n\t\t// already armed\n\t\treturn true;\n\t}\n\n\t// check if we are in a mode that allows arming\n\tif (!is_armable()) {\n\t\t// not in a mode that allows arming\n\t\treturn false;\n\t}\n\n\t// check if we are in a mode that allows arming\n\tif (!is_armable()) {\n\t\t// not in a mode that allows arming\n\t\treturn false;\n\t}\n\n\t// perform arming checks if required\n\tif (do_arming_checks &&!arming_checks()) {\n\t\t// arming checks failed\n\t\treturn false;\n\t}\n\n\t// set the armed status\n\t_armed.armed = true;\n\n\t// update the soft armed status\n\tupdate_soft_armed();\n\n\t// set the home location for smart_rtl\n\trover.g2.smart_rtl.set_home();\n\n\t// initialize the simple mode heading\n\trover.mode_simple.init_heading();\n\n\t// record the home heading for sail vehicles\n\tif (rover.g2.windvane.have_home_heading()) {\n\t\trover.g2.windvane.record_home_heading();\n\t}\n\n\t// send an arm/disarm status text\n\tsend_arm_disarm_statustext();\n\n\t// arming succeeded\n\treturn true;\n}", "CodeBleu_score": 55.97647955718791}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tif (do_arming_checks) {\n\t\tif (!arming_checks()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (method == AP_Arming::Method::ARM_VIA_APP) {\n\t\tg.log.printf_P(PSTR(\"Arming via app\n\"));\n\t} else {\n\t\tg.log.printf_P(PSTR(\"Arming via switch\n\"));\n\t}\n\n\t// set home position for smart RTL\n\tif (g.rtl_enabled == AP_RTL::ENABLED) {\n\t\tg.rtl.set_home();\n\t}\n\n\t// initialize simple mode heading\n\tif (g.simple_mode == SIMPLE_MODE_HEADING) {\n\t\tinit_heading();\n\t}\n\n\t// record home heading for sail vehicles\n\tif (g.sail_enabled) {\n\t\tg.windvane.record_home_heading();\n\t}\n\n\t// update soft armed status\n\tupdate_soft_armed();\n\n\t// send arm/disarm status text\n\tsend_arm_disarm_statustext();\n\n\treturn true;\n}", "CodeBleu_score": 49.77863199849815}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\t// check if already armed\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// perform arming checks\n\tif (do_arming_checks &&!arming_checks()) {\n\t\treturn false;\n\t}\n\n\t// set the armed flag\n\t_armed = true;\n\n\t// set the armed event\n\tevents.set(EVENT_ID(\"armed\"));\n\n\t// set the arming_failed event\n\tevents.clear_all(EVENT_ID(\"arming_failed\"));\n\n\t// set the arming_failed event\n\tevents.clear_all(EVENT_ID(\"disarmed\"));\n\n\t// set the arming_failed event\n\tevents.clear_all(EVENT_ID(\"disarming_failed\"));\n\n\t// update the soft armed status\n\tupdate_soft_armed();\n\n\t// set the home location for smart_rtl\n\tg.smart_rtl.set_home();\n\n\t// initialize the simple mode heading\n\tmode_simple.init_heading();\n\n\t// record the home heading for sail vehicles\n\tif (g.compass_enabled) {\n\t\tg.windvane.record_home_heading();\n\t}\n\n\t// send the arm/disarm status text\n\tsend_arm_disarm_statustext();\n\n\t// return success\n\treturn true;\n}", "CodeBleu_score": 53.81702639134032}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\t// Charging is not enabled, but should be.\n\t\t\t// Enable charging and record the time.\n\t\t\tcharging_enabled = true;\n\t\t\tlast_charging_enabled_time = millis();\n\t\t}\n\t} else {\n\t\t// Charging is not allowed.\n\t\tif (charging_enabled) {\n\t\t\t// Charging is enabled, but should not be.\n\t\t\t// Disable charging and record the time.\n\t\t\tcharging_enabled = false;\n\t\t\tlast_charging_disabled_time = millis();\n\t\t} else {\n\t\t\t// Charging is disabled, but should not be.\n\t\t\t// Check if it's time to retry enabling charging.\n\t\t\tunsigned long time_since_last_disable = millis() - last_charging_disabled_time;\n\t\t\tif (time_since_last_disable > RETRY_CHARGING_DELAY) {\n\t\t\t\t// It's time to retry enabling charging.\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tlast_charging_enabled_time = millis();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.38630122568401}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\tenableCharging();\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_enabled_time = millis();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tdisableCharging();\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_enabled_time = millis();\n\t\t} else {\n\t\t\tif (millis() - charging_enabled_time > 30000) {\n\t\t\t\tenableCharging();\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_enabled_time = millis();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.40502912010401}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (shouldCharge()) {\n\t\t\tif (!charging_enabled) {\n\t\t\t\tenableCharging();\n\t\t\t}\n\t\t} else {\n\t\t\tdisableCharging();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tdisableCharging();\n\t\t} else {\n\t\t\tif (millis() - last_charging_disable_time > CHARGING_RETRY_DELAY) {\n\t\t\t\tenableCharging();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 27.739299423577517}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::isStarted()) {\n\t\tif (size >= 4) {\n\t\t\tuint16_t crc = CRC16.ccitt(message, size - 2);\n\t\t\tuint8_t *msg = (uint8_t *) message;\n\t\t\tmsg[size - 2] = (uint8_t) (crc >> 8);\n\t\t\tmsg[size - 1] = (uint8_t) (crc & 0xFF);\n\t\t\tpacketSerial.send(message, size);\n\t\t}\n\t}\n}", "CodeBleu_score": 56.94968168767176}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (size < 4) {\n\t\treturn;\n\t}\n\tif (ros::isStarted()) {\n\t\tuint16_t crc = CRC16.ccitt(message, size - 2);\n\t\tmemcpy(message + size - 2, &crc, 2);\n\t\tpacketSerial.send(message, size);\n\t}\n}", "CodeBleu_score": 38.616521808010404}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::isStarted() && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tuint8_t *msg = (uint8_t*) message;\n\t\tmsg[size] = crc >> 8;\n\t\tmsg[size + 1] = crc & 0xff;\n\t\tpacketSerial.send(message, size + 2);\n\t}\n}", "CodeBleu_score": 50.883030379246385}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\tbool success = false;\n\tsoundSerial.begin(9600);\n\tsoundSerial.flush();\n\tdelay(100);\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0x02);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0xEF);\n\tdelay(100);\n\tsoundSerial.flush();\n\tdelay(100);\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0x02);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0xEF);\n\tdelay(100);\n\tsoundSerial.flush();\n\tdelay(100);\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0x02);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0xEF);\n\tdelay(100);\n\tsoundSerial.flush();\n\tdelay(100);\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0x02);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0xEF);\n\tdelay(100);\n\tsoundSerial.flush();\n\tdelay(100);\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0x02);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0xEF);\n\tdelay(100);\n\tsoundSerial.flush();\n\tdelay(100);\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0x02);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0xEF);\n\tdelay(100);\n\tsoundSerial.flush();\n\tdelay(100);\n\tsoundSerial.write(0x7E);\n\tsoundSerial.write(0x02);\n\tsoundSerial.write(0x00);\n\tsoundSerial.write(0xEF);\n\tdelay(100);\n\tsoundSerial.flush();\n\tdelay(", "CodeBleu_score": 40.32734835832832}, {"code": "bool MP3Sound::begin(){\n\t\tSerial.begin(9600);\n\twhile (Serial.available())\n\t\tSerial.read();\n\tdelay(100);\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x09);\n\tSerial.write(0x00);\n\tSerial.write(0x01);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(100);\n\twhile (Serial.available())\n\t\tSerial.read();\n\tdelay(100);\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x0C);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(100);\n\twhile (Serial.available())\n\t\tSerial.read();\n\tdelay(100);\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x06);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0xEF);\n\tdelay(100);\n\twhile (Serial.available())\n\t\tSerial.read();\n\tdelay(100);\n\tSerial.write(0x7E);\n\tSerial.write(0xFF);\n\tSerial.write(0x06);\n\tSerial.write(0x07);\n\tSerial.write(0x00);\n\tSerial.write(0x00);\n\tSerial.write(0x", "CodeBleu_score": 41.271841767366496}, {"code": "bool MP3Sound::begin(){\n\t\tsoundSerial.begin(9600);\n\tsoundSerial.flush();\n\tdelay(100);\n\tif (numSdTracks > 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 31.49047583211575}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.320775072950724}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.320775072950724}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tmyMP3.play(active_sounds.back());\n\t\tactive_sounds.pop_back();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 43.320775072950724}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef USE_CAMERA\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (d->camera_is_memory_mapped_file)\n        wb_camera_memory_mapped_file_cleanup(d);\n      wb_camera_memory_mapped_file_setup(d, r);\n      return true;\n    }\n    default:\n      return false;\n  }\n#else\n  return false;\n#endif  // USE_CAMERA\n}", "CodeBleu_score": 38.22719295399275}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_handle_command(command=%d)\n\", command);\n#endif\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      image_cleanup();\n      image_setup();\n      return true;\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 41.577073772732085}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef DEBUG_CAMERA\n  printf(\"abstract camera command received: %d\n\", command);\n#endif\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      int width = wb_request_read_uchar(r);\n      int height = wb_request_read_uchar(r);\n      int format = wb_request_read_uchar(r);\n      int fov = wb_request_read_uchar(r);\n      int resolution = wb_request_read_uchar(r);\n      int noise = wb_request_read_uchar(r);\n      int width_mm = wb_request_read_uchar(r);\n      int height_mm = wb_request_read_uchar(r);\n      int focal_length_mm = wb_request_read_uchar(r);\n\n      if (width < 1 || height < 1 || width > 2000 || height > 2000 || format < 0 || format >= NUM_CAMERA_IMAGE_FORMATS ||\n          fov < 0 || fov > 180 || resolution < 0 || resolution > 3 || noise < 0 || noise > 100 || width_mm < 1 ||\n          height_mm < 1 || width_mm > 10000 || height_mm > 10000 || focal_length_mm < 1 || focal_length_mm > 10000) {\n        fprintf(stderr, \"abstract camera: invalid parameters\n\");\n        return false;\n      }\n\n      if (wb_abstract_camera_is_initialized(d))\n        wb_abstract_camera_cleanup(d);\n\n      wb_abstract_camera_setup(d, width, height, format, fov, resolution, noise, width_mm, height_mm, focal_length_mm);\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 40.59631607482118}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef DEBUG_FUNCS\n  printf(\"wb_abstract_camera_get_height(%d)\n\", d);\n#endif\n  robot_mutex_lock();\n  WbAbstractCamera *c = wb_robot_get_device(d, WB_NODE_ABSTRACT_CAMERA, false);\n  int result = c? c->height : -1;\n  robot_mutex_unlock();\n  return result;\n}", "CodeBleu_score": 51.33743274021173}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\trobot_mutex_lock\nint result = -1;\nif (d->data) {\nWbAbstractCamera *ac = (WbAbstractCamera *)d->data;\nresult = ac->height;\n}\nrobot_mutex_unlock\nreturn result;\n}", "CodeBleu_score": 29.5127649715609}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef DEBUG_ABSTRACT_CAMERA\n  printf(\"wb_abstract_camera_get_height\n\");\n#endif\n\n  robot_mutex_lock();\n  WbAbstractCamera *ac = (WbAbstractCamera *)d->pdata;\n  int height = ac->height;\n  robot_mutex_unlock();\n\n  return height;\n}", "CodeBleu_score": 51.704114891959385}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\trobot_mutex_lock();\n\tAccelerometer *accelerometer = accelerometer_get_struct(tag);\n\tif (accelerometer)\n\t\tsampling_period = accelerometer->sampling_period;\n\telse\n\t\tfprintf(stderr, \"wb_accelerometer_get_sampling_period: invalid device tag\n\");\n\trobot_mutex_unlock();\n\treturn sampling_period;\n}", "CodeBleu_score": 48.64725896771058}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\trobot_mutex_lock();\n\tAccelerometer *accelerometer = accelerometer_get_struct(tag);\n\tif (accelerometer)\n\t\tsampling_period = accelerometer->sampling_period;\n\telse\n\t\tfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n\trobot_mutex_unlock();\n\treturn sampling_period;\n}", "CodeBleu_score": 56.47092960860469}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\trobot_mutex_lock();\n\tAccelerometer *accelerometer = accelerometer_get_struct(tag);\n\tif (accelerometer) {\n\t\tint sampling_period = accelerometer->sampling_period;\n\t\trobot_mutex_unlock();\n\t\treturn sampling_period;\n\t}\n\trobot_mutex_unlock();\n\tfprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n\treturn 0;\n}", "CodeBleu_score": 64.5048003493329}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = dms;\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 41.90011620056393}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms(dmsString);\n\tfree(dmsString);\n\treturn dms;\n}", "CodeBleu_score": 40.27371132774727}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 39.0149142293266}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdxBox* box = (dxBox*) g;\n\tdUASSERT (box->type == dBoxClass, \"argument not a box\");\n\n\tdVector3 p;\n\tp[0] = x - box->posr.pos[0];\n\tp[1] = y - box->posr.pos[1];\n\tp[2] = z - box->posr.pos[2];\n\tdMULTIPLY1_331 (p, box->posr.R, p);\n\n\tdReal dist = 0;\n\tdReal d = 0;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\td = p[i] - box->side[i] * 0.5;\n\t\tif (d > 0) {\n\t\t\tif (d > dist) {\n\t\t\t\tdist = d;\n\t\t\t\tplane[0] = box->posr.R[0*4+i];\n\t\t\t\tplane[1] = box->posr.R[1*4+i];\n\t\t\t\tplane[2] = box->posr.R[2*4+i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\td = p[i] + box->side[i] * 0.5;\n\t\t\tif (d < 0) {\n\t\t\t\tif (-d > dist) {\n\t\t\t\t\tdist = -d;\n\t\t\t\t\tplane[0] = -box->posr.R[0*4+i];\n\t\t\t\t\tplane[1] = -box->posr.R[1*4+i];\n\t\t\t\t\tplane[2] = -box->posr.R[2*4+i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tplane[3] = dist;\n}", "CodeBleu_score": 36.119323860841575}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\tdUASSERT (plane, \"bad argument\");\n\tconst dxBox *box = (const dxBox*) g;\n\tdReal dx = x - box->final_posr.pos[0];\n\tdReal dy = y - box->final_posr.pos[1];\n\tdReal dz = z - box->final_posr.pos[2];\n\tdReal dist = dInfinity;\n\tdVector3 normal;\n\tif (dx > box->side[0]) {\n\t\tdSetZero (normal);\n\t\tnormal[0] = -1;\n\t\tdist = box->side[0] - dx;\n\t}\n\telse if (dx < -box->side[0]) {\n\t\tdSetZero (normal);\n\t\tnormal[0] = 1;\n\t\tdist = dx + box->side[0];\n\t}\n\tif (dy > box->side[1]) {\n\t\tdReal d = box->side[1] - dy;\n\t\tif (d < dist) {\n\t\t\tdSetZero (normal);\n\t\t\tnormal[1] = -1;\n\t\t\tdist = d;\n\t\t}\n\t}\n\telse if (dy < -box->side[1]) {\n\t\tdReal d = dy + box->side[1];\n\t\tif (d < dist) {\n\t\t\tdSetZero (normal);\n\t\t\tnormal[1] = 1;\n\t\t\tdist = d;\n\t\t}\n\t}\n\tif (dz > box->side[2]) {\n\t\tdReal d = box->side[2] - dz;\n\t\tif (d < dist) {\n\t\t\tdSetZero (normal);\n\t\t\tnormal[2] = -1;\n\t\t\tdist = d;\n\t\t}\n\t}\n\telse if (dz < -box->side[2]) {\n\t\tdReal d = dz + box->side[2];\n\t\tif (d < dist) {\n\t\t\tdSetZero (normal);\n\t\t\tnormal[2] = 1;\n\t\t\tdist = d;\n\t\t}\n\t}\n\tif (dist == dInfinity) {\n\t\tdSetZero (normal);\n\t\tdist = 0;\n", "CodeBleu_score": 38.16894060894675}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\tdVector3 p;\n\tp[0] = x - g->posr.pos[0];\n\tp[1] = y - g->posr.pos[1];\n\tp[2] = z - g->posr.pos[2];\n\tdMULTIPLY1_331 (p,g->posr.R,p);\n\tif (p[0] > g->box.side[0] - dGeomBoxTolerance) {\n\t\tplane[0] = g->posr.R[0*4+0];\n\t\tplane[1] = g->posr.R[1*4+0];\n\t\tplane[2] = g->posr.R[2*4+0];\n\t\tplane[3] = dCalcVectorDot3 (g->posr.pos,plane) - dFabs(g->box.side[0]);\n\t\treturn;\n\t}\n\tif (p[0] < -g->box.side[0] + dGeomBoxTolerance) {\n\t\tplane[0] = -g->posr.R[0*4+0];\n\t\tplane[1] = -g->posr.R[1*4+0];\n\t\tplane[2] = -g->posr.R[2*4+0];\n\t\tplane[3] = dCalcVectorDot3 (g->posr.pos,plane) + dFabs(g->box.side[0]);\n\t\treturn;\n\t}\n\tif (p[1] > g->box.side[1] - dGeomBoxTolerance) {\n\t\tplane[0] = g->posr.R[0*4+1];\n\t\tplane[1] = g->posr.R[1*4+1];\n\t\tplane[2] = g->posr.R[2*4+1];\n\t\tplane[3] = dCalcVectorDot3 (g->posr.pos,plane) - dFabs(g->box.side[1]);\n\t\treturn;\n\t}\n\tif (p[1] < -g->box.side[1] + dGeomBoxTolerance) {\n\t", "CodeBleu_score": 28.226396906465133}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdUASSERT (box->body, \"box has no body\");\n\tdUASSERT (box->flags & dBoxFlagImmersion, \"box has no immersion flag\");\n\tsBoxImmersionData data (box, fluidPlane, flags, immersion);\n\tdata.performImmersionChecking ();\n\tdIASSERT (data.immersion == immersion);\n\treturn data.immersion->flags;\n}", "CodeBleu_score": 57.73849853118909}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT (box->body,\"dImmerseBox(): a box must have a body\n\");\ndUASSERT (flags >= 0 && flags <= 3,\"dImmerseBox(): flags must be between 0 and 3\n\");\nsBoxImmersionData data;\ndata.box = box;\ndata.fluidPlane = fluidPlane;\ndata.flags = flags;\ndata.immersion = immersion;\ndata.performImmersionChecking\ndIASSERT\nreturn data.result;\n}", "CodeBleu_score": 48.63971817682714}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdUASSERT (box->body, \"A box must have a body.\");\n\tdUASSERT (flags & (dImmersionFlags)0x03, \"Invalid immersion flags.\");\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\tdata.performImmersionChecking = performBoxImmersionChecking;\n\tdIASSERT\n\tdata.performImmersionChecking\ndIASSERT\n\treturn 0;\n}", "CodeBleu_score": 47.11849566030603}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (o1->type == dBoxClass, \"Argument not a box\");\n\tdUASSERT (o2->type == dCapsuleClass, \"Argument not a capsule\");\n\tdUASSERT (immersion, \"NULL immersion argument\");\n\n\tdVector3 side;\n\tdReal radius, length;\n\tdVector3 pos;\n\tdMatrix3 R;\n\tdVector3 dir;\n\tdReal depth;\n\n\tdGeomBoxGetLengths (o1, side);\n\tdGeomCapsuleGetParams (o2, &radius, &length);\n\tdGeomCopyPosition (o2, pos);\n\tdGeomCopyRotation (o2, R);\n\tdMULTIPLY1_331 (dir, R, o2->final_posr->pos);\n\n\tdepth = dImmerseBoxCapsule (pos, R, dir, side, radius, length, immersion);\n\n\tif (depth > 0) {\n\t\tdVector3 p;\n\t\tdVector3 n;\n\t\tdVector3 plane;\n\t\tdReal k;\n\n\t\tdMULTIPLY0_331 (p, R, immersion->pos);\n\t\tdAddVectors3 (p, p, pos);\n\n\t\tdMULTIPLY0_331 (n, R, immersion->normal);\n\n\t\tk = dCalcVectorDot3 (n, dir);\n\t\tif (k > 0) {\n\t\t\tdSubtractVectors3 (plane, p, dir);\n\t\t\tdAddScaledVectors3 (plane, plane, n, depth);\n\t\t} else {\n\t\t\tdAddScaledVectors3 (plane, p, n, depth);\n\t\t}\n\n\t\tdGeomSetPosition (o2, plane[0], plane[1], plane[2]);\n\t\tdGeomSetRotation (o2, R);\n\t}\n\n\treturn depth > 0;\n}", "CodeBleu_score": 35.31803617595332}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (immersion->depth >= 0, \"Immersion depth must be non-negative\");\n\tdUASSERT (immersion->depth <= 1, \"Immersion depth must be less than 1\");\n\tdUASSERT (o1->type == dBoxClass, \"First argument must be a box\");\n\tdUASSERT (o2->type == dCapsuleClass, \"Second argument must be a capsule\");\n\tdUASSERT (o1->body && o2->body, \"Both geometries must have a body\");\n\tdUASSERT (o1->body == o2->body, \"Both geometries must have the same body\");\n\n\tdxBox *box = (dxBox *) o1;\n\tdxCapsule *capsule = (dxCapsule *) o2;\n\n\t// Check for collision\n\tdVector3 normal;\n\tdReal depth;\n\tif (!dCollideCapsuleBox (o2, o1, flags, &depth, &normal, 0, 0, 0, 0)) {\n\t\treturn 0;\n\t}\n\n\t// Set immersion parameters\n\timmersion->depth = depth;\n\timmersion->normal = normal;\n\timmersion->plane = dPlaneSpace (normal, immersion->plane);\n\n\t// Process immersion\n\tdImmerseBox (o1, o2, flags, immersion);\n\n\treturn 1;\n}", "CodeBleu_score": 46.54945211276985}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdxBox *b;\n\tdxCapsule *c;\n\tdVector3 normal;\n\tdReal depth;\n\tdReal radius, length;\n\tdReal b_radius, b_length;\n\tdReal b_depth;\n\tdVector3 b_normal;\n\tdVector3 b_center;\n\tdVector3 b_pos;\n\tdVector3 b_size;\n\tdVector3 b_relpos;\n\tdVector3 b_relpos_proj;\n\tdVector3 b_relpos_proj_norm;\n\tdVector3 b_relpos_proj_norm_dir;\n\tdVector3 b_relpos_proj_norm_dir_norm;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm_dir;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm_dir_norm;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm_dir_norm_dir;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm_dir_norm_dir_norm;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir_norm;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir_norm;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir_norm_dir;\n\tdVector3 b_relpos_proj_norm_dir_norm_dir_norm", "CodeBleu_score": 6.971866929654391}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal cosTheta0 = sqrt(1 - tanTheta0 * tanTheta0);\n\tdReal cosTheta1 = sqrt(1 - sinTheta1 * sinTheta1);\n\tdReal cosTheta1OverCosTheta0 = cosTheta1 / cosTheta0;\n\tdReal sinTheta0 = tanTheta0 * cosTheta0;\n\tdReal sinTheta1OverSinTheta0 = sinTheta1 / sinTheta0;\n\n\tsHemisphereIntegrationData data1(zIOverR, tanTheta0, sinTheta1OverSinTheta0);\n\tsHemisphereIntegrationData data2(zIOverR, tanTheta0, cosTheta1OverCosTheta0);\n\n\tdReal volume1 = simpson(data1, 0, 1, 1000);\n\tdReal volume2 = simpson(data2, 1, 1000, 1000);\n\n\treturn volume1 + volume2;\n}", "CodeBleu_score": 39.843321843431276}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal h = 0.5 * (zIOverR - tanTheta0);\n\tdReal h0 = h;\n\tdReal h1 = h;\n\tif (h0 < 0.001) {\n\t\th0 = 0.001;\n\t}\n\tif (h1 > 0.999) {\n\t\th1 = 0.999;\n\t}\n\tdReal v0 = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(h0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1", "CodeBleu_score": 30.343007871336532}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\t// Calculate the volume of the immersed hemisphere using Simpson's rule for numerical integration\n\t// Divide the integration into two parts to handle potential singularities\n\t// Sum the results to return the total volume\n\tdReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(sHemisphereIntegrationData(zIOverR, tanTheta0, sinTheta1), 0.0, 1.0, 100);\n\treturn volume;\n}", "CodeBleu_score": 26.680868028222427}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal xCenterOfMass = 0;\n\tdReal xCenterOfMassIntegral = 0;\n\tsHemisphereIntegrationData hemisphereIntegrationData(zIOverR, tanTheta0, sinTheta1, volume);\n\txCenterOfMassIntegral = sHemisphereIntegrationData::xCenterOfMassIntegrand(0, &hemisphereIntegrationData);\n\txCenterOfMass = (xCenterOfMassIntegral / hemisphereIntegrationData.getSurfaceArea()) * hemisphereIntegrationData.getVolume();\n\treturn xCenterOfMass;\n}", "CodeBleu_score": 30.60237654963854}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\t// Calculate the x-coordinate of the buoyancy center scaled by the radius\n\tdReal xBuoyancyCenter = 0;\n\tif (zIOverR <= 0) {\n\t\t// The capsule is fully submerged\n\t\txBuoyancyCenter = 0.5;\n\t} else if (zIOverR >= 1) {\n\t\t// The capsule is fully outside the hemisphere\n\t\txBuoyancyCenter = 0;\n\t} else {\n\t\t// The capsule is partially submerged and partially outside the hemisphere\n\t\txBuoyancyCenter = 0.5 * (1 - zIOverR) * (1 + zIOverR * zIOverR) + zIOverR * zIOverR * tanTheta0 + 0.5 * zIOverR * zIOverR * zIOverR * zIOverR / sinTheta1;\n\t}\n\t// Adjust the x-coordinate of the buoyancy center by the volume\n\txBuoyancyCenter *= volume;\n\treturn xBuoyancyCenter;\n}", "CodeBleu_score": 33.3318623365069}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tsHemisphereIntegrationData data(zIOverR, tanTheta0, sinTheta1, volume);\n\treturn simpson(data, 0.0, 1.0, 100);\n}", "CodeBleu_score": 17.20492400780395}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdxTriMesh *trimesh = (dxTriMesh *) o2;\n\tdVector3 normal;\n\tdVector3 p1;\n\tdVector3 p2;\n\tdVector3 p3;\n\tdVector3 p4;\n\tdVector3 p5;\n\tdVector3 p6;\n\tdVector3 p7;\n\tdVector3 p8;\n\tdVector3 p9;\n\tdVector3 p10;\n\tdVector3 p11;\n\tdVector3 p12;\n\tdVector3 p13;\n\tdVector3 p14;\n\tdVector3 p15;\n\tdVector3 p16;\n\tdVector3 p17;\n\tdVector3 p18;\n\tdVector3 p19;\n\tdVector3 p20;\n\tdVector3 p21;\n\tdVector3 p22;\n\tdVector3 p23;\n\tdVector3 p24;\n\tdVector3 p25;\n\tdVector3 p26;\n\tdVector3 p27;\n\tdVector3 p28;\n\tdVector3 p29;\n\tdVector3 p30;\n\tdVector3 p31;\n\tdVector3 p32;\n\tdVector3 p33;\n\tdVector3 p34;\n\tdVector3 p35;\n\tdVector3 p36;\n\tdVector3 p37;\n\tdVector3 p38;\n\tdVector3 p39;\n\tdVector3 p40;\n\tdVector3 p41;\n\tdVector3 p42;\n\tdVector3 p43;\n\tdVector3 p44;\n\tdVector3 p45;\n\tdVector3 p46;\n\tdVector3 p47;\n\tdVector3 p48;\n\tdVector3 p49;\n\tdVector3 p50;\n\tdVector3 p51;\n\tdVector3 p52;\n\tdVector3 p53;\n\tdVector3 p54;\n\tdVector3 p55;\n\td", "CodeBleu_score": 9.558704718327373}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (immersion->g1 == o1 && immersion->g2 == o2, \"Immersion geometry mismatch\");\n\tdUASSERT (o1->type == dCapsuleClass && o2->type == dTriMeshClass, \"Immersion geometry mismatch\");\n\tdUASSERT (o1->space && o2->space, \"Not enough space for immersion\");\n\tdUASSERT (o1->body && o2->body, \"Not enough body for immersion\");\n\tdUASSERT (o1->body!= o2->body, \"Not enough body for immersion\");\n\tdUASSERT (o1->body->world == o2->body->world, \"Not enough body for immersion\");\n\tdUASSERT (o1->body->world, \"Not enough world for immersion\");\n\tdUASSERT (o1->body->world->collision_space, \"Not enough space for immersion\");\n\tdUASSERT (o1->body->world->collision_space->g, \"Not enough geometry for immersion\");\n\tdUASSERT (o1->body->world->collision_space->g->type == dTriMeshClass, \"Not enough geometry for immersion\");\n\tdUASSERT (o1->body->world->collision_space->g->space, \"Not enough space for immersion\");\n\tdUASSERT (o1->body->world->collision_space->g->space->g, \"Not enough geometry for immersion\");\n\tdUASSERT (o1->body->world->collision_space->g->space->g->type == dTriMeshClass, \"Not enough geometry for immersion\");\n\tdUASSERT (o1->body->world->collision_space->g->space->g->space, \"Not enough space for immersion\");\n\tdUASSERT (o1->body->world->collision_space->g->space->g->space->g, \"Not enough geometry for immersion\");\n\tdUASSERT (o1->body->world->collision_space->g->space->g->space->g->type == dTriMeshClass, \"Not enough geometry for immersion\");\n\tdUASSERT (o1->body->world->collision_space->g->space->g->space->g->space, \"Not enough space for immersion", "CodeBleu_score": 31.805871129600394}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT (immersion->g1 == o1 && immersion->g2 == o2,\"immersion->g1 == o1 && immersion->g2 == o2\");\n\tdUASSERT (immersion->g1->type == dCapsuleClass && immersion->g2->type == dTriMeshClass,\"immersion->g1->type == dCapsuleClass && immersion->g2->type == dTriMeshClass\");\n\tdUASSERT (immersion->g1->space && immersion->g2->space,\"immersion->g1->space && immersion->g2->space\");\n\tdUASSERT (immersion->g1->space == immersion->g2->space,\"immersion->g1->space == immersion->g2->space\");\n\tdUASSERT (immersion->g1->body && immersion->g2->body,\"immersion->g1->body && immersion->g2->body\");\n\tdUASSERT (immersion->g1->body == immersion->g2->body,\"immersion->g1->body == immersion->g2->body\");\n\tdUASSERT (immersion->g1->body->world && immersion->g2->body->world,\"immersion->g1->body->world && immersion->g2->body->world\");\n\tdUASSERT (immersion->g1->body->world == immersion->g2->body->world,\"immersion->g1->body->world == immersion->g2->body->world\");\n\n\tdUASSERT (o1->body && o2->body,\"o1->body && o2->body\");\n\tdUASSERT (o1->body == o2->body,\"o1->body == o2->body\");\n\tdUASSERT (o1->body->world && o2->body->world,\"o1->body->world && o2->body->world\");\n\tdUASSERT (o1->body->world == o2->body->world,\"o1->body->world == o2->body->world\");\n\n\tdUASSERT (o1->type == dCapsuleClass && o2->type == dTriMeshClass,\"o1->type == dCapsuleClass && o2->type == dTriMeshClass\");\n\n\td", "CodeBleu_score": 34.01684616303962}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get sleep duration in milliseconds from input\n\tconst auto duration = getInput<std::chrono::milliseconds>(\"duration\");\n\tif (!duration.has_value()) {\n\t\t// If duration is missing, return SUCCESS\n\t\treturn NodeStatus::SUCCESS;\n\t} else if (duration.value().count() <= 0) {\n\t\t// If duration is non-positive, return SUCCESS\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start a timer with the sleep duration\n\ttimer_.add(duration.value(), [this]() {\n\t\t// When the timer expires, emit a wake-up signal\n\t\temitWakeUpSignal();\n\t});\n\n\t// Set a callback to reset the timer_waiting_ flag if the timer is aborted\n\ttimer_.setAbortCallback([this]() {\n\t\ttimer_waiting_ = false;\n\t});\n\n\t// Set the timer_waiting_ flag to true\n\ttimer_waiting_ = true;\n\n\t// Return RUNNING\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 54.01343998119196}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get the sleep duration in milliseconds from the input.\n\tauto duration = getInput<int>(\"duration\");\n\t// If the duration is missing or non-positive, return SUCCESS.\n\tif (!duration || *duration <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\t// Set the node status to RUNNING.\n\tsetStatus(NodeStatus::RUNNING);\n\t// Start a timer with the given duration in milliseconds.\n\ttimer_.add(std::chrono::milliseconds(*duration), [this]() {\n\t\t// When the timer expires, emit a wake-up signal.\n\t\temitWakeUpSignal();\n\t});\n\t// Set a callback to reset the timer_waiting_ flag when the timer is aborted.\n\ttimer_.setAbortCallback([this]() {\n\t\ttimer_waiting_ = false;\n\t});\n\t// Set the timer_waiting_ flag to true to indicate that the node is waiting for the timer to expire.\n\ttimer_waiting_ = true;\n\t// Return RUNNING to indicate that the node is waiting for the timer to expire.\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 53.09953015988611}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get the sleep duration from the input\n\tauto duration_ms = getInput<int>(0);\n\n\t// If the duration is missing or non-positive, return SUCCESS\n\tif (!duration_ms.has_value() || duration_ms.value() <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start a timer with the sleep duration\n\ttimer_.add(std::chrono::milliseconds(duration_ms.value()), [&]() {\n\t\t// Emit a wake-up signal when the timer expires\n\t\temitWakeUpSignal();\n\n\t\t// Ensure the timer_waiting_ flag is reset\n\t\ttimer_waiting_ = false;\n\t});\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_waiting_ = true;\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 43.09253014401597}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (config().blackboard->isEntryRegistered(config().entryName)) {\n\t\tEntryBase* entry = config().blackboard->getEntry(config().entryName);\n\t\tentry->lock();\n\t\tif (entry->getSequenceId()!= config().sequenceId) {\n\t\t\tconfig().sequenceId = entry->getSequenceId();\n\t\t\tentry->unlock();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t\tentry->unlock();\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 32.45833651452975}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Get the entry from the blackboard\n\tauto entry = config().blackboard->getEntry(entry_name_);\n\tif (entry) {\n\t\t// Lock the entry's mutex\n\t\tstd::lock_guard<std::mutex> lock(entry->mutex_);\n\t\t// Check if the entry's sequence ID has changed\n\t\tif (entry->sequence_id_!= sequence_id_) {\n\t\t\t// Update the sequence ID and return SUCCESS\n\t\t\tsequence_id_ = entry->sequence_id_;\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\t// If the entry is not found or the sequence IDs are the same, return FAILURE\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 36.9791382763668}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry from the blackboard.\n\t// Note that the entry is retrieved as a pointer, which is then dereferenced using the * operator.\n\t// This is necessary because the blackboard::getEntry method returns a pointer to the entry, not the entry itself.\n\t// The * operator dereferences the pointer and returns the actual entry.\n\t// If the entry is not found, the blackboard::getEntry method will return a nullptr, which will be handled by the if statement.\n\t// If the entry is found, it will be dereferenced and stored in the entry variable.\n\tauto entry = blackboard->getEntry<int>(entryName);\n\tif (!entry) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the mutex associated with the entry.\n\t// The mutex is used to protect the entry from being accessed by multiple threads simultaneously.\n\t// This is important because multiple threads may be trying to access the entry at the same time, which could lead to race conditions and data corruption.\n\t// By locking the mutex, we ensure that only one thread at a time can access the entry, preventing race conditions and data corruption.\n\tentry->mutex.lock();\n\n\t// Check if the sequence ID of the entry has changed since the last time the action was executed.\n\t// The sequence ID is a unique identifier that is assigned to each update of the entry.\n\t// If the sequence ID has changed, it means that the entry has been updated by another thread or action.\n\t// If the sequence ID has not changed, it means that the entry has not been updated, and the action should return NodeStatus::FAILURE.\n\tif (entry->sequenceId!= lastSequenceId) {\n\t\t// The entry has been updated, so we store the new sequence ID and return NodeStatus::SUCCESS.\n\t\t// This indicates that the action has successfully completed and the entry has been updated.\n\t\tlastSequenceId = entry->sequenceId;\n\t\tentry->mutex.unlock();\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// The entry has not been updated, so we unlock the mutex and return NodeStatus::FAILURE.\n\t// This indicates that the action has failed to complete because the entry has not been updated.\n\tentry->mutex.unlock();\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 36.71306099042596}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn children_nodes_.size() + success_threshold_;\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 49.92709212356128}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tsize_t threshold = success_threshold_;\n\tif (threshold < 0) {\n\t\tthreshold = children_nodes_.size() + threshold;\n\t\tif (threshold < 0) {\n\t\t\tthreshold = 0;\n\t\t}\n\t}\n\treturn threshold;\n}", "CodeBleu_score": 46.7916367974181}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn children_nodes_.size() + success_threshold_;\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 49.92709212356128}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - lastHeartbeat).count() > 1000) {\n\t\t\tdisableAllHooks();\n\t\t\tstd::cout << \"Heartbeat lost, disabling all breakpoints\" << std::endl;\n\t\t} else {\n\t\t\tenableAllHooks();\n\t\t\tstd::cout << \"Heartbeat active, enabling all breakpoints\" << std::endl;\n\t\t}\n\t}\n}", "CodeBleu_score": 32.3981365045965}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\tbool isAlive = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - lastHeartbeat).count() < 1000;\n\t\tif (isAlive!= isAliveLastHeartbeat) {\n\t\t\tisAliveLastHeartbeat = isAlive;\n\t\t\tenableAllHooks(isAlive);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.6077588776018}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\t//std::cout << \"Groot2Publisher::heartbeatLoop() started\" << std::endl;\n\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (this->heartbeatActive) {\n\t\t\tif (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - this->lastHeartbeat).count() > 1000) {\n\t\t\t\t//std::cout << \"Groot2Publisher::heartbeatLoop() heartbeat timed out\" << std::endl;\n\t\t\t\tthis->heartbeatActive = false;\n\t\t\t\tthis->enableAllHooks(false);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 24.809475652867494}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\tnlohmann::json j;\n\tfor (auto& bb_name : bb_names) {\n\t\tauto _p = _blackboards.find(bb_name);\n\t\tif (_p == _blackboards.end()) {\n\t\t\tcontinue;\n\t\t}\n\t\tauto _it = _p->second.lock();\n\t\tif (!_it) {\n\t\t\tcontinue;\n\t\t}\n\t\tj[bb_name] = ExportBlackboardToJSON(_it);\n\t}\n\treturn nlohmann::json::to_msgpack(j);\n}", "CodeBleu_score": 50.38892769519141}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\tnlohmann::json json_dump;\n\tfor (const auto& bb_name : bb_names) {\n\t\tauto it = _p->subtrees.find(bb_name);\n\t\tif (it!= _p->subtrees.end()) {\n\t\t\tauto subtree = it->second.lock();\n\t\t\tif (subtree) {\n\t\t\t\tjson_dump[bb_name] = ExportBlackboardToJSON(*subtree);\n\t\t\t}\n\t\t}\n\t}\n\treturn nlohmann::json::to_msgpack(json_dump);\n}", "CodeBleu_score": 58.11916361185388}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tnlohmann::json j;\n\tstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\tfor (const std::string& bb_name : bb_names) {\n\t\tauto it = _p->subtrees.find(bb_name);\n\t\tif (it!= _p->subtrees.end()) {\n\t\t\tstd::shared_ptr<BT::Blackboard> bb = it->second.lock();\n\t\t\tif (bb) {\n\t\t\t\tj[bb_name] = ExportBlackboardToJSON(bb);\n\t\t\t}\n\t\t}\n\t}\n\treturn nlohmann::json::to_msgpack(j);\n}", "CodeBleu_score": 57.963533456366164}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::lock_guard<std::mutex> lk(mtx);\n\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif (it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\tauto node = it->second.lock();\n\tif (!node) {\n\t\treturn false;\n\t}\n\tauto hook = node->getHook(pos);\n\tif (!hook) {\n\t\treturn false;\n\t}\n\tstd::lock_guard<std::mutex> hook_lk(hook->mtx);\n\tif (hook->mode!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->desired_status = result;\n\thook->remove = remove;\n\thook->ready = true;\n\thook->cv.notify_all();\n\treturn true;\n}", "CodeBleu_score": 67.4054062484078}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\n_p->nodes_by_uid.find", "CodeBleu_score": 6.5478481138414315}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t_p->nodes_by_uid.find", "CodeBleu_score": 6.547848116858017}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tasync_result_ = std::async(std::launch::async, &ThreadedAction::tick, this);\n\t}\n\n\tif (async_result_.valid()) {\n\t\ttry {\n\t\t\tasync_result_.wait();\n\t\t\tstatus_ = async_result_.get();\n\t\t} catch (const std::exception& e) {\n\t\t\tBT::Logger::instance()->logErr(name_, e.what());\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t} catch (...) {\n\t\t\tif (std::current_exception()) {\n\t\t\t\tstd::rethrow_exception(std::current_exception());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status_;\n}", "CodeBleu_score": 34.78564542077922}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status() == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\n\t\tauto func = [this]() {\n\t\t\ttry {\n\t\t\t\tthis->tick();\n\t\t\t} catch (...) {\n\t\t\t\tLOG_ERROR << \"Exception caught in ThreadedAction::executeTick\";\n\t\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t\t\thalt_requested_ = false;\n\t\t\t\tthrow;\n\t\t\t}\n\n\t\t\tif (!halt_requested_) {\n\t\t\t\tstatus_ = NodeStatus::SUCCESS;\n\t\t\t} else {\n\t\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t\t}\n\t\t};\n\n\t\tthread_ = std::async(std::launch::async, func);\n\t}\n\n\tif (thread_.valid()) {\n\t\ttry {\n\t\t\tthread_.get();\n\t\t} catch (...) {\n\t\t\tstd::current_exception();\n\t\t}\n\t}\n\n\treturn status();\n}", "CodeBleu_score": 41.19835343049078}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\ttry {\n\t\t\ttick_thread_ = std::async(std::launch::async, &ThreadedAction::tick, this);\n\t\t} catch (std::exception& e) {\n\t\t\tLOG_ERROR << \"Exception thrown while starting async tick thread: \" << e.what();\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t\treturn status_;\n\t\t}\n\t}\n\tif (tick_thread_.valid()) {\n\t\ttry {\n\t\t\ttick_thread_.get();\n\t\t} catch (std::exception& e) {\n\t\t\tLOG_ERROR << \"Exception thrown while ticking: \" << e.what();\n\t\t}\n\t\tif (isHaltRequested()) {\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t}\n\treturn status_;\n}", "CodeBleu_score": 36.97729769879623}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\tstream << \"----------------------------------------\" << std::endl;\n\tauto print = [&](const TreeNode* node, int depth) {\n\t\tfor (int i = 0; i < depth; ++i) {\n\t\t\tstream << \"|  \";\n\t\t}\n\t\tstream << node->name << std::endl;\n\t\tif (const auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control->children) {\n\t\t\t\tprint(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (const auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\t\tprint(decorator->child, depth + 1);\n\t\t}\n\t};\n\tprint(root_node, 0);\n\tstream << \"----------------------------------------\" << std::endl;\n}", "CodeBleu_score": 50.975187282984514}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// Lambda function to recursively print the tree structure\n\tauto printTree = [&stream](const TreeNode* node, int depth) {\n\t\t// Indent the output based on the node's depth\n\t\tfor (int i = 0; i < depth; ++i) {\n\t\t\tstream << \"  \";\n\t\t}\n\n\t\t// Print the node's name\n\t\tstream << node->name << std::endl;\n\n\t\t// Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (const auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control->children) {\n\t\t\t\tprintTree(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (const auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\t\tprintTree(decorator->child, depth + 1);\n\t\t}\n\t};\n\n\t// Begin and end with separator lines\n\tstream << \"=====================\" << std::endl;\n\tprintTree(root_node, 0);\n\tstream << \"=====================\" << std::endl;\n}", "CodeBleu_score": 51.73741023144972}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstream << \"------------------------------------------\" << std::endl;\n\tstd::function<void(const TreeNode*, int)> print_tree = [&](const TreeNode* node, int depth) {\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"  \";\n\t\t}\n\t\tstream << node->name << std::endl;\n\t\tif (const auto control = dynamic_cast<const ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control->children) {\n\t\t\t\tprint_tree(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (const auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\t\tprint_tree(decorator->child, depth + 1);\n\t\t}\n\t};\n\tprint_tree(root_node, 0);\n\tstream << \"------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 49.03230271267541}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"Node is null\");\n\t}\n\tvisitor(node);\n\tif (dynamic_cast<const BT::ControlNode*>(node)!= nullptr) {\n\t\tfor (const auto& child : dynamic_cast<const BT::ControlNode*>(node)->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t}\n\telse if (dynamic_cast<const BT::DecoratorNode*>(node)!= nullptr) {\n\t\tapplyRecursiveVisitor(dynamic_cast<const BT::DecoratorNode*>(node)->child, visitor);\n\t}\n}", "CodeBleu_score": 52.8891340855099}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (auto control = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child, visitor);\n\t}\n}", "CodeBleu_score": 58.14200378964417}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child, visitor);\n\t}\n}", "CodeBleu_score": 65.0054031241441}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.registration_ID)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"ID already registered\");\n\t}\n\tbuilders[manifest.registration_ID] = builder;\n\tmanifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 42.38229156837902}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.registration_ID)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder already registered: \" + manifest.registration_ID);\n\t}\n\tmanifests.insert(std::make_pair(manifest.registration_ID, manifest));\n\tbuilders.insert(std::make_pair(manifest.registration_ID, builder));\n}", "CodeBleu_score": 50.985000694259696}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.registration_ID)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"The registration ID '\" + manifest.registration_ID +\n\t\t\t\"' is already registered\");\n\t}\n\n\tbuilders.insert({manifest.registration_ID, builder});\n\tmanifests.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 50.68726036881345}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\nauto builder = [tick_functor](TreeNodeManifests& manifests) {\n    return std::make_unique<SimpleActionNode>(tick_functor, manifests);\n};\n\nTreeNodeManifest manifest(NodeType::SIMPLE_ACTION, ID, ports);\nregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 42.344914105455686}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\n// Create a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\nNodeBuilder builder = [tick_functor, ports]() {\n    return std::make_unique<SimpleActionNode>(tick_functor, ports);\n};\n\n// Create a TreeNodeManifest with the action node type, ID, and ports list.\nTreeNodeManifest manifest(NodeType::ACTION, ID, std::move(ports));\n\n// Call registerBuilder to register the manifest and builder.\nregisterBuilder(manifest, std::move(builder));\n}", "CodeBleu_score": 48.50411447988438}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\n// 1. Create a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\n  auto builder = [tick_functor, ports](const std::string& name,\n                                       const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n  };\n\n// 2. Create a TreeNodeManifest with the action node type, ID, and ports list.\n  TreeNodeManifest manifest{TreeNodeType::ACTION, ID, ports};\n\n// 3. Call registerBuilder to register the manifest and builder.\n  registerBuilder(manifest, std::move(builder));\n}", "CodeBleu_score": 72.77795207258286}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (auto& sub : tree.subtrees) {\n\t\tBlackboard::Ptr backup = sub->blackboard->cloneInto();\n\t\tbb.push_back(backup);\n\t}\n\treturn bb;\n}", "CodeBleu_score": 69.23454637181885}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tsubtree->blackboard->cloneInto(bb.back());\n\t}\n\treturn bb;\n}", "CodeBleu_score": 72.87645840148853}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb;\n\tbb.reserve(tree.subtrees.size());\n\tfor (auto& subtree : tree.subtrees) {\n\t\tbb.push_back(Blackboard::create());\n\t\tsubtree->blackboard->cloneInto(*bb.back());\n\t}\n\treturn bb;\n}", "CodeBleu_score": 74.21495723889093}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(env, script);\n\tif (!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor.value().Execute(env);\n}", "CodeBleu_score": 66.44798763497896}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor.value()->Execute(env);\n}", "CodeBleu_score": 70.34072286899128}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(env, script);\n\tif (!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor.value()->Execute(env);\n}", "CodeBleu_score": 66.46667738624583}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (handle_) {\n\t\tthrow RuntimeError(\"Shared library already loaded\");\n\t}\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle_) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tpath_ = path;\n}", "CodeBleu_score": 47.250976316461745}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (handle) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tthis->path = path;\n}", "CodeBleu_score": 49.57662155573468}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (handle_!= nullptr) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle_ == nullptr) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tpath_ = path;\n}", "CodeBleu_score": 47.476978355195534}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tstr = str.trim();\n\n\tif (str[0]!= '{' || str[str.size - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 20.5728353794907}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped = str.strip();\n\n\tif (stripped[0]!= '{' || stripped[stripped.size - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.subStringView(1, stripped.size - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 22.67370066669524}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size < 3) {\n\t\treturn false;\n\t}\n\n\tstr = str.trim();\n\n\tif (str[0]!= '{' || str[str.size - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.subString(1, str.size - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 20.716805953594253}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (int i = 0; i < line.count(); ++i, line.advance()) {\n\t\tdouble point_cost = pointCost(line.getX(), line.getY());\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\tcost = std::max(cost, point_cost);\n\t}\n\treturn cost;\n}", "CodeBleu_score": 52.330235047466154}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0;\n\tLineIterator line(x0, y0, x1, y1);\n\tfor (line.reset(); line.isValid(); line.advance()) {\n\t\tdouble pointCost = pointCost(line.getX(), line.getY());\n\t\tif (pointCost < 0) {\n\t\t\treturn pointCost;\n\t\t}\n\t\tcost = std::max(cost, pointCost);\n\t}\n\treturn cost;\n}", "CodeBleu_score": 56.75311696810476}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\t// initialize the line iterator\n\tLineIterator line(costmap_, Point(x0, y0), Point(x1, y1));\n\t// iterate through each point on the line\n\tfor (int i = 0; i < line.count(); ++i, line.advance()) {\n\t\t// calculate the point cost\n\t\tdouble point_cost = pointCost(line.getX(), line.getY());\n\t\t// if the point cost is negative, return immediately\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\t// update the line cost if the point cost is higher\n\t\tif (point_cost > line_cost) {\n\t\t\tline_cost = point_cost;\n\t\t}\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 62.037457234365824}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 83.04198294017864}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 83.04198294017864}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\n\t\tif (!path.empty()) {\n\t\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\t}\n\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 79.25448806576337}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tdouble x_vel = base_odom.twist.twist.linear.x;\n\tdouble y_vel = base_odom.twist.twist.linear.y;\n\tdouble z_vel = base_odom.twist.twist.linear.z;\n\tdouble x_rot = base_odom.twist.twist.angular.x;\n\tdouble y_rot = base_odom.twist.twist.angular.y;\n\tdouble z_rot = base_odom.twist.twist.angular.z;\n\n\tdouble rot_vel = sqrt(x_rot*x_rot + y_rot*y_rot + z_rot*z_rot);\n\tdouble trans_vel = sqrt(x_vel*x_vel + y_vel*y_vel + z_vel*z_vel);\n\n\tif (rot_vel <= rot_stopped_velocity && trans_vel <= trans_stopped_velocity) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 48.17604190160951}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) && (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}", "CodeBleu_score": 54.695409491608004}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity);\n}", "CodeBleu_score": 87.75235257480885}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tboost::mutex::scoped_lock l(configuration_mutex_);\n\tif (restore_defaults) {\n\t\tdefault_limits_ = LocalPlannerLimits();\n\t\tsetup_ = false;\n\t}\n\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\tlimits_ = config;\n}", "CodeBleu_score": 64.12214904312201}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\t// if we're restoring the default configuration, make sure to use the\n\t\t// original configuration\n\t\tconfig = default_limits_;\n\t\tsetup_ = false;\n\t}\n\n\tif (!setup_) {\n\t\t// first time initialization\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tconfig_mutex_.lock();\n\tlimits_ = config;\n\tconfig_mutex_.unlock();\n}", "CodeBleu_score": 59.84865254327825}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t\t//avoid looping\n\t\tsetup_ = false;\n\t}\n\n\tboost::mutex::scoped_lock l(configuration_mutex_);\n\tlimits_ = config;\n}", "CodeBleu_score": 69.95767446975776}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\tunsigned int mx, my;\n\t// get the cell's map coordinates\n\tmx = check_cell->x;\n\tmy = check_cell->y;\n\n\t// check the cell's cost\n\tunsigned char cost = costmap.getCost(mx, my);\n\n\t// if the cell is an obstacle or has no information, set its target distance to the maximum obstacle cost and return false\n\tif (cost >= costmap_2d::LETHAL_OBSTACLE) {\n\t\tcheck_cell->target_distance = LETHAL_OBSTACLE_COST;\n\t\treturn false;\n\t}\n\n\t// if the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter\n\tunsigned int distance = current_cell->target_distance + 1;\n\tif (distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = distance;\n\t}\n\n\t// return true\n\treturn true;\n}", "CodeBleu_score": 52.90204340424529}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\tunsigned int mx, my;\n\tif (!costmap.worldToMap(check_cell->x, check_cell->y, mx, my)) {\n\t\treturn false;\n\t}\n\n\tunsigned int index = getIndex(mx, my);\n\tunsigned char cost = costmap.getCost(mx, my);\n\tif (cost >= costmap_2d::LETHAL_OBSTACLE) {\n\t\tcheck_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n\t\treturn false;\n\t}\n\n\tdouble distance = distanceLookup[index];\n\tif (distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = distance;\n\t\tcheck_cell->parent_x = current_cell->x;\n\t\tcheck_cell->parent_y = current_cell->y;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 57.10502969909452}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// Get the cost of the cell from the costmap\n\tunsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\t// If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false\n\tif (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n\t\tcurrent_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n\t\treturn false;\n\t}\n\t// If the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter\n\tunsigned int new_distance = current_cell->target_distance + cost;\n\tif (new_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_distance;\n\t}\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 60.50568696562494}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\t// initialize the cost and scaling factor\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\n\t// check if the footprint specification is empty\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"Footprint specification is empty.\");\n\t\treturn -9;\n\t}\n\n\t// for each point in the trajectory\n\tfor (int i = 0; i < traj.getPointsSize(); ++i) {\n\t\t// get the point\n\t\tconst geometry_msgs::PoseStamped &pose = traj.getPoint(i);\n\n\t\t// calculate the footprint cost\n\t\tdouble footprint_cost = footprintCost(pose.pose.position.x, pose.pose.position.y, pose.pose.position.z,\n\t\t\t\tpose.pose.orientation.x, pose.pose.orientation.y, pose.pose.orientation.z,\n\t\t\t\tpose.pose.orientation.w);\n\n\t\t// if the footprint cost is negative, return the cost immediately\n\t\tif (footprint_cost < 0)\n\t\t\treturn footprint_cost;\n\n\t\t// otherwise, either sum the scores or take the maximum score based on the sum_scores_ flag\n\t\tif (sum_scores_)\n\t\t\tcost += footprint_cost;\n\t\telse\n\t\t\tcost = std::max(cost, footprint_cost);\n\t}\n\n\t// return the total cost\n\treturn cost * scaling_factor;\n}", "CodeBleu_score": 52.026104052307765}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"No footprint points provided for cost calculation\");\n\t\treturn -9;\n\t}\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i), footprint_spec_,\n\t\t\t\tinscribed_radius_, circumscribed_radius_);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t} else {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost;\n\t\t\t} else {\n\t\t\t\tcost = std::max(cost, footprint_cost);\n\t\t\t}\n\t\t}\n\t}\n\tcost *= scaling_factor;\n\treturn cost;\n}", "CodeBleu_score": 53.105799097496885}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t\t// Initialize the cost and scaling factor\n\tdouble cost = 0.0;\n\tdouble scaling_factor = 1.0;\n\tif (traj.getPointsSize() > 0) {\n\t\tdouble vx = traj.getPoint(0).velocity_.x();\n\t\tdouble vy = traj.getPoint(0).velocity_.y();\n\t\tdouble speed = hypot(vx, vy);\n\t\tscaling_factor = getScalingFactor(speed);\n\t}\n\t// If the footprint specification is empty, log an error and return -9\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"No footprint points provided\");\n\t\treturn -9;\n\t}\n\t// For each point in the trajectory, calculate the footprint cost\n\tfor (size_t i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble footprint_cost = footprintCost(traj.getPoint(i));\n\t\t// If the footprint cost is negative, return the cost immediately\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\t\t// Either sum the scores or take the maximum score based on the sum_scores_ flag\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\t// Return the total cost\n\treturn cost * scaling_factor;\n}", "CodeBleu_score": 55.05866187777835}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t// scale the footprint points by the scale factor\n\tstd::vector<geometry_msgs::Point> scaled_footprint;\n\tfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n\t\tgeometry_msgs::Point new_point;\n\t\tnew_point.x = footprint_spec[i].x * scale;\n\t\tnew_point.y = footprint_spec[i].y * scale;\n\t\tnew_point.z = 0.0;\n\t\tscaled_footprint.push_back(new_point);\n\t}\n\n\t// compute the footprint cost using a world model\n\tdouble footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint, costmap);\n\n\t// if the cost is negative, return -6.0\n\tif (footprint_cost < 0.0) {\n\t\treturn -6.0;\n\t}\n\n\t// if the position is off the map, return -7.0\n\tunsigned int cell_x, cell_y;\n\tif (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n\t\treturn -7.0;\n\t}\n\n\t// return the maximum cost between the footprint cost and the cell cost at the given position\n\treturn std::max(footprint_cost, costmap->getCost(cell_x, cell_y));\n}", "CodeBleu_score": 73.7138447034817}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t// scale the footprint points by a given scale factor\n\tstd::vector<geometry_msgs::Point> scaled_footprint;\n\tfor (unsigned int i = 0; i < footprint_spec.size(); i++) {\n\t\tgeometry_msgs::Point new_point;\n\t\tnew_point.x = footprint_spec[i].x * scale;\n\t\tnew_point.y = footprint_spec[i].y * scale;\n\t\tnew_point.z = footprint_spec[i].z * scale;\n\t\tscaled_footprint.push_back(new_point);\n\t}\n\n\t// compute the footprint cost using a world model\n\tdouble cost = world_model->footprintCost(x, y, th, scaled_footprint, costmap);\n\n\t// if the cost is negative, return -6.0\n\tif (cost < 0) {\n\t\treturn -6.0;\n\t}\n\n\t// if the position is off the map, return -7.0\n\tif (!costmap->worldToMap(x, y, mx, my)) {\n\t\treturn -7.0;\n\t}\n\n\t// otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n\treturn std::max(cost, costmap->getCost(mx, my));\n}", "CodeBleu_score": 64.49413842871326}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//  std::vector<geometry_msgs::Point> scaled_footprint;\n  std::vector<geometry_msgs::Point> scaled_footprint;\n\n  // check if we have a valid footprint, since we depend on the\n  // footprint for computations\n  if (footprint_spec.size() < 3) {\n    ROS_ERROR(\"The robot footprint must be at least 3 points long\");\n    return -1.0;\n  }\n\n  // we need to cycle through each point in the footprint and\n  // transform it into the global frame so we can obtain its cost\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    double x_i = footprint_spec[i].x * scale;\n    double y_i = footprint_spec[i].y * scale;\n\n    //we don't want to rotate back to the frame of the footprint, since it takes\n    //more time than just moving the robot for a negligible difference\n    double x_f = x + cos(th) * x_i - sin(th) * y_i;\n    double y_f = y + sin(th) * x_i + cos(th) * y_i;\n\n    geometry_msgs::Point pt;\n    pt.x = x_f;\n    pt.y = y_f;\n    scaled_footprint.push_back(pt);\n  }\n\n  // now we can compute the costs of the footprint at this position\n  double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint, costmap);\n\n  //if the footprint is invalid at this point return -6\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  // check for legality at the center point\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n\n  double point_cost = costmap->getCost(mx, my);\n\n  //if the center point is not legal...\n  if (point_cost >= costmap_2d::LETHAL_OBSTACLE) {\n    return -5.0;\n  }\n\n  //if the footprint is legal...\n  if (footprint_cost >= 0) {\n    //check the highest of", "CodeBleu_score": 67.56923877166388}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic_!= odom_topic) {\nodom_topic_ = odom_topic;\nif (odom_topic_.empty()) {\nodom_sub_.shutdown();\n} else {\nodom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n}\n}\n}", "CodeBleu_score": 41.36248300635763}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic_!= odom_topic) {\nodom_topic_ = odom_topic;\nif (!odom_topic_.empty()) {\nodom_sub_.subscribe(node_, odom_topic_, 50, &OdometryHelperRos::odomCallback, this);\n} else {\nodom_sub_.shutdown();\n}\n}\n}", "CodeBleu_score": 44.00492034149587}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic_!= odom_topic) {\nodom_topic_ = odom_topic;\nif (odom_topic_.empty()) {\nodom_sub_.shutdown();\n} else {\nodom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 5, &OdometryHelperRos::odomCallback, this);\n}\n}\n}", "CodeBleu_score": 44.86195873027559}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t//squared distance between current and previous positions\n\tfloat sqr_dist = (pos - prev).squaredNorm();\n\t//angular difference between current and previous positions\n\tfloat angle_diff = fabs(angles::shortest_angular_distance(tf::getYaw(tf::createQuaternionFromYaw(tf::getYaw(tf::createQuaternionFromRPY(0, 0, pos.z())))), tf::getYaw(tf::createQuaternionFromYaw(tf::getYaw(tf::createQuaternionFromRPY(0, 0, prev.z()))))));\n\tif (sqr_dist > sqr_dist_threshold_ || angle_diff > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 37.92019674278265}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tconst float dx = pos.x() - prev.x();\n\tconst float dy = pos.y() - prev.y();\n\tconst float dz = pos.z() - prev.z();\n\n\tconst float sq_dist = dx * dx + dy * dy + dz * dz;\n\tconst float sq_dist_threshold = oscillation_reset_dist_ * oscillation_reset_dist_;\n\n\tif (sq_dist > sq_dist_threshold) {\n\t\tresetOscillationFlags();\n\t\treturn;\n\t}\n\n\tconst float yaw = tf::getYaw(tf::createQuaternionFromYaw(tf::getYaw(prev_orientation_)));\n\tconst float prev_yaw = tf::getYaw(tf::createQuaternionFromYaw(tf::getYaw(current_orientation_)));\n\n\tconst float diff_yaw = angles::shortest_angular_distance(yaw, prev_yaw);\n\tconst float diff_yaw_abs = fabs(diff_yaw);\n\tconst float diff_yaw_threshold = oscillation_reset_angle_ * M_PI / 180.0;\n\n\tif (diff_yaw_abs > diff_yaw_threshold) {\n\t\tresetOscillationFlags();\n\t\treturn;\n\t}\n}", "CodeBleu_score": 41.947371195512694}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat sq_dist = (pos - prev).squaredNorm();\n\tfloat angle = fabs(tf2::getYaw(tf2::Quaternion(pos.x(), pos.y(), pos.z(), 0.0f) * tf2::Quaternion(prev.x(), prev.y(), prev.z(), 0.0f).inverse()));\n\n\tif (sq_dist > sq_dist_threshold_ || angle > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 37.576220969608364}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// TODO: Implement this function.\n\t// HINT: You may want to use the following functions:\n\t// gridCoords, gridIndex, nearestNeighborDistance\n\t// You may also want to use the following member variables:\n\t// grid_bounds_, grid_resolution_, grid_size_, cells_\n\t// If you use the nearestNeighborDistance function, you will need to use the following member variables:\n\t// kdtree_\n\t// If you use the gridIndex function, you will need to use the following member variables:\n\t// grid_bounds_, grid_resolution_, grid_size_\n\t// You may also want to use the following member functions:\n\t// PointGrid::insert\n\n\t// get grid coordinates\n\tstd::vector<double> gridCoords = gridCoords(pt);\n\n\t// check if point is outside grid bounds\n\tif (gridCoords[0] < 0 || gridCoords[0] >= grid_size_[0] ||\n\t\tgridCoords[1] < 0 || gridCoords[1] >= grid_size_[1]) {\n\t\treturn;\n\t}\n\n\t// check if point is too close to its nearest neighbor\n\tif (nearestNeighborDistance(pt) < 0.05) {\n\t\treturn;\n\t}\n\n\t// get grid index\n\tint gridIndex = gridIndex(gridCoords);\n\n\t// insert point into corresponding cell\n\tcells_[gridIndex].push_back(pt);\n}", "CodeBleu_score": 44.71364600926198}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// get the grid coordinates of the point\n\tstd::vector<int> gridCoords = getGridCoords(pt);\n\n\t// check if the point is outside the grid bounds\n\tif (gridCoords[0] < 0 || gridCoords[0] >= gridSize_[0] || gridCoords[1] < 0 || gridCoords[1] >= gridSize_[1]) {\n\t\treturn;\n\t}\n\n\t// check if the point is too close to its nearest neighbor\n\tdouble nearestNeighborDistance = getNearestNeighborDistance(pt);\n\tif (nearestNeighborDistance < minDistance_) {\n\t\treturn;\n\t}\n\n\t// calculate the grid index\n\tint gridIndex = gridCoords[0] * gridSize_[1] + gridCoords[1];\n\n\t// insert the point into the corresponding cell\n\tcells_[gridIndex].push_back(pt);\n}", "CodeBleu_score": 44.67558404120071}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t// Calculate the grid coordinates of the point\n\tint grid_x = (pt.x - min_x_) / grid_size_;\n\tint grid_y = (pt.y - min_y_) / grid_size_;\n\tint grid_z = (pt.z - min_z_) / grid_size_;\n\n\t// Check if the point is within the grid bounds\n\tif (grid_x < 0 || grid_x >= num_grid_x_ || grid_y < 0 || grid_y >= num_grid_y_ || grid_z < 0 || grid_z >= num_grid_z_) {\n\t\treturn;\n\t}\n\n\t// Calculate the grid index\n\tint grid_index = grid_x + grid_y * num_grid_x_ + grid_z * num_grid_x_ * num_grid_y_;\n\n\t// Check if the point is too close to its nearest neighbor\n\tif (!cells_[grid_index].empty()) {\n\t\tdouble nearest_neighbor_distance = std::numeric_limits<double>::max();\n\t\tfor (const auto& neighbor : cells_[grid_index]) {\n\t\t\tdouble distance = std::sqrt(std::pow(pt.x - neighbor.x, 2) + std::pow(pt.y - neighbor.y, 2) + std::pow(pt.z - neighbor.z, 2));\n\t\t\tif (distance < nearest_neighbor_distance) {\n\t\t\t\tnearest_neighbor_distance = distance;\n\t\t\t}\n\t\t}\n\t\tif (nearest_neighbor_distance < min_distance_) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Insert the point into the corresponding cell\n\tcells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 40.10155466796689}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tnew_vel[i] = std::min(std::max(vel[i] + acclimits[i] * dt, sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 60.668089020837}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 75.85987720991375}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel(i) > vel(i)) {\n\t\t\tnew_vel(i) = std::min(vel(i) + acclimits(i) * dt, sample_target_vel(i));\n\t\t} else {\n\t\t\tnew_vel(i) = std::max(vel(i) - acclimits(i) * dt, sample_target_vel(i));\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 61.71159312451985}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = 0.0;\n\tdouble x_diff = 0.0;\n\tdouble y_diff = 0.0;\n\n\t//find the farthest point along the path that is visible\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t//convert the global plan point to map coordinates\n\t\tunsigned int mx, my;\n\t\tcostmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y, mx, my);\n\n\t\t//check if the global plan point is in a lethal cell\n\t\tif (costmap_.getCost(mx, my) >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n\t\t\t//if so, then we have found the farthest visible point\n\t\t\tbreak;\n\t\t}\n\n\t\t//if not, then save this point\n\t\tx_diff = global_plan_[i].pose.position.x - x;\n\t\ty_diff = global_plan_[i].pose.position.y - y;\n\t}\n\n\t//if we have a valid point, then calculate the difference in heading\n\tif (x_diff!= 0.0 || y_diff!= 0.0) {\n\t\t//convert the goal point to world coordinates\n\t\tdouble wx, wy;\n\t\tcostmap_.mapToWorld(cell_x, cell_y, wx, wy);\n\n\t\t//calculate the difference in heading\n\t\tdouble angle = atan2(wy - y, wx - x);\n\t\tdiff = angles::shortest_angular_distance(heading, angle);\n\t} else {\n\t\t//if we don't have a valid point, then return DBL_MAX\n\t\tdiff = DBL_MAX;\n\t}\n\n\treturn diff;\n}", "CodeBleu_score": 57.82579883571333}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t// Find the farthest point on the path that has a clear line of sight to the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// Convert the path point coordinates to world coordinates\n\t\tdouble wx, wy;\n\t\tcostmap_.mapToWorld(global_plan_[i].x, global_plan_[i].y, wx, wy);\n\n\t\t// Check if the line of sight to the current cell is clear\n\t\tdouble line_cost = lineCost(cell_x, cell_y, global_plan_[i].x, global_plan_[i].y);\n\t\tif (line_cost >= 0) {\n\t\t\t// Calculate the difference in heading between the current heading and the direction to the goal point\n\t\t\tdouble goal_heading = atan2(wy - y, wx - x);\n\t\t\tdouble heading_diff = angles::shortest_angular_distance(heading, goal_heading);\n\n\t\t\t// Return the absolute value of the heading difference\n\t\t\treturn fabs(heading_diff);\n\t\t}\n\t}\n\n\t// No valid point found, return DBL_MAX\n\treturn DBL_MAX;\n}", "CodeBleu_score": 55.298947726691}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t// get the current cell\n\tunsigned int current_cell_x, current_cell_y;\n\tcostmap_.worldToMap(x, y, current_cell_x, current_cell_y);\n\n\t// iterate through the global plan in reverse\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// get the map coordinates of the global plan point\n\t\tunsigned int global_cell_x, global_cell_y;\n\t\tcostmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y, global_cell_x, global_cell_y);\n\n\t\t// check if the global plan point is in the current cell\n\t\tif (global_cell_x == current_cell_x && global_cell_y == current_cell_y) {\n\t\t\t// check if there is a clear line of sight to the global plan point\n\t\t\tif (lineCost(current_cell_x, current_cell_y, global_cell_x, global_cell_y) >= 0.0) {\n\t\t\t\t// convert the goal cell coordinates to world coordinates\n\t\t\t\tdouble goal_x, goal_y;\n\t\t\t\tcostmap_.mapToWorld(global_cell_x, global_cell_y, goal_x, goal_y);\n\n\t\t\t\t// return the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n\t\t\t\treturn fabs(angles::shortest_angular_distance(heading, atan2(goal_y - y, goal_x - x)));\n\t\t\t}\n\t\t}\n\t}\n\n\t// if no valid point is found, return DBL_MAX\n\treturn DBL_MAX;\n}", "CodeBleu_score": 67.79245267906609}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost >= 0) {\n\t\treturn true;\n\t} else {\n\t\tROS_WARN(\"Invalid Trajectory vx=%f, vy=%f, vtheta=%f, cost=%f\", vx_samp, vy_samp, vtheta_samp, cost);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 81.85697370818885}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t//ROS_INFO(\"TrajectoryPlanner::checkTrajectory\");\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost < 0) {\n\t\tROS_WARN(\"Invalid Trajectory: vx: %.2f vy: %.2f vtheta: %.2f, cost: %.3f\", vx_samp, vy_samp, vtheta_samp, cost);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 78.6601566265144}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost >= 0) {\n\t\treturn true;\n\t} else {\n\t\tROS_WARN(\"Invalid trajectory: x=%f, y=%f, theta=%f, vx=%f, vy=%f, vtheta=%f, vx_samp=%f, vy_samp=%f, vtheta_samp=%f, cost=%f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, cost);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 73.79196396182499}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not clear the costmaps given to the navigation stack.\");\n\t\treturn;\n\t}\n\n\tros::WallTime t0 = ros::WallTime::now();\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing outside the area to clear\");\n\t} else {\n\t\tROS_WARN(\"Clearing inside the area to clear\");\n\t}\n\n\tif (clear_global_costmap_) {\n\t\tglobal_costmap_->clearArea(clear_x_, clear_y_, clear_radius_,\n\t\t\t\tinvert_area_to_clear_);\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->updateMap();\n\t\t}\n\t}\n\n\tif (clear_local_costmap_) {\n\t\tlocal_costmap_->clearArea(clear_x_, clear_y_, clear_radius_,\n\t\t\t\tinvert_area_to_clear_);\n\t\tif (force_update_) {\n\t\t\tlocal_costmap_->updateMap();\n\t\t}\n\t}\n\n\tROS_DEBUG(\"Clearing took %.2f seconds\",\n\t\t\t(ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 53.61213173500949}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not clear the costmaps given to the navigation stack.\");\n\t\treturn;\n\t}\n\n\tros::WallTime t0 = ros::WallTime::now();\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing outside the area to clear\");\n\t} else {\n\t\tROS_WARN(\"Clearing inside the area to clear\");\n\t}\n\n\tif (clear_global_costmap_) {\n\t\tglobal_costmap_->resetLayers();\n\t\tif (force_updating_when_clearing_) {\n\t\t\tglobal_costmap_->updateMap();\n\t\t}\n\t}\n\n\tif (clear_local_costmap_) {\n\t\tlocal_costmap_->resetLayers();\n\t\tif (force_updating_when_clearing_) {\n\t\t\tlocal_costmap_->updateMap();\n\t\t}\n\t}\n\n\tROS_DEBUG(\"Clearing took %f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 47.18407390743674}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not set the costmaps in the constructor.  \"\n\t\t\t\t\"Do not set the costmaps when the object is initialized. Instead, call the object's initialize function.\");\n\t\treturn;\n\t}\n\n\tros::WallTime t0 = ros::WallTime::now();\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing outside the robot's footprint.\");\n\t} else {\n\t\tROS_WARN(\"Clearing inside the robot's footprint.\");\n\t}\n\n\tif (affected_maps_ == BOTH) {\n\t\tROS_DEBUG(\"Clearing both costmaps.\");\n\t\tif (invert_area_to_clear_) {\n\t\t\tglobal_costmap_->clearUnknownSpace(footprint_spec_);\n\t\t\tlocal_costmap_->clearUnknownSpace(footprint_spec_);\n\t\t} else {\n\t\t\tglobal_costmap_->clearRobotFootprint();\n\t\t\tlocal_costmap_->clearRobotFootprint();\n\t\t}\n\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->updateMap();\n\t\t\tlocal_costmap_->updateMap();\n\t\t}\n\t} else if (affected_maps_ == LOCAL) {\n\t\tROS_DEBUG(\"Clearing local costmap.\");\n\t\tif (invert_area_to_clear_) {\n\t\t\tlocal_costmap_->clearUnknownSpace(footprint_spec_);\n\t\t} else {\n\t\t\tlocal_costmap_->clearRobotFootprint();\n\t\t}\n\n\t\tif (force_update_) {\n\t\t\tlocal_costmap_->updateMap();\n\t\t}\n\t} else if (affected_maps_ == GLOBAL) {\n\t\tROS_DEBUG(\"Clearing global costmap.\");\n\t\tif (invert_area_to_clear_) {\n\t\t\tglobal_costmap_->clearUnknownSpace(footprint_spec_);\n\t\t} else {\n\t\t\tglobal_costmap_->clearRobotFootprint();\n\t\t}\n\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->updateMap();\n\t\t}\n\t} else {\n\t", "CodeBleu_score": 49.951319791063526}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\n\tif (polygon.empty())\n\t\treturn;\n\n\t//add all cells between points\n\tfor (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n\t\traytraceLine(polygon_cells, polygon[i], polygon[i + 1]);\n\t}\n\n\t//close the polygon\n\tif (!polygon.empty()) {\n\t\traytraceLine(polygon_cells, polygon.back(), polygon.front());\n\t}\n}", "CodeBleu_score": 47.089991064917825}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tpolygon_cells.clear();\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tfor (unsigned int i = 1; i < polygon.size(); i++) {\n\t\traytraceLine(polygon[i - 1], polygon[i], polygon_cells);\n\t}\n\tif (polygon.size() > 2) {\n\t\traytraceLine(polygon.back(), polygon.front(), polygon_cells);\n\t}\n}", "CodeBleu_score": 40.042335938791126}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t// polygonOutlineCells\n\tpolygon_cells.clear();\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\t// Add the cells between consecutive points\n\tfor (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n\t\traytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n\t}\n\t// Close the polygon\n\tif (polygon.size() > 2) {\n\t\traytraceLine(polygon.back(), polygon.front(), polygon_cells);\n\t}\n}", "CodeBleu_score": 45.950862156527506}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tROS_DEBUG(\"New subscriber\");\n\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 67.94011159462406}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tROS_DEBUG(\"Got a new subscriber - publishing grid\");\n\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 65.17655021469508}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tdouble wx, wy;\n\tcostmap_->mapToWorld(0, 0, wx, wy);\n\tgrid_.info.origin.position.x = wx - resolution / 2;\n\tgrid_.info.origin.position.y = wy - resolution / 2;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tunsigned char* costmap_data = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < grid_.info.width * grid_.info.height; ++i) {\n\t\tgrid_.data[i] = costmap_data[i] == costmap_2d::NO_INFORMATION? -1 : (costmap_data[i] >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE? 100 : 0);\n\t}\n}", "CodeBleu_score": 82.64069022337921}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap for publishing\n\tcostmap_->getMutex().lock();\n\t// Get the costmap resolution\n\tdouble resolution = costmap_->getResolution();\n\t// Set the grid's header\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\t// Set the grid's resolution, width, and height\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\t// Convert the map coordinates to world coordinates for the origin\n\tdouble origin_x, origin_y;\n\tcostmap_->mapToWorld(0, 0, origin_x, origin_y);\n\t// Set the origin's position and orientation\n\tgrid_.info.origin.position.x = origin_x;\n\tgrid_.info.origin.position.y = origin_y;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\t// Save the origin coordinates\n\torigin_x_ = origin_x;\n\torigin_y_ = origin_y;\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\t// Populate the grid data from the costmap's character map\n\tunsigned char* char_map = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < grid_.data.size(); ++i) {\n\t\tgrid_.data[i] = char_map_translation_table_[char_map[i]];\n\t}\n\t// Unlock the costmap\n\tcostmap_->getMutex().unlock();\n}", "CodeBleu_score": 71.37605074666023}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tconst char* char_map = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < grid_.data.size(); i++) {\n\t\tgrid_.data[i] = char_map_translation_table_[char_map[i]];\n\t}\n}", "CodeBleu_score": 71.4069521110955}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\t// If the footprint and robot radius in the new and old configurations are the same, return immediately.\n\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\t// If the new configuration contains a valid footprint string, convert the string to a footprint and set it.\n\tif (!new_config.footprint.empty()) {\n\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\tif (makeFootprintFromString(new_config.footprint, footprint)) {\n\t\t\tsetUnpaddedRobotFootprint(footprint);\n\t\t\treturn;\n\t\t} else {\n\t\t\tROS_ERROR(\"Failed to parse footprint string '%s'.\", new_config.footprint.c_str());\n\t\t}\n\t}\n\t// If no valid footprint string is provided, set the footprint based on the robot radius.\n\tstd::vector<geometry_msgs::Point> footprint;\n\tmakeFootprintFromRadius(new_config.robot_radius, footprint);\n\tsetUnpaddedRobotFootprint(footprint);\n}", "CodeBleu_score": 67.42408279165066}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\n\t// we need to re-subscribe to topics if our footprint has changed\n\tif (new_config.footprint!= old_config.footprint) {\n\t\t// we need to re-subscribe to topics if our footprint has changed\n\t\tclearRobotFootprint();\n\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\tif (makeFootprintFromString(new_config.footprint, footprint)) {\n\t\t\tsetUnpaddedRobotFootprint(footprint);\n\t\t} else {\n\t\t\tROS_ERROR(\"Invalid footprint specification, using default\");\n\t\t\tmakeFootprintFromRadius(new_config.robot_radius);\n\t\t}\n\t} else {\n\t\tmakeFootprintFromRadius(new_config.robot_radius);\n\t}\n}", "CodeBleu_score": 72.16972329433723}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\n\tif (!new_config.footprint.empty()) {\n\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\tif (makeFootprintFromString(new_config.footprint, footprint)) {\n\t\t\tsetUnpaddedRobotFootprint(footprint);\n\t\t\treturn;\n\t\t} else {\n\t\t\tROS_ERROR(\"Failed to parse footprint string into a vector of points, using default footprint\");\n\t\t}\n\t}\n\n\tsetUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n}", "CodeBleu_score": 69.39955359640409}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (!tf_->getRobotPose(global_frame_, ros::Time(), costmap_ros_->getGlobalFrameID(), new_pose_)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\n\t// @brief\n\t// This function, Costmap2DROS::reconfigureCB, is a callback for handling reconfiguration events.\nIt attempts to get the robot's current pose and stores it in new_pose.\nIf it fails to retrieve the pose, it logs a warning message and cancels reconfiguration.\n\treconfigureCB(reconfigure_server_->getConfig(), true);\n}", "CodeBleu_score": 52.89261026646256}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// getRobotPose() is a function that returns a bool.\n\t// It is defined in costmap_2d_ros.cpp\n\tif (!getRobotPose()) {\n\t\t// if getRobotPose() returns false,\n\t\t// log a warning message\n\t\tROS_WARN_THROTTLE(1.0, \"Costmap2DROS transform timeout. Current pose undefined.\");\n\t\treturn;\n\t}\n\t// if getRobotPose() returns true,\n\t// cancel reconfiguration\n\tcancelReconfiguration();\n}", "CodeBleu_score": 26.11219419251792}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\ttf::Stamped<tf::Pose> new_pose;\n\tif (!tf_.getRobotPose(new_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\tif (new_pose.frame_id_!= global_frame_) {\n\t\tROS_ERROR(\"The costmap was told to track robot pose in the frame %s, but the robot's frame is %s.  Cannot set pose\", global_frame_.c_str(), new_pose.frame_id_.c_str());\n\t\treturn;\n\t}\n\n\t//we also want to check if the new pose has moved in a significantly different direction than the last time we updated the costmap\n\tdouble yaw = tf::getYaw(new_pose.getRotation());\n\tdouble my_delta = angles::shortest_angular_distance(last_pose_.getRotation().getAngle(), yaw);\n\tdouble mx_delta = new_pose.getOrigin().x() - last_pose_.getOrigin().x();\n\tdouble my_delta = new_pose.getOrigin().y() - last_pose_.getOrigin().y();\n\tif (fabs(my_delta) < min_trans_delta_ || fabs(mx_delta) < min_trans_delta_ || fabs(my_delta) < min_rot_delta_) {\n\t\treturn;\n\t}\n\tlast_pose_ = new_pose;\n\t//we need to call one update on the map since the robot has moved\n\tupdateMap();\n}", "CodeBleu_score": 52.34612007453296}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\tstd::vector<boost::shared_ptr<Layer> > *plugins = layered_costmap_->getPlugins();\n\t\tfor (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin!= plugins->end(); ++plugin) {\n\t\t\t(*plugin)->activate();\n\t\t}\n\t\tstopped_ = false;\n\t\tstop_updates_ = false;\n\t}\n\twhile (!ros::ok() ||!layered_costmap_->isSizeLocked() ||!map_update_thread_ ||!map_update_thread_->isActive()) {\n\t\tif (!ros::ok()) {\n\t\t\tROS_ERROR(\"Costmap2DROS: Received a shutdown request.\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!layered_costmap_->isSizeLocked()) {\n\t\t\tROS_ERROR(\"Costmap2DROS: The costmap has no size lock.\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!map_update_thread_ ||!map_update_thread_->isActive()) {\n\t\t\tROS_ERROR(\"Costmap2DROS: The costmap update thread is not running.\");\n\t\t\tbreak;\n\t\t}\n\t\tROS_ERROR(\"Costmap2DROS: Waiting for the costmap to be ready...\");\n\t\tros::Duration(0.5).sleep();\n\t}\n}", "CodeBleu_score": 58.688092951214465}, {"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\tstd::vector<boost::shared_ptr<Layer> > *plugins = layered_costmap_->getPlugins();\n\t\tfor (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin!= plugins->end(); ++plugin) {\n\t\t\t(*plugin)->activate();\n\t\t}\n\t\tstopped_ = false;\n\t\tstop_updates_ = false;\n\t\twhile (!ros::ok() ||!layered_costmap_->isSizeLocked() ||!layered_costmap_->isInitialized()) {\n\t\t\tif (!ros::ok()) {\n\t\t\t\tROS_ERROR(\"Costmap2DROS starting, but ROS is not ok. Quitting.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!layered_costmap_->isInitialized()) {\n\t\t\t\tROS_ERROR(\"Costmap2DROS starting, but layered costmap is not initialized. Quitting.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!layered_costmap_->isSizeLocked()) {\n\t\t\t\tROS_ERROR(\"Costmap2DROS starting, but size is not locked. Quitting.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tROS_WARN(\"Costmap2DROS starting, but it is still waiting for the first map to be received...\");\n\t\t\tros::Duration(0.1).sleep();\n\t\t}\n\t}\n}", "CodeBleu_score": 59.69033239468398}, {"code": "void Costmap2DROS::start(){\n\t\tstd::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n\tbool stopped = false;\n\tBOOST_FOREACH (boost::shared_ptr<Layer> &plugin, *plugins)\n\t{\n\t\tif (plugin->isStopped())\n\t\t{\n\t\t\tplugin->activate();\n\t\t\tstopped = true;\n\t\t}\n\t}\n\tif (stopped)\n\t\tstopped_ = false;\n\tstop_updates_ = false;\n\n\twhile (!ros::ok() ||!layered_costmap_->isInitialized() ||!map_update_thread_ ||!map_update_thread_->isActive())\n\t{\n\t\tif (!ros::ok())\n\t\t{\n\t\t\tROS_ERROR(\"Costmap2DROS starting, but ROS is not running. Waiting for the first ROS spin().\");\n\t\t}\n\t\telse if (!layered_costmap_->isInitialized())\n\t\t{\n\t\t\tROS_ERROR(\"Costmap2DROS starting, but layered costmap is not current. Waiting for first update.\");\n\t\t}\n\t\telse if (!map_update_thread_ ||!map_update_thread_->isActive())\n\t\t{\n\t\t\tROS_ERROR(\"Costmap2DROS starting, but map update thread is not running. Waiting.\");\n\t\t}\n\t\tros::Duration(0.1).sleep();\n\t}\n}", "CodeBleu_score": 46.37783840990638}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_.isZero()) {\n\t\tif (!observation_list_.empty()) {\n\t\t\tobservation_list_.erase(observation_list_.begin());\n\t\t}\n\t} else {\n\t\tros::Time now = ros::Time::now();\n\t\tfor (ObservationList::iterator it = observation_list_.begin(); it!= observation_list_.end();) {\n\t\t\tif (now - it->header.stamp > observation_keep_time_) {\n\t\t\t\tit = observation_list_.erase(it);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.51377939973776}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If we're keeping only the most recent observation, then we can just\n\t// remove all but the last observation.\n\tif (observation_keep_time_.isZero()) {\n\t\tobservation_list_.erase(observation_list_.begin(),\n\t\t\t\tobservation_list_.end() - 1);\n\t\treturn;\n\t}\n\n\t// Otherwise, we need to iterate through the list and remove observations\n\t// that are too old.\n\tfor (ObservationList::iterator it = observation_list_.begin();\n\t\t\tit!= observation_list_.end();) {\n\t\tif (observation_keep_time_ < ros::Time::now() - it->timestamp) {\n\t\t\tit = observation_list_.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.29323979813327}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == ros::Duration(0.0)) {\n\t\tobservation_list_.clear();\n\t\tobservation_list_.push_back(last_observation_);\n\t} else {\n\t\tros::Time now = ros::Time::now();\n\t\tObservationList::iterator it = observation_list_.begin();\n\t\twhile (it!= observation_list_.end()) {\n\t\t\tif (now - it->header.stamp >= observation_keep_time_) {\n\t\t\t\tit = observation_list_.erase(it);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.53651965733361}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// If the path is empty, return\n\tif (path.empty()) {\n\t\treturn;\n\t}\n\n\t// If the start index is out of bounds, set it to the first index\n\tif (start_index < 0) {\n\t\tstart_index = 0;\n\t}\n\n\t// If the end index is out of bounds, set it to the last index\n\tif (end_index >= path.size()) {\n\t\tend_index = path.size() - 1;\n\t}\n\n\t// If the start and end indices are the same, return\n\tif (start_index == end_index) {\n\t\treturn;\n\t}\n\n\t// Get the yaw angle of the start pose\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\n\t// Get the yaw angle of the end pose\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble shortest_angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Calculate the incremental change in angle for each pose in the specified range\n\tdouble delta_angle = shortest_angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\t// Calculate the new yaw angle for the current pose\n\t\tdouble new_yaw = start_yaw + delta_angle * (i - start_index);\n\n\t\t// Set the orientation of the current pose to the new yaw angle\n\t\tpath[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), new_yaw));\n\t}\n}", "CodeBleu_score": 58.02404259892734}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// TODO: Implement this method to interpolate the orientation of poses in a path between given start and end indices.\n\t// The function should calculate the yaw angles at the start and end indices and determine the shortest angular distance between them.\n\t// It should then compute the incremental change in angle for each pose and update the orientation of each pose in the specified range accordingly.\n\n\t// Calculate the yaw angle at the start index\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\n\t// Calculate the yaw angle at the end index\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble shortest_angular_distance = tf2::shortestAngularDistance(start_yaw, end_yaw);\n\n\t// Calculate the incremental change in angle for each pose in the specified range\n\tdouble incremental_angle = shortest_angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\t// Calculate the new yaw angle for the current pose\n\t\tdouble new_yaw = start_yaw + incremental_angle * (i - start_index);\n\n\t\t// Set the new orientation for the current pose\n\t\tpath[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), new_yaw));\n\t}\n}", "CodeBleu_score": 59.66333244473263}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (start_index > end_index) {\n\t\tthrow std::runtime_error(\"OrientationFilter::interpolate: start_index > end_index\");\n\t}\n\n\t// get the yaw angles at the start and end indices\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// determine the shortest angular distance between the start and end yaw angles\n\tdouble angular_distance = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n\t// compute the incremental change in angle for each pose\n\tdouble delta_angle = angular_distance / (end_index - start_index);\n\n\t// update the orientation of each pose in the specified range\n\tdouble current_angle = start_yaw;\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tcurrent_angle += delta_angle;\n\t\tpath[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), current_angle));\n\t}\n}", "CodeBleu_score": 58.019848942771276}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// set up the frame_id of the start and goal\n\treq.start.header.frame_id = costmap_ros_->getGlobalFrameID();\n\treq.goal.header.frame_id = costmap_ros_->getGlobalFrameID();\n\n\t// call the makePlan function\n\tmakePlan(req.start, req.goal, req.tolerance, resp.plan);\n\n\t// update the response with the success status and the generated path\n\tresp.code = resp.plan.size() > 0? navfn::MakeNavPlan::Response::OK : navfn::MakeNavPlan::Response::OUT_OF_REACH;\n\n\t// return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 40.39255633879359}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t//std::cout << \"makePlanService\" << std::endl;\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tbool result = makePlan(req.start, req.goal, plan);\n\tresp.plan.poses.clear();\n\tif (result) {\n\t\tfor (unsigned int i = 0; i < plan.size(); i++) {\n\t\t\tresp.plan.poses.push_back(plan[i]);\n\t\t}\n\t}\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\treturn true;\n}", "CodeBleu_score": 59.06688440521795}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_DEBUG(\"Got a goal request to make a plan.\");\n\tif(req.goal.header.frame_id!= costmap_ros_->getGlobalFrameID()) {\n\t\tROS_ERROR(\"This planner as configured will only accept goals in the %s frame, but a goal was sent in the %s frame.\", costmap_ros_->getGlobalFrameID().c_str(), req.goal.header.frame_id.c_str());\n\t\treturn false;\n\t}\n\tgeometry_msgs::PoseStamped start;\n\tstart.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tstart.header.stamp = ros::Time::now();\n\tstart.pose = req.start;\n\tgeometry_msgs::PoseStamped goal;\n\tgoal.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tgoal.header.stamp = ros::Time::now();\n\tgoal.pose = req.goal;\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tbool result = makePlan(start, goal, plan);\n\tif(result) {\n\t\tROS_DEBUG(\"Found a plan to goal\");\n\t\tresp.plan.resize(plan.size());\n\t\tfor(unsigned int i = 0; i < plan.size(); i++) {\n\t\t\tresp.plan[i] = plan[i];\n\t\t}\n\t}\n\telse {\n\t\tROS_DEBUG(\"Failed to find a plan to goal\");\n\t}\n\tresp.success = result;\n\treturn true;\n}", "CodeBleu_score": 44.70205661832012}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\n//\tprivate_nh = ros::NodeHandle(\"~/\" + name);\n\tprivate_nh = ros::NodeHandle(\"~\");\n\n\tros::NodeHandle n;\n\tmake_plan_srv = n.advertiseService(\"make_plan\",\n\t\t\t&PlannerWithCostmap::makePlanService, this);\n\tgoal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1,\n\t\t\t&PlannerWithCostmap::goalCB, this);\n\n}", "CodeBleu_score": 62.12926833929363}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tprivate_nh.advertiseService(name, &PlannerWithCostmap::makePlanService, this);\n\tprivate_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 51.08430541781453}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t//    ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n    cmap_ = cmap;\n    private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 61.64081116547223}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\tdouble resolution = costmap_->getResolution();\n\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 83.87997991772444}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\tdouble resolution = costmap_->getResolution();\n\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 83.87997991772444}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\tdouble resolution = costmap_->getResolution();\n\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 83.87997991772444}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = ros::Time::now();\n\n\t\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 88.60358048543145}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = ros::Time::now();\n\n\t\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 88.60358048543145}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\n\t\t\t\t\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = ros::Time::now();\n\n\t\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 90.47381022559843}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID g;\n\n\t// This convenience function creates a unique ID for this goal.\n\tg.id = ros::this_node::getName() + ros::this_node::getNamespace() +\n\t\t\tboost::lexical_cast<std::string>(goal_count_++);\n\tg.stamp = ros::Time::now();\n\n\tgoal_id_ = g.id;\n\tROS_DEBUG_NAMED(\"goal\", \"Setting goal ID to %s\", goal_id_.c_str());\n\n\t// We'll get the full path for the filename instead of just a basename\n\t// This allows us to run multiple stacks without having to worry about\n\t// getting collisions in our log files.\n\tstd::string filename =\n\t\ttf::createFileName(ros::this_node::getName(), ros::this_node::getNamespace(),\n\t\t\t\t\"goal\");\n\n\t// Open the file with a unique filename.\n\t// We don't want to overwrite an old one that might still be being written to.\n\tFILE* f = fopen(filename.c_str(), \"w\");\n\tif (f) {\n\t\t// Write the message to the file.\n\t\tfprintf(f, \"header:", "CodeBleu_score": 45.53691468194731}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID goal_id;\n\tgoal_id.stamp = ros::Time::now();\n\tgoal_id.id = boost::lexical_cast<std::string>(goal_id.stamp.toNSec()) + \"_\" + boost::lexical_cast<std::string>(rand());\n\n\t//we have a new goal\n\tROS_DEBUG_NAMED(\"goal\", \"Received a new goal action\");\n\n\t//wrap the pose in the action message and publish it\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = goal_id.stamp;\n\taction_goal.goal_id = goal_id;\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 64.38215889761858}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID goal_id;\n\tgoal_id.stamp = ros::Time::now();\n\tgoal_id.id = \"move_base\";\n\tactionlib_msgs::GoalStatus status;\n\tstatus.status = actionlib_msgs::GoalStatus::PENDING;\n\tstatus.goal_id = goal_id;\n\tstatus.text = \"Move base accepts the goal\";\n\tstatus.stamp = ros::Time::now();\n\taction_goal_pub_.publish(status);\n\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 64.63276124964861}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble current_sq_distance = (current_pose_.pose.position.x - start_pose_.pose.position.x) * (current_pose_.pose.position.x - start_pose_.pose.position.x) + (current_pose_.pose.position.y - start_pose_.pose.position.y) * (current_pose_.pose.position.y - start_pose_.pose.position.y);\n\tif (current_sq_distance >= limited_sq_distance_) {\n\t\tROS_INFO(\"MoveSlowAndClear: Robot has moved far enough. Removing speed limit.\");\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 65.29647970547302}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble sq_distance = current_pose_.getSqDistance(start_pose_);\n\tif (sq_distance >= sq_limited_distance_) {\n\t\tROS_INFO(\"Distance check passed, moving forward\");\n\t\tif (remove_limit_thread_) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 75.27227994239387}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\t// Check if the robot has moved far enough to remove the speed limit\n\tif (current_distance_sq_ >= limited_distance_sq_) {\n\t\tROS_INFO(\"Distance check passed, removing speed limit.\");\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 55.972976455762435}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\trm::PoseStamped robot;\n\tcostmap_ros_->getRobotPose(robot);\n\tstd::vector<rm::PoseStamped> plan;\n\tmakePlan(robot, *goal, plan);\n}", "CodeBleu_score": 56.26524825455107}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Got new pose\");\n\t// Get the current pose of the robot\n\ttf::Stamped<tf::Pose> global_pose;\n\tcostmap_ros_->getRobotPose(global_pose);\n\n\t// Create a vector of waypoints to hold the path\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\n\t// Call the navfn planner to get a path from the current pose to the goal pose\n\tif (navfn_planner_->makePlan(global_pose, *goal, plan)) {\n\t\t// Publish the path\n\t\tROS_INFO(\"Path found\");\n\t\tpath_pub_.publish(plan);\n\t} else {\n\t\tROS_INFO(\"No path found\");\n\t}\n}", "CodeBleu_score": 50.72946943988701}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Received a goal pose!\");\n\trm::PoseStamped global_pose;\n\tif(!costmap_->getRobotPose(global_pose)) {\n\t\tROS_WARN(\"Unable to get starting pose of robot, unable to create global plan\");\n\t\treturn;\n\t}\n\tstd::vector<rm::PoseStamped> plan;\n\tmakePlan(global_pose, *goal, plan);\n}", "CodeBleu_score": 53.54423100072716}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet gimbal_param_set;\n\tgimbal_param_set.request.param_id = param_set.param_id;\n\tgimbal_param_set.request.value = param_set.value;\n\tthis->param_set_client_.call(gimbal_param_set);\n}", "CodeBleu_score": 60.68481059657016}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value.integer = param_set.value;\n\tthis->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 68.03012571924391}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tthis->param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 62.826747042969785}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\t//create a socket using socket()\n\tint sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sockfd < 0) {\n\t\tROS_ERROR(\"ERROR opening socket\");\n\t\treturn;\n\t}\n\n\t//initialize socket structure\n\tstruct sockaddr_in serv_addr;\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(port);\n\n\t//bind the socket to port\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tROS_ERROR(\"ERROR on binding\");\n\t\treturn;\n\t}\n\n\t//listen for socket connections\n\tlisten(sockfd, 5);\n\n\t//accept incoming connections\n\tstruct sockaddr_in cli_addr;\n\tsocklen_t clilen = sizeof(cli_addr);\n\tint newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\tif (newsockfd < 0) {\n\t\tROS_ERROR(\"ERROR on accept\");\n\t\treturn;\n\t}\n\n\t//read from socket\n\tint n;\n\tchar buffer[256];\n\tbzero(buffer, 256);\n\tn = read(newsockfd, buffer, 255);\n\tif (n < 0) {\n\t\tROS_ERROR(\"ERROR reading from socket\");\n\t\treturn;\n\t}\n\n\t//decode message\n\tstd::string msg = buffer;\n\tROS_INFO(\"Message received: %s\", msg.c_str());\n\tstd::vector<std::string> msg_parts = split(msg, ',');\n\tif (msg_parts.size()!= 2) {\n\t\tROS_ERROR(\"Message format error\");\n\t\treturn;\n\t}\n\tstd::string msg_type = msg_parts[0];\n\tstd::string msg_content = msg_parts[1];\n\n\t//publish message\n\tif (msg_type == \"status\") {\n\t\tROS_INFO(\"Publishing status message\");\n\t", "CodeBleu_score": 39.97370535136092}, {"code": "void CommunicationBridge::serverFun(){\n\t\tint sockfd, newsockfd, portno;\n\tsocklen_t clilen;\n\tchar buffer[256];\n\tstruct sockaddr_in serv_addr, cli_addr;\n\tint n;\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"ERROR, no port provided\n\");\n\t\texit(1);\n\t}\n\tsockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sockfd < 0)\n\t\tperror(\"ERROR opening socket\");\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tportno = atoi(argv[1]);\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(portno);\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0)\n\t\tperror(\"ERROR on binding\");\n\tlisten(sockfd, 5);\n\tclilen = sizeof(cli_addr);\n\tnewsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\tif (newsockfd < 0)\n\t\tperror(\"ERROR on accept\");\n\twhile (1) {\n\t\tbzero(buffer, 256);\n\t\tn = read(newsockfd, buffer, 255);\n\t\tif (n < 0)\n\t\t\tperror(\"ERROR reading from socket\");\n\t\tif (n <= 0) {\n\t\t\tROS_ERROR(\"ERROR: Received message length is zero or less.\");\n\t\t\tclose(newsockfd);\n\t\t\tbreak;\n\t\t}\n\t\tdecodeMsg(buffer);\n\t\tpubMsg();\n\t}\n}", "CodeBleu_score": 44.952362159684164}, {"code": "void CommunicationBridge::serverFun(){\n\t\tROS_INFO(\"Waiting for connection from ground station...\");\n\twaitConnectionFromGroundStation();\n\tROS_INFO(\"Connection established.\");\n\n\twhile (ros::ok()) {\n\t\tpubMsg = accept(serverSocket, (struct sockaddr *) &clientAddress, &clientAddressLength);\n\t\tif (pubMsg < 0) {\n\t\t\tperror(\"Error accepting connection.\");\n\t\t\tclose(pubMsg);\n\t\t\texit(1);\n\t\t}\n\n\t\tROS_INFO(\"Waiting for data from ground station...\");\n\t\tdecodeMsg(pubMsg);\n\t\tif (msgLength <= 0) {\n\t\t\tROS_ERROR(\"Error receiving data from ground station.\");\n\t\t\tclose(pubMsg);\n\t\t\texit(1);\n\t\t}\n\n\t\tROS_INFO(\"Data received from ground station.\");\n\t\tROS_INFO(\"Publishing data to ROS...\");\n\t\tpub.publish(msg);\n\t\tROS_INFO(\"Data published to ROS.\");\n\t\tclose(pubMsg);\n\t}\n}", "CodeBleu_score": 32.100121461200146}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->simulation_mode_) {\n\t\tstd::map<int, UAVBasic*>::iterator it = this->swarm_control_simulation_.find(uav_cmd.id);\n\t\tif (it!= this->swarm_control_simulation_.end()) {\n\t\t\t(*it).second->uavCmdPub(uav_cmd);\n\t\t}\n\t} else {\n\t\tthis->uav_basic_->uavCmdPub(uav_cmd);\n\t}\n}", "CodeBleu_score": 53.582602338592935}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (simulation_mode_) {\n\t\t// Find the corresponding UAV by ID from swarm_control_simulation_\n\t\tmap<int, UAVBasic*>::iterator it = swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= swarm_control_simulation_.end()) {\n\t\t\t// Publish the command to the matching UAV\n\t\t\t(*it).second->uavCmdPub(uav_cmd);\n\t\t}\n\t} else {\n\t\t// Publish the command to a single UAV using uav_basic_\n\t\tuav_basic_->uavCmdPub(uav_cmd);\n\t}\n}", "CodeBleu_score": 42.92577825726812}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->simulation_mode_) {\n\t\t// Find the UAV in the simulation\n\t\tstd::map<int, UAVBasic*>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\t// If the UAV is found, publish the command\n\t\tif (it!= this->swarm_control_simulation_.end()) {\n\t\t\t(*it).second->uavCmdPub(uav_cmd);\n\t\t}\n\t} else {\n\t\t// If not in simulation mode, publish the command to a single UAV\n\t\tthis->uav_basic_->uavCmdPub(uav_cmd);\n\t}\n}", "CodeBleu_score": 53.76250836132168}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t} else if (mode_selection.mode == EXITNX) {\n\t\tsystem(\"exit\");\n\t} else if (mode_selection.mode == CREATEMODE) {\n\t\tcreateMode(mode_selection.use_mode);\n\t} else if (mode_selection.mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection.use_mode);\n\t}\n}", "CodeBleu_score": 49.71667048253827}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t}\n\telse if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exitnx\");\n\t}\n\telse if (mode_selection.use_mode == CREATE) {\n\t\tcreateMode(mode_selection);\n\t}\n\telse if (mode_selection.use_mode == DELETE) {\n\t\tdeleteMode(mode_selection);\n\t}\n\telse {\n\t\tstd::cout << \"Invalid mode selected\" << std::endl;\n\t}\n}", "CodeBleu_score": 60.82179512410536}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t}\n\telse if (mode_selection.mode == EXITNX) {\n\t\tsystem(\"exit\");\n\t}\n\telse if (mode_selection.mode == CREATE) {\n\t\tcreateMode(mode_selection);\n\t}\n\telse if (mode_selection.mode == DELETE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 59.959467947416364}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (heartbeat_count_ == prev_heartbeat_count_) {\n\t\tif (heartbeat_count_ == 0) {\n\t\t\tROS_ERROR(\"No heartbeat received\");\n\t\t} else {\n\t\t\tROS_ERROR(\"No heartbeat received for %d seconds\", heartbeat_count_);\n\t\t}\n\n\t\tif (triggerSwarmControl) {\n\t\t\tROS_ERROR(\"Triggering swarm control\");\n\t\t\ttriggerSwarmControl = false;\n\t\t\ttriggerUAV = true;\n\t\t\ttriggerUGV = true;\n\t\t} else if (triggerUAV) {\n\t\t\tROS_ERROR(\"Triggering UAV\");\n\t\t\ttriggerUAV = false;\n\t\t\ttriggerUGV = true;\n\t\t} else if (triggerUGV) {\n\t\t\tROS_ERROR(\"Triggering UGV\");\n\t\t\ttriggerUGV = false;\n\t\t} else {\n\t\t\tROS_ERROR(\"Triggering swarm control\");\n\t\t\ttriggerSwarmControl = true;\n\t\t\ttriggerUAV = true;\n\t\t\ttriggerUGV = true;\n\t\t}\n\n\t\tdisconnect_flag_ = true;\n\t} else {\n\t\tdisconnect_flag_ = false;\n\t}\n\tprev_heartbeat_count_ = heartbeat_count_;\n}", "CodeBleu_score": 35.820342712066676}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (heartbeat_count == prev_heartbeat_count) {\n\t\theartbeat_count = 0;\n\t\tif (heartbeat_count == 0) {\n\t\t\tROS_ERROR(\"No Heartbeat received from %s\", vehicle_type.c_str());\n\t\t\tif (vehicle_type == \"swarm\") {\n\t\t\t\ttriggerSwarmControl = true;\n\t\t\t} else if (vehicle_type == \"UAV\") {\n\t\t\t\ttriggerUAV = true;\n\t\t\t} else if (vehicle_type == \"UGV\") {\n\t\t\t\ttriggerUGV = true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprev_heartbeat_count = heartbeat_count;\n\t}\n}", "CodeBleu_score": 36.45498235194579}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// Check if the heartbeat count has changed since the last time the function was called\n\tif (heartbeat_count!= last_heartbeat_count) {\n\t\t// Reset the heartbeat count\n\t\tlast_heartbeat_count = heartbeat_count;\n\t\t// Reset the counter for missed heartbeats\n\t\tmissed_heartbeat_count = 0;\n\t\t// Reset the disconnect flag\n\t\tdisconnect_flag = false;\n\t} else {\n\t\t// Increment the counter for missed heartbeats\n\t\tmissed_heartbeat_count++;\n\t\t// Check if the counter has reached the maximum allowed value\n\t\tif (missed_heartbeat_count >= max_missed_heartbeat_count) {\n\t\t\t// Print an error message\n\t\t\tROS_ERROR_STREAM(\"CommunicationBridge: No heartbeat from \" << vehicle_type << \" for \" << missed_heartbeat_count << \" attempts.\");\n\t\t\t// Trigger appropriate actions based on the type of vehicle\n\t\t\tif (vehicle_type == \"swarm\") {\n\t\t\t\t// TODO: Trigger actions for swarm\n\t\t\t} else if (vehicle_type == \"UAV\") {\n\t\t\t\t// TODO: Trigger actions for UAV\n\t\t\t} else if (vehicle_type == \"UGV\") {\n\t\t\t\t// TODO: Trigger actions for UGV\n\t\t\t}\n\t\t\t// Set the disconnect flag to true\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 32.30556956681968}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tif(this->is_initialized == false) {\n\t\tROS_ERROR(\"EGOPlannerSwarm::multitrajSubTcpCb: Not initialized yet!\");\n\t\treturn;\n\t}\n\n\tint drone_id = msg->drone_id;\n\tif(drone_id < 0 || drone_id >= this->swarm_size) {\n\t\tROS_ERROR(\"EGOPlannerSwarm::multitrajSubTcpCb: Invalid drone ID!\");\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < msg->traj.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.id = msg->traj[i].id;\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\t\tbspline.total_time = msg->traj[i].total_time;\n\t\tbspline.total_seg_num = msg->traj[i].total_seg_num;\n\t\tbspline.order = msg->traj[i].order;\n\t\tbspline.knots.resize(msg->traj[i].knots.size());\n\t\tbspline.pos_pts.resize(msg->traj[i].pos_pts.size());\n\t\tbspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\t\tfor(int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots[j] = msg->traj[i].knots[j];\n\t\t}\n\t\tfor(int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts[j].x() = msg->traj[i].pos_pts[j].x;\n\t\t\tbspline.pos_pts[j].y() = msg->traj[i].pos_pts[j].y;\n\t\t\tbspline.pos_pts[j].z() = msg->traj[i].pos_pts[j].z;\n\t\t}\n\t\tfor(int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts[j] = msg->", "CodeBleu_score": 61.8516008855603}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->traj.size(); i++) {\n\t\tBspline bspline;\n\t\tbspline.id = msg->traj[i].id;\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots.push_back(msg->traj[i].knots[j]);\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tbspline.pos_pts.push_back(msg->traj[i].pos_pts[j]);\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tbspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n\t\t}\n\t\tthis->communication->sendMsgByTcp(this->communication->encodeMsg(bspline));\n\t}\n}", "CodeBleu_score": 51.625864105749876}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"Received a message from %s.\", msg->header.frame", "CodeBleu_score": 1.2533535680483698}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\tpcl::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\toctree_compression.encodePointCloud(cloud, compressed_str);\n\tcompressed_str.size();\n\toctree_compression.setInputCloud(cloud);\n\tpcl::fromROSMsg(msg, *cloud);\n\tstd::memcpy(compressed_data.str, compressed_str.data(), compressed_str.size());\n\tstd::vector<uint8_t> compressed_data_vector(compressed_data.str, compressed_data.str + compressed_str.size());\n\tsensor_msgs::PointCloud2 output_msg;\n\toutput_msg.header = msg.header;\n\toutput_msg.height = msg.height;\n\toutput_msg.width = msg.width;\n\toutput_msg.fields = msg.fields;\n\toutput_msg.is_bigendian = msg.is_bigendian;\n\toutput_msg.point_step = msg.point_step;\n\toutput_msg.row_step = msg.row_step;\n\toutput_msg.is_dense = msg.is_dense;\n\toutput_msg.data = compressed_data_vector;\n\treturn output_msg;\n}", "CodeBleu_score": 52.8460248063663}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZRGB> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\tpcl::io::OctreePointCloudCompression<pcl::PointXYZRGB> octree_compression;\n\toctree_compression.encodePointCloud(cloud, compressed_data.str());\n\tstd::memcpy(&compressed_str[0], compressed_data.str().data(), compressed_data.str().size());\n\tsensor_msgs::PointCloud2 output;\n\toutput.header = msg.header;\n\toutput.height = msg.height;\n\toutput.width = msg.width;\n\toutput.is_bigendian = msg.is_bigendian;\n\toutput.is_dense = msg.is_dense;\n\toutput.fields = msg.fields;\n\toutput.point_step = msg.point_step;\n\toutput.row_step = msg.row_step;\n\toutput.data = compressed_str;\n\toutput.data.resize(compressed_data.str().size());\n\treturn output;\n}", "CodeBleu_score": 35.17367071007996}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZRGB> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree_compression;\n\toctree_compression.setInputCloud(cloud.makeShared());\n\toctree_compression.encodePointCloud();\n\n\tstd::stringstream compressed_str;\n\tstd::vector<uint8_t> compressed_data;\n\tcompressed_data.resize(octree_compression.getCompressedPointCloudSize());\n\tcompressed_str.write((char*)compressed_data.data(), compressed_data.size());\n\n\tsensor_msgs::PointCloud2 output;\n\toutput.data = compressed_str.str();\n\toutput.header = msg.header;\n\toutput.height = msg.height;\n\toutput.width = msg.width;\n\toutput.is_bigendian = msg.is_bigendian;\n\toutput.is_dense = msg.is_dense;\n\toutput.point_step = msg.point_step;\n\toutput.row_step = msg.row_step;\n\toutput.fields = msg.fields;\n\toutput.data.resize(compressed_data.size());\n\tstd::memcpy(&output.data[0], &compressed_data[0], compressed_data.size());\n\n\treturn output;\n}", "CodeBleu_score": 40.83568318044573}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\t// TODO: update the state of a specific UAV in the multi_uav_state_ list\n\t// iterate through the list of UAV states and replace the matching UAV state with the new uav_state data based on the UAV ID.\n\tfor(int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++){\n\t\tif(this->multi_uav_state_.uav_state_all[i].id == uav_state.id){\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 75.71280185893609}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (uav_state.uav_id == this->multi_uav_state_.uav_state_all[i].uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 80.77247261005924}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 91.53973655827699}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.header.stamp = ros::Time::now();\n\tmulti_ugv_state.ugv_state_all.clear();\n\tmulti_ugv_state.ugv_count = 0;\n\n\tfor (std::map<int, UGVState>::iterator it = m_multi_ugv_state.ugv_state_all.begin(); it!= m_multi_ugv_state.ugv_state_all.end(); ++it) {\n\t\tUGVState ugv_state;\n\t\tugv_state.ugv_id = it->second.ugv_id;\n\t\tugv_state.battery = it->second.battery;\n\t\tugv_state.position.x = it->second.position.x;\n\t\tugv_state.position.y = it->second->position.y;\n\t\tugv_state.position.z = it->second->position.z;\n\t\tugv_state.velocity.x = it->second->velocity.x;\n\t\tugv_state.velocity.y = it->second->velocity.y;\n\t\tugv_state.velocity.z = it->second->velocity.z;\n\t\tugv_state.attitude.x = it->second->attitude.x;\n\t\tugv_state.attitude.y = it->second->attitude.y;\n\t\tugv_state.attitude.z = it->second->attitude.z;\n\t\tugv_state.attitude.w = it->second->attitude.w;\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t\tmulti_ugv_state.ugv_count++;\n\t}\n\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 43.439577944013195}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_state_all.clear();\n\tmulti_ugv_state.ugv_count = 0;\n\n\tfor (auto &ugv_state : m_multi_ugv_state.ugv_state_all) {\n\t\tUGVState ugv_state_msg;\n\t\tugv_state_msg.id = ugv_state.id;\n\t\tugv_state_msg.battery = ugv_state.battery;\n\t\tugv_state_msg.position.x = ugv_state.position.x;\n\t\tugv_state_msg.position.y = ugv_state.position.y;\n\t\tugv_state_msg.position.z = ugv_state.position.z;\n\t\tugv_state_msg.velocity.x = ugv_state.velocity.x;\n\t\tugv_state_msg.velocity.y = ugv_state.velocity.y;\n\t\tugv_state_msg.velocity.z = ugv_state.velocity.z;\n\t\tugv_state_msg.attitude.x = ugv_state.attitude.x;\n\t\tugv_state_msg.attitude.y = ugv_state.attitude.y;\n\t\tugv_state_msg.attitude.z = ugv_state.attitude.z;\n\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state_msg);\n\t\tmulti_ugv_state.ugv_count++;\n\t}\n\n\tthis->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 42.55148259516006}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_state_all.clear();\n\tmulti_ugv_state.ugv_count = 0;\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tUGVState ugv_state;\n\t\tugv_state.ugv_id = m_multi_ugv_state.ugv_state_all[i].ugv_id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state_all[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state_all[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state_all[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state_all[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state_all[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state_all[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state_all[i].velocity.z;\n\t\tugv_state.attitude.x = m_multi_ugv_state.ugv_state_all[i].attitude.x;\n\t\tugv_state.attitude.y = m_multi_ugv_state.ugv_state_all[i].attitude.y;\n\t\tugv_state.attitude.z = m_multi_ugv_state.ugv_state_all[i].attitude.z;\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t\tmulti_ugv_state.ugv_count++;\n\t}\n\tthis->all_ugv_state_pub_.publish(multi_", "CodeBleu_score": 46.47387335001882}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// The number of control points\n\tint n = q.cols();\n\n\t// The number of moving objects\n\tint m = moving_objs_->getObjNums();\n\n\t// The number of dimensions\n\tint d = q.rows();\n\n\t// The predicted position of each moving object\n\tEigen::MatrixXd obj_prid(d, m);\n\n\t// The distance between each control point and each moving object\n\tEigen::MatrixXd dist(1, m);\n\n\t// The cost and gradient of each control point\n\tdouble cost_i;\n\tEigen::MatrixXd gradient_i(d, 1);\n\n\t// The cost and gradient of the B-spline trajectory\n\tcost = 0;\n\tgradient.setZero();\n\n\t// Iterate through control points\n\tfor (int i = 0; i < n; i++) {\n\t\t// Predict the position of each moving object\n\t\tmoving_objs_->evaluateConstVel(q.col(i), ros::Time::now().toSec(), obj_prid);\n\n\t\t// Iterate through moving objects\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\t// Calculate the distance between control points and moving objects\n\t\t\tdist(j) = (cps_.points.col(i) - obj_prid.col(j)).norm();\n\n\t\t\t// If the distance is less than the clearance, update the cost and gradient\n\t\t\tif (dist(j) < clearance_) {\n\t\t\t\tcost_i = pow(clearance_ - dist(j), 2);\n\t\t\t\tgradient_i = 2 * (clearance_ - dist(j)) * (cps_.points.col(i) - obj_prid.col(j)).normalized();\n\n\t\t\t\tcost += cost_i;\n\t\t\t\tgradient.col(i) += gradient_i;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.97652267749879}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Calculate the predicted positions of moving objects.\n\tmoving_objs_->evaluateConstVel(q, moving_objs_prid_);\n\n\t// Iterate through control points.\n\tfor (int i = 0; i < cps_.points.cols(); i++) {\n\t\t// Iterate through moving objects.\n\t\tfor (int j = 0; j < moving_objs_->getObjNums(); j++) {\n\t\t\t// Compute the distance between the control point and the predicted position of the moving object.\n\t\t\tdouble dist = (cps_.points.col(i) - moving_objs_prid_.col(j)).norm();\n\n\t\t\t// If the distance is less than a specified clearance, update the cost and gradient based on the distance error.\n\t\t\tif (dist < clearance_) {\n\t\t\t\tcost += pow(clearance_ - dist, 2);\n\t\t\t\tgradient.col(i) -= 2 * (clearance_ - dist) * (cps_.points.col(i) - moving_objs_prid_.col(j)).normalized();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.04862652186196}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// initialize cost and gradient\n\tcost = 0;\n\tgradient.setZero();\n\n\t// get number of control points\n\tint n_cps = q.cols();\n\n\t// get number of moving objects\n\tint n_objs = moving_objs_->getObjNums();\n\n\t// get clearance\n\tdouble clearance = moving_objs_->getClearance();\n\n\t// get time step\n\tdouble dt = moving_objs_->getDt();\n\n\t// get predicted positions of moving objects\n\tmoving_objs_->evaluateConstVel();\n\n\t// iterate through control points\n\tfor (int i = 0; i < n_cps; i++) {\n\t\t// get control point\n\t\tEigen::Vector3d cp = q.col(i);\n\n\t\t// iterate through moving objects\n\t\tfor (int j = 0; j < n_objs; j++) {\n\t\t\t// get predicted position of moving object\n\t\t\tEigen::Vector3d obj_prid = moving_objs_->getObjPos(j);\n\n\t\t\t// compute distance between control point and moving object\n\t\t\tdouble dist = (cp - obj_prid).norm();\n\n\t\t\t// if distance is less than clearance, update cost and gradient\n\t\t\tif (dist < clearance) {\n\t\t\t\tcost += pow(clearance - dist, 2);\n\t\t\t\tgradient.col(i) += 2 * (clearance - dist) * (cp - obj_prid).normalized();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.39531952076027}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize the cost to zero and the gradient to a zero matrix.\n\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\t// Iterate through the control points of the trajectory.\n\tfor (int i = 2; i < q.rows(); i += 3) {\n\t\t// Calculate the positional error relative to reference points.\n\t\tEigen::Vector3d x = q.row(i).transpose() - ref_pts_[i - 2];\n\t\t// Calculate a velocity vector based on the difference between the current and previous control points.\n\t\tEigen::Vector3d v = q.row(i) - q.row(i - 2);\n\t\t// Calculate the squared dot product of the positional error and the velocity vector.\n\t\tdouble xdotv = x.dot(v);\n\t\t// Calculate the cross product of the positional error and the velocity vector.\n\t\tEigen::Vector3d xcrossv = x.cross(v);\n\t\t// Calculate the squared norm of the cross product.\n\t\tdouble xcrossv_norm_sq = xcrossv.squaredNorm();\n\t\t// Calculate the squared norm of the positional error.\n\t\tdouble x_norm_sq = x.squaredNorm();\n\t\t// Calculate the squared norm of the velocity vector.\n\t\tdouble v_norm_sq = v.squaredNorm();\n\t\t// Calculate the squared norm of the cross product of the velocity vector and the reference point.\n\t\tdouble vcrossref_norm_sq = v.cross(ref_pts_[i - 2]).squaredNorm();\n\t\t// Calculate the squared norm of the cross product of the positional error and the reference point.\n\t\tdouble xcrossref_norm_sq = x.cross(ref_pts_[i - 2]).squaredNorm();\n\t\t// Calculate the squared norm of the cross product of the velocity vector and the positional error.\n\t\tdouble vcrossx_norm_sq = v.cross(x).squaredNorm();\n\t\t// Calculate the squared norm of the cross product of the reference point and the positional error.\n\t\tdouble refxcrossx_norm_sq = ref_pts_[i - 2].cross(x).squaredNorm();\n\t\t// Calculate the squared norm of the cross product of the reference point and the velocity vector.\n\t\tdouble refxcrossv", "CodeBleu_score": 32.17133615803564}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tint num_pts = q.cols();\n\tcost = 0;\n\tgradient = Eigen::MatrixXd::Zero(3, num_pts);\n\n\tfor (int i = 2; i < num_pts - 2; i++) {\n\t\tEigen::Vector3d x = q.col(i);\n\t\tEigen::Vector3d v = (q.col(i + 1) - q.col(i - 1)) / 2;\n\t\tEigen::Vector3d x_cross_v = x.cross(v);\n\n\t\tEigen::Vector3d x_ref = ref_pts_[i];\n\t\tEigen::Vector3d v_ref = (ref_pts_[i + 1] - ref_pts_[i - 1]) / 2;\n\t\tEigen::Vector3d x_ref_cross_v_ref = x_ref.cross(v_ref);\n\n\t\tEigen::Vector3d x_ref_cross_v = x_ref.cross(v);\n\t\tEigen::Vector3d x_cross_v_ref = x.cross(v_ref);\n\n\t\tdouble x_ref_dot_x = x_ref.dot(x);\n\t\tdouble x_ref_dot_v = x_ref.dot(v);\n\t\tdouble v_ref_dot_v = v_ref.dot(v);\n\t\tdouble x_ref_dot_x_ref_cross_v_ref = x_ref.dot(x_ref_cross_v_ref);\n\t\tdouble x_ref_dot_x_cross_v_ref = x_ref.dot(x_cross_v_ref);\n\t\tdouble x_ref_dot_v_ref = x_ref.dot(v_ref);\n\t\tdouble x_ref_dot_x_ref_cross_v = x_ref.dot(x_ref_cross_v);\n\t\tdouble x_dot_x_ref_cross_v_ref = x.dot(x_ref_cross_v_ref);\n\t\tdouble x_dot_x_cross_v_ref = x.dot(x_cross_v_ref);\n\t\tdouble x_dot_v_ref = x.dot(v_ref);\n\t\tdouble x_dot_x_ref", "CodeBleu_score": 37.04703095625651}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tconst double a2 = 1000000.0;\n\tconst double b2 = 1000000.0;\n\tconst double c2 = 1000000.0;\n\tconst double d2 = 1000000.0;\n\tconst double e2 = 1000000.0;\n\tconst double f2 = 1000000.0;\n\tconst double g2 = 1000000.0;\n\tconst double h2 = 1000000.0;\n\tconst double i2 = 1000000.0;\n\tconst double j2 = 1000000.0;\n\tconst double k2 = 1000000.0;\n\tconst double l2 = 1000000.0;\n\tconst double m2 = 1000000.0;\n\tconst double n2 = 1000000.0;\n\tconst double o2 = 1000000.0;\n\tconst double p2 = 1000000.0;\n\tconst double q2 = 1000000.0;\n\tconst double r2 = 1000000.0;\n\tconst double s2 = 1000000.0;\n\tconst double t2 = 1000000.0;\n\tconst double u2 = 1000000.0;\n\tconst double v2 = 1000000.0;\n\tconst double w2 = 1000000.0;\n\tconst double x2 = 1000000.0;\n\tconst double y2 = 1000000.0;\n\tconst double z2 = 1000000.0;\n\tconst double aa2 = 1000000.0;\n\tconst double ab2 = 1000000.0;\n\tconst double ac2 = 1", "CodeBleu_score": 5.975903917555035}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\t// get third derivative\n\tUniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n\t// get knot times and control points\n\tstd::vector<double> knots = jerk_traj.getKnot();\n\tstd::vector<Eigen::VectorXd> ctrl_pts = jerk_traj.getControlPoint();\n\n\t// calculate jerk\n\tdouble jerk = 0;\n\tfor (int i = 0; i < ctrl_pts.size(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts[i].size(); j++) {\n\t\t\tjerk += ctrl_pts[i][j] * (knots[i + 3] - knots[i]);\n\t\t}\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 59.13155010116719}, {"code": "double UniformBspline::getJerk(){\n\t\t// Calculate the third derivative of the spline to obtain the jerk trajectory\n\tUniformBspline jerk_traj = this->getDerivative().getDerivative().getDerivative();\n\n\t// Retrieve the knot times and control points of the jerk trajectory\n\tstd::vector<double> knot_times = jerk_traj.getKnot();\n\tEigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n\t// Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n\tdouble jerk = 0;\n\tfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows(); j++) {\n\t\t\tjerk += pow(ctrl_pts(j, i), 2) * (knot_times[i + 1] - knot_times[i]);\n\t\t}\n\t}\n\n\t// Return the total jerk value\n\treturn jerk;\n}", "CodeBleu_score": 57.646881018786814}, {"code": "double UniformBspline::getJerk(){\n\t\t// get the third derivative of the spline\n\tUniformBspline jerk_traj = this->getDerivative().getDerivative().getDerivative();\n\n\t// get the knot times and control points of the jerk trajectory\n\tMatrixXd knots = jerk_traj.getKnot();\n\tMatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n\t// iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n\tdouble jerk = 0;\n\tfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows(); j++) {\n\t\t\tjerk += pow(ctrl_pts(j, i), 2) * (knots(i + 1, 0) - knots(i, 0));\n\t\t}\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 53.949072810652446}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 75.71884142349269}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 75.71884142349269}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 74.49740701774701}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(1));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 50.396697226605156}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(1, odom.child_frame_id.find_first_of('_') - 1));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t}\n\tcatch (const std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 48.02482846859662}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = std::stoi(odom.child_frame_id.substr(4));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector: Failed to extract drone ID from odometry message: %s\", e.what());\n\t}\n}", "CodeBleu_score": 49.364637186306126}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t//  ROS_INFO(\"DroneDetector::detect\");\n  // Compute the true pose of the drone in the camera frame\n  Eigen::Vector3d drone_pose_cam;\n  drone_pose_cam << true_pixel(0), true_pixel(1), 0;\n  Eigen::Vector3d drone_pose_world = cam_pose_ * drone_pose_cam;\n\n  // Check for the presence of the drone\n  bool found = false;\n  for (int i = 0; i < drones_.size(); i++) {\n    if (drones_[i].id == drone_id) {\n      found = true;\n      break;\n    }\n  }\n\n  // If the drone is found, compute the pose error and update the debug result\n  if (found) {\n    Eigen::Vector3d pose_error = drone_pose_world - drone_pose_cam;\n    debug_result_.pose_error_x = pose_error(0);\n    debug_result_.pose_error_y = pose_error(1);\n    debug_result_.pose_error_z = pose_error(2);\n    debug_result_.pose_error_status = true;\n\n    // Publish the pose error\n    drone_pose_err_pub_[drone_id].publish(pose_error);\n  } else {\n    // Update the debug result to indicate failure\n    debug_result_.pose_error_status = false;\n  }\n}", "CodeBleu_score": 43.29622423544687}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the true pose of the drone in the camera frame\n\tEigen::Vector3d drone_pose_cam;\n\tif (!getDronePoseCam(drone_id, true_pixel, drone_pose_cam)) {\n\t\treturn;\n\t}\n\n\t// Check for the presence of the drone\n\tif (!checkForDrone(drone_id, true_pixel)) {\n\t\treturn;\n\t}\n\n\t// Compute the pose error between the camera and world coordinates\n\tEigen::Vector3d pose_error;\n\tif (!getPoseError(drone_id, true_pixel, pose_error)) {\n\t\treturn;\n\t}\n\n\t// Update the debug result\n\tdebug_result_[drone_id].status = 1;\n\tdebug_result_[drone_id].pose_error = pose_error;\n\tdebug_result_[drone_id].pose_cam = drone_pose_cam;\n\n\t// Publish the pose error\n\tdrone_pose_err_pub_[drone_id].publish(pose_error);\n}", "CodeBleu_score": 35.99878303751801}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the true pose of the drone in the camera frame\n\tEigen::Vector3d true_pose = getTruePose(drone_id);\n\t// Check if the drone is present in the image\n\tif (isDronePresent(drone_id, true_pixel)) {\n\t\t// Compute the pose error between the camera and world coordinates\n\t\tEigen::Vector3d pose_error = true_pose - getPose(true_pixel);\n\t\t// Update the debug result\n\t\tdebug_result_.pose_error = pose_error;\n\t\tdebug_result_.status = true;\n\t\t// Publish the pose error\n\t\tdrone_pose_err_pub_[drone_id].publish(pose_error);\n\t} else {\n\t\t// Update the debug result to indicate failure\n\t\tdebug_result_.status = false;\n\t}\n}", "CodeBleu_score": 29.554062057867636}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 78.86875382773461}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tif (!Coord2Index(start_pt, start_idx) ||!Coord2Index(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\tif (!checkOccupancy(start_idx) ||!checkOccupancy(end_idx)) {\n\t\treturn false;\n\t}\n\tVector3d start_pt_adjusted = start_pt;\n\tVector3d end_pt_adjusted = end_pt;\n\tVector3i start_idx_adjusted = start_idx;\n\tVector3i end_idx_adjusted = end_idx;\n\twhile (checkOccupancy(start_idx_adjusted) && checkOccupancy(end_idx_adjusted)) {\n\t\tstart_pt_adjusted -= (start_pt_adjusted - end_pt_adjusted).normalized() * 0.01;\n\t\tend_pt_adjusted -= (end_pt_adjusted - start_pt_adjusted).normalized() * 0.01;\n\t\tCoord2Index(start_pt_adjusted, start_idx_adjusted);\n\t\tCoord2Index(end_pt_adjusted, end_idx_adjusted);\n\t}\n\tif (checkOccupancy(start_idx_adjusted)) {\n\t\tstart_idx = start_idx_adjusted;\n\t\tstart_pt = start_pt_adjusted;\n\t}\n\tif (checkOccupancy(end_idx_adjusted)) {\n\t\tend_idx = end_idx_adjusted;\n\t\tend_pt = end_pt_adjusted;\n\t}\n\treturn true;\n}", "CodeBleu_score": 49.60666684712617}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert 3D coordinates of start and end points to grid indices\n\tif (!ConvertToIndex(start_pt, start_idx) ||!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Check if start or end point is inside an obstacle\n\tif (checkOccupancy(start_idx) || checkOccupancy(end_idx)) {\n\t\t// Adjust the point by moving it away from the other point until it is no longer in an obstacle\n\t\tVector3d start_pt_adj = start_pt;\n\t\tVector3d end_pt_adj = end_pt;\n\t\tVector3i start_idx_adj = start_idx;\n\t\tVector3i end_idx_adj = end_idx;\n\t\tVector3d dir_to_start = (start_pt - end_pt).normalized();\n\t\tVector3d dir_to_end = (end_pt - start_pt).normalized();\n\t\twhile (checkOccupancy(start_idx_adj) || checkOccupancy(end_idx_adj)) {\n\t\t\tif (checkOccupancy(start_idx_adj)) {\n\t\t\t\tstart_pt_adj += dir_to_start * 0.01;\n\t\t\t\tConvertToIndex(start_pt_adj, start_idx_adj);\n\t\t\t}\n\t\t\tif (checkOccupancy(end_idx_adj)) {\n\t\t\t\tend_pt_adj += dir_to_end * 0.01;\n\t\t\t\tConvertToIndex(end_pt_adj, end_idx_adj);\n\t\t\t}\n\t\t}\n\n\t\t// Update start and end points\n\t\tstart_pt = start_pt_adj;\n\t\tend_pt = end_pt_adj;\n\t\tstart_idx = start_idx_adj;\n\t\tend_idx = end_idx_adj;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 51.25399928486183}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\tif (checkOccupancy(start_idx)) {\n\t\tVector3d direction = (end_pt - start_pt).normalized();\n\t\tVector3d adjusted_start_pt = start_pt;\n\t\tVector3i adjusted_start_idx = start_idx;\n\t\twhile (checkOccupancy(adjusted_start_idx)) {\n\t\t\tadjusted_start_pt += direction * 0.01;\n\t\t\tif (!ConvertToIndex(adjusted_start_pt, adjusted_start_idx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tstart_pt = adjusted_start_pt;\n\t\tstart_idx = adjusted_start_idx;\n\t}\n\tif (checkOccupancy(end_idx)) {\n\t\tVector3d direction = (start_pt - end_pt).normalized();\n\t\tVector3d adjusted_end_pt = end_pt;\n\t\tVector3i adjusted_end_idx = end_idx;\n\t\twhile (checkOccupancy(adjusted_end_idx)) {\n\t\t\tadjusted_end_pt += direction * 0.01;\n\t\t\tif (!ConvertToIndex(adjusted_end_pt, adjusted_end_idx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tend_pt = adjusted_end_pt;\n\t\tend_idx = adjusted_end_idx;\n\t}\n\treturn true;\n}", "CodeBleu_score": 51.658851557508015}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// Get the min and max indices in the grid map\n\tEigen::Vector3i min_id = worldToGrid(min_pos);\n\tEigen::Vector3i max_id = worldToGrid(max_pos);\n\t// Iterate over the grid coordinates\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\t// Set the corresponding element in the occupancy buffer to zero\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.05404604444512}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t//ROS_INFO(\"resetBuffer\");\n\t//ROS_INFO(\"min_pos: %f %f %f\", min_pos.x(), min_pos.y(), min_pos.z());\n\t//ROS_INFO(\"max_pos: %f %f %f\", max_pos.x(), max_pos.y(), max_pos.z());\n\t//ROS_INFO(\"resolution: %f\", resolution_);\n\t//ROS_INFO(\"min_id: %d %d %d\", min_id.x(), min_id.y(), min_id.z());\n\t//ROS_INFO(\"max_id: %d %d %d\", max_id.x(), max_id.y(), max_id.z());\n\t//ROS_INFO(\"size: %d %d %d\", occupancy_buffer_inflate_.size(), occupancy_buffer_inflate_.size() / size_x_, occupancy_buffer_inflate_.size() / (size_x_ * size_y_));\n\t//ROS_INFO(\"size_x_: %d\", size_x_);\n\t//ROS_INFO(\"size_y_: %d\", size_y_);\n\t//ROS_INFO(\"size_z_: %d\", size_z_);\n\t//ROS_INFO(\"min_id.x(): %d\", min_id.x());\n\t//ROS_INFO(\"max_id.x(): %d\", max_id.x());\n\t//ROS_INFO(\"min_id.y(): %d\", min_id.y());\n\t//ROS_INFO(\"max_id.y(): %d\", max_id.y());\n\t//ROS_INFO(\"min_id.z(): %d\", min_id.z());\n\t//ROS_INFO(\"max_id.z(): %d\", max_id.z());\n\t//ROS_INFO(\"min_id.x() * size_y_ + min_id.y(): %d\", min_id.x() * size_y_ + min_id.y());\n\t//ROS_INFO(\"max_id.x() * size_y_ + max_id.y(): %d\", max_id.x() * size_y_ + max_id.y());\n\t//ROS_INFO(\"min", "CodeBleu_score": 4.296144653489969}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = worldToGrid3i(min_pos);\n\tEigen::Vector3i max_id = worldToGrid3i(max_pos);\n\tresetBuffer(min_id, max_id);\n}", "CodeBleu_score": 21.31778480734926}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble min_scale = 1.0;\n\tdouble max_scale = 1.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff(i)!= 0) {\n\t\t\tdouble min_scale_i = (min_bound(i) - camera_pt(i)) / diff(i);\n\t\t\tdouble max_scale_i = (max_bound(i) - camera_pt(i)) / diff(i);\n\t\t\tmin_scale = std::min(min_scale, min_scale_i);\n\t\t\tmax_scale = std::min(max_scale, max_scale_i);\n\t\t}\n\t}\n\tEigen::Vector3d new_pt = camera_pt + diff * max_scale;\n\treturn new_pt;\n}", "CodeBleu_score": 42.394331097099744}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_diff = Eigen::Vector3d::Zero();\n\tEigen::Vector3d max_diff = Eigen::Vector3d::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tmin_diff(i) = -diff(i);\n\t\tmax_diff(i) = diff(i);\n\t}\n\tEigen::Vector3d min_scale = min_diff.cwiseQuotient(diff);\n\tEigen::Vector3d max_scale = max_diff.cwiseQuotient(diff);\n\tEigen::Vector3d scale = Eigen::Vector3d::Ones();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (min_scale(i) > 0) {\n\t\t\tscale(i) = min_scale(i);\n\t\t}\n\t\telse if (max_scale(i) > 0) {\n\t\t\tscale(i) = max_scale(i);\n\t\t}\n\t}\n\tdouble min_scale_value = scale.minCoeff();\n\tEigen::Vector3d new_pt = camera_pt + diff * min_scale_value;\n\treturn new_pt;\n}", "CodeBleu_score": 43.960629645758495}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d max_coeff = (pt - max_pt) / diff;\n\tEigen::Vector3d min_coeff = (pt - min_pt) / diff;\n\tEigen::Vector3d coeff = max_coeff;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (min_coeff[i] > 0 && min_coeff[i] < coeff[i]) {\n\t\t\tcoeff[i] = min_coeff[i];\n\t\t}\n\t}\n\treturn camera_pt + coeff.cwiseProduct(diff);\n}", "CodeBleu_score": 42.52862573170053}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// update last occupancy update time\n\tmd_.last_occ_update_time_ = ros::Time::now();\n\n\t// if an update is needed, project the depth image into points and process them with raycasting\n\tif (md_.update_occ_grid_ &&!md_.depth_data_timeout_) {\n\t\t// project depth image into points\n\t\tstd::vector<cv::Point3f> points;\n\t\tprojectDepthImage(md_.depth_image_, md_.depth_camera_info_, points);\n\n\t\t// process the points with raycasting\n\t\traycastProcess(points);\n\t}\n\n\t// if the local map has been updated, clear and inflate the local map\n\tif (md_.update_local_map_) {\n\t\tclearAndInflateLocalMap();\n\t}\n\n\t// handle timeout errors for odometry or depth data\n\tif (md_.odom_timeout_) {\n\t\tROS_ERROR(\"No odometry data received for %f seconds!\",\n\t\t\t\t(ros::Time::now() - md_.last_odom_time_).toSec());\n\t}\n\tif (md_.depth_data_timeout_) {\n\t\tROS_ERROR(\"No depth data received for %f seconds!\",\n\t\t\t\t(ros::Time::now() - md_.last_depth_data_time_).toSec());\n\t}\n}", "CodeBleu_score": 55.000502548191136}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tmd_.last_occ_update_time_ = ros::Time::now();\n\tif (md_.occ_update_needed_) {\n\t\tmd_.occ_update_needed_ = false;\n\t\tif (md_.depth_image_data_ready_) {\n\t\t\tprojectDepthImage(md_.depth_image_, md_.depth_image_info_);\n\t\t\traycastProcess();\n\t\t}\n\t\tif (md_.local_map_updated_) {\n\t\t\tclearAndInflateLocalMap();\n\t\t\tmd_.local_map_updated_ = false;\n\t\t}\n\t}\n\tif (md_.timeout_occ_update_) {\n\t\tROS_ERROR(\"Occupancy update timed out\");\n\t\tmd_.timeout_occ_update_ = false;\n\t}\n}", "CodeBleu_score": 45.03260168002641}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tmd_.last_occ_update_time_ = ros::Time::now();\n\tif (md_.occ_update_needed_) {\n\t\t// Project depth image into points\n\t\tsensor_msgs::PointCloud2 cloud;\n\t\tprojectDepthImage(md_.depth_image_, md_.depth_camera_info_, cloud);\n\t\t// Process points with raycasting\n\t\traycastProcess(cloud);\n\t\t// If local map has been updated, clear and inflate local map\n\t\tif (md_.local_map_updated_) {\n\t\t\tclearAndInflateLocalMap();\n\t\t}\n\t\t// Handle timeout errors for odometry or depth data\n\t\tif (md_.odom_timeout_error_) {\n\t\t\tROS_ERROR(\"Odometry data timeout error\");\n\t\t\tmd_.odom_timeout_error_ = false;\n\t\t}\n\t\tif (md_.depth_timeout_error_) {\n\t\t\tROS_ERROR(\"Depth data timeout error\");\n\t\t\tmd_.depth_timeout_error_ = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 51.38088562590807}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\t// Initialize variables\n\tfloat fmeasure_sum = 0.0;\n\tfloat fmeasure_avg = 0.0;\n\n\t// Iterate through the provided image filenames\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\t// Load the image, ground truth ellipses, and detected ellipses\n\t\tMat image = imread(image_fns[i]);\n\t\tvector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i], gt_angle_radians);\n\n\t\t// Evaluate the detection performance for the current image\n\t\tfloat fmeasure = _ellipse_evaluate_one(image, gt_ellipses, dt_ellipses);\n\n\t\t// Accumulate the F-measure\n\t\tfmeasure_sum += fmeasure;\n\t}\n\n\t// Calculate the average F-measure\n\tfmeasure_avg = fmeasure_sum / image_fns.size();\n\n\t// Return the average F-measure\n\treturn fmeasure_avg;\n}", "CodeBleu_score": 60.87078000762231}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat f_measure_sum = 0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tfloat f_measure = _ellipse_evaluate_one(image_fns[i], gt_fns[i], dt_fns[i], gt_angle_radians);\n\t\tf_measure_sum += f_measure;\n\t}\n\treturn f_measure_sum / image_fns.size();\n}", "CodeBleu_score": 49.13067777133272}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat avg_f_measure = 0.0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tavg_f_measure += _ellipse_evaluate_one(image_fns[i], gt_fns[i], dt_fns[i], gt_angle_radians);\n\t}\n\tavg_f_measure /= image_fns.size();\n\treturn avg_f_measure;\n}", "CodeBleu_score": 49.623675520849}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle1, angle2, angle_diff;\n\tif (foci == NULL) {\n\t\treturn 0.0;\n\t}\n\tangle1 = atan2(y - foci[1], x - foci[0]);\n\tangle2 = atan2(y - foci[3], x - foci[2]);\n\tangle_diff = angle_diff_signed(angle1, angle2);\n\tif (angle_diff > M_PI) {\n\t\tangle_diff -= 2 * M_PI;\n\t} else if (angle_diff < -M_PI) {\n\t\tangle_diff += 2 * M_PI;\n\t}\n\treturn angle_diff;\n}", "CodeBleu_score": 52.03760413166051}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tif (foci == NULL) {\n\t\treturn 0;\n\t}\n\n\tfloat angle_a = atan2(y, x - foci[0]);\n\tfloat angle_b = atan2(y, x - foci[1]);\n\tfloat angle_diff = angle_a - angle_b;\n\n\treturn _angle_diff_signed(angle_diff);\n}", "CodeBleu_score": 29.5054221000775}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tif (foci) {\n\t\tfloat angle1 = _angle_diff_signed(atan2(y, x), atan2(foci[1], foci[0]));\n\t\tfloat angle2 = _angle_diff_signed(atan2(y, x), atan2(foci[3], foci[2]));\n\t\treturn _angle_diff_signed(angle1, angle2);\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 28.809318924542826}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint i, j;\n\tdouble x1, y1, x2, y2, x3, y3, x4, y4;\n\tdouble x_min, x_max, y_min, y_max;\n\tdouble a1, a2, b1, b2, c1, c2;\n\tdouble above, below;\n\tdouble x_int, y_int;\n\n\t// Find the minimum and maximum x and y coordinates of the points in the section\n\tx_min = vp1[start].x;\n\tx_max = vp1[start].x;\n\ty_min = vp1[start].y;\n\ty_max = vp1[start].y;\n\tfor (i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < x_min)\n\t\t\tx_min = vp1[i].x;\n\t\tif (vp1[i].x > x_max)\n\t\t\tx_max = vp1[i].x;\n\t\tif (vp1[i].y < y_min)\n\t\t\ty_min = vp1[i].y;\n\t\tif (vp1[i].y > y_max)\n\t\t\ty_max = vp1[i].y;\n\t}\n\n\t// Compute the integral above and below the polygon section\n\tabove = 0.0;\n\tbelow = 0.0;\n\tfor (i = start; i < end - 1; i++) {\n\t\tx1 = vp1[i].x;\n\t\ty1 = vp1[i].y;\n\t\tx2 = vp1[i + 1].x;\n\t\ty2 = vp1[i + 1].y;\n\t\ta1 = y1;\n\t\tb1 = -x1;\n\t\tc1 = x1 * y1;\n\t\ta2 = y2;\n\t\tb2 = -x2;\n\t\tc2 = x2 * y2;\n\t\tif (x1 == x2) {\n\t\t\tif (y1 < y2) {\n\t\t\t\tif (x1 < x_min)\n\t\t\t\t\tx_min = x1;\n\t\t\t\tif (x1 > x_max)\n\t\t\t\t\tx_max = x", "CodeBleu_score": 34.93185534845145}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint i;\n\tdouble x, y;\n\tdouble max_x, min_x, max_y, min_y;\n\tdouble integral_above, integral_below;\n\n\tmax_x = vp1[start].x;\n\tmin_x = vp1[start].x;\n\tmax_y = vp1[start].y;\n\tmin_y = vp1[start].y;\n\n\tfor (i = start + 1; i <= end; i++) {\n\t\tx = vp1[i].x;\n\t\ty = vp1[i].y;\n\t\tif (x > max_x)\n\t\t\tmax_x = x;\n\t\tif (x < min_x)\n\t\t\tmin_x = x;\n\t\tif (y > max_y)\n\t\t\tmax_y = y;\n\t\tif (y < min_y)\n\t\t\tmin_y = y;\n\t}\n\n\tintegral_above = 0;\n\tintegral_below = 0;\n\tfor (i = start; i < end; i++) {\n\t\tx = (vp1[i].x + vp1[i + 1].x) / 2;\n\t\ty = (vp1[i].y + vp1[i + 1].y) / 2;\n\t\tif (y > min_y && y < max_y && x > min_x && x < max_x) {\n\t\t\tif (y > vp1[i].y && y < vp1[i + 1].y)\n\t\t\t\tintegral_above += (x - vp1[i].x) * (y - vp1[i].y);\n\t\t\telse if (y < vp1[i].y && y > vp1[i + 1].y)\n\t\t\t\tintegral_below += (x - vp1[i].x) * (y - vp1[i].y);\n\t\t}\n\t}\n\n\tif (integral_above < integral_below)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 39.120062251311246}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t} else if (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t} else if (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\n\tfor (int i = start; i <= end; i++) {\n\t\tdouble x1 = vp1[i].x;\n\t\tdouble y1 = vp1[i].y;\n\t\tdouble x2 = vp1[(i + 1) % vp1.size()].x;\n\t\tdouble y2 = vp1[(i + 1) % vp1.size()].y;\n\n\t\tdouble integral_above_i = ((max_x - x1) * (y1 - min_y) + (x2 - max_x) * (max_y - y2)) / 2;\n\t\tdouble integral_below_i = ((x2 - min_x) * (y2 - min_y) + (x1 - x2) * (max_y - y1)) / 2;\n\n\t\tintegral_above += integral_above_i;\n\t\tintegral_below += integral_below_i;\n\t}\n\n\treturn integral_above < integral_below;\n}", "CodeBleu_score": 41.971530351674495}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].target_num == 0) {\n\t\t\tellipse_det.ellipse_det_info = msg->detection_infos[i];\n\t\t\tellipse_det.is_detected = true;\n\t\t\tellipse_det.num_lost = 0;\n\t\t\tellipse_det.num_regain++;\n\t\t\tif (ellipse_det.num_regain > VISION_THRES) {\n\t\t\t\tellipse_det.is_detected = true;\n\t\t\t\tellipse_det.num_regain = 0;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tellipse_det.is_detected = false;\n\tellipse_det.num_regain = 0;\n\tellipse_det.num_lost++;\n\tif (ellipse_det.num_lost > VISION_THRES) {\n\t\tellipse_det.is_detected = false;\n\t\tellipse_det.num_lost = 0;\n\t}\n}", "CodeBleu_score": 34.83393918104679}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tif (msg->detection_infos.size() == 0) {\n\t\tnum_lost++;\n\t\tnum_regain = 0;\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t\tnum_lost = 0;\n\t\t\tnum_regain = 0;\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\t\tif (msg->detection_infos[i].id == \"T\") {\n\t\t\t\tnum_lost = 0;\n\t\t\t\tnum_regain++;\n\t\t\t\tif (num_regain > VISION_THRES) {\n\t\t\t\t\tis_detected = true;\n\t\t\t\t\tnum_lost = 0;\n\t\t\t\t\tnum_regain = 0;\n\t\t\t\t}\n\t\t\t\tellipse_det.id = msg->detection_infos[i].id;\n\t\t\t\tellipse_det.center.x = msg->detection_infos[i].bbox.center.x;\n\t\t\t\tellipse_det.center.y = msg->detection_infos[i].bbox.center.y;\n\t\t\t\tellipse_det.center.z = msg->detection_infos[i].bbox.center.z;\n\t\t\t\tellipse_det.size.x = msg->detection_infos[i].bbox.size_x;\n\t\t\t\tellipse_det.size.y = msg->detection_infos[i].bbox.size_y;\n\t\t\t\tellipse_det.size.z = msg->detection_infos[i].bbox.size_z;\n\t\t\t\tellipse_det.angle.x = msg->detection_infos[i].bbox.angle.x;\n\t\t\t\tellipse_det.angle.y = msg->detection_infos[i].bbox.angle.y;\n\t\t\t\tellipse_det.angle.z = msg->detection_infos[i].bbox.angle.z;\n\t\t\t\tellipse_det.distance = msg->detection_infos[i].distance;\n\t\t\t\tellipse_det.relative_distance = msg->detection_infos[i].relative_distance;\n\t\t\t\tellipse_det.absolute_distance = msg->detection_infos[i].absolute_distance;\n\t\t\t\tellipse_det.velocity.x = msg->detection_infos[i].velocity.x;\n\t\t\t\tellipse_det.velocity", "CodeBleu_score": 46.262924034405195}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tif (msg->detection_infos.size() == 0) {\n\t\tnum_lost++;\n\t\tnum_regain = 0;\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t}\n\telse {\n\t\tnum_lost = 0;\n\t\tnum_regain++;\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].id == \"T\") {\n\t\t\tellipse_det.x = msg->detection_infos[i].bbox.center.x;\n\t\t\tellipse_det.y = msg->detection_infos[i].bbox.center.y;\n\t\t\tellipse_det.z = msg->detection_infos[i].bbox.center.z;\n\t\t\tellipse_det.roll = msg->detection_infos[i].bbox.roll;\n\t\t\tellipse_det.pitch = msg->detection_infos[i].bbox.pitch;\n\t\t\tellipse_det.yaw = msg->detection_infos[i].bbox.yaw;\n\t\t\tellipse_det.length = msg->detection_infos[i].bbox.size_x;\n\t\t\tellipse_det.width = msg->detection_infos[i].bbox.size_y;\n\t\t\tellipse_det.height = msg->detection_infos[i].bbox.size_z;\n\t\t\tellipse_det.distance = msg->detection_infos[i].distance;\n\t\t\tellipse_det.relative_distance = msg->detection_infos[i].relative_distance;\n\t\t\tellipse_det.relative_yaw = msg->detection_infos[i].relative_yaw;\n\t\t\tellipse_det.relative_pitch = msg->detection_infos[i].relative_pitch;\n\t\t\tellipse_det.relative_roll = msg->detection_infos[i].relative_roll;\n\t\t\tellipse_det.absolute_x = msg->detection_infos[i].absolute_position.x;\n\t\t\tellipse_det.absolute_y = msg->detection_infos[i].absolute_position.y;\n\t\t\tellipse_det.absolute_z = msg->detection_", "CodeBleu_score": 45.018561099152365}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tif (Occupy_map_ptr->check_safety(cur_pos, safe_distance))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "CodeBleu_score": 46.4277840743613}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\tpath_nodes_.push_back(current_node);\n\twhile (current_node->parent_!= nullptr) {\n\t\tcurrent_node = current_node->parent_;\n\t\tpath_nodes_.push_back(current_node);\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 63.07808072046146}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr node = end_node;\n\twhile (node->getParent()!= nullptr) {\n\t\tpath_nodes_.push_back(node);\n\t\tnode = node->getParent();\n\t}\n\tpath_nodes_.push_back(node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 55.95141296657119}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr node = end_node;\n\twhile (node!= nullptr) {\n\t\tpath_nodes_.push_back(node);\n\t\tnode = node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 49.75303871233074}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"nei_odom_cb %d\", id);\n\tstate_nei[id] = Vector3d(odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n\tif(sim_mode) {\n\t\tif((start_pos-state_nei[id]).norm() > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t} else {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t} else {\n\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 50.83379723462925}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif (mode == \"simulation\") {\n\t\tif ((start_pos-odom->pose.pose.position).norm() > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\tstate_nei[id] = odom->pose.pose.position;\n\tstate_nei[id].z = 0;\n}", "CodeBleu_score": 38.58393023054417}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\n\tif (sim_mode) {\n\t\tif ((start_pos-state_nei[id]).norm > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t} else {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t} else {\n\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 52.265645190257935}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count == 5) {\n\t\tupdate_count = 0;\n\t\tAstar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n\t}\n}", "CodeBleu_score": 57.97973197336893}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tif (++update_counter % 5 == 0) {\n\t\t\tAstar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n\t\t\tupdate_counter = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.673762546080404}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) return;\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count == 5) {\n\t\tupdate_count = 0;\n\t\tAstar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n\t}\n}", "CodeBleu_score": 47.867850189518144}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(get_gpcl == false) {\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tget_gpcl = true;\n\t\tinflate_point_cloud(gpcl, 0.1);\n\t}\n}", "CodeBleu_score": 46.982051996778985}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tinflate_point_cloud(gpcl, inflated_gpcl);\n\t\tget_gpcl = true;\n\t}\n}", "CodeBleu_score": 47.10671836195214}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, global_pcl);\n\t\tinflate_point_cloud(global_pcl, global_pcl, 0.05);\n\t}\n}", "CodeBleu_score": 45.93931242670459}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t//Project laser data into a PointCloud2 format\n\tprojector_.projectLaser(*local_point, cloud_);\n\n\t//Convert the PointCloud2 format to a pcl::PointCloud\n\tpcl::fromROSMsg(cloud_, *cloud_pcl_);\n\n\tif (not simulation_mode_) {\n\t\t//Merge the local map with the provided odometry data\n\t\tlocal_map_merge_odom(odom);\n\t}\n\n\t//Update the occupancy map\n\tmap_update_laser();\n}", "CodeBleu_score": 51.620699636946}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert the laser scan data into a PointCloud2 format\n\tsensor_msgs::PointCloud2 local_point_cloud;\n\tprojector_.projectLaser(*local_point, local_point_cloud);\n\n\t// Convert the PointCloud2 format to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> local_cloud;\n\tpcl::fromROSMsg(local_point_cloud, local_cloud);\n\n\t// If not in simulation mode, merge the local map with the provided odometry data\n\tif (!simulation_mode_) {\n\t\tlocal_map_merge_odom(local_cloud, odom);\n\t}\n\n\t// Update the occupancy map using the local cloud\n\tmap_update(local_cloud);\n}", "CodeBleu_score": 48.76442384808656}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\tif (local_point->ranges.empty()) {\n\t\tROS_WARN(\"No laser scan data available!\");\n\t\treturn;\n\t}\n\n\t// project laser scan into a point cloud\n\tprojector_.projectLaser(*local_point, cloud_);\n\n\t// convert point cloud to pcl::PointCloud\n\tpcl::fromROSMsg(cloud_, cloud_pcl_);\n\n\t// merge local map with odometry data\n\tif (!simulation_mode_) {\n\t\tlocal_map_merge_odom(odom);\n\t}\n\n\t// publish the point cloud\n\tcloud_pub_.publish(cloud_);\n}", "CodeBleu_score": 51.56501438874048}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::toROSMsg(*global_pcl, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\tpcl::toROSMsg(*global_pcl_inflate, global_pcl_inflate_msg);\n\tglobal_pcl_inflate_msg.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(global_pcl_inflate_msg);\n}", "CodeBleu_score": 49.82452022175446}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::toROSMsg\nglobal_pcl_pub.publish\npcl::toROSMsg\ninflate_pcl_pub.publish\n}", "CodeBleu_score": 12.032600490231541}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::toROSMsg\n\tglobal_pcl_pub.publish\n\tpcl::toROSMsg\n\tinflate_pcl_pub.publish\n}", "CodeBleu_score": 12.060692632569097}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//    ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n    if (odom_ready) {\n        sensor_ready = true;\n        Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, odom_msg);\n    }\n}", "CodeBleu_score": 60.99894975236636}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\t//ROS_INFO(\"msg->height = %d\", msg->height);\n\t//ROS_INFO(\"msg->width = %d\", msg->width);\n\t//ROS_INFO(\"msg->is_dense = %d\", msg->is_dense);\n\t//ROS_INFO(\"msg->point_step = %d\", msg->point_step);\n\t//ROS_INFO(\"msg->row_step = %d\", msg->row_step);\n\t//ROS_INFO(\"msg->data.size = %d\", msg->data.size());\n\t//ROS_INFO(\"msg->fields.size = %d\", msg->fields.size());\n\t//ROS_INFO(\"msg->header.seq = %d\", msg->header.seq);\n\t//ROS_INFO(\"msg->header.stamp.sec = %d\", msg->header.stamp.sec);\n\t//ROS_INFO(\"msg->header.stamp.nsec = %d\", msg->header.stamp.nsec);\n\t//ROS_INFO(\"msg->header.frame_id = %s\", msg->header.frame_id.c_str());\n\t//ROS_INFO(\"msg->is_bigendian = %d\", msg->is_bigendian);\n\t//ROS_INFO(\"msg->width = %d\", msg->width);\n\t//ROS_INFO(\"msg->height = %d\", msg->height);\n\t//ROS_INFO(\"msg->data.size = %d\", msg->data.size());\n\t//ROS_INFO(\"msg->fields.size = %d\", msg->fields.size());\n\t//ROS_INFO(\"msg->point_step = %d\", msg->point_step);\n\t//ROS_INFO(\"msg->row_step = %d\", msg->row_step);\n\t//ROS_INFO(\"msg->is_dense = %d\", msg->is_dense);\n\n\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n\tif (odom_ready) {\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: odom_ready\");\n\t\tsensor_ready = true;\n\t\t//ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: sensor_ready = %d", "CodeBleu_score": 13.677703490331538}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\tROS_WARN(\"GlobalPlanner::Lpointcloud_cb: Odometry not ready. Waiting...\");\n\t\treturn;\n\t}\n\n\tif (!sensor_ready) {\n\t\tsensor_ready = true;\n\t\tROS_INFO(\"GlobalPlanner::Lpointcloud_cb: Sensor ready.\");\n\t}\n\n\t// Get the current time\n\tros::Time current_time = ros::Time::now();\n\n\t// Convert the incoming point cloud to a PCL point cloud\n\tpcl::PointCloud<pcl::PointXYZ> pcl_cloud;\n\tpcl::fromROSMsg(*msg, pcl_cloud);\n\n\t// Update the occupancy map using the current point cloud\n\tAstar_ptr->Occupy_map_ptr->map_update_lpcl(pcl_cloud, current_time);\n}", "CodeBleu_score": 59.03062413135807}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get the current time\n\tconst ros::Time now = ros::Time::now();\n\tconst ros::Duration period = now - last_control_time_;\n\tlast_control_time_ = now;\n\n\t// Get the current pose command\n\tconst Eigen::VectorXd pose_command = body_controller_.getPoseCommand();\n\n\t// Get the current joint positions\n\tconst Eigen::VectorXd joint_positions = kinematics_.getJointPositions();\n\n\t// Calculate the target foot positions based on the desired pose\n\tconst Eigen::VectorXd target_foot_positions = kinematics_.forward(pose_command);\n\n\t// Calculate the velocity commands for the legs\n\tconst Eigen::VectorXd velocity_commands = leg_controller_.computeVelocityCommands(target_foot_positions, joint_positions, period);\n\n\t// Perform inverse kinematics to determine target joint positions\n\tconst Eigen::VectorXd target_joint_positions = kinematics_.inverse(target_foot_positions);\n\n\t// Publish foot contact information\n\tpublishFootContacts_(target_foot_positions);\n\n\t// Publish joint positions\n\tpublishJoints_(target_joint_positions);\n}", "CodeBleu_score": 45.28656309733417}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t//    ROS_INFO(\"controlLoop_\");\n    // Get the time step for this iteration\n    double dt = event.current_real.toSec() - event.last_real.toSec();\n\n    // Get the current pose from the body controller\n    Eigen::Vector3d current_body_position;\n    Eigen::Quaterniond current_body_orientation;\n    body_controller_.getPose(current_body_position, current_body_orientation);\n\n    // Get the desired pose from the body controller\n    Eigen::Vector3d desired_body_position;\n    Eigen::Quaterniond desired_body_orientation;\n    body_controller_.getDesiredPose(desired_body_position, desired_body_orientation);\n\n    // Get the desired foot positions from the body controller\n    std::vector<Eigen::Vector3d> desired_foot_positions;\n    body_controller_.getDesiredFootPositions(desired_foot_positions);\n\n    // Get the current foot positions from the leg controller\n    std::vector<Eigen::Vector3d> current_foot_positions;\n    leg_controller_.getFootPositions(current_foot_positions);\n\n    // Get the desired foot positions from the leg controller\n    std::vector<Eigen::Vector3d> desired_foot_positions_from_leg_controller;\n    leg_controller_.getDesiredFootPositions(desired_foot_positions_from_leg_controller);\n\n    // Get the current foot contact states from the leg controller\n    std::vector<bool> current_foot_contact_states;\n    leg_controller_.getFootContactStates(current_foot_contact_states);\n\n    // Get the desired foot contact states from the leg controller\n    std::vector<bool> desired_foot_contact_states;\n    leg_controller_.getDesiredFootContactStates(desired_foot_contact_states);\n\n    // Calculate the desired foot positions based on the desired pose\n    std::vector<Eigen::Vector3d> desired_foot_positions_from_pose;\n    for (size_t i = 0; i < foot_names_.size(); i++) {\n        desired_foot_positions_from_pose.push_back(desired_body_position + desired_body_orientation * foot_positions_[i]);\n    }\n\n    // Calculate the desired foot positions based on the desired pose\n    std::vector<Eigen::Vector3d> desired_foot_positions_from_pose_and_leg_controller;", "CodeBleu_score": 37.37481662678421}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\t// Get the current time for the control loop\n\tconst auto now = ros::Time::now();\n\n\t// Calculate the desired foot positions based on the desired pose\n\tconst auto foot_positions = body_controller_.calculateFootPositions(now);\n\n\t// Calculate the desired joint positions for each leg\n\tauto leg_positions = leg_controller_.calculateLegPositions(now, foot_positions);\n\n\t// Publish the foot contact information\n\tpublishFootContacts_(now);\n\n\t// Publish the joint positions\n\tpublishJoints_(now, leg_positions);\n}", "CodeBleu_score": 42.33183683336327}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (publish_foot_contacts_ &&!gazebo_sim_) {\n\t\t// Create a ContactsStamped message\n\t\tsensor_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.header.frame_id = base_link_name_;\n\t\tcontacts_msg.contacts.resize(4);\n\t\t// Populate the message\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts[i].name = base_.legs[i]->name + \"_foot\";\n\t\t\tcontacts_msg.contacts[i].states.resize(1);\n\t\t\tcontacts_msg.contacts[i].states[0].state = foot_contacts[i]? 1 : 0;\n\t\t\tcontacts_msg.contacts[i].states[0].name = \"foot_contact\";\n\t\t}\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 60.76494059999946}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (publish_foot_contacts_ &&!gazebo_simulation_) {\n\t\t// Create a ContactsStamped message\n\t\tsensor_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\n\t\t// Populate the message with the current gait phase of each leg\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts.resize(4);\n\t\t\tcontacts_msg.contacts[i].name = quadruped_base_.legs[i]->name;\n\t\t\tcontacts_msg.contacts[i].states.resize(1);\n\t\t\tcontacts_msg.contacts[i].states[0].state = foot_contacts[i];\n\t\t}\n\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 63.45736125403364}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\t// Create a ContactsStamped message\n\t\tsensor_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.header.frame_id = \"base_link\";\n\t\tcontacts_msg.contacts.resize(quadruped_base_.legs.size());\n\t\tfor (int i = 0; i < quadruped_base_.legs.size(); i++) {\n\t\t\tcontacts_msg.contacts[i].header.stamp = contacts_msg.header.stamp;\n\t\t\tcontacts_msg.contacts[i].header.frame_id = quadruped_base_.legs[i]->name;\n\t\t\tcontacts_msg.contacts[i].name = quadruped_base_.legs[i]->name;\n\t\t\tcontacts_msg.contacts[i].states.resize(1);\n\t\t\tcontacts_msg.contacts[i].states[0].state = foot_contacts[i];\n\t\t\tcontacts_msg.contacts[i].states[0].name = \"contact\";\n\t\t\tcontacts_msg.contacts[i].states[0].values.resize(1);\n\t\t\tcontacts_msg.contacts[i].states[0].values[0] = quadruped_base_.legs[i]->gait_phase;\n\t\t}\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 42.607995602024026}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\t// Create a minimal joints message with the first 12 joint positions\n\t// and publish it\n\tdef joints_msg = new JointState()\n\tjoints_msg.name = joints.name[0..11]\n\tjoints_msg.position = joints.position[0..11]\n\tjoints_msg.velocity = joints.velocity[0..11]\n\tjoints_msg.effort = joints.effort[0..11]\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tjoints_pub.publish(joints_msg)\n\n\t// Construct a joint trajectory message with the same positions and\n\t// a specified duration\n\tdef traj = new JointTrajectory()\n\ttraj.joint_names = joints.name[0..11]\n\ttraj.points = [new JointTrajectoryPoint()]\n\ttraj.points[0].positions = joints.position[0..11]\n\ttraj.points[0].velocities = joints.velocity[0..11]\n\ttraj.points[0].accelerations = joints.effort[0..11]\n\ttraj.points[0].time_from_start = rospy.Duration.from_sec(0.5)\n\ttraj_pub.publish(traj)\n}", "CodeBleu_score": 34.446485827795456}, {"code": "def joints_cmd_callback(self, joints){\n\t\tdef msg = new JointState()\n\tmsg.name = joints.name\n\tmsg.position = joints.position\n\tmsg.velocity = joints.velocity\n\tmsg.effort = joints.effort\n\tmsg.header.stamp = self.get_clock().now()\n\tself.joints_pub.publish(msg)\n\tdef traj = new JointTrajectory()\n\ttraj.joint_names = joints.name\n\tdef point = new JointTrajectoryPoint()\n\tpoint.positions = joints.position\n\tpoint.velocities = joints.velocity\n\tpoint.accelerations = joints.effort\n\tpoint.time_from_start = self.get_clock().now()\n\ttraj.points.add(point)\n\tself.traj_pub.publish(traj)\n}", "CodeBleu_score": 48.874814044209536}, {"code": "def joints_cmd_callback(self, joints){\n\t\tdef joints_msg = new JointState()\n\tjoints_msg.name = joints.name[0..11]\n\tjoints_msg.position = joints.position[0..11]\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tjoints_pub.publish(joints_msg)\n\tdef traj_msg = new JointTrajectory()\n\ttraj_msg.joint_names = joints_msg.name\n\tdef traj_point = new JointTrajectoryPoint()\n\ttraj_point.positions = joints_msg.position\n\ttraj_point.velocities = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\ttraj_point.accelerations = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\ttraj_point.time_from_start = rospy.Duration.from_sec(1.0)\n\ttraj_msg.points = [traj_point]\n\ttraj_msg.header.stamp = rospy.Time.now()\n\ttraj_pub.publish(traj_msg)\n}", "CodeBleu_score": 46.70262388175299}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfoot_contact_states_.left = false;\n\tfoot_contact_states_.right = false;\n\n\tfor (unsigned int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::vector<std::string> collision;\n\t\tboost::split(collision, _msg->contact(i).collision1(), boost::is_any_of(\"/\"));\n\n\t\tif (collision[1] == \"left_foot\") {\n\t\t\tfoot_contact_states_.left = true;\n\t\t}\n\t\telse if (collision[1] == \"right_foot\") {\n\t\t\tfoot_contact_states_.right = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.20759238153831}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfootContact[LEFT] = false;\n\tfootContact[RIGHT] = false;\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::vector<std::string> collision;\n\t\tboost::split(collision, _msg->contact(i).collision1(), boost::is_any_of(\":\"));\n\t\tif (collision[0] == \"base_link\" && collision[1] == \"l_sole\") {\n\t\t\tfootContact[LEFT] = true;\n\t\t}\n\t\tif (collision[0] == \"base_link\" && collision[1] == \"r_sole\") {\n\t\t\tfootContact[RIGHT] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 46.36345075340091}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfoot_contact_state_.left = false;\n\tfoot_contact_state_.right = false;\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::vector<std::string> contact;\n\t\tboost::split(contact, _msg->contact(i).collision1(), boost::is_any_of(\":\"));\n\t\tif (contact[0] == \"base_link\" && contact[1] == \"l_sole\") {\n\t\t\tfoot_contact_state_.left = true;\n\t\t}\n\t\tif (contact[0] == \"base_link\" && contact[1] == \"r_sole\") {\n\t\t\tfoot_contact_state_.right = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.2082927199477}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);", "CodeBleu_score": 6.234323053025302}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities!= nullptr);\nassert(rotor_velocities->size() == kRotorCount);\n\nif (!is_active_) {\nrotor_velocities->setZero();\nreturn;\n}\n\nEigen::Vector3d acceleration = ComputeDesiredAcceleration();\nEigen::Vector3d angular_acceleration_thrust = ComputeDesiredAngularAcceleration();\n\n// Project thrust onto body z-axis.\nangular_acceleration_thrust(2) +=\nodometry_.orientation.toRotationMatrix().col(2).dot(acceleration);\n\n// Combine thrust and angular acceleration.\nEigen::VectorXd desired_acceleration_thrust_angular =\nEigen::VectorXd::Zero(kRotorCount);\ndesired_acceleration_thrust_angular.block<3, 1>(0, 0) =\nangular_acceleration_thrust;\n\n// Calculate rotor velocities.\n*rotor_velocities = rotor_velocities_matrix_ *\ndesired_acceleration_thrust_angular.cwiseSqrt().cwiseMax(Eigen::VectorXd::Zero(kRotorCount));\n}", "CodeBleu_score": 45.04279681796301}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\nassert(rotor_velocities->size() == vehicle_parameters_.rotor_configuration_.rotors.size());\nif (!controller_active_) {\nrotor_velocities->setZero();\nreturn;\n}\nEigen::Vector3d acceleration = ComputeDesiredAcceleration();\nEigen::Vector3d angular_acceleration_thrust = ComputeDesiredAngularAcc(acceleration);\n// Project thrust onto the body z-axis.\nangular_acceleration_thrust.block<3, 1>(0, 0) =\nodometry_.orientation.toRotationMatrix().col(2).cross(angular_acceleration_thrust.block<3, 1>(0, 0));\n// Combine angular acceleration and thrust into a single vector.\nEigen::VectorXd acceleration_thrust(6);\nacceleration_thrust.block<3, 1>(0, 0) = angular_acceleration_thrust;\nacceleration_thrust.block<3, 1>(3, 0) = acceleration;\n// Compute rotor velocities.\n*rotor_velocities = rotor_velocity_matrix_ * acceleration_thrust;\n// Ensure non-negative values.\n*rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->size()));\n// Take the square root of each component.\n*rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 57.997205842537404}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// Get the position and velocity errors\nEigen::Vector3d position_error = position_error_;\nEigen::Vector3d velocity_error = velocity_error_;\n\n// Transform the velocity error to the world frame\nvelocity_error =\nodometry_.orientation.toRotationMatrix().transpose() * velocity_error;\n\n// Calculate the desired acceleration\n*acceleration = -position_gain_ * position_error - velocity_gain_ * velocity_error;\n\n// Adjust for mass, gravity, and commanded acceleration\n*acceleration =\n(*acceleration - odometry_.orientation.toRotationMatrix() * gravity_) /\nodometry_.velocity.norm();\n*acceleration += command_trajectory_.acceleration;\n}", "CodeBleu_score": 33.16228536991937}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position error\n\tEigen::Vector3d position_error = odometry_.position - command_trajectory_.position;\n\n\t// Compute the velocity error\n\tEigen::Vector3d velocity_error = odometry_.orientation.toRotationMatrix().transpose() * (odometry_.velocity - command_trajectory_.velocity);\n\n\t// Compute the desired acceleration\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error + acceleration_ff_;\n}", "CodeBleu_score": 31.677687983596627}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute position and velocity errors.\n\tEigen::Vector3d position_error = odometry_.position - command_trajectory_.position();\n\tEigen::Vector3d velocity_error = odometry_.velocity - command_trajectory_.velocity();\n\n\t// Transform velocity error to the world frame.\n\tvelocity_error = odometry_.orientation.toRotationMatrix().transpose() * velocity_error;\n\n\t// Compute desired acceleration.\n\t*acceleration =\n\t\tposition_gain_ * position_error + velocity_gain_ * velocity_error +\n\t\tcommand_trajectory_.acceleration() - gravity_ * Eigen::Vector3d::UnitZ() * mass_;\n}", "CodeBleu_score": 37.904162197764876}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\tassert(rotor_velocities->size() == kRotorVelocityCount);\n\tassert(kRotorVelocityCount == kRotorCount);\n\n\tEigen::VectorXd angular_acceleration_thrust = CalculateDesiredAngularAccel();\n\tEigen::VectorXd control_attitude_thrust_reference = CalculateControlAttitudeThrustReference();\n\n\tEigen::VectorXd desired_accel_thrust_combined = angular_acceleration_thrust + control_attitude_thrust_reference;\n\n\trotor_velocities->resize(kRotorCount);\n\trotor_velocities->noalias() = kRotorVelocityGain * desired_accel_thrust_combined;\n\trotor_velocities->cwiseMax(Eigen::VectorXd::Ones(kRotorCount));\n\trotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 46.731626164774156}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\tassert(rotor_velocities->size() == kRotorCount);\n\n\tEigen::VectorXd angular_acceleration_thrust = control_attitude_thrust_reference_.block<3, 1>(0, 0);\n\tangular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration_thrust.block<3, 1>(0, 0) + control_attitude_thrust_reference_.block<3, 1>(3, 0);\n\n\trotor_velocities->cwiseSqrt();\n\trotor_velocities->rows();\n\trotor_velocities->resize(kRotorCount);\n\trotor_velocities->cwiseMax(Eigen::VectorXd::Ones(kRotorCount));\n\trotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 52.71086095716457}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\tassert(rotor_velocities->size() == rotor_velocities_reference_.size());\n\tassert(rotor_velocities_reference_.size() == kRotorVelocityGain.size());\n\n\tEigen::VectorXd angular_acceleration_thrust = CalculateAngularAccelThrust();\n\n\trotor_velocities->resize(rotor_velocities_reference_.size());\n\trotor_velocities->array() = rotor_velocities_reference_.array() + kRotorVelocityGain.array() * angular_acceleration_thrust.array();\n\trotor_velocities->array().max(1.0);\n\trotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 45.35660613831464}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # Find the index of the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n\n    # Create a copy of the object\n    copied_obj = copy.deepcopy(self)\n\n    # Slice each attribute of the copied object\n    copied_obj.time = self.time[start_index:end_index]\n    copied_obj.data = self.data[start_index:end_index]\n    copied_obj.metadata = self.metadata.copy()\n\n    # Return the copied and sliced object\n    return copied_obj\n", "CodeBleu_score": 38.3167924959735}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the corresponding indices for the start and end times\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n\n    # Make a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n\n    # Update each attribute of the copied object to contain only the sliced data\n    copied_obj.time = copied_obj.time[start_index:end_index]\n    copied_obj.data = copied_obj.data[start_index:end_index]\n    copied_obj.data_type = copied_obj.data_type[start_index:end_index]\n    copied_obj.data_units = copied_obj.data_units[start_index:end_index]\n    copied_obj.data_name = copied_obj.data_name[start_index:end_index]\n    copied_obj.data_source = copied_obj.data_source[start_index:end_index]\n    copied_obj.data_quality = copied_obj.data_quality[start_index:end_index]\n    copied_obj.data_comments = copied_obj.data_comments[start_index:end_index]\n\n    # Return the copied and sliced object\n    return copied_obj\n\n", "CodeBleu_score": 18.53512519113403}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_index_at_time(start_time)\n    end_index = self.get_index_at_time(end_time)\n    copied_obj = copy.deepcopy(self)\n    copied_obj.time = self.time[start_index:end_index]\n    copied_obj.x = self.x[start_index:end_index]\n    copied_obj.y = self.y[start_index:end_index]\n    copied_obj.z = self.z[start_index:end_index]\n    copied_obj.roll = self.roll[start_index:end_index]\n    copied_obj.pitch = self.pitch[start_index:end_index]\n    copied_obj.yaw = self.yaw[start_index:end_index]\n    copied_obj.roll_rate = self.roll_rate[start_index:end_index]\n    copied_obj.pitch_rate = self.pitch_rate[start_index:end_index]\n    copied_obj.yaw_rate = self.yaw_rate[start_index:end_index]\n    copied_obj.accel_x = self.accel_x[start_index:end_index]\n    copied_obj.accel_y = self.accel_y[start_index:end_index]\n    copied_obj.accel_z = self.accel_z[start_index:end_index]\n    copied_obj.accel_mag = self.accel_mag[start_index:end_index]\n    copied_obj.gyro_x = self.gyro_x[start_index:end_index]\n    copied_obj.gyro_y = self.gyro_y[start_index:end_index]\n    copied_obj.gyro_z = self.gyro_z[start_index:end_index]\n    copied_obj.gyro_mag = self.gyro_mag[start_index:end_index]\n    copied_obj.mag_x = self.mag_x[start_index:end_index]\n    copied_obj.mag_y = self.mag_y[start_index:end_index]\n    copied_obj.mag_z = self.mag_z[start_index:end_index]\n    copied_obj.mag_mag", "CodeBleu_score": 14.275322442914174}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    quaternion = (rotation.x, rotation.y, rotation.z, rotation.w)\n    roll, pitch, yaw = euler_from_quaternion(quaternion)\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint is None or self.last_waypoint!= point or self.last_yaw!= yaw:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(yaw)\n        self.append_times(bag_time, msg_time)\n        # Update the last waypoint and yaw\n        self.last_waypoint = point\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 29.081857554948332}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if self.last_waypoint is not None:\n        if (self.last_waypoint.position.x!= waypoint_msg.pose.position.x or\n                self.last_waypoint.position.y!= waypoint_msg.pose.position.y or\n                self.last_waypoint.position.z!= waypoint_msg.pose.position.z or\n                self.last_yaw!= waypoint_msg.pose.orientation.z):\n            self.append_point(waypoint_msg.pose.position.x, waypoint_msg.pose.position.y, waypoint_msg.pose.position.z)\n            self.append_times(msg_time, bag_time)\n            self.append_yaw(waypoint_msg.pose.orientation.z)\n            self.last_waypoint = waypoint_msg.pose.position\n            self.last_yaw = waypoint_msg.pose.orientation.z\n    else:\n        self.append_point(waypoint_msg.pose.position.x, waypoint_msg.pose.position.y, waypoint_msg.pose.position.z)\n        self.append_times(msg_time, bag_time)\n        self.append_yaw(waypoint_msg.pose.orientation.z)\n        self.last_waypoint = waypoint_msg.pose.position\n        self.last_yaw = waypoint_msg.pose.orientation.z\n\n", "CodeBleu_score": 25.118644395959922}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    quaternion = (\n        rotation.x,\n        rotation.y,\n        rotation.z,\n        rotation.w,\n    )\n    euler = euler_from_quaternion(quaternion)\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint is None or (\n        self.last_waypoint.x!= point.x\n        or self.last_waypoint.y!= point.y\n        or self.last_waypoint.z!= point.z\n        or self.last_waypoint.yaw!= euler[2]\n    ):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(euler[2])\n        self.append_times(msg_time, bag_time)\n        # Update the last waypoint\n        self.last_waypoint = point\n\n", "CodeBleu_score": 22.558437616941397}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acceleration_z.append(msg.linear_acceleration.z)\n        self.imu_linear_acceleration_time.append(to_sec(msg.header.stamp))\n        self.imu_linear_acceleration_bag_time.append(bag_time)\n    elif topic == \"/imu/data_raw\":\n        self.imu_raw_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_raw_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_raw_linear_acceleration_z.append(msg.linear_acceleration.z)\n        self.imu_raw_linear_acceleration_time.append(to_sec(msg.header.stamp))\n        self.imu_raw_linear_acceleration_bag_time.append(bag_time)\n    elif topic == \"/imu/mag\":\n        self.imu_mag_x.append(msg.magnetic_field.x)\n        self.imu_mag_y.append(msg.magnetic_field.y)\n        self.imu_mag_z.append(msg.magnetic_field.z)\n        self.imu_mag_time.append(to_sec(msg.header.stamp))\n        self.imu_mag_bag_time.append(bag_time)\n    elif topic == \"/imu/mag_raw\":\n        self.imu_raw_mag_x.append(msg.magnetic_field.x)\n        self.imu_raw_mag_y.append(msg.magnetic_field.y)\n        self.imu_raw_mag_z.append(msg.magnetic_field.z)\n        self.imu_raw_mag_time.append(to_sec(msg.header.stamp))\n        self.imu_raw_mag_bag_time.append(bag_time)\n    elif topic == \"/imu/rpy\":\n        self.imu_rpy_roll.append(msg.orientation.x)\n        self.imu_rpy_pitch.append(msg.orientation.y)", "CodeBleu_score": 22.659804883352724}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_linear_acc_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acc_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acc_z.append(msg.linear_acceleration.z)\n        self.imu_linear_acc_time.append(to_sec(msg.header.stamp))\n        self.imu_linear_acc_bag_time.append(bag_time)\n    elif topic == '/imu/data_raw':\n        self.imu_linear_acc_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acc_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acc_z.append(msg.linear_acceleration.z)\n        self.imu_linear_acc_time.append(to_sec(msg.header.stamp))\n        self.imu_linear_acc_bag_time.append(bag_time)\n\n", "CodeBleu_score": 29.750384825254095}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acceleration_z.append(msg.linear_acceleration.z)\n        self.imu_linear_acceleration_time.append(to_sec(msg.header.stamp))\n        self.imu_linear_acceleration_bag_time.append(bag_time)\n\n", "CodeBleu_score": 30.839552853325785}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    for i, a_x in enumerate(self.accelerations):\n        subplot = fig.add_subplot(len(self.accelerations), 1, i + 1)\n        subplot.plot(a_x.time, a_x.x, label=\"x\")\n        subplot.plot(a_x.time, a_x.y, label=\"y\")\n        subplot.plot(a_x.time, a_x.z, label=\"z\")\n        pyplot.ylabel(\"Acceleration (m/s^2)\")\n        pyplot.legend()\n    pyplot.xlabel(\"Time (s)\")\n    if self.save_plots:\n        filename = f\"{self.plot_prefix}{plot_suffix}.png\"\n        pyplot.savefig(filename)", "CodeBleu_score": 42.11262036065433}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.plot_enabled:\n        fig = pyplot.figure()\n        fig.suptitle('Accelerations')\n        accel_subplot = fig.add_subplot(111)\n        for i, accel_x in enumerate(self.accelerations):\n            accel_subplot.plot(accel_x.time, accel_x.x, color='C{}'.format(i), label='x')\n            accel_subplot.plot(accel_x.time, accel_x.y, color='C{}'.format(i), label='y')\n            accel_subplot.plot(accel_x.time, accel_x.z, color='C{}'.format(i), label='z')\n            accel_subplot.legend(loc='upper right')\n            pyplot.xlabel('Time (s)')\n            pyplot.ylabel('Acceleration (m/s^2)')\n        if plot_suffix is not None:\n            filename = '{}_accelerations_{}.png'.format(self.plot_prefix, plot_suffix)\n        else:\n            filename = '{}_accelerations.png'.format(self.plot_prefix)\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 51.76102026681423}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if not self.plot_enabled:\n        return\n\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n\n    ax_a_x = fig.add_subplot(311)\n    ax_a_y = fig.add_subplot(312, sharex=ax_a_x)\n    ax_a_z = fig.add_subplot(313, sharex=ax_a_x)\n\n    for i, a in enumerate(self.accelerations):\n        ax_a_x.plot(a.time, a.x, label=\"x\")\n        ax_a_y.plot(a.time, a.y, label=\"y\")\n        ax_a_z.plot(a.time, a.z, label=\"z\")\n\n    pyplot.ylabel(\"Acceleration (m/s^2)\")\n    pyplot.legend()\n    pyplot.xlabel(\"Time (s)\")\n\n    if plot_suffix is not None:\n        plot_filename = self.plot_prefix + \"_\" + plot_suffix + \".png\"\n    else:\n        plot_filename = self.plot_prefix + \".png\"\n\n    pyplot.savefig(plot_filename)\n\n", "CodeBleu_score": 42.27482312209054}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print \"Error: compare_positions requires at least two pose indices to compare\"\n        return\n    for index_1, pose_index_1 in enumerate(pose_indeces):\n        for pose_index_2 in pose_indeces[index_1+1:]:\n            self.compare_two_xyz(pose_index_1, pose_index_2)\n\n", "CodeBleu_score": 50.87175555180332}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        raise ValueError(\"At least two pose indices must be provided for comparison.\")\n    for i, pose_index_i in enumerate(pose_indeces):\n        for pose_index_j in pose_indeces[i+1:]:\n            self.compare_two_xyz(pose_index_i, pose_index_j)\n\n", "CodeBleu_score": 50.29037040083738}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print \"At least two pose indices are required to compare positions.\"\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 40.79384495776376}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if time >= start_time and time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 33.221366883419925}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision[\"time\"] <= end_time:\n            collision_times.append(collision[\"time\"])\n    return collision_times\n\n", "CodeBleu_score": 35.06554255117816}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    abs_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 28.605689571937422}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    end_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 30.97332787703203}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    abs_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 30.760733497479364}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check if data pointer is null\nif (!data) {\nreturn;\n}\n// Calculate multiplier based on camera parameters\nconst float multiplier =\n(float) width / (float) (width + this->dist);\n// Map data to Eigen vector\nEigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n// Compute RMS noise\nconst float rms_noise =\nmultiplier * this->noise_rms *\nstd::sqrt(static_cast<float>(width * height));\n// Compute noise values\nconst Eigen::VectorXf noise =\nEigen::VectorXf::Random(width * height) * rms_noise;\n// For each pixel, add noise if in range, otherwise set to bad point value\nfor (uint32_t i = 0; i < width * height; i++) {\nif (InRange(data[i])) {\ndata[i] += noise[i];\n} else {\ndata[i] = this->bad_point;\n}\n}\n}", "CodeBleu_score": 46.3587860362772}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\nif (data == nullptr) {\nreturn;\n}\n\nconst float multiplier = (float)width / (float)height;\nconst Eigen::VectorXf data_vector_map =\nEigen::Map<Eigen::VectorXf>(data, width * height);\n\nconst float rms_noise =\nstd::min(multiplier * multiplier * noise_multiplier_ * 0.0001f, 0.001f);\n\nconst Eigen::VectorXf noise =\nEigen::VectorXf::Random(width * height).array() * rms_noise;\n\nfor (uint32_t i = 0; i < width * height; ++i) {\nif (data_vector_map(i) < 0.0f || data_vector_map(i) > 10.0f) {\ndata[i] = bad_point_value_;\n} else {\ndata[i] = data_vector_map(i) + noise(i);\n}\n}\n}", "CodeBleu_score": 50.32791819116024}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\nreturn;\n}\nconst float multiplier =\n(1.0f / static_cast<float>(width)) *\n(1.0f / static_cast<float>(height)) *\n(1.0f / static_cast<float>(width)) *\n(1.0f / static_cast<float>(height));\nconst Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\nconst float rms_noise =\nstd::sqrt(multiplier * this->dist.array().square().sum());\nEigen::VectorXf noise =\nEigen::VectorXf::Random(width * height) * rms_noise;\nfor (uint32_t i = 0; i < width * height; i++) {\nif (InRange(data[i])) {\ndata[i] += noise[i];\n} else {\ndata[i] = bad_point;\n}\n}\n}", "CodeBleu_score": 51.713074398345725}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t//  ROS_INFO_STREAM(\"WaypointCallback: \" << trajectory_msg->header.frame_id);\n  // Get the current simulation time and convert it to ROS time.\n  gazebo::common::Time sim_time = world_->SimTime();\n  ros::Time ros_time(sim_time.sec, sim_time.nsec);\n\n  // Write the trajectory message to the bag file.\n  bag_.write(trajectory_msg_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 55.795147553815774}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n//  ros::Time time = ros::Time::now();", "CodeBleu_score": 8.532146662056924}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time\n\tdouble sim_time = this->world_->SimTime().Double();\n\n\t// Convert the simulation time to ROS time\n\tros::Time ros_time(sim_time);\n\n\t// Write the trajectory message to the bag file\n\tthis->waypoint_bag_.write(this->waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 36.280773901696435}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time ros_now = ConvertGazeboToRos(now);\n\tsensor_msgs::ActuatorVelocities rot_velocities_msg;\n\trot_velocities_msg.header.stamp = ros_now;\n\trot_velocities_msg.header.frame_id = \"base_link\";\n\trot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\tint i = 0;\n\tfor (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m!= motor_joints_.end(); m++) {\n\t\trot_velocities_msg.angular_velocities[i].joint_name = m->first;\n\t\trot_velocities_msg.angular_velocities[i].velocity = m->second->GetVelocity(0) * motor_velocity_slowdown_;\n\t\ti++;\n\t}\n\trot_velocities_pub_.publish(rot_velocities_msg);\n}", "CodeBleu_score": 54.649950882837075}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time t = ros::Time(now.sec, now.nsec);\n\tros::Duration d = ros::Duration(now.sec, now.nsec);\n\t//d.fromSec(now.Double());\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time(now.sec, now.nsec);\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros::Time::now();\n\t//ros::Time t = ros", "CodeBleu_score": 15.654950741234213}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time t = ros::Time(now.sec, now.nsec);\n\tsensor_msgs::ActuatorVelocities rot_velocities_msg;\n\trot_velocities_msg.header.stamp = t;\n\trot_velocities_msg.header.frame_id = \"base_link\";\n\trot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n\tint i = 0;\n\tfor (auto m = motor_joints_.begin(); m!= motor_joints_.end(); ++m, ++i) {\n\t\trot_velocities_msg.angular_velocities[i].joint_name = m->first;\n\t\trot_velocities_msg.angular_velocities[i].speed = m->second->GetVelocity(0) * slowdown_;\n\t}\n\tmotor_velocities_pub_.publish(rot_velocities_msg);\n\tmotor_velocities_bag_.write(motor_topic_, t, rot_velocities_msg);\n}", "CodeBleu_score": 56.58698694316764}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT\n  gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\"\n        << std::endl;", "CodeBleu_score": 3.5671865543906036}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t\n/*\n * This if statement checks if debug printing is enabled. If it is, it logs that the callback was called.\n */\n  if (debug_enabled_) {\n    gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\n\";\n  }\n\n/*\n * This function call, GazeboFwDynamicsPlugin::NormalizedInputToAngle, converts the normalized input value for roll to a control surface angle for the ailerons.\n */\n  roll_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll(),\n                                 roll_input_min_, roll_input_max_,\n                                 roll_min_, roll_max_);\n\n/*\n * This function call, GazeboFwDynamicsPlugin::NormalizedInputToAngle, converts the normalized input value for pitch to a control surface angle for the elevator.\n */\n  pitch_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch(),\n                                  pitch_input_min_, pitch_input_max_,\n                                  pitch_min_, pitch_max_);\n\n/*\n * This function call, GazeboFwDynamicsPlugin::NormalizedInputToAngle, converts the normalized input value for yaw rate to a control surface angle for the rudder.\n */\n  yaw_rate_ = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate(),\n                                     yaw_rate_input_min_, yaw_rate_input_max_,\n                                     yaw_rate_min_, yaw_rate_max_);\n\n/*\n * This line sets the throttle value from the thrust message.\n */\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 39.86436948769719}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_MAJOR_VERSION >= 7\n  if (debug_enabled_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called\n\";\n  }\n#else\n  if (debug_enabled_) {\n    ROS_DEBUG_STREAM(\"RollPitchYawrateThrustCallback called\");\n  }\n#endif\n\n  // Convert normalized input values to control surface angles.\n  double aileron_angle =\n      roll_pitch_yawrate_thrust_msg->roll() * aileron_angle_max_;\n  double elevator_angle =\n      roll_pitch_yawrate_thrust_msg->pitch() * elevator_angle_max_;\n  double rudder_angle =\n      roll_pitch_yawrate_thrust_msg->yaw_rate() * rudder_angle_max_;\n\n  // Set the control surface angles.\n  SetAileronAngle(aileron_angle);\n  SetElevatorAngle(elevator_angle);\n  SetRudderAngle(rudder_angle);\n\n  // Set the throttle value.\n  SetThrottle(roll_pitch_yawrate_thrust_msg->thrust());\n}", "CodeBleu_score": 42.97529026019787}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 9\n  common::Time start_time = world->SimTime();\n  common::Time end_time = start_time + common::Time(_timeoutMs / 1000.0);\n  common::Time current_time = start_time;\n#else\n  common::Time start_time = world->GetSimTime();\n  common::Time end_time = start_time + common::Time(_timeoutMs / 1000.0);\n  common::Time current_time = start_time;\n#endif\n\n  while (current_time < end_time) {\n    // Check if there is data available\n    if (this->dataAvailable()) {\n      // Receive the data\n      int len = this->receiveData();\n      if (len > 0) {\n        // Parse the MAVLink messages from the buffer\n        this->parseMessages(len);\n      }\n    }\n\n    // Sleep for a short while\n    usleep(100);\n\n    // Update the current time\n#if GAZEBO_MAJOR_VERSION >= 9\n    current_time = world->SimTime();\n#else\n    current_time = world->GetSimTime();\n#endif\n  }\n}", "CodeBleu_score": 36.94025848362571}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 9\n  common::Time timeout = common::Time(_timeoutMs / 1000.0);\n#else\n  double timeout = _timeoutMs / 1000.0;\n#endif\n  // poll for new data\n  if (this->dataPtr->socket.Poll(&timeout, 0)) {\n    // Receive data\n    char buffer[BUFFER_LENGTH];\n    int bytes_received = this->dataPtr->socket.Recv(buffer, BUFFER_LENGTH);\n\n    if (bytes_received > 0) {\n      // Forward data to the serial port if it is connected\n      if (this->dataPtr->serialEnabled) {\n        this->dataPtr->serialPort->Write(buffer, bytes_received);\n      }\n\n      // Handle message\n      mavlink_message_t message;\n      mavlink_status_t status;\n\n      for (unsigned int i = 0; i < (unsigned int)bytes_received; ++i) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &message, &status)) {\n          this->handleMessage(message);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 48.79048796406213}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t//  if (this->fd < 0) {", "CodeBleu_score": 1.425587607358519}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(io_mutex_);\n\tif (is_open)  {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable())  {\n\t\t\tio_thread_.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 65.83630824874037}, {"code": "void GazeboMavlinkInterface::close() {\n\t\nstd::lock_guard<std::mutex> lock(mutex_);\n\nif (is_open)  {\n\nio_service_.stop();\nserial_dev_.close();\n\nif (io_thread_.joinable())\nio_thread_.join();\n\nis_open = false;\n\n}\n\n}", "CodeBleu_score": 70.58611350174637}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::unique_lock<boost::mutex> lock(interface_mutex_);\n\tif (is_open)  {\n\t\tio_service_.stop();\n\t\tserial_dev_.close();\n\t\tif (io_thread_.joinable())  {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open = false;\n\t}\n}", "CodeBleu_score": 62.816108642285094}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tdouble x,\n\tignition::math::Vector3d value1,\n\tignition::math::Vector3d value2,\n\tignition::math::Vector3d value3,\n\tignition::math::Vector3d value4,\n\tignition::math::Vector3d value5,\n\tignition::math::Vector3d value6,\n\tignition::math::Vector3d value7,\n\tignition::math::Vector3d value8,\n\tignition::math::Vector3d value9,\n\tignition::math::Vector3d value10,\n\tignition::math::Vector3d value11,\n\tignition::math::Vector3d value12,\n\tignition::math::Vector3d value13,\n\tignition::math::Vector3d value14,\n\tignition::math::Vector3d value15,\n\tignition::math::Vector3d value16,\n\tignition::math::Vector3d value17,\n\tignition::math::Vector3d value18,\n\tignition::math::Vector3d value19,\n\tignition::math::Vector3d value20,\n\tignition::math::Vector3d value21,\n\tignition::math::Vector3d value22,\n\tignition::math::Vector3d value23,\n\tignition::math::Vector3d value24,\n\tignition::math::Vector3d value25,\n\tignition::math::Vector3d value26,\n\tignition::math::Vector3d value27,\n\tignition::math::Vector3d value28,\n\tignition::math::Vector3d value29,\n\tignition::math::Vector3d value30,\n\tignition::math::Vector3d value31,\n\tignition::math::Vector3d value32,\n\tignition::math::Vector3d value33,\n\tignition::math::Vector3d value34,\n\tignition::math::Vector3d value35,\n\tignition::math::Vector3d value36,\n\tignition::math::Vector3d value37", "CodeBleu_score": 10.48758642692334}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d position,\n\tignition::math::Vector3d point1,\n\tignition::math::Vector3d point2,\n\tignition::math::Vector3d value1,\n\tignition::math::Vector3d value2\n}", "CodeBleu_score": 17.020925602434414}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tconst double &x,\n\tconst double &x0,\n\tconst double &x1,\n\tconst ignition::math::Vector3d &y0,\n\tconst ignition::math::Vector3d &y1\n}", "CodeBleu_score": 23.594699710692474}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}, {"code": "void Animation::SetTime(double _time){\n\t}", "CodeBleu_score": 2.3054066121187096}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    self.construct_target()\n    self.print_vehicle_info()\n\n", "CodeBleu_score": 6.576782511750447}, {"code": "def hover(self)\n\t\n    self.construct_target()\n    self.vehicle.set_mav_frame(1)\n    self.vehicle.set_mav_type(0)\n    self.vehicle.set_mav_mode(1)\n    self.print_vehicle_info()\n\n", "CodeBleu_score": 9.185491791133842}, {"code": "def hover(self)\n\t\n    self.vehicle_type = \"hover\"\n    self.vehicle_id = 1\n    self.flight_mode = \"0\"\n    self.coordinate_frame = 1\n    self.construct_target\n    self.print", "CodeBleu_score": 24.81794014118458}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = 1\n        self.hover()\n    else:\n        self.flightModeService(self.flight_mode)\n        if self.flightModeService.success:\n            print \"Mode changed to: \" + self.flight_mode\n            return True\n        else:\n            print \"Failed to change mode to: \" + self.flight_mode\n            return False\n\n", "CodeBleu_score": 37.51706814705549}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        self.hover = 1\n        print 'Hovering'\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print 'Changing to %s mode' % self.flightMode\n            return True\n        except rospy.ServiceException, e:\n            print 'Service call failed: %s' % e\n            return False\n\n", "CodeBleu_score": 37.22987838709169}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        self.hover = 1\n        print 'Hovering'\n        return True\n    else:\n        self.flightModeService(self.flightMode)\n        if self.flightModeService.response.result == 0:\n            print 'Switching to'+ self.flightMode\n            return True\n        else:\n            print 'Failed to switch to'+ self.flightMode\n            return False\n\n", "CodeBleu_score": 33.22879463763764}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    if not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.angular.z)\n\n", "CodeBleu_score": 23.908999032768268}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.angular.z)\n", "CodeBleu_score": 25.611550638086015}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear, msg.angular)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear, msg.angular, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear, msg.angular)\n\n", "CodeBleu_score": 22.147435825313472}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode!= \"HOVER\" and (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_flight_mode(\"OFFBOARD\")\n        self.hover_flag = 0\n        self.set_flight_mode(\"HOVER\")\n        self.hover_flag = 1\n        self.hover()\n    elif self.flight_mode == \"HOVER\" and (abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005):\n        self.hover_flag = 1\n        self.hover()\n    else:\n        self.hover_flag = 0\n        self.set_flight_mode(\"OFFBOARD\")\n        self.hover_flag = 0\n        self.set_flight_mode(\"HOVER\")\n        self.hover_flag = 1\n        self.hover()", "CodeBleu_score": 53.08575858167841}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode!= \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.set_mode(\"OFFBOARD\")\n        else:\n            self.hover_flag = 1\n            self.set_mode(\"HOVER\")\n            self.hover()\n\n", "CodeBleu_score": 66.39549355422002}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.mode = 'OFFBOARD'\n        self.hover_state_transition = 1\n    elif (self.mode!= 'HOVER' and self.hover_flag == 1):\n        self.hover_flag = 1\n        self.mode = 'HOVER'\n        self.hover_state_transition = 1\n    else:\n        self.hover_state_transition = 0\n    return self.hover_state_transition\n\n", "CodeBleu_score": 56.696546880921304}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.set_coordinate_frame(self.coordinate_frame)\n    self.set_motion_type(self.motion_type)\n    self.construct_target()\n    self.print()\n\n", "CodeBleu_score": 6.673267742132885}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = Vehicle.FRAME_LOCAL_NED\n    self.motion_type = Vehicle.MOTION_TYPE_HOLD\n    self.construct_target()\n    print(\"Vehicle Type: \" + str(self.vehicle_type))\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: \" + str(self.flight_mode))\n\n", "CodeBleu_score": 23.102655490765468}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = self.vehicle.location.global_frame\n    self.motion_type = self.vehicle.mode\n    self.construct_target()\n    print(\"Vehicle Type: %s", "CodeBleu_score": 8.994996377103364}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        self.hover = True\n        return True\n    else:\n        self.flightModeService(self.flightMode)\n        self.flightMode = self.flightModeService.call().mode.data\n        print 'Flight mode switched to:', self.flightMode\n        return True\n    return False\n\n", "CodeBleu_score": 32.81522068821514}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        self.hover = True\n        print 'HOVER'\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print self.flightMode\n            return True\n        except rospy.ServiceException, e:\n            print 'flight_mode_switch failed: %s' % e\n            return False\n\n", "CodeBleu_score": 33.4689110640655}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print 'Flight mode set to: ', self.flightMode\n            return True\n        except rospy.ServiceException, e:\n            print 'Service call failed: %s' % e\n            return False\n\n", "CodeBleu_score": 32.791907557911934}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == i:\n        self.local_pose = msg\n        if self.gcs_command == 0:\n            self.takeoff_target_pose = self.local_pose\n            self.hover_target_pose = self.local_pose\n        elif self.gcs_command == 1:\n            self.hover_target_pose = self.local_pose\n        self.global_pose = deepcopy(self.local_pose)\n        self.global_pose.position.x += self.global_pose_bias.position.x\n        self.global_pose.position.y += self.global_pose_bias.position.y\n        self.global_pose.position.z += self.global_pose_bias.position.z\n\n", "CodeBleu_score": 27.120954462501363}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = msg\n            self.takeoff_target_pose.position.x = msg.position.x + self.takeoff_bias_x\n            self.takeoff_target_pose.position.y = msg.position.y + self.takeoff_bias_y\n            self.takeoff_target_pose.position.z = msg.position.z + self.takeoff_bias_z\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = msg\n            self.hover_target_pose.position.x = msg.position.x + self.hover_bias_x\n            self.hover_target_pose.position.y = msg.position.y + self.hover_bias_y\n            self.hover_target_pose.position.z = msg.position.z + self.hover_bias_z\n        self.global_pose = msg\n        self.global_pose.position.x = msg.position.x + self.global_pose_bias_x\n        self.global_pose.position.y = msg.position.y + self.global_pose_bias_y\n        self.global_pose.position.z = msg.position.z + self.global_pose_bias_z\n\n", "CodeBleu_score": 20.87743991417163}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == str(i):\n        self.local_pose[i] = msg\n        self.local_pose_updated[i] = True\n        self.local_pose_updated_time[i] = rospy.get_time()\n\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose[i] = msg\n            self.takeoff_target_pose[i].pose.position.x = msg.pose.position.x + self.takeoff_bias_x\n            self.takeoff_target_pose[i].pose.position.y = msg.pose.position.y + self.takeoff_bias_y\n            self.takeoff_target_pose[i].pose.position.z = msg.pose.position.z + self.takeoff_bias_z\n\n        if self.gcs_command == \"hover\":\n            self.hover_target_pose[i] = msg\n            self.hover_target_pose[i].pose.position.x = msg.pose.position.x + self.hover_bias_x\n            self.hover_target_pose[i].pose.position.y = msg.pose.position.y + self.hover_bias_y\n            self.hover_target_pose[i].pose.position.z = msg.pose.position.z + self.hover_bias_z\n\n        self.global_pose[i] = msg\n        self.global_pose[i].pose.position.x = msg.pose.position.x + self.global_pose_bias_x\n        self.global_pose[i].pose.position.y = msg.pose.position.y + self.global_pose_bias_y\n        self.global_pose[i].pose.position.z = msg.pose.position.z + self.global_pose_bias_z\n\n", "CodeBleu_score": 25.12730808055683}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.vehicle.armed and self.vehicle.location.global_relative_frame.alt > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 55.337351953608874}, {"code": "def takeoff_detection(self)\n\t\n    if self.arm_state.armed and self.local_position[2] > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 57.39106146189312}, {"code": "def takeoff_detection(self)\n\t\n    if self.local_position[2] > 0.2 and self.arm_state == 1:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 65.34899232529526}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # build graph\n    distance_matrix = []\n    for i in range(len(orig_formation)):\n        distance_matrix.append([])\n        for j in range(len(change_formation)):\n            distance_matrix[i].append(int(50 - norm(np.array(orig_formation[i]) - np.array(change_formation[j]))))\n    return distance_matrix\n\n", "CodeBleu_score": 23.856693437682157}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize distance matrix\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    # Iterate through the original formation and calculate distances\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            # Calculate Euclidean norm\n            norm = np.linalg.norm(np.array(orig_formation[i]) - np.array(change_formation[j]))\n            # Adjust distance and convert to integer\n            range = int(50 - norm)\n            # Add adjusted distance to distance matrix\n            distance_matrix[i, j] = range\n    # Return distance matrix\n    return distance_matrix", "CodeBleu_score": 26.590014607242335}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    dist_mat = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_mat[i, j] = 50 - np.linalg.norm(orig_formation[i] - change_formation[j])\n    dist_mat = dist_mat.astype(int)\n    return dist_mat\n\n", "CodeBleu_score": 25.024595518592168}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visited[i] = True\n    for j in self.graph[i]:\n        if self.right_visited[j]:\n            continue\n        gap = self.left_label[i] + self.right_label[j] - self.match_weight[i][j]\n        if gap == 0:\n            self.right_visited[j] = True\n            if self.right_match[j] == -1 or self.find_path(self.right_match[j]):\n                self.right_match[j] = i\n                self.left_match[i] = j\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n\n", "CodeBleu_score": 47.228884162295365}, {"code": "def find_path(self, i)\n\t\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in self.graph[i]:\n        if self.match[j] == -1 or self.find_path(self.match[j]):\n            self.match[j] = i\n            return True\n    return False\n\n", "CodeBleu_score": 25.19017279009811}, {"code": "def find_path(self, i)\n\t\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in range(self.n):\n        if self.right_match[j] == -1 or self.find_path(self.right_match[j]):\n            self.right_match[j] = i\n            self.left_match[i] = j\n            return True\n    return False\n", "CodeBleu_score": 25.569609873862976}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    self.match_results = numpy.zeros(self.num_uavs, dtype=numpy.int) - 1\n    self.slack = numpy.zeros(self.num_uavs, dtype=numpy.float64)\n    self.slack_row = numpy.zeros(self.num_uavs, dtype=numpy.int)\n    self.slack_col = numpy.zeros(self.num_uavs, dtype=numpy.int)\n    self.visited_row = numpy.zeros(self.num_uavs, dtype=numpy.int)\n    self.visited_col = numpy.zeros(self.num_uavs, dtype=numpy.int)\n    for uav in range(self.num_uavs):\n        self.slack.fill(numpy.inf)\n        self.visited_row.fill(0)\n        self.visited_col.fill(0)\n        self.find_path(uav)\n        if self.match_results[uav] == -1:\n            self.adjust_labels(uav)\n    return self.match_results[self.num_uavs:]\n\n", "CodeBleu_score": 23.5139614612351}, {"code": "def KM(self)\n\t\n    # Initialize slack variables and visit arrays\n    self.slack = numpy.zeros(self.num_UAV)\n    self.visit_UAV = numpy.zeros(self.num_UAV, dtype=bool)\n    self.visit_target = numpy.zeros(self.num_target, dtype=bool)\n    for uav in range(self.num_UAV):\n        # Initialize the minimum slack value as infinity\n        self.slack[uav] = numpy.inf\n        # Reset visit arrays\n        self.visit_UAV.fill(False)\n        self.visit_target.fill(False)\n        # Find a path from the UAV to a target\n        self.find_path(uav)\n        # Adjust the labels based on the minimum slack value if no path is found\n        while not self.visit_UAV[uav]:\n            # Find the minimum slack value\n            min_slack = numpy.min(self.slack)\n            # Adjust the labels\n            self.label_UAV -= min_slack\n            self.label_target += min_slack\n            self.slack -= min_slack\n            # Reset visit arrays\n            self.visit_UAV.fill(False)\n            self.visit_target.fill(False)\n            # Find a path from the UAV to a target\n            self.find_path(uav)\n    # Return the match results for the right side of the bipartite graph\n    return self.match_UAV\n\n", "CodeBleu_score": 24.397090733073124}, {"code": "def KM(self)\n\t\n    for uav in range(self.uav_num):\n        self.slack = [float(\"inf\")] * self.node_num\n        self.visited_uav = [False] * self.uav_num\n        self.visited_node = [False] * self.node_num\n        self.find_path(uav)\n    return self.match_results\n\n", "CodeBleu_score": 10.299873852074732}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # convert to hsv color space\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    # define lower and upper bounds for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    # create mask for yellow color\n    yellow_mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    # apply mask to original image\n    yellow_image = cv2.bitwise_and(image, image, mask=yellow_mask)\n    # return result\n    return yellow_image\n\n", "CodeBleu_score": 26.034177197742537}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([50, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 25.5444853207554}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t// find the description in the standalone_tag_descriptions_ map\n\tauto it = standalone_tag_descriptions_.find(id);\n\tif (it!= standalone_tag_descriptions_.end()) {\n\t\t// found it\n\t\tdescriptionContainer = it->second;\n\t\treturn true;\n\t} else {\n\t\t// not found\n\t\tif (printWarning) {\n\t\t\tROS_WARN_THROTTLE(10, \"standalone tag ID %d not found\", id);\n\t\t}\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 35.16985380788895}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n}", "CodeBleu_score": 0.6648108845887202}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n}", "CodeBleu_score": 0.6648108845887202}]}
