{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\tif (download) {\nfor (const auto &file : GetRequiredFiles(folder, false)) {\nif (!FileExists(file)) {\nRequestFile(file);\nlog_info(\"Downloading file: {}\", file);\n} else {\nlog_info(\"File found in cache: {}\", file);\n}\n}\n}\nreturn GetRequiredFiles(folder, false);\n}", "CodeBleu_score": 51.54453015111391}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\tstd::vector<std::string> requiredFiles;\nstd::vector<std::string> localFiles;\nstd::vector<std::string> missingFiles;\n\nif (!folder.empty()) {\n\nif (download) {\n\nif (GetLocalFiles(folder, localFiles)) {\n\nfor (const auto &localFile : localFiles) {\n\nif (FileExists(localFile)) {\n\nlog_info(\"File '{}' found in cache.\", localFile);\nrequiredFiles.push_back(localFile);\n} else {\n\nlog_info(\"File '{}' not found in cache.\", localFile);\nmissingFiles.push_back(localFile);\n}\n}\n}\n}\n\nif (!missingFiles.empty()) {\n\nfor (const auto &missingFile : missingFiles) {\n\nlog_info(\"Requesting file '{}' from server.\", missingFile);\n\nif (RequestFile(missingFile)) {\n\nlog_info(\"File '{}' requested from server.\", missingFile);\n\nif (GetLocalFiles(folder, localFiles)) {\n\nfor (const auto &localFile : localFiles) {\n\nif (FileExists(localFile)) {\n\nlog_info(\"File '{}' found in cache.\", localFile);\nrequiredFiles.push_back(localFile);\n} else {\n\nlog_info(\"File '{}' not found in cache.\", localFile);\nmissingFiles.push_back(localFile);\n}\n}\n}\n}\n}\n}\n}\nreturn requiredFiles;\n}", "CodeBleu_score": 52.385487265493325}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> required_files;\n\tstd::vector<std::string> files_to_download;\n\tstd::vector<std::string> files_in_cache;\n\n\t// Get the list of files in the specified folder\n\tstd::vector<std::string> files = _pimpl->CallAndWait<std::vector<std::string>>([this, &folder]() {\n\t\treturn _pimpl->GetFilesInFolder(folder);\n\t});\n\n\t// Check if the files exist in the cache\n\tfor (const std::string &file : files) {\n\t\tif (FileExists(file)) {\n\t\t\tfiles_in_cache.push_back(file);\n\t\t}\n\t}\n\n\t// Check if the files exist locally\n\tfor (const std::string &file : files) {\n\t\tif (FileExists(file)) {\n\t\t\tlog_info(\"File \" + file + \" found in cache\");\n\t\t} else {\n\t\t\tfiles_to_download.push_back(file);\n\t\t}\n\t}\n\n\t// Download the missing files\n\tif (download) {\n\t\tfor (const std::string &file : files_to_download) {\n\t\t\tDownloadFile(file);\n\t\t}\n\t}\n\n\t// Return the list of required files\n\trequired_files.insert(required_files.end(), files_in_cache.begin(), files_in_cache.end());\n\trequired_files.insert(required_files.end(), files_to_download.begin(), files_to_download.end());\n\treturn required_files;\n}", "CodeBleu_score": 49.603826072363454}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n/*\n * This function, Client::SpawnActorWithParent, spawns an actor with a specified parent using the provided description, transform, parent ID, attachment type, and socket name.", "CodeBleu_score": 19.986618305810786}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 8.495909444103484}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 8.495909444103484}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t_pimpl->streaming_client.Subscribe(\n      ActorId,\n      GBufferId,\n      std::move(callback));\n}", "CodeBleu_score": 24.357147384791638}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n_pimpl->streaming_client.Subscribe(\n      std::move(ActorId),\n      std::move(GBufferId),\n      std::move(callback));\n}", "CodeBleu_score": 31.28962019483479}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n_pimpl->streaming_client.Subscribe\n\n}", "CodeBleu_score": 9.502824507050631}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n\tif (navigation == nullptr) {\n\t\tstd::unique_lock<std::mutex> lock(_walker_navigation_mutex);\n\t\tnavigation = _walker_navigation.load();\n\t\tif (navigation == nullptr) {\n\t\t\tnavigation = std::make_shared<WalkerNavigation>();\n\t\t\tif (!_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n\t\t\t\tnavigation = _walker_navigation.load();\n\t\t\t}\n\t\t}\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 48.13788659239665}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n\tif (navigation) {\n\t\treturn navigation;\n\t}\n\t// We need to create a new navigation object.\n\t// We first need to create a new WalkerNavigation instance.\n\t// We use a placement new to create the object at the address pointed to by navigation_ptr.\n\t// We use the shared_ptr constructor to create a new shared_ptr that points to the same address as navigation_ptr.\n\t// We use compare_exchange_strong to attempt to set the navigation object to the new shared_ptr.\n\t// If the compare_exchange_strong fails, then another thread has already created the navigation object.\n\t// In that case, we can just return the navigation object that was created by another thread.\n\tstd::shared_ptr<WalkerNavigation> new_navigation = std::shared_ptr<WalkerNavigation>(new WalkerNavigation());\n\tif (_walker_navigation.compare_exchange_strong(navigation, new_navigation)) {\n\t\treturn new_navigation;\n\t} else {\n\t\treturn navigation;\n\t}\n}", "CodeBleu_score": 47.28962089712051}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n\tif (navigation == nullptr) {\n\t\tstd::unique_lock<std::mutex> lock(_walker_navigation_mutex);\n\t\tnavigation = _walker_navigation.load();\n\t\tif (navigation == nullptr) {\n\t\t\tnavigation = std::make_shared<WalkerNavigation>();\n\t\t\tif (!_walker_navigation.compare_exchange_strong(navigation, navigation)) {\n\t\t\t\tnavigation = _walker_navigation.load();\n\t\t\t}\n\t\t}\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 48.13788659239665}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\\tconst auto start_time = std::chrono::steady_clock::now();\n\\twhile (episode.GetState()->GetFrameNumber() < frame) {\n\\t\\tif (timeout.count() <= 0.0) {\n\\t\\t\\treturn false;\n\\t\\t}\n\\t\\tconst auto elapsed_time = std::chrono::steady_clock::now() - start_time;\n\\t\\tif (std::chrono::duration_cast<std::chrono::milliseconds>(elapsed_time) >= timeout) {\n\\t\\t\\treturn false;\n\\t\\t}\n\\t\\tstd::this_thread::yield();\n\\t}\n\\tepisode.GetTrafficManager().Tick();\n\\treturn true;\n}", "CodeBleu_score": 50.11500645730719}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\twhile (episode.GetState()->GetFrameNumber() < frame) {\n\t\tif (timeout.count() == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t\ttimeout -= std::chrono::milliseconds(10);\n\t}\n\tcarla::traffic_manager::TrafficManager::Get().Tick();\n\treturn true;\n}", "CodeBleu_score": 27.67712256360251}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start_time = std::chrono::system_clock::now();\n\twhile (episode.GetState()->GetTimestamp() < frame) {\n\t\tif (std::chrono::system_clock::now() - start_time > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tcarla::traffic_manager::TrafficManager::Get().Tick();\n\treturn true;\n}", "CodeBleu_score": 39.43928407350796}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tauto _client = GetClient();\n\trpc::EpisodeSettings settings;\n\tsettings.map_name = map_name;\n\tsettings.reset_settings = reset_settings;\n\tsettings.map_layers = map_layers;\n\trpc::EpisodeInfo info;\n\t_client.LoadEpisode(settings, info);\n\tauto _episode = GetCurrentEpisode();\n\tif (_episode.GetId() == info.id) {\n\t\treturn _episode;\n\t}\n\tauto start_time = std::chrono::steady_clock::now();\n\twhile (std::chrono::steady_clock::now() - start_time < _client.GetTimeout().milliseconds) {\n\t\t_episode = GetCurrentEpisode();\n\t\tif (_episode.GetId() == info.id) {\n\t\t\treturn _episode;\n\t\t}\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t}\n\tthrow std::runtime_error(\"Failed to connect to new episode.\");\n}", "CodeBleu_score": 50.18945929955834}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n}", "CodeBleu_score": 3.4852633042533125}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tauto _client = _client_wrapper.GetClient();\n\trpc::EpisodeSettings settings;\n\tsettings.map_name = map_name;\n\tsettings.reset_settings = reset_settings;\n\tsettings.map_layers = map_layers;\n\trpc::EpisodeState state;\n\trpc::EpisodeInfo episode_info;\n\tuint32_t episode_id = 0;\n\tuint32_t timeout_ms = 0;\n\tuint32_t num_attempts = 0;\n\twhile (num_attempts < _max_attempts) {\n\t\ttry {\n\t\t\tepisode_id = _client.LoadEpisode(settings, state, episode_info, timeout_ms);\n\t\t\tbreak;\n\t\t}\n\t\tcatch (const std::runtime_error& e) {\n\t\t\tnum_attempts++;\n\t\t\tif (num_attempts == _max_attempts) {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\treturn EpisodeProxy(_client_wrapper, episode_id);\n}", "CodeBleu_score": 46.03468277964463}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (!controller.GetAgent()) {\n\t\tthrow std::runtime_error(\"Agent not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()) {\n\t\tthrow std::runtime_error(\"Agent brain not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetNavMeshQuery()) {\n\t\tthrow std::runtime_error(\"Agent brain navigation mesh not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetMemory()) {\n\t\tthrow std::runtime_error(\"Agent brain memory not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetPlanner()) {\n\t\tthrow std::runtime_error(\"Agent brain planner not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetSensor()) {\n\t\tthrow std::runtime_error(\"Agent brain sensor not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetSensor()->GetMemory()) {\n\t\tthrow std::runtime_error(\"Agent brain sensor memory not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetSensor()->GetSensor()) {\n\t\tthrow std::runtime_error(\"Agent brain sensor sensor not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetSensor()->GetSensor()->GetMemory()) {\n\t\tthrow std::runtime_error(\"Agent brain sensor sensor memory not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetSensor()->GetSensor()->GetMemory()->GetNodeMemory()) {\n\t\tthrow std::runtime_error(\"Agent brain sensor sensor memory node memory not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetSensor()->GetSensor()->GetMemory()->GetLinkMemory()) {\n\t\tthrow std::runtime_error(\"Agent brain sensor sensor memory link memory not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetSensor()->GetSensor()->GetMemory()->GetLinkMemory()->GetNodeMemory()) {\n\t\tthrow std::runtime_error(\"Agent brain sensor sensor memory link memory node memory not set in controller\");\n\t}\n\tif (!controller.GetAgent()->GetBrain()->GetSensor()->GetSensor()->GetMemory()->GetLinkMemory()->", "CodeBleu_score": 29.23359879624846}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (controller.GetParent() != nullptr) {\n\t\t// The controller already has a parent\n\t\treturn;\n\t}\n\tauto walker = GetWalkerFromId(controller.GetId());\n\tif (walker == nullptr) {\n\t\tthrow_exception(\"Controller's walker is not found\");\n\t}\n\tauto episode = _episode.get();\n\tif (episode == nullptr) {\n\t\tthrow_exception(\"Episode is not found\");\n\t}\n\tauto nav = episode->CreateNavigationIfMissing();\n\tnav->RegisterWalker(walker);\n}", "CodeBleu_score": 60.91265162928904}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (!controller.GetEpisode()) {\n\t\tthrow_exception(\"Cannot register an AI controller without an episode\");\n\t}\n\tauto walker = controller.GetAgent();\n\tif (!walker) {\n\t\tthrow_exception(\"Cannot register an AI controller without a walker\");\n\t}\n\tif (!walker->GetAgentType() == AgentType::WALKER) {\n\t\tthrow_exception(\"Cannot register an AI controller with a non-walker agent\");\n\t}\n\tauto nav = controller.GetEpisode()->CreateNavigationIfMissing();\n\tif (!nav) {\n\t\tthrow_exception(\"Cannot register an AI controller without a navigation mesh\");\n\t}\n\tnav->RegisterWalker(walker);\n}", "CodeBleu_score": 50.11717946689589}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 7.425333410238643}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 7.425333410238643}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 7.425333410238643}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n}", "CodeBleu_score": 10.221038326534257}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n}", "CodeBleu_score": 10.221038326534257}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n}", "CodeBleu_score": 10.221038326534257}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tif (!Load(episode)) return;\n\tauto walkers = _nav.GetAgents();\n\tif (walkers->empty()) return;\n\tauto commands = std::vector<WalkerCommand>();\n\tauto state = episode->GetState();\n\tfor (auto walker : *walkers) {\n\t\tif (!CheckIfWalkerExist(walker, state)) {\n\t\t\t_nav.RemoveAgent(walker);\n\t\t\tUnregisterWalker(walker);\n\t\t\tcontinue;\n\t\t}\n\t\tauto transform = _nav.GetWalkerTransform(walker);\n\t\tauto speed = _nav.GetWalkerSpeed(walker);\n\t\tcommands.emplace_back(transform, speed);\n\t}\n\t_simulator.lock()->SetActorCollisions(true);\n\tUpdateVehiclesInCrowd(state);\n\t_nav.UpdateCrowd();\n\t_simulator.lock()->ApplyBatchSync(commands, true);\n\tfor (auto walker : *walkers) {\n\t\tif (!_nav.IsWalkerAlive(walker)) {\n\t\t\t_simulator.lock()->SetActorDead(walker);\n\t\t\t_nav.RemoveAgent(walker);\n\t\t\tUnregisterWalker(walker);\n\t\t}\n\t}\n}", "CodeBleu_score": 44.103380388315486}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = Load();\n\tif (walkers->empty()) {\n\t\treturn;\n\t}\n\n\tauto commands = std::vector<WalkerCommand>();\n\tauto state = episode->GetState();\n\tfor (auto& w : *walkers) {\n\t\tif (CheckIfWalkerExist(w, state)) {\n\t\t\tcommands.emplace_back(w, state);\n\t\t} else {\n\t\t\tUnregisterWalker(w);\n\t\t}\n\t}\n\n\tUpdateVehiclesInCrowd(commands);\n\t_nav.UpdateCrowd(commands);\n\n\tfor (auto& c : commands) {\n\t\tauto transform = _nav.GetWalkerTransform(c.walker);\n\t\tauto speed = _nav.GetWalkerSpeed(c.walker);\n\t\t_simulator.lock()->ApplyBatchSync(\n\t\t\t{\n\t\t\t\tcarla::command::ApplyWalkerControl(c.walker, speed, transform),\n\t\t\t\tcarla::command::ApplyWalkerState(c.walker, speed, transform)\n\t\t\t},\n\t\t\ttrue);\n\n\t\tif (_nav.IsWalkerAlive(c.walker) == false) {\n\t\t\t_simulator.lock()->SetActorDead(c.walker, true);\n\t\t\t_nav.RemoveAgent(c.walker);\n\t\t\tUnregisterWalker(c.walker);\n\t\t}\n\t}\n}", "CodeBleu_score": 47.27730541033035}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\tauto walkers = _simulator.lock()->GetAgents();\n\tif (walkers->empty()) {\n\t\treturn;\n\t}\n\tauto commands = std::vector<carla::command::ApplyWalkerState>();\n\tauto state = episode->GetState();\n\tauto walker_speed = _nav.GetWalkerSpeed();\n\tauto walker_transform = _nav.GetWalkerTransform();\n\tfor (auto& walker : *walkers) {\n\t\tauto walker_id = walker.first;\n\t\tauto walker_actor = walker.second;\n\t\tif (state.find(walker_id) == state.end()) {\n\t\t\t_nav.RemoveAgent(walker_actor);\n\t\t\tUnregisterWalker(walker_id);\n\t\t\tcontinue;\n\t\t}\n\t\tauto walker_state = state[walker_id];\n\t\tauto walker_location = walker_state.location;\n\t\tauto walker_rotation = walker_state.rotation;\n\t\tauto walker_velocity = walker_state.velocity;\n\t\tauto walker_angular_velocity = walker_state.angular_velocity;\n\t\tauto walker_transform = carla::geom::Transform(walker_location, walker_rotation);\n\t\tauto walker_speed = walker_velocity.length();\n\t\tcommands.emplace_back(carla::command::ApplyWalkerState{ walker_actor, walker_transform, walker_speed });\n\t}\n\t_simulator.lock()->ApplyBatchSync(commands, true);\n\t_nav.UpdateVehiclesInCrowd();\n\t_nav.UpdateCrowd();\n\tfor (auto& walker : *walkers) {\n\t\tauto walker_id = walker.first;\n\t\tauto walker_actor = walker.second;\n\t\tif (state.find(walker_id) == state.end()) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (state[walker_id].is_alive) {\n\t\t\tcontinue;\n\t\t}\n\t\t_nav.RemoveAgent(walker_actor);\n\t\tUnregisterWalker(walker_id);\n\t\t_simulator.lock()->SetActorDead(walker_actor);\n\t}\n}", "CodeBleu_score": 46.19300812179906}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\ndescription.uid = uid_;\ndescription.id = id_;\ndescription.attributes.reserve(attributes_.size());\nfor (const auto &attribute : attributes_) {\ndescription.attributes.push_back(attribute.MakeAttribute());\n}\nreturn description;\n}", "CodeBleu_score": 75.5870492791347}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\tdescription.mutable_attributes()->Reserve(attributes.size());\n\tfor (auto attribute : attributes) {\n\t\tdescription.mutable_attributes()->Add()->CopyFrom(attribute);\n\t}\n\treturn description;\n}", "CodeBleu_score": 58.776867918787886}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\ndescription.uid = this->uid;\ndescription.id = this->id;\ndescription.attributes.reserve(this->attributes.size());\nfor (auto &attribute : this->attributes) {\ndescription.attributes.push_back(attribute);\n}\nreturn description;\n}", "CodeBleu_score": 71.82789465947444}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto pair : blueprints_) {\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\tconst Attribute& attribute = pair.second.GetAttribute(name);\n\t\t\tif (attribute.GetValue() == value || attribute.GetRecommendedValues().find(value) != attribute.GetRecommendedValues().end()) {\n\t\t\t\tresult->AddBlueprint(pair.first, pair.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 42.46851313417288}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tconst auto &blueprints = GetBlueprints();\nauto result = MakeShared<BlueprintLibrary>();\nfor (const auto &pair : blueprints) {\nconst auto &blueprint = pair.second;\nif (blueprint.ContainsAttribute(name)) {\nconst auto &attribute = blueprint.GetAttribute(name);\nif (attribute.GetValue() == value) {\nresult->AddBlueprint(pair.first, blueprint);\n} else if (attribute.GetRecommendedValues().count(value) > 0) {\nresult->AddBlueprint(pair.first, blueprint);\n}\n}\n}\nreturn result;\n}", "CodeBleu_score": 45.9738812584463}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto pair : blueprints) {\n\t\tif (pair.second.ContainsAttribute(name)) {\n\t\t\tauto attribute = pair.second.GetAttribute(name);\n\t\t\tif (attribute.GetValue() == value || attribute.GetRecommendedValues().find(value) != attribute.GetRecommendedValues().end()) {\n\t\t\t\tresult->blueprints[pair.first] = pair.second;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 43.28980112567945}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = path + \".\" + std::to_string(carla::version::major) + \".\" + std::to_string(carla::version::minor) + \".\" + std::to_string(carla::version::patch);\n\tstd::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n\tif (!out.is_open()) {\n\t\treturn false;\n\t}\n\tout.write(reinterpret_cast<const char*>(content.data()), content.size());\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 45.518653490081576}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Construct the full file path\n\tstd::string full_path = GetFullFilePath(path);\n\t// Validate the file path\n\tif (!ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream out(full_path, std::ios::binary);\n\tif (!out.is_open()) {\n\t\treturn false;\n\t}\n\t// Write the content to the file\n\tout.write(reinterpret_cast<const char*>(content.data()), content.size());\n\t// Close the file\n\tout.close();\n\treturn true;\n}", "CodeBleu_score": 39.381856903514056}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Construct the full path\n\tstd::string full_path = path + GetVersionString();\n\t// Validate the path\n\tif (!ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\t// Open the file in binary mode to truncate its contents\n\tstd::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n\t// Write the content\n\tout.write((char *)content.data(), content.size());\n\t// Close the file\n\tout.close();\n\t// Return true if the file was successfully opened\n\treturn out.good();\n}", "CodeBleu_score": 40.51706498517979}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t// Get the location of the parent's bounding box.\n  const auto parent_location = transform.GetLocation();\n// Calculate the location of the bounding box.\n  const auto location = parent_location + geom::Location(0, 0, 0.5);\n// Calculate the yaw angle of the transform.\n  const auto yaw = transform.GetRotation().GetAsEulerRotation().z();\n// Calculate the extents of the bounding box.\n  const auto extents = geom::Box(transform.GetRotation(), 1, 1, 1);\n// Rotate the extents based on the yaw angle.\n  const auto rotated_extents = extents.Rotate(yaw);\n// Calculate the four corners of the bounding box.\n  const auto corners = rotated_extents.GetCorners();\n// Return a shared pointer to a Bounds object containing the frame number and the calculated corners.\n  return std::make_shared<const Bounds>(Bounds{frame, location, corners});\n}", "CodeBleu_score": 36.869136967154795}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t// Add the location of the parent frame to the location of the child frame.\n  const geom::Location location = transform.location + parent_frame_location_[frame];\n// Compute the four corners of the bounding box by rotating the extents based on the yaw angle.\n  const std::array<geom::Point, 4> corners = {\n    geom::Point(location.x + std::cos(transform.rotation.yaw) * extents_.x,\n                location.y + std::sin(transform.rotation.yaw) * extents_.x),\n    geom::Point(location.x + std::cos(transform.rotation.yaw + M_PI_2) * extents_.y,\n                location.y + std::sin(transform.rotation.yaw + M_PI_2) * extents_.y),\n    geom::Point(location.x + std::cos(transform.rotation.yaw + M_PI) * extents_.z,\n                location.y + std::sin(transform.rotation.yaw + M_PI) * extents_.z),\n    geom::Point(location.x + std::cos(transform.rotation.yaw + 3 * M_PI_2) * extents_.w,\n                location.y + std::sin(transform.rotation.yaw + 3 * M_PI_2) * extents_.w)};\n// Return a shared pointer to a Bounds object containing the frame number and the calculated corners.\n  return std::make_shared<const Bounds>(frame, corners);\n}", "CodeBleu_score": 43.17745847101123}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto location = transform.GetLocation() + parent_bounds_.location_;", "CodeBleu_score": 13.36398202739481}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(*_episode.Lock());\n\tauto lights = _episode.Lock()->QueryLightsStateToServer();\n\tfor (auto light : lights) {\n\t\tauto it = _lights.find(light.id);\n\t\tif (it == _lights.end()) {\n\t\t\t_lights[light.id] = std::make_shared<Light>(light);\n\t\t} else {\n\t\t\tit->second->Update(light);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.24638285144154}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nstd::vector<LightState> light_states = _episode.Lock()->QueryLightsStateToServer();\nfor (const LightState& light_state : light_states) {\nauto it = _lights.find(light_state.id);\nif (it == _lights.end()) {\n_lights.emplace(light_state.id, std::make_shared<Light>(light_state));\n} else {\nit->second->UpdateState(light_state);\n}\n}\n}", "CodeBleu_score": 39.676305821400526}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_mutex);\nstd::vector<LightState> light_states;\nif (_episode.Lock() != nullptr) {\n_episode.Lock()->QueryLightsStateToServer(&light_states);\n}\nfor (const LightState& light_state : light_states) {\nauto it = _lights.find(light_state.id());\nif (it == _lights.end()) {\n_lights.insert(std::make_pair(light_state.id(), Light(light_state)));\n} else {\nit->second.Update(light_state);\n}\n}\n}", "CodeBleu_score": 40.43082951952981}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t_lights.lock\n_lights_changes.lock\nif (_lights_changes.empty()) {\n_lights.unlock\n_lights_changes.unlock\nreturn\n}\n\nauto message = std::make_shared<messages::LightState>();\nmessage->set_type(messages::LightState::UPDATE);\n\nfor (auto& light : _lights_changes) {\nauto& light_state = message->add_light_states();\nlight_state.set_id(light.first);\nlight_state.set_color(light.second);\n}\n\n_lights_changes.clear();\n_lights.unlock\n_lights_changes.unlock\n\nif (discard_client) {\nmessage->set_discard_client(true);\n}\n\n_server_comm.Send(message);\n}", "CodeBleu_score": 34.23858420205139}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(_episode.Lock());\n\tif (_lights_changes.empty()) {\n\t\treturn;\n\t}\n\tauto message = std::make_shared<Message>();\n\tmessage->set_sender_id(_episode.GetServerId());\n\tmessage->set_recipient_id(kCoordinatorId);\n\tmessage->set_type(kMsgTypeUpdateLights);\n\tauto update_lights = message->mutable_update_lights();\n\tfor (auto& [light_id, light_change] : _lights_changes) {\n\t\tauto light = update_lights->add_lights();\n\t\tlight->set_id(light_id);\n\t\tlight->set_state(light_change.state);\n\t\tlight->set_color(light_change.color);\n\t}\n\t_lights_changes.clear();\n\t_lights_dirty = false;\n\t_episode.Send(message, discard_client);\n}", "CodeBleu_score": 42.51654233832504}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(lights_mutex_);\n\tif (lights_changes_.empty()) {\n\t\treturn;\n\t}\n\tstd::vector<Light> lights;\n\tfor (auto it = lights_changes_.begin(); it != lights_changes_.end(); it++) {\n\t\tlights.push_back(*it);\n\t}\n\tlights_changes_.clear();\n\tlights_dirty_ = false;\n\tstd::string message = \"lights: \";\n\tfor (auto it = lights.begin(); it != lights.end(); it++) {\n\t\tmessage += std::to_string(it->id) + \":\";\n\t\tmessage += std::to_string(it->x) + \",\" + std::to_string(it->y) + \",\" + std::to_string(it->z) + \":\";\n\t\tmessage += std::to_string(it->r) + \",\" + std::to_string(it->g) + \",\" + std::to_string(it->b) + \":\";\n\t\tmessage += std::to_string(it->intensity) + \":\";\n\t\tmessage += std::to_string(it->type) + \":\";\n\t\tmessage += std::to_string(it->radius) + \":\";\n\t\tmessage += std::to_string(it->falloff) + \":\";\n\t\tmessage += std::to_string(it->cast_shadows) + \":\";\n\t\tmessage += std::to_string(it->active) + \":\";\n\t\tmessage += std::to_string(it->lock_player) + \":\";\n\t\tmessage += std::to_string(it->lock_team) + \":\";\n\t\tmessage += std::to_string(it->lock_vehicle) + \":\";\n\t\tmessage += std::to_string(it->lock_object) + \":\";\n\t\tmessage += std::to_string(it->lock_room) + \":\";\n\t\tmessage += std::to_string(it->lock_pickups) + \":\";\n\t\tmessage += std::to_string(it->lock_pickups_in_vehicle) + \":\";\n\t\tmessage += std::to_string(it->lock_pickups_in_object) + \":\";\n\t\tmessage += std::to_string(", "CodeBleu_score": 35.31991679899846}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetSensorId() != \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"ServerSideSensor::Send: sensor ID is not 'sensor.other.v2x_custom' (is '{}')\", GetSensorId());\n\t\treturn;\n\t}\n\tGetEpisode().Lock()->Send(GetSensorContext(), message);\n}", "CodeBleu_score": 54.434736042009526}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetDisplayId() != \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"Sensor ID does not match.  Expected 'sensor.other.v2x_custom', got '{}'.\", GetDisplayId());\n\t\treturn;\n\t}\n\n\tauto episode = GetEpisode();\n\tepisode->Lock()->Send(GetContext(), message);\n}", "CodeBleu_score": 52.50560752171155}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->id() != \"sensor.other.v2x_custom\") {\n\t\tlog_warning(\"This sensor does not have the correct ID. Please check that the sensor is correctly configured in the blueprint.\");\n\t\treturn;\n\t}\n\tauto episode = GetEpisode();\n\tif (episode == nullptr) {\n\t\treturn;\n\t}\n\tauto sensor_context = GetContext();\n\tif (sensor_context == nullptr) {\n\t\treturn;\n\t}\n\tepisode->Lock()->Send(sensor_context, message);\n}", "CodeBleu_score": 49.03662389226502}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(this, tm_port);\n\t}\n\telse {\n\t\ttm.UnregisterVehicles(this);\n\t}\n}", "CodeBleu_score": 41.48126795325315}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicle(this, tm_port);\n\t} else {\n\t\ttm.UnregisterVehicle(this);\n\t}\n}", "CodeBleu_score": 41.057286307485775}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm.RegisterVehicles(this, tm_port);\n\t}\n\telse {\n\t\ttm.UnregisterVehicles(this);\n\t}\n}", "CodeBleu_score": 41.48126795325315}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\n\t// Get the pawn being controlled.\n\tAPawn* Pawn = GetPawn();\n\tif (!Pawn) {\n\t\treturn;\n\t}\n\n\t// Get the walker from the controlled pawn.\n\tWalker* Walker = Cast<Walker>(Pawn);\n\tif (!Walker) {\n\t\treturn;\n\t}\n\n\t// Get the AI controller for the walker.\n\tWalkerAIController* AIController = Cast<WalkerAIController>(Walker->GetController());\n\tif (!AIController) {\n\t\treturn;\n\t}\n\n\t// Get the AI controller's navigation system.\n\tUNavigationSystemV1* NavSys = AIController->GetNavSystem();\n\tif (!NavSys) {\n\t\treturn;\n\t}\n\n\t// Add the walker to the navigation system.\n\tNavSys->AddNavAgent(Walker);\n\n\t// Disable physics simulation and collision for the walker.\n\tWalker->SetActorSimulatePhysics(false);\n\tWalker->SetActorEnableCollision(false);\n}", "CodeBleu_score": 33.871285694888684}, {"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\n\tauto walker = GetPawn();\n\tif (!walker) {\n\t\treturn;\n\t}\n\n\tauto episode = GetEpisode();\n\tif (!episode) {\n\t\treturn;\n\t}\n\n\tepisode->Lock()->AddActor(walker);\n\tepisode->Lock()->SetActorLocation(walker->GetActorLocation());\n\tepisode->Lock()->SetActorCollisions(walker, false);\n\tepisode->Lock()->SetActorSimulatePhysics(walker, false);\n}", "CodeBleu_score": 46.3654930162347}, {"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\n\t// Get the pawn being controlled.\n\tAPawn* Pawn = GetPawn();\n\tif (!Pawn) {\n\t\treturn;\n\t}\n\n\t// Get the walker from the pawn.\n\tWalker* Walker = Cast<Walker>(Pawn);\n\tif (!Walker) {\n\t\treturn;\n\t}\n\n\t// Get the AI controller for the pawn.\n\tWalkerAIController* AIController = Cast<WalkerAIController>(Pawn->GetController());\n\tif (!AIController) {\n\t\treturn;\n\t}\n\n\t// Get the AI controller's navigation system.\n\tUNavigationSystemV1* NavSys = AIController->GetNavigationSystemV1();\n\tif (!NavSys) {\n\t\treturn;\n\t}\n\n\t// Add the walker to the navigation system.\n\tNavSys->AddNavData(Walker);\n\n\t// Disable physics simulation and collisions for the walker.\n\tWalker->SetActorSimulatePhysics(false);\n\tWalker->SetActorEnableCollision(false);\n}", "CodeBleu_score": 35.73710928759507}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\t// Get the navigation instance from the current episode\n\tauto nav = GetEpisode().Lock()->GetNavigation();\n\tif (!nav) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to retrieve the navigation instance from the current episode\");\n\t\treturn;\n\t}\n\t// Get the parent walker\n\tauto walker = GetParent();\n\tif (!walker) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to retrieve the parent walker\");\n\t\treturn;\n\t}\n\t// Set the maximum speed\n\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\tlog_warning(\"WalkerAIController::SetMaxSpeed: Failed to set the maximum speed for the walker\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 56.53483547265634}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (m_pEpisode) {\n\t\tboost::shared_ptr<Navigation> nav = m_pEpisode->GetNavigation();\n\t\tif (nav) {\n\t\t\tboost::shared_ptr<Walker> walker = m_pEpisode->GetWalker(m_id);\n\t\t\tif (walker) {\n\t\t\t\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\t\t\tlog_warning(\"Failed to set the maximum speed of walker %d.\", m_id);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_warning(\"Walker %d not found.\", m_id);\n\t\t\t}\n\t\t} else {\n\t\t\tlog_warning(\"Navigation not found.\");\n\t\t}\n\t} else {\n\t\tlog_warning(\"Episode not found.\");\n\t}\n}", "CodeBleu_score": 48.77670539483269}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tIAIObject* ai_object = GetParent();\n\tif (ai_object) {\n\t\tIAIActor* ai_actor = CastToIAIActorSafe(ai_object);\n\t\tif (ai_actor) {\n\t\t\tIAICharacter* ai_character = CastToIAICharacterSafe(ai_object);\n\t\t\tif (ai_character) {\n\t\t\t\tIAIActor* ai_actor = ai_character->GetAIActor();\n\t\t\t\tif (ai_actor) {\n\t\t\t\t\tIAIObject* ai_object = ai_actor->GetParent();\n\t\t\t\t\tif (ai_object) {\n\t\t\t\t\t\tIAIEpisode* ai_episode = ai_object->GetAIEpisode();\n\t\t\t\t\t\tif (ai_episode) {\n\t\t\t\t\t\t\tIAIObject* ai_object = ai_episode->GetAIObject(AIOBJECT_NAVIGATION);\n\t\t\t\t\t\t\tif (ai_object) {\n\t\t\t\t\t\t\t\tIAIObject* ai_object = ai_object->GetParent();\n\t\t\t\t\t\t\t\tif (ai_object) {\n\t\t\t\t\t\t\t\t\tIAIActor* ai_actor = CastToIAIActorSafe(ai_object);\n\t\t\t\t\t\t\t\t\tif (ai_actor) {\n\t\t\t\t\t\t\t\t\t\tIAICharacter* ai_character = CastToIAICharacterSafe(ai_object);\n\t\t\t\t\t\t\t\t\t\tif (ai_character) {\n\t\t\t\t\t\t\t\t\t\t\tIAIActor* ai_actor = ai_character->GetAIActor();\n\t\t\t\t\t\t\t\t\t\t\tif (ai_actor) {\n\t\t\t\t\t\t\t\t\t\t\t\tIAIObject* ai_object = ai_actor->GetParent();\n\t\t\t\t\t\t\t\t\t\t\t\tif (ai_object) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tIAIEpisode* ai_episode = ai_object->GetAIEpisode();\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (ai_episode) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIAIObject* ai_object = ai_episode->GetAIObject(AIOBJECT_NAVIGATION);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (ai_object) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIAIObject* ai_object = ai_object->GetParent();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (ai_object) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIAIActor* ai_actor = CastToIAIActorSafe(ai_object);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (ai_actor) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIAICharacter* ai_character = CastToIAICharacterSafe(ai_object);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (ai_character) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIAIActor* ai_actor = ai_character->GetAIActor();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (ai_actor) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tI", "CodeBleu_score": 34.07862709346998}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(distance / _parent->GetMap().GetResolution());\n\tdouble dist = 0;\n\tfor (auto it = _parent->GetMap().GetWaypoints().rbegin(); it != _parent->GetMap().GetWaypoints().rend(); ++it) {\n\t\tdist += (*it)->GetDistance();\n\t\tif (dist > distance) {\n\t\t\tbreak;\n\t\t}\n\t\tresult.emplace_back(*it);\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.98158038935584}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tresult.reserve(distance / _parent->GetMap().GetResolution());\n\tfor (double d = 0; d < distance; d += _parent->GetMap().GetResolution()) {\n\t\tresult.emplace_back(std::move(_parent->GetMap().GetPrevious(GetLocation(), d)));\n\t}\n\treturn result;\n}", "CodeBleu_score": 53.640232940367795}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<Waypoint*> waypoints;\n_parent->GetMap().GetPrevious(GetLocation(), distance, waypoints);\nstd::vector<SharedPtr<Waypoint>> result;\nfor (auto waypoint : waypoints) {\nresult.emplace_back(std::make_shared<Waypoint>(waypoint, _parent));\n}\nreturn result;\n}", "CodeBleu_score": 61.50951371616857}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n\nfor (auto&& signal : GetSignalsInDistance(distance, stop_at_junction)) {\n  if (signal->GetParent() == nullptr) {\n    continue;\n  }\n\n  auto&& landmark = std::make_shared<Landmark>(signal->GetParent());\n  if (result.empty() || result.back()->GetLandmarkId() != landmark->GetLandmarkId()) {\n    result.emplace_back(landmark);\n  }\n}\n\nreturn result;\n}", "CodeBleu_score": 36.88555115656843}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nstd::vector<SharedPtr<Waypoint>> added_signals;\nfor (auto& signal : GetSignalsInDistance(distance, stop_at_junction)) {\nif (added_signals.count(signal) == 0) {\nresult.emplace_back(std::make_shared<Landmark>(signal->GetTransform()));\nresult.back()->SetWaypoint(signal);\nadded_signals.emplace_back(signal);\n}\n}\nreturn result;\n}", "CodeBleu_score": 36.7897377475039}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\nfor (auto& signal : GetSignalsInDistance(distance, stop_at_junction)) {\nif (result.count(signal) == 0) {\nresult.emplace_back(std::make_shared<Landmark>(signal));\n}\n}\nreturn result;\n}", "CodeBleu_score": 26.964759868650823}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tuint64_t settings_id = _episode.Lock()->GetSettingsId();", "CodeBleu_score": 8.796058789293536}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tuint64_t settings_id = _next_settings_id++;", "CodeBleu_score": 3.6989668925662764}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tuint64_t settings_id = 0;", "CodeBleu_score": 4.237408323321209}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat sqr_length = Dot2D(segment_end - segment_start, segment_end - segment_start);\n\tfloat length = std::sqrt(sqr_length);\n\tif (length == 0.0f) {\n\t\treturn std::make_pair(0.0f, Distance2D(point, segment_start));\n\t}\n\tfloat t = Dot2D(point - segment_start, segment_end - segment_start) / sqr_length;\n\tif (t < 0.0f) {\n\t\treturn std::make_pair(Distance2D(point, segment_start), 0.0f);\n\t}\n\tif (t > 1.0f) {\n\t\treturn std::make_pair(Distance2D(point, segment_end), 0.0f);\n\t}\n\treturn std::make_pair(length * std::sqrt(1.0f - t * t), Distance2D(point, segment_start + t * (segment_end - segment_start)));\n}", "CodeBleu_score": 43.96267456834177}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segmentLengthSquared = DistanceSquared2D(segmentEnd - segmentStart);\n\tfloat segmentLength = std::sqrt(segmentLengthSquared);\n\tif (segmentLength == 0.0f) {\n\t\treturn std::make_pair(0.0f, Distance2D(point, segmentStart));\n\t}\n\tVector2D segmentDirection = (segmentEnd - segmentStart) / segmentLength;\n\tVector2D pointToSegmentStart = point - segmentStart;\n\tfloat projection = Dot2D(pointToSegmentStart, segmentDirection);\n\tVector2D clampedProjection = Clamp(projection, 0.0f, segmentLength);\n\tVector2D closestPointOnSegment = segmentStart + clampedProjection * segmentDirection;\n\treturn std::make_pair(Distance2D(point, closestPointOnSegment), Distance2D(point, closestPointOnSegment));\n}", "CodeBleu_score": 41.968914623584716}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segmentLengthSquared = LengthSquared2D(segmentEnd - segmentStart);\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn std::make_pair(0.0f, Distance2D(point, segmentStart));\n\t}\n\tfloat segmentLength = std::sqrt(segmentLengthSquared);\n\tfloat segmentProjection = Dot2D(point - segmentStart, segmentEnd - segmentStart) / segmentLengthSquared;\n\tsegmentProjection = Clamp(segmentProjection, 0.0f, segmentLength);\n\tVector2 segmentProjectionPoint = segmentStart + segmentProjection * (segmentEnd - segmentStart);\n\treturn std::make_pair(segmentProjection, Distance2D(point, segmentProjectionPoint));\n}", "CodeBleu_score": 42.6429670272551}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t DEBUG_ASSERT(vertices.size() > 2);\n AddIndex(vertices.size() - 2);\n for (std::vector<Mesh::vertex_type>::const_iterator it = vertices.begin() + 1; it != vertices.end(); ++it) {\n AddVertices(1, *it);\n AddIndex(vertices.size() - std::distance(vertices.begin(), it));\n }\n }", "CodeBleu_score": 35.72615623278464}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t DEBUG_ASSERT(vertices.size() >= 3);\n const auto index = AddVertices(vertices);\n for (auto i = 0u; i < vertices.size() - 2; ++i) {\n AddIndex(index + i);\n AddIndex(index + i + 1);\n AddIndex(index + i + 2);\n }\n }", "CodeBleu_score": 48.98841376994761}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t DEBUG_ASSERT(vertices.size() >= 3);\n const auto initial_index = vertices_.size();\n vertices_.insert(vertices_.end(), vertices.begin(), vertices.end());\n for (std::size_t i = 2; i < vertices.size(); ++i) {\n AddIndex(initial_index);\n AddIndex(initial_index + i - 1);\n AddIndex(initial_index + i);\n }\n }", "CodeBleu_score": 59.09567715248303}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tDEBUG_ASSERT(message);\n\tDEBUG_ASSERT(!message->empty());\n\tDEBUG_ASSERT(self->_socket.is_open());\n\tDEBUG_ASSERT(!self->_deadline.expires_from_now().is_negative());\n\tDEBUG_ASSERT(self->_strand.running_in_this_thread());\n\n\tboost::asio::post(\n\t\tself->_strand, [self, message]() {\n\t\t\tboost::system::error_code ec;\n\n\t\t\tif (!self->_socket.is_open()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tself->_deadline.expires_from_now(boost::posix_time::seconds(1));\n\n\t\t\tboost::asio::async_write(\n\t\t\t\tself->_socket,\n\t\t\t\tmessage->GetBufferSequence(),\n\t\t\t\tboost::asio::bind_executor(\n\t\t\t\t\tself->_strand,\n\t\t\t\t\tstd::bind(\n\t\t\t\t\t\t&Primary::handle_sent,\n\t\t\t\t\t\tself,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tstd::placeholders::_1,\n\t\t\t\t\t\tstd::placeholders::_2)));\n\t\t});\n}", "CodeBleu_score": 36.27065669124222}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message);\nDEBUG_ASSERT(!message->empty());\nDEBUG_ASSERT(self->_socket.is_open());\n\nboost::asio::async_write(self->_socket, message->GetBufferSequence(),\nboost::asio::bind_executor(self->_strand,\n[weak_self = self->weak_from_this(), message = std::move(message)](const boost::system::error_code &ec, std::size_t) {\nauto self = weak_self.lock();\nif (!self) {\nreturn;\n}\n\nif (ec) {\nself->log_error(\"Failed to send message: {}\", ec.message());\nself->CloseNow();\nreturn;\n}\n\nDEBUG_ASSERT(message->empty());\n}\n));\n\n}", "CodeBleu_score": 41.11887136122244}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tDEBUG_ASSERT(message != nullptr);\nDEBUG_ASSERT(message->empty() == false);\n\nboost::asio::post(\nself->_strand, [this, message]() {\nif (self->_socket.is_open()) {\nself->_deadline.expires_from_now(boost::posix_time::seconds(10));\nself->_deadline.async_wait(boost::bind(&Primary::HandleTimeout, self, boost::asio::placeholders::error));\nboost::asio::async_write(\nself->_socket,\nmessage->GetBufferSequence(),\nboost::bind(&Primary::HandleSent, self, message, boost::asio::placeholders::error));\n} else {\nlog_error(\"Socket closed, cannot write\");\nself->CloseNow();\n}\n});\n}", "CodeBleu_score": 36.87144890434831}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_deadline.cancel();\nif (!ec && _socket.is_open()) {\nboost::system::error_code ignored_ec;\n_socket.shutdown(tcp::socket::shutdown_both, ignored_ec);\n_socket.close(ignored_ec);\n}\n_on_closed(ec);\nlog_debug(\"Session closed\");\n}", "CodeBleu_score": 54.90650829400945}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t_deadline.cancel();\nif (!ec && _socket.is_open()) {\n_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n_socket.close(ec);\n}\n_on_closed(ec);\nlog_debug(\"session closed\");\n}", "CodeBleu_score": 45.672315853485756}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (!ec) {\n_deadline.cancel();\nif (_socket.is_open()) {\n_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\nif (!ec) {\n_socket.close(ec);\n}\n}\n}\nif (_on_closed) {\n_on_closed();\n}\nlog_debug(\"session closed\");\n}", "CodeBleu_score": 58.078421050793196}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create the message\n\tstd::string message = \"Are you alive?\";\n\n\t// Log the sending action\n\tLOG_INFO(\"Sending message: %s\", message.c_str());\n\n\t// Create a buffer from the message\n\tauto buffer = std::make_shared<MessageBuffer>(message.c_str(), message.size());\n\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\t_router->WriteToNext(buffer, Commands::YOU_ALIVE);\n\n\t// Wait for and log the response from the system\n\tauto response = _router->ReadFromPrevious(Commands::YOU_ALIVE);\n\tLOG_INFO(\"Received message: %s\", response.buffer.data);\n}", "CodeBleu_score": 50.09075405037824}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tauto buffer = Buffer(std::string(\"Are you alive?\"));\n\t// Log the sending action\n\tlog_info(\"Sending I am alive\");\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\t_router->WriteToNext(buffer, YOU_ALIVE);\n\t// Wait for and log the response from the system\n\tauto response = _router->ReadFromPrevious(std::chrono::seconds(5));\n\tlog_info(\"Received: \" + response.buffer.data);\n}", "CodeBleu_score": 42.38602686590981}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer to send to the next router with the command YOU_ALIVE\n\tauto buffer = std::make_shared<Buffer>(Buffer(std::string(\"Are you alive?\")));\n\t// Log the sending action\n\tLOG4CXX_INFO(logger_, \"Sending \" << buffer->data << \" to next router\");\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\t_router->WriteToNext(Command::YOU_ALIVE, buffer);\n\t// Wait for and log the response from the system\n\tauto response = _router->ReadFromPrev(Command::YOU_ALIVE);\n\tLOG4CXX_INFO(logger_, \"Received \" << response.data << \" from previous router\");\n}", "CodeBleu_score": 45.719484608049115}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tauto fut = std::async(std::launch::async, [this, sensor_id](){\n\t\tstd::unique_lock<std::mutex> lock(_servers_mutex);\n\t\tauto it = _servers.find(sensor_id);\n\t\tif (it == _servers.end()) {\n\t\t\tLOG_ERROR(\"Sensor %d not found on any server.\", sensor_id);\n\t\t\treturn;\n\t\t}\n\t\tlock.unlock();\n\t\tauto& server = it->second;\n\t\tauto buffer = std::make_shared<Buffer>(sizeof(int32_t));\n\t\tauto ptr = reinterpret_cast<int32_t*>(buffer->data());\n\t\t*ptr = sensor_id;\n\t\tauto fut = server.router->WriteToOne(server.id, std::move(buffer));\n\t\tfut.get();\n\t\tserver.router->Read(std::move(fut));\n\t});\n\tfut.get();\n}", "CodeBleu_score": 55.470500897496734}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\n/*\n * The following variables are used to check if the sensor is found on any secondary server.\n */", "CodeBleu_score": 2.3731958406911615}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tauto fut = _router->WriteToOne(sensor_id, ENABLE_ROS);\nauto response = fut.get();\nif (response.type == ResponseType::ERROR) {\nlog_error(\"Error enabling ROS for sensor %d on secondary server %d\", sensor_id, response.server_id);\nreturn;\n}\n}", "CodeBleu_score": 28.98807759235298}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\n}", "CodeBleu_score": 1.558723446821436}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\t// Check if the sensor is already activated.\n\tauto it = _tokens.find(sensor_id);\n\tif (it != _tokens.end()) {\n\t\t// The sensor is already activated.\n\t\ttoken_type token = it->second;\n\t\tLOG_DEBUG(\"Sensor %d is already activated, returning token %d\", sensor_id, token.get_stream_id());\n\t\treturn token;\n\t}\n\n\t// The sensor is not activated.\n\tLOG_DEBUG(\"Sensor %d is not activated, enabling sensor on secondary server\", sensor_id);\n\t// Enable the sensor on a secondary server.\n\tauto server_it = _router->GetNextServer();\n\tif (server_it == _router->end()) {\n\t\tLOG_ERROR(\"No secondary server available\");\n\t\treturn token_type();\n\t}\n\tserver_id server_id = server_it->second.get_server_id();\n\tif (!server_it->second.get_is_enabled()) {\n\t\tserver_it->second.set_is_enabled(true);\n\t}\n\t// Retrieve a new token.\n\ttoken_type token = GetTokenFromSecondary(server_id);\n\tif (!token.get_stream_id()) {\n\t\tLOG_ERROR(\"Failed to get token from secondary server %d\", server_id);\n\t\treturn token_type();\n\t}\n\t// Update the maps.\n\t_tokens[sensor_id] = token;\n\tserver_it->second.AddToken(token);\n\t// Log the action.\n\tLOG_DEBUG(\"Enabled sensor %d on secondary server %d, token %d\", sensor_id, server_id, token.get_stream_id());\n\treturn token;\n}", "CodeBleu_score": 58.13659553164609}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t_mutex.lock\n_tokens.find\n_router->GetNextServer\nSendEnableSensor\n_tokens.end\nit->second.get_port\ntoken.get_port\nit->second.get_stream_id\nlog_debug\n_tokens.end\nit->second.get_stream_id\n\n_mutex.unlock\nreturn token\n}", "CodeBleu_score": 21.323124764991398}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f(filename, std::ios::binary);\n\tif (!f.is_open()) return false;\n\tstd::vector<char> data;\n\tf.seekg(0, std::ios::end);\n\tdata.resize(f.tellg());\n\tf.seekg(0, std::ios::beg);\n\tf.read(&data[0], data.size());\n\tf.close();\n\treturn Load(&data[0], data.size());\n}", "CodeBleu_score": 50.128203717123945}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\t// Open the file\n\tstd::ifstream f;\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\n\t// Read the file\n\tstd::vector<char> data;\n\tf.seekg(0, std::ios::end);\n\tdata.resize(f.tellg());\n\tf.seekg(0, std::ios::beg);\n\tf.read(data.data(), data.size());\n\tf.close();\n\n\t// Parse the file\n\treturn Load(data);\n}", "CodeBleu_score": 66.87774406662021}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tf.open(filename, std::ios::in | std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<unsigned char> fileData(\n\t\t(std::istreambuf_iterator<char>(f)),\n\t\t(std::istreambuf_iterator<char>()));\n\tf.close();\n\treturn Load(fileData);\n}", "CodeBleu_score": 63.75839884555698}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(m_ready);\n\tDEBUG_ASSERT(m_crowd);\n\n\t// Find the agent in the walker and vehicle mappings.\n\tauto walker_it = _mapped_walkers_id.find(id);\n\tauto vehicle_it = _mapped_vehicles_id.find(id);\n\n\t// If the agent is not in the mappings, return false.\n\tif (walker_it == _mapped_walkers_id.end() && vehicle_it == _mapped_vehicles_id.end()) {\n\t\treturn false;\n\t}\n\n\t// Enter a critical section to safely remove the agent from the crowd.\n\tScopedLock lock(m_lock);\n\n\t// Remove the agent from the crowd.\n\tif (walker_it != _mapped_walkers_id.end()) {\n\t\t_walker_manager.RemoveWalker(walker_it->second);\n\t\t_mapped_walkers_id.erase(walker_it);\n\t} else if (vehicle_it != _mapped_vehicles_id.end()) {\n\t\t_crowd->removeAgent(vehicle_it->second);\n\t\t_mapped_vehicles_id.erase(vehicle_it);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.65036803614966}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tDEBUG_ASSERT(_crowd);\n\tDEBUG_ASSERT(_ready);\n\n\t// First, check if the agent is a vehicle\n\tauto it = _mapped_vehicles_id.find(id);\n\tif (it != _mapped_vehicles_id.end()) {\n\t\t// Remove the agent from the crowd\n\t\t_crowd->removeAgent(it->second);\n\t\t// Remove the agent from the vehicle manager\n\t\t_vehicle_manager.RemoveVehicle(it->second);\n\t\t// Remove the agent from the mapping\n\t\t_mapped_vehicles_id.erase(it);\n\t\treturn true;\n\t}\n\n\t// If not, check if the agent is a walker\n\tit = _mapped_walkers_id.find(id);\n\tif (it != _mapped_walkers_id.end()) {\n\t\t// Remove the agent from the crowd\n\t\t_crowd->removeAgent(it->second);\n\t\t// Remove the agent from the walker manager\n\t\t_walker_manager.RemoveWalker(it->second);\n\t\t// Remove the agent from the mapping\n\t\t_mapped_walkers_id.erase(it);\n\t\treturn true;\n\t}\n\n\t// If not found, return false\n\treturn false;\n}", "CodeBleu_score": 54.203007143581694}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tDEBUG_ASSERT(_crowd);\n\n// find the agent in the vehicle and walker mappings\nauto it_vehicles = _mapped_vehicles_id.find(id);\nauto it_walkers = _mapped_walkers_id.find(id);\n\n// if the agent is found in the vehicle or walker mappings, remove the agent from the crowd\nif (it_vehicles != _mapped_vehicles_id.end()) {\n_crowd->removeAgent(it_vehicles->second);\n_mapped_by_index.erase(it_vehicles->second);\n_mapped_vehicles_id.erase(it_vehicles);\n} else if (it_walkers != _mapped_walkers_id.end()) {\n_crowd->removeAgent(it_walkers->second);\n_walker_manager.RemoveWalker(it_walkers->second);\n_mapped_walkers_id.erase(it_walkers);\n} else {\nreturn false;\n}\n\nreturn true;\n}", "CodeBleu_score": 49.317721322778276}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\\tstd::set<int> current_vehicles;\n\\tfor (auto &kv : vehicle_map) {\n\\t\\tcurrent_vehicles.insert(kv.first);\n\\t}\n\\tfor (auto &v : vehicles) {\n\\t\\tif (current_vehicles.count(v.id) == 0) {\n\\t\\t\\tAddOrUpdateVehicle(v);\n\\t\\t} else {\n\\t\\t\\tupdated.insert(v.id);\n\\t\\t}\n\\t}\n\\tfor (auto &kv : vehicle_map) {\n\\t\\tif (updated.count(kv.first) == 0) {\n\\t\\t\\tRemoveAgent(kv.first);\n\\t\\t}\n\\t}\n\\treturn true;\n}", "CodeBleu_score": 34.86586419233382}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\nstd::set<int> vehicle_ids;\nfor (auto vehicle : vehicles_) {\nvehicle_ids.insert(vehicle.id);\n}\n\nfor (auto vehicle : vehicles) {\nif (vehicle_ids.count(vehicle.id)) {\nvehicles_.at(vehicle.id).Update(vehicle);\n} else {\nvehicles_.emplace_back(vehicle);\n}\n}\n\nfor (auto vehicle_id : vehicle_ids) {\nif (std::find_if(vehicles.begin(), vehicles.end(), [vehicle_id](const VehicleCollisionInfo& vehicle) {\nreturn vehicle_id == vehicle.id;\n}) == vehicles.end()) {\nvehicles_.erase(vehicle_id);\n}\n}\n\nreturn true;\n}", "CodeBleu_score": 51.22901974346297}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\\tstd::set<int> current_vehicles;\n\\tfor (const auto &vehicle : vehicles) {\n\\t\\tcurrent_vehicles.insert(vehicle.id);\n\\t}\n\n\\tfor (const auto &vehicle : vehicles) {\n\\t\\t// Check if vehicle is already mapped\n\\t\\tif (vehicles_.find(vehicle.id) == vehicles_.end()) {\n\\t\\t\\t// Vehicle is not mapped, add it\n\\t\\t\\tAddOrUpdateVehicle(vehicle);\n\\t\\t} else {\n\\t\\t\\t// Vehicle is mapped, update it\n\\t\\t\\tAddOrUpdateVehicle(vehicle, true);\n\\t\\t}\n\\t}\n\n\\tfor (auto it = vehicles_.begin(); it != vehicles_.end();) {\n\\t\\tint vehicle_id = it->first;\n\\t\\t// Check if vehicle is still active\n\\t\\tif (current_vehicles.find(vehicle_id) == current_vehicles.end()) {\n\\t\\t\\t// Vehicle is not active, remove it\n\\t\\t\\tRemoveAgent(vehicle_id);\n\\t\\t} else {\n\\t\\t\\t// Vehicle is active, update it\n\\t\\t\\tAddOrUpdateVehicle(it->second, true);\n\\t\\t}\n\\t}\n\n\\treturn true;\n}", "CodeBleu_score": 32.386835816213285}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tif (auto *walker = _mapped_walkers_id.find(id)) {\n\t\tauto location = walker->get_location();\n\t\treturn _crowd->hasVehicleNear(location, distance, direction);\n\t}\n\telse if (auto *vehicle = _mapped_vehicles_id.find(id)) {\n\t\tauto location = vehicle->get_location();\n\t\treturn _crowd->hasVehicleNear(location, distance, direction);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 43.59668059930824}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// Check if the actor is a vehicle or a walker.\n\tif (auto walker = _mapped_walkers_id.find(id); walker != _mapped_walkers_id.end()) {\n\t\t// Check if the walker is in the crowd.\n\t\tif (auto crowd = _crowd.get(); crowd) {\n\t\t\treturn crowd->hasVehicleNear(walker->second, distance, direction);\n\t\t}\n\t}\n\telse if (auto vehicle = _mapped_vehicles_id.find(id); vehicle != _mapped_vehicles_id.end()) {\n\t\t// Check if the vehicle is in the crowd.\n\t\tif (auto crowd = _crowd.get(); crowd) {\n\t\t\treturn crowd->hasVehicleNear(vehicle->second, distance, direction);\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 49.78611044326735}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tauto *walker = _mapped_walkers_id.find(id);\n\tif (walker != _mapped_walkers_id.end()) {\n\t\treturn _crowd->hasVehicleNear(walker->second, distance, direction);\n\t}\n\tauto *vehicle = _mapped_vehicles_id.find(id);\n\tif (vehicle != _mapped_vehicles_id.end()) {\n\t\treturn _crowd->hasVehicleNear(vehicle->second, distance, direction);\n\t}\n\treturn false;\n}", "CodeBleu_score": 48.73655065852035}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Get the route point for the walker\n\tRoutePoint &routePoint = info.route.GetCurrentRoutePoint();\n\n\t// Create the visitor\n\tWalkerEventVisitor visitor(info, delta);\n\n\t// Visit the route point\n\treturn boost::variant2::visit(visitor, routePoint);\n}", "CodeBleu_score": 45.425021119787225}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Get the route point for the walker\n\tRoutePoint routePoint = info.GetRoutePoint();\n\t// Create a WalkerEventVisitor with the current context\n\tWalkerEventVisitor visitor(this, id, routePoint);\n\t// Process the event at the current route point using boost::variant2::visit\n\tEventResult result = boost::variant2::visit(visitor, info.event);\n\t// Return the result of the event execution\n\treturn result;\n}", "CodeBleu_score": 60.11320524638927}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto &walker = m_walkers[id];\n\tauto &route = walker.route;\n\tauto &event = route.events[route.current];\n\tauto &context = info.context;\n\tauto &current = route.points[route.current];\n\tauto &next = route.points[route.current + 1];\n\tauto &result = context.result;\n\tauto &eventVisitor = context.eventVisitor;\n\tauto &eventExecutor = context.eventExecutor;\n\tauto &eventExecutor2 = context.eventExecutor2;\n\tauto &eventExecutor3 = context.eventExecutor3;\n\tauto &eventExecutor4 = context.eventExecutor4;\n\tauto &eventExecutor5 = context.eventExecutor5;\n\tauto &eventExecutor6 = context.eventExecutor6;\n\tauto &eventExecutor7 = context.eventExecutor7;\n\tauto &eventExecutor8 = context.eventExecutor8;\n\tauto &eventExecutor9 = context.eventExecutor9;\n\tauto &eventExecutor10 = context.eventExecutor10;\n\tauto &eventExecutor11 = context.eventExecutor11;\n\tauto &eventExecutor12 = context.eventExecutor12;\n\tauto &eventExecutor13 = context.eventExecutor13;\n\tauto &eventExecutor14 = context.eventExecutor14;\n\tauto &eventExecutor15 = context.eventExecutor15;\n\tauto &eventExecutor16 = context.eventExecutor16;\n\tauto &eventExecutor17 = context.eventExecutor17;\n\tauto &eventExecutor18 = context.eventExecutor18;\n\tauto &eventExecutor19 = context.eventExecutor19;\n\tauto &eventExecutor20 = context.eventExecutor20;\n\tauto &eventExecutor21 = context.eventExecutor21;\n\tauto &eventExecutor22 = context.eventExecutor22;\n\tauto &eventExecutor23 = context.eventExecutor23;\n\tauto &eventExecutor24 = context.eventExecutor24;\n\tauto &eventExecutor25 = context.eventExecutor25;\n\tauto &eventExecutor26 = context.eventExecutor26;\n\tauto &eventExecutor27 = context.eventExecutor27;", "CodeBleu_score": 38.569972067170724}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node\nfor (const pugi::xml_node &road_node : xml.child(\"OpenDRIVE\").child(\"roads\").children(\"road\")) {\n\n// Extract the road ID\nuint32_t road_id = road_node.attribute(\"id\").as_uint();\n\n// Iterate through each lane section node\nfor (const pugi::xml_node &lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n\n// Get the left, center, and right lane nodes\nconst pugi::xml_node &left_lanes_node = lane_section_node.child(\"left\");\nconst pugi::xml_node &center_lanes_node = lane_section_node.child(\"center\");\nconst pugi::xml_node &right_lanes_node = lane_section_node.child(\"right\");\n\n// Parse the lane data\nParseLanes(left_lanes_node, center_lanes_node, right_lanes_node, map_builder);\n}\n}\n}", "CodeBleu_score": 41.32705512058112}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node in the OpenDRIVE document\nfor (const pugi::xml_node &road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\n// Extract the road ID\nconst std::string road_id = road_node.attribute(\"id\").value();\n\n// Iterate through each lane section node in the road node\nfor (const pugi::xml_node &lane_section_node : road_node.children(\"laneSection\")) {\n\n// Iterate through each lane node in the lane section node\nfor (const pugi::xml_node &lane_node : lane_section_node.children(\"lane\")) {\n\n// Parse the lane data\nParseLane(lane_node, map_builder, road_id);\n}\n}\n}\n}", "CodeBleu_score": 29.179739747312617}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\nfor (auto road_node : xml.child(\"OpenDRIVE\").child(\"roads\").children(\"road\")) {\n\nauto road_id = road_node.attribute(\"id\").as_uint();\n\nfor (auto lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n\nauto left_lanes = lane_section_node.child(\"left\").children(\"lane\");\nauto center_lanes = lane_section_node.child(\"center\").children(\"lane\");\nauto right_lanes = lane_section_node.child(\"right\").children(\"lane\");\n\nParseLanes(left_lanes, map_builder, road_id);\nParseLanes(center_lanes, map_builder, road_id);\nParseLanes(right_lanes, map_builder, road_id);\n}\n}\n}", "CodeBleu_score": 43.231022769922404}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (info.total_count_change == 1) {\n\t\tif (info.current_count == 1) {\n\t\t\tmatched_ = true;\n\t\t\tmatched_count_ = info.total_count;\n\t\t\tfirst_connection_ = true;\n\t\t\tlog_debug(\"New match found!\");\n\t\t} else {\n\t\t\tlog_error(\"New match lost!\");\n\t\t}\n\t} else if (info.total_count_change == -1) {\n\t\tif (info.current_count == 0) {\n\t\t\tmatched_ = false;\n\t\t\tmatched_count_ = info.total_count;\n\t\t\tlog_debug(\"Match lost!\");\n\t\t} else {\n\t\t\tlog_error(\"Match invalid!\");\n\t\t}\n\t} else {\n\t\tlog_error(\"Match invalid!\");\n\t}\n}", "CodeBleu_score": 53.67437725299086}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Check if the writer is the writer of the first connection.\n\tif (info.guid_prefix == first_connection_guid_prefix) {\n\t\t// If the writer is the writer of the first connection, check if the status is MATCHED.\n\t\tif (info.status == efd::MATCHED_MATCHING) {\n\t\t\t// If the status is MATCHED, set the matched count and mark the first connection as matched.\n\t\t\tmatched_count = info.total_count;\n\t\t\tis_first_connection_matched = true;\n\t\t} else if (info.status == efd::MATCHED_REMOVED) {\n\t\t\t// If the status is REMOVED, set the matched count to zero and mark the first connection as not matched.\n\t\t\tmatched_count = 0;\n\t\t\tis_first_connection_matched = false;\n\t\t} else {\n\t\t\t// If the status is not MATCHED or REMOVED, log an error message.\n\t\t\tROS_ERROR_STREAM(\"Received invalid status on first connection: \" << info.status);\n\t\t}\n\t} else {\n\t\t// If the writer is not the writer of the first connection, check if the status is MATCHED.\n\t\tif (info.status == efd::MATCHED_MATCHING) {\n\t\t\t// If the status is MATCHED, increment the matched count.\n\t\t\tmatched_count++;\n\t\t} else if (info.status == efd::MATCHED_REMOVED) {\n\t\t\t// If the status is REMOVED, decrement the matched count.\n\t\t\tmatched_count--;\n\t\t} else {\n\t\t\t// If the status is not MATCHED or REMOVED, log an error message.\n\t\t\tROS_ERROR_STREAM(\"Received invalid status on other connection: \" << info.status);\n\t\t}\n\t}\n}", "CodeBleu_score": 50.57196688734169}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\t// Check if the writer is the listener's writer\n\tif (writer != _writer) {\n\t\treturn;\n\t}\n\n\t// Check if the status is valid\n\tif (info.total_count == info.total_count_change) {\n\t\treturn;\n\t}\n\n\t// Check if there are any matches\n\tif (info.total_count > 0) {\n\t\t// Check if there is no connection\n\t\tif (_matched_count == 0) {\n\t\t\t_first_connection = true;\n\t\t}\n\n\t\t// Increment the matched count\n\t\t_matched_count += info.total_count_change;\n\t} else {\n\t\t// Check if the matched count is greater than zero\n\t\tif (_matched_count > 0) {\n\t\t\t// Decrement the matched count\n\t\t\t_matched_count -= info.total_count_change;\n\n\t\t\t// Check if there are no more matches\n\t\t\tif (_matched_count == 0) {\n\t\t\t\t_first_connection = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if the matched count is greater than the maximum\n\tif (_matched_count > _max_matched_count) {\n\t\t// Log an error message\n\t\tCARLA_ERROR_LOG(\"Exceeded maximum number of matches ({}/{})!\", _matched_count, _max_matched_count);\n\n\t\t// Reset the matched count\n\t\t_matched_count = 0;\n\t}\n}", "CodeBleu_score": 38.46888118903601}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t#if DEBUG_CARLA_SUBSCRIBER_LISTENER\n  std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched\" << std::endl;\n#endif\n  if (info.current_count_change == 1) {\n    matched_count_++;\n    if (matched_count_ == 1) {\n      first_connected_ = true;\n    }\n  } else if (info.current_count_change == -1) {\n    matched_count_--;\n    if (matched_count_ == 0) {\n      reader->destroy_subscriber();\n      delete this;\n    }\n  } else {\n    std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched - Error: invalid current_count_change \" << info.current_count_change << std::endl;\n  }\n}", "CodeBleu_score": 51.37816422392307}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t// New match.\n\t\t++_matched_count;\n\t\tif (_matched_count == 1) {\n\t\t\t_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t// Removed match.\n\t\t--_matched_count;\n\t\tif (_matched_count == 0) {\n\t\t\t// No more matches: destroy the subscriber.\n\t\t\t_subscriber.reset();\n\t\t}\n\t} else {\n\t\t// Error.\n\t\tCARLA_LOG_ERROR(\"Received an invalid match change on the DataReader\")\n\t}\n}", "CodeBleu_score": 52.72183683105817}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t#if defined(_WIN32)\n  std::lock_guard<std::mutex> lock(mutex);\n#endif\n  if (info.current_count_change == 1) {\n    ++matched_count;\n    if (first_connected) {\n      return;\n    }\n    first_connected = true;\n    if (matched_count == 1) {\n      return;\n    }\n  } else if (info.current_count_change == -1) {\n    --matched_count;\n    if (matched_count == 0) {\n      reader->destroy();\n      return;\n    }\n  } else {\n    std::cout << \"Unexpected current_count_change status: \" << info.current_count_change << std::endl;\n    return;\n  }\n}", "CodeBleu_score": 51.882527465600184}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t(const std::lock_guard<std::recursive_mutex> lock(m_mutex));\nif (!m_isGetKeyDefined) {\nreturn false;\n}\nif (force_md5 || m_keyBuffer.empty()) {\nInstanceHandle_t p_handle = handleNewInstance();\nif (!p_handle) {\nreturn false;\n}\n\nCarlaCollisionEvent* p_data =reinterpret_cast<CarlaCollisionEvent*>(data);\n\n*handle = p_handle;\n\nif (m_keyBuffer.empty()) {\nm_keyBuffer.resize(m_md5.getSerializedSize(p_handle));\n}\nm_md5.getInstanceKey(*handle, &m_keyBuffer[0]);\n} else {\n(void)memcpy(handle, &m_keyBuffer[0], m_keyBuffer.size());\n}\nreturn true;\n}", "CodeBleu_score": 32.54629199327695}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t#if defined(CARLA_NO_MD5)\n    (void)data;\n    (void)handle;\n    (void)force_md5;\n    return false;", "CodeBleu_score": 7.591703970763176}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t(void)data;\nif (!m_isGetKeyDefined) {\nreturn false;\n}\n\nbool ret = false;\n\n// If the handle is null, the hash code needs to be computed.\nif (*handle == NULL) {\n\n*handle = new InstanceHandle_t();\n\nif (force_md5 || m_keyBuffer.getMaxCdrSerializedSize() > eprosima::fastcdr::Cdr::MAX_SERIALIZED_SIZE) {\nm_md5.init();\nm_md5.update(reinterpret_cast<const unsigned char*>(m_keyBuffer.data()), m_keyBuffer.getSerializedSize());\nm_md5.finalize();\nfor (uint8_t i = 0; i < 14; ++i) {\nhandle->value[i] = m_md5.digest[i];\n}\nret = true;\n} else {\n*(reinterpret_cast<InstanceHandle_t*>(handle)) = m_key;\nret = true;\n}\n} else {\nret = true; // Nothing to do here.\n}\n\nreturn ret;\n}", "CodeBleu_score": 46.415533669291285}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tbool ret = true;\nuint32_t cdrSize = 0;\nconst char * cdrEndianness = ser.cdrEndianness();\nser.setCdrEndianness(topicDataType.md5sumEndianness());\nFastBuffer *buffer = static_cast<FastBuffer*>(payload->data);\nser.serialize_encapsulation(buffer);\ncdr.serialize(buffer, (const char*)data);\nser.serialize_encapsulation(buffer);\n\npayload->length = buffer->length;\n\nser.setCdrEndianness(cdrEndianness);\n\nreturn ret;\n}", "CodeBleu_score": 39.33116779570713}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\t// Cast data to the type of the parameter\n    CarlaEgoVehicleControl* p_type = reinterpret_cast<CarlaEgoVehicleControl*>(data);\n\n    // Create a CDR serialization object\n    eprosima::fastcdr::Cdr ser(\n            eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n\n    try {\n        // Serialize encapsulation\n        ser.serialize_encapsulation();\n\n        if (payload->encapsulation == CDR_BE) {\n            payload->length = (uint32_t)getSerializedSize(p_type);\n            // Serialize the object\n            p_type->serialize(ser);\n        } else {\n            payload->length = (uint32_t)getSerializedSize(p_type);\n            p_type->serialize(ser);\n        }\n\n        // Get the serialized length\n        payload->length = (uint32_t)ser.getSerializedDataLength();\n    }\n\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 69.6067777634076}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\t(void)payload;\n\tstd::vector<uint8_t> buf;\n\tif (!data) {\n\t\treturn false;\n\t}\n\ttry {\n\t\tCarlaEgoVehicleControl* p = (CarlaEgoVehicleControl*) data;\n\t\tcdr ser(buf, ser.endianness == ser.BIG_ENDIANNESS);\n\t\tp_type->serialize(ser, p);\n\t\tpayload->data = buf.data();\n\t\tpayload->length = buf.size();\n\t\treturn true;\n\t} catch (std::bad_alloc&) {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 41.93257175021765}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (g.sysid_target != 0) {\n\t\treturn;\n\t}\n\tif (msg.msgid != MAVLINK_MSG_ID_HEARTBEAT) {\n\t\treturn;\n\t}\n\tmavlink_heartbeat_t heartbeat;\n\tmavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\tif (heartbeat.type != MAV_TYPE_GCS) {\n\t\treturn;\n\t}\n\tg.sysid_target = heartbeat.system_id;\n\ttracker.gcs().request_datastream_position();\n\ttracker.gcs().request_datastream_airpressure();\n}", "CodeBleu_score": 38.23245022564563}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\tif (msg.msgid == MAVLINK_MSG_ID_GLOBAL_POSITION_INT) {\n\t\tmavlink_global_position_int_t pos;\n\t\tmavlink_msg_global_position_int_decode(&msg, &pos);\n\t\ttracker.g.sysid_target = pos.system_id;\n\t\ttracker.gcs().request_datastream_position(pos.system_id, pos.component_id);\n\t\ttracker.gcs().request_datastream_airpressure(pos.system_id, pos.component_id);\n\t\ttarget_set = true;\n\t}\n}", "CodeBleu_score": 42.63856130364514}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// Check if target has already been set\n\tif (target_set) {\n\t\treturn;\n\t}\n\t// Decode the message\n\tmavlink_message_t msg_decoded;\n\tmavlink_msg_heartbeat_decode(&msg_decoded, &msg);\n\t// Check if the message type is one that should be tracked\n\tif (msg_decoded.msgid != MAVLINK_MSG_ID_HEARTBEAT) {\n\t\treturn;\n\t}\n\t// Check if the target system ID is set\n\tif (msg_decoded.sysid == 0) {\n\t\t// Set the target system ID to the message system ID\n\t\ttarget_sysid = msg_decoded.compid;\n\t\t// Request position and air pressure data streams from the target\n\t\ttracker.gcs().request_datastream_position(target_sysid);\n\t\ttracker.gcs().request_datastream_airpressure(target_sysid);\n\t\t// Flag that the target has been set\n\t\ttarget_set = true;\n\t}\n}", "CodeBleu_score": 38.51360637805431}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK_BaseClass::_handle_command_preflight_calibration_baro(msg);\n\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_need_altitude_calibration = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 64.80208736644148}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\tif (_flight_controller != NULL) {\n\t\tresult = GCS_MAVLINK_Base::_handle_command_preflight_calibration_baro(msg);\n\t\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t\t_baro_calibration_required = true;\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 54.95465212502085}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\tif (_flight_controller_id == MAV_COMP_ID_IMU) {\n\t\tresult = GCS_MAVLINK_Base::_handle_command_preflight_calibration_baro(msg);\n\t\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t\t_baro_cal_needed = true;\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 54.307007421257346}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\ttracker.disarm_servos();\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 57.55461159575209}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\ttracker.disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 70.29383879107523}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 != 1.0 && packet.param1 != 0.0) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\tif (packet.param1 == 1.0) {\n\t\ttracker.arm_servos();\n\t} else {\n\t\ttracker.disarm_servos();\n\t}\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 49.56131363347945}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over the available GCS channels\n\tfor (uint8_t i = 0; i < num_gcs; i++) {\n\t\t// Check if there is available payload space\n\t\tif (gcs_channels[i].available_payload_space()) {\n\t\t\t// Send a request to start the data stream on the corresponding channel\n\t\t\tmavlink_msg_request_data_stream_send(gcs_channels[i].get_channel(), sysid, compid, MAV_DATA_STREAM_TYPE_POSITION, MAV_DATA_STREAM_PRESET_BEST_EFFORT, 1, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.23945086808164}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (int i = 0; i < num_gcs; i++) {\n\t\tif (gcs[i].sysid == sysid && gcs[i].compid == compid) {\n\t\t\tif (gcs[i].payload_space_available) {\n\t\t\t\tgcs[i].payload_space_available = false;\n\t\t\t\tmavlink_msg_request_data_stream_send(gcs[i].channel, gcs[i].sysid, gcs[i].compid, MAV_DATA_STREAM_POSITION, 0, 1, 100);\n\t\t\t\tgcs[i].payload_space_available = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.44197463161207}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// iterate over available GCS channels\n\tfor (uint8_t i = 0; i < num_gcs; i++) {\n\t\t// check if channel is available\n\t\tif (gcs_channels[i].available) {\n\t\t\t// check if payload space is available\n\t\t\tif (gcs_channels[i].payload_space >= MIN_PAYLOAD_SPACE) {\n\t\t\t\t// send request\n\t\t\t\tmavlink_msg_request_data_stream_send(\n\t\t\t\t\tMAV_CMD_REQUEST_MESSAGE,\n\t\t\t\t\tgcs_channels[i].mavlink_channel,\n\t\t\t\t\tsysid,\n\t\t\t\t\tcompid,\n\t\t\t\t\tMAV_DATA_STREAM_POSITION,\n\t\t\t\t\tMAVLINK_MSG_ID_POSITION_TARGET,\n\t\t\t\t\tMAVLINK_MSG_ID_POSITION_TARGET,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\t// set payload space to zero\n\t\t\t\tgcs_channels[i].payload_space = 0;\n\t\t\t\t// set channel as unavailable\n\t\t\t\tgcs_channels[i].available = false;\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].data_stream = MAVLINK_MSG_ID_POSITION_TARGET;\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].stream_rate = 0;\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].stream_rate_hz = 0;\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].stream_rate_ms = 0;\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].stream_rate_us = 0;\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].stream_rate_ns = 0;\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].stream_rate_s = 0;\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].stream_rate_hz_str = \"0\";\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].stream_rate_ms_str = \"0\";\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].stream_rate_us_str = \"0\";\n\t\t\t\t// set channel as position\n\t\t\t\tgcs_channels[i].stream_", "CodeBleu_score": 40.18346638217499}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAP::ahrs\nif (ahrs.cos_pitch.is_zero()) {\nreturn false;\n}\nef_pitch = atan2(ahrs.sin_roll * sin(pitch) + ahrs.cos_roll * cos(pitch), ahrs.cos_pitch * cos(yaw) - ahrs.sin_pitch * sin(yaw) * ahrs.cos_roll);\nef_yaw = atan2(-ahrs.sin_roll * cos(pitch) + ahrs.cos_roll * sin(pitch), ahrs.cos_pitch * sin(yaw) + ahrs.sin_pitch * cos(yaw) * ahrs.cos_roll);\nreturn true;\n}", "CodeBleu_score": 54.84871443562709}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.cos_pitch == 0.0f) {\n\t\treturn false;\n\t}\n\tef_pitch = atan2(ahrs.sin_roll * sin(yaw) - ahrs.cos_roll * ahrs.sin_pitch * cos(yaw), ahrs.cos_roll * cos(yaw) + ahrs.sin_roll * ahrs.sin_pitch * sin(yaw));\n\tef_yaw = atan2(-ahrs.sin_roll * ahrs.cos_pitch * sin(yaw) + ahrs.cos_roll * ahrs.sin_pitch * cos(yaw), ahrs.cos_roll * ahrs.cos_pitch * cos(yaw) - ahrs.sin_roll * ahrs.sin_pitch * sin(yaw));\n\treturn true;\n}", "CodeBleu_score": 38.76729091779195}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAP::ahrs->update();\n\tif (AP::ahrs->cos_pitch == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = -asin(AP::ahrs->sin_roll * sin(pitch) + AP::ahrs->cos_roll * cos(pitch) * cos(yaw));\n\tef_yaw = atan2(sin(yaw) * cos(AP::ahrs->cos_pitch), cos(yaw) * cos(AP::ahrs->cos_pitch) - AP::ahrs->sin_roll * sin(pitch));\n\treturn true;\n}", "CodeBleu_score": 48.20727059278642}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// Update the target yaw and pitch for the tracker based on navigation status and parameters.\n\t// Calculate the yaw and pitch in centidegrees.\n\t// Check if the direction is reversed.\n\t// Compute the angle error.\n\t// Convert the errors from earth frame to body frame.\n\t// If the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly.\n}", "CodeBleu_score": 1.5024751854113272}, {"code": "void Mode::update_auto(void){\n\tfloat yaw_error_cd;", "CodeBleu_score": 2.2364192326083954}, {"code": "void Mode::update_auto(void){\n\t\n// Check if the navigation is valid", "CodeBleu_score": 1.4375372059984985}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tif (gps.new_data) {\n\t\t// Update the GPS data\n\t\tgps.update();\n\n\t\t// Check if the GPS is 3D fix\n\t\tif (gps.status >= 3) {\n\t\t\t// Check if the last message time has changed\n\t\t\tif (last_message_time_ms != gps.last_message_time_ms) {\n\t\t\t\t// Reset the last message time\n\t\t\t\tlast_message_time_ms = gps.last_message_time_ms;\n\n\t\t\t\t// Check if the countdown is at zero\n\t\t\t\tif (countdown == 0) {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\tset_home();\n\t\t\t\t} else {\n\t\t\t\t\t// Decrement the countdown\n\t\t\t\t\tcountdown--;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Reset the countdown\n\t\t\tcountdown = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 35.938083746269626}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update GPS\n\tgps.update();\n\n\t// Check if the GPS has a new message\n\tif (gps.last_message_time_ms != _last_message_time_ms) {\n\t\t// Update the last message time\n\t\t_last_message_time_ms = gps.last_message_time_ms;\n\n\t\t// Check if the GPS has a 3D fix\n\t\tif (gps.status >= 3) {\n\t\t\t// Check if the GPS has been initialized\n\t\t\tif (_home_location_set == false) {\n\t\t\t\t// Set the home location\n\t\t\t\t_home_location_set = set_home();\n\t\t\t}\n\n\t\t\t// Check if ground start is enabled\n\t\t\tif (_ground_start_enabled) {\n\t\t\t\t// Check if the countdown has reached zero\n\t\t\t\tif (_ground_start_countdown == 0) {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\t_home_location_set = set_home();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Decrement the countdown\n\t\t\t\t\t_ground_start_countdown--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.1682104872566}, {"code": "void Tracker::update_GPS(void){\n\t\t// If the GPS has a fix and the last message time has changed, update the GPS data.\n\tif (gps.status >= 3 && gps.last_message_time_ms != last_gps_time) {\n\t\tlast_gps_time = gps.last_message_time_ms;\n\t\tgps_time = gps.last_message_time_ms / 1000;\n\t\tgps_fix_time = gps.fix_time_utc_us / 1000;\n\t\tgps_fix_counter++;\n\t\tgps_fix_type = gps.fix_type;\n\t\tgps_lat = gps.latitude;\n\t\tgps_lon = gps.longitude;\n\t\tgps_alt = gps.altitude;\n\t\tgps_speed = gps.speed;\n\t\tgps_ground_speed = gps.ground_speed;\n\t\tgps_vertical_speed = gps.vertical_speed;\n\t\tgps_ground_course = gps.ground_course;\n\t\tgps_hdop = gps.hdop;\n\t\tgps_vdop = gps.vdop;\n\t\tgps_pdop = gps.pdop;\n\t\tgps_epe = gps.epe;\n\t\tgps_satellites_used = gps.satellites_used;\n\t\tgps_satellites_visible = gps.satellites_visible;\n\t\tgps_satellites_visible_used = gps.satellites_visible_used;\n\t\tgps_satellites_prn = gps.satellites_prn;\n\t\tgps_satellites_elevation = gps.satellites_elevation;\n\t\tgps_satellites_azimuth = gps.satellites_azimuth;\n\t\tgps_satellites_snr = gps.satellites_snr;\n\t\tgps_satellites_used_prn = gps.satellites_used_prn;\n\t\tgps_satellites_used_elevation = gps.satellites_used_elevation;\n\t\tgps_satellites_used_azimuth = gps.satellites_used_azimuth;\n\t\tgps_satellites_used_snr = gps.satellites_used_snr;\n\t\tgps_satellites_visible_prn = gps.satell", "CodeBleu_score": 20.154904091024928}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\nTracker::update_pitch_onoff_servo\n", "CodeBleu_score": 7.062366765953298}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0f) {\n\t\tif (pitch > 1.0f) {\n\t\t\tpitch = 1.0f;\n\t\t}\n\t\t_pitch_onoff_servo.write(1.0f - pitch);\n\t} else {\n\t\t_pitch_onoff_servo.write(0.0f);\n\t}\n}", "CodeBleu_score": 15.08721470794621}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// If the GPS has a valid fix and the last message time has changed, update the GPS data\n\tif (GPS_status >= 3 && last_message_time != GPS_time) {\n\t\tlast_message_time = GPS_time;\n\t\tgps_new_data = true;\n\t}\n\n\t// If ground start is enabled and the countdown has reached 1, set the home location\n\tif (ground_start_enabled && ground_start_countdown == 1) {\n\t\t// If the GPS is valid, set the home location\n\t\tif (GPS_status >= 3) {\n\t\t\thome_set = true;\n\t\t\thome_latitude = latitude;\n\t\t\thome_longitude = longitude;\n\t\t\thome_altitude = altitude;\n\t\t}\n\t\t// If the GPS is invalid, reset the countdown\n\t\telse {\n\t\t\tground_start_countdown = 0;\n\t\t}\n\t}\n\n\t// If ground start is enabled and the home location is set, update the pitch\n\tif (ground_start_enabled && home_set) {\n\t\t// If the GPS is valid, update the pitch\n\t\tif (GPS_status >= 3) {\n\t\t\t// If the GPS altitude is less than 10 meters, set the pitch to 0\n\t\t\tif (altitude < 10) {\n\t\t\t\tpitch = 0;\n\t\t\t}\n\t\t\t// If the GPS altitude is greater than 10 meters, set the pitch to the difference between the home altitude and the current altitude\n\t\t\telse {\n\t\t\t\tpitch = home_altitude - altitude;\n\t\t\t}\n\t\t}\n\t\t// If the GPS is invalid, set the pitch to 0\n\t\telse {\n\t\t\tpitch = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 30.657820490944452}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tbool success = true;\nif (!AP_Arming::barometer_checks(display_failure)) {\nreturn false;\n}\nif (g.baro_enabled && g.baro_check_enabled) {\nfloat baro_alt_cm = baro.get_altitude_cm();\nif (fabsf(baro_alt_cm - inertial_nav.get_position_z_up_cm()) > g.baro_max_diff_cm) {\nif (display_failure) {\narming_check_failed(ARMING_CHECK_BARO, ARMING_CHECK_FAIL_BARO_DIFF);\n}\nsuccess = false;\n}\n}\nreturn success;\n}", "CodeBleu_score": 42.555764754699844}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool result = AP_Arming::barometer_checks(display_failure);\n\tif (result) {\n\t\t// check barometer altitude against inertial nav altitude\n\t\tif (g.baro_enabled && g.baro_source == BARO_SOURCE_GPS) {\n\t\t\tfloat baro_alt = g.baro_alt_m * 100.0f;\n\t\t\tfloat inertial_alt = copter.inertial_nav.get_position_z_up_cm();\n\t\t\tfloat alt_disparity = fabsf(baro_alt - inertial_alt);\n\t\t\tif (alt_disparity > 200) {\n\t\t\t\tif (display_failure) {\n\t\t\t\t\tarming_check_failed(ARMING_CHECK_BARO);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 46.35383885681739}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tbool success = true;\n\nif (!AP_Arming::barometer_checks(display_failure)) {\nsuccess = false;\n}\n\nif (success && (g.baro_source == BARO_SOURCE_GPS)) {\n// check that the barometer altitude is close to the inertial nav altitude\nfloat baro_alt = g.baro_alt_filtered;\nfloat inertial_nav_alt = copter.inertial_nav.get_altitude_cm();\n\nif (fabsf(baro_alt - inertial_nav_alt) > 200.0f) {\nif (display_failure) {\narming_check_failed(ARMING_CHECK_BARO, \"Baro altitude (%.1f cm) too far from inertial nav altitude (%.1f cm)\",\nbaro_alt, inertial_nav_alt);\n}\nsuccess = false;\n}\n}\n\nreturn success;\n}", "CodeBleu_score": 49.15839229862912}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_vehicle->mode_nav == &copter.mode_rtl) {\n\t\tif (_vehicle->mode_nav->get_alt_type() == RangeFinder::terrain) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 46.78197390109247}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (copter.mode_rtl.get_alt_type() == RangeFinder::terrain) {\n\t\treturn true;\n\t} else {\n\t\treturn AP_Arming::terrain_database_required();\n\t}\n}", "CodeBleu_score": 33.00894829556786}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_vehicle->rangefinder->get_terrain_source() == RangeFinder::RangeFinder_Terrain_Source_RangeFinder) {\n\t\treturn false;\n\t} else if (_vehicle->rangefinder->get_terrain_source() == RangeFinder::RangeFinder_Terrain_Source_TerrainDB && _vehicle->mode_rtl.get_alt_type() == RangeFinder::RangeFinder_Altitude_Type_Terrain) {\n\t\treturn true;\n\t} else {\n\t\treturn AP_Arming::terrain_database_required();\n\t}\n}", "CodeBleu_score": 60.991201549125954}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for attitude, position, and motor controllers using the last loop time from the scheduler\n\tattitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tpos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tmotors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n\t// run the low-level rate controllers that require only IMU data by invoking the rate_controller_run method of the attitude control\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 47.2679269595788}, {"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for attitude, position, and motor controllers\n\t// using the last loop time from the scheduler\n\trate_controller_set_dt(AP_Scheduler::scheduler.get_last_loop_time_s());\n\n\t// run the low-level rate controllers that require only IMU data\n\trate_controller_run(IMU_sample_time_us);\n}", "CodeBleu_score": 13.802736752980035}, {"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for attitude, position, and motor controllers using the last loop time from the scheduler\n\tattitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tpos_control->set_dt(AP::scheduler().get_last_loop_time_s());\n\tmotors->set_dt(AP::scheduler().get_last_loop_time_s());\n\n\t// run the low-level rate controllers that require only IMU data by invoking the rate_controller_run method of the attitude control\n\tattitude_control->rate_controller_run();\n}", "CodeBleu_score": 47.2679269595788}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n}", "CodeBleu_score": 6.5492355507845295}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n}", "CodeBleu_score": 6.5492355507845295}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tif (new_loc.get_type() == Location::NONE) {\nreturn false;\n}\n\nif (new_loc.get_type() == Location::WAYPOINT) {\nwp_index_target = new_loc.get_index();\n}\n\nif (old_loc.get_type() == Location::WAYPOINT && old_loc.get_index() == wp_index_target && old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\nreturn false;\n}\n\ntarget_location = new_loc;\nreturn true;\n}", "CodeBleu_score": 52.990943496282505}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (ch_flag == AUX_SWITCH_HIGH) {\nif (set_mode(mode)) {\nreturn;\n}\n} else {\nif (mode == mode_number) {\nrc().reset_mode_switch();\n}\n}\n}", "CodeBleu_score": 41.41101852923826}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode != Mode::MANUAL) {\n\t\t\t// We're not in manual mode, so try to set the mode\n\t\t\tif (!copter.set_mode(mode)) {\n\t\t\t\t// Failed to set the mode, so reset the mode switch\n\t\t\t\trc().reset_mode_switch();\n\t\t\t}\n\t\t}\n\t} else if (mode == copter.flightmode->mode_number) {\n\t\t// The mode switch is not in the HIGH position and the mode is the same as the current flight mode, so reset the mode switch\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 57.10028606717139}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t#if defined(RC_CHANNELS_ENABLED) && RC_CHANNELS_ENABLED == ENABLED\n    if (ch_flag == AuxSwitchPos::HIGH) {\n        // AUX switch is in the HIGH position\n        if (mode == mode_number) {\n            // The current mode matches the given mode\n            rc().reset_mode_switch();\n        } else {\n            // The current mode does not match the given mode\n            set_mode(mode);\n        }\n    } else {\n        // AUX switch is in the LOW position\n        if (mode == mode_number) {\n            // The current mode matches the given mode\n            rc().reset_mode_switch();\n        }\n    }\n#endif\n}", "CodeBleu_score": 54.01417607156489}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\tfloat roll_trim = 0.0f;\n\tfloat pitch_trim = 0.0f;\n\tfloat roll_trim_rad = 0.0f;\n\tfloat pitch_trim_rad = 0.0f;\n\troll_trim = channel_roll->get_control_in();\n\tpitch_trim = channel_pitch->get_control_in();\n\troll_trim_rad = ToRad(roll_trim);\n\tpitch_trim_rad = ToRad(pitch_trim);\n\tahrs.add_trim(roll_trim_rad, pitch_trim_rad);\n\tlog_message(mavlink_log_level_info, \"TRIM SAVE: Roll %5.2f Pitch %5.2f\", (double)roll_trim, (double)pitch_trim);\n\tgcs().send_text_fmt(PSTR(\"TRIM SAVE: Roll %5.2f Pitch %5.2f\"), (double)roll_trim, (double)pitch_trim);\n}", "CodeBleu_score": 52.386986055607984}, {"code": "void Copter::save_trim(){\n\t\n}", "CodeBleu_score": 2.7694730809033348}, {"code": "void Copter::save_trim(){\n\t\n}", "CodeBleu_score": 2.7694730809033348}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat yaw_angle;", "CodeBleu_score": 2.51050699023212}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat yaw_angle;\nfloat speed_squared;\nfloat yaw_angle_threshold;\n\nif (copter.position_ok) {\n// Calculate the yaw angle threshold based on the current speed.\nspeed_squared = vel.xy().length_squared;\nif (speed_squared > 0.0000000000001) {\nyaw_angle_threshold = 1.0 / sqrtf(speed_squared);\n} else {\nyaw_angle_threshold = 1.0;\n}\n\n// Calculate the yaw angle based on the velocity components.\nyaw_angle = atan2f(vel.y, vel.x);\n\n// If the yaw angle is within the threshold, update the look-ahead yaw angle.\nif (fabsf(yaw_angle) < yaw_angle_threshold) {\nlook_ahead_yaw_angle = yaw_angle;\n}\n}\n\nreturn look_ahead_yaw_angle;\n}", "CodeBleu_score": 45.12624981060374}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat yaw = 0.0f;\n\n// Get the copter's velocity\nVector3f vel = copter.inertial_nav.get_velocity_neu_cms();\n\n// Calculate the speed squared\nfloat speed_squared = vel.xy().length_squared();\n\n// If the copter's position is valid and the speed is greater than the minimum threshold\nif (copter.position_ok && speed_squared > MIN_SPEED_SQUARED) {\n// Calculate the look-ahead yaw angle\nyaw = atan2f(vel.y, vel.x);\n}\n\n// Return the look-ahead yaw angle\nreturn yaw;\n}", "CodeBleu_score": 47.50972736800874}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (g.ARMED == AP_Arming::NO_ARMED) {\nreturn true;\n}\nif (g.ARMED == AP_Arming::ALWAYS_FAIL) {\nreturn false;\n}\nif (g.ARMED == AP_Arming::ALWAYS_PASS) {\nreturn true;\n}\nif (g.ARMED == AP_Arming::RC_RECEIVER) {\nif (gcs_mavlink->get_rc_channel_override(rc_channel_arm) != 0) {\nreturn true;\n}\n}\nif (method == AP_Arming::RUDDER) {\nif (g.rudder_arming_disabled) {\nreturn false;\n}\nif (!is_zero(plane.get_throttle_input())) {\nreturn false;\n}\n}\nif (hal.util->was_watchdog_armed()) {\nreturn true;\n}\nreturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 59.43381093090245}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER) {\nif (g.disable_rudder_arming || !plane.get_throttle_input()) {\nreturn false;\n}\n}\nif (g.disable_arming_checks || hal.util->was_watchdog_armed()) {\nreturn true;\n}\nreturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 45.76894205772103}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER && !g.rudder_arming_enabled) {\nreturn false;\n}\nif (!g.arming_checks_enabled && hal.util->was_watchdog_armed()) {\nreturn true;\n}\nreturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 43.2081235532119}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// check if we are already armed\n\tif (arming_state == ARMED) {\n\t\treturn true;\n\t}\n\t// check if we are in the process of arming\n\tif (arming_state == ARMING) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of disarming\n\tif (arming_state == DISARMING) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of taking off\n\tif (arming_state == TAKING_OFF) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of landing\n\tif (arming_state == LANDING) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of taking off\n\tif (arming_state == RTL) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of landing\n\tif (arming_state == GUIDED) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of landing\n\tif (arming_state == INITIALISING) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of landing\n\tif (arming_state == SAFETY_CHECK) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of landing\n\tif (arming_state == STABILISING) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of landing\n\tif (arming_state == SAFETY_CHECK) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of landing\n\tif (arming_state == RTH) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of landing\n\tif (arming_state == APPROACH) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of landing\n\tif (arming_state == HOVER) {\n\t\treturn false;\n\t}\n\t// check if we are in the process of landing\n\tif (arming_state == TRY_AGAIN) {\n\t\treturn false;", "CodeBleu_score": 25.316753760721646}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t// check if already armed\nif (armed) {\nreturn true;\n}\n// check if arming is allowed\nif (!AP_Arming::arming_allowed(method)) {\nreturn false;\n}\n// check if arming checks should be performed\nif (do_arming_checks && !check_arming_checks(method)) {\nreturn false;\n}\n// arm the plane\nswitch (method) {\ncase AP_Arming::DISARM:\n// disarming is always allowed\nbreak;\ncase AP_Arming::ALWAYS:\n// always arm the plane\nbreak;\ncase AP_Arming::ALWAYS_FAIL:\n// always fail to arm the plane\nreturn false;\ncase AP_Arming::ALWAYS_PASS:\n// always pass the arming checks\nbreak;\ncase AP_Arming::RC_LOITER:\n// arm if RC throttle is loitering\nif (plane.rc_channel_data.throttle_failsafe) {\nreturn false;\n}\nbreak;\ncase AP_Arming::RC_STICK:\n// arm if RC throttle stick is in the middle position\nif (plane.rc_channel_data.throttle < 1000) {\nreturn false;\n}\nbreak;\ncase AP_Arming::RC_FULL:\n// arm if RC throttle is full\nif (plane.rc_channel_data.throttle < 1000) {\nreturn false;\n}\nbreak;\ncase AP_Arming::FAILSAFE:\n// arm if failsafe is not enabled\nif (plane.failsafe.enabled()) {\nreturn false;\n}\nbreak;\ncase AP_Arming::FAILSAFE_CUSTOM:\n// arm if failsafe is not enabled\nif (plane.failsafe.enabled()) {\nreturn false;\n}\nbreak;\n}\n// arm the plane\nplane.update_home();\nplane.ahrs.set_home(plane.home);\nplane.update_current_loc();\nchange_arm_state(true);\nplane.delay_armed = true;\nsend_arm_disarm_statustext(true);\nreturn true;\n}", "CodeBleu_score": 40.69085612877157}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\t// check if we are already armed\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// check if we are ready to arm\n\tif (do_arming_checks && !ready_to_arm()) {\n\t\treturn false;\n\t}\n\n\t// set the home position\n\tupdate_home();\n\n\t// set the home position in the AHRS system\n\tplane.ahrs.set_home();\n\n\t// set the current location\n\tupdate_current_loc();\n\n\t// change the arm state\n\tchange_arm_state(true);\n\n\t// set the delay arming flag\n\tdelay_arming = true;\n\n\t// send a status text\n\tsend_arm_disarm_statustext(true);\n\n\treturn true;\n}", "CodeBleu_score": 35.50394597006961}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tbool ret = true;\nif (g.ARMED) {\nreturn ret;\n}\nif (g.pre_arm_check_failed) {\nreturn ret;\n}\nif (!g.HAS_DISARM_FUNCTION) {\nif (display_failure) {\nAP_Notify::flags.pre_arm_failed = true;\n}\nret = false;\n} else {\nret = AP_Arming::pre_arm_checks(display_failure);\n}\nreturn ret;\n}", "CodeBleu_score": 45.75121702539086}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (get_mode() == STABILIZE) {", "CodeBleu_score": 7.217418173356465}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (armed) {\nreturn true;\n}\nif (get_disarm_button() == NULL) {\nif (display_failure) {\nprint_disarm_button_missing();\n}\nreturn false;\n}\nreturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.94215313548042}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 55.006522403276705}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tx = cos_yaw * temp_x - sin_yaw * y;\n\ty = sin_yaw * temp_x + cos_yaw * y;\n}", "CodeBleu_score": 33.80394341702928}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tx = temp_x * cos_yaw - y * sin_yaw;\n\ty = temp_x * sin_yaw + y * cos_yaw;\n}", "CodeBleu_score": 33.98116505847533}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if the yaw angle is within acceptable ranges\n\tif (packet.param4 > 0.0f && packet.param4 < 360.0f) {\n\t\t// Check if the yaw heading is within acceptable ranges\n\t\tif (packet.param1 > 0.0f && packet.param1 < 360.0f) {\n\t\t\t// Set the yaw heading\n\t\t\tset_auto_yaw_look_at_heading(packet.param1, packet.param4);\n\n\t\t\t// Return success\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t}\n\n\t// Return failure\n\treturn MAV_RESULT_DENIED;\n}", "CodeBleu_score": 46.41346361238791}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 < 0 || packet.param1 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param4 < -90 || packet.param4 > 90) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param5 < 0 || packet.param5 > 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tmode_sub.mode_auto.set_auto_yaw_look_at_heading(packet.param1, packet.param4, packet.param5);\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 53.63704121834236}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if yaw is within acceptable range\n\tif (packet.param4 > 180.0f || packet.param4 < 0.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set yaw heading\n\tset_yaw_heading(packet.param4);\n\n\t// Return success\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 30.210654074583477}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == MAV_MODE_FLAG_AUTO_ENABLED || control_mode == MAV_MODE_FLAG_GUIDED_ENABLED) {\n\t\treturn (uint8_t) (wp_bearing_to_destination / 2);\n\t}\n\treturn 0;\n}", "CodeBleu_score": 39.31789332223056}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n\t\treturn (wp_bearing / 2) % 360;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 36.65508098313545}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tif (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED) {\n\t\treturn (wp_bearing_to_destination + 18000) / 2;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 38.997117822370065}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(id)) {\n\t\tuint8_t buf[10];\n\t\tuint8_t *p = buf;\n\t\t*p++ = AP_HAL::Util::get_log_packet_header();\n\t\t*p++ = (uint8_t)id;\n\t\t*p++ = (uint8_t)(value >> 24);\n\t\t*p++ = (uint8_t)(value >> 16);\n\t\t*p++ = (uint8_t)(value >> 8);\n\t\t*p++ = (uint8_t)value;\n\t\tlogger.WriteCriticalBlock(buf, p - buf);\n\t}\n}", "CodeBleu_score": 43.70836134913116}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (!should_log()) return;\n\tLogPacketHeader header = LOG_PACKET_HEADER_INIT;\n\theader.magic = LOG_PACKET_MAGIC;\n\theader.size = sizeof(header) + sizeof(int32_t);\n\theader.data_id = id;\n\theader.time_us = hal.scheduler->micros64();\n\tuint8_t buf[sizeof(header) + sizeof(int32_t)];\n\tmemcpy(buf, &header, sizeof(header));\n\tmemcpy(buf + sizeof(header), &value, sizeof(int32_t));\n\tlogger.WriteCriticalBlock(buf, sizeof(buf));\n}", "CodeBleu_score": 38.53941914744102}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (should_log(id)) {\n\t\tLogPacketHeader packet_header = LOG_PACKET_HEADER_INIT;\n\t\tpacket_header.data_id = id;\n\t\tpacket_header.size = sizeof(packet_header) + sizeof(value);\n\t\tpacket_header.time_us = hal.scheduler->micros64();\n\t\tLog_Write_Packet(&packet_header, sizeof(packet_header), (uint8_t *)&value, sizeof(value));\n\t}\n}", "CodeBleu_score": 45.65696688029812}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\n\tif (motors.armed) {\n\t\tset_home_to_current_location_inflight();\n\n\t} else {\n\t\t// Attempt to set the home to the current EKF location\n\t\tif (!set_home_to_current_location()) {\n\t\t\t// If we fail to set the home to the EKF location, we do nothing\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// If we get here, we have successfully set the home to the EKF location\n\thome_is_set = true;\n}", "CodeBleu_score": 37.268078951806}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\n\tif (motors.armed) {\n\t\tset_home_to_current_location_inflight();\n\n\t} else {\n\t\t// Try to set the home position to the current EKF location\n\t\tbool success = set_home_position_from_EKF();\n\n\t\t// If the EKF location was not set, don't do anything else\n\t\tif (!success) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the motors are not armed, set the home position to the current location\n\t\tset_home_to_current_location();\n\t}\n}", "CodeBleu_score": 34.748768780919725}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (!ahrs.home_is_set) {\n\t\tif (motors.armed) {\n\t\t\tset_home_to_current_location_inflight();\n\t\t} else {\n\t\t\tset_home_to_current_location();\n\t\t}\n\t}\n}", "CodeBleu_score": 29.68989023886258}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\tif (!motors.armed()) {\n\t\tmotors.set_throttle(0.0f);\n\t\tmotors.set_desired_spool_state(SPOOL_STATE_UNLIMITED);\n\t\tattitude_control.relax_attitude_controllers();\n\t\treturn;\n\t}\n\tmotors.set_desired_spool_state(SPOOL_STATE_UNLIMITED);\n\tfloat roll_rate = get_pilot_desired_angle_rates().roll;\n\tfloat pitch_rate = get_pilot_desired_angle_rates().pitch;\n\tfloat yaw_rate = get_pilot_desired_angle_rates().yaw;\n\tfloat throttle = get_control_in(channel_throttle);\n\tfloat roll = get_control_in(channel_roll);\n\tfloat pitch = get_control_in(channel_pitch);\n\tfloat yaw = get_control_in(channel_yaw);\n\tfloat lateral = get_control_in(channel_lateral);\n\tfloat forward = get_control_in(channel_forward);\n\tfloat roll_rate_bf = attitude_control.input_rate_bf_roll_pitch_yaw(roll_rate, pitch_rate, yaw_rate, roll, pitch, yaw);\n\tfloat roll_rate_bf_norm = roll_rate_bf / RATE_BETA;\n\tfloat roll_rate_bf_norm_sq = roll_rate_bf_norm * roll_rate_bf_norm;\n\tfloat roll_rate_bf_norm_cubed = roll_rate_bf_norm_sq * roll_rate_bf_norm;\n\tfloat roll_rate_bf_norm_quartic = roll_rate_bf_norm_cubed * roll_rate_bf_norm;\n\tfloat roll_rate_bf_norm_quintic = roll_rate_bf_norm_quartic * roll_rate_bf_norm;\n\tfloat roll_rate_bf_norm_sextic = roll_rate_bf_norm_quintic * roll_rate_bf_norm;\n\tfloat roll_rate_bf_norm_septic = roll_rate_bf_norm_sextic * roll_rate_bf_norm;\n\tfloat roll_rate_bf", "CodeBleu_score": 42.72566677381305}, {"code": "void ModeAcro::run(){\n\t\n}", "CodeBleu_score": 1.8702286680134719}, {"code": "void ModeAcro::run(){\n\t\tif (!motors.armed) {\n\t\tmotors.set_throttle(0);\n\t\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\t\tattitude_control->relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\tmotors.set_desired_spool_state(SpoolState::UNLIMITED_THROTTLE);\n\tattitude_control->input_rate_bf_roll_pitch_yaw(get_pilot_desired_angle_rates());\n\tattitude_control->set_throttle_out(channel_throttle->norm_input);\n\tmotors.set_forward(channel_forward->norm_input);\n\tmotors.set_lateral(channel_lateral->norm_input);\n\tmotors.set_yaw(channel_yaw->norm_input);\n}", "CodeBleu_score": 36.00316891350184}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set mode to position control\n\t_mode = MODE_POS_CONTROL;\n\n\t// Initialize the waypoint controller\n\tsub.wp_nav.wp_and_spline_init();\n\n\t// Get the stopping point\n\tVector3f stopping_point = sub.wp_nav.get_wp_stopping_point();\n\n\t// Set the stopping point as the waypoint destination\n\tsub.wp_nav.set_wp_destination(stopping_point);\n\n\t// Initialize yaw using the default auto yaw mode\n\tset_auto_yaw_mode(sub.wp_nav.get_default_auto_yaw_mode());\n}", "CodeBleu_score": 53.19404996683653}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set the mode to position control\n\tmode_position_control();\n\n\t// set the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n\n\t// get the stopping point\n\tVector3f stopping_point = get_stopping_point();\n\n\t// set the stopping point as the waypoint destination\n\tsub.wp_nav.set_wp_destination(stopping_point);\n\n\t// initialize the waypoint controller\n\tsub.wp_nav.wp_and_spline_init();\n}", "CodeBleu_score": 43.55554582573749}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\tset_mode(MODE_POSCTL);\n\tset_pos_setpoint(vehicle_local_position.x, vehicle_local_position.y, vehicle_local_position.z);\n\tset_yaw_setpoint(0.0f);\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n\tsub.wp_nav.set_wp_destination(0.0f, 0.0f, 0.0f);\n\tsub.wp_nav.wp_and_spline_init(0);\n}", "CodeBleu_score": 40.6584731803538}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set velocity control mode\n\t_control_mode.set(ControlMode::VELOCITY_CONTROL);\n\t// Initialize vertical maximum speeds and accelerations\n\t_vel_control->set_max_speed_up(_vel_max_up_m_s);\n\t_vel_control->set_max_speed_down(_vel_max_down_m_s);\n\t_vel_control->set_max_acceleration_up(_vel_max_up_m_s2);\n\t_vel_control->set_max_acceleration_down(_vel_max_down_m_s2);\n\t// Initialize velocity controllers\n\t_vel_control->init_xy_controller();\n\t_vel_control->init_z_controller();\n\t// Set yaw control mode\n\t_auto_yaw_mode.set(AutoYawMode::AUTO_YAW_HOLD);\n}", "CodeBleu_score": 34.47029110693501}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set the mode to GUIDED_VEL_CONTROL\n\tset_mode(GUIDED_VEL_CONTROL);\n\n\t// Initialize vertical speeds and accelerations using pilot-defined parameters\n\tposition_control->init_xy_controller();\n\tposition_control->set_max_speed_accel_z();\n\n\t// Initialize the vertical and horizontal velocity controllers\n\tposition_control->init_z_controller();\n\tposition_control->init_xy_controller();\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD\n\tset_auto_yaw_mode();\n}", "CodeBleu_score": 33.60202371713352}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// Set velocity mode\n\tset_velocity_mode();\n\n\t// Set max speeds and accelerations\n\tset_max_speed_accel_xy();\n\tset_max_speed_accel_z();\n\n\t// Initialize velocity controllers\n\tinit_xy_controller();\n\tinit_z_controller();\n\n\t// Set yaw control mode\n\tset_auto_yaw_mode();\n}", "CodeBleu_score": 8.327739747524515}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\tbool ret = false;\n\n\t// Check for a timeout\n\tif (millis() - _start_time > _timeout_max) {\n\t\tret = true;\n\t}\n\n\t// Check for a minimum altitude\n\tif (curr_pos.alt < _min_alt) {\n\t\tret = true;\n\t}\n\n\t// Check for a maximum altitude\n\tif (curr_pos.alt > _max_alt) {\n\t\tret = true;\n\t}\n\n\t// Check for a maximum horizontal distance\n\tif (get_horizontal_distance_cm() > _max_dist) {\n\t\tret = true;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 22.052736817269807}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tbool ret = false;\n\t// Check for timeout\n\tif (millis() - _start_time > _guided_timeout_max) {\n\t\tret = true;\n\t}\n\t// Check for altitude limits\n\tif (curr_pos.alt < _guided_min_alt) {\n\t\tret = true;\n\t}\n\tif (curr_pos.alt > _guided_max_alt) {\n\t\tret = true;\n\t}\n\t// Check for horizontal distance limits\n\tif (get_horizontal_distance_cm() > _guided_max_dist) {\n\t\tret = true;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 23.00709134942424}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check for timeout\n\tif (hal.util->get_soft_armed()) {\n\t\treturn false;\n\t}\n\tif (hal.util->get_soft_kill()) {\n\t\treturn true;\n\t}\n\tif (hal.util->get_soft_disable()) {\n\t\treturn true;\n\t}\n\n\t// Check for minimum altitude\n\tif (curr_pos.alt < guided_limit.min_alt) {\n\t\treturn true;\n\t}\n\n\t// Check for maximum altitude\n\tif (curr_pos.alt > guided_limit.max_alt) {\n\t\treturn true;\n\t}\n\n\t// Check for horizontal distance\n\tfloat dist = get_horizontal_distance_cm();\n\tif (dist > guided_limit.max_dist) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 37.80159698465091}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\t// Verify that the motor test is enabled\n\tif (!AP_HAL::get_HAL()->motor_test()) {\n\t\treturn true;\n\t}\n\n\t// Verify that the motor test has been armed\n\tif (!AP_HAL::get_HAL()->motor_test_armed()) {\n\t\treturn true;\n\t}\n\n\t// Verify that the motor test has been run at least once\n\tif (!AP_HAL::get_HAL()->motor_test_ran()) {\n\t\treturn true;\n\t}\n\n\t// Get the time of the last motor test request\n\tuint32_t last_test_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test failure\n\tuint32_t last_failure_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test pass\n\tuint32_t last_pass_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test timeout\n\tuint32_t last_timeout_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test pass\n\tuint32_t last_pass_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test failure\n\tuint32_t last_failure_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test request\n\tuint32_t last_test_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test timeout\n\tuint32_t last_timeout_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test pass\n\tuint32_t last_pass_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test failure\n\tuint32_t last_failure_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test request\n\tuint32_t last_test_time = AP_HAL::get_HAL()->millis();\n\n\t// Get the time of the last motor test timeout", "CodeBleu_score": 40.10859419429556}, {"code": "bool Sub::verify_motor_test(){\n\t\t// Verify the motor test\n\tif (test_motor_requests == 0) {\n\t\t// No motor test requests received\n\t\tsend_text(\"Motor test: FAILED\");\n\t\tsend_text(\"No motor test requests received\");\n\t\tset_pass(false);\n\t\tdisarm();\n\t\ttest_motor_failure_time = millis();\n\t\treturn false;\n\t}\n\telse if (test_motor_requests < 20) {\n\t\t// Less than 20 motor test requests received\n\t\tsend_text(\"Motor test: FAILED\");\n\t\tsend_text(\"Less than 20 motor test requests received\");\n\t\tset_pass(false);\n\t\tdisarm();\n\t\ttest_motor_failure_time = millis();\n\t\treturn false;\n\t}\n\telse if (test_motor_requests < 40) {\n\t\t// Less than 40 motor test requests received\n\t\tsend_text(\"Motor test: FAILED\");\n\t\tsend_text(\"Less than 40 motor test requests received\");\n\t\tset_pass(false);\n\t\tdisarm();\n\t\ttest_motor_failure_time = millis();\n\t\treturn false;\n\t}\n\telse if (test_motor_requests < 60) {\n\t\t// Less than 60 motor test requests received\n\t\tsend_text(\"Motor test: FAILED\");\n\t\tsend_text(\"Less than 60 motor test requests received\");\n\t\tset_pass(false);\n\t\tdisarm();\n\t\ttest_motor_failure_time = millis();\n\t\treturn false;\n\t}\n\telse if (test_motor_requests < 80) {\n\t\t// Less than 80 motor test requests received\n\t\tsend_text(\"Motor test: FAILED\");\n\t\tsend_text(\"Less than 80 motor test requests received\");\n\t\tset_pass(false);\n\t\tdisarm();\n\t\ttest_motor_failure_time = millis();\n\t\treturn false;\n\t}\n\telse if (test_motor_requests < 100) {\n\t\t// Less than 100 motor test requests received\n\t\tsend_text(\"Motor test: FAILED\");\n\t\tsend_text(\"Less than 100 motor test requests received\");\n\t\tset_pass(false);\n\t\tdisarm();\n\t\ttest_motor", "CodeBleu_score": 37.276532449243916}, {"code": "bool Sub::verify_motor_test(){\n\t\t// TODO: Implement Sub::verify_motor_test\n\treturn true;\n}", "CodeBleu_score": 4.877943933983955}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll = wp_nav.get_roll();\n\tfloat pitch = wp_nav.get_pitch();\n\tconstrain_int16(roll, -WPNAV_MAX_ROLL_PITCH_CD, WPNAV_MAX_ROLL_PITCH_CD);\n\tconstrain_int16(pitch, -WPNAV_MAX_ROLL_PITCH_CD, WPNAV_MAX_ROLL_PITCH_CD);\n\tlateral_out = ((float)roll) / (WPNAV_MAX_ROLL_PITCH_CD);\n\tforward_out = ((float)pitch) / (WPNAV_MAX_ROLL_PITCH_CD);\n}", "CodeBleu_score": 45.48998376906671}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_norm = constrain_int16(wp_nav.get_roll(), -WPNAV_MAX_ANGLE, WPNAV_MAX_ANGLE) / (float)WPNAV_MAX_ANGLE;\n\tfloat pitch_norm = constrain_int16(wp_nav.get_pitch(), -WPNAV_MAX_ANGLE, WPNAV_MAX_ANGLE) / (float)WPNAV_MAX_ANGLE;\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 37.227698909806065}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Retrieve roll and pitch targets from wp_nav in centidegrees.\n\tfloat roll_cdeg = wp_nav.get_roll();\n\tfloat pitch_cdeg = wp_nav.get_pitch();\n\n\t// Constrain roll and pitch targets within a specified maximum angle range.\n\troll_cdeg = constrain_int16(roll_cdeg, -WPNAV_MAX_ROLL_PITCH_CDEG, WPNAV_MAX_ROLL_PITCH_CDEG);\n\tpitch_cdeg = constrain_int16(pitch_cdeg, -WPNAV_MAX_ROLL_PITCH_CDEG, WPNAV_MAX_ROLL_PITCH_CDEG);\n\n\t// Normalize roll and pitch targets.\n\tfloat roll_norm = (float)roll_cdeg / (float)WPNAV_MAX_ROLL_PITCH_CDEG;\n\tfloat pitch_norm = (float)pitch_cdeg / (float)WPNAV_MAX_ROLL_PITCH_CDEG;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out.\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 47.19530523954536}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// Update barometer data\n\tbarometer.update();\n\n\t// If the barometer is healthy, update the sensor health status\n\tif (barometer.healthy) {\n\t\tsensors.health.barometer = true;\n\t}\n\n\t// If the barometer altitude is above zero, update the barometer calibration\n\tif (barometer.get_altitude() > 0.0f) {\n\t\tbarometer.update_calibration();\n\t}\n}", "CodeBleu_score": 58.1229035899388}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\n\tif (depth_sensor.present()) {\n\t\tdepth_sensor.set_healthy(barometer.healthy());\n\t}\n}", "CodeBleu_score": 58.12949290220578}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer.get_altitude() > 0) {\n\t\tbarometer.update_calibration();\n\t}\n\tif (barometer.healthy()) {\n\t\tbarometer_healthy = true;\n\t}\n}", "CodeBleu_score": 55.372261614009275}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\n\tif (status.condition(Status::OK_IN_AIR)) {\n\t\treturn true;\n\t}\n\n\tif (status.condition(Status::OK_IN_AIR) && filter_status.in_air) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 29.95870033270913}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// if we don't have inertial nav, return false\n\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\t// if the motors are disarmed, accept a predicted position\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\t// if the motors are armed, require a good position\n\tif (ahrs.is_good_position() && !ahrs.is_constant_position_mode()) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 37.409526360402786}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!ahrs.have_inertial_nav) {\n\t\treturn false;\n\t}\n\n\tif (!motors.armed) {\n\t\treturn true;\n\t}\n\n\tif (position_lock.flags.abs_lock) {\n\t\treturn true;\n\t}\n\n\tif (position_lock.flags.in_position) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 30.517572446796027}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!rover.control_mode->requires_position && !rover.control_mode->requires_velocity) {\nreturn true;\n}\nif (!AP_Arming::gps_checks(display_failure)) {\nreturn false;\n}\nif (!rover.ahrs.pre_arm_check(display_failure)) {\nreturn false;\n}\nif (!rover.ekf_position_ok) {\nif (display_failure) {\nrover.console->println_P(PSTR(\"EKF failed\"));\n}\nreturn false;\n}\nif (!rover.in_position_mode) {\nif (display_failure) {\nrover.console->println_P(PSTR(\"Not in position mode\"));\n}\nreturn false;\n}\nreturn true;\n}", "CodeBleu_score": 45.708388282989304}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!AP_Arming::gps_checks(display_failure)) {\nreturn false;\n}\nif (!ahrs.is_ready()) {\nif (display_failure) {\nprint_message(\"GPS AHRS not ready\");\n}\nreturn false;\n}\nif (!rover.ekf_position_ok()) {\nif (display_failure) {\nprint_message(\"EKF failsafe active\");\n}\nreturn false;\n}\nif (!rover.position_ok()) {\nif (display_failure) {\nprint_message(\"Invalid position estimate\");\n}\nreturn false;\n}\nreturn true;\n}", "CodeBleu_score": 41.26436879622896}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!AP_Arming::gps_checks(display_failure)) {\nreturn false;\n}\n\n// if we're not in a mode that requires position or velocity, return true\nif (!control_mode->requires_position && !control_mode->requires_velocity) {\nreturn true;\n}\n\n// check that the AHRS is ready\nif (!ahrs.initialised()) {\nif (display_failure) {\nConsole.print(\"GPS: AHRS not initialised\");\n}\nreturn false;\n}\n\n// check that the EKF has a valid position estimate\nif (!rover.ekf_position_ok()) {\nif (display_failure) {\nConsole.print(\"GPS: EKF position invalid\");\n}\nreturn false;\n}\n\n// check that the EKF failsafe is not active\nif (rover.get_ekf_health() == AP_Rover::EKF_FAILSAFE) {\nif (display_failure) {\nConsole.print(\"GPS: EKF failsafe active\");\n}\nreturn false;\n}\n\nreturn true;\n}", "CodeBleu_score": 48.95364627505154}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool armed = false;\n\tif (do_arming_checks) {\n\t\tif (!check_prearm_checks()) {\n\t\t\treturn armed;\n\t\t}\n\t}\n\tswitch (method) {\n\t\tcase AP_Arming::AUTO:\n\t\t\tif (check_auto_arm_checks()) {\n\t\t\t\tarmed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AP_Arming::ALWAYS:\n\t\t\tarmed = true;\n\t\t\tbreak;\n\t\tcase AP_Arming::NEVER:\n\t\t\tbreak;\n\t\tcase AP_Arming::RC_LOITER:\n\t\t\tif (check_rc_loiter_arm_checks()) {\n\t\t\t\tarmed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AP_Arming::FAILSAFE:\n\t\t\tif (check_failsafe_arm_checks()) {\n\t\t\t\tarmed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AP_Arming::SMART_RTL:\n\t\t\tif (check_smart_rtl_arm_checks()) {\n\t\t\t\tarmed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AP_Arming::GUIDED_NOGPS:\n\t\t\tif (check_guided_no_gps_arm_checks()) {\n\t\t\t\tarmed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AP_Arming::GUIDED:\n\t\t\tif (check_guided_arm_checks()) {\n\t\t\t\tarmed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AP_Arming::LOITER:\n\t\t\tif (check_loiter_arm_checks()) {\n\t\t\t\tarmed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AP_Arming::STABILIZE:\n\t\t\tif (check_stabilize_arm_checks()) {\n\t\t\t\tarmed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AP_Arming::LAND:\n\t\t\tif (check_land_arm_checks()) {\n\t\t\t\tarmed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AP_Arming::OF_LOITER:\n\t\t\tif (check_of_loiter_arm_checks()) {\n\t\t\t\tarmed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AP_Arming::OF_NAV:\n\t\t\tif (check_of", "CodeBleu_score": 27.46032073348458}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tbool success = true;\n", "CodeBleu_score": 5.288213515127308}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// If arming is disabled, do not arm", "CodeBleu_score": 4.873033772960604}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (shouldCharge()) {\n\t\t\tif (!charging_enabled) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_start_time = millis();\n\t\t\t\tdigitalWrite(CHARGING_LED, HIGH);\n\t\t\t}\n\t\t} else {\n\t\t\tif (charging_enabled) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tdigitalWrite(CHARGING_LED, LOW);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tdigitalWrite(CHARGING_LED, LOW);\n\t\t}\n\t\tif (millis() - charging_start_time > CHARGING_RETRY_DELAY) {\n\t\t\tcharging_allowed = checkShouldCharge();\n\t\t\tcharging_start_time = millis();\n\t\t}\n\t}\n}", "CodeBleu_score": 58.31187859549216}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (shouldCharge) {\n\t\t\tif (shouldCharge == 1) {\n\t\t\t\t// We should be charging, but we're not.\n\t\t\t\t// Record the time we should have started charging.\n\t\t\t\tcharging_start_time = millis();\n\t\t\t\tshouldCharge = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We should be charging, and we're not.\n\t\t\t\t// Check if we should have started charging.\n\t\t\t\tif (millis() - charging_start_time > 10000) {\n\t\t\t\t\t// We should have started charging, but didn't.\n\t\t\t\t\t// Disable charging and retry.\n\t\t\t\t\tdigitalWrite(CHARGER_ENABLE_PIN, LOW);\n\t\t\t\t\tshouldCharge = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// We should not be charging, but we are.\n\t\t\t// Disable charging and record the time we should have stopped charging.\n\t\t\tcharging_stop_time = millis();\n\t\t\tshouldCharge = 1;\n\t\t}\n\t}\n\telse {\n\t\t// We should not be charging, and we are not.\n\t\t// Check if we should have stopped charging.\n\t\tif (shouldCharge == 1) {\n\t\t\t// We should have stopped charging, but didn't.\n\t\t\t// Check if we should retry enabling charging.\n\t\t\tif (millis() - charging_stop_time > 10000) {\n\t\t\t\t// We should have stopped charging, but didn't.\n\t\t\t\t// Enable charging and retry.\n\t\t\t\tdigitalWrite(CHARGER_ENABLE_PIN, HIGH);\n\t\t\t\tshouldCharge = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 48.600698165326044}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (shouldCharge()) {\n\t\t\tif (charging_enabled) {\n\t\t\t\t// do nothing\n\t\t\t} else {\n\t\t\t\tdigitalWrite(CHARGE_PIN, HIGH);\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_start_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (charging_enabled) {\n\t\t\t\tdigitalWrite(CHARGE_PIN, LOW);\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_stop_time = millis();\n\t\t\t\tcharging_stop_reason = CHARGING_STOP_REASON_SHOULD_NOT_CHARGE;\n\t\t\t} else {\n\t\t\t\t// do nothing\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tdigitalWrite(CHARGE_PIN, LOW);\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_stop_time = millis();\n\t\t\tcharging_stop_reason = CHARGING_STOP_REASON_NOT_ALLOWED;\n\t\t} else {\n\t\t\t// do nothing\n\t\t}\n\t}\n}", "CodeBleu_score": 56.9796132880854}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (rosRunning && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tuint8_t crcBytes[2];\n\t\tcrcBytes[0] = crc & 0xFF;\n\t\tcrcBytes[1] = crc >> 8;\n\t\tpacketSerial.write(message, size);\n\t\tpacketSerial.write(crcBytes, 2);\n\t}\n}", "CodeBleu_score": 38.255848458086284}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (rosRunning && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tmemcpy(message + size, &crc, sizeof(crc));\n\t\tsize += sizeof(crc);\n\t\tpacketSerial.write(message, size);\n\t}\n}", "CodeBleu_score": 34.24388432182053}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (rosRunning && size >= 4) {\n\t\tuint16_t crc = CRC16.ccitt(message, size);\n\t\tuint8_t crcBytes[2];\n\t\tcrcBytes[0] = crc >> 8;\n\t\tcrcBytes[1] = crc & 0xFF;\n\t\tpacketSerial.write(message, size);\n\t\tpacketSerial.write(crcBytes, 2);\n\t}\n}", "CodeBleu_score": 38.255848458086284}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\tif (!soundSerial.begin(9600)) {\n\t\treturn false;\n\t}\n\tsoundSerial.flush();\n\treturn true;\n}", "CodeBleu_score": 26.75850178200371}, {"code": "bool MP3Sound::begin(){\n\t\tif (!soundSerial.begin(9600)) {\n\t\treturn false;\n\t}\n\tsoundSerial.flush();\n\tdelay(100);\n\tif (!sendCommand(MP3_COMMAND_INIT)) {\n\t\treturn false;\n\t}\n\tif (!sendCommand(MP3_COMMAND_GET_SD_STATUS)) {\n\t\treturn false;\n\t}\n\tif (!readResponse(MP3_RESPONSE_SD_STATUS)) {\n\t\treturn false;\n\t}\n\tif (sdStatus == MP3_SD_STATUS_NO_FILES) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 35.412700557102596}, {"code": "bool MP3Sound::begin(){\n\t\t// Initialize the serial port\n\tif (soundSerial.begin(9600) == false) {\n\t\treturn false;\n\t}\n\n\t// Clear any existing data in the buffer\n\tsoundSerial.flush();\n\n\t// Initialize the sound module\n\tsoundSerial.write(\"AT+FRESET\\r\");\n\tdelay(500);\n\n\t// Retrieve the number of sound files available on the SD card\n\tsoundSerial.write(\"AT+FSDNUM\\r\");\n\tdelay(500);\n\tif (soundSerial.find(\"OK\")) {\n\t\tsoundSerial.readBytes(numSdTracks, 2);\n\t\tnumSdTracks = atoi(numSdTracks);\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 46.673501106821845}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tmyMP3 = active_sounds.back();\n\t\tactive_sounds.pop_back();\n\t\tmyMP3.play();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 44.36027614713459}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\telse {\n\t\tmyMP3 = active_sounds.back();\n\t\tactive_sounds.pop_back();\n\t\tmyMP3.play();\n\t\treturn active_sounds.size();\n\t}\n}", "CodeBleu_score": 44.36027614713459}, {"code": "int MP3Sound::processSounds(){\n\t\tif (active_sounds.size() == 0 || myMP3.isPlaying()) {\n\t\treturn active_sounds.size();\n\t}\n\n\tmyMP3.play();\n\tactive_sounds.pop_back();\n\treturn active_sounds.size();\n}", "CodeBleu_score": 41.77272606017851}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tbool handled = true;\n\tswitch (command) {\n\t\tcase C_CAMERA_MEMORY_MAPPED_FILE:\n\t\t\timage_cleanup(ac);\n\t\t\timage_setup(ac, r);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thandled = false;\n\t\t\tbreak;\n\t}\n\treturn handled;\n}", "CodeBleu_score": 52.536838750340465}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n\t\tif (ac->memory_mapped_file) {\n\t\t\twb_memory_mapped_file_cleanup(ac->memory_mapped_file);\n\t\t\tac->memory_mapped_file = NULL;\n\t\t}\n\t\tac->memory_mapped_file = wb_memory_mapped_file_new(r, ac->image_width, ac->image_height, ac->image_width * 3, 3, 1);\n\t\tif (!ac->memory_mapped_file) {\n\t\t\tfprintf(stderr, \"Error: wb_memory_mapped_file_new failed.\n\");\n\t\t\treturn false;\n\t\t}\n\t\tac->image_width = ac->memory_mapped_file->width;\n\t\tac->image_height = ac->memory_mapped_file->height;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.60630077429937}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tbool command_handled = true;\n\tWbCamera *c = (WbCamera *) d;\n\tswitch (command) {\n\t\tcase C_CAMERA_MEMORY_MAPPED_FILE:\n\t\t\tif (r->data_size != sizeof(WbCameraMemoryMappedFileRequest)) {\n\t\t\t\tfprintf(stderr, \"Received a malformed request from the supervisor for the 'wb_camera_memory_mapped_file' function.\n\");\n\t\t\t\tr->status = -EINVAL;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (c->memory_mapped_file != NULL)\n\t\t\t\twb_memory_mapped_file_delete(c->memory_mapped_file);\n\t\t\tc->memory_mapped_file = wb_memory_mapped_file_new(((WbCameraMemoryMappedFileRequest *) r->data)->path, ((WbCameraMemoryMappedFileRequest *) r->data)->size);\n\t\t\tif (c->memory_mapped_file == NULL) {\n\t\t\t\tfprintf(stderr, \"Failed to create the memory-mapped file for the camera.\n\");\n\t\t\t\tr->status = -EIO;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr->status = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcommand_handled = false;\n\t\t\tbreak;\n\t}\n\treturn command_handled;\n}", "CodeBleu_score": 60.47107205116805}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint result = -1;\n\tWbAbstractCamera *camera = (WbAbstractCamera *) d;\n\n\tif (camera->mutex)\n\t\tpthread_mutex_lock(camera->mutex);\n\n\tif (camera->image_data)\n\t\tresult = camera->image_data->height;\n\n\tif (camera->mutex)\n\t\tpthread_mutex_unlock(camera->mutex);\n\n\treturn result;\n}", "CodeBleu_score": 47.31501174408634}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint result;\n\tWbAbstractCamera *camera;\n\tif(d == NULL)\n\t\treturn -1;\n\tcamera = d->pdata;\n\tif(camera == NULL)\n\t\treturn -1;\n\trobot_mutex_lock(camera->mutex);\n\tresult = camera->height;\n\trobot_mutex_unlock(camera->mutex);\n\treturn result;\n}", "CodeBleu_score": 45.04671768010865}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\treturn wb_abstract_camera_get_width(d);\n}", "CodeBleu_score": 2.917667738578457}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tstruct Accelerometer *accelerometer;\n\tif (tag < 0 || tag >= WB_DEVICES_COUNT || devices[tag].type != WB_NODE_ACCELEROMETER) {\n\t\tfprintf(stderr, \"Invalid device tag.\n\");\n\t\treturn -1;\n\t}\n\trobot_mutex_lock(devices[tag].mutex);\n\taccelerometer = (struct Accelerometer *)devices[tag].device;\n\tif (accelerometer) {\n\t\tsampling_period = accelerometer->sampling_period;\n\t} else {\n\t\tfprintf(stderr, \"Device not initialized.\n\");\n\t\trobot_mutex_unlock(devices[tag].mutex);\n\t\treturn -1;\n\t}\n\trobot_mutex_unlock(devices[tag].mutex);\n\treturn sampling_period;\n}", "CodeBleu_score": 43.11910561433079}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tstruct Accelerometer *accelerometer;\n\tif (tag < 0 || tag >= WB_MAX_ROBOTS) {\n\t\tfprintf(stderr, \"Error: Invalid device tag.\n\");\n\t\treturn -1;\n\t}\n\trobot_mutex_lock(accelerometer_mutexes[tag]);\n\taccelerometer = accelerometer_get_struct(tag);\n\tif (accelerometer == NULL) {\n\t\trobot_mutex_unlock(accelerometer_mutexes[tag]);\n\t\treturn -1;\n\t}\n\tsampling_period = accelerometer->sampling_period;\n\trobot_mutex_unlock(accelerometer_mutexes[tag]);\n\treturn sampling_period;\n}", "CodeBleu_score": 46.557679413399214}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period = 0;\n\tstruct accelerometer_t accelerometer;\n\n\tif (wb_accelerometer_get_struct(tag, &accelerometer) == 0) {\n\t\tsampling_period = accelerometer.sampling_period;\n\t} else {\n\t\tfprintf(stderr, \"Error: wb_accelerometer_get_sampling_period() failed: invalid device tag.\n\");\n\t}\n\n\treturn sampling_period;\n}", "CodeBleu_score": 40.29768444440679}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms = dmsString;\n\tfree(dmsString);\n\treturn dms;\n}", "CodeBleu_score": 43.95046110648649}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms(dmsString);\n\tfree(dmsString);\n\treturn dms;\n}", "CodeBleu_score": 40.27371132774727}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tdouble degrees = 0;\n\tdouble minutes = 0;\n\tdouble seconds = 0;\n\tchar *degreesMinutesSeconds = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree, degrees, minutes, seconds);\n\tstring result = string(degreesMinutesSeconds);\n\tfree(degreesMinutesSeconds);\n\treturn result;\n}", "CodeBleu_score": 41.40252203185448}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdAASSERT (g && plane);\n\tdUASSERT (g->type == dBoxClass, \"argument not a box\");\n\tdVector3 p;\n\tp[0] = x - g->final_posr->pos[0];\n\tp[1] = y - g->final_posr->pos[1];\n\tp[2] = z - g->final_posr->pos[2];\n\tdReal sign;\n\tdReal f;\n\tf = dFabs (p[0]);\n\tif (f < dFabs (p[1])) {\n\t\tif (f < dFabs (p[2])) {\n\t\t\t/* use x-axis */\n\t\t\tplane[0] = 1;\n\t\t\tsign = (p[0] > 0) ? 1 : -1;\n\t\t\tplane[1] = 0;\n\t\t\tplane[2] = 0;\n\t\t\tplane[3] = sign * g->final_posr->R[0];\n\t\t}\n\t\telse {\n\t\t\t/* use z-axis */\n\t\t\tplane[0] = 0;\n\t\t\tplane[1] = 0;\n\t\t\tplane[2] = 1;\n\t\t\tsign = (p[2] > 0) ? 1 : -1;\n\t\t\tplane[3] = sign * g->final_posr->R[2];\n\t\t}\n\t}\n\telse {\n\t\tif (dFabs (p[2]) < dFabs (p[1])) {\n\t\t\t/* use z-axis */\n\t\t\tplane[0] = 0;\n\t\t\tplane[1] = 0;\n\t\t\tplane[2] = 1;\n\t\t\tsign = (p[2] > 0) ? 1 : -1;\n\t\t\tplane[3] = sign * g->final_posr->R[2];\n\t\t}\n\t\telse {\n\t\t\t/* use y-axis */\n\t\t\tplane[0] = 0;\n\t\t\tplane[1] = 1;\n\t\t\tplane[2] = 0;\n\t\t\tsign = (p[1] > 0) ? 1 : -1;\n\t\t\tplane[3] = sign * g->final_posr->R[1];\n\t\t}\n", "CodeBleu_score": 29.15459329685258}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdAASSERT (g && plane);\n\tdUASSERT (g->type == dBoxClass, \"argument not a box\");\n\n\tdVector3 p;\n\tdGeomBoxPointDepth (g, x, y, z, p);\n\tplane[0] = p[0];\n\tplane[1] = p[1];\n\tplane[2] = p[2];\n\tplane[3] = -dCalcVectorDot3(p,p);\n}", "CodeBleu_score": 15.308198492872721}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdAASSERT (g && plane);\n\tdUASSERT (g->type == dBoxClass,\"argument not a box\");\n\tdVector3 p;\n\tdGeomBoxPointDepth (g,x,y,z,&p[0],&p[1],&p[2]);\n\tdReal depth = dFabs(p[0])+dFabs(p[1])+dFabs(p[2]);\n\tplane[0] = p[0] > 0 ? 1 : -1;\n\tplane[1] = p[1] > 0 ? 1 : -1;\n\tplane[2] = p[2] > 0 ? 1 : -1;\n\tplane[3] = depth * 0.5f;\n}", "CodeBleu_score": 19.648818526036518}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\ndUASSERT (box, \"box not given\")\ndUASSERT (box->body, \"box has no body\")\ndUASSERT (box->flags & dBOX_IMMERSION_TEST_MASK, \"box flags invalid\")\ndUASSERT (fluidPlane, \"fluid plane not given\")\n\ndAASSERT (immersion)\n\nsBoxImmersionData data (box, fluidPlane, flags, immersion);\nreturn data.performImmersionChecking();\n}", "CodeBleu_score": 56.785760290343234}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT (box && box->body, \"invalid box or body\");\ndUASSERT (fluidPlane && immersion, \"invalid fluid plane or immersion\");\ndUASSERT (box->side[0] >= 0 && box->side[1] >= 0 && box->side[2] >= 0,\n      \"invalid box side lengths\");\ndUASSERT (box->side[0] > 0 && box->side[1] > 0 && box->side[2] > 0,\n      \"zero or negative box side lengths\");\n\ndUASSERT (flags >= 0 && flags <= 7, \"invalid flags\");\n\ndUASSERT (box->geomClass == dBoxClass, \"box is not a box\");\n\nsBoxImmersionData data (box, fluidPlane, flags, immersion);\nreturn data.performImmersionChecking();\n}", "CodeBleu_score": 51.042428978217345}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdAASSERT (box && fluidPlane && immersion);\ndUASSERT (box->body, \"A box must have a body\");\ndUASSERT (box->flags >= 0 && box->flags <= 7, \"Invalid box flags\");\n\nimmersion->box = box;\nimmersion->fluidPlane = fluidPlane;\nimmersion->flags = flags;\nimmersion->result = dIERR_UNKNOWN;\n\nreturn data.performImmersionChecking (data, immersion);\n}", "CodeBleu_score": 48.23938138981019}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdAASSERT(o1 && o2 && immersion);\n\tdUASSERT(o1->type == dBoxClass,\"argument 1 is not a box\");\n\tdUASSERT(o2->type == dCapsuleClass,\"argument 2 is not a capsule\");\n\treturn dImmerseBox(o1, o2, flags, immersion);\n}", "CodeBleu_score": 23.66940512020089}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT(o1->type == dBoxClass);\n\tdIASSERT(o2->type == dCapsuleClass);\n\tdIASSERT(flags == 0);\n\tdIASSERT(immersion != NULL);\n\n\tdAASSERT(o1->space_id == o2->space_id);\n\tdAASSERT(o1->space_id == immersion->space_id);\n\n\tconst dReal *p1 = o1->final_posr->pos;\n\tconst dReal *R1 = o1->final_posr->R;\n\tconst dReal *p2 = o2->final_posr->pos;\n\tconst dReal *R2 = o2->final_posr->R;\n\tconst dReal *normal = R2 + 2;\n\tconst dReal radius = o2->radius;\n\tconst dReal half_height = o2->lz * REAL(0.5);\n\tconst dReal *extents = o1->final_aabb->extents;\n\n\tdReal depth;\n\tdVector3 p;\n\tdVector3 n;\n\tdVector3 Rn;\n\tdVector3 Rp;\n\tdReal Rn_dot_Rn;\n\tdReal Rn_dot_Rp;\n\tdReal Rp_dot_Rp;\n\tdReal Rp_dot_Rn;\n\tdReal Rn_dot_normal;\n\tdReal Rp_dot_normal;\n\tdReal Rn_dot_p;\n\tdReal Rp_dot_p;\n\tdReal Rn_dot_e;\n\tdReal Rp_dot_e;\n\tdReal Rn_dot_n;\n\tdReal Rp_dot_n;\n\tdReal Rn_dot_R;\n\tdReal Rp_dot_R;\n\tdReal Rn_dot_Rn_plus_Rp_dot_Rp;\n\tdReal Rn_dot_Rn_minus_Rp_dot_Rp;\n\tdReal Rn_dot_Rp_plus_Rn_dot_Rp;\n\tdReal Rn_dot_Rp_minus_Rn_dot_Rp;\n\tdReal Rp_dot_Rn_plus_Rn_dot_", "CodeBleu_score": 33.510401519254444}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tconst dReal *p1 = o1->final_posr->pos;\n\tconst dReal *p2 = o2->final_posr->pos;\n\tconst dReal *R1 = o1->final_posr->R;\n\tconst dReal *R2 = o2->final_posr->R;\n\tconst dReal *side1 = o1->side;\n\tconst dReal *side2 = o2->side;\n\tconst dReal *radius = o2->radius;\n\tconst dReal *normal = o2->normal;\n\tdReal depth;\n\tdReal penetration;\n\tdReal depth_max;\n\tdVector3 p1_local;\n\tdVector3 p2_local;\n\tdVector3 R1_local;\n\tdVector3 R2_local;\n\tdVector3 side1_local;\n\tdVector3 side2_local;\n\tdVector3 normal_local;\n\tdMatrix3 R1_local_inv;\n\tdMatrix3 R2_local_inv;\n\tdVector4 plane;\n\tdVector3 p1_local_proj;\n\tdVector3 p2_local_proj;\n\tdReal side1_local_proj;\n\tdReal side2_local_proj;\n\tdReal radius_local_proj;\n\tdReal depth_local_proj;\n\tdReal penetration_local_proj;\n\tdReal depth_local_proj_max;\n\tdVector3 p1_local_proj_max;\n\tdVector3 p2_local_proj_max;\n\tdReal side1_local_proj_max;\n\tdReal side2_local_proj_max;\n\tdReal radius_local_proj_max;\n\tdReal depth_local_proj_min;\n\tdVector3 p1_local_proj_min;\n\tdVector3 p2_local_proj_min;\n\tdReal side1_local_proj_min;\n\tdReal side2_local_proj_min;\n\tdReal radius_local_proj_min;\n\tdReal depth_local_proj_min_max;\n\tdVector3 p1_local_proj_min", "CodeBleu_score": 22.126092083129635}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal volume = 0;\n\tdReal z0 = 0;\n\tdReal z1 = 0;\n\tdReal z2 = 0;\n\tdReal z3 = 0;\n\tdReal z4 = 0;\n\tdReal z5 = 0;\n\tdReal z6 = 0;\n\tdReal z7 = 0;\n\tdReal z8 = 0;\n\tdReal z9 = 0;\n\tdReal z10 = 0;\n\tdReal z11 = 0;\n\tdReal z12 = 0;\n\tdReal z13 = 0;\n\tdReal z14 = 0;\n\tdReal z15 = 0;\n\tdReal z16 = 0;\n\tdReal z17 = 0;\n\tdReal z18 = 0;\n\tdReal z19 = 0;\n\tdReal z20 = 0;\n\tdReal z21 = 0;\n\tdReal z22 = 0;\n\tdReal z23 = 0;\n\tdReal z24 = 0;\n\tdReal z25 = 0;\n\tdReal z26 = 0;\n\tdReal z27 = 0;\n\tdReal z28 = 0;\n\tdReal z29 = 0;\n\tdReal z30 = 0;\n\tdReal z31 = 0;\n\tdReal z32 = 0;\n\tdReal z33 = 0;\n\tdReal z34 = 0;\n\tdReal z35 = 0;\n\tdReal z36 = 0;\n\tdReal z37 = 0;\n\tdReal z38 = 0;\n\tdReal z39 = 0;\n\tdReal z40 = 0;\n\tdReal z41 = 0;\n\tdReal z42 = 0;\n\tdReal z43 = 0;\n\tdReal z44 = 0;\n\tdReal z45 = 0;\n\tdReal z46 =", "CodeBleu_score": 10.215358300638256}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal volume = 0.0;\n\tdReal z0 = zIOverR * tanTheta0;\n\tdReal z1 = zIOverR * sinTheta1;\n\tdReal dz = (z1 - z0) / 2.0;\n\tvolume += dz * (zIOverR * zIOverR * sinTheta1 * sinTheta1 + 2.0 * zIOverR * zIOverR * tanTheta0 * sinTheta1 + zIOverR * zIOverR * tanTheta0 * tanTheta0);\n\tvolume += dz * (zIOverR * zIOverR * sinTheta1 * sinTheta1 + 2.0 * zIOverR * zIOverR * tanTheta0 * sinTheta1 + zIOverR * zIOverR * tanTheta0 * tanTheta0);\n\treturn volume;\n}", "CodeBleu_score": 35.52104234016825}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal volume = 0.0;\n\tdReal z = zIOverR*R;\n\tdReal zOverR = z/R;\n\tdReal zOverR3 = zOverR*zOverR*zOverR;\n\tdReal zOverR5 = zOverR3*zOverR*zOverR;\n\tdReal zOverR7 = zOverR5*zOverR*zOverR;\n\tdReal zOverR9 = zOverR7*zOverR*zOverR;\n\tdReal zOverR11 = zOverR9*zOverR*zOverR;\n\tdReal zOverR13 = zOverR11*zOverR*zOverR;\n\tdReal zOverR15 = zOverR13*zOverR*zOverR;\n\tdReal zOverR17 = zOverR15*zOverR*zOverR;\n\tdReal zOverR19 = zOverR17*zOverR*zOverR;\n\tdReal zOverR21 = zOverR19*zOverR*zOverR;\n\tdReal zOverR23 = zOverR21*zOverR*zOverR;\n\tdReal zOverR25 = zOverR23*zOverR*zOverR;\n\tdReal zOverR27 = zOverR25*zOverR*zOverR;\n\tdReal zOverR29 = zOverR27*zOverR*zOverR;\n\tdReal zOverR31 = zOverR29*zOverR*zOverR;\n\tdReal zOverR33 = zOverR31*zOverR*zOverR;\n\tdReal zOverR35 = zOverR33*zOverR*zOverR;\n\tdReal zOverR37 = zOverR35*zOverR*zOverR;\n\tdReal zOverR39 = zOverR37*zOverR*zOverR;\n\tdReal zOverR41 = zOverR39*zOverR*zOverR;\n\tdReal zOverR", "CodeBleu_score": 32.327387893583044}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\tdReal zIOverR2 = zIOverR*zIOverR;\n\tdReal zIOverR3 = zIOverR2*zIOverR;\n\tdReal zIOverR4 = zIOverR3*zIOverR;\n\tdReal zIOverR5 = zIOverR4*zIOverR;\n\tdReal zIOverR6 = zIOverR5*zIOverR;\n\tdReal zIOverR7 = zIOverR6*zIOverR;\n\tdReal zIOverR8 = zIOverR7*zIOverR;\n\tdReal zIOverR9 = zIOverR8*zIOverR;\n\tdReal zIOverR10 = zIOverR9*zIOverR;\n\tdReal zIOverR11 = zIOverR10*zIOverR;\n\tdReal zIOverR12 = zIOverR11*zIOverR;\n\tdReal zIOverR13 = zIOverR12*zIOverR;\n\tdReal zIOverR14 = zIOverR13*zIOverR;\n\tdReal zIOverR15 = zIOverR14*zIOverR;\n\tdReal zIOverR16 = zIOverR15*zIOverR;\n\tdReal zIOverR17 = zIOverR16*zIOverR;\n\tdReal zIOverR18 = zIOverR17*zIOverR;\n\tdReal zIOverR19 = zIOverR18*zIOverR;\n\tdReal zIOverR20 = zIOverR19*zIOverR;\n\tdReal zIOverR21 = zIOverR20*zIOverR;\n\tdReal zIOverR22 = zIOverR21*zIOverR;\n\tdReal zIOverR23 = zIOverR22*zIOverR;\n\tdReal zIOverR24 = zIOverR23*zIOverR;\n\t", "CodeBleu_score": 34.175612479854856}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\treturn (volume * (zIOverR + (0.5 * (1.0 + tanTheta0) * sinTheta1) / tanTheta0)) / (M_PI * r * r);\n}", "CodeBleu_score": 29.44998059598244}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\treturn volume*(0.5*zIOverR*(zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR*zIOverR", "CodeBleu_score": 17.096759529103384}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdReal depthRatio, tangent, sinAngle, volume, radius, xCenter, yCenter, zCenter, xBuoyancyCenter, yBuoyancyCenter, zBuoyancyCenter, volumeRatio, volumeRatioSquared, volumeRatioCubed, volumeRatioTo2, volumeRatioTo3, volumeRatioTo4, volumeRatioTo5, volumeRatioTo6, volumeRatioTo7, volumeRatioTo8, volumeRatioTo9, volumeRatioTo10, volumeRatioTo11, volumeRatioTo12, volumeRatioTo13, volumeRatioTo14, volumeRatioTo15, volumeRatioTo16, volumeRatioTo17, volumeRatioTo18, volumeRatioTo19, volumeRatioTo20, volumeRatioTo21, volumeRatioTo22, volumeRatioTo23, volumeRatioTo24, volumeRatioTo25, volumeRatioTo26, volumeRatioTo27, volumeRatioTo28, volumeRatioTo29, volumeRatioTo30, volumeRatioTo31, volumeRatioTo32, volumeRatioTo33, volumeRatioTo34, volumeRatioTo35, volumeRatioTo36, volumeRatioTo37, volumeRatioTo38, volumeRatioTo39, volumeRatioTo40, volumeRatioTo41, volumeRatioTo42, volumeRatioTo43, volumeRatioTo44, volumeRatioTo45, volumeRatioTo46, volumeRatioTo47, volumeRatioTo48, volumeRatioTo49, volumeRatioTo50, volumeRatioTo51, volumeRatioTo52, volumeRatioTo53, volumeRatioTo54, volumeRatioTo55, volumeRatioTo56, volumeRatioTo57, volumeRatioTo58, volumeRatioTo59, volumeRatioTo60, volumeRatioTo61, volumeRatioTo62, volumeRatioTo63, volumeRatioTo64, volumeRatioTo65, volumeRatioTo66, volumeRatioTo67, volumeRatioTo68, volumeRatioTo69, volumeRatioTo70, volumeRatioTo71, volumeRatioTo72, volumeRatioTo73, volumeRatioTo74, volumeRatioTo75, volumeRatioTo76, volumeRatioTo77, volumeRatioTo78, volumeRatioTo7", "CodeBleu_score": 6.789352700046765}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tint i;\n\tdVector3 tmp;\n\tdReal tmp1, tmp2;\n\tdReal volume, volume1, volume2, volume3, volume4, volume5;\n\tdReal cos_theta1, cos_theta2, cos_theta3, cos_theta4, cos_theta5;\n\tdReal sin_theta1, sin_theta2, sin_theta3, sin_theta4, sin_theta5;\n\tdReal theta1, theta2, theta3, theta4, theta5;\n\tdReal radius, depth, depth_ratio, depth_ratio_squared;\n\tdReal x1, x2, x3, x4, x5;\n\tdReal y1, y2, y3, y4, y5;\n\tdReal z1, z2, z3, z4, z5;\n\tdReal x_buoyancy_center, y_buoyancy_center, z_buoyancy_center;\n\tdReal x_center, y_center, z_center;\n\tdReal x_center_squared, y_center_squared, z_center_squared;\n\tdReal x_center_cubed, y_center_cubed, z_center_cubed;\n\tdReal x_center_fourth, y_center_fourth, z_center_fourth;\n\tdReal x_center_fifth, y_center_fifth, z_center_fifth;\n\tdReal x_center_sixth, y_center_sixth, z_center_sixth;\n\tdReal x_center_seventh, y_center_seventh, z_center_seventh;\n\tdReal x_center_eighth, y_center_eighth, z_center_eighth;\n\tdReal x_center_ninth, y_center_ninth, z_center_ninth;\n\tdReal x_center_tenth, y_center_tenth, z_center_tenth;\n\tdReal x_center_eleventh, y_center_eleventh, z_center_eleventh;\n\tdReal x_center_twelfth, y_center_twelfth, z", "CodeBleu_score": 5.931678561504334}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tint i;\n\tdVector3 p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12;\n\tdReal x, y, z;\n\tdReal r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;\n\tdReal h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11, h12;\n\tdReal h13, h14, h15, h16;\n\tdReal h17, h18, h19, h20;\n\tdReal h21, h22, h23, h24;\n\tdReal h25, h26, h27, h28;\n\tdReal h29, h30, h31, h32;\n\tdReal h33, h34, h35, h36;\n\tdReal h37, h38, h39, h40;\n\tdReal h41, h42, h43, h44;\n\tdReal h45, h46, h47, h48;\n\tdReal h49, h50, h51, h52;\n\tdReal h53, h54, h55, h56;\n\tdReal h57, h58, h59, h60;\n\tdReal h61, h62, h63, h64;\n\tdReal h65, h66, h67, h68;\n\tdReal h69, h70, h71, h72;\n\tdReal h73, h74, h75, h76;\n\tdReal h77, h78, h79, h80;\n\tdReal h81, h82, h83, h84;\n\tdReal h85,", "CodeBleu_score": 5.323759077286944}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get the sleep duration in milliseconds from the input\n\tauto sleep_duration = getInput<std::chrono::milliseconds>();\n\tif (!sleep_duration) {\n\t\t// The duration is missing or non-positive\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start a timer to wake up the node after the specified duration\n\ttimer_.add(sleep_duration.value(), std::bind(&SleepNode::onTimer, this));\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_.setCallback(std::bind(&SleepNode::emitWakeUpSignal, this));\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 39.124473734660626}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Retrieve the sleep duration in milliseconds from the input.\n\tconst auto sleep_duration_ms = getInput<std::chrono::milliseconds>(\"sleep_duration_ms\");\n\tif (!sleep_duration_ms) {\n\t\t// The sleep duration is missing or non-positive.\n\t\tROS_WARN_STREAM_THROTTLE(5, \"Missing or non-positive sleep duration. \" << *sleep_duration_ms);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING.\n\tROS_INFO_STREAM_THROTTLE(5, \"Setting node status to RUNNING...\");\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start a timer to wake up the node after the specified duration.\n\tROS_INFO_STREAM_THROTTLE(5, \"Starting timer to wake up the node after \" << *sleep_duration_ms << \" milliseconds...\");\n\ttimer_ = createTimer(*sleep_duration_ms, std::bind(&SleepNode::onTimer, this));\n\n\t// Set a callback to emit a wake-up signal when the timer expires.\n\tROS_INFO_STREAM_THROTTLE(5, \"Setting callback to emit a wake-up signal when the timer expires...\");\n\ttimer_.setCallback(std::bind(&SleepNode::emitWakeUpSignal, this));\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 41.349622890487694}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Retrieve the sleep duration in milliseconds from the input\n\tconst std::chrono::milliseconds sleep_duration = getInput<std::chrono::milliseconds>(\"sleep_duration\");\n\t// If the duration is missing or non-positive, return SUCCESS\n\tif (!sleep_duration.count()) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\t// Start a timer with the specified duration\n\ttimer_.add(sleep_duration, std::bind(&SleepNode::onTimer, this));\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_.setCallback(std::bind(&SleepNode::emitWakeUpSignal, this));\n\t// Return RUNNING\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 42.613814508726236}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Get the blackboard and entry\n\tBlackboard::Ptr blackboard = this->blackboard_ptr_;\n\tBlackboard::PtrEntry entry = this->entry_ptr_;\n\n\t// Check if the entry exists\n\tif (!entry) {\n\t\tROS_ERROR(\"EntryUpdatedAction: Could not find entry '%s'\", entry_name_.c_str());\n\t\treturn FAILURE;\n\t}\n\n\t// Lock the entry mutex\n\tentry->mutex_.lock();\n\n\t// Check if the entry has been updated\n\tif (entry->sequence_id_ != entry->sequence_id_updated_) {\n\t\t// Update the sequence ID\n\t\tentry->sequence_id_ = entry->sequence_id_updated_;\n\n\t\t// Unlock the entry mutex\n\t\tentry->mutex_.unlock();\n\n\t\t// Return SUCCESS\n\t\treturn SUCCESS;\n\t}\n\n\t// Unlock the entry mutex\n\tentry->mutex_.unlock();\n\n\t// Return FAILURE\n\treturn FAILURE;\n}", "CodeBleu_score": 26.09213089870868}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t// Retrieve the entry\nBlackboard::Ptr blackboard = getBlackboard();\nEntry entry = blackboard->getEntry(entry_name_);\n\n// Lock the entry's mutex\nif (!entry.mutex.try_lock()) {\nROS_WARN_STREAM(\"Could not lock mutex for entry '\" << entry_name_ << \"'\");\nreturn NodeStatus::FAILURE;\n}\n\n// Compare the sequence IDs\nif (entry.sequence_id != sequence_id_) {\n// Update the sequence ID\nsequence_id_ = entry.sequence_id;\n\n// Unlock the entry's mutex\nentry.mutex.unlock();\n\n// Return success\nreturn NodeStatus::SUCCESS;\n}\n\n// Unlock the entry's mutex\nentry.mutex.unlock();\n\n// Return failure\nreturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 44.5788914886896}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Get the entry\n\tBlackboard::Ptr blackboard = this->blackboard_client_->getBlackboard();\n\tif (!blackboard) {\n\t\tROS_ERROR(\"Failed to get the blackboard\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tBlackboard::Entry entry = blackboard->getEntry(this->entry_name_);\n\tif (!entry) {\n\t\tROS_ERROR(\"Failed to get the entry %s\", this->entry_name_.c_str());\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the entry mutex\n\tif (!entry.lock(this->node_handle_)) {\n\t\tROS_ERROR(\"Failed to lock the entry mutex\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Get the sequence ID\n\tint64_t sequence_id = entry.getSequenceId();\n\tif (sequence_id < 0) {\n\t\tROS_ERROR(\"Failed to get the sequence ID\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Check if the sequence ID has changed\n\tif (this->last_sequence_id_ != sequence_id) {\n\t\t// Update the last sequence ID\n\t\tthis->last_sequence_id_ = sequence_id;\n\t\tROS_INFO(\"Entry %s has been updated\", this->entry_name_.c_str());\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\telse {\n\t\treturn NodeStatus::FAILURE;\n\t}\n}", "CodeBleu_score": 44.997656638327946}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn std::max(static_cast<size_t>(0), static_cast<size_t>(-success_threshold_ * children_nodes_.size()));\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 53.95474066616253}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn std::max(static_cast<size_t>(0), static_cast<size_t>(-success_threshold_ * children_nodes_.size()));\n\t}\n\treturn success_threshold_;\n}", "CodeBleu_score": 53.95474066616253}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn std::max(static_cast<size_t>(0), static_cast<size_t>(children_nodes_.size() + success_threshold_));\n\t} else {\n\t\treturn static_cast<size_t>(success_threshold_);\n\t}\n}", "CodeBleu_score": 57.666378198191616}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\tauto now = std::chrono::system_clock::now();\n\t\tauto elapsed = now - lastHeartbeat;\n\t\tif (elapsed.count() > 1.0) {\n\t\t\tif (heartbeatStatus == HeartbeatStatus::HEALTHY) {\n\t\t\t\theartbeatStatus = HeartbeatStatus::UNHEALTHY;\n\t\t\t\tenableAllHooks();\n\t\t\t} else if (heartbeatStatus == HeartbeatStatus::UNHEALTHY) {\n\t\t\t\theartbeatStatus = HeartbeatStatus::HEALTHY;\n\t\t\t\tdisableAllHooks();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 49.52901901878637}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (this->heartbeatActive) {\n\t\t\tif (this->lastHeartbeatTime + this->heartbeatInterval < std::chrono::system_clock::now()) {\n\t\t\t\tthis->heartbeatActive = false;\n\t\t\t\tthis->disableAllHooks();\n\t\t\t}\n\t\t} else {\n\t\t\tif (this->lastHeartbeatTime + this->heartbeatInterval < std::chrono::system_clock::now()) {\n\t\t\t\tthis->heartbeatActive = true;\n\t\t\t\tthis->enableAllHooks();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 25.770695251683684}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (heartbeatStatus != lastHeartbeatStatus) {\n\t\t\tif (heartbeatStatus) {\n\t\t\t\tenableAllHooks();\n\t\t\t} else {\n\t\t\t\tdisableAllHooks();\n\t\t\t}\n\t\t\tlastHeartbeatStatus = heartbeatStatus;\n\t\t}\n\t}\n}", "CodeBleu_score": 28.669781178725597}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\tnlohmann::json j;\n\n\tstd::vector<std::string> bb_names;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\n\tfor (std::string bb_name : bb_names) {\n\t\tauto it = _p->subtrees.find(bb_name);\n\t\tif (it != _p->subtrees.end()) {\n\t\t\tstd::unique_lock<std::mutex> lock(it->second.lock);\n\t\t\tif (it->second.blackboard) {\n\t\t\t\tnlohmann::json bb_json = ExportBlackboardToJSON(it->second.blackboard);\n\t\t\t\tj[bb_name] = bb_json;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = nlohmann::json::to_msgpack(j);\n\treturn result;\n}", "CodeBleu_score": 53.921764740273495}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\nstd::vector<uint8_t> msgpack_dump;\n\nnlohmann::json json_dump;\n\nstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\nfor (const std::string& bb_name : bb_names) {\n\nauto it = _p->subtrees.find(bb_name);\n\nif (it != _p->subtrees.end()) {\n\nstd::unique_lock<std::mutex> lock(it->second.lock);\n\nif (it->second.subtree) {\n\nnlohmann::json subtree_dump = ExportBlackboardToJSON(it->second.subtree);\n\njson_dump[bb_name] = subtree_dump;\n\n}\n\n}\n\n}\n\nmsgpack_dump = nlohmann::json::to_msgpack(json_dump);\n\nreturn msgpack_dump;\n\n}", "CodeBleu_score": 54.04034698133942}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\tnlohmann::json json_result;\n\tstd::vector<std::string> bb_names = splitString(bb_list, ',');\n\tfor (auto bb_name : bb_names) {\n\t\tauto it = _p->subtrees.find(bb_name);\n\t\tif (it != _p->subtrees.end()) {\n\t\t\tauto subtree = it->second.lock();\n\t\t\tif (subtree) {\n\t\t\t\tsubtree->lock.lock();\n\t\t\t\tauto json_bb = ExportBlackboardToJSON(subtree);\n\t\t\t\tjson_result[bb_name] = json_bb;\n\t\t\t\tsubtree->lock.unlock();\n\t\t\t}\n\t\t}\n\t}\n\tresult = nlohmann::json::to_msgpack(json_result);\n\treturn result;\n}", "CodeBleu_score": 55.11042527513478}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tstd::unique_lock<std::recursive_mutex> lk(_p->lock);\n\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif (it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\n\tauto hook = it->second.lock();\n\tif (!hook) {\n\t\treturn false;\n\t}\n\n\tif (hook->mode != NodeMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\thook->status = result;\n\thook->remove = remove;\n\thook->ready = true;\n\thook->wakeup.notify_all();\n\treturn true;\n}", "CodeBleu_score": 54.683672117384596}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tauto it = _p->nodes_by_uid.find(node_uid);\n\tif (it == _p->nodes_by_uid.end()) {\n\t\treturn false;\n\t}\n\tauto hook = it->second.lock();\n\tif (!hook) {\n\t\treturn false;\n\t}\n\tstd::unique_lock<std::mutex> lk(hook->lock);\n\tif (hook->status != NodeStatus::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->status = result;\n\thook->remove = remove;\n\thook->ready = true;\n\thook->wakeup.notify_all();\n\treturn true;\n}", "CodeBleu_score": 54.05990141346222}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tif (!checkNode(node_uid)) return false;\n\n\tNode *node = getNode(node_uid);\n\tif (node->status != NodeStatus::BREAKPOINT) return false;\n\n\tstd::lock_guard<std::mutex> lk(node->lock);\n\tif (node->status != NodeStatus::BREAKPOINT) return false;\n\n\tnode->status = result;\n\tnode->remove = remove;\n\tnode->ready = true;\n\tnode->hook->wakeup.notify_all();\n\n\treturn true;\n}", "CodeBleu_score": 32.96552347522647}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t// If the node is not running, start a new thread to run the tick function\nif (status_ != NodeStatus::RUNNING) {\n// Set the node status to RUNNING\nsetStatus(NodeStatus::RUNNING);\n// Reset the halt request flag\nhalt_requested_ = false;\n// Run the tick function in a new thread\nstd::async(std::launch::async, [this] {\n// Call the tick function\ntick();\n});\n}\n\n// If an exception occurred, rethrow it\nif (std::current_exception()) {\nstd::rethrow_exception(std::current_exception());\n}\n\n// If the node is running, check for a halt request\nif (status_ == NodeStatus::RUNNING && halt_requested_) {\n// Set the node status to IDLE\nsetStatus(NodeStatus::IDLE);\n}\n\n// Return the current node status\nreturn status_;\n}", "CodeBleu_score": 31.244455873222797}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus status;\n\nif (status_ == NodeStatus::IDLE) {\nstatus_ = NodeStatus::RUNNING;\nhalt_requested_ = false;\n\nstd::async(std::launch::async, [this] {\ntry {\ntick();\n} catch (const std::exception& e) {\nROS_ERROR_STREAM(\"Exception in BT::ThreadedAction::tick: \" << e.what());\n}\n});\n}\n\nif (!halt_requested_) {\nstatus = status_;\n} else {\nstatus = NodeStatus::IDLE;\n}\n\nif (std::current_exception()) {\nstd::rethrow_exception(std::current_exception());\n}\n\nreturn status;\n}", "CodeBleu_score": 37.78200863320975}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\t// If the node is not running, start it\n\tif (status_ != NodeStatus::RUNNING) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\n\t\t// Start a new thread to run the tick function\n\t\tthread_ = std::async(std::launch::async, &ThreadedAction::tick, this);\n\t}\n\n\t// If the tick function has completed, update the node status\n\tif (thread_.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {\n\t\ttry {\n\t\t\tthread_.get();\n\t\t} catch (const std::exception& e) {\n\t\t\tROS_ERROR_STREAM(\"Exception in \" << name_ << \" tick function: \" << e.what());\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t\t// Check for any stored exceptions and rethrow them if present\n\t\tif (!stored_exceptions_.empty()) {\n\t\t\tthrow stored_exceptions_.front();\n\t\t}\n\t\treturn status_;\n\t}\n\n\t// If an exception occurs, catch it, log an error, and set the node status to IDLE\n\tif (std::current_exception()) {\n\t\ttry {\n\t\t\tstd::rethrow_exception(std::current_exception());\n\t\t} catch (const std::exception& e) {\n\t\t\tROS_ERROR_STREAM(\"Exception in \" << name_ << \" tick function: \" << e.what());\n\t\t\tstatus_ = NodeStatus::IDLE;\n\t\t}\n\t}\n\n\treturn status_;\n}", "CodeBleu_score": 40.568483967188826}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstream << \"----------------------------------------\n\";\n\tauto print_node = [&stream](const TreeNode* node, int depth) {\n\t\tstream << std::string(depth * 2, ' ') << node->name << \"\n\";\n\t};\n\tauto print_children = [&print_node, &stream](const TreeNode* node, int depth) {\n\t\tfor (const TreeNode* child : node->children) {\n\t\t\tprint_node(child, depth + 1);\n\t\t\tif (dynamic_cast<const ControlNode*>(node)) {\n\t\t\t\tprint_children(child, depth + 1);\n\t\t\t}\n\t\t}\n\t};\n\tprint_node(root_node, 0);\n\tprint_children(root_node, 0);\n\tstream << \"----------------------------------------\n\";\n}", "CodeBleu_score": 35.097748284409356}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\n}", "CodeBleu_score": 3.8627219268601167}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tstd::function<void(const TreeNode*, int)> print_helper = [=](const TreeNode* node, int depth) {\nif (node != nullptr) {\nstream << std::string(depth * 2, ' ') << node->name << std::endl;\nif (const ControlNode* control = dynamic_cast<const ControlNode*>(node)) {\nfor (const TreeNode* child : control->children) {\nprint_helper(child, depth + 1);\n}\n} else if (const DecoratorNode* decorator = dynamic_cast<const DecoratorNode*>(node)) {\nprint_helper(decorator->child, depth + 1);\n}\n}\n};\nprint_helper(root_node, 0);\n}", "CodeBleu_score": 30.95349933263708}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\nthrow LogicError(\"null node\");\n}\nvisitor(node);\nif (const ControlNode* control = dynamic_cast<const ControlNode*>(node)) {\nfor (const TreeNode* child : control->children) {\napplyRecursiveVisitor(child, visitor);\n}\n} else if (const DecoratorNode* decorator = dynamic_cast<const DecoratorNode*>(node)) {\napplyRecursiveVisitor(decorator->child, visitor);\n} else {\nthrow LogicError(\"node is neither a ControlNode nor a DecoratorNode\");\n}\n}", "CodeBleu_score": 58.154807992554055}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (node == nullptr) {\nthrow LogicError(\"The node cannot be null\");\n}\nvisitor(node);\nif (const auto control = dynamic_cast<const ControlNode*>(node)) {\nfor (const auto& child : control->children) {\napplyRecursiveVisitor(child, visitor);\n}\n} else if (const auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\napplyRecursiveVisitor(decorator->child, visitor);\n}\n}", "CodeBleu_score": 58.01579518316717}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr) {\n\t\tthrow LogicError(\"node is nullptr\");\n\t}\n\tvisitor(node);\n\tif (const auto* control = dynamic_cast<const ControlNode*>(node)) {\n\t\tfor (const auto* child : control->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (const auto* decorator = dynamic_cast<const DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child, visitor);\n\t}\n}", "CodeBleu_score": 58.97835289489348}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\t// Check if the registration ID already exists in the builders map\n\tif (_p->builders.find(manifest.registrationID) != _p->builders.end()) {\n\t\tROS_ERROR(\"The registration ID [%s] is already registered.\", manifest.registrationID.c_str());\n\t\tthrow BehaviorTreeException(\"The registration ID is already registered\");\n\t}\n\n\t// Insert the builder and manifest into their respective maps using the registration ID\n\t_p->builders[manifest.registrationID] = builder;\n\t_p->manifests[manifest.registrationID] = manifest;\n}", "CodeBleu_score": 49.863138493224255}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\nBehaviorTreeException\n_p->manifests.insert\nBehaviorTreeException\n_p->builders.insert\n}", "CodeBleu_score": 13.356453664340329}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (manifest.registration_ID == \"\") {\n\t\tthrow BehaviorTreeException(\"Cannot register a builder without a registration ID\");\n\t}\n\tif (_p->builders.find(manifest.registration_ID) != _p->builders.end()) {\n\t\tthrow BehaviorTreeException(\"A builder with the same ID is already registered\");\n\t}\n\t_p->builders[manifest.registration_ID] = builder;\n\t_p->manifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 57.93096031346403}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\nreturn std::make_unique<SimpleActionNode>(name, config, tick_functor);\n};\nregisterBuilder<SimpleActionNode>(ID, std::move(ports), std::move(builder));\n}", "CodeBleu_score": 60.840242235954555}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\nreturn std::make_unique<SimpleActionNode>(name, config, tick_functor);\n};\nregisterBuilder(ID, std::move(builder), std::move(ports));\n}", "CodeBleu_score": 60.09479048942752}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\nreturn std::make_unique<SimpleActionNode>(name, config, tick_functor);\n};\nregisterBuilder(ID, builder, std::move(ports));\n}", "CodeBleu_score": 56.54077960911091}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backup;\n\tbb_backup.reserve(tree.subtrees.size());\n\tfor (unsigned int i = 0; i < tree.subtrees.size(); ++i) {\n\t\tBlackboard::Ptr bb = Blackboard::create();\n\t\ttree.subtrees[i]->blackboard->cloneInto(bb);\n\t\tbb_backup.push_back(bb);\n\t}\n\treturn bb_backup;\n}", "CodeBleu_score": 54.13473947836223}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backup;\n\tbb_backup.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tauto bb = std::make_shared<Blackboard>();\n\t\tsubtree->blackboard->cloneInto(bb);\n\t\tbb_backup.push_back(bb);\n\t}\n\treturn bb_backup;\n}", "CodeBleu_score": 57.26015503617504}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> bb_backups;\n\tbb_backups.reserve(tree.subtrees.size());\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tBlackboard::Ptr bb = Blackboard::create();\n\t\tsubtree->blackboard->cloneInto(bb);\n\t\tbb_backups.push_back(bb);\n\t}\n\treturn bb_backups;\n}", "CodeBleu_score": 58.1161765854935}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\treturn ParseScript(script).and_then([&](BT::Executor executor) {\nreturn executor.Execute(env);\n});\n}", "CodeBleu_score": 38.535144228920615}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor.value().Execute(env);\n}", "CodeBleu_score": 70.3174172948274}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn executor.value().Execute(env);\n}", "CodeBleu_score": 70.3174172948274}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (handle) throw RuntimeError(\"Library already loaded\");\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tstd::string error = dlerror();\n\t\tif (error.empty()) error = \"Unknown error\";\n\t\tthrow RuntimeError(\"Failed to load library: \" + error);\n\t}\n\tthis->path = path;\n}", "CodeBleu_score": 61.99088602795637}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (handle != nullptr) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tthis->path = path;\n}", "CodeBleu_score": 48.778031998058694}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tif (this->loaded) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\n\tthis->path = path;\n\n\t// Acquire the lock\n\tthis->mutex.lock();\n\n\t// Load the library\n\tthis->handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!this->handle) {\n\t\tstd::string err = dlerror();\n\t\tthis->mutex.unlock();\n\t\tthrow RuntimeError(\"Failed to load library: \" + err);\n\t}\n\n\tthis->loaded = true;\n\n\t// Release the lock\n\tthis->mutex.unlock();\n}", "CodeBleu_score": 46.93321100502039}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tstr = str.trim();\n\tif (str.front() != '{' || str.back() != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 21.9226678541978}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tstr = str.trim();\n\tif (str[0] != '{' || str[str.size() - 1] != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 22.18279267708872}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped_str = str.trim();\n\tif (stripped_str.size() < 2 || stripped_str[0] != '{' || stripped_str[stripped_str.size() - 1] != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped_str.substr(1, stripped_str.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 25.913784534187307}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0.0;\n\tif (!initialized_) {\n\t\tROS_ERROR(\"CostmapModel: CostmapModel is not initialized\");\n\t\treturn cost;\n\t}\n\tif (x0 < 0 || x0 >= size_x_ || y0 < 0 || y0 >= size_y_ || x1 < 0 || x1 >= size_x_ || y1 < 0 || y1 >= size_y_) {\n\t\tROS_ERROR(\"CostmapModel: (x0, y0) = (%d, %d), (x1, y1) = (%d, %d) is out of bounds\", x0, y0, x1, y1);\n\t\treturn cost;\n\t}\n\tcost = getCost(x0, y0);\n\tif (cost < 0.0) {\n\t\treturn cost;\n\t}\n\tcost += getCost(x1, y1);\n\tif (cost < 0.0) {\n\t\treturn cost;\n\t}\n\tcost -= getCost(x0, y1);\n\tif (cost < 0.0) {\n\t\treturn cost;\n\t}\n\tcost -= getCost(x1, y0);\n\tif (cost < 0.0) {\n\t\treturn cost;\n\t}\n\tcost /= 2.0;\n\treturn cost;\n}", "CodeBleu_score": 39.54653138858435}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0;\n\tdouble dx = x1 - x0;\n\tdouble dy = y1 - y0;\n\tdouble err = dx - dy;\n\tint yi = 1;\n\n\tif (dy < 0) {\n\t\tyi = -1;\n\t\tdy = -dy;\n\t}\n\n\tfor (int x = x0, y = y0; x <= x1; x++) {\n\t\tcost += getCost(x, y);\n\t\terr += dy;\n\t\tif (err > 0) {\n\t\t\ty += yi;\n\t\t\terr -= dx;\n\t\t}\n\t}\n\treturn cost;\n}", "CodeBleu_score": 30.366895054776666}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"CostmapModel is not initialized\");\n\t\treturn -1.0;\n\t}\n\n\tif (!isValid(x0, y0) || !isValid(x1, y1)) {\n\t\tROS_ERROR(\"Point (%d, %d) is not valid\", x0, y0);\n\t\treturn -1.0;\n\t}\n\n\tif (x0 == x1 && y0 == y1) {\n\t\treturn pointCost(x0, y0);\n\t}\n\n\tdouble line_cost = 0.0;\n\tunsigned int x, y;\n\tdouble p0_cost, p1_cost;\n\tdouble dx = x1 - x0;\n\tdouble dy = y1 - y0;\n\tdouble slope = dy / dx;\n\tdouble x_step = 0.0;\n\tdouble y_step = 0.0;\n\tdouble error = 0.0;\n\tdouble delta_error = 0.0;\n\n\tif (fabs(slope) < 1.0) {\n\t\tx_step = 1.0;\n\t\ty_step = slope;\n\t} else {\n\t\tx_step = slope;\n\t\ty_step = 1.0;\n\t}\n\n\tif (x0 < x1) {\n\t\tx = x0;\n\t\ty = y0;\n\t} else {\n\t\tx = x1;\n\t\ty = y1;\n\t}\n\n\tp0_cost = pointCost(x, y);\n\tif (p0_cost < 0.0) {\n\t\treturn p0_cost;\n\t}\n\n\tp1_cost = pointCost(x + x_step, y + y_step);\n\tif (p1_cost < 0.0) {\n\t\treturn p1_cost;\n\t}\n\n\tif (p1_cost > p0_cost) {\n\t\tline_cost = p0_cost;\n\t} else {\n\t\tline_cost = p1_cost;\n\t}\n\n\tLineIterator line_it(this, x0, y0, x1, y1);\n\tfor (; line_it.isValid(); line_it.advance()) {\n\t\tx", "CodeBleu_score": 49.71098661383668}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty())  {\nreturn;\n}\nnav_msgs::Path gui_path;\ngui_path.header.frame_id = path[0].header.frame_id;\ngui_path.header.stamp = path[0].header.stamp;\ngui_path.poses.resize(path.size());\nfor (unsigned int i = 0; i < path.size(); i++)  {\ngui_path.poses[i] = path[i];\n}\npub.publish(gui_path);\n}", "CodeBleu_score": 81.83044731261296}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_WARN(\"Path is empty. Not publishing plan.\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Publishing plan\");\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = path[0].header.frame_id;\n\tgui_path.header.stamp = path[0].header.stamp;\n\tfor (size_t i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 77.8690016138062}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\nif (path.empty()) {\nreturn;\n}\n\nnav_msgs::Path gui_path;\ngui_path.header.frame_id = path.front().header.frame_id;\ngui_path.header.stamp = path.front().header.stamp;\ngui_path.poses.resize(path.size());\n\nfor (std::size_t i = 0; i < path.size(); ++i) {\ngui_path.poses[i] = path[i];\n}\n\npub.publish(gui_path);\n}", "CodeBleu_score": 70.20163527757836}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tif (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 84.55008460054115}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tbool stopped = true;\n\tif (fabs(base_odom.twist.twist.angular.z) > rot_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (fabs(base_odom.twist.twist.linear.x) > trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (fabs(base_odom.twist.twist.linear.y) > trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\tif (fabs(base_odom.twist.twist.linear.z) > trans_stopped_velocity) {\n\t\tstopped = false;\n\t}\n\treturn stopped;\n}", "CodeBleu_score": 55.8778784297572}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tbool rot_stopped = fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity;\n\tbool trans_stopped = fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n\treturn rot_stopped && trans_stopped;\n}", "CodeBleu_score": 76.87648835968618}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tboost::mutex::scoped_lock lock(configuration_mutex);\n\tif (setup_done && restore_defaults) {\n\t\tconfig = default_limits;\n\t} else if (!setup_done) {\n\t\tdefault_limits = config;\n\t\tsetup_done = true;\n\t}\n\tcurrent_limits = config;\n}", "CodeBleu_score": 66.25298128900005}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig = default_limits_;\n\t\tsetup_ = false;\n\t}\n\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\tstd::lock_guard<std::mutex> lock(mutex_);\n\tlimits_ = config;\n}", "CodeBleu_score": 62.69641088827041}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tboost::recursive_mutex::scoped_lock lock(config_mutex_);\n\n\tif (restore_defaults) {\n\t\tconfig = default_config_;\n\t\tconfig.setup = true;\n\t} else if (!config.setup) {\n\t\tdefault_config_ = config;\n\t\tconfig.setup = true;\n\t}\n\n\tcurrent_config_ = config;\n}", "CodeBleu_score": 45.60453890716809}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\tif (check_cell->isObstacle() || check_cell->isEmpty()) {\n\t\tcurrent_cell->setTargetDistance(obstacleCosts);\n\t\treturn false;\n\t}\n\n\tdouble current_cost = costmap.getCost(check_cell->getIndex());\n\tdouble current_target_distance = current_cell->getTargetDistance();\n\tdouble new_target_distance = current_cost + current_target_distance;\n\n\tif (new_target_distance < current_target_distance) {\n\t\tcurrent_cell->setTargetDistance(new_target_distance);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 42.35374884307437}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\n/*\n * Get the cost of the cell using the costmap.\n */\n  unsigned int cost = costmap.getCost(check_cell->x, check_cell->y);\n\n/*\n * If the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false.\n */\n  if (cost >= costmap.getObstacleThreshold()) {\n    current_cell->target_distance = costmap.getObstacleThreshold();\n    return false;\n  }\n\n/*\n * If the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter.\n */\n  unsigned int x_diff = current_cell->x - check_cell->x;\n  unsigned int y_diff = current_cell->y - check_cell->y;\n  unsigned int x_diff_sq = x_diff * x_diff;\n  unsigned int y_diff_sq = y_diff * y_diff;\n  unsigned int dist_sq = x_diff_sq + y_diff_sq;\n  unsigned int dist = sqrt(dist_sq);\n  unsigned int new_target_distance = dist + cost;\n  if (new_target_distance < current_cell->target_distance) {\n    current_cell->target_distance = new_target_distance;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 48.33188590333608}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// Check if the cell is an obstacle or has no information.\nif (costmap.getCost(check_cell->x, check_cell->y) >= costmap.getObstacleThreshold()) {\n// The cell is an obstacle.\ncurrent_cell->target_distance = costmap.getObstacleThreshold();\nreturn false;\n}\n// The cell is not an obstacle.\n// Calculate the new target distance.\ndouble new_target_distance = current_cell->distance + check_cell->distance;\n// Check if the new target distance is shorter than the current target distance.\nif (new_target_distance < current_cell->target_distance) {\n// The new target distance is shorter.\ncurrent_cell->target_distance = new_target_distance;\n}\nreturn true;\n}", "CodeBleu_score": 43.55261127325851}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\ndouble scaling_factor = 0.0;\nif (footprint_spec_.size() == 0) {\nROS_ERROR(\"Footprint specification is empty, but is required for obstacle cost function\");\nreturn -9.0;\n}\n\nscaling_factor = getScalingFactor(traj);\n\nfor (int i = 0; i < traj.getPointsSize(); i++) {\ncost += footprintCost(traj.getPoint(i), scaling_factor);\n}\n\nif (!sum_scores_) {\ncost = std::max(cost, 0.0);\n}\n\nreturn cost;\n}", "CodeBleu_score": 38.96487725879656}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\ndouble scaling_factor = 1.0;\nif (footprint_spec_.size() == 0) {\nROS_ERROR(\"Footprint specification is empty. Cannot compute cost function\");\nreturn -9;\n}\n\nfor (int i = 0; i < traj.getPointsSize(); i++) {\nPoint point = traj.getPoint(i);\ncost += footprintCost(point, scaling_factor);\nif (cost < 0.0) {\nreturn cost;\n}\n}\n\nif (sum_scores_) {\nreturn cost;\n} else {\nreturn cost / scaling_factor;\n}\n}", "CodeBleu_score": 42.18474174980454}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\ndouble scaling_factor = 1.0;\nif (footprint_spec_.size() == 0) {\nROS_ERROR(\"Footprint specification is empty\");\nreturn -9;\n}\n\n/*\n * If the trajectory is empty, return the cost\n */\nif (traj.getPointsSize() == 0) {\nreturn cost;\n}\n\n/*\n * Initialize the scaling factor based on the trajectory length\n */\nscaling_factor = getScalingFactor(traj);\n\n/*\n * For each point in the trajectory, calculate the footprint cost and add it to the total cost\n */\nfor (unsigned int i = 0; i < traj.getPointsSize(); i++) {\nPoint point = traj.getPoint(i);\ndouble footprint_cost = footprintCost(point, scaling_factor);\nif (footprint_cost < 0) {\nreturn footprint_cost;\n}\ncost += footprint_cost;\n}\n\n/*\n * If sum_scores_ is true, return the total cost. Otherwise, return the maximum cost\n */\nif (sum_scores_) {\nreturn cost;\n} else {\nreturn std::max(cost, 0.0);\n}\n}", "CodeBleu_score": 51.70360668455424}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n}", "CodeBleu_score": 8.490178557284024}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n/*\n * This function, ObstacleCostFunction::footprintCost, calculates the cost of a robot's footprint at a given position and orientation on a costmap.", "CodeBleu_score": 12.283621944358972}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n/*\n * This function, ObstacleCostFunction::footprintCost, calculates the cost of a robot's footprint at a given position and orientation on a costmap.", "CodeBleu_score": 12.283621944358972}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic == odom_topic_) {\nreturn;\n}\nodom_topic_ = odom_topic;\nif (odom_topic != \"\") {\nROS_INFO(\"Subscribing to odometry topic: %s\", odom_topic_.c_str());\nodom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n}\nelse {\nROS_INFO(\"Unsubscribing from odometry topic\");\nodom_sub_.shutdown();\n}\n}", "CodeBleu_score": 46.92812383632119}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\nodom_topic_ = odom_topic;\nif (odom_topic_.empty()) {\nodom_sub_.shutdown();\n} else {\nodom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n}\n}\n}", "CodeBleu_score": 45.7856819142922}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\n}", "CodeBleu_score": 3.8817094643040866}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// Calculate the squared distance and the angular difference\n\tfloat squared_distance = (pos - prev).squaredNorm();\n\tfloat angular_difference = fabs(pos.angularDistance(prev));\n\n\t// Reset the oscillation flags if the squared distance is greater than the threshold or the angular difference is greater than the set angle\n\tif (squared_distance > squared_distance_threshold || angular_difference > angular_difference_threshold) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 30.807999519331062}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat distance = (pos - prev).squaredNorm();\n\tfloat angle = fabs(atan2(pos.y() - prev.y(), pos.x() - prev.x()) - atan2(this->previous_position_.y() - this->previous_position_.y(), this->previous_position_.x() - this->previous_position_.x()));\n\tif (distance > this->oscillation_distance_threshold_ || angle > this->oscillation_angle_threshold_) {\n\t\tthis->resetOscillationFlags();\n\t}\n}", "CodeBleu_score": 33.07304222492001}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tif (pos.squaredNorm() < 0.00001f) {\n\t\treturn;\n\t}\n\n\tconst float dist_sq = (prev - pos).squaredNorm();\n\tconst float angle = acos(pos.normalized().dot(prev.normalized()));\n\tif (dist_sq > 0.000001f && angle > 0.000001f) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 29.89955111970046}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tint gridIndex = getGridIndex(pt);\n\tif (gridIndex < 0) {\n\t\treturn;\n\t}\n\n\t// Check if the point is too close to its nearest neighbor\n\tif (nearestNeighborDistance > 0) {\n\t\tdouble dist = std::sqrt(std::pow(pt.x - gridCoords[gridIndex].x, 2) + std::pow(pt.y - gridCoords[gridIndex].y, 2));\n\t\tif (dist < nearestNeighborDistance) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Insert the point into the grid\n\tcells_[gridIndex].push_back(pt);\n}", "CodeBleu_score": 44.332525937076184}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tdouble gridIndex[3];\ndouble nearestNeighborDistance;\ndouble gridCoords[3];\n\n// Determine grid coordinates of point\ngridCoords[0] = (pt.x - origin_.x) / resolution_;\ngridCoords[1] = (pt.y - origin_.y) / resolution_;\ngridCoords[2] = (pt.z - origin_.z) / resolution_;\n\n// Check if point is outside grid bounds\nif (gridCoords[0] < 0 || gridCoords[0] >= num_cells_[0] || gridCoords[1] < 0 || gridCoords[1] >= num_cells_[1] || gridCoords[2] < 0 || gridCoords[2] >= num_cells_[2]) {\nreturn;\n}\n\n// Get grid index of point\ngridIndex[0] = floor(gridCoords[0]);\ngridIndex[1] = floor(gridCoords[1]);\ngridIndex[2] = floor(gridCoords[2]);\n\n// Get distance to nearest neighbor\nnearestNeighborDistance = getNearestNeighborDistance(gridIndex);\n\n// Check if point is too close to its nearest neighbor\nif (pt.x - nearestNeighborDistance < origin_.x || pt.y - nearestNeighborDistance < origin_.y || pt.z - nearestNeighborDistance < origin_.z || pt.x + nearestNeighborDistance > origin_.x + resolution_ * num_cells_[0] || pt.y + nearestNeighborDistance > origin_.y + resolution_ * num_cells_[1] || pt.z + nearestNeighborDistance > origin_.z + resolution_ * num_cells_[2]) {\nreturn;\n}\n\n// Insert point into grid\ncells_[gridIndex[0] + gridIndex[1] * num_cells_[0] + gridIndex[2] * num_cells_[0] * num_cells_[1]].push_back(pt);\n}", "CodeBleu_score": 36.49516449422454}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\tif (pt.x > maxX || pt.x < minX || pt.y > maxY || pt.y < minY || pt.z > maxZ || pt.z < minZ) {\n\t\tROS_DEBUG_NAMED(\"point_grid\", \"Point (%f, %f, %f) is outside the grid bounds.\", pt.x, pt.y, pt.z);\n\t\treturn;\n\t}\n\n\t// Get the grid coordinates of the point\n\tint gridX = (int) ((pt.x - minX) / cellSize);\n\tint gridY = (int) ((pt.y - minY) / cellSize);\n\tint gridZ = (int) ((pt.z - minZ) / cellSize);\n\n\t// Calculate the index of the cell\n\tint gridIndex = gridX + gridY * numCellsX + gridZ * numCellsX * numCellsY;\n\n\t// Check if the point is too close to its nearest neighbor\n\tif (nearestNeighborDistance > 0.0) {\n\t\tif (cells_[gridIndex].size() > 0) {\n\t\t\tfloat nearestNeighborDistance = std::numeric_limits<float>::max();\n\t\t\tfor (unsigned int i = 0; i < cells_[gridIndex].size(); i++) {\n\t\t\t\tfloat distance = (cells_[gridIndex][i].x - pt.x) * (cells_[gridIndex][i].x - pt.x) + (cells_[gridIndex][i].y - pt.y) * (cells_[gridIndex][i].y - pt.y) + (cells_[gridIndex][i].z - pt.z) * (cells_[gridIndex][i].z - pt.z);\n\t\t\t\tif (distance < nearestNeighborDistance) {\n\t\t\t\t\tnearestNeighborDistance = distance;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nearestNeighborDistance < this->nearestNeighborDistance * this->nearestNeighborDistance) {\n\t\t\t\tROS_DEBUG_NAMED(\"point_grid\", \"Point (%f, %f, %f) is too close to its nearest neighbor.\", pt.x, pt.y, pt.z);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Insert the point into the cell\n\tcells_[gridIndex].push_back(pt);\n}", "CodeBleu_score": 36.658575577769625}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\\tfor (int i = 0; i < 3; i++) {\n\\t\\t// Check if the target velocity is larger than the current velocity.\n\\t\\tif (sample_target_vel[i] > vel[i]) {\n\\t\\t\\t// If so, check if the target velocity is larger than the maximum acceleration.\n\\t\\t\\tif (sample_target_vel[i] > acclimits[i]) {\n\\t\\t\\t\\t// If so, set the new velocity to the maximum acceleration.\n\\t\\t\\t\\tnew_vel[i] = acclimits[i];\n\\t\\t\\t} else {\n\\t\\t\\t\\t// Otherwise, set the new velocity to the target velocity.\n\\t\\t\\t\\tnew_vel[i] = sample_target_vel[i];\n\\t\\t\\t}\n\\t\\t} else if (sample_target_vel[i] < vel[i]) {\n\\t\\t\\t// If not, check if the target velocity is smaller than the maximum deceleration.\n\\t\\t\\tif (sample_target_vel[i] < -acclimits[i]) {\n\\t\\t\\t\\t// If so, set the new velocity to the maximum deceleration.\n\\t\\t\\t\\tnew_vel[i] = -acclimits[i];\n\\t\\t\\t} else {\n\\t\\t\\t\\t// Otherwise, set the new velocity to the target velocity.\n\\t\\t\\t\\tnew_vel[i] = sample_target_vel[i];\n\\t\\t\\t}\n\\t\\t} else {\n\\t\\t\\t// If the target velocity is equal to the current velocity, set the new velocity to the target velocity.\n\\t\\t\\tnew_vel[i] = sample_target_vel[i];\n\\t\\t}\n\\t}\n\\treturn new_vel;\n}", "CodeBleu_score": 49.33887329144506}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n}", "CodeBleu_score": 6.365155396314788}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n}", "CodeBleu_score": 6.365155396314788}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble goal_theta;\n\tint goal_x, goal_y;\n\tdouble dist;\n\tdouble min_dist = DBL_MAX;\n\tdouble min_dist_theta = DBL_MAX;\n\tdouble min_dist_x = DBL_MAX;\n\tdouble min_dist_y = DBL_MAX;\n\tdouble min_dist_theta_x = DBL_MAX;\n\tdouble min_dist_theta_y = DBL_MAX;\n\tdouble min_dist_theta_x_y = DBL_MAX;\n\tdouble theta;\n\tdouble theta_x;\n\tdouble theta_y;\n\tdouble theta_x_y;\n\tdouble x_y;\n\tdouble dist_x;\n\tdouble dist_y;\n\tdouble dist_theta_x;\n\tdouble dist_theta_y;\n\tdouble dist_theta_x_y;\n\tdouble dist_x_y;\n\tdouble dist_theta;\n\tdouble dist_theta_x_y;\n\tdouble dist_theta_x;\n\tdouble dist_theta_y;\n\tdouble dist_theta_x_y;\n\tdouble dist_x_y;\n\tdouble dist_theta;\n\tdouble dist_theta_x_y;\n\tdouble dist_theta_x;\n\tdouble dist_theta_y;\n\tdouble dist_theta_x_y;\n\tdouble dist_x_y;\n\tdouble dist_theta;\n\tdouble dist_theta_x_y;\n\tdouble dist_theta_x;\n\tdouble dist_theta_y;\n\tdouble dist_theta_x_y;\n\tdouble dist_x_y;\n\tdouble dist_theta;\n\tdouble dist_theta_x_y;\n\tdouble dist_theta_x;\n\tdouble dist_theta_y;\n\tdouble dist_theta_x_y;\n\tdouble dist_x_y;\n\tdouble dist_theta;\n\tdouble dist_theta_x_y;\n\tdouble dist_theta_x;\n\tdouble dist_theta_y;\n\tdouble dist_theta_x_y;\n\tdouble dist_x_y;\n\tdouble dist_theta;\n\tdouble dist_theta_x_y;\n", "CodeBleu_score": 17.138586334317566}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble x_diff, y_diff;\n\tdouble heading_diff = DBL_MAX;\n\tdouble current_heading = heading;\n\tdouble current_x = x;\n\tdouble current_y = y;\n\tdouble x_world, y_world;\n\tdouble angle_to_goal;\n\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\tx_diff = global_plan_[i].x - current_x;\n\t\ty_diff = global_plan_[i].y - current_y;\n\t\tif (fabs(x_diff) < 0.01 && fabs(y_diff) < 0.01) {\n\t\t\tx_world = costmap_.mapToWorld(current_x, current_y).x;\n\t\t\ty_world = costmap_.mapToWorld(current_x, current_y).y;\n\t\t\tangle_to_goal = atan2(y_world - y, x_world - x);\n\t\t\theading_diff = angles::shortest_angular_distance(current_heading, angle_to_goal);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn heading_diff;\n}", "CodeBleu_score": 48.45371339878341}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble goal_x = cell_x;\n\tdouble goal_y = cell_y;\n\tdouble dist = 0;\n\tdouble goal_dist = 0;\n\tdouble goal_angle = 0;\n\tdouble angle = 0;\n\tdouble diff = 0;\n\tdouble goal_diff = 0;\n\tdouble angle_diff = 0;\n\tdouble dist_to_goal = 0;\n\tdouble goal_dist_to_goal = 0;\n\tdouble goal_angle_to_goal = 0;\n\tdouble angle_to_goal = 0;\n\tdouble goal_angle_diff = 0;\n\tdouble angle_diff = 0;\n\tdouble goal_dist_diff = 0;\n\tdouble dist_diff = 0;\n\tdouble goal_angle_to_goal_diff = 0;\n\tdouble angle_to_goal_diff = 0;\n\tdouble goal_dist_to_goal_diff = 0;\n\tdouble dist_to_goal_diff = 0;\n\tdouble goal_heading = 0;\n\tdouble heading_diff = 0;\n\tdouble goal_heading_diff = 0;\n\tdouble heading_to_goal = 0;\n\tdouble heading_to_goal_diff = 0;\n\tdouble goal_heading_to_goal = 0;\n\tdouble goal_heading_to_goal_diff = 0;\n\tdouble heading_to_goal_diff_1 = 0;\n\tdouble heading_to_goal_diff_2 = 0;\n\tdouble heading_to_goal_diff_3 = 0;\n\tdouble heading_to_goal_diff_4 = 0;\n\tdouble heading_to_goal_diff_5 = 0;\n\tdouble heading_to_goal_diff_6 = 0;\n\tdouble heading_to_goal_diff_7 = 0;\n\tdouble heading_to_goal_diff_8 = 0;\n\tdouble heading_to_goal_diff_9 = 0;\n\tdouble heading_to_goal_diff_10 = 0;\n\tdouble heading_to_goal_diff_11 = 0;\n\tdouble heading_", "CodeBleu_score": 10.442024063582881}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost < 0) {\n\t\tROS_WARN_STREAM(\"Invalid trajectory with cost \" << cost << \" found for (\" << x << \", \" << y << \", \" << theta << \") with velocities (\" << vx << \", \" << vy << \", \" << vtheta << \").\");\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 63.310298382611684}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\nROS_INFO(\"Checking trajectory with vx=%f, vy=%f, vtheta=%f\", vx, vy, vtheta);\n\n// Calculate the cost of the trajectory\ndouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n// Check if the cost is non-negative\nif (cost >= 0) {\nROS_INFO(\"Trajectory is valid with cost %f\", cost);\nreturn true;\n}\n\n// If the cost is negative, log a warning and return false\nROS_WARN(\"Invalid trajectory with cost %f\", cost);\nreturn false;\n\n}", "CodeBleu_score": 66.77009568346121}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t// TODO: Your code here\n  // Compute and return the cost of the trajectory\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost < 0) {\n    ROS_WARN_STREAM(\"Invalid trajectory: \" << \"x: \" << x << \", y: \" << y << \", theta: \" << theta << \", vx: \" << vx << \", vy: \" << vy << \", vtheta: \" << vtheta);\n  }\n  return cost >= 0;\n}", "CodeBleu_score": 61.52909371469517}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {", "CodeBleu_score": 2.1523366406219733}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\nROS_ERROR(\"ClearCostmapRecovery is not initialized, cannot run behavior\");\nreturn;\n}\nif (!global_costmap_ || !local_costmap_) {\nROS_ERROR(\"ClearCostmapRecovery has a NULL costmap, cannot run behavior\");\nreturn;\n}\n\nif (invert_area_to_clear_) {\nROS_WARN(\"Clearing all costs inside the specified area\");\n} else {\nROS_WARN(\"Clearing all costs outside the specified area\");\n}\n\nros::WallTime t0 = ros::WallTime::now();\n\nif (std::string::npos != affected_maps_.find(\"global_costmap\")) {\nROS_WARN(\"Clearing the global costmap\");\nglobal_costmap_->clearMap(invert_area_to_clear_);\n}\n\nif (std::string::npos != affected_maps_.find(\"local_costmap\")) {\nROS_WARN(\"Clearing the local costmap\");\nlocal_costmap_->clearMap(invert_area_to_clear_);\n}\n\nif (update_maps_) {\nROS_WARN(\"Updating the global and local costmaps\");\nlocal_costmap_->updateMap();\nglobal_costmap_->updateMap();\n}\n\nROS_ERROR(\"Clearing costmaps took %f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 47.03601089822551}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\nROS_ERROR(\"ClearCostmapRecovery: Behavior is not initialized, but run() method was called. Please call initialize() to use this behavior\");\nreturn;\n}\nif (!global_costmap_ || !local_costmap_) {\nROS_ERROR(\"ClearCostmapRecovery: Costmap is not set, but run() method was called. Please set costmap using setCostmap()\");\nreturn;\n}\nROS_WARN(\"ClearCostmapRecovery: Clearing costmap. Area to clear: (%f, %f, %f, %f). Invert area: %s. Clearing maps: %s\", x_min_, x_max_, y_min_, y_max_, invert_area_to_clear_ ? \"True\" : \"False\", affected_maps_.c_str());\nif (affected_maps_.find(\"global_costmap\") != std::string::npos) {\nif (invert_area_to_clear_) {\nROS_WARN(\"ClearCostmapRecovery: Clearing inside specified area\");\n} else {\nROS_WARN(\"ClearCostmapRecovery: Clearing outside specified area\");\n}\nif (force_clear_) {\nglobal_costmap_->clear();\n}\nglobal_costmap_->updateMap();\nROS_WARN(\"ClearCostmapRecovery: Clearing global costmap took %f seconds\", (ros::WallTime::now() - t0).toSec());\n}\nif (affected_maps_.find(\"local_costmap\") != std::string::npos) {\nif (invert_area_to_clear_) {\nROS_WARN(\"ClearCostmapRecovery: Clearing inside specified area\");\n} else {\nROS_WARN(\"ClearCostmapRecovery: Clearing outside specified area\");\n}\nif (force_clear_) {\nlocal_costmap_->clear();\n}\nlocal_costmap_->updateMap();\nROS_WARN(\"ClearCostmapRecovery: Clearing local costmap took %f seconds\", (ros::WallTime::now() - t0).toSec());\n}\n}", "CodeBleu_score": 45.992485087529886}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty())\n\t\treturn;\n\tpolygon_cells.clear();\n\tpolygon_cells.reserve(polygon.size() * 2);\n\tfor (unsigned int i = 0; i < polygon.size() - 1; i++) {\n\t\traytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n\t}\n\traytraceLine(polygon[polygon.size() - 1], polygon[0], polygon_cells);\n}", "CodeBleu_score": 47.881391939063846}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif(polygon.empty())\n\t\treturn;\n\tpolygon_cells.clear();\n\tpolygon_cells.reserve(polygon.size());\n\tMapLocation prev_point = polygon.back();\n\tfor(const MapLocation& point : polygon) {\n\t\tpolygon_cells.insert(polygon_cells.end(), raytraceLine(prev_point, point));\n\t\tprev_point = point;\n\t}\n\t// close the polygon\n\tpolygon_cells.insert(polygon_cells.end(), raytraceLine(prev_point, polygon.front()));\n}", "CodeBleu_score": 31.50251333177173}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\n\t// add the first point\n\tpolygon_cells.push_back(polygon.front());\n\n\t// iterate through the polygon points\n\tfor (std::vector<MapLocation>::const_iterator it = polygon.begin(); it != polygon.end(); ++it) {\n\t\t// get the next point\n\t\tstd::vector<MapLocation>::const_iterator next_it = it + 1;\n\t\tif (next_it == polygon.end()) {\n\t\t\tnext_it = polygon.begin();\n\t\t}\n\n\t\t// get the cells between the two points\n\t\traytraceLine(it->x, it->y, next_it->x, next_it->y, polygon_cells);\n\t}\n}", "CodeBleu_score": 32.5226633583803}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid);\n}", "CodeBleu_score": 73.1143176438417}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tROS_DEBUG_NAMED(\"costmap_2d_publisher\", \"New subscriber to costmap_2d detected. Preparing grid data and publishing to %s.\", pub.getTopic());\n\tprepareGrid();\n\tpub.publish(grid);\n}", "CodeBleu_score": 52.72307936392008}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tROS_INFO(\"New subscriber detected\");\n\tprepareGrid();\n\tpub.publish(grid);\n}", "CodeBleu_score": 58.475285921265666}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\tmutex_.lock();\ngrid_.header.stamp = ros::Time::now();\ngrid_.info.resolution = costmap_->getResolution();\ngrid_.info.width = costmap_->getSizeInCellsX();\ngrid_.info.height = costmap_->getSizeInCellsY();\ngrid_.info.origin.position.x = costmap_->getOriginX();\ngrid_.info.origin.position.y = costmap_->getOriginY();\ngrid_.info.origin.orientation.w = 1.0;\ngrid_.data.resize(grid_.info.width * grid_.info.height);\nint index = 0;\nfor (unsigned int i = 0; i < costmap_->getSizeInCellsY(); i++) {\nfor (unsigned int j = 0; j < costmap_->getSizeInCellsX(); j++) {\ngrid_.data[index] = translation_table_[costmap_->getCharMap()[i * costmap_->getSizeInCellsX() + j]];\nindex++;\n}\n}\nmutex_.unlock();\n}", "CodeBleu_score": 52.51961461061223}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap mutex\n\tcostmap_->getMutex()->lock();\n\n\t// Get the costmap's resolution\n\tresolution_ = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\n\t// Set the grid's resolution\n\tgrid_.info.resolution = resolution_;\n\n\t// Set the grid's width and height\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tgeometry_msgs::Point origin_world_coords;\n\torigin_world_coords = costmap_->mapToWorld(0, 0);\n\n\t// Set the origin's position and orientation\n\tgrid_.info.origin.position.x = origin_world_coords.x;\n\tgrid_.info.origin.position.y = origin_world_coords.y;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Save the origin coordinates\n\torigin_x_ = origin_world_coords.x;\n\torigin_y_ = origin_world_coords.y;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (int i = 0; i < grid_.info.width; i++) {\n\t\tfor (int j = 0; j < grid_.info.height; j++) {\n\t\t\tgrid_.data[j * grid_.info.width + i] = costmap_->getCharMap()[j * costmap_->getSizeInCellsX() + i];\n\t\t}\n\t}\n\n\t// Unlock the costmap mutex\n\tcostmap_->getMutex()->unlock();\n}", "CodeBleu_score": 59.599427494224265}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = costmap_->getResolution();\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tint index = 0;\n\tfor (unsigned int i = 0; i < costmap_->getSizeInCellsX(); i++) {\n\t\tfor (unsigned int j = 0; j < costmap_->getSizeInCellsY(); j++) {\n\t\t\tgrid_.data[index] = costmap_->getCharMap()[i][j];\n\t\t\tindex++;\n\t\t}\n\t}\n}", "CodeBleu_score": 50.04825127645238}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n}", "CodeBleu_score": 4.80081231526899}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.robot_radius != old_config.robot_radius) {\nROS_DEBUG(\"Robot radius changed from %f to %f\", old_config.robot_radius, new_config.robot_radius);\nsetUnpaddedRobotFootprint(new_config.robot_radius);\n}\nif (new_config.footprint != old_config.footprint) {\nROS_DEBUG(\"Footprint changed from %s to %s\", old_config.footprint.c_str(), new_config.footprint.c_str());\nmakeFootprintFromString(new_config.footprint);\n}\n}", "CodeBleu_score": 44.18648006136421}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.robot_radius != old_config.robot_radius) {\nROS_DEBUG(\"Costmap2DROS::readFootprintFromConfig(): Robot radius has changed. Updating robot footprint.\");\nsetUnpaddedRobotFootprint(new_config.robot_radius);\n}\nif (!new_config.footprint_spec.empty()) {\nROS_DEBUG(\"Costmap2DROS::readFootprintFromConfig(): Footprint spec has changed. Updating robot footprint.\");\nif (!makeFootprintFromString(new_config.footprint_spec)) {\nROS_ERROR(\"Costmap2DROS::readFootprintFromConfig(): Footprint spec is invalid. Using default footprint.\");\nsetUnpaddedRobotFootprint(new_config.robot_radius);\n}\n}\n}", "CodeBleu_score": 46.034347156801694}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// Get the current robot pose\n\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN_THROTTLE(1, \"Could not get robot pose. Canceling reconfiguration.\");\n\t\treconfigure_server.cancel();\n\t\treturn;\n\t}\n}", "CodeBleu_score": 40.2510381025563}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\n//  // get the current robot pose\n//  geometry_msgs::PoseStamped current_pose;\n//  try {\n//    current_pose = getRobotPose();\n//  }\n//  catch (tf::TransformException &ex) {\n//    ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose from TF: %s\", ex.what());\n//    return;\n//  }\n\n  // get the current robot pose\n  geometry_msgs::PoseStamped current_pose = getRobotPose();\n\n  // check if the robot pose is valid\n  if (!current_pose.pose.position.x || !current_pose.pose.position.y) {\n    ROS_WARN_THROTTLE(1.0, \"Invalid robot pose received. Ignoring movement event.\");\n    return;\n  }\n\n  // store the robot pose\n  new_pose = current_pose;\n}", "CodeBleu_score": 51.597439963529744}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tif (getRobotPose(new_pose)) {\n\t\t// Set the current pose to the new pose\n\t\tcurrent_pose = new_pose;\n\t\t// Set the current pose to the new pose\n\t\tcurrent_pose.header.stamp = ros::Time::now();\n\t\t// Publish the current pose to the robot's current pose topic\n\t\tcurrent_pose_pub.publish(current_pose);\n\t}\n\telse {\n\t\tROS_WARN_THROTTLE(1, \"Failed to get the robot's current pose.  Reconfigure the costmap to try again.\");\n\t\t// Cancel the reconfiguration\n\t\treconfigure_server.cancel();\n\t}\n}", "CodeBleu_score": 50.02448929437381}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t// If the costmap is already running, do nothing\nif (initialized_) {\nROS_DEBUG(\"Costmap2DROS::start() called on an already initialized costmap. Ignoring.\");\nreturn;\n}\n\n// Retrieve the list of plugins\nplugin_container_ = layered_costmap_->getPlugins();\n\n// Check if the costmap was stopped\nif (stopped_) {\n// Re-subscribe to topics\nfor (auto plugin : plugin_container_) {\nplugin->activate();\n}\n\n// Set the stopped flag to false\nstopped_ = false;\n}\n\n// Set stop_updates_ to false\nstop_updates_ = false;\n\n// Wait until ROS is running, the costmap is initialized, and the map update thread is active\nros::Rate r(10);\nwhile (!ros::ok() || !initialized_ || !map_update_thread_.get()) {\nr.sleep();\n}\n}", "CodeBleu_score": 50.8929393188688}, {"code": "void Costmap2DROS::start(){\n\t\t// Retrieve the list of plugins\n\tboost::recursive_mutex::scoped_lock lock(mutex_);\n\tplugins_ = layered_costmap_->getPlugins();\n\n\t// Check if the costmap was stopped\n\tif (stopped_) {\n\t\t// Re-subscribe to topics by activating each plugin\n\t\tfor (size_t i = 0; i < plugins_.size(); i++) {\n\t\t\tboost::shared_ptr<Costmap2DPlugin> plugin = plugins_[i];\n\t\t\tplugin->activate();\n\t\t}\n\n\t\t// Set the stopped flag to false\n\t\tstopped_ = false;\n\n\t\t// Set stop_updates_ to false\n\t\tstop_updates_ = false;\n\n\t\t// Wait until ROS is running, the costmap is initialized, and the map update thread is active\n\t\twhile (!initialized_ || !active_) {\n\t\t\tr.sleep();\n\t\t}\n\t}\n}", "CodeBleu_score": 56.676451429302375}, {"code": "void Costmap2DROS::start(){\n\t\tif (initialized_ && !stop_updates_) {\n\t\treturn;\n\t}\n\tif (initialized_) {\n\t\tROS_INFO(\"Re-activating costmap client\");\n\t}\n\tinitialized_ = false;\n\tstop_updates_ = false;\n\tros::NodeHandle nh;\n\tcostmap_ = boost::shared_ptr<Costmap2D>(new Costmap2D(get_name()));\n\tcostmap_ros_ = boost::shared_ptr<Costmap2DROS>(new Costmap2DROS(get_name()));\n\tcostmap_ros_->setCostmap(costmap_);\n\tcostmap_ros_->setRobotPose(pose_);\n\tcostmap_ros_->setFrameId(frame_id_);\n\tcostmap_ros_->setResolution(resolution_);\n\tcostmap_ros_->setOriginX(origin_x_);\n\tcostmap_ros_->setOriginY(origin_y_);\n\tcostmap_ros_->setNegate(negate_);\n\tcostmap_ros_->setOccupancyThres(occupancy_threshold_);\n\tcostmap_ros_->setFreeThres(free_threshold_);\n\tcostmap_ros_->setUnknownThres(unknown_threshold_);\n\tcostmap_ros_->setLETHalton(lethal_threshold_);\n\tcostmap_ros_->setLETHalton2(lethal_threshold_2_);\n\tcostmap_ros_->setLETHalton3(lethal_threshold_3_);\n\tcostmap_ros_->setLETHalton4(lethal_threshold_4_);\n\tcostmap_ros_->setLETHalton5(lethal_threshold_5_);\n\tcostmap_ros_->setLETHalton6(lethal_threshold_6_);\n\tcostmap_ros_->setLETHalton7(lethal_threshold_7_);\n\tcostmap_ros_->setLETHalton8(lethal_threshold_8_);\n\tcostmap_ros_->setLETHalton9(lethal_threshold_9_);\n\tcostmap_ros_->setLETHalton10(lethal_threshold_10_);\n\tcostmap_ros_->setLETHalton11(lethal_threshold", "CodeBleu_score": 33.76771855827121}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == ros::Duration(0.0)) {\n// Keep only the most recent observation.\nobservation_list_.erase(observation_list_.begin(), observation_list_.begin() + (observation_list_.size() - 1));\n} else {\n// Iterate through the list and remove observations that are older than the specified keep time.\nObservationBuffer::ObservationList::iterator it = observation_list_.begin();\nwhile (it != observation_list_.end()) {\nif (it->header.stamp < (ros::Time::now() - observation_keep_time_)) {\nit = observation_list_.erase(it);\n} else {\n++it;\n}\n}\n}\n}", "CodeBleu_score": 44.1006438649066}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == ros::Duration(0.0)) {\n\t\t// Keep only the most recent observation\n\t\tobservation_list_.erase(observation_list_.begin(), observation_list_.begin() + (observation_list_.size() - 1));\n\t} else {\n\t\t// Iterate through the list and remove observations that are older than the specified keep time\n\t\tobservation_list_.erase(observation_list_.begin(), observation_list_.end());\n\t\tobservation_list_.push_back(Observation(ros::Time::now(), 0.0, 0.0, 0.0, 0.0, 0.0));\n\t\tObservationList::iterator it = observation_list_.begin();\n\t\twhile (it != observation_list_.end()) {\n\t\t\tif (it->header.stamp + observation_keep_time_ < ros::Time::now()) {\n\t\t\t\tit = observation_list_.erase(it);\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 48.60825902635318}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t// If the keep time is zero, we can just clear the list.\nif (observation_keep_time_.isZero()) {\nROS_DEBUG_NAMED(\"observation_buffer\", \"Keep time is zero. Purging all observations.\");\nobservation_list_.clear();\nreturn;\n}\n\n// Otherwise, we need to iterate through the list and remove observations older than the keep time.\nROS_DEBUG_NAMED(\"observation_buffer\", \"Keep time is non-zero. Iterating through list and purging observations.\");\nObservationList::iterator it = observation_list_.begin();\nwhile (it != observation_list_.end()) {\n// If the observation is too old, remove it.\nif (it->header.stamp < ros::Time::now() - observation_keep_time_) {\nROS_DEBUG_NAMED(\"observation_buffer\", \"Removing observation with timestamp %f.\", it->header.stamp.toSec());\nit = observation_list_.erase(it);\n} else {\n// Otherwise, just move to the next element in the list.\n++it;\n}\n}\n}", "CodeBleu_score": 37.65193105430741}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n//    std::cout << \"OrientationFilter::interpolate\" << std::endl;\n\n    // Calculate the yaw angles at the start and end indices.\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n    // Determine the shortest angular distance between the start and end yaw angles.\n    double yaw_dist = shortest_angular_distance(start_yaw, end_yaw);\n\n    // Compute the incremental change in angle for each pose in the specified range.\n    double yaw_increment = yaw_dist / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range.\n    for (int i = start_index + 1; i <= end_index; i++) {\n        double yaw = start_yaw + (yaw_increment * (i - start_index));\n        geometry_msgs::Quaternion quat = tf::createQuaternionMsgFromYaw(yaw);\n        path[i].pose.orientation = quat;\n    }\n}", "CodeBleu_score": 60.19207279688018}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n//    ROS_INFO(\"Interpolating path from %d to %d\", start_index, end_index);\n    // Get the yaw angles at the start and end indices\n    double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n    // Calculate the shortest angular distance between the two\n    double yaw_dist = shortest_angular_distance(start_yaw, end_yaw);\n    // Calculate the incremental change in angle for each pose\n    double yaw_increment = yaw_dist / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index; i < end_index; i++) {\n        // Get the current pose's yaw angle\n        double current_yaw = tf2::getYaw(path[i].pose.orientation);\n        // Calculate the new yaw angle\n        double new_yaw = current_yaw + yaw_increment;\n        // Update the pose's orientation\n        set_angle(path[i].pose.orientation, new_yaw);\n    }\n}", "CodeBleu_score": 60.57759330243007}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (path.empty()) {\n\t\tROS_ERROR(\"Empty path given to interpolate function\");\n\t\treturn;\n\t}\n\n\tif (start_index < 0 || start_index >= (int) path.size()) {\n\t\tROS_ERROR(\"Invalid start index given to interpolate function\");\n\t\treturn;\n\t}\n\n\tif (end_index < 0 || end_index >= (int) path.size()) {\n\t\tROS_ERROR(\"Invalid end index given to interpolate function\");\n\t\treturn;\n\t}\n\n\tif (start_index >= end_index) {\n\t\tROS_ERROR(\"Start index must be less than end index\");\n\t\treturn;\n\t}\n\n\t// Calculate the yaw angles at the start and end indices\n\tdouble start_yaw = getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = getYaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble angular_distance = shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Calculate the incremental change in yaw angle for each pose in the range\n\tdouble yaw_increment = angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tset_angle(path[i].pose.orientation, start_yaw + (yaw_increment * (i - start_index)));\n\t}\n}", "CodeBleu_score": 47.83795279454199}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a new plan request\");\n\tresp.plan_found = false;\n\n\t// Set the frame_id to map\n\tstart.header.frame_id = \"map\";\n\tgoal.header.frame_id = \"map\";\n\n\t// Set the start and goal positions\n\tstart.pose.position.x = req.start.pose.position.x;\n\tstart.pose.position.y = req.start.pose.position.y;\n\tstart.pose.orientation = req.start.pose.orientation;\n\n\tgoal.pose.position.x = req.goal.pose.position.x;\n\tgoal.pose.position.y = req.goal.pose.position.y;\n\tgoal.pose.orientation = req.goal.pose.orientation;\n\n\t// Make the plan\n\tmakePlan();\n\n\t// Check if a plan was found\n\tif (path.poses.size() > 0) {\n\t\tresp.plan_found = true;\n\t\tresp.plan = path;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 53.457526177559004}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a make plan request\");\n\n\t// Set the start and goal frame ids to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a plan\n\tnavfn::MakeNavPlan::Response plan = makePlan(req);\n\n\t// Check if a plan was found\n\tif (plan.plan.poses.size() == 0) {\n\t\tROS_WARN(\"No plan found\");\n\t\treturn false;\n\t}\n\n\t// A valid plan was found\n\tROS_INFO(\"Found a plan with %d steps\", (int)plan.plan.poses.size());\n\tresp = plan;\n\treturn true;\n}", "CodeBleu_score": 49.32303551887118}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a make plan request\");\n\n\t// Set the start and goal frame_id to \"map\"\n\tstart.header.frame_id = \"map\";\n\tgoal.header.frame_id = \"map\";\n\n\t// Set the start and goal poses\n\tstart.pose.position.x = req.start.pose.position.x;\n\tstart.pose.position.y = req.start.pose.position.y;\n\tstart.pose.position.z = req.start.pose.position.z;\n\tstart.pose.orientation.x = req.start.pose.orientation.x;\n\tstart.pose.orientation.y = req.start.pose.orientation.y;\n\tstart.pose.orientation.z = req.start.pose.orientation.z;\n\tstart.pose.orientation.w = req.start.pose.orientation.w;\n\n\tgoal.pose.position.x = req.goal.pose.position.x;\n\tgoal.pose.position.y = req.goal.pose.position.y;\n\tgoal.pose.position.z = req.goal.pose.position.z;\n\tgoal.pose.orientation.x = req.goal.pose.orientation.x;\n\tgoal.pose.orientation.y = req.goal.pose.orientation.y;\n\tgoal.pose.orientation.z = req.goal.pose.orientation.z;\n\tgoal.pose.orientation.w = req.goal.pose.orientation.w;\n\n\t// Call makePlan to generate a path\n\tmakePlan(start, goal, resp.plan.poses);\n\n\t// Set the response status to success\n\tresp.status.status = resp.status.SUCCESS;\n\n\tROS_INFO(\"Sending a make plan response\");\n\treturn true;\n}", "CodeBleu_score": 39.80304426962448}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh = ros::NodeHandle(\"~/\" + name);\nmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\ngoal_sub = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 63.23217141378606}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh = ros::NodeHandle(\"~/\" + name);\nmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\ngoal_sub = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 63.23217141378606}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tprivate_nh = ros::NodeHandle(\"~/\" + name);\nmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\ngoal_sub = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 62.5638075840291}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInCellsX() * costmap_->getResolution() || wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInCellsY() * costmap_->getResolution()) {\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 42.3907527384014}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble ox = costmap_->getOriginX();\n\tdouble oy = costmap_->getOriginY();\n\tdouble res = costmap_->getResolution();\n\tint sx = costmap_->getSizeInCellsX();\n\tint sy = costmap_->getSizeInCellsY();\n\n\tif (wx < ox || wy < oy) {\n\t\tROS_WARN(\"GlobalPlanner::worldToMap(): world coordinates (%f, %f) are outside of the costmap's bounds (%f, %f)\", wx, wy, ox, oy);\n\t\treturn false;\n\t}\n\n\tmx = (wx - ox) / res;\n\tmy = (wy - oy) / res;\n\n\tif (mx < 0 || my < 0) {\n\t\tROS_WARN(\"GlobalPlanner::worldToMap(): world coordinates (%f, %f) are outside of the costmap's bounds (%f, %f)\", wx, wy, ox, oy);\n\t\treturn false;\n\t}\n\n\tif (mx >= sx || my >= sy) {\n\t\tROS_WARN(\"GlobalPlanner::worldToMap(): world coordinates (%f, %f) are outside of the costmap's bounds (%f, %f)\", wx, wy, ox, oy);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 57.42303503399629}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n\t\treturn false;\n\t}\n\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\tif (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 45.80012401636419}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\nROS_ERROR(\"Global planner has not been initialized, cannot publish plan\");\nreturn;\n}\n\nnav_msgs::Path gui_path;\ngui_path.header.frame_id = frame_id_;\ngui_path.header.stamp = ros::Time::now();\ngui_path.poses.resize(path.size());\nfor (unsigned int i = 0; i < path.size(); ++i) {\ngui_path.poses[i] = path[i];\n}\n\nROS_INFO(\"Published plan with %d points\", (int) path.size());\nplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 77.81355530077032}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\nROS_ERROR(\"The planner has not been initialized, please call initialize() to use the planner\");\nreturn;\n}\n\nnav_msgs::Path gui_path;\ngui_path.header.frame_id = frame_id_;\ngui_path.header.stamp = ros::Time::now();\ngui_path.poses.resize(path.size());\nfor (unsigned int i = 0; i < path.size(); i++) {\ngui_path.poses[i] = path[i];\n}\n\nROS_INFO(\"Publishing plan\");\nplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 80.92861811087693}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tROS_INFO(\"Publishing plan\");\nif (!initialized_) {\nROS_ERROR(\"Global planner has not been initialized yet, no plan will be published\");\nreturn;\n}\nnav_msgs::Path gui_path;\ngui_path.header.frame_id = frame_id_;\ngui_path.header.stamp = ros::Time::now();\ngui_path.poses.resize(path.size());\nfor (unsigned int i = 0; i < path.size(); ++i) {\ngui_path.poses[i] = path[i];\n}\nplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 79.06657278721372}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Got a new goal\");\n\n// Create a new MoveBaseActionGoal\nMoveBaseActionGoal action_goal;\n\n// Set the timestamp of the action goal to \"now\"\naction_goal.header.stamp = ros::Time::now();\n\n// Assign the goal to the action goal\naction_goal.goal = *goal;\n\n// Publish the action goal\naction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 62.07089144406894}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"Goal received\");\n\tMoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 67.86706353139505}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_STREAM(\"MoveBase::goalCB\");\n\n// Create a MoveBaseActionGoal\nactionlib::SimpleActionGoal<move_base_msgs::MoveBaseActionGoal> action_goal;\n\n// Set the timestamp to the current time\naction_goal.header.stamp = ros::Time::now();\n\n// Assign the goal to the target_pose\naction_goal.goal.target_pose = *goal;\n\n// Publish the action goal to the action_goal_pub_ topic\naction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 66.92957260470921}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tdouble sq_dist = getSqDistance();\nif (sq_dist > sq_dist_limit_) {\nROS_INFO(\"Robot has moved a distance of %f. Stopping.\", sqrt(sq_dist));\nremoveLimitThread_->join();\ndelete removeLimitThread_;\nremoveLimitThread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\ndistance_check_timer_.stop();\n}\n}", "CodeBleu_score": 55.715253784680726}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (getSqDistance() > 0.01) {\n\t\tROS_INFO(\"Distance check failed. Robot has moved %.2f units.\", sqrt(getSqDistance()));\n\t\tif (remove_limit_thread_ != NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t\tremove_limit_thread_ = NULL;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 65.75320673316149}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tdouble sqCurrentDistance = getSqDistance();\nif (sqCurrentDistance >= sqLimitDistance_) {\nROS_INFO(\"Robot has moved a sufficient distance. Stopping...\");\nremoveLimitThread_->join();\ndelete removeLimitThread_;\nremoveLimitThread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\ndistance_check_timer_.stop();\n}\n}", "CodeBleu_score": 57.559816936906905}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Received a new goal\");\n\tgeometry_msgs::PoseStamped pose;\n\tpose = getRobotPose();\n\tROS_INFO(\"Got robot pose\");\n\tmakePlan(pose, goal->pose, plan);\n\tROS_INFO(\"Made plan\");\n}", "CodeBleu_score": 46.88613065398263}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Received a goal pose\");\n\t// Get the current robot pose from the costmap\n\tgeometry_msgs::PoseStamped robot_pose = getRobotPose();\n\t// Generate a path to the goal pose\n\tmakePlan(robot_pose, *goal, path_);\n}", "CodeBleu_score": 41.51186304010432}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Retrieve the current global pose of the robot\n\tgeometry_msgs::PoseStamped robot_pose = getRobotPose();\n\n\t// Generate a plan from the current robot pose to the goal pose\n\tmakePlan(robot_pose, goal->pose, path);\n}", "CodeBleu_score": 37.2784362952062}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tROS_INFO(\"Gimbal param set server called\");\n\tmavros_msgs::ParamValue param_value;\n\tparam_value.param_id = param_set.param_id;\n\tparam_value.value = param_set.value;\n\tparam_set_client_(param_value);\n}", "CodeBleu_score": 49.893562617882125}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create a service request\n\tmavros_msgs::ParamSetRequest request;\n\t// Assign the parameter ID and value from the provided GimbalParamSet structure\n\trequest.param_id = param_set.param_id;\n\trequest.value = param_set.value;\n\t// Call the param_set_client_ to send the request\n\tthis->param_set_client_.call(request);\n}", "CodeBleu_score": 59.127761020195976}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tservice_request_.request.param_id = param_set.param_id;\n\tservice_request_.request.param_value = param_set.param_value;\n\tparam_set_client_.call(service_request_);\n}", "CodeBleu_score": 50.72629657696118}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\tROS_INFO(\"Server thread started\");\n\twhile (ros::ok()) {\n\t\t// Wait for a connection from the ground station\n\t\tROS_INFO(\"Waiting for a connection from the ground station\");\n\t\taccept();\n\t\tROS_INFO(\"Connection accepted\");\n\t\t// Enter a loop to handle incoming connections\n\t\twhile (ros::ok()) {\n\t\t\t// Receive data from the ground station\n\t\t\tROS_INFO(\"Receiving data from the ground station\");\n\t\t\trecv();\n\t\t\t// Process the received data\n\t\t\tROS_INFO(\"Processing the received data\");\n\t\t\tdecodeMsg();\n\t\t\t// Publish the decoded message\n\t\t\tROS_INFO(\"Publishing the decoded message\");\n\t\t\tpubMsg();\n\t\t}\n\t}\n}", "CodeBleu_score": 16.34439512901412}, {"code": "void CommunicationBridge::serverFun(){\n\t\tROS_INFO(\"Server thread started\");\n\tros::NodeHandle n;\n\tros::Rate loop_rate(10);\n\tros::Publisher pub = n.advertise<sensor_msgs::NavSatFix>(\"/fix\", 1000);\n\tint sockfd, newsockfd, portno, clilen;\n\tchar buffer[256];\n\tsocklen_t len;\n\tstruct sockaddr_in serv_addr, cli_addr;\n\tint n_bytes;\n\tsockfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sockfd < 0) {\n\t\tperror(\"ERROR opening socket\");\n\t\texit(1);\n\t}\n\tROS_INFO(\"Socket created\");\n\tbzero((char *) &serv_addr, sizeof(serv_addr));\n\tportno = 8888;\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = INADDR_ANY;\n\tserv_addr.sin_port = htons(portno);\n\tif (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tperror(\"ERROR on binding\");\n\t\texit(1);\n\t}\n\tROS_INFO(\"Socket bound to port %d\", portno);\n\tlisten(sockfd, 5);\n\tROS_INFO(\"Listening for connections\");\n\tclilen = sizeof(cli_addr);\n\twhile (true) {\n\t\tnewsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\t\tif (newsockfd < 0) {\n\t\t\tperror(\"ERROR on accept\");\n\t\t\texit(1);\n\t\t}\n\t\tROS_INFO(\"Connection accepted\");\n\t\twhile (true) {\n\t\t\tn_bytes = recv(newsockfd, buffer, 255, 0);\n\t\t\tif (n_bytes <= 0) {\n\t\t\t\tROS_ERROR(\"ERROR receiving data\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n_bytes > 0) {\n\t\t\t\tROS_INFO(\"Received %d bytes\", n_bytes);\n\t\t\t\tsensor_msgs::NavSatFix msg;\n\t\t\t\tif (decodeMsg", "CodeBleu_score": 43.57529344078959}, {"code": "void CommunicationBridge::serverFun(){\n\t\tROS_INFO(\"Waiting for connection from ground station...\");\n\tint sockfd = waitConnectionFromGroundStation(PORT);\n\tif (sockfd < 0) {\n\t\tROS_ERROR(\"Failed to connect to ground station\");\n\t\texit(1);\n\t}\n\tROS_INFO(\"Connected to ground station\");\n\twhile (true) {\n\t\tint newsockfd = accept(sockfd, (struct sockaddr *) NULL, NULL);\n\t\tif (newsockfd < 0) {\n\t\t\tperror(\"accept\");\n\t\t\tcontinue;\n\t\t}\n\t\tROS_INFO(\"Accepted new connection\");\n\t\tchar buffer[BUFFER_SIZE];\n\t\tint nbytes = recv(newsockfd, buffer, BUFFER_SIZE, 0);\n\t\tif (nbytes <= 0) {\n\t\t\tROS_ERROR(\"Failed to receive message from ground station\");\n\t\t\tclose(newsockfd);\n\t\t\tcontinue;\n\t\t}\n\t\tROS_INFO(\"Received message from ground station\");\n\t\tif (decodeMsg(buffer, nbytes) < 0) {\n\t\t\tROS_ERROR(\"Failed to decode message from ground station\");\n\t\t\tclose(newsockfd);\n\t\t\tcontinue;\n\t\t}\n\t\tROS_INFO(\"Decoded message from ground station\");\n\t\tpubMsg();\n\t\tROS_INFO(\"Published message\");\n\t\tclose(newsockfd);\n\t}\n}", "CodeBleu_score": 49.55532443931601}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (this->simulation_mode_) {\n\t\t// In simulation mode, publish the command to the correct UAV\n\t\tfor (std::map<int, UAVBasic*>::iterator it = this->swarm_control_simulation_.begin(); it != this->swarm_control_simulation_.end(); it++) {\n\t\t\tif ((*it).first == uav_cmd.uav_id) {\n\t\t\t\t(*it).second->uav_cmd_pub_.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// In real mode, publish the command to the UAV\n\t\tthis->uav_basic_->uav_cmd_pub_.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 47.16495805031897}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (!this->simulation_mode_) {\n\t\tthis->uav_basic_->uavCmdPub(uav_cmd);\n\t} else {\n\t\tstd::map<int, UAVBasic*>::iterator it = this->swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it != this->swarm_control_simulation_.end()) {\n\t\t\t(*it).second->uavCmdPub(uav_cmd);\n\t\t}\n\t}\n}", "CodeBleu_score": 58.20591996963055}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (!this->simulation_mode_) {\nthis->uav_basic_->uavCmdPub.publish(uav_cmd);\n} else {\nfor (auto it = this->swarm_control_simulation_.begin(); it != this->swarm_control_simulation_.end(); ++it) {\nif ((*it).first == uav_cmd.uav_id) {\n(*it).second->uavCmdPub.publish(uav_cmd);\n}\n}\n}\n}", "CodeBleu_score": 46.93141868660383}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch (mode_selection.use_mode) {\n\t\tcase REBOOTNX:\n\t\t\tsystem(\"reboot -f\");\n\t\t\tbreak;\n\t\tcase EXITNX:\n\t\t\tsystem(\"reboot\");\n\t\t\tbreak;\n\t\tcase CREATE:\n\t\t\tcreateMode(mode_selection.mode);\n\t\t\tbreak;\n\t\tcase DELETE:\n\t\t\tdeleteMode(mode_selection.mode);\n\t\t\tbreak;\n\t\tcase NONE:\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 30.024832560471935}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\nswitch (mode_selection.use_mode) {\ncase REBOOTNX:\nsystem(\"reboot -f -n\");\nbreak;\ncase EXITNX:\nsystem(\"reboot -f -n\");\nbreak;\ncase CREATE:\ncreateMode(mode_selection.mode_name);\nbreak;\ncase DELETE:\ndeleteMode(mode_selection.mode_name);\nbreak;\ndefault:\nbreak;\n}\n}", "CodeBleu_score": 29.857422508107355}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch(mode_selection.mode) {\n\t\tcase REBOOTNX:\n\t\t\tsystem(\"rebootnx\");\n\t\t\tbreak;\n\t\tcase EXITNX:\n\t\t\tsystem(\"exitnx\");\n\t\t\tbreak;\n\t\tcase CREATE_MODE:\n\t\t\tcreateMode(mode_selection.mode_name, mode_selection.use_mode);\n\t\t\tbreak;\n\t\tcase DELETE_MODE:\n\t\t\tdeleteMode(mode_selection.mode_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 34.1970969759965}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (heartbeat_count == 0) {\n\t\theartbeat_count = 1;\n\t}\n\telse {\n\t\theartbeat_count++;\n\t}\n\n\tif (heartbeat_count > 10) {\n\t\tROS_ERROR_STREAM(\"No heartbeat received from \" << vehicle_type << \" for \" << heartbeat_count << \" attempts.\");\n\t\tif (vehicle_type == \"UGV\") {\n\t\t\tROS_ERROR_STREAM(\"UGV has been disconnected.\");\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t\telse if (vehicle_type == \"UAV\") {\n\t\t\tROS_ERROR_STREAM(\"UAV has been disconnected.\");\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t\telse if (vehicle_type == \"Swarm\") {\n\t\t\tROS_ERROR_STREAM(\"Swarm has been disconnected.\");\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t\telse {\n\t\t\tROS_ERROR_STREAM(\"Vehicle type is not defined.\");\n\t\t}\n\t}\n}", "CodeBleu_score": 36.488809076864015}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\tif (is_connected) {\n// Check for heartbeat\nif (heartbeat_count == 0) {\n// Heartbeat has been lost\nif (vehicle_type == \"uav\") {\n// UAV has been lost\nROS_WARN_STREAM(\"UAV heartbeat lost\");\n}\nelse if (vehicle_type == \"ugv\") {\n// UGV has been lost\nROS_WARN_STREAM(\"UGV heartbeat lost\");\n}\nelse if (vehicle_type == \"swarm\") {\n// Swarm has been lost\nROS_WARN_STREAM(\"Swarm heartbeat lost\");\n}\nelse {\nROS_WARN_STREAM(\"Heartbeat lost\");\n}\n\n// Set the disconnect flag\ndisconnect_flag = true;\n}\nelse {\n// Heartbeat has been received\nif (vehicle_type == \"uav\") {\n// UAV has been found\nROS_INFO_STREAM(\"UAV heartbeat found\");\n}\nelse if (vehicle_type == \"ugv\") {\n// UGV has been found\nROS_INFO_STREAM(\"UGV heartbeat found\");\n}\nelse if (vehicle_type == \"swarm\") {\n// Swarm has been found\nROS_INFO_STREAM(\"Swarm heartbeat found\");\n}\nelse {\nROS_INFO_STREAM(\"Heartbeat found\");\n}\n\n// Reset the heartbeat count\nheartbeat_count = 0;\n}\n}\nelse {\n// Check for heartbeat\nif (heartbeat_count == 0) {\n// Heartbeat has been lost\nif (vehicle_type == \"uav\") {\n// UAV has been lost\nROS_WARN_STREAM(\"UAV heartbeat lost\");\n}\nelse if (vehicle_type == \"ugv\") {\n// UGV has been lost\nROS_WARN_STREAM(\"UGV heartbeat lost\");\n}\nelse if (vehicle_type == \"swarm\") {\n// Swarm has been lost\nROS_WARN_STREAM(\"Swarm heartbeat lost\");\n}\nelse {\nROS_WARN_STREAM(\"Heartbeat lost\");\n}\n}\n\n// Increment the heartbeat count\nheartbeat_count++;\n}\n}", "CodeBleu_score": 37.34847394921758}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// Check for heartbeat loss\n\tif (heartbeat_count_ == 0) {\n\t\tif (heartbeat_timer_running_) {\n\t\t\tROS_ERROR(\"No heartbeat received from vehicle for %f seconds\", heartbeat_timeout_);\n\t\t\theartbeat_timer_running_ = false;\n\t\t\tif (is_uav_ && !is_ugv_) {\n\t\t\t\tROS_ERROR(\"UAV lost connection to vehicle. Triggering UAV land.\");\n\t\t\t\ttriggerUAV(land_type_);\n\t\t\t} else if (is_ugv_) {\n\t\t\t\tROS_ERROR(\"UGV lost connection to vehicle. Triggering UGV land.\");\n\t\t\t\ttriggerUGV(land_type_);\n\t\t\t} else {\n\t\t\t\tROS_ERROR(\"Swarm lost connection to vehicle. Triggering swarm land.\");\n\t\t\t\ttriggerSwarmControl(land_type_);\n\t\t\t}\n\t\t}\n\t} else {\n\t\theartbeat_count_--;\n\t}\n}", "CodeBleu_score": 27.902031815715635}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->traj.size(); i++) {\n\t\tint drone_id = msg->traj[i].header.frame_id;\n\t\tthis->bspline_mutex.lock();\n\t\tthis->bspline_map[drone_id] = Bspline();\n\t\tthis->bspline_map[drone_id].header = msg->traj[i].header;\n\t\tthis->bspline_map[drone_id].traj_id = msg->traj[i].traj_id;\n\t\tthis->bspline_map[drone_id].duration = msg->traj[i].duration;\n\t\tthis->bspline_map[drone_id].period = msg->traj[i].period;\n\t\tthis->bspline_map[drone_id].start_time = msg->traj[i].start_time;\n\t\tthis->bspline_map[drone_id].knots.resize(msg->traj[i].knots.size());\n\t\tthis->bspline_map[drone_id].pos_pts.resize(msg->traj[i].pos_pts.size());\n\t\tthis->bspline_map[drone_id].yaw_pts.resize(msg->traj[i].yaw_pts.size());\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tthis->bspline_map[drone_id].knots[j] = msg->traj[i].knots[j];\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tthis->bspline_map[drone_id].pos_pts[j] = msg->traj[i].pos_pts[j];\n\t\t}\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\tthis->bspline_map[drone_id].yaw_pts[j] = msg->traj[i].yaw_pts[j];\n\t\t}\n\t\tthis->bspline_mutex.unlock();\n\t}\n\tthis->communication->encodeMsg(msg);\n\tthis->communication->sendMsgByTcp();\n}", "CodeBleu_score": 59.63456428600219}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\tint drone_id;\nfor (int i = 0; i < msg->traj.size(); i++) {\n// Get drone ID\ndrone_id = msg->traj[i].header.frame_id;\n// Initialize Bspline struct\nBspline bspline;\nbspline.header.frame_id = drone_id;\nbspline.header.stamp = msg->traj[i].header.stamp;\n// Set Bspline attributes\nbspline.traj_type = msg->traj[i].traj_type;\nbspline.duration = msg->traj[i].duration;\nbspline.pos_pts.resize(msg->traj[i].pos_pts.size());\nbspline.yaw_pts.resize(msg->traj[i].yaw_pts.size());\nbspline.knots.resize(msg->traj[i].knots.size());\n// Populate Bspline knots, position points, and yaw points\nfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\nbspline.knots[j] = msg->traj[i].knots[j];\n}\nfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\nbspline.pos_pts[j] = msg->traj[i].pos_pts[j];\n}\nfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\nbspline.yaw_pts[j] = msg->traj[i].yaw_pts[j];\n}\n// Send Bspline data via TCP\nthis->communication->sendMsgByTcp(this->swarm_name, drone_id, bspline);\n}\n}", "CodeBleu_score": 64.23886711623582}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Extract drone ID from header\n\tint drone_id = atoi(msg->header.frame_id.c_str());\n\t// Iterate through each trajectory in the message\n\tfor (int i = 0; i < msg->traj.size(); i++) {\n\t\t// Initialize Bspline struct\n\t\tBspline bspline;\n\t\tbspline.traj_id = msg->traj[i].traj_id;\n\t\tbspline.knots.clear();\n\t\tbspline.pos_pts.clear();\n\t\tbspline.yaw_pts.clear();\n\t\t// Set Bspline struct attributes\n\t\tbspline.start_time = msg->traj[i].start_time.toSec();\n\t\tbspline.duration = msg->traj[i].duration;\n\t\tbspline.period = msg->traj[i].period;\n\t\tbspline.dt = msg->traj[i].dt;\n\t\tbspline.num_segments = msg->traj[i].num_segments;\n\t\tbspline.num_pts = msg->traj[i].num_pts;\n\t\tbspline.num_knots = msg->traj[i].knots.size();\n\t\tbspline.num_yaw_pts = msg->traj[i].yaw_pts.size();\n\t\t// Populate Bspline struct knots\n\t\tfor (int j = 0; j < msg->traj[i].knots.size(); j++) {\n\t\t\tbspline.knots.push_back(msg->traj[i].knots[j]);\n\t\t}\n\t\t// Populate Bspline struct position points\n\t\tfor (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n\t\t\tgeometry_msgs::Point point;\n\t\t\tpoint.x = msg->traj[i].pos_pts[j].x;\n\t\t\tpoint.y = msg->traj[i].pos_pts[j].y;\n\t\t\tpoint.z = msg->traj[i].pos_pts[j].z;\n\t\t\tbspline.pos_pts.push_back(point);\n\t\t}\n\t\t// Populate Bspline struct yaw points\n\t\tfor (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n\t\t\t", "CodeBleu_score": 70.21977034583719}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Compress the point cloud\n\tstd::vector<uint8_t> compressed_data;\n\toctree_compression.setInputCloud(cloud);\n\toctree_compression.encodePointCloud(compressed_data);\n\n\t// Create a new PointCloud2 message and store the compressed data\n\tsensor_msgs::PointCloud2 output;\n\toutput.header = msg.header;\n\toutput.height = 1;\n\toutput.width = compressed_data.size();\n\toutput.fields.resize(1);\n\toutput.fields[0].name = \"data\";\n\toutput.fields[0].offset = 0;\n\toutput.fields[0].datatype = sensor_msgs::PointField::UINT8;\n\toutput.fields[0].count = 1;\n\toutput.is_bigendian = false;\n\toutput.point_step = 1;\n\toutput.row_step = output.point_step * output.width;\n\toutput.is_dense = true;\n\toutput.data = compressed_data;\n\n\t// Return the compressed message\n\treturn output;\n}", "CodeBleu_score": 38.77648416365634}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n}", "CodeBleu_score": 4.0524330945826055}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n// Create a pcl::PointCloud object from the PointCloud2 message.\npcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZRGB>);\npcl::fromROSMsg (msg, *cloud);\n\n// Compress the point cloud.\npcl::PointCloud<pcl::PointXYZRGB>::Ptr compressed_cloud (new pcl::PointCloud<pcl::PointXYZRGB>);\noctree_compression.setInputCloud (cloud);\noctree_compression.encodePointCloud (compressed_cloud);\n\n// Convert the compressed point cloud to a PointCloud2 message.\nsensor_msgs::PointCloud2 output;\npcl::toROSMsg (*compressed_cloud, output);\noutput.header.stamp = msg.header.stamp;\noutput.header.frame_id = msg.header.frame_id;\n\n// Release dynamically allocated memory.\ncompressed_cloud.reset ();\n\n// Return the compressed PointCloud2 message.\nreturn output;\n}", "CodeBleu_score": 30.47945774413683}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor(int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif(this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 73.41473073454486}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor(int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif(this->multi_uav_state_.uav_state_all.at(i).uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all.replace(i, uav_state);\n\t\t}\n\t}\n}", "CodeBleu_score": 62.663168811144345}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor(int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n\t\tif(this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n\t\t\tthis->multi_uav_state_.uav_state_all[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 73.41473073454486}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_state_all.clear();\n\tmulti_ugv_state.ugv_count = m_multi_ugv_state.ugv_count;\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tUGVState ugv_state;\n\t\tugv_state.ugv_id = m_multi_ugv_state.ugv_state_all[i].ugv_id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state_all[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state_all[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state_all[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state_all[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state_all[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state_all[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state_all[i].velocity.z;\n\t\tugv_state.attitude.x = m_multi_ugv_state.ugv_state_all[i].attitude.x;\n\t\tugv_state.attitude.y = m_multi_ugv_state.ugv_state_all[i].attitude.y;\n\t\tugv_state.attitude.z = m_multi_ugv_state.ugv_state_all[i].attitude.z;\n\t\tugv_state.attitude.w = m_multi_ugv_state.ugv_state_all[i].attitude.w;\n\t\tmulti_ugv_state.ugv_state", "CodeBleu_score": 42.87583193404263}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_state_all.clear();\n\tmulti_ugv_state.ugv_state_all.reserve(m_multi_ugv_state.ugv_state_all.size());\n\tfor (auto ugv_state : m_multi_ugv_state.ugv_state_all) {\n\t\tUGVState ugv_state_msg;\n\t\tugv_state_msg.ugv_id = ugv_state.ugv_id;\n\t\tugv_state_msg.battery = ugv_state.battery;\n\t\tugv_state_msg.position.x = ugv_state.position.x;\n\t\tugv_state_msg.position.y = ugv_state.position.y;\n\t\tugv_state_msg.position.z = ugv_state.position.z;\n\t\tugv_state_msg.velocity.x = ugv_state.velocity.x;\n\t\tugv_state_msg.velocity.y = ugv_state.velocity.y;\n\t\tugv_state_msg.velocity.z = ugv_state.velocity.z;\n\t\tugv_state_msg.attitude.x = ugv_state.attitude.x;\n\t\tugv_state_msg.attitude.y = ugv_state.attitude.y;\n\t\tugv_state_msg.attitude.z = ugv_state.attitude.z;\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state_msg);\n\t}\n\tmulti_ugv_state.ugv_state_all.shrink_to_fit();\n\tmulti_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 40.010303416288885}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// Create the message\n\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.header.stamp = ros::Time::now();\n\tmulti_ugv_state.header.frame_id = \"world\";\n\tmulti_ugv_state.ugv_state_all.clear();\n\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state_all.size(); i++) {\n\t\t// Create the UGVState message\n\t\tUGVState ugv_state;\n\n\t\t// Set the UGV ID\n\t\tugv_state.id = m_multi_ugv_state.ugv_state_all[i].id;\n\n\t\t// Set the UGV battery\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state_all[i].battery;\n\n\t\t// Set the UGV position\n\t\tugv_state.position = m_multi_ugv_state.ugv_state_all[i].position;\n\n\t\t// Set the UGV velocity\n\t\tugv_state.velocity = m_multi_ugv_state.ugv_state_all[i].velocity;\n\n\t\t// Set the UGV attitude\n\t\tugv_state.attitude = m_multi_ugv_state.ugv_state_all[i].attitude;\n\n\t\t// Add the UGVState to the MultiUGVState message\n\t\tmulti_ugv_state.ugv_state_all.push_back(ugv_state);\n\t}\n\n\t// Publish the MultiUGVState message\n\tall_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 39.18257423248227}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// 1. Initialize cost and gradient\ncost = 0.0;\ngradient.setZero(dim_q_, n_control_points_);\n// 2. For each control point\nfor (int i = 0; i < n_control_points_; ++i) {\n// 2.1. Get the position of the control point\nEigen::VectorXd obj_prid = moving_objs_->evaluateConstVel(q, i);\n// 2.2. Calculate the distance between the control point and the predicted position of the moving object\ndouble dist = (cps_.points.col(i) - obj_prid).norm();\n// 2.3. If the distance is less than a specified clearance, update the cost and gradient\nif (dist < clearance_) {\ncost += pow(dist, 2);\ngradient.col(i) = 2 * (cps_.points.col(i) - obj_prid);\n}\n}\n}", "CodeBleu_score": 32.69828435414802}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Clear cost and gradient\n\tcost = 0.0;\n\tgradient = Eigen::MatrixXd::Zero(q.cols(), 1);\n\t// Iterate through all control points\n\tfor (int i = 0; i < cps_.points.cols(); i++) {\n\t\t// Predict the position of moving objects\n\t\tEigen::VectorXd obj_prid = moving_objs_->evaluateConstVel(cps_.points.col(i), q.col(i));\n\t\t// Calculate the distance between the control point and the predicted position\n\t\tdouble dist = (cps_.points.col(i) - obj_prid).norm();\n\t\t// If the distance is less than the clearance, update the cost and gradient\n\t\tif (dist < clearance_) {\n\t\t\tcost += pow(dist, 2);\n\t\t\tgradient.col(i) = 2 * (cps_.points.col(i) - obj_prid).normalized();\n\t\t}\n\t}\n}", "CodeBleu_score": 34.30449349543889}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Check if there are moving objects\n\tif (moving_objs_ == nullptr)\n\t\treturn;\n\n\t// Get the number of control points\n\tint num_cps = cps_.points.cols();\n\n\t// Get the number of moving objects\n\tint num_objs = moving_objs_->getObjNums();\n\n\t// Initialize the cost and gradient\n\tcost = 0.0;\n\tgradient.resize(6, num_cps);\n\tgradient.setZero();\n\n\t// Iterate through control points\n\tfor (int i = 0; i < num_cps; i++) {\n\t\t// Get the control point\n\t\tEigen::Vector3d cp = cps_.points.col(i);\n\n\t\t// Initialize the cost and gradient of the current control point\n\t\tdouble cost_i = 0.0;\n\t\tEigen::Vector3d gradient_i = Eigen::Vector3d::Zero();\n\n\t\t// Iterate through moving objects\n\t\tfor (int j = 0; j < num_objs; j++) {\n\t\t\t// Get the predicted position of the moving object\n\t\t\tEigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(q, i, j);\n\n\t\t\t// Evaluate the distance between control point and the moving object\n\t\t\tdouble dist = (cp - obj_prid).norm();\n\n\t\t\t// Update the cost and gradient of the current control point\n\t\t\tif (dist < clearance_) {\n\t\t\t\tcost_i += pow(dist, 2);\n\t\t\t\tgradient_i += 2 * (cp - obj_prid).normalized() * (dist / clearance_);\n\t\t\t}\n\t\t}\n\n\t\t// Update the cost and gradient\n\t\tcost += cost_i;\n\t\tgradient.col(i) = gradient_i;\n\t}\n}", "CodeBleu_score": 48.02623937360032}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize cost and gradient\n\tcost = 0.0;\n\tgradient.setZero();\n\n\t// Iterate through control points\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// Calculate position error\n\t\tEigen::Vector3d pos_err = ref_pts_[i] - q.col(i);\n\t\t// Calculate velocity vector\n\t\tEigen::Vector3d v = (ref_pts_[i] - ref_pts_[i - 2]).normalized();\n\t\t// Calculate cross product\n\t\tEigen::Vector3d xcrossv = pos_err.cross(v);\n\t\t// Calculate norm of cross product\n\t\tdouble xcrossv_norm = xcrossv.norm();\n\t\t// Calculate cost\n\t\tcost += a2_ * xcrossv_norm * xcrossv_norm + b2_ * xcrossv_norm;\n\n\t\t// Calculate gradient\n\t\tEigen::Vector3d gradient_i = 2.0 * a2_ * xcrossv * xcrossv.transpose() + 2.0 * b2_ * xcrossv;\n\t\t// Update gradient\n\t\tgradient.col(i) = gradient_i;\n\t}\n}", "CodeBleu_score": 35.624065822269365}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tgradient.setZero();\n\tdouble a2 = 1.0 / (2.0 * pow(a_, 2.0));\n\tdouble b2 = 1.0 / (2.0 * pow(b_, 2.0));\n\tfor (int i = 2; i < q.cols(); i++) {\n\t\t// Compute the position error\n\t\tEigen::Vector3d x = q.col(i);\n\t\tEigen::Vector3d xref = ref_pts_[i - 2];\n\t\tEigen::Vector3d xerr = x - xref;\n\t\t// Compute the velocity vector\n\t\tEigen::Vector3d v = (xref - ref_pts_[i - 4]) / 2.0;\n\t\t// Compute the cost\n\t\tcost += a2 * xerr.dot(xerr) + b2 * xerr.cross(v).norm();\n\t\t// Compute the gradient\n\t\tEigen::Vector3d xcrossv = xerr.cross(v);\n\t\tEigen::Vector3d xdot = xerr.dot(xerr);\n\t\tEigen::Vector3d xdotv = xerr.dot(v);\n\t\tEigen::Vector3d xdotvcross = xdotv * xcrossv;\n\t\tEigen::Vector3d xcrossvdot = xcrossv.dot(xerr);\n\t\tEigen::Vector3d xcrossvcross = xcrossv.cross(xerr);\n\t\tEigen::Vector3d xdotvcrossv = xdotv * xcrossvcross;\n\t\tEigen::Vector3d xcrossvcrossv = xcrossv.cross(v);\n\t\tEigen::Vector3d xcrossvdotv = xcrossvdot * v;\n\t\tEigen::Vector3d xdotvcrossvcross = xdotvcross * v;\n\t\tEigen::Vector3d xdotvdot = xdotv * xdot;\n\t\tEigen::Vector3d xdotvdotv = xdotv * xdotv;\n\t\tEigen::Vector3d xdotvdotvcross = xdotv * xdotvcross;\n\t\tEigen::Vector3d xdotvcrossvdot = xdotvcrossv * xdot;\n\t\tEigen::Vector3d xdotvcrossvc", "CodeBleu_score": 38.42969305419665}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tint n = q.cols();\n\tint dim = q.rows();\n\n\tcost = 0;\n\n\tEigen::MatrixXd ref_pts = ref_pts_.topRows(dim);\n\n\tfor (int i = 1; i < n - 2; i++) {\n\t\tEigen::VectorXd x = q.col(i);\n\t\tEigen::VectorXd xprev = q.col(i - 1);\n\t\tEigen::VectorXd xnext = q.col(i + 1);\n\t\tEigen::VectorXd xprevprev = q.col(i - 2);\n\t\tEigen::VectorXd xnextnext = q.col(i + 2);\n\n\t\tEigen::VectorXd xcrossv = (xnext - xprev).cross(x - xprev);\n\t\tEigen::VectorXd xprevcrossv = (x - xprevprev).cross(xprev - xprevprev);\n\t\tEigen::VectorXd xnextcrossv = (xnextnext - xnext).cross(xnextnext - xnextnext);\n\n\t\tdouble xcrossv_norm = xcrossv.norm();\n\t\tdouble xprevcrossv_norm = xprevcrossv.norm();\n\t\tdouble xnextcrossv_norm = xnextcrossv.norm();\n\n\t\tdouble a2 = 0.00001;\n\t\tdouble b2 = 0.00001;\n\t\tdouble c2 = 0.00001;\n\n\t\tdouble a = a2 * xcrossv_norm;\n\t\tdouble b = b2 * xprevcrossv_norm;\n\t\tdouble c = c2 * xnextcrossv_norm;\n\n\t\tdouble dot = xcrossv.dot(ref_pts.col(i));\n\t\tdouble dotprev = xprevcrossv.dot(ref_pts.col(i - 1));\n\t\tdouble dotnext = xnextcrossv.dot(ref_pts.col(i + 1));\n\n\t\tdouble dot_norm = dot / (a2 * xcrossv_norm);\n\t\tdouble dotprev_norm = dotprev / (b2 * xprevcrossv_norm);\n\t\tdouble dotnext_norm = dotnext / (c2 * xnextcrossv_norm);\n\n\t\tdouble cost_i = a * dot_norm *", "CodeBleu_score": 37.316219538150634}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd jerk_ctrl_pts = jerk_traj.getControlPoint();\n\tdouble jerk_total = 0;\n\tfor (int i = 0; i < ctrl_pts.cols(); i++) {\n\t\tfor (int j = 0; j < ctrl_pts.rows(); j++) {\n\t\t\tdouble jerk_val = pow(jerk_ctrl_pts(j, i), 2);\n\t\t\tdouble knot_diff = knot_times[i + 1] - knot_times[i];\n\t\t\tjerk_total += jerk_val * knot_diff;\n\t\t}\n\t}\n\treturn jerk_total;\n}", "CodeBleu_score": 49.44984544297909}, {"code": "double UniformBspline::getJerk(){\n\t\n}", "CodeBleu_score": 1.2218541675839774}, {"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0.0;\n\tdouble diff_time;\n\tdouble diff_pt;\n\tdouble diff_pt_dim;\n\tdouble diff_pt_dim_2;\n\tdouble diff_pt_dim_3;\n\tdouble diff_pt_dim_4;\n\tdouble diff_pt_dim_5;\n\tdouble diff_pt_dim_6;\n\tdouble diff_pt_dim_7;\n\tdouble diff_pt_dim_8;\n\tdouble diff_pt_dim_9;\n\tdouble diff_pt_dim_10;\n\tdouble diff_pt_dim_11;\n\tdouble diff_pt_dim_12;\n\tdouble diff_pt_dim_13;\n\tdouble diff_pt_dim_14;\n\tdouble diff_pt_dim_15;\n\tdouble diff_pt_dim_16;\n\tdouble diff_pt_dim_17;\n\tdouble diff_pt_dim_18;\n\tdouble diff_pt_dim_19;\n\tdouble diff_pt_dim_20;\n\tdouble diff_pt_dim_21;\n\tdouble diff_pt_dim_22;\n\tdouble diff_pt_dim_23;\n\tdouble diff_pt_dim_24;\n\tdouble diff_pt_dim_25;\n\tdouble diff_pt_dim_26;\n\tdouble diff_pt_dim_27;\n\tdouble diff_pt_dim_28;\n\tdouble diff_pt_dim_29;\n\tdouble diff_pt_dim_30;\n\tdouble diff_pt_dim_31;\n\tdouble diff_pt_dim_32;\n\tdouble diff_pt_dim_33;\n\tdouble diff_pt_dim_34;\n\tdouble diff_pt_dim_35;\n\tdouble diff_pt_dim_36;\n\tdouble diff_pt_dim_37;\n\tdouble diff_pt_dim_38;\n\tdouble diff_pt_dim_39;\n\tdouble diff_pt_dim_40;\n\tdouble diff_pt_dim_41;\n\tdouble diff_pt_", "CodeBleu_score": 5.668041974519648}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1;\n\treturn pos;\n}", "CodeBleu_score": 60.79764647195039}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 74.49740701774701}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tfloat x = (u - cx_) * depth / fx_;\n\tfloat y = (v - cy_) * depth / fy_;\n\tfloat z = depth;\n\treturn Eigen::Vector4d(x, y, z, 1.0);\n}", "CodeBleu_score": 50.534064314428676}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstd::string droneID = odom.child_frame_id.substr(0, odom.child_frame_id.find('_'));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (std::exception& e) {\n\t\tROS_ERROR_STREAM(\"Exception caught in rcvDroneXOdomCallback: \" << e.what());\n\t}\n}", "CodeBleu_score": 47.011317191979906}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstd::string droneID = odom.child_frame_id.substr(0, odom.child_frame_id.find('_'));\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t}\n\tcatch (std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 47.03593835441341}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\nint droneID = std::stoi(odom.child_frame_id.substr(1, odom.child_frame_id.size()));\nrcvDroneOdomCallbackBase(odom, droneID);\n}\ncatch (std::invalid_argument& e) {\nROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n}\n}", "CodeBleu_score": 47.17042842406918}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n// Check if the drone is already being tracked\nif (drone_id_to_pose_.find(drone_id) == drone_id_to_pose_.end()) {\n// Drone is not being tracked, so check if it is present in the camera frame\nif (drone_id_to_pixel_.find(drone_id) != drone_id_to_pixel_.end()) {\n// Drone is present in the camera frame, so compute the true pose\nEigen::Vector3d true_pose = computeTruePose(drone_id, true_pixel);\n\n// Check if the true pose is within the detection range\nif (true_pose(0) >= 0.0 && true_pose(0) <= detection_range_ && true_pose(1) >= 0.0 && true_pose(1) <= detection_range_) {\n// True pose is within the detection range, so check if the drone is present in the world frame\nif (drone_id_to_pose_.find(drone_id) != drone_id_to_pose_.end()) {\n// Drone is present in the world frame, so compute the pose error\nEigen::Vector3d pose_error = computePoseError(drone_id, true_pose);\n\n// Update the debug result\nupdateDebugResult(drone_id, true_pose, true);\n\n// Publish the pose error\npublishPoseError(drone_id, pose_error);\n} else {\n// Drone is not present in the world frame, so update the debug result\nupdateDebugResult(drone_id, true_pose, false);\n}\n}\n}\n}\n}", "CodeBleu_score": 36.069319180583335}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t//\tstd::cout << \"detecting drone \" << drone_id << std::endl;\n\tEigen::Vector2d true_position;\n\tEigen::Vector2d estimated_position;\n\tEigen::Vector2d pose_error;\n\tEigen::Vector2d true_position_2d;\n\tEigen::Vector2d estimated_position_2d;\n\tEigen::Vector2d pose_error_2d;\n\tEigen::Vector3d true_position_3d;\n\tEigen::Vector3d estimated_position_3d;\n\tEigen::Vector3d pose_error_3d;\n\tbool found;\n\n\t// Convert the pixel to a position in the camera frame\n\ttrue_position = pixel_to_position(true_pixel);\n\n\t// Convert the position to a position in the world frame\n\ttrue_position_3d = position_to_position_3d(true_position);\n\n\t// Get the estimated position of the drone in the camera frame\n\tif (drone_id == 1) {\n\t\testimated_position_3d = estimated_position_1_3d_;\n\t} else if (drone_id == 2) {\n\t\testimated_position_3d = estimated_position_2_3d_;\n\t} else {\n\t\tstd::cout << \"Invalid drone ID\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Convert the estimated position to a position in the world frame\n\testimated_position_3d = position_to_position_3d(estimated_position_3d);\n\n\t// Compute the pose error\n\tpose_error_3d = true_position_3d - estimated_position_3d;\n\n\t// Convert the pose error to a pose error in the camera frame\n\tpose_error = position_3d_to_position(pose_error_3d);\n\n\t// Convert the pose error to a pose error in the camera frame\n\tpose_error_2d = position_to_position_2d(pose_error);\n\n\t// Convert the true position to a position in the camera frame\n\ttrue_position_2d = position_to_position_2d(true_position);\n\n\t// Convert the estimated position to a position in the camera frame\n\testimated_position", "CodeBleu_score": 26.723651280144047}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n/*\n * Get the camera pose in the world frame.\n */", "CodeBleu_score": 3.116351179668452}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current != start) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}", "CodeBleu_score": 67.61263126327187}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current != start) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 70.23339106455427}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\twhile (current != start) {\n\t\tpath.push_back(current);\n\t\tcurrent = cameFrom[current];\n\t}\n\tpath.push_back(start);\n\treturn path;\n}", "CodeBleu_score": 56.91311835956975}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert the start point to an index\n\tstart_idx = Coord2Index(start_pt);\n\tif (start_idx.x() < 0 || start_idx.x() >= grid_size.x() || start_idx.y() < 0 || start_idx.y() >= grid_size.y() || start_idx.z() < 0 || start_idx.z() >= grid_size.z()) {\n\t\tROS_ERROR(\"Start point (%f, %f, %f) is out of range.\", start_pt.x(), start_pt.y(), start_pt.z());\n\t\treturn false;\n\t}\n\t// Convert the end point to an index\n\tend_idx = Coord2Index(end_pt);\n\tif (end_idx.x() < 0 || end_idx.x() >= grid_size.x() || end_idx.y() < 0 || end_idx.y() >= grid_size.y() || end_idx.z() < 0 || end_idx.z() >= grid_size.z()) {\n\t\tROS_ERROR(\"End point (%f, %f, %f) is out of range.\", end_pt.x(), end_pt.y(), end_pt.z());\n\t\treturn false;\n\t}\n\t// Adjust the start point if it is inside an obstacle\n\tif (occupancy_grid[start_idx.x()][start_idx.y()][start_idx.z()] == 0) {\n\t\tVector3d pt = start_pt;\n\t\twhile (occupancy_grid[start_idx.x()][start_idx.y()][start_idx.z()] == 0) {\n\t\t\tpt += (start_pt - end_pt).normalized() * step_size;\n\t\t\tstart_idx = Coord2Index(pt);\n\t\t}\n\t}\n\t// Adjust the end point if it is inside an obstacle\n\tif (occupancy_grid[end_idx.x()][end_idx.y()][end_idx.z()] == 0) {\n\t\tVector3d pt = end_pt;\n\t\twhile (occupancy_grid[end_idx.x()][end_idx.y()][end_idx.z()]", "CodeBleu_score": 43.59521625968621}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Check if start_pt and end_pt are valid\n\tif (start_pt.x() < 0 || start_pt.x() > grid_size_x_ || start_pt.y() < 0 || start_pt.y() > grid_size_y_ || start_pt.z() < 0 || start_pt.z() > grid_size_z_ || end_pt.x() < 0 || end_pt.x() > grid_size_x_ || end_pt.y() < 0 || end_pt.y() > grid_size_y_ || end_pt.z() < 0 || end_pt.z() > grid_size_z_) {\n\t\tROS_ERROR(\"Start or end point is out of bounds\");\n\t\treturn false;\n\t}\n\n\t// Check if start_pt and end_pt are in collision\n\tif (checkOccupancy(start_pt) || checkOccupancy(end_pt)) {\n\t\tROS_ERROR(\"Start or end point is in collision\");\n\t\treturn false;\n\t}\n\n\t// Convert start_pt and end_pt to indices\n\tstart_idx = Coord2Index(start_pt);\n\tend_idx = Coord2Index(end_pt);\n\n\t// Adjust start_pt and end_pt if they are inside obstacles\n\tint num_iter = 0;\n\twhile (checkOccupancy(Index2Coord(start_idx)) || checkOccupancy(Index2Coord(end_idx))) {\n\t\t// Check if the start_pt and end_pt are still inside obstacles after num_iter iterations\n\t\tif (num_iter >= max_iter_) {\n\t\t\tROS_ERROR(\"Start or end point is in collision after %d iterations\", max_iter_);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Adjust start_pt\n\t\tif (checkOccupancy(Index2Coord(start_idx))) {\n\t\t\tstart_idx = start_idx + (start_pt - Index2Coord(start_idx)).normalized();\n\t\t}\n\n\t\t// Adjust end_pt\n\t\tif (checkOccupancy(Index2Coord(end_idx))) {\n\t\t\tend_idx = end_idx + (end_pt - Index2Coord(end_idx)).normalized();\n\t\t}\n\n\t", "CodeBleu_score": 45.142434881335305}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tVector3i start_idx_tmp, end_idx_tmp;\n\tif (!Coord2Index(start_pt, start_idx_tmp)) {\n\t\tROS_ERROR(\"Start point is outside the map\");\n\t\treturn false;\n\t}\n\tif (!Coord2Index(end_pt, end_idx_tmp)) {\n\t\tROS_ERROR(\"End point is outside the map\");\n\t\treturn false;\n\t}\n\tif (!checkOccupancy(start_idx_tmp)) {\n\t\tROS_DEBUG(\"Start point is inside an obstacle\");\n\t\twhile (checkOccupancy(start_idx_tmp)) {\n\t\t\tROS_DEBUG(\"Start point is inside an obstacle\");\n\t\t\tstart_idx_tmp += Vector3i(1, 0, 0);\n\t\t}\n\t\tROS_DEBUG(\"Start point is no longer inside an obstacle\");\n\t}\n\tif (!checkOccupancy(end_idx_tmp)) {\n\t\tROS_DEBUG(\"End point is inside an obstacle\");\n\t\twhile (checkOccupancy(end_idx_tmp)) {\n\t\t\tROS_DEBUG(\"End point is inside an obstacle\");\n\t\t\tend_idx_tmp += Vector3i(-1, 0, 0);\n\t\t}\n\t\tROS_DEBUG(\"End point is no longer inside an obstacle\");\n\t}\n\tstart_idx = start_idx_tmp;\n\tend_idx = end_idx_tmp;\n\treturn true;\n}", "CodeBleu_score": 34.091528532517714}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// Check if the given position is within the bounds of the grid.\n\tif (!isPositionInGrid(min_pos) || !isPositionInGrid(max_pos)) {\n\t\tROS_ERROR(\"Given position is out of bounds of the grid!\");\n\t\treturn;\n\t}\n\n\t// Calculate the grid coordinates of the given position.\n\tEigen::Vector3i min_id = getPositionInGrid(min_pos);\n\tEigen::Vector3i max_id = getPositionInGrid(max_pos);\n\n\t// Iterate over the grid coordinates and set the corresponding elements in the occupancy_buffer_inflate_ to zero.\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.84699430065369}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\tif (!getGridIndex(min_pos, min_id)) {\n\t\tROS_ERROR(\"GridMap::resetBuffer(): Failed to get grid index for position %f, %f, %f\", min_pos.x(), min_pos.y(), min_pos.z());\n\t\treturn;\n\t}\n\tif (!getGridIndex(max_pos, max_id)) {\n\t\tROS_ERROR(\"GridMap::resetBuffer(): Failed to get grid index for position %f, %f, %f\", max_pos.x(), max_pos.y(), max_pos.z());\n\t\treturn;\n\t}\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0.0;\n\t\t\t\tdistance_buffer_inflate_(i, j, k) = std::numeric_limits<float>::infinity();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.108487263708525}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\tgetGridCoordinatesFromPosition(min_pos, min_id);\n\tgetGridCoordinatesFromPosition(max_pos, max_id);\n\tresetBuffer(min_id, max_id);\n}", "CodeBleu_score": 27.386573938926023}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble min_x = std::min(std::abs(diff[0]), std::abs(diff[0] - map_size_[0]));\n\tdouble min_y = std::min(std::abs(diff[1]), std::abs(diff[1] - map_size_[1]));\n\tdouble min_z = std::min(std::abs(diff[2]), std::abs(diff[2] - map_size_[2]));\n\tdouble max_x = std::max(std::abs(diff[0]), std::abs(diff[0] - map_size_[0]));\n\tdouble max_y = std::max(std::abs(diff[1]), std::abs(diff[1] - map_size_[1]));\n\tdouble max_z = std::max(std::abs(diff[2]), std::abs(diff[2] - map_size_[2]));\n\tdouble scale_x = 1.0;\n\tdouble scale_y = 1.0;\n\tdouble scale_z = 1.0;\n\tif (min_x > max_x) {\n\t\tscale_x = max_x / min_x;\n\t}\n\tif (min_y > max_y) {\n\t\tscale_y = max_y / min_y;\n\t}\n\tif (min_z > max_z) {\n\t\tscale_z = max_z / min_z;\n\t}\n\tEigen::Vector3d new_pt = camera_pt + scale_x * diff;\n\tnew_pt = new_pt + scale_y * (new_pt - camera_pt);\n\tnew_pt = new_pt + scale_z * (new_pt - camera_pt);\n\treturn new_pt;\n}", "CodeBleu_score": 38.06757174313961}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_x = fabs(diff[0]) - (0.5 * map_size_[0]);\n\tdouble max_y = fabs(diff[1]) - (0.5 * map_size_[1]);\n\tdouble max_z = fabs(diff[2]) - (0.5 * map_size_[2]);\n\tdouble min_x = -fabs(diff[0]) + (0.5 * map_size_[0]);\n\tdouble min_y = -fabs(diff[1]) + (0.5 * map_size_[1]);\n\tdouble min_z = -fabs(diff[2]) + (0.5 * map_size_[2]);\n\tdouble x_scale = 1.0;\n\tdouble y_scale = 1.0;\n\tdouble z_scale = 1.0;\n\tif (max_x > 0) {\n\t\tx_scale = min_x / max_x;\n\t}\n\tif (max_y > 0) {\n\t\ty_scale = min_y / max_y;\n\t}\n\tif (max_z > 0) {\n\t\tz_scale = min_z / max_z;\n\t}\n\tdouble scale = std::min(std::min(x_scale, y_scale), z_scale);\n\tEigen::Vector3d pt_in_map = pt - scale * diff;\n\treturn pt_in_map;\n}", "CodeBleu_score": 35.34542974695963}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = camera_pt - pt;\n\tdouble max_coeff = std::max(std::max(std::abs(diff[0]), std::abs(diff[1])), std::abs(diff[2]));\n\tdouble min_coeff = std::min(std::min(std::abs(diff[0]), std::abs(diff[1])), std::abs(diff[2]));\n\tdouble coeff = 1.0;\n\tif (max_coeff > 0.0) {\n\t\tcoeff = min_coeff / max_coeff;\n\t}\n\tEigen::Vector3d result = camera_pt + diff * coeff;\n\treturn result;\n}", "CodeBleu_score": 33.587330128090876}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update the last occupancy update time.\nmd_.last_occ_update_time_ = ros::Time::now();\n\n// Check if an update is needed.\nif (md_.last_odom_time_ + md_.update_interval_ < ros::Time::now() || md_.last_depth_time_ + md_.update_interval_ < ros::Time::now()) {\n// Project the depth image into points.\npcl::PointCloud<pcl::PointXYZ>::Ptr points_temp(new pcl::PointCloud<pcl::PointXYZ>);\nprojectDepthImage(points_temp, md_.last_depth_time_);\n\n// Process the points with raycasting.\nraycastProcess(points_temp, md_.last_depth_time_);\n\n// Update the local map if needed.\nif (md_.last_local_map_update_time_ + md_.local_map_update_interval_ < ros::Time::now()) {\nclearAndInflateLocalMap();\n}\n}\n\n// Handle timeout errors for odometry or depth data.\nif (md_.last_odom_time_ + md_.update_interval_ < ros::Time::now()) {\nROS_ERROR(\"GridMap::updateOccupancyCallback: Odometry data is too old. Ignoring update.\");\nmd_.last_odom_time_ = ros::Time::now();\n}\nif (md_.last_depth_time_ + md_.update_interval_ < ros::Time::now()) {\nROS_ERROR(\"GridMap::updateOccupancyCallback: Depth data is too old. Ignoring update.\");\nmd_.last_depth_time_ = ros::Time::now();\n}\n}", "CodeBleu_score": 55.187939377599626}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\tif (!initialized_) {\nROS_WARN_THROTTLE(1.0, \"Grid map not initialized\");\nreturn;\n}\n\n// Update the last occupancy update time.\nmd_.last_occ_update_time_ = ros::Time::now();\n\n// Check if an update is needed.\nif (!update_occupancy_) {\nreturn;\n}\n\n// Check if the local map has been updated.\nif (update_local_map_) {\nclearAndInflateLocalMap();\n}\n\n// Get the latest depth image.\nif (!getDepthImage(md_.depth_image_, md_.depth_image_time_)) {\nreturn;\n}\n\n// Project the depth image into points.\nprojectDepthImage(md_.depth_image_, md_.depth_image_time_, md_.points_);\n\n// Process the points.\nraycastProcess();\n\n// Set the update flag to false.\nupdate_occupancy_ = false;\n\n// Handle timeout errors.\nif (md_.timeout_error_) {\nROS_ERROR(\"No odometry or depth data received for more than %.2f seconds\",\ntimeout_error_threshold_);\n}\nif (md_.timeout_error_local_map_) {\nROS_ERROR(\"No odometry or depth data received for more than %.2f seconds in local map\",\ntimeout_error_local_map_threshold_);\n}\n}", "CodeBleu_score": 49.71399377510877}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\tif (grid_map_visualization_publisher_.getNumSubscribers() > 0) {", "CodeBleu_score": 10.08254191177765}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat total_F = 0.0f;\n\tfloat F;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tF = _ellipse_evaluate_one(image_fns[i], gt_fns[i], dt_fns[i], gt_angle_radians);\n\t\ttotal_F += F;\n\t}\n\treturn total_F / image_fns.size();\n}", "CodeBleu_score": 44.45824431604342}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tint num_images = image_fns.size();\n\tfloat f_measure = 0;\n\tfor (int i = 0; i < num_images; i++) {\n\t\tvector<Ellipse> gt_ellipse = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipse = _load_ellipse_DT(dt_fns[i]);\n\t\tfloat f_measure_one = _ellipse_evaluate_one(gt_ellipse, dt_ellipse);\n\t\tf_measure += f_measure_one;\n\t}\n\treturn f_measure / num_images;\n}", "CodeBleu_score": 52.70466239525664}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tfloat f_measure = 0;\n\tfor (unsigned int i = 0; i < image_fns.size(); i++) {\n\t\tcv::Mat image = cv::imread(image_fns[i]);\n\t\tvector<ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n\t\tvector<ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i], gt_angle_radians);\n\t\tf_measure += _ellipse_evaluate_one(image, gt_ellipses, dt_ellipses);\n\t}\n\treturn f_measure / image_fns.size();\n}", "CodeBleu_score": 60.64498462855402}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle1, angle2;\n\tif (foci) {\n\t\tangle1 = atan2(foci[1] - y, foci[0] - x);\n\t\tangle2 = atan2(foci[3] - y, foci[2] - x);\n\t\treturn _angle_diff_signed(angle1, angle2);\n\t}\n\treturn 0.0;\n}", "CodeBleu_score": 26.01018998514611}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a, b, c, d, e, f, g, h, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, AA, BB, CC, DD, EE, FF, GG, HH, II, JJ, KK, LL, MM, NN, OO, PP, QQ, RR, SS, TT, UU, VV, WW, XX, YY, ZZ, AAA, BBB, CCC, DDD, EEE, FFF, GGG, HHH, III, JJJ, KKK, LLL, MMM, NNN, OOO, PPP, QQQ, RRR, SSS, TTT, UUU, VVV, WWW, XXX, YYY, ZZZ, AAAA, BBBB, CCCC, DDDD, EEEE, FFFF, GGGG, HHHH, IIIII, JJJJ, KKKK, LLLL, MMMM, NNNN, OOOO, PPPP, QQQQ, RRRR, SSSS, TTTT, UUUU, VVVV, WWWW, XXXX, YYYY, ZZZZ, AAAAA, BBBBB, CCCCC, DDDDD, EEEEE, FFFFF, GGGGG, HHHHH, IIIIII, JJJJJ, KKKKK, LLLLL, MMMMM, NNNNN, OOOOO, PPPPP, QQQQQ, RRRRR, SSSSS, TTTTT, UUUUU, VVVVV, WWWWW, XXXXX, YYYY, ZZZ, AAA, BBB, CCC, DDD, EEE, FFF, GGG, HHH, III, JJJ, KKK, LLL, MMM, NNN, OOO, PPP, QQQ, RRR, SSS, TTT, UUU, VVV, WWW, XXX, YYY, ZZ, AA, BB, CC, DD, EE, FF, GG, HH, II", "CodeBleu_score": 17.54067621965478}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle1, angle2;\n\tif (foci != NULL) {\n\t\tangle1 = atan2(foci[1] - y, foci[0] - x);\n\t\tangle2 = atan2(foci[3] - y, foci[2] - x);\n\t\treturn _angle_diff_signed(angle1, angle2);\n\t} else {\n\t\treturn 0.0f;\n\t}\n}", "CodeBleu_score": 28.202588689153174}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint i;\n\tint min_x, max_x, min_y, max_y;\n\tdouble area = 0.0;\n\tdouble x, y;\n\n\tmin_x = vp1[start].x;\n\tmax_x = vp1[start].x;\n\tmin_y = vp1[start].y;\n\tmax_y = vp1[start].y;\n\n\tfor (i = start + 1; i < end; i++) {\n\t\tx = vp1[i].x;\n\t\ty = vp1[i].y;\n\n\t\tif (x < min_x) min_x = x;\n\t\tif (x > max_x) max_x = x;\n\t\tif (y < min_y) min_y = y;\n\t\tif (y > max_y) max_y = y;\n\t}\n\n\tfor (i = start + 1; i < end; i++) {\n\t\tarea += (vp1[i].x + vp1[i - 1].x) * (vp1[i].y - vp1[i - 1].y);\n\t}\n\n\tif (area < 0.0) return true;\n\telse return false;\n}", "CodeBleu_score": 38.40791243174792}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint i;\n\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tfor (i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\tdouble area = 0;\n\tfor (i = start; i < end; i++) {\n\t\tarea += vp1[i].x * vp1[(i + 1) % end].y - vp1[i].y * vp1[(i + 1) % end].x;\n\t}\n\tif (area < 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 28.633280908241915}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint i, j;\n\tdouble min_x, max_x, min_y, max_y;\n\tdouble x1, y1, x2, y2;\n\tdouble area_above, area_below;\n\tdouble area_total;\n\tdouble x_slope, y_slope;\n\n\tmin_x = vp1[start].x;\n\tmax_x = vp1[start].x;\n\tmin_y = vp1[start].y;\n\tmax_y = vp1[start].y;\n\tfor (i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\tarea_above = 0;\n\tarea_below = 0;\n\tfor (i = start + 1; i < end; i++) {\n\t\tx1 = vp1[i - 1].x;\n\t\ty1 = vp1[i - 1].y;\n\t\tx2 = vp1[i].x;\n\t\ty2 = vp1[i].y;\n\t\tif (x2 != x1) {\n\t\t\tx_slope = (y2 - y1) / (x2 - x1);\n\t\t} else {\n\t\t\tx_slope = 0;\n\t\t}\n\t\tif (y2 != y1) {\n\t\t\ty_slope = (x1 - x2) / (y2 - y1);\n\t\t} else {\n\t\t\ty_slope = 0;\n\t\t}\n\t\tif (x_slope > 0) {\n\t\t\tarea_above += x_slope * (vp1[i].y + vp1[i].x) / 2;\n\t\t} else if (x_slope < 0)", "CodeBleu_score": 33.11010725750744}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t// Iterate through each detection info\n\tfor (int i = 0; i < msg->bounding_boxes.size(); i++) {\n\t\t// If T is detected, increment num_regain and reset num_lost\n\t\tif (msg->bounding_boxes[i].Class == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t}\n\t\t// Otherwise, increment num_lost and reset num_regain\n\t\telse {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t\t// If num_lost exceeds VISION_THRES, set is_detected to false\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\t// If num_regain exceeds VISION_THRES, set is_detected to true\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\t// Swap the sight_angle values of ellipse_det\n\t\tdouble temp = ellipse_det.sight_angle;\n\t\tellipse_det.sight_angle = ellipse_det.sight_angle_2;\n\t\tellipse_det.sight_angle_2 = temp;\n\t}\n}", "CodeBleu_score": 55.89072115582424}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tint num_regain = 0;\n\tint num_lost = 0;\n\tbool is_detected = false;\n\n\tfor (int i = 0; i < msg->objects.size(); i++) {\n\t\tif (msg->objects[i].id == \"T\") {\n\t\t\tnum_regain++;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t}\n\t}\n\n\tif (num_lost > VISION_THRES) {\n\t\tis_detected = false;\n\t} else if (num_regain > VISION_THRES) {\n\t\tis_detected = true;\n\t}\n\n\tfor (int i = 0; i < msg->objects.size(); i++) {\n\t\tif (msg->objects[i].id == \"T\") {\n\t\t\tellipse_det.sight_angle = msg->objects[i].angle;\n\t\t}\n\t}\n\n\tellipse_det.is_detected = is_detected;\n}", "CodeBleu_score": 51.51159295375548}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tprometheus_msgs::DetectionInfo::ConstPtr tmp_det;\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\ttmp_det = msg->detection_infos[i];\n\t\tif (tmp_det->name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (is_detected) {\n\t\t\tsight_angle = tmp_det->angle;\n\t\t} else {\n\t\t\tsight_angle = -1.0;\n\t\t}\n\t\tellipse_det.x = tmp_det->pose.pose.position.x;\n\t\tellipse_det.y = tmp_det->pose.pose.position.y;\n\t\tellipse_det.a = tmp_det->ellipse_a;\n\t\tellipse_det.b = tmp_det->ellipse_b;\n\t\tellipse_det.angle = tmp_det->angle;\n\t}\n}", "CodeBleu_score": 58.780049654102484}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tEigen::Vector3d safety_pos = cur_pos;\n\tsafety_pos[2] = 0.0;\n\treturn Occupy_map_ptr->check_safety(safety_pos, safe_distance);\n}", "CodeBleu_score": 55.46683623948325}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tdouble x_dist = cur_pos[0] - Occupy_map_ptr->map_origin[0];\n\tdouble y_dist = cur_pos[1] - Occupy_map_ptr->map_origin[1];\n\tdouble z_dist = cur_pos[2] - Occupy_map_ptr->map_origin[2];\n\tdouble dist = sqrt(pow(x_dist, 2) + pow(y_dist, 2) + pow(z_dist, 2));\n\tif (dist < safe_distance) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 41.55694891627931}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// Check if the position is within the occupancy grid\n\tif (cur_pos.x() >= 0 && cur_pos.x() < occupy_map_ptr->get_map_width() && cur_pos.y() >= 0 && cur_pos.y() < occupy_map_ptr->get_map_height()) {\n\t\t// Check if the position is within the safety distance\n\t\tif (occupy_map_ptr->get_occupancy_grid()[(int)cur_pos.y()][(int)cur_pos.x()] < safe_distance) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.693479018632935}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node != nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tif (!path_nodes_.empty()) {\n\t\tpath_nodes_.pop_back();\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 57.35423918823243}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node != nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 57.77414612364241}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// Initialize the current node to the end node\n\tNodePtr current_node = end_node;\n\twhile (current_node != nullptr) {\n\t\t// Add the current node to path_nodes_\n\t\tpath_nodes_.push_back(current_node);\n\t\t// Update the current node to the node that current_node points to\n\t\tcurrent_node = current_node->parent;\n\t}\n\t// Reverse the order of path_nodes_ so that it is from start to end\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 57.749367167009794}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif (sim_mode) {\n\t\tif ( (start_pos-state_nei[id]).norm > 5.0) {\n\t\t\tget_nei_state = false;\n\t\t} else {\n\t\t\tget_nei_state = true;\n\t\t}\n\t}\n\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n}", "CodeBleu_score": 34.80285730877595}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif (sim_mode) {\n\t\tdouble dist = (start_pos-state_nei[id]).norm;\n\t\tif (dist > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t} else {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n}", "CodeBleu_score": 45.75305689770753}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif (sim_mode) {\n\t\tif ((start_pos-state_nei[id]).norm > 5) {\n\t\t\tget_nei_state = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state = true;\n\t\t}\n\t}\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n}", "CodeBleu_score": 34.70636222780059}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tupdate_count++;\n\t\tif (update_count > 5) {\n\t\t\tupdate_count = 0;\n\t\t\tAstar_ptr->Occupy_map_ptr->update_map(msg);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.4436489549581}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\n\tsensor_ready = true;\n\tupdate_counter++;\n\n\tif (update_counter == 5) {\n\t\tupdate_counter = 0;\n\t\tmap_update_gpcl = true;\n\t}\n}", "CodeBleu_score": 39.13247433353804}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odometry_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_counter++;\n\tif (update_counter > 4) {\n\t\tupdate_counter = 0;\n\t\tmap_update_gpcl = true;\n\t\tmap_update_gpcl_counter = 0;\n\t\tupdate_gpcl_pub.publish(msg);\n\t}\n}", "CodeBleu_score": 51.339055489368626}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, gpcl);\n\t\tgpcl_inflated = gpcl;\n\t\tinflate_point_cloud(gpcl_inflated);\n\t}\n}", "CodeBleu_score": 47.75451916499958}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl == false) {\n\t\tpcl::PointCloud<pcl::PointXYZ> global_map_pcl;\n\t\tpcl::fromROSMsg(*global_point, global_map_pcl);\n\t\tglobal_map = global_map_pcl;\n\t\tget_gpcl = true;\n\t\tinflate_point_cloud();\n\t}\n}", "CodeBleu_score": 53.688874009022115}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, gpcl);\n\t\tinflate_point_cloud();\n\t}\n}", "CodeBleu_score": 37.71413813659026}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t//Convert the laser scan data to a PointCloud2 format\n\tsensor_msgs::PointCloud2 local_point_cloud;\n\tprojector_.projectLaser(*local_point, local_point_cloud);\n\n\t//Convert the PointCloud2 format to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_point_cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(local_point_cloud, *local_point_cloud_pcl);\n\n\t//If not in simulation mode, merge the local map with the provided odometry data\n\tif(!simulation_) {\n\t\tlocal_map_merge_odom(local_point_cloud_pcl, odom);\n\t}\n\n\t//Update the map using the laser scan data\n\tmap_update(local_point_cloud_pcl);\n}", "CodeBleu_score": 51.389327770672345}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Project laser scan into PointCloud2\n\tprojector_.projectLaser(local_point);\n\t// Convert to pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*local_point, *laser_cloud);\n\t// Merge local map with odometry data\n\tif (!simulation_mode_) {\n\t\tmap_merge_odom(laser_cloud, odom);\n\t}\n\t// Update the map\n\tupdate_map(laser_cloud);\n}", "CodeBleu_score": 46.17618575378929}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert the laser scan message to a PointCloud2\n\tsensor_msgs::PointCloud2 local_map_projected_msg;\n\tprojector_.projectLaser(local_point, local_map_projected_msg);\n\n\t// Convert the PointCloud2 message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> local_map_projected;\n\tpcl::fromROSMsg(local_map_projected_msg, local_map_projected);\n\n\t// If not in simulation mode, merge the local map with the odometry data\n\tif (!sim_mode_) {\n\t\tlocal_map_merge_odom(local_map_projected, odom);\n\t}\n\n\t// Update the occupancy map\n\tmap_update(local_map_projected);\n}", "CodeBleu_score": 44.56013739079317}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n// 1. Convert the global point cloud map to a ROS message.\npcl::toROSMsg(global_pcl, global_pcl_msg);\n\n// 2. Assign the frame ID \"world\" to the ROS message.\nglobal_pcl_msg.header.frame_id = \"world\";\n\n// 3. Publish the ROS message to the global_pcl_pub topic.\nglobal_pcl_pub.publish(global_pcl_msg);\n\n// 4. Convert the inflated point cloud to a ROS message.\npcl::toROSMsg(inflate_pcl, inflate_pcl_msg);\n\n// 5. Assign the frame ID \"world\" to the ROS message.\ninflate_pcl_msg.header.frame_id = \"world\";\n\n// 6. Publish the ROS message to the inflate_pcl_pub topic.\ninflate_pcl_pub.publish(inflate_pcl_msg);\n\n}", "CodeBleu_score": 43.6395664987244}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n// 1. Convert the global point cloud map to a ROS message.\nsensor_msgs::PointCloud2 msg;\npcl::toROSMsg(global_pcl, msg);\n\n// 2. Update the header information in the ROS message.\nmsg.header.stamp = ros::Time::now();\nmsg.header.frame_id = \"world\";\n\n// 3. Publish the ROS message.\nglobal_pcl_pub.publish(msg);\n\n// 4. Convert the inflated point cloud to a ROS message.\nsensor_msgs::PointCloud2 msg_inflate;\npcl::toROSMsg(inflate_pcl, msg_inflate);\n\n// 5. Update the header information in the ROS message.\nmsg_inflate.header.stamp = ros::Time::now();\nmsg_inflate.header.frame_id = \"world\";\n\n// 6. Publish the ROS message.\ninflate_pcl_pub.publish(msg_inflate);\n\n}", "CodeBleu_score": 51.16928719377645}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n/*\n * Convert the global point cloud map to a ROS message.\n */\n  pcl::toROSMsg(*global_map, global_pcl);\n\n/*\n * Set the header information.\n */\n  global_pcl.header.stamp = ros::Time::now();\n  global_pcl.header.frame_id = \"world\";\n\n/*\n * Publish the global point cloud map.\n */\n  global_pcl_pub.publish(global_pcl);\n\n/*\n * Convert the inflated point cloud to a ROS message.\n */\n  pcl::toROSMsg(*inflate_map, inflate_pcl);\n\n/*\n * Set the header information.\n */\n  inflate_pcl.header.stamp = ros::Time::now();\n  inflate_pcl.header.frame_id = \"world\";\n\n/*\n * Publish the inflated point cloud.\n */\n  inflate_pcl_pub.publish(inflate_pcl);\n}", "CodeBleu_score": 49.52590187643757}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tROS_INFO(\"Received point cloud\");\n\t// Set flag to true\n\tsensor_ready = true;\n\n\t// Update map\n\tAstar_ptr->Map_update(msg);\n}", "CodeBleu_score": 42.49168438540156}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t}\n\tif (sensor_ready) {\n\t\tif (use_map_update_lpcl) {\n\t\t\tif (Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, Astar_ptr->current_pos)) {\n\t\t\t\tROS_INFO(\"Map updated\");\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 50.627419231308664}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud_cb\");\n\t//ROS_INFO(\"pointcloud", "CodeBleu_score": 8.121721781368093}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the current time.\nros::Time current_time = ros::Time::now();\n\n// Calculate the time difference between the current and previous loop execution.\ndouble dt = (current_time - previous_time_).toSec();\nprevious_time_ = current_time;\n\n// Update the controller.\nupdateController(dt);\n\n// Get the current pose of the robot.\ngeometry_msgs::Pose current_pose = body_controller_.getCurrentPose();\n\n// Get the desired pose of the robot.\ngeometry_msgs::Pose desired_pose = body_controller_.getDesiredPose();\n\n// Compute the desired foot positions.\ncomputeDesiredFootPositions(current_pose, desired_pose);\n\n// Compute the desired joint positions.\ncomputeDesiredJointPositions();\n\n// Publish the foot contact states.\npublishFootContacts();\n\n// Publish the joint positions.\npublishJoints();\n}", "CodeBleu_score": 42.661264876628216}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n// Get the current time.\nros::Time time = ros::Time::now();\n\n// Update the controller's internal state.\nupdateInternalState();\n\n// Compute the desired foot positions.\ncomputeFeetPositions();\n\n// Compute the desired joint positions.\ncomputeJointCommands();\n\n// Publish the foot contact information.\npublishFootContacts();\n\n// Publish the joint positions.\npublishJoints();\n\n}", "CodeBleu_score": 9.340764605288065}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t\n// Get the current time.\nros::Time current_time = ros::Time::now();\n\n// Compute the time since the last loop.\nros::Duration dt = current_time - last_time_;\nlast_time_ = current_time;\n\n// Update the controller's state.\nupdateControllerState(dt);\n\n// Compute the desired foot positions.\ncomputeFeetPositions();\n\n// Compute the desired joint positions.\ncomputeJointPositions();\n\n// Publish the foot contact information.\npublishFootContacts();\n\n// Publish the joint positions.\npublishJoints();\n}", "CodeBleu_score": 35.21348166594104}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contact_for_gazebo_ && !in_gazebo_) {", "CodeBleu_score": 5.535805655047002}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contact_estimation_enabled_ && !in_gazebo_) {\n// Create the message.\ncontacts_msg.header.stamp = ros::Time::now();\nfor (int i = 0; i < 4; ++i) {\ncontacts_msg.contacts.resize(4);\ncontacts_msg.contacts[i].position.x = robot_model_.base_.legs[i]->motor_positions_[0];\ncontacts_msg.contacts[i].position.y = robot_model_.base_.legs[i]->motor_positions_[1];\ncontacts_msg.contacts[i].position.z = robot_model_.base_.legs[i]->motor_positions_[2];\ncontacts_msg.contacts[i].normal.x = robot_model_.base_.legs[i]->motor_directions_[0];\ncontacts_msg.contacts[i].normal.y = robot_model_.base_.legs[i]->motor_directions_[1];\ncontacts_msg.contacts[i].normal.z = robot_model_.base_.legs[i]->motor_directions_[2];\ncontacts_msg.contacts[i].depth = robot_model_.base_.legs[i]->motor_torques_[0];\ncontacts_msg.contacts[i].force.x = robot_model_.base_.legs[i]->motor_torques_[1];\ncontacts_msg.contacts[i].force.y = robot_model_.base_.legs[i]->motor_torques_[2];\ncontacts_msg.contacts[i].force.z = robot_model_.base_.legs[i]->motor_torques_[3];\ncontacts_msg.contacts[i].state = foot_contacts[i] ? 1 : 0;\n}\n// Publish the message.\nfoot_contacts_publisher_.publish(contacts_msg);\n}\n}", "CodeBleu_score": 51.100459382752476}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (!foot_contact_for_gazebo_ && !is_gazebo_) {\nfor (int i = 0; i < 4; i++) {\ncontacts_msg.contacts[i].position.z = foot_contacts[i] ? 0.03 : -0.03;\n}\nfoot_contacts_publisher_.publish(contacts_msg);\n}\n}", "CodeBleu_score": 45.953464291463206}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t// Create a joint message for publishing.\nJointState joint_msg;\njoint_msg.header.stamp = rospy.Time.now();\njoint_msg.name = self.joint_names;\njoint_msg.position = joints.position;\njoint_msg.velocity = self.joint_vel;\njoint_msg.effort = self.joint_eff;\n\n// Publish the joint command.\nself.joint_pub.publish(joint_msg);\n\n// Construct a trajectory message.\nJointTrajectory trajectory_msg;\ntrajectory_msg.header.stamp = rospy.Time.now();\ntrajectory_msg.joint_names = self.joint_names;\n\nTrajectoryPoint point;\npoint.positions = joints.position;\npoint.velocities = self.joint_vel;\npoint.accelerations = self.joint_acc;\npoint.effort = self.joint_eff;\npoint.time_from_start = rospy.Duration(self.traj_duration);\ntrajectory_msg.points.append(point);\n\n// Publish the trajectory.\nself.traj_pub.publish(trajectory_msg);\n}", "CodeBleu_score": 46.84029187082738}, {"code": "def joints_cmd_callback(self, joints){\n\t\trospy.loginfo(\"joints_cmd_callback: %s\", str(joints))\n\tmsg = JointTrajectory()\n\tmsg.header.stamp = rospy.Time.now()\n\tmsg.joint_names = self.joint_names\n\tmsg.points.append(JointTrajectoryPoint())\n\tmsg.points[0].positions = joints[:12]\n\tmsg.points[0].velocities = [0.0] * 12\n\tmsg.points[0].accelerations = [0.0] * 12\n\tmsg.points[0].time_from_start = rospy.Duration(1.0)\n\tself.pub_jt.publish(msg)\n}", "CodeBleu_score": 38.51844452432409}, {"code": "def joints_cmd_callback(self, joints){\n\t\trospy.loginfo(\"Received joints command\")\n\t# Create a message with the first 12 joint positions\n\t# This is the message type that will be sent to the robot\n\tmsg = JointState()\n\tmsg.header.stamp = rospy.Time.now()\n\tmsg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n\tmsg.position = joints.position[0:12]\n\t# Publish the message\n\tself.joints_pub.publish(msg)\n\t# Create a message with the same joint positions and the specified duration\n\t# This is the message type that will be sent to the robot\n\tmsg = JointTrajectory()\n\tmsg.header.stamp = rospy.Time.now()\n\tmsg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n\tmsg.points.append(JointTrajectoryPoint())\n\tmsg.points[0].positions = joints.position[0:12]\n\tmsg.points[0].velocities = [0.0] * 12\n\tmsg.points[0].accelerations = [0.0] * 12\n\tmsg.points[0].time_from_start = rospy.Duration(5.0)\n\t# Publish the message\n\tself.traj_pub.publish(msg)\n}", "CodeBleu_score": 37.77658505996249}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\\t// Initialize foot contact states to false\n\\tcontact_states_[0] = false;\n\\tcontact_states_[1] = false;\n\\tcontact_states_[2] = false;\n\\tcontact_states_[3] = false;\n\\tcontact_states_[4] = false;\n\\tcontact_states_[5] = false;\n\n\\t// For each contact in the message\n\\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\\t\\t// Split the collision string to identify the contact link\n\\t\\tstd::vector<std::string> link_names = boost::split(_msg->contact(i).collision1.split(\\\"::\\\"), boost::is_any_of(\\\"_\\\"));\n\n\\t\\t// If the contact is with one of the foot links\n\\t\\tif (link_names[0] == \\\"left_foot\\\" || link_names[0] == \\\"right_foot\\\") {\n\\t\\t\\t// Set the corresponding foot contact state to true\n\\t\\t\\tcontact_states_[link_names[0] == \\\"left_foot\\\" ? 0 : 1] = true;\n\\t\\t}\n\\t}\n}", "CodeBleu_score": 32.92989195404842}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\\t// Initialize all foot contact states to false.\n\\tfor (int i = 0; i < 4; i++) {\n\\t\\tfootContact_[i] = false;\n\\t}\n\\t// For each contact in the message, split the collision string to identify the contact link.\n\\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\\t\\tstd::string::size_type found = _msg->contact(i).collision1.find(\"::\");\n\\t\\tstd::string::size_type found2 = _msg->contact(i).collision2.find(\"::\");\n\\t\\tstd::string link = _msg->contact(i).collision1.substr(0, found);\n\\t\\tstd::string link2 = _msg->contact(i).collision2.substr(0, found2);\n\\t\\t// If a contact matches one of the foot links, set the corresponding foot contact state to true.\n\\t\\tif (link == \"left_foot\" || link == \"right_foot\" || link2 == \"left_foot\" || link2 == \"right_foot\") {\n\\t\\t\\tfor (int j = 0; j < 4; j++) {\n\\t\\t\\t\\tif (link == footLinks_[j] || link2 == footLinks_[j]) {\n\\t\\t\\t\\t\\tfootContact_[j] = true;\n\\t\\t\\t\\t}\n\\t\\t\\t}\n\\t\\t}\n\\t}\n}", "CodeBleu_score": 43.03036749546241}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t//  ROS_INFO(\"Contacts: %d\", _msg->contact_size);\n  for (int i = 0; i < _msg->contact_size; i++) {\n    std::string link1 = _msg->contact(i).collision1.split(\"::\")[1];\n    if (link1 == \"l_foot\" || link1 == \"r_foot\") {\n      foot_contacts_[link1] = true;\n    } else {\n      foot_contacts_[link1] = false;\n    }\n  }\n}", "CodeBleu_score": 36.77601751849281}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!is_active_) {\nrotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\nrotor_velocities->setZero();\nreturn;\n}\n\nEigen::Vector3d angular_acceleration_thrust;\nComputeDesiredAcceleration(&angular_acceleration_thrust);\n\n// Project thrust onto the body z-axis.\nangular_acceleration_thrust.z() = 0.0;\nconst double thrust_z = angular_acceleration_thrust.norm();\nif (thrust_z > 0.0) {\nangular_acceleration_thrust /= thrust_z;\n}\n\n// Combine the thrust vector and the angular acceleration vector.\nEigen::VectorXd acceleration = angular_acceleration_thrust;\nacceleration.tail(3) += angular_acceleration_thrust;\n\n// Compute the rotor velocities from the acceleration.\n*rotor_velocities = rotor_matrix_ * acceleration;\nrotor_velocities->cwiseSqrt();\nrotor_velocities->cwiseMax(0.0);\n}", "CodeBleu_score": 37.10953103711036}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!is_active_) {\nrotor_velocities->setZero();\n} else {\nassert(rotor_velocities->rows() == vehicle_parameters_.rotor_configuration_.rotors.size());\nassert(rotor_velocities->cols() == 1);\nComputeDesiredAcceleration(rotor_velocities);\nComputeDesiredAngularAcc(rotor_velocities);\nEigen::VectorXd thrust_body_z = vehicle_parameters_.rotor_configuration_.thrust_moment_weights.transpose() * (*rotor_velocities);\nEigen::VectorXd angular_acceleration_thrust = vehicle_parameters_.rotor_configuration_.angular_acceleration_weights.transpose() * (*rotor_velocities);\nEigen::VectorXd acceleration = thrust_body_z + angular_acceleration_thrust;\nacceleration.dot(vehicle_parameters_.rotor_configuration_.thrust_moment_weights.col(2));\nacceleration.dot(vehicle_parameters_.rotor_configuration_.angular_acceleration_weights.col(2));\nacceleration.dot(vehicle_parameters_.rotor_configuration_.thrust_moment_weights.col(1));\nacceleration.dot(vehicle_parameters_.rotor_configuration_.angular_acceleration_weights.col(1));\nacceleration.dot(vehicle_parameters_.rotor_configuration_.thrust_moment_weights.col(0));\nacceleration.dot(vehicle_parameters_.rotor_configuration_.angular_acceleration_weights.col(0));\nrotor_velocities->cwiseSqrt();\nrotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n}\n}", "CodeBleu_score": 46.39093878033975}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tif (!is_active_) {\nrotor_velocities->setZero();\nreturn;\n}\n\nEigen::Vector3d acceleration;\nEigen::Vector3d angular_acceleration;\nComputeDesiredAcceleration(&acceleration);\nComputeDesiredAngularAcc(&angular_acceleration);\n\nEigen::Vector3d thrust_body_z;\nthrust_body_z << 0.0, 0.0, acceleration.z();\nEigen::Vector3d desired_thrust = angular_acceleration.cross(thrust_body_z) + thrust_body_z;\n\nEigen::VectorXd angular_acceleration_thrust = desired_thrust;\nangular_acceleration_thrust.block<3, 1>(0, 0) += angular_acceleration;\n\nassert(rotor_velocities->rows() == vehicle_parameters_.rotor_configuration_.rotors.size());\nrotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\nrotor_velocities->cwiseSqrt() = angular_acceleration_thrust.cwiseAbs().cwiseMin(vehicle_parameters_.max_thrust_ / vehicle_parameters_.rotor_configuration_.rotors.size());\nrotor_velocities->cwiseSqrt() *= vehicle_parameters_.rotor_configuration_.signs.cwiseProduct(vehicle_parameters_.rotor_configuration_.rotors.size());\n}", "CodeBleu_score": 49.95489951024312}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t//  double kPosP = 0.0;", "CodeBleu_score": 5.1856153391073505}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position error.\n\tEigen::Vector3d position_error;\n\tposition_error = (command_trajectory_.position_trajectory.block<3, 1>(0, current_timestep_) - odometry_.position.block<3, 1>(0, 0));\n\n\t// Compute the velocity error.\n\tEigen::Vector3d velocity_error;\n\tvelocity_error = (command_trajectory_.velocity_trajectory.block<3, 1>(0, current_timestep_) - odometry_.velocity.block<3, 1>(0, 0));\n\n\t// Transform the velocity error to the world frame.\n\tEigen::Matrix3d rotation_matrix;\n\trotation_matrix = odometry_.orientation.toRotationMatrix();\n\tvelocity_error = rotation_matrix * velocity_error;\n\n\t// Compute the desired acceleration.\n\tEigen::Vector3d desired_acceleration;\n\tdesired_acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error + gravity_;\n\tdesired_acceleration = (desired_acceleration / vehicle_mass_) + commanded_acceleration_;\n\n\t// Set the acceleration.\n\t*acceleration = desired_acceleration;\n}", "CodeBleu_score": 48.93751580752813}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// Compute the position error.\nEigen::Vector3d position_error;\nposition_error = command_trajectory_.position_ - odometry_.position_;\n\n// Compute the velocity error.\nEigen::Vector3d velocity_error;\nvelocity_error = command_trajectory_.velocity_ - odometry_.velocity_;\n\n// Transform the vehicle's velocity to the world frame.\nEigen::Vector3d velocity_world;\nvelocity_world = odometry_.orientation_.toRotationMatrix() * odometry_.velocity_;\n\n// Compute the desired acceleration.\nacceleration->setZero();\nacceleration->head(2) = position_error.cwiseProduct(position_gain_) + velocity_error.cwiseProduct(velocity_gain_) + vehicle_mass_ * gravity_;\nacceleration->tail(1) = command_trajectory_.acceleration_;\nacceleration->tail(1) += (vehicle_mass_ * gravity_).cross(velocity_world);\n}", "CodeBleu_score": 53.1203270858557}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t// Ensure input is valid.\nassert(rotor_velocities != NULL);\n// Ensure parameters are valid.\nassert(rotor_velocities->rows() == kNumRotors);\nassert(rotor_velocities->cols() == 1);\n// Resize rotor_velocities to match the number of rotors.\nrotor_velocities->resize(kNumRotors, 1);\n// Calculate the desired angular acceleration.\nEigen::Vector3d angular_acceleration_thrust = ComputeDesiredAngularAcc(rotor_velocities);\n// Combine the desired angular acceleration with the thrust reference into a single vector.\ncontrol_attitude_thrust_reference_.block<3, 1>(0, 0) = angular_acceleration_thrust;\ncontrol_attitude_thrust_reference_.block<3, 1>(3, 0) = thrust_command_;\n// Compute the rotor velocities.\nrotor_velocities->noalias() = rotor_matrix_ * control_attitude_thrust_reference_;\nrotor_velocities->cwiseSqrt();\nrotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()));\n}", "CodeBleu_score": 52.99749289177436}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert", "CodeBleu_score": 4.068045606127209}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t// Ensure the input is valid.\nassert(rotor_velocities);\n\n// Resize the rotor velocities vector to match the number of rotors.\nrotor_velocities->resize(num_rotors_);\n\n// Calculate the desired angular acceleration.\nEigen::VectorXd angular_acceleration_thrust = ComputeDesiredAngularAcc();\n\n// Combine the desired angular acceleration and thrust reference into a single vector.\nEigen::VectorXd control_attitude_thrust_reference = control_attitude_thrust_reference_;\ncontrol_attitude_thrust_reference.block<3, 1>(0, 0) += angular_acceleration_thrust;\n\n// Compute the rotor velocities.\n*rotor_velocities = rotor_thrust_matrix_ * control_attitude_thrust_reference;\nrotor_velocities->cwiseSqrt();\n\n// Ensure the rotor velocities are at least one.\nrotor_velocities->cwiseMax(Eigen::VectorXd::Ones());\n}", "CodeBleu_score": 46.90323333493803}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in self.__dict__:\n        if isinstance(self.__dict__[attr], list):\n            copied_obj.__dict__[attr] = self.__dict__[attr][start_index:end_index]\n    return copied_obj\n\n", "CodeBleu_score": 42.271284151604696}, {"code": "def slice(self, start_time, end_time)\n\t\n    # find the start and end indices\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # create a deep copy of the object\n    copied_obj = copy.deepcopy(self)\n    # update each attribute of the copied object to contain only the sliced data\n    for attr in self.attrs:\n        copied_obj.__setattr__(attr, self.__getattribute__(attr)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 42.04009165053314}, {"code": "def slice(self, start_time, end_time)\n\t\n    if start_time > end_time:\n        raise ValueError('start_time cannot be greater than end_time')\n    if start_time < self.start_time:\n        raise ValueError('start_time cannot be less than start_time of object')\n    if end_time > self.end_time:\n        raise ValueError('end_time cannot be greater than end_time of object')\n    if start_time == end_time:\n        raise ValueError('start_time cannot be equal to end_time')\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = deepcopy(self)\n    for attr in self.attrs:\n        copied_obj.__setattr__(attr, copied_obj.__getattribute__(attr)[start_index:end_index])\n    copied_obj.start_time = start_time\n    copied_obj.end_time = end_time\n    return copied_obj\n\n", "CodeBleu_score": 60.016493534912144}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    # Convert quaternion to Euler angles\n    euler = euler_from_quaternion([quaternion.x, quaternion.y, quaternion.z, quaternion.w])\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n    # Check if the current waypoint is different from the last one\n    if self.last_point is None:\n        self.last_point = point\n        self.last_yaw = euler[2]\n        return\n    # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays\n    if not numpy.allclose(point.to_array(), self.last_point.to_array()):\n        self.append_points.append(point)\n        self.append_yaws.append(euler[2])\n        self.append_times.append(bag_time)\n        self.last_point = point\n        self.last_yaw = euler[2]\n\n", "CodeBleu_score": 26.717456921702443}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and quaternion from waypoint message\n    position = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    # Convert quaternion to Euler angles\n    euler_angles = euler_from_quaternion([quaternion.x, quaternion.y, quaternion.z, quaternion.w])\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n    # Check if the current waypoint is different from the last one\n    if self.last_point != point or self.last_yaw != euler_angles[2]:\n        # Append point, yaw, and times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(euler_angles[2])\n        self.append_times(bag_time, msg_time)\n        # Update last point and yaw\n        self.last_point = point\n        self.last_yaw = euler_angles[2]\n\n", "CodeBleu_score": 24.710874000763177}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation from the waypoint message\n    waypoint_position = waypoint_msg.pose.pose.position\n    waypoint_orientation = waypoint_msg.pose.pose.orientation\n    # Convert the rotation to Euler angles\n    (roll, pitch, yaw) = euler_from_quaternion([waypoint_orientation.x, waypoint_orientation.y, waypoint_orientation.z, waypoint_orientation.w])\n    # Create a Point object\n    waypoint_point = Point()\n    waypoint_point.x = waypoint_position.x\n    waypoint_point.y = waypoint_position.y\n    waypoint_point.z = waypoint_position.z\n    # Check if the waypoint is different from the last one\n    if (self.last_point.x != waypoint_point.x) or (self.last_point.y != waypoint_point.y) or (self.last_point.z != waypoint_point.z) or (self.last_yaw != yaw):\n        # Append the new point, yaw, and times to their respective arrays\n        self.append_points.append(waypoint_point)\n        self.append_yaws.append(yaw)\n        self.append_times.append(bag_time)\n        self.last_point = waypoint_point\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 25.49479281986263}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.accel_time.append(to_sec(msg.header.stamp))\n        self.accel_bag_time.append(bag_time)\n    elif topic == \"/imu/data_raw\":\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.accel_time.append(to_sec(msg.header.stamp))\n        self.accel_bag_time.append(bag_time)\n    elif topic == \"/imu/mag\":\n        self.mag_x.append(msg.magnetic_field.x)\n        self.mag_y.append(msg.magnetic_field.y)\n        self.mag_z.append(msg.magnetic_field.z)\n        self.mag_time.append(to_sec(msg.header.stamp))\n        self.mag_bag_time.append(bag_time)\n    elif topic == \"/imu/data_raw_mag\":\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.accel_time.append(to_sec(msg.header.stamp))\n        self.accel_bag_time.append(bag_time)\n        self.mag_x.append(msg.magnetic_field.x)\n        self.mag_y.append(msg.magnetic_field.y)\n        self.mag_z.append(msg.magnetic_field.z)\n        self.mag_time.append(to_sec(msg.header.stamp))\n        self.mag_bag_time.append(bag_time)\n    elif topic == \"/imu/data_raw_accel\":\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(", "CodeBleu_score": 26.190395071041916}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.acceleration.x.append(msg.linear_acceleration.x)\n        self.acceleration.y.append(msg.linear_acceleration.y)\n        self.acceleration.z.append(msg.linear_acceleration.z)\n        self.acceleration.time.append(msg.header.stamp.to_sec())\n        self.acceleration.bag_time.append(bag_time)\n    elif topic == '/imu/data_raw':\n        self.acceleration.x.append(msg.linear_acceleration.x)\n        self.acceleration.y.append(msg.linear_acceleration.y)\n        self.acceleration.z.append(msg.linear_acceleration.z)\n        self.acceleration.time.append(msg.header.stamp.to_sec())\n        self.acceleration.bag_time.append(bag_time)\n    elif topic == '/imu/mag':\n        self.magnetic.x.append(msg.magnetic_field.x)\n        self.magnetic.y.append(msg.magnetic_field.y)\n        self.magnetic.z.append(msg.magnetic_field.z)\n        self.magnetic.time.append(msg.header.stamp.to_sec())\n        self.magnetic.bag_time.append(bag_time)\n    elif topic == '/imu/data_raw_mag':\n        self.acceleration.x.append(msg.linear_acceleration.x)\n        self.acceleration.y.append(msg.linear_acceleration.y)\n        self.acceleration.z.append(msg.linear_acceleration.z)\n        self.acceleration.time.append(msg.header.stamp.to_sec())\n        self.acceleration.bag_time.append(bag_time)\n        self.magnetic.x.append(msg.magnetic_field.x)\n        self.magnetic.y.append(msg.magnetic_field.y)\n        self.magnetic.z.append(msg.magnetic_field.z)\n        self.magnetic.time.append(msg.header.stamp.to_sec())\n        self.magnetic.bag_time.append(bag_time)\n    elif topic == '/imu/data_raw_accel':\n        self.acceleration.x.append(msg.linear_acceleration.x", "CodeBleu_score": 26.40505666100251}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp)\n        self.imu_bag_time.append(bag_time)\n        self.imu_x.append(msg.linear_acceleration.x)\n        self.imu_y.append(msg.linear_acceleration.y)\n        self.imu_z.append(msg.linear_acceleration.z)\n    elif topic == \"/imu/data_raw\":\n        self.imu_raw_time.append(msg.header.stamp)\n        self.imu_raw_bag_time.append(bag_time)\n        self.imu_raw_x.append(msg.linear_acceleration.x)\n        self.imu_raw_y.append(msg.linear_acceleration.y)\n        self.imu_raw_z.append(msg.linear_acceleration.z)\n    elif topic == \"/imu/mag\":\n        self.imu_mag_time.append(msg.header.stamp)\n        self.imu_mag_bag_time.append(bag_time)\n        self.imu_mag_x.append(msg.magnetic_field.x)\n        self.imu_mag_y.append(msg.magnetic_field.y)\n        self.imu_mag_z.append(msg.magnetic_field.z)\n    elif topic == \"/imu/mag_raw\":\n        self.imu_mag_raw_time.append(msg.header.stamp)\n        self.imu_mag_raw_bag_time.append(bag_time)\n        self.imu_mag_raw_x.append(msg.magnetic_field.x)\n        self.imu_mag_raw_y.append(msg.magnetic_field.y)\n        self.imu_mag_raw_z.append(msg.magnetic_field.z)\n    elif topic == \"/imu/temp\":\n        self.imu_temp_time.append(msg.header.stamp)\n        self.imu_temp_bag_time.append(bag_time)\n        self.imu_temp.append(msg.temperature)\n    elif topic == \"/imu/wrench\":\n        self.imu_wrench_time.append(msg.header.stamp)\n        self.imu_wrench_bag_time.append(bag_time)", "CodeBleu_score": 22.393590318296035}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        else:\n            plot_suffix = \"_\" + plot_suffix\n    else:\n        plot_suffix = \"\"\n    fig = pyplot.figure()\n    fig.suptitle(self.title)\n    ax = fig.add_subplot(111)\n    for i, accel_dataset in enumerate(self.accel_datasets):\n        ax.plot(accel_dataset.time, accel_dataset.x, label=accel_dataset.label + \" x\")\n        ax.plot(accel_dataset.time, accel_dataset.y, label=accel_dataset.label + \" y\")\n        ax.plot(accel_dataset.time, accel_dataset.z, label=accel_dataset.label + \" z\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    ax.set_xlabel(\"Time (s)\")\n    ax.legend(loc=\"upper left\")\n    if self.save_plots:\n        pyplot.savefig(self.plot_filename_prefix + \"_accelerations\" + plot_suffix + \".png\")\n\n", "CodeBleu_score": 41.180295814500816}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure and title\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n\n    # Plot the acceleration data\n    for i, (name, data) in enumerate(self.accelerations.items()):\n        pyplot.subplot(3, 1, i + 1)\n        pyplot.plot(data[\"x\"], label=\"x\")\n        pyplot.plot(data[\"y\"], label=\"y\")\n        pyplot.plot(data[\"z\"], label=\"z\")\n        pyplot.ylabel(name)\n\n    # Add labels and a legend\n    pyplot.xlabel(\"Time (s)\")\n    pyplot.legend()\n\n    # Save the plot if enabled\n    if self.save_plots:\n        # Construct the filename\n        filename = \"accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n\n        # Save the plot\n        pyplot.savefig(os.path.join(self.plots_dir, filename))\n\n", "CodeBleu_score": 36.8639026377591}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if plot_suffix is None:\n        plot_suffix = ''\n    else:\n        plot_suffix = '_' + plot_suffix\n    fig = pyplot.figure()\n    fig.suptitle(self.name)\n    pyplot.ylabel('Acceleration (m/s^2)')\n    for i, acc in enumerate(self.accelerations):\n        pyplot.plot(acc.times, acc.x, color='red', label='x' + str(i))\n        pyplot.plot(acc.times, acc.y, color='green', label='y' + str(i))\n        pyplot.plot(acc.times, acc.z, color='blue', label='z' + str(i))\n    pyplot.legend()\n    pyplot.xlabel('Time (s)')\n    if self.save_plots:\n        pyplot.savefig(self.name + '_accelerations' + plot_suffix + '.png')\n\n", "CodeBleu_score": 42.765694352993336}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    print(\"Comparing poses...\")\n    for i in pose_indeces:\n        for j in pose_indeces[pose_indeces.index(i)+1:]:\n            self.compare_two_xyz(i, j)\n    print(\"Comparisons complete.\")\n\n", "CodeBleu_score": 30.658165049164932}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in pose_indeces:\n        for j in pose_indeces[pose_indeces.index(i)+1:]:\n            self.compare_two_xyz(i, j)\n", "CodeBleu_score": 21.26573807430057}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    print \"Comparing the positions of multiple poses based on their indices.\"\n    print \"For each pose index, it compares the position with all subsequent pose indices using the compare_two_xyz function.\"\n    print\n    print \"The pose indices that will be compared are: \"\n    print pose_indeces\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of the poses that will be compared are: \"\n    for pose_index in pose_indeces:\n        print self.poses[pose_index].position\n    print\n    print \"The positions of", "CodeBleu_score": 15.30984423566969}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time is None and end_time is None:\n            collision_times.append(time)\n        elif start_time is not None and end_time is None:\n            if time >= start_time:\n                collision_times.append(time)\n        elif start_time is None and end_time is not None:\n            if time <= end_time:\n                collision_times.append(time)\n        else:\n            if start_time <= time <= end_time:\n                collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 42.480033174908606}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 32.146680046322444}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    # Calculate absolute settling time\n    settling_time = start_time + settling_time\n    # Call analyze_bag.plot_angular_velocities\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 29.32422071502378}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time,\n                                        x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 35.617081494174855}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 31.476525987439373}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\nreturn;\n}\n\nconst float fx = intrinsics.fx;\nconst float fy = intrinsics.fy;\nconst float cx = intrinsics.ppx;\nconst float cy = intrinsics.ppy;\n\n// Calculate a multiplier based on camera parameters\nconst float multiplier = 1.0f / (fx * fy);\n\n// Map the data to an Eigen vector\nEigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>> data_vector_map(data,\n                                                                     width * height);\n\n// Compute the RMS noise and the noise values\nconst float rms_noise = multiplier * sqrtf(std::min(data_vector_map.array().square().sum() / (width * height), 1.0f));\nconst float noise = rms_noise * (data_vector_map.array() * 1000.0).array().square();\n\n// For each pixel, add noise if the pixel value is in range, otherwise set the pixel to a bad point value\nfor (uint32_t y = 0; y < height; ++y) {\nfor (uint32_t x = 0; x < width; ++x) {\nif (InRange(x, y)) {\ndata_vector_map(y * width + x) += noise(y * width + x);\n} else {\ndata_vector_map(y * width + x) = 0.0f;\n}\n}\n}\n}", "CodeBleu_score": 47.397944652953804}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) return;\nconst float focal_length = GetFocalLength();\nconst float baseline = GetBaseline();\nconst float depth_scale = GetDepthScale();\nconst float noise_scale = GetNoiseScale();\nconst float outlier_threshold = GetOutlierThreshold();\nconst float outlier_multiplier = GetOutlierMultiplier();\nconst float outlier_exponent = GetOutlierExponent();\nconst uint32_t num_pixels = width * height;\nconst float *data_vector_map = static_cast<const float *>(data);\nEigen::Map<Eigen::VectorXf> data_vector(data_vector_map, num_pixels);\nEigen::VectorXf rms_noise = CalculateRMSNoise(focal_length, baseline, depth_scale,\n                                              noise_scale, num_pixels);\nEigen::VectorXf noise = CalculateNoise(rms_noise, outlier_threshold,\n                                       outlier_multiplier, outlier_exponent,\n                                       num_pixels);\nfor (uint32_t i = 0; i < num_pixels; ++i) {\nif (InRange(data_vector[i], noise[i], outlier_threshold)) {\ndata_vector[i] += noise[i];\n} else {\ndata_vector[i] = 0.0f;\n}\n}\n}", "CodeBleu_score": 36.87125092210641}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\nreturn;\n}\n\nconst float focal_length_pixels = 525.0f;\nconst float focal_length_meters = 0.000000001f * focal_length_pixels;\nconst float principal_point_x = 319.5f;\nconst float principal_point_y = 239.5f;\nconst float pixel_size_meters = 0.000000001f * focal_length_meters / width;\nconst float max_distance_meters = 0.000000001f * focal_length_meters / principal_point_y;\nconst float min_distance_meters = 0.000000001f * focal_length_meters / (height - principal_point_y);\nconst float max_distance_pixels = focal_length_pixels / principal_point_y;\nconst float min_distance_pixels = focal_length_pixels / (height - principal_point_y);\nconst float max_distance_meters_squared = max_distance_meters * max_distance_meters;\nconst float min_distance_meters_squared = min_distance_meters * min_distance_meters;\n\nEigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\nconst Eigen::VectorXf rms_noise = ComputeRMSNoise(width, height, pixel_size_meters);\nconst Eigen::VectorXf noise = ComputeNoise(width, height, pixel_size_meters);\n\nfor (uint32_t i = 0; i < width * height; i++) {\nif (data_vector_map[i] < max_distance_meters_squared && data_vector_map[i] > min_distance_meters_squared) {\ndata_vector_map[i] += noise[i];\n} else {\ndata_vector_map[i] = 0.0f;\n}\n}\n}", "CodeBleu_score": 48.38695129366238}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time.\nros::Time current_time = ros::Time::now();\n// Write the trajectory message to the bag file.\nbag_.write(namespace_ + \"/\" + waypoint_topic_, current_time, trajectory_msg);\n}", "CodeBleu_score": 46.34364922735399}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n// Get the current simulation time.\ngazebo::common::Time sim_time = this->world_->SimTime();\n\n// Convert the simulation time to a ROS time.\nros::Time ros_time = ros::Time(sim_time.sec, sim_time.nsec);\n\n// Write the trajectory message to a bag file.\nthis->bag_.write(this->namespace_ + \"/\" + this->waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 57.19454131022877}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n// Get the current simulation time.\nros::Time time = world_->SimTime();\n\n// Convert the simulation time to a ROS time.\nros::Time ros_time = ros::Time(time.sec, time.nsec);\n\n// Write the trajectory message to a bag file using the specified namespace and waypoint topic.\nbag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, trajectory_msg);\n}", "CodeBleu_score": 70.09354688301102}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tros::Time ros_time = ros::Time(now.sec, now.nsec);\ngazebo_msgs::JointVelocities rot_velocities_msg;\nrot_velocities_msg.header.stamp = ros_time;\nrot_velocities_msg.name.resize(motor_joints_.size());\nrot_velocities_msg.velocity.resize(motor_joints_.size());\nfor (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\nrot_velocities_msg.name[m->second->GetScopedName()] = m->second->GetScopedName();\nrot_velocities_msg.velocity[m->second->GetScopedName()] = m->second->GetVelocity(0);\n}\nbag_.write(namespace_ + \"/\" + motor_topic_, ros_time, rot_velocities_msg);\n}", "CodeBleu_score": 61.391194834607276}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\n// Convert the simulation time to a ROS time.\nros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n// Prepare a message for actuator velocities.\ngazebo_msgs::JointCmd rot_velocities_msg;\nrot_velocities_msg.header.stamp = ros_time;\nrot_velocities_msg.name.resize(motor_joints_.size());\nrot_velocities_msg.position.resize(motor_joints_.size());\nrot_velocities_msg.velocity.resize(motor_joints_.size());\nrot_velocities_msg.effort.resize(motor_joints_.size());\n\n// Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message.\nfor (std::map<std::string, physics::JointPtr>::iterator m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n\n// Calculate the slowed-down rotational velocity.\ndouble rotational_velocity = m->second->GetVelocity(0);\nrotational_velocity *= 1.0 - velocity_slowdown_factor_;\n\n// Assign the slowed-down rotational velocity to the message.\nrot_velocities_msg.name[m->second->GetScopedName().substr(1).find(\"_\") + 1] = m->second->GetScopedName().substr(1);\nrot_velocities_msg.position[m->second->GetScopedName().substr(1).find(\"_\") + 1] = m->second->GetAngle(0).Radian();\nrot_velocities_msg.velocity[m->second->GetScopedName().substr(1).find(\"_\") + 1] = rotational_velocity;\nrot_velocities_msg.effort[m->second->GetScopedName().substr(1).find(\"_\") + 1] = m->second->GetForceTorque(0).body_torque[2];\n}\n\n// Write the message to a bag file.\nbag_.write(namespace_ + \"/\" + motor_topic_, ros_time, rot_velocities_msg);\n}", "CodeBleu_score": 57.8388169650832}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert the simulation time to a ROS time.\nros::Time ros_time = ConvertToRosTime(now);\n\n// Prepare a message for actuator velocities.\ngazebo_msgs::JointVelocities rot_velocities_msg;\nrot_velocities_msg.header.frame_id = \"world\";\nrot_velocities_msg.header.stamp = ros_time;\nrot_velocities_msg.velocities.resize(motor_joints_.size());\n\n// Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message.\nfor (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\ndouble velocity = m->second->GetVelocity(0);\ndouble max_velocity = m->second->GetParam(\"vel\", 0);\ndouble slow_factor = m->second->GetParam(\"slow_factor\", 0);\ndouble rotational_velocity = velocity * slow_factor;\nrotational_velocity = std::min(rotational_velocity, max_velocity);\nrot_velocities_msg.velocities[m->first] = rotational_velocity;\n}\n\n// Write the message to the bag file.\nrosbag::Bag bag;\nbag.open(bag_filename_, rosbag::bagmode::Append);\nbag.write(motor_topic_, rot_velocities_msg.header.stamp, rot_velocities_msg);\nbag.close();\n}", "CodeBleu_score": 56.58103147814961}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_FW_DYNAMICS_PLUGIN_DEBUG_PRINT\n  gzdbg << \"RollPitchYawrateThrustCallback: \" << roll_pitch_yawrate_thrust_msg->DebugString() << std::endl;\n#endif\n\n  // Convert normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  roll_pitch_yawrate_thrust_msg->aileron_cmd = NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->roll);\n  roll_pitch_yawrate_thrust_msg->elevator_cmd = NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->pitch);\n  roll_pitch_yawrate_thrust_msg->rudder_cmd = NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set the throttle value from the thrust message.\n  roll_pitch_yawrate_thrust_msg->thrust_cmd = roll_pitch_yawrate_thrust_msg->thrust;\n}", "CodeBleu_score": 42.185831008683884}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_FW_DYNAMICS_PLUGIN_DEBUG_PRINT\n  gzdbg << \"RollPitchYawrateThrustCallback called\" << std::endl;\n#endif\n\n  // Convert normalized inputs to angles\n  double roll = roll_pitch_yawrate_thrust_msg->roll();\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch();\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n  double roll_angle = NormalizedInputToAngle(roll);\n  double pitch_angle = NormalizedInputToAngle(pitch);\n  double yaw_rate_angle = NormalizedInputToAngle(yaw_rate);\n\n  // Set control surface angles\n  double aileron_angle = roll_angle;\n  double elevator_angle = pitch_angle;\n  double rudder_angle = yaw_rate_angle;\n\n  // Set throttle\n  double throttle = thrust;\n\n  // Publish control surfaces and throttle\n  this->PublishControlSurfacesAndThrottle(aileron_angle, elevator_angle,\n                                          rudder_angle, throttle);\n}", "CodeBleu_score": 45.016242108889436}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_print_on_) {\nROS_INFO_STREAM(\"RollPitchYawrateThrustCallback called\");\n}\n\n// Convert the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\nroll_pitch_yawrate_thrust_msg->ailerons = NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->roll(), roll_pitch_yawrate_thrust_msg->pitch());\nroll_pitch_yawrate_thrust_msg->elevator = NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->pitch(), roll_pitch_yawrate_thrust_msg->roll());\nroll_pitch_yawrate_thrust_msg->rudder = NormalizeInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate(), roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n// Set the throttle value from the thrust message.\nroll_pitch_yawrate_thrust_msg->thrust = NormalizeInputToThrust(roll_pitch_yawrate_thrust_msg->thrust());\n\nif (debug_print_on_) {\nROS_INFO_STREAM(\"ailerons: \" << roll_pitch_yawrate_thrust_msg->ailerons);\nROS_INFO_STREAM(\"elevator: \" << roll_pitch_yawrate_thrust_msg->elevator);\nROS_INFO_STREAM(\"rudder: \" << roll_pitch_yawrate_thrust_msg->rudder);\nROS_INFO_STREAM(\"thrust: \" << roll_pitch_yawrate_thrust_msg->thrust);\n}\n}", "CodeBleu_score": 44.510606295179315}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#ifdef __MACH__\n  // Mac OS X does not support poll(), so use select() instead\n  fd_set rfds;\n  struct timeval tv;\n  FD_ZERO(&rfds);\n  FD_SET(this->serialPort->GetFD(), &rfds);\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n  select(this->serialPort->GetFD() + 1, &rfds, NULL, NULL, &tv);\n#else\n  // poll() is a POSIX function that can be used to wait for data to become available on a file descriptor.\n  struct pollfd fds[1];\n  fds[0].fd = this->serialPort->GetFD();\n  fds[0].events = POLLIN;\n  poll(fds, 1, _timeoutMs);\n#endif\n\n  if (fds[0].revents & POLLIN) {\n    // Data is available to be read from the serial port\n    unsigned char buffer[1024];\n    int bytesRead = this->serialPort->Read(buffer, sizeof(buffer));\n    if (bytesRead > 0) {\n      // Parse the bytes read from the serial port\n      mavlink_message_t msg;\n      mavlink_status_t status;\n      mavlink_parse_char(this->mavlink_system.mavlink_version, buffer, &msg, &status);\n      this->handleMessage(&msg);\n    }\n  }\n}", "CodeBleu_score": 57.56263940583541}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 8\n  // Get the time until the next timeout\n  auto now = std::chrono::steady_clock::now();\n  auto timeToNext = std::chrono::duration_cast<std::chrono::microseconds>(\n      now + std::chrono::milliseconds(_timeoutMs) - std::chrono::steady_clock::now());\n  if (timeToNext.count() <= 0) {\n    return;\n  }\n\n  // Poll for data\n  struct pollfd fds[1];\n  fds[0].fd = mavlink_fd;\n  fds[0].events = POLLIN;\n  int ret = poll(fds, 1, timeToNext.count());\n  if (ret == -1) {\n    gzerr << \"poll() failed: \" << strerror(errno) << \"", "CodeBleu_score": 25.2134951141475}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 8\n    // For Gazebo 8 and above, we can use the Gazebo transport\n    // mechanism to receive messages.\n    mavlink_message_t msg;\n    while (this->transport->Read(msg)) {\n        this->handle_message(msg);\n    }\n#else\n    // For Gazebo 7 and below, we use the Gazebo event\n    // mechanism to receive messages.\n    auto events = this->event.GetEvents();\n    for (auto event : events) {\n        if (event.size() > 0) {\n            mavlink_message_t msg;\n            mavlink_parse_char(\n                MAVLINK_COMM_0,\n                event.data(),\n                &msg,\n                &this->mavlink_status);\n            this->handle_message(msg);\n        }\n    }\n#endif\n}", "CodeBleu_score": 25.984857049344633}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\tstd::lock_guard<std::mutex> lock(mutex_);\nif (!is_open_)  {\nreturn;\n}\nio_service_.stop();\nserial_dev_.close();\nif (io_thread_.joinable())  {\nio_thread_.join();\n}\nis_open_ = false;\n}", "CodeBleu_score": 67.72580742135565}, {"code": "void GazeboMavlinkInterface::close() {\n\tstd::lock_guard<std::mutex> lock(mutex_);\nif (is_open_)  {\nio_service_.stop();\nserial_dev_.close();\nif (io_thread_.joinable())  {\nio_thread_.join();\n}\nis_open_ = false;\n}\n}", "CodeBleu_score": 66.64248303053972}, {"code": "void GazeboMavlinkInterface::close() {\n\tstd::lock_guard<std::mutex> lock(mutex_);\nif (is_open_) {\nio_service_.stop();\nserial_dev_.close();\nif (io_thread_.joinable()) {\nio_thread_.join();\n}\nis_open_ = false;\n}\n}", "CodeBleu_score": 66.70505157828951}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\n/*\n * This function, GazeboWindPlugin::LinearInterpolation, performs linear interpolation for a given position.", "CodeBleu_score": 10.73037653599421}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tignition::math::Vector3d LinearInterpolation(double x1, double y1, double z1, double x2, double y2, double z2, double x) {\ndouble x_diff = x2 - x1;\ndouble y_diff = y2 - y1;\ndouble z_diff = z2 - z1;\n\ndouble x_interp = x_diff * (x - x1) / (x2 - x1);\ndouble y_interp = y_diff * (x - x1) / (x2 - x1);\ndouble z_interp = z_diff * (x - x1) / (x2 - x1);\n\nignition::math::Vector3d interp_vec {x_interp, y_interp, z_interp};\n\nreturn interp_vec;\n}\n}", "CodeBleu_score": 32.61847239574808}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tignition::math::Vector3d(\n    (1.0 - t) * p1.X() + t * p2.X(),\n    (1.0 - t) * p1.Y() + t * p2.Y(),\n    (1.0 - t) * p1.Z() + t * p2.Z()\n);\n}", "CodeBleu_score": 25.69933745613761}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (_time != m_time) {\n\t\tm_time = _time;\n\t\tif (m_looping) {\n\t\t\tm_time = fmod(m_time, m_length);\n\t\t} else {\n\t\t\tm_time = std::min(m_length, std::max(0.0, m_time));\n\t\t}\n\t\tm_dirty = true;\n\t}\n}", "CodeBleu_score": 31.724043669893675}, {"code": "void Animation::SetTime(double _time){\n\t\tif (m_time != _time) {\n\t\tm_time = _time;\n\t\tif (m_looping) {\n\t\t\tm_time = fmod(m_time, m_length);\n\t\t} else {\n\t\t\tm_time = math::clamp(m_time, 0.0, m_length);\n\t\t}\n\t\tOnTimeChanged();\n\t}\n}", "CodeBleu_score": 31.60897200425483}, {"code": "void Animation::SetTime(double _time){\n\t\tif (_time != time) {\n\t\ttime = _time;\n\t\tif (loop) {\n\t\t\ttime = fmod(time, length);\n\t\t} else {\n\t\t\ttime = std::max(0.0, std::min(time, length));\n\t\t}\n\t}\n}", "CodeBleu_score": 31.00961127371641}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.vehicle.frame = 1\n    self.vehicle.mode = 0\n    self.vehicle.armed = True\n    self.print_vehicle_info()\n    self.construct_target()\n    self.print_target()\n", "CodeBleu_score": 22.406248281742972}, {"code": "def hover(self)\n\t\n    self.vehicle.set_frame(1)\n    self.vehicle.set_motion_type(0)\n    self.construct_target()\n    print('Vehicle type: ', self.vehicle.get_type())\n    print('Vehicle ID: ', self.vehicle.get_id())\n    print('Flight mode: ', self.vehicle.get_flight_mode())\n\n", "CodeBleu_score": 23.429093792363233}, {"code": "def hover(self)\n\t\n    self.vehicle.set_attribute_value('coordFrame', 1)\n    self.vehicle.set_attribute_value('motionType', 0)\n    self.construct_target()\n    print(self.vehicle.get_vehicle_type())\n    print(self.vehicle.get_vehicle_id())\n    print(self.vehicle.get_flight_mode())\n", "CodeBleu_score": 13.563612768301677}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService.getFlightMode() == 'HOVER':\n        self.hover()\n        return True\n    elif self.flightModeService.getFlightMode() == 'LOITER':\n        self.set_mode('MANUAL')\n        return True\n    elif self.flightModeService.getFlightMode() == 'MANUAL':\n        self.set_mode('STABILIZE')\n        return True\n    elif self.flightModeService.getFlightMode() == 'STABILIZE':\n        self.set_mode('AUTO')\n        return True\n    elif self.flightModeService.getFlightMode() == 'AUTO':\n        self.set_mode('RTL')\n        return True\n    elif self.flightModeService.getFlightMode() == 'RTL':\n        self.set_mode('LAND')\n        return True\n    elif self.flightModeService.getFlightMode() == 'LAND':\n        self.set_mode('RTL')\n        return True\n    else:\n        print('Mode switch failed.')\n        return False\n\n", "CodeBleu_score": 25.09919776801366}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService.getFlightMode() == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.setFlightMode(self.flight_mode)\n            return True\n        except:\n            return False\n", "CodeBleu_score": 29.783129916636224}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService.getFlightMode() == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.setFlightMode(self.flightMode)\n            print\n            'Flight mode switched to ' + self.flightMode\n            return True\n        except:\n            print\n            'Flight mode switch failed'\n            return False\n\n", "CodeBleu_score": 32.01262773958943}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    if self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.angular.z)\n    elif self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.angular.z)\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.angular.z)\n\n", "CodeBleu_score": 36.65845486953793}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.angular.z)\n    if self.hover_flag == False:\n        self.hold_state_transition(msg.linear.x, msg.angular.z, 'enu')\n    if self.hover_flag == False and self.hold_flag == False:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.angular.z)\n\n", "CodeBleu_score": 29.94236014293803}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.angular.z)\n\n", "CodeBleu_score": 29.70772769047293}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.set_mode(\"OFFBOARD\")\n            self.flight_mode = \"OFFBOARD\"\n        elif self.hover_flag == 0 and (abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005):\n            self.hover_flag = 1\n            self.set_mode(\"HOVER\")\n            self.flight_mode = \"HOVER\"\n    else:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.set_mode(\"OFFBOARD\")\n            self.flight_mode = \"OFFBOARD\"\n\n", "CodeBleu_score": 57.828897515409864}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.set_mode(\"OFFBOARD\")\n        elif self.hover_flag == 0:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.set_mode(\"HOVER\")\n            self.hover()\n    elif abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n        self.hover_flag = 0\n        self.flight_mode = \"OFFBOARD\"\n        self.set_mode(\"OFFBOARD\")\n\n", "CodeBleu_score": 63.70672721147652}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != \"HOVER\":\n        if (\n            abs(x) > 0.02\n            or abs(y) > 0.02\n            or abs(z) > 0.02\n            or abs(w) > 0.005\n        ):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.arm()\n    if self.flight_mode == \"HOVER\":\n        if (\n            abs(x) < 0.02\n            and abs(y) < 0.02\n            and abs(z) < 0.02\n            and abs(w) < 0.005\n        ):\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover()\n\n", "CodeBleu_score": 62.178967447793895}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n\n", "CodeBleu_score": 19.528210155997467}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.frame = 0\n    self.motion_type = 0\n    self.construct_target()\n    print\n    self.vehicle_type\n    print\n    self.vehicle_id\n    print\n    self.flight_mode\n", "CodeBleu_score": 23.368259840014765}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 2\n    self.construct_target()\n    self.print()\n", "CodeBleu_score": 19.791218947063307}, {"code": "def hover(self)\n\t\n    self.frame = \"body\"\n    self.motion_type = \"hover\"\n    self.construct_target()\n    print\n    self.vehicle_type\n    print\n    self.vehicle_id\n    print\n    self.flight_mode\n\n", "CodeBleu_score": 11.118843959160179}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print(\"Flight mode switched to %s\" % self.flightMode)\n            return True\n        except:\n            print(\"Failed to switch flight mode to %s\" % self.flightMode)\n            return False\n", "CodeBleu_score": 35.57338274715426}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService.getFlightMode() == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService.setFlightMode('HOVER')\n            return True\n        except:\n            print 'Failed to switch flight mode.'\n            return False\n\n", "CodeBleu_score": 30.642340325478013}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightModeService.getFlightMode() == 'HOVER':\n        self.hover()\n        self.hoverFlag = True\n        print\n        'Flight mode switched to HOVER'\n        return True\n    else:\n        try:\n            self.flightModeService.setFlightMode(self.flightMode)\n            print\n            'Flight mode switched to ' + self.flightMode\n            return True\n        except RuntimeError as e:\n            print\n            'Failed to switch flight mode: ' + e\n            return False\n\n", "CodeBleu_score": 31.35826578497587}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    # Update the local pose\n    if msg.header.seq == i:\n        self.local_pose = msg\n        self.local_pose.pose.position.z = 0.0\n        self.local_pose.pose.orientation.x = 0.0\n        self.local_pose.pose.orientation.y = 0.0\n        self.local_pose.pose.orientation.z = 0.0\n        self.local_pose.pose.orientation.w = 1.0\n\n        # Update the global pose\n        self.global_pose.header = msg.header\n        self.global_pose.pose = msg.pose\n        self.global_pose.pose.position.x += self.bias_x\n        self.global_pose.pose.position.y += self.bias_y\n        self.global_pose.pose.position.z += self.bias_z\n        self.global_pose.pose.orientation.x = 0.0\n        self.global_pose.pose.orientation.y = 0.0\n        self.global_pose.pose.orientation.z = 0.0\n        self.global_pose.pose.orientation.w = 1.0\n\n        # Update the takeoff target pose\n        if self.takeoff_target_pose.header.seq == 0:\n            self.takeoff_target_pose.header = msg.header\n            self.takeoff_target_pose.pose = msg.pose\n            self.takeoff_target_pose.pose.position.z = 0.0\n            self.takeoff_target_pose.pose.orientation.x = 0.0\n            self.takeoff_target_pose.pose.orientation.y = 0.0\n            self.takeoff_target_pose.pose.orientation.z = 0.0\n            self.takeoff_target_pose.pose.orientation.w = 1.0\n\n        # Update the hover target pose\n        if self.hover_target_pose.header.seq == 0:\n            self.hover_target_pose.header = msg.header\n            self.hover_target_pose.pose = msg.pose\n            self.hover_target_pose.pose.position.z = 0.0\n            self.hover_target_pose.pose.orientation.x = 0.0\n            self.hover_", "CodeBleu_score": 15.800487956090208}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == i:\n        self.local_pose = msg\n        self.local_pose.pose.position.x = self.local_pose.pose.position.x + self.pose_bias.position.x\n        self.local_pose.pose.position.y = self.local_pose.pose.position.y + self.pose_bias.position.y\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z + self.pose_bias.position.z\n        self.local_pose.pose.orientation.x = self.local_pose.pose.orientation.x + self.pose_bias.orientation.x\n        self.local_pose.pose.orientation.y = self.local_pose.pose.orientation.y + self.pose_bias.orientation.y\n        self.local_pose.pose.orientation.z = self.local_pose.pose.orientation.z + self.pose_bias.orientation.z\n        self.local_pose.pose.orientation.w = self.local_pose.pose.orientation.w + self.pose_bias.orientation.w\n        self.global_pose = self.local_pose\n        self.global_pose.pose.position.x = self.global_pose.pose.position.x + self.global_pose_bias.position.x\n        self.global_pose.pose.position.y = self.global_pose.pose.position.y + self.global_pose_bias.position.y\n        self.global_pose.pose.position.z = self.global_pose.pose.position.z + self.global_pose_bias.position.z\n        self.global_pose.pose.orientation.x = self.global_pose.pose.orientation.x + self.global_pose_bias.orientation.x\n        self.global_pose.pose.orientation.y = self.global_pose.pose.orientation.y + self.global_pose_bias.orientation.y\n        self.global_pose.pose.orientation.z = self.global_pose.pose.orientation.z + self.global_pose_bias.orientation.z\n        self.global_pose.pose.orientation.w = self.global_pose.pose.orientation.w + self.global_pose", "CodeBleu_score": 18.222884559771764}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = deepcopy(msg)\n        self.local_pose.pose.position.x += self.x_bias\n        self.local_pose.pose.position.y += self.y_bias\n        self.local_pose.pose.position.z += self.z_bias\n\n        if self.local_pose.pose.position.z < self.hover_height:\n            self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.hover_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.hover_target_pose.pose.position.z = self.hover_height\n\n            self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.takeoff_target_pose.pose.position.z = self.hover_height + self.takeoff_height\n\n        else:\n            self.hover_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.hover_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.hover_target_pose.pose.position.z = self.hover_height\n\n            self.takeoff_target_pose.pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.pose.position.y = self.local_pose.pose.position.y\n            self.takeoff_target_pose.pose.position.z = self.hover_height + self.takeoff_height\n\n        self.global_pose.header.stamp = rospy.Time.now()\n        self.global_pose.header.frame_id = \"world\"\n        self.global_pose.pose.position.x = self.local_pose.pose.position.x + self.global_x_bias\n        self.global_pose.pose.position.y = self.local_pose.pose.position.y + self.global_y_bias\n        self.global_pose.pose.", "CodeBleu_score": 17.61389323632103}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.uav.get_current_state().armed and self.uav.get_current_state().position[2] > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 51.846952512486055}, {"code": "def takeoff_detection(self)\n\t\n    if self.alt > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.6464041749083}, {"code": "def takeoff_detection(self)\n\t\n    if self.get_altitude() > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.9333762550345}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize the distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n\n    # Loop through the rows and columns of the distance matrix\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            # Calculate the distance between the UAVs\n            dist = norm(orig_formation[i] - change_formation[j])\n            # Subtract the distance from 50 and convert to integer\n            dist_matrix[i][j] = int(dist - 50)\n    return dist_matrix\n\n", "CodeBleu_score": 23.344092911243557}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize the distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    # Loop through all the UAVs in the original formation\n    for i in range(len(orig_formation)):\n        # Loop through all the UAVs in the changed formation\n        for j in range(len(change_formation)):\n            # Calculate the Euclidean distance between the UAVs\n            dist = np.linalg.norm(orig_formation[i] - change_formation[j])\n            # Adjust the distance\n            dist = 50 - dist\n            # Convert the distance to an integer\n            dist = int(dist)\n            # Add the distance to the distance matrix\n            dist_matrix[i][j] = dist\n    # Return the distance matrix\n    return dist_matrix\n\n", "CodeBleu_score": 28.10514720984055}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    orig_formation = orig_formation.reshape(orig_formation.shape[0], 2)\n    change_formation = change_formation.reshape(change_formation.shape[0], 2)\n    dist_matrix = np.zeros((orig_formation.shape[0], change_formation.shape[0]))\n    for i in range(orig_formation.shape[0]):\n        for j in range(change_formation.shape[0]):\n            dist_matrix[i][j] = norm(orig_formation[i] - change_formation[j])\n    dist_matrix = dist_matrix - 50\n    dist_matrix = dist_matrix.astype(int)\n    return dist_matrix\n", "CodeBleu_score": 17.25980958214529}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    if self.left_visited[i]:\n        return False\n    self.left_visited[i] = True\n    for j in range(self.n_right):\n        if self.right_visited[j]:\n            continue\n        gap = self.right_labels[j] - self.left_labels[i]\n        if gap == 0:\n            self.right_visited[j] = True\n            if self.find_path(j):\n                return True\n            self.right_visited[j] = False\n        else:\n            self.right_slack[j] = min(self.right_slack[j], gap)\n    return False\n\n", "CodeBleu_score": 39.370342517474576}, {"code": "def find_path(self, i)\n\t\n    if self.left_visited[i] or self.right_visited[i]:\n        return False\n    self.left_visited[i] = True\n    for j in range(self.n):\n        if not self.right_visited[j] and self.weight[i][j] == self.match[i]:\n            self.right_visited[j] = True\n            if self.find_path(j):\n                return True\n            self.right_visited[j] = False\n    if self.match[i] == -1:\n        return True\n    gap = self.weight[i][self.match[i]] - self.weight[i][j]\n    if gap == 0:\n        self.right_visited[self.match[i]] = True\n        if self.find_path(self.match[i]):\n            return True\n        self.right_visited[self.match[i]] = False\n    else:\n        self.slack[i] = min(self.slack[i], gap)\n    return False\n\n", "CodeBleu_score": 37.90868664523481}, {"code": "def find_path(self, i)\n\t\n    if self.left_visited[i]:\n        return False\n    self.left_visited[i] = True\n    for j in self.right_adj[i]:\n        if not self.right_visited[j]:\n            gap = self.labels[i] - self.labels[j]\n            if gap == 0:\n                self.right_visited[j] = True\n                if self.find_path(j):\n                    return True\n                else:\n                    self.right_visited[j] = False\n            else:\n                self.slack[j] = min(self.slack[j], gap)\n    return False\n", "CodeBleu_score": 34.061361255060554}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t_matrix.\n\n    :rtype: list\n    :return: the match results for the right side of the bipartite graph_matrix\n    \"\"\"\n    #Initialize the slack variables and visit arrays for each UAV\n    for i in range(self.num_uavs):\n        self.slack[i] = 0\n        self.visited[i] = False\n\n    #Iterate over UAVs\n    for i in range(self.num_uavs):\n        #If the UAV has not been visited\n        if not self.visited[i]:\n            #Get the path for the UAV\n            path = self.find_path(i)\n            #If no path was found, adjust the labels based on the minimum slack value\n            if path == -1:\n                min_slack = min(self.slack)\n                for j in range(self.num_uavs):\n                    if self.slack[j] == min_slack:\n                        self.labels[j] = 1 - self.labels[j]\n                self.slack = [0] * self.num_uavs\n            #If a path was found, update the slack variables\n            else:\n                for j in range(len(path)):\n                    self.slack[path[j]] += 1\n                self.visited[i] = True\n\n    #Return the match results for the right side of the bipartite graph_matrix\n    return self.labels\n", "CodeBleu_score": 0.7663442900125119}, {"code": "def KM(self)\n\t_matrix.\"\"\"\n    #initialize slack variables\n    for i in range(self.n_uavs):\n        self.slack[i] = 0\n\n    #initialize visit arrays\n    for i in range(self.n_uavs):\n        self.visited[i] = False\n\n    #iterate over UAVs\n    for i in range(self.n_uavs):\n        #reset the visited array\n        for j in range(self.n_uavs):\n            self.visited[j] = False\n\n        #initialize the slack variable\n        self.slack[i] = 0\n\n        #iterate over the left side of the bipartite graph_matrix\n        for j in range(self.n_uavs):\n            #if the left side is not empty\n            if self.graph_matrix[i][j] != 0:\n                #if the right side is not visited\n                if not self.visited[j]:\n                    #if the slack variable is less than the value in the graph_matrix, set the slack variable to the value in the graph_matrix\n                    if self.slack[i] < self.graph_matrix[i][j]:\n                        self.slack[i] = self.graph_matrix[i][j]\n\n        #iterate over the right side of the bipartite graph_matrix\n        for j in range(self.n_uavs):\n            #if the right side is not empty\n            if self.graph_matrix[j][i] != 0:\n                #if the left side is not visited\n                if not self.visited[j]:\n                    #add the slack variable to the value in the graph_matrix\n                    self.graph_matrix[j][i] -= self.slack[i]\n\n        #iterate over the right side of the bipartite graph_matrix\n        for j in range(self.n_uavs):\n            #if the right side is not empty\n            if self.graph_matrix[j][i] != 0:\n                #if the left side is not visited\n                if not self.visited[j]:\n                    #if the slack variable is less than the value in the graph_matrix, set the slack variable to the value in the graph_matrix\n                    if self.slack[i] < self.graph_matrix[j][i]:\n                        self.slack[i] = self.graph_matrix[j][i]\n\n        #iterate", "CodeBleu_score": 27.49898451868049}, {"code": "def KM(self)\n\t_matrix.", "CodeBleu_score": 0.4557772850455778}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([15, 100, 100])\n    upper_yellow = np.array([45, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.33641404572912}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # HSV color space is better for detecting yellow color\n    # Hue range: 0-179, Saturation range: 0-255, Value range: 0-255\n    # Hue is color, Saturation is purity of color and Value is brightness of color\n    # Lower HSV bound for yellow color is 20-30, 100-255, 100-255\n    # Upper HSV bound for yellow color is 30-40, 255-255, 255-255\n    lower_bound = np.array([20, 100, 100])\n    upper_bound = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_bound, upper_bound)\n    # Bitwise AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 28.925112400436397}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\tbool TagDetector::findStandaloneTagDescription(int tag_id, std::string & descriptionContainer, bool printWarning) {\n  bool found = false;\n  auto it = standalone_tag_descriptions_.find(tag_id);\n  if (it != standalone_tag_descriptions_.end()) {\n    descriptionContainer = it->second;\n    found = true;\n  } else {\n    if (printWarning) {\n      ROS_WARN_STREAM(\"TagDetector: Could not find description for tag ID \" << tag_id << \".\");\n    }\n  }\n  return found;\n}\n", "CodeBleu_score": 49.25975557443759}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tTagDetector.cpp:128\n", "CodeBleu_score": 2.31409463732287}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tTagDetector.cpp:140\n}", "CodeBleu_score": 2.3314775554353044}]}
