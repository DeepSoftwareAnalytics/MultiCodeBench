{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *p = (uint8_t *)desc;\n\tuint8_t *end = (uint8_t *)desc + desc->bLength;\n\n\twhile (p < end) {\n\t\tuint8_t len = p[0];\n\t\tif (p[1] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *)p;\n\t\t}\n\t\tp += len;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.109468235305904}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t * p = (uint8_t *) desc;\n\tuint8_t * end = (uint8_t *) desc + desc->bLength;\n\twhile (p < end) {\n\t\tif (*p == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) p;\n\t\t}\n\t\tp += p[0];\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 33.81258706974789}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t i;\n\tuint8_t *p;\n\n\tfor (i = 0; i < desc->bNumInterfaces; i++) {\n\t\tp = (uint8_t *)desc;\n\t\tp += sizeof(usb_conf_desc_t);\n\t\twhile (desc->bLength) {\n\t\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\t\treturn desc;\n\t\t\t}\n\t\t\tp += desc->bLength;\n\t\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)p;\n\t\t}\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 39.24383399937684}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *conf;\n\tuint8_t *desc;\n\tuint8_t *desc_end;\n\tuint8_t desc_type;\n\tuint8_t desc_len;\n\tuint8_t iface_desc_idx;\n\tuint8_t iface_desc_count;\n\tuint8_t iface_desc_found;\n\tuint8_t iface_desc_setting_idx;\n\tuint8_t iface_desc_setting_count;\n\tuint8_t iface_desc_setting_found;\n\tbool retval;\n\n\t/* Verify that there is a valid configuration. */\n\tconf = udc_get_conf();\n\tif (conf == NULL) {\n\t\treturn false;\n\t}\n\n\t/* Verify that the interface number is within bounds. */\n\tif (iface_num >= UDC_MAX_INTERFACES) {\n\t\treturn false;\n\t}\n\n\t/* Initialize variables. */\n\tiface_desc_idx = 0;\n\tiface_desc_count = conf[7];\n\tiface_desc_found = false;\n\tiface_desc_setting_idx = 0;\n\tiface_desc_setting_count = 0;\n\tiface_desc_setting_found = false;\n\tretval = false;\n\n\t/* Iterate through the descriptors, starting from the beginning of the configuration descriptor. */\n\tdesc = conf;\n\tdesc_end = conf + conf[3];\n\twhile (desc < desc_end) {\n\t\t/* Get the descriptor's type and length. */\n\t\tdesc_type = desc[1];\n\t\tdesc_len = desc[2];\n\n\t\t/* Check if this is an interface descriptor. */\n\t\tif (desc_type == UDC_DESC_TYPE_INTERFACE) {\n\t\t\t/* Check if this is the interface descriptor we're looking for. */\n\t\t\tif (desc[2] >= 2) {\n\t\t\t\tif (desc[5] == iface_num) {\n\t\t\t\t\t/* This is the interface descriptor we're looking for. */\n\t\t\t\t\tiface_desc_found = true;\n\t\t\t\t\tiface_desc_setting_idx = 0;\n\t\t\t\t\tiface_desc_setting_count = desc[4];\n\t\t\t\t\tiface_desc_setting_found = false;\n\t\t\t\t}", "CodeBleu_score": 34.63112097623277}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t iface_desc_len = 0;\n\tuint8_t iface_desc_type = 0;\n\tuint8_t iface_desc_num_settings = 0;\n\tuint8_t iface_desc_cur_setting = 0;\n\tuint8_t iface_desc_cur_index = 0;\n\tuint8_t iface_desc_cur_type = 0;\n\tuint8_t iface_desc_cur_num_settings = 0;\n\tuint8_t iface_desc_cur_index_end = 0;\n\tbool found_iface_desc = false;\n\n\tif (g_udc_get_conf_desc_size() == 0) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= g_udc_get_conf_desc_iface_count()) {\n\t\treturn false;\n\t}\n\n\tiface_desc_len = g_udc_get_conf_desc_iface_desc_len(iface_num, 0);\n\tiface_desc_type = g_udc_get_conf_desc_iface_desc_type(iface_num, 0);\n\tiface_desc_num_settings = g_udc_get_conf_desc_iface_desc_num_settings(iface_num, 0);\n\n\tif (iface_desc_type != USB_DESC_TYPE_INTERFACE) {\n\t\treturn false;\n\t}\n\n\tif (iface_desc_num_settings == 0) {\n\t\treturn false;\n\t}\n\n\tif (setting_num >= iface_desc_num_settings) {\n\t\treturn false;\n\t}\n\n\tiface_desc_cur_index = 0;\n\n\twhile (iface_desc_cur_index < g_udc_get_conf_desc_size()) {\n\t\tiface_desc_cur_index_end = iface_desc_cur_index + iface_desc_len;\n\n\t\tif (iface_desc_cur_index_end > g_udc_get_conf_desc_size()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tiface_desc_cur_type = g_udc_get_conf_desc_byte(iface_desc_cur_index);\n\t\tiface_", "CodeBleu_score": 27.130508996983306}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t i;\n\tuint8_t iface_desc_len;\n\tuint8_t iface_desc_type;\n\tuint8_t iface_desc_num_settings;\n\tuint8_t iface_desc_start_setting;\n\tuint8_t iface_desc_end_setting;\n\tuint8_t iface_desc_setting_num;\n\tuint8_t iface_desc_index;\n\tuint8_t iface_desc_index_max;\n\tuint8_t *iface_desc_ptr;\n\tuint8_t *iface_desc_ptr_tmp;\n\n\t/* Check if there is a valid configuration */\n\tif (udc_get_configuration() == 0) {\n\t\treturn false;\n\t}\n\n\t/* Check if the interface number is within bounds */\n\tif (iface_num >= udc_get_configuration_desc_num_interfaces()) {\n\t\treturn false;\n\t}\n\n\t/* Iterate through the descriptors, starting from the beginning of the configuration descriptor */\n\tiface_desc_ptr = udc_get_configuration_desc_ptr();\n\tiface_desc_len = iface_desc_ptr[2];\n\tiface_desc_type = iface_desc_ptr[3];\n\tiface_desc_num_settings = iface_desc_ptr[5];\n\tiface_desc_start_setting = iface_desc_ptr[6];\n\tiface_desc_end_setting = iface_desc_start_setting + iface_desc_num_settings - 1;\n\tiface_desc_ptr_tmp = iface_desc_ptr + iface_desc_len;\n\tiface_desc_index = 0;\n\tiface_desc_index_max = 255;\n\twhile (iface_desc_ptr < iface_desc_ptr_tmp) {\n\t\tif (iface_desc_index > iface_desc_index_max) {\n\t\t\treturn false;\n\t\t}\n\t\tif (iface_desc_type == 4) {\n\t\t\tiface_desc_setting_num = iface_desc_ptr[5];\n\t\t\tif (iface_desc_setting_num == setting_num) {\n\t\t\t\tif (iface_desc_ptr[4] == iface_num) {\n\t\t\t\t", "CodeBleu_score": 31.29372867345937}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = udc_req_get_wValue() & 0x0F;\n\tuint8_t ep_status;\n\n\tif (udc_req_get_wLength() != sizeof(ep_status)) {\n\t\tudc_req_stall();\n\t\treturn false;\n\t}\n\n\tif (ep_num == 0) {\n\t\tep_status = (udd_ep_is_halted(0) ? 1 : 0);\n\t} else {\n\t\tep_status = (udd_ep_is_halted(ep_num) ? 1 : 0);\n\t}\n\n\tudc_req_set_payload(&ep_status, sizeof(ep_status));\n\treturn true;\n}", "CodeBleu_score": 30.05651833583486}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num;\n\tuint8_t ep_status;\n\tuint8_t *p_buf;\n\tuint8_t length;\n\tbool ret_val;\n\tuint8_t ep_type;\n\tuint8_t ep_dir;\n\tuint16_t ep_mps;\n\tuint16_t ep_size;\n\tuint16_t ep_byte_count;\n\tuint16_t ep_byte_count_remaining;\n\tuint16_t ep_max_packet_size;\n\tuint16_t ep_byte_count_limit;\n\tuint16_t ep_byte_count_remaining_limit;\n\tuint8_t ep_is_halted;\n\tuint8_t ep_is_busy;\n\tuint8_t ep_is_in;\n\tuint8_t ep_is_out;\n\tuint8_t ep_is_isochronous;\n\tuint8_t ep_is_control;\n\tuint8_t ep_is_enabled;\n\tuint8_t ep_is_open;\n\tuint8_t ep_is_pending;\n\tuint8_t ep_is_in_buf_ready;\n\tuint8_t ep_is_out_buf_ready;\n\tuint8_t ep_is_in_buf_empty;\n\tuint8_t ep_is_out_buf_empty;\n\tuint8_t ep_is_in_buf_full;\n\tuint8_t ep_is_out_buf_full;\n\tuint8_t ep_is_in_buf_free;\n\tuint8_t ep_is_out_buf_free;\n\tuint8_t ep_is_in_buf_ready_to_send;\n\tuint8_t ep_is_out_buf_ready_to_receive;\n\tuint8_t ep_is_in_buf_ready_to_send_or_empty;\n\tuint8_t ep_is_out_buf_ready_to_receive_or_full;\n\tuint8_t ep_is_in_buf_ready_to_send_or_full", "CodeBleu_score": 5.4663089450030595}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint16_t ep_addr = udd_ep_get_addr(udd_g_ctrl_req.req.wIndex);\n\tuint8_t ep_size = udd_ep_get_size(ep_addr);\n\tuint8_t ep_status = 0;\n\n\tif (udd_g_ctrl_req.req.wLength != ep_size) {\n\t\tudd_g_ctrl_req.status = USB_ERR_INVALID_REQ_LEN;\n\t\treturn false;\n\t}\n\n\tif (udd_ep_is_halted(ep_addr)) {\n\t\tep_status = 1;\n\t}\n\n\tudd_set_setup_payload(ep_status, 0);\n\tudd_g_ctrl_req.status = USB_ERR_OK;\n\n\treturn true;\n}", "CodeBleu_score": 47.627296655955405}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tbool ret = false;\n\tuint8_t iface_num = udc_req_getwvalue() & 0xFF;\n\tuint8_t alt_setting = udc_req_getwindex() & 0xFF;\n\tuint8_t iface_desc_len = 0;\n\tuint8_t *iface_desc_buf = NULL;\n\tuint8_t iface_desc_type = 0;\n\tuint8_t iface_desc_index = 0;\n\tuint8_t iface_desc_alt_setting = 0;\n\tuint8_t iface_desc_num_endpoints = 0;\n\tuint8_t iface_desc_class = 0;\n\tuint8_t iface_desc_subclass = 0;\n\tuint8_t iface_desc_protocol = 0;\n\tuint8_t iface_desc_extra_len = 0;\n\tuint8_t *iface_desc_extra_buf = NULL;\n\tuint8_t ep_num = 0;\n\tuint8_t ep_type = 0;\n\tuint16_t ep_max_size = 0;\n\tuint8_t ep_interval = 0;\n\tuint8_t ep_dir = 0;\n\tuint8_t ep_xfer_type = 0;\n\tuint8_t ep_xfer_sync_type = 0;\n\tuint8_t ep_xfer_usage_type = 0;\n\tuint8_t ep_desc_len = 0;\n\tuint8_t *ep_desc_buf = NULL;\n\tuint8_t ep_desc_type = 0;\n\tuint8_t ep_desc_index = 0;\n\tuint8_t ep_desc_address = 0;\n\tuint8_t ep_desc_attr = 0;\n\tuint8_t ep_desc_max_size = 0;\n\tuint8_t ep_desc_interval = 0;\n\tuint8_t ep_desc_xfer_type = 0;\n\tuint8_t ep_desc_xfer_sync_type = 0;\n\tuint8_t ep_desc_", "CodeBleu_score": 7.221240227087075}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num = udc_setup.wIndex;\n\tuint8_t iface_alt = udc_setup.wValue & 0xff;\n\n\tif (udc_state == UDC_STATE_DEFAULT) {\n\t\tif (iface_num >= udc_dev.cfg.bNumInterfaces) {\n\t\t\treturn false;\n\t\t}\n\t\tudc_update_iface_desc(iface_num, iface_alt);\n\t\tudc_state = UDC_STATE_CONFIGURED;\n\t} else if (udc_state == UDC_STATE_CONFIGURED) {\n\t\tif (iface_num != udc_cfg_desc.bConfigurationValue) {\n\t\t\treturn false;\n\t\t}\n\t\tudc_update_iface_desc(iface_num, iface_alt);\n\t} else {\n\t\treturn false;\n\t}\n\n\treturn udc_api->setup();\n}", "CodeBleu_score": 47.46467217043878}, {"code": "static bool udc_req_iface(void){\n\t\tif (dev.state != UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\tif (req.wIndex != dev.config.bConfigurationValue) {\n\t\treturn false;\n\t}\n\tif (req.wValue != 0) {\n\t\tif (!udc_set_altsetting()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (!udi_api->setup(dev.config.bConfigurationValue, req.bRequest, req.wValue, req.wIndex, req.data, req.length)) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.88433862230781}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t\tuint8_t i;\n\tuint8_t nb_lun;\n\tuint8_t lun;\n\tbool ret;\n\tuint8_t * ptr;\n\tuint8_t * ptr_nb_lun;\n\tuint8_t * ptr_lun;\n\tuint8_t * ptr_enable;\n\tuint8_t * ptr_enable_ext;\n\tuint8_t * ptr_enable_ext_data;\n\tuint8_t * ptr_msc_enable;\n\tuint8_t * ptr_msc_enable_data;\n\tuint8_t * ptr_msc_enable_ext;\n\tuint8_t * ptr_msc_enable_ext_data;\n\tuint8_t * ptr_msc_enable_ext_data_len;\n\tuint8_t * ptr_msc_enable_ext_data_len_data;\n\tuint8_t * ptr_msc_enable_ext_data_len_data_len;\n\tuint8_t * ptr_msc_enable_ext_data_len_data_len_data;\n\tuint8_t * ptr_msc_enable_ext_data_len_data_len_data_len;\n\tuint8_t * ptr_msc_enable_ext_data_len_data_len_data_len_data;\n\tuint8_t * ptr_msc_enable_ext_data_len_data_len_data_len_data_len;\n\tuint8_t * ptr_msc_enable_ext_data_len_data_len_data_len_data_len_data;\n\tuint8_t * ptr_msc_enable_ext_data_len_data_len_data_len_data_len_data_len;\n\tuint8_t * ptr_msc_enable_ext_data_len_data_len_data_len_data_len_data_len_data;\n\tuint8_t * ptr_msc_enable_ext_data_len_data_len_data_len_data_len_data_len_data_len;\n\tuint8_t * ptr_msc_enable_ext_data_len_data_len_data_len_data_len", "CodeBleu_score": 4.63574584903939}, {"code": "bool udi_msc_enable(void){\n\t\tuint8_t i;\n\tuint8_t lun;\n\tbool ret;\n\tuint8_t nb_lun;\n\tuint8_t csw_status;\n\tuint8_t sense_key;\n\tuint8_t sense_asc;\n\tuint8_t sense_ascq;\n\tuint8_t sense_info;\n\tuint8_t sense_length;\n\tuint8_t sense_buf[18];\n\tuint8_t inquiry_response[36];\n\tuint8_t inquiry_length;\n\tuint8_t inquiry_cmd;\n\tuint8_t inquiry_page_code;\n\tuint8_t inquiry_page_length;\n\tuint8_t inquiry_response_length;\n\tuint8_t inquiry_response_cmd;\n\tuint8_t inquiry_response_page_code;\n\tuint8_t inquiry_response_page_length;\n\tuint8_t inquiry_response_response_qualifier;\n\tuint8_t inquiry_response_reserved;\n\tuint8_t inquiry_response_version;\n\tuint8_t inquiry_response_flags;\n\tuint8_t inquiry_response_length_hi;\n\tuint8_t inquiry_response_length_med;\n\tuint8_t inquiry_response_length_lo;\n\tuint8_t inquiry_response_vid;\n\tuint8_t inquiry_response_pid;\n\tuint8_t inquiry_response_response_code;\n\tuint8_t inquiry_response_page_spc;\n\tuint8_t inquiry_response_page_spc_length;\n\tuint8_t inquiry_response_page_spc_type;\n\tuint8_t inquiry_response_page_spc_qualifier;\n\tuint8_t inquiry_response_page_spc_id;\n\tuint8_t inquiry_response_page_spc_rev;\n\tuint8_t inquiry_response_page_spc_vendor;\n\tuint8_t inquiry_response_page_spc_product;\n\tuint8", "CodeBleu_score": 3.845948926511807}, {"code": "bool udi_msc_enable(void){\n\t\t// Initialize the flags and variables\n\tudi_msc_state = UDI_MSC_IDLE;\n\tudi_msc_lun_nb = 0;\n\tudi_msc_lun_max = 0;\n\tudi_msc_lun_cur = 0;\n\tudi_msc_lun_state = 0;\n\tudi_msc_lun_info.state = 0;\n\tudi_msc_lun_info.sense_key = 0;\n\tudi_msc_lun_info.sense_code = 0;\n\tudi_msc_lun_info.sense_qualifier = 0;\n\tudi_msc_lun_info.lun = 0;\n\tudi_msc_lun_info.sense_valid = false;\n\tudi_msc_lun_info.capacity = 0;\n\tudi_msc_lun_info.block_size = 0;\n\tudi_msc_lun_info.nb_block = 0;\n\tudi_msc_lun_info.wr_protect = false;\n\tudi_msc_lun_info.removal = false;\n\tudi_msc_lun_info.lockable = false;\n\tudi_msc_lun_info.eject = false;\n\tudi_msc_lun_info.cd_media = false;\n\tudi_msc_lun_info.media_changed = false;\n\tudi_msc_lun_info.ready = false;\n\tudi_msc_lun_info.state = UDI_MSC_LUN_UNKNOWN;\n\tudi_msc_lun_info.sense_key = UDI_MSC_SENSE_KEY_NO_SENSE;\n\tudi_msc_lun_info.sense_code = 0;\n\tudi_msc_lun_info.sense_qualifier = 0;\n\tudi_msc_lun_info.sense_valid = false;\n\tudi_msc_lun_info.capacity = 0;\n\tudi_msc_lun_info.block_size = 0;\n\tudi_msc_lun_info.nb_block = 0;\n\tudi_msc_lun_info.wr_protect = false;\n\tudi_msc_lun_info.removal = false;\n\t", "CodeBleu_score": 22.382757454784258}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tuint8_t csw_tag;\n\tuint8_t csw_data_residue;\n\tuint8_t csw_status;\n\n\t/* Check the status of the transfer. */\n\tif (status == UDD_EP_TRANSFER_OK) {\n\t\t/* Get the tag from the CSW. */\n\t\tcsw_tag = udi_msc_cbw_tag;\n\t\t/* Get the data residue from the CSW. */\n\t\tcsw_data_residue = udi_msc_cbw_data_residue;\n\t\t/* Get the status from the CSW. */\n\t\tcsw_status = udi_msc_cbw_status;\n\t\t/* Decrease the data residue. */\n\t\tcsw_data_residue -= nb_sent;\n\t\t/* Check if the data residue is not zero. */\n\t\tif (csw_data_residue != 0) {\n\t\t\t/* Update the CSW data residue. */\n\t\t\tudi_msc_cbw_data_residue = csw_data_residue;\n\t\t\t/* Process the updated CSW. */\n\t\t\tudi_msc_process_csw();\n\t\t} else {\n\t\t\t/* Check the status. */\n\t\t\tif (csw_status == UDD_EP_TRANSFER_OK) {\n\t\t\t\t/* Send the response. */\n\t\t\t\tudi_msc_send_response(csw_tag, csw_status);\n\t\t\t} else {\n\t\t\t\t/* Send the response. */\n\t\t\t\tudi_msc_send_response(csw_tag, csw_status);\n\t\t\t\t/* Reset the CBW. */\n\t\t\t\tudi_msc_reset_cbw();\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Reset the CBW. */\n\t\tudi_msc_reset_cbw();\n\t}\n}", "CodeBleu_score": 43.86286983887619}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(ep)\n\n/* Check the transfer status */\nif (status == UDD_EP_TRANSFER_OK) {\n\n/* Update the sense data */\nudi_msc_sense_pass();\n\n/* Decrease the data residue */\nudi_msc_csw.dCSWDataResidue -= nb_sent;\n\n/* Process the updated CSW */\nudi_msc_process_csw();\n} else {\n\n/* Update the sense data */\nudi_msc_sense_fail(UDI_MSC_SENSE_KEY_NOT_READY,\n    UDI_MSC_ASC_NO_MEDIA, UDI_MSC_ASCQ_MEDIUM_NOT_PRESENT);\n\n/* Wait for a MSC setup reset */\nudi_msc_wait_setup_reset();\n}\n}", "CodeBleu_score": 55.542132974053125}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t\tif (status == UDD_EP_TRANSFER_OK) {\n\t\t/* Update the amount of data sent */\n\t\tudi_msc_cbw_t *cbw = &udi_msc_cbw;\n\t\tcbw->dcs.DataResidue -= nb_sent;\n\t\t/* Process the updated CSW */\n\t\tudi_msc_process_csw();\n\t} else {\n\t\t/*\n\t\t * The transfer failed, so wait for a MSC setup reset to restart\n\t\t * CBW reception.\n\t\t */\n\t\tudi_msc_state = UDI_MSC_STATE_WAIT_SETUP;\n\t}\n}", "CodeBleu_score": 52.26373415089095}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tuint8_t b_data_residue;\n\tuint8_t b_ep_num;\n\tuint8_t b_ep_in;\n\tuint8_t b_ep_out;\n\tuint8_t b_ep_in_max_size;\n\tuint8_t b_ep_out_max_size;\n\tuint8_t b_ep_in_size;\n\tuint8_t b_ep_out_size;\n\tuint8_t b_ep_in_size_max;\n\tuint8_t b_ep_out_size_max;\n\tuint8_t b_ep_in_size_send;\n\tuint8_t b_ep_out_size_send;\n\tuint8_t b_ep_in_size_max_send;\n\tuint8_t b_ep_out_size_max_send;\n\tuint8_t b_ep_in_size_max_send_orig;\n\tuint8_t b_ep_out_size_max_send_orig;\n\tuint8_t b_ep_in_size_max_orig;\n\tuint8_t b_ep_out_size_max_orig;\n\tuint8_t b_ep_in_size_orig;\n\tuint8_t b_ep_out_size_orig;\n\tuint8_t b_ep_in_size_max_orig_send;\n\tuint8_t b_ep_out_size_max_orig_send;\n\tuint8_t b_ep_in_size_max_orig_send_orig;\n\tuint8_t b_ep_out_size_max_orig_send_orig;\n\tuint8_t b_ep_in_size_max_orig_orig;\n\tuint8_t b_ep_out_size_max_orig_orig;\n\tuint8_t b_ep_in_size_max_orig_orig_send;\n\tuint8_t b_ep_out_size_max_orig_orig_send;\n\tuint8_t b_ep_in_size_max_orig_orig_send_orig;\n\tuint8", "CodeBleu_score": 3.788282018428514}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint8_t data[4] = {0};\n\tuint8_t i;\n\tuint16_t residue;\n\tuint8_t direction;\n\tuint8_t status;\n\tuint8_t csw_status;\n\tuint8_t csw_tag;\n\tuint8_t csw_data_residue[4];\n\n\tresidue = cpu_to_le16(msc_cbw.dCBWDataTransferLength);\n\tdirection = msc_cbw.bCBWFlags & UDI_MSC_CBW_DIRECTION_MASK;\n\n\t/*\n\t * If there is a non-zero data residue, stall the next request from the USB host on the appropriate endpoint.\n\t */\n\tif (residue) {\n\t\tif (direction == UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\tudd_ep_set_halt(msc_bulk_in_addr);\n\t\t} else {\n\t\t\tudd_ep_set_halt(msc_bulk_out_addr);\n\t\t}\n\t}\n\n\t/*\n\t * Prepare the CSW by setting its tag and converting the data residue to little-endian format.\n\t */\n\tcsw_tag = msc_cbw.dCBWTag;\n\tcsw_status = UDI_MSC_CSW_STATUS_PASSED;\n\tif (residue) {\n\t\tcsw_status = UDI_MSC_CSW_STATUS_FAILED;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tcsw_data_residue[i] = residue & 0xFF;\n\t\tresidue >>= 8;\n\t}\n\n\t/*\n\t * Send the CSW.\n\t */\n\tdata[0] = csw_tag;\n\tdata[1] = csw_status;\n\tdata[2] = csw_data_residue[0];\n\tdata[3] = csw_data_residue[1];\n\tstatus = udi_msc_csw_send(data);\n\tif (status) {\n\t\tudi_msc_state = UDI_MSC_STATE_IDLE;\n\t}\n}", "CodeBleu_score": 44.94334712133951}, {"code": "static void udi_msc_csw_process(void){\n\t\tuint32_t csw_tag;\n\tuint32_t csw_residue;\n\tuint32_t csw_status;\n\tuint8_t csw_sig;\n\tuint8_t csw_tag0;\n\tuint8_t csw_tag1;\n\tuint8_t csw_tag2;\n\tuint8_t csw_tag3;\n\tuint8_t csw_tag4;\n\tuint8_t csw_tag5;\n\tuint8_t csw_tag6;\n\tuint8_t csw_tag7;\n\tuint8_t csw_tag8;\n\tuint8_t csw_tag9;\n\tuint8_t csw_tag10;\n\tuint8_t csw_tag11;\n\tuint8_t csw_tag12;\n\tuint8_t csw_tag13;\n\tuint8_t csw_tag14;\n\tuint8_t csw_tag15;\n\tuint8_t csw_sig0;\n\tuint8_t csw_sig1;\n\tuint8_t csw_sig2;\n\tuint8_t csw_sig3;\n\tuint8_t csw_sig4;\n\tuint8_t csw_sig5;\n\tuint8_t csw_sig6;\n\tuint8_t csw_sig7;\n\tuint8_t csw_sig8;\n\tuint8_t csw_sig9;\n\tuint8_t csw_sig10;\n\tuint8_t csw_sig11;\n\tuint8_t csw_sig12;\n\tuint8_t csw_sig13;\n\tuint8_t csw_sig14;\n\tuint8_t csw_sig15;\n\tuint8_t csw_sig16;\n\tuint8_t csw_sig17;\n\tuint8_t csw_sig18;\n\tuint8_t csw_sig19;\n\tuint8_t csw_sig20;\n\tuint8", "CodeBleu_score": 3.812969093508869}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_MAX_CDC_PORT) {\n\t\treturn;\n\t}\n\n\tif (b_enable) {\n\t\tif (usb_cdc_port_dtr[port]) {\n\t\t\treturn;\n\t\t}\n\n\t\tusb_cdc_port_dtr[port] = true;\n\t\tif (usb_cdc_port_dtr_rate[port] == 1200) {\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\tif (!usb_cdc_port_dtr[port]) {\n\t\t\treturn;\n\t\t}\n\n\t\tusb_cdc_port_dtr[port] = false;\n\t\tif (usb_cdc_port_dtr_rate[port] == 1200) {\n\t\t\tinitiateReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.402636150476916}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_CDC_PORT_COUNT) {\n\t\treturn;\n\t}\n\n\t// Check if the DTR signal is enabled.\n\tif (b_enable) {\n\t\t// Check if the DTR rate is 1200.\n\t\tif (usb_cdc_dtr_rate[port] == USB_CDC_DTR_RATE_1200) {\n\t\t\t// Cancel any scheduled reset.\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\t// Check if the DTR rate is 1200.\n\t\tif (usb_cdc_dtr_rate[port] == USB_CDC_DTR_RATE_1200) {\n\t\t\t// Schedule a delayed system reset.\n\t\t\tinitiateReset();\n\t\t}\n\t}\n\n\t// Update the DTR status.\n\tusb_cdc_dtr[port] = b_enable;\n}", "CodeBleu_score": 39.2281538503154}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_CDC_PORT_COUNT) {\n\t\treturn;\n\t}\n\tif (b_enable) {\n\t\t// Enable DTR signal\n\t\tusb_cdc_ports[port].b_dtr = true;\n\t\t// Check if DTR rate is 1200\n\t\tif (usb_cdc_ports[port].dw_dtr_rate == 1200) {\n\t\t\t// Cancel any scheduled reset\n\t\t\tcancelReset();\n\t\t\t// Schedule a delayed system reset\n\t\t\tusb_cdc_ports[port].dw_reset_time = getMs() + 1000;\n\t\t\tinitiateReset();\n\t\t}\n\t} else {\n\t\t// Disable DTR signal\n\t\tusb_cdc_ports[port].b_dtr = false;\n\t\t// Cancel any scheduled reset\n\t\tcancelReset();\n\t}\n}", "CodeBleu_score": 37.548176085811}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tuint8_t *payload = usb_control_request.payload;\n\tuint8_t *size = &usb_control_request.length;\n\tuint8_t *index = &usb_control_request.index;\n\tuint8_t *request_type = &usb_control_request.request_type;\n\tuint8_t *request = &usb_control_request.request;\n\n\tswitch (*request_type) {\n\t\tcase USB_REQUEST_TYPE_VENDOR:\n\t\t\tswitch (*request) {\n\t\t\t\tcase MS_OS_STRING_DESCRIPTOR_REQUEST:\n\t\t\t\t\t// Microsoft OS 2.0 Descriptors\n\t\t\t\t\tif (usb_control_request.length < MS_OS_20_STRING_DESCRIPTOR_SIZE) {\n\t\t\t\t\t\tusb_control_request.length = MS_OS_20_STRING_DESCRIPTOR_SIZE;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tusb_control_request.length = MS_OS_20_STRING_DESCRIPTOR_SIZE;\n\t\t\t\t\tusb_control_request.payload[0] = 0x0A;\n\t\t\t\t\tusb_control_request.payload[1] = 0x00;\n\t\t\t\t\tusb_control_request.payload[2] = 0x00;\n\t\t\t\t\tusb_control_request.payload[3] = 0x00;\n\t\t\t\t\tusb_control_request.payload[4] = 0x00;\n\t\t\t\t\tusb_control_request.payload[5] = 0x00;\n\t\t\t\t\tusb_control_request.payload[6] = 0x00;\n\t\t\t\t\tusb_control_request.payload[7] = 0x00;\n\t\t\t\t\tusb_control_request.payload[8] = 0x00;\n\t\t\t\t\tusb_control_request.payload[9] = 0x00;\n\t\t\t\t\tusb_control_request.payload[10] = 0x00;\n\t\t\t\t\tusb_control_request.payload[11] = 0x00;\n\t\t\t\t\tusb_control_request.payload[12] = 0x00;\n\t\t\t\t\tusb_control_request.payload[13] = 0x00;\n\t\t\t\t\tusb_control_request.payload[14] = 0x0", "CodeBleu_score": 21.828787593381787}, {"code": "bool usb_task_other_requests(void){\n\t\tusb_setup_packet_t *setup_packet = &g_usb_device.setup_packet;\n\tuint8_t *buffer = g_usb_device.ctrl_request_buffer;\n\tuint16_t length = g_usb_device.ctrl_request_length;\n\tuint8_t *buffer_ptr = buffer;\n\tuint8_t *buffer_end = buffer + length;\n\n\tif (setup_packet->request == USB_REQUEST_GET_DESCRIPTOR) {\n\t\tswitch (setup_packet->value >> 8) {\n\t\tcase USB_DESCRIPTOR_TYPE_STRING:\n\t\t\tif (setup_packet->value == 0) {\n\t\t\t\t// Language descriptor\n\t\t\t\tbuffer_ptr = usb_string_langid_desc_list;\n\t\t\t\tlength = 4;\n\t\t\t} else {\n\t\t\t\t// String descriptor\n\t\t\t\tuint8_t index = setup_packet->value & 0xFF;\n\t\t\t\tif (index < USB_STRING_DESC_COUNT) {\n\t\t\t\t\tbuffer_ptr = g_usb_device.string_descriptor_list[index];\n\t\t\t\t\tlength = g_usb_device.string_descriptor_list[index][0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USB_DESCRIPTOR_TYPE_DEVICE_QUALIFIER:\n\t\t\tif (setup_packet->value == 0) {\n\t\t\t\t// Device qualifier descriptor\n\t\t\t\tusb_device_qualifier_desc_t *dev_qual_desc = (usb_device_qualifier_desc_t *)buffer_ptr;\n\t\t\t\tdev_qual_desc->bLength = sizeof(usb_device_qualifier_desc_t);\n\t\t\t\tdev_qual_desc->bDescriptorType = USB_DESCRIPTOR_TYPE_DEVICE_QUALIFIER;\n\t\t\t\tdev_qual_desc->bcdUSB = 0x0200;\n\t\t\t\tdev_qual_desc->bDeviceClass = 0;\n\t\t\t\tdev_qual_desc->bDeviceSubClass = 0;\n\t\t\t\tdev_qual_desc->bDeviceProtocol = 0;\n\t\t\t\tdev_qual_desc->bMaxPacketSize0 = 64;\n\t\t\t\tdev_qual_desc->bNumConfigurations = 1;\n\t\t\t\tlength = sizeof(usb_device_qualifier_desc_t);\n\t\t\t}\n\t\t\tbreak;", "CodeBleu_score": 31.10454480178214}, {"code": "bool usb_task_other_requests(void){\n\t\tbool ret = false;\n\n\tif (usb_setup.bmRequestType.Type == USB_SETUP_TYPE_VENDOR) {\n\t\tif (usb_setup.bRequest == USB_SETUP_REQUEST_SET_DESCRIPTOR) {\n\t\t\tswitch (usb_setup.wValue.WB.L) {\n\t\t\tcase USB_SETUP_VALUE_MS_EXT_PROPERTIES:\n\t\t\t\tif (usb_setup.wLength == 0x0009) {\n\t\t\t\t\tusb_control_in_buffer[0] = 0x09;\n\t\t\t\t\tusb_control_in_buffer[1] = 0x24;\n\t\t\t\t\tusb_control_in_buffer[2] = 0x00;\n\t\t\t\t\tusb_control_in_buffer[3] = 0x01;\n\t\t\t\t\tusb_control_in_buffer[4] = 0x01;\n\t\t\t\t\tusb_control_in_buffer[5] = 0x00;\n\t\t\t\t\tusb_control_in_buffer[6] = 0x01;\n\t\t\t\t\tusb_control_in_buffer[7] = 0x00;\n\t\t\t\t\tusb_control_in_buffer[8] = 0x00;\n\t\t\t\t\tusb_control_in_buffer_size = 0x09;\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_SETUP_VALUE_MS_OS_DESC:\n\t\t\t\tif (usb_setup.wLength == 0x0000) {\n\t\t\t\t\tusb_control_in_buffer[0] = 0x00;\n\t\t\t\t\tusb_control_in_buffer_size = 0x00;\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (usb_setup.bRequest == USB_SETUP_REQUEST_GET_DESCRIPTOR) {\n\t\t\tswitch (usb_setup.wValue.WB.H) {\n\t\t\tcase USB_SETUP_VALUE_MS_EXT_PROPERTIES:\n\t\t\t\tif (usb_setup.wValue.WB.L == USB_SETUP_VALUE_MS_EXT_PROPERTIES) {\n\t\t\t\t\tif (usb_setup.wLength == 0x0009) {\n\t\t\t\t\t\tusb_control_in_buffer[0] = 0x09", "CodeBleu_score": 28.903600203054054}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tuint8_t i;\n\tuint8_t rxByte;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPDR = 0xFF;\n\t\twhile (!(SPSR & (1 << SPIF))) {\n\t\t\t;\n\t\t}\n\t\trxByte = SPDR;\n\t\tbuf[i] = rxByte;\n\t}\n\tSPDR = 0xFF;\n\twhile (!(SPSR & (1 << SPIF))) {\n\t\t;\n\t}\n\tbuf[nbyte - 1] = SPDR;\n}", "CodeBleu_score": 42.586967602749056}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\n\tuint8_t *p = buf;\n\n\twhile (nbyte-- > 1) {\n\t\t*p++ = spiRec();\n\t}\n\t*p = spiRec();\n}", "CodeBleu_score": 30.17324106044381}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tuint8_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(0x00);\n\t\twhile (spiRec() == 0x00) {\n\t\t\t;\n\t\t}\n\t\tbuf[i] = spiRec();\n\t}\n\tspiSend(0x00);\n\twhile (spiRec() == 0x00) {\n\t\t;\n\t}\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 46.321674814256966}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *relocatedTable;\n\n\t// Retrieve the address of the relocated interrupt vector table.\n\trelocatedTable = get_relocated_table_addr();\n\n\t// Disable global interrupts to ensure atomic operation.\n\t__disable_irq();\n\n\t// Retrieve the original handler for the specified IRQ.\n\toldHandler = (pfnISR_Handler) relocatedTable[irq];\n\n\t// Replace the original handler with the new handler.\n\trelocatedTable[irq] = (uint32_t) newHandler;\n\n\t// Re-enable global interrupts.\n\t__enable_irq();\n\n\t// Return the original handler.\n\treturn oldHandler;\n}", "CodeBleu_score": 50.762753869723824}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *relocatedTable;\n\tuint32_t newHandlerAddr;\n\tuint32_t oldHandlerAddr;\n\n\t/* Get the address of the relocated interrupt vector table */\n\trelocatedTable = get_relocated_table_addr();\n\n\t/* Disable global interrupts */\n\t__disable_irq();\n\n\t/* Get the address of the new handler */\n\tnewHandlerAddr = (uint32_t)newHandler;\n\n\t/* Get the address of the old handler */\n\toldHandlerAddr = relocatedTable[irq];\n\n\t/* Install the new handler */\n\trelocatedTable[irq] = newHandlerAddr;\n\n\t/* Re-enable global interrupts */\n\t__enable_irq();\n\n\t/* Return the original handler */\n\toldHandler = (pfnISR_Handler)oldHandlerAddr;\n\treturn oldHandler;\n}", "CodeBleu_score": 47.21790434758407}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *relocated_table_addr = get_relocated_table_addr();\n\tuint32_t old_handler_addr;\n\n\tCRITICAL_SECTION_START\n\told_handler_addr = relocated_table_addr[irq];\n\trelocated_table_addr[irq] = (uint32_t) newHandler;\n\tNVIC_EnableIRQ(irq);\n\tCRITICAL_SECTION_END\n\n\treturn (pfnISR_Handler) old_handler_addr;\n}", "CodeBleu_score": 47.746357636348925}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\tif (m_emergency_parser.peek()) return m_emergency_parser.peek();\n\tif (m_enabled && m_cdc_enabled) {\n\t\tif (udi_cdc_is_rx_ready()) {\n\t\t\tm_cdc_rx_buffer[m_cdc_rx_buffer_head] = udi_cdc_getc();\n\t\t\tm_cdc_rx_buffer_head = (m_cdc_rx_buffer_head + 1) & (SERIAL_RX_BUFFER_SIZE - 1);\n\t\t\tif (m_cdc_rx_buffer_head == m_cdc_rx_buffer_tail) {\n\t\t\t\tm_cdc_rx_buffer_tail = (m_cdc_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);\n\t\t\t}\n\t\t\tif (m_emergency_parser.update()) return m_emergency_parser.peek();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 35.61546862251878}, {"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(USE_USB_SERIAL) && !defined(USBCON)\n  if (usb_task_cdc_isenabled()) {\n    if (udi_cdc_is_rx_ready()) {\n      return udi_cdc_getc();\n    }\n  }\n#endif\n  return -1;\n}", "CodeBleu_score": 14.442332227941856}, {"code": "int MarlinSerialUSB::peek(){\n\t\t// If the USB CDC is not enabled or configured on the PC side, or if no bytes are sent from the PC, return -1\n\tif (!usb_task_cdc_isenabled || !usb_cdc_rx_enabled) return -1;\n\t// If bytes are available, read the next character, process it if the emergency parser is enabled, and return the character\n\tif (udi_cdc_is_rx_ready()) {\n\t\tconst int c = udi_cdc_getc();\n\t\tif (c >= 0) {\n\t\t\tif (emergency_parser.enabled) emergency_parser.process(c);\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 41.85389015968181}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\t// Check if there is a pending character\n\tif (m_rx_buffer_head != m_rx_buffer_tail) {\n\t\tuint8_t c = m_rx_buffer[m_rx_buffer_tail];\n\t\tm_rx_buffer_tail = (m_rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n\t\treturn c;\n\t}\n\t// Check if the USB CDC is enabled and configured\n\tif (!usb_task_cdc_isenabled()) return -1;\n\t// Check if there are any bytes available to read from the PC\n\tif (!udi_cdc_is_rx_ready()) return -1;\n\t// Read the byte\n\tuint8_t c = udi_cdc_getc();\n\t// Update the emergency parser\n\tif (m_emergency_parser.enabled()) m_emergency_parser.update(c);\n\t// Return the read character\n\treturn c;\n}", "CodeBleu_score": 54.914345476980856}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (m_rx_buffer_head != m_rx_buffer_tail) {\n\t\t// Return character from receive buffer\n\t\tuint8_t c = m_rx_buffer[m_rx_buffer_tail];\n\t\tm_rx_buffer_tail = (m_rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n\t\treturn c;\n\t}\n\tif (!m_enabled || !m_configured) {\n\t\treturn -1;\n\t}\n\tif (!usb_cdc_is_rx_ready()) {\n\t\treturn -1;\n\t}\n\tuint8_t c = usb_cdc_getc();\n\tif (m_emergency_parser) {\n\t\tm_emergency_parser->update(c);\n\t}\n\treturn c;\n}", "CodeBleu_score": 44.35911443305064}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (rx_buffer_head != rx_buffer_tail) {\n\t\t// Return character from receive buffer\n\t\tuint8_t c = rx_buffer[rx_buffer_tail];\n\t\trx_buffer_tail = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n\t\treturn c;\n\t}\n\telse if (usb_task_cdc_isenabled && cdc_rx_buffer_head != cdc_rx_buffer_tail) {\n\t\t// Return character from receive buffer\n\t\tuint8_t c = cdc_rx_buffer[cdc_rx_buffer_tail];\n\t\tcdc_rx_buffer_tail = (cdc_rx_buffer_tail + 1) % CDC_RX_BUFFER_SIZE;\n\t\tif (emergency_parser.enabled) emergency_parser.update(c);\n\t\treturn c;\n\t}\n\telse if (usb_task_cdc_isenabled) {\n\t\t// No character available\n\t\treturn -1;\n\t}\n\telse {\n\t\t// No character available\n\t\treturn -1;\n\t}\n}", "CodeBleu_score": 35.34128241674663}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tif (cdc_rx_buf_head != cdc_rx_buf_tail) {\n\t\treturn (cdc_rx_buf_head - cdc_rx_buf_tail) + 1;\n\t}\n\telse if (cdc_rx_buf_head == cdc_rx_buf_tail && usb_cdc_is_rx_ready()) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 42.104309003603404}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (cdc_rx_count) {\n\t\treturn cdc_rx_count;\n\t}\n\telse {\n\t\tif (cdc_enabled && usb_cdc_is_rx_ready()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.07487448919851}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (count_available) return count_available;\n\tif (cdc_enabled) {\n\t\tif (cdc_is_rx_ready) return 1;\n\t\telse return 0;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 31.748085331502228}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tuint8_t b;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (!read_byte(pos, b, crc, writing))\n\t\t\treturn false;\n\t\tif (value)\n\t\t\tvalue[i] = b;\n\t}\n\treturn true;\n}", "CodeBleu_score": 42.61543356941989}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (pos >= _size) {\n\t\treturn false;\n\t}\n\tif (pos + size > _size) {\n\t\tsize = _size - pos;\n\t}\n\tif (value != NULL) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tvalue[i] = _data[pos + i];\n\t\t}\n\t}\n\tif (crc != NULL) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\t*crc = crc16(*crc, _data[pos + i]);\n\t\t}\n\t}\n\tif (writing) {\n\t\t_size = pos + size;\n\t}\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 43.17453931737746}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\tif (!value || !size || !crc) {\n\t\treturn false;\n\t}\n\tif (pos < 0 || pos >= EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tif (writing) {\n\t\t*crc = crc16(crc, (uint8_t *) &pos, sizeof(pos));\n\t}\n\tfor (size_t i = 0; i < size; ++i) {\n\t\tif (writing) {\n\t\t\tvalue[i] = ee_Read(pos);\n\t\t\t*crc = crc16(crc, (uint8_t *) &value[i], sizeof(value[i]));\n\t\t}\n\t\tpos++;\n\t}\n\treturn true;\n}", "CodeBleu_score": 45.23657875017154}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin < NUM_DIGITAL_PINS) {\n\t\tif (IS_PWM_PIN(pin)) {\n\t\t\tledcWrite(get_pwm_channel(pin), value);\n\t\t} else {\n\t\t\t// Software PWM\n\t\t\tif (get_pwm_state(pin) == NULL) {\n\t\t\t\t// Start the timer if this is the first PWM pin\n\t\t\t\tif (used_pwm_channels == 0) {\n\t\t\t\t\tHAL_timer_start();\n\t\t\t\t}\n\t\t\t\t// Allocate a new software PWM state\n\t\t\t\tset_pwm_state(pin, new_pwm_state(pin, freq, res));\n\t\t\t\tused_pwm_channels++;\n\t\t\t}\n\t\t\t// Set the PWM value\n\t\t\tset_pwm_value(pin, value);\n\t\t}\n\t}\n}", "CodeBleu_score": 27.69582744431344}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (pin < 0) return;\n\tif (value > 1023) value = 1023;\n\tif (value == 0) {\n\t\tif (pwm_state[pin].timer != NULL) {\n\t\t\tpwm_state[pin].timer->stop();\n\t\t\tif (pwm_state[pin].timer->get_auto_reload() == true) {\n\t\t\t\tpwm_state[pin].timer->set_counter_value(0);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif (freq == 0) {\n\t\tfreq = PWM_FREQUENCY;\n\t}\n\tif (res == 0) {\n\t\tres = 8;\n\t}\n\tif (pwm_state[pin].timer != NULL) {\n\t\tif (pwm_state[pin].timer->get_auto_reload() == true) {\n\t\t\tpwm_state[pin].timer->set_period(1000000000 / freq);\n\t\t\tpwm_state[pin].timer->set_counter_value(0);\n\t\t\tpwm_state[pin].timer->set_auto_reload(false);\n\t\t\tpwm_state[pin].timer->set_counter_value(value * (1 << res) / 1023);\n\t\t\tpwm_state[pin].timer->set_auto_reload(true);\n\t\t\tpwm_state[pin].timer->start();\n\t\t} else {\n\t\t\tpwm_state[pin].timer->set_period(1000000000 / freq);\n\t\t\tpwm_state[pin].timer->set_counter_value(value * (1 << res) / 1023);\n\t\t\tpwm_state[pin].timer->start();\n\t\t}\n\t\treturn;\n\t}\n\tif (pwm_state[pin].used == false) {\n\t\tpwm_state[pin].timer = new HardwarePWM(get_pwm_channel(), freq, res);\n\t\tpwm_state[pin].used = true;\n\t\tpwm_state[pin].count = 1;\n\t} else {\n\t\tpwm_state[pin].count++;\n\t}\n\tpwm_state[pin].timer->set_period(1000000000", "CodeBleu_score": 27.737231420203067}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\tif (value > 255) {\n\t\tanalogWrite(pin, 255);\n\t}\n\telse if (value == 0) {\n\t\tanalogWrite(pin, 0);\n\t}\n\telse {\n\t\tif (ledcWrite(pin, value, freq, res)) {\n\t\t\treturn;\n\t\t}\n\t\tif (pwm_state[pin].timer == NULL) {\n\t\t\tif (!pwm_state[pin].used) {\n\t\t\t\tpwm_state[pin].used = true;\n\t\t\t\tpwm_state[pin].count = 0;\n\t\t\t}\n\t\t\tpwm_state[pin].timer = timerBegin(0, 80, true);\n\t\t\ttimerAttachInterrupt(pwm_state[pin].timer, &pwm_timer_isr, true);\n\t\t\ttimerAlarmWrite(pwm_state[pin].timer, PWM_PERIOD, true);\n\t\t\ttimerAlarmEnable(pwm_state[pin].timer);\n\t\t}\n\t\tpwm_state[pin].count++;\n\t\tpwm_state[pin].values[pwm_state[pin].count] = value;\n\t}\n}", "CodeBleu_score": 30.324171329839494}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH != 0\n\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH > SERVO_CHANNEL_COUNT, \"The servo delay array length must be greater than or equal to the servo channel count.\");\n#endif\n\tif (attach()) {\n\t\twrite(value);\n#if SERVO_DELAY_ARRAY_LENGTH != 0\n\t\tdelay(SERVO_DELAY_ARRAY_LENGTH > SERVO_CHANNEL_COUNT ? SERVO_DELAY_ARRAY_LENGTH : SERVO_CHANNEL_COUNT, SERVO_DELAY_ARRAY[SERVO_CHANNEL]);\n#endif\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tdetach();\n\t\t}\n\t}\n}", "CodeBleu_score": 45.670714656172976}, {"code": "void Servo::move(const int value){\n\t\tstatic_assert(SERVO_DELAY_ARRAY_LENGTH == SERVO_CHANNEL_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must be equal to SERVO_CHANNEL_COUNT\");\n\tif (attach()) {\n\t\twrite(value);\n\t\tdelay(safe_delay(value));\n\t\tif (DEACTIVATE_SERVOS_AFTER_MOVE) {\n\t\t\tdetach();\n\t\t}\n\t}\n}", "CodeBleu_score": 32.79018819101379}, {"code": "void Servo::move(const int value){\n\t#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n    detach();\n#endif\n\n#if SERVO_DELAY_ARRAY_LENGTH != 0\n    static_assert(SERVO_DELAY_ARRAY_LENGTH >= SERVO_CHANNEL_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must be greater than or equal to SERVO_CHANNEL_COUNT\");\n#endif\n\n    if (value > SERVO_MAX_ANGLE || value < SERVO_MIN_ANGLE) {\n        return;\n    }\n\n    const uint16_t pulse = (value * 1000) / SERVO_MAX_ANGLE + SERVO_MIN_PULSE_WIDTH;\n\n    write(pulse);\n\n#if SERVO_DELAY_ARRAY_LENGTH != 0\n    delay(servo_delay[channel]);\n#endif\n\n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n    attach();\n#endif\n}", "CodeBleu_score": 42.53903009622488}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tuint32_t port_state = 0;\n\tuint32_t i;\n\n\t// Update the PWM states for each pin\n\tfor (i = 0; i < NUM_PINS; i++) {\n\t\tif (pwm_states[i].tick_count) {\n\t\t\tpwm_states[i].tick_count--;\n\t\t} else {\n\t\t\tpwm_states[i].pin_state = !pwm_states[i].pin_state;\n\t\t\tpwm_states[i].tick_count = pwm_states[i].duty_cycle;\n\t\t}\n\n\t\tport_state |= pwm_states[i].pin_state << i;\n\t}\n\n\t// Write the updated port data to the DMA buffer\n\tuint32_t *dst = (uint32_t *)audio_dma_buffer;\n\tdst[audio_dma_buffer_pos] = port_state;\n\n\t// Increment the buffer position\n\taudio_dma_buffer_pos++;\n\tif (audio_dma_buffer_pos >= AUDIO_DMA_BUFFER_LENGTH) {\n\t\taudio_dma_buffer_pos = 0;\n\t}\n}", "CodeBleu_score": 26.43864475400263}, {"code": "void i2s_push_sample(){\n\t\tuint16_t i;\n\tuint32_t *p;\n\tuint32_t sample;\n\n\t// Loop through each pin\n\tfor (i = 0; i < NUM_PINS; i++) {\n\t\t// If the pin has active PWM, update the PWM state\n\t\tif (PWM_STATE[i].duty_cycle) {\n\t\t\tPWM_STATE[i].tick_count--;\n\n\t\t\t// If the tick count reaches zero, toggle the pin state\n\t\t\tif (!PWM_STATE[i].tick_count) {\n\t\t\t\tPWM_STATE[i].tick_count = PWM_STATE[i].period;\n\t\t\t\tPWM_STATE[i].pin_state = !PWM_STATE[i].pin_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Loop through each pin\n\tfor (i = 0; i < NUM_PINS; i++) {\n\t\t// If the pin has active PWM, write the pin state to the DMA buffer\n\t\tif (PWM_STATE[i].duty_cycle) {\n\t\t\tsample = (PWM_STATE[i].pin_state << i) & 0x00000001;\n\t\t}\n\t\telse {\n\t\t\tsample = 0x00000000;\n\t\t}\n\n\t\t// Write the sample to the DMA buffer\n\t\tp = (uint32_t *) &DMA_BUFFER[DMA_BUFFER_POS];\n\t\t*p = sample;\n\n\t\t// Increment the DMA buffer position\n\t\tDMA_BUFFER_POS += 4;\n\t}\n}", "CodeBleu_score": 30.163230832744105}, {"code": "void i2s_push_sample(){\n\t\tfor (uint8_t pin = 0; pin < NUM_I2S_PINS; pin++) {\n\t\tif (i2s_pin_state[pin].duty_cycle) {\n\t\t\tif (i2s_pin_state[pin].tick_count == 0) {\n\t\t\t\ti2s_pin_state[pin].tick_count = i2s_pin_state[pin].duty_cycle;\n\t\t\t\ti2s_pin_state[pin].pin_state = !i2s_pin_state[pin].pin_state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti2s_pin_state[pin].tick_count--;\n\t\t\t}\n\t\t}\n\t\ti2s_dma_buffer[i2s_dma_buffer_pos] = i2s_pin_state[pin].pin_state;\n\t\ti2s_dma_buffer_pos++;\n\t\tif (i2s_dma_buffer_pos >= I2S_DMA_BUFFER_SIZE) {\n\t\t\ti2s_dma_buffer_pos = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 33.335768551122044}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.565388263516002}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn HAL_timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.888117861936223}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn HAL_timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.888117861936223}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (writing) {\n\t\t\tvalue[i] = EEPROM.read(pos + i);\n\t\t}\n\t\t*crc = crc16_update(*crc, value[i]);\n\t}\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 61.010097015053645}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tif (pos + size > EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\n\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos + i);\n\t\tif (crc) {\n\t\t\t*crc = crc16(*crc, value[i]);\n\t\t}\n\t\tif (writing) {\n\t\t\tEEPROM.write(pos + i, value[i]);\n\t\t}\n\t}\n\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 61.627360677539066}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t\tuint16_t crc_tmp = 0;\n\tfor (int i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos);\n\t\tcrc_tmp = crc16(crc_tmp, value[i]);\n\t\tif (writing)\n\t\t\t*(pos + i) = value[i];\n\t}\n\tif (crc != NULL)\n\t\t*crc = crc_tmp;\n\treturn false;\n}", "CodeBleu_score": 55.688823501437334}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tSD_HandleTypeDef *hsd = SD_HANDLE;\n\tuint32_t data_error_counter = 0;\n\tuint32_t data_error = 0;\n\n\t/* Check parameters */\n\tif ((hsd == NULL) || (src == NULL)) {\n\t\treturn false;\n\t}\n\n\t/* Write block of data to the SD card */\n\tif (HAL_SD_WriteBlocks(hsd, (uint8_t *)src, block, 1) != HAL_OK) {\n\t\t/* Check whether the SD card is ready for writing */\n\t\tif (HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER) {\n\t\t\t/* Re-initialise the SD card */\n\t\t\tif (SD_Init() != SD_OK) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/* Increment the data error counter */\n\t\tdata_error_counter++;\n\n\t\t/* Check whether the maximum number of data errors has been reached */\n\t\tif (data_error_counter == SD_MAX_DATA_ERRORS) {\n\t\t\t/* Set the error flag */\n\t\t\tdata_error = 1;\n\n\t\t\t/* Print error message */\n\t\t\tprintf(\"SD card data error\n\");\n\t\t}\n\t}\n\n\t/* Check whether the data error flag is set */\n\tif (data_error == 1) {\n\t\t/* Return error status */\n\t\treturn false;\n\t} else {\n\t\t/* Return OK status */\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 37.116715602826304}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tSD_Error status;\n\tuint32_t timeout = 0;\n\tif (SD_HANDLE == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\tstatus = SDCARD_WriteBlocks(SD_HANDLE, src, block, 1);\n\twhile (status != SD_OK && timeout < 1000) {\n\t\ttimeout++;\n\t\tstatus = SDCARD_WriteBlocks(SD_HANDLE, src, block, 1);\n\t}\n\tif (status == SD_OK) {\n\t\treturn true;\n\t}\n\telse {\n\t\tprintf(\"SDCARD_WriteBlocks failed with error code %d\\r\n\", status);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 42.48091517385673}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tSD_HandleTypeDef sdHandle;\n\tuint32_t timeout = SDCARD_MAX_WRITE_TIMEOUT;\n\tuint8_t retries = SDCARD_MAX_WRITE_RETRIES;\n\tbool success = false;\n\n\tif (SDHandle == NULL) {\n\t\tCORE_ASSERT(false, \"SDHandle is null\");\n\t\treturn false;\n\t}\n\n\tif (src == NULL) {\n\t\tCORE_ASSERT(false, \"src is null\");\n\t\treturn false;\n\t}\n\n\tsdHandle = *SDHandle;\n\n\twhile (retries > 0) {\n\t\tif (HAL_SD_WriteBlocks(&sdHandle, (uint8_t *) src, block, 1) == HAL_OK) {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tretries--;\n\t\tSDCARD_WriteRetry(retries, timeout);\n\t}\n\n\tif (success == false) {\n\t\tSDCARD_WriteError();\n\t}\n\n\treturn success;\n}", "CodeBleu_score": 41.504484704188165}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tCORE_DEBUG_ASSERT", "CodeBleu_score": 2.999142593299572}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\ttimer_num->start", "CodeBleu_score": 8.047219516323269}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\n}", "CodeBleu_score": 3.0208119559598674}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tif (file) {\n\t\treturn false;\n\t}\n\tfile = fopen(filename, \"r+b\");\n\tif (!file) {\n\t\tfile = fopen(filename, \"w+b\");\n\t\tif (!file) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfseek(file, 0, SEEK_END);\n\tsize_t size = ftell(file);\n\tif (size < sizeof(eeprom)) {\n\t\tfseek(file, 0, SEEK_SET);\n\t\tmemset(eeprom, erase_value, sizeof(eeprom));\n\t\tfwrite(eeprom, sizeof(eeprom), 1, file);\n\t\tfseek(file, 0, SEEK_SET);\n\t} else {\n\t\tfseek(file, 0, SEEK_SET);\n\t\tfread(eeprom, sizeof(eeprom), 1, file);\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.57006642933891}, {"code": "bool PersistentStore::access_start(){\n\t\tif (this->eeprom_file) {\n\t\treturn false;\n\t}\n\tthis->eeprom_file = fopen(this->eeprom_filename, \"r+b\");\n\tif (!this->eeprom_file) {\n\t\treturn false;\n\t}\n\tthis->eeprom_file_size = fseek(this->eeprom_file, 0, SEEK_END);\n\tif (this->eeprom_file_size < this->eeprom_size) {\n\t\tfseek(this->eeprom_file, 0, SEEK_SET);\n\t\tfwrite(this->eeprom_erase_value, 1, this->eeprom_size - this->eeprom_file_size, this->eeprom_file);\n\t\tthis->eeprom_file_size = this->eeprom_size;\n\t} else {\n\t\tfseek(this->eeprom_file, 0, SEEK_SET);\n\t}\n\tfread(this->eeprom_buffer, 1, this->eeprom_size, this->eeprom_file);\n\tfclose(this->eeprom_file);\n\tthis->eeprom_file = NULL;\n\treturn true;\n}", "CodeBleu_score": 20.190451308499274}, {"code": "bool PersistentStore::access_start(){\n\t\tif (this->eeprom_fd != NULL) {\n\t\tfclose(this->eeprom_fd);\n\t}\n\tthis->eeprom_fd = fopen(this->eeprom_filename, \"r+b\");\n\tif (this->eeprom_fd == NULL) {\n\t\treturn false;\n\t}\n\tthis->eeprom_size = fseek(this->eeprom_fd, 0, SEEK_END);\n\tif (this->eeprom_size == -1) {\n\t\tfclose(this->eeprom_fd);\n\t\treturn false;\n\t}\n\tif (this->eeprom_size < this->eeprom_size_expected) {\n\t\tfseek(this->eeprom_fd, 0, SEEK_SET);\n\t\tif (fwrite(this->eeprom_default_erase_value, 1, this->eeprom_size_expected - this->eeprom_size, this->eeprom_fd) != this->eeprom_size_expected - this->eeprom_size) {\n\t\t\tfclose(this->eeprom_fd);\n\t\t\treturn false;\n\t\t}\n\t}\n\tfseek(this->eeprom_fd, 0, SEEK_SET);\n\tif (fread(this->eeprom_buffer, 1, this->eeprom_size, this->eeprom_fd) != this->eeprom_size) {\n\t\tfclose(this->eeprom_fd);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 20.031122923736387}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t ret = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPIx->GPIOx, SPIx->CLKx, GPIO_PIN_RESET);\n\t\t\tHAL_GPIO_WritePin(SPIx->GPIOx, SPIx->MOSIx, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPIx->GPIOx, SPIx->CLKx, GPIO_PIN_RESET);\n\t\t\tHAL_GPIO_WritePin(SPIx->GPIOx, SPIx->MOSIx, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPIx->GPIOx, SPIx->CLKx, GPIO_PIN_SET);\n\t\tret = ret << 1;\n\t\tif (HAL_GPIO_ReadPin(SPIx->GPIOx, SPIx->MISOx)) {\n\t\t\tret |= 0x01;\n\t\t}\n\t\tb = b << 1;\n\t}\n\tHAL_Delay(SPI_DELAY_NS);\n\treturn ret;\n}", "CodeBleu_score": 35.17537742577234}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t result = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) {\n\t\t\tresult |= (1 << i);\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(DELAY_NS);\n\treturn result;\n}", "CodeBleu_score": 37.642610359832986}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t data = 0;\n\tfor(i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI1_NSS_GPIO_Port, SPI1_NSS_Pin, GPIO_PIN_RESET);\n\t\tif(b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, GPIO_PIN_SET);\n\t\t}\n\t\telse {\n\t\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_Delay(SPI_DELAY_NS);\n\t\tHAL_GPIO_WritePin(SPI1_NSS_GPIO_Port, SPI1_NSS_Pin, GPIO_PIN_SET);\n\t\tHAL_Delay(SPI_DELAY_NS);\n\t\tif(HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin)) {\n\t\t\tdata |= 1 << i;\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(SPI_DELAY_NS);\n\treturn data;\n}", "CodeBleu_score": 36.81347721968466}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 83.96887672648454}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 83.96887672648454}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 83.96887672648454}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.update(obj)) return;\n#endif\n  MSerialT *self = static_cast<MSerialT*>(obj);\n  uint8_t c = self->read();\n  if (self->rx_buffer_head != self->rx_buffer_tail) {\n    self->rx_buffer[self->rx_buffer_head] = c;\n    self->rx_buffer_head = (self->rx_buffer_head + 1) % SERIAL_BUFFER_SIZE;\n  }\n}", "CodeBleu_score": 42.78199945212344}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tMSerialT *uart = static_cast<MSerialT*>(obj);\n\tuint8_t c = uart->read();\n\tif (uart->rx_buffer_head != uart->rx_buffer_tail) {\n\t\tuart->rx_buffer[uart->rx_buffer_head] = c;\n\t\tuart->rx_buffer_head = (uart->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t}\n\tif (uart->emergency_parser.enabled)\n\t\tuart->emergency_parser.update(c);\n}", "CodeBleu_score": 40.61807790724615}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Get the received byte\n\tuint8_t c = obj->getc();\n\n\t// Check for a parity error\n\tif (obj->has_error(SERIAL_ERROR_PARITY)) {\n\t\t// If the error is a parity error, clear the error and return\n\t\tobj->clear_error(SERIAL_ERROR_PARITY);\n\t\treturn;\n\t}\n\n\t// Check if there is space available in the receive buffer\n\tif (obj->rx_buffer_head != (obj->rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE) {\n\t\t// If there is space available, store the received byte in the receive buffer\n\t\tobj->rx_buffer[obj->rx_buffer_head] = c;\n\n\t\t// Update the buffer index\n\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t}\n\n\t// Update the emergency parser\n\temergency_parser.update(c);\n}", "CodeBleu_score": 43.7170538804558}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num] == NULL) {\n\t\treturn;\n\t}\n\tif (timer_instance[timer_num]->hasInterrupt) {\n\t\treturn;\n\t}\n\ttimer_instance[timer_num]->attachInterrupt(timer_instance[timer_num]->timer_num, (timer_instance[timer_num]->timer_num == MF_TIMER_STEP) ? Step_Handler : Temp_Handler);\n\ttimer_instance[timer_num]->hasInterrupt = true;\n}", "CodeBleu_score": 48.56030960172462}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_instance[timer_num] != NULL && !timer_instance[timer_num]->hasInterrupt) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 56.139541487613485}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (HAL_timer_initialized(timer_num) && !timer_instance[timer_num]->hasInterrupt) {\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Step_Handler);\n\t\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\t\ttimer_instance[timer_num]->attachInterrupt(Temp_Handler);\n\t\t}\n\t\ttimer_instance[timer_num]->hasInterrupt = true;\n\t}\n}", "CodeBleu_score": 60.25330819490877}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\t// Calculate the hash of the substring.\n\th := HashStrRev(sep)\n\t// Calculate the hash of the substring in the main string.\n\thsep := HashStrRev(s[:len(s)-len(sep)])\n\tif hsep == h && s[len(s)-len(sep):] == sep {\n\t\treturn len(s) - len(sep)\n\t}\n\t// Calculate the hash of the last substring in the main string.\n\thlast := HashStrRev(s[len(s)-len(sep)-1:])\n\t// Calculate the hash of the first substring in the main string.\n\thfirst := HashStrRev(s[:len(sep)])\n\t// Calculate the hash of the last character in the main string.\n\thlastchar := HashStrRev(s[len(s)-1:])\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\t// Calculate the hash of the current substring.\n\t\th = hlast\n\t\th = h*primeRK + hfirst\n\t\th = h - hsep*uint32(len(sep))\n\t\th = h*primeRK + hlastchar\n\t\th = h - hfirst*uint32(i)\n\t\t// Check if the hash matches.\n\t\tif h == 0 {\n\t\t\t// Check if the substring matches.\n\t\t\tif s[i:i+len(sep)] == sep {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 42.066694413453945}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(s) == 0 || len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\th := HashStrRev(sep)\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif HashStrRev(s[i:i+len(sep)]) == h && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 31.764664612824788}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\treturn LastIndexRabinKarpStr(s, string(sep))\n}", "CodeBleu_score": 5.31246520297936}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Len() > 0 {\n\t\tusbcdc.txBuffer.Get()\n\t\tusbcdc.waitTxc = false\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 40.36564386444139}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Len() > 0 {\n\t\tusbcdc.txBuffer.Get()\n\t\tusbcdc.waitTxc = false\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 40.36564386444139}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif len(usbcdc.txBuffer) > 0 {\n\t\tusbcdc.txBuffer.SendUSBInPacket()\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 36.339476383843675}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(0)\n\ti2c.crReg.SetBits(i2c.crReg.SWRST)\n\ti2c.crReg.ClearBits(i2c.crReg.SWRST)\n\ti2c.crReg.SetBits(i2c.crReg.EN)\n\ti2c.crReg.SetBits(i2c.crReg.START)\n\tfor i2c.crReg.HasBits(i2c.crReg.START) {\n\t}\n\ti2c.writeByte(address, write)\n}", "CodeBleu_score": 34.519342117869044}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.Set(0)\n\ti2c.crReg.Set(i2c.crReg.Get() | i2c.crReg.START)\n\ti2c.crReg.Set(i2c.crReg.Get() | i2c.crReg.EN)\n\tfor i2c.crReg.HasBits(i2c.crReg.START) {\n\t}\n\ti2c.writeByte(address<<1 | uint8(i2c.crReg.Get()&i2c.crReg.RD_WR)>>1)\n}", "CodeBleu_score": 35.22020192639814}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear interrupt flag\n\ti2c.crReg.ClearBits(i2c.crReg.I2CEN)\n\t// Send start condition\n\ti2c.sda.Set()\n\ti2c.scl.Clear()\n\t// Enable module\n\ti2c.crReg.SetBits(i2c.crReg.I2CEN)\n\t// Wait for start condition to be transmitted\n\tfor i2c.crReg.HasBits(i2c.crReg.START) == false {\n\t}\n\t// Write address\n\ti2c.writeByte(address, write)\n}", "CodeBleu_score": 36.98038138349333}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"invalid parameters\")\n\t}\n\tif start+len > f.EraseBlockSize*f.EraseBlockCount {\n\t\treturn errors.New(\"invalid parameters\")\n\t}\n\tf.EraseBlock(uint32(start / f.EraseBlockSize))\n\twaitWhileFlashBusy()\n\treturn nil\n}", "CodeBleu_score": 24.806424125839733}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 1 || start+len > int64(f.EraseBlockSize)*int64(f.NumEraseBlocks) {\n\t\treturn fmt.Errorf(\"invalid block erase range %d-%d\", start, start+len)\n\t}\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\taddr := uint32(f.EraseBlockSize) * uint32(start)\n\tf.ErasePage(addr)\n\tfor i := start; i < start+len; i++ {\n\t\tf.ErasePage(addr)\n\t\twaitWhileFlashBusy()\n\t\taddr += uint32(f.EraseBlockSize)\n\t}\n\tf.SetReadMode()\n\treturn nil\n}", "CodeBleu_score": 54.36428743616125}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := uint32(start * f.EraseBlockSize)\n\tendAddr := uint32((start + len) * f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: start: %d, len: %d, startAddr: %d, endAddr: %d\", start, len, startAddr, endAddr)\n\t//log.Printf(\"EraseBlocks: startAddr: %d, endAddr: %d\", startAddr, endAddr)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d\", f.EraseBlockSize)\n\t//log.Printf(\"EraseBlocks: %d", "CodeBleu_score": 16.94740873865126}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds\n\tif off < 0 {\nreturn 0, errors.New(\"invalid offset\")\n}\nif uint64(off) >= f.Size() {\nreturn 0, io.EOF\n}\n\n// Calculate the start address for writing and pad the byte slice to fit the write block size\nstartAddr := uint32(off)\nif uint64(off) % uint64(f.WriteBlockSize()) != 0 {\npadLen := uint32(f.WriteBlockSize()) - uint32(off)%uint32(f.WriteBlockSize())\np = append(p, make([]byte, padLen)...)\n}\n\n// Enable write mode on the flash memory controller\nwaitWhileFlashBusy()\nnrf.NVMC.CONFIG.SetWEN(true)\n\n// Write the data in blocks\nfor len(p) > 0 {\n// Write the data in a single block\nf.WriteBlockSize\nuintptr\nunsafe.Pointer\nf.pad\nnrf.NVMC.ERASEPAGE\nuint32\nstartAddr\nbinary.LittleEndian.PutUint32\n(*uint32)(unsafe.Pointer(&p[0]))\n\n// Update the byte slice\np = p[f.WriteBlockSize():]\nstartAddr += uint32(f.WriteBlockSize())\n}\n\n// Wait for the flash memory to be ready after each write operation\nwaitWhileFlashBusy()\n\n// Return the number of bytes written or an error if the operation fails\nreturn len(p), nil\n}", "CodeBleu_score": 39.73724210291484}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 {\nreturn 0, errors.New(\"invalid offset\")\n}\nif off+int64(len(p)) > int64(f.Size()) {\nreturn 0, errors.New(\"write exceeds flash size\")\n}\nif len(p) == 0 {\nreturn 0, nil\n}\n\n// Pad the data to the write block size.\np = f.pad(p)\n\n// Calculate the start address for writing.\naddr := FlashDataStart + uintptr(off)\n\n// Enable write mode.\nf.NVMC.SetCTRL_WEN()\n\n// Write the data in blocks.\nfor len(p) > 0 {\n// Calculate the block size.\nblockSize := f.WriteBlockSize\nif len(p) < int(blockSize) {\nblockSize = uintptr(len(p))\n}\n\n// Write the data.\nf.WriteBlock(addr, p[:blockSize])\n\n// Update the address and data.\naddr += blockSize\np = p[blockSize:]\n}\n\n// Wait for the flash memory to be ready after writing.\nf.NVMC.WaitReady()\n\n// Return the number of bytes written.\nreturn len(p), nil\n}", "CodeBleu_score": 34.456434245128676}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\treturn 0, errors.New(\"invalid offset\")\n}", "CodeBleu_score": 5.641828941012948}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Dup the file descriptor to avoid closing it when we close the directory.\n\tdupFd, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"could not duplicate file descriptor: %w\", err)\n\t}\n\tdefer syscall.Close(dupFd)\n\n\t// Check for errors.\n\terr = checkFdErr(dupFd)\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"could not check file descriptor: %w\", err)\n\t}\n\n\t// Repeatedly attempt to open the directory.\n\tfor {\n\t\tdirPtr, err := syscall.Fdopendir(dupFd)\n\t\tif err != nil {\n\t\t\tif err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn 0, \"\", fmt.Errorf(\"could not open directory: %w\", err)\n\t\t}\n\t\treturn dirPtr, \"\", nil\n\t}\n}", "CodeBleu_score": 55.223266987475064}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor so we can close it after opening the directory.\n\tdupFd, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to duplicate file descriptor: %v\", err)\n\t}\n\tdefer syscall.Close(dupFd)\n\n\t// Open the directory.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %v\", err)\n\t}\n\n\t// Loop until the directory is successfully opened.\n\tfor {\n\t\t// Check for errors other than \"syscall.EINTR\".\n\t\tif err, ok := err.(syscall.Errno); ok && err != syscall.EINTR {\n\t\t\tsyscall.Closedir(dir)\n\t\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %v\", err)\n\t\t}\n\t\t// Open the directory.\n\t\tdir, err = syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Return the directory pointer and no error.\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 58.0922272282687}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tfdDup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(fdDup)\n\n\t// Check for errors.\n\tif err = checkError(fdDup, \"syscall.Dup\"); err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Repeatedly attempt to open the directory until it either succeeds or encounters an error other than \"syscall.EINTR\".\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fdDup)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %v\", err)\n\t\t}\n\t}\n\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 68.40124755127401}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running = esp_ota_get_running_partition();\n\tif (running == NULL) {\n\t\treturn 0;\n\t}\n\tif (esp_partition_verify(running) != ESP_OK) {\n\t\treturn 0;\n\t}\n\tif (response) {\n\t\treturn esp_partition_get_size(running) - esp_partition_get_offset(running);\n\t}\n\treturn esp_partition_get_size(running);\n}", "CodeBleu_score": 35.40710531110901}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running;\n\tesp_image_metadata_t metadata;\n\tesp_err_t err = esp_ota_get_running_partition(&running);\n\tif (err != ESP_OK) {\n\t\treturn 0;\n\t}\n\terr = esp_image_get_metadata(running, &metadata);\n\tif (err != ESP_OK) {\n\t\treturn 0;\n\t}\n\tif (response) {\n\t\treturn running->size - metadata.image_len;\n\t} else {\n\t\treturn metadata.image_len;\n\t}\n}", "CodeBleu_score": 53.027559124731695}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t *running = esp_ota_get_running_partition();\n\tif (running == NULL) {\n\t\treturn 0;\n\t}\n\tesp_image_metadata_t data;\n\tesp_err_t err = esp_ota_get_partition_data(running, &data);\n\tif (err != ESP_OK) {\n\t\treturn 0;\n\t}\n\tif (response) {\n\t\treturn data.partition_length - data.image_length;\n\t} else {\n\t\treturn data.image_length;\n\t}\n}", "CodeBleu_score": 51.480450246425214}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tbool result = false;\n\tuint32_t required_disk_sectors = msc_update_get_required_disk_sectors();\n\tuint8_t *disk_data = (uint8_t *)calloc(required_disk_sectors, 512);\n\tif (disk_data != NULL) {\n\t\tresult = msc_update_setup_disk_with_data(volume_label, serial_number, disk_data, required_disk_sectors);\n\t}\n\treturn result;\n}", "CodeBleu_score": 17.18588967997708}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t required_disk_sectors;\n\tuint8_t *disk_buffer;\n\n\trequired_disk_sectors = msc_update_get_required_disk_sectors();\n\tdisk_buffer = calloc(required_disk_sectors, sizeof(uint8_t));\n\tif (disk_buffer == NULL) {\n\t\tlog_e(\"MSC update: Failed to allocate memory for RAM disk\");\n\t\treturn false;\n\t}\n\n\tmsc_update_disk_buffer = disk_buffer;\n\tmsc_update_disk_buffer_size = required_disk_sectors;\n\n\tif (!fat_add_boot_sector(disk_buffer, volume_label, serial_number)) {\n\t\tlog_e(\"MSC update: Failed to add boot sector to RAM disk\");\n\t\treturn false;\n\t}\n\n\tif (!fat_add_table(disk_buffer)) {\n\t\tlog_e(\"MSC update: Failed to add FAT to RAM disk\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 31.68396405001994}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tuint32_t required_disk_sectors;\n\tuint32_t i;\n\n\trequired_disk_sectors = msc_update_get_required_disk_sectors();\n\tif (required_disk_sectors == 0) {\n\t\tlog_e(\"error: required disk size is zero\");\n\t\treturn false;\n\t}\n\n\tdisk_ram = (uint8_t *)calloc(required_disk_sectors, sizeof(uint8_t));\n\tif (disk_ram == NULL) {\n\t\tlog_e(\"error: out of memory\");\n\t\treturn false;\n\t}\n\n\tfat_init(disk_ram, required_disk_sectors);\n\n\t/*\n\t * The following code initializes the boot sector and file allocation table (FAT) for a FAT12 file system.\n\t * It assumes that the disk is formatted with a 32-bit FAT.\n\t */\n\n\tfat_add_boot_sector(volume_label, serial_number);\n\n\t/*\n\t * The following code initializes the file allocation table (FAT) for a FAT12 file system.\n\t * It assumes that the disk is formatted with a 32-bit FAT.\n\t */\n\n\tfat_add_table(0, 1, 0x00000000);\n\tfat_add_table(1, 13, 0x00000000);\n\tfor (i = 2; i < 1024; i++) {\n\t\tfat_add_table(i, 0, 0x00000000);\n\t}\n\n\t/*\n\t * The following code adds a root directory entry for a firmware file.\n\t */\n\n\treturn fat_add_root_file(\"firmware.bin\", 0x00000000, 0x00000000);\n}", "CodeBleu_score": 32.13577189450253}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % partition->sector_size != 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%08x is not aligned with sector size 0x%08x\", offset, partition->sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size % partition->sector_size != 0) {\n\t\tESP_LOGE(TAG, \"Size 0x%08x is not aligned with sector size 0x%08x\", size, partition->sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tesp_err_t err = ESP_OK;\n\tif (offset % partition->sector_size != 0) {\n\t\terr = esp_partition_erase_range(partition, offset, partition->sector_size);\n\t\tif (err != ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Erase failed at offset 0x%08x with error code 0x%08x\", offset, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Write failed at offset 0x%08x with error code 0x%08x\", offset, err);\n\t\treturn err;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 53.1720293115474}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % partition->sector_size != 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x is not aligned with the sector size 0x%x\", offset, partition->sector_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size % partition->sector_size != 0) {\n\t\tESP_LOGE(TAG, \"Size 0x%x is not aligned with the sector size 0x%x\", size, partition->sector_size);\n\t\treturn ESP_ERR_INVALID_SIZE;\n\t}\n\tif (size + offset > partition->size) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x and size 0x%x exceed the partition size 0x%x\", offset, size, partition->size);\n\t\treturn ESP_ERR_INVALID_SIZE;\n\t}\n\tif (esp_partition_erase_range(partition, offset, size) != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase sector at offset 0x%x\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 47.475197404578886}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % SPI_FLASH_SEC_SIZE != 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x is not sector aligned\", offset);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size % SPI_FLASH_SEC_SIZE != 0) {\n\t\tESP_LOGE(TAG, \"Size 0x%x is not sector aligned\", size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tconst esp_partition_t *update_partition = partition;\n\tif (partition->subtype == ESP_PARTITION_SUBTYPE_APP_OTA) {\n\t\tupdate_partition = esp_ota_get_boot_partition();\n\t}\n\n\tesp_err_t err = ESP_OK;\n\tif (update_partition->subtype == ESP_PARTITION_SUBTYPE_DATA_NVS) {\n\t\terr = nvs_flash_erase_block(offset, size / SPI_FLASH_SEC_SIZE);\n\t\tif (err != ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Failed to erase NVS partition at offset 0x%x\", offset);\n\t\t\treturn err;\n\t\t}\n\t} else if (update_partition->subtype == ESP_PARTITION_SUBTYPE_DATA_FAT) {\n\t\terr = esp_partition_erase_range(update_partition, offset, size);\n\t\tif (err != ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Failed to erase FAT partition at offset 0x%x\", offset);\n\t\t\treturn err;\n\t\t}\n\t} else if (update_partition->subtype == ESP_PARTITION_SUBTYPE_APP_FACTORY) {\n\t\terr = esp_partition_erase_range(update_partition, offset, size);\n\t\tif (err != ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Failed to erase FACTORY partition at offset 0x%x\", offset);\n\t\t\treturn err;\n\t\t}\n\t} else if (update_partition->subtype == ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD) {\n\t\terr = esp_partition_erase_range(update_partition, offset, size);\n\t\tif (err != ESP_OK) {\n\t\t\tESP_LOGE(TAG", "CodeBleu_score": 50.07237919121017}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\tsize_t j = 0;\n\tunsigned char c;\n\twhile (i < maxlen && in[i] != '\\0') {\n\t\tif (in[i] == ' ' || in[i] == '\\t' || in[i] == '\n' || in[i] == '\\r') {\n\t\t\ti++;\n\t\t} else if (isxdigit(in[i])) {\n\t\t\tc = hex_char_to_byte(in[i]);\n\t\t\tif (isxdigit(in[i + 1])) {\n\t\t\t\tc = (c << 4) | hex_char_to_byte(in[i + 1]);\n\t\t\t\ti += 2;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tout[j] = c;\n\t\t\tj++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn j;\n}", "CodeBleu_score": 41.54803176324141}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t out_len = 0;\n\twhile (*in && (out_len < maxlen)) {\n\t\tif (*in >= '0' && *in <= '9') {\n\t\t\tout[out_len] = hex_char_to_byte(*in) << 4;\n\t\t} else if (*in >= 'a' && *in <= 'f') {\n\t\t\tout[out_len] = hex_char_to_byte(*in) << 4;\n\t\t} else if (*in >= 'A' && *in <= 'F') {\n\t\t\tout[out_len] = hex_char_to_byte(*in) << 4;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tin++;\n\t\tif (*in >= '0' && *in <= '9') {\n\t\t\tout[out_len] |= hex_char_to_byte(*in);\n\t\t} else if (*in >= 'a' && *in <= 'f') {\n\t\t\tout[out_len] |= hex_char_to_byte(*in);\n\t\t} else if (*in >= 'A' && *in <= 'F') {\n\t\t\tout[out_len] |= hex_char_to_byte(*in);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tin++;\n\t\tout_len++;\n\t}\n\treturn out_len;\n}", "CodeBleu_score": 38.10155419350379}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0;\n\tsize_t j = 0;\n\twhile (i < maxlen && *in != 0) {\n\t\tif (is_hex_char(*in)) {\n\t\t\tout[i] = hex_char_to_byte(*in);\n\t\t\ti++;\n\t\t}\n\t\tin++;\n\t}\n\treturn i;\n}", "CodeBleu_score": 27.08183186541634}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (!xRingbufferIsQueueEmpty(xRingBuffer)) {\n\t\tif (xSemaphoreTake(xTXLock, portMAX_DELAY) == pdTRUE) {\n\t\t\treturn xRingbufferGetCurFreeSize(xRingBuffer);\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 24.24334821798786}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (xRingbuffer == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(xRingbufferLock, portMAX_DELAY) == pdTRUE) {\n\t\tint size = xRingbufferGetCurFreeSize(xRingbuffer);\n\t\txSemaphoreGive(xRingbufferLock);\n\t\treturn size;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 56.34108834938672}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (!tx_buffer) return 0;\n\tif (!tx_buffer_lock) return 0;\n\tif (xSemaphoreTake(tx_buffer_lock, 1000 / portTICK_RATE_MS) == pdTRUE) {\n\t\tint size = xRingbufferGetCurFreeSize(tx_buffer);\n\t\txSemaphoreGive(tx_buffer_lock);\n\t\treturn size;\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 55.089158027143625}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\t_rxTimeout = onlyOnTimeout;\n\tif (function) {\n\t\tif (_rxEventTask == NULL) {\n\t\t\t_rxEventTask = _createEventTask();\n\t\t}\n\t\t_setRxFIFOFullThreshold();\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 33.86712606384655}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\tif (function) {\n\t\tif (!eventTask) {\n\t\t\teventTask = _createEventTask();\n\t\t}\n\t\t_setRxFIFOFull();\n\t\tif (onlyOnTimeout) {\n\t\t\t_setRxTimeout(true);\n\t\t} else {\n\t\t\t_setRxTimeout(false);\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 36.04554367286037}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\tif (function != NULL) {\n\t\t_rxTimeout = onlyOnTimeout ? _rxTimeout : 0;\n\t\tif (rx_fifo_size > 0 && _rxEventTask == NULL) {\n\t\t\t_createEventTask();\n\t\t\t_setRxFIFOFullThreshold();\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 36.4243380468747}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t count = 0;\n\twhile (count < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[count++] = (char)c;\n\t}\n\treturn count;\n}", "CodeBleu_score": 57.336798664751676}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index] = (char)c;\n\t\tindex++;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 76.0320514442134}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\tsize_t index = 0;\n\tchar c;\n\twhile (index < length && timedRead(&c, 1)) {\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index++] = c;\n\t}\n\treturn index;\n}", "CodeBleu_score": 61.850094959181135}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\t// Log the pin, frequency, and duration\n\tlog_d(\"tone\", \"pin=%d, frequency=%d, duration=%d\", pin, frequency, duration);\n\t// Check if the pin is available\n\tif (pinAvailable(pin)) {\n\t\t// Initialize the tone\n\t\ttone_init(pin, frequency, duration);\n\t\t// Send a start command with the pin, frequency, and duration to a queue\n\t\txQueueSend(queue, &pin, portMAX_DELAY);\n\t} else {\n\t\t// Log an error message instructing to stop the current tone on the pin first\n\t\tlog_e(\"tone\", \"pin %d is already in use\", pin);\n\t}\n}", "CodeBleu_score": 32.83990194043268}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (pin < NUM_DIGITAL_PINS) {\n\t\tif (digitalPinToTimer(pin) == NOT_ON_TIMER) {\n\t\t\tlog_d(\"Tone pin %d at %d Hz for %d ms\", pin, frequency, duration);\n\t\t\tif (xQueueReceive(digitalPinToQueue[pin], &msg, 0) == pdFALSE) {\n\t\t\t\tmsg.type = TONE;\n\t\t\t\tmsg.pin = pin;\n\t\t\t\tmsg.frequency = frequency;\n\t\t\t\tmsg.duration = duration;\n\t\t\t\txQueueSend(digitalPinToQueue[pin], &msg, 0);\n\t\t\t} else {\n\t\t\t\tlog_e(\"Tone pin %d is in use\", pin);\n\t\t\t}\n\t\t} else {\n\t\t\tlog_e(\"Tone pin %d is in use\", pin);\n\t\t}\n\t} else {\n\t\tlog_e(\"Tone pin %d is not valid\", pin);\n\t}\n}", "CodeBleu_score": 43.238381403554406}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif(pin == 0) {\n\t\tlog_e(\"ERROR: Pin 0 is not available for use.\");\n\t}\n\telse if(pin == 1) {\n\t\tlog_e(\"ERROR: Pin 1 is not available for use.\");\n\t}\n\telse if(pin == 2) {\n\t\tlog_e(\"ERROR: Pin 2 is not available for use.\");\n\t}\n\telse if(pin == 3) {\n\t\tlog_e(\"ERROR: Pin 3 is not available for use.\");\n\t}\n\telse if(pin == 4) {\n\t\tlog_e(\"ERROR: Pin 4 is not available for use.\");\n\t}\n\telse if(pin == 5) {\n\t\tlog_e(\"ERROR: Pin 5 is not available for use.\");\n\t}\n\telse if(pin == 6) {\n\t\tlog_e(\"ERROR: Pin 6 is not available for use.\");\n\t}\n\telse if(pin == 7) {\n\t\tlog_e(\"ERROR: Pin 7 is not available for use.\");\n\t}\n\telse if(pin == 8) {\n\t\tlog_e(\"ERROR: Pin 8 is not available for use.\");\n\t}\n\telse if(pin == 9) {\n\t\tlog_e(\"ERROR: Pin 9 is not available for use.\");\n\t}\n\telse if(pin == 10) {\n\t\tlog_e(\"ERROR: Pin 10 is not available for use.\");\n\t}\n\telse if(pin == 11) {\n\t\tlog_e(\"ERROR: Pin 11 is not available for use.\");\n\t}\n\telse if(pin == 12) {\n\t\tlog_e(\"ERROR: Pin 12 is not available for use.\");\n\t}\n\telse if(pin == 13) {\n\t\tlog_e(\"ERROR: Pin 13 is not available for use.\");\n\t}\n\telse if(pin == 14) {\n\t\tlog_e(\"ERROR: Pin 14 is not available for use.\");\n\t}\n\telse if(pin == 15) {\n\t\tlog_e(\"ERROR: Pin 15 is not available for use.\");\n\t}\n\telse if(pin", "CodeBleu_score": 18.952855694168857}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!USB.hasStarted()) {\n\t\t_webUSBEnabled = enabled;\n\t\tif (enabled) {\n\t\t\tif (USB.getUSBVersion() < 0x0210) {\n\t\t\t\tUSB.setUSBVersion(0x0210);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 37.864386103575164}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usb_started) {\n\t\tweb_usb_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tif (usb_version < 0x0210) {\n\t\t\t\tusb_version = 0x0210;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 59.62372404656494}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usbStarted) {\n\t\twebUSBEnabled = enabled;\n\t\tif (webUSBEnabled) {\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\tusbVersion = 0x0210;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 56.365884762298016}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t byte;\n\tuint8_t buf[256];\n\tuint8_t buf_len = 0;\n\tuint8_t buf_pos = 0;\n\tuint8_t queue_overflow = 0;\n\n\twhile (tud_cdc_n_available()) {\n\t\tif (buf_len >= sizeof(buf)) {\n\t\t\tqueue_overflow = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tbyte = tud_cdc_n_read();\n\t\tbuf[buf_len++] = byte;\n\t}\n\n\tif (queue_overflow) {\n\t\tuint8_t dropped = buf_len - sizeof(buf);\n\n\t\t_log_e(\"Receive queue overflow. Dropping %u bytes\", dropped);\n\t\t_event_post(CDC_EVENT_RX_OVERFLOW, dropped);\n\t} else if (buf_len > 0) {\n\t\t_event_post(CDC_EVENT_RX, buf_len);\n\t}\n}", "CodeBleu_score": 25.77572489241573}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t buf[64];\n\tuint8_t n = tud_cdc_n_read(CDC_RX_EP, buf, sizeof(buf));\n\tif (n) {\n\t\tif (xQueueSend(rxQueue, &n, 0) != pdTRUE) {\n\t\t\tlog_e(\"RX queue overflow: %d bytes dropped\", n);\n\t\t\tevent_post(usb_cdc_event_rx_overflow, &n);\n\t\t} else {\n\t\t\tevent_post(usb_cdc_event_rx, &n);\n\t\t}\n\t}\n}", "CodeBleu_score": 14.666928430407172}, {"code": "void USBCDC::_onRX(){\n\t\t// Read data from the CDC buffer into the receive buffer\n\tint bytesRead = tud_cdc_n_read(CDC_RX_EP, _receiveBuffer, sizeof(_receiveBuffer));\n\tif (bytesRead > 0) {\n\t\t// Send the data to the receive queue\n\t\tif (xQueueSend(_receiveQueue, &_receiveBuffer, portMAX_DELAY) == pdTRUE) {\n\t\t\t// Post a receive event with the number of bytes received\n\t\t\tarduino_usb_event_post(ARDUINO_USB_EVENT_RX, bytesRead);\n\t\t} else {\n\t\t\t// The queue is full, log an error\n\t\t\tlog_e(\"Receive queue overflow: %d bytes dropped\", bytesRead);\n\t\t}\n\t}\n}", "CodeBleu_score": 14.323277679261832}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\ta.writeJSON(res, http.StatusBadRequest, map[string]string{\"error\": \"no robot name specified\"})\n\t\treturn\n\t}\n\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name \" + name})\n\t\treturn\n\t}\n\n\tdevices := make(map[string]interface{})\n\trobot.Devices().Each(func(name string, device gobot.Device) {\n\t\tdevices[name] = device.Name()\n\t})\n\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 46.43181051015822}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\ta.writeJSON(res, http.StatusBadRequest, map[string]string{\"error\": \"missing robot name\"})\n\t\treturn\n\t}\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\tvar devices []*Device\n\trobot.Devices().Each(func(key string, device gobot.Device) {\n\t\tdevices = append(devices, &Device{Name: key, Device: device})\n\t})\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 49.76455786986216}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL query parameters\n\tname := req.URL.Query().Get(\"name\")\n\n\t// Get the robot with the specified name\n\trobot := a.master.Robot(name)\n\n\t// If the robot does not exist, return an error message\n\tif robot == nil {\n\t\tres.WriteJSON(map[string]string{\"error\": fmt.Sprintf(\"no robot found with the name %s\", name)})\n\t\treturn\n\t}\n\n\t// Get the devices associated with the robot\n\tdevices := robot.Devices()\n\n\t// Create a JSON response\n\tresponse := make(map[string][]map[string]string)\n\n\t// Iterate through the devices and add them to the response\n\tdevices.Each(func(device gobot.Device) {\n\t\tresponse[device.Name()] = device.Connection().Adaptor().GetConnections()\n\t})\n\n\t// Write the response\n\tres.WriteJSON(response)\n}", "CodeBleu_score": 53.084260509384684}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\tres.Write([]byte(\"no robot named \" + name))\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\ta.writeJSON(res, robot.Connections())\n}", "CodeBleu_score": 26.55046748579295}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\tif robot, ok := a.master.Robot(robotName); ok {\n\t\tconnections := []Connection{}\n\t\trobot.Connections().Each(func(conn interface{}) {\n\t\t\tconnections = append(connections, Connection{\n\t\t\t\tName: conn.(gobot.Connection).Name(),\n\t\t\t\tAdaptor: conn.(gobot.Connection).Adaptor().Name(),\n\t\t\t\tPort: conn.(gobot.Connection).Port(),\n\t\t\t})\n\t\t})\n\t\ta.writeJSON(res, connections)\n\t} else {\n\t\ta.writeError(res, http.StatusNotFound, fmt.Sprintf(\"no robot with name '%s' found\", robotName))\n\t}\n}", "CodeBleu_score": 51.23050947115433}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := a.getRobotName(req)\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeError(res, http.StatusNotFound, fmt.Sprintf(\"No robot with name '%s' found\", robotName))\n\t\treturn\n\t}\n\n\ta.writeJSON(res, http.StatusOK, robot.Connections())\n}", "CodeBleu_score": 26.15187588687229}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\n\t// Check if the device exists.\n\tdevice, err := a.jsonDeviceFor(robotName, deviceName)\n\tif err != nil {\n\t\t// If an error occurs, write the error message as a JSON response.\n\t\ta.writeJSON(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\terr = a.executeCommand(device, req.URL.Query().Get(\":command\"))\n\tif err != nil {\n\t\t// If an error occurs, write the error message as a JSON response.\n\t\ta.writeJSON(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Write the success message as a JSON response.\n\ta.writeJSON(res, \"OK\", http.StatusOK)\n}", "CodeBleu_score": 55.96893782097221}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Retrieve the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\":robot\")\n\tdeviceName := req.URL.Query().Get(\":device\")\n\n\t// Retrieve the device for the robot.\n\tdevice := a.jsonDeviceFor(robotName, deviceName)\n\tif device == nil {\n\t\t// If the device was not found, return an error response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"error\": \"Device not found\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\terr := a.executeCommand(device, req.URL.Query().Get(\":command\"))\n\tif err != nil {\n\t\t// If an error occurred while executing the command, return an error response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\ta.writeJSON(res, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t\treturn\n\t}\n\n\t// If the command was executed successfully, return an empty response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\ta.writeJSON(res, map[string]interface{}{})\n}", "CodeBleu_score": 53.066829852772536}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL query parameters.\n\trobotName := req.URL.Query().Get(\":robot\")\n\n\t// Get the device name from the URL query parameters.\n\tdeviceName := req.URL.Query().Get(\":device\")\n\n\t// Get the command name from the URL query parameters.\n\tcommandName := req.URL.Query().Get(\":command\")\n\n\t// Get the command parameters from the URL query parameters.\n\tcommandParams := req.URL.Query().Get(\":params\")\n\n\t// Check if the robot exists.\n\trobot, ok := a.master.Robot(robotName)\n\tif !ok {\n\t\t// If the robot does not exist, write the error message as a JSON response.\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"robot '%s' not found\", robotName),\n\t\t})\n\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tdevice, ok := robot.Device(deviceName)\n\tif !ok {\n\t\t// If the device does not exist, write the error message as a JSON response.\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"device '%s' not found\", deviceName),\n\t\t})\n\n\t\treturn\n\t}\n\n\t// Check if the command exists.\n\tcommand, ok := device.(gobot.Commander).Command(commandName)\n\tif !ok {\n\t\t// If the command does not exist, write the error message as a JSON response.\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"command '%s' not found\", commandName),\n\t\t})\n\n\t\treturn\n\t}\n\n\t// Execute the command.\n\terr := command(commandParams)\n\tif err != nil {\n\t\t// If an error occurs, write the error message as a JSON response.\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"error executing command '%s': %s\", commandName, err.Error()),\n\t\t})\n\n\t\treturn\n\t}\n\n\t// Write the success message as a JSON response.\n\t", "CodeBleu_score": 49.91959043785422}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\t// If the \"Authorization\" header is empty, set the \"WWW-Authenticate\" header to \"Basic\" and respond with a \"401 Unauthorized\" status and an error message.\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the \"Authorization\" header value into \"Basic\" and the encoded credentials.\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\t// If the \"Authorization\" header does not start with \"Basic\", set the \"WWW-Authenticate\" header to \"Basic\" and respond with a \"401 Unauthorized\" status and an error message.\n\t\tif !(len(parts) == 2 && parts[0] == \"Basic\") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Decode the encoded credentials.\n\t\tb, err := base64.StdEncoding.DecodeString(parts[1])\n\t\t// If the encoded credentials are invalid, set the \"WWW-Authenticate\" header to \"Basic\" and respond with a \"401 Unauthorized\" status and an error message.\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the decoded credentials into the username and password.\n\t\tparts = strings.SplitN(string(b), \":\", 2)\n\t\t// If the decoded credentials do not contain exactly one colon, set the \"WWW-Authenticate\" header to \"Basic\" and respond with a \"401 Unauthorized\" status and an error message.\n\t\tif !(len(parts) == 2) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If the username does not match", "CodeBleu_score": 47.11703810164856}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request.\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\t// If the header is missing, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the header value into two parts: the \"Basic\" prefix and the encoded credential.\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\tif !(len(parts) == 2 && parts[0] == \"Basic\") {\n\t\t\t// If the header value is not formatted correctly, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the encoded credential and compare it with the expected value.\n\t\tpayload, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err != nil {\n\t\t\t// If the credential cannot be decoded, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif !secureCompare(payload, username+\":\"+password) {\n\t\t\t// If the credential is not valid, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status.\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the credential is valid, the request proceeds to the next handler.\n\t}\n}", "CodeBleu_score": 49.53456164288322}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Compare the \"Authorization\" header from the request with the expected value based on the provided credentials.\n\t\t// If the comparison fails, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status and an error message.\n\t\t// If the comparison succeeds, the request proceeds to the next handler.\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.09513762764863}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.sensorCfg.analog {\n\t\treturn 0, 0, errors.New(\"Analog reading not supported on this connection\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := raw * a.sensorCfg.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.420173004448586}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif !a.sensorCfg.analog {\n\t\treturn 0, 0, fmt.Errorf(\"this sensor does not support analog reads\")\n\t}\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn raw, 0, err\n\t}\n\tscaled := a.sensorCfg.scale(raw)\n\ta.sensorCfg.lastRaw = raw\n\ta.sensorCfg.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 44.775963471325184}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.sensorCfg.connection == nil {\n\t\treturn 0, 0, errors.New(\"Analog sensor not connected\")\n\t}\n\n\tif a.sensorCfg.connection.AnalogRead == nil {\n\t\treturn 0, 0, errors.New(\"Analog reading not supported by connection\")\n\t}\n\n\trawValue, err := a.sensorCfg.connection.AnalogRead(a.sensorCfg.pin)\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"Failed to read analog sensor: %s\", err)\n\t}\n\n\tscaledValue := rawValue * a.sensorCfg.scale\n\n\ta.lastRaw = rawValue\n\ta.lastScaled = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 47.36384598780704}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tgsd := &GroveSoundSensorDriver{\n\t\ta:    a,\n\t\tpin:  pin,\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t}\n\tfor _, opt := range opts {\n\t\topt(gsd)\n\t}\n\tgsd.Adaptor = gsd.a.GetAdaptor()\n\tgsd.connection = &i2c.Connection{\n\t\tName:         gsd.name,\n\t\tDriver:       &LPS25HDriver{bus: gsd.Adaptor, connection: gsd.pin},\n\t\tConnector:    &LPS25HConnector{},\n\t\tDevice:       gsd,\n\t\tAutoReconnect: true,\n\t}\n\tgsd.AddConnection(gsd.connection)\n\treturn gsd\n}", "CodeBleu_score": 34.75931329889698}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tgsd := &GroveSoundSensorDriver{\n\t\tname:         gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tanalogReader: a,\n\t\tpin:          pin,\n\t}\n\tfor _, opt := range opts {\n\t\topt(gsd)\n\t}\n\tgsd.analogSensor = NewAnalogSensorDriver(a, pin)\n\tgsd.AddDriver(gsd.analogSensor)\n\treturn gsd\n}", "CodeBleu_score": 39.991517802255004}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\treturn NewGroveSoundSensorDriverWithDefaults(a, pin, D2, opts...)\n}", "CodeBleu_score": 16.895891124192126}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\tvar err error\n\tif d.Debug {\n\t\tfmt.Printf(\"Soft resetting MFRC522\n\")\n\t}\n\td.writeCommand(PCD_RESETPHASE)\n\ttime.Sleep(100 * time.Millisecond)\n\tstatus, err := d.readStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif (status & 0x08) == 0x00 {\n\t\treturn fmt.Errorf(\"MFRC522 not in idle state\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.93686646675954}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeCommand(PCD_RESETPHASE)\n\ttime.Sleep(100 * time.Millisecond)\n\treturn d.readError()\n}", "CodeBleu_score": 16.932433385282074}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tvar err error\n\td.writeCommand(PCD_RESETPHASE)\n\ttime.Sleep(100 * time.Millisecond)\n\tif d.readStatus()&0x08 != 0 {\n\t\terr = fmt.Errorf(\"PCD_RESETPHASE timeout\")\n\t}\n\treturn err\n}", "CodeBleu_score": 29.068804272528187}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tlength, err := d.readByteData(CommandFIFOData, nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif int(length) != len(backData) {\n\t\treturn 0, fmt.Errorf(\"length of backData does not match length of FIFO (%d != %d)\", len(backData), length)\n\t}\n\tfor i := range backData {\n\t\tbackData[i], err = d.readByteData(CommandFIFOData, nil)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn d.readByteData(CommandControl, nil)\n}", "CodeBleu_score": 39.09306531310087}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) != d.getFIFOLevel() {\n\t\treturn 0, errors.New(\"The length of the byte slice and the number of bytes in the FIFO do not match\")\n\t}\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i] = d.readByteData(FIFODataReg)\n\t}\n\treturn d.readByteData(ControlReg), nil\n}", "CodeBleu_score": 25.70638509144682}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) != d.getFIFOLevel() {\n\t\treturn 0, errors.New(\"Byte slice size does not match number of bytes in FIFO buffer\")\n\t}\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i] = d.readByteData(FIFODataReg)\n\t}\n\treturn d.readByteData(ControlReg), nil\n}", "CodeBleu_score": 25.31769744651286}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Printf(\"halting PICC\")\n\t}\n\n\t// Build command for PICC Halt.\n\tcmd := []byte{PICC_HALT}\n\n\t// Calculate CRC for the command.\n\tcrc := d.calculateCRC(cmd[:])\n\n\t// Append CRC to command.\n\tcmd = append(cmd, crc)\n\n\t// Send the command.\n\t_, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 29.1004687751465}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"PICC halting\")\n\t}\n\ttxCommand := []byte{PICC_HALT}\n\ttxCRC := d.calculateCRC(txCommand[:])\n\ttxCommand = append(txCommand, txCRC[0])\n\ttxCommand = append(txCommand, txCRC[1])\n\tif d.debug {\n\t\tfmt.Printf(\"PCD halting command: % x\n\", txCommand)\n\t}\n\trx, err := d.communicateWithPICC(txCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif rx[len(rx)-2] != PICC_OK {\n\t\treturn fmt.Errorf(\"PCD received error response to halt command: % x\", rx)\n\t}\n\treturn nil\n}", "CodeBleu_score": 40.51513819782725}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"halting PICC\")\n\t}\n\t// Build command for PICC Halt.\n\tcmd := []byte{PICC_HALT}\n\t// Calculate CRC for command.\n\tcrc := d.calculateCRC(cmd[:])\n\t// Append CRC to command.\n\tcmd = append(cmd, crc)\n\t// Send the command.\n\tif d.communicateWithPICC(cmd) != nil {\n\t\treturn fmt.Errorf(\"failed to halt PICC\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 26.479382298736464}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build command for PICC_READ.\n\tdata := []byte{PICC_READ, block}\n\t// Calculate CRC for the command.\n\tcrc := d.calculateCRC(data[:2])\n\t// Append CRC to the command.\n\tdata = append(data, crc)\n\t// Send the command.\n\t_, err := d.communicateWithPICC(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Read the response.\n\tdata, err = d.communicateWithPICC(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Check the CRC.\n\terr = d.checkCRC(data[:len(data)-2], data[len(data)-2:])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Return data.\n\treturn data[:len(data)-2], nil\n}", "CodeBleu_score": 45.63603779109854}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build a read command for a PICC.\n\tdata := []byte{piccCommandRead, block}\n\n\t// Calculate CRC for the command.\n\tdata = append(data, d.calculateCRC(data))\n\n\t// Communicate with the PICC.\n\tresponse, err := d.communicateWithPICC(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the CRC.\n\tif !d.checkCRC(response[:len(response)-2], response[len(response)-2:]) {\n\t\treturn nil, ErrCRC\n\t}\n\n\t// Return the data.\n\treturn response[:len(response)-2], nil\n}", "CodeBleu_score": 36.90475021492035}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Create and initialise the buffer for the data to be read in\n\tdata := make([]byte, 18)\n\t// Create and initialise the command buffer\n\tcommand := make([]byte, 2)\n\t// Set the first byte of the command to 0x30 (authKeyA)\n\tcommand[0] = 0x30\n\t// Set the second byte of the command to the block number\n\tcommand[1] = byte(block)\n\t// Calculate the CRC for the command\n\tcrc := d.calculateCRC(command[:])\n\t// Set the last byte of the command to the CRC\n\tcommand[len(command)-1] = crc\n\t// Send the command to the card\n\t_, err := d.communicateWithPICC(command, data[:])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Return the data\n\treturn data, nil\n}", "CodeBleu_score": 28.876251229522342}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: The length of the answer must be at least 2\")\n\t}\n\t// Clear the bits in the CollReg register.\n\td.clearRegisterBitMask(CollReg, 0x80|0x40|0x20|0x10|0x08|0x04|0x02|0x01)\n\t// Set the bits in TxLastBle to send the last byte\n\tif reqMode == Transceive7Bits {\n\t\td.setRegisterBitMask(TxLastBle, 0x01)\n\t} else {\n\t\td.clearRegisterBitMask(TxLastBle, 0x01)\n\t}\n\t// Transceive the data.\n\tif err := d.communicateWithPICC(reqMode, 0, 0, 0, answer); err != nil {\n\t\treturn err\n\t}\n\t// Check if there was a collision.\n\tif d.readRegister(CollReg) != 0 {\n\t\treturn fmt.Errorf(\"piccRequest: CollReg is not 0\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.14222864453225}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: answer buffer too short: %d bytes\", len(answer))\n\t}\n\n\t// Clear the bits in the CollReg register.\n\td.clearRegisterBitMask(CollReg, 0x80|0x40|0x20|0x10|0x08|0x04|0x02|0x01)\n\n\t// Set the bits in TxLastBits if reqMode is not 0x0C.\n\tif reqMode != 0x0C {\n\t\td.setRegisterBitMask(TxLastBits, 0x07)\n\t}\n\n\t// Prepare the command.\n\tcommand := []byte{reqMode}\n\tif reqMode != 0x0C {\n\t\tcommand = append(command, 0)\n\t}\n\n\t// Transceive the command.\n\terr := d.communicateWithPICC(command, answer, 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"piccRequest: %v\", err)\n\t}\n\n\t// Check if the PICC was in IDLE state before executing the Transceive command.\n\tif d.readRegister(Status2Reg) != 0x00 {\n\t\treturn fmt.Errorf(\"piccRequest: PICC is not in IDLE state\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 51.60061755589223}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"piccRequest: len(answer) < 2\")\n\t}\n\td.clearRegisterBitMask(CollReg, 0x80)\n\tif reqMode == piccRequestModeTypeA {\n\t\td.setRegisterBits(TxLastBits, 0x07)\n\t}\n\terr := d.communicateWithPICC(reqMode, 0, 0, 0, 0, 0, 0, answer)\n\tif reqMode == piccRequestModeTypeA {\n\t\td.setRegisterBits(TxLastBits, 0x00)\n\t}\n\treturn err\n}", "CodeBleu_score": 46.28061889130714}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\t// Trigger a step\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Wait for the step to finish\n\ttime.Sleep(d.getDelayPerStep())\n\t// Move the step number\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 63.636725556218984}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\terr := d.digitalWrite(d.stepPin, gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif d.direction == gpio.Low {\n\t\td.stepNum--\n\t} else {\n\t\td.stepNum++\n\t}\n\treturn nil\n}", "CodeBleu_score": 70.5737557229562}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.digitalWrite(d.stepPin, gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.getDelayPerStep())\n\n\terr = d.digitalWrite(d.stepPin, gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 68.32625106631784}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn errors.New(\"distance monitor is already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 65.8324276379652}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tif d.distanceMonitorStopChan != nil {\n\t\td.mutex.Unlock()\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\td.mutex.Unlock()\n\treturn nil\n}", "CodeBleu_score": 81.18841608130234}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\n\td.distanceMonitorStopWaitGroup.Add(1)\n\tgo func() {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 77.94365992508847}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(gpio int, duration time.Duration, channel string, timestamp uint32, nanoseconds uint32) {\n\t\tif gpio == d.triggerPin {\n\t\t\td.startTimestamp = timestamp\n\t\t\treturn\n\t\t}\n\t\tif gpio == d.echoPin {\n\t\t\tif d.startTimestamp == 0 {\n\t\t\t\treturn\n\t\t\t}\n\t\t\td.startTimestamp = 0\n\t\t\td.sendDuration(channel, duration)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 44.643612577819255}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(gpio int, level time.Duration, id string, timestamp uint32, sequence uint32) {\n\t\tif level == time.Microsecond {\n\t\t\td.startTimestamp = timestamp\n\t\t} else if level == time.Nanosecond {\n\t\t\td.sendPulseDuration(id, timestamp, sequence)\n\t\t\td.startTimestamp = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 36.81457702041634}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, channel string, timestamp uint32, sequence uint32) {\n\t\tif channel == \"pulse\" {\n\t\t\td.pulseDuration = duration\n\t\t\td.pulseTimestamp = timestamp\n\t\t}\n\t}\n}", "CodeBleu_score": 30.102110424748663}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor\n\td.emitTrigger()\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measureComplete:\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout waiting for sensor response\")\n\t}\n\n\t// Return the measured time\n\treturn nil\n}", "CodeBleu_score": 30.269295767772253}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access\n\td.measureMutex.Lock()\n\t// Trigger the sensor\n\td.emitTrigger()\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measureComplete:\n\t\t// The measurement is complete, so unlock the measurement mutex\n\t\td.measureMutex.Unlock()\n\t\t// Return nil to indicate success\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// The timeout is reached, so unlock the measurement mutex\n\t\td.measureMutex.Unlock()\n\t\t// Return an error to indicate a timeout\n\t\treturn fmt.Errorf(\"timeout while waiting for measurement to complete\")\n\t}\n}", "CodeBleu_score": 30.39140369153553}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\terr := d.emitTrigger()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = <-d.measureComplete\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 45.004069110251}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get(self.token_environment_variable)\n    if token is None:\n        token = self.get_state_item(self.token_state_item)\n    if token is not None:\n        if time.time() > token[\"expires_at\"]:\n            if token.get(\"refresh_token\") is not None:\n                token = self.fetch_json_data(\n                    \"https://api.tdameritrade.com/v1/oauth2/token\",\n                    headers={\n                        \"Content-Type\": \"application/x-www-form-urlencoded\"\n                    },\n                    data={\n                        \"grant_type\": \"refresh_token\",\n                        \"refresh_token\": token[\"refresh_token\"],\n                        \"access_type\": \"offline\",\n                        \"client_id\": self.client_id,\n                        \"redirect_uri\": self.redirect_uri,\n                    },\n                )\n                if token is not None:\n                    self.set_state_item(self.token_state_item, token)\n                    return token[\"access_token\"]\n        return token[\"access_token\"]\n    raise AccountNotAuthorized(\n        \"No access token available. Please authorize your account.\"\n    )\n\n", "CodeBleu_score": 41.84766687312612}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.authentication_token is not None:\n        return self.authentication_token\n    if self.refresh_token is not None:\n        if self.access_token is not None:\n            if self.access_token_expiration_time > time.time():\n                return self.access_token\n        self.access_token, self.access_token_expiration_time = self.fetch_new_access_token()\n        self.set_state_item('access_token', self.access_token)\n        self.set_state_item('access_token_expiration_time', self.access_token_expiration_time)\n        return self.access_token\n    raise AccountNotAuthorized\n\n", "CodeBleu_score": 23.282295972694943}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.access_token is None:\n        if self.refresh_token is not None:\n            self.fetch_new_access_token()\n        else:\n            raise AccountNotAuthorized\n    return self.access_token\n\n", "CodeBleu_score": 7.771506823886272}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.send_post_request(\n            endpoint=\"/v1/logout\",\n            data={\"refresh_token\": refresh_token},\n            headers={\"Content-Type\": \"application/json\"},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 53.1488014432109}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.post_request(\n            \"v1/logout\",\n            {\"refresh_token\": refresh_token},\n            return_json=False,\n            return_response=False,\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 51.95906627876755}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.fetch_refresh_token()\n        self.delete_local_session()\n        self.send_post_request(\n            url=f\"{self.API_URL}/v1/logout\",\n            headers={\n                \"Authorization\": f\"Bearer {refresh_token}\"\n            }\n        )\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 46.2036356716783}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if package.is_optional:\n            continue\n        metadata = package.get_metadata()\n        if metadata.get(\"external\"):\n            result.append(\n                (\n                    package.name,\n                    package.version,\n                    metadata.get(\"external_url\"),\n                )\n            )\n        else:\n            result.append((package.name, package.version))\n    return result\n", "CodeBleu_score": 29.37333283946957}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for name, package in self.packages.items():\n        if package.optional:\n            continue\n        metadata = package.metadata\n        if metadata.get('external', False):\n            result.append((name, metadata['version'], metadata['source_url']))\n        else:\n            result.append((name, metadata['version']))\n    return result\n", "CodeBleu_score": 34.68648836246}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if not package.optional:\n            pkg_name = package.name\n            pkg_version = package.version\n            pkg_url = package.url\n            pkg_hash = package.hash\n            pkg_build_id = package.build_id\n            pkg_external = package.external\n            pkg_optional = package.optional\n            pkg_system = package.system\n            pkg_system_libs = package.system_libs\n            pkg_system_include_dirs = package.system_include_dirs\n            pkg_system_lib_dirs = package.system_lib_dirs\n            pkg_system_bin_dirs = package.system_bin_dirs\n            pkg_system_framework_dirs = package.system_framework_dirs\n            pkg_system_frameworks = package.system_frameworks\n            pkg_system_defines = package.system_defines\n            pkg_system_cflags = package.system_cflags\n            pkg_system_cxxflags = package.system_cxxflags\n            pkg_system_sharedlinkflags = package.system_sharedlinkflags\n            pkg_system_exelinkflags = package.system_exelinkflags\n            pkg_system_bin_path = package.system_bin_path\n            pkg_system_lib_path = package.system_lib_path\n            pkg_system_include_path = package.system_include_path\n            pkg_system_framework_path = package.system_framework_path\n            pkg_system_framework_paths = package.system_framework_paths\n            pkg_system_framework_paths_debug = package.system_framework_paths_debug\n            pkg_system_framework_paths_release = package.system_framework_paths_release\n            pkg_system_lib_prefix = package.system_lib_prefix\n            pkg_system_lib_suffix = package.system_lib_suffix\n            pkg_system_libs = package.system_libs\n            pkg_system_defines = package.system_defines\n            pkg_system_cflags = package.system_cflags\n            pkg_system_cxxflags = package.system_cxxflags\n            pkg_system_sharedlinkflags = package.system_sharedlinkflags\n            pkg_system_exelinkflags = package.system_exelinkflags\n            pkg_system_defines = package.system_defines\n            pkg_system_cflags = package.system_c", "CodeBleu_score": 9.876754683022632}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not isinstance(env, str):\n        raise TypeError(\"env must be a string\")\n    if targets is not None and not isinstance(targets, (list, tuple)):\n        raise TypeError(\"targets must be a list or tuple\")\n    p = ProjectConfig.get_instance()\n    platform_spec = p.get(\"environments\", {}).get(env, {}).get(\"platform\")\n    if platform_spec is None:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(platform_spec, autoinstall)\n    instance.env = env\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 42.66530440820402}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = ProjectConfig.get_instance()\n    spec = p.get_env_platform(env)\n    if spec is None:\n        raise UndefinedEnvPlatformError(env)\n    return cls.new(spec, autoinstall=autoinstall).set_env(env, targets).configure_project_packages(env, targets)\n\n", "CodeBleu_score": 30.699397892209696}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    p = ProjectConfig.get_instance()\n    platform_spec = p.get(env)\n    if platform_spec is None:\n        raise UndefinedEnvPlatformError(env)\n    return cls(platform_spec, autoinstall=autoinstall).set_env(env, targets=targets).configure_project_packages()\n\n", "CodeBleu_score": 26.544949168121732}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, (uint8_t)Size);\n\tuint8_t i = 0;\n\twhile (Wire1.available()) {\n\t\tBuff[i++] = Wire1.read();\n\t}\n}", "CodeBleu_score": 62.64437274723805}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission();\n\tWire1.requestFrom(0x34, (uint8_t) Size);\n\tuint8_t i = 0;\n\twhile (Wire1.available()) {\n\t\tBuff[i++] = Wire1.read();\n\t}\n}", "CodeBleu_score": 62.63382434633271}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire1.beginTransmission(0x34);\n\tWire1.write(Addr);\n\tWire1.endTransmission(false);\n\tWire1.requestFrom(0x34, (uint8_t)Size);\n\tuint8_t i = 0;\n\twhile (Wire1.available()) {\n\t\tBuff[i++] = Wire1.read();\n\t}\n}", "CodeBleu_score": 59.12814259433511}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 64.9342703245996}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 64.9342703245996}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_ALL);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 51.32897943758257}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\t// Save the current scroll address\n\tint16_t scrollAddress = tft.getScrollAddressY();\n\t// Scroll the display by one line\n\ttft.scroll(0, 1);\n\t// Fill the new line with the specified color\n\ttft.fillRect(0, scrollAddress, tft.width(), tft.fontHeight(), color);\n\t// If a specific condition (tteBar) is met, use alternative top fixed area coordinates\n\tif (scrollAddress == tteBar) {\n\t\tscrollAddress = tteBarAlt;\n\t}\n\t// Update the scroll address and return the previous y-coordinate\n\treturn scrollAddress;\n}", "CodeBleu_score": 14.287272840515309}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = scrollAddress;\n\ttft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n\tif (y >= tft.height() - tft.fontHeight()) {\n\t\ty = 0;\n\t} else {\n\t\ty += tft.fontHeight();\n\t}\n\tscrollAddress = y;\n\treturn y;\n}", "CodeBleu_score": 12.522202301923313}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint32_t y = scrollAddress;\n\tscrollAddress += tft.fontHeight();\n\tif (scrollAddress >= tft.height() - tft.fontHeight() - tft.fontHeight()) {\n\t\tscrollAddress = tft.height() - tft.fontHeight() - tft.fontHeight();\n\t\ttft.fillRect(0, 0, tft.width(), tft.fontHeight(), color);\n\t\ttft.fillRect(0, tft.height() - tft.fontHeight(), tft.width(), tft.fontHeight(), color);\n\t\ttft.fillRect(0, scrollAddress - tft.fontHeight(), tft.width(), tft.fontHeight(), color);\n\t}\n\telse {\n\t\ttft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n\t}\n\treturn y;\n}", "CodeBleu_score": 16.1608860369589}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// Check if the lists are empty\n\tif (ssids->isEmpty() || access_points->isEmpty()) {\n\t\treturn false;\n\t}\n\n\t// Set the SSIDs and access points\n\tif (!setSSIDs(ssids)) {\n\t\treturn false;\n\t}\n\tif (!setAPs(access_points)) {\n\t\treturn false;\n\t}\n\n\t// Set the HTML content\n\tif (!setHtml()) {\n\t\treturn false;\n\t}\n\n\t// Start the portal\n\tstartPortal();\n\n\t// Return true if everything went well\n\treturn true;\n}", "CodeBleu_score": 56.91508705382701}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// Set up access points\n\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\n\t// Set up HTML content\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\n\t// Start portal\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 61.874474982232385}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setAP(access_points)) {\n\t\treturn false;\n\t}\n\tif (!this->setHtml(ssids)) {\n\t\treturn false;\n\t}\n\tthis->startPortal();\n\treturn true;\n}", "CodeBleu_score": 61.87356687923673}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag == false) {\n\t\tthis->flush_queue();\n\t\tthis->new_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 15.562091895491015}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag == true) {\n\t\tthis->flush_queue();\n\t}\n\telse {\n\t\tthis->flush_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 20.026021962259154}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (this->queue_enabled_flag == true) {\n\t\tthis->flush_queue();\n\t} else {\n\t\tthis->new_queue();\n\t\tthis->queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 17.76717720134122}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue) {\n\t\tthis->new_queue = new QueueNmea();\n\t\tdelete this->queue;\n\t\tthis->queue = this->new_queue;\n\t}\n\telse {\n\t\tthis->new_queue = new QueueNmea();\n\t\tthis->queue = this->new_queue;\n\t}\n}", "CodeBleu_score": 21.067512123123343}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea) {\n\t\tdelete this->queue_nmea;\n\t\tthis->queue_nmea = nullptr;\n\t}\n\tthis->queue_nmea = new Queue<std::string>();\n}", "CodeBleu_score": 16.920472936562575}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue != NULL) {\n\t\tthis->new_queue = new Queue<string>();\n\t\tdelete this->queue;\n\t\tthis->queue = this->new_queue;\n\t}\n\telse {\n\t\tthis->queue = new Queue<string>();\n\t}\n}", "CodeBleu_score": 22.77797828876791}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n#ifdef LV_USE_LOG\n    LV_LOG_INFO(\"my_disp_flush: area: x:%d y:%d w:%d h:%d\", area->x1, area->y1, area->x2 - area->x1 + 1, area->y2 - area->y1 + 1);\n#endif\n\n    /* In this example `my_disp_flush` is used only with the parallel interface.\n     * To make it work with other interfaces too, you need to add the flush callback to the disp_drv structure.\n     * E.g. disp_drv.flush_cb = my_disp_flush;\n     */\n    display_obj.tft.startWrite();\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2 - area->x1 + 1, area->y2 - area->y1 + 1);\n\n    /* The most simple case (but also the slowest) to write pixel to the display\n     * is to write all pixels in the specified area one-by-one.\n     * In real life scenarios, there are faster ways to do it.\n     * E.g. in SPI or QSPI interfaces you can write pixels in blocks.\n     * In parallel interface you can write words instead of individual pixels.\n     *\n     * This example shows the most simple way.\n     */\n    for(int32_t y = area->y1; y <= area->y2; y++) {\n        for(int32_t x = area->x1; x <= area->x2; x++) {\n            display_obj.tft.writeColor(*color_p);\n            color_p++;\n        }\n    }\n\n    display_obj.tft.endWrite();\n\n    /* IMPORTANT!!!\n     * Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 66.60303314201987}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n/*\n * The flushing time of a display driver can be a bottleneck in embedded systems.\n * E.g. if the display is placed in a close distance from the controller,\n * the flushing time can be long.\n * To avoid it, you can use a double buffering in your display driver.\n * It will allow the driver to display different parts of the screen at the same time.\n *\n * To create a double buffer, you need to declare two display buffers:\n * 1. A buffer for the display content\n * 2. A buffer for the display refresh\n *\n * The display driver needs to know the buffer's address and size.\n * It can be set in the display driver with `lv_disp_drv_t.flush_cb` member.\n *\n * The display driver can then use the flushing time to decide which buffer is active.\n * The active buffer can be set with `lv_disp_drv_t.buffer` member.\n *\n * The display driver can use `lv_disp_flush_ready()` to check if the flush is ready or not.\n *\n * In the display driver function `my_disp_flush`, you need to do the following:\n * 1. Check if the flush is ready or not with `lv_disp_flush_ready()`\n * 2. If it's ready, get the active buffer with `lv_disp_get_buf()`\n * 3. Copy the content of the active buffer to the display refresh buffer\n * 4. Call `lv_disp_flush_ready()` to notify the completion of the flushing\n *\n * In the display driver function `my_disp_rounder`, you need to do the following:\n * 1. Get the active buffer with `lv_disp_get_buf()`\n * 2. Copy the content of the active buffer to the display refresh buffer\n * 3. Call `lv_disp_flush_ready()` to notify the completion of the flushing\n *\n * In the display driver function `my_disp_wait_cb`, you need to do the following:\n * 1. Check if the flush is ready or not with `lv_disp_flush_ready()`\n * 2. If it's ready, get the active buffer with `lv_disp_get_buf()`\n * 3. Copy", "CodeBleu_score": 31.702864512960836}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n#if LV_USE_LOG\n    lv_log_debug(\"flushing area\");\n#endif\n\n    /* In the simulator we need to flush the display after every command.\n     * In a real driver it can be done in the background when there is no other\n     * CPU activity.\n     */\n    display_obj.tft.startWrite();\n\n    /* Set the address window */\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\n    /* Iterate through each pixel in the area */\n    for (int32_t y = area->y1; y <= area->y2; y++) {\n        for (int32_t x = area->x1; x <= area->x2; x++) {\n            /* Get the pixel color from the color buffer */\n            lv_color_t color = color_p[y * disp->hor_res + x];\n\n            /* Write the pixel to the display */\n            display_obj.tft.writeColor(color.full);\n        }\n    }\n\n    /* Signal that the flush is ready */\n    lv_disp_flush_ready(disp);\n\n    /* In the simulator we need to flush the display after every command.\n     * In a real driver it can be done in the background when there is no other\n     * CPU activity.\n     */\n    display_obj.tft.endWrite();\n}", "CodeBleu_score": 64.36624265979384}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tMenuNode * node = menu->getFirstNode();\n\twhile(node != NULL) {\n\t\tfor(int i = 0; i < layer; i++) {\n\t\t\tSerial.print(\"  \");\n\t\t}\n\t\tSerial.println(node->getName());\n\t\tnode = node->getNext();\n\t}\n\tSerial.println();\n}", "CodeBleu_score": 53.43294005149208}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial.print(F(\"  \"));\n\tSerial", "CodeBleu_score": 17.785809406579727}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\t// Print the menu's name\n\tSerial.print(menu->getName());\n\tSerial.println(\":\");\n\n\t// Iterate through all menu nodes\n\tfor (int i = 0; i < menu->size(); i++) {\n\t\t// Print the node's name with indentation\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tSerial.print(\"\\t\");\n\t\t}\n\t\tSerial.println(menu->get(i)->getName());\n\t}\n\n\t// Print an empty line\n\tSerial.println();\n}", "CodeBleu_score": 60.04562431760423}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\tint i;\nString ssid;\nfor (i = 0; i < count; i++) {\nssid = \"\";\nfor (int j = 0; j < 6; j++) {\nssid.concat(random(97, 122));\n}\nSerial.println(ssid);\nssids->add(ssid, random(1, 11), WiFi.macAddress());\n}\nreturn count;\n}", "CodeBleu_score": 31.52777490957581}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tfor (i = 0; i < count; i++) {\n\t\tchar essid[7];\n\t\tchar mac[18];\n\t\tchar channel[3];\n\t\tint j;\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tessid[j] = random(97, 123);\n\t\t}\n\t\tessid[6] = 0;\n\t\tsprintf(channel, \"%d\", random(1, 14));\n\t\tsprintf(mac, \"00:00:00:%02x:%02x:%02x\", random(0, 255), random(0, 255), random(0, 255));\n\t\tSerial.println(essid);\n\t\tSerial.println(channel);\n\t\tSerial.println(mac);\n\t\tssids->add(essid, channel, mac);\n\t}\n\treturn i;\n}", "CodeBleu_score": 40.322364170304716}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint i = 0;\nfor (i = 0; i < count; i++) {\n// Generate a random 6-character SSID\nString ssid = \"\";\nint j = 0;\nfor (j = 0; j < 6; j++) {\nssid.concat(random(65, 90));\n}\n// Assign a random channel and MAC address to the SSID\nint channel = random(1, 13);\nString mac = \"\";\nint k = 0;\nfor (k = 0; k < 6; k++) {\nmac.concat(random(0, 255));\nif (k < 5) {\nmac.concat(\":\");\n}\n}\n// Add the SSID to the list\nSerial.println(\"Generated SSID: \" + ssid);\nSerial.println(\"Channel: \" + channel);\nSerial.println(\"MAC: \" + mac);\nssids->add(ssid, channel, mac);\n}\n// Return the number of generated SSIDs\nreturn count;\n}", "CodeBleu_score": 41.66414643044523}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n\n    # Initialize a Publisher client.\n    publisher = pubsub_v1.PublisherClient()\n\n    # Construct the fully qualified topic name.\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic.\n    topic = publisher.create_topic(topic_path)\n\n    # Print the topic name.\n    print(f\"Created topic: {topic.name}\")\n", "CodeBleu_score": 47.407721850208304}, {"code": "def create_topic(project_id, topic_name)\n\t\n    # Initialize a Publisher client.\n    publisher = pubsub_v1.PublisherClient()\n    # Create a fully qualified identifier in the form of `projects/{project_id}/topics/{topic_name}`\n    topic_path = publisher.topic_path(project_id, topic_name)\n    # Create the topic.\n    topic = publisher.create_topic(topic_path)\n    print(f\"Created topic: {topic.name}\")\n    return topic\n\n", "CodeBleu_score": 47.154447874062825}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(f\"Created topic: {topic.name}\")\n    return topic\n", "CodeBleu_score": 47.154447874062825}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print(private_key)\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 58.21640720214055}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print 'Creating JWT using {} from private key file {}'.format(algorithm, private_key_file)\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 68.95143026222124}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print 'Creating JWT using {} from private key file {}'.format(algorithm, private_key_file)\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 68.95143026222124}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Received message '\" + str(payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos))\n    if payload == \"on\":\n        preview_capture()\n        upload_file()\n        unused_client.publish(\n            \"events/preview\",\n            payload=\"https://storage.googleapis.com/iot-core-demo-bucket/preview.jpg\",\n            qos=1,\n        )\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 27.812550559478343}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message '\" + payload + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos))\n    if payload == \"on\":\n        preview_capture()\n        upload_file()\n        unused_client.publish(MQTT_TOPIC, \"https://s3.amazonaws.com/iot-camera-files/capture.jpg\", qos=1)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 24.019066425977115}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Received message '{}' on topic '{}' with Qos {}\".format(\n        payload, message.topic, str(message.qos)))\n    if payload == \"on\":\n        preview_capture()\n        upload_file(BUCKET_NAME, PREVIEW_FILE)\n        url = get_url(BUCKET_NAME, PREVIEW_FILE)\n        unused_client.publish(MQTT_TOPIC, url, 1)\n        print(\"Published message to topic '{}': {}\".format(MQTT_TOPIC, url))\n    else:\n        print(\"Turned off.\")\n\n", "CodeBleu_score": 34.516562481412564}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        required=True,\n        help='GCP cloud project name.')\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='Cloud Pub/Sub subscription name to listen to.')\n    parser.add_argument(\n        '--device_id',\n        required=True,\n        help='Cloud IoT Core device id.')\n    parser.add_argument(\n        '--registry_id',\n        required=True,\n        help='Cloud IoT Core registry id.')\n    parser.add_argument(\n        '--private_key_file',\n        required=True,\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument(\n        '--num_messages',\n        default=100,\n        type=int,\n        help=('Number of messages to publish. If not specified, '\n              'the server will publish forever.'))\n    parser.add_argument(\n        '--message_type',\n        choices=('event', 'state'),\n        default='event',\n        help=('Indicates whether the message to be published is a '\n              'telemetry event or a device state message.'))\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help=('MQTT bridge hostname.'))\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        choices=(8883, 443),\n        default=8883,\n        type=int,\n        help=('MQTT bridge port.'))\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,\n        help=('Expiration time, in minutes, for JWT tokens.'))\n    parser.add_argument", "CodeBleu_score": 41.868042804552736}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument('project_id', help='GCP cloud project name')\n    parser.add_argument('subscription_name', help='Cloud Pub/Sub subscription name')\n    parser.add_argument('--registry_id', help='Cloud IoT Core registry id')\n    parser.add_argument('--device_id', help='Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', help='Path to private key file.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--ca_certs', help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--num_messages', default=100, type=int, help='Number of messages to publish.')\n    parser.add_argument('--message_type', default='event', choices=('event', 'state'), help='Type of message to publish. Either \"event\" for events or \"state\" for device state.')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--mqtt_topic', default='events', help='MQTT topic.')\n    parser.add_argument('--service_account_json', default=None, help='Path to service account json file.')\n    parser.add_argument('--project_id', default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help='GCP cloud project name')\n    return parser.parse_args()\n", "CodeBleu_score": 39.8179109617099}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument('project_id', help='GCP cloud project name.')\n    parser.add_argument('subscription_name', help='Pub/Sub subscription name')\n    parser.add_argument('--algorithm', choices=['RS256', 'ES256'], default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--private_key_file', required=True, help='Path to private key file.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--ca_certs', default='roots.pem', help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--num_messages', default=100, type=int, help='Number of messages to publish.')\n    parser.add_argument('--message_type', default='event', choices=['event', 'state'], help='Type of message to publish. Either \"event\" for events or \"state\" for device state.')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--verbosity', choices=['debug', 'info', 'error'], default='error', help='Logging verbosity.')\n    args = parser.parse_args()\n    return args\n\n", "CodeBleu_score": 41.10500899708619}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # Define the necessary API scopes, version, and discovery URL\n    CLOUD_IOT_CORE_SCOPE = 'https://www.googleapis.com/auth/cloud-platform'\n    CLOUD_IOT_CORE_DISCOVERY_URL = 'https://{api}.googleapis.com/$discovery/rest?version={apiVersion}'\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    # Scope the credentials with the necessary API scopes\n    scoped_credentials = credentials.with_scopes([CLOUD_IOT_CORE_SCOPE])\n    # Build and return the client for the Cloud IoT Core service using the discovery API URL\n    return discovery.build('cloudiot', 'v1', credentials=scoped_credentials, discoveryServiceUrl=CLOUD_IOT_CORE_DISCOVERY_URL)\n\n", "CodeBleu_score": 18.946010731027602}, {"code": "def get_client(service_account_json)\n\t\n    # Define the required scopes\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Get the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes)\n\n    # Build the Cloud IoT Core client\n    return discovery.build('cloudiot', 'v1', credentials=credentials,\n                          discoveryServiceUrl=DISCOVERY_URL)\n\n", "CodeBleu_score": 15.480999338298659}, {"code": "def get_client(service_account_json)\n\t\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = ('https://cloudiot.googleapis.com/$discovery/rest?version={}'.format(version))\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n    scoped_credentials = credentials.with_scopes(scopes)\n    return discovery.build('cloudiot', version, credentials=scoped_credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 37.57521591189936}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method not in HASH_METHODS:\n        raise ValueError(\"Invalid hash method\")\n    asn1_code = HASH_METHODS[hash_method]\n    hash_value = asn1_code + hash_value\n    hash_value = _pad_for_signing(hash_value)\n    signature = priv_key.blinded_encrypt(hash_value)\n    return signature\n\n", "CodeBleu_score": 34.687760890205524}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method_asn1 = _get_hash_method_asn1(hash_method)\n    if hash_method_asn1 == None:\n        raise ValueError(\"Invalid hash method!\")\n    hash_value_asn1 = _get_hash_value_asn1(hash_value)\n    hash_value_asn1_bytes = _get_hash_value_asn1_bytes(hash_value_asn1)\n    padded_hash_value = _pad_for_signing(hash_value_asn1_bytes)\n    signature = priv_key.blinded_encrypt(padded_hash_value)\n    return signature\n\n", "CodeBleu_score": 32.61298791267212}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method not in HASH_METHODS:\n        raise ValueError(\n            f\"Hash method {hash_method} is not supported. Use one of {HASH_METHODS}\"\n        )\n    asn1_code = HASH_METHODS[hash_method]\n    hash_bytes = asn1_code + hash_value\n    padded_hash = _pad_for_signing(hash_bytes, priv_key.curve)\n    signature = priv_key.blinded_encrypt(padded_hash)\n    return signature\n\n", "CodeBleu_score": 38.51225947473198}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    if type(message) == str:\n        message = message.encode('utf-8')\n    if type(signature) == str:\n        signature = signature.encode('utf-8')\n    if type(pub_key) == str:\n        pub_key = pub_key.encode('utf-8')\n    # Convert the signature to an integer\n    signature_int = transform.bytes2int(signature)\n    # Decrypt the signature to obtain the clear signature\n    clear_sig = core.decrypt_int(signature_int, pub_key)\n    # Determine the hash method used\n    hash_method = _find_method_hash(clear_sig)\n    # Compute the hash of the message\n    message_hash = compute_hash(message, hash_method)\n    # Reconstruct the expected padded hash\n    expected_hash = _pad_for_signing(message_hash, hash_method)\n    # If the expected padded hash does not match the clear signature, raise a verification error\n    if clear_sig != expected_hash:\n        raise VerificationError('Invalid signature')\n    # If the verification is successful, return the hash method name\n    return hash_method\n\n", "CodeBleu_score": 46.41491519152202}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    sig_int = transform.bytes2int(signature)\n    # Decrypt the signature to obtain the clear signature\n    clear_sig = core.decrypt_int(sig_int, pub_key)\n    # Determine the hash method used\n    hash_method = _find_method_hash(clear_sig)\n    # Compute the hash of the message\n    message_hash = compute_hash(message, hash_method)\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _pad_for_signing(message_hash, hash_method)\n    # Compare the expected padded hash to the clear signature\n    if clear_sig == expected_padded_hash:\n        return hash_method\n    else:\n        raise VerificationError\n", "CodeBleu_score": 17.660910974938105}, {"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        # Convert signature to integer\n        clear_signature = core.decrypt_int(signature, pub_key)\n\n        # Determine hash method\n        hash_method_name = _find_method_hash(clear_signature)\n\n        # Compute hash of message\n        message_hash = compute_hash(message, hash_method_name)\n\n        # Reconstruct padded hash\n        padded_hash = _pad_for_signing(message_hash, hash_method_name)\n\n        # Raise error if signature is invalid\n        if clear_signature != padded_hash:\n            raise VerificationError(\"Signature is invalid.\")\n\n        # Return hash method name\n        return hash_method_name\n\n    except VerificationError as e:\n        print(e)\n\n", "CodeBleu_score": 39.29152040532827}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tint rc;\n\ttime_t now;\n\tstruct tm timeinfo;\n\tchar jwt[256];\n\tchar *topic = NULL;\n\tchar *payload = NULL;\n\tint topic_len = 0;\n\tint payload_len = 0;\n\tint topic_len_int = 0;\n\tint payload_len_int = 0;\n\tint payload_int = 0;\n\tint topic_int = 0;\n\n\t// Get current time\n\ttime(&now);\n\tlocaltime_r(&now, &timeinfo);\n\n\t// Check if the current time is valid\n\tif (timeinfo.tm_year < (2017 - 1900)) {\n\t\t// Invalid time\n\t\treturn;\n\t}\n\n\t// Update JWT\n\tupdateJWT();\n\n\t// Connect to MQTT client\n\trc = MQTT_CLIENT_connect();\n\tif (rc != 0) {\n\t\t// Connection failed\n\t\treturn;\n\t}\n\n\t// Flag to send MQTT SUBSCRIBE packet after connection is established\n\tsendSubscribePacket = 1;\n\n\t// Print debug message\n\tdebug_print(\"MQTT connection established\");\n}", "CodeBleu_score": 17.6339516105288}, {"code": "static void connectMQTT(){\n\t\t// Get the current time\n\ttime_t now = time(NULL);\n\t// Check if the current time is valid\n\tif (now != (time_t)-1) {\n\t\t// Update the JWT\n\t\tupdateJWT(now);\n\t}\n\t// Connect to the MQTT client\n\tMQTT_CLIENT_connect();\n\t// Set the flag to send an MQTT SUBSCRIBE packet after the connection is established\n\tmqtt_subscribe_flag = 1;\n\t// Print a debug message\n\tdebug_print(\"MQTT connection attempt\");\n}", "CodeBleu_score": 23.50738911078868}, {"code": "static void connectMQTT(){\n\t\t// Get current time\n\tstruct tm timeinfo;\n\tif (!getLocalTime(&timeinfo, 3000)) {\n\t\t// Failed to get time\n\t\tdebug_print(ERROR_GET_TIME);\n\t\treturn;\n\t}\n\n\t// Update JWT\n\tif (updateJWT(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec)) {\n\t\t// Failed to update JWT\n\t\tdebug_print(ERROR_UPDATE_JWT);\n\t\treturn;\n\t}\n\n\t// Connect to MQTT client\n\tif (MQTT_CLIENT_connect() == 0) {\n\t\t// Connection failed\n\t\tdebug_print(ERROR_CONNECT_MQTT);\n\t\treturn;\n\t}\n\n\t// Set flag to send MQTT SUBSCRIBE packet\n\tsubscribe = 1;\n}", "CodeBleu_score": 35.89428232548776}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tint i;\n\tuint32_t n;\n\tfor (i = 0, n = 0; i < width; i++) {\n\t\tif (str[i] >= '0' && str[i] <= '9') {\n\t\t\tn = n * 10 + (str[i] - '0');\n\t\t} else {\n\t\t\t*num = n;\n\t\t\treturn str;\n\t\t}\n\t}\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 24.96609003226012}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\t*num = 0;\n\twhile (width--) {\n\t\tuint32_t digit = *str - '0';\n\t\tif (digit > 9) {\n\t\t\treturn str;\n\t\t}\n\t\t*num = *num * 10 + digit;\n\t\tstr++;\n\t}\n\treturn str;\n}", "CodeBleu_score": 21.502770102061987}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tint i;\n\tuint8_t c;\n\tuint32_t val;\n\n\tval = 0;\n\tfor (i = 0; i < width; i++) {\n\t\tc = str[i];\n\t\tif (c < '0' || c > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tval = val * 10 + c - '0';\n\t}\n\t*num = val;\n\treturn str + width;\n}", "CodeBleu_score": 25.618778987611236}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tuint8_t* cert_ptr = NULL;\n\tuint8_t* cert_end = NULL;\n\tuint8_t* cert_start = NULL;\n\tuint8_t* cert_max = NULL;\n\tuint8_t* cert_temp = NULL;\n\tuint8_t* cert_max_temp = NULL;\n\tuint8_t cert_length = 0;\n\tuint8_t cert_tag = 0;\n\tuint8_t cert_class = 0;\n\tuint8_t cert_constructed = 0;\n\tuint8_t cert_tag_constructed = 0;\n\tuint8_t cert_tag_number = 0;\n\tuint8_t cert_tag_class = 0;\n\tuint8_t cert_tag_constructed = 0;\n\tuint8_t cert_tag_number = 0;\n\tuint8_t cert_tag_class = 0;\n\tuint8_t cert_tag_constructed = 0;\n\tuint8_t cert_tag_number = 0;\n\tuint8_t cert_tag_class = 0;\n\tuint8_t cert_tag_constructed = 0;\n\tuint8_t cert_tag_number = 0;\n\tuint8_t cert_tag_class = 0;\n\tuint8_t cert_tag_constructed = 0;\n\tuint8_t cert_tag_number = 0;\n\tuint8_t cert_tag_class = 0;\n\tuint8_t cert_tag_constructed = 0;\n\tuint8_t cert_tag_number = 0;\n\tuint8_t cert_tag_class = 0;\n\tuint8_t cert_tag_constructed = 0;\n\tuint8_t cert_tag_number = 0;\n\tuint8_t cert_tag_class = 0;\n\tuint8_t cert_tag_constructed = 0;\n\tuint8_t cert_tag_number = 0;\n\tuint8_t cert_tag_class = 0;\n\tuint8", "CodeBleu_score": 10.735676607256748}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\tint ret = 0;\n\tuint8_t* cert_data = NULL;\n\tsize_t cert_data_size = 0;\n\tuint8_t* cert_sn_256 = NULL;\n\tuint8_t cert_sn_256_comp[CERT_SN_256_SIZE];\n\tuint8_t cert_sn_comp[CERT_SN_SIZE];\n\tuint8_t* cert_template = NULL;\n\tsize_t cert_template_size = 0;\n\tuint8_t* cert_template_comp = NULL;\n\tsize_t cert_template_comp_size = 0;\n\tuint8_t* cert_sn = NULL;\n\tsize_t cert_sn_size = 0;\n\tuint8_t* cert_public_key = NULL;\n\tsize_t cert_public_key_size = 0;\n\tuint8_t* cert_comp = NULL;\n\tsize_t cert_comp_size = 0;\n\tuint8_t* cert = NULL;\n\tsize_t cert_size = 0;\n\tuint8_t* cert_ca_public_key = NULL;\n\tsize_t cert_ca_public_key_size = 0;\n\tuint8_t* cert_ca_comp = NULL;\n\tsize_t cert_ca_comp_size = 0;\n\tuint8_t* cert_ca = NULL;\n\tsize_t cert_ca_size = 0;\n\tuint8_t* cert_signer_id = NULL;\n\tsize_t cert_signer_id_size = 0;\n\tuint8_t* cert_signer_id_comp = NULL;\n\tsize_t cert_signer_id_comp_size = 0;\n\tuint8_t* cert_signer_id_256 = NULL;\n\tuint8_t cert_signer_id_256_comp[CERT_SIGNER_ID_SIZE];\n\tuint8_t* cert_tbs = NULL;\n\tsize_t cert_tbs_size = 0;\n\tuint8_t* cert_tbs_comp = NULL;\n", "CodeBleu_score": 11.353951948815656}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t\\tuint8_t* cert = build_state->cert;", "CodeBleu_score": 6.211943853259962}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n/*\n * The function \"atcacert_verify_cert_sw\" verifies a certificate using software only.", "CodeBleu_score": 10.178676880344293}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n}", "CodeBleu_score": 8.707806121624742}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n/*\n * The function \"atcacert_verify_cert_sw\" verifies a certificate using software crypto.", "CodeBleu_score": 10.180318633162463}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tbool result = false;\n\nif (list == NULL || *list == NULL || timer == NULL)\nreturn result;\n\nif (timer == *list)\n{\n*list = timer->next;\nresult = true;\n}\nelse\n{\ntimerStruct_t *cur = *list;\nwhile (cur != NULL && cur->next != timer)\ncur = cur->next;\nif (cur != NULL)\n{\ncur->next = timer->next;\nresult = true;\n}\n}\n\nreturn result;\n}", "CodeBleu_score": 37.72171881741351}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tbool found = false;\n\ttimerStruct_t *tmp = NULL;\n\ttimerStruct_t *prev = NULL;\n\ttimerStruct_t *next = NULL;\n\tif ((list == NULL) || (timer == NULL)) {\n\t\treturn false;\n\t}\n\ttmp = *list;\n\twhile (tmp != NULL) {\n\t\tif (tmp == timer) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\tprev = tmp;\n\t\ttmp = tmp->next;\n\t}\n\tif (found == true) {\n\t\tif (tmp == *list) {\n\t\t\t*list = (*list)->next;\n\t\t} else {\n\t\t\tprev->next = tmp->next;\n\t\t}\n\t\tfree(tmp);\n\t\ttmp = NULL;\n\t}\n\treturn found;\n}", "CodeBleu_score": 43.39641655485449}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tbool found = false;\n\ttimerStruct_t *cur = *list;\n\ttimerStruct_t *prev = NULL;\n\twhile (cur) {\n\t\tif (cur == timer) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = cur->next;\n\t\t\t} else {\n\t\t\t\t*list = cur->next;\n\t\t\t}\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\treturn found;\n}", "CodeBleu_score": 36.514540454255496}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tint status = BSD_SUCCESS;\n\tstruct socketInfo *sockInfo = NULL;\n\n\t// Check if the socket is valid\n\tif (socket < 0 || socket >= MAX_NUM_SOCKETS) {\n\t\t// Invalid socket\n\t\tprintError(ERR_INVALID_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\n\t// Retrieve the socket information\n\tsockInfo = getSocketInfo(socket);\n\tif (sockInfo == NULL) {\n\t\t// Invalid socket\n\t\tprintError(ERR_INVALID_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\n\t// Check if the socket is already closed\n\tif (sockInfo->state == NOT_A_SOCKET) {\n\t\t// Socket is already closed\n\t\tprintError(ERR_SOCKET_CLOSED);\n\t\treturn BSD_ERROR;\n\t}\n\n\t// Set the socket state to \"NOT_A_SOCKET\"\n\tsockInfo->state = NOT_A_SOCKET;\n\n\t// Attempt to close the socket\n\tif (close(socket) < 0) {\n\t\t// Error occurred\n\t\tstatus = BSD_ERROR;\n\t\tprintError(ERR_CLOSE);\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 45.542399841696415}, {"code": "int BSD_close(int socket){\n\t\tint status;\n\tstruct socketInfo *info;\n\n\t/* Retrieve the socket information. */\n\tinfo = getSocketInfo(socket);\n\n\t/* If the socket does not exist, return an error. */\n\tif (info == NULL) {\n\t\treturn (setErrNo(EBADF));\n\t}\n\n\t/* Set the socket state to \"NOT_A_SOCKET\". */\n\tinfo->state = NOT_A_SOCKET;\n\n\t/* Call the close function. */\n\tstatus = close(socket);\n\n\t/* If an error occurred, set the error number and return an error. */\n\tif (status < 0) {\n\t\treturn (setErrNo(errno));\n\t}\n\n\t/* Return success. */\n\treturn (BSD_SUCCESS);\n}", "CodeBleu_score": 21.998764204075695}, {"code": "int BSD_close(int socket){\n\t\tstruct socketInfo *sockInfo;\n\tint ret;\n\tsockInfo = getSocketInfo(socket);\n\tif (sockInfo == NULL) {\n\t\treturn BSD_ERROR;\n\t}\n\tsockInfo->state = NOT_A_SOCKET;\n\tret = close(socket);\n\tif (ret == -1) {\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 28.290679233966852}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint result;\n\n\tresult = listen(socket, backlog);\n\n\tif (result == -1) {\n\t\tBSD_setErrNoFromErrno();\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 19.139565706395825}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret = listen(socket, backlog);\n\tif (ret < 0) {\n\t\tBSD_setErrNoFromErrno();\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 14.844230468540365}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint response;\n\tresponse = listen(socket, backlog);\n\tif (response == -1) {\n\t\tBSD_setErrNoFromErrno();\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 19.567357272716585}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = -1;\n\tint family = -1;\n\tint addr_len = -1;\n\tint bsd_addr_len = -1;\n\tstruct sockaddr_in bsd_addr = {0};\n\tstruct sockaddr_in6 bsd_addr6 = {0};\n\tstruct sockaddr * bsd_addr_ptr = NULL;\n\tstruct sockaddr_in * bsd_addr_ptr_in = NULL;\n\tstruct sockaddr_in6 * bsd_addr_ptr_in6 = NULL;\n\tstruct bsd_sockaddr bsd_addr_ret = {0};\n\tstruct bsd_sockaddr * bsd_addr_ret_ptr = NULL;\n\n\t/*\n\t * Check the parameters.\n\t */\n\tif (socket < 0) {\n\t\terrno = EBADF;\n\t\tgoto cleanup;\n\t}\n\tif (addr == NULL) {\n\t\terrno = EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif (addrlen == NULL) {\n\t\terrno = EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Get the socket address family.\n\t */\n\tfamily = get_socket_family(socket);\n\tif (family < 0) {\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Get the socket address length.\n\t */\n\taddr_len = get_socket_addr_len(socket);\n\tif (addr_len < 0) {\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Check the address family.\n\t */\n\tif (family == AF_INET) {\n\t\tbsd_addr_ptr = (struct sockaddr *) &bsd_addr;\n\t\tbsd_addr_ptr_in = &bsd_addr;\n\t\tbsd_addr_len = sizeof(struct sockaddr_in);\n\t} else if (family == AF_INET6) {\n\t\tbsd_addr_ptr = (struct sockaddr *) &bsd_addr6;\n\t\tbsd_addr_ptr_in6 = &bsd_addr6;\n\t\tbsd_addr_len = sizeof(struct sockaddr_in6);\n\t} else {\n\t\terrno = EAFNOSUPPORT;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Call the accept function.\n\t */\n\tret = accept(socket", "CodeBleu_score": 39.4695842152647}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret;\n\tstruct sockaddr * addr_tmp;\n\tsocklen_t addrlen_tmp;\n\tsocklen_t addrlen_tmp_2;\n\tint family;\n\tint error;\n\n\tif (socket < 0) {\n\t\tBSD_setErrNo(EBADF);\n\t\treturn -1;\n\t}\n\n\tif (addr == NULL) {\n\t\tBSD_setErrNo(EFAULT);\n\t\treturn -1;\n\t}\n\n\tif (addrlen == NULL) {\n\t\tBSD_setErrNo(EFAULT);\n\t\treturn -1;\n\t}\n\n\tfamily = BSD_getSocketFamily(socket);\n\tif (family == AF_INET) {\n\t\taddr_tmp = (struct sockaddr *) addr;\n\t\taddrlen_tmp = *addrlen;\n\t\tret = accept(socket, addr_tmp, &addrlen_tmp);\n\t\tif (ret < 0) {\n\t\t\tBSD_setErrNo(BSD_getSocketError(socket));\n\t\t\treturn -1;\n\t\t}\n\t\t*addrlen = addrlen_tmp;\n\t\treturn ret;\n\t}\n\telse if (family == AF_INET6) {\n\t\taddr_tmp = (struct sockaddr *) addr;\n\t\taddrlen_tmp = *addrlen;\n\t\tret = accept(socket, addr_tmp, &addrlen_tmp);\n\t\tif (ret < 0) {\n\t\t\tBSD_setErrNo(BSD_getSocketError(socket));\n\t\t\treturn -1;\n\t\t}\n\t\t*addrlen = addrlen_tmp;\n\t\treturn ret;\n\t}\n\telse {\n\t\tBSD_setErrNo(EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n}", "CodeBleu_score": 45.55295302194623}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret;\n\tint family;\n\tstruct sockaddr *new_addr;\n\tsocklen_t new_addrlen;\n\tstruct bsd_sockaddr *bsd_addr;\n\tsocklen_t bsd_addrlen;\n\n\tif (socket < 0 || socket >= BSD_SOCKET_TABLE_SIZE || BSD_SOCKET_TABLE[socket].state == BSD_SOCKET_STATE_UNUSED) {\n\t\tBSD_SET_ERRNO(EBADF);\n\t\treturn -1;\n\t}\n\n\tfamily = BSD_SOCKET_TABLE[socket].domain;\n\tif (family == AF_INET) {\n\t\tif (addr == NULL || addrlen == NULL) {\n\t\t\tBSD_SET_ERRNO(EFAULT);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (addrlen < sizeof(struct bsd_sockaddr_in)) {\n\t\t\tBSD_SET_ERRNO(EINVAL);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbsd_addr = (struct bsd_sockaddr *) addr;\n\t\tbsd_addrlen = sizeof(struct bsd_sockaddr_in);\n\t\tnew_addr = (struct sockaddr *) &BSD_SOCKET_TABLE[socket].sockaddr_in;\n\t\tnew_addrlen = sizeof(struct sockaddr_in);\n\t} else if (family == AF_INET6) {\n\t\tif (addr == NULL || addrlen == NULL) {\n\t\t\tBSD_SET_ERRNO(EFAULT);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (addrlen < sizeof(struct bsd_sockaddr_in6)) {\n\t\t\tBSD_SET_ERRNO(EINVAL);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbsd_addr = (struct bsd_sockaddr *) addr;\n\t\tbsd_addrlen = sizeof(struct bsd_sockaddr_in6);\n\t\tnew_addr = (struct sockaddr *) &BSD_SOCKET_TABLE[socket].sockaddr_in6;\n\t\tnew_addrlen = sizeof(struct sockaddr_in6);\n\t} else {\n\t\tBSD_SET_ERRNO(EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\n\tret = accept(BSD_SOCKET_TABLE[socket].fd, new_addr, &new_addrlen);\n\tif (ret < 0) {", "CodeBleu_score": 37.58560467950701}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tint64_t current_time = time(NULL);\n\tif (current_time > 0) {\n\t\tupdateJWT(current_time);\n\t\tMQTT_CLIENT_connect();\n\t\tdebug_print(\"MQTT connected\");\n\t\tmqtt_subscribe = true;\n\t}\n}", "CodeBleu_score": 33.135080434856135}, {"code": "static void connectMQTT(){\n\t\t// Retrieve the current time in UNIX format\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\t// Check if the time is valid\n\tif (now.tv_sec < 0 || now.tv_sec > 2147483647) {\n\t\t// Invalid time\n\t\tprintf(\"Invalid time: %d\n\", now.tv_sec);\n\t\treturn;\n\t}\n\t// Update the JWT with the current time offset\n\tupdateJWT(now.tv_sec);\n\t// Initiate the MQTT connection\n\tMQTT_CLIENT_connect();\n\t// Print a debug message to indicate the connection attempt\n\tprintf(\"Attempting MQTT connection...\n\");\n\t// Set a flag to send an MQTT SUBSCRIBE packet once the connection is established\n\tsubscribeFlag = true;\n}", "CodeBleu_score": 46.35797580474079}, {"code": "static void connectMQTT(){\n\t\t// Get current time in UNIX format\n\ttime_t now = time(NULL);\n\n\t// Check if the time is valid\n\tif (now == (time_t)-1) {\n\t\t// If the time is invalid, print a debug message and return\n\t\tdebug_print(\"Failed to get current time\");\n\t\treturn;\n\t}\n\n\t// Update the JWT with the current time offset\n\tupdateJWT(now);\n\n\t// Initiate the MQTT connection\n\tMQTT_CLIENT_connect();\n\n\t// Set a flag to send an MQTT SUBSCRIBE packet once the connection is established\n\tmqtt_subscribe_flag = true;\n}", "CodeBleu_score": 26.995995284896434}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n\t\tMQTTClient_disconnect(client, 10000);\n\t\tdebug_printInfo(\"Disconnected from the cloud service\");\n\t}\n}", "CodeBleu_score": 57.95727732709845}, {"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_GetConnectionState() == MQTT_CONNECTED) {\n\t\tMQTTClient_disconnect(client);\n\t\tdebug_printError(\"MQTT Disconnected\");\n\t}\n}", "CodeBleu_score": 58.024476544099535}, {"code": "void CLOUD_disconnect(void){\n\t\tif (MQTT_GetConnectionState() == eMQTTConnectionState_Connected) {\n\t\tMQTT_ClientConnectionInfo_t connectionInfo;\n\t\tif (MQTT_GetClientConnectionInfo(&connectionInfo) == eMQTTSuccess) {\n\t\t\tMQTT_Disconnect(&connectionInfo);\n\t\t} else {\n\t\t\tdebug_printError(\"Error retrieving client connection info\");\n\t\t}\n\t}\n\tdebug_printInfo(\"Disconnecting from the cloud service\");\n}", "CodeBleu_score": 51.4076618042457}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tint8_t ret = M2M_SUCCESS;\n\tif (passed_wifi_creds) {\n\t\tret = m2m_wifi_connect(SSID_USED, sizeof(SSID_USED) - 1, wifi_auth, &wifi_creds);\n\t} else {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (M2M_SUCCESS != ret) {\n\t\tdebug_printError(\"ERROR: m2m_wifi_connect() failed with error code: %d\", ret);\n\t\tupdate_network_error_status(NETWORK_ERROR_WIFI_CONNECTION_FAILED);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 53.178814262006945}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\ttstrWifiInitParam param;\n\tmemset(&param, 0, sizeof(tstrWifiInitParam));\n\tparam.pfAppWifiCb = wifi_cb;\n\tif (passed_wifi_creds) {\n\t\t// Initialize Wi-Fi parameters structure\n\t\tstrcpy((char *)param.au8SSID, (char *)ssid);\n\t\tparam.u8SecType = wifi_security_type;\n\t\tstrcpy((char *)param.au8Password, (char *)password);\n\t}\n\t// Initialize the WINC Driver\n\tsint8 ret = m2m_wifi_init(&param);\n\tif (M2M_SUCCESS != ret) {\n\t\tdebug_printError(\"m2m_wifi_init call error!(%d)\", ret);\n\t\treturn false;\n\t}\n\t// Connect to the Wi-Fi AP\n\tif (passed_wifi_creds) {\n\t\tdebug_print(\"Connecting to AP: %s, type: %d, password: %s\", param.au8SSID, param.u8SecType, param.au8Password);\n\t} else {\n\t\tdebug_print(\"Connecting to default AP\");\n\t}\n\tret = m2m_wifi_connect();\n\tif (M2M_SUCCESS == ret) {\n\t\treturn true;\n\t} else {\n\t\tdebug_printError(\"m2m_wifi_connect call error!(%d)\", ret);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 48.8519294214993}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tint8_t ret;\n\tuint8_t wifi_creds = passed_wifi_creds;\n\ttstrM2MWifiCred m2m_wifi_cred;\n\tuint8_t wifi_connected = 0;\n\n\tif (wifi_creds == 0) {\n\t\t// Connect to the Wi-Fi access point using the default credentials.\n\t\tret = m2m_wifi_enable_default_wifi_connect();\n\t} else {\n\t\t// Connect to the Wi-Fi access point using the specified credentials.\n\t\tmemset((uint8_t *)&m2m_wifi_cred, 0, sizeof(tstrM2MWifiCred));\n\t\tm2m_wifi_cred.pfAppWifiCb = wifi_event_cb;\n\t\tm2m_wifi_cred.strSSID.u8Length = sizeof(SSID);\n\t\tmemcpy(m2m_wifi_cred.strSSID.au8SSID, SSID, m2m_wifi_cred.strSSID.u8Length);\n\t\tm2m_wifi_cred.strPassword.u8Length = sizeof(PASSWORD);\n\t\tmemcpy(m2m_wifi_cred.strPassword.au8Password, PASSWORD, m2m_wifi_cred.strPassword.u8Length);\n\t\tm2m_wifi_cred.u8SecType = M2M_WIFI_SEC_WPA_PSK;\n\t\tm2m_wifi_cred.u8AuthType = M2M_WIFI_AUTH_WPA_PSK;\n\t\tret = m2m_wifi_connect(&m2m_wifi_cred);\n\t}\n\n\tif (M2M_SUCCESS == ret) {\n\t\t// Wi-Fi is connected.\n\t\twifi_connected = 1;\n\t} else {\n\t\t// Wi-Fi is not connected.\n\t\twifi_connected = 0;\n\t\tdebug_printError(\"ERROR: Failed to connect to Wi-Fi access point: %d\", ret);\n\t}\n\n\treturn wifi_connected;\n}", "CodeBleu_score": 45.64074688897664}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tconst client = new ApolloClient({\nuri: \"https://api.sensor.community/v1/graphql\",\n});\ntry {\nconst response = await client.query({\nquery: gql`\nquery listSensors {\nlistSensors {\nid\nname\ndescription\ngeo {\nlatitude\nlongitude\n}\n}\n}\n`,\n});\nconsole.log(response.data.listSensors);\nresponse.data.listSensors.forEach(sensor => {\nconst marker = document.createElement(\"div\");\nmarker.className = \"marker\";\nmarker.id = sensor.id;\nnew Marker({ element: marker })\n.setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n.addTo(map);\n});\n} catch (error) {\nconsole.log(error);\n}\n}", "CodeBleu_score": 46.773764508352286}, {"code": "async function DisplaySensors(map){\n\tconst client = new ApolloClient({", "CodeBleu_score": 2.4518518849750635}, {"code": "async function DisplaySensors(map){\n\tconst client = new ApolloClient({\nuri: \"https://api.sensor.community/v1/graphql/\",\n});\nconst response = await client.query({\nquery: listSensors,\n});\nconsole.log(response);\nif (response.data.listSensors) {\nconsole.log(\"Retrieved sensors:\");\nresponse.data.listSensors.forEach(sensor => {\nconsole.log(sensor);\nconst marker = document.createElement(\"div\");\nmarker.className = \"marker\";\nconst sensorMarker = new Marker({\nelement: marker,\n});\nsensorMarker.setLngLat([sensor.geo.longitude, sensor.geo.latitude]);\nsensorMarker.addTo(map);\n});\n}\n}", "CodeBleu_score": 48.94019237178113}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\")\n\tmarker.id = sensor.id\n\tmarker.className = \"sensor-marker\"\n\tmarker.style.backgroundColor = sensor.color\n\tmarker.style.border = \"1px solid black\"\n\tmarker.style.width = \"10px\"\n\tmarker.style.height = \"10px\"\n\tmarker.style.borderRadius = \"5px\"\n\tmarker.style.position = \"absolute\"\n\tmarker.style.left = sensor.x + \"px\"\n\tmarker.style.top = sensor.y + \"px\"\n\tmarker.style.zIndex = 1\n\treturn marker\n}", "CodeBleu_score": 42.34220210744476}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\t// Create the marker element\n\tconst marker = document.createElement(\"div\");\n\t// Set the marker's id\n\tmarker.id = sensor.id;\n\t// Assign the marker a specific class name\n\tmarker.className = \"sensor-marker\";\n\t// Set the marker's style\n\tmarker.style.backgroundColor = \"white\";\n\tmarker.style.border = \"solid 2px black\";\n\t// Return the marker\n\treturn marker;\n}", "CodeBleu_score": 43.23853240034388}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor\";\n\tmarker.style.backgroundColor = \"#000000\";\n\tmarker.style.border = \"1px solid #000000\";\n\treturn marker;\n}", "CodeBleu_score": 42.18724176959788}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    _LOGGER.debug(\"Attempting to load MFA module '%s'...\", module_name)\n    module_path = f\"homeassistant.auth_providers.mfa.{module_name}\"\n    module = await async_import_module(hass, module_path)\n    if not hasattr(module, \"AUTH_PROVIDER_SCHEMA\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'AUTH_PROVIDER_SCHEMA'\")\n    if not hasattr(module, \"async_setup\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'async_setup'\")\n    if not hasattr(module, \"async_setup_flow\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'async_setup_flow'\")\n    if not hasattr(module, \"async_validate_login\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'async_validate_login'\")\n    if not hasattr(module, \"async_get_setup_flow\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'async_get_setup_flow'\")\n    if not hasattr(module, \"async_get_auth_flow\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'async_get_auth_flow'\")\n    if not hasattr(module, \"async_get_mfa_setup_flow\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'async_get_mfa_setup_flow'\")\n    if not hasattr(module, \"async_get_mfa_auth_flow\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'async_get_mfa_auth_flow'\")\n    if not hasattr(module, \"async_get_register_flow\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'async_get_register_flow'\")\n    if not hasattr(module, \"async_get_setup_flow\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'async_get_setup_flow'\")\n    if not hasattr(module, \"async_get_user_id\"):\n        raise HomeAssistantError(f\"Module '{module_name}' does not define 'async_get_user_id'\")\n   ", "CodeBleu_score": 21.11917027390274}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth.mfa_{module_name}\"\n    module = await async_import_module(hass, module_path)\n    if not module:\n        raise HomeAssistantError(f\"MFA module {module_name} could not be found\")\n    if not hasattr(module, \"async_setup\"):\n        raise HomeAssistantError(\n            f\"MFA module {module_name} does not define async_setup\"\n        )\n    return module\n\n", "CodeBleu_score": 22.955682920508192}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    try:\n        module_path = f\"{MFA_MODULE_PATH}.{module_name}\"\n        module = await hass.async_add_executor_job(importlib.import_module, module_path)\n        return module\n    except ImportError as error:\n        _LOGGER.error(\n            \"Failed to import multi-factor authentication (MFA) module %s: %s\",\n            module_name,\n            error,\n        )\n        raise HomeAssistantError(\n            f\"Failed to import multi-factor authentication (MFA) module {module_name}\"\n        ) from error\n\n", "CodeBleu_score": 32.747353372732846}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if not setup_data:\n        return False\n\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        return False\n\n    user_data = await self.async_get_user_data(user_id)\n    if user_data:\n        user_data[\"pin\"] = pin\n        await self.async_set_user_data(user_id, user_data)\n        return True\n\n    user_data = {\"pin\": pin}\n    await self.async_set_user_data(user_id, user_data)\n    return True\n\n", "CodeBleu_score": 36.83336838057149}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        raise InvalidSetupDataError(\"No PIN provided\")\n    for entry in self._data:\n        if entry.user_id == user_id:\n            entry.pin = pin\n            return\n    self._data.append(MFAUserData(user_id, pin))\n\n", "CodeBleu_score": 40.146555366670015}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Extract the PIN from the setup data\n    pin = setup_data.get(\"pin\")\n    # Check if the user already has an entry in the data list\n    for index, entry in enumerate(self.data):\n        if entry.get(\"user_id\") == user_id:\n            # Update the PIN\n            self.data[index][\"pin\"] = pin\n            break\n    else:\n        # Add a new entry to the data list\n        self.data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 42.959090183352565}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    if not self._initialized:\n        async with self._initialization_lock:\n            if not self._initialized:\n                try:\n                    data = await self.data.async_load()\n                except FileNotFoundError:\n                    data = {}\n\n                if not data:\n                    data = {}\n\n                for user_id, user_data in data.items():\n                    self._settings[user_id] = NotifySetting(user_id, user_data)\n\n                self._initialized = True\n\n", "CodeBleu_score": 30.020701946721047}, {"code": "async def _async_load(self) -> None\n\t\n    if self._async_lock.locked():\n        return\n    async with self._async_lock:\n        if self._loaded:\n            return\n        self._loaded = True\n        if not self._store.async_is_empty():\n            data = await self._store.async_load()\n        else:\n            data = {}\n        if not data:\n            data = {}\n        self._settings = {\n            user_id: NotifySetting(\n                user_id,\n                data.get(user_id, {}).get(\"enabled\", True),\n                data.get(user_id, {}).get(\"channels\", []),\n            )\n            for user_id in self._user_ids\n        }\n\n", "CodeBleu_score": 37.391659208747896}, {"code": "async def _async_load(self) -> None\n\t\n    if self._initialized:\n        return\n\n    async with self._initialization_lock:\n        if self._initialized:\n            return\n\n        if self._store.empty:\n            self._settings = {}\n        else:\n            data = await self._store.async_load()\n            self._settings = {\n                user_id: NotifySetting.from_dict(data.get(user_id))\n                for user_id in data.get(\"users\", [])\n            }\n\n        self._initialized = True\n", "CodeBleu_score": 38.898644442367235}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    if user_id not in self._data:\n        return False\n    settings = self._data[user_id]\n    if settings is None:\n        return False\n    if user_input[CONF_OTP] != settings[\"otp\"]:\n        return False\n    return True\n\n", "CodeBleu_score": 41.74968086550051}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    if user_id not in self._settings:\n        return False\n    if \"otp_secret\" not in user_input:\n        return False\n    try:\n        await async_validate_user_input(user_input[\"otp_secret\"])\n    except ValueError:\n        return False\n    return True\n\n", "CodeBleu_score": 37.1482522111415}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    if user_id not in self._users:\n        return False\n    settings = self._users[user_id]\n    if settings.get(CONF_OTP_KEY) is None:\n        return False\n    otp = user_input.get(CONF_OTP_KEY)\n    if otp is None:\n        return False\n    return await async_add_executor_job(validate, settings[CONF_OTP_KEY], otp)\n\n", "CodeBleu_score": 49.45857581319948}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.async_get_entity(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.async_get_device(entity_entry.device_id)\n    if device_entry is None or device_entry.area_id is None:\n        return None\n    area_id = device_entry.area_id\n    area_entry = perm_lookup.async_get_area(area_id)\n    if area_entry is None:\n        return None\n    area_key = area_entry.key\n    return area_dict.get(area_key)\n\n", "CodeBleu_score": 68.59129149939726}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.async_get_entity_entry(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.async_get_device_entry(entity_entry.device_id)\n    if device_entry is None or device_entry.area_id is None:\n        return None\n    area_id = device_entry.area_id\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 69.719996338743}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 71.85350694065305}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for p in policies:\n        for category, rules in p.items():\n            if category not in seen:\n                seen.add(category)\n                policy.setdefault(category, []).extend(rules)\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 45.424514529778136}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy = PolicyType()\n    seen = set()\n    for p in policies:\n        for category, value in p.items():\n            if category not in seen:\n                seen.add(category)\n                policy[category] = value\n            else:\n                policy[category] = merge_values(policy[category], value)\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 39.4879715351218}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_ in policies:\n        for category, rules in policy_.items():\n            if category not in seen:\n                seen.add(category)\n                policy[category] = rules\n            else:\n                policy[category] = merge_rules(policy[category], rules)\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 51.5270575230127}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        provider_module = await async_import_module(f\"homeassistant.auth_providers.{provider}\")\n    except ImportError:\n        _LOGGER.error(\"Unable to find auth provider %s\", provider)\n        raise HomeAssistantError(f\"Unable to find auth provider {provider}\")\n    if not hasattr(provider_module, \"REQUIREMENTS\"):\n        return provider_module\n    processed = set()\n    requirements = await async_process_requirements(hass, provider_module.REQUIREMENTS)\n    for req in requirements:\n        processed.add(req)\n    return provider_module\n\n", "CodeBleu_score": 35.12169110255164}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth_providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to load authentication provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            f\"Unable to load authentication provider {provider}\"\n        ) from err\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if provider in processed:\n        return module\n    processed.add(provider)\n    await requirements.async_process_requirements(hass, provider, module.REQUIREMENTS)\n    return module\n\n", "CodeBleu_score": 47.23174550697289}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in processed:\n        return None\n    try:\n        module = await async_import_module(f\"homeassistant.auth_providers.{provider}\")\n    except ImportError:\n        _LOGGER.error(\n            \"Unable to find authentication provider %s\",\n            provider,\n        )\n        raise HomeAssistantError()\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    for requirement in module.REQUIREMENTS:\n        if requirement in processed:\n            continue\n        processed.add(requirement)\n        await load_auth_provider_module(hass, requirement)\n    return module\n", "CodeBleu_score": 40.617180099923274}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    try:\n        _LOGGER.debug(\"Loading data from store\")\n        data = await self._store.async_load()\n        if not data:\n            _LOGGER.debug(\"No data found in store, initializing empty data\")\n            data = {\"users\": []}\n        self._users = data[\"users\"]\n        self._async_check_for_not_normalized_usernames()\n        _LOGGER.debug(\"Data loaded from store\")\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Could not load data from store: %s\", err)\n\n", "CodeBleu_score": 35.77481946968181}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        with open(self._store_path, \"r\") as store:\n            self._users = json.load(store)\n    except FileNotFoundError:\n        self._users = []\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 28.95218802276549}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        with open(self._store_path, \"r\") as store:\n            self._users = json.load(store)\n    except FileNotFoundError:\n        self._users = []\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 28.95218802276549}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b'', bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = base64.b64decode(user.password_hash)\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth(\"Invalid username\")\n    else:\n        raise InvalidAuth(\"Invalid username and password\")\n", "CodeBleu_score": 40.02804892379983}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b'', bcrypt.gensalt())\n    for user in self.users:\n        if user.username == normalized_username:\n            stored_hash = user.password\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth(\"Invalid username\")\n    else:\n        raise InvalidAuth(\"Invalid username and password\")\n\n", "CodeBleu_score": 37.03484627870206}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b'', bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), user.password_hash):\n                return\n            else:\n                raise InvalidAuth\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth\n    else:\n        raise InvalidAuth\n", "CodeBleu_score": 38.12754191004425}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for index, user in enumerate(self.users):\n        if user.username == username:\n            self.users.pop(index)\n            return\n    raise InvalidUser(f\"User {username} not found\")\n", "CodeBleu_score": 34.78148235154786}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    self.users.pop(username)\n\n", "CodeBleu_score": 24.664428813842715}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    self.users.pop(username)\n\n", "CodeBleu_score": 24.664428813842715}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        await self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.data[\"username\"])\n        await self.async_save()\n    except:\n        pass\n\n", "CodeBleu_score": 44.79469234889194}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        self.data = {}\n\n    if self.data.get(CONF_USERNAME) == credentials.data.get(CONF_USERNAME):\n        try:\n            await self.async_remove_auth(credentials)\n            await self.async_save()\n        except HomeAssistantError:\n            pass\n", "CodeBleu_score": 42.12710273965208}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._initialized:\n        self.async_initialize()\n    try:\n        await self.async_remove_auth(credentials.data[\"username\"])\n        await self.async_save()\n    except InvalidAuth:\n        pass\n\n", "CodeBleu_score": 49.236191976285596}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    start = time.time()\n    for thread in threads:\n        thread_timeout = timeout - (time.time() - start)\n        if thread_timeout <= 0:\n            break\n        if thread.is_alive():\n            try:\n                thread.join(thread_timeout)\n            except RuntimeError:\n                pass\n            if thread.is_alive():\n                if log:\n                    _log_thread_running_at_shutdown(thread)\n                joined.add(thread)\n    for thread in threads:\n        if thread.is_alive():\n            try:\n                async_raise(thread.ident, SystemExit)\n            except (ValueError, TypeError):\n                pass\n    return joined\n\n", "CodeBleu_score": 48.43757968464549}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    if timeout is None:\n        timeout = 300\n    if not threads:\n        return set()\n    joined = set()\n    threads_to_join = set(threads)\n    start = time.time()\n    while threads_to_join:\n        current_time = time.time()\n        if current_time - start >= timeout:\n            break\n        for thread in set(threads_to_join):\n            if thread.is_alive():\n                if thread.ident is not None:\n                    thread.join(timeout=max(0, timeout - (current_time - start)))\n                else:\n                    joined.add(thread)\n                    threads_to_join.remove(thread)\n            else:\n                joined.add(thread)\n                threads_to_join.remove(thread)\n    if log:\n        for thread in threads_to_join:\n            _log_thread_running_at_shutdown(thread)\n    for thread in threads_to_join:\n        async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 49.24722604744858}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    # Calculate the timeout for each thread\n    thread_timeouts = {\n        thread: timeout / len(threads) for thread in threads if thread.is_alive()\n    }\n    # Join threads\n    for thread in thread_timeouts:\n        thread.join(thread_timeouts[thread])\n    # Get threads that were not joined\n    unjoined = threads - set(thread_timeouts)\n    # Add threads that were not joined to the joined set\n    joined.update(unjoined)\n    # Log threads that are still running\n    if log:\n        _log_thread_running_at_shutdown(unjoined)\n    # Attempt to raise a SystemExit exception in any remaining threads\n    for thread in unjoined:\n        async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 52.38802775392517}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    # pylint: disable=global-statement\n    global SHUTDOWN_TIMEOUT\n    SHUTDOWN_TIMEOUT = max(0, SHUTDOWN_TIMEOUT)\n    if SHUTDOWN_TIMEOUT <= 0:\n        return\n    # pylint: enable=global-statement\n    _LOGGER.debug(\"Shutting down in %s seconds\", SHUTDOWN_TIMEOUT)\n    # pylint: disable=protected-access\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()\n    ]\n    # pylint: enable=protected-access\n    if not threads:\n        return\n    # pylint: disable=protected-access\n    timeout = SHUTDOWN_TIMEOUT / len(threads)\n    # pylint: enable=protected-access\n    for thread in threads:\n        thread.join(timeout=timeout)\n        if thread.is_alive():\n            _LOGGER.warning(\"Failed to join thread %s\", thread.name)\n", "CodeBleu_score": 57.85948711255525}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # pylint: disable=global-statement\n    global SHUTDOWN_TIMEOUT\n    # pylint: enable=global-statement\n    remaining_threads = [\n        thread for thread in threading.enumerate() if not thread.is_alive()\n    ]\n    if remaining_threads:\n        SHUTDOWN_TIMEOUT = SHUTDOWN_TIMEOUT / len(remaining_threads)\n        for thread in remaining_threads:\n            try:\n                thread.join(timeout=SHUTDOWN_TIMEOUT)\n            except RuntimeError:\n                _LOGGER.warning(\n                    \"Failed to join thread %s within %s seconds.\",\n                    thread.name,\n                    SHUTDOWN_TIMEOUT,\n                )\n", "CodeBleu_score": 43.44136362995312}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # pylint: disable=global-statement\n    global _SHUTDOWN_TIMEOUT\n    global _SHUTDOWN_EVENT\n    global _LOGGER\n    if _SHUTDOWN_TIMEOUT is None:\n        return\n    _LOGGER.debug(\"Performing deadlock-safe shutdown\")\n    _LOGGER.debug(\"Identifying non-main, non-daemon, alive threads\")\n    threads = [\n        thread\n        for thread in threading.enumerate()\n        if not thread.is_alive()\n        and not thread.name == \"MainThread\"\n        and not thread.daemon\n    ]\n    _LOGGER.debug(\"Identified %s non-main, non-daemon, alive threads\", len(threads))\n    _LOGGER.debug(\"Calculating timeout per thread\")\n    timeout_per_thread = _SHUTDOWN_TIMEOUT / len(threads)\n    _LOGGER.debug(\"Calculated timeout per thread: %s\", timeout_per_thread)\n    _LOGGER.debug(\"Joining threads\")\n    for thread in threads:\n        try:\n            thread.join(timeout=timeout_per_thread)\n        except RuntimeError as exception:\n            _LOGGER.warning(\n                \"Failed to join thread %s within timeout: %s\", thread.name, exception\n            )\n        else:\n            if thread.is_alive():\n                _LOGGER.warning(\"Thread %s failed to join within timeout\", thread.name)\n    _LOGGER.debug(\"Shutdown complete\")\n\n", "CodeBleu_score": 44.6915683041169}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        _async_dispatcher_send_internal(self.hass, self._setup_dispatch_signal, remaining_with_setup_started)\n    self._remaining_with_setup_started = remaining_with_setup_started != {}\n", "CodeBleu_score": 42.62271325167269}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        _async_dispatcher_send_internal(self.hass, SIGNAL_REMAINING_SETUPS, remaining_with_setup_started)\n    else:\n        _async_dispatcher_send_internal(self.hass, SIGNAL_REMAINING_SETUPS, {})\n    self._remaining_with_setup_started = remaining_with_setup_started\n", "CodeBleu_score": 44.78384919845778}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self._setup_state != {} or remaining_with_setup_started != {}:\n        _async_dispatcher_send_internal(self._hass, self._signal_internal, remaining_with_setup_started)\n    self._setup_state = remaining_with_setup_started\n", "CodeBleu_score": 50.24677125259214}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.specific_integrations:\n        # If the user only wants to validate a few integrations,\n        # we can generate the content for all of them and then filter it.\n        generate_and_validate(integrations, config)\n        validate_integrations(integrations, config)\n    else:\n        # Otherwise, we have to read the current content of bluetooth.py\n        # and compare it with the generated content.\n        validate_file(integrations, config)\n\n", "CodeBleu_score": 15.699291733981239}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.error_on_generated:\n        config.add_error(\n            \"bluetooth.py is generated, please do not modify it. \"\n            \"Use `python3 -m homeassistant --script check_config` to check the generated file.\"\n        )\n        return\n\n    if not integrations:\n        return\n\n    if \"bluetooth\" in integrations:\n        config.cache[\"bluetooth\"] = generate_and_validate(config)\n        return\n\n    # If bluetooth integration is not being validated,\n    # read the current content of bluetooth.py and compare it with the generated content.\n    if \"bluetooth\" in config.cache:\n        return\n\n    config.cache[\"bluetooth\"] = fp.read()\n    if generate_and_validate(config) != config.cache[\"bluetooth\"]:\n        config.add_error(\n            \"The content of bluetooth.py is not up to date. \"\n            \"Run python3 -m homeassistant --script check_config to check the generated file.\",\n            fixable=True,\n        )\n\n", "CodeBleu_score": 39.69511207544321}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.integrations is None or config.integrations.get(\"bluetooth\") is None:\n        config.add_error(\n            \"bluetooth\",\n            \"Integrations 'bluetooth' is missing from 'integrations' key in configuration.yaml\",\n            \"Add 'bluetooth' to your 'integrations' key in configuration.yaml\",\n            \"integrations: !include_dir_merge_named ../integrations\",\n            \"integrations:\n  bluetooth: !include bluetooth.yaml\",\n        )\n        return\n    if config.core.disabled_integrations is not None and \"bluetooth\" in config.core.disabled_integrations:\n        return\n    if config.config_type == ConfigType.CUSTOMIZE:\n        return\n    if config.config_type == ConfigType.YAML:\n        config.cache[\"bluetooth\"] = config.config[\"bluetooth\"]\n        return\n    if config.config_type == ConfigType.CORE:\n        if config.core.generated is None:\n            config.add_error(\n                \"bluetooth\",\n                \"The content of bluetooth.py is not generated by HACS. Something is wrong.\",\n                \"Reinstall HACS after making a backup of your 'custom_components/bluetooth.py' file\",\n                \"Remove the file 'custom_components/bluetooth.py'\",\n            )\n            return\n        if \"bluetooth\" in config.core.generated:\n            config.cache[\"bluetooth\"] = config.core.generated[\"bluetooth\"]\n            return\n    if config.config_type == ConfigType.PLUGIN:\n        if config.plugin.generated is None:\n            config.add_error(\n                \"bluetooth\",\n                \"The content of bluetooth.py is not generated by HACS. Something is wrong.\",\n                \"Reinstall HACS after making a backup of your 'custom_components/bluetooth.py' file\",\n                \"Remove the file 'custom_components/bluetooth.py'\",\n            )\n            return\n        if \"bluetooth\" in config.plugin.generated:\n            config.cache[\"bluetooth\"] = config.plugin.generated[\"bluetooth\"]\n            return\n    if config.config_type == ConfigType.NETDAEMON:\n        config.add_error(\n            \"bluetooth\",\n            \"The content of bluetooth.py is not generated by HACS. Something is wrong.\",\n            \"Reinstall HACS after making a backup of your 'custom_components/bluetooth.py' file\",\n            \"Remove the file 'custom_components/bluetooth.py'\",\n        )\n        return\n    if config.config_", "CodeBleu_score": 29.919483179822837}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create a new Resty client\n\tclient := base.RestyClient.R()\n\n\t// Set the result and error objects\n\tvar resp base.TokenResponse\n\tvar e base.TokenError\n\n\t// Set the request parameters\n\tclient.SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.TokenURL)\n\n\t// Check if there was an error\n\tif e.Error != \"\" {\n\t\t// Log the error\n\t\tlogger.Error(fmt.Sprintf(\"Error refreshing access token: %s\", e.Error))\n\n\t\t// Return the error\n\t\treturn errors.New(e.Error)\n\t}\n\n\t// Update the access token\n\td.AccessToken = resp.AccessToken\n\n\t// Log the refresh\n\tlogger.Info(fmt.Sprintf(\"Successfully refreshed access token: %s\", d.AccessToken))\n\n\t// Return nil\n\treturn nil\n}", "CodeBleu_score": 64.31110528302311}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t\tScope       string `json:\"scope\"`\n\t}\n\te := error(nil)\n\tbase.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.TokenURL)\n\tif e != nil {\n\t\tlogger.Error(e)\n\t\treturn e\n\t}\n\td.AccessToken = resp.AccessToken\n\td.TokenType = resp.TokenType\n\td.ExpiresIn = resp.ExpiresIn\n\td.Scope = resp.Scope\n\tlogger.Info(\"Refreshed access token\")\n\treturn nil\n}", "CodeBleu_score": 58.97795118651271}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp base.TokenResponse\n\tvar e error\n\n\t// Send the request to the OAuth2 token endpoint with the refresh token, app key, and app secret.\n\tif e = base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(base.TokenEndpoint); e != nil {\n\t\t// If the request fails, log the response and return an error.\n\t\tlogger.Error(e.Error())\n\t\treturn e\n\t}\n\n\t// Update the access token.\n\td.AccessToken = resp.AccessToken\n\n\t// Return nil to indicate success.\n\treturn nil\n}", "CodeBleu_score": 55.254876726444294}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetHeader(\"Content-Type\", \"application/json\")\n\treq.SetHeader(\"Accept\", \"application/json\")\n\treq.SetHeader(\"User-Agent\", \"Golang Google Drive SDK\")\n\treq.SetError(Error{})\n\treq.SetResult(resp)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"fields\", \"kind, nextPageToken, incompleteSearch, files(id, name, mimeType, parents, size, modifiedTime, createdTime, ownedByMe, capabilities, teamDriveId, driveId, trashed, capabilities, capabilities.canShare, capabilities.canTrash, capabilities.canUntrash, capabilities.canDeleteChildren, capabilities.canRename, capabilities.canMoveChildrenOutOfDrive, capabilities.canMoveChildrenOutOfTeamDrive, capabilities.canMoveChildrenIntoTeamDrive, capabilities.canMoveChildrenIntoDrive, capabilities.canAddChildren, capabilities.canShareWithinOrg, capabilities.canShareWithDomain, capabilities.canShareWithAnyone, capabilities.canMoveItemIntoTeamDrive, capabilities.canMoveItemOutOfTeamDrive, capabilities.canMoveItemOutOfDrive, capabilities.canMoveItemIntoDrive, capabilities.canReadRevisions, capabilities.canReadTeamDrive, capabilities.canListChildren, capabilities.canModifyContent, capabilities.canModifyContent, capabilities.canCopy, capabilities.canTrashChildren, capabilities.canListChildren, capabilities.canChangeRestrictedDownload, capabilities.canDownload, capabilities.canComment)\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tvar err error\n\tfor i := 0; i < 2; i++ {\n\t\tresp, err = req.Execute(method, url)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err.Error() == \"401 Unauthorized\" {\n\t\t\td.refreshToken()\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp.Body(), nil\n}", "CodeBleu_score": 46.42502752604794}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R()\n\treq.SetHeader(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.accessToken))\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetError(func(resp *resty.Response, err error) error {\n\t\tif resp.StatusCode() == http.StatusUnauthorized {\n\t\t\td.refreshToken()\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn err\n\t})\n\treq.SetResult(resp)\n\tif callback != nil {\n\t\treturn callback(req)\n\t}\n\treturn req.Execute(method, url)\n}", "CodeBleu_score": 43.22554519718276}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := d.client.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetHeader(\"Content-Type\", \"application/json\")\n\treq.SetHeader(\"Accept\", \"application/json\")\n\treq.SetHeader(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"X-Upload-Content-Length\", \"0\")\n\treq.SetHeader(\"X-File-Name\", \"\")\n\treq.SetHeader(\"X-Delete-Content-Length\", \"0\")\n\treq.SetHeader(\"X-Delete-Content-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"X-Delete-File-Name\", \"\")\n\treq.SetHeader(\"X-Update-Content-Length\", \"0\")\n\treq.SetHeader(\"X-Update-Content-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"X-Update-File-Name\", \"\")\n\treq.SetHeader(\"X-Upload-Content-Length\", \"0\")\n\treq.SetHeader(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"X-Upload-File-Name\", \"\")\n\treq.SetHeader(\"X-Upload-Content-Length\", \"0\")\n\treq.SetHeader(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"X-Upload-File-Name\", \"\")\n\treq.SetHeader(\"X-Upload-Content-Length\", \"0\")\n\treq.SetHeader(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"X-Upload-File-Name\", \"\")\n\treq.SetHeader(\"X-Upload-Content-Length\", \"0\")\n\treq.SetHeader(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"X-Upload-File-Name\", \"\")\n\treq.SetHeader(\"X-Upload-Content-Length\", \"0\")\n\treq.SetHeader(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.SetHeader(\"X-Upload-File-Name\", \"\")\n\treq.SetHeader(\"X-Upload-", "CodeBleu_score": 17.56957961456695}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tvar (\n\t\tchunkSize int64\n\t\tfinish    int64\n\t)\n\tchunkSize = stream.GetChunkSize()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tfinish += chunkSize\n\t\t\tif finish > stream.GetSize() {\n\t\t\t\tfinish = stream.GetSize()\n\t\t\t}\n\t\t\treq := d.request(ctx, http.MethodPut, url)\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish-chunkSize, finish-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t\tif err := req.Do(nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif finish == stream.GetSize() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 49.83724575267634}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size.\n\tchunkSize := d.chunkSize\n\tif chunkSize == 0 {\n\t\tchunkSize = d.defaultChunkSize\n\t}\n\tif chunkSize > stream.GetSize() {\n\t\tchunkSize = stream.GetSize()\n\t}\n\n\t// Upload each chunk.\n\tfinish := int64(0)\n\tfor {\n\t\t// Check for context cancellation.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Upload the chunk.\n\t\terr := d.uploadChunk(ctx, stream, url, finish, chunkSize)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Update the finish position.\n\t\tfinish += chunkSize\n\n\t\t// Check if the entire file is uploaded.\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.09148004895991}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size\n\tchunkSize := d.calculateChunkSize(stream)\n\n\t// Upload the file in chunks\n\tfinish := int64(0)\n\tfor {\n\t\t// Check if the upload is cancelled\n\t\tif utils.IsCanceled(ctx) {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Upload the chunk\n\t\tif err := d.uploadChunk(ctx, stream, url, finish, chunkSize); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Update the uploaded size\n\t\tfinish += chunkSize\n\n\t\t// Check if the upload is complete\n\t\tif finish >= stream.GetSize() {\n\t\t\treturn nil\n\t\t}\n\t}\n}", "CodeBleu_score": 28.407951041537842}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind the JSON data from the request context to a StorageConfig struct.\n\tvar config storage.StorageConfig\n\tif err := ctx.Bind(&config); err != nil {\n\t\treturn common_err.GetMsg(ctx, err)\n\t}\n\n\t// Check if the mount point is empty.\n\tif config.MountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"mount_point cannot be empty\")\n\t}\n\n\t// Attempt to unmount the storage.\n\tif err := service.MyService.Storage().UnmountStorage(config.MountPoint); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete the configuration.\n\tif err := service.MyService.Storage().DeleteConfigByName(config.Name); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"status\": \"success\"})\n}", "CodeBleu_score": 37.295198556372476}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Binds JSON data from the request context\n\tif err := ctx.Bind(new(UnmountStorageJSONRequestBody)); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequestError(err))\n\t}\n\t// Retrieves the \"mount_point\" value\n\tmountPoint := ctx.Get(\"mount_point\")\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequestError(\"mount_point cannot be empty\"))\n\t}\n\t// Attempts to unmount the storage at the specified mount point\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err))\n\t}\n\t// Deletes the corresponding configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err))\n\t}\n\t// Returns a success response\n\treturn ctx.JSON(http.StatusOK, SuccessResponse{Success: true})\n}", "CodeBleu_score": 44.56599691383273}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind the JSON data from the request context.\n\tvar json Bind\n\tif err := ctx.Bind(&json); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err, ctx))\n\t}\n\n\t// Retrieve the \"mount_point\" value.\n\tmountPoint := json.MountPoint\n\n\t// If the mount point is empty, return a client error response.\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err, ctx))\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err, ctx))\n\t}\n\n\t// Delete the corresponding configuration and return a success response.\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err, ctx))\n\t}\n\treturn ctx.JSON(http.StatusOK, \"Unmounted \"+mountPoint)\n}", "CodeBleu_score": 46.39087688738202}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\t// If the path is missing, return an error.\n\t\treturn ctx.JSON(\n\t\t\thttp.StatusBadRequest,\n\t\t\tcommon_err.NewBadRequestError(\n\t\t\t\t\"the path is missing\",\n\t\t\t),\n\t\t)\n\t}\n\n\t// Check if the file exists.\n\tif !file.Exists(filePath) {\n\t\t// If the file does not exist, return an error.\n\t\treturn ctx.JSON(\n\t\t\thttp.StatusNotFound,\n\t\t\tcommon_err.NewNotFoundError(\n\t\t\t\t\"the file does not exist\",\n\t\t\t),\n\t\t)\n\t}\n\n\t// If the file exists, return the file to the client.\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 34.91583924056712}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"filePath\")\n\n\t// Check if the path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrPathMissing))\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.ErrFileMissing))\n\t}\n\n\t// Open the file\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrInternal))\n\t}\n\tdefer file.Close()\n\n\t// Create a response writer\n\tw := ctx.Response()\n\n\t// Copy the file to the response writer\n\t_, err = io.Copy(w, file)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(common_err.ErrInternal))\n\t}\n\n\t// Set the content type\n\tw.Header().Set(echo.HeaderContentType, mime.TypeByExtension(filepath.Ext(filePath)))\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.ErrSuccess))\n}", "CodeBleu_score": 43.20198673214819}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.NewBadRequestError(\"Missing path parameter\"))\n\t}\n\n\t// Check if the file exists\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.NewNotFoundError(filePath))\n\t}\n\n\t// Open the file\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err))\n\t}\n\tdefer file.Close()\n\n\t// Create a buffer to read the file into\n\tfileBytes := make([]byte, 512)\n\n\t// Read the file into the buffer\n\t_, err = file.Read(fileBytes)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err))\n\t}\n\n\t// Create a new multipart writer\n\twriter := multipart.NewWriter(ctx.Response())\n\n\t// Create a new form file to write the file into\n\tformFile, err := writer.CreateFormFile(\"file\", filepath.Base(filePath))\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err))\n\t}\n\n\t// Write the file into the form file\n\t_, err = formFile.Write(fileBytes)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err))\n\t}\n\n\t// Close the multipart writer\n\terr = writer.Close()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.NewInternalServerError(err))\n\t}\n\n\t// Return a response with the file\n\treturn ctx.NoContent(http.StatusOK)\n}", "CodeBleu_score": 39.82536931433466}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tvar msg map[string]interface{}\n\tif err := ctx.Bind(&msg); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification.\n\tif err := service.MyService.Notify().SendNotify(name, msg); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.NoContent(http.StatusCreated)\n}", "CodeBleu_score": 50.26724011197984}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\t// Bind the request body to a message map.\n\tif err := ctx.Bind(message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\t// Send the notification.\n\tif err := service.MyService.Notify(name).SendNotify(message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\t// Return a success response.\n\treturn ctx.NoContent(http.StatusCreated)\n}", "CodeBleu_score": 48.605705387524104}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification.\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"success\": true,\n\t})\n}", "CodeBleu_score": 60.50492333603324}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection\n\tupGrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running\n\tgo sendMessages()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(mt)\n\t\tfmt.Println(string(message))\n\t}\n}", "CodeBleu_score": 47.53911048892602}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tupGrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running\n\tgo sendMessages()\n\t// Read messages from the WebSocket connection\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(mt, string(message), err)\n\t}\n}", "CodeBleu_score": 48.26276818258131}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tupGrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// ensure that the message sending service is running\n\tgo sendMeg()\n\n\tfor {\n\t\tmessageType, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Println(messageType)\n\t\tfmt.Println(string(message))\n\t\tfmt.Println(err)\n\t}\n}", "CodeBleu_score": 44.980521421935094}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the system hardware information\n\thardwareInfo := common.GetSystemHardwareInfo()\n\n\t// Return the hardware information as JSON\n\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n}", "CodeBleu_score": 7.224408914794653}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the system hardware information\n\tsysInfo := service.MyService.System().GetHardwareInfo()\n\n\t// If the CPU information is available, add it to the response\n\tif sysInfo.CpuInfo != nil {\n\t\tctx.JSON(http.StatusOK, sysInfo)\n\t} else {\n\t\t// If the CPU information is not available, return a \"nil\" response\n\t\tctx.JSON(http.StatusOK, common_err.GetMsg(common_err.NilError))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 19.963306844795284}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar err error\n\tvar res map[string]interface{}\n\tvar driveModel string\n\tvar driveArch string\n\tvar cpuInfo map[string]interface{}\n\n\tif driveModel, driveArch, err = service.MyService.System().GetDriveInfo(); err != nil {\n\t\treturn common_err.NewBadRequest(ctx, err, \"Failed to get drive information\")\n\t}\n\n\tif cpuInfo, err = service.MyService.System().GetCpuInfo(); err != nil {\n\t\treturn common_err.NewBadRequest(ctx, err, \"Failed to get CPU information\")\n\t}\n\n\tres = map[string]interface{}{\n\t\t\"driveModel\": driveModel,\n\t\t\"driveArch\":  driveArch,\n\t\t\"cpuInfo\":    cpuInfo,\n\t}\n\n\treturn ctx.JSON(http.StatusOK, res)\n}", "CodeBleu_score": 36.455259132578554}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tif strings.Contains(service, \"active\") {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 63.103074391419156}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.listServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := []string{}\n\tnotRunningServices := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 63.963059042059164}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tif systemctl.IsServiceRunning(service) {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 61.6876909984242}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Create a new message\n\tmsg := &notify.Notify{\n\t\tName:   name,\n\t\tParams: message,\n\t}\n\t// Publish the event\n\tresponse, err := i.bus.PublishEventWithResponse(context.Background(), msg)\n\tif err != nil {\n\t\t// Log the error\n\t\ti.logger.Error(\"failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\t// Check the response status\n\tif response.Status() != http.StatusOK {\n\t\t// Log the failure\n\t\ti.logger.Error(\"failed to publish event\", zap.String(\"name\", name), zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 41.40535625268786}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Create a new event with the given name and message map.\n\tevent := i.bus.NewEvent(name, message)\n\n\t// Marshal the event to JSON.\n\tdata, err := json.Marshal(event)\n\tif err != nil {\n\t\t// Log the error.\n\t\ti.logger.Error(\"failed to marshal event\", zap.Error(err))\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\tresponse := i.bus.PublishEventWithResponse(context.Background(), data)\n\n\t// Check the response status code.\n\tif response.Status() != http.StatusOK {\n\t\t// Log the failure.\n\t\ti.logger.Error(\"failed to send event\",\n\t\t\tzap.String(\"event\", name),\n\t\t\tzap.Any(\"details\", response.Details()),\n\t\t)\n\t}\n}", "CodeBleu_score": 38.03513769061728}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tctx := context.Background()\n\tevent := notify.NotifyEvent{\n\t\tName: name,\n\t\tMessage: message,\n\t}\n\tresponse := i.MyService.MessageBus().PublishEventWithResponse(ctx, \"notify\", event)\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"failed to send notification\", zap.String(\"name\", name), zap.Any(\"message\", message), zap.Int(\"status_code\", response.StatusCode), zap.String(\"status\", response.Status))\n\t}\n}", "CodeBleu_score": 33.54953824455221}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.server)\n\tif c.server != \"\" {\n\t\tc.server = client.GetMessageBusAddress().Address\n\t} else {\n\t\tc.server = \"Unable to retrieve message bus address\"\n\t}\n\treturn client\n}", "CodeBleu_score": 29.509893082681664}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.server)\n\tif c.server == \"\" {\n\t\tc.server = \"Could not retrieve message bus address\"\n\t}\n\treturn client\n}", "CodeBleu_score": 19.324377231979806}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\treturn &message_bus.ClientWithResponses{Client: c.message_bus}\n}", "CodeBleu_score": 7.3747792118328865}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tif xff := request.Header.Get(\"x-forwarded-for\"); xff != \"\" {\n\t\tip := strings.Split(xff, \",\")[0]\n\t\tip = strings.TrimSpace(ip)\n\t\tif ip != \"\" {\n\t\t\treturn ip\n\t\t}\n\t}\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\treturn ip\n}", "CodeBleu_score": 37.773607190692104}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \", \") {\n\t\tip = strings.Split(ip, \", \")[0]\n\t}\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 63.50603603936731}, {"code": "func GetIP(request *http.Request) string{\n\t\tif ip := request.Header.Get(\"x-forwarded-for\"); ip != \"\" {\n\t\treturn strings.Split(ip, \", \")[0]\n\t}\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 45.53803772429125}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tvar err error\n\n\tentryFilePath := filepath.Join(c.modulesDir, systemEntryFileName)\n\n\t// If the entry file does not exist, create it.\n\tif _, err = os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tif err = os.WriteFile(entryFilePath, []byte(\"[]\"), 0644); err != nil {\n\t\t\tlogger.Error(\"Failed to create system entry file: %s\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files.\n\tmodules := []string{}\n\tif modules, err = os.ReadDir(c.modulesDir); err != nil {\n\t\tlogger.Error(\"Failed to read modules directory: %s\", err)\n\t\treturn\n\t}\n\n\t// Concatenate each module's entry file into a single array.\n\tvar entries []systemEntry\n\tfor _, module := range modules {\n\t\tif module.Name() == systemEntryFileName {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar moduleEntry []systemEntry\n\t\tif moduleEntry, err = c.readModuleEntry(module.Name()); err != nil {\n\t\t\tlogger.Error(\"Failed to read module entry file: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tentries = append(entries, moduleEntry...)\n\t}\n\n\t// Write the array to the entry file.\n\tif err = os.WriteFile(entryFilePath, json.Marshal(entries), 0644); err != nil {\n\t\tlogger.Error(\"Failed to write system entry file: %s\", err)\n\t}\n}", "CodeBleu_score": 46.63641398306424}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the path to the modules directory\n\tmodulesPath, err := c.GetModulesPath()\n\tif err != nil {\n\t\tlogger.Error(\"Error getting modules path: %s\", err)\n\t\treturn\n\t}\n\n\t// Get the path to the entry file\n\tentryPath, err := c.GetEntryPath()\n\tif err != nil {\n\t\tlogger.Error(\"Error getting entry path: %s\", err)\n\t\treturn\n\t}\n\n\t// Get a list of module directories\n\tmoduleDirs, err := c.getModulesDirs(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(\"Error getting module directories: %s\", err)\n\t\treturn\n\t}\n\n\t// Create an empty slice to hold the entry JSON objects\n\tvar entryObjects []map[string]interface{}\n\n\t// For each module directory\n\tfor _, moduleDir := range moduleDirs {\n\t\t// Get the path to the module entry file\n\t\tmoduleEntryPath := filepath.Join(moduleDir, \"entry.json\")\n\n\t\t// Read the module entry file\n\t\tmoduleEntryFile, err := os.Open(moduleEntryPath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error reading module entry file: %s\", err)\n\t\t\tcontinue\n\t\t}\n\t\tdefer moduleEntryFile.Close()\n\n\t\t// Parse the module entry file\n\t\tmoduleEntryObject := make(map[string]interface{})\n\t\tif err := json.NewDecoder(moduleEntryFile).Decode(&moduleEntryObject); err != nil {\n\t\t\tlogger.Error(\"Error parsing module entry file: %s\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Append the module entry object to the entry objects slice\n\t\tentryObjects = append(entryObjects, moduleEntryObject)\n\t}\n\n\t// Create the entry file\n\tentryFile, err := os.Create(entryPath)\n\tif err != nil {\n\t\tlogger.Error(\"Error creating entry file: %s\", err)\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\n\t// Marshal the entry objects slice into a JSON array\n\tentryArray, err := json.Marshal(entryObjects)\n\tif err != nil {\n\t\tlogger.Error(\"Error marshaling entry objects: %s\", err)\n\t\treturn\n\t}\n\n\t// Write the JSON array", "CodeBleu_score": 39.1970844239905}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\t// Get the modules directory path.\n\tmodulesDir := c.modulesDir()\n\n\t// Get the entry file path.\n\tentryFilePath := c.entryFilePath()\n\n\t// Get the entry file's directory.\n\tentryFileDir := filepath.Dir(entryFilePath)\n\n\t// Ensure the entry file's directory exists.\n\tif _, err := os.Stat(entryFileDir); os.IsNotExist(err) {\n\t\t// Create the entry file's directory.\n\t\tif err := os.MkdirAll(entryFileDir, 0777); err != nil {\n\t\t\t// Log the error.\n\t\t\tc.logger.Error(err)\n\n\t\t\t// Return.\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Get the module directories.\n\tmoduleDirs, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\t// Log the error.\n\t\tc.logger.Error(err)\n\n\t\t// Return.\n\t\treturn\n\t}\n\n\t// Create an empty slice to hold the entry JSON objects.\n\tvar entries []map[string]interface{}\n\n\t// Iterate through the module directories.\n\tfor _, moduleDir := range moduleDirs {\n\t\t// Get the module directory path.\n\t\tmoduleDirPath := filepath.Join(modulesDir, moduleDir.Name())\n\n\t\t// Get the module directory's entry file path.\n\t\tentryFilePath := filepath.Join(moduleDirPath, \"entry.json\")\n\n\t\t// Get the module directory's entry file.\n\t\tentryFile, err := os.ReadFile(entryFilePath)\n\t\tif err != nil {\n\t\t\t// Log the error.\n\t\t\tc.logger.Error(err)\n\n\t\t\t// Return.\n\t\t\treturn\n\t\t}\n\n\t\t// Unmarshal the module directory's entry file into a JSON object.\n\t\tvar entry map[string]interface{}\n\t\tif err := json.Unmarshal(entryFile, &entry); err != nil {\n\t\t\t// Log the error.\n\t\t\tc.logger.Error(err)\n\n\t\t\t// Return.\n\t\t\treturn\n\t\t}\n\n\t\t// Append the module directory's entry object to the entries slice.\n\t\tentries = append(entries, entry)\n\t}\n\n\t// Create the entry file's JSON array.\n\tentryFileJSON, err := json.Marshal(entries)\n\tif err != nil {\n\t\t//", "CodeBleu_score": 42.517980747206806}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tvar err error\n\tifaces, err := c.GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range ifaces {\n\t\tfor _, name := range iface.Names {\n\t\t\tif name == \"eth0\" || name == \"en0\" {\n\t\t\t\treturn iface.HardwareAddr, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no interface found\")\n}", "CodeBleu_score": 58.90446905909737}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range ifaces {\n\t\tif iface.Name == \"eth0\" {\n\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No interface found\")\n}", "CodeBleu_score": 53.96757020209595}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tnetInterfaces, err := c.GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnetNames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, netInterface := range netInterfaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif netName == netInterface.Name {\n\t\t\t\treturn netInterface.MacAddress, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching interface found\")\n}", "CodeBleu_score": 58.08909338078401}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t retCode = 0;\n\tuint32_t requestCount = 0;\n\tuint32_t totalRequestCount = 0;\n\tuint32_t totalActiveRequestCount = 0;\n\tuint32_t totalActiveRequestCountByCaller = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLock = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTsc = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThread = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLock = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLockAndThread = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLockAndThreadAndLock = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLockAndThreadAndLockAndThread = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLockAndThreadAndLockAndThreadAndLock = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLockAndThreadAndLockAndThreadAndLockAndThread = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLockAndThreadAndLockAndThreadAndLockAndThreadAndLock = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLockAndThreadAndLockAndThreadAndLockAndThreadAndLockAndThread = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLockAndThreadAndLockAndThreadAndLockAndThreadAndLockAndThreadAndLock = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLockAndThreadAndLockAndThreadAndLockAndThreadAndLockAndThreadAndLockAndThread = 0;\n\tuint32_t totalActiveRequestCountByCallerAndLockAndTscAndThreadAndLockAndThreadAndLock", "CodeBleu_score": 5.788954418306498}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t l = 0;\n\tint32_t m = 0;\n\tint32_t n = 0;\n\tint32_t o = 0;\n\tint32_t p = 0;\n\tint32_t q = 0;\n\tint32_t r = 0;\n\tint32_t s = 0;\n\tint32_t t = 0;\n\tint32_t u = 0;\n\tint32_t v = 0;\n\tint32_t w = 0;\n\tint32_t x = 0;\n\tint32_t y = 0;\n\tint32_t z = 0;\n\tint32_t a = 0;\n\tint32_t b = 0;\n\tint32_t c = 0;\n\tint32_t d = 0;\n\tint32_t e = 0;\n\tint32_t f = 0;\n\tint32_t g = 0;\n\tint32_t h = 0;\n\tint32_t i1 = 0;\n\tint32_t j1 = 0;\n\tint32_t k1 = 0;\n\tint32_t l1 = 0;\n\tint32_t m1 = 0;\n\tint32_t n1 = 0;\n\tint32_t o1 = 0;\n\tint32_t p1 = 0;\n\tint32_t q1 = 0;\n\tint32_t r1 = 0;\n\tint32_t s1 = 0;\n\tint32_t t1 = 0;\n\tint32_t u1 = 0;\n\tint32_t v1 = 0;\n\tint32_t", "CodeBleu_score": 5.761397285817013}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t retCode = 0;\n\tif (pRequest == NULL) {\n\t\tretCode = -1;\n\t\tgoto cleanup;\n\t}\n\tif (pTscObj == NULL) {\n\t\tretCode = -1;\n\t\tgoto cleanup;\n\t}\n\tif (pRequest->refCount == 0) {\n\t\tpRequest->refCount++;\n\t\tif (pTscObj->appInfo.appInfo != NULL) {\n\t\t\tpTscObj->appInfo.appInfo->requestCount++;\n\t\t\tpTscObj->appInfo.appInfo->currentRequestCount++;\n\t\t}\n\t}\n\tlogDebug(\"registerRequest: pRequest=%p, pTscObj=%p, refCount=%d\", pRequest, pTscObj, pRequest->refCount);\ncleanup:\n\treturn retCode;\n}", "CodeBleu_score": 38.54945353857108}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *p;\n\tchar *p2;\n\tchar *p3;\n\tchar *p4;\n\tchar *p5;\n\tchar *p6;\n\tchar *p7;\n\tchar *p8;\n\tchar *p9;\n\tchar *p10;\n\tchar *p11;\n\tchar *p12;\n\tchar *p13;\n\tchar *p14;\n\tchar *p15;\n\tchar *p16;\n\tchar *p17;\n\tchar *p18;\n\tchar *p19;\n\tchar *p20;\n\tchar *p21;\n\tchar *p22;\n\tchar *p23;\n\tchar *p24;\n\tchar *p25;\n\tchar *p26;\n\tchar *p27;\n\tchar *p28;\n\tchar *p29;\n\tchar *p30;\n\tchar *p31;\n\tchar *p32;\n\tchar *p33;\n\tchar *p34;\n\tchar *p35;\n\tchar *p36;\n\tchar *p37;\n\tchar *p38;\n\tchar *p39;\n\tchar *p40;\n\tchar *p41;\n\tchar *p42;\n\tchar *p43;\n\tchar *p44;\n\tchar *p45;\n\tchar *p46;\n\tchar *p47;\n\tchar *p48;\n\tchar *p49;\n\tchar *p50;\n\tchar *p51;\n\tchar *p52;\n\tchar *p53;\n\tchar *p54;\n\tchar *p55;\n\tchar *p56;\n\tchar *p57;\n\tchar *p58;\n\tchar *p59;\n\tchar *p60;\n\tchar *p61;\n\tchar *p62;\n\tchar *p63;\n\tchar *p64;\n\tchar *p65;\n\tchar", "CodeBleu_score": 4.791021048243936}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb;\n\n\tif (pRequest->pPrimaryDb->pDbName == exceptDb) {\n\t\treturn true;\n\t}\n\n\tfor (pDb = pRequest->pDbList; pDb; pDb = pDb->pNext) {\n\t\tif (pDb->pDbName == exceptDb) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 31.28744853269896}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tif (pRequest->primaryDb != NULL) {\n\t\tif (strcmp(pRequest->primaryDb, exceptDb) != 0) {\n\t\t\tchar* db = pRequest->primaryDb;\n\t\t\tchar* p = strchr(db, '.');\n\t\t\tif (p != NULL) {\n\t\t\t\tdb = p + 1;\n\t\t\t}\n\t\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdb = pRequest->secondaryDb;\n\t\t\tp = strchr(db, '.');\n\t\t\tif (p != NULL) {\n\t\t\t\tdb = p + 1;\n\t\t\t}\n\t\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (pRequest->nDb > 0) {\n\t\t\t\tfor (int i = 0; i < pRequest->nDb; i++) {\n\t\t\t\t\tdb = pRequest->dbList[i];\n\t\t\t\t\tp = strchr(db, '.');\n\t\t\t\t\tif (p != NULL) {\n\t\t\t\t\t\tdb = p + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 63.066331310826854}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tswitch (code) {\n\t\tcase TDB2_ERR_NEED_REDIRECT:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_READONLY:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_NOT_FOUND:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_EXISTS:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_NOT_EMPTY:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_NOT_UNIQUE:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_BADVALUE:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_READONLY:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_NO_SPACE:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_NO_MORE_SPACE:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_INVALID_STATE:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_BADARGS:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_NOT_IMPLEMENTED:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_UNKNOWN_ERROR:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_BAD_HANDLE:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_HANDLE_IN_USE:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_NO_HANDLE:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_BAD_LOCK_LEVEL:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_LOCK_FAILED:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_BAD_LOCK_STATE:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_LOCK_TIMEOUT:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_LOCK_DEADLOCK:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_READONLY:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_NO_LOCK:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_NO_LOCK_SPACE:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_NO_LOCK_OWNER:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_BAD_LOCK_TIMEOUT:\n\t\t\treturn true;\n\t\tcase TDB2_ERR_BAD_", "CodeBleu_score": 31.541978272997362}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == RPC_ERR_NEED_REDIRECT) {\n\t\tswitch (msgType) {\n\t\t\tcase TMSG_CLIENT_RPC_CALL:\n\t\t\tcase TMSG_CLIENT_RPC_RESP:\n\t\t\tcase TMSG_CLIENT_RPC_NOTIFICATION:\n\t\t\tcase TMSG_CLIENT_RPC_CANCEL:\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.68864482260098}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\t/*\n\t * If the error code indicates a need for redirection and the message type is not one of several specific types, it returns true indicating redirection is needed.\n\t */\n\tif (code == RPC_NEED_REDIRECT_ERROR && msgType != TMSG_OPEN_SESSION_REPLY && msgType != TMSG_CREATE_SESSION_REPLY && msgType != TMSG_CLOSE_SESSION_REPLY && msgType != TMSG_RPC_EXECUTE_REQUEST && msgType != TMSG_RPC_EXECUTE_WITH_CONTEXT_REQUEST) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * Otherwise, it returns false indicating no redirection is required.\n\t */\n\treturn false;\n}", "CodeBleu_score": 36.023240094388385}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashEntry *pEntry;\n\tRequestInfo *pRequest;\n\n\t/* Iterate through the hash table and stop all ongoing requests */\n\tfor (pEntry = s_hash_first(pRequests); pEntry; pEntry = s_hash_next(pRequests)) {\n\t\tpRequest = (RequestInfo *)s_hash_entry_value(pEntry);\n\t\tif (pRequest->requestID != INVALID_REQUEST_ID) {\n\t\t\tacquireRequest(pRequest);\n\t\t\tif (pRequest->requestID != INVALID_REQUEST_ID) {\n\t\t\t\ttaos_stop_query(pRequest->conn, pRequest->requestID);\n\t\t\t\tpRequest->requestID = INVALID_REQUEST_ID;\n\t\t\t}\n\t\t\treleaseRequest(pRequest);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.51503884976537}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashIterator iterator;\n\tTaoHashRequest *pRequest;\n\n\tshash_iterator_init(&iterator, pRequests);\n\twhile (shash_iterator_next(&iterator, NULL, (void **)&pRequest)) {\n\t\tif (pRequest->requestID != 0) {\n\t\t\tacquireRequest(pRequest);\n\t\t\tif (pRequest->query != NULL) {\n\t\t\t\ttaos_stop_query(pRequest->query);\n\t\t\t\tpRequest->query = NULL;\n\t\t\t}\n\t\t\treleaseRequest(pRequest);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.09015722734728}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashIterator *pIterator;\n\tvoid *pKey;\n\tvoid *pValue;\n\n\tpIterator = shash_begin(pRequests);\n\twhile (pIterator != NULL) {\n\t\tpKey = shash_iterator_key(pIterator);\n\t\tpValue = shash_iterator_value(pIterator);\n\t\tacquireRequest(pValue);\n\t\tif (requestIsValid(pValue)) {\n\t\t\ttaos_stop_query(pValue->pQuery);\n\t\t}\n\t\treleaseRequest(pValue);\n\t\tpIterator = shash_iterator_next(pIterator);\n\t}\n}", "CodeBleu_score": 42.24285350507636}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportingEnabled == 0) {\n\t\treturn;\n\t}\n\tint32_t oldVal = 0;\n\tint32_t newVal = 1;\n\tif (atomic_val_compare_exchange_32(&clientStop, &oldVal, newVal) != 0) {\n\t\ttsc_log(TSC_LOG_ERROR, \"Crash report thread already stopped\");\n\t\treturn;\n\t}\n\twhile (clientStop != 0) {\n\t\ttsc_sleep(1000);\n\t}\n}", "CodeBleu_score": 57.35912374927325}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\n\tint oldVal = 0;\n\tint newVal = 1;\n\tif (!atomic_val_compare_exchange_32((volatile int32_t *)&tscClientStop, &oldVal, newVal)) {\n\t\ttscLogMessage(\"Crash report thread already stopped.\n\");\n\t\treturn;\n\t}\n\n\twhile (tscClientStop) {\n\t\ttscThreadSleep(1000000);\n\t}\n}", "CodeBleu_score": 47.54062685544318}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\n\tif (atomic_val_compare_exchange_32(&clientStop, 0, 1) == 0) {\n\t\ttscLogMessage(TSC_LOG_DEBUG, \"Crash report thread is already stopped\");\n\t\treturn;\n\t}\n\n\twhile (clientStop != 0) {\n\t\ttscSleep(1);\n\t}\n}", "CodeBleu_score": 56.57905905708106}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t ret = 0;\n\tint32_t i = 0;\n\tint32_t viewCount = 0;\n\tint32_t viewCountOld = 0;\n\tint32_t viewCountNew = 0;\n\tint32_t viewCountRemoved = 0;\n\tint32_t viewCountAdded = 0;\n\tint32_t viewCountUpdated = 0;\n\tint32_t viewCountUnchanged = 0;\n\tint32_t viewCountErrors = 0;\n\tint32_t viewCountErrorsRemoved = 0;\n\tint32_t viewCountErrorsAdded = 0;\n\tint32_t viewCountErrorsUpdated = 0;\n\tint32_t viewCountErrorsUnchanged = 0;\n\tint32_t viewCountErrorsTotal = 0;\n\tstruct SViewMeta *pViewMeta = NULL;\n\tstruct SViewMeta *pViewMetaOld = NULL;\n\tstruct SViewMeta *pViewMetaNew = NULL;\n\tstruct SViewMeta *pViewMetaRemoved = NULL;\n\tstruct SViewMeta *pViewMetaAdded = NULL;\n\tstruct SViewMeta *pViewMetaUpdated = NULL;\n\tstruct SViewMeta *pViewMetaUnchanged = NULL;\n\tstruct SViewMeta *pViewMetaErrors = NULL;\n\tstruct SViewMeta *pViewMetaErrorsRemoved = NULL;\n\tstruct SViewMeta *pViewMetaErrorsAdded = NULL;\n\tstruct SViewMeta *pViewMetaErrorsUpdated = NULL;\n\tstruct SViewMeta *pViewMetaErrorsUnchanged = NULL;\n\tstruct SViewMeta *pViewMetaErrorsTotal = NULL;\n\tstruct SViewMeta *pViewMetaNext = NULL;\n\tstruct SViewMeta *pViewMetaNextOld = NULL;\n\tstruct SViewMeta *pViewMetaNextNew = NULL;\n\tstruct SViewMeta *pViewMetaNextRemoved = NULL;\n\tstruct SViewMeta *pViewMetaNextAdded = NULL;\n\tstruct SViewMeta *pViewMetaNextUpdated = NULL;\n\tstruct SViewMeta *pViewMetaNextUnchanged = NULL;\n\tstruct SViewMeta *p", "CodeBleu_score": 9.586216800312704}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t ret = TSC_OK;\n\tstruct SViewMeta *pViewMeta = NULL;\n\tstruct SViewMeta *pViewMetaTemp = NULL;\n\tstruct SViewMeta *pViewMetaTemp2 = NULL;\n\tstruct SViewMeta *pViewMetaTemp3 = NULL;\n\tstruct SViewMeta *pViewMetaTemp4 = NULL;\n\tstruct SViewMeta *pViewMetaTemp5 = NULL;\n\tstruct SViewMeta *pViewMetaTemp6 = NULL;\n\tstruct SViewMeta *pViewMetaTemp7 = NULL;\n\tstruct SViewMeta *pViewMetaTemp8 = NULL;\n\tstruct SViewMeta *pViewMetaTemp9 = NULL;\n\tstruct SViewMeta *pViewMetaTemp10 = NULL;\n\tstruct SViewMeta *pViewMetaTemp11 = NULL;\n\tstruct SViewMeta *pViewMetaTemp12 = NULL;\n\tstruct SViewMeta *pViewMetaTemp13 = NULL;\n\tstruct SViewMeta *pViewMetaTemp14 = NULL;\n\tstruct SViewMeta *pViewMetaTemp15 = NULL;\n\tstruct SViewMeta *pViewMetaTemp16 = NULL;\n\tstruct SViewMeta *pViewMetaTemp17 = NULL;\n\tstruct SViewMeta *pViewMetaTemp18 = NULL;\n\tstruct SViewMeta *pViewMetaTemp19 = NULL;\n\tstruct SViewMeta *pViewMetaTemp20 = NULL;\n\tstruct SViewMeta *pViewMetaTemp21 = NULL;\n\tstruct SViewMeta *pViewMetaTemp22 = NULL;\n\tstruct SViewMeta *pViewMetaTemp23 = NULL;\n\tstruct SViewMeta *pViewMetaTemp24 = NULL;\n\tstruct SViewMeta *pViewMetaTemp25 = NULL;\n\tstruct SViewMeta *pViewMetaTemp26 = NULL;\n\tstruct SViewMeta *pViewMetaTemp27 = NULL;\n\tstruct SViewMeta *pViewMetaTemp28 = NULL;\n\tstruct SViewMeta *pViewMetaTemp29 = NULL;\n\tstruct SViewMeta *pViewMetaTemp30 = NULL;\n\tstruct SViewMeta *pViewMetaTemp31 = NULL;", "CodeBleu_score": 7.016879231797035}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t retCode = SC_ERR_NONE;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t numViews = 0;\n\tint32_t numColumns = 0;\n\tint32_t viewId = 0;\n\tint32_t viewType = 0;\n\tint32_t viewNameLen = 0;\n\tint32_t viewNameLen2 = 0;\n\tint32_t viewNameLen3 = 0;\n\tint32_t viewNameLen4 = 0;\n\tint32_t viewNameLen5 = 0;\n\tint32_t viewNameLen6 = 0;\n\tint32_t viewNameLen7 = 0;\n\tint32_t viewNameLen8 = 0;\n\tint32_t viewNameLen9 = 0;\n\tint32_t viewNameLen10 = 0;\n\tint32_t viewNameLen11 = 0;\n\tint32_t viewNameLen12 = 0;\n\tint32_t viewNameLen13 = 0;\n\tint32_t viewNameLen14 = 0;\n\tint32_t viewNameLen15 = 0;\n\tint32_t viewNameLen16 = 0;\n\tint32_t viewNameLen17 = 0;\n\tint32_t viewNameLen18 = 0;\n\tint32_t viewNameLen19 = 0;\n\tint32_t viewNameLen20 = 0;\n\tint32_t viewNameLen21 = 0;\n\tint32_t viewNameLen22 = 0;\n\tint32_t viewNameLen23 = 0;\n\tint32_t viewNameLen24 = 0;\n\tint32_t viewNameLen25 = 0;\n\tint32_t viewNameLen26 = 0;\n\tint32_t viewNameLen27 = 0", "CodeBleu_score": 9.331499725864289}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tif (properties->contentLength > 0) {\n\t\t((struct transferData *) callbackData)->contentLength = properties->contentLength;\n\t} else {\n\t\t((struct transferData *) callbackData)->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 67.6006483714765}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tif (properties->contentLength > 0) {\n\t\t((GetObjectCallbackData*) callbackData)->contentLength = properties->contentLength;\n\t} else {\n\t\t((GetObjectCallbackData*) callbackData)->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 67.40979582879363}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tstruct callbackData *data = (struct callbackData *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\n\treturn S3StatusOK;\n}", "CodeBleu_score": 76.32571732613623}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t\tif (uDebug) {\n\t\tprintf(\"Starting Rsync server...\n\");\n\t}\n\n\tif (taosMulMkDir(backupDir, 0755) != 0) {\n\t\tif (uDebug) {\n\t\t\tprintf(\"Failed to create checkpoint backup directory %s.\n\", backupDir);\n\t\t}\n\t\tuError = 1;\n\t\treturn;\n\t}\n\n\tif (removeEmptyDir(backupDir) != 0) {\n\t\tif (uDebug) {\n\t\t\tprintf(\"Failed to remove empty directories in checkpoint backup directory %s.\n\", backupDir);\n\t\t}\n\t\tuError = 1;\n\t\treturn;\n\t}\n\n\tif (generateConfigFile() != 0) {\n\t\tif (uDebug) {\n\t\t\tprintf(\"Failed to generate Rsync configuration file.\n\");\n\t\t}\n\t\tuError = 1;\n\t\treturn;\n\t}\n\n\tchar *rsyncCmd = (char *) malloc(sizeof(char) * 1024);\n\tsnprintf(rsyncCmd, 1024, \"rsync --daemon --config=%s --port=%d\", rsyncConf, rsyncPort);\n\tif (system(rsyncCmd) != 0) {\n\t\tif (uDebug) {\n\t\t\tprintf(\"Failed to start Rsync server.\n\");\n\t\t}\n\t\tuError = 1;\n\t}\n\n\tfree(rsyncCmd);\n}", "CodeBleu_score": 35.82537990924667}, {"code": "void startRsync(){\n\t\tuDebug(\"Starting Rsync server...\");\n\tif (taosMulMkDir(CHECKPOINT_BACKUP_DIR) == -1) {\n\t\tuError(\"Failed to create checkpoint backup directory.\");\n\t\treturn;\n\t}\n\tremoveEmptyDir(CHECKPOINT_BACKUP_DIR);\n\tif (generateConfigFile(RSYNC_CONFIG_FILE, RSYNC_CONFIG_FILE_CONTENT) == -1) {\n\t\tuError(\"Failed to generate Rsync configuration file.\");\n\t\treturn;\n\t}\n\tchar *cmd = (char *) malloc(sizeof(char) * 100);\n\tsnprintf(cmd, 100, \"rsync --daemon --config=%s\", RSYNC_CONFIG_FILE);\n\tif (system(cmd) == -1) {\n\t\tuError(\"Failed to start Rsync server.\");\n\t\treturn;\n\t}\n\tuInfo(\"Rsync server started successfully.\");\n}", "CodeBleu_score": 25.535202323566164}, {"code": "void startRsync(){\n\t\tchar *backupDir = \"/home/taos/backup\";\n\tchar *configFileName = \"/home/taos/backup/rsyncd.conf\";\n\tchar *command = \"rsync --daemon --config=/home/taos/backup/rsyncd.conf\";\n\tchar *port = \"873\";\n\n\t/*\n\t * Attempt to create the checkpoint backup directory.\n\t */\n\tif (taosMulMkDir(backupDir) != 0) {\n\t\tuError(\"Failed to create the checkpoint backup directory\");\n\t}\n\n\t/*\n\t * Remove empty directories.\n\t */\n\tremoveEmptyDir(backupDir);\n\n\t/*\n\t * Generate an Rsync configuration file.\n\t */\n\tif (generateConfigFile(configFileName) != 0) {\n\t\tuError(\"Failed to generate the Rsync configuration file\");\n\t}\n\n\t/*\n\t * Construct and execute a command to start the Rsync daemon with the specified port and configuration file.\n\t */\n\tsnprintf(command, 1024, \"%s --port=%s\", command, port);\n\tsystem(command);\n\n\t/*\n\t * Log whether the Rsync server started successfully or if it encountered an error.\n\t */\n\tuDebug(\"Rsync server started successfully\");\n}", "CodeBleu_score": 24.84007800323964}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tExecutor executor = dispatchers.get(dispatcherId).getExecutor();\n\t\texecutor.shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n}", "CodeBleu_score": 62.07900860696951}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n}", "CodeBleu_score": 47.204727966519506}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n\tdispatcher.shutdownNow();\n\tdispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 60.636584354658616}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tif (parent == null) {\n\t\treturn;\n\t}\n\tMap<TbActorId, TbActorRef> children = childrenMap.get(parent);\n\tif (children == null) {\n\t\treturn;\n\t}\n\tchildren.values().stream()\n\t\t.filter(childFilter)\n\t\t.forEach(child -> {\n\t\t\ttry {\n\t\t\t\tchild.tell(msg, highPriority);\n\t\t\t} catch (TbActorRefException e) {\n\t\t\t\tlog.warn(\"Failed to send msg [{}] to child [{}]\", msg, child, e);\n\t\t\t}\n\t\t});\n}", "CodeBleu_score": 53.47802158539145}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tif (children.containsKey(parent)) {\n\t\tchildren.get(parent).stream()\n\t\t\t.filter(childFilter)\n\t\t\t.forEach(child -> {\n\t\t\t\tif (actorSystem.isRegistered(child)) {\n\t\t\t\t\tif (highPriority) {\n\t\t\t\t\t\tactorSystem.tell(child, msg, HIGH_PRIORITY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactorSystem.tell(child, msg);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlog.warn(\"[{}] is not registered!\", child);\n\t\t\t\t}\n\t\t\t});\n\t}\n}", "CodeBleu_score": 38.23993393431605}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tList<TbActorId> children = childrenMap.get(parent);\n\tif (children != null) {\n\t\tfor (TbActorId child : children) {\n\t\t\tif (childFilter.test(child)) {\n\t\t\t\tTbActor actor = actorMap.get(child);\n\t\t\t\tif (actor != null) {\n\t\t\t\t\tactor.tell(msg, highPriority);\n\t\t\t\t} else {\n\t\t\t\t\tlog.warn(\"Child actor is not registered: {}\", child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 50.08361468698983}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (!destroyed) {\n\t\tif (highPriority) {\n\t\t\tif (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n\t\t\t\tif (actor.isFailed()) {\n\t\t\t\t\tif (actor.getReinitCount() < actor.getMaxReinitCount()) {\n\t\t\t\t\t\tactor.setReinitCount(actor.getReinitCount() + 1);\n\t\t\t\t\t\tactor.initActor();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t} else {\n\t\tmsg.onTbActorStopped();\n\t}\n}", "CodeBleu_score": 43.83870399385551}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (destroying) {\n\t\tif (highPriority && msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n\t\t\tif (initActor(msg.getActorId())) {\n\t\t\t\tprocessQueue();\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.onTbActorStopped();\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t}\n}", "CodeBleu_score": 43.54361110031644}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (msg == null) {\n\t\treturn;\n\t}\n\tif (destroying) {\n\t\tif (highPriority && msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n\t\t\tif (initActor()) {\n\t\t\t\tprocessQueue();\n\t\t\t}\n\t\t} else {\n\t\t\tmsg.onTbActorStopped();\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\tprocessQueue();\n\t}\n}", "CodeBleu_score": 44.03987156367227}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t\tif (status == Status.INITIALIZING) {\n\t\tif (initFailed) {\n\t\t\tif (stopReason == null) {\n\t\t\t\tstopReason = new ActorStoppedException(this, \"Initialization failed\");\n\t\t\t}\n\t\t\tdestroy();\n\t\t} else {\n\t\t\tif (stopReason != null) {\n\t\t\t\tdestroy();\n\t\t\t} else {\n\t\t\t\tstatus = Status.PROCESSING;\n\t\t\t\tprocess();\n\t\t\t}\n\t\t}\n\t} else if (status == Status.PROCESSING) {\n\t\ttry {\n\t\t\tif (throughput > 0) {\n\t\t\t\tlong start = System.nanoTime();\n\t\t\t\tint processed = 0;\n\t\t\t\twhile (System.nanoTime() - start < throughput && processed < mailboxSize) {\n\t\t\t\t\tif (processQueue(highPriorityQueue)) {\n\t\t\t\t\t\tprocessed++;\n\t\t\t\t\t}\n\t\t\t\t\tif (processQueue(normalPriorityQueue)) {\n\t\t\t\t\t\tprocessed++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (processed == 0) {\n\t\t\t\t\tstatus = Status.FREE;\n\t\t\t\t\tscheduler.schedule(this::processMailbox);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (processQueue(highPriorityQueue)) {\n\t\t\t\t}\n\t\t\t\twhile (processQueue(normalPriorityQueue)) {\n\t\t\t\t}\n\t\t\t\tstatus = Status.FREE;\n\t\t\t\tscheduler.schedule(this::processMailbox);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif (e instanceof ActorStoppedException) {\n\t\t\t\tif (stopReason == null) {\n\t\t\t\t\tstopReason = e;\n\t\t\t\t}\n\t\t\t\tdestroy();\n\t\t\t} else {\n\t\t\t\tlogger.error(\"Exception in actor's process method\", e);\n\t\t\t\tif (processFailureStrategy == ProcessFailureStrategy.RESTART) {\n\t\t\t\t\tstatus = Status.INITIALIZING;\n\t\t\t\t\tinit();\n\t\t\t\t} else {\n\t\t\t\t\tstatus = Status.STOPPED;\n\t\t\t\t\tdestroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 27.440561973002474}, {"code": "private void processMailbox(){\n\t\tif (status == ActorStatus.FREE) {\n\t\treturn;\n\t}\n\ttry {\n\t\tprocessQueue(highPriorityQueue, highPriorityQueue.getActorThroughput());\n\t\tprocessQueue(normalPriorityQueue, normalPriorityQueue.getActorThroughput());\n\t\tif (status == ActorStatus.PROCESSING) {\n\t\t\tschedule(processMailbox);\n\t\t} else {\n\t\t\tset(ActorStatus.FREE);\n\t\t}\n\t} catch (InitializationFailure e) {\n\t\tsetStopReason(e);\n\t\tdestroy();\n\t} catch (Exception e) {\n\t\tif (status == ActorStatus.PROCESSING) {\n\t\t\tlogger.error(\"Failed to process messages\", e);\n\t\t\tprocessFailureStrategy.apply(e);\n\t\t\tif (status == ActorStatus.PROCESSING) {\n\t\t\t\tsetStopReason(e);\n\t\t\t\tdestroy();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 17.070258778405798}, {"code": "private void processMailbox(){\n\t\twhile (true) {\n\t\tif (isStop()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isPaused()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isTerminated()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isFailed()) {\n\t\t\treturn;\n\t\t}\n\t\tif (isRestarting()) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tif (processQueue(highPriorityQueue)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (processQueue(normalPriorityQueue)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (processQueue(lowPriorityQueue)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isStop()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isPaused()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isTerminated()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isFailed()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isRestarting()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset(Status.FREE);\n\t\t\tschedule(processQueue);\n\t\t\treturn;\n\t\t} catch (InitializationFailure e) {\n\t\t\tsetStopReason(e);\n\t\t\tdestroy();\n\t\t\treturn;\n\t\t} catch (Exception e) {\n\t\t\tif (isStop()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isPaused()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isTerminated()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isFailed()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isRestarting()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlog(e, \"Exception processing message\");\n\t\t\tset(Status.FAILED);\n\t\t\ttry {\n\t\t\t\tprocessFailure(e);\n\t\t\t} catch (Exception e2) {\n\t\t\t\tlog(e2, \"Exception processing failure\");\n\t\t\t\tset(Status.FAILED);\n\t\t\t}\n\t\t\tif (isStop()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isPaused()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isTerminated()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isFailed()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isRestarting()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset(Status.FREE);\n\t\t\tschedule(processQueue);\n\t\t\treturn;\n\t\t}\n\t", "CodeBleu_score": 17.98234733362902}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = cause;\n\t}\n\tdestroying = true;\n\texecutor.execute(new Runnable() {\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tdestroyInternal(cause);\n\t\t\t} catch (Exception e) {\n\t\t\t\twarn(\"Exception while destroying actor \" + Actor.this, e);\n\t\t\t}\n\t\t}\n\t});\n}", "CodeBleu_score": 20.66531657269211}, {"code": "public void destroy(Throwable cause){\n\t\tif (isDestroyed()) {\n\t\treturn;\n\t}\n\tif (getStopReason() == null) {\n\t\tsetStopReason(cause);\n\t}\n\tsetDestroyInProgress(true);\n\tgetExecutor().execute(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tdestroy(getStopReason(), cause);\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.warn(\"Exception during destroy\", e);\n\t\t\t}\n\t\t\tnotifyQueuedMessagesOfActorStopped();\n\t\t}\n\t});\n}", "CodeBleu_score": 20.287564883207185}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = new ActorStopReason(ActorStopReason.DESTROYED, cause);\n}\ndestroying = true;\nexecutor.execute(new Runnable() {\npublic void run() {\ntry {\nsetReady(false);\ndestroy0(stopReason.cause);\nnotifyQueuedMessages(stopReason);\n} catch (Exception e) {\nlogger.warn(\"Exception while destroying actor {}\", getActorName(), e);\n}\n}\n});\n}", "CodeBleu_score": 33.4847360364864}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.equals(getSysTenantId())) {\n\t\treturn true;\n\t}\n\ttry {\n\t\tTenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n\t\tRateLimit rateLimit = tenantProfile.getRateLimit(level);\n\t\tif (rateLimit.check(api)) {\n\t\t\treturn true;\n\t\t}\n\t\tprocess(rateLimit, api, tenantId, level);\n\t\treturn false;\n\t} catch (TenantProfileNotFoundException e) {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 25.898596273673835}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.equals(systemTenantId)) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n\tRateLimit rateLimit = tenantProfile.getRateLimit(api, level);\n\tif (rateLimit == null) {\n\t\treturn true;\n\t}\n\tif (!rateLimit.check(api, level)) {\n\t\tprocessRateLimitNotification(rateLimit);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 25.354340847052935}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (isSysTenantId(tenantId)) {\n\t\treturn true;\n\t}\n\ttry {\n\t\tTenantProfile tenantProfile = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n\t\tRateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n\t\tif (rateLimitConfiguration == null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn rateLimitConfiguration.checkRateLimit(api, level);\n\t} catch (TenantProfileNotFoundException e) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 31.905925255719303}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tsynchronized (sessions) {\n\t\tIterator<Map.Entry<String, DtlsSession>> iterator = sessions.entrySet().iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tMap.Entry<String, DtlsSession> entry = iterator.next();\n\t\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\t\tlogger.info(\"Removing expired session for \" + entry.getKey());\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.8246532202795}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - inactivityTimeout;\n\tsynchronized (dtlsSessions) {\n\t\tfor (Iterator<Entry<String, DtlsSession>> it = dtlsSessions.entrySet().iterator(); it.hasNext();) {\n\t\t\tEntry<String, DtlsSession> entry = it.next();\n\t\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\t\tlogger.info(\"DTLS session for \" + entry.getKey() + \" has expired\");\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.691557263198426}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tSet<Map.Entry<String, DtlsSession>> entries = sessions.entrySet();\n\tfor (Map.Entry<String, DtlsSession> entry : entries) {\n\t\tString key = entry.getKey();\n\t\tDtlsSession session = entry.getValue();\n\t\tlong lastActivityTime = session.getLastActivityTime();\n\t\tif (lastActivityTime < expirationTime) {\n\t\t\tsessions.remove(key);\n\t\t\tlogger.info(\"Removed session with key \" + key + \" because it has been inactive for \" + timeout + \" milliseconds\");\n\t\t}\n\t}\n}", "CodeBleu_score": 33.82080431343879}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn emptyList();\n\t} else {\n\t\tList<TsKvEntry> result = new ArrayList<>();\n\t\ttimeseries.forEach((key, value) -> value.forEach(json -> result.add(new BasicTsKvEntry(key, parseValue(json.get(\"value\"))))));\n\t\treturn result;\n\t}\n}", "CodeBleu_score": 33.30084522086712}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> ts = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tfor (JsonNode value : values) {\n\t\t\tTsKvEntry tsKvEntry = new BasicTsKvEntry(toLong(value.get(\"ts\").asText()), parseValue(value.get(\"value\")));\n\t\t\tts.add(tsKvEntry);\n\t\t}\n\t}\n\treturn ts;\n}", "CodeBleu_score": 38.38148904844591}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\tList<TsKvEntry> ts = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tfor (JsonNode value : entry.getValue()) {\n\t\t\tts.add(new BasicTsKvEntry(toLong(key), parseValue(value)));\n\t\t}\n\t}\n\treturn ts;\n}", "CodeBleu_score": 35.28181784159635}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tMap<String, String> request = new HashMap<String, String>();\n\trequest.put(\"refresh_token\", refreshToken);\n\trequest.put(\"client_id\", clientId);\n\trequest.put(\"client_secret\", clientSecret);\n\trequest.put(\"grant_type\", \"refresh_token\");\n\ttry {\n\t\tResponseEntity<String> response = restTemplate.postForEntity(authUrl, request, String.class);\n\t\tsetTokenInfo(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 42.69558295691339}, {"code": "public void refreshToken(){\n\t\t// Create a request map with the current refresh token\n\tMap<String, String> request = new HashMap<String, String>();\n\trequest.put(\"refresh_token\", getRefreshToken());\n\n\t// Send a POST request to the authentication endpoint\n\tResponseEntity<String> response = restTemplate.postForEntity(getAuthUrl(), request, String.class);\n\n\t// Update the token information with the current timestamp and the response body\n\tsetTokenInfo(response.getBody());\n}", "CodeBleu_score": 40.1589591239889}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", getRefreshToken());\n\tResponseEntity<String> responseEntity = postForEntity(getAuthenticationEndpoint(), requestMap, String.class);\n\tsetTokenInfo(responseEntity.getBody());\n\tsetLastTokenRefresh(currentTimeMillis());\n}", "CodeBleu_score": 43.923313705112854}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\t// Create a map to store the login request information.\n\tMap<String, String> loginRequest = new HashMap<>();\n\t// Set the username and password to the map.\n\tloginRequest.put(\"username\", usernameField.getText());\n\tloginRequest.put(\"password\", passwordField.getText());\n\t// Get the current timestamp.\n\tlong timestamp = System.currentTimeMillis();\n\t// Send the login request to the server.\n\tResponseEntity<String> response = restTemplate.postForEntity(url + \"/api/auth/login\", loginRequest, String.class);\n\t// Update the token information.\n\tsetTokenInfo(response.getBody(), timestamp);\n}", "CodeBleu_score": 60.55459457614675}, {"code": " private void doLogin(){\n\t String username = usernameField.getText();\n String password = passwordField.getText();\n long currentTime = currentTimeMillis();\n Map<String, Object> loginRequest = new HashMap<>();\n loginRequest.put(\"username\", username);\n loginRequest.put(\"password\", password);\n loginRequest.put(\"timestamp\", currentTime);\n\n// Send the login request to the server.\n ResponseEntity<Map<String, Object>> response = restTemplate.postForEntity(\"/api/auth/login\", loginRequest, Map.class);\n\n// Update the token information with the response data and the current timestamp.\n tokenInfo.setToken(response.getBody().get(\"token\"));\n tokenInfo.setExpirationTime(response.getBody().get(\"expirationTime\"));\n tokenInfo.setUsername(response.getBody().get(\"username\"));\n tokenInfo.setRole(response.getBody().get(\"role\"));\n tokenInfo.setTimestamp(currentTime);\n }", "CodeBleu_score": 52.99089976876187}, {"code": " private void doLogin(){\n\t\t// Get the current timestamp\n\tlong now = currentTimeMillis();\n\n\t// Create the login request map\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", password);\n\n\t// Send the login request\n\tResponseEntity<Map<String, Object>> response = postForEntity(\"/api/auth/login\", loginRequest, Map.class);\n\n\t// Update the token information\n\ttokenInfo.setToken(response.getBody().get(\"token\").toString());\n\ttokenInfo.setExpiration(now + Long.parseLong(response.getBody().get(\"expiresIn\").toString()));\n\ttokenInfo.setRefreshToken(response.getBody().get(\"refreshToken\").toString());\n}", "CodeBleu_score": 55.891725610991536}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\nResponse response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId);\nif (response.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nreturn Optional.ofNullable(response.getBody());\n}\n} catch (HttpClientErrorException ex) {\nthrow ex;\n}\n}", "CodeBleu_score": 53.84662404609131}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponse response = client.target(baseUri).path(\"api/device/{deviceId}\").resolveTemplate(\"deviceId\", deviceId).request().get();\n\t\tif (response.getStatus() == 200) {\n\t\t\treturn Optional.of(response.readEntity(Device.class));\n\t\t} else if (response.getStatus() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new ClientErrorException(response);\n\t\t}\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 53.89387761147667}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\tResponse response = getForEntity(\"/api/device/\" + deviceId.getId(), Device.class);\n\tif (response.getStatusCode().equals(HttpStatus.NOT_FOUND)) {\n\t\treturn Optional.empty();\n\t} else if (!response.getStatusCode().is2xxSuccessful()) {\n\t\tthrow new RuntimeException(\"HTTP error: \" + response.getStatusCode());\n\t}\n\treturn Optional.ofNullable(response.getBody());\n}", "CodeBleu_score": 44.497279558668986}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nRequestEntity<Device> requestEntity = new RequestEntity<>(device, HttpMethod.POST);\nResponseEntity<Device> responseEntity = restTemplate.exchange(\n\"http://localhost:8080/api/device-with-credentials\",\nHttpMethod.POST,\nrequestEntity,\nDevice.class);\nreturn Optional.ofNullable(responseEntity.getBody());\n} catch (HttpClientErrorException.NotFound ex) {\nreturn Optional.empty();\n}\n}", "CodeBleu_score": 43.81310689654345}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tDeviceWithCredentialsRequest request = new DeviceWithCredentialsRequest();\n\t\trequest.setDevice(device);\n\t\trequest.setCredentials(credentials);\n\t\treturn Optional.ofNullable(restTemplate.postForEntity(baseUrl + \"/api/device-with-credentials\", request, Device.class).getBody());\n\t}\n\tcatch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 43.78684452885855}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\nreturn Optional.ofNullable(restTemplate.postForEntity(\n\"http://localhost:8080/api/device-with-credentials\",\nnew DeviceWithCredentials(device, credentials),\nDevice.class\n).getBody());\n} catch (HttpClientErrorException e) {\nif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\nreturn Optional.empty();\n} else {\nthrow e;\n}\n}\n}", "CodeBleu_score": 42.08930033537372}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t}", "CodeBleu_score": 2.8022481803282675}, {"code": "brightness(addr, val){\n\t\tif (typeof addr === 'undefined') {\n\t\tthis.brightness = val;\n\t} else {\n\t\tthis.brightness[addr] = val;\n\t}\n\treturn this;\n}", "CodeBleu_score": 22.232661679573052}, {"code": "brightness(addr, val){\n\t\n}", "CodeBleu_score": 2.8022481803282675}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tObject.keys(LedControl.prototype).forEach(function(key) {\n\t\tif (typeof this[key] === 'function') {\n\t\t\tthis[key] = this[key].bind(this, addr);\n\t\t}\n\t}, this);\n\treturn this;\n}", "CodeBleu_score": 23.725326137761666}, {"code": "device(addr){\n\t\tObject.keys(LedControl.prototype).forEach(function(key) {\n\t\tthis[key] = this[key].bind(this, addr);\n\t}, this);\n\treturn this;\n}", "CodeBleu_score": 16.713675102918064}, {"code": "device(addr){\n\t\tvar self = this;\n\tObject.keys(LedControl.prototype).forEach(function(key) {\n\t\tif (typeof self[key] === 'function') {\n\t\t\tself[key] = self[key].bind(self, addr);\n\t\t}\n\t});\n\treturn self;\n}", "CodeBleu_score": 23.533255547445382}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tif (typeof methods === 'string') {\n\t\tmethods = [methods]\n\t}\n\tfor (let method of methods) {\n\t\tlet original = target[method]\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration\n\t\t\t\tduration = 1000\n\t\t\t}\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tcallback = function() {}\n\t\t\t}\n\t\t\tlet promises = []\n\t\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\t\tlet element = this[i]\n\t\t\t\tpromises.push(element[method](duration, callback))\n\t\t\t}\n\t\t\treturn Promise.all(promises).then(callback)\n\t\t}\n\t}\n}", "CodeBleu_score": 45.683682369716436}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method + 'WithCallback'] = function(duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\treturn this.map(element => {\n\t\t\t\treturn element[method](duration).then(callback);\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 27.783170152206637}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\tconst original = target[method]\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration\n\t\t\t\tduration = 1000\n\t\t\t}\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tcallback = () => {}\n\t\t\t}\n\t\t\tconst promises = []\n\t\t\tthis.forEach(element => {\n\t\t\t\tconst promise = new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(original.call(element))\n\t\t\t\t\t}, duration)\n\t\t\t\t})\n\t\t\t\tpromises.push(promise)\n\t\t\t})\n\t\t\tPromise.all(promises).then(callback)\n\t\t}\n\t})\n}", "CodeBleu_score": 44.348389601007035}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\tthis.input = \"\";\n\tthis.io.serialRead(this.port, this.baudrate, this.onSerialData);\n}", "CodeBleu_score": 3.6755720091933077}, {"code": "listen(){\n\t\t// Initialize an empty input string\n\tvar input = '';\n\n\t// Start a read loop on the specified serial port\n\tthis.io.serialRead(this.serialPort, (data) => {\n\t\t// Append the data to the input string\n\t\tinput += data;\n\n\t\t// Split the input string into sentences\n\t\tvar sentences = input.split('\\r\n');\n\n\t\t// Process each sentence\n\t\tfor (var i = 0; i < sentences.length - 1; i++) {\n\t\t\t// Process the sentence\n\t\t\tthis.parseNmeaSentence(sentences[i]);\n\t\t}\n\n\t\t// Retain any incomplete sentence for the next read\n\t\tinput = sentences[sentences.length - 1];\n\t});\n}", "CodeBleu_score": 39.96764712633242}, {"code": "listen(){\n\t\tthis.input = \"\";\n\tthis.io.serialRead(this.port, (data) => {\n\t\tthis.input += data.toString();\n\t\tlet sentences = this.input.split(\"\\r\n\");\n\t\tthis.input = sentences.pop();\n\t\tfor (let sentence of sentences) {\n\t\t\tthis.parseNmeaSentence(sentence);\n\t\t}\n\t});\n}", "CodeBleu_score": 25.164204731227702}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t active_channels = 0;\n\tuint8_t bytes_per_sample = 0;\n\tuint8_t buffer_size = 0;\n\n\tif (sequence->resolution == 12) {\n\t\tbytes_per_sample = 2;\n\t} else if (sequence->resolution == 16) {\n\t\tbytes_per_sample = 4;\n\t} else {\n\t\tLOG_ERR(\"Unsupported resolution %d\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\tfor (uint8_t i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tbuffer_size = active_channels * bytes_per_sample;\n\n\tif (buffer_size > config->buffer_size) {\n\t\tLOG_ERR(\"Insufficient memory for %d-bit conversion\", sequence->resolution);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.83785752623634}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t num_channels = 0U;\n\tuint32_t buffer_size = 0U;\n\tuint32_t channel_size = 0U;\n\tuint32_t i;\n\n\tif (sequence->resolution != config->resolution) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tfor (i = 0U; i < sequence->channels; i++) {\n\t\tif (sequence->channels & BIT(sequence->channels)) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (num_channels == 0U) {\n\t\treturn -EINVAL;\n\t}\n\n\tchannel_size = sizeof(uint16_t);\n\tbuffer_size = num_channels * channel_size;\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.586537140209565}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tu32_t num_channels = 0U;\n\tu32_t buf_size = 0U;\n\n\t/*\n\t * Check if the sequence is NULL.\n\t */\n\tif (sequence == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the buffer is NULL.\n\t */\n\tif (sequence->buffer == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the buffer size is 0.\n\t */\n\tif (sequence->buffer_size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the channel list is NULL.\n\t */\n\tif (sequence->channels == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the number of channels is 0.\n\t */\n\tif (sequence->channels->channel_count == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the channel list is NULL.\n\t */\n\tif (sequence->channels->channels == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the channel list size is 0.\n\t */\n\tif (sequence->channels->channel_count == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the channel list size is greater than the maximum number of channels.\n\t */\n\tif (sequence->channels->channel_count > ADC_AD559X_MAX_CHANNELS) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the sample size is 0.\n\t */\n\tif (sequence->resolution == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if the sample size is greater than the maximum sample size.\n\t */\n\tif (sequence->resolution > ADC_AD559X_MAX_SAMPLE_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Count the number of active channels.\n\t */\n\tfor (u32_t i = 0U; i < sequence->channels->channel_count; i++) {\n\t\tif (sequence->channels->channels[i].channel_", "CodeBleu_score": 42.9145440717311}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_context *context = sequence->user_data;\n\tint err;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution requested\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > NUM_CHANNELS) {\n\t\tLOG_ERR(\"Invalid channel requested\");\n\t\treturn -EINVAL;\n\t}\n\n\tadc_ad559x_validate_buffer_size(dev, sequence->buffer, sequence->buffer_size);\n\n\tcontext->buffer = sequence->buffer;\n\tcontext->buffer_size = sequence->buffer_size;\n\tcontext->read_count = 0;\n\n\terr = adc_context_start_read(context, dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tadc_context_wait_for_completion(context);\n\n\treturn 0;\n}", "CodeBleu_score": 51.16529471134046}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channel_mask = 0;\n\tuint8_t channel_count = 0;\n\tuint8_t channel_index = 0;\n\tuint8_t channel_index_mask = 0;\n\tuint8_t channel_index_shift = 0;\n\tuint8_t channel_mask_shift = 0;\n\tuint8_t channel_count_shift = 0;\n\tuint8_t channel_count_mask = 0;\n\tuint8_t channel_mask_value = 0;\n\tuint8_t channel_count_value = 0;\n\tuint8_t channel_mask_bit = 0;\n\tuint8_t channel_count_bit = 0;\n\tuint8_t channel_mask_lsb = 0;\n\tuint8_t channel_count_lsb = 0;\n\tuint8_t channel_mask_msb = 0;\n\tuint8_t channel_count_msb = 0;\n\tuint8_t channel_mask_lsb_value = 0;\n\tuint8_t channel_count_lsb_value = 0;\n\tuint8_t channel_mask_msb_value = 0;\n\tuint8_t channel_count_msb_value = 0;\n\tuint8_t channel_mask_lsb_shift = 0;\n\tuint8_t channel_count_lsb_shift = 0;\n\tuint8_t channel_mask_msb_shift = 0;\n\tuint8_t channel_count_msb_shift = 0;\n\tuint8_t channel_mask_lsb_mask = 0;\n\tuint8_t channel_count_lsb_mask = 0;\n\tuint8_t channel_mask_msb_mask = 0;\n\tuint8_t channel_count_msb_mask = 0;\n\tuint8_t channel_mask_lsb_msb_mask = 0;\n\tuint8_t channel_", "CodeBleu_score": 13.129452167089795}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_context *context = sequence->user_data;\n\tint err;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution requested. Expected %d bits, got %d bits\", config->resolution, sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\terr = adc_ad559x_validate_channels(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tadc_context_start_read(context, sequence);\n\n\tadc_context_wait_for_completion(context);\n\n\treturn 0;\n}", "CodeBleu_score": 46.45183115431668}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tint err;\n\n\t/* Make sure the DMA output buffer is ready to be written to. */\n\terr = dma_buf_begin_cpu_access(ctx->buffer, DMA_BUF_WRITE);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"dma_buf_begin_cpu_access failed: %d", "CodeBleu_score": 14.751766311836942}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tint err;\n\n\t/* a context may be simultaneously in use by multiple threads */\n\tpthread_mutex_lock(&ctx->mutex);\n\n\t/* ensure that the ADC has been configured */\n\tif (!ctx->configured) {\n\t\tfprintf(stderr, \"adc_context_start_sampling(): the ADC has not been configured", "CodeBleu_score": 17.031911035866624}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tint ret;\n\n\tif (ctx->buffer_size > 0) {\n\t\tret = adc_read(ctx->dev, &ctx->buffer[0], ctx->buffer_size);\n\t\tif (ret != 0) {\n\t\t\tSYS_LOG_ERR(\"Could not read sample buffer\");\n\t\t}\n\t}\n\n\tadc_enable_channel(ctx->dev, ctx->channel);\n\tadc_start_read(ctx->dev, ctx->buffer, ctx->buffer_size);\n}", "CodeBleu_score": 41.53001896561077}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (ctx->buffer_processing_required) {\n\t\tif (repeat_sampling) {\n\t\t\tctx->buffer = ctx->buffer_repeat;\n\t\t} else {\n\t\t\tctx->buffer = ctx->buffer_raw;\n\t\t}\n\t}\n}", "CodeBleu_score": 46.23401988266917}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\t/* Update buffer pointer to new data container */\n\t\tctx->buffer = ctx->buffer_repeat;\n\t}\n\telse {\n\t\t/* Update buffer pointer to new data container */\n\t\tctx->buffer = ctx->buffer_raw;\n\t}\n}", "CodeBleu_score": 45.849027876409835}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buf_ptr = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buf_ptr = ctx->buffer;\n\t}\n}", "CodeBleu_score": 46.686993367571034}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint8_t channel;\n\tint err;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < data->channels; channel++) {\n\t\t\terr = adc_read_channel(data->dev, channel, &data->buffer[channel]);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"ADC read failed %d\", err);\n\t\t\t\tadc_context_complete(data->dev, err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tadc_context_on_sampling_done(data->dev, data, NULL);\n\t}\n}", "CodeBleu_score": 39.15814135188804}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint err;\n\tuint8_t channel;\n\tuint8_t channel_index;\n\tint32_t adc_value;\n\tbool channel_active;\n\tuint8_t active_channels;\n\tuint8_t channel_buffer[ADC_AD559X_MAX_CHANNELS];\n\tint32_t *buffer;\n\tint32_t *buffer_ptr;\n\tint32_t *buffer_end;\n\tint32_t *buffer_start;\n\tint32_t *buffer_pos;\n\tint32_t *buffer_next_pos;\n\tstruct device *dev;\n\tstruct adc_context *ctx;\n\tstruct adc_sequence sequence;\n\tstruct k_sem *sem;\n\n\tdev = data->dev;\n\tctx = &data->ctx;\n\tsem = &data->sem;\n\tbuffer = data->buffer;\n\tbuffer_ptr = data->buffer_ptr;\n\tbuffer_end = data->buffer_end;\n\tbuffer_start = data->buffer_start;\n\tbuffer_pos = data->buffer_pos;\n\tbuffer_next_pos = data->buffer_next_pos;\n\n\twhile (1) {\n\t\tk_sem_take(sem, K_FOREVER);\n\n\t\tactive_channels = data->active_channels;\n\t\tchannel_index = 0;\n\t\tbuffer_pos = buffer_start;\n\n\t\twhile (active_channels) {\n\t\t\tchannel_active = (active_channels & 0x01);\n\t\t\tactive_channels >>= 1;\n\n\t\t\tif (channel_active) {\n\t\t\t\tchannel = data->channels[channel_index].channel;\n\t\t\t\tsequence.channels = BIT(channel);\n\t\t\t\tsequence.buffer = &channel_buffer[0];\n\t\t\t\tsequence.buffer_size = sizeof(channel_buffer);\n\t\t\t\tsequence.resolution = 12;\n\t\t\t\tsequence.calibrate = false;\n\t\t\t\tsequence.differential = false;\n\n\t\t\t\terr = adc_read(dev, &sequence);\n\t\t\t\tif (err) {\n\t\t\t\t\tLOG_ERR(\"ADC read failed with code %d\", err);\n\t\t\t\t\tadc_context_complete(ctx, err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadc_value", "CodeBleu_score": 21.39555583350383}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (true) {\n\t\tk_sem_take(&data->acquisition_lock, K_FOREVER);\n\t\tfor (int i = 0; i < data->channel_count; i++) {\n\t\t\tstruct adc_channel_cfg *channel = &data->channels[i];\n\t\t\tif (channel->active) {\n\t\t\t\tint32_t raw_value;\n\t\t\t\tint rc = adc_read(data->dev, channel->channel_id, &raw_value);\n\t\t\t\tif (rc) {\n\t\t\t\t\tLOG_ERR(\"ADC read failed (err %d)\", rc);\n\t\t\t\t\tadc_context_complete(&data->ctx, rc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tchannel->buffer[data->buffer_index] = raw_value;\n\t\t\t}\n\t\t}\n\t\tdata->buffer_index++;\n\t\tif (data->buffer_index >= data->buffer_length) {\n\t\t\tadc_context_on_sampling_done(&data->ctx, data->buffer, data->buffer_length);\n\t\t\tdata->buffer_index = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.63504742406496}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tuint8_t config;\n\tint err;\n\tuint32_t timeout;\n\tuint32_t ready_time_usec;\n\tuint32_t sleep_time_usec;\n\tuint32_t sleep_time_usec_max = 100;\n\tstruct ads1112_data *drv_data = dev->driver_data;\n\tconst struct ads1112_config *cfg = dev->config;\n\n\t/* Get the current ready time */\n\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tready_time_usec = ADS1112_CONFIG_DR_TO_USEC(config & ADS1112_CONFIG_DR_MASK);\n\n\t/*\n\t * If the ready time is 0, the device is always ready.\n\t * If the ready time is 1, the device is ready after 3.75 ms.\n\t * If the ready time is 2, the device is ready after 15.625 ms.\n\t * If the ready time is 3, the device is ready after 60 ms.\n\t * If the ready time is 4, the device is ready after 240 ms.\n\t * If the ready time is 5, the device is ready after 600 ms.\n\t * If the ready time is 6, the device is ready after 2400 ms.\n\t * If the ready time is 7, the device is ready after 6000 ms.\n\t */\n\tif (ready_time_usec == 0) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Calculate the sleep time for the current ready time.\n\t * The sleep time is the ready time minus the time it takes to read the configuration register.\n\t */\n\tsleep_time_usec = ready_time_usec - ADS1112_CONFIG_REG_READ_USEC;\n\n\t/*\n\t * If the sleep time is greater than the maximum sleep time,\n\t * set the sleep time to the maximum sleep time.\n\t */\n\tif (sleep_time_usec > sleep_time_usec_max) {", "CodeBleu_score": 38.80943767443602}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *cfg = dev->config;\n\tuint8_t status;\n\tint err;\n\n\tk_sleep(cfg->ready_time_usec);\n\n\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &status, sizeof(status));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (status & ADS1112_CONFIG_OS_BUSY) {\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 31.37081579898176}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tint err;\n\tuint16_t reg_val;\n\tint ready_time_us;\n\n\t/* Get the ready time from the configuration register */\n\terr = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t/* Convert the ready time to microseconds */\n\tready_time_us = ads1112_ready_time_usec(reg_val);\n\n\t/* Sleep for the ready time */\n\tk_sleep(K_USEC(ready_time_us));\n\n\t/* Check the status register to see if the device is ready */\n\terr = ads1112_read_reg(dev, ADS1112_REG_STATUS, &reg_val);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t/* Check the device status */\n\tif (reg_val & ADS1112_STATUS_DRDY) {\n\t\treturn 0;\n\t} else {\n\t\treturn -EBUSY;\n\t}\n}", "CodeBleu_score": 43.96139478395393}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size;\n\tint num_samplings = sequence->options.extra_samplings + 1;\n\tint num_channels = sequence->channels;\n\n\t/*\n\t * The buffer size must be at least the number of channels multiplied by the number of samplings.\n\t */\n\tbuffer_size = num_channels * num_samplings;\n\n\tif (buffer_size < ADS1112_MIN_BUFFER_SIZE) {\n\t\tdev_err(&g_ads1112_dev->dev, \"The buffer size (%d) is less than the minimum required size (%d).\n\",\n\t\t\tbuffer_size, ADS1112_MIN_BUFFER_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 43.4886853554867}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = 0;\n\tint num_samplings = 0;\n\tint num_extra_samplings = 0;\n\tint i;\n\n\tif (sequence->options & ADC_OPTION_HW_TRIGGER) {\n\t\t/*\n\t\t * If the hardware trigger option is enabled, the buffer size must be large enough to\n\t\t * hold one sample for each channel.\n\t\t */\n\t\tbuffer_size = sequence->channels;\n\t} else {\n\t\t/*\n\t\t * If the hardware trigger option is disabled, the buffer size must be large enough to\n\t\t * hold one sample for each channel, plus one extra sample for each channel for each\n\t\t * extra sampling specified in the sequence options.\n\t\t */\n\t\tnum_samplings = 1;\n\t\tnum_extra_samplings = 0;\n\t\tfor (i = 0; i < ADC_MAX_EXTRA_SAMPLINGS; i++) {\n\t\t\tif (sequence->extra_samplings & BIT(i)) {\n\t\t\t\tnum_extra_samplings++;\n\t\t\t\tnum_samplings += 1 + sequence->extra_samplings_num[i];\n\t\t\t}\n\t\t}\n\t\tbuffer_size = sequence->channels * num_samplings + num_extra_samplings;\n\t}\n\n\tif (buffer_size > ADC_BUFFER_SIZE) {\n\t\tLOG_ERR(\"Buffer size %d is too large. Maximum is %d.\", buffer_size, ADC_BUFFER_SIZE);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 40.94924754695703}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint8_t num_samplings = 0;\n\tuint8_t num_extra_samplings = 0;\n\tuint8_t buffer_size;\n\tuint8_t i;\n\n\t/*\n\t * Calculate the number of samplings in the sequence.\n\t */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tnum_samplings += sequence->channels[i].count;\n\t}\n\n\t/*\n\t * Calculate the number of extra samplings specified in the sequence options.\n\t */\n\tif (sequence->options) {\n\t\tnum_extra_samplings = (sequence->options >> 8) & 0xFF;\n\t}\n\n\t/*\n\t * Calculate the buffer size required for the sequence.\n\t */\n\tbuffer_size = num_samplings + num_extra_samplings;\n\n\t/*\n\t * If the buffer size is less than the required size, log an error message and return an error code.\n\t */\n\tif (buffer_size < sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size is less than the required size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 37.78640577042343}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\trc = adc_context_start_read(&data->adc, sequence, ads1112_adc_read_callback,\n\t\t\t\t   wait);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 66.60977433524735}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *drv_data = dev->data;\n\tstruct ads1112_context *context = sequence->user_data;\n\tint rc;\n\n\t__ASSERT_NO_MSG(context);\n\t__ASSERT_NO_MSG(context->buffer);\n\t__ASSERT_NO_MSG(context->buffer_size);\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\t/* Set the sequence buffer to the device data */\n\tdrv_data->buffer = context->buffer;\n\tdrv_data->buffer_size = context->buffer_size;\n\n\t/* Start the ADC read context */\n\trc = adc_context_start_read(&drv_data->adc, sequence, wait);\n\n\treturn rc;\n}", "CodeBleu_score": 53.97303976646095}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *drv_data = dev->data;\n\tint err_code = 0;\n\n\tif (!drv_data->adc_context) {\n\t\tdrv_data->adc_context =\n\t\t\tadc_context_start_read(&drv_data->adc, sequence,\n\t\t\t\t\t      ads1112_adc_callback, dev);\n\t\tif (!drv_data->adc_context) {\n\t\t\tLOG_ERR(\"ADC context start read failed\");\n\t\t\terr_code = -EBUSY;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"ADC context is busy\");\n\t\terr_code = -EBUSY;\n\t}\n\n\tif (err_code == 0 && wait) {\n\t\terr_code = adc_context_wait_for_completion(drv_data->adc_context,\n\t\t\t\t\t\t\tK_FOREVER);\n\t}\n\n\treturn err_code;\n}", "CodeBleu_score": 44.65907445549448}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint err;\n\tstruct device *dev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Cannot get device binding\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = audio_codec_apply_properties(dev, argv[2], argv[3]);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to apply properties to device %s\", argv[1]);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 58.33608111791606}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint err;\n\tconst char *codec_dev_name = argv[1];\n\tconst char *prop_name = argv[2];\n\tconst char *prop_value = argv[3];\n\tstruct device *dev;\n\n\tdev = device_get_binding(codec_dev_name);\n\tif (!dev) {\n\t\tLOG_ERR(\"Cannot get the binding object for %s\", codec_dev_name);\n\t\treturn -ENODEV;\n\t}\n\n\terr = audio_codec_apply_properties(dev, prop_name, prop_value);\n\tif (err) {\n\t\tLOG_ERR(\"Cannot apply property %s to device %s\", prop_name, codec_dev_name);\n\t\treturn err;\n\t}\n\n\tLOG_INF(\"Successfully applied property %s to device %s\", prop_name, codec_dev_name);\n\n\treturn 0;\n}", "CodeBleu_score": 53.207243851596466}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint err;\n\tstruct device *dev;\n\tstruct audio_codec_cfg_data cfg;\n\tint i;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Cannot find %s device\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 2; i < argc; i++) {\n\t\terr = audio_codec_parse_property(argv[i], &cfg);\n\t\tif (err) {\n\t\t\tshell_error(sh, \"Cannot parse property %s\", argv[i]);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = audio_codec_apply_properties(dev, &cfg);\n\t\tif (err) {\n\t\t\tshell_error(sh, \"Cannot apply property %s\", argv[i]);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 53.10148743881638}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_dev_data *dd = dev->data;\n\tint ret = 0;\n\tu8_t i2s_cmd = 0;\n\tu8_t i2s_state = dd->i2s_state;\n\tu8_t i2s_cmd_mask = dd->i2s_cmd_mask;\n\n\t/*\n\t * Check if the device is in the correct state for the requested command\n\t */\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (i2s_state != MPXXDTTYY_I2S_STATE_CONFIGURED) {\n\t\t\tLOG_ERR(\"Device is not in the correct state for START command\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (i2s_state != MPXXDTTYY_I2S_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device is not in the correct state for STOP command\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported DMIC trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Set the I2S command based on the requested command\n\t */\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\ti2s_cmd = MPXXDTTYY_I2S_CMD_START;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\ti2s_cmd = MPXXDTTYY_I2S_CMD_STOP;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported DMIC trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Update the I2S command and state\n\t */\n\ti2s_cmd_mask |= i2s_cmd;\n\ti2s_state = (i2s_cmd == MPXXDTTYY_I2S_CMD_START) ? MPXXDTTYY_I2S_STATE_ACTIVE : MPXXDTTYY_I2S_STATE_CONFIGURED;\n\n\t/*\n\t * Send the I2S command and update the device state if successful\n\t */\n\tret = mpxxdtyy_", "CodeBleu_score": 51.731300255478196}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_dev_data *dd = dev->data;\n\tint ret;\n\n\t/* Check that the device is in the configured state */\n\tif (dd->state != MPXXDTYY_STATE_CONFIGURED) {\n\t\tLOG_ERR(\"Device is not in configured state\");\n\t\treturn -EIO;\n\t}\n\n\t/* Check that the device is in the active state */\n\tif (dd->state != MPXXDTYY_STATE_ACTIVE) {\n\t\tLOG_ERR(\"Device is not in active state\");\n\t\treturn -EIO;\n\t}\n\n\t/* Check that the command is valid */\n\tif (cmd != DMIC_TRIGGER_START && cmd != DMIC_TRIGGER_STOP) {\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Set the I2S command based on the specified trigger command */\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tdd->i2s_cmd = MPXXDTYY_I2S_CMD_START;\n\t} else {\n\t\tdd->i2s_cmd = MPXXDTYY_I2S_CMD_STOP;\n\t}\n\n\t/* Send the I2S command to the device */\n\tret = mpxxdtyy_i2s_cmd_write(dev, dd->i2s_cmd);\n\tif (ret != 0) {\n\t\tLOG_ERR(\"Failed to send I2S command\");\n\t\treturn ret;\n\t}\n\n\t/* Update the device state */\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tdd->state = MPXXDTYY_STATE_ACTIVE;\n\t} else {\n\t\tdd->state = MPXXDTYY_STATE_CONFIGURED;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.15492432305494}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_dev_data *dd = DEV_DATA(dev);\n\tint ret = 0;\n\n\tif (dd->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tret = mpxxdtyy_i2s_start(dev);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"mpxxdtyy_i2s_start failed\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"mpxxdtyy_i2s_stop failed\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Unsupported DMIC trigger command\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (dd->state == MPXXDTYY_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"mpxxdtyy_i2s_stop failed\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Device is active, cannot issue new command\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Device is not configured\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 30.096201797616988}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = 0;\n\n\t/* Retrieve the current configuration and data from the device */\n\tauxdisplay_hd44780_get_config(dev);\n\tauxdisplay_hd44780_get_data(dev);\n\n\t/* Initialize the display mode command */\n\tcmd = auxdisplay_hd44780_command(dev, AUXDISPLAY_HD44780_CMD_DISPLAY_MODE);\n\n\t/* Modify the command based on the current cursor and position blink settings */\n\tif (data->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK_ENABLE;\n\t}\n\tif (data->cursor_reverse) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_REVERSE;\n\t}\n\tif (data->cursor_enable) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ENABLE;\n\t}\n\tif (data->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK_ENABLE;\n\t}\n\tif (data->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK_ENABLE;\n\t}\n\tif (data->display_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_BLINK_ENABLE;\n\t}\n\tif (data->display_reverse) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_REVERSE;\n\t}\n\tif (data->display_enable) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ENABLE;\n\t}\n\n\t/* If the display is enabled, set the corresponding flag */\n\tif (enabled) {\n\t\tdata->display_enabled = true;\n\t}\n\n\t/* Send the command to the device to update the display mode */\n\tauxdisplay_hd44780_write", "CodeBleu_score": 59.37852438900059}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\n\t/* Retrieve the current configuration and data */\n\tuint8_t config = auxdisplay_hd44780_get_config(dev);\n\tuint8_t data_pins = auxdisplay_hd44780_get_data_pins(dev);\n\n\t/* Initialize the display mode command */\n\tuint8_t command = auxdisplay_hd44780_command_display_mode_init(config, data_pins);\n\n\t/* Modify the command based on the current cursor and position blink settings */\n\tif (data->cursor_blink) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK;\n\t}\n\tif (data->position_blink) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_POSITION_BLINK;\n\t}\n\n\t/* If the display is enabled, set the corresponding flag */\n\tif (enabled) {\n\t\tdata->display_enabled = true;\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ENABLED;\n\t} else {\n\t\tdata->display_enabled = false;\n\t}\n\n\t/* Send the command to the device to update the display mode */\n\tauxdisplay_hd44780_command(dev, command);\n}", "CodeBleu_score": 58.86229639136653}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = 0;\n\n\t/* Retrieve the current configuration and data */\n\tauxdisplay_hd44780_get_config(dev);\n\tauxdisplay_hd44780_get_data(dev);\n\n\t/* Set the display mode command */\n\tif (data->config.cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON_BLINK;\n\t} else if (data->config.cursor_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON;\n\t} else {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_OFF;\n\t}\n\n\t/* Set the display mode */\n\tif (enabled) {\n\t\tdata->display_mode = cmd;\n\t\tauxdisplay_hd44780_send_command(dev, cmd);\n\t} else {\n\t\tdata->display_mode = AUXDISPLAY_HD44780_DISPLAY_OFF;\n\t}\n}", "CodeBleu_score": 59.704248011811934}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tconst struct auxdisplay_itron_data *data = dev->data;\n\tint ret = 0;\n\n\tif (config->busy_gpio_port == 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 62.42537058400889}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tconst struct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\n\tif (config->busy_gpio == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_gpio, &data->busy_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn data->busy_pin;\n}", "CodeBleu_score": 67.44882019854052}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (!config->busy_gpio_port) {\n\t\tLOG_ERR(\"Busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Cannot get busy GPIO pin status\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 61.18945992554734}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tu8_t buffer[2];\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\treturn i2c_write_dt(dev, buffer, sizeof(buffer), config->i2c_write_dt);\n}", "CodeBleu_score": 61.74473832317871}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tu8_t command_buffer[2];\n\tcommand_buffer[0] = K_MSEC(CONFIG_AUXDISPLAY_SERLCD_SPECIAL_COMMAND_DELAY);\n\tcommand_buffer[1] = command;\n\treturn i2c_write_dt(dev, &command_buffer[0], sizeof(command_buffer));\n}", "CodeBleu_score": 46.01372996360989}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\tint rc;\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\trc = i2c_write_dt(dev, buf, sizeof(buf));\n\tif (rc < 0) {\n\t\treturn rc;\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay_ms));\n\n\treturn 0;\n}", "CodeBleu_score": 68.77198205183264}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_config *config = dev->config;\n\tuint8_t *mem = config->memory;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(mem, offset, size)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.69747485071409}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_dev_cfg *cfg = dev->config;\n\tconst struct bbram_emul_data *data_cfg = cfg->data;\n\tconst struct bbram_emul_range *range;\n\tsize_t i;\n\n\t/* Check if the requested read size is valid */\n\tif (size == 0 || size > data_cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the read operation does not exceed the memory bounds */\n\tfor (i = 0; i < data_cfg->range_num; i++) {\n\t\trange = &data_cfg->range[i];\n\t\tif (range->offset <= offset &&\n\t\t    (range->offset + range->size) > (offset + size)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == data_cfg->range_num) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the read operation does not involve invalid memory */\n\tif (bbram_emul_check_invalid(data_cfg, offset, size) != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Copy the data from the specified offset in the device's memory to the provided buffer */\n\tmemcpy(data, data_cfg->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 58.626547200142156}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tint ret;\n\tstruct bbram_emul_dev_data *dev_data = dev->data;\n\n\t/* Check if the requested read size is valid */\n\tif (size > BBRAM_EMUL_MAX_READ_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the read operation does not exceed the memory bounds or involve invalid memory */\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Perform the read operation */\n\tmemcpy(data, dev_data->memory + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 64.80619988495499}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_dev_cfg *cfg = DEV_CFG(dev);\n\tuint8_t *mem = cfg->mem;\n\tsize_t dev_size = cfg->size;\n\tint err = 0;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev) != 0) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(mem + offset, data, size);\n\n\treturn err;\n}", "CodeBleu_score": 58.64952197628156}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_dev_data *dev_data = dev->data;\n\tuint8_t *mem = dev_data->mem;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.62361060741657}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tconst struct bbram_emul_dev_cfg *cfg = dev->config;\n\tstruct bbram_emul_data *data_dev = dev->data;\n\tuint8_t *mem_start = data_dev->mem_start;\n\tuint8_t *mem_end = data_dev->mem_end;\n\tuint8_t *mem_ptr = mem_start + offset;\n\tuint8_t *mem_ptr_end = mem_end + offset;\n\tuint8_t *data_ptr = (uint8_t *)data;\n\tuint8_t *data_ptr_end = data_ptr + size;\n\tuint8_t *data_ptr_tmp;\n\tint ret;\n\n\t/* Check if the write size is valid */\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM */\n\tif ((offset + size) > data_dev->mem_size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state */\n\tif (data_dev->invalid_state) {\n\t\treturn -EIO;\n\t}\n\n\t/* Copy data to BBRAM */\n\tdata_ptr_tmp = data_ptr;\n\twhile (data_ptr_tmp < data_ptr_end) {\n\t\t*mem_ptr = *data_ptr_tmp;\n\t\tmem_ptr++;\n\t\tdata_ptr_tmp++;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state */\n\tif (data_dev->invalid_state) {\n\t\treturn -EIO;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state */\n\tif (data_dev->invalid_state) {\n\t\treturn -EIO;\n\t}\n\n\t/* Return success */\n\treturn 0;\n}", "CodeBleu_score": 45.62485439608742}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tARG_UNUSED(sh);\n\n\tif (argc == 1) {\n\t\tshell_error(sh, \"No BBRAM device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Could not get BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.43952463470892}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Error: BBRAM device not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Error: BBRAM device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 83.49330525680243}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc == 1) {\n\t\tshell_error(sh, \"Error: BBRAM device not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Error: BBRAM device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 78.61570833016339}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct uart_h4_dev_cfg *cfg = DEV_CFG(dev);\n\tuint8_t *hdr_buf = cfg->hdr_buf;\n\tuint8_t *hdr_buf_end = cfg->hdr_buf + cfg->hdr_buf_size;\n\tsize_t num_bytes_read;\n\n\tnum_bytes_read = uart_fifo_read(dev, hdr_buf, cfg->hdr_buf_size);\n\tif (num_bytes_read != cfg->hdr_buf_size) {\n\t\tLOG_ERR(\"Failed to read header data (%d/%d)\", num_bytes_read,\n\t\t\tcfg->hdr_buf_size);\n\t} else {\n\t\tcfg->hdr_buf_rem = cfg->hdr_buf_size - num_bytes_read;\n\t}\n}", "CodeBleu_score": 41.7560001679536}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct uart_h4_dev_cfg *cfg = DEV_CFG(dev);\n\tstruct uart_h4_rx *rx = &cfg->rx;\n\tint err;\n\n\tif (rx->hdr_len) {\n\t\terr = uart_fifo_read(dev, rx->hdr + rx->hdr_len, sizeof(rx->hdr) - rx->hdr_len);\n\t\tif (err) {\n\t\t\tLOG_ERR(\"Failed to read H4 header (%d)\", err);\n\t\t\treturn;\n\t\t}\n\n\t\trx->hdr_len += err;\n\t}\n}", "CodeBleu_score": 42.899906445478585}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tuint8_t hdr_len;\n\tuint8_t *hdr_buf;\n\tuint8_t hdr_buf_len;\n\tuint8_t hdr_buf_rem;\n\tuint8_t hdr_buf_idx;\n\tuint8_t hdr_buf_rem_idx;\n\tuint8_t hdr_buf_rem_len;\n\tuint8_t hdr_buf_rem_rem;\n\tuint8_t hdr_buf_rem_rem_idx;\n\tuint8_t hdr_buf_rem_rem_len;\n\tuint8_t hdr_buf_rem_rem_rem;\n\tuint8_t hdr_buf_rem_rem_rem_idx;\n\tuint8_t hdr_buf_rem_rem_rem_len;\n\tuint8_t hdr_buf_rem_rem_rem_rem;\n\tuint8_t hdr_buf_rem_rem_rem_rem_idx;\n\tuint8_t hdr_buf_rem_rem_rem_rem_len;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem_idx;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem_len;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem_rem;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem_rem_idx;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem_rem_len;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem_rem_rem;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem_rem_rem_idx;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem_rem_rem_len;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem_rem_rem_rem;\n\tuint8_t hdr_buf_rem_rem_rem_rem_rem_rem_rem_rem_idx;\n\tuint8_t hdr_", "CodeBleu_score": 6.780834921156939}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t n = 0;\n\twhile (n < len) {\n\t\tconst size_t chunk = MIN(len - n, sizeof(buf));\n\t\tconst size_t r = uart_fifo_read(uart, buf, chunk);\n\t\tif (r == 0) {\n\t\t\tLOG_ERR(\"Failed to read %d bytes from UART device %s\", len, uart->name);\n\t\t\treturn 0;\n\t\t}\n\t\tn += r;\n\t}\n\treturn n;\n}", "CodeBleu_score": 41.93110704399141}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read = 0;\n\n\twhile (len > 0) {\n\t\tsize_t bytes_to_read = MIN(sizeof(buf), len);\n\t\tint ret = uart_fifo_read(uart, buf, bytes_to_read);\n\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"uart_fifo_read failed with code %d\", ret);\n\t\t\treturn bytes_read;\n\t\t}\n\n\t\tif (ret == 0) {\n\t\t\tLOG_ERR(\"read timed out\");\n\t\t\treturn bytes_read;\n\t\t}\n\n\t\tbytes_read += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 34.89654273511921}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t read_len = 0;\n\tuint8_t tmp[33];\n\twhile (len > 0) {\n\t\tconst size_t tmp_len = (len > sizeof(tmp)) ? sizeof(tmp) : len;\n\t\tconst size_t read_len = uart_fifo_read(uart, tmp, tmp_len);\n\t\tif (read_len == 0) {\n\t\t\tLOG_ERR(\"Could not read from UART device %s\", uart->name);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= read_len;\n\t}\n\treturn read_len;\n}", "CodeBleu_score": 33.971824460684374}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *o;\n\tstruct zbus_observer *o_next;\n\tuint8_t hop = ZBUS_OBSERVER_PRIORITY_LOWEST;\n\tzbus_spinlock_lock(&chan->lock);\n\tzlist_for_each_entry_safe(o, o_next, &chan->observers, _next) {\n\t\tif (o->priority > hop && o->enabled)\n\t\t\thop = o->priority;\n\t}\n\tchan->hop = hop;\n\tzbus_spinlock_unlock(&chan->lock);\n}", "CodeBleu_score": 16.551765385081467}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct chan_data *cd = chan->data;\n\tint32_t hop = 0;\n\tint32_t hop_new;\n\tint32_t hop_old;\n\tint32_t hop_tmp;\n\tint32_t i;\n\tint32_t n;\n\tint32_t n_enabled;\n\tstruct chan_observer *observer;\n\tint32_t spinlock_old;\n\tint32_t spinlock_new;\n\tint32_t spinlock_tmp;\n\tint32_t spinlock_tmp_old;\n\tint32_t spinlock_tmp_new;\n\tint32_t spinlock_tmp_tmp;\n\tint32_t spinlock_tmp_tmp_old;\n\tint32_t spinlock_tmp_tmp_new;\n\tint32_t spinlock_tmp_tmp_tmp;\n\tint32_t spinlock_tmp_tmp_tmp_old;\n\tint32_t spinlock_tmp_tmp_tmp_new;\n\tint32_t spinlock_tmp_tmp_tmp_tmp;\n\tint32_t spinlock_tmp_tmp_tmp_tmp_old;\n\tint32_t spinlock_tmp_tmp_tmp_tmp_new;\n\tint32_t spinlock_tmp_tmp_tmp_tmp_tmp;\n\tint32_t spinlock_tmp_tmp_tmp_tmp_tmp_old;\n\tint32_t spinlock_tmp_tmp_tmp_tmp_tmp_new;\n\tint32_t spinlock_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint32_t spinlock_tmp_tmp_tmp_tmp_tmp_tmp_old;\n\tint32_t spinlock_tmp_tmp_tmp_tmp_tmp_tmp_new;\n\tint32_t spinlock_tmp_tmp_tmp_tmp_tmp_tmp_tmp;\n\tint32_t spinlock_tmp_tmp_tmp_tmp_tmp_tmp_tmp_old;\n\tint32_t spinlock_tmp_tmp", "CodeBleu_score": 11.447190691762662}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint i;\n\tint hop = 0;\n\tint old_hop;\n\tstruct zbus_observer *obs;\n\tstruct zbus_observer *old_obs;\n\tstruct zbus_observer *obs_iter;\n\tstruct zbus_observer *old_obs_iter;\n\n\t/*\n\t * Lock the channel data.\n\t */\n\tzbus_spinlock_lock(&chan->lock);\n\n\t/*\n\t * Iterate through the observers, checking each observer's priority and whether it is enabled.\n\t */\n\tfor (i = 0; i < chan->observer_count; i++) {\n\t\tobs = &chan->observers[i];\n\t\tif (obs->priority < hop && obs->enabled) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\n\t/*\n\t * If the channel's highest observer priority is not equal to the determined value, update the channel's highest observer priority.\n\t */\n\told_hop = chan->hop;\n\tif (hop != old_hop) {\n\t\tchan->hop = hop;\n\n\t\t/*\n\t\t * Iterate through the observers, checking each observer's priority and whether it is enabled.\n\t\t */\n\t\tfor (i = 0; i < chan->observer_count; i++) {\n\t\t\tobs = &chan->observers[i];\n\t\t\tif (obs->priority == hop && obs->enabled) {\n\t\t\t\t/*\n\t\t\t\t * If the observer is enabled, call the observer's callback function.\n\t\t\t\t */\n\t\t\t\tobs->cb(chan, obs->data);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Unlock the channel data.\n\t */\n\tzbus_spinlock_unlock(&chan->lock);\n}", "CodeBleu_score": 33.194873533068595}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel *chan;\n\tstruct zbus_observer *o;\n\n\tZBUS_STRUCT_SECTION_FOREACH(chan, struct zbus_channel, &all_channels) {\n\t\to = chan->observer;\n\t\tif (o && o->update_hop && o->update_hop(o, obs)) {\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 22.94527722686333}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct chan_update_hop_args args = {\n\t\t.obs = obs,\n\t};\n\tzbus_chan_foreach(chan_update_hop, &args);\n}", "CodeBleu_score": 13.99290982077087}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct chan_update_hop_data data;\n\tdata.observer = obs;\n\tstruct chan_update_hop_data *d = &data;\n\tstruct chan_update_hop_data *d_end = d + sizeof(data) / sizeof(data.chan);\n\tstruct chan_update_hop_data *d_cur;\n\tfor (d_cur = d; d_cur != d_end; ++d_cur) {\n\t\td_cur->chan = NULL;\n\t\td_cur->chan_end = NULL;\n\t}\n\tstruct chan_update_hop_data *d_cur_end;\n\tfor (d_cur = d; d_cur != d_end; ++d_cur) {\n\t\tstruct chan *chan = chan_next(d_cur->chan);\n\t\td_cur->chan_end = chan;\n\t\tfor (; chan != NULL; chan = chan_next(chan)) {\n\t\t\tif (chan->observer == d_cur->observer) {\n\t\t\t\td_cur->chan = chan;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (d_cur = d; d_cur != d_end; ++d_cur) {\n\t\tif (d_cur->chan) {\n\t\t\tchan_update_hop(d_cur->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 16.699957029133444}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(obs != NULL, \"Observer cannot be NULL\");\n\t_ZBUS_ASSERT(!k_is_in_isr(), \"Cannot attach an observer in an ISR\");\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\tobs->priority = K_THREAD_PRIO_HIGHEST;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&obs->lock, key);\n\treturn 0;\n}", "CodeBleu_score": 57.813484958090655}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t_ZBUS_ASSERT(obs != NULL, \"Observer is null\");\n\t_ZBUS_ASSERT(!k_is_in_isr(), \"Cannot perform this operation in an ISR\");\n\t_ZBUS_SPINLOCK_LOCK(&obs->lock);\n\tobs->priority = K_THREAD_PRIO_HIGHEST;\n\tupdate_all_channels_hop(obs);\n\t_ZBUS_SPINLOCK_UNLOCK(&obs->lock);\n\treturn 0;\n}", "CodeBleu_score": 59.32420429094651}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tint rc;\n\tunsigned int old_pri;\n\tstruct zbus_observer *o = (struct zbus_observer *)obs;\n\tunsigned int pri = 0;\n\n\t/* Check the arguments */\n\tif (o == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check that the observer is not already attached to a thread */\n\tif (o->thread != NULL) {\n\t\treturn -EALREADY;\n\t}\n\n\t/* Check that the observer is not being used in an ISR */\n\tif (k_is_in_isr()) {\n\t\treturn -EDEADLK;\n\t}\n\n\t/* Lock the spinlock */\n\tz_spin_lock_key_t key = z_spin_lock(&o->lock);\n\n\t/* Set the observer's priority to the minimum thread priority */\n\told_pri = o->priority;\n\to->priority = pri;\n\n\t/* Update all channels associated with the observer */\n\trc = update_all_channels_hop(o);\n\n\t/* Release the spinlock */\n\tz_spin_unlock(&o->lock, key);\n\n\t/* Return the result */\n\treturn rc;\n}", "CodeBleu_score": 40.48842197096203}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint rc = -1;\n\tif (!chan) {\n\t\treturn -1;\n\t}\n\tif (z_is_in_isr()) {\n\t\tif (timeout) {\n\t\t\ttimeout = k_uptime_get() + timeout;\n\t\t}\n\t}\n\tchan->ctx_priority = k_thread_priority_get(k_current_get());\n\tchan_lock(chan);\n\twhile (1) {\n\t\tif (chan->ctx_notify) {\n\t\t\tbreak;\n\t\t}\n\t\tif (timeout) {\n\t\t\tif (timeout <= k_uptime_get()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchan_unlock(chan);\n\t\tk_yield();\n\t\tchan_lock(chan);\n\t}\n\tif (chan->ctx_notify) {\n\t\trc = chan->ctx_notify(chan, chan->ctx_data);\n\t\tchan->ctx_notify = NULL;\n\t}\n\tchan_unlock(chan);\n\treturn rc;\n}", "CodeBleu_score": 37.49492194859776}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint rc = 0;\n\tstruct zbus_context *ctx;\n\tstruct zbus_chan_notify_context *nc;\n\tk_timeout_t end_time;\n\n\t/* asserts */\n\t_ZBUS_ASSERT(chan != NULL, -EINVAL);\n\t_ZBUS_ASSERT(chan->state == ZBUS_CHAN_STATE_OPEN, -EIO);\n\n\t/* adjust timeout if in an ISR */\n\tif (_k_is_in_isr()) {\n\t\ttimeout = k_timeout_min(timeout, K_MSEC(10));\n\t}\n\n\t/* calculate end time */\n\tend_time = k_uptime_get() + timeout;\n\n\t/* initialize context */\n\tctx = zbus_chan_get_context(chan);\n\tnc = &ctx->notify_context;\n\tnc->chan = chan;\n\tnc->end_time = end_time;\n\tnc->priority = ctx->priority;\n\n\t/* lock channel */\n\tchan_lock(chan);\n\n\t/* execute notification logic */\n\trc = _zbus_vded_exec(chan, zbus_chan_notify_fn, nc);\n\n\t/* unlock channel */\n\tchan_unlock(chan);\n\n\treturn rc;\n}", "CodeBleu_score": 42.03381495245168}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint rc;\n\tstruct zbus_context *ctx;\n\tstruct zbus_chan_notify_context *nctx;\n\tstruct zbus_chan_notify_context ctx_stack;\n\tstruct zbus_chan_notify_context *nctx_stack = &ctx_stack;\n\n\t/* Assert that the channel is not null */\n\tif (chan == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Adjust the timeout if in an ISR */\n\tif (_k_is_in_isr()) {\n\t\ttimeout = k_is_in_isr() ? K_NO_WAIT : timeout;\n\t}\n\n\t/* Calculate the end time based on the timeout */\n\tstruct sys_timepoint end_time = sys_time_get();\n\tif (timeout != K_FOREVER) {\n\t\tend_time.ticks += sys_ticks_from_ms(sys_time_ms_to_ticks(timeout));\n\t}\n\n\t/* Initialize the context priority */\n\tk_sched_lock();\n\tctx = zbus_context_get();\n\tif (ctx != NULL) {\n\t\tnctx = &ctx->chan_notify;\n\t\tnctx->priority = ctx->priority + 1;\n\t} else {\n\t\tnctx = nctx_stack;\n\t\tnctx->priority = 0;\n\t}\n\tk_sched_unlock();\n\n\t/* Lock the channel */\n\trc = chan_lock(chan, nctx->priority);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/* Execute the notification logic */\n\trc = _zbus_chan_notify_locked(chan, &end_time);\n\n\t/* Unlock the channel */\n\tchan_unlock(chan);\n\n\treturn rc;\n}", "CodeBleu_score": 39.78344336778747}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tassert_param(IS_ETH_INT(Int));\n\tassert_param(IS_FUNCTIONAL_STATE(enable));\n\tif (enable) {\n\t\t/* Enable interrupt */\n\t\tif (Int == ETH_INT_TX) {\n\t\t\t/* Enable Tx interrupt */\n\t\t\tETH->INTEN |= ETH_INTEN_TXIE;\n\t\t} else if (Int == ETH_INT_RX) {\n\t\t\t/* Enable Rx interrupt */\n\t\t\tETH->INTEN |= ETH_INTEN_RXIE;\n\t\t} else if (Int == ETH_INT_WKUP) {\n\t\t\t/* Enable Wakeup interrupt */\n\t\t\tETH->INTEN |= ETH_INTEN_WKIE;\n\t\t} else if (Int == ETH_INT_ABNORMAL) {\n\t\t\t/* Enable Abnormal interrupt */\n\t\t\tETH->INTEN |= ETH_INTEN_AIE;\n\t\t} else {\n\t\t\t/* Enable Normal interrupt */\n\t\t\tETH->INTEN |= ETH_INTEN_NIE;\n\t\t}\n\t} else {\n\t\t/* Disable interrupt */\n\t\tif (Int == ETH_INT_TX) {\n\t\t\t/* Disable Tx interrupt */\n\t\t\tETH->INTEN &= ~ETH_INTEN_TXIE;\n\t\t} else if (Int == ETH_INT_RX) {\n\t\t\t/* Disable Rx interrupt */\n\t\t\tETH->INTEN &= ~ETH_INTEN_RXIE;\n\t\t} else if (Int == ETH_INT_WKUP) {\n\t\t\t/* Disable Wakeup interrupt */\n\t\t\tETH->INTEN &= ~ETH_INTEN_WKIE;\n\t\t} else if (Int == ETH_INT_ABNORMAL) {\n\t\t\t/* Disable Abnormal interrupt */\n\t\t\tETH->INTEN &= ~ETH_INTEN_AIE;\n\t\t} else {\n\t\t\t/* Disable Normal interrupt */\n\t\t\tETH->INTEN &= ~ETH_INTEN_NIE;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.47990421849321}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\n}", "CodeBleu_score": 4.451885662912518}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t tmpreg = 0;\n\ttmpreg = ETH->MACIMR;\n\tif (enable) {\n\t\t/* Check function parameters */\n\t\tassert_param(IS_ETH_INT(Int));\n\t\t/* Get the ETH interrupt enable register value */\n\t\ttmpreg &= ~Int;\n\t\t/* Check on which interrupt we are */\n\t\tif ((Int & ETH_INT_RXBUFOVF) != (uint32_t)RESET) {\n\t\t\t/* Clear the ETH OverFlow pending bit */\n\t\t\tETH->MACIMR &= ~ETH_MACIMR_RXBUFO;\n\t\t\t/* Set the corresponding bit to enable the interrupt */\n\t\t\tETH->MACIMR |= ETH_MACIMR_RXBUFO;\n\t\t} else if ((Int & ETH_INT_TXBUFE) != (uint32_t)RESET) {\n\t\t\t/* Clear the ETH Transmission pending bit */\n\t\t\tETH->MACIMR &= ~ETH_MACIMR_TXBUFE;\n\t\t\t/* Set the corresponding bit to enable the interrupt */\n\t\t\tETH->MACIMR |= ETH_MACIMR_TXBUFE;\n\t\t} else if ((Int & ETH_INT_TXCOMP) != (uint32_t)RESET) {\n\t\t\t/* Clear the ETH Transmission complete pending bit */\n\t\t\tETH->MACIMR &= ~ETH_MACIMR_TXCOMP;\n\t\t\t/* Set the corresponding bit to enable the interrupt */\n\t\t\tETH->MACIMR |= ETH_MACIMR_TXCOMP;\n\t\t} else if ((Int & ETH_INT_RX) != (uint32_t)RESET) {\n\t\t\t/* Clear the ETH Receive pending bit */\n\t\t\tETH->MACIMR &= ~ETH_MACIMR_RX;\n\t\t\t/* Set the corresponding bit to enable the interrupt */\n\t\t\tETH->MACIMR |= ETH_MACIMR_RX;\n\t\t} else if ((Int & ETH_INT_TX) != (uint32_t)RESET) {\n\t\t\t/* Clear the ETH Transmit pending bit */\n\t\t\tETH->MACIMR &= ~ETH_MACIMR_TX;\n\t\t\t/* Set the corresponding bit to enable the interrupt */\n\t\t\tETH->MACIMR |= ETH_MACIMR_TX;\n\t\t} else if ((Int & ETH_INT_L", "CodeBleu_score": 38.7634844228511}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tuint32_t i;\n\tETH_TX_DESC *pDesc;\n\tpDesc = (ETH_TX_DESC *) ETH_TxDescStartAddr;\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\tif (pDesc->status & ETH_TX_DESC_OWN) {\n\t\t\tpDesc = (ETH_TX_DESC *) ((uint32_t) pDesc + 1);\n\t\t\tif (pDesc == (ETH_TX_DESC *) ETH_TxDescEndAddr) {\n\t\t\t\tpDesc = (ETH_TX_DESC *) ETH_TxDescStartAddr;\n\t\t\t}\n\t\t} else {\n\t\t\treturn pDesc;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 48.59413031601012}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tuint32_t i;\n\tETH_TX_DESC *pTxDesc;\n\n\t/* Get the current transmit descriptor address */\n\tpTxDesc = (ETH_TX_DESC *)g_pTxDescListStart;\n\n\t/* Check each descriptor in the list */\n\tfor (i = 0; i < g_TxDescCount; i++) {\n\t\t/* Check if the descriptor is owned by the device */\n\t\tif (pTxDesc->tx_desc.status & ETH_DMATXDESC_OWN) {\n\t\t\t/* Try the next descriptor */\n\t\t\tpTxDesc++;\n\n\t\t\t/* Check if we've reached the end of the list */\n\t\t\tif (pTxDesc == (ETH_TX_DESC *)g_pTxDescListEnd) {\n\t\t\t\tpTxDesc = (ETH_TX_DESC *)g_pTxDescListStart;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Return the descriptor if it's available */\n\t\t\treturn pTxDesc;\n\t\t}\n\t}\n\n\t/* No free descriptor was found */\n\treturn 0;\n}", "CodeBleu_score": 47.2224875853943}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tu32_t dwIndex;\n\tu32_t dwCount = 0;\n\tu32_t dwMaxCount = 10000;\n\n\t/* Get the current transmit descriptor address */\n\tpTxDesc = &g_sTxDesc[g_sEth.TxDescIndex];\n\n\t/* Loop through the list of transmit descriptors */\n\twhile (dwCount < dwMaxCount) {\n\t\t/* Check if the descriptor is owned by the device */\n\t\tif ((pTxDesc->dwStatus & ETH_DMATXDESC_OWN) == 0) {\n\t\t\treturn pTxDesc;\n\t\t}\n\n\t\t/* Get the next transmit descriptor address */\n\t\tpTxDesc++;\n\n\t\t/* Check if we have reached the end of the list */\n\t\tif (pTxDesc == &g_sTxDesc[g_sEth.TxDescCount]) {\n\t\t\tpTxDesc = &g_sTxDesc[0];\n\t\t}\n\n\t\t/* Increment the loop counter */\n\t\tdwCount++;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.63757518674714}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\tif (device == NULL) {\n\t\tLOG_E(\"The device parameter is NULL\");\n\t\tresult = -RT_ERROR;\n\t} else {\n\t\tCy_CSD_Type *base = (Cy_CSD_Type *)device->parent.user_data;\n\t\tCy_CSD_IDAC_Type *dac = (Cy_CSD_IDAC_Type *)(base->ptrIDAC[channel]);\n\t\tif (dac == NULL) {\n\t\t\tLOG_E(\"The device does not have the specified channel\");\n\t\t\tresult = -RT_ERROR;\n\t\t} else {\n\t\t\tCy_CSDIDAC_OutputEnable(dac, *value);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 42.149858981926755}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tRT_ASSERT(device != RT_NULL);\n\tstruct cyp_dac *dac = (struct cyp_dac *)device->parent.user_data;\n\tRT_ASSERT(dac != RT_NULL);\n\tCy_CSD_Type *base = dac->base;\n\tCy_CSD_IDAC_Channel_Type *idac = &base->idac[channel];\n\tCy_CSD_IDAC_SetBufferMode(base, channel, CY_CSD_IDAC_BUFFER_MODE_SW_BYPASS);\n\tCy_CSD_IDAC_SetSwitchState(base, channel, CY_CSD_IDAC_SWITCH_STATE_ENABLE);\n\tCy_CSD_IDAC_SetDacValue(base, channel, *value);\n\tCy_CSD_IDAC_SetBufferMode(base, channel, CY_CSD_IDAC_BUFFER_MODE_SW_BUFFER);\n\tCy_CSD_IDAC_SetSwitchState(base, channel, CY_CSD_IDAC_SWITCH_STATE_DISABLE);\n\tCy_CSD_IDAC_SetDacValue(base, channel, 0);\n\tCy_CSD_IDAC_SetBufferMode(base, channel, CY_CSD_IDAC_BUFFER_MODE_SW_BYPASS);\n\tCy_CSD_IDAC_SetSwitchState(base, channel, CY_CSD_IDAC_SWITCH_STATE_ENABLE);\n\tCy_CSD_IDAC_SetDacValue(base, channel, *value);\n\tCy_CSD_IDAC_SetBufferMode(base, channel, CY_CSD_IDAC_BUFFER_MODE_SW_BUFFER);\n\tCy_CSD_IDAC_SetSwitchState(base, channel, CY_CSD_IDAC_SWITCH_STATE_DISABLE);\n\tCy_CSD_IDAC_SetDacValue(base, channel, 0);\n\tCy_CSD_IDAC_SetBufferMode(base, channel, CY_CSD_IDAC_BUFFER_MODE_SW_BYPASS);\n\tCy_CSD_IDAC_SetSwitchState(base, channel, CY_CSD_IDAC_SWITCH_STATE_ENABLE);\n\t", "CodeBleu_score": 40.03376458274957}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tRT_ASSERT(device != RT_NULL)\n\tRT_ASSERT(channel < device->info.channel_num)\n\trt_err_t result = RT_EOK;\n\tCy_CSD_Type *base = (Cy_CSD_Type *)device->parent.user_data;\n\tCy_CSD_IDAC_Channel_Type *dac = &base->IDAC[channel];\n\tresult = Cy_CSDIDAC_OutputEnable(dac, *value);\n\tif (result != CY_CSD_SUCCESS) {\n\t\tLOG_E(\"cyp_adc_convert: %d\", result);\n\t\treturn -RT_ERROR;\n\t}\n\treturn result;\n}", "CodeBleu_score": 51.218888429370104}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t j;\n\trt_uint32_t k;\n\trt_uint32_t flash_addr;\n\trt_uint32_t flash_size;\n\trt_uint32_t flash_end;\n\trt_uint32_t read_size;\n\trt_uint32_t read_addr;\n\trt_uint32_t read_end;\n\trt_uint32_t read_len;\n\trt_uint32_t read_len_max;\n\trt_uint32_t read_len_min;\n\trt_uint32_t read_len_mod;\n\trt_uint32_t read_len_rem;\n\trt_uint32_t read_len_rem_max;\n\trt_uint32_t read_len_rem_min;\n\trt_uint32_t read_len_rem_mod;\n\trt_uint32_t read_len_rem_rem;\n\trt_uint32_t read_len_rem_rem_max;\n\trt_uint32_t read_len_rem_rem_min;\n\trt_uint32_t read_len_rem_rem_mod;\n\trt_uint32_t read_len_rem_rem_rem;\n\trt_uint32_t read_len_rem_rem_rem_max;\n\trt_uint32_t read_len_rem_rem_rem_min;\n\trt_uint32_t read_len_rem_rem_rem_mod;\n\trt_uint32_t read_len_rem_rem_rem_rem;\n\trt_uint32_t read_len_rem_rem_rem_rem_max;\n\trt_uint32_t read_len_rem_rem_rem_rem_min;\n\trt_uint32_t read_len_rem_rem_rem_rem_mod;\n\trt_uint32_t read_len_rem_rem_rem_rem_rem;\n\trt_uint32_t", "CodeBleu_score": 8.167883479573147}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif (addr + size > IFX_FLASH_END) {\n\t\tIFX_LOG_E(\"address out of range\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile (size > 0) {\n\t\t*buf = *(rt_uint8_t *)addr;\n\t\tbuf++;\n\t\taddr++;\n\t\tsize--;\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 37.13325341218353}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\n\tif (addr + size > IFX_FLASH_END_ADDR) {\n\t\tIFX_LOG_E(\"read operation would exceed flash memory's end address\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 45.59021645846551}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer != RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 30.92013937546092}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tCY_ASSERT(timer != NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\trt_uint32_t ret = cyhal_timer_read(timer_obj);\n\treturn ret;\n}", "CodeBleu_score": 54.279553769960444}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer != RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 30.92013937546092}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\tint ret;\n\trt_mutex_take(g_dfs_mutex, RT_WAITING_FOREVER);\n\tRT_ASSERT(g_dfs_mutex->owner == rt_thread_self());\n\tRT_ASSERT(g_dfs_mutex->type == RT_Mutex);\n\tRT_ASSERT(g_dfs_mutex->value == 1);\n\tRT_ASSERT(g_dfs_mutex->hold == 1);\n\tRT_ASSERT(g_dfs_mutex->owner == rt_thread_self());\n\tRT_ASSERT(g_dfs_mutex->wait_thread == RT_NULL);\n\tRT_ASSERT(g_dfs_mutex->object_type == RT_Object_Class_Mutex);\n\tRT_ASSERT(g_dfs_mutex->parent.flag == RT_Object_Class_Mutex);\n\tRT_ASSERT(g_dfs_mutex->parent.type == RT_Object_Class_Mutex);\n\tRT_ASSERT(g_dfs_mutex->parent.ref_count == 1);\n\tRT_ASSERT(g_dfs_mutex->parent.parent == RT_NULL);\n\tRT_ASSERT(g_dfs_mutex->parent.sibling == RT_NULL);\n\tRT_ASSERT(g_dfs_mutex->parent.child == RT_NULL);\n\tRT_ASSERT(g_dfs_mutex->parent.name == \"dfs_mutex\");\n\tRT_ASSERT(g_dfs_mutex->parent.user_data == RT_NULL);\n\tRT_ASSERT(g_dfs_mutex->parent.cleanup == RT_NULL);\n\tRT_ASSERT(g_dfs_mutex->parent.class_type == RT_Object_Class_Mutex);\n\tRT_ASSERT(g_dfs_mutex->parent.init == RT_NULL);\n\tRT_ASSERT(g_dfs_mutex->parent.deinit == RT_NULL);\n\tRT_ASSERT(g_dfs_mutex->parent.system_lock == 0);\n\tRT_ASSERT(g_dfs_mutex->parent.user_lock == 0);\n\tRT_ASSERT(g_dfs_mutex->parent.cleanup == RT_NULL);\n\tRT_ASSERT(g_dfs_mutex->parent.object_type == RT_Object_Class_Mutex);\n\tRT", "CodeBleu_score": 22.97865350693047}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(g_dfs_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.367937630211839}, {"code": "void dfs_lock(void){\n\t\trt_mutex_take(g_dfs_lock, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.404565786908461}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tfor (fd = startfd; fd < fdt->maxfds; fd++) {\n\t\tif (fdt->fd[fd].fd_pos == 0 && fdt->fd[fd].fd_obj == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\treturn fd_slot_expand(fdt, startfd);\n}", "CodeBleu_score": 29.34988370817061}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint i;\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\n\tfor (fd = startfd; fd < fdt->maxfds; fd++) {\n\t\tif (fdt->fd_array[fd].fd_inode == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\tif (fd_slot_expand(fdt) < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (i = startfd; i < fdt->maxfds; i++) {\n\t\tif (fdt->fd_array[i].fd_inode == NULL) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 40.48718455534409}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tfor (fd = startfd; fd < fdt->maxfds; fd++) {\n\t\tif (fdt->fd[fd].fd_obj == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\tif (fd_slot_expand(fdt, startfd) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd_slot_alloc(fdt, startfd);\n}", "CodeBleu_score": 44.36530023799502}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < RT_ERR_UNKNOWN; i++) {\n\t\tif (error == rt_err_list[i].code) {\n\t\t\treturn rt_err_list[i].msg;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 48.0853654509608}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < RT_ERR_UNKNOWN; i++) {\n\t\tif (error == rt_err_str[i].err) {\n\t\t\treturn rt_err_str[i].str;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 48.90065465290047}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tif (error >= RT_ERR_UNKNOWN) {\n\t\treturn \"EUNKNOW\";\n\t}\n\n\treturn rt_error_strings[error];\n}", "CodeBleu_score": 26.588410691365823}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (idle_hook_list.next == RT_NULL) {\n\t\tresult = -RT_EFULL;\n\t} else {\n\t\tidle_hook_list.next->data = hook;\n\t\tresult = RT_EOK;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 25.073089814322852}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\t/* lock interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check hook list */\n\tif (idle_hook_list.next == RT_NULL) {\n\t\t/* no empty slot found, return error */\n\t\tresult = -RT_EFULL;\n\t} else {\n\t\t/* find an empty slot */\n\t\tidle_hook_list.next->data = hook;\n\t}\n\n\t/* unlock interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 22.15872002259478}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_thread_idle_hook_t *idle_hook;\n\n\t/* lock the hook list */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* find an empty slot */\n\tfor (idle_hook = &rt_thread_idle_hook; idle_hook->next != RT_NULL; idle_hook = idle_hook->next) {\n\t\t/* keep searching if there is no empty slot */\n\t}\n\n\t/* check if there is an empty slot */\n\tif (idle_hook->next == RT_NULL) {\n\t\t/* unlock the hook list */\n\t\trt_hw_interrupt_enable(level);\n\n\t\t/* no empty slot */\n\t\treturn -RT_EFULL;\n\t}\n\n\t/* set the hook */\n\tidle_hook->next = (rt_thread_idle_hook_t *)hook;\n\n\t/* unlock the hook list */\n\trt_hw_interrupt_enable(level);\n\n\t/* return success */\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.78293120527438}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (hook == RT_NULL) {\n\t\tresult = RT_ERROR;\n\t} else {\n\t\tif (rt_thread_idle_hook == hook) {\n\t\t\trt_thread_idle_hook = RT_NULL;\n\t\t\tresult = RT_EOK;\n\t\t} else {\n\t\t\tstruct rt_thread *thread;\n\n\t\t\tthread = idle_thread;\n\t\t\twhile (thread != RT_NULL) {\n\t\t\t\tif (thread->idle_hook == hook) {\n\t\t\t\t\tthread->idle_hook = RT_NULL;\n\t\t\t\t\tresult = RT_EOK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthread = thread->next;\n\t\t\t}\n\t\t}\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 38.54417879200693}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result;\n\trt_thread_idle_hook_t *hook_ptr;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* find the specified hook */\n\thook_ptr = &rt_thread_idle_hook;\n\twhile (hook_ptr->next != RT_NULL) {\n\t\tif (hook_ptr->next == hook) {\n\t\t\t/* found */\n\t\t\thook_ptr->next = hook_ptr->next->next;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\n\t\thook_ptr = hook_ptr->next;\n\t}\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 35.54910235797733}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\trt_thread_idle_hook_t *hook_ptr;\n\trt_thread_idle_hook_t *prev_hook_ptr;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check hook */\n\tif (hook == RT_NULL) {\n\t\tresult = RT_ERROR;\n\t} else {\n\t\t/* find the hook */\n\t\tprev_hook_ptr = RT_NULL;\n\t\thook_ptr = &rt_thread_idle_hook;\n\t\twhile (hook_ptr != RT_NULL) {\n\t\t\tif (hook_ptr->hook == hook) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprev_hook_ptr = hook_ptr;\n\t\t\thook_ptr = hook_ptr->next;\n\t\t}\n\n\t\t/* delete hook */\n\t\tif (hook_ptr != RT_NULL) {\n\t\t\tif (prev_hook_ptr == RT_NULL) {\n\t\t\t\trt_thread_idle_hook = hook_ptr->next;\n\t\t\t} else {\n\t\t\t\tprev_hook_ptr->next = hook_ptr->next;\n\t\t\t}\n\n\t\t\tresult = RT_EOK;\n\t\t} else {\n\t\t\tresult = -RT_ERROR;\n\t\t}\n\t}\n\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 41.19504688298008}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_err_t ret;\n\trt_thread_t thread;\n\trt_list_t *list;\n\trt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* Ensure the scheduler is unlocked */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* Resume all threads in the list */\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tlist = rt_list_entry(susp_list->next, struct rt_thread, suspended);\n\t\tthread = rt_list_entry(list, struct rt_thread, tlist);\n\n\t\t/* Resume the thread */\n\t\tret = rt_thread_resume(thread, thread_error);\n\t\tif (ret != RT_EOK) {\n\t\t\trt_hw_interrupt_enable(level);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 41.17016005489206}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_err_t ret_val;\n\trt_thread_t thread;\n\trt_thread_t thread_to_resume;\n\trt_list_t *susp_list_node;\n\trt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (RT_Object)susp_list);\n\n\t/* check parameter */\n\tRT_DEBUG_NULL_POINTER(susp_list);\n\n\t/* resume all threads in the list */\n\tlevel = rt_hw_interrupt_disable();\n\twhile (rt_list_isempty(susp_list) == 0) {\n\t\t/* dequeue a thread */\n\t\tsusp_list_node = rt_list_isempty(susp_list) ? RT_NULL : rt_list_first(susp_list);\n\t\tthread_to_resume = (rt_thread_t)rt_list_entry(susp_list_node, struct rt_thread, suspended_list);\n\n\t\t/* resume the thread */\n\t\trt_list_remove(susp_list_node);\n\t\tthread_to_resume->error = thread_error;\n\t\trt_hw_interrupt_enable(level);\n\n\t\t/* resume the thread */\n\t\tret_val = rt_thread_resume(thread_to_resume);\n\t\tif (ret_val != RT_EOK) {\n\t\t\trt_kprintf(\"resume thread %s failed\n\", thread_to_resume->name);\n\t\t\treturn ret_val;\n\t\t}\n\n\t\t/* disable interrupt */\n\t\tlevel = rt_hw_interrupt_disable();\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 32.7700821522496}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_err_t err;\n\trt_thread_t thread;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* resume all threads in the list */\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\t/* get thread from list */\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n\t\t/* resume thread */\n\t\terr = rt_thread_resume(thread, thread_error);\n\t\tif (err != RT_EOK) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 48.54926646019796}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t device, old_device;\n\n\t/* save current console device */\n\told_device = rt_console_get_device();\n\n\t/* find new console device */\n\tdevice = rt_device_find(name);\n\tif (device == RT_NULL) {\n\t\treturn old_device;\n\t}\n\n\t/* check if the new console device is the same as the current console device */\n\tif (device == old_device) {\n\t\treturn old_device;\n\t}\n\n\t/* close current console device */\n\tif (old_device != RT_NULL) {\n\t\trt_device_close(old_device);\n\t}\n\n\t/* open new console device */\n\tif (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t/* set new console device */\n\t\trt_console_set_device(device);\n\t}\n\n\treturn old_device;\n}", "CodeBleu_score": 59.99074082878772}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t new_device, old_device;\n\n\t/* find new device */\n\tnew_device = rt_device_find(name);\n\tif (new_device == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* check if new device is console device */\n\tif (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* get old device */\n\told_device = rt_console_get_device();\n\n\t/* close old device */\n\tif (old_device != RT_NULL) {\n\t\trt_device_close(old_device);\n\t}\n\n\t/* set new device as console device */\n\trt_console_set_device(new_device);\n\n\treturn old_device;\n}", "CodeBleu_score": 60.724475461762275}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t device;\n\trt_device_t old_device;\n\tchar *new_device_name;\n\tchar *old_device_name;\n\n\told_device = rt_console_get_device();\n\told_device_name = rt_device_get_name(old_device);\n\tnew_device_name = rt_strdup(name);\n\tif (new_device_name == RT_NULL) {\n\t\treturn old_device;\n\t}\n\n\tdevice = rt_device_find(new_device_name);\n\tif (device == RT_NULL) {\n\t\trt_kprintf(\"console device %s not found\n\", new_device_name);\n\t\trt_free(new_device_name);\n\t\treturn old_device;\n\t}\n\n\tif (device == old_device) {\n\t\trt_free(new_device_name);\n\t\treturn old_device;\n\t}\n\n\tif (old_device != RT_NULL) {\n\t\tif (rt_device_open(old_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n\t\t\trt_kprintf(\"open device %s failed\n\", old_device_name);\n\t\t\trt_free(new_device_name);\n\t\t\treturn old_device;\n\t\t}\n\n\t\tif (rt_device_close(old_device) != RT_EOK) {\n\t\t\trt_kprintf(\"close device %s failed\n\", old_device_name);\n\t\t\trt_free(new_device_name);\n\t\t\treturn old_device;\n\t\t}\n\t}\n\n\tif (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n\t\trt_kprintf(\"open device %s failed\n\", new_device_name);\n\t\trt_free(new_device_name);\n\t\treturn old_device;\n\t}\n\n\trt_free(new_device_name);\n\treturn old_device;\n}", "CodeBleu_score": 49.834159819358895}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_size_t count = 0;\n\trt_object_information_t *information;\n\trt_list_node_t *node;\n\n\t/* get object information */\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/* lock the object spinlock */\n\trt_spin_lock_irqsave(&information->lock);\n\n\t/* get the object list */\n\tnode = information->object_list.next;\n\twhile (node != &information->object_list) {\n\t\tcount++;\n\t\tnode = node->next;\n\t}\n\n\t/* unlock the object spinlock */\n\trt_spin_unlock_irqrestore(&information->lock);\n\n\treturn count;\n}", "CodeBleu_score": 45.507290236709075}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object *object;\n\tint count = 0;\n\trt_base_t level;\n\tlevel = rt_hw_interrupt_disable();\n\tobject = object_list_head[type];\n\twhile (object != RT_NULL) {\n\t\tcount++;\n\t\tobject = object->parent.next;\n\t}\n\trt_hw_interrupt_enable(level);\n\treturn count;\n}", "CodeBleu_score": 35.9956223386969}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\trt_base_t level;\n\trt_object_information_t *information;\n\trt_object_information_t *information_tmp;\n\trt_uint16_t count;\n\n\t/* get object information */\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/* lock object list */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* count objects */\n\tcount = 0;\n\trt_list_for_each_entry(information_tmp, &information->object_list, list) {\n\t\tcount ++;\n\t}\n\n\t/* unlock object list */\n\trt_hw_interrupt_enable(level);\n\n\treturn count;\n}", "CodeBleu_score": 43.875017809284834}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object != RT_NULL);\n\tif (object->type != RT_Object_Class_Unknown) {\n\t\tif (object->parent.type != RT_Object_Class_Unknown) {\n\t\t\tobject->parent.type = RT_Object_Class_Unknown;\n\t\t}\n\t\tobject->type = RT_Object_Class_Unknown;\n\t\trt_object_hook_call(object, RT_Object_Event_Detach);\n\t\trt_spin_lock_irqsave(&object->parent.lock, &irq_flags);\n\t\trt_list_remove(&object->parent.list);\n\t\trt_spin_unlock_irqrestore(&object->parent.lock, irq_flags);\n\t}\n}", "CodeBleu_score": 45.39566603191922}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\tRT_DEBUG_NULL_POINTER(object);\n\n\trt_object_information_t info;\n\n\tRT_OBJECT_HOOK_CALL(object, RT_Object_Detach_Hook, (object));\n\n\t/* get object's information */\n\tinfo = (rt_object_information_t)object;\n\n\t/* lock object */\n\trt_spin_lock(&(info->lock));\n\n\t/* remove object from list */\n\trt_list_remove(&(info->parent.list));\n\n\t/* unlock object */\n\trt_spin_unlock(&(info->lock));\n\n\t/* set object's type to RT_Object_Class_Unknown */\n\tinfo->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 46.073748007804085}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\tRT_DEBUG_NULL_POINTER(object);\n\tRT_DEBUG_OBJECT_ID(object);\n\tRT_DEBUG_OBJECT_TYPE(object);\n\tRT_DEBUG_OBJECT_HOOK(object, RT_OBJECT_HOOK_CALL);\n\tRT_DEBUG_OBJECT_HOOK(object, RT_OBJECT_HOOK_DETACH);\n\tRT_DEBUG_OBJECT_HOOK(object, RT_OBJECT_HOOK_FREE);\n\tif (object->type != RT_Object_Class_Unknown) {\n\t\trt_object_information_t info;\n\t\trt_base_t level;\n\t\tinfo = rt_object_get_information(object->type);\n\t\tRT_DEBUG_OBJECT_TYPE(object);\n\t\tRT_DEBUG_OBJECT_HOOK(object, RT_OBJECT_HOOK_CALL);\n\t\tRT_DEBUG_OBJECT_HOOK(object, RT_OBJECT_HOOK_DETACH);\n\t\tRT_DEBUG_OBJECT_HOOK(object, RT_OBJECT_HOOK_FREE);\n\t\tlevel = rt_hw_interrupt_disable();\n\t\trt_list_remove(&object->list);\n\t\trt_spin_unlock(&(info->lock));\n\t\tobject->type = RT_Object_Class_Unknown;\n\t\trt_hw_interrupt_enable(level);\n\t}\n}", "CodeBleu_score": 43.49265259864967}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_custom_object_t cobj = (rt_custom_object_t)obj;\n\n\tRT_ASSERT(obj != RT_NULL);\n\tRT_ASSERT(rt_object_get_type(obj) == RT_Object_Class_Custom);\n\n\tif (cobj->destroy != RT_NULL) {\n\t\trt_err_t result = cobj->destroy(obj);\n\t\tif (result != RT_EOK) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\trt_object_delete(obj);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 47.07327758030719}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_custom_object_t cobj = (rt_custom_object_t)obj;\n\n\tRT_ASSERT(obj != RT_NULL);\n\tRT_ASSERT(cobj->type == RT_Object_Class_Custom);\n\n\tif (cobj->destroy != RT_NULL) {\n\t\trt_value_t result = cobj->destroy(obj);\n\t\trt_object_delete(obj);\n\t\treturn result.u;\n\t}\n\n\trt_object_delete(obj);\n\treturn RT_EOK;\n}", "CodeBleu_score": 47.248285294118084}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result;\n\trt_custom_object_t cobj;\n\n\t/* check if the object is valid */\n\tif (rt_object_get_type(obj) != RT_Object_Class_Custom) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get the custom object */\n\tcobj = (rt_custom_object_t)obj;\n\n\t/* check if the object has a destroy method */\n\tif (cobj->destroy != RT_NULL) {\n\t\t/* call the destroy method */\n\t\tresult = cobj->destroy(obj);\n\t} else {\n\t\tresult = RT_EOK;\n\t}\n\n\t/* delete the object */\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 47.698200782331426}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\trt_thread_t thread;\nrt_base_t level;\n\n/* get current thread */\nthread = rt_thread_self();\n\n/* close thread */\nrt_enter_critical();\nrt_thread_close(thread);\nrt_exit_critical_safe(level);\n\n/* add thread to defunct thread list */\nrt_thread_defunct_enqueue(thread);\n\n/* schedule next thread */\nrt_schedule();\n}", "CodeBleu_score": 62.55525486681468}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\n\tthread = rt_thread_self();\n\tif (thread != RT_NULL) {\n\t\trt_enter_critical();\n\t\trt_thread_close(thread);\n\t\trt_thread_defunct_enqueue(thread);\n\t\trt_exit_critical_safe();\n\t\trt_schedule();\n\t}\n}", "CodeBleu_score": 62.147312961096034}, {"code": "static void _thread_exit(void){\n\t\trt_thread_t thread;\n\trt_base_t level;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* remove thread from thread list */\n\trt_list_remove(&(thread->tlist));\n\n\t/* close thread */\n\trt_thread_close(thread);\n\n\t/* resume interrupt */\n\trt_hw_interrupt_enable(level);\n\n\t/* add thread to defunct thread list */\n\trt_thread_defunct_enqueue(thread);\n\n\t/* context switch */\n\trt_schedule();\n}", "CodeBleu_score": 62.0092357066696}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread;\n\trt_base_t level;\n\n\t/* parameter check */\n\tRT_ASSERT(parameter != RT_NULL);\n\n\t/* get thread object */\n\tthread = (rt_thread_t)parameter;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* thread must be suspended */\n\tif (thread->stat != RT_THREAD_SUSPEND) {\n\t\trt_kprintf(\"thread %s is not suspend\n\", thread->name);\n\t\trt_hw_interrupt_enable(level);\n\n\t\treturn;\n\t}\n\n\t/* set thread error number */\n\tthread->error = -ETIME;\n\n\t/* remove thread from suspend list */\n\trt_list_remove(&(thread->suspend_thread));\n\n\t/* resume thread */\n\trt_sched_insert_thread(thread);\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 41.55532985348225}, {"code": "static void _thread_timeout(void *parameter){\n\t\trt_thread_t thread;\n\tRT_ASSERT(parameter);\n\tthread = (rt_thread_t)parameter;\n\t/* thread is locked in thread_suspend */\n\tif (thread->stat == RT_THREAD_READY) {\n\t\trt_kprintf(\"thread:%s is ready, can't be timeout\n\", thread->name);\n\t\treturn;\n\t}\n\tif (thread->stat == RT_THREAD_SUSPEND) {\n\t\trt_kprintf(\"thread:%s is suspend, can't be timeout\n\", thread->name);\n\t\treturn;\n\t}\n\tthread->error = -ETIME;\n\trt_thread_resume(thread);\n\trt_schedule();\n}", "CodeBleu_score": 37.295772431045435}, {"code": "static void _thread_timeout(void *parameter){\n\t\tRT_ASSERT(parameter != RT_NULL);\n\tstruct rt_thread *thread;\n\tstruct rt_list_node *node;\n\tstruct rt_list_node *n;\n\tstruct rt_list_node *head;\n\tstruct rt_thread_delay *delay;\n\n\tthread = (struct rt_thread *)parameter;\n\tRT_ASSERT(thread->parent.type == RT_Object_Class_Thread);\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check thread state */\n\tif (thread->stat != RT_THREAD_SUSPEND) {\n\t\treturn;\n\t}\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* check thread state */\n\tif (thread->stat != RT_THREAD_SUSPEND) {\n\t\trt_exit_critical();\n\t\treturn;\n\t}\n\n\t/* set error number */\n\tthread->error = -ETIME;\n\n\t/* remove thread from suspend list */\n\tnode = &thread->suspend_node;\n\thead = &rt_thread_suspend_list;\n\trt_list_for_each_safe(node, n, head) {\n\t\tif (node == &thread->suspend_node) {\n\t\t\trt_list_remove(head, node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* insert thread to ready list */\n\tdelay = (struct rt_thread_delay *)thread->delay_start;\n\tif (delay == RT_NULL) {\n\t\trt_sched_insert_thread(thread);\n\t} else {\n\t\trt_tick_t now;\n\t\trt_tick_t delta;\n\t\trt_tick_t time_slice;\n\t\trt_base_t level;\n\n\t\t/* get current tick */\n\t\tnow = rt_tick_get();\n\n\t\t/* get time slice */\n\t\ttime_slice = thread->time_slice;\n\t\tif (time_slice == 0) {\n\t\t\ttime_slice = thread->parent.init_tick;\n\t\t}\n\n\t\t/* get time slice delta */\n\t\tdelta = now - delay->timestamp;\n\t\tif (delta < time_slice) {\n\t\t\trt_exit_critical();\n\t\t\treturn;\n\t\t}\n\n\t\t/* set time slice */\n\t\tthread->time_slice = ", "CodeBleu_score": 49.20458362749333}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_mutex_t mutex;\n\trt_list_t *pos, *n;\n\trt_thread_t waiting_thread;\n\trt_object_t object;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (thread->object_type == RT_Object_Class_Mutex) {\n\t\tmutex = (rt_mutex_t)thread->parent.data;\n\t\trt_list_for_each_safe(pos, n, &mutex->thread_list) {\n\t\t\twaiting_thread = rt_list_entry(pos, struct rt_thread, list);\n\t\t\tif (waiting_thread == thread) {\n\t\t\t\trt_list_remove(&thread->list);\n\t\t\t\tthread->object_type = RT_Object_Class_Thread;\n\t\t\t\tthread->parent.type = RT_Object_Class_Unknown;\n\t\t\t\tthread->parent.data = RT_NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\trt_mutex_release(thread, RT_WAITING_FOREVER);\n\twhile (!rt_list_isempty(&thread->mutex_list)) {\n\t\tmutex = rt_list_entry(thread->mutex_list.next, struct rt_mutex, list);\n\t\trt_mutex_release(thread, RT_WAITING_FOREVER);\n\t}\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 48.61665640502286}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_list_t *node;\n\trt_mutex_t mutex;\n\trt_object_t object;\n\trt_bool_t is_waiting;\n\trt_bool_t is_owner;\n\trt_thread_t owner;\n\n\tlevel = rt_hw_interrupt_disable();\n\t/* check if the thread is waiting on a mutex */\n\tis_waiting = thread->wait_info.is_waiting;\n\tif (is_waiting) {\n\t\t/* get the mutex the thread is waiting on */\n\t\tmutex = thread->wait_info.object;\n\t\t/* remove the thread from the mutex's waiting list */\n\t\trt_list_remove(&(thread->tlist));\n\t\t/* clear the pending object */\n\t\tthread->wait_info.object = RT_NULL;\n\t\t/* release the mutex */\n\t\trt_mutex_release(mutex);\n\t}\n\t/* check if the thread has taken any mutexes */\n\tis_owner = thread->mutex_list.owner != RT_NULL;\n\tif (is_owner) {\n\t\t/* get the thread's owner */\n\t\towner = thread->mutex_list.owner;\n\t\t/* release all mutexes the thread has taken */\n\t\tnode = thread->mutex_list.next;\n\t\twhile (node != &(thread->mutex_list)) {\n\t\t\t/* get the mutex */\n\t\t\tmutex = rt_list_entry(node, struct rt_mutex, owner_thread_list);\n\t\t\t/* release the mutex */\n\t\t\trt_mutex_release(mutex);\n\t\t\t/* point to the next node */\n\t\t\tnode = node->next;\n\t\t}\n\t\t/* clear the thread's owner */\n\t\tthread->mutex_list.owner = RT_NULL;\n\t}\n\t/* restore the thread's interrupt level */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 50.19533841910645}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_thread_t owner;\n\trt_thread_t object;\n\trt_bool_t is_waiting;\n\trt_bool_t is_pending;\n\trt_bool_t is_owner;\n\trt_bool_t is_object;\n\trt_mutex_t mutex;\n\trt_list_t *list;\n\trt_list_t *n;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* get thread's owner */\n\towner = thread->owner;\n\t/* get thread's object */\n\tobject = thread->object;\n\n\t/* check if the thread is waiting on a mutex */\n\tis_waiting = thread->wait_option != RT_THREAD_WAITING_NONE;\n\t/* check if the thread is pending on a mutex */\n\tis_pending = thread->wait_option == RT_THREAD_WAITING_MUTEX;\n\t/* check if the thread is the owner of a mutex */\n\tis_owner = owner == thread;\n\t/* check if the thread is the object of a mutex */\n\tis_object = object == thread;\n\n\t/* if the thread is the owner of a mutex */\n\tif (is_owner) {\n\t\t/* get the mutex */\n\t\tmutex = (rt_mutex_t)object;\n\t\t/* if the thread is the object of a mutex */\n\t\tif (is_object) {\n\t\t\t/* detach the thread from the mutex */\n\t\t\tmutex->owner = RT_NULL;\n\t\t\tmutex->object = RT_NULL;\n\t\t\t/* if the thread is waiting on a mutex */\n\t\t\tif (is_waiting) {\n\t\t\t\t/* remove the thread from the mutex's waiting list */\n\t\t\t\tlist = &mutex->wait_list;\n\t\t\t\trt_list_for_each_entry(n, list, rt_thread_t, list) {\n\t\t\t\t\tif (n == thread) {\n\t\t\t\t\t\trt_list_remove(n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if the thread is pending on a mutex */\n\t\t\tif (is_pending) {\n\t\t\t\t/* clear the pending object */\n\t\t\t\tthread->wait_option = RT_THREAD_WAITING_NONE", "CodeBleu_score": 42.87140698665095}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(thread->type == RT_ThreadType_Thread);\n\tLOG_D(\"thread %s startup\", thread->name);\n\trt_thread_resume(thread);\n\treturn RT_EOK;\n}", "CodeBleu_score": 37.48593224474301}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread != RT_NULL);\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\tRT_DEBUG_LOG(RT_DEBUG_THREAD, (\"start thread:%s, stack:%p, entry:%p, parameter:%p, stack_size:%d, priority:%d, tick:%d, error:%d", "CodeBleu_score": 13.704541787408095}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t\tRT_ASSERT(thread != RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_INIT);\n\tRT_ASSERT(thread->type == RT_ThreadType_Normal);\n\n\tLOG_D(\"thread:%s, priority:%d\", thread->name, thread->current_priority);\n\n\t/* set thread's priority */\n\trt_thread_set_priority(thread, thread->init_priority);\n\n\t/* reset thread's state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume thread */\n\trt_thread_resume(thread);\n\n\t/* trigger scheduler */\n\tif (rt_thread_self() != RT_NULL && rt_thread_self()->cleanup_hook != RT_NULL) {\n\t\trt_thread_self()->cleanup_hook(RT_OK);\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 53.177772467791804}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_list_head = timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\trt_list_t *timer_list_next;\n\trt_timer_t *timer;\n\n\tif (rt_list_isempty(timer_list_head)) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\ttimer_list_next = timer_list_head->next;\n\ttimer = rt_list_entry(timer_list_next, struct rt_timer, list);\n\n\t*timeout_tick = timer->timeout_tick;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 48.029991488094005}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_list_head;\n\trt_list_t *timer_list_next;\n\trt_timer_t *timer;\n\trt_list_t *timer_list_timer;\n\n\ttimer_list_head = &timer_list[0];\n\n\tif (rt_list_isempty(timer_list_head)) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\ttimer_list_next = rt_list_entry(timer_list_head->next, struct rt_timer_s, list);\n\n\ttimer = rt_list_entry(timer_list_next, struct rt_timer_s, list);\n\n\ttimer_list_timer = &timer->list;\n\n\t*timeout_tick = timer_list_timer->next->key;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 41.08539951287105}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_err_t result;\n\trt_list_t *timer_list_head;\n\trt_list_t *timer_list_entry;\n\trt_timer_t *timer;\n\n\ttimer_list_head = &timer_list[RT_TIMER_SKIPLIST_LEVEL - 1];\n\ttimer_list_entry = rt_list_isempty(timer_list_head) ? RT_NULL : rt_list_entry(timer_list_head->next, struct rt_timer, list);\n\n\tif (timer_list_entry == RT_NULL) {\n\t\tresult = -RT_ETIMEOUT;\n\t} else {\n\t\ttimer = rt_list_entry(timer_list_entry, struct rt_timer, list);\n\t\t*timeout_tick = timer->timeout_tick;\n\t\tresult = RT_EOK;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 47.952230401414134}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_HEAP\n    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TICK_MAX / 2);\n\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer);\n    if (timer == RT_NULL) return RT_NULL;\n\n    _timer_init(timer, name, timeout, parameter, time, flag);\n\n    return timer;\n#else\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TICK_MAX / 2);\n\n    if (rt_object_init(rt_object_get_type(RT_Object_Class_Timer), name, RT_NULL) != RT_EOK) {\n        return RT_NULL;\n    }\n\n    return (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name, RT_NULL);\n#endif /* RT_USING_HEAP */\n}", "CodeBleu_score": 63.84324717729367}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\n}", "CodeBleu_score": 11.501974892288617}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\n/*\n * The function \"rt_timer_init\" initializes a timer object with the specified timeout function, parameter, time, and flag.", "CodeBleu_score": 24.307665482732975}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ta.router.ServeHTTP(rec, r)\n\t})\n\thandler.ServeHTTP(res, req)\n\tfor k, v := range rec.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 60.60780477657005}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tvar rec *httptest.ResponseRecorder\n\tif a.Recorder == nil {\n\t\trec = httptest.NewRecorder()\n\t} else {\n\t\trec = a.Recorder\n\t}\n\tdefer func() {\n\t\tfor k, v := range rec.HeaderMap {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}()\n\tvar handler http.Handler\n\tif a.Router == nil {\n\t\thandler = http.NotFoundHandler()\n\t} else {\n\t\thandler = a.Router\n\t}\n\tif a.Error == nil {\n\t\ta.Error = http.Error\n\t}\n\tfor _, h := range a.Handlers {\n\t\th(res, req, rec)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\ta.Error(res, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\thandler.ServeHTTP(res, req)\n}", "CodeBleu_score": 44.40017070388403}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// TODO: add a context to the request for logging\n\t// TODO: add a context to the request for tracing\n\t// TODO: add a context to the request for metrics\n\t// TODO: add a context to the request for security\n\t// TODO: add a context to the request for authentication\n\t// TODO: add a context to the request for authorization\n\t// TODO: add a context to the request for validation\n\t// TODO: add a context to the request for transformation\n\t// TODO: add a context to the request for caching\n\t// TODO: add a context to the request for logging\n\t// TODO: add a context to the request for tracing\n\t// TODO: add a context to the request for metrics\n\t// TODO: add a context to the request for security\n\t// TODO: add a context to the request for authentication\n\t// TODO: add a context to the request for authorization\n\t// TODO: add a context to the request for validation\n\t// TODO: add a context to the request for transformation\n\t// TODO: add a context to the request for caching\n\t// TODO: add a context to the request for logging\n\t// TODO: add a context to the request for tracing\n\t// TODO: add a context to the request for metrics\n\t// TODO: add a context to the request for security\n\t// TODO: add a context to the request for authentication\n\t// TODO: add a context to the request for authorization\n\t// TODO: add a context to the request for validation\n\t// TODO: add a context to the request for transformation\n\t// TODO: add a context to the request for caching\n\t// TODO: add a context to the request for logging\n\t// TODO: add a context to the request for tracing\n\t// TODO: add a context to the request for metrics\n\t// TODO: add a context to the request for security\n\t// TODO: add a context to the request for authentication\n\t// TODO: add a context to the request for authorization\n\t// TODO: add a context to the request for validation\n\t// TODO: add a context to the request for transformation\n\t// TODO: add a context to the request for caching\n\t// TODO: add a context to the request for logging\n\t// TODO: add a context to the request for tracing\n\t// TODO: add a context to the request for metrics\n\t// TODO: add", "CodeBleu_score": 3.9860708851698727}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the requested asset.\n\tasset, err := a.Assets.Open(req.URL.Path)\n\tif err != nil {\n\t\t// If the asset is not found, return a 404 error.\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer asset.Close()\n\n\t// Get the asset content.\n\tcontent, err := ioutil.ReadAll(asset)\n\tif err != nil {\n\t\t// If an error occurs while reading the asset, return a 500 error.\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Set the Content-Type header based on the asset extension.\n\text := path.Ext(req.URL.Path)\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t// Write the asset content to the response.\n\tres.Write(content)\n}", "CodeBleu_score": 64.22066258974571}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Retrieve the requested asset.\n\t// If an error occurs, return a 404 error.\n\tasset, err := a.assets.Asset(req.URL.Path[1:])\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the Content-Type header based on the file extension.\n\text := path.Ext(req.URL.Path)\n\tcontentType := \"text/plain\"\n\tswitch ext {\n\tcase \".css\":\n\t\tcontentType = \"text/css\"\n\tcase \".html\":\n\t\tcontentType = \"text/html\"\n\tcase \".js\":\n\t\tcontentType = \"text/javascript\"\n\t}\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Write the asset content to the response.\n\tres.Write(asset)\n}", "CodeBleu_score": 49.612131047783095}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the asset name from the URL path.\n\tname := req.URL.Path[1:]\n\t// Retrieve the asset.\n\tasset, err := a.Asset(name)\n\tif err != nil {\n\t\t// If the asset could not be found, return a 404 error.\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\t// Get the file extension from the asset name.\n\text := path.Ext(name)\n\t// Set the Content-Type header based on the file extension.\n\tres.Header().Set(\"Content-Type\", mime.TypeByExtension(ext))\n\t// Write the asset content to the response.\n\tres.Write(asset)\n}", "CodeBleu_score": 41.13994936564197}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name \" + name})\n\t\treturn\n\t}\n\tconnections := []map[string]string{}\n\trobot.Connections().Each(func(connection interface{}) {\n\t\tconnections = append(connections, map[string]string{\"name\": connection.(gobot.Connection).Name()})\n\t})\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 53.87334629355309}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"{\\\"error\\\":\\\"no robot name provided\\\"}\"))\n\t\treturn\n\t}\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"{\\\"error\\\":\\\"no robot found with name \" + name + \"\\\"}\"))\n\t\treturn\n\t}\n\tvar connections []Connection\n\trobot.Connections().Each(func(conn interface{}) bool {\n\t\tconnections = append(connections, conn.(Connection))\n\t\treturn true\n\t})\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 48.74348003588948}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\tname := req.URL.Query().Get(\"name\")\n\tif name == \"\" {\n\t\t// If the robot name is not specified, return an error.\n\t\ta.writeJSON(res, http.StatusBadRequest, map[string]string{\"error\": \"no robot name specified\"})\n\t\treturn\n\t}\n\n\t// Find the robot with the specified name.\n\trobot := a.master.Robot(name)\n\tif robot == nil {\n\t\t// If the robot is not found, return an error.\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\n\t// Gather the robot's connections and convert them to JSON format.\n\tconnections := []map[string]interface{}{}\n\trobot.Connections().Each(func(conn gobot.Connection) bool {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\":        conn.Name(),\n\t\t\t\"adaptor\":     conn.Adaptor().Name(),\n\t\t\t\"address\":     conn.Address(),\n\t\t\t\"port\":        conn.Port(),\n\t\t\t\"description\": conn.Description(),\n\t\t})\n\t\treturn true\n\t})\n\n\t// Write the JSON response containing the connections.\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 49.111235574536614}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif !secureCompare(r.Header.Get(\"Authorization\"), \"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 65.10949260163153}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tconst prefix = \"Basic \"\n\t\tif !strings.HasPrefix(auth, prefix) {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tb, err := base64.StdEncoding.DecodeString(auth[len(prefix):])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.20046857598341}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if the \"Authorization\" header is set and contains the \"Basic\" auth type\n\t\tif r.Header.Get(\"Authorization\") == \"\" || !strings.HasPrefix(r.Header.Get(\"Authorization\"), \"Basic \") {\n\t\t\t// If not, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Check if the username and password are correct\n\t\tif !secureCompare(r.Header.Get(\"Authorization\")[6:], base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))) {\n\t\t\t// If not, set the \"WWW-Authenticate\" header and return a \"Not Authorized\" response\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 57.79556839774522}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Min(math.Max(slope*input+intercept, float64(toMin)), float64(toMax)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.96773985080796}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept for the scaling transformation.\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\n\t// Return a function that performs the scaling.\n\treturn func(input float64) (value int) {\n\t\t// Calculate the output value.\n\t\tvalue = int(slope*input + intercept)\n\n\t\t// Clamp the output value.\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\t// Return the output value.\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.42414133094553}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tif fromMin == fromMax {\n\t\treturn func(input float64) (value int) {\n\t\t\treturn toMin\n\t\t}\n\t}\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 57.04953990049033}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, errors.New(\"no connection\")\n\t}\n\n\tif !a.Connection().AnalogInput() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog input\")\n\t}\n\n\traw := reader.AnalogRead(a.Pin())\n\tscaled := a.scale(raw)\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 41.80008256271206}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection == nil {\n\t\treturn 0, 0, errors.New(\"analog sensor driver not connected\")\n\t}\n\tif a.Connection.AnalogRead == nil {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog reads\", a.Connection.Name)\n\t}\n\n\traw, err := a.Connection.AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 50.70816573925103}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection().AnalogRead == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Analog read not supported by connection %s\", a.Connection().Name)\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn raw, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 50.50306078555643}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}", "CodeBleu_score": 40.05919918036268}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - m * float64(fromMin)\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}", "CodeBleu_score": 50.7251722367881}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}", "CodeBleu_score": 40.05919918036268}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tg := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tanalogReader: a,\n\t\tpin: pin,\n\t}\n\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase string:\n\t\t\tg.name = o\n\t\tcase int:\n\t\t\tg.threshold = o\n\t\t}\n\t}\n\n\tg.AddEvent(\"vibration\")\n\tg.analogReader.AddListener(g.eventHandler)\n\treturn g\n}", "CodeBleu_score": 28.92291699470979}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:    gobot.DefaultName(\"Grove Piezo Vibration Sensor\"),\n\t\tanalog:  a,\n\t\tpin:     pin,\n\t\toptions: opts,\n\t}\n\td.AddEvent(Vibration)\n\td.On(d.Event(Vibration), func(data interface{}) {\n\t\tif val, ok := data.(int); ok {\n\t\t\tif val > 1000 {\n\t\t\t\td.Publish(d.Event(Vibration), val)\n\t\t\t}\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 45.42382963897165}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tname := gobot.DefaultName\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase gobot.Name:\n\t\t\tname = string(o)\n\t\t}\n\t}\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:          name,\n\t\tanalogSensor:  NewAnalogSensorDriver(a, pin),\n\t\tthreshold:     1000,\n\t\tdataThreshold: 1000,\n\t\tEvent:         make(chan interface{}),\n\t}\n\td.AddEvent(d.onData)\n\tif err := d.analogSensor.AddEvent(d.onAnalogData); err != nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 48.87388745202759}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.On {\n\t\treturn errors.New(\"Buzzer is already on\")\n\t}\n\tif hz <= 0 {\n\t\treturn errors.New(\"Frequency must be greater than zero\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"Duration must be greater than zero\")\n\t}\n\tperiod := 1.0 / hz\n\ttempo := 60.0 / d.Bpm\n\ttoneDuration := time.Duration(period/tempo) * time.Second\n\tfor i := time.Duration(0); i < time.Duration(duration); i += toneDuration {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(toneDuration)\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(toneDuration)\n\t}\n\treturn nil\n}", "CodeBleu_score": 56.951114739273365}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.On {\n\t\treturn errors.New(\"buzzer is already on\")\n\t}\n\tif hz <= 0 {\n\t\treturn errors.New(\"frequency must be greater than zero\")\n\t}\n\tif duration < 0 {\n\t\treturn errors.New(\"duration must be greater than or equal to zero\")\n\t}\n\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\tperiod := time.Duration(float64(time.Second) / (hz * float64(d.tempo)))\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := time.Duration(0); i < duration; i += period {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(period / 2)\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(period / 2)\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.89452248421003}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn errors.New(\"invalid frequency\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"invalid duration\")\n\t}\n\tperiod := 1.0 / hz\n\ttempo := d.BeatsPerMinute()\n\tif tempo <= 0 {\n\t\treturn errors.New(\"invalid tempo\")\n\t}\n\tperiod = period * 60 / tempo\n\tdelay := time.Duration(period)\n\tt := time.NewTicker(delay * time.Second)\n\tdefer t.Stop()\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-t.C:\n\t\t\t\td.On()\n\t\t\tcase <-time.After(delay * time.Second):\n\t\t\t\td.Off()\n\t\t\t}\n\t\t}\n\t}()\n\ttime.Sleep(duration * time.Second)\n\treturn nil\n}", "CodeBleu_score": 32.525622011770366}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\tif d.isSleeping() {\n\t\treturn fmt.Errorf(\"already sleeping\")\n\t}\n\tif d.isStopped() {\n\t\treturn fmt.Errorf(\"already stopped\")\n\t}\n\tif d.isStarting() {\n\t\treturn fmt.Errorf(\"already starting\")\n\t}\n\tif d.isStopping() {\n\t\treturn fmt.Errorf(\"already stopping\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, 0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 33.28534096834588}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, d.sleepPinActiveState)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 34.201777509516134}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not configured\")\n\t}\n\td.stopIfRunning()\n\td.digitalWrite(d.sleepPin, false)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 32.46218744026996}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pin map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := a.sys.NewAnalogPin(path, params...)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 55.85305686073468}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin, err := a.sys.NewAnalogPin(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 53.54668369915525}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := a.sys.NewAnalogPin(path)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 53.56392119920134}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 65.821263485048}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 65.821263485048}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getDigitalPin(id, gopi.OUTPUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 66.49141717874116}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.connected == false {\n\t\treturn nil, fmt.Errorf(\"DigitalPinsAdaptor %s is not connected\", a.name)\n\t}\n\tpin, err := a.Pin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin.ApplyOptions(opts...)\n\tif pin.Name() == \"\" {\n\t\tpin.SetName(id)\n\t}\n\tif pin.Pin() == nil {\n\t\tpin.Pin(a.sys.NewDigitalPin(pin.Line()))\n\t}\n\tif pin.Err() == nil {\n\t\tpin.Err(a.initialize(pin))\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 38.98803973457726}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.connect() {\n\t\treturn nil, fmt.Errorf(\"adaptor %s is not connected\", a.Name())\n\t}\n\n\tpin, err := a.pin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\tif pin.DigitalPin == nil {\n\t\tpin.DigitalPin, err = a.sys.NewDigitalPin(pin.Chip, pin.Line)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin.DigitalPin.ApplyOptions(pin.Options)\n\t\ta.pins = append(a.pins, pin)\n\t} else {\n\t\tpin.DigitalPin.ApplyOptions(pin.Options)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 49.68697393850384}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.connect() == false {\n\t\treturn nil, fmt.Errorf(\"digital pin: adaptor is not connected\")\n\t}\n\n\tpin, err := a.Pin(id)\n\tif err != nil {\n\t\tvar chip, line int\n\t\tchip, line, err = a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = a.sys.NewDigitalPin(chip, line)\n\t\terr = pin.ApplyOptions(opts...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.pins = append(a.pins, pin)\n\t} else {\n\t\terr = pin.ApplyOptions(opts...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\terr = pin.Initialize()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 55.81584615124802}]}
