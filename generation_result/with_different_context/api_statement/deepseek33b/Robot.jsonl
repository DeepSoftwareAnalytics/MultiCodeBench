{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    log_info(\"Getting required files from folder '{}'\", folder);\n    std::vector<std::string> required_files;\n\n    // Get the list of files in the folder\n    std::vector<std::string> files = _pimpl->CallAndWait<std::vector<std::string>>(\n            [this, &folder]() { return _pimpl->GetFilesInFolder(folder); });\n\n    // Check if each file exists locally\n    for (const auto &file : files) {\n        if (download) {\n            if (!_pimpl->CallAndWait<bool>([this, &file]() { return _pimpl->FileExists(file); })) {\n                log_info(\"Downloading file '{}'\", file);\n                _pimpl->CallAndWait<void>([this, &file]() { _pimpl->DownloadFile(file); });\n            } else {\n                log_info(\"File '{}' found in cache\", file);\n            }\n        }\n        required_files.push_back(file);\n    }\n\n    return required_files;\n}", "CodeBleu_score": 51.9167028268557}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> requiredFiles;\n    std::string folderPath = folder + \"/\";\n    std::string line;\n    std::ifstream file(folderPath + \"required.txt\");\n    if (file.is_open()) {\n        while (std::getline(file, line)) {\n            requiredFiles.push_back(line);\n        }\n        file.close();\n    }\n    if (download) {\n        for (const auto &fileName : requiredFiles) {\n            if (!FileExists(folderPath + fileName)) {\n                log_info(\"Downloading {}\", fileName);\n                RequestFile(fileName);\n            } else {\n                log_info(\"Found {} in cache\", fileName);\n            }\n        }\n    }\n    return requiredFiles;\n}", "CodeBleu_score": 57.748674031227175}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    std::vector<std::string> required_files;\n    std::string path = \"./\" + folder;\n    for (const auto &entry : std::filesystem::directory_iterator(path)) {\n        if (entry.is_regular_file()) {\n            std::string file_name = entry.path().filename().string();\n            required_files.push_back(file_name);\n            if (download) {\n                if (!std::filesystem::exists(file_name)) {\n                    log_info(\"Downloading file: {}\", file_name);\n                    _pimpl->CallAndWait<std::string>(\n                            \"RequestFile\",\n                            file_name);\n                } else {\n                    log_info(\"File found in cache: {}\", file_name);\n                }\n            }\n        }\n    }\n    return required_files;\n}", "CodeBleu_score": 50.94749657187578}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the attachment type is SpringArm or SpringArmGhost\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the translation is only in the 'z' axis\n    if (transform.location.MakeSafeUnitVector().z == 1.0f) {\n      // Issue a warning if the translation is only in the 'z' axis\n      _warning_logger << \"Warning: Translation is only in the 'z' axis. \"\n                       << \"This may cause ill-formed transformations.\" << std::endl;\n    }\n  }\n\n  // Call an internal function to complete the actor spawning process\n  return _pimpl->CallAndWait<rpc::Actor>(\n      \"SpawnActorWithParent\",\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 47.38151273393049}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.MakeSafeUnitVector().z < std::numeric_limits<float>::epsilon()) {\n      _logger->warn(\"Attaching a {} to a {} with a translation of {} will cause the actor to be spawned at the same location as its parent. This is probably not intended.\",\n                    description.id,\n                    parent.id,\n                    transform.location);\n    }\n  }\n\n  return _pimpl->CallAndWait<rpc::Actor>(\n      \"simulator.spawn_actor_with_parent\",\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 53.02128029400297}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.MakeSafeUnitVector().z > 0.9999999999999998) {\n      log_warning(\n          \"Attachment type %s is not allowed to have a translation in the z axis. \"\n          \"Use a different attachment type or set the z axis to 0.\",\n          attachment_type == rpc::AttachmentType::SpringArm ? \"SpringArm\" : \"SpringArmGhost\");\n    }\n  }\n\n  return _pimpl->CallAndWait<rpc::Actor>(\n      \"simulation/spawn_actor_with_parent\",\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 53.691975845980345}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t   auto token = _pimpl->rpc_client.GetGBuffer(ActorId, GBufferId);\n   auto token_data = token.GetData();\n   std::vector<unsigned char> token_data_vector(token_data.size());\n   std::memcpy(token_data_vector.data(), token_data.data(), token_data.size());\n   _pimpl->streaming_client.Subscribe(token_data_vector, [callback](Buffer buffer) {\n      callback(buffer);\n   });\n}", "CodeBleu_score": 54.046399888515786}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t   // Get the token for the G-buffer\n   auto token = _pimpl->rpc_client.GetGBuffer(ActorId, GBufferId);\n\n   // Copy the token data\n   std::vector<unsigned char> token_data(token.size());\n   std::memcpy(token_data.data(), token.data(), token.size());\n\n   // Subscribe to the streaming client using the token data and callback function\n   _pimpl->streaming_client.Subscribe(\n      token_data,\n      [callback](Buffer buffer) {\n         // Call the callback function with the received buffer\n         callback(std::move(buffer));\n      });\n}", "CodeBleu_score": 57.34933443217667}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n   // Get the token for the G-buffer\n   auto token = _pimpl->rpc_client.GetGBuffer(ActorId, GBufferId);\n\n   // Copy the token data\n   std::vector<unsigned char> token_data(token.size);\n   std::memcpy(token_data.data(), token.data, token.size);\n\n   // Subscribe to the streaming client using the provided callback function\n   _pimpl->streaming_client.Subscribe(token_data, callback);\n}", "CodeBleu_score": 56.962688154851705}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>();\n    if (!_walker_navigation.compare_exchange(nullptr, navigation)) {\n      navigation = _walker_navigation.load();\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 54.84194801443838}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    std::shared_ptr<WalkerNavigation> navigation = _walker_navigation.load();\n    if (navigation == nullptr) {\n        navigation = std::make_shared<WalkerNavigation>();\n        if (!_walker_navigation.compare_exchange(navigation, navigation)) {\n            navigation = _walker_navigation.load();\n        }\n    }\n    return navigation;\n}", "CodeBleu_score": 53.40001422698375}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  // Check if the navigation object is null\n  if (_walker_navigation == nullptr) {\n    // Create a new WalkerNavigation instance\n    auto navigation = std::make_shared<WalkerNavigation>();\n    // Attempt to set the navigation object\n    if (!_walker_navigation.compare_exchange_strong(_walker_navigation, navigation)) {\n      // If the comparison fails, return the existing navigation object\n      return _walker_navigation;\n    }\n  }\n  // Return the existing or newly created WalkerNavigation object\n  return _walker_navigation;\n}", "CodeBleu_score": 50.212429493708854}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto start = std::chrono::system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    std::this_thread::yield();\n    if (std::chrono::system_clock::now() - start > timeout.to_chrono()) {\n      return false;\n    }\n  }\n  episode.GetState()->GetTrafficManager().Tick();\n  return true;\n}", "CodeBleu_score": 42.79807285553168}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const auto start = std::chrono::system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    std::this_thread::yield();\n    if (std::chrono::system_clock::now() - start > timeout.to_chrono()) {\n      return false;\n    }\n  }\n  episode.GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 42.109023494867934}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = std::chrono::system_clock::now();\n  while (episode.GetState()->GetFrame() < frame) {\n    std::this_thread::yield();\n    if (std::chrono::system_clock::now() - start > timeout.to_chrono()) {\n      return false;\n    }\n  }\n  episode.GetTrafficManager()->Tick();\n  return true;\n}", "CodeBleu_score": 42.49086206610648}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // Check if the episode is already loaded\n  if (_episode && _episode->GetId() == _client.GetEpisodeSettings().map) {\n    return GetCurrentEpisode();\n  }\n\n  // Load the new episode\n  _episode = _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Wait for the episode to load\n  bool episode_loaded = false;\n  for (int i = 0; i < _client.GetTimeout().milliseconds; ++i) {\n    if (_episode->GetId() != _client.GetEpisodeSettings().map) {\n      episode_loaded = true;\n      break;\n    }\n    _episode->WaitForState(rpc::EpisodeState::Running);\n  }\n\n  // Check if the episode loaded successfully\n  if (!episode_loaded) {\n    throw std::runtime_error(\"Failed to load episode.\");\n  }\n\n  // Return the episode object\n  return std::move(_episode);\n}", "CodeBleu_score": 47.33198758674182}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  _episode = std::make_unique<EpisodeProxy>(_client, map_name, reset_settings, map_layers);\n  auto start_time = std::chrono::high_resolution_clock::now();\n  while (_episode->GetId() == _episode->GetEpisodeSettings().map_name) {\n    _episode->WaitForState();\n    auto elapsed_time = std::chrono::high_resolution_clock::now() - start_time;\n    if (elapsed_time > _client.GetTimeout()) {\n      throw std::runtime_error(\"Timeout while loading episode\");\n    }\n  }\n  return std::move(*_episode);\n}", "CodeBleu_score": 41.925730499950355}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t  // Get the current episode ID.\n  std::string episode_id = GetCurrentEpisode().GetId();\n\n  // Load the new episode with the specified map name, reset settings, and map layers.\n  _client.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Get the episode settings for the new episode.\n  EpisodeSettings settings = _client.GetEpisodeSettings();\n\n  // Wait for the episode to change state.\n  _episode->WaitForState(rpc::EpisodeState::Running);\n\n  // Check if the new episode ID is different from the current episode ID.\n  if (episode_id == GetCurrentEpisode().GetId()) {\n    // If the episode ID is the same, throw a runtime exception.\n    throw std::runtime_error(\"Failed to load new episode\");\n  }\n\n  // Move the new episode object to the episode pointer.\n  _episode = std::move(GetCurrentEpisode());\n\n  // Return the new episode object.\n  return _episode;\n}", "CodeBleu_score": 41.01203315258317}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    Walker *walker = _episode->GetWalker(controller.GetId());\n    if (walker == nullptr) {\n        throw std::runtime_error(\"Walker with ID \" + std::to_string(controller.GetId()) + \" not found.\");\n    }\n    ASSERT(_episode != nullptr);\n    if (!_episode->CreateNavigationIfMissing()) {\n        throw std::runtime_error(\"Failed to create navigation\");\n    }\n    walker->RegisterAIController(controller.GetId());\n}", "CodeBleu_score": 55.06501994034482}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  // Get the walker associated with the controller\n  Walker *walker = GetWalker(controller.GetId());\n  // Throw an exception if the walker is not found\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker with ID \" + std::to_string(controller.GetId()) + \" not found.\");\n  }\n  // Assert that the episode is not null\n  DEBUG_ASSERT(episode != nullptr);\n  // Create navigation if it is missing\n  _episode->CreateNavigationIfMissing();\n  // Register the walker with the controller's ID\n  nav->RegisterWalker(walker, controller.GetId());\n}", "CodeBleu_score": 54.15764342631086}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    auto walker = GetWalker(controller.GetId());\n    if (walker == nullptr) {\n        throw std::runtime_error(\"Walker not found\");\n    }\n    DEBUG_ASSERT(_episode != nullptr);\n    if (!_episode->CreateNavigationIfMissing()) {\n        throw std::runtime_error(\"Navigation not found\");\n    }\n    auto nav = _episode->GetNavigation();\n    nav->RegisterWalker(controller.GetId(), walker);\n}", "CodeBleu_score": 66.45032685728948}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  const auto &attributes = blueprint.GetAttributes();\n  DEBUG_ASSERT(attributes.HasMember(\"id\"));\n  const auto id = attributes[\"id\"].GetString();\n  const auto display_id = attributes[\"display_id\"].GetString();\n\n  auto result = _client.SpawnActorWithParent(\n      blueprint,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n\n  if (result == nullptr) {\n    return nullptr;\n  }\n\n  result->GetDisplayId = display_id;\n\n  _episode->RegisterActor(result);\n  result->SetGarbageCollectionPolicy(gc);\n\n  log_debug(\"Spawned actor: {}\", blueprint.MakeActorDescription());\n\n  return result;\n}", "CodeBleu_score": 46.1998324854915}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  auto actor = blueprint.MakeActorDescription(transform);\n  if (parent != nullptr) {\n    actor.SetParent(*parent);\n    actor.SetAttachment(attachment_type, socket_name);\n  }\n  auto result = _client.SpawnActor(actor, gc);\n  if (result != rpc::ActorDynamicState::Invalid) {\n    auto current_episode = GetCurrentEpisode();\n    if (current_episode != nullptr) {\n      current_episode->RegisterActor(result);\n    }\n    log_debug(\n        \"ActorFactory::MakeActor() created actor \",\n        actor.GetDisplayId(),\n        \" (\",\n        blueprint.GetId(),\n        \")\");\n    return result;\n  }\n  return nullptr;\n}", "CodeBleu_score": 53.4197166924872}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t  // Get the current episode.\n  auto _episode = _current_episode.load();\n  DEBUG_ASSERT(_episode != nullptr);\n\n  // Get the display id.\n  auto result = _client.SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n  auto display_id = result->GetDisplayId();\n\n  // Make the actor description.\n  auto actor_description = blueprint.MakeActorDescription();\n  actor_description->SetId(display_id);\n\n  // Register the actor.\n  _episode->RegisterActor(actor_description);\n\n  // Apply the garbage collection policy.\n  if (gc == GarbageCollectionPolicy::EXPLICIT) {\n    _episode->RemoveActor(display_id);\n  }\n\n  // Log the creation details.\n  auto parent_id = parent != nullptr ? parent->GetId() : 0;\n  log_debug(\n    \"SpawnActor: id \", display_id,\n    \", blueprint \", blueprint.GetId(),\n    \", parent \", parent_id,\n    \", attachment \", static_cast<uint8_t>(attachment_type),\n    \", socket \", socket_name);\n\n  // Return the actor.\n  return _episode->GetActorById(display_id);\n}", "CodeBleu_score": 54.38973186918727}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(episode != nullptr);\n  auto token = sensor.GetActorDescription().GetStreamToken();\n  client->SubscribeToStream(token, [=](Buffer buffer) {\n    auto data = sensor::Deserializer::Deserialize(buffer);\n    data->SetEpisode(episode);\n    callback(data);\n  });\n}", "CodeBleu_score": 54.43682667389807}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(episode.IsValid());\n  client->SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [weak_episode = episode.shared_from_this(), callback](Buffer buffer) {\n        auto episode = weak_episode.lock();\n        if (episode != nullptr) {\n          auto sensor_data = sensor::Deserializer::Deserialize(std::move(buffer));\n          sensor_data->SetEpisode(episode);\n          callback(sensor_data);\n        }\n      });\n}", "CodeBleu_score": 52.72395072737008}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  DEBUG_ASSERT(_Episode.GetEpisodeProxy() != nullptr);\n  _Episode.GetEpisodeProxy()->Lock()->SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [this, callback, sensor](Buffer buffer) {\n        auto data = sensor::Deserializer::Deserialize(buffer);\n        data->SetEpisodeId(_Episode.GetId());\n        callback(data);\n      });\n}", "CodeBleu_score": 55.15324435550431}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  auto &_simulator = episode->GetSimulator();\n  auto &_nav = episode->GetNavigation();\n\n  // Load current walkers.\n  const auto &walkers = _nav.GetWalkers();\n  if (walkers->empty()) {\n    return;\n  }\n\n  // Get current state.\n  auto state = episode->GetState();\n\n  // Remove walkers that no longer exist.\n  std::vector<Walker> dead_walkers;\n  for (auto &&walker : *walkers) {\n    if (!_nav.IsWalkerAlive(walker.id)) {\n      dead_walkers.push_back(walker);\n    }\n  }\n  for (auto &&walker : dead_walkers) {\n    _nav.RemoveAgent(walker.id);\n  }\n\n  // Update vehicles in the crowd.\n  UpdateVehiclesInCrowd(episode);\n\n  // Update the crowd itself.\n  _nav.UpdateCrowd();\n\n  // Apply states to walkers.\n  std::vector<Command> commands;\n  commands.reserve(walkers->size());\n  for (auto &&walker : *walkers) {\n    auto walker_transform = _nav.GetWalkerTransform(walker.id);\n    auto walker_speed = _nav.GetWalkerSpeed(walker.id);\n    commands.emplace_back(Command::ApplyVelocity{walker_transform, walker_speed});\n  }\n  _simulator.lock()->ApplyBatchSync(commands, state);\n\n  // Check if any walker has been killed.\n  for (auto &&walker : *walkers) {\n    if (!_nav.IsWalkerAlive(walker.id)) {\n      _nav.RemoveAgent(walker.id);\n      UnregisterWalker(episode, walker.id);\n      _simulator.lock()->DestroyActor(walker.id);\n    }\n  }\n}", "CodeBleu_score": 58.43431023336223}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  // Load current walkers\n  const auto walkers = _nav.GetWalkers();\n  if (walkers->empty()) {\n    return;\n  }\n\n  // Get current state of episode\n  const auto state = episode->GetState();\n\n  // Remove walkers that no longer exist\n  for (auto it = walkers->begin(); it != walkers->end();) {\n    if (!CheckIfWalkerExist(state, *it)) {\n      UnregisterWalker(*it);\n      it = walkers->erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  // Update vehicles in crowd\n  _nav.UpdateCrowd();\n\n  // Apply states to walkers\n  std::vector<Command> commands;\n  commands.reserve(walkers->size());\n  for (auto walker : *walkers) {\n    const auto walker_speed = _nav.GetWalkerSpeed(walker);\n    const auto walker_transform = _nav.GetWalkerTransform(walker);\n    commands.emplace_back(walker, walker_transform, walker_speed);\n  }\n\n  // Apply batch sync\n  _simulator.lock()->ApplyBatchSync(commands);\n\n  // Check if any walker has been killed\n  for (auto walker : *walkers) {\n    if (!_simulator.lock()->IsWalkerAlive(walker)) {\n      _nav.RemoveAgent(walker);\n      UnregisterWalker(walker);\n    }\n  }\n}", "CodeBleu_score": 48.24311842658068}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t  // Load the current walkers.\n  auto walkers = _nav.GetWalkers();\n  if (walkers->empty()) {\n    return;\n  }\n\n  // Retrieve the current state of the episode.\n  auto state = episode->GetState();\n\n  // Remove any walkers that no longer exist.\n  for (auto it = walkers->begin(); it != walkers->end();) {\n    if (!CheckIfWalkerExist(state, *it)) {\n      UnregisterWalker(*it);\n      it = walkers->erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  // Update the vehicles in the crowd and the crowd itself in the navigation module.\n  _nav.UpdateCrowd();\n\n  // Apply the batch of states to the simulator.\n  std::vector<Commands> commands;\n  commands.reserve(walkers->size());\n  for (auto &walker : *walkers) {\n    // Get the walker's transform and speed.\n    const auto walker_transform = _nav.GetWalkerTransform(walker);\n    const auto walker_speed = _nav.GetWalkerSpeed(walker);\n\n    // Create a command for the walker.\n    Commands command;\n    command.emplace_back(\n        std::make_unique<SyncVehiclePoseCommand>(walker_transform, walker_speed));\n    commands.push_back(std::move(command));\n  }\n\n  // Apply the batch of states to the simulator.\n  _simulator.lock()->ApplyBatchSync(commands, false);\n\n  // Check if any walker has been killed.\n  for (auto &walker : *walkers) {\n    if (!_nav.IsWalkerAlive(walker)) {\n      // Remove the walker from the crowd and destroy its controller.\n      _nav.RemoveAgent(walker);\n      UnregisterWalker(walker);\n\n      // Destroy the walker's actor.\n      _simulator.lock()->SetActorDead(walker);\n      _simulator.lock()->", "CodeBleu_score": 51.27302940248916}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.uid = uid;\n    description.id = id;\n    description.attributes.reserve(attributes.size());\n    for (const auto& attribute : attributes) {\n        description.attributes.push_back(attribute);\n    }\n    return description;\n}", "CodeBleu_score": 78.7429452821066}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.uid = this->uid;\n    description.id = this->id;\n    description.attributes.reserve(this->attributes.size());\n    for (auto &attribute : this->attributes) {\n        description.attributes.push_back(attribute);\n    }\n    return description;\n}", "CodeBleu_score": 71.7129324889691}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t  rpc::ActorDescription description;\n  description.set_uid(uid);\n  description.set_id(id);\n  description.attributes.reserve(attributes.size());\n  for (const auto &attribute : attributes) {\n    description.attributes.push_back(attribute);\n  }\n  return description;\n}", "CodeBleu_score": 77.00488968480217}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  std::vector<SharedPtr<Blueprint>> result;\n  for (auto const &blueprint : blueprints_) {\n    if (blueprint.second->ContainsAttribute(name)) {\n      auto attribute = blueprint.second->GetAttribute(name);\n      if (attribute.GetValue() == value ||\n          attribute.GetRecommendedValues().contains(value)) {\n        result.emplace_back(blueprint.second);\n      }\n    }\n  }\n  return std::make_shared<BlueprintLibrary>(result);\n}", "CodeBleu_score": 42.490664229275865}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  auto result = std::make_shared<BlueprintLibrary>();\n  for (auto &pair : blueprints) {\n    if (pair.second.ContainsAttribute(name)) {\n      if (pair.second.GetAttribute(name).GetValue() == value ||\n          pair.second.GetAttribute(name).GetRecommendedValues().contains(value)) {\n        result->blueprints.emplace(pair.first, pair.second);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 40.657785281515935}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  auto result = std::make_shared<BlueprintLibrary>();\n  for (auto &pair : _blueprints) {\n    if (pair.second.ContainsAttribute(name)) {\n      const auto &attribute = pair.second.GetAttribute(name);\n      if (attribute.GetValue() == value ||\n          attribute.GetRecommendedValues().contains(value)) {\n        result->_blueprints.emplace(pair);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 46.28821752274395}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string full_path = base_folder + \"/\" + path + \"_\" + std::to_string(version) + \".bin\";\n    if (!FileSystem::ValidateFilePath(full_path)) {\n        return false;\n    }\n    std::ofstream out(full_path, std::ios::binary | std::ios::trunc);\n    if (!out.good()) {\n        return false;\n    }\n    out.write(reinterpret_cast<char*>(content.data()), content.size());\n    out.close();\n    return true;\n}", "CodeBleu_score": 49.06197745461903}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string filePath = FileSystem::ValidateFilePath(path, m_baseFolder, m_version);\n    std::ofstream out(filePath, std::ios::binary | std::ios::trunc);\n    if (out.good()) {\n        out.write(reinterpret_cast<char*>(content.data()), content.size());\n        out.close();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 45.75152386593076}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string fullPath = baseFolder + \"/\" + path + \"_\" + std::to_string(version) + \".bin\";\n    if (!FileSystem::ValidateFilePath(fullPath)) {\n        return false;\n    }\n    std::ofstream out(fullPath, std::ios::binary | std::ios::trunc);\n    if (!out.good()) {\n        return false;\n    }\n    out.write(reinterpret_cast<char*>(content.data()), content.size());\n    out.close();\n    return true;\n}", "CodeBleu_score": 49.54572046853929}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto &extents = parent->GetExtents(frame);\n  const auto location = transform.location + parent->GetLocation(frame);\n  const auto yaw = transform.rotation.yaw;\n  const auto corners = geom::Rotate(extents, yaw);\n  return std::make_shared<const Bounds>(frame, location, corners);\n}", "CodeBleu_score": 38.44883392072316}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto &extents = parent_bounds->GetExtent();\n  const auto &location = parent_bounds->GetLocation();\n  const auto &yaw = transform.rotation.yaw;\n  const auto &cos_yaw = std::cos(yaw);\n  const auto &sin_yaw = std::sin(yaw);\n\n  const geom::Location corners[4] = {\n      location + geom::Location(cos_yaw * extents.x - sin_yaw * extents.y, sin_yaw * extents.x + cos_yaw * extents.y),\n      location + geom::Location(cos_yaw * extents.x + sin_yaw * extents.y, -sin_yaw * extents.x + cos_yaw * extents.y),\n      location + geom::Location(-cos_yaw * extents.x + sin_yaw * extents.y, -sin_yaw * extents.x - cos_yaw * extents.y),\n      location + geom::Location(-cos_yaw * extents.x - sin_yaw * extents.y, sin_yaw * extents.x - cos_yaw * extents.y),\n  };\n\n  return std::make_shared<const Bounds>(frame, corners);\n}", "CodeBleu_score": 45.22585845635631}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t  const auto &parent = transform.GetParent();\n  const auto &bounds = parent.GetBoundingBox();\n  const auto &location = bounds.location + transform.location;\n  const auto &yaw = transform.rotation.yaw;\n  const auto &extent = bounds.extent;\n  const auto &rotated = geom::Rotate(geom::Location(extent.x, extent.y), yaw);\n  const auto &rotated2 = geom::Rotate(geom::Location(extent.x, -extent.y), yaw);\n  const auto &rotated3 = geom::Rotate(geom::Location(-extent.x, extent.y), yaw);\n  const auto &rotated4 = geom::Rotate(geom::Location(-extent.x, -extent.y), yaw);\n  return std::make_shared<const Bounds>(frame, location + rotated, location + rotated2, location + rotated3, location + rotated4);\n}", "CodeBleu_score": 44.15701430451633}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_episode.Lock());\n  const auto light_states = _episode.Lock()->QueryLightsStateToServer();\n  for (auto &light_state : light_states) {\n    if (_lights.find(light_state.id) == _lights.end()) {\n      _lights.emplace(\n          light_state.id,\n          std::make_unique<Light>(\n              light_state.id,\n              static_cast<LightState::LightGroup>(light_state.group),\n              Color(light_state.color)));\n    }\n    _lights.at(light_state.id)->SetColor(Color(light_state.color));\n  }\n}", "CodeBleu_score": 47.004892482340885}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_episode.Lock()->GetMutex());\n  const auto &light_states = _episode.Lock()->QueryLightsStateToServer();\n  for (const auto &light_state : light_states) {\n    auto search = _lights.find(light_state.first);\n    if (search != _lights.end()) {\n      search->second->SetState(light_state.second);\n    } else {\n      _lights.insert({light_state.first, std::make_shared<Light>(light_state.second)});\n    }\n  }\n}", "CodeBleu_score": 41.335273770194654}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t  std::lock_guard<std::mutex> lock(_episode.Lock()->GetMutex());\n  _client->GetLightStates(\n      _episode.Lock()->GetCurrentEpisode().Lock()->GetMapName(),\n      _lightsState);\n\n  for (auto &lightState : _lightsState) {\n    if (_lights.find(lightState.first) == _lights.end()) {\n      _lights.emplace(\n          lightState.first,\n          std::make_unique<Light>(lightState.first, lightState.second));\n    } else {\n      _lights.at(lightState.first)->SetState(lightState.second);\n    }\n  }\n}", "CodeBleu_score": 37.168849066329464}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(_episode.Lock());\n\n  if (!_lights_changes.empty()) {\n    std::vector<rpc::LightState> message;\n    message.reserve(_lights_changes.size());\n    for (auto it_light = _lights_changes.begin(); it_light != _lights_changes.end();\n         ++it_light) {\n      rpc::LightState light_state;\n      light_state.id = it_light->first;\n      light_state.color = it_light->second.GetColor();\n      light_state.location = it_light->second.GetLocation();\n      message.push_back(std::move(light_state));\n    }\n    _lights_changes.clear();\n    _dirty = false;\n    if (!discard_client) {\n      _episode.GetClient()->UpdateLightsState(message);\n    }\n  }\n}", "CodeBleu_score": 51.20660876781257}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(_lights_mutex);\n\n    if (_lights_changes.empty()) {\n        return;\n    }\n\n    flatbuffers::FlatBufferBuilder builder;\n    auto states = builder.CreateVectorOfStructs(_lights_changes);\n    auto message = CreateUpdateLightsState(builder, states);\n    builder.Finish(message);\n\n    _episode.Lock()->SendMessage(Message(builder.GetBufferPointer(), builder.GetSize()), discard_client);\n\n    _lights_changes.clear();\n    _lights_dirty = false;\n}", "CodeBleu_score": 34.80128358701956}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    if (_lights_changes.empty())\n        return;\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    if (!_lights_changes.empty()) {\n        std::vector<rpc::LightState> message;\n        for (auto it_light = _lights_changes.begin(); it_light != _lights_changes.end(); ++it_light) {\n            message.push_back(it_light->second);\n        }\n        _lights_changes.clear();\n        if (discard_client) {\n            _client->DiscardLightState(message);\n        } else {\n            _client->UpdateLightState(message);\n        }\n    }\n    _dirty = false;\n}", "CodeBleu_score": 43.50028614289328}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"sensor.other.v2x_custom\", \"Sensor ID mismatch\");\n    return;\n  }\n\n  GetEpisode().Lock()->Send(std::move(message));\n}", "CodeBleu_score": 50.6686226448793}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"Sensor ID is not sensor.other.v2x_custom\");\n    return;\n  }\n\n  log_debug(\"Sending message: \" + message);\n  GetEpisode().Lock()->Send(message, GetContext());\n}", "CodeBleu_score": 57.17395884970842}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() == \"sensor.other.v2x_custom\") {\n    log_debug(\"Sending message: \" + message);\n  } else {\n    log_warning(\"Sensor ID does not match\");\n  }\n  GetEpisode().Lock()->Send(message, GetDisplayId(), GetContext());\n}", "CodeBleu_score": 53.42636420813558}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        tm.RegisterVehicles(shared_from_this(), tm_port);\n    }\n    else {\n        tm.UnregisterVehicles(shared_from_this(), tm_port);\n    }\n}", "CodeBleu_score": 57.52413071529487}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        // Register the vehicle with the traffic manager\n        shared_ptr<Vehicle> vehicle = shared_from_this();\n        tm.RegisterVehicles(vehicle, tm_port);\n    } else {\n        // Unregister the vehicle from the traffic manager\n        tm.UnregisterVehicles(shared_from_this());\n    }\n}", "CodeBleu_score": 50.714851404232284}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        tm.RegisterVehicles(shared_from_this(), tm_port);\n    } else {\n        tm.UnregisterVehicles(shared_from_this());\n    }\n}", "CodeBleu_score": 53.74226913755604}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t    GetEpisode().Lock()->RegisterAIController(*this);\n    auto walker = GetParent().CastTo<AWalker>();\n    auto location = walker->GetActorLocation();\n    GetEpisode().Lock()->GetNavigation()->AddWalker(walker->GetId(), location);\n    walker->GetRootComponent()->SetSimulatePhysics(false);\n    walker->GetRootComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}", "CodeBleu_score": 53.073566990699646}, {"code": "void WalkerAIController::Start(){\n\t    // Register the AI controller with the episode\n    GetEpisode().Lock()->RegisterAIController(shared_from_this());\n\n    // Get the walker actor\n    auto walker = GetParent().lock();\n\n    // Add the walker actor to the navigation system with its current location\n    GetEpisode().Lock()->GetNavigation()->AddWalker(walker->GetId(), walker->GetLocation());\n\n    // Disable the physics simulation and collisions for the walker actor\n    walker->GetActor()->SetSimulatePhysics(false);\n    walker->GetActor()->SetActorEnableCollision(false);\n}", "CodeBleu_score": 44.597989827644405}, {"code": "void WalkerAIController::Start(){\n\t  Super::Start();\n  auto* walker = Cast<ACharacter>(GetPawn());\n  if (walker != nullptr) {\n    GetEpisode().Lock()->RegisterAIController(*this);\n    GetEpisode().Lock()->GetNavigation()->AddWalker(walker, walker->GetActorLocation());\n    walker->GetCharacterMovement()->bSimulationEnabled = false;\n    walker->GetCharacterMovement()->SetMovementMode(MOVE_None);\n    walker->GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n  }\n}", "CodeBleu_score": 55.92868560845321}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto* walker = GetParent();\n  if (walker == nullptr) {\n    return;\n  }\n  auto* nav = GetEpisode().Lock()->GetNavigation();\n  if (nav == nullptr) {\n    return;\n  }\n  if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n    log_warning(\n        \"The navigation mesh doesn't have this walker or it is \"\n        \"not on the same navigation mesh\");\n  }\n}", "CodeBleu_score": 59.030331864122374}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (auto episode = GetEpisode().Lock()) {\n    if (auto parent_walker = episode->GetParentActor()) {\n      if (auto nav = episode->GetNavigation()) {\n        if (!nav->SetWalkerMaxSpeed(parent_walker->GetId(), max_speed)) {\n          log_warning(\"Failed to set max speed: \", max_speed, \" for walker: \", parent_walker->GetId());\n        }\n      } else {\n        log_warning(\"Navigation is not available\");\n      }\n    } else {\n      log_warning(\"Parent walker is not available\");\n    }\n  } else {\n    log_warning(\"Current episode is not available\");\n  }\n}", "CodeBleu_score": 56.884283955670135}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t    if (auto episode = GetEpisode().Lock()) {\n        if (auto nav = episode->GetNavigation()) {\n            if (auto walker = nav->GetWalker(GetParent())) {\n                if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n                    log_warning(\"failed to set max speed for walker: \", walker->GetId());\n                }\n            } else {\n                log_warning(\"failed to find walker for agent: \", GetParent()->GetId());\n            }\n        } else {\n            log_warning(\"failed to find navigation system in episode\");\n        }\n    } else {\n        log_warning(\"failed to lock episode\");\n    }\n}", "CodeBleu_score": 55.52358146677855}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(_parent->GetMap().GetPrevious(_waypoint).size());\n  for (auto &waypoint : _parent->GetMap().GetPrevious(_waypoint, distance)) {\n    result.emplace_back(std::make_shared<Waypoint>(waypoint));\n  }\n  return result;\n}", "CodeBleu_score": 64.8063715486909}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : _parent->GetMap().GetPrevious(_waypoint, distance)) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n  }\n  return result;\n}", "CodeBleu_score": 63.9981945035011}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(\n      std::make_shared<Waypoint>(_parent->GetMap().GetPrevious(waypoint.first, distance)));\n  }\n  return result;\n}", "CodeBleu_score": 66.92795271708266}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  std::unordered_set<SharedPtr<Waypoint>> added_signals;\n\n  // Get signals in distance\n  result = _parent->GetMap().GetSignalsInDistance(\n      distance, _transform, stop_at_junction);\n\n  // Add landmarks to result\n  for (auto &waypoint : result) {\n    // Check if signal is repeated\n    if (added_signals.count(waypoint) == 0) {\n      // Add signal to set of added signals\n      added_signals.insert(waypoint);\n      // Create new waypoint and landmark\n      SharedPtr<Waypoint> new_waypoint = std::make_shared<Waypoint>();\n      SharedPtr<Landmark> new_landmark = std::make_shared<Landmark>();\n      // Set waypoint and landmark properties\n      new_waypoint->_transform = waypoint->_transform;\n      new_waypoint->_parent = _parent;\n      new_landmark->_transform = waypoint->_transform;\n      new_landmark->_type = waypoint->_type;\n      new_landmark->_parent = _parent;\n      // Add new waypoint and landmark to result\n      result.emplace_back(new_waypoint);\n      result.emplace_back(new_landmark);\n    }\n  }\n\n  // Return result\n  return result;\n}", "CodeBleu_score": 54.735369197859576}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::unordered_set<SharedPtr<Signal>> added_signals;\n  for (auto &signal : GetSignalsInDistance(distance, stop_at_junction)) {\n    if (added_signals.count(signal) > 0) {\n      continue;\n    }\n    result.emplace_back(\n        new Landmark(shared_from_this(), signal, distance));\n    added_signals.insert(signal);\n  }\n  return result;\n}", "CodeBleu_score": 41.51757203953203}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Waypoint>> result;\n  std::unordered_set<SharedPtr<Signal>> added_signals;\n\n  // Get signals in distance\n  result = GetSignalsInDistance(distance, stop_at_junction);\n\n  // Check for repeated signals to avoid duplicates\n  for (auto &signal : result) {\n    if (added_signals.count(signal) == 0) {\n      // Create a new Waypoint and Landmark for each unique signal\n      SharedPtr<Landmark> landmark =\n          std::make_shared<Landmark>(signal->GetSignalId(), signal->GetLocation());\n      SharedPtr<Waypoint> waypoint = std::make_shared<Waypoint>(landmark);\n      result.emplace_back(waypoint);\n      added_signals.insert(signal);\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 49.51076115682434}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  // Lock the episode and get the timeout.\n  auto episode = _episode.Lock();\n  const time_duration episode_timeout = episode->GetNetworkingTimeout();\n  // Set the local timeout based on the provided timeout or the episode's networking timeout.\n  const time_duration local_timeout = timeout.milliseconds() > 0.0f ? timeout : episode_timeout;\n  // Get the current snapshot.\n  const Snapshot &curr_snapshot = episode->GetStateSnapshot();\n  // Create a new settings object.\n  rpc::EpisodeSettings new_settings = settings;\n  // If the settings include a fixed delta time, verify its accuracy over a series of ticks.\n  if (settings.fixed_delta_seconds.has_value()) {\n    // Set the fixed delta time in the new settings object.\n    new_settings.fixed_delta_seconds = settings.fixed_delta_seconds.get();\n    // Set the number of attempts to 10.\n    constexpr int attempts = 10;\n    // Set the maximum allowed error to a small value.\n    constexpr float max_allowed_error = 0.0001f;\n    // Set the number of ticks to 100.\n    constexpr int ticks = 100;\n    // Set the time scale to 1.0f.\n    constexpr float time_scale = 1.0f;\n    // Set the number of failed attempts to 0.\n    int failed_attempts = 0;\n    // Loop over the number of attempts.\n    for (int i = 0; i < attempts; ++i) {\n      // Set the fixed delta time in the new settings object.\n      new_settings.fixed_delta_seconds = settings.fixed_delta_seconds.get();\n      // Set the time scale in the new settings object.\n      new_settings.time_scale = time_scale;\n      // Apply the new settings to the episode.\n      episode->SetEpisodeSettings(new_settings, local_timeout);\n      // Get the current timestamp.\n      const Timestamp curr_timestamp = curr_snapshot.GetTimestamp();\n      // Loop over the number of ticks.\n      for (int j = ", "CodeBleu_score": 51.59154518546845}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  // Lock the episode and get the networking timeout.\n  auto episode = _episode.Lock();\n  time_duration networking_timeout = episode->GetNetworkingTimeout();\n\n  // Set the local timeout based on the provided timeout or the episode's networking timeout.\n  time_duration local_timeout = timeout > time_duration::zero() ? timeout : networking_timeout;\n\n  // If the settings include a fixed delta time, verify the accuracy of this setting over a series of ticks.\n  if (settings.fixed_delta_seconds.has_value()) {\n    // Get the fixed delta time from the settings.\n    float fixed_delta_time = settings.fixed_delta_seconds.get();\n\n    // Set the number of attempts to verify the accuracy of the fixed delta time.\n    constexpr int num_attempts = 10;\n\n    // Set the number of ticks to use for the verification.\n    constexpr int num_ticks = 100;\n\n    // Set the tolerance for the accuracy of the fixed delta time.\n    constexpr float tolerance = 0.001f;\n\n    // Initialize the number of successful attempts.\n    int num_successful_attempts = 0;\n\n    // Initialize the average time per tick.\n    float average_time_per_tick = 0.0f;\n\n    // Loop over the number of attempts.\n    for (int i = 0; i < num_attempts; ++i) {\n      // Set the episode's fixed delta time.\n      episode->SetFixedDeltaSeconds(fixed_delta_time);\n\n      // Get the initial timestamp.\n      auto initial_timestamp = GetTimestamp();\n\n      // Loop over the number of ticks.\n      for (int j = 0; j < num_ticks; ++j) {\n        // Tick the world.\n        Tick(time_duration::zero());\n      }\n\n      // Get the final timestamp.\n      auto final_timestamp = GetTimestamp();\n\n      // Calculate the elapsed time.\n      float elapsed_time = static_cast<float>((final_timestamp - initial_timestamp).count()) / 1e6f;\n\n      // Calculate the average", "CodeBleu_score": 48.434536434196104}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  // Set a local timeout based on the provided timeout or the episode's networking timeout.\n  time_duration local_timeout = timeout;\n  if (local_timeout == time_duration::zero()) {\n    local_timeout = _episode.Lock()->GetNetworkingTimeout();\n  }\n\n  // If the settings include a fixed delta time, attempt to verify the accuracy of this setting over a series of ticks.\n  if (settings.fixed_delta_seconds.has_value()) {\n    constexpr int num_ticks = 10;\n    constexpr float epsilon = std::numeric_limits<float>::epsilon();\n    const float fixed_delta_seconds = settings.fixed_delta_seconds.get();\n    const float expected_delta_seconds = fixed_delta_seconds / static_cast<float>(num_ticks);\n    const float expected_delta_seconds_squared = expected_delta_seconds * expected_delta_seconds;\n    const float expected_delta_seconds_squared_sum = expected_delta_seconds_squared * num_ticks;\n    float delta_seconds_squared_sum = 0.0f;\n    for (int i = 0; i < num_ticks; ++i) {\n      const Snapshot &snapshot = _episode.Lock()->GetSnapshot(Tick(_episode.Lock()->GetGameTime() + local_timeout));\n      const float delta_seconds = static_cast<float>(snapshot.GetTimestamp().elapsed_seconds());\n      delta_seconds_squared_sum += delta_seconds * delta_seconds;\n    }\n    const float delta_seconds_squared_sum_error = abs(delta_seconds_squared_sum - expected_delta_seconds_squared_sum);\n    if (delta_seconds_squared_sum_error > epsilon) {\n      log_warning(\n          \"fixed delta time not correctly applied: expected delta time squared sum\",\n          expected_delta_seconds_squared_sum,\n          \"but got\",\n          delta_seconds_squared_sum,\n          \"with error\",\n          delta_seconds_squared_sum_error);\n    }\n  }\n\n  // Set the episode settings and return", "CodeBleu_score": 47.70474549916883}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  const float segmentLengthSquared = DistanceSquared2D(segmentStart, segmentEnd);\n  const float segmentLength = std::sqrt(segmentLengthSquared);\n\n  if (segmentLength == 0) {\n    return std::make_pair(0, Distance2D(segmentStart, point));\n  }\n\n  const float t = Clamp(Dot2D(point - segmentStart, segmentEnd - segmentStart) / segmentLengthSquared, 0.0f, 1.0f);\n  const float distanceAlongSegment = t * segmentLength;\n  const float distanceToPoint = Distance2D(segmentStart + t * (segmentEnd - segmentStart), point);\n\n  return std::make_pair(distanceAlongSegment, distanceToPoint);\n}", "CodeBleu_score": 51.59485232576839}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    // Calculate the squared length of the segment\n    float segmentLengthSquared = Math::DistanceSquared2D(start, end);\n    // If the segment length is zero, return zero and the distance from the point to one endpoint\n    if (segmentLengthSquared == 0) {\n        return std::make_pair(0, Math::Distance2D(point, start));\n    }\n    // Project the point onto the segment\n    float t = Math::Dot2D(point - start, end - start) / segmentLengthSquared;\n    // Clamp the projection to the segment\n    t = Math::Clamp(t, 0.0f, 1.0f);\n    // Calculate the distance along the segment and the distance from the projection to the point\n    float distanceAlongSegment = t * std::sqrt(segmentLengthSquared);\n    float distanceToPoint = Math::Distance2D(point, start + t * (end - start));\n    // Return the distance along the segment and the distance from the projection to the point\n    return std::make_pair(distanceAlongSegment, distanceToPoint);\n}", "CodeBleu_score": 40.62739725265499}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    float squaredLength = DistanceSquared2D(start, end);\n    float length = std::sqrt(squaredLength);\n\n    if (length == 0.0f) {\n        return std::make_pair(0.0f, Distance2D(start, point));\n    }\n\n    float t = Clamp(Dot2D(point - start, end - start) / squaredLength, 0.0f, 1.0f);\n    return std::make_pair(t * length, Distance2D(point, start + t * (end - start)));\n}", "CodeBleu_score": 47.399767900416066}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    DEBUG_ASSERT(vertices.size() >= 3);\n    const auto first_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (std::size_t i = 1; i < vertices.size() - 1; ++i) {\n        AddIndex(first_index);\n        AddIndex(first_index + i);\n        AddIndex(first_index + i + 1);\n    }\n}", "CodeBleu_score": 55.0558391357084}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    assert(vertices.size() >= 3);\n    const auto initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n        AddIndex(initial_index);\n        AddIndex(initial_index + i);\n        AddIndex(initial_index + i + 1);\n    }\n}", "CodeBleu_score": 52.7540542520215}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    DEBUG_ASSERT(vertices.size() >= 3);\n    const unsigned int first_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (unsigned int i = 0; i < vertices.size() - 2; i++) {\n        AddIndex(first_index);\n        AddIndex(first_index + i + 1);\n        AddIndex(first_index + i + 2);\n    }\n}", "CodeBleu_score": 53.95371590898685}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(message->GetSize() > 0u);\n    boost::asio::post(\n        _strand,\n        [weak = weak_from_this(), message]() {\n          if (auto self = weak.lock()) {\n            if (self->_socket.is_open()) {\n              self->_deadline.expires_from_now(boost::posix_time::seconds(10));\n              boost::asio::async_write(\n                  self->_socket,\n                  message->GetBufferSequence(),\n                  boost::asio::bind_executor(\n                      self->_strand,\n                      [weak, message](auto ec, auto) {\n                        if (auto self = weak.lock()) {\n                          self->_deadline.cancel();\n                          if (ec) {\n                            log_error(\"write error:\", ec.message());\n                            self->CloseNow();\n                          }\n                        }\n                      }));\n            }\n          }\n        });\n  }", "CodeBleu_score": 47.36257894492007}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t    DEBUG_ASSERT(message != nullptr);\n    DEBUG_ASSERT(!message->empty());\n    boost::asio::post(\n        self->_strand,\n        [=]() {\n            if (!self->_socket.is_open()) {\n                return;\n            }\n            self->_deadline.expires_from_now(boost::posix_time::seconds(1));\n            boost::asio::async_write(\n                self->_socket,\n                message->GetBufferSequence(),\n                boost::asio::bind_executor(\n                    self->_strand,\n                    [=](boost::system::error_code ec, std::size_t) {\n                        self->_deadline.cancel();\n                        if (ec) {\n                            log_error(\"error sending message: \", ec.message());\n                            self->CloseNow();\n                        }\n                    }));\n        });\n}", "CodeBleu_score": 44.932419365021524}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  boost::asio::post(\n      self->_strand,\n      [weak = weak_from_this(), message]() {\n        if (auto self = weak.lock()) {\n          if (self->_socket.is_open()) {\n            self->_deadline.expires_from_now(boost::posix_time::seconds(1));\n            boost::asio::async_write(\n                self->_socket,\n                message->GetBufferSequence(),\n                boost::asio::bind_executor(\n                    self->_strand,\n                    [weak, message](boost::system::error_code ec, std::size_t /*length*/) {\n                      if (auto self = weak.lock()) {\n                        self->_deadline.cancel();\n                        if (ec) {\n                          log_error(\n                              \"write error\",\n                              ec,\n                              self->_socket.remote_endpoint().address().to_string(),\n                              self->_socket.remote_endpoint().port(),\n                              ec.message());\n                          self->CloseNow();\n                        }\n                      }\n                    }));\n          }\n        }\n      });\n}", "CodeBleu_score": 42.13845944868094}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  _deadline.cancel();\n  if (!ec && _socket.is_open()) {\n    _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    _socket.close(ec);\n  }\n  _on_closed();\n  log_debug(\"session closed\");\n}", "CodeBleu_score": 48.91380666233491}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n    if (!ec && _socket.is_open()) {\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        _socket.close(ec);\n    }\n    _on_closed();\n    log_debug(\"session closed\");\n}", "CodeBleu_score": 50.5068269802329}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    _deadline.cancel();\n    if (ec && ec != boost::asio::error::operation_aborted)\n        log_debug() << \"Error during closing: \" << ec.message();\n    if (_socket.is_open()) {\n        _socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n        _socket.close();\n    }\n    _on_closed();\n    log_debug() << \"Session closed\";\n}", "CodeBleu_score": 54.903802422223514}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t    // Create a buffer from the message\n    Buffer buffer(std::string(\"Are you alive?\"));\n\n    // Log the sending action\n    log_info(\"Sending: %s\", buffer.data().c_str());\n\n    // Write the buffer to the next router with the command YOU_ALIVE\n    _router->WriteToNext(buffer, YOU_ALIVE);\n\n    // Wait for the response from the system\n    auto fut = _router->WaitForNext();\n    auto msg = fut.get();\n\n    // Log the response\n    log_info(\"Received: %s\", msg.c_str());\n}", "CodeBleu_score": 51.29026147396147}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t    std::string msg = \"Are you alive?\";\n    Buffer buffer(msg.c_str(), msg.size());\n    log_info(\"Sending: %s\", msg.c_str());\n    _router->WriteToNext(buffer, YOU_ALIVE);\n    auto fut = _router->ReadFromNext();\n    auto response = fut.get();\n    log_info(\"Response: %s\", response.buffer.data);\n}", "CodeBleu_score": 56.683970255251424}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t    // Create a buffer from the message \"Are you alive?\"\n    Buffer buffer = Buffer(\"Are you alive?\", 14);\n\n    // Log the sending action\n    log_info(\"Sending: %s\", buffer.data.c_str());\n\n    // Write the buffer to the next router with the command YOU_ALIVE\n    _router->WriteToNext(buffer, YOU_ALIVE);\n\n    // Wait for and log the response from the system\n    std::future<Buffer> fut = _router->WaitForNext(YOU_ALIVE);\n    Buffer msg = fut.get();\n    log_info(\"Received: %s\", msg.data.c_str());\n}", "CodeBleu_score": 50.120741070846975}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    bool found = false;\n    for (auto &server : _servers) {\n        if (server.second->IsSensorEnabled(sensor_id)) {\n            found = true;\n            std::vector<uint8_t> buffer;\n            buffer.resize(sizeof(stream_id));\n            memcpy(buffer.data(), &sensor_id, sizeof(stream_id));\n            auto fut = _router->WriteToOne(server.second->GetServerId(), Commands::ENABLE_ROS, buffer);\n            fut.get();\n            auto response = _router->ReadFromOne(server.second->GetServerId());\n            if (response.buffer.size() > 0) {\n                if (response.buffer.data()[0] == 1) {\n                    LOG_INFO << \"Sensor \" << sensor_id << \" enabled on server \" << server.second->GetServerId();\n                } else {\n                    LOG_ERROR << \"Failed to enable sensor \" << sensor_id << \" on server \" << server.second->GetServerId();\n                }\n            } else {\n                LOG_ERROR << \"Failed to enable sensor \" << sensor_id << \" on server \" << server.second->GetServerId();\n            }\n            break;\n        }\n    }\n    if (!found) {\n        LOG_ERROR << \"Sensor \" << sensor_id << \" not found on any server\";\n    }\n}", "CodeBleu_score": 48.45149085960338}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  // Check if the sensor is found on any server\n  auto found = _servers.find(sensor_id);\n  if (found != _servers.end()) {\n    // Create a buffer with the sensor ID\n    std::vector<uint8_t> buffer(sizeof(sensor_id));\n    memcpy(buffer.data(), &sensor_id, sizeof(sensor_id));\n\n    // Send an ENABLE_ROS command to the server using the router\n    auto fut = _router->WriteToOne(found->second, buffer, Commands::ENABLE_ROS);\n    fut.get();\n\n    // Wait for and process the server's response\n    auto response = _router->ReadFromOne(found->second);\n    if (!response.buffer.empty()) {\n      if (response.buffer[0] == static_cast<uint8_t>(Commands::ENABLE_ROS_ACK)) {\n        LOG_INFO(\"ROS enabled for sensor \" + std::to_string(sensor_id));\n      } else {\n        LOG_ERROR(\"Error enabling ROS for sensor \" + std::to_string(sensor_id));\n      }\n    } else {\n      LOG_ERROR(\"Error enabling ROS for sensor \" + std::to_string(sensor_id));\n    }\n  } else {\n    LOG_ERROR(\"Sensor \" + std::to_string(sensor_id) + \" not found on any server\");\n  }\n}", "CodeBleu_score": 56.01000310275379}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    auto fut = _router->WriteToOne(\n        [sensor_id](auto &buffer) {\n            buffer.data[0] = static_cast<uint8_t>(PrimaryCommand::ENABLE_ROS);\n            *reinterpret_cast<stream_id *>(&buffer.data[1]) = sensor_id;\n            buffer.size = 1 + sizeof(stream_id);\n        },\n        [sensor_id](auto &buffer) {\n            if (buffer.data[0] == static_cast<uint8_t>(PrimaryCommand::ENABLE_ROS)) {\n                if (buffer.size == 1 + sizeof(stream_id)) {\n                    auto server_sensor_id = *reinterpret_cast<stream_id *>(&buffer.data[1]);\n                    if (server_sensor_id == sensor_id) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        });\n    auto response = fut.get();\n    if (response.server_id != -1) {\n        log_info(\"Sensor %d enabled on server %d\", sensor_id, response.server_id);\n    } else {\n        log_error(\"Sensor %d not found on any server\", sensor_id);\n    }\n}", "CodeBleu_score": 46.79877463369079}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  // Check if the sensor is already activated\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    // Sensor is already activated, return existing token\n    log_debug(\"Sensor \" + std::to_string(sensor_id) + \" is already activated\");\n    return it->second.get_token();\n  }\n\n  // Sensor is not activated, enable it on a secondary server\n  auto server_id = _router->GetNextServer();\n  auto port = _router->GetNextPort();\n  auto stream_id = _router->GetNextStreamId();\n  auto token = _secondary_commands->SendGetToken(server_id, port, stream_id);\n\n  // Update the maps\n  _tokens[sensor_id] = TokenInfo(token, port, stream_id);\n  _ports[port] = sensor_id;\n  _stream_ids[stream_id] = sensor_id;\n\n  // Log the action\n  log_debug(\"Sensor \" + std::to_string(sensor_id) + \" is now activated on server \" + std::to_string(server_id) + \" with port \" + std::to_string(port) + \" and stream ID \" + std::to_string(stream_id));\n\n  return token;\n}", "CodeBleu_score": 58.96270776406985}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t    if (_tokens.find(sensor_id) != _tokens.end()) {\n        log_debug(\"Sensor \" + std::to_string(sensor_id) + \" already activated. Returning existing token.\");\n        return _tokens[sensor_id];\n    }\n\n    Server secondary_server = _router->GetNextServer();\n    token_type token = SendGetToken(secondary_server, sensor_id);\n    _tokens[sensor_id] = token;\n    _server_map[sensor_id] = secondary_server;\n    log_debug(\"Activated sensor \" + std::to_string(sensor_id) + \" on server \" + secondary_server.get_ip() + \":\" + std::to_string(secondary_server.get_port()));\n    return token;\n}", "CodeBleu_score": 51.740685896756034}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  if (_tokens.find(sensor_id) != _tokens.end()) {\n    log_debug(\"Sensor \" + std::to_string(sensor_id) + \" already activated\");\n    return _tokens.find(sensor_id)->second.get_token();\n  }\n\n  std::string secondary_ip = _router->GetNextServer();\n  log_debug(\"Sensor \" + std::to_string(sensor_id) + \" not activated, activating on \" + secondary_ip);\n  token_type token = SendGetToken(secondary_ip, sensor_id);\n  _tokens[sensor_id] = TokenInfo(token, secondary_ip, _router->GetPort(secondary_ip), sensor_id);\n  log_debug(\"Sensor \" + std::to_string(sensor_id) + \" activated on \" + secondary_ip);\n  return token;\n}", "CodeBleu_score": 48.00632500139199}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f;\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n\n  f.seekg(0, std::ios::end);\n  const size_t size = f.tellg();\n\n  std::vector<uint8_t> data(size);\n  f.seekg(0);\n  f.read(reinterpret_cast<char *>(data.data()), size);\n  return Load(data);\n}", "CodeBleu_score": 70.77248685967649}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f;\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n        return false;\n    }\n\n    f.seekg(0, std::ios::end);\n    int length = f.tellg();\n    f.seekg(0, std::ios::beg);\n    std::vector<uint8_t> data;\n    data.resize(length);\n    f.read(reinterpret_cast<char *>(&data[0]), length);\n    f.close();\n\n    return Load(data);\n}", "CodeBleu_score": 66.84939105344291}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f(filename, std::ios::binary);\n    if (!f.is_open()) {\n        return false;\n    }\n    std::vector<uint8_t> data((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());\n    f.close();\n    return Load(data);\n}", "CodeBleu_score": 65.15496445080645}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!_ready) {\n        return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    const auto walker_it = _mapped_walkers_id.find(id);\n    const auto vehicle_it = _mapped_vehicles_id.find(id);\n\n    if (walker_it != _mapped_walkers_id.end()) {\n        std::lock_guard<std::mutex> lock(_mutex);\n        _crowd->removeAgent(walker_it->second);\n        _walker_manager.RemoveWalker(id);\n        _mapped_walkers_id.erase(walker_it);\n        _mapped_by_index.erase(walker_it->second);\n        return true;\n    } else if (vehicle_it != _mapped_vehicles_id.end()) {\n        std::lock_guard<std::mutex> lock(_mutex);\n        _crowd->removeAgent(vehicle_it->second);\n        _vehicle_manager.RemoveVehicle(id);\n        _mapped_vehicles_id.erase(vehicle_it);\n        _mapped_by_index.erase(vehicle_it->second);\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 71.04235589723542}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!_is_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    std::lock_guard<std::mutex> lock(_crowd_mutex);\n\n    auto walker_it = _mapped_walkers_id.find(id);\n    if (walker_it != _mapped_walkers_id.end()) {\n      _crowd->removeAgent(walker_it->second);\n      _walker_manager.RemoveWalker(walker_it->second);\n      _mapped_walkers_id.erase(walker_it);\n      return true;\n    }\n\n    auto vehicle_it = _mapped_vehicles_id.find(id);\n    if (vehicle_it != _mapped_vehicles_id.end()) {\n      _crowd->removeAgent(vehicle_it->second);\n      _vehicle_manager.RemoveVehicle(vehicle_it->second);\n      _mapped_vehicles_id.erase(vehicle_it);\n      return true;\n    }\n\n    return false;\n  }", "CodeBleu_score": 67.47108588636426}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!_is_ready) {\n        return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    std::unique_lock<std::mutex> lock(_mutex);\n\n    auto walker_it = _mapped_walkers_id.find(id);\n    if (walker_it != _mapped_walkers_id.end()) {\n        _crowd->removeAgent(walker_it->second);\n        _walker_manager.RemoveWalker(id);\n        _mapped_walkers_id.erase(walker_it);\n        _mapped_by_index.erase(id);\n        return true;\n    }\n\n    auto vehicle_it = _mapped_vehicles_id.find(id);\n    if (vehicle_it != _mapped_vehicles_id.end()) {\n        _crowd->removeAgent(vehicle_it->second);\n        _vehicle_manager.RemoveVehicle(id);\n        _mapped_vehicles_id.erase(vehicle_it);\n        _mapped_by_index.erase(id);\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 69.70940868744982}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    std::set<int> mapped_vehicles;\n    for (auto& [id, vehicle] : vehicles_) {\n        mapped_vehicles.insert(id);\n    }\n    for (auto& vehicle : vehicles) {\n        if (vehicles_.find(vehicle.id) == vehicles_.end()) {\n            AddOrUpdateVehicle(vehicle);\n        } else {\n            vehicles_[vehicle.id].updated = true;\n        }\n    }\n    for (auto& id : mapped_vehicles) {\n        if (vehicles_[id].updated == false) {\n            RemoveVehicle(id);\n        }\n    }\n    return true;\n}", "CodeBleu_score": 52.47673370116366}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    std::set<int> current_vehicles;\n    for (auto& v : this->vehicles) {\n        current_vehicles.insert(v.first);\n    }\n\n    for (auto& v : vehicles) {\n        this->AddOrUpdateVehicle(v);\n        current_vehicles.erase(v.id);\n    }\n\n    for (auto& v : current_vehicles) {\n        this->RemoveVehicle(v);\n    }\n\n    return true;\n}", "CodeBleu_score": 57.13697785790687}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t    // Collect the IDs of currently mapped vehicles\n    std::set<int> mappedVehicles;\n    for (auto& pair : vehicles_) {\n        mappedVehicles.insert(pair.first);\n    }\n\n    // Add or update vehicles from the provided list\n    for (auto& vehicle : vehicles) {\n        if (vehicles_.count(vehicle.vehicleId) == 0) {\n            AddOrUpdateVehicle(vehicle);\n        } else {\n            vehicles_[vehicle.vehicleId].Update(vehicle);\n        }\n        mappedVehicles.erase(vehicle.vehicleId);\n    }\n\n    // Remove vehicles that are not updated\n    for (int vehicleId : mappedVehicles) {\n        vehicles_.erase(vehicleId);\n    }\n\n    return true;\n}", "CodeBleu_score": 46.395153910147}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  auto walker_id = _mapped_walkers_id.find(id);\n  if (walker_id != _mapped_walkers_id.end()) {\n    std::lock_guard<std::mutex> lock(_mutex);\n    cg::Location loc = walker_id->second->GetLocation();\n    float squared_distance = cg::Math::DistanceSquared(loc, direction);\n    return squared_distance < distance * distance && _crowd->hasVehicleNear(walker_id->second);\n  }\n\n  auto vehicle_id = _mapped_vehicles_id.find(id);\n  if (vehicle_id != _mapped_vehicles_id.end()) {\n    std::lock_guard<std::mutex> lock(_mutex);\n    cg::Location loc = vehicle_id->second->GetLocation();\n    float squared_distance = cg::Math::DistanceSquared(loc, direction);\n    return squared_distance < distance * distance && _crowd->hasVehicleNear(vehicle_id->second);\n  }\n\n  return false;\n}", "CodeBleu_score": 53.0382425028825}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t    if (_mapped_vehicles_id.find(id) != _mapped_vehicles_id.end()) {\n        std::lock_guard<std::mutex> lock(_mutex);\n        float squared_distance = distance * distance;\n        return _crowd->hasVehicleNear(id, squared_distance, direction);\n    }\n    if (_mapped_walkers_id.find(id) != _mapped_walkers_id.end()) {\n        std::lock_guard<std::mutex> lock(_mutex);\n        float squared_distance = distance * distance;\n        return _crowd->hasVehicleNear(id, squared_distance, direction);\n    }\n    return false;\n}", "CodeBleu_score": 50.89753538577726}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  // Search for the actor in the mapped walkers and vehicles.\n  auto walker_id = _mapped_walkers_id.find(id);\n  auto vehicle_id = _mapped_vehicles_id.find(id);\n  if (walker_id != _mapped_walkers_id.end()) {\n    // If found, enter a critical section.\n    std::lock_guard<std::mutex> lock(_mutex);\n    // Compute the squared distance.\n    float squared_distance = distance * distance;\n    // Use the crowd system to determine if a vehicle is nearby.\n    return _crowd->hasVehicleNear(walker_id->second, squared_distance, direction);\n  } else if (vehicle_id != _mapped_vehicles_id.end()) {\n    // If found, enter a critical section.\n    std::lock_guard<std::mutex> lock(_mutex);\n    // Compute the squared distance.\n    float squared_distance = distance * distance;\n    // Use the crowd system to determine if a vehicle is nearby.\n    return _crowd->hasVehicleNear(vehicle_id->second, squared_distance, direction);\n  }\n  // If the actor is not found, return false.\n  return false;\n}", "CodeBleu_score": 54.135878775663485}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  const auto &route_point = info.route_points[info.current_route_index];\n  WalkerEventVisitor visitor(\n    id,\n    info.current_route_index,\n    info.route_points.size(),\n    route_point.point,\n    route_point.event,\n    delta,\n    this\n  );\n  return boost::variant2::visit(visitor, route_point.event);\n}", "CodeBleu_score": 55.47524465190976}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  if (info.route.empty()) {\n    return EventResult::Failure;\n  }\n\n  const auto &current_route_point = info.route.front();\n  WalkerEventVisitor visitor(info, current_route_point, delta);\n  return boost::variant2::visit(visitor, current_route_point);\n}", "CodeBleu_score": 40.9444236091478}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  const auto &route = info.route;\n  const auto &current_route_point = route.route_points[info.current_route_point];\n  WalkerEventVisitor visitor(id, current_route_point, info.current_route_point, delta, info);\n  return boost::variant2::visit(visitor, current_route_point.event);\n}", "CodeBleu_score": 55.54337791821226}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node = xml.child(\"road\");\n       road_node;\n       road_node = road_node.next_sibling(\"road\")) {\n    const uint16_t road_id = road_node.attribute(\"id\").as_uint();\n    for (pugi::xml_node lane_section_node = road_node.child(\"lanes\").child(\"laneOffset\");\n         lane_section_node;\n         lane_section_node = lane_section_node.next_sibling(\"laneOffset\")) {\n      const double s = lane_section_node.attribute(\"s\").as_double();\n      const auto left_lane_node = lane_section_node.child(\"left\");\n      const auto center_lane_node = lane_section_node.child(\"center\");\n      const auto right_lane_node = lane_section_node.child(\"right\");\n      ParseLanes(left_lane_node, carla::road::Lane::LaneType::Left, road_id, s, map_builder);\n      ParseLanes(center_lane_node, carla::road::Lane::LaneType::Center, road_id, s, map_builder);\n      ParseLanes(right_lane_node, carla::road::Lane::LaneType::Right, road_id, s, map_builder);\n    }\n  }\n}", "CodeBleu_score": 56.52907943753684}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const uint16_t road_id = road_node.attribute(\"id\").as_uint();\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneOffset\")) {\n      const double s = lane_section_node.attribute(\"s\").as_double();\n      for (pugi::xml_node lane_node : lane_section_node.children()) {\n        const std::string lane_type = lane_node.name();\n        if (lane_type == \"left\") {\n          ParseLanes(lane_node, map_builder, road_id, s, carla::road::Lane::LaneType::Left);\n        } else if (lane_type == \"right\") {\n          ParseLanes(lane_node, map_builder, road_id, s, carla::road::Lane::LaneType::Right);\n        } else if (lane_type == \"center\") {\n          ParseLanes(lane_node, map_builder, road_id, s, carla::road::Lane::LaneType::Center);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 57.685971215149344}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node = xml.child(\"road\"); road_node; road_node = road_node.next_sibling(\"road\")) {\n    const uint32_t road_id = road_node.attribute(\"id\").as_uint();\n    for (pugi::xml_node lane_section_node = road_node.child(\"lanes\").child(\"laneSection\");\n        lane_section_node;\n        lane_section_node = lane_section_node.next_sibling(\"laneSection\")) {\n      const double s = lane_section_node.attribute(\"s\").as_double();\n      const pugi::xml_node left_node = lane_section_node.child(\"left\");\n      const pugi::xml_node center_node = lane_section_node.child(\"center\");\n      const pugi::xml_node right_node = lane_section_node.child(\"right\");\n      ParseLanes(left_node, road_id, s, map_builder, carla::road::Lane::LaneType::Driving);\n      ParseLanes(center_node, road_id, s, map_builder, carla::road::Lane::LaneType::Driving);\n      ParseLanes(right_node, road_id, s, map_builder, carla::road::Lane::LaneType::Driving);\n    }\n  }\n}", "CodeBleu_score": 60.64682044208586}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 71.10309940676105}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 71.10309940676105}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        // not sure what to do in this case.\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 71.10309940676105}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_count_++;\n        if (matched_count_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_count_--;\n        if (matched_count_ == 0) {\n            // Destroy the subscriber\n            _owner->DestroySubscriber();\n        }\n    } else {\n        // Log an error message\n        std::cerr << \"Error: invalid change in subscription count\" << std::endl;\n    }\n}", "CodeBleu_score": 62.478073301324265}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        m_matched++;\n        if (m_matched == 1) {\n            m_first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        m_matched--;\n        if (m_matched == 0) {\n            m_owner->DestroySubscriber();\n        }\n    } else {\n        // Log error\n        std::cerr << \"on_subscription_matched: invalid change: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 64.96770398205338}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        _matched++;\n        if (_matched == 1) {\n            _first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        _matched--;\n        if (_matched == 0) {\n            _owner->DestroySubscriber();\n        }\n    } else {\n        std::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: invalid change\"\n                  << std::endl;\n    }\n}", "CodeBleu_score": 64.08168115803502}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 97.01569280410635}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 97.02370031557412}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 97.01569280410635}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.49831474323292}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.95739996321375}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 94.30811008515623}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (tracker.target_set) {\n        return;\n    }\n\n    switch (msg.msgid) {\n    case MAVLINK_MSG_ID_ATTITUDE:\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n        break;\n    default:\n        return;\n    }\n\n    if (tracker.g.sysid_target != 0) {\n        return;\n    }\n\n    tracker.g.sysid_target = mavlink_msg_heartbeat_get_sysid(&msg);\n    tracker.gcs().request_datastream_position(tracker.g.sysid_target);\n    tracker.gcs().request_datastream_airpressure(tracker.g.sysid_target);\n    tracker.target_set = true;\n}", "CodeBleu_score": 47.46040337448152}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (tracker.g.sysid_target != 0) {\n        return;\n    }\n\n    mavlink_heartbeat_t packet;\n    mavlink_msg_heartbeat_decode(&msg, &packet);\n\n    if (packet.type != MAV_TYPE_GCS && packet.type != MAV_TYPE_ONBOARD_CONTROLLER && packet.type != MAV_TYPE_GIMBAL) {\n        return;\n    }\n\n    tracker.g.sysid_target = msg.sysid;\n    tracker.gcs().request_datastream_position(tracker.g.sysid_target);\n    tracker.gcs().request_datastream_airpressure(tracker.g.sysid_target);\n\n    tracker.g.target_set = true;\n}", "CodeBleu_score": 58.003192877061004}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // exit immediately if target has already been set\n    if (tracker.g.sysid_target.get() != 0) {\n        return;\n    }\n\n    mavlink_tracker_message_t packet;\n    mavlink_msg_tracker_decode(&msg, &packet);\n\n    // exit immediately if this is not a message that should be tracked\n    if (packet.type != MAV_TYPE_GCS &&\n        packet.type != MAV_TYPE_ONBOARD_CONTROLLER &&\n        packet.type != MAV_TYPE_GIMBAL) {\n        return;\n    }\n\n    // set target sysid and request data streams\n    tracker.g.sysid_target.set(packet.sysid);\n    tracker.gcs().request_datastream_position(tracker.g.sysid_target.get());\n    tracker.gcs().request_datastream_airpressure(tracker.g.sysid_target.get());\n\n    // flag that target has been set\n    tracker.g.sysid_target_set.set(true);\n}", "CodeBleu_score": 54.23502265812099}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        barometer.set_calibration_needed();\n    }\n    return result;\n}", "CodeBleu_score": 64.54935762665033}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        set_accel_cal_mask(3);\n    }\n    return result;\n}", "CodeBleu_score": 61.969598706282255}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        AP_Notify::flags.pre_arm_check_barometer = true;\n    }\n    return result;\n}", "CodeBleu_score": 66.91414124388041}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (is_zero(packet.param1))  {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 89.27238189767404}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0) {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 75.64613080313404}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (is_zero(packet.param1))  {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 89.27238189767404}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i = 0; i < num_gcs; i++) {\n        if (!HAVE_PAYLOAD_SPACE((mavlink_channel_t)i, DATA_STREAM)) {\n            continue;\n        }\n        mavlink_msg_request_data_stream_send(\n            (mavlink_channel_t)i,\n            sysid,\n            compid,\n            MAV_DATA_STREAM_POSITION,\n            MAVLINK_MSG_ID_GLOBAL_POSITION_INT,\n            streamRates[i].get_default_rate(),\n            1);\n    }\n}", "CodeBleu_score": 66.45194047975305}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs; i++) {\n        if (HAVE_PAYLOAD_SPACE((mavlink_channel_t)i, DATA_STREAM_POSITION)) {\n            mavlink_msg_request_data_stream_send(\n                (mavlink_channel_t)i,\n                sysid,\n                compid,\n                MAV_DATA_STREAM_POSITION,\n                MAV_DATA_STREAM_POSITION_MASK,\n                MAVLINK_MSG_ID_LOCAL_POSITION_NED,\n                stream_rate_position\n            );\n        }\n    }\n}", "CodeBleu_score": 72.33780338978339}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i = 0; i < num_gcs; i++) {\n        if (HAVE_PAYLOAD_SPACE((mavlink_channel_t)i, POSITION)) {\n            mavlink_msg_request_data_stream_send(\n                (mavlink_channel_t)i,\n                sysid,\n                compid,\n                MAV_DATA_STREAM_POSITION,\n                MAV_DATA_STREAM_POSITION_ALL_MESSAGES,\n                MAVLINK_MSG_ID_GLOBAL_POSITION_INT,\n                MAVLINK_MSG_ID_GLOBAL_POSITION_INT\n            );\n        }\n    }\n}", "CodeBleu_score": 67.95374118878563}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (is_zero(cos_pitch)) {\n        return false;\n    }\n    ef_pitch = atan2f(ahrs.sin_roll(), cos_pitch);\n    ef_yaw = atan2f(ahrs.sin_pitch() * ahrs.sin_yaw() + ahrs.cos_pitch() * ahrs.cos_yaw(), ahrs.cos_pitch() * ahrs.sin_yaw() - ahrs.sin_pitch() * ahrs.cos_yaw());\n    return true;\n}", "CodeBleu_score": 55.50070714336286}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (is_zero(cos_pitch)) {\n        return false;\n    }\n    ef_pitch = degrees(atan2f(ahrs.sin_roll(), cos_pitch));\n    ef_yaw = wrap_360(degrees(atan2f(-ahrs.sin_yaw(), ahrs.cos_yaw()*ahrs.cos_roll()/cos_pitch)));\n    return true;\n}", "CodeBleu_score": 56.40637078047573}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    if (is_zero(ahrs.cos_pitch())) {\n        return false;\n    }\n    ef_pitch = pitch * ahrs.cos_pitch() - yaw * ahrs.sin_pitch();\n    ef_yaw = pitch * ahrs.sin_pitch() + yaw * ahrs.cos_pitch();\n    return true;\n}", "CodeBleu_score": 70.76677416235788}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t    // Calculate target yaw and pitch in centidegrees\n    int32_t target_yaw_cd = wrap_180_cd(tracker.get_angle_yaw_cd());\n    int32_t target_pitch_cd = tracker.get_angle_pitch_cd();\n\n    // Check if the direction is reversed\n    int8_t yaw_direction = get_ef_yaw_direction();\n\n    // Compute angle error in centidegrees\n    int32_t angle_error_cd = calc_angle_error(target_yaw_cd, yaw_direction);\n\n    // Convert angle error from earth frame to body frame\n    int32_t angle_error_bf_cd = convert_ef_to_bf(angle_error_cd, target_pitch_cd);\n\n    // Update pitch servo if the target distance is valid or no minimum distance is set\n    if (tracker.get_target_distance_valid() || tracker.get_min_distance_cm() <= 0) {\n        tracker.update_pitch_servo(angle_error_bf_cd);\n    }\n\n    // Update yaw servo\n    tracker.update_yaw_servo(angle_error_cd);\n}", "CodeBleu_score": 32.821639667902915}, {"code": "void Mode::update_auto(void){\n\t  // calculate target yaw and pitch in centidegrees\n  int32_t target_yaw = wrap_180_cd(nav_status.bearing_cd);\n  int32_t target_pitch = nav_status.altitude_error_cm * 100.0f;\n\n  // check if direction is reversed\n  if (reversed) {\n    target_yaw = wrap_180_cd(target_yaw + 18000);\n    target_pitch = -target_pitch;\n  }\n\n  // compute angle error\n  int32_t yaw_error = target_yaw - ahrs.yaw_sensor;\n  int32_t pitch_error = target_pitch - ahrs.pitch_sensor;\n\n  // convert errors from earth frame to body frame\n  int32_t yaw_error_bf, pitch_error_bf;\n  convert_ef_to_bf(yaw_error, pitch_error, yaw_error_bf, pitch_error_bf);\n\n  // update pitch and yaw servos if target distance is valid or no minimum distance is set\n  if (nav_status.target_distance_valid || (params.wp_navalt_min == 0)) {\n    tracker.update_yaw_servo(yaw_error_bf);\n    tracker.update_pitch_servo(pitch_error_bf);\n  }\n}", "CodeBleu_score": 38.18886192217346}, {"code": "void Mode::update_auto(void){\n\t    // calculate yaw and pitch in centidegrees\n    float yaw_cd = wrap_180_cd(tracker.get_yaw_angle_cd());\n    float pitch_cd = tracker.get_pitch_angle_cd();\n\n    // check if direction is reversed\n    int8_t yaw_dir = get_ef_yaw_direction();\n\n    // compute angle error\n    float yaw_error_cd = calc_angle_error(yaw_cd, tracker.get_yaw_target_cd(), yaw_dir);\n    float pitch_error_cd = calc_angle_error(pitch_cd, tracker.get_pitch_target_cd(), 1);\n\n    // convert errors from earth frame to body frame\n    convert_ef_to_bf(yaw_error_cd, pitch_error_cd);\n\n    // update pitch and yaw servos\n    if (tracker.target_distance_valid() || tracker.get_min_distance_cm() == 0) {\n        tracker.update_pitch_servo(pitch_error_cd);\n        tracker.update_yaw_servo(yaw_error_cd);\n    }\n}", "CodeBleu_score": 36.97049795220946}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t    gps.update();\n\n    // Check if the last message time has changed\n    if (gps.last_message_time_ms() != last_message_time_ms) {\n        last_message_time_ms = gps.last_message_time_ms();\n        if (gps.status() >= 3) {\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n                if (ground_start_countdown == 0) {\n                    if (gps.location.isValid()) {\n                        set_home();\n                    } else {\n                        ground_start_countdown = 10;\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 49.34213384811631}, {"code": "void Tracker::update_GPS(void){\n\t    gps.update();\n    if (gps.last_message_time_ms() != last_gps_message_time_ms) {\n        last_gps_message_time_ms = gps.last_message_time_ms();\n        if (gps.status() >= 3) {\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n                if (ground_start_countdown == 0) {\n                    if (gps.location.is_valid()) {\n                        set_home();\n                    } else {\n                        ground_start_countdown = GROUND_START_COUNTDOWN;\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 46.70309608830063}, {"code": "void Tracker::update_GPS(void){\n\t    gps.update();\n    if (gps.last_message_time_ms() != last_gps_message_time_ms) {\n        last_gps_message_time_ms = gps.last_message_time_ms();\n        if (gps.status() >= 3) {\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n            if (ground_start_countdown == 1) {\n                if (gps.location.is_valid()) {\n                    set_home();\n                } else {\n                    ground_start_countdown = 10;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 49.20262500260374}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch < 0) {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 1800);\n    } else {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 1200);\n    }\n}", "CodeBleu_score": 21.35393736392585}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t  // set servo to 100% if pitch is above 0 degrees\n  if (pitch > 0) {\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch_onoff, 100);\n  } else {\n    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch_onoff, 0);\n  }\n}", "CodeBleu_score": 21.034476110099174}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch < 0) {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 1000);\n    } else {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 1500);\n    }\n}", "CodeBleu_score": 21.376229936595543}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // perform checks common to all vehicle types\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // exit immediately if we are not arming\n    if (arm_state != ArmState::ARMING) {\n        return true;\n    }\n\n    // check baro reference\n    if ((checks_to_perform & ARMING_CHECK_ALL) ||\n        (checks_to_perform & ARMING_CHECK_BARO)) {\n\n        // check baro vs inav alt\n        if (fabsf(inertial_nav.get_position_z_up_cm() - baro_alt) > ARMING_MAX_BARO_ALT_DISPARITY_CM) {\n            check_failed(ARMING_CHECK_BARO);\n            if (display_failure) {\n                gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: Check failed: Baro altitude too far from EKF altitude\");\n            }\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 43.9398945248616}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (checks_to_perform == ARMING_CHECK_ALL ||\n        checks_to_perform == ARMING_CHECK_BARO) {\n        if (copter.ap.home_state != HOME_UNSET) {\n            // check home position is set\n            if (!AP::ahrs().home_is_set()) {\n                check_failed(display_failure, \"Home position not set\");\n                return false;\n            }\n\n            // check home position is closer than 100m to EKF origin\n            if (copter.ahrs.get_home().distance_to(inertial_nav.get_position()) > 100.0f) {\n                check_failed(display_failure, \"Home position too far from EKF origin\");\n                return false;\n            }\n\n            // check home position is within 100m of vehicle\n            if (copter.current_loc.distance_to(copter.ahrs.get_home()) > 100.0f) {\n                check_failed(display_failure, \"Home position too far from vehicle\");\n                return false;\n            }\n        }\n\n        // check WP_SPEED is zero when in RTL\n        if (copter.mode_rtl.state() == RTL_Land && copter.wp_nav.get_default_speed() > 0) {\n            check_failed(display_failure, \"RTL WP_SPEED too high\");\n            return false;\n        }\n\n        // check inertial nav has started and is not in failsafe and gps checks are enabled\n        if (copter.g.fs_gcs_enabled &&\n            (copter.failsafe.radio || copter.failsafe.gcs || copter.failsafe.ekf) &&\n            copter.g.fs_ekf_thresh > 0) {\n            check_failed(display_failure, \"Pre-arm gps checks disabled with EKF failsafe\");\n            return false;\n       ", "CodeBleu_score": 45.64689644051057}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call parent class checks\n    bool ret = AP_Arming::barometer_checks(display_failure);\n\n    if (!ret) {\n        return ret;\n    }\n\n    // check baro reference is ok\n    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_BARO)) {\n        if (copter.ap.pre_arm_rc_check) {\n            // check baro vs inertial nav altitude\n            if (fabsf(copter.inertial_nav.get_position_z_up_cm() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM) {\n                check_failed(ARMING_CHECK_BARO);\n                if (display_failure) {\n                    gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: Altitude disparity\");\n                }\n                return false;\n            }\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 59.97195505347723}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == AP_NavEKF_Source::SourceZ::SOURCE_Z_RANGEFINDER) {\n        return false;\n    }\n    if (copter.wp_nav->get_terrain_source() == AP_NavEKF_Source::SourceZ::SOURCE_Z_TERRAIN &&\n        copter.mode_rtl.get_alt_type() == ModeRTL::AltType::TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 85.98706786228071}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if rangefinder is used for terrain then no terrain database is required\n    if (copter.wp_nav->get_terrain_source() == AC_WPNav::TerrainSourceType::TERRAIN_FROM_RANGEFINDER) {\n        return false;\n    }\n\n    // if terrain database is used for terrain and RTL alt type is terrain, then a terrain database is required\n    if (copter.wp_nav->get_terrain_source() == AC_WPNav::TerrainSourceType::TERRAIN_FROM_TERRAINDATABASE &&\n        copter.mode_rtl.get_alt_type() == ModeRTL::AltType::TERRAIN) {\n        return true;\n    }\n\n    // defer to base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 89.77512892352769}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.wp_nav->get_terrain_source() == AP_Terrain::TerrainSourceType::TERRAIN_FROM_RANGEFINDER) {\n        return false;\n    }\n    if (copter.wp_nav->get_terrain_source() == AP_Terrain::TerrainSourceType::TERRAIN_FROM_TERRAINDATABASE && copter.mode_rtl.get_alt_type() == ModeRTL::AltType::TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 88.16785608196383}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    // run low level rate controllers that use imu data\n    attitude_control->set_dt(scheduler.get_last_loop_time_s());\n    pos_control->set_dt(scheduler.get_last_loop_time_s());\n    motors->set_dt(scheduler.get_last_loop_time_s());\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 46.30037086006175}, {"code": "void Copter::run_rate_controller(){\n\t    // call attitude controller\n    attitude_control->set_dt(AP::scheduler().get_last_loop_time_s());\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 29.853219376200713}, {"code": "void Copter::run_rate_controller(){\n\t    // set the loop time for attitude, position, and motor controllers\n    // this is used to set the dt value for the attitude controllers\n    // this is also used to set the dt value for the motors\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used to set the dt value for the position controllers\n    // this is also used", "CodeBleu_score": 3.379235655852661}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    if (new_loc.same_loc_as(old_loc)) {\n        return false;\n    }\n    if (new_loc.get_alt_frame() != old_loc.get_alt_frame()) {\n        return false;\n    }\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 57.39456884654306}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // get next waypoint location\n    Location next_wp;\n    if (!flightmode->get_wp(next_wp)) {\n        return false;\n    }\n\n    // check if old location matches next waypoint\n    if (!old_loc.same_loc_as(next_wp)) {\n        return false;\n    }\n\n    // check if altitude frames match\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set new location as target\n    set_target_location(new_loc);\n\n    return true;\n}", "CodeBleu_score": 71.231644062004}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // retrieve the next waypoint location\n    const Location &next_loc = flightmode->get_wp();\n\n    // check if the old location matches this waypoint\n    if (!old_loc.same_loc_as(next_loc)) {\n        return false;\n    }\n\n    // check if the altitude frames of the old and new locations are the same\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set the new location as the target\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 69.72723176208993}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // switch flight mode\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode->mode_number() == mode) {\n        // return to flight mode switch if already in the correct mode\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 69.34280080899627}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // engage mode (if we are currently stabilising or acro)\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else {\n        bool mode_change_desired = false;\n        if (copter.flightmode->mode_number() == mode) {\n            // the user wants the mode to be turned off\n            mode_change_desired = true;\n        } else if (copter.flightmode->mode_number() == Mode::Number::LOITER &&\n                   mode == Mode::Number::ALT_HOLD) {\n            // user wants to go to Loiter from AltHold, which is sent\n            // via the Throttle failsafe\n            mode_change_desired = true;\n        }\n\n        if (mode_change_desired) {\n            // the user wants the mode to be turned off\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 63.76017014414218}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode->mode_number() == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 69.34280080899627}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // get_control_in returns the control input of the roll and pitch channels\n    channel_roll->get_control_in()\n    channel_pitch->get_control_in()\n    // ToRad converts the control input to radians\n    ToRad(channel_roll->get_control_in())\n    ToRad(channel_pitch->get_control_in())\n    // add_trim adds the trim values to the AHRS trim\n    ahrs.add_trim(ToRad(channel_roll->get_control_in()), ToRad(channel_pitch->get_control_in()));\n    // LOGGER_WRITE_EVENT logs the event\n    LOGGER_WRITE_EVENT(LogEvent::SAVE_TRIM);\n    // gcs().send_text sends a confirmation message with MAV_SEVERITY_INFO\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 58.65947664063149}, {"code": "void Copter::save_trim(){\n\t    // get roll and pitch control inputs in radians\n    float roll_in = channel_roll->get_control_in() * ToRad;\n    float pitch_in = channel_pitch->get_control_in() * ToRad;\n\n    // add trim values to AHRS\n    ahrs.add_trim(roll_in, pitch_in);\n\n    // log event and send confirmation message\n    Log_Write_Event(DATA_SAVEWP_MSG);\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 60.2839994483682}, {"code": "void Copter::save_trim(){\n\t    ahrs.add_trim(channel_roll->get_control_in() * ToRad(4500.0f), channel_pitch->get_control_in() * ToRad(4500.0f));\n    Log_Write_Event(DATA_SAVEWP_MSG);\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 36.504603918468206}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    const Vector3f& vel = copter.inertial_nav.get_velocity_neu_cms();\n    float speed_sq = vel.xy().length_squared();\n    if (copter.position_ok() && (speed_sq > MIN_SPEED_SQUARED)) {\n        look_ahead_yaw = atan2f(-vel.y, -vel.x);\n    }\n    return look_ahead_yaw;\n}", "CodeBleu_score": 66.47231617354171}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // Get the copter's velocity\n    const Vector3f& vel = copter.inertial_nav.get_velocity_neu_cms();\n\n    // Calculate the speed squared\n    const float speed_sq = vel.xy().length_squared();\n\n    // Check if the copter's position is valid and the speed exceeds a minimum threshold\n    if (copter.position_ok() && (speed_sq > MIN_SPEED_SQ)) {\n        // Update the look-ahead yaw angle using the arctangent of the velocity components\n        look_ahead_yaw = atan2f(-vel.y, -vel.x);\n    }\n\n    // Return the computed look-ahead yaw angle\n    return look_ahead_yaw;\n}", "CodeBleu_score": 70.62585813811299}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // Get the copter's velocity\n    const Vector3f& vel = copter.inertial_nav.get_velocity_neu_cms();\n\n    // Calculate the speed squared\n    const float speed_sq = vel.xy().length_squared();\n\n    // Check if the copter's position is valid and the speed exceeds a minimum threshold\n    if (copter.position_ok() && (speed_sq > MIN_SPEED_SQ)) {\n        // Update the look-ahead yaw angle using the arctangent of the velocity components\n        look_ahead_yaw = atan2f(-vel.y, -vel.x);\n    }\n\n    // Return the computed look-ahead yaw angle\n    return look_ahead_yaw;\n}", "CodeBleu_score": 70.62585813811299}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        if (plane.rudder_arm_disarm == 0) {\n            check_failed(display_failure, \"Rudder arming disabled\");\n            return false;\n        }\n        if (!is_zero(plane.get_throttle_input())) {\n            check_failed(display_failure, \"Non-zero throttle\");\n            return false;\n        }\n    }\n\n    if (method == AP_Arming::Method::MAVLINK || method == AP_Arming::Method::RUDDER) {\n        if (hal.util->was_watchdog_armed()) {\n            // if we've already armed then skip the checks, except if we're\n            // arming via MAVLink\n            return true;\n        }\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 68.82456688461626}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        if (plane.get_rudder_arming_type() == AP_Arming::RudderArmingType::ARMING_DISABLED) {\n            return false;\n        }\n\n        if (!is_zero(plane.get_throttle_input())) {\n            check_failed(ARMING_CHECK_RC, display_failure, \"Throttle not zero\");\n            return false;\n        }\n\n        if (hal.util->was_watchdog_armed()) {\n            // if we've already been armed, return true so that arming\n            // won't be stopped\n            return true;\n        }\n\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 66.7665934428427}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        if (rudder_arming_disabled()) {\n            return false;\n        }\n        if (!is_zero(get_rudder_arming_type()) && !plane.get_throttle_input()) {\n            return false;\n        }\n    }\n\n    if (hal.util->was_watchdog_armed()) {\n        // don't allow arming if we were armed with the watchdog:\n        return false;\n    }\n\n    if (method == AP_Arming::Method::AUTO) {\n        // also disallow arming via AUTO if we are on the ground\n        // the user must pull the safety switch to arm in this case\n        if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {\n            const char *failmsg = \"Disarm switch not on - Arming failed\";\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"%s\", failmsg);\n            arming.set_failure_reason(failmsg);\n            return false;\n        }\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 65.97908475444956}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    plane.update_home();\n\n    // update current location\n    plane.update_current_loc();\n\n    // set arming flag\n    plane.set_armed(true);\n\n    // set delay arming flag\n    plane.set_delay_arming(true);\n\n    // send arming status text\n    send_arm_disarm_statustext();\n\n    // set home location in AHRS\n    plane.ahrs.set_home(plane.home);\n\n    return true;\n}", "CodeBleu_score": 67.85382118958395}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!_require) {\n        return true;\n    }\n    if (method == AP_Arming::Method::AUTO) {\n        // try to do direct arming\n        if (arm_direct(method, do_arming_checks)) {\n            return true;\n        }\n        // try to do arming via rc switch\n        return arm_rc_switch(method, do_arming_checks);\n    }\n    // try to do arming via rc switch\n    if (arm_rc_switch(method, do_arming_checks)) {\n        return true;\n    }\n    // try to do direct arming\n    return arm_direct(method, do_arming_checks);\n}", "CodeBleu_score": 42.172378276661945}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!_require_positive_throttle) {\n        _require_positive_throttle = true;\n        gcs().send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n    }\n\n    // check if arming is disabled\n    if (method == AP_Arming::Method::MAVLINK) {\n        if (plane.g.arming_check == AP_Arming::ARMING_CHECK_NONE) {\n            plane.set_throttle_and_failsafe(0.0f);\n            return true;\n        }\n    }\n\n    // ensure throttle is above zero\n    if (!plane.throttle_allows_arming()) {\n        gcs().send_text(MAV_SEVERITY_INFO, \"Disarmed with throttle low\");\n        return false;\n    }\n\n    // check arming method is allowed\n    if (method == AP_Arming::Method::MAVLINK && plane.g.arming_check != AP_Arming::ARMING_CHECK_ALL) {\n        gcs().send_text(MAV_SEVERITY_INFO, \"Arming method MAVLINK not allowed\");\n        return false;\n    }\n\n    // check throttle is not too low\n    if ((plane.g.arming_check == AP_Arming::ARMING_CHECK_ALL) &&\n        (plane.channel_throttle->get_radio_min() > 1200)) {\n        gcs().send_text(MAV_SEVERITY_INFO, \"Disarmed with throttle low\");\n        return false;\n    }\n\n    // check if arming checks are disabled\n    if (do_arming_checks == false) {\n        plane.set_throttle_and_failsafe(0.0f);\n        return true;\n    }\n\n    // check if flight mode requires GPS\n    bool gps_required = false;\n    if (plane.flight_mode == &plane.mode_auto) {\n        gps_required = ((AP_Mission::Mission_Command&)plane.mission.", "CodeBleu_score": 48.75219025821658}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (armed) {\n        return true;\n    }\n\n    if (!check_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm function not configured\");\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 72.88482730008731}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // if pre arm checks are disabled run a minimal check to prevent disarming\n    // while in pre-arm checks it could result in a crash\n    if (checks_to_perform == ARMING_CHECK_NONE) {\n        return mandatory_checks();\n    }\n\n    if (!check_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm not configured\");\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 64.77171992590911}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (armed) {\n        return true;\n    }\n\n    if (!has_disarm_function) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm function not configured\");\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.03123974373867}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw() - y * ahrs.sin_yaw();\n    float ne_y = x * ahrs.sin_yaw() + y * ahrs.cos_yaw();\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 84.29194785321683}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * ahrs.cos_yaw() - y * ahrs.sin_yaw();\n    float ne_y = x * ahrs.sin_yaw() + y * ahrs.cos_yaw();\n\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 84.29194785321683}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    // Calculate the new coordinates in the North-East frame\n    float ne_x = x * ahrs.cos_yaw - y * ahrs.sin_yaw;\n    float ne_y = x * ahrs.sin_yaw + y * ahrs.cos_yaw;\n\n    // Update the original coordinates with the new values\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 68.60048240477681}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // sanity check location\n    if (!sub.ap.auto_yaw) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // param1 : target angle [0-360]\n    // param2 : speed during change [deg per second]\n    // param3 : direction (-1:ccw, +1:cw)\n    // param4 : relative offset (1) or absolute angle (0)\n\n    // get base_rc from subsystem\n    uint16_t bfs_rc = sub.ap.angle_max;\n\n    // use yaw_slew_time from subsystem if set\n    float yaw_change_max_rate = sub.ap.angle_max;\n\n    // ensure we are in angle mode\n    sub.flightmode->auto_yaw.set_mode(AUTO_YAW_HOLD);\n\n    // convert p1 from centi-degrees to degrees\n    float target_angle_cd = packet.param1 * 100.0f;\n\n    // if we are setting an absolute angle\n    if (packet.param4 == MAV_MOUNT_MODE_MAVLINK_TARGETING) {\n        // constrain to 0-360\n        target_angle_cd = wrap_360_cd(target_angle_cd);\n\n        // set target angle for auto mode\n        sub.flightmode->auto_yaw.set_fixed_yaw(\n            target_angle_cd * 0.01f,\n            0.0f,\n            0,\n            0\n        );\n\n        // log target\n        AP::logger().Write_Event(LogEvent::SUB_SET_YAW_ANGLE,\n                                 DataFlash_Class::PACKET_SUBSCRIPTION_YAW,\n                                 target_angle_cd);\n\n        // return success\n        return MAV_RESULT_ACCEPTED;\n    }\n\n    // relative offset\n    if (is_zero(packet.param4)) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // get current yaw target\n    float current_angle_cd", "CodeBleu_score": 33.22877512285011}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // convert to radians\n    float angle_deg = packet.param1;\n    float angle_rad = radians(angle_deg);\n\n    // a negative param4 means reverse\n    float direction = is_negative(packet.param4) ? -1.0f : 1.0f;\n\n    // set yaw mode\n    sub.set_auto_yaw_look_at_heading(angle_rad, direction, 0, sub.g.rc_speed);\n\n    // return success\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 29.4196120139521}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // param1 : target angle [0-360]\n    // param2 : speed during change [deg per second]\n    // param3 : direction (-1:ccw, +1:cw)\n    // param4 : relative offset (1) or absolute angle (0)\n\n    // exit immediately if vehicle is not in Guided mode\n    if (sub.control_mode != GUIDED) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // check param1\n    if (packet.param1 < 0.0f || packet.param1 > 360.0f) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // send command\n    sub.mode_auto.mode_auto_set_yaw(packet.param1,\n                                    packet.param2,\n                                    (MAV_MOUNT_MODE) packet.param3,\n                                    (MAV_MOUNT_MODE) packet.param4);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 48.19824215464122}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode != AUTO && sub.control_mode != GUIDED) {\n        return 0;\n    }\n    return wrap_360_cd(sub.wp_nav.get_wp_bearing_to_destination()) / 2;\n}", "CodeBleu_score": 62.06239150494079}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode == AUTO || sub.control_mode == GUIDED) {\n        return wrap_360_cd(sub.wp_nav.get_wp_bearing_to_destination()) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 72.11376888999521}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (sub.control_mode == AUTO || sub.control_mode == GUIDED) {\n        return wrap_360_cd(sub.wp_nav.get_wp_bearing_to_destination() / 2);\n    }\n    return 0;\n}", "CodeBleu_score": 64.87830026410164}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(MASK_LOG_ANY),\n            time_us : AP_HAL::micros64(),\n            id : (uint16_t)id,\n            value : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 86.80067070931702}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (!should_log(MASK_LOG_ANY)) {\n        return;\n    }\n\n    uint64_t time_us = AP_HAL::micros64();\n\n    struct PACKED log_Data_Int {\n        LOG_PACKET_HEADER;\n        uint64_t time_us;\n        uint8_t id;\n        int32_t data_value;\n    };\n\n    struct log_Data_Int pkt = {\n        LOG_PACKET_HEADER_INIT(LOG_DATA_INT_MSG),\n        time_us   : time_us,\n        id        : (uint8_t)id,\n        data_value: value\n    };\n\n    logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n}", "CodeBleu_score": 66.18102757725724}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us : AP_HAL::micros64(),\n            id      : (uint8_t)id,\n            data    : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}", "CodeBleu_score": 96.08159847785012}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if the home is not set, set it to the current location from EKF\n    if (motors.armed()) {\n        if (!set_home_to_current_location_inflight()) {\n            // ignore failure\n        }\n    } else {\n        // try to set EKF home if not already set\n        if (!ahrs.set_home_to_current_location(false)) {\n            // ignore failure\n        }\n    }\n}", "CodeBleu_score": 54.56826745542326}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if we are not armed, then we can't set the home location\n    if (!motors.armed()) {\n        // try to set home using EKF if we are not armed\n        if (ahrs.get_position(current_loc)) {\n            set_home_to_current_location_inflight();\n        }\n        return;\n    }\n\n    // set home to current location if disarmed\n    set_home_to_current_location();\n}", "CodeBleu_score": 44.92651000674107}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n        return;\n    }\n\n    // if disarmed try to set home to EKF origin\n    if (!set_home_to_current_location()) {\n        // ignore failure\n    }\n}", "CodeBleu_score": 51.73351567612332}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t    if (!motors.armed()) {\n        // Motors should be Stopped\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN);\n        // Attempting to Land\n        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n    motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    float target_roll, target_pitch, target_yaw;\n    get_pilot_desired_lean_angles(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, attitude_control->get_althold_lean_angle_max());\n\n    // get pilot's desired yaw rate\n    target_yaw = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // get pilot desired climb rate\n    float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in());\n\n    // get pilot's desired forward throttle\n    float target_forward_thrust = get_pilot_desired_forward_thrust();\n\n    // get pilot's desired lateral throttle\n    float target_lateral_thrust = get_pilot_desired_lateral_thrust();\n\n    // convert pilot input to body frame rates\n    float target_roll_rate, target_pitch_rate, target_yaw_rate;\n    get_pilot_desired_angle_rates(target_roll, target_pitch, target_yaw, target_roll_rate, target_pitch_rate, target_yaw_rate);\n\n    // run attitude controller\n    attitude_control->input_rate_bf", "CodeBleu_score": 63.43522722977916}, {"code": "void ModeAcro::run(){\n\t    // convert pilot input to lean angles\n    float target_roll, target_pitch, target_yaw;\n    get_pilot_desired_lean_angles(target_roll, target_pitch, target_yaw, attitude_control->get_althold_lean_angle_max());\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input());\n\n    // get pilot desired climb rate\n    float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->norm_input());\n\n    // Acro Mode controls:\n    // - roll, pitch from pilot\n    // - yaw rate from pilot\n    // - climb rate from pilot\n\n    // run attitude controller\n    if (motors.armed()) {\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n        // convert pilot input to body-frame rates\n        // convert pilot input to body-frame rates\n        float target_roll_rate = get_pilot_desired_angle_rates(channel_roll->norm_input(), target_roll, g.acro_rp_expo);\n        float target_pitch_rate = get_pilot_desired_angle_rates(channel_pitch->norm_input(), target_pitch, g.acro_rp_expo);\n\n        // get attitude targets\n        const Vector3f att_target = attitude_control->input_euler_angle_roll_pitch_yaw(target_roll, target_pitch, target_yaw, true);\n\n        // run attitude controller\n        attitude_control->input_rate_bf_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate);\n        attitude_control->rate_controller_run();\n        attitude_control->attitude_euler_rate_to_ang_vel(target_roll_rate, target_pitch_", "CodeBleu_score": 59.560988189300765}, {"code": "void ModeAcro::run(){\n\t    // convert pilot input to lean angles\n    float target_roll, target_pitch, target_yaw;\n    get_pilot_desired_lean_angles(target_roll, target_pitch, target_yaw, attitude_control->get_althold_lean_angle_max());\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input());\n\n    // get pilot desired climb rate\n    float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->norm_input());\n\n    // Acro Mode controls rate roll, pitch, yaw\n    target_roll = target_roll * g.acro_roll_rate;\n    target_pitch = target_pitch * g.acro_pitch_rate;\n\n    // get avoidance adjusted climb rate\n    target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to body-frame rates\n    get_pilot_desired_angle_rates(target_roll, target_pitch, target_yaw_rate, target_climb_rate);\n\n    // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yaw_rate);\n\n    // output pilot's throttle without angle boost\n    attitude_control->set_throttle_out(channel_throttle->norm_input(), false, g.throttle_filt);\n\n    // set forward and lateral outputs\n    motors->set_lateral(channel_lateral->norm_input());\n    motors->set_forward(channel_forward->norm_input());\n}", "CodeBleu_score": 60.92675394529128}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set guided_mode to position controller\n    guided_mode = SubMode::GUIDED_POS;\n\n    // initialise waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // set the destination to be the stopping point\n    Vector3f stopping_point;\n    sub.wp_nav.get_wp_stopping_point(stopping_point);\n    sub.wp_nav.set_wp_destination(stopping_point, false);\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 81.67372661247929}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set guided_mode to position control mode\n    guided_mode = SubMode::POSITION;\n\n    // initialise wpnav\n    sub.wp_nav.wp_and_spline_init();\n\n    // initialise guided start time and position\n    guided_start_time = AP_HAL::millis();\n    guided_start_pos = inertial_nav.get_position();\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 30.04869035798633}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set guided_mode to position controller\n    guided_mode = SubMode::GUIDED_POS;\n\n    // initialise waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n\n    // set the stopping point as the destination\n    Vector3f stopping_point;\n    sub.wp_nav.get_wp_stopping_point(stopping_point);\n    sub.wp_nav.set_wp_destination(stopping_point, false);\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 81.67372661247929}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\n    // set vertical speed and acceleration\n    if (!copter.position_control->is_active_z()) {\n        copter.position_control->set_max_speed_accel_z(-copter.get_pilot_speed_dn(), copter.wp_nav->get_default_speed_up(), copter.wp_nav->get_default_speed_down(), copter.wp_nav->get_accel_z());\n    }\n\n    // initialise the vertical position controller\n    if (!copter.position_control->is_active_z()) {\n        copter.position_control->init_z_controller();\n    }\n\n    // initialise the lateral position controller\n    copter.pos_control->init_xy_controller();\n\n    // set vertical speed and acceleration\n    copter.pos_control->set_max_speed_accel_xy(copter.wp_nav->get_default_speed_xy(), copter.wp_nav->get_wp_acceleration());\n    copter.pos_control->set_correction_speed_accel_xy(copter.wp_nav->get_default_speed_xy(), copter.wp_nav->get_wp_acceleration());\n\n    // set auto yaw mode\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 35.34231928952771}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    guided_vel_z_pilot = g.pilot_velocity_z_max;\n    guided_vel_xy_pilot = g.pilot_velocity_xy_max;\n    guided_accel_z_pilot = g.pilot_velocity_z_accel_max;\n    guided_accel_xy_pilot = g.pilot_velocity_xy_accel_max;\n    guided_vel_z_cms = g.pilot_velocity_z_max * 100;\n    guided_vel_xy_cms = g.pilot_velocity_xy_max * 100;\n    guided_accel_z_cms = g.pilot_velocity_z_accel_max * 100;\n    guided_accel_xy_cms = g.pilot_velocity_xy_accel_max * 100;\n\n    position_control->init_xy_controller();\n    position_control->set_max_speed_accel_z(guided_vel_z_cms, guided_accel_z_cms);\n    position_control->init_z_controller();\n    position_control->set_correction_speed_accel_z(guided_vel_z_cms, guided_accel_z_cms);\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n\n    sub.get_pilot_desired_velocity_accel_z(guided_vel_z_cms, guided_accel_z_cms);\n    sub.get_pilot_desired_velocity_accel_xy(guided_vel_xy_cms, guided_accel_xy_cms);\n}", "CodeBleu_score": 46.9097638097025}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration\n    if (copter.g2.guided_options.get() & uint32_t(Options::IgnoreClimbRate)) {\n        // initialise the vertical position controller\n        if (!pos_control->is_active_z()) {\n            pos_control->init_z_controller();\n        }\n\n        // set vertical speed and acceleration\n        pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), copter.wp_nav->get_default_speed_down(), copter.wp_nav->get_default_speed_up());\n    } else {\n        // initialise the vertical position controller\n        if (!pos_control->is_active_z()) {\n            pos_control->init_z_controller();\n        }\n\n        // set vertical speed and acceleration\n        pos_control->set_max_speed_accel_z(-get_pilot_speed_up(), copter.wp_nav->get_default_speed_down(), copter.wp_nav->get_default_speed_up());\n    }\n\n    // set horizontal speed and acceleration\n    pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), copter.wp_nav->get_wp_acceleration());\n    pos_control->set_correction_speed_accel_xy(wp_nav->get_default_speed_xy(), copter.wp_nav->get_wp_acceleration());\n\n    // initialise the yaw target to current heading\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 52.80939525326242}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we've gone past the timeout\n    if ((millis() - guided_limit.timeout_ms) > guided_limit.timeout_max_ms) {\n        return true;\n    }\n\n    // check if altitude is below min or above max\n    if (guided_limit.alt_min_cm > 0 && (int32_t)current_loc.alt < guided_limit.alt_min_cm) {\n        return true;\n    }\n    if (guided_limit.alt_max_cm > 0 && (int32_t)current_loc.alt > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n    // check if we've gone too far\n    if (guided_limit.horiz_max_cm > 0) {\n        float dist = get_horizontal_distance_cm(guided_limit.start_pos.xy, current_loc.xy);\n        if (dist > guided_limit.horiz_max_cm) {\n            return true;\n        }\n    }\n\n    // if we got this far we must be in keep going\n    return false;\n}", "CodeBleu_score": 58.78930727541171}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    if (AP_HAL::millis() - guided_limit.timeout_ms > guided_limit.timeout_max_ms) {\n        return true;\n    }\n    if (guided_limit.alt_min_cm != 0 && inertial_nav.get_altitude() < guided_limit.alt_min_cm) {\n        return true;\n    }\n    if (guided_limit.alt_max_cm != 0 && inertial_nav.get_altitude() > guided_limit.alt_max_cm) {\n        return true;\n    }\n    if (guided_limit.horiz_max_cm > 0.0f) {\n        // get current horizontal position\n        const Vector3f& curr_pos = inertial_nav.get_position_neu_cm();\n        // check distance between start and current position\n        if (get_horizontal_distance_cm(guided_limit.start_pos.xy(), curr_pos.xy()) > guided_limit.horiz_max_cm) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 67.35370608803294}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // Check if timeout has been exceeded\n    if (AP_HAL::millis() - guided_limit.timeout_ms > guided_limit.timeout_max_ms) {\n        return true;\n    }\n\n    // Check if current altitude is below minimum or above maximum\n    if (guided_limit.alt_min_cm != -1 && inertial_nav.get_altitude() < guided_limit.alt_min_cm) {\n        return true;\n    }\n    if (guided_limit.alt_max_cm != -1 && inertial_nav.get_altitude() > guided_limit.alt_max_cm) {\n        return true;\n    }\n\n    // Check if horizontal distance moved exceeds limit\n    if (guided_limit.horiz_max_cm != -1) {\n        Vector2f curr_pos_xy = inertial_nav.get_position_xy_cm();\n        if (get_horizontal_distance_cm(curr_pos_xy, guided_limit.start_pos.xy) > guided_limit.horiz_max_cm) {\n            return true;\n        }\n    }\n\n    // If none of the above conditions are met, return false\n    return false;\n}", "CodeBleu_score": 60.38936937382534}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t    // check if motor test requests are received at least every 2 Hz\n    if (AP_HAL::millis() - last_motor_test_ms < 500) {\n        return true;\n    }\n\n    // if the requests time out, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false\n    if (AP_HAL::millis() - last_motor_test_ms > 1000) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        motor_test_complete = true;\n        motor_test_pass = false;\n        AP::arming().disarm();\n        motor_test_failure_ms = AP_HAL::millis();\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 65.86074637030114}, {"code": "bool Sub::verify_motor_test(){\n\t    // Check if the motor test is enabled\n    if (!motor_test) {\n        return true;\n    }\n\n    // Check if the motor test is timed out\n    if (AP_HAL::millis() - motor_test_start_ms > MOTOR_TEST_TIMEOUT_MS) {\n        // Send a timeout message\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n\n        // Set the pass flag to false\n        motor_test_pass = false;\n\n        // Disable the motor test\n        disable_motor_test();\n\n        // Disarm the system\n        AP::arming().disarm();\n\n        // Record the failure time\n        motor_test_failed_ms = AP_HAL::millis();\n\n        // Return false\n        return false;\n    }\n\n    // Check if the motor test is passed\n    if (motor_test_pass) {\n        // Return true\n        return true;\n    }\n\n    // Check if the motor test requests are received at least every 2 Hz\n    if (AP_HAL::millis() - motor_test_last_request_ms < 500) {\n        // Return false\n        return false;\n    }\n\n    // Set the motor test last request time\n    motor_test_last_request_ms = AP_HAL::millis();\n\n    // Send a request message\n    gcs().send_text(MAV_SEVERITY_INFO, \"Motor test request\");\n\n    // Return false\n    return false;\n}", "CodeBleu_score": 59.12543852637481}, {"code": "bool Sub::verify_motor_test(){\n\t    // Check if the motor test is enabled\n    if (!motor_test_mode) {\n        return true;\n    }\n\n    // Check if the motor test requests are received at least every 2 Hz\n    if (AP_HAL::millis() - motor_test_last_run_ms < 500) {\n        return true;\n    }\n\n    // Send a timeout message\n    gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout\");\n\n    // Set the pass flag to false\n    motor_test_pass = false;\n\n    // Disable the motor test\n    disable_motor_test();\n\n    // Disarm the system\n    AP::arming().disarm();\n\n    // Record the failure time\n    motor_test_failed_ms = AP_HAL::millis();\n\n    // Return false\n    return false;\n}", "CodeBleu_score": 47.97718805378772}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get_wp_desired_velocity - returns vector to current target point\n    const Vector3f& curr_pos = inertial_nav.get_position();\n    const Vector3f& curr_wp = wp_nav.get_wp_destination();\n    Vector3f wp_error = curr_wp - curr_pos;\n\n    // calculate bearing and distance to wp_nav waypoint\n    float bearing = atan2f(-wp_error.y, -wp_error.x) * DEGX100;\n    float distance = wp_error.length();\n\n    // convert distance to cross-track error\n    float crosstrack_error = wp_nav.crosstrack_error();\n\n    // calculate desired roll angle\n    lateral_out = wp_nav.get_roll();\n\n    // calculate bearing error\n    lateral_out -= bearing;\n    lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n\n    // calculate desired pitch angle\n    forward_out = wp_nav.get_pitch();\n\n    // calculate altitude error\n    forward_out -= (wp_nav.get_alt_target() - curr_pos.z);\n\n    // scale forward_out based on distance\n    // ramped altitude control\n    if (wp_nav.get_alt_target() > curr_pos.z) {\n        forward_out *= constrain_float(distance / MAX(wp_nav.get_default_speed_xy(), wp_nav.get_speed_xy()), 0.0f, 1.0f);\n    }\n\n    // scale forward_out based on lateral_out\n    // ramped lateral control\n    forward_out *= constrain_float(MAX(fabsf(lateral_out)/aparm.angle_max, 0.0f), 0.0f, 1.0f);\n\n    // scale lateral_out with sqrt of forward_out\n    // this counteracts the downward force that scales with forward_out in order to prevent vehicle flip\n    lateral_out *=", "CodeBleu_score": 44.46603804296614}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets in centidegrees\n    lateral_out = wp_nav.get_roll();\n    forward_out = wp_nav.get_pitch();\n\n    // constrain target forward/lateral values\n    lateral_out = constrain_int16(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_int16(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize\n    lateral_out  /= aparm.angle_max;\n    forward_out /= aparm.angle_max;\n}", "CodeBleu_score": 47.76675200954935}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get pitch and roll targets in centi-degrees\n    int32_t lateral_int, forward_int;\n    wp_nav.get_pitch(lateral_int);\n    wp_nav.get_roll(forward_int);\n\n    // constrain target forward/lateral values\n    lateral_int = constrain_int16(lateral_int, -aparm.angle_max, aparm.angle_max);\n    forward_int = constrain_int16(forward_int, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize\n    lateral_out = (float)lateral_int/(float)aparm.angle_max;\n    forward_out = (float)forward_int/(float)aparm.angle_max;\n}", "CodeBleu_score": 65.82333892753664}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t    barometer.update();\n    if (barometer.get_altitude() > 0) {\n        barometer.update_calibration();\n    }\n    if (depth_sensor) {\n        depth_sensor->update_healthy_flag(barometer.healthy);\n    }\n}", "CodeBleu_score": 71.82365956812944}, {"code": "void Sub::read_barometer(){\n\t    barometer.update();\n    if (barometer.healthy()) {\n        barometer.update_calibration();\n        if (depth_sensor_present && depth_sensor.enabled()) {\n            depth_sensor.update_health();\n        }\n    }\n}", "CodeBleu_score": 53.99521455830225}, {"code": "void Sub::read_barometer(){\n\t    barometer.update();\n    if (barometer.get_altitude() > 0) {\n        barometer.update_calibration();\n    }\n    if (depth_sensor) {\n        depth_sensor->update_healthy_flag(barometer.healthy);\n    }\n}", "CodeBleu_score": 71.82365956812944}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    // return false if ekf not yet initialised\n    Location temp_loc;\n    if (!ahrs.get_location(temp_loc)) {\n        return false;\n    }\n\n    // return false if ekf does not have a good horizontal position estimate\n    if (!ahrs.have_inertial_nav() || ahrs.prearm_failure()) {\n        return false;\n    }\n\n    // return true if disarmed\n    if (!motors.armed()) {\n        return true;\n    }\n\n    // ensure absolute position is ok\n    if (!ahrs.prearm_ekf_attitude_check()) {\n        return false;\n    }\n\n    // ensure ekf position filter has started and is not in constant position mode\n    if ((inertial_nav.get_filter_status() == INAV_INITIALISING) ||\n        (inertial_nav.get_filter_status() == INAV_HIGH_LATENCY)) {\n        return false;\n    }\n\n    // if we get this far, EKF position estimate should be OK\n    return true;\n}", "CodeBleu_score": 40.704946220091664}, {"code": "bool Sub::ekf_position_ok(){\n\t    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n\n    // ensure the EKF knows it's in flight\n    if (ahrs.prearm_checks_passing() && !inertial_nav.get_filter_status().flags.in_air) {\n        return false;\n    }\n\n    // get EKF filter status\n    nav_filter_status filt_status = inertial_nav.get_filter_status();\n\n    // check ekf origin has been set\n    Location ekf_origin;\n    if (!ahrs.get_origin(ekf_origin)) {\n        return false;\n    }\n\n    // if disarmed we accept a predicted horizontal position\n    if (!motors.armed()) {\n        return (filt_status.flags.horiz_pos_abs && (filt_status.flags.pred_horiz_pos_abs || filt_status.flags.using_gps));\n    }\n\n    // if in const_pos_mode, EKF's alt is an absolute altitude\n    // DO NOT navigate based on altitude in this mode\n    if (filt_status.flags.const_pos_mode) {\n        return filt_status.flags.horiz_pos_abs && (filt_status.flags.pred_horiz_pos_abs || filt_status.flags.using_gps);\n    }\n\n    // return true if ekf has set an absolute altitude\n    return filt_status.flags.pred_horiz_pos_abs && filt_status.flags.using_gps;\n}", "CodeBleu_score": 60.28278545391276}, {"code": "bool Sub::ekf_position_ok(){\n\t    // return false if ekf is not used\n    if (!ahrs.have_inertial_nav()) {\n        return false;\n    }\n\n    // return true if disarmed\n    if (!motors.armed()) {\n        return true;\n    }\n\n    // accept predicted position if in-air and healthy\n    if (motors.armed() &&\n        (flightmode->is_guided_mode() || flightmode->is_takeoff_complete())) {\n        return true;\n    }\n\n    // require good absolute position\n    if (!ahrs.prearm_healthy()) {\n        return false;\n    }\n\n    // ensure ekf position is good\n    return (ahrs.get_position_xy_kalman_health() >= 1);\n}", "CodeBleu_score": 50.83354561195657}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // if we don't need GPS for position or velocity, return true\n    if (!rover.control_mode->requires_position() && !rover.control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure ahrs is ready\n    if (!ahrs.pre_arm_check()) {\n        check_failed(display_failure, \"AHRS not healthy\");\n        return false;\n    }\n\n    // ensure ekf position estimate is ok\n    if (!rover.ekf_position_ok()) {\n        check_failed(display_failure, \"EKF position estimate not healthy\");\n        return false;\n    }\n\n    // check if ekf failsafe is active\n    if (rover.ekf_failsafe.ekf_failsafe_active()) {\n        check_failed(display_failure, \"EKF failsafe active\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 66.45105422257502}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // check EKF has required GPSs and positions\n    if (rover.control_mode->requires_position() &&\n        (!ahrs.pre_arm_check() ||\n         rover.ekf_position_ok() ||\n         !rover.pre_arm_ekf_attitude_check())) {\n        check_failed(ARMING_CHECK_PARAMETERS, display_failure, \"EKF not ok\");\n        return false;\n    }\n\n    // check position estimate is ok\n    if (rover.control_mode->requires_position() && !rover.is_position_estimate_ok()) {\n        check_failed(ARMING_CHECK_PARAMETERS, display_failure, \"Position estimate not ok\");\n        return false;\n    }\n\n    return AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 43.02208805611387}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // check EKF has started\n    if (rover.control_mode->requires_position() && !rover.ekf_position_ok()) {\n        return false;\n    }\n\n    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure position estimate is ok\n    if (rover.control_mode->requires_position() && !rover.ekf_position_ok()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: EKF fail: %s\", rover.ekf_fail_string());\n        }\n        return false;\n    }\n\n    // check home and EKF origin are set\n    if (!AP::ahrs().home_is_set()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Home not set\");\n        }\n        return false;\n    }\n    if (!rover.ekf_origin_ok()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: EKF origin not set\");\n        }\n        return false;\n    }\n\n    // check vehicle is within position control limits\n    if (rover.control_mode->requires_position() && !rover.pos_control->is_active_xy()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: XY control is required\");\n        }\n        return false;\n    }\n\n    // check vehicle is within velocity control limits\n    if (rover.control_mode->requires_velocity() && !rover.pos_control->is_active_z()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Z control is required\");\n", "CodeBleu_score": 51.53379461767364}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!rover.control_mode->do_user_takeoff_start(method == AP_Arming::Method::RUDDER)) {\n        return false;\n    }\n\n    if (do_arming_checks) {\n        if (!rover.control_mode->do_user_arm_checks(method == AP_Arming::Method::RUDDER)) {\n            return false;\n        }\n    }\n\n    // if checks are successful or not performed, arm motors\n    rover.set_mode(rover.mode_simple, ModeReason::ARMING_COMPLETE);\n\n    // update soft arm state\n    update_soft_armed();\n\n    // set smartrtl home location\n    rover.g2.smart_rtl.set_home(true);\n\n    // initialise simple heading\n    rover.mode_simple.init_heading();\n\n    // record home heading for sail vehicles\n    if (rover.g2.windvane.enabled()) {\n        rover.g2.windvane.record_home_heading();\n    }\n\n    // send arm/disarm status text\n    send_arm_disarm_statustext();\n\n    return true;\n}", "CodeBleu_score": 54.195890485503554}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!rover.control_mode->do_user_takeoff_start(method == AP_Arming::Method::MAVLINK)) {\n        return false;\n    }\n\n    // check vehicle doesn't have a motor interlock and RTL is not active\n    if (rover.motor_interlock_switch && rover.motor_interlock_switch->enabled() && rover.control_mode != &rover.mode_rtl) {\n        gcs().send_text(MAV_SEVERITY_EMERGENCY, \"Arm: Motor Interlock Switch enabled\");\n        return false;\n    }\n\n    // check vehicle doesn't have a motor interlock and RTL is not active\n    if (rover.g2.ice_detector.enabled() && rover.g2.ice_detector.detected()) {\n        gcs().send_text(MAV_SEVERITY_EMERGENCY, \"Arm: Ice detected\");\n        return false;\n    }\n\n    if (do_arming_checks) {\n        if (!rover.control_mode->do_user_arm_checks(method == AP_Arming::Method::MAVLINK)) {\n            return false;\n        }\n    }\n\n    // call base class checks\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // check throttle is not too high\n    if (rover.channel_throttle->get_servo_out() > rover.g.throttle_max) {\n        gcs().send_text(MAV_SEVERITY_EMERGENCY, \"Arm: Throttle too high\");\n        return false;\n    }\n\n    // check if safety switch has been pushed\n    if (rover.check_safety_switch_arm_requirement()) {\n        return false;\n    }\n\n    // set arming status to armed\n    set_armed_status(AP_Arming::ArmingStatus::ARMED);\n\n    // set smart RTL home location\n    rover.g2.", "CodeBleu_score": 51.37325136408689}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!rover.control_mode->do_user_takeoff_start(method == AP_Arming::Method::RUDDER)) {\n        return false;\n    }\n\n    if (do_arming_checks && !rover.control_mode->in_guided_mode()) {\n        const char *fail_msg = nullptr;\n        if (!rover.pre_arm_checks(fail_msg)) {\n            if (fail_msg) {\n                gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: %s\", fail_msg);\n            }\n            return false;\n        }\n    }\n\n    // don't allow arming via INAV if we are already armed\n    if (rover.control_mode != &rover.mode_simple && rover.control_mode != &rover.mode_auto) {\n        return false;\n    }\n\n    if (do_arming_checks &&\n        !rover.g2.sailboat.sail_enabled() &&\n        !rover.g2.windvane.enabled() &&\n        !rover.g2.soaring_controller.is_active()) {\n        // if we are using throttle interlock and we are not in guided or simple mode, we can't arm if the throttle is zero\n        if (rover.ap.using_interlock && rover.channel_throttle->get_control_in() <= 0) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Arm: Throttle not at zero\");\n            return false;\n        }\n    }\n\n    // call parent class to actually change armed state\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // return true if arming was successful\n    return true;\n}", "CodeBleu_score": 53.37383837421679}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (!checkShouldCharge()) {\n      digitalWrite(CHARGE_ENABLE_PIN, LOW);\n      charging_disabled_time = millis();\n    }\n  } else {\n    if (checkShouldCharge()) {\n      digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n    } else if (millis() - charging_disabled_time > CHARGING_RETRY_DELAY) {\n      updateChargingEnabled();\n    }\n  }\n}", "CodeBleu_score": 50.38774350670637}, {"code": "void updateChargingEnabled(){\n\t  if (charging_allowed) {\n    if (checkShouldCharge()) {\n      if (!charging_enabled) {\n        charging_enabled = true;\n        digitalWrite(CHARGE_PIN, HIGH);\n      }\n    } else {\n      if (charging_enabled) {\n        charging_enabled = false;\n        digitalWrite(CHARGE_PIN, LOW);\n        last_disabled_time = millis();\n      }\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      digitalWrite(CHARGE_PIN, LOW);\n      last_disabled_time = millis();\n    } else {\n      if (millis() - last_disabled_time > RETRY_DELAY) {\n        if (checkShouldCharge()) {\n          charging_allowed = true;\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 68.40139616325843}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (!checkShouldCharge()) {\n            charging_enabled = false;\n            last_charging_disabled_time = millis();\n        }\n    } else {\n        if (checkShouldCharge()) {\n            charging_enabled = true;\n        } else if (millis() - last_charging_disabled_time >= CHARGING_RETRY_DELAY) {\n            charging_enabled = true;\n        }\n    }\n}", "CodeBleu_score": 45.2468186029075}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t    if (ros::ok() && size >= 4) {\n        uint16_t crc = CRC16.ccitt((uint8_t *) message, size - 2);\n        memcpy(((uint8_t *) message) + size - 2, &crc, 2);\n        packetSerial.send((uint8_t *) message, size);\n    }\n}", "CodeBleu_score": 50.68090335571096}, {"code": "void sendMessage(void *message, size_t size){\n\t    if (ros::ok() && size >= 4) {\n        uint16_t crc = CRC16.ccitt((uint8_t *) message, size - 2);\n        memcpy((uint8_t *) message + size - 2, &crc, 2);\n        packetSerial.send((uint8_t *) message, size);\n    }\n}", "CodeBleu_score": 50.64206374977914}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros::ok() && size >= 4) {\n    uint16_t crc = CRC16.ccitt((uint8_t *)message, size-2);\n    memcpy((uint8_t *)message+size-2, &crc, sizeof(uint16_t));\n    packetSerial.send((uint8_t *)message, size);\n  }\n}", "CodeBleu_score": 43.71681708029948}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  delay(200);\n  soundSerial.flush();\n  delay(100);\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0xEF);\n  delay(100);\n  soundSerial.flush();\n  delay(100);\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0xEF);\n  delay(100);\n  soundSerial.flush();\n  delay(100);\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0xEF);\n  delay(100);\n  soundSerial.flush();\n  delay(100);\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0", "CodeBleu_score": 40.87213309290483}, {"code": "bool MP3Sound::begin(){\n\t    soundSerial.begin(9600);\n    delay(100);\n    soundSerial.flush();\n    soundSerial.write(0x7E);\n    soundSerial.write(0xFF);\n    soundSerial.write(0x06);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0xEF);\n    delay(100);\n    soundSerial.flush();\n    soundSerial.write(0x7E);\n    soundSerial.write(0xFF);\n    soundSerial.write(0x06);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0xEF);\n    delay(100);\n    soundSerial.flush();\n    soundSerial.write(0x7E);\n    soundSerial.write(0xFF);\n    soundSerial.write(0x06);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0x00);\n    soundSerial.write(0xEF);\n    delay(100);\n    soundSerial.flush();\n    soundSerial.write(0x7E);\n    soundSerial.write(0xFF);\n    soundSerial", "CodeBleu_score": 41.067515144281444}, {"code": "bool MP3Sound::begin(){\n\t  soundSerial.begin(9600);\n  soundSerial.flush();\n  delay(100);\n  soundSerial.write(0x7E);\n  soundSerial.write(0xFF);\n  soundSerial.write(0x06);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0x00);\n  soundSerial.write(0xEF);\n  delay(200);\n  if (soundSerial.available()) {\n    if (soundSerial.read() == 0x7E) {\n      if (soundSerial.read() == 0xFF) {\n        if (soundSerial.read() == 0x06) {\n          if (soundSerial.read() == 0x00) {\n            if (soundSerial.read() == 0x00) {\n              if (soundSerial.read() == 0x00) {\n                if (soundSerial.read() == 0x00) {\n                  if (soundSerial.read() == 0x00) {\n                    if (soundSerial.read() == 0x00) {\n                      if (soundSerial.read() == 0x00) {\n                        if (soundSerial.read() == 0x00) {\n                          if (soundSerial.read() == 0x00) {\n                            if (soundSerial.read() == 0x00) {\n                              if (soundSerial.read() == 0x00) {\n                                if (soundSerial.read() == 0x00) {\n                                  if (soundSerial.read() == 0x00) {\n                                    if (soundSerial.read() == 0x00) {\n                                      if (soundSerial.read() == 0x00) {\n                                        if (soundSerial.read() == 0x00) {\n                                          if (soundSerial.read() == 0x00) {\n                                            if (soundSerial.read() == 0x00) {\n                                              if (soundSerial.read() == 0x00", "CodeBleu_score": 42.057975529740084}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t    if (active_sounds.size() == 0) {\n        return 0;\n    }\n    if (myMP3.isPlaying()) {\n        return active_sounds.size();\n    }\n    String sound = active_sounds.back();\n    active_sounds.pop_back();\n    playMP3(sound);\n    return active_sounds.size();\n}", "CodeBleu_score": 47.55541915422845}, {"code": "int MP3Sound::processSounds(){\n\t    if (active_sounds.size() == 0 || myMP3.isPlaying()) {\n        return active_sounds.size();\n    } else {\n        MP3Sound *last_sound = active_sounds.back();\n        last_sound->play();\n        active_sounds.pop_back();\n        return active_sounds.size();\n    }\n}", "CodeBleu_score": 45.13052917414607}, {"code": "int MP3Sound::processSounds(){\n\t  if (active_sounds.size() == 0) {\n    return 0;\n  }\n  if (myMP3.isPlaying()) {\n    return active_sounds.size();\n  }\n  myMP3.play(active_sounds.back());\n  active_sounds.pop_back();\n  return active_sounds.size();\n}", "CodeBleu_score": 48.66317070129003}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    // cleanup existing memory-mapped file\n    if (d->image_buffer)\n      wb_image_cleanup(d->image_buffer);\n\n    // create new memory-mapped file\n    d->image_buffer = wb_image_setup(r->argument_count, r->arguments);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 33.66129523781246}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    wb_camera_cleanup(d);\n    wb_camera_set_memory_mapped_file(d, r);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 19.81869570546054}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (d->image_buffer) {\n        free(d->image_buffer);\n        d->image_buffer = NULL;\n      }\n      const char *filename = wb_request_get_string_argument(r, 0, NULL);\n      d->image_buffer = wb_image_read_file(filename, &d->image_width, &d->image_height, &d->image_channels);\n      if (!d->image_buffer) {\n        fprintf(stderr, \"Error: Failed to read image file '%s'.\n\", filename);\n        return false;\n      }\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 47.45996186758731}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  wb_mutex_lock(d->mutex);\n  if (d->image)\n    height = d->image->height;\n  wb_mutex_unlock(d->mutex);\n  return height;\n}", "CodeBleu_score": 44.348444037237456}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int ret;\n  int height;\n  if (d == NULL || d->tag != WB_TAG_CAMERA)\n    return -1;\n  wb_robot_mutex_lock();\n  ret = wb_camera_get_height(d->data.camera, &height);\n  wb_robot_mutex_unlock();\n  return ret ? -1 : height;\n}", "CodeBleu_score": 47.09025845135528}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height;\n  wb_robot_mutex_lock();\n  if (d->data == NULL) {\n    height = -1;\n  } else {\n    height = d->data->height;\n  }\n  wb_robot_mutex_unlock();\n  return height;\n}", "CodeBleu_score": 50.79709604279263}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  robot_mutex_lock();\n  Accelerometer *accelerometer = robot_get_accelerometer(tag);\n  if (accelerometer == NULL) {\n    fprintf(stderr, \"Error: %s: invalid device tag.\n\", __FUNCTION__);\n    sampling_period = 0;\n  } else\n    sampling_period = accelerometer->sampling_period;\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 49.989182132344595}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  robot_mutex_lock();\n  accelerometer_get_struct(tag);\n  if (accelerometer_struct)\n    sampling_period = accelerometer_struct->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s: invalid tag.\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 58.56760950832128}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  robot_mutex_lock();\n  accelerometer_get_struct(tag);\n  if (accelerometer_get_struct(tag)) {\n    sampling_period = accelerometer_get_struct(tag)->sampling_period;\n  } else {\n    fprintf(stderr, \"Error: %s: invalid tag.\n\", __FUNCTION__);\n  }\n  robot_mutex_unlock();\n  return sampling_period;\n}", "CodeBleu_score": 64.70078327180777}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *DMS = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result = string(DMS);\n  free(DMS);\n  return result;\n}", "CodeBleu_score": 44.74057176945744}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *DMS = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(DMS);\n  free(DMS);\n  return result;\n}", "CodeBleu_score": 39.25517561510863}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 39.37179132599584}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dUASSERT (g,\"bad geom passed to dGeomBoxGetTangentPlane\");\n    dUASSERT (dGeomGetClass(g) == dBoxClass,\"non-box geom passed to dGeomBoxGetTangentPlane\");\n    dVector3 p,half_extents;\n    dReal dx,dy,dz;\n    dGeomBoxGetLengths (g,half_extents);\n    p[0] = x - dGeomGetPosition(g)[0];\n    p[1] = y - dGeomGetPosition(g)[1];\n    p[2] = z - dGeomGetPosition(g)[2];\n    dx = dFabs(p[0]) - half_extents[0];\n    dy = dFabs(p[1]) - half_extents[1];\n    dz = dFabs(p[2]) - half_extents[2];\n    if (dx < dy) {\n        if (dx < dz) {\n            if (p[0] < 0) {\n                plane[0] = -1;\n                plane[3] = -half_extents[0];\n            } else {\n                plane[0] = 1;\n                plane[3] =  half_extents[0];\n            }\n            plane[1] = plane[2] = 0;\n        } else {\n            if (p[2] < 0) {\n                plane[2] = -1;\n                plane[3] = -half_extents[2];\n            } else {\n                plane[2] = 1;\n                plane[3] =  half_extents[2];\n            }\n            plane[0] = plane[1] = 0;\n        }\n    } else {\n        if (dy < dz) {\n            if (p[1] < 0) {\n                plane[1] = -1;\n                plane[3] = -half_extents[1];\n            } else {\n                plane[1] = 1;\n                plane[3] =  half_extents[1];\n            }\n            plane[0] = plane[2] = 0;\n        } else {\n           ", "CodeBleu_score": 29.21726295678001}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  dVector3 tmp;\n  dGeomBoxGetLengths(g, tmp);\n  dReal dx = x - g->pos[0];\n  dReal dy = y - g->pos[1];\n  dReal dz = z - g->pos[2];\n  dReal dx_abs = dFabs(dx);\n  dReal dy_abs = dFabs(dy);\n  dReal dz_abs = dFabs(dz);\n  dReal dx_sign = (dx > 0) ? 1.0 : -1.0;\n  dReal dy_sign = (dy > 0) ? 1.0 : -1.0;\n  dReal dz_sign = (dz > 0) ? 1.0 : -1.0;\n  dReal dx_abs_tmp = dx_abs - tmp[0];\n  dReal dy_abs_tmp = dy_abs - tmp[1];\n  dReal dz_abs_tmp = dz_abs - tmp[2];\n  dReal dx_abs_tmp_abs = dFabs(dx_abs_tmp);\n  dReal dy_abs_tmp_abs = dFabs(dy_abs_tmp);\n  dReal dz_abs_tmp_abs = dFabs(dz_abs_tmp);\n  dReal dx_abs_tmp_sign = (dx_abs_tmp > 0) ? 1.0 : -1.0;\n  dReal dy_abs_tmp_sign = (dy_abs_tmp > 0) ? 1.0 : -1.0;\n  dReal dz_abs_tmp_sign = (dz_abs_tmp > 0) ? 1.0 : -1.0;\n  dReal dx_abs_tmp_abs_tmp = dx_abs_tmp_abs - tmp[0];\n  dReal dy_abs_tmp_abs_tmp = dy_abs_tmp_abs - tmp[1];\n  dReal dz_abs_tmp_abs_tmp = dz_abs_tmp_abs - tmp[2];\n  dReal dx_abs_tmp_abs_tmp_abs = dFabs(dx_abs_tmp_abs_tmp);", "CodeBleu_score": 30.292190201961493}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  dVector3 n;\n  dVector3 p;\n  dVector3 v;\n  dReal d;\n  dReal l;\n  int i;\n\n  dUASSERT (g,\"dGeomBoxGetTangentPlane\");\n  dGeomBoxGetLengths (g,n);\n  p[0] = x;\n  p[1] = y;\n  p[2] = z;\n  dGeomBoxPointToRelPoint(g,p,v);\n  for (i=0; i<3; i++) {\n    d = dFabs(v[i]);\n    if (d<n[i]) {\n      plane[i] = dSign(v[i]);\n      plane[3] = -n[i];\n    }\n    else {\n      plane[i] = 0;\n      plane[3] = -v[i];\n    }\n  }\n}", "CodeBleu_score": 26.021365658930918}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t   sBoxImmersionData data;\n\n   dASSERT_IS_BOX(box);\n   dASSERT(fluidPlane);\n   dASSERT(immersion);\n   dASSERT(flags & (dIMMERSE_BOX_HIT_FULL_DEPTH | dIMMERSE_BOX_HIT_EITHER_DEPTH));\n\n   data.box = box;\n   data.fluidPlane = fluidPlane;\n   data.immersion = immersion;\n   data.flags = flags;\n\n   return dGeomBoxImmersion (box->body, box->geom, fluidPlane, &data);\n}", "CodeBleu_score": 45.34249732623622}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t   dIASSERT (box);\n   dIASSERT (box->body);\n   dIASSERT (flags >= 0);\n\n   sBoxImmersionData data;\n   data.box = box;\n   data.fluidPlane = fluidPlane;\n   data.immersion = immersion;\n   data.flags = flags;\n\n   return dImmerseBoxInternal (&data);\n}", "CodeBleu_score": 47.69205105989322}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t   sBoxImmersionData data;\n\n   dIASSERT (box);\n   dIASSERT (box->body);\n   dIASSERT (fluidPlane);\n   dIASSERT (immersion);\n\n   data.box = box;\n   data.fluidPlane = fluidPlane;\n   data.immersion = immersion;\n   data.flags = flags;\n\n   return dImmerseBoxData (&data);\n}", "CodeBleu_score": 46.721064160615974}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    int code;\n    dxGeom *box;\n    dxGeom *capsule;\n    dVector3 box_size;\n    dVector3 box_pos;\n    dVector3 box_R;\n    dVector3 box_axis;\n    dVector3 capsule_pos;\n    dVector3 capsule_R;\n    dVector3 capsule_axis;\n    dReal capsule_length;\n    dReal capsule_radius;\n    dReal box_radius;\n    dReal box_length;\n    dReal box_width;\n    dReal box_height;\n    dReal box_depth;\n    dReal box_radius2;\n    dReal box_length2;\n    dReal box_width2;\n    dReal box_height2;\n    dReal box_depth2;\n    dReal box_radius_sq;\n    dReal box_length_sq;\n    dReal box_width_sq;\n    dReal box_height_sq;\n    dReal box_depth_sq;\n    dReal box_radius_sq2;\n    dReal box_length_sq2;\n    dReal box_width_sq2;\n    dReal box_height_sq2;\n    dReal box_depth_sq2;\n    dReal box_radius_sq3;\n    dReal box_length_sq3;\n    dReal box_width_sq3;\n    dReal box_height_sq3;\n    dReal box_depth_sq3;\n    dReal box_radius_sq4;\n    dReal box_length_sq4;\n    dReal box_width_sq4;\n    dReal box_height_sq4;\n    dReal box_depth_sq4;\n    dReal box_radius_sq5;\n    dReal box_length_sq5;\n    dReal box_width_sq5;\n    dReal box_height_sq5;\n    dReal box_depth_sq5;\n    dReal box_radius_sq6;\n    dReal box_length_sq6;\n    dReal box_width_sq6;\n    dReal box_height_sq6;\n    dReal box_depth", "CodeBleu_score": 8.515452783941168}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dVector3 p;\n    dReal a0, a1, b0, b1, c0, c1, r, R;\n    dReal dist, depth;\n    dReal normal[3];\n    dReal point[3];\n    dReal dir[3];\n    dReal plane[4];\n    dReal tmp[3];\n    dReal dir_tmp[3];\n    dReal tmp_tmp[3];\n    dReal tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp[3];\n    dReal tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_", "CodeBleu_score": 6.5419385661158085}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dVector3 side_dir;\n    dReal side_depth;\n    dReal side_normal[4];\n    dReal side_pos[4];\n    dReal side_vel[4];\n    dReal side_omega[4];\n    dReal side_radius;\n    dReal side_depth_vel;\n    dReal side_depth_omega;\n    dReal side_depth_acc;\n    dReal side_depth_alpha;\n    dReal side_depth_vel_acc;\n    dReal side_depth_vel_alpha;\n    dReal side_depth_omega_acc;\n    dReal side_depth_omega_alpha;\n    dReal side_depth_acc_acc;\n    dReal side_depth_acc_alpha;\n    dReal side_depth_omega_acc_acc;\n    dReal side_depth_omega_acc_alpha;\n    dReal side_depth_alpha_acc;\n    dReal side_depth_alpha_alpha;\n    dReal side_depth_vel_acc_acc;\n    dReal side_depth_vel_acc_alpha;\n    dReal side_depth_vel_alpha_acc;\n    dReal side_depth_vel_alpha_alpha;\n    dReal side_depth_omega_acc_acc;\n    dReal side_depth_omega_acc_alpha;\n    dReal side_depth_omega_alpha_acc;\n    dReal side_depth_omega_alpha_alpha;\n    dReal side_depth_acc_acc_acc;\n    dReal side_depth_acc_acc_alpha;\n    dReal side_depth_acc_alpha_acc;\n    dReal side_depth_acc_alpha_alpha;\n    dReal side_depth_omega_acc_acc_acc;\n    dReal side_depth_omega_acc_acc_alpha;\n    dReal side_depth_omega_acc_alpha_acc;\n    dReal side_depth_omega_acc_alpha_alpha;\n    dReal side_depth_omega_alpha_acc_acc;\n    dReal side_depth_omega_alpha_acc_alpha;\n    dReal side_depth_omega_alpha_alpha_acc;\n    dReal", "CodeBleu_score": 9.755305122478456}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t  // If zIOverR is zero, the hemisphere is centered on the sphere, and the volume is 1.\n  if (zIOverR == 0) {\n    return 1;\n  }\n\n  // If zIOverR is less than zero, the hemisphere is completely outside the sphere, and the volume is 0.\n  if (zIOverR < 0) {\n    return 0;\n  }\n\n  // If zIOverR is greater than the radius, the hemisphere is completely inside the sphere, and the volume is 1.\n  if (zIOverR > radius) {\n    return 1;\n  }\n\n  // Calculate the z coordinate of the center of the hemisphere.\n  dReal zCenter = zIOverR * radius;\n\n  // Calculate the z coordinate of the top of the hemisphere.\n  dReal zTop = zCenter + radius;\n\n  // Calculate the z coordinate of the bottom of the hemisphere.\n  dReal zBottom = zCenter - radius;\n\n  // Calculate the z coordinate of the intersection of the hemisphere with the sphere.\n  dReal zIntersection = sqrt(radius * radius - zIOverR * zIOverR);\n\n  // Calculate the volume of the hemisphere above the intersection.\n  dReal volumeAboveIntersection = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(\n      {zTop, zIntersection, radius, tanTheta0, sinTheta1},\n      {0, 1},\n      1000\n  );\n\n  // Calculate the volume of the hemisphere below the intersection.\n  dReal volumeBelowIntersection = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(\n      {zBottom, zIntersection, radius, tanTheta0, sinTheta1},\n      {0, 1},\n      1000\n  );\n\n  // Calculate the total volume of the hemisphere.\n  dReal totalVolume = volumeAboveIntersection + volumeBelowIntersection;\n\n  // Normalize the", "CodeBleu_score": 45.798138709581586}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    dReal zIOverR2 = zIOverR * zIOverR;\n    dReal tanTheta02 = tanTheta0 * tanTheta0;\n    dReal sinTheta12 = sinTheta1 * sinTheta1;\n    dReal zIOverR2tanTheta02 = zIOverR2 * tanTheta02;\n    dReal zIOverR2sinTheta12 = zIOverR2 * sinTheta12;\n    dReal tanTheta02sinTheta12 = tanTheta02 * sinTheta12;\n    dReal zIOverR2tanTheta02sinTheta12 = zIOverR2 * tanTheta02sinTheta12;\n\n    dReal zIOverR2tanTheta02sinTheta12_plus_1 = 1 + zIOverR2tanTheta02sinTheta12;\n    dReal zIOverR2tanTheta02sinTheta12_plus_1_pow_2 = zIOverR2tanTheta02sinTheta12_plus_1 * zIOverR2tanTheta02sinTheta12_plus_1;\n    dReal zIOverR2tanTheta02sinTheta12_plus_1_pow_3 = zIOverR2tanTheta02sinTheta12_plus_1_pow_2 * zIOverR2tanTheta02sinTheta12_plus_1;\n    dReal zIOverR2tanTheta02sinTheta12_plus_1_pow_4 = zIOverR2tanTheta02sinTheta12_plus_1_pow_3 * zIOverR2tanTheta02sinTheta12_plus_1;\n\n    dReal zIOverR2tanTheta02sinTheta12_plus_1_pow_2_plus_1 = zIOverR2tanTheta02sinTheta12_plus_1_pow_2 + 1;\n    dReal zIOverR2tanTheta02sinTheta12_plus_1_pow_3_plus_1 = zIOverR2tanTheta02sinTheta12_plus_1_pow_3 + 1;\n    dReal zIOverR2tanTheta", "CodeBleu_score": 34.85172995273498}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    // Calculate the angle of the hemisphere's base\n    dReal theta0 = atan(tanTheta0);\n\n    // Calculate the angle of the hemisphere's top\n    dReal theta1 = atan(sinTheta1 / cos(theta0));\n\n    // Calculate the volume of the hemisphere\n    dReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(\n        sHemisphereIntegrationData(*this, zIOverR, theta0, theta1), 0, theta1, 1000);\n\n    // Return the normalized volume\n    return volume / (M_PI * r * r * r / 3);\n}", "CodeBleu_score": 42.92055954394211}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    return simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(sHemisphereIntegrationData(zIOverR, tanTheta0, sinTheta1), 0, sinTheta1, 10000) * radius * volume;\n}", "CodeBleu_score": 40.74939274652808}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    // Set the initial angle\n    dReal theta0 = atan(tanTheta0);\n\n    // Set the final angle\n    dReal theta1 = asin(sinTheta1);\n\n    // Set the number of steps for Simpson's rule\n    const int nSteps = 1000;\n\n    // Set the step size\n    dReal step = (theta1 - theta0) / nSteps;\n\n    // Initialize the sum\n    dReal sum = 0;\n\n    // Initialize the current angle\n    dReal theta = theta0;\n\n    // Loop over the number of steps\n    for (int i = 0; i < nSteps; i++) {\n        // Calculate the current value of the integrand\n        dReal value = xCenterOfMassIntegrand(zIOverR, theta, volume);\n\n        // Update the sum based on the value of the integrand and the step size\n        sum += (i == 0 || i == nSteps) ? value : ((i % 2 == 0) ? 2 : 4) * value;\n\n        // Increment the current angle\n        theta += step;\n    }\n\n    // Return the final value of the sum scaled by the step size and adjusted by the volume\n    return sum * step / (3 * volume);\n}", "CodeBleu_score": 42.467794947670335}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    // Calculate the integrand using the given inputs\n    dReal integrand = xCenterOfMassIntegrand(zIOverR, tanTheta0, sinTheta1);\n    // Return the x-coordinate of the buoyancy center scaled by the radius and adjusted by the volume\n    return (radius * integrand) / volume;\n}", "CodeBleu_score": 32.577202747083575}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dReal volume;\n    dReal tangentInitialAngle;\n    dReal sineFinalAngle;\n    dReal depthRatio;\n    dReal buoyancyCenter;\n    dReal radius;\n    dReal radiusSquared;\n    dReal radiusCubed;\n    dReal radiusToFourth;\n    dReal radiusToFifth;\n    dReal radiusToSixth;\n    dReal radiusToSeventh;\n    dReal radiusToEighth;\n    dReal radiusToNinth;\n    dReal radiusToTenth;\n    dReal radiusToEleventh;\n    dReal radiusToTwelfth;\n    dReal radiusToThirteenth;\n    dReal radiusToFourteenth;\n    dReal radiusToFifteenth;\n    dReal radiusToSixteenth;\n    dReal radiusToSeventeenth;\n    dReal radiusToEighteenth;\n    dReal radiusToNineteenth;\n    dReal radiusToTwentieth;\n    dReal radiusToTwentyFirst;\n    dReal radiusToTwentySecond;\n    dReal radiusToTwentyThird;\n    dReal radiusToTwentyFourth;\n    dReal radiusToTwentyFifth;\n    dReal radiusToTwentySixth;\n    dReal radiusToTwentySeventh;\n    dReal radiusToTwentyEighth;\n    dReal radiusToTwentyNinth;\n    dReal radiusToThirtieth;\n    dReal radiusToThirtyFirst;\n    dReal radiusToThirtySecond;\n    dReal radiusToThirtyThird;\n    dReal radiusToThirtyFourth;\n    dReal radiusToThirtyFifth;\n    dReal radiusToThirtySixth;\n    dReal radiusToThirtySeventh;\n    dReal radiusToThirtyEighth;\n    dReal radiusToThirtyNinth;\n    dReal radiusToFortieth;\n    dReal radiusToFortyFirst;\n    dReal radiusToFortySecond;\n    dReal radiusToFortyThird;\n    dReal radiusToFortyFourth;\n    dReal radiusToFortyFifth;\n    dReal radiusToFort", "CodeBleu_score": 5.997348908153316}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    dReal depth = immersion->depth;\n    dReal tanTheta = immersion->tanTheta;\n    dReal sinTheta = immersion->sinTheta;\n    dReal volume = immersion->volume;\n\n    if (depth == 0) {\n        return 0;\n    }\n\n    dReal xBuoyancyCenter = immersion->xBuoyancyCenter;\n    dReal yBuoyancyCenter = immersion->yBuoyancyCenter;\n    dReal zBuoyancyCenter = immersion->zBuoyancyCenter;\n\n    dReal radius = immersion->radius;\n    dReal length = immersion->length;\n\n    dReal x, y, z;\n    dReal xBuoyancyCenterScaled = xBuoyancyCenter / radius;\n    dReal yBuoyancyCenterScaled = yBuoyancyCenter / radius;\n    dReal zBuoyancyCenterScaled = zBuoyancyCenter / radius;\n\n    dReal xBuoyancyCenterScaledSquared = xBuoyancyCenterScaled * xBuoyancyCenterScaled;\n    dReal yBuoyancyCenterScaledSquared = yBuoyancyCenterScaled * yBuoyancyCenterScaled;\n    dReal zBuoyancyCenterScaledSquared = zBuoyancyCenterScaled * zBuoyancyCenterScaled;\n\n    dReal xBuoyancyCenterScaledCubed = xBuoyancyCenterScaled * xBuoyancyCenterScaled * xBuoyancyCenterScaled;\n    dReal yBuoyancyCenterScaledCubed = yBuoyancyCenterScaled * yBuoyancyCenterScaled * yBuoyancyCenterScaled;\n    dReal zBuoyancyCenterScaledCubed = zBuoyancyCenterScaled * zBuoyancyCenterScaled * zBuoyancyCenterScaled;\n\n    dReal xBuoyancyCenterScaledQuartic = xBuoyancyCenterScaledCubed * xBuoyancyCenterScaled;\n    dReal yBuoyancyCenterScaledQuartic = yBuoyancyCenterScaledCubed * yBuoyancyCenterScaled;\n    dReal", "CodeBleu_score": 30.60667306959763}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t    int i;\n    dReal volume;\n    dReal tangentInitialAngle;\n    dReal sineFinalAngle;\n    dReal immersionDepthRatio;\n    dReal buoyancyCenter;\n    dReal immersionDepth;\n    dReal immersionDepthScaled;\n    dReal immersionDepthScaledSquared;\n    dReal immersionDepthScaledCubed;\n    dReal immersionDepthScaledQuartic;\n    dReal immersionDepthScaledQuintic;\n    dReal immersionDepthScaledSextic;\n    dReal immersionDepthScaledSeptic;\n    dReal immersionDepthScaledOctic;\n    dReal immersionDepthScaledNonic;\n    dReal immersionDepthScaledDecanic;\n    dReal immersionDepthScaledDodecic;\n    dReal immersionDepthScaledTridecic;\n    dReal immersionDepthScaledTetradecic;\n    dReal immersionDepthScaledPentadecic;\n    dReal immersionDepthScaledHexadecic;\n    dReal immersionDepthScaledHeptadecic;\n    dReal immersionDepthScaledOctadecic;\n    dReal immersionDepthScaledEnneadecic;\n    dReal immersionDepthScaledDodecadecic;\n    dReal immersionDepthScaledTricadecic;\n    dReal immersionDepthScaledQuadradecic;\n    dReal immersionDepthScaledQuindecic;\n    dReal immersionDepthScaledSexdecic;\n    dReal immersionDepthScaledSeptendecic;\n    dReal immersionDepthScaledOctodecic;\n    dReal immersionDepthScaledNovemdecic;\n    dReal immersionDepthScaledVigintic;\n    dReal immersionDepthScaledUnvigintic;\n    dReal immersionDepthScaledDuovigintic;\n    dReal immersionDepthScaledTreviigintic;\n    dReal immersionDepthScaledQuattuorvigintic;\n    dReal immersionDepthScaledQuinvigintic;\n    dReal imm", "CodeBleu_score": 6.908091452240115}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t  // Get the sleep duration in milliseconds from the input\n  auto duration = getInput<std::chrono::milliseconds>(\"duration\");\n\n  // If the duration is missing or non-positive, return SUCCESS\n  if (!duration) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n\n  // Start a timer with the specified duration\n  timer_.add(*duration, [this]() {\n    // If the timer was not aborted, emit a wake-up signal\n    if (!timer_waiting_) {\n      emitWakeUpSignal();\n    }\n  });\n\n  // Reset the timer_waiting_ flag\n  timer_waiting_ = false;\n\n  // Return SUCCESS\n  return NodeStatus::SUCCESS;\n}", "CodeBleu_score": 43.517752833697045}, {"code": "NodeStatus SleepNode::onStart(){\n\t  auto duration_ms = getInput<int>(\"duration\");\n  if (!duration_ms) {\n    return NodeStatus::SUCCESS;\n  }\n  if (*duration_ms <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_.add(std::chrono::milliseconds(*duration_ms),\n             [this]() {\n               timer_.stop();\n               timer_waiting_ = false;\n               emitWakeUpSignal();\n             },\n             true);\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 52.410699836292416}, {"code": "NodeStatus SleepNode::onStart(){\n\t  // Retrieve the sleep duration in milliseconds from the input\n  auto duration = getInput<int>(\"duration\");\n\n  // Check if the duration is missing or non-positive\n  if (!duration || *duration <= 0) {\n    // If the duration is missing or non-positive, return SUCCESS\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n\n  // Start a timer with the specified duration\n  timer_.add(std::chrono::milliseconds(*duration), [this]() {\n    // Set the timer_waiting_ flag to false\n    timer_waiting_ = false;\n\n    // Emit a wake-up signal\n    emitWakeUpSignal();\n  });\n\n  // Reset the timer_waiting_ flag\n  timer_waiting_ = true;\n\n  // Return SUCCESS\n  return NodeStatus::SUCCESS;\n}", "CodeBleu_score": 47.52007391264337}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  const auto entry = config().blackboard->getEntry(entry_name_);\n  if (!entry) {\n    return NodeStatus::FAILURE;\n  }\n  entry->mutex.lock();\n  const auto seq_id = entry->seq_id();\n  entry->mutex.unlock();\n\n  if (seq_id != last_seq_id_) {\n    last_seq_id_ = seq_id;\n    return NodeStatus::SUCCESS;\n  }\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 50.65446384842293}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    auto entry = config().blackboard->getEntry(entry_name_);\n    if (entry) {\n        std::lock_guard<std::mutex> lock(entry->mutex);\n        if (entry->sequence_number != last_sequence_number_) {\n            last_sequence_number_ = entry->sequence_number;\n            return NodeStatus::SUCCESS;\n        }\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 37.67303997885813}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    auto entry = config().blackboard->getEntry<int>(key_);\n    if (!entry) {\n        return NodeStatus::FAILURE;\n    }\n    {\n        std::lock_guard<std::mutex> lock(entry->mutex);\n        if (entry->sequenceNumber != last_seq_ID_) {\n            last_seq_ID_ = entry->sequenceNumber;\n            return NodeStatus::SUCCESS;\n        }\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 43.63409283876869}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t  size_t success_threshold = (size_t) success_threshold_;\n  if (success_threshold < 0) {\n    success_threshold = (size_t) std::max(0, (int) children_nodes_.size() + success_threshold);\n  }\n  return success_threshold;\n}", "CodeBleu_score": 49.87519980443436}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  size_t threshold = success_threshold_;\n  if (threshold < 0) {\n    threshold = children_nodes_.size() + threshold + 1;\n  }\n  return threshold;\n}", "CodeBleu_score": 48.23374975838765}, {"code": "size_t ParallelNode::successThreshold() const{\n\t  size_t success_threshold = success_threshold_;\n  if (success_threshold < 0) {\n    success_threshold = children_nodes_.size() + success_threshold;\n  }\n  return static_cast<size_t>(success_threshold);\n}", "CodeBleu_score": 50.60253124995347}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n        auto now = std::chrono::system_clock::now();\n        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - lastHeartbeatTime).count();\n\n        if (elapsed > heartbeatTimeout && isHeartbeatActive) {\n            isHeartbeatActive = false;\n            enableAllHooks(false);\n        }\n    }\n}", "CodeBleu_score": 48.73971741895991}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        auto now = std::chrono::system_clock::now();\n        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - lastHeartbeat);\n        if (elapsed.count() > 1000) {\n            std::cout << \"Heartbeat lost\" << std::endl;\n            enableAllHooks(false);\n        } else {\n            std::cout << \"Heartbeat active\" << std::endl;\n            enableAllHooks(true);\n        }\n    }\n}", "CodeBleu_score": 47.7831823220918}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n    if (now - lastHeartbeatTime > std::chrono::milliseconds(500)) {\n      enableAllHooks(false);\n    }\n  }\n}", "CodeBleu_score": 32.883948145372806}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<std::string> bb_names = BT::splitString(bb_list, ';');\n    nlohmann::json json_result;\n    for (const auto& bb_name : bb_names) {\n        auto it = _p->subtrees.find(bb_name);\n        if (it != _p->subtrees.end()) {\n            auto subtree = it->second.lock();\n            if (subtree) {\n                nlohmann::json json_bb = ExportBlackboardToJSON(*subtree->blackboard());\n                json_result[bb_name] = json_bb;\n            }\n        }\n    }\n    std::vector<uint8_t> msgpack_result = nlohmann::json::to_msgpack(json_result);\n    return msgpack_result;\n}", "CodeBleu_score": 58.844087429013115}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> output;\n  std::vector<std::string> blackboard_names = BT::splitString(bb_list, ';');\n  nlohmann::json j_output;\n\n  for (const auto& bb_name : blackboard_names) {\n    auto it = _p->subtrees.find(bb_name);\n    if (it != _p->subtrees.end()) {\n      auto subtree_locked = it->second.lock();\n      if (subtree_locked) {\n        nlohmann::json j_bb = ExportBlackboardToJSON(subtree_locked->blackboard);\n        j_output[bb_name] = j_bb;\n      }\n    }\n  }\n\n  nlohmann::json::to_msgpack(j_output, output);\n  return output;\n}", "CodeBleu_score": 58.90088909963911}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<std::string> bb_names = BT::splitString(bb_list, ';');\n    nlohmann::json j_array = nlohmann::json::array();\n\n    for (const auto& bb_name : bb_names) {\n        auto it = _p->subtrees.find(bb_name);\n        if (it != _p->subtrees.end()) {\n            auto subtree = it->second.lock();\n            if (subtree) {\n                nlohmann::json j_bb = ExportBlackboardToJSON(*subtree->blackboard());\n                j_array.push_back(j_bb);\n            }\n        }\n    }\n\n    nlohmann::json j_msg = nlohmann::json::object();\n    j_msg[\"blackboards\"] = j_array;\n    std::vector<uint8_t> buffer = nlohmann::json::to_msgpack(j_msg);\n    return buffer;\n}", "CodeBleu_score": 54.73651300718046}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::unique_lock<std::mutex> lk(mutex_);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  auto node = it->second.lock();\n  if (!node) {\n    return false;\n  }\n  auto hook = getHook(node);\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk_hook(hook->mutex);\n  if (hook->mode == HookMode::BREAKPOINT) {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->wakeup.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 63.21582963467816}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::unique_lock<std::mutex> lk(_p->nodes_mtx);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  auto node = it->second.lock();\n  if (!node) {\n    return false;\n  }\n  auto hook = node->getHook();\n  if (!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk_hook(hook->mtx);\n  if (hook->mode == HookMode::BREAKPOINT) {\n    hook->desired_status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->wakeup.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 65.20273540006973}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  std::unique_lock<std::mutex> lk(mutex_);\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if (it == _p->nodes_by_uid.end()) {\n    return false;\n  }\n  auto hook = it->second.lock();\n  if (!hook) {\n    return false;\n  }\n  lk.unlock();\n  if (hook->mode == NodeMode::BREAKPOINT) {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->wakeup.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 60.24548496992237}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t    if (status() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n        // \u542f\u52a8\u4e00\u4e2a\u65b0\u7684\u7ebf\u7a0b\u6765\u6267\u884c tick \u51fd\u6570\n        std::async(std::launch::async, [this]() {\n            try {\n                // \u6267\u884c tick \u51fd\u6570\n                tick();\n                // \u5982\u679c tick \u51fd\u6570\u6ca1\u6709\u88ab\u6302\u8d77\uff0c\u5219\u66f4\u65b0\u8282\u70b9\u72b6\u6001\u4e3a SUCCESS\n                if (!halt_requested_) {\n                    setStatus(NodeStatus::SUCCESS);\n                }\n            }\n            catch (std::exception& exc) {\n                // \u6355\u83b7\u5f02\u5e38\u5e76\u8bb0\u5f55\u9519\u8bef\u65e5\u5fd7\n                BT_ROS_ERROR(\"ThreadedAction [%s]: exception from async thread: %s\", name().c_str(), exc.what());\n                setStatus(NodeStatus::IDLE);\n            }\n        });\n    }\n    // \u68c0\u67e5\u662f\u5426\u6709\u5b58\u50a8\u7684\u5f02\u5e38\uff0c\u5982\u679c\u6709\u5219\u91cd\u65b0\u629b\u51fa\u5f02\u5e38\n    if (std::current_exception()) {\n        std::rethrow_exception(std::current_exception());\n    }\n    // \u8fd4\u56de\u8282\u70b9\u72b6\u6001\n    return status();\n}", "CodeBleu_score": 45.88120904904262}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status() == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    // resetting the exception_ptr\n    exception_ptr_ = std::exception_ptr{};\n    // creating a new thread to execute the tick\n    thread_ = std::async(std::launch::async, [this]() {\n      try {\n        tick();\n        if (!halt_requested_) {\n          setStatus(NodeStatus::SUCCESS);\n        }\n      } catch (...) {\n        exception_ptr_ = std::current_exception();\n        setStatus(NodeStatus::IDLE);\n      }\n    });\n  }\n  // check if the thread completed\n  if (thread_.valid() && thread_.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {\n    // if an exception occurred, rethrow it\n    if (exception_ptr_) {\n      std::rethrow_exception(exception_ptr_);\n    }\n    // if no exception occurred, return the status of the node\n    return status();\n  }\n  // if the thread is still running, return RUNNING\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 51.17892717783911}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  if (status() == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    auto future = std::async(std::launch::async, [this]() {\n      try {\n        tick();\n      }\n      catch (...) {\n        halt_requested_.store(true);\n        emitWakeUpSignal();\n        throw;\n      }\n      if (!halt_requested_) {\n        setStatus(NodeStatus::IDLE);\n      }\n    });\n    future.get();\n  }\n\n  std::exception_ptr exception_ptr;\n  try {\n    exception_ptr = std::current_exception();\n  }\n  catch (...) {\n    exception_ptr = std::current_exception();\n  }\n  if (exception_ptr) {\n    std::rethrow_exception(exception_ptr);\n  }\n\n  return status();\n}", "CodeBleu_score": 47.739089251379475}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto print_recursively = [&stream](const TreeNode* node, int indent) {\n        for (int i = 0; i < indent; i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n\n        if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children()) {\n                print_recursively(child, indent + 1);\n            }\n        } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            print_recursively(decorator->child(), indent + 1);\n        }\n    };\n\n    stream << std::endl;\n    print_recursively(root_node, 0);\n    stream << std::endl;\n}", "CodeBleu_score": 61.00835079929531}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    // lambda function to handle the recursive printing\n    std::function<void(const TreeNode*, int)> printTreeRecursively;\n    printTreeRecursively = [&printTreeRecursively, &stream](const TreeNode* node, int indent) {\n        for (int i = 0; i < indent; i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n\n        if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children()) {\n                printTreeRecursively(child, indent + 1);\n            }\n        } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            printTreeRecursively(decorator->child(), indent + 1);\n        }\n    };\n\n    // print the tree structure\n    stream << \"----------------\" << std::endl;\n    printTreeRecursively(root_node, 0);\n    stream << \"----------------\" << std::endl;\n}", "CodeBleu_score": 66.23698155661297}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    static const char* g_indent = \"    \";\n\n    std::function<void(const TreeNode*, int)> printRecursively;\n    printRecursively = [&printRecursively, &stream](const TreeNode* node, int indent) {\n        for (int i = 0; i < indent; i++) {\n            stream << g_indent;\n        }\n        stream << node->name() << std::endl;\n        if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n            for (const auto& child : control->children()) {\n                printRecursively(child, indent + 1);\n            }\n        } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n            printRecursively(decorator->child(), indent + 1);\n        }\n    };\n\n    stream << \"----------------\" << std::endl;\n    printRecursively(root_node, 0);\n    stream << \"----------------\" << std::endl;\n}", "CodeBleu_score": 65.61293707849185}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"Null node in applyRecursiveVisitor\");\n  }\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 74.71406408727863}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"A DecoratorNode must have either a child or a tree root\");\n  }\n  visitor(node);\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  }\n  else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 76.44465603550881}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"It is not possible to visit a null node\");\n  }\n\n  visitor(node);\n\n  const ControlNode* control = dynamic_cast<const ControlNode*>(node);\n  if (control) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  }\n\n  const DecoratorNode* decorator = dynamic_cast<const DecoratorNode*>(node);\n  if (decorator) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 68.09526764683294}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (_p->builders.count(manifest.registration_ID)) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                \"] already registered\");\n  }\n  _p->builders.insert({manifest.registration_ID, builder});\n  _p->manifests.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 65.49628457532725}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  auto it = _p->builders.find(manifest.registration_ID);\n  if (it != _p->builders.end()) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID, \"] already registered\");\n  }\n  _p->builders.insert({manifest.registration_ID, builder});\n  _p->manifests.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 87.21959109206334}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (auto it = _p->builders.find(manifest.registration_ID);\n      it != _p->builders.end()) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                \"] already registered\");\n  }\n  _p->builders.insert({manifest.registration_ID, builder});\n  _p->manifests.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 80.08211256641043}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = NodeType::ACTION;\n  manifest.ports = std::move(ports);\n  manifest.simple_action_ID = ID;\n\n  registerBuilder(manifest, std::move(builder));\n}", "CodeBleu_score": 62.71411046532489}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n  };\n  TreeNodeManifest manifest = {NodeType::ACTION, ID, std::move(ports)};\n  registerBuilder(manifest, std::move(builder));\n}", "CodeBleu_score": 69.22113250181597}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t    NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n    };\n    TreeNodeManifest manifest = {NodeType::ACTION, ID, std::move(ports)};\n    registerBuilder(manifest, std::move(builder));\n}", "CodeBleu_score": 70.08270994130513}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backup;\n    backup.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        auto new_bb = Blackboard::create();\n        subtree->blackboard->cloneInto(new_bb);\n        backup.push_back(std::move(new_bb));\n    }\n    return backup;\n}", "CodeBleu_score": 58.57388611106282}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n  for (const auto& subtree : tree.subtrees) {\n    auto bb = Blackboard::create();\n    subtree->blackboard->cloneInto(*bb);\n    backup.push_back(bb);\n  }\n  return backup;\n}", "CodeBleu_score": 61.54922317557576}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.subtrees.size());\n\n  for (const auto& subtree : tree.subtrees) {\n    auto new_bb = Blackboard::create();\n    subtree->blackboard->cloneInto(new_bb);\n    backup.push_back(std::move(new_bb));\n  }\n\n  return backup;\n}", "CodeBleu_score": 59.962931737241895}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor.value()->execute(env);\n}", "CodeBleu_score": 74.35989961401633}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (executor) {\n        return executor.value()->execute(env);\n    } else {\n        return nonstd::make_unexpected(executor.error());\n    }\n}", "CodeBleu_score": 83.81912417092532}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if (!executor) {\n    return nonstd::make_unexpected(executor.error());\n  }\n  return executor.value()->execute(env);\n}", "CodeBleu_score": 72.74294157005143}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n\n    if (handle_) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle_) {\n        std::string error_message = dlerror();\n        throw RuntimeError(\"Failed to load library: \" + error_message);\n    }\n\n    path_ = path;\n}", "CodeBleu_score": 61.173495914778385}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n\n    if (handle) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n\n    this->path = path;\n}", "CodeBleu_score": 52.073417352983256}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n    if (library_ != nullptr) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    library_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (library_ == nullptr) {\n        std::string error_message = dlerror();\n        throw RuntimeError(\"Failed to load library: \" + error_message);\n    }\n    path_ = path;\n}", "CodeBleu_score": 58.10810555354185}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n\n    const auto first_non_space = str.find_first_not_of(' ');\n    if (first_non_space == StringView::npos) {\n        return false;\n    }\n    const auto last_non_space = str.find_last_not_of(' ');\n    if (last_non_space == StringView::npos) {\n        return false;\n    }\n    const auto stripped = str.substr(first_non_space, last_non_space - first_non_space + 1);\n    if (stripped.empty()) {\n        return false;\n    }\n\n    if (stripped.front() != '{' || stripped.back() != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    }\n\n    return true;\n}", "CodeBleu_score": 38.407599918351856}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n\n  StringView stripped = strip(str);\n\n  if (stripped.front() != '{' || stripped.back() != '}') {\n    return false;\n  }\n\n  if (stripped_pointer) {\n    *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n  }\n\n  return true;\n}", "CodeBleu_score": 24.478044656196257}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n\n  StringView stripped = strip(str);\n\n  if (stripped.front() == '{' && stripped.back() == '}') {\n    if (stripped_pointer) {\n      *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    }\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 25.290804006953003}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  //Bresenham Ray-Tracing\n  double line_cost = 0.0;\n  double point_cost = -1.0;\n\n  for( LineIterator line( x0, y0, x1, y1 ); line.isValid(); line.advance() )\n  {\n    point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n\n    if(point_cost < 0)\n      return point_cost;\n\n    if(line_cost < point_cost)\n      line_cost = point_cost;\n  }\n\n  return line_cost;\n}", "CodeBleu_score": 99.9292786893785}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t  // Bresenham Ray-Tracing\n  int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n  int dy = abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n  int err = dx - dy, e2, x2, y2;\n  double line_cost = 0.0;\n  double point_cost = -1.0;\n\n  while (true) {\n    point_cost = pointCost(x0, y0); // Score the current point\n\n    if (point_cost < 0)\n      return point_cost;\n\n    if (x0 == x1 && y0 == y1)\n      break;\n    e2 = err;\n    if (e2 > -dx) {\n      err -= dy;\n      x0 += sx;\n    }\n    if (e2 < dy) {\n      err += dx;\n      y0 += sy;\n    }\n  }\n\n  return line_cost;\n}", "CodeBleu_score": 51.67898001937916}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    //Bresenham Ray-Tracing\n    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    for(LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance()) {\n        point_cost = pointCost(line.getX(), line.getY()); //Score based on the distance from an obstacle\n\n        if(line_cost < 0) {\n            return line_cost;\n        }\n\n        if(point_cost < 0) {\n            line_cost = point_cost;\n        }\n        else if(line_cost < point_cost) {\n            line_cost = point_cost;\n        }\n    }\n\n    return line_cost;\n}", "CodeBleu_score": 73.48394986769516}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses.resize(path.size());\n\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 83.77730789736049}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    if (path.empty()) {\n        return;\n    }\n\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n\n    gui_path.poses.resize(path.size());\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    pub.publish(gui_path);\n}", "CodeBleu_score": 81.89011914743215}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    if (path.empty()) {\n        return;\n    }\n\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n    gui_path.poses.resize(path.size());\n\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    pub.publish(gui_path);\n}", "CodeBleu_score": 81.89011914743215}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n    fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n    fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}", "CodeBleu_score": 98.94400169988755}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}", "CodeBleu_score": 98.48708768338908}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}", "CodeBleu_score": 98.48708768338908}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t    if (setup_ && restore_defaults) {\n        config = default_limits_;\n    }\n    if (!setup_) {\n        default_limits_ = config;\n        setup_ = true;\n    }\n    boost::mutex::scoped_lock l(limits_configuration_mutex_);\n    current_limits_ = config;\n}", "CodeBleu_score": 81.53341883452798}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup && restore_defaults) {\n    config = default_limits_;\n  }\n  if (!setup) {\n    default_limits_ = config;\n    setup = true;\n  }\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = LocalPlannerLimits(config);\n}", "CodeBleu_score": 90.62422122856519}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup && restore_defaults) {\n    config = default_limits_;\n    config.restore_defaults = false;\n  }\n  if (!setup) {\n    default_limits_ = config;\n    default_limits_.restore_defaults = false;\n    setup = true;\n  }\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 73.18263896426397}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = (unsigned int) costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_dist = obstacleCosts;\n    return false;\n  } else if (cell_cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_dist = unreachableCellCosts;\n    return false;\n  }\n\n  double new_target_dist = current_cell->target_dist + 1;\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n  }\n  return true;\n}", "CodeBleu_score": 72.3449037064768}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = (unsigned int)costmap.getCost(check_cell->x, check_cell->y);\n  if (cell_cost >= costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_dist = obstacleCosts;\n    return false;\n  } else if (cell_cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_dist = costs_[COST_OBS];\n    return false;\n  }\n  double new_target_dist = current_cell->target_dist + distanceLookup_[cell_cost];\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 67.01195128943316}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_dist = obstacleCosts();\n    return false;\n  } else if (cell_cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = unreachableCellCosts();\n    return false;\n  } else {\n    unsigned int new_target_dist = current_cell->target_dist + 1;\n    if (new_target_dist < check_cell->target_dist) {\n      check_cell->target_dist = new_target_dist;\n    }\n    return true;\n  }\n}", "CodeBleu_score": 74.5120782957691}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scaling_factor = getScalingFactor(traj, scaling_speed_, num_scaling_timesteps_);\n\n  if (footprint_spec_.size() == 0) {\n    // footprint empty... then we may as well just return zero\n    return 0.0;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double px = traj.getPoint(i).pose.position.x;\n    double py = traj.getPoint(i).pose.position.y;\n    double pth = traj.getPoint(i).pose.orientation.z;\n\n    double footprint_cost = footprintCost(px, py, pth, footprint_spec_, inscribed_radius_, circumscribed_radius_);\n\n    if (footprint_cost < 0) {\n      return -9;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost * scaling_factor;\n}", "CodeBleu_score": 60.59229821904361}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_scaling_factor_);\n  if (scale < 0) {\n    return -9;\n  }\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty, maybe missing call to setFootprint()?\");\n    return -9;\n  }\n\n  unsigned int i;\n  for (i = 0; i < traj.getPointsSize(); ++i) {\n    double px = traj.getPoint(i).pose.position.x;\n    double py = traj.getPoint(i).pose.position.y;\n    double pth = traj.getPoint(i).pose.orientation.z;\n\n    double f_cost = footprintCost(px, py, pth);\n\n    if (f_cost < 0) {\n      return -9;\n    }\n\n    if (sum_scores_) {\n      cost += f_cost;\n    } else {\n      cost = std::max(cost, f_cost);\n    }\n  }\n  return scale * cost;\n}", "CodeBleu_score": 66.26115332598494}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, scaling_factor_);\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty, maybe missing call to setFootprint()?\");\n    return -9;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double px = traj.getPointPx(i), py = traj.getPointPy(i), pth = traj.getPointPth(i);\n\n    double f_cost = footprintCost(px, py, pth, footprint_spec_, inscribed_radius_, circumscribed_radius_);\n\n    if (f_cost < 0) {\n      return -5;\n    }\n\n    if (sum_scores_) {\n      cost += f_cost;\n    } else {\n      cost = std::max(cost, f_cost);\n    }\n  }\n  return scale * cost;\n}", "CodeBleu_score": 71.9826306917497}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    //check if the plugin initialized\n    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return -1.0;\n    }\n\n    //get the oriented footprint of the robot\n    std::vector<geometry_msgs::Point> oriented_footprint;\n    geometry_msgs::Point robot_position;\n    robot_position.x = x;\n    robot_position.y = y;\n\n    //get the oriented footprint of the robot\n    world_model->getOrientedFootprint(robot_position, th, footprint_spec, oriented_footprint);\n\n    //set the cost of the footprint to zero\n    double footprint_cost = 0.0;\n\n    //get the number of points in the footprint\n    unsigned int cell_x, cell_y;\n\n    //declare variables\n    double line_cost = 0.0;\n    double footprint_x, footprint_y, line_length;\n    double scaled_line_length;\n    double p1_x, p1_y, p2_x, p2_y;\n\n    //if the footprint has two points\n    if (footprint_spec.size() == 2) {\n        //get the first point\n        geometry_msgs::Point first_point = footprint_spec[0];\n        //get the second point\n        geometry_msgs::Point second_point = footprint_spec[1];\n        //get the x and y coordinates of the first point\n        p1_x = first_point.x;\n        p1_y = first_point.y;\n        //get the x and y coordinates of the second point\n        p2_x = second_point.x;\n        p2_y = second_point.y;\n\n        //calculate the length of the line\n        line_length = distance(p1_x, p1_y, p2_x, p2_y);\n        //calculate the scaled length of the line\n        scaled_line_length = line_length * scale;\n\n        //calculate the cost of the line\n        line_cost = lineCost(p1_x, p", "CodeBleu_score": 45.67884684904695}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n  //check if the plugin initialized\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized, please call initialize() to use the planner\");\n    return -1.0;\n  }\n\n  //get the angle of the robot\n  double cos_th = cos(th);\n  double sin_th = sin(th);\n  //get the origin of the costmap\n  double origin_x = costmap->getOriginX();\n  double origin_y = costmap->getOriginY();\n\n  //scale the footprint\n  geometry_msgs::Point new_pt;\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    new_pt.x = x + (footprint_spec[i].x * cos_th - footprint_spec[i].y * sin_th) * scale;\n    new_pt.y = y + (footprint_spec[i].x * sin_th + footprint_spec[i].y * cos_th) * scale;\n    scaled_footprint.push_back(new_pt);\n  }\n\n  //now we really have to lay down the footprint in the costmap grid\n  int x0, x1, y0, y1;\n  //we need to compute the bounding box of the footprint on the grid\n  costmap->worldToMapEnforceBounds(x, y, x0, y0);\n  costmap->worldToMapEnforceBounds(x + footprint_spec[0].x * scale, y + footprint_spec[0].y * scale, x1, y1);\n  x0 = std::min(x0, x1);\n  x1 = std::max(x0, x1);\n  y0 = std::min(y0, y1);\n  y1 = std::max(y0, y1);\n\n  //we want to check line segments along the footprint of the robot, so we need to know which cells we intersect\n  std::vector<base_local_planner::Position2DInt> footprint_positions;\n  //we'll start from the", "CodeBleu_score": 55.98214121822457}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    if( footprint_spec.size() == 0 ) {\n        return -6.0;\n    }\n\n    double cos_th = cos(th);\n    double sin_th = sin(th);\n    std::vector<geometry_msgs::Point> oriented_footprint;\n    for(unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        geometry_msgs::Point new_pt;\n        new_pt.x = x + (footprint_spec[i].x * cos_th - footprint_spec[i].y * sin_th) * scale;\n        new_pt.y = y + (footprint_spec[i].x * sin_th + footprint_spec[i].y * cos_th) * scale;\n        oriented_footprint.push_back(new_pt);\n    }\n\n    geometry_msgs::Point robot_position;\n    robot_position.x = x;\n    robot_position.y = y;\n\n    //now we really have to lay down the footprint in the costmap grid\n    unsigned int cell_x, cell_y;\n\n    //we'll make sure that the footprint specifies a polygon\n    //that is fully contained in the map grid\n    std::vector<geometry_msgs::Point> full_footprint = oriented_footprint;\n    double wx, wy;\n\n    //get the cell coord of the center point of the robot\n    if( ! costmap->worldToMap(x, y, cell_x, cell_y) ) {\n        return -7.0;\n    }\n\n    //if number of points in the footprint is less than 3, we'll just assume a circular robot\n    if( oriented_footprint.size() < 3 ) {\n        unsigned char cost = costmap->getCost(cell_x, cell_y);\n        //if( cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE ) {\n        if( cost == LETHAL_OBSTACLE || cost == INSCRIBED_INFLATED_OBSTACLE || cost == NO_INFORMATION ) {\n            return -5.0;\n", "CodeBleu_score": 63.63926967330124}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    if (odom_topic == odom_topic_) {\n        return;\n    }\n    odom_topic_ = odom_topic;\n    if (odom_topic_.empty()) {\n        odom_sub_.shutdown();\n    } else {\n        odom_sub_ = nh_.subscribe(odom_topic_, 10, &OdometryHelperRos::odomCallback, this);\n    }\n}", "CodeBleu_score": 44.655544434913985}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.90579232493761}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t    if (odom_topic == odom_topic_) {\n        return;\n    }\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n        odom_sub_ = nh_.subscribe(odom_topic_, 10, &OdometryHelperRos::odomCallback, this);\n    } else {\n        odom_sub_.shutdown();\n    }\n}", "CodeBleu_score": 48.44013705166019}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t    float distance = (pos - prev).squaredNorm();\n    if (distance > distance_squared_reset_threshold_) {\n        reset_oscillation_flags();\n    }\n}", "CodeBleu_score": 20.96828192613831}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  float distance = (pos - prev).squaredNorm();\n\n  float squaredRotation = Eigen::Quaternionf(pos.normalized(), prev.normalized()).squaredNorm();\n\n  if (distance > oscillation_distance_reset_threshold_sqr_ || squaredRotation > oscillation_angle_reset_threshold_sqr_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 33.82683257915498}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  // Calculate the squared distance between the current and previous positions\n  float sq_dist = (pos - prev).squaredNorm();\n\n  // Calculate the angular difference between the current and previous positions\n  float angular_diff = std::acos(pos.dot(prev) / (pos.norm() * prev.norm()));\n\n  // If the squared distance exceeds a threshold or the angular difference is greater than a set angle, reset the oscillation flags\n  if (sq_dist > reset_dist_sq_ || angular_diff > reset_angle_) {\n    prev_ = pos;\n    sq_dist_ = 1e10;\n    return;\n  }\n\n  // Update the squared distance and previous position\n  sq_dist_ = sq_dist;\n  prev_ = pos;\n}", "CodeBleu_score": 41.17546640832407}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    // Determine the grid coordinates of the point\n    int x = (int)floor(pt.x / resolution_);\n    int y = (int)floor(pt.y / resolution_);\n\n    // Check if the coordinates are outside the grid bounds\n    if (x < 0 || x >= width_ || y < 0 || y >= height_) {\n        return;\n    }\n\n    // Calculate the grid index\n    int pt_index = x + y * width_;\n\n    // Check if the point is too close to its nearest neighbor\n    if (!cells_[pt_index].empty()) {\n        float nearest_dist = std::numeric_limits<float>::max();\n        for (const auto& neighbor : cells_[pt_index]) {\n            float dist = distance(pt, neighbor);\n            if (dist < nearest_dist) {\n                nearest_dist = dist;\n            }\n        }\n        if (nearest_dist < nearestNeighborDistance_) {\n            return;\n        }\n    }\n\n    // Insert the point into the corresponding cell\n    cells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 43.78769919070742}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // Convert point to grid coordinates\n  std::vector<int> grid_coords = pointToGridCoords(pt);\n\n  // Check if point is outside grid bounds\n  if (grid_coords[0] < 0 || grid_coords[0] >= grid_width_ ||\n      grid_coords[1] < 0 || grid_coords[1] >= grid_height_) {\n    return;\n  }\n\n  // Check if point is too close to its nearest neighbor\n  if (nearestNeighborDistance(grid_coords) < min_distance_) {\n    return;\n  }\n\n  // Calculate grid index\n  int grid_index = grid_coords[0] + grid_coords[1] * grid_width_;\n\n  // Insert point into corresponding cell\n  cells_[grid_index].push_back(pt);\n}", "CodeBleu_score": 43.86026385157378}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  // Convert the point to grid coordinates\n  std::vector<int> gridCoords = pointToGridCoords(pt);\n\n  // Check if the point is outside the grid bounds\n  if (!isValidGridCoords(gridCoords)) {\n    return;\n  }\n\n  // Check if the point is too close to its nearest neighbor\n  if (isTooCloseToNearestNeighbor(pt, gridCoords)) {\n    return;\n  }\n\n  // Calculate the grid index\n  int pt_index = gridCoordsToIndex(gridCoords);\n\n  // Insert the point into the corresponding cell\n  cells_[pt_index].push_back(pt);\n}", "CodeBleu_score": 46.81588314028103}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel;\n    new_vel.setZero();\n    for (int i = 0; i < 3; i++) {\n        if (vel[i] < sample_target_vel[i]) {\n            new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n        } else {\n            new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 90.11487348356324}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n  Eigen::Vector3f new_vel;\n  new_vel.setZero();\n\n  for (int i = 0; i < 3; i++) {\n    if (acclimits[i] == 0.0)\n      continue;\n\n    if (sample_target_vel[i] > vel[i])\n      new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n    else if (sample_target_vel[i] < vel[i])\n      new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n    else\n      new_vel[i] = sample_target_vel[i];\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 76.55750544434252}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t  Eigen::Vector3f new_vel;\n  new_vel.setZero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] < vel[i] - acclimits[i] * dt) {\n      new_vel[i] = vel[i] - acclimits[i] * dt;\n    } else if (sample_target_vel[i] > vel[i] + acclimits[i] * dt) {\n      new_vel[i] = vel[i] + acclimits[i] * dt;\n    } else {\n      new_vel[i] = sample_target_vel[i];\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 71.09324504657967}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  int x_i = cell_x;\n  int y_i = cell_y;\n  int x_g = x;\n  int y_g = y;\n  double heading_g = heading;\n  int x_c = x_i;\n  int y_c = y_i;\n  double heading_c = heading_g;\n  int x_d = x_g - x_c;\n  int y_d = y_g - y_c;\n  double heading_d = atan2(y_d, x_d);\n  double heading_diff = angles::shortest_angular_distance(heading_c, heading_d);\n  return fabs(heading_diff);\n}", "CodeBleu_score": 28.05403092581247}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  int x0, y0, x1, y1;\n  costmap_.mapToWorld(cell_x, cell_y, x0, y0);\n  costmap_.worldToMap(x, y, x1, y1);\n  int dx = x1 - x0;\n  int dy = y1 - y0;\n\n  double angle_to_goal = atan2(dy, dx);\n  double angle_diff = angles::shortest_angular_distance(heading, angle_to_goal);\n\n  for (int i = global_plan_.size() - 1; i >= 0; --i) {\n    double gx = global_plan_[i].pose.position.x;\n    double gy = global_plan_[i].pose.position.y;\n    costmap_.worldToMap(gx, gy, x1, y1);\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n\n    double distance_to_goal = hypot(dx, dy);\n    if (distance_to_goal < carrot_distance_) {\n      return DBL_MAX;\n    }\n\n    double angle_to_goal = atan2(dy, dx);\n    double angle_diff = angles::shortest_angular_distance(heading, angle_to_goal);\n\n    if (fabs(angle_diff) <= heading_lookahead_) {\n      return fabs(angle_diff);\n    }\n  }\n\n  return DBL_MAX;\n}", "CodeBleu_score": 57.64362547738114}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // Iterate through the global plan in reverse\n  for (int i = global_plan_.size() - 1; i >= 0; --i) {\n    // Convert the goal cell coordinates to world coordinates\n    double x_goal = global_plan_[i].pose.position.x;\n    double y_goal = global_plan_[i].pose.position.y;\n\n    // Check if the goal point is within the costmap\n    if (costmap_.worldToMap(x_goal, y_goal, cell_x, cell_y)) {\n      // Check if there is a clear line of sight from the robot's current cell to the goal point\n      if (lineCost(cell_x, cell_y) < 0) {\n        // Calculate the direction to the goal point\n        double angle_to_goal = atan2(y_goal - y, x_goal - x);\n\n        // Calculate the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n        return fabs(angles::shortest_angular_distance(heading, angle_to_goal));\n      }\n    }\n  }\n\n  // If no valid point is found, return DBL_MAX\n  return DBL_MAX;\n}", "CodeBleu_score": 60.34158004375318}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double v_mag = hypot(vx_samp, vy_samp);\n  double lin_vel = v_mag;\n  double ang_vel = fabs(vtheta_samp);\n  double vel_ratio;\n  if (lin_vel < 1e-06) {\n    vel_ratio = 0.0;\n  }\n  else {\n    vel_ratio = ang_vel / lin_vel;\n  }\n  if (vel_ratio < 1e-06) {\n    vel_ratio = 0.0;\n  }\n\n  if (lin_vel == 0.0) {\n    ROS_WARN(\"Trajectory %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %", "CodeBleu_score": 31.799603440658565}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double v_mag = hypot(vx, vy);\n  double x_vel = vx_samp * cos(theta) + vy_samp * sin(theta) + v_mag * cos(vtheta_samp);\n  double y_vel = vx_samp * sin(theta) + vy_samp * cos(theta) + v_mag * sin(vtheta_samp);\n  double theta_vel = vtheta_samp;\n\n  double cost = scoreTrajectory(x, y, theta, x_vel, y_vel, theta_vel);\n\n  if (cost < 0) {\n    ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp,\n        vtheta_samp, cost);\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 66.97972383822437}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t  double vmag = hypot(vx, vy);\n  double vsamples[3];\n  vsamples[0] = vx_samp;\n  vsamples[1] = vy_samp;\n  vsamples[2] = vtheta_samp;\n\n  double costs[3];\n  bool valid = scoreTrajectory(x, y, theta, vx, vy, vtheta, vmag, vsamples, costs);\n  if (!valid) {\n    ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f %f %f\",\n        vx_samp, vy_samp, vtheta_samp,\n        costs[0], costs[1], costs[2]);\n  }\n  return valid;\n}", "CodeBleu_score": 60.39054242818436}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The global_costmap_ and local_costmap_ must be set before runBehavior is called\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside the area instead of outside\");\n  } else {\n    ROS_WARN(\"Clearing outside the area instead of inside\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_ & GLOBAL_COSTMAP) {\n    global_costmap_->updateMap();\n    global_costmap_->clear();\n    global_costmap_->updateMap();\n  }\n\n  if (affected_maps_ & LOCAL_COSTMAP) {\n    local_costmap_->updateMap();\n    local_costmap_->clear();\n    local_costmap_->updateMap();\n  }\n\n  ROS_DEBUG(\"Clearing costmap took %.2f sec for %s.\", (ros::WallTime::now() - t0).toSec(), name_.c_str());\n}", "CodeBleu_score": 45.68406650151277}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The global_costmap_ and local_costmap_ must be set before runBehavior is called\");\n    return;\n  }\n\n  if (affected_maps_ == \"all\") {\n    if (invert_area_to_clear_) {\n      ROS_WARN(\"Both the local and global costmap will be cleared, but the area to clear will be the inverse of the specified area\");\n    }\n    clear(global_costmap_);\n    clear(local_costmap_);\n  } else if (affected_maps_ == \"global\") {\n    if (invert_area_to_clear_) {\n      ROS_WARN(\"The global costmap will be cleared, but the area to clear will be the inverse of the specified area\");\n    }\n    clear(global_costmap_);\n  } else if (affected_maps_ == \"local\") {\n    if (invert_area_to_clear_) {\n      ROS_WARN(\"The local costmap will be cleared, but the area to clear will be the inverse of the specified area\");\n    }\n    clear(local_costmap_);\n  } else {\n    ROS_ERROR(\"affected_maps_ must be one of all, global, or local. Check yaml file.\");\n    return;\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_ == \"all\" || affected_maps_ == \"global\") {\n    global_costmap_->updateMap();\n  }\n  if (affected_maps_ == \"all\" || affected_maps_ == \"local\") {\n    local_costmap_->updateMap();\n  }\n  ROS_DEBUG(\"Clearing costmap took %.2f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 58.898631093605246}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The global_costmap_ and local_costmap_ must be set before runBehavior is called\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside area\");\n  } else {\n    ROS_WARN(\"Clearing outside area\");\n  }\n\n  ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_ & GLOBAL_COSTMAP) {\n    global_costmap_->updateMap();\n    global_costmap_->clear();\n    if (force_update_) {\n      global_costmap_->updateMap();\n    }\n  }\n  if (affected_maps_ & LOCAL_COSTMAP) {\n    local_costmap_->updateMap();\n    local_costmap_->clear();\n    if (force_update_) {\n      local_costmap_->updateMap();\n    }\n  }\n  ROS_DEBUG(\"Clearing costmaps took %.2f seconds\", (ros::WallTime::now() - t0).toSec());\n}", "CodeBleu_score": 48.929363354822996}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t    PolygonOutlineCells cell_gatherer(*this);\n    for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n        raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n    }\n    if (!polygon.empty()) {\n        unsigned int last_index = polygon.size() - 1;\n        // we also need to close the polygon\n        raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n    }\n    polygon_cells = cell_gatherer.getCells();\n}", "CodeBleu_score": 92.10207300456341}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells cell_gatherer(*this);\n\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n  }\n\n  if (!polygon.empty()) {\n    unsigned int last_index = polygon.size() - 1;\n    // we also need to close the polygon by going from the last point to the first\n    raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n  }\n\n  cell_gatherer.getCells(polygon_cells);\n}", "CodeBleu_score": 93.47545943574347}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells cell_gatherer(*this);\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n  }\n  if (!polygon.empty()) {\n    unsigned int last_index = polygon.size() - 1;\n    // we also need to close the polygon by going from the last point to the first\n    raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n  }\n\n  cell_gatherer.getCells(polygon_cells);\n}", "CodeBleu_score": 93.47545943574347}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t    boost::unique_lock < boost::mutex > lock(*(costmap_->getMutex()));\n    double resolution = costmap_->getResolution();\n    grid_.header.frame_id = \"map\";\n    grid_.header.stamp = ros::Time::now();\n    grid_.info.resolution = resolution;\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n    grid_.info.origin.position.x = costmap_->getOriginX();\n    grid_.info.origin.position.y = costmap_->getOriginY();\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n    grid_.data.clear();\n    unsigned int size = grid_.info.width * grid_.info.height;\n    grid_.data.resize(size);\n\n    unsigned char *data = costmap_->getCharMap();\n    for (unsigned int i = 0; i < size; i++) {\n        grid_.data[i] = cost_translation_table_[data[i]];\n    }\n}", "CodeBleu_score": 71.85592335671538}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock < boost::recursive_mutex > lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = new_header_frame_id_;\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.clear();\n  unsigned int size = grid_.info.width * grid_.info.height;\n  grid_.data.resize(size);\n\n  unsigned char *data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < size; i++) {\n    grid_.data[i] = cost_translation_table_[ data[i] ];\n  }\n}", "CodeBleu_score": 83.24101587930103}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock < boost::mutex > lock(*costmap_->getMutex());\n  double resolution = costmap_->getResolution();\n\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = new_header_frame_id_;\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.clear();\n  unsigned int size = grid_.info.width * grid_.info.height;\n  grid_.data.resize(size);\n\n  unsigned char *data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < size; i++) {\n    grid_.data[i] = cost_translation_table_[ data[i] ];\n  }\n}", "CodeBleu_score": 81.86579487024883}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  std::vector<geometry_msgs::Point> footprint;\n  if (makeFootprintFromString(new_config.footprint, footprint)) {\n    setUnpaddedRobotFootprint(footprint);\n  } else {\n    setRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n  }\n}", "CodeBleu_score": 58.149202448844925}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // first, we need to clear the footprint\n  footprint_.clear();\n\n  // next, we'll update the robot radius\n  if (new_config.footprint != old_config.footprint) {\n    if (makeFootprintFromString(new_config.footprint, footprint_)) {\n      ROS_INFO(\"Read new robot footprint from param server\");\n    } else {\n      ROS_ERROR(\"New robot footprint string is not valid, keeping the previous one.\");\n      footprint_ = old_config.footprint;\n    }\n  }\n\n  if (new_config.robot_radius != old_config.robot_radius) {\n    setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n    ROS_INFO(\"Read new robot radius from param server\");\n  }\n}", "CodeBleu_score": 55.256760839365604}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // first, we'll update the robot footprint\n  if (new_config.footprint != old_config.footprint) {\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n    } else {\n      ROS_ERROR(\"The footprint parameter does not take a valid value.  Footprint will not be set.\");\n    }\n  }\n\n  // next we'll update the robot radius, if it has changed\n  if (new_config.footprint_padding != old_config.footprint_padding) {\n    setFootprintPadding(new_config.footprint_padding);\n  }\n\n  if (new_config.robot_radius != old_config.robot_radius) {\n    setRobotRadius(new_config.robot_radius);\n  }\n}", "CodeBleu_score": 67.59153239089942}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  // get the current pose of the robot\n  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Could not get the robot pose on timer for %s. \"\n                        \"Check to make sure that either the initial pose is set \"\n                        \"or a proper transform is set up between %s and %s\",\n                        name_.c_str(), global_frame_.c_str(), robot_base_frame_.c_str());\n    return;\n  }\n\n  // we'll only update the planner's path if the robot has moved since the last time we updated it\n  if (old_pose_ == new_pose) {\n    return;\n  }\n\n  // update the old pose\n  old_pose_ = new_pose;\n\n  // clear the footprint polygon\n  footprint_.clear();\n\n  // get the footprint of the robot and store it in footprint_\n  if (calculate_footprint_) {\n    footprint_ = robot_footprint_;\n  }\n\n  // transform the footprint polygon to the global frame\n  transformFootprint(new_pose.pose.position.x, new_pose.pose.position.y, new_pose.pose.orientation,\n                     footprint_);\n\n  // unlock the mutex\n  lock_.unlock();\n\n  // call the update function\n  updateMap(new_pose.pose.position.x, new_pose.pose.position.y, new_pose.pose.orientation);\n\n  // lock the mutex\n  lock_.lock();\n}", "CodeBleu_score": 61.012066843795395}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  tf::Stamped<tf::Pose> new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Could not get robot pose, cancelling reconfiguration\");\n    return;\n  }\n\n  if (stop_updates_) return;\n\n  double x = new_pose.getOrigin().x(), y = new_pose.getOrigin().y();\n  double theta = tf::getYaw(new_pose.getRotation());\n  if (fabs(old_pose_.getOrigin().x() - x) < 0.001 && fabs(old_pose_.getOrigin().y() - y) < 0.001 &&\n      fabs(old_pose_.getRotation().z() - theta) < 0.001)\n    return;\n\n  // check if the robot jumps are big enough or it has not moved at all\n  if (fabs(old_pose_.getOrigin().x() - x) < resolution_ || fabs(old_pose_.getOrigin().y() - y) < resolution_ ||\n      fabs(old_pose_.getRotation().z() - theta) < resolution_)\n    return;\n\n  // interpolate a new pose\n  tf::Vector3 new_origin = old_pose_.getOrigin().lerp(new_pose.getOrigin(), 0.5);\n  tf::Matrix3x3 old_basis(old_pose_.getRotation()), new_basis(new_pose.getRotation());\n  tf::Matrix3x3 new_rotation((old_basis.getColumn(0) + new_basis.getColumn(0)) / 2,\n                             (old_basis.getColumn(1) + new_basis.getColumn(1)) / 2,\n                             (old_basis.getColumn(2) + new_basis.getColumn(2)) / 2);\n  tf::Quaternion new_quat;\n  new_rotation.getRotation(new_quat);\n  tf::Stamped<tf::Pose> interpolated_pose(tf::", "CodeBleu_score": 66.37349399655979}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  if (!initialized_) {\n    return;\n  }\n\n  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Could not get the robot pose on the /%s topic. \"\n                           \"The costmap cannot update its configuration\",\n                      robot_base_frame_.c_str());\n    return;\n  }\n\n  if (stop_updates_) {\n    if (!stopped_) {\n      ROS_WARN(\"Movement commands connected to the costmap are now being ignored\");\n      stopped_ = true;\n    }\n    return;\n  }\n\n  if (stopped_) {\n    ROS_INFO(\"Movement commands connected to the costmap are now being accepted\");\n    stopped_ = false;\n  }\n\n  if (robot_stopped_) {\n    // If we are not stopped yet... we need to check if we are\n    if (hypot(old_pose_.pose.position.x - new_pose.pose.position.x,\n             old_pose_.pose.position.y - new_pose.pose.position.y) <=\n        oscillation_distance_) {\n      // Check if the robot has stopped\n      if ((event.current_real - event.last_real).toSec() > oscillation_timeout_) {\n        ROS_WARN(\"Robot appears to have stopped. \"\n                 \"If it's stuck, make sure that the locator is publishing valid data. \"\n                 \"Costmap will now resume updates\");\n        robot_stopped_ = false;\n      }\n    } else {\n      // If the robot has moved again its not stopped\n      old_pose_ = new_pose;\n      robot_stopped_ = false;\n    }\n  } else {\n    // If not stopped, we need to see if we've moved far enough to\n    // consider the robot stopped\n    if (hypot(old_pose_.pose.position.x - new_pose.pose.position.x,\n             old_pose_.pose.position.y - new_pose.pose.position.y) >=\n        oscillation_distance", "CodeBleu_score": 58.422080211367245}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  if (stopped_) {\n    std::list<boost::shared_ptr<Layer> > * plugins = layered_costmap_->getPlugins();\n    for (std::list<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin != plugins->end(); ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n    stop_updates_ = false;\n    initialized_ = true;\n    map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, map_update_frequency_));\n  } else {\n    ROS_ERROR(\"This costmap has already been initialized... doing nothing\");\n  }\n}", "CodeBleu_score": 63.21049168608591}, {"code": "void Costmap2DROS::start(){\n\t  std::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n  // check if we're stopped or just not ready yet\n  if (stopped_) {\n    // if we're stopped we need to re-subscribe to topics\n    for (vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin != plugins->end(); ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n  }\n  //block until the costmap is reinitialized.. meaning one update has been received and sent\n  ROS_DEBUG(\"Costmap2DROS::start() waitForMap\");\n  ros::Rate r(100);\n  ros::NodeHandle n;\n  if (!layered_costmap_->isInitialized()) {\n    //block until the costmap is reinitialized.. meaning one update has been received and sent\n    ros::Rate r(100);\n    while (n.ok() && !layered_costmap_->isInitialized()) {\n      r.sleep();\n    }\n  }\n  map_update_thread_ = new boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, layered_costmap_->getFrequency()));\n}", "CodeBleu_score": 71.18516249748373}, {"code": "void Costmap2DROS::start(){\n\t  std::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n\n  // check if we're stopped or just not initialized\n  if (stopped_) {\n    // we're stopped, so re-subscribe to topics\n    for (vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin != plugins->end();\n         ++plugin) {\n      (*plugin)->activate();\n    }\n\n    stopped_ = false;\n  }\n\n  map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, map_update_frequency_));\n\n  if (stopped_) {\n    // we're not yet running, but we want to be\n    resume();\n  }\n}", "CodeBleu_score": 73.22090029993522}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    if (observation_list_.size() > 0) {\n      observation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n    }\n  } else {\n    ros::Time keep_until = ros::Time::now() - observation_keep_time_;\n    std::list<Observation>::iterator it = observation_list_.begin();\n    while (it != observation_list_.end()) {\n      if ((*it).header.stamp < keep_until) {\n        it = observation_list_.erase(it);\n      } else {\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 52.133979345931834}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t    if (observation_keep_time_ == ros::Duration(0.0)) {\n        observation_list_.erase(std::begin(observation_list_) + 1, std::end(observation_list_));\n        return;\n    }\n\n    for (auto obs = std::begin(observation_list_); obs != std::end(observation_list_);) {\n        if ((last_updated_timestamp_ - obs->header.stamp) > observation_keep_time_) {\n            obs = observation_list_.erase(obs);\n        } else {\n            // We're keeping them in observation time order, so if we find the first valid one, we're done.\n            return;\n        }\n    }\n}", "CodeBleu_score": 44.53428518791342}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    // keep only the most recent observation\n    observation_list_.resize(1);\n  } else {\n    // remove observations that are older than the observation keep time\n    ros::Time now = ros::Time::now();\n    for (ObservationList::iterator it = observation_list_.begin(); it != observation_list_.end(); ) {\n      if ((now - it->header.stamp) > observation_keep_time_) {\n        it = observation_list_.erase(it);\n      } else {\n        ++it;\n      }\n    }\n  }\n}", "CodeBleu_score": 43.297090613396385}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  double start_yaw, end_yaw, d_yaw;\n  start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  d_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  double step = (end_index - start_index) == 0 ? 0.0 : 1.0 / (end_index - start_index);\n  double d_yaw_step = d_yaw * step;\n\n  for (int i = start_index; i <= end_index; ++i) {\n    double angle = start_yaw + i * d_yaw_step;\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 67.0273193081951}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  double start_yaw, end_yaw, cur_yaw, angle_diff;\n  // Get the yaw angles at the start and end indices\n  start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end yaw angles\n  angle_diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Calculate the incremental change in angle for each pose\n  double angle_increment = angle_diff / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index; i <= end_index; i++) {\n    // Calculate the current yaw angle\n    cur_yaw = tf2::getYaw(path[i].pose.orientation) + angle_increment;\n\n    // Set the orientation of the current pose to the updated yaw angle\n    path[i].pose.orientation = tf2::toMsg(tf2::Quaternion(tf2::Vector3(0, 0, 1), cur_yaw));\n  }\n}", "CodeBleu_score": 58.28923394841144}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  double start_yaw, end_yaw, cur_yaw, angle_inc;\n  start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n  if (start_yaw > M_PI) {\n    start_yaw -= 2 * M_PI;\n  }\n  if (end_yaw > M_PI) {\n    end_yaw -= 2 * M_PI;\n  }\n  angle_inc = angles::shortest_angular_distance(start_yaw, end_yaw) / (end_index - start_index);\n  for (int i = start_index; i <= end_index; i++) {\n    cur_yaw = tf2::getYaw(path[i].pose.orientation);\n    if (cur_yaw > M_PI) {\n      cur_yaw -= 2 * M_PI;\n    }\n    cur_yaw += angle_inc;\n    set_angle(&path[i].pose.orientation, cur_yaw);\n  }\n}", "CodeBleu_score": 55.29349815722298}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    makePlan(req.start, req.goal, resp.plan.poses);\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.frame_id = frame_id_;\n\n    if (resp.plan.poses.empty())\n        resp.plan.header.stamp = ros::Time::now();\n\n    return true;\n}", "CodeBleu_score": 39.99136161498769}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    makePlan(req.start, req.goal, resp.plan.poses);\n\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.frame_id = frame_id_;\n\n    if (resp.plan.poses.empty())\n        resp.plan.header.stamp = ros::Time::now();\n\n    return true;\n}", "CodeBleu_score": 39.99136161498769}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    makePlan(req.start, req.goal, resp.plan.poses);\n\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.frame_id = frame_id_;\n\n    if (resp.plan.poses.empty())\n        resp.plan.poses.push_back(req.start);\n    resp.success = !resp.plan.poses.empty();\n    return true;\n}", "CodeBleu_score": 38.91604002018416}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 69.4833654683534}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 69.4833654683534}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    private_nh = ros::NodeHandle(\"~/\" + name);\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 69.4833654683534}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    return false;\n  }\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 50.185779020546825}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < origin_x_ || wy < origin_y_)\n    return false;\n\n  mx = (wx - origin_x_) / resolution_;\n  my = (wy - origin_y_) / resolution_;\n\n  if (mx < size_x_ && my < size_y_)\n    return true;\n\n  return false;\n}", "CodeBleu_score": 40.893829773699785}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    return false;\n  }\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 50.185779020546825}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  //create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  if (!path.empty()) {\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n      gui_path.poses[i] = path[i];\n    }\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 93.80239831199907}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 97.07520516691747}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    // create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = frame_id_;\n        gui_path.header.stamp = ros::Time::now();\n    }\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 94.0913292178291}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message and re-sending to the server.\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 97.91245108335265}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"Received a new goal\");\n  actionlib_msgs::GoalID goal_id;\n  goal_id.stamp = ros::Time::now();\n  goal_id.id = to_string(goal_id.stamp.toNSec());\n  actionlib_msgs::GoalStatus goal_status;\n  goal_status.goal_id = goal_id;\n  goal_status.status = actionlib_msgs::GoalStatus::ACTIVE;\n  action_goal_pub_.publish(goal_status);\n\n  MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal = *goal;\n  action_goal.goal_id = goal_id;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 59.710365715752324}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    ROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message and re-sending to the server.\");\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n\n    action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 97.07532557418959}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  double sq_distance = boost::bind(&MoveSlowAndClear::getSqDistance, this)();\n  if (sq_distance > sq_limited_distance_) {\n    ROS_INFO(\"MoveSlowAndClear: Distance threshold reached.\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 63.825600021704474}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  // Check if we've traveled far enough\n  if (limited_distance_sq_ < current_distance_sq_) {\n    ROS_INFO(\"Moved far enough; removing limit\");\n    // Stop the timer\n    distance_check_timer_.stop();\n    // Join and delete any existing remove limit thread\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    // Start a new thread to remove the speed limit\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n  }\n}", "CodeBleu_score": 57.95222529638}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  // Calculate the squared distance between the robot's current position and the initial position\n  double sq_distance = getSqDistance(initial_x_, initial_y_, current_x_, current_y_);\n  // If the squared distance is greater than the squared limited distance\n  if (sq_distance > sq_limited_distance_) {\n    // Log a message indicating that the robot has moved far enough\n    ROS_INFO(\"Moved far enough; removing speed limit\");\n    // If there is an existing remove limit thread\n    if (remove_limit_thread_) {\n      // Join and delete the remove limit thread\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    // Start a new thread to remove the speed limit\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    // Stop the distance check timer\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 74.74427180134455}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the current global pose of the robot\n  rm::PoseStamped start;\n  getRobotPose(start);\n\n  // Create an empty path vector\n  std::vector<rm::PoseStamped> path;\n\n  // Generate a path from the current pose to the goal pose\n  makePlan(start, *goal, path);\n}", "CodeBleu_score": 57.196559668301774}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Retrieve the current global pose of the robot\n    geometry_msgs::PoseStamped global_pose;\n    getRobotPose(global_pose);\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<geometry_msgs::PoseStamped> path;\n    makePlan(global_pose, *goal, path);\n}", "CodeBleu_score": 73.27134767695445}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the current global pose of the robot\n  geometry_msgs::PoseStamped start;\n  getRobotPose(start);\n\n  // Generate a path from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> path;\n  makePlan(start, *goal, path);\n\n  // Publish the path as a nav_msgs::Path message\n  nav_msgs::Path path_msg;\n  path_msg.header.frame_id = \"map\";\n  path_msg.header.stamp = ros::Time::now();\n  path_msg.poses = path;\n  path_pub_.publish(path_msg);\n}", "CodeBleu_score": 53.43129830524733}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    dji_osdk_ros::GimbalParamSet gimbal_param_set_req;\n    gimbal_param_set_req.request.param_id = param_set.param_id;\n    gimbal_param_set_req.request.value = param_set.value;\n    param_set_client_.call(gimbal_param_set_req);\n}", "CodeBleu_score": 54.52427339684556}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    dji_osdk_ros::GimbalParamSet gimbal_param_set_req;\n    gimbal_param_set_req.request.param_id = param_set.param_id;\n    gimbal_param_set_req.request.param_value = param_set.param_value;\n    this->param_set_client_.call(gimbal_param_set_req);\n}", "CodeBleu_score": 58.00914072378119}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t  dji_osdk_ros::GimbalParamSet gimbal_param_set;\n  gimbal_param_set.request.param_id = param_set.param_id;\n  gimbal_param_set.request.param_value = param_set.param_value;\n  this->param_set_client_.call(gimbal_param_set);\n}", "CodeBleu_score": 58.491393913478284}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t    waitConnectionFromGroundStation();\n    while (1) {\n        pubMsg();\n        accept();\n        decodeMsg();\n        perror();\n        ROS_ERROR();\n        close();\n        exit();\n    }\n}", "CodeBleu_score": 2.6558972235437093}, {"code": "void CommunicationBridge::serverFun(){\n\t    int server_fd, new_socket, valread;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Forcefully attaching socket to the port 8080\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(port);\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *) &address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    if ((new_socket = accept(server_fd, (struct sockaddr *) &address, (socklen_t *) &addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n    while (true) {\n        valread = read(new_socket, buffer, 1024);\n        if (valread > 0) {\n            decodeMsg(buffer, valread);\n            pubMsg();\n        } else if (valread == 0) {\n            ROS_ERROR(\"Received message length is zero or less\");\n            close(new_socket);\n            exit(EXIT_FAILURE);\n        }\n    }\n}", "CodeBleu_score": 55.13854687677706}, {"code": "void CommunicationBridge::serverFun(){\n\t    // Wait for connection from ground station\n    waitConnectionFromGroundStation();\n\n    // Enter loop to accept incoming connections\n    while (true) {\n        // Accept incoming connection\n        accept();\n\n        // Receive data\n        recv();\n\n        // If data is received successfully\n        if (recvMsgLen > 0) {\n            // Decode message\n            decodeMsg();\n\n            // Publish message\n            pubMsg();\n        }\n        // If the received message length is zero or less\n        else {\n            // Log error\n            perror(\"recv failed\");\n\n            // Close socket\n            close();\n\n            // Exit program\n            exit(1);\n        }\n    }\n}", "CodeBleu_score": 10.176879239069615}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (!this->simulation_mode_) {\n    this->uav_basic_->uavCmdPub(uav_cmd);\n  } else {\n    std::map<int, UAVBasic*>::iterator it;\n    it = this->swarm_control_simulation_.find(uav_cmd.id);\n    if (it != this->swarm_control_simulation_.end()) {\n      (*it).second->uavCmdPub(uav_cmd);\n    } else {\n      ROS_ERROR(\"UAV %d not found in swarm_control_simulation_\", uav_cmd.id);\n    }\n  }\n}", "CodeBleu_score": 60.99184382286514}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (this->simulation_mode_) {\n    std::map<int, std::shared_ptr<UAVBasic>>::iterator it;\n    it = this->swarm_control_simulation_.find(uav_cmd.drone_id);\n    if (it != this->swarm_control_simulation_.end()) {\n      (*it).second->uavCmdPub(uav_cmd);\n    } else {\n      std::cout << \"UAV not found in swarm_control_simulation_\" << std::endl;\n    }\n  } else {\n    this->uav_basic_->uavCmdPub(uav_cmd);\n  }\n}", "CodeBleu_score": 60.24792818595355}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (this->simulation_mode_) {\n        std::map<int, UAVBasic*>::iterator it = this->swarm_control_simulation_.find(uav_cmd.id);\n        if (it != this->swarm_control_simulation_.end()) {\n            this->uav_basic_->uavCmdPub((*it).second->uavCmdPub, uav_cmd);\n        }\n    } else {\n        this->uav_basic_->uavCmdPub(this->uav_basic_->uavCmdPub, uav_cmd);\n    }\n}", "CodeBleu_score": 53.53243592002019}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    switch (mode_selection.mode) {\n        case REBOOTNX:\n            system(\"reboot\");\n            break;\n        case EXITNX:\n            system(\"exit\");\n            break;\n        case CREATEMODE:\n            createMode(mode_selection);\n            break;\n        case DELETEMODE:\n            deleteMode(mode_selection);\n            break;\n        default:\n            break;\n    }\n}", "CodeBleu_score": 40.76831388467972}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode == REBOOTNX) {\n        system(\"rebootNX\");\n    } else if (mode_selection.use_mode == EXITNX) {\n        system(\"exitNX\");\n    } else if (mode_selection.use_mode == CREATEMODE) {\n        createMode(mode_selection.mode_name);\n    } else if (mode_selection.use_mode == DELETEMODE) {\n        deleteMode(mode_selection.mode_name);\n    }\n}", "CodeBleu_score": 53.13635792240979}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    // Check if the system is in use mode\n    if (mode_selection.use_mode) {\n        // Call the createMode function with the mode_selection parameter\n        createMode(mode_selection);\n    } else {\n        // Call the deleteMode function with the mode_selection parameter\n        deleteMode(mode_selection);\n    }\n\n    // Check if the mode_selection mode is REBOOTNX\n    if (mode_selection.mode == REBOOTNX) {\n        // Execute the REBOOTNX system command\n        system(\"REBOOTNX\");\n    }\n    // Check if the mode_selection mode is EXITNX\n    else if (mode_selection.mode == EXITNX) {\n        // Execute the EXITNX system command\n        system(\"EXITNX\");\n    }\n}", "CodeBleu_score": 56.965394153502515}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  if (heartbeat_counter == heartbeat_counter_prev) {\n    heartbeat_counter++;\n  } else {\n    heartbeat_counter = 0;\n  }\n\n  if (heartbeat_counter == heartbeat_counter_max) {\n    if (vehicle_type == \"swarm\") {\n      triggerSwarmControl();\n    } else if (vehicle_type == \"UAV\") {\n      triggerUAV();\n    } else if (vehicle_type == \"UGV\") {\n      triggerUGV();\n    }\n    heartbeat_counter = 0;\n  }\n  heartbeat_counter_prev = heartbeat_counter;\n}", "CodeBleu_score": 41.033475737664034}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (heartbeat_count_ == heartbeat_count_prev_) {\n        if (heartbeat_count_ >= heartbeat_attempts_) {\n            if (vehicle_type_ == \"swarm\") {\n                ROS_ERROR_STREAM(\"Communication with swarm lost\");\n                triggerSwarmControl();\n            } else if (vehicle_type_ == \"UAV\") {\n                ROS_ERROR_STREAM(\"Communication with UAV lost\");\n                triggerUAV();\n            } else if (vehicle_type_ == \"UGV\") {\n                ROS_ERROR_STREAM(\"Communication with UGV lost\");\n                triggerUGV();\n            }\n            disconnect_flag_ = true;\n        }\n    } else {\n        heartbeat_count_prev_ = heartbeat_count_;\n        heartbeat_count_ = 0;\n        disconnect_flag_ = false;\n    }\n}", "CodeBleu_score": 45.79138438999904}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  if (time_event.current_real - last_heartbeat_time_ > heartbeat_timeout_) {\n    if (heartbeat_counter_ == heartbeat_attempts_) {\n      heartbeat_counter_ = 0;\n      if (is_swarm_) {\n        triggerSwarmControl();\n      } else if (is_UAV_) {\n        triggerUAV();\n      } else if (is_UGV_) {\n        triggerUGV();\n      }\n    } else {\n      heartbeat_counter_++;\n    }\n  } else {\n    heartbeat_counter_ = 0;\n  }\n}", "CodeBleu_score": 26.51673090318648}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract the drone ID from the message\n    int drone_id = msg->drone_id;\n\n    // Create a MultiBsplines message to be sent via TCP\n    prometheus_msgs::MultiBsplines tcp_msg;\n    tcp_msg.drone_id = drone_id;\n\n    // Iterate over each trajectory in the message\n    for (int i = 0; i < msg->traj.size(); i++) {\n        // Initialize a Bspline struct to store the trajectory data\n        Bspline bspline;\n\n        // Set the Bspline struct's attributes\n        bspline.knots.push_back(msg->traj[i].knots[0]);\n        bspline.knots.push_back(msg->traj[i].knots[1]);\n        bspline.knots.push_back(msg->traj[i].knots[2]);\n        bspline.knots.push_back(msg->traj[i].knots[3]);\n        bspline.knots.push_back(msg->traj[i].knots[4]);\n        bspline.knots.push_back(msg->traj[i].knots[5]);\n        bspline.knots.push_back(msg->traj[i].knots[6]);\n        bspline.knots.push_back(msg->traj[i].knots[7]);\n        bspline.knots.push_back(msg->traj[i].knots[8]);\n        bspline.knots.push_back(msg->traj[i].knots[9]);\n        bspline.knots.push_back(msg->traj[i].knots[10]);\n        bspline.knots.push_back(msg->traj[i].knots[11]);\n        bspline.knots.push_back(msg->traj[i].knot", "CodeBleu_score": 46.8464578275797}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract drone ID from message\n    int drone_id = msg->drone_id;\n\n    // Initialize a Bspline struct for each trajectory\n    Bspline bspline;\n    for (int i = 0; i < msg->traj.size(); i++) {\n        // Set Bspline attributes\n        bspline.knots.clear();\n        bspline.pos_pts.clear();\n        bspline.yaw_pts.clear();\n\n        // Populate Bspline knots, position points, and yaw points\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots.push_back(msg->traj[i].knots[j].toSec());\n        }\n\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts.push_back(\n                Eigen::Vector3d(msg->traj[i].pos_pts[j].x, msg->traj[i].pos_pts[j].y, msg->traj[i].pos_pts[j].z));\n        }\n\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j].toSec());\n        }\n\n        // Encode MultiBsplines data and send via TCP\n        this->communication->encodeMsg(msg);\n        this->communication->sendMsgByTcp(this->communication->getSocket(), this->communication->getSendBuffer(),\n                                          this->communication->getMsgLen());\n    }\n}", "CodeBleu_score": 62.04373938116793}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Check if the message contains any trajectories\n    if (msg->traj.size() == 0) {\n        return;\n    }\n\n    // Create a MultiBsplines message\n    prometheus_msgs::MultiBsplines multi_bsplines;\n\n    // Iterate over each trajectory in the message\n    for (int i = 0; i < msg->traj.size(); i++) {\n        // Extract the drone ID from the trajectory\n        int drone_id = msg->traj[i].drone_id;\n\n        // Create a Bspline struct\n        Bspline bspline;\n\n        // Set the Bspline attributes\n        bspline.knots.push_back(msg->traj[i].start_time.toSec());\n        bspline.knots.push_back(msg->traj[i].end_time.toSec());\n        bspline.knots.push_back(msg->traj[i].end_time.toSec() + 0.1);\n\n        // Populate the Bspline's knots, position points, and yaw points\n        for (int j = 0; j < msg->traj[i].knots.size(); j++) {\n            bspline.knots.push_back(msg->traj[i].knots[j].toSec());\n        }\n\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++) {\n            bspline.pos_pts.push_back(Eigen::Vector3d(msg->traj[i].pos_pts[j].x, msg->traj[i].pos_pts[j].y, msg->traj[i].pos_pts[j].z));\n        }\n\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++) {\n            bspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j].data);\n        }", "CodeBleu_score": 59.10061336968124}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t  // Convert the input message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Compress the point cloud\n  std::stringstream compressed_data;\n  octree_compression.encodePointCloud(cloud, compressed_data);\n\n  // Create a new PointCloud2 message with the compressed data\n  sensor_msgs::PointCloud2 compressed_msg;\n  compressed_msg.header = msg.header;\n  compressed_msg.height = 1;\n  compressed_msg.width = compressed_data.str().size();\n  compressed_msg.is_bigendian = false;\n  compressed_msg.point_step = compressed_data.str().size();\n  compressed_msg.row_step = compressed_data.str().size();\n  compressed_msg.is_dense = true;\n  compressed_msg.data.resize(compressed_data.str().size());\n  std::memcpy(&compressed_msg.data[0], compressed_data.str().data(), compressed_data.str().size());\n\n  // Release dynamically allocated memory\n  cloud.reset();\n\n  return compressed_msg;\n}", "CodeBleu_score": 40.81853310943821}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud\n    std::stringstream compressed_data;\n    octree_compression.encodePointCloud(cloud, compressed_data);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.str().size();\n    compressed_msg.is_bigendian = false;\n    compressed_msg.point_step = sizeof(uint8_t);\n    compressed_msg.row_step = compressed_data.str().size();\n    compressed_msg.is_dense = true;\n    compressed_msg.data.resize(compressed_data.str().size());\n    std::memcpy(&compressed_msg.data[0], compressed_data.str().data(), compressed_data.str().size());\n\n    // Release dynamically allocated memory\n    cloud.reset();\n    compressed_data.str(\"\");\n\n    return compressed_msg;\n}", "CodeBleu_score": 42.24886056317465}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  std::stringstream compressed_data;\n  std::vector<uint8_t> compressed_str;\n  octree_compression.setInputCloud(cloud);\n  octree_compression.encodePointCloud(compressed_str);\n  compressed_data.str(std::string(compressed_str.begin(), compressed_str.end()));\n\n  sensor_msgs::PointCloud2 compressed_msg;\n  compressed_msg.header = msg.header;\n  compressed_msg.height = 1;\n  compressed_msg.width = compressed_str.size();\n  compressed_msg.is_bigendian = false;\n  compressed_msg.is_dense = true;\n  compressed_msg.point_step = compressed_msg.width;\n  compressed_msg.row_step = compressed_msg.width;\n  compressed_msg.fields.resize(1);\n  compressed_msg.fields[0].name = \"compressed_data\";\n  compressed_msg.fields[0].offset = 0;\n  compressed_msg.fields[0].count = 1;\n  compressed_msg.fields[0].datatype = 7;\n  compressed_msg.data.resize(compressed_msg.width);\n  std::memcpy(&compressed_msg.data[0], &compressed_str[0], sizeof(uint8_t) * compressed_msg.width);\n\n  return compressed_msg;\n}", "CodeBleu_score": 49.876883248146896}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto& state : this->multi_uav_state_.uav_state_all) {\n        if (state.uav_id == uav_state.uav_id) {\n            state = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 47.4572231500794}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t  for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n    if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n      this->multi_uav_state_.uav_state_all[i] = uav_state;\n      break;\n    }\n  }\n}", "CodeBleu_score": 94.37680252604139}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t  for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++) {\n    if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id) {\n      this->multi_uav_state_.uav_state_all[i] = uav_state;\n      return;\n    }\n  }\n}", "CodeBleu_score": 85.38519351903221}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t  m_multi_ugv_state_pub_.publish(m_multi_ugv_state);\n}", "CodeBleu_score": 5.570048351463782}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    swarm_control::MultiUGVState multi_ugv_state;\n    int ugv_count = 0;\n    for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); ++it) {\n        swarm_control::UGVState ugv_state;\n        ugv_state.id = it->id;\n        ugv_state.battery = it->battery;\n        ugv_state.position.x = it->position.x;\n        ugv_state.position.y = it->position.y;\n        ugv_state.position.z = it->position.z;\n        ugv_state.velocity.x = it->velocity.x;\n        ugv_state.velocity.y = it->velocity.y;\n        ugv_state.velocity.z = it->velocity.z;\n        ugv_state.attitude.x = it->attitude.x;\n        ugv_state.attitude.y = it->attitude.y;\n        ugv_state.attitude.z = it->attitude.z;\n        ugv_state.attitude.w = it->attitude.w;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n        ugv_count++;\n    }\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}", "CodeBleu_score": 50.94640335829552}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    // Initialize a MultiUGVState message\n    swarm_control::MultiUGVState multi_ugv_state;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (auto ugv_state_it = m_multi_ugv_state.ugv_state_all.begin(); ugv_state_it != m_multi_ugv_state.ugv_state_all.end(); ugv_state_it++) {\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        swarm_control::UGVState ugv_state;\n        ugv_state.ugv_id = ugv_state_it->ugv_id;\n        ugv_state.battery = ugv_state_it->battery;\n        ugv_state.position.x = ugv_state_it->position.x;\n        ugv_state.position.y = ugv_state_it->position.y;\n        ugv_state.position.z = ugv_state_it->position.z;\n        ugv_state.velocity.x = ugv_state_it->velocity.x;\n        ugv_state.velocity.y = ugv_state_it->velocity.y;\n        ugv_state.velocity.z = ugv_state_it->velocity.z;\n        ugv_state.attitude.x = ugv_state_it->attitude.x;\n        ugv_state.attitude.y = ugv_state_it->attitude.y;\n        ugv_state.attitude.z = ugv_state_it->attitude.z;\n        ugv_state.attitude.w = ugv_state_it->attitude.w;\n\n        // Increment the UGV count and add the UGVState to the MultiUGVState message\n        multi_ugv_state.ugv_count++;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n", "CodeBleu_score": 44.89274888086571}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    /*\n     * q: Matrix of control points\n     * cost: Variable to store the calculated cost\n     * gradient: Matrix to store the gradient of the cost\n     */\n\n    // Iterate through control points\n    for (int i = 0; i < q.cols(); ++i) {\n        // Get the predicted positions of moving objects at the current control point\n        Eigen::VectorXd obj_prid = moving_objs_->evaluateConstVel(q.col(i), ros::Time::now().toSec());\n\n        // Iterate through moving objects\n        for (int j = 0; j < moving_objs_->getObjNums(); ++j) {\n            // Compute the distance between control point and moving object\n            double dist = (cps_.points.col(i) - obj_prid).norm();\n\n            // Check if the distance is less than clearance\n            if (dist < planner_setting_.swarm_clearance) {\n                // Update the cost based on the distance error\n                cost += planner_setting_.swarm_clearance - dist;\n\n                // Update the gradient based on the distance error\n                gradient.col(i) += -2 * (planner_setting_.swarm_clearance - dist) * (cps_.points.col(i) - obj_prid).normalized();\n            }\n        }\n    }\n}", "CodeBleu_score": 43.5735854673642}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Initialize the cost to zero\n  cost = 0.0;\n  // Initialize the gradient matrix to zero\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n  // Iterate through control points of the B-spline\n  for (int i = 0; i < q.cols(); i++) {\n    // Get the predicted positions of moving objects at the current control point\n    std::vector<Eigen::Vector3d> obj_prids;\n    moving_objs_->evaluateConstVel(q.col(i), obj_prids);\n    // Iterate through predicted positions of moving objects\n    for (const auto &obj_prid : obj_prids) {\n      // Compute the distance between control point and predicted position of moving object\n      double dist = (cps_.points.col(i) - obj_prid).norm();\n      // If the distance is less than the clearance, update the cost and gradient\n      if (dist < moving_objs_->getClearance()) {\n        // Update the cost based on the distance error\n        cost += pow(dist - moving_objs_->getClearance(), 2);\n        // Update the gradient based on the distance error\n        gradient.col(i) += 2.0 * (dist - moving_objs_->getClearance()) * (cps_.points.col(i) - obj_prid).normalized();\n      }\n    }\n  }\n}", "CodeBleu_score": 41.91326962475381}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Iterate through control points of the B-spline\n  for (int i = 0; i < q.cols(); ++i) {\n    // Get the predicted positions of moving objects at the current control point\n    Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(q.col(i));\n    // Compute the distance between control point and predicted positions of moving objects\n    double dist = (cps_.points.col(i) - obj_prid).norm();\n    // If the distance is less than the clearance, update the cost and gradient\n    if (dist < moving_objs_->getClearance()) {\n      // Update the cost based on the distance error\n      cost += pow(dist - moving_objs_->getClearance(), 2);\n      // Update the gradient based on the distance error\n      gradient.col(i) += 2.0 * (dist - moving_objs_->getClearance()) * (cps_.points.col(i) - obj_prid).normalized();\n    }\n  }\n}", "CodeBleu_score": 33.66875052324199}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  gradient.setZero();\n\n  int N = q.cols();\n  int K = q.rows();\n\n  /* iterate through all points */\n  for (int i = 2; i < N - 2; ++i) {\n    /* calculate positional error */\n    Eigen::VectorXd e = 2.0 * (q.col(i) - ref_pts_.col(i));\n    /* calculate velocity */\n    Eigen::VectorXd v = (ref_pts_.col(i + 1) - ref_pts_.col(i - 1)) / (t_(i + 1) - t_(i - 1));\n    /* calculate cost and gradient */\n    double a2 = e.squaredNorm();\n    double b2 = v.squaredNorm();\n    double ab = e.dot(v);\n    double b2inv = 1.0 / b2;\n    cost += (a2 * b2inv - 2 * ab * b2inv + ab * ab * b2inv * b2inv);\n    gradient.col(i) += 4 * (e * b2inv - v * ab * b2inv * b2inv);\n  }\n}", "CodeBleu_score": 38.391824398431325}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  // Initialize the cost to zero\n  cost = 0.0;\n\n  // Set the gradient to zero\n  gradient.setZero();\n\n  // Iterate through the control points of the trajectory\n  for (int i = 2; i < q.cols() - 2; i++) {\n    // Compute the positional error relative to reference points\n    Eigen::Vector3d p = q.col(i) - ref_pts_[i];\n\n    // Compute the velocity vector\n    Eigen::Vector3d v = (q.col(i + 1) - q.col(i - 1)) / (t_[i + 1] - t_[i - 1]);\n\n    // Compute the dot product and cross product of the error and velocity vectors\n    double dot = p.dot(v);\n    Eigen::Vector3d cross = p.cross(v);\n\n    // Update the cost function\n    cost += a2_ * dot * dot + b2_ * cross.dot(cross);\n\n    // Update the gradient for the current control point\n    gradient.col(i) += 2.0 * a2_ * dot * v + 4.0 * b2_ * cross.cross(v);\n  }\n}", "CodeBleu_score": 34.99907108762322}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  gradient.setZero();\n  int num_control_points = q.cols();\n  for (int i = 0; i < num_control_points; ++i) {\n    Eigen::Vector3d p = q.col(i);\n    Eigen::Vector3d v = Eigen::Vector3d::Zero();\n    if (i > 0 && i < num_control_points - 1) {\n      v = (q.col(i + 1) - q.col(i - 1)) / (dt_ * 2.0);\n    }\n    Eigen::Vector3d pos_err = p - ref_pts_[i];\n    double a2 = pos_err.squaredNorm();\n    double b2 = v.squaredNorm();\n    cost += a2 + b2;\n    Eigen::Vector3d xcrossv = pos_err.cross(v);\n    double xcrossv_norm = xcrossv.norm();\n    Eigen::Vector3d gradient_i = (2.0 * pos_err + 2.0 * v.dot(pos_err) * v / b2) / (a2 + b2);\n    gradient.col(i) += gradient_i;\n  }\n}", "CodeBleu_score": 41.300994265771216}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t  // Calculate the third derivative of the spline to obtain the jerk trajectory\n  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  // Retrieve the knot times and control points of the jerk trajectory\n  double time = jerk_traj.getTimeSum();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.control_points_;\n\n  // Initialize a variable to store the total jerk value\n  double jerk = 0.0;\n\n  // Iterate through the control points and dimensions\n  for (int i = 0; i < ctrl_pts.cols(); i++) {\n    for (int j = 0; j < ctrl_pts.rows(); j++) {\n      // Calculate the difference in knot times\n      double dt = jerk_traj.getKnot(j + 1, i) - jerk_traj.getKnot(j, i);\n\n      // Add the squared control point value multiplied by the difference in knot times to the total jerk value\n      jerk += (ctrl_pts(j, i) * ctrl_pts(j, i)) * (dt * dt * dt);\n    }\n  }\n\n  // Return the total jerk value\n  return jerk;\n}", "CodeBleu_score": 66.67787991896704}, {"code": "double UniformBspline::getJerk(){\n\t  NonUniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  double jerk = 0.0;\n  double time_seg = jerk_traj.getTimeSum();\n  double dt, dt2, dt3;\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n  vector<double> knt_time = jerk_traj.getKnot();\n\n  // ROS_WARN(\"[knt_time]: %d\", knt_time.size());\n  // ROS_WARN(\"time_sum: %f\", time_seg);\n\n  for (int i = 0; i < int(time_seg) - 1; i++) {\n    dt = knt_time[i + 1] - knt_time[i];\n    for (int j = 0; j < ctrl_pts.cols(); j++) {\n      // jerk += (getVel(knt_time[i + 1]) - getVel(knt_time[i])) / dt;\n      dt2 = knt_time[i + 2] - knt_time[i + 1];\n      dt3 = knt_time[i + 2] - knt_time[i];\n      jerk += (dt2 * (2 * ctrl_pts(i + 2, j) + ctrl_pts(i + 1, j)) -\n               dt3 * (2 * ctrl_pts(i + 1, j) + ctrl_pts(i, j))) /\n              (dt * dt2 * (dt + dt2));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 61.1464677716422}, {"code": "double UniformBspline::getJerk(){\n\t  // Calculate the third derivative of the spline to obtain the jerk trajectory\n  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n\n  // Retrieve the knot times and control points of the jerk trajectory\n  double time = jerk_traj.getTimeSum();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n  // Initialize a variable to store the total jerk value\n  double jerk = 0.0;\n\n  // Iterate through the control points and dimensions\n  for (int i = 0; i < ctrl_pts.cols(); ++i) {\n    for (int j = 0; j < ctrl_pts.rows(); ++j) {\n      // Sum the squared control point values multiplied by the differences in knot times\n      jerk += pow(ctrl_pts(j, i), 2) * (jerk_traj.getKnot(j + 3) - jerk_traj.getKnot(j));\n    }\n  }\n\n  // Return the total jerk value\n  return jerk;\n}", "CodeBleu_score": 66.37173347325539}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos[0] = (u - cx_) / fx_ * depth;\n    pos[1] = (v - cy_) / fy_ * depth;\n    pos[2] = depth;\n    pos[3] = 1;\n    return pos;\n}", "CodeBleu_score": 54.82880055768149}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t  Eigen::Vector4d pos;\n  pos(0) = (u - cx_) * depth / fx_;\n  pos(1) = (v - cy_) * depth / fy_;\n  pos(2) = depth;\n  pos(3) = 1;\n  return pos;\n}", "CodeBleu_score": 76.78054970942637}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t  Eigen::Vector4d pos;\n  pos[0] = (u - cx_) / fx_ * depth;\n  pos[1] = (v - cy_) / fy_ * depth;\n  pos[2] = depth;\n  pos[3] = 1;\n  return pos;\n}", "CodeBleu_score": 54.59565148375861}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    std::string drone_id = odom.child_frame_id.substr(0, 1);\n    int id = std::stoi(drone_id);\n    rcvDroneOdomCallbackBase(odom, id);\n  } catch (const std::exception& e) {\n    ROS_ERROR(\"Error extracting drone ID from child_frame_id: %s\", e.what());\n  }\n}", "CodeBleu_score": 59.87221621606634}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        // Extract the drone ID from the child_frame_id field of the odometry message\n        int droneId = std::stoi(odom.child_frame_id.substr(1, 1));\n        // Call the base function with the odometry data and drone ID\n        rcvDroneOdomCallbackBase(odom, droneId);\n    } catch (const std::exception& e) {\n        // Catch any exceptions that occur during the extraction of the drone ID\n        // and print the exception message\n        std::cout << \"Error extracting drone ID from child_frame_id: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 56.568211729475905}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        // Extract the drone ID from the child_frame_id field of the odometry message\n        int drone_id = std::stoi(odom.child_frame_id.substr(4));\n        // Call rcvDroneOdomCallbackBase with the odometry data and drone ID\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (const std::exception& e) {\n        // Catch and print any exceptions that occur during the extraction of the drone ID\n        std::cerr << \"Error extracting drone ID: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 59.9164445855203}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // Calculate true pose of the drone in the camera frame\n  Eigen::Vector3d true_pose = getTruePose(drone_id, true_pixel);\n\n  // Check if the drone is present in the camera frame\n  bool found = checkDronePresence(true_pose);\n\n  if (found) {\n    // Compute the pose error between the camera and world coordinates\n    Eigen::Vector3d pose_error = getPoseError(true_pose);\n\n    // Update the debug result\n    updateDebugResult(drone_id, true_pixel, pose_error);\n\n    // Publish the pose error\n    drone_pose_err_pub_[drone_id].publish(pose_error);\n  } else {\n    // Update the debug result to indicate failure\n    updateDebugResult(drone_id, true_pixel, Eigen::Vector3d::Zero());\n  }\n}", "CodeBleu_score": 33.716802465918136}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Compute the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = computeTruePose(drone_id, true_pixel);\n\n    // Check if the drone is present in the image\n    if (checkDronePresence(true_pose)) {\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d pose_error = computePoseError(true_pose);\n\n        // Update the debug result with the detected drone\n        updateDebugResult(drone_id, true_pixel, pose_error);\n\n        // Publish the pose error\n        drone_pose_err_pub_[drone_id].publish(pose_error);\n    } else {\n        // Update the debug result to indicate failure\n        updateDebugResult(drone_id, true_pixel, Eigen::Vector3d::Zero());\n    }\n}", "CodeBleu_score": 31.865853733016213}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Calculate the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = drone_pose_[drone_id];\n    true_pose.z() = 0.0;\n\n    // Check for the drone's presence in the camera frame\n    if (true_pixel.x() >= 0 && true_pixel.x() < image_width_ &&\n        true_pixel.y() >= 0 && true_pixel.y() < image_height_) {\n        // If found, compute the pose error between the camera and world coordinates\n        Eigen::Vector3d pose_error = true_pose - camera_pose_;\n\n        // Update the debug result with the detected drone\n        cv::circle(debug_result_, cv::Point(true_pixel.x(), true_pixel.y()), 5, cv::Scalar(0, 0, 255), -1);\n\n        // Publish the pose error\n        geometry_msgs::PoseStamped pose_error_msg;\n        pose_error_msg.header.stamp = ros::Time::now();\n        pose_error_msg.header.frame_id = \"world\";\n        pose_error_msg.pose.position.x = pose_error.x();\n        pose_error_msg.pose.position.y = pose_error.y();\n        pose_error_msg.pose.position.z = pose_error.z();\n        pose_error_msg.pose.orientation.w = 1.0;\n        drone_pose_err_pub_[drone_id].publish(pose_error_msg);\n    } else {\n        // If not found, update the debug result to indicate failure\n        cv::putText(debug_result_, \"Drone \" + std::to_string(drone_id) + \" not detected\", cv::Point(10, 30),\n                    cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 255), 2);\n    }\n}", "CodeBleu_score": 43.37546254509077}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t  vector<GridNodePtr> path;\n  // std::cout << \"Retrieving path\" << std::endl;\n  path.push_back(current);\n  while (current->cameFrom != nullptr) {\n    current = current->cameFrom;\n    path.push_back(current);\n  }\n  return path;\n}", "CodeBleu_score": 91.51210790346786}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    // std::cout << \"Retrieving path\" << std::endl;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 93.99751622940664}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom != NULL) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 92.88895128395902}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))\n    return false;\n\n  if (checkOccupancy(start_idx)) {\n    //ROS_WARN(\"Start point is insde obstacle.\");\n    do {\n      start_pt = start_pt - 0.05 * (end_pt - start_pt).normalized();\n      if (!Coord2Index(start_pt, start_idx))\n        return false;\n    } while (checkOccupancy(start_idx));\n    //ROS_WARN(\"Adjusted start point.\");\n  }\n\n  if (checkOccupancy(end_idx)) {\n    //ROS_WARN(\"End point is insde obstacle.\");\n    do {\n      end_pt = end_pt + 0.05 * (end_pt - start_pt).normalized();\n      if (!Coord2Index(end_pt, end_idx))\n        return false;\n    } while (checkOccupancy(end_idx));\n    //ROS_WARN(\"Adjusted end point.\");\n  }\n\n  return true;\n}", "CodeBleu_score": 67.51317754287591}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))\n    return false;\n\n  if (checkOccupancy(start_idx)) {\n    //ROS_WARN(\"Start point is insde obstacle !\");\n    do {\n      start_pt = (start_pt - end_pt).normalized() * step_size + start_pt;\n      //ROS_WARN_STREAM(\"new start point: \" << start_pt.transpose());\n    } while (checkOccupancy(start_idx));\n    Coord2Index(start_pt, start_idx);\n  }\n\n  if (checkOccupancy(end_idx)) {\n    //ROS_WARN(\"End point is insde obstacle !\");\n    do {\n      end_pt = (end_pt - start_pt).normalized() * step_size + end_pt;\n      //ROS_WARN_STREAM(\"new end point: \" << end_pt.transpose());\n    } while (checkOccupancy(end_idx));\n    Coord2Index(end_pt, end_idx);\n  }\n\n  return true;\n}", "CodeBleu_score": 67.28073751385357}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))\n        return false;\n\n    if (checkOccupancy(start_idx)) {\n        //ROS_WARN(\"Start point is insde obstacle.\");\n        do {\n            start_pt = start_pt - 0.05 * (end_pt - start_pt).normalized();\n            if (!Coord2Index(start_pt, start_idx))\n                return false;\n        } while (checkOccupancy(start_idx));\n        //ROS_WARN(\"Adjusted start point.\");\n    }\n\n    if (checkOccupancy(end_idx)) {\n        //ROS_WARN(\"End point is insde obstacle.\");\n        do {\n            end_pt = end_pt + 0.05 * (end_pt - start_pt).normalized();\n            if (!Coord2Index(end_pt, end_idx))\n                return false;\n        } while (checkOccupancy(end_idx));\n        //ROS_WARN(\"Adjusted end point.\");\n    }\n\n    return true;\n}", "CodeBleu_score": 70.54266737806242}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  Index x, y, z;\n  resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 27.68871464556051}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  Index x, y, z;\n  for (x = min_id(0); x <= max_id(0); ++x)\n    for (y = min_id(1); y <= max_id(1); ++y)\n      for (z = min_id(2); z <= max_id(2); ++z)\n        occupancy_buffer_inflate_[x * grid_size_(1) * grid_size_(2) +\n                                 y * grid_size_(2) + z] = 0;\n}", "CodeBleu_score": 59.742724514505184}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 23.885411100951046}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d pt_near_boundary = pt;\n    for (int i = 0; i < 3; i++) {\n        double min_coeff = -1.0 * diff[i] / map_size_[i];\n        double max_coeff = (map_size_[i] - diff[i]) / map_size_[i];\n        if (min_coeff > 0.0 && min_coeff < 1.0) {\n            Eigen::Vector3d adjusted_pt = pt + min_coeff * diff;\n            if (isInMap(adjusted_pt)) {\n                pt_near_boundary = adjusted_pt;\n                break;\n            }\n        }\n        if (max_coeff > 0.0 && max_coeff < 1.0) {\n            Eigen::Vector3d adjusted_pt = pt + max_coeff * diff;\n            if (isInMap(adjusted_pt)) {\n                pt_near_boundary = adjusted_pt;\n                break;\n            }\n        }\n    }\n    return pt_near_boundary;\n}", "CodeBleu_score": 48.76059991255745}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d max_t = (map_max_boundary_ - camera_pt).cwiseQuotient(diff);\n    Eigen::Vector3d min_t = (map_min_boundary_ - camera_pt).cwiseQuotient(diff);\n\n    double min_positive_t = DBL_MAX;\n    for (int i = 0; i < 3; i++) {\n        if (max_t[i] > 0 && max_t[i] < min_positive_t) {\n            min_positive_t = max_t[i];\n        }\n        if (min_t[i] > 0 && min_t[i] < min_positive_t) {\n            min_positive_t = min_t[i];\n        }\n    }\n\n    return camera_pt + min_positive_t * diff;\n}", "CodeBleu_score": 51.0492769108708}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d max_t = (boundary_max_ - camera_pt).cwiseQuotient(diff);\n    Eigen::Vector3d min_t = (boundary_min_ - camera_pt).cwiseQuotient(diff);\n    Eigen::Vector3d pt_near_boundary(camera_pt);\n    double min_t_positive = std::numeric_limits<double>::max();\n    for (int i = 0; i < 3; i++) {\n        if (max_t(i) > 0 && max_t(i) < min_t_positive) {\n            min_t_positive = max_t(i);\n            pt_near_boundary = camera_pt + max_t(i) * diff;\n        }\n        if (min_t(i) > 0 && min_t(i) < min_t_positive) {\n            min_t_positive = min_t(i);\n            pt_near_boundary = camera_pt + min_t(i) * diff;\n        }\n    }\n    return pt_near_boundary;\n}", "CodeBleu_score": 48.106868282829204}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update the last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // Check if an update is needed\n  if ((ros::Time::now() - md_.last_map_update_time_).toSec() < md_.occ_update_time_resolution_) {\n    return;\n  }\n\n  // Project depth image into points\n  md_.proj_points_.clear();\n  md_.proj_points_cnt_.clear();\n  md_.proj_map_idx_.clear();\n  md_.proj_idx_.clear();\n  md_.proj_points_cnt_.resize(md_.depth_image_width_ * md_.depth_image_height_, 0);\n  md_.proj_map_idx_.resize(md_.depth_image_width_ * md_.depth_image_height_, -1);\n  md_.proj_idx_.resize(md_.depth_image_width_ * md_.depth_image_height_, -1);\n\n  // ROS_INFO(\"md_.depth_image_width_: %d\", md_.depth_image_width_);\n  // ROS_INFO(\"md_.depth_image_height_: %d\", md_.depth_image_height_);\n  // ROS_INFO(\"md_.depth_image_.size(): %d\", md_.depth_image_.size());\n\n  for (int i = 0; i < md_.depth_image_width_; ++i) {\n    for (int j = 0; j < md_.depth_image_height_; ++j) {\n      // ROS_INFO(\"i: %d\", i);\n      // ROS_INFO(\"j: %d\", j);\n      // ROS_INFO(\"md_.depth_image_width_: %d\", md_.depth_image_width_);\n      // ROS_INFO(\"md_.depth_image_height_: %d\", md_.depth_image_height_);\n      // ROS_INFO(\"md_.depth_image_.size(): %d\", md_.depth_image_.size());\n      int idx = i + j * md_.depth_image_width_;\n      // ROS_INFO(\"idx: %d\", idx);\n      // ROS_INFO(\"", "CodeBleu_score": 50.273816812611514}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t    // Update the last occupancy update time\n    md_.last_occ_update_time_ = ros::Time::now();\n\n    // Check if an update is needed\n    if (!md_.has_odom_ || !md_.has_depth_) return;\n    if ((ros::Time::now() - md_.last_depth_update_time_).toSec() > md_.depth_timeout_) {\n        ROS_WARN(\"Depth data timeout!\");\n        md_.has_depth_ = false;\n        return;\n    }\n    if ((ros::Time::now() - md_.last_odom_update_time_).toSec() > md_.odom_timeout_) {\n        ROS_WARN(\"Odometry data timeout!\");\n        md_.has_odom_ = false;\n        return;\n    }\n\n    // Project depth image into points\n    vector<Vector3d> points;\n    projectDepthImage(points);\n\n    // Process the points with raycasting\n    raycastProcess(points);\n\n    // Clear and inflate the local map\n    clearAndInflateLocalMap();\n\n    // Handle timeout errors\n    if ((ros::Time::now() - md_.last_odom_update_time_).toSec() > md_.odom_timeout_) {\n        ROS_ERROR(\"Odometry data timeout!\");\n        md_.has_odom_ = false;\n    }\n    if ((ros::Time::now() - md_.last_depth_update_time_).toSec() > md_.depth_timeout_) {\n        ROS_ERROR(\"Depth data timeout!\");\n        md_.has_depth_ = false;\n    }\n\n    // Set the relevant flags\n    md_.map_updated_flag_ = true;\n    md_.has_odom_ = false;\n    md_.has_depth_ = false;\n}", "CodeBleu_score": 62.395734507658176}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update the last occupancy update time\n  md_.last_occ_update_time_ = ros::Time::now();\n\n  // If an update is needed\n  if (need_occ_update_) {\n    // Project depth image into points\n    md_.proj_points_.clear();\n    md_.proj_points_cnt_.clear();\n    md_.proj_idx_.clear();\n    md_.proj_points_cnt_.resize(md_.proj_h_ * md_.proj_w_, 0);\n    md_.proj_idx_.resize(md_.proj_h_ * md_.proj_w_, -1);\n\n    // ROS_INFO(\"md_.depth_image_.size(): %d\", md_.depth_image_.size());\n    // ROS_INFO(\"md_.proj_points_.size(): %d\", md_.proj_points_.size());\n    // ROS_INFO(\"md_.proj_points_cnt_.size(): %d\", md_.proj_points_cnt_.size());\n    // ROS_INFO(\"md_.proj_idx_.size(): %d\", md_.proj_idx_.size());\n\n    projectDepthImage();\n\n    // ROS_INFO(\"md_.proj_points_.size(): %d\", md_.proj_points_.size());\n    // ROS_INFO(\"md_.proj_points_cnt_.size(): %d\", md_.proj_points_cnt_.size());\n    // ROS_INFO(\"md_.proj_idx_.size(): %d\", md_.proj_idx_.size());\n\n    // Process the projected points with raycasting\n    raycastProcess();\n\n    // Clear and inflate the local map\n    if (md_.has_local_map_) {\n      clearAndInflateLocalMap();\n    }\n\n    // Reset the update flag\n    need_occ_update_ = false;\n\n    // Check for timeout errors\n    if ((ros::Time::now() - md_.last_odom_time_).toSec() > md_.odom_timeout_) {\n      md_.odom_valid_ = false;\n      ROS_ERROR(\"Odometry data timeout!\");\n    }\n    if ((ros::Time::now() - md", "CodeBleu_score": 60.23049769284845}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float f_sum = 0.0;\n    for (int i = 0; i < image_fns.size(); i++) {\n        string image_fn = image_fns[i];\n        string gt_fn = gt_fns[i];\n        string dt_fn = dt_fns[i];\n        float f = _ellipse_evaluate_one(image_fn, gt_fn, dt_fn, gt_angle_radians);\n        f_sum += f;\n    }\n    return f_sum / image_fns.size();\n}", "CodeBleu_score": 57.23193480012715}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float sum_f = 0;\n    for (int i = 0; i < image_fns.size(); i++) {\n        string image_fn = image_fns[i];\n        string gt_fn = gt_fns[i];\n        string dt_fn = dt_fns[i];\n        cv::Mat image = cv::imread(image_fn);\n        vector<Ellipse> gt = _load_ellipse_GT(gt_fn, gt_angle_radians);\n        vector<Ellipse> dt = _load_ellipse_DT(dt_fn, gt_angle_radians);\n        float f = _ellipse_evaluate_one(image, gt, dt);\n        sum_f += f;\n    }\n    return sum_f / image_fns.size();\n}", "CodeBleu_score": 61.082853114317345}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float avg_f = 0;\n    for (int i = 0; i < image_fns.size(); i++) {\n        Mat image = imread(image_fns[i]);\n        vector<Ellipse> gt_ellipses = _load_ellipse_GT(gt_fns[i], gt_angle_radians);\n        vector<Ellipse> dt_ellipses = _load_ellipse_DT(dt_fns[i], gt_angle_radians);\n        float f = _ellipse_evaluate_one(image, gt_ellipses, dt_ellipses);\n        avg_f += f;\n    }\n    return avg_f / image_fns.size();\n}", "CodeBleu_score": 66.42116652466788}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle1 = atan2(y - foci[1], x - foci[0]);\n    float angle2 = atan2(y - foci[3], x - foci[2]);\n    float angle_diff = angle_diff_signed(angle1, angle2);\n    return fmod(angle_diff, M_PI);\n}", "CodeBleu_score": 35.721027718893716}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    if (foci != NULL) {\n        float a = foci[0];\n        float b = foci[1];\n        float c = foci[2];\n        float d = foci[3];\n        float e = foci[4];\n        float f = foci[5];\n\n        float angle_1 = atan2(y - f, x - e);\n        float angle_2 = atan2(y - d, x - c);\n\n        return angle_diff_signed(angle_1, angle_2);\n    } else {\n        fprintf(stderr, \"Error: foci parameter is null.\n\");\n        return 0.0f;\n    }\n}", "CodeBleu_score": 41.8909382191338}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    if (foci != NULL) {\n        float dx = x - foci[0];\n        float dy = y - foci[1];\n        float angle1 = atan2(dy, dx);\n        dx = x - foci[2];\n        dy = y - foci[3];\n        float angle2 = atan2(dy, dx);\n        return _angle_diff_signed(angle1, angle2);\n    } else {\n        return 0;\n    }\n}", "CodeBleu_score": 38.842421237707555}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    double min_x = std::numeric_limits<double>::max();\n    double max_x = std::numeric_limits<double>::min();\n    double min_y = std::numeric_limits<double>::max();\n    double max_y = std::numeric_limits<double>::min();\n    for (int i = start; i <= end; i++) {\n        min_x = std::min(min_x, vp1[i].x);\n        max_x = std::max(max_x, vp1[i].x);\n        min_y = std::min(min_y, vp1[i].y);\n        max_y = std::max(max_y, vp1[i].y);\n    }\n    double integral_above = 0.0;\n    double integral_below = 0.0;\n    for (int i = start; i <= end; i++) {\n        int j = (i + 1) % vp1.size();\n        double x1 = vp1[i].x;\n        double y1 = vp1[i].y;\n        double x2 = vp1[j].x;\n        double y2 = vp1[j].y;\n        if (y1 > y2) {\n            integral_above += (x2 - x1) * (y1 - y2) / 2.0;\n        } else if (y1 < y2) {\n            integral_below += (x2 - x1) * (y2 - y1) / 2.0;\n        }\n    }\n    return integral_above < integral_below;\n}", "CodeBleu_score": 47.91058595374169}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n\n    for (int i = start; i <= end; i++) {\n        if (vp1[i].x < min_x) {\n            min_x = vp1[i].x;\n        }\n        if (vp1[i].x > max_x) {\n            max_x = vp1[i].x;\n        }\n        if (vp1[i].y < min_y) {\n            min_y = vp1[i].y;\n        }\n        if (vp1[i].y > max_y) {\n            max_y = vp1[i].y;\n        }\n    }\n\n    double integral_above = 0.0;\n    double integral_below = 0.0;\n\n    for (int i = start; i <= end; i++) {\n        integral_above += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n        integral_below += (vp1[i].x - min_x) * (max_y - vp1[i].y);\n    }\n\n    return integral_above < integral_below;\n}", "CodeBleu_score": 41.40603201191281}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    int min_x = vp1[start].x;\n    int max_x = vp1[start].x;\n    int min_y = vp1[start].y;\n    int max_y = vp1[start].y;\n    for (int i = start; i <= end; i++) {\n        if (vp1[i].x < min_x) {\n            min_x = vp1[i].x;\n        }\n        if (vp1[i].x > max_x) {\n            max_x = vp1[i].x;\n        }\n        if (vp1[i].y < min_y) {\n            min_y = vp1[i].y;\n        }\n        if (vp1[i].y > max_y) {\n            max_y = vp1[i].y;\n        }\n    }\n    int integral_above = 0;\n    int integral_below = 0;\n    for (int i = start; i <= end; i++) {\n        integral_above += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n        integral_below += (max_x - vp1[i].x) * (max_y - vp1[i].y);\n    }\n    return integral_above < integral_below;\n}", "CodeBleu_score": 42.3000581398703}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    ellipse_det = *msg;\n    for (int i = 0; i < ellipse_det.detection_info.size(); i++) {\n        if (ellipse_det.detection_info[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n        if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n    }\n    if (ellipse_det.detection_info.size() > 0) {\n        for (int i = 0; i < ellipse_det.detection_info.size(); i++) {\n            if (ellipse_det.detection_info[i].name == \"T\") {\n                double temp = ellipse_det.detection_info[i].sight_angle[0];\n                ellipse_det.detection_info[i].sight_angle[0] = ellipse_det.detection_info[i].sight_angle[1];\n                ellipse_det.detection_info[i].sight_angle[1] = temp;\n            }\n        }\n    }\n}", "CodeBleu_score": 67.44785616759887}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    ellipse_det.detected = false;\n    ellipse_det.num_lost = 0;\n    ellipse_det.num_regain = 0;\n    ellipse_det.sight_angle.x = 0;\n    ellipse_det.sight_angle.y = 0;\n\n    for (int i = 0; i < msg->num_of_det; i++) {\n        if (msg->name[i] == \"T\") {\n            ellipse_det.num_regain++;\n            ellipse_det.num_lost = 0;\n            ellipse_det.sight_angle.x = msg->pos[i].x;\n            ellipse_det.sight_angle.y = msg->pos[i].y;\n        } else {\n            ellipse_det.num_lost++;\n            ellipse_det.num_regain = 0;\n        }\n    }\n\n    if (ellipse_det.num_lost > VISION_THRES) {\n        ellipse_det.detected = false;\n    }\n    if (ellipse_det.num_regain > VISION_THRES) {\n        ellipse_det.detected = true;\n    }\n\n    float temp = ellipse_det.sight_angle.x;\n    ellipse_det.sight_angle.x = ellipse_det.sight_angle.y;\n    ellipse_det.sight_angle.y = temp;\n}", "CodeBleu_score": 40.916235374033775}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    ellipse_det.is_detected = false;\n    ellipse_det.num_regain = 0;\n    ellipse_det.num_lost = 0;\n\n    for (auto &det : msg->detections) {\n        if (det.name == \"T\") {\n            ellipse_det.num_regain++;\n            ellipse_det.num_lost = 0;\n        } else {\n            ellipse_det.num_regain = 0;\n            ellipse_det.num_lost++;\n        }\n    }\n\n    if (ellipse_det.num_lost >= VISION_THRES) {\n        ellipse_det.is_detected = false;\n    }\n\n    if (ellipse_det.num_regain >= VISION_THRES) {\n        ellipse_det.is_detected = true;\n    }\n\n    ellipse_det.sight_angle.data[0] = msg->detections[0].camera_position.data[0];\n    ellipse_det.sight_angle.data[1] = msg->detections[0].camera_position.data[1];\n    ellipse_det.sight_angle.data[2] = msg->detections[0].camera_position.data[2];\n}", "CodeBleu_score": 38.77449902796323}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    return Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 45.68302491297701}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    return Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 45.68302491297701}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    // Check if the current position is safe based on the Occupy_map_ptr\n    return Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 45.78128616816927}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 67.26908921647082}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n\n    reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 74.70027882849524}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 67.26908921647082}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id].pos = odom->pose.pose.position;\n    state_nei[id].pos.z = state_nei[id].pos.z + 0.1;\n    if(sim_mode) {\n        if((start_pos-state_nei[id].pos).norm() > 5) {\n            get_nei_state = false;\n        } else {\n            get_nei_state = true;\n        }\n    }\n}", "CodeBleu_score": 35.00379385385826}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id].pos(0) = odom->pose.pose.position.x;\n    state_nei[id].pos(1) = odom->pose.pose.position.y;\n    state_nei[id].pos(2) = odom->pose.pose.position.z;\n    state_nei[id].vel(0) = odom->twist.twist.linear.x;\n    state_nei[id].vel(1) = odom->twist.twist.linear.y;\n    state_nei[id].vel(2) = odom->twist.twist.linear.z;\n    state_nei[id].acc(0) = (state_nei[id].vel(0) - last_vel[id](0)) / dt;\n    state_nei[id].acc(1) = (state_nei[id].vel(1) - last_vel[id](1)) / dt;\n    state_nei[id].acc(2) = (state_nei[id].vel(2) - last_vel[id](2)) / dt;\n    last_vel[id] = state_nei[id].vel;\n\n    if(sim_mode){\n        if((start_pos-state_nei[id].pos).norm() > 5){\n            get_nei_state[id] = false;\n        }\n        else{\n            get_nei_state[id] = true;\n        }\n    }\n    else{\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 49.874669925505046}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    state_nei[id].pos(0) = odom->pose.pose.position.x;\n    state_nei[id].pos(1) = odom->pose.pose.position.y;\n    state_nei[id].pos(2) = odom->pose.pose.position.z;\n\n    state_nei[id].vel(0) = odom->twist.twist.linear.x;\n    state_nei[id].vel(1) = odom->twist.twist.linear.y;\n    state_nei[id].vel(2) = odom->twist.twist.linear.z;\n\n    state_nei[id].acc(0) = 0;\n    state_nei[id].acc(1) = 0;\n    state_nei[id].acc(2) = 0;\n\n    if(sim_mode) {\n        if((start_pos-state_nei[id].pos).norm() > 5) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    }\n}", "CodeBleu_score": 52.03058242656351}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter == 5) {\n        Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n        update_counter = 0;\n    }\n}", "CodeBleu_score": 67.04130380910856}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter == 5) {\n        update_counter = 0;\n        Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n    }\n}", "CodeBleu_score": 63.22465852864123}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n\n    sensor_ready = true;\n    update_counter++;\n\n    if (update_counter == 5) {\n        update_counter = 0;\n        Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n    }\n}", "CodeBleu_score": 63.22465852864123}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (get_gpcl) {\n        get_gpcl = false;\n        pcl::fromROSMsg(*global_point, *global_cloud);\n        global_cloud->header.frame_id = \"map\";\n        inflate_point_cloud(global_cloud, global_cloud, 0.2);\n    }\n}", "CodeBleu_score": 52.12911241276124}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\n    if (get_gpcl) {\n        get_gpcl = false;\n        pcl::fromROSMsg(*global_point, *global_cloud);\n        store_map();\n        inflate_point_cloud();\n    }\n}", "CodeBleu_score": 43.68090315759083}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl == false) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *cloud_global);\n    map_inflate();\n  }\n}", "CodeBleu_score": 42.21849348941}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    if (simulation_mode_) {\n        local_map_merge_odom(odom);\n    }\n    else {\n        local_map_merge_odom(odom);\n        // local_map_merge_odom(odom);\n    }\n\n    // Convert the laser scan to a PointCloud2 message\n    sensor_msgs::PointCloud2 laser_cloud;\n    projector_.projectLaser(*local_point, laser_cloud);\n\n    // Convert the PointCloud2 message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(laser_cloud, *cloud);\n\n    // Update the occupancy map with the laser scan data\n    map_update_laser(cloud);\n}", "CodeBleu_score": 59.82141075196714}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t    sensor_msgs::PointCloud2 cloud_msg;\n    projector_.projectLaser(*local_point, cloud_msg);\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(cloud_msg, cloud);\n    if (!simulation_mode_) {\n        local_map_merge_odom(cloud, odom);\n    }\n    else {\n        local_map_merge_odom(cloud);\n    }\n}", "CodeBleu_score": 54.017223387308576}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n  // Convert the laser scan to a PointCloud2 message\n  sensor_msgs::PointCloud2 local_point_cloud2;\n  projector_.projectLaser(*local_point, local_point_cloud2);\n\n  // Convert the PointCloud2 message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ> local_point_cloud;\n  pcl::fromROSMsg(local_point_cloud2, local_point_cloud);\n\n  // If not in simulation mode, merge the local map with the provided odometry data\n  if (!simulation_mode_) {\n    local_map_merge_odom(local_point_cloud, odom);\n  }\n\n  // Update the occupancy map with the local point cloud\n  map_update_local_map(local_point_cloud);\n}", "CodeBleu_score": 50.35613572055646}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(*global_map_ptr_, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_msg);\n\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(*inflate_map_ptr_, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 66.3428044360676}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  if (global_pcl_pub.getNumSubscribers() > 0) {\n    pcl::toROSMsg(global_pcl_map, global_pcl_map_msg);\n    global_pcl_map_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_map_msg);\n  }\n\n  if (inflate_pcl_pub.getNumSubscribers() > 0) {\n    pcl::toROSMsg(inflate_pcl_map, inflate_pcl_map_msg);\n    inflate_pcl_map_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_map_msg);\n  }\n}", "CodeBleu_score": 49.01566582532603}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    pcl::toROSMsg(global_map, global_pcl);\n    global_pcl.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl);\n\n    pcl::toROSMsg(inflate_map, inflate_pcl);\n    inflate_pcl.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl);\n}", "CodeBleu_score": 44.74531066260817}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (odom_ready) {\n        sensor_ready = true;\n        Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n        Astar_ptr->set_start_point(odom_pos);\n    }\n}", "CodeBleu_score": 55.605824069108635}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (odom_ready) {\n        sensor_ready = true;\n    }\n\n    Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg);\n}", "CodeBleu_score": 51.70575237209442}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (odom_ready) {\n    sensor_ready = true;\n  }\n  Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, odom_ptr->odom_pos);\n}", "CodeBleu_score": 51.797958614114116}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Calculate target foot positions based on the desired pose using the body controller\n  body_controller_.updatePoseCommand();\n  body_controller_.updateTwistCommand();\n\n  // Compute velocity commands for the legs\n  leg_controller_.updateVelocityCommand();\n\n  // Perform inverse kinematics to determine target joint positions\n  kinematics_.inverse(leg_controller_.velocityCommand, joint_positions_);\n\n  // Publish foot contact information\n  publishFootContacts_();\n\n  // Publish joint positions\n  publishJoints_();\n}", "CodeBleu_score": 26.642096125425653}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Calculate target foot positions based on the desired pose using the body controller\n  // ...\n\n  // Compute velocity commands for the legs\n  // ...\n\n  // Perform inverse kinematics to determine target joint positions\n  // ...\n\n  // Publish foot contact information\n  // ...\n\n  // Publish joint positions\n  // ...\n}", "CodeBleu_score": 5.798352126831164}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  // Get the current time\n  ros::Time time = ros::Time::now();\n\n  // Calculate the desired foot positions based on the desired pose\n  body_controller_.getFootPositions(desired_foot_positions_);\n\n  // Compute velocity commands for the legs\n  for (int i = 0; i < 4; i++) {\n    leg_controller_.velocityCommand(desired_foot_positions_[i], leg_velocity_commands_[i]);\n  }\n\n  // Perform inverse kinematics to determine target joint positions\n  kinematics_.inverse(leg_velocity_commands_, joint_position_commands_);\n\n  // Publish foot contact information\n  publishFootContacts_();\n\n  // Publish joint positions\n  publishJoints_();\n}", "CodeBleu_score": 48.621566426622245}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t    if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n        // Create a ContactsStamped message\n        free_gait_msgs::ContactsStamped contacts_msg;\n        contacts_msg.header.stamp = ros::Time::now();\n        contacts_msg.header.frame_id = \"base_link\";\n\n        // Populate the message with the current gait phase of each leg\n        for (int i = 0; i < 4; i++) {\n            free_gait_msgs::Contact contact;\n            contact.name = base_.legs[i]->name;\n            contact.contact = foot_contacts[i];\n            contacts_msg.contacts.push_back(contact);\n        }\n\n        // Publish the message\n        foot_contacts_publisher_.publish(contacts_msg);\n    }\n}", "CodeBleu_score": 54.15989731658439}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t    if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n        // Create a ContactsStamped message\n        free_gait_msgs::ContactsStamped contacts_msg;\n        contacts_msg.header.stamp = ros::Time::now();\n\n        // Populate the message with the current gait phase of each leg\n        for (int i = 0; i < 4; i++) {\n            free_gait_msgs::Contact contact;\n            contact.contact_state = foot_contacts[i];\n            contact.phase = base_.legs[i]->gait_phase;\n            contacts_msg.contacts.push_back(contact);\n        }\n\n        // Publish the message\n        foot_contacts_publisher_.publish(contacts_msg);\n    }\n}", "CodeBleu_score": 55.47193245029942}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    // Create a ContactsStamped message\n    quadruped_msgs::ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n\n    // Populate the message with the current gait phase of each leg\n    for (int i = 0; i < 4; i++) {\n      quadruped_msgs::Contact contact;\n      contact.leg_index = i;\n      contact.phase = base_.legs[i]->gait_phase;\n      contact.contact = foot_contacts[i];\n      contacts_msg.contacts.push_back(contact);\n    }\n\n    // Publish the message\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 54.88406759106809}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message with the first 12 joint positions\n    joints_msg = Joints()\n    joints_msg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    joints_msg.position = joints.position[:12]\n\n    # Publish the joints message\n    self.publish(joints_msg)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    trajectory_msg = JointTrajectory()\n    trajectory_msg.joint_names = joints_msg.name\n    point = JointTrajectoryPoint()\n    point.positions = joints_msg.position\n    point.time_from_start = Duration(sec=5.0)\n    trajectory_msg.points.append(point)\n\n    # Publish the trajectory message to the joint trajectory topic\n    self.publish(trajectory_msg)\n}", "CodeBleu_score": 43.597568941628076}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message with the first 12 joint positions\n    minimal_joints = Joints()\n    minimal_joints.header.stamp = self.get_clock().now().to_msg()\n    minimal_joints.header.frame_id = 'base_link'\n    minimal_joints.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    minimal_joints.position = joints.position[:12]\n\n    # Publish the minimal joints message\n    self.joints_publisher.publish(minimal_joints)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    trajectory = JointTrajectory()\n    trajectory.header.stamp = self.get_clock().now().to_msg()\n    trajectory.header.frame_id = 'base_link'\n    trajectory.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[:12]\n    point.time_from_start = Duration(seconds=5.0)\n    trajectory.points.append(point)\n\n    # Publish the joint trajectory message\n    self.joint_trajectory_publisher.publish(trajectory)\n}", "CodeBleu_score": 38.85855810364321}, {"code": "def joints_cmd_callback(self, joints){\n\t    self.joints_msg.position = joints.position[0:12]\n    self.joints_pub.publish(self.joints_msg)\n\n    self.joint_traj_msg.points[0].positions = joints.position[0:12]\n    self.joint_traj_msg.points[0].time_from_start = self.duration\n    self.joint_traj_pub.publish(self.joint_traj_msg)\n}", "CodeBleu_score": 23.803207799715832}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  // Initialize foot contact states to false\n  bool l_foot_contact = false;\n  bool r_foot_contact = false;\n\n  // Process each contact in the message\n  for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n    // Split the collision string to identify the contact link\n    std::vector<std::string> strs;\n    boost::split(strs, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n    std::string collision_link = strs[strs.size() - 2];\n\n    // Check if the contact link matches one of the foot links\n    if (collision_link == \"left_sole_link\" || collision_link == \"left_foot_link\") {\n      l_foot_contact = true;\n    }\n    if (collision_link == \"right_sole_link\" || collision_link == \"right_foot_link\") {\n      r_foot_contact = true;\n    }\n  }\n\n  // Publish foot contact states\n  std_msgs::Bool l_foot_contact_msg;\n  l_foot_contact_msg.data = l_foot_contact;\n  l_foot_contact_pub_.publish(l_foot_contact_msg);\n\n  std_msgs::Bool r_foot_contact_msg;\n  r_foot_contact_msg.data = r_foot_contact;\n  r_foot_contact_pub_.publish(r_foot_contact_msg);\n}", "CodeBleu_score": 40.87510243763562}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    // Initialize foot contact states to false\n    for (int i = 0; i < 4; i++) {\n        footContactStates[i] = false;\n    }\n\n    // Process each contact in the message\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        // Split the collision string to identify the contact link\n        std::vector<std::string> contactLink = split(_msg->contact(i).collision1().c_str(), \"::\");\n        std::string contactLinkName = contactLink[contactLink.size() - 2];\n\n        // Check if the contact matches one of the foot links\n        if (contactLinkName == \"foot_fl\" || contactLinkName == \"foot_fr\" || contactLinkName == \"foot_rl\" || contactLinkName == \"foot_rr\") {\n            // Set the corresponding foot contact state to true\n            if (contactLinkName == \"foot_fl\") {\n                footContactStates[0] = true;\n            } else if (contactLinkName == \"foot_fr\") {\n                footContactStates[1] = true;\n            } else if (contactLinkName == \"foot_rl\") {\n                footContactStates[2] = true;\n            } else if (contactLinkName == \"foot_rr\") {\n                footContactStates[3] = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 49.67218139044814}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    // Initialize foot contact states to false\n    bool contact_state_lf = false;\n    bool contact_state_rf = false;\n    bool contact_state_lh = false;\n    bool contact_state_rh = false;\n\n    // Iterate over all contacts in the message\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        // Split the collision string to identify the contact link\n        std::vector<std::string> collision_parts;\n        boost::split(collision_parts, _msg->contact(i).collision1(), boost::is_any_of(\"::\"));\n        std::string collision_link = collision_parts[0];\n\n        // Check if the contact link matches one of the foot links\n        if (collision_link == \"l_foot_collision\" || collision_link == \"l_foot_lower_collision\") {\n            contact_state_lf = true;\n        } else if (collision_link == \"r_foot_collision\" || collision_link == \"r_foot_lower_collision\") {\n            contact_state_rf = true;\n        } else if (collision_link == \"l_foot_lower_collision\") {\n            contact_state_lh = true;\n        } else if (collision_link == \"r_foot_lower_collision\") {\n            contact_state_rh = true;\n        }\n    }\n\n    // Update the foot contact states\n    contact_state_lf_ = contact_state_lf;\n    contact_state_rf_ = contact_state_rf;\n    contact_state_lh_ = contact_state_lh;\n    contact_state_rh_ = contact_state_rh;\n}", "CodeBleu_score": 40.284438246449035}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_cmd_);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 81.90311523531278}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_cmd_);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::VectorXd angular_acceleration_thrust(5);\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n  angular_acceleration_thrust(4) = moments_.desired_thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 79.54420596906277}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_takeoff_);\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector3d angular_acceleration_thrust = angular_acceleration.cross(odometry_.orientation.toRotationMatrix().col(2))\n                                                 + odometry_.angular_velocity.cross(odometry_.angular_velocity);\n  // Add thrust and angular acceleration together to get desired angular velocity\n  // Convert desired angular velocity into angular rates using small angle approximation\n  angular_acceleration_thrust.block<2, 1>(0, 0) = vehicle_parameters_.inertia_.inverse() * angular_acceleration_thrust.block<2, 1>(0, 0);\n  angular_acceleration_thrust.normalize();\n  *rotor_velocities = (angular_acceleration_thrust + acceleration) / thrust;\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = vehicle_parameters_.rotor_configuration_.min_rotor_velocity +\n                      ((*rotor_velocities - Eigen::VectorXd::", "CodeBleu_score": 77.85464425181608}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(initialized_params_);\n  assert(initialized_dynamics_);\n\n  // Compute the velocity tracking errors\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position_W;\n\n  // Transform the velocity to the world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - command_trajectory_.velocity_W;\n\n  Eigen::Vector3d acc_desired;\n  acc_desired = position_gain_.cwiseProduct(position_error) +\n                velocity_gain_.cwiseProduct(velocity_error) +\n                inertia_gain_.cwiseProduct(acceleration_W) +\n                Eigen::Vector3d(0, 0, -gravity_);\n  *acceleration = acc_desired;\n}", "CodeBleu_score": 72.0885230467972}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration != nullptr);\n\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position.at(0);\n\n  // Transform the velocity to the world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_I = R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_I - command_trajectory_.velocity.at(0);\n\n  Eigen::Vector3d acc_desired = Eigen::Vector3d::Zero();\n  acc_desired += position_error.cwiseProduct(position_gain_);\n  acc_desired += velocity_error.cwiseProduct(velocity_gain_);\n\n  // We can't output a vertical acceleration at zero.\n  acc_desired(2) = (acc_desired(2) > 0.0) ? acc_desired(2) : 0.0;\n  *acceleration = acc_desired;\n}", "CodeBleu_score": 62.12393982729192}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  assert(acceleration != nullptr);\n\n  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  // Transform velocity to world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  position_error = odometry_.position - command_trajectory_.position_W;\n  velocity_error = velocity_W - command_trajectory_.velocity_W;\n\n  Eigen::Vector3d acc_grav = R_W_I.col(2) * (-EARTH_GRAVITY);\n  Eigen::Vector3d acc_correct = position_error.cwiseProduct(position_gain_) + velocity_error.cwiseProduct(velocity_gain_);\n\n  *acceleration = acc_grav + acc_correct + command_trajectory_.acceleration_W;\n  (*acceleration)(2) = 0.0;\n}", "CodeBleu_score": 71.42009658793167}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_attitude_controller_);\n\n  rotor_velocities->resize(rotor_count_);\n  Eigen::VectorXd angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd angular_acceleration_thrust(angular_acceleration);\n  angular_acceleration_thrust.resize(rotor_count_ + 1);\n  angular_acceleration_thrust(rotor_count_) = -angular_acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  *rotor_velocities = angular_acceleration_to_rotor_velocities_matrix_.transpose() * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_count_));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 62.73105706979866}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_attitude_controller_);\n\n  rotor_velocities->resize(rotor_velocities_.rows(), rotor_velocities_.cols());\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd angular_acceleration_thrust(5);\n  angular_acceleration_thrust << angular_acceleration,\n                                  control_attitude_thrust_reference_;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 73.47534301542066}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_attitude_controller_);\n\n  rotor_velocities->resize(rotor_count_);\n\n  Eigen::Vector3d angular_acceleration_thrust;\n  ComputeDesiredAngularAcc(&angular_acceleration_thrust);\n\n  Eigen::VectorXd angular_acceleration_thrust_reference(6);\n  angular_acceleration_thrust_reference << angular_acceleration_thrust, control_attitude_thrust_reference_;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust_reference;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_count_));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 64.51498740222998}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in copied_obj.attributes:\n        setattr(copied_obj, attr, getattr(copied_obj, attr)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 42.032623686454535}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in vars(copied_obj):\n        if isinstance(getattr(copied_obj, attr), np.ndarray):\n            setattr(copied_obj, attr, getattr(copied_obj, attr)[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 46.71163103848479}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for attr in vars(copied_obj):\n        attr_value = getattr(copied_obj, attr)\n        if isinstance(attr_value, list):\n            setattr(copied_obj, attr, attr_value[start_index:end_index])\n    return copied_obj\n\n", "CodeBleu_score": 42.143632321142064}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    pos = waypoint_msg.pose.position\n    rot = waypoint_msg.pose.orientation\n    yaw = euler_from_quaternion([rot.x, rot.y, rot.z, rot.w])[2]\n    point = Point(pos.x, pos.y, pos.z)\n    if len(self.points) == 0 or point != self.points[-1] or yaw != self.yaws[-1]:\n        self.points.append(point)\n        self.yaws.append(yaw)\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 21.429829168646954}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n\n    # Extract position and rotation from the waypoint message\n    pos = waypoint_msg.pose.pose.position\n    rot = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    yaw = euler_from_quaternion([rot.x, rot.y, rot.z, rot.w])[2]\n\n    # Create a Point object with the position data\n    point = Point(pos.x, pos.y, pos.z)\n\n    # Check if the current waypoint is different from the last one\n    if not self.points or point != self.points[-1] or yaw != self.yaws[-1]:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.points.append(point)\n        self.yaws.append(yaw)\n        self.times.append(msg_time)\n        self.bag_times.append(bag_time)\n\n", "CodeBleu_score": 21.2291150296567}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert the rotation to Euler angles\n    roll, pitch, yaw = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object with the position and yaw values\n    point = Point(position.x, position.y, yaw)\n\n    # Check if the current waypoint is different from the last one\n    if not self.waypoints or point != self.waypoints[-1]:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.yaw.append(yaw)\n        self.append_times(msg_time, bag_time)\n        self.append_point(point)\n\n", "CodeBleu_score": 25.663314193578234}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_time_bag.append(bag_time)\n        self.imu_accel_x.append(msg.linear_acceleration.x)\n        self.imu_accel_y.append(msg.linear_acceleration.y)\n        self.imu_accel_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.53560939183339}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_acc_x.append(msg.linear_acceleration.x)\n        self.imu_acc_y.append(msg.linear_acceleration.y)\n        self.imu_acc_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.428588771076}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_accel_x.append(msg.linear_acceleration.x)\n        self.imu_accel_y.append(msg.linear_acceleration.y)\n        self.imu_accel_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.551099583735414}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = pyplot.figure()\n    fig.suptitle(\"Acceleration Data\")\n    ax_a_x = fig.add_subplot(1, 1, 1)\n    ax_a_x.plot(self.acceleration_x, \"r\", label=\"x\")\n    ax_a_x.plot(self.acceleration_y, \"g\", label=\"y\")\n    ax_a_x.plot(self.acceleration_z, \"b\", label=\"z\")\n    ax_a_x.set_ylabel(\"Acceleration (m/s^2)\")\n    ax_a_x.set_xlabel(\"Time (s)\")\n    ax_a_x.legend()\n    if self.save_plots:\n        filename = \"acceleration\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 33.959948134329856}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n\n    fig = pyplot.figure()\n    fig.suptitle('Acceleration data')\n    ax_a_x = fig.add_subplot(111)\n    ax_a_x.plot(self.t, self.a_x, 'r', label='x')\n    ax_a_x.plot(self.t, self.a_y, 'g', label='y')\n    ax_a_x.plot(self.t, self.a_z, 'b', label='z')\n    ax_a_x.set_ylabel('Acceleration (m/s^2)')\n    ax_a_x.set_xlabel('Time (s)')\n    ax_a_x.legend()\n    if self.save_plots:\n        filename = 'accelerations'\n        if plot_suffix is not None:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        pyplot.savefig(filename)\n\n", "CodeBleu_score": 36.79408531320248}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if not self.save_plots:\n        return\n    fig = pyplot.figure(figsize=(12, 6))\n    fig.suptitle(f\"Accelerations for {self.name}\")\n    ax_a = fig.add_subplot(111)\n    for i, a_x in enumerate(self.accelerations):\n        ax_a.plot(a_x.times, a_x.values, label=f\"x{i}\")\n        ax_a.plot(a_x.times, a_x.values, label=f\"y{i}\")\n        ax_a.plot(a_x.times, a_x.values, label=f\"z{i}\")\n    ax_a.set_ylabel(\"Acceleration (m/s^2)\")\n    ax_a.set_xlabel(\"Time (s)\")\n    ax_a.legend()\n    if plot_suffix is None:\n        plot_suffix = \"\"\n    filename = f\"{self.name}_accelerations{plot_suffix}.png\"\n    pyplot.savefig(filename)\n\n", "CodeBleu_score": 42.25224748429873}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: At least two pose indices are required to perform comparisons.\")\n        return\n\n    for i, pose_index in enumerate(pose_indeces):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(pose_index, pose_indeces[j])\n\n", "CodeBleu_score": 41.567277399384025}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: At least two pose indices are required for comparison.\")\n        return\n\n    for i, index1 in enumerate(pose_indeces):\n        for index2 in pose_indeces[i + 1:]:\n            compare_two_xyz(self, index1, index2)\n\n", "CodeBleu_score": 40.39374612974588}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"At least two pose indeces are required to perform comparisons.\")\n        return\n\n    for i, pose_index1 in enumerate(pose_indeces):\n        for j in range(i + 1, len(pose_indeces)):\n            pose_index2 = pose_indeces[j]\n            compare_two_xyz(self, pose_index1, pose_index2)\n\n", "CodeBleu_score": 44.859893142442154}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 36.74172620165253}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision_time in self.wrench:\n        if start_time is not None and collision_time < start_time:\n            continue\n        if end_time is not None and collision_time > end_time:\n            break\n        collision_times.append(collision_time)\n    return collision_times\n\n", "CodeBleu_score": 39.608774818391964}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time is None or time >= start_time:\n            if end_time is None or time <= end_time:\n                collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 43.106439814849686}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n\n    # Calculate the absolute settling time\n    absolute_settling_time = start_time + settling_time\n\n    # Call plot_angular_velocities with the specified parameters\n    analyze_bag.plot_angular_velocities(\n        start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 35.28137792029307}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    abs_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 30.760733497479364}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(\n        start_time, end_time, absolute_settling_time, x_range, plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 38.20206225847643}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  // Multiplier is a value that is used to scale the noise based on the camera parameters.\n  const float multiplier =\n      (0.12f * (1 << (1 - (int)this->noise_param.filter_decimation_factor))) /\n      ((float)this->noise_param.filter_decimation_factor * 1000.0f);\n\n  // Map the data to an Eigen vector.\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n  // Compute the RMS noise.\n  const float rms_noise =\n      this->noise_param.noise_std * multiplier * this->noise_param.filter_decimation_factor;\n\n  // Compute the noise values.\n  const float noise =\n      this->noise_param.noise_std * multiplier * this->noise_param.filter_decimation_factor;\n\n  // Apply noise to the data.\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (InRange(data_vector_map[i] * 1000.0f, this->noise_param.min_depth,\n                this->noise_param.max_depth)) {\n      data_vector_map[i] +=\n          noise * tanf(this->noise_param.noise_seed * i) *\n          (rms_noise * rms_noise / (rms_noise * rms_noise +\n                                    (data_vector_map[i] * 1000.0f) *\n                                        (data_vector_map[i] * 1000.0f)));\n    } else {\n      data_vector_map[i] = bad_point;\n    }\n  }\n}", "CodeBleu_score": 49.39898584120927}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  float multiplier =\n      (this->dist_to_plane_mm_ / 1000.0) /\n      (this->focal_length_x_ * tanf(this->h_fov_ / 2.0) * 2.0);\n\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n\n  float rms_noise =\n      this->noise_param_1_ * multiplier + this->noise_param_2_ * multiplier * multiplier;\n\n  Eigen::VectorXf noise = Eigen::VectorXf::Random(width * height) * rms_noise;\n\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (InRange(data_vector_map(i) * 1000.0,\n                 this->min_depth_mm_,\n                 this->max_depth_mm_)) {\n      data_vector_map(i) =\n          (data_vector_map(i) * 1000.0 + noise(i)) / 1000.0;\n    } else {\n      data_vector_map(i) = this->bad_point_;\n    }\n  }\n}", "CodeBleu_score": 51.431684002174826}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (!data) return;\n  float multiplier =\n      (1.0f / (this->dist * this->dist)) *\n      (this->camera_params.fx * this->camera_params.fy) *\n      (this->camera_params.fx * this->camera_params.fy);\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n  float rms_noise =\n      std::min(this->dist * 1000.0f,\n               std::sqrt(data_vector_map.array().square().mean()));\n  Eigen::VectorXf noise =\n      Eigen::VectorXf::Random(width * height) * rms_noise;\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (InRange(data_vector_map(i))) {\n      data_vector_map(i) +=\n          std::tanf(noise(i)) * multiplier * data_vector_map(i);\n    } else {\n      data_vector_map(i) = bad_point;\n    }\n  }\n}", "CodeBleu_score": 49.32822466502776}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  common::Time sim_time = world_->SimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = ros::Time(sim_time.sec, sim_time.nsec);\n\n  // Write the trajectory message to the bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 69.10951654875332}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  common::Time current_time = world_->SimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time;\n  ros_time.sec = current_time.sec;\n  ros_time.nsec = current_time.nsec;\n\n  // Write the trajectory message to the bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 61.81316518464766}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t    ros::Time time = ros::Time::now();\n    ros::Time sim_time = world_->SimTime();\n\n    bag_.write(namespace_ + \"/\" + waypoint_topic_, time, *trajectory_msg);\n}", "CodeBleu_score": 52.87953628566776}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert the simulation time to ROS time\n  ros::Time now_ros = ros::Time::now();\n\n  // Prepare a message for actuator velocities\n  gazebo_msgs::msgs::ActuatorVelocities rot_velocities_msg;\n  rot_velocities_msg.set_stamp(now_ros);\n\n  // Iterate through the motor joints\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Calculate the slowed-down rotational velocities\n    double slowed_down_velocity = m->second->GetVelocity(0) * motor_velocity_slowdown_factor_;\n    rot_velocities_msg.add_angular_velocities(slowed_down_velocity);\n  }\n\n  // Set the message timestamp\n  rot_velocities_msg.set_stamp(now_ros);\n\n  // Write the message to a bag file\n  writeBag(motor_topic_, rot_velocities_msg, motor_namespace_);\n}", "CodeBleu_score": 51.874237397457094}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time time_now = ros::Time::now();\n\n  // Prepare message for actuator velocities\n  gazebo_msgs::ActuatorVelocities rot_velocities_msg;\n  rot_velocities_msg.header.stamp = ros::Time::now();\n\n  // Iterate through the motor joints\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Calculate the slowed-down rotational velocities\n    double slowed_down_velocity = m->second->GetVelocity(0) * motor_velocity_slowdown_;\n\n    // Assign the slowed-down velocities to the message\n    rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n    rot_velocities_msg.angular_velocities[m - motor_joints_.begin()] = slowed_down_velocity;\n  }\n\n  // Set the message timestamp\n  rot_velocities_msg.header.stamp = time_now;\n\n  // Write the data to the bag file\n  writeBag(namespace_, motor_topic_, rot_velocities_msg);\n}", "CodeBleu_score": 62.03787525237888}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time now_ros = ros::Time::now();\n\n  // Prepare message\n  sensor_msgs::JointState rot_velocities_msg;\n  rot_velocities_msg.header.stamp = now_ros;\n  rot_velocities_msg.name.resize(motor_joints_.size());\n  rot_velocities_msg.velocity.resize(motor_joints_.size());\n\n  // Iterate through motor joints\n  for (auto m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    // Calculate slowed-down rotational velocities\n    double rot_velocity = m->second->GetVelocity(0) * slowdown_factor_;\n\n    // Assign to message\n    rot_velocities_msg.name[m - motor_joints_.begin()] = m->first;\n    rot_velocities_msg.velocity[m - motor_joints_.begin()] = rot_velocity;\n  }\n\n  // Set message timestamp\n  rot_velocities_msg.header.stamp = now_ros;\n\n  // Write to bag\n  writeBag(motor_topic_, \"sensor_msgs/JointState\", rot_velocities_msg);\n}", "CodeBleu_score": 61.96834502543418}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  double roll = roll_pitch_yawrate_thrust_msg->roll();\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch();\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n\n  double aileron_left = NormalizedInputToAngle(roll);\n  double aileron_right = -NormalizedInputToAngle(roll);\n  double elevator = -NormalizedInputToAngle(pitch);\n  double rudder = -NormalizedInputToAngle(yaw_rate);\n  double throttle = thrust;\n\n  SetControlSurfaceAngles(aileron_left, aileron_right, elevator, rudder);\n  SetThrottle(throttle);\n}", "CodeBleu_score": 61.73517158838471}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to\n  // control surface angles for ailerons, elevator, and rudder respectively.\n  double aileron_left_angle =\n      NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  double aileron_right_angle =\n      NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  double elevator_angle =\n      NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch());\n  double rudder_angle =\n      NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Call the SetControlSurfaceAngles function with the converted control\n  // surface angles and throttle value.\n  SetControlSurfaceAngles(aileron_left_angle, aileron_right_angle,\n                          elevator_angle, rudder_angle, throttle);\n}", "CodeBleu_score": 62.73157174942254}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Convert normalized input values to control surface angles\n  // Ailerons\n  double aileron_left = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  double aileron_right = -NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->roll());\n  // Elevator\n  double elevator = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->pitch());\n  // Rudder\n  double rudder = NormalizedInputToAngle(roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set control surface angles\n  joints_[\"left_aileron_joint\"]->SetParam(\"vel\", 0, aileron_left);\n  joints_[\"right_aileron_joint\"]->SetParam(\"vel\", 0, aileron_right);\n  joints_[\"elevator_joint\"]->SetParam(\"vel\", 0, elevator);\n  joints_[\"rudder_joint\"]->SetParam(\"vel\", 0, rudder);\n\n  // Set throttle\n  joints_[\"left_engine_propeller_joint\"]->SetParam(\"fmax\", 0, roll_pitch_yawrate_thrust_msg->thrust());\n  joints_[\"right_engine_propeller_joint\"]->SetParam(\"fmax\", 0, roll_pitch_yawrate_thrust_msg->thrust());\n}", "CodeBleu_score": 58.32731907302578}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // poll for MAVLink messages\n  if (readMessages) {\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(fd, &readfds);\n    timeval timeout;\n    timeout.tv_sec = 0;\n    timeout.tv_usec = _timeoutMs * 1000;\n    int ret = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);\n    if (ret < 0) {\n      std::cerr << \"select error\n\";\n      throw std::runtime_error(\"select error\");\n    }\n    if (ret > 0) {\n      // something to read\n      uint8_t buf[2048];\n      int bufsize = read(fd, buf, 2048);\n      if (bufsize > 0) {\n        mavlink_message_t msg;\n        uint8_t msgReceived = false;\n        for (int k = 0; k < bufsize; k++) {\n          msgReceived = mavlink_parse_char(MAVLINK_COMM_0, buf[k], &msg, &mavlinkStatus);\n          if (msgReceived) {\n            // forward message via serial\n            if (serialEnabled) {\n              send_mavlink_message(serial_fd, &msg);\n            }\n            // handle message\n            handle_message(&msg);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 48.323510852508676}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // poll for MAVLink messages\n  if (readMessages) {\n    fd_set readfds = mavlink_interface_fd;\n    timeval timeout;\n    timeout.tv_sec = 0;\n    timeout.tv_usec = _timeoutMs * 1000;\n    int status = select(mavlink_interface_fd.fd_count, &readfds, NULL, NULL,\n                        &timeout);\n    if (status > 0) {\n      if (FD_ISSET(mavlink_interface_fd.fd_array[0], &readfds)) {\n        int len = ::recvfrom(mavlink_interface_fd.fd_array[0],\n                             mavlink_buffer, sizeof(mavlink_buffer), 0,\n                             (struct sockaddr *)&mavlink_interface_addr,\n                             &mavlink_interface_addrlen);\n        if (len > 0) {\n          mavlink_message_t message;\n          mavlink_status_t status;\n          for (ssize_t i = 0; i < len; ++i) {\n            if (mavlink_parse_char(MAVLINK_COMM_1, mavlink_buffer[i],\n                                   &message, &status)) {\n              // forward message via serial\n              if (serial_enabled) {\n                send_mavlink_message(serial_fd, &message);\n              }\n              // handle message\n              handle_message(&message);\n            }\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 55.80689090877825}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Poll serial port for data\n  int ret = poll(&fds, 1, _timeoutMs);\n\n  if (ret > 0) {\n    // Only parse MAVLink messages if data is available\n    if (fds.revents & POLLIN) {\n      // Receive data from serial port\n      ssize_t recv_len = recvfrom(fds.fd, buf, sizeof(buf), 0, NULL, NULL);\n      if (recv_len > 0) {\n        // Parse MAVLink messages from buffer\n        mavlink_message_t msg;\n        mavlink_status_t status;\n        for (ssize_t i = 0; i < recv_len; i++) {\n          if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status)) {\n            // Forward MAVLink message to serial connection\n            if (serial_conn_) {\n              serial_conn_->send_message(&msg);\n            }\n            // Handle MAVLink message\n            handle_message(&msg);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 57.180321484217046}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t  std::lock_guard<std::mutex> lock(mutex);\n  if (is_open()) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n}", "CodeBleu_score": 69.29548225540556}, {"code": "void GazeboMavlinkInterface::close() {\n\t  boost::mutex::scoped_lock lock(mutex);\n  if (serial_dev_.is_open()) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n}", "CodeBleu_score": 66.90365610009373}, {"code": "void GazeboMavlinkInterface::close() {\n\t  boost::mutex::scoped_lock lock(mutex);\n  if (is_open()) {\n    io_service_.stop();\n    serial_dev_.close();\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n  }\n}", "CodeBleu_score": 68.73164459149605}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    ignition::math::Vector3d position = this->wind_velocity_map_ptr_->Position(ignition::math::Vector3d(x, y, z));\n    ignition::math::Vector3d wind_velocity = ignition::math::Vector3d(0, 0, 0);\n    if (position.X() < 0 || position.X() >= this->wind_velocity_map_ptr_->XPoints() - 1 || position.Y() < 0 || position.Y() >= this->wind_velocity_map_ptr_->YPoints() - 1 || position.Z() < 0 || position.Z() >= this->wind_velocity_map_ptr_->ZPoints() - 1) {\n        return wind_velocity;\n    }\n\n    ignition::math::Vector3i position_i = ignition::math::Vector3i(position.X(), position.Y(), position.Z());\n    ignition::math::Vector3d position_f = ignition::math::Vector3d(position.X() - position_i.X(), position.Y() - position_i.Y(), position.Z() - position_i.Z());\n\n    ignition::math::Vector3d wind_velocity_000 = this->wind_velocity_map_ptr_->At(position_i.X(), position_i.Y(), position_i.Z());\n    ignition::math::Vector3d wind_velocity_100 = this->wind_velocity_map_ptr_->At(position_i.X() + 1, position_i.Y(), position_i.Z());\n    ignition::math::Vector3d wind_velocity_010 = this->wind_velocity_map_ptr_->At(position_i.X(), position_i.Y() + 1, position_i.Z());\n    ignition::math::Vector3d wind_velocity_110 = this->wind_velocity_map_ptr_->At(position_i.X() + 1, position_i.Y() + 1, position_i.Z());\n    ignition::math::Vector3d wind_velocity", "CodeBleu_score": 30.7943099052445}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    double x_diff = x_1 - x_0;\n    double y_diff = y_1 - y_0;\n    double z_diff = z_1 - z_0;\n\n    double x_ratio = (x_diff == 0) ? 0 : (x - x_0) / x_diff;\n    double y_ratio = (y_diff == 0) ? 0 : (y - y_0) / y_diff;\n    double z_ratio = (z_diff == 0) ? 0 : (z - z_0) / z_diff;\n\n    double x_interp = x_0 + x_ratio * x_diff;\n    double y_interp = y_0 + y_ratio * y_diff;\n    double z_interp = z_0 + z_ratio * z_diff;\n\n    return ignition::math::Vector3d(x_interp, y_interp, z_interp);\n}", "CodeBleu_score": 32.58652250294719}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d position;\n  double x_min, x_max, y_min, y_max, z_min, z_max;\n  double x_value, y_value, z_value;\n  double x_ratio, y_ratio, z_ratio;\n  ignition::math::Vector3d value1, value2, value3, value4, value5, value6;\n\n  position = wind_velocity_msg_.position;\n  x_min = wind_velocity_msg_.x_min;\n  x_max = wind_velocity_msg_.x_max;\n  y_min = wind_velocity_msg_.y_min;\n  y_max = wind_velocity_msg_.y_max;\n  z_min = wind_velocity_msg_.z_min;\n  z_max = wind_velocity_msg_.z_max;\n  x_value = position.X();\n  y_value = position.Y();\n  z_value = position.Z();\n\n  if (x_value < x_min) x_value = x_min;\n  if (x_value > x_max) x_value = x_max;\n  if (y_value < y_min) y_value = y_min;\n  if (y_value > y_max) y_value = y_max;\n  if (z_value < z_min) z_value = z_min;\n  if (z_value > z_max) z_value = z_max;\n\n  x_ratio = (x_value - x_min) / (x_max - x_min);\n  y_ratio = (y_value - y_min) / (y_max - y_min);\n  z_ratio = (z_value - z_min) / (z_max - z_min);\n\n  value1 = wind_velocity_msg_.x_min_y_min_z_min;\n  value2 = wind_velocity_msg_.x_min_y_min_z_max;\n  value3 = wind_velocity_msg_.x_min_y_max_z_min;", "CodeBleu_score": 32.95530054244558}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t  if (this->time != _time) {\n    this->time = _time;\n    this->timeDirty = true;\n  }\n}", "CodeBleu_score": 35.58948933164918}, {"code": "void Animation::SetTime(double _time){\n\t  if (looping) {\n    _time = fmod(_time, this->Length());\n  } else {\n    _time = ignition::math::clamp(_time, 0.0, this->Length());\n  }\n  if (_time != timePos) {\n    timePos = _time;\n    this->UpdateNodes();\n  }\n}", "CodeBleu_score": 42.12622829422464}, {"code": "void Animation::SetTime(double _time){\n\t  if (_time != timePos) {\n    timePos = _time;\n    if (timePos < 0) {\n      timePos = 0;\n    }\n    if (timePos > length) {\n      timePos = length;\n    }\n    this->timePosChanged();\n  }\n}", "CodeBleu_score": 41.632142822289424}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.construct_target()\n    self.set_attitude_target_to_current_attitude()\n    self.set_mav_frame(1)\n    self.set_mav_type(0)\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)", "CodeBleu_score": 12.824904485632512}, {"code": "def hover(self)\n\t\n    self.construct_target()\n    self.vehicle.simple_goto(self.target_position, airspeed=10)\n    print(self.vehicle_type, self.vehicle_id, self.vehicle.mode)\n\n", "CodeBleu_score": 10.25341281800068}, {"code": "def hover(self)\n\t\n    self.construct_target()\n    self.set_attitude_target_to_current_attitude()\n    self.set_attitude_target(0, 0, 0, 0.6, 0.5)\n    self.set_attitude_target_thrust(0.5)\n    self.set_attitude_target_type(0)\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)", "CodeBleu_score": 20.84078543038761}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hover = 1\n        self.hover()\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print(f\"Flight mode switched to {self.flightMode}\")\n            return True\n        except Exception as e:\n            print(f\"Failed to switch flight mode: {e}\")\n            return False", "CodeBleu_score": 50.04631819127477}, {"code": "def flight_mode_switch(self)\n\t\n    if self.hover == 1:\n        self.hover = 0\n        self.hover_mode()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print(\"Flight mode switched to \" + self.flightMode)\n            return True\n        except:\n            print(\"Flight mode switch failed\")\n            return False\n\n", "CodeBleu_score": 40.22623350274151}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hover = 1\n        self.hover()\n    else:\n        try:\n            self.flightModeService.setFlightMode(self.flightMode)\n            print(\"Successfully changed to \" + self.flightMode + \" mode\")\n            return True\n        except:\n            print(\"Failed to change to \" + self.flightMode + \" mode\")\n            return False\n\n", "CodeBleu_score": 36.06442914691901}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n", "CodeBleu_score": 34.74712745252826}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear, msg.angular)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear, msg.angular, \"enu\")\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear, msg.angular)\n", "CodeBleu_score": 22.147435825313472}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.construct_target(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n", "CodeBleu_score": 35.23236175551183}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.flight_mode = \"OFFBOARD\"\n    else:\n        self.hover_flag = 1\n        self.flight_mode = \"HOVER\"\n        self.hover()\n\n", "CodeBleu_score": 65.48524986945768}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.set_flight_mode('OFFBOARD')\n    else:\n        if self.flight_mode != 'HOVER':\n            self.hover_flag = 1\n            self.set_flight_mode('HOVER')\n            self.hover()\n\n", "CodeBleu_score": 43.64398069919687}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.set_flight_mode(\"OFFBOARD\")\n        else:\n            self.hover_flag = 1\n            self.set_flight_mode(\"HOVER\")\n            self.hover()\n\n    else:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.set_flight_mode(\"OFFBOARD\")\n        else:\n            self.hover_flag = 1\n            self.hover()", "CodeBleu_score": 58.332743697569946}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        return q.yaw_pitch_roll[0]", "CodeBleu_score": 42.03119669833365}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q).yaw_pitch_roll[0]", "CodeBleu_score": 24.58575872254351}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q)\n        return q.yaw_pitch_roll[0]", "CodeBleu_score": 31.245351062239585}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.update_coordinate_frame()\n    self.motion_type = \"hover\"\n    self.construct_target(self.position, self.yaw)\n    print(\n        f\"{self.vehicle_type} {self.vehicle_id} is flying in hover mode.\"\n    )", "CodeBleu_score": 12.542900375021926}, {"code": "def hover(self)\n\t\n    self.construct_target()\n    self.update_coordinate_frame()\n    self.motion_type = \"hover\"\n    print(f\"{self.vehicle_type} {self.vehicle_id} is now in hover mode.\")\n\n", "CodeBleu_score": 15.794422933971145}, {"code": "def hover(self)\n\t\n    self.update_coordinate_frame()\n    self.motion_type = \"hover\"\n    self.construct_target()\n    print(f\"{self.vehicle_type} {self.vehicle_id} is in {self.motion_type} mode\")", "CodeBleu_score": 10.749561425839193}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n    else:\n        if self.flightModeService.setFlightMode(self.flight_mode):\n            print(f\"Flight mode set to {self.flight_mode}\")\n            return True\n        else:\n            print(\"Failed to set flight mode\")\n            return False\n\n", "CodeBleu_score": 44.80743265236461}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flightMode == \"HOVER\":\n        self.hover = True\n        self.hover()\n    else:\n        try:\n            self.flightModeService(self.flightMode)\n            print(\"Flight mode set to \" + self.flightMode)\n            return True\n        except Exception as e:\n            print(\"Failed to set flight mode: \", e)\n            return False", "CodeBleu_score": 45.59539947978315}, {"code": "def flight_mode_switch(self)\n\t\n    if self.hover:\n        self.hover = False\n        self.hover()\n    else:\n        if self.flightModeService:\n            if self.flightModeService.setFlightMode(self.flightMode):\n                print(\"Flight mode set to:\", self.flightMode)\n                return True\n            else:\n                print(\"Failed to set flight mode\")\n                return False\n        else:\n            print(\"Flight mode service not available\")\n            return False", "CodeBleu_score": 35.227418773498634}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == \"world\":\n        self.global_pose = msg\n    elif msg.header.frame_id == \"base_link\":\n        self.local_pose = msg\n    else:\n        raise ValueError(\"Unknown frame_id: {}\".format(msg.header.frame_id))\n\n    if i == self.uav_id:\n        if self.takeoff_target_pose is not None:\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n        if self.hover_target_pose is not None:\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n\n    self.local_pose.pose.position.x += self.position_bias[0]\n    self.local_pose.pose.position.y += self.position_bias[1]\n    self.local_pose.pose.position.z += self.position_bias[2]\n    self.global_pose.pose.position.x += self.position_bias[0]\n    self.global_pose.pose.position.y += self.position_bias[1]\n    self.global_pose.pose.position.z += self.position_bias[2]\n\n", "CodeBleu_score": 31.05777884195936}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        if self.gcs_command == \"TAKEOFF\":\n            self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n            self.takeoff_target_pose.pose.position.z = self.takeoff_altitude\n            self.hover_target_pose = copy.deepcopy(self.local_pose)\n            self.hover_target_pose.pose.position.z = self.hover_altitude\n        self.global_pose = copy.deepcopy(self.local_pose)\n        self.global_pose.pose.position.x += self.bias_x\n        self.global_pose.pose.position.y += self.bias_y\n        self.global_pose.pose.position.z += self.bias_z\n        self.global_pose.pose.orientation.x += self.bias_qx\n        self.global_pose.pose.orientation.y += self.bias_qy\n        self.global_pose.pose.orientation.z += self.bias_qz\n        self.global_pose.pose.orientation.w += self.bias_qw\n\n", "CodeBleu_score": 28.192297776936243}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.get_srcSystem() == i:\n        self.local_pose = msg\n        if self.takeoff_target_pose is not None and self.takeoff_target_pose.get_type() == msg.get_type():\n            self.takeoff_target_pose = copy.deepcopy(msg)\n        if self.hover_target_pose is not None and self.hover_target_pose.get_type() == msg.get_type():\n            self.hover_target_pose = copy.deepcopy(msg)\n        self.global_pose = copy.deepcopy(msg)\n        self.global_pose.position.x += self.bias_x\n        self.global_pose.position.y += self.bias_y\n        self.global_pose.position.z += self.bias_z\n\n", "CodeBleu_score": 29.710971966545785}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.local_position.z > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 60.40512724867122}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.altitude > 0.2:\n        return True\n    else:\n        return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 57.03249491742921}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.mode == \"GUIDED\":\n        if self.state.altitude > 0.2:\n            return True\n        else:\n            return False\n    else:\n        return False\n\n", "CodeBleu_score": 60.09547653083062}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize the distance matrix with zeros\n    dist_matrix = np.zeros((len(orig_formation), len(orig_formation)))\n\n    # Iterate over the UAVs in the original formation\n    for i in range(len(orig_formation)):\n        # Iterate over the UAVs in the changed formation\n        for j in range(len(orig_formation)):\n            # Calculate the Euclidean distance between the UAVs in the original and changed formations\n            dist = np.linalg.norm(orig_formation[i] - change_formation[j])\n            # Adjust the distance by subtracting it from 50 and converting it to an integer\n            dist_matrix[i][j] = int(50 - dist)\n\n    # Return the distance matrix\n    return dist_matrix\n\n", "CodeBleu_score": 27.38210844950335}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    distance_matrix = np.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            distance_matrix[i][j] = int(50 - np.linalg.norm(orig_formation[i] - orig_formation[j]))\n    return distance_matrix\n\n", "CodeBleu_score": 26.10627776760716}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = []\n    for i in range(len(orig_formation)):\n        row = []\n        for j in range(len(orig_formation)):\n            dist = int(50 - np.linalg.norm(orig_formation[i] - change_formation[j]))\n            row.append(dist)\n        distance_matrix.append(row)\n    return distance_matrix\n\n", "CodeBleu_score": 27.964096950620366}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visited_left[i] = True\n    for j in self.adj_right[i]:\n        if self.visited_right[j]:\n            continue\n        gap = self.labels_left[i] + self.labels_right[j] - self.weights[(i, j)]\n        if gap == 0:\n            self.visited_right[j] = True\n            if self.match_right[j] is None or self.find_path(self.match_right[j]):\n                self.match_left[i] = j\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n\n\n\n", "CodeBleu_score": 32.95283120516909}, {"code": "def find_path(self, i)\n\t\n    self.visited_left[i] = True\n    for j in self.adj_right[i]:\n        if self.visited_right[j]:\n            continue\n        gap = self.left_label[i] + self.right_label[j] - self.weights[i][j]\n        if gap == 0:\n            self.visited_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_left[i] = j\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n\n", "CodeBleu_score": 35.654230063371436}, {"code": "def find_path(self, i)\n\t\n    self.visited_left[i] = True\n    for j in self.adj_right[i]:\n        if self.visited_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - self.weight[i][j]\n        if gap == 0:\n            self.visited_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_left[i] = j\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n\n", "CodeBleu_score": 38.39283912389754}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    # Initialize slack variables and reset visit arrays for each UAV\n    for uav in self.UAVs:\n        uav.slack = [float('inf')] * len(self.targets)\n        uav.visited = [False] * len(self.targets)\n\n    # Iterate over UAVs\n    for uav in self.UAVs:\n        # Initialize visit array for UAV\n        uav.visited = [False] * len(self.targets)\n\n        # Find a path for the UAV\n        while True:\n            # Initialize visit array for UAV\n            uav.visited = [False] * len(self.targets)\n\n            # Find a path for the UAV\n            if self.find_path(uav):\n                break\n\n            # Adjust labels based on minimum slack value\n            delta = float('inf')\n            for j in range(len(self.targets)):\n                if not uav.visited[j]:\n                    delta = min(delta, uav.slack[j])\n            for i in range(len(self.UAVs)):\n                if self.UAVs[i].visited:\n                    self.UAVs[i].labels[0] -= delta\n            for j in range(len(self.targets)):\n                if uav.visited[j]:\n                    self.UAVs[i].labels[j] += delta\n                else:\n                    uav.slack[j] -= delta\n\n    # Return match results for the right side of the bipartite graph\n    return [self.UAVs[i].match for i in range(len(self.UAVs))]\n", "CodeBleu_score": 33.9647455396373}, {"code": "def KM(self)\n\t\n    for uav_id in range(self.num_uavs):\n        slack = [float('inf')] * self.num_targets\n        slack_uav = [0] * self.num_targets\n        visit_left = [False] * self.num_uavs\n        visit_right = [False] * self.num_targets\n        while True:\n            visit_right = [False] * self.num_targets\n            if self.find_path(uav_id, visit_left, visit_right, slack, slack_uav):\n                break\n            d = float('inf')\n            for target_id in range(self.num_targets):\n                if not visit_right[target_id]:\n                    if slack[target_id] < d:\n                        d = slack[target_id]\n            for uav_id in range(self.num_uavs):\n                if visit_left[uav_id]:\n                    self.left_label[uav_id] -= d\n            for target_id in range(self.num_targets):\n                if visit_right[target_id]:\n                    self.right_label[target_id] += d\n                else:\n                    slack[target_id] -= d\n    match = [-1] * self.num_targets\n    for target_id in range(self.num_targets):\n        match[target_id] = self.right_match[target_id]\n    return match\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 31.52939073615092}, {"code": "def KM(self)\n\t\n    for uav in self.uavs:\n        slack = [float(\"inf\")] * len(self.tasks)\n        uav.visited = [False] * len(self.tasks)\n        while True:\n            uav.visited = [False] * len(self.tasks)\n            if self.find_path(uav, slack):\n                break\n            d = float(\"inf\")\n            for i in range(len(self.tasks)):\n                if not uav.visited[i] and slack[i] < d:\n                    d = slack[i]\n            for i in range(len(self.tasks)):\n                if uav.visited[i]:\n                    uav.label[i] -= d\n                else:\n                    slack[i] -= d\n    return [uav.match for uav in self.uavs]\n\n", "CodeBleu_score": 31.96113155731276}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds of the yellow color in HSV color space\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Create a mask for yellow color using the defined bounds\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    # Return the result\n    return result\n\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower = np.uint8([10, 100, 100])\n    upper = np.uint8([40, 255, 255])\n    mask = cv2.inRange(image, lower, upper)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 31.094069160000736}, {"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds for yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([40, 255, 255])\n\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result", "CodeBleu_score": 27.00416257573453}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t    if (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n        if (print_warning) {\n            ROS_WARN_THROTTLE(10.0, \"Standalone tag description with id %d not found.\", id);\n        }\n        return false;\n    }\n    descriptionContainer = standalone_tag_descriptions_[id];\n    return true;\n}", "CodeBleu_score": 34.70215230726021}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n  // Check if the description is found in the standalone_tag_descriptions_ map\n  if (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN_THROTTLE(1.0, \"Standalone tag description with id %d not found.\", id);\n    }\n    return false;\n  }\n\n  // If found, set the descriptionContainer to the tag's description and return true\n  descriptionContainer = standalone_tag_descriptions_[id];\n  return true;\n}", "CodeBleu_score": 34.11616791235311}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n    // Check if the description is found in the standalone_tag_descriptions_ map\n    if (standalone_tag_descriptions_.find(id) == standalone_tag_descriptions_.end()) {\n        if (printWarning) {\n            ROS_WARN_THROTTLE(10.0, \"Tag description not found. Tag ID: %d\", id);\n        }\n        return false;\n    }\n\n    // Set the descriptionContainer to the tag's description\n    descriptionContainer = standalone_tag_descriptions_[id];\n    return true;\n}", "CodeBleu_score": 35.76011506849115}]}
