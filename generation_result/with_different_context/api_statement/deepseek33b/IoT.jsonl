{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bLength != 0) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)(((uint8_t UDC_DESC_STORAGE *)desc) + desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 32.58853000684896}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bLength != 0) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc + desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.00003953282957}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\twhile (next_desc != NULL) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t\n\t\tUDC_DESC_STORAGE *)next_desc + next_desc->bLength);\n\t\tif (next_desc->bLength == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 39.432163415043924}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    // Check if there is a valid configuration\n    if (udc_get_eof_conf()) {\n        return false;\n    }\n\n    // Check if the interface number is within bounds\n    if (iface_num >= UDC_NUM_IFACES) {\n        return false;\n    }\n\n    // Iterate through the descriptors, starting from the beginning of the configuration descriptor\n    uint8_t *desc_ptr = (uint8_t *)udc_get_conf_desc();\n    while (desc_ptr != NULL) {\n        // Check if the current descriptor matches the specified interface number and setting number\n        if (desc_ptr[0] == UDC_DESC_TYPE_INTERFACE && desc_ptr[1] == iface_num && desc_ptr[2] == setting_num) {\n            return true;\n        }\n\n        // Move to the next descriptor\n        desc_ptr += desc_ptr[0];\n    }\n\n    return false;\n}", "CodeBleu_score": 32.02518067672009}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tusb_desc_t *desc;\n\tusb_cdc_desc_t *cdc_desc;\n\tusb_iface_desc_t *iface_desc;\n\tusb_endpoint_desc_t *ep_desc;\n\tuint8_t *desc_buf;\n\tuint8_t desc_size;\n\tuint8_t desc_type;\n\tuint8_t desc_idx;\n\tuint8_t iface_desc_idx;\n\tuint8_t iface_desc_count;\n\tuint8_t ep_desc_count;\n\tuint8_t i;\n\tuint8_t j;\n\tuint8_t k;\n\tuint8_t l;\n\tuint8_t m;\n\tuint8_t n;\n\tuint8_t o;\n\tuint8_t p;\n\tuint8_t q;\n\tuint8_t r;\n\tuint8_t s;\n\tuint8_t t;\n\tuint8_t u;\n\tuint8_t v;\n\tuint8_t w;\n\tuint8_t x;\n\tuint8_t y;\n\tuint8_t z;\n\tuint8_t a;\n\tuint8_t b;\n\tuint8_t c;\n\tuint8_t d;\n\tuint8_t e;\n\tuint8_t f;\n\tuint8_t g;\n\tuint8_t h;\n\tuint8_t i;\n\tuint8_t j;\n\tuint8_t k;\n\tuint8_t l;\n\tuint8_t m;\n\tuint8_t n;\n\tuint8_t o;\n\tuint8_t p;\n\tuint8_t q;\n\tuint8_t r;\n\tuint8_t s;\n\tuint8_t t;\n\tuint8_t u;\n\tuint8_t v;\n\tuint8_t w;\n\tuint8_t x;\n\tuint8_t y;\n\tuint8_t z;\n\tuint8_t a;\n\tuint8_t b;\n\tuint8_t c;\n", "CodeBleu_score": 7.591441844129526}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    // Check if there is a valid configuration\n    if (udc_config_valid) {\n        // Check if the interface number is within bounds\n        if (iface_num < udc_config_desc->bNumInterfaces) {\n            // Iterate through the descriptors, starting from the beginning of the configuration descriptor\n            uint8_t *desc_ptr = udc_config_desc->extra;\n            while (desc_ptr < udc_config_desc->extra + udc_config_desc->wTotalLength) {\n                // Check if the descriptor is an interface descriptor\n                if (*desc_ptr == USB_DESC_INTERFACE) {\n                    // Check if the interface number and setting number match\n                    if (desc_ptr[2] == iface_num && desc_ptr[3] == setting_num) {\n                        // Update the interface descriptor\n                        udc_interface_descriptors[iface_num].extra = desc_ptr;\n                        udc_interface_descriptors[iface_num].wTotalLength = desc_ptr[1];\n                        return true;\n                    }\n                }\n                // Move to the next descriptor\n                desc_ptr += desc_ptr[0];\n            }\n        }\n    }\n    return false;\n}", "CodeBleu_score": 39.490676354655186}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_addr;\n\tuint8_t ep_status;\n\tuint8_t ep_halted;\n\tuint16_t ep_stall;\n\tuint16_t ep_rx_count;\n\tuint16_t ep_tx_count;\n\tuint16_t ep_rx_size;\n\tuint16_t ep_tx_size;\n\tuint16_t ep_rx_buffer;\n\tuint16_t ep_tx_buffer;\n\tuint16_t ep_rx_buffer_size;\n\tuint16_t ep_tx_buffer_size;\n\tuint16_t ep_rx_buffer_count;\n\tuint16_t ep_tx_buffer_count;\n\tuint16_t ep_rx_buffer_count_size;\n\tuint16_t ep_tx_buffer_count_size;\n\tuint16_t ep_rx_buffer_count_size_size;\n\tuint16_t ep_tx_buffer_count_size_size;\n\tuint16_t ep_rx_buffer_count_size_size_size;\n\tuint16_t ep_tx_buffer_count_size_size_size;\n\tuint16_t ep_rx_buffer_count_size_size_size_size;\n\tuint16_t ep_tx_buffer_count_size_size_size_size;\n\tuint16_t ep_rx_buffer_count_size_size_size_size_size;\n\tuint16_t ep_tx_buffer_count_size_size_size_size_size;\n\tuint16_t ep_rx_buffer_count_size_size_size_size_size_size;\n\tuint16_t ep_tx_buffer_count_size_size_size_size_size_size;\n\tuint16_t ep_rx_buffer_count_size_size_size_size_size_size_size;\n\tuint16_t ep_tx_buffer_count_size_size_size_size_size_size_size;\n\tuint16_t ep_", "CodeBleu_score": 4.863724134074744}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udd_ep_is_halted(udd_ep_get_setup_address())) {\n        udd_set_setup_payload(udd_ep_get_setup_address(), 0);\n    } else {\n        udd_set_setup_payload(udd_ep_get_setup_address(), 0);\n    }\n    return true;\n}", "CodeBleu_score": 19.506309666620766}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udd_req.wLength != sizeof(udd_ep_status)) {\n        return false;\n    }\n\n    udd_ep_status = udd_ep_is_halted(udd_req.wValue & 0x0F);\n    udd_set_setup_payload((uint8_t*)&udd_ep_status, sizeof(udd_ep_status));\n    return true;\n}", "CodeBleu_score": 43.857862572474424}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t alt_setting;\n\tuint8_t *p_desc;\n\tuint8_t *p_desc_alt;\n\tuint8_t *p_desc_alt_new;\n\n\tiface_num = udi_api->setup.wIndex & 0x0F;\n\tif (iface_num > udc_num_ifaces) {\n\t\treturn false;\n\t}\n\n\tp_desc = udc_desc_iface[iface_num];\n\tp_desc_alt = p_desc + p_desc[0];\n\n\tif (udc_state == UDC_STATE_CONFIGURED) {\n\t\talt_setting = udi_api->setup.wValue;\n\t\tif (alt_setting < p_desc[2]) {\n\t\t\tp_desc_alt_new = p_desc + p_desc[0] + p_desc_alt[1] * p_desc_alt[0];\n\t\t\tudi_api->getsetting(iface_num, alt_setting, p_desc_alt_new);\n\t\t\tp_desc_alt[0] = p_desc_alt_new[0];\n\t\t\tp_desc_alt[1] = alt_setting;\n\t\t}\n\t}\n\n\treturn udi_api->setup(iface_num, udi_api->setup.wValue, udi_api->setup.wIndex, udi_api->setup.wLength);\n}", "CodeBleu_score": 47.67251091685477}, {"code": "static bool udc_req_iface(void){\n\t    if (udc_state != UDC_STATE_CONFIGURED) {\n        return false;\n    }\n\n    if (udi_api->setup.wIndex > udc_iface_count) {\n        return false;\n    }\n\n    udc_update_iface_desc(udi_api->setup.wIndex, 0);\n    udc_update_iface_desc(udi_api->setup.wIndex, udi_api->setup.wValue);\n\n    return udi_api->setup(&udi_api->getsetting);\n}", "CodeBleu_score": 48.031568072222704}, {"code": "static bool udc_req_iface(void){\n\t    uint8_t iface = udi_api->setup->wIndex;\n    if (iface >= udc_config.n_iface) {\n        return false;\n    }\n    if (!udc_config.is_configured) {\n        return false;\n    }\n    if (!udi_api->getsetting(UDI_IFACE_SETTING, iface)) {\n        return false;\n    }\n    if (!udc_update_iface_desc(iface)) {\n        return false;\n    }\n    return udi_api->setup(udi_api->setup);\n}", "CodeBleu_score": 30.38585377263233}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t    // Check if the MSC interface is already enabled\n    if (udi_msc_is_enabled()) {\n        // Return false if the MSC interface is already enabled\n        return false;\n    }\n\n    // Set the initial state of the MSC interface\n    udi_msc_init();\n\n    // Check if the external enable function fails\n    if (!udi_msc_enable_ext()) {\n        // Return false if the external enable function fails\n        return false;\n    }\n\n    // Retrieve the number of LUNs\n    uint8_t nb_lun = get_nb_lun();\n\n    // Check if there are any LUNs available\n    if (nb_lun == 0) {\n        // Return false if there are no LUNs available\n        return false;\n    }\n\n    // Unload the medium on each LUN\n    for (uint8_t i = 0; i < nb_lun; i++) {\n        mem_unload(i);\n    }\n\n    // Start the MSC process by waiting for a CBW reception\n    udi_msc_cbw_wait();\n\n    // Return true if the MSC interface is successfully enabled\n    return true;\n}", "CodeBleu_score": 42.97156268825641}, {"code": "bool udi_msc_enable(void){\n\t\tmem_unload();\n\tget_nb_lun();\n\tif (nb_lun == 0) {\n\t\treturn false;\n\t}\n\tif (!UDI_MSC_ENABLE_EXT()) {\n\t\treturn false;\n\t}\n\tudi_msc_cbw_wait();\n\treturn true;\n}", "CodeBleu_score": 14.638890470393303}, {"code": "bool udi_msc_enable(void){\n\t    // Check if the MSC interface is already enabled\n    if (udi_msc_cbw_wait) {\n        return true;\n    }\n\n    // Set initial states for several flags\n    udi_msc_cbw_wait = false;\n    udi_msc_cbw_wait_data = false;\n    udi_msc_cbw_wait_status = false;\n    udi_msc_cbw_wait_status_data = false;\n    udi_msc_cbw_wait_status_data_in = false;\n    udi_msc_cbw_wait_status_data_out = false;\n    udi_msc_cbw_wait_status_data_out_in = false;\n    udi_msc_cbw_wait_status_data_out_in_data = false;\n    udi_msc_cbw_wait_status_data_out_in_data_in = false;\n\n    // Retrieve the number of LUNs\n    uint8_t nb_lun = get_nb_lun();\n\n    // If no LUNs are available, return false\n    if (!nb_lun) {\n        return false;\n    }\n\n    // Check if the external enable function fails\n    if (!UDI_MSC_ENABLE_EXT()) {\n        return false;\n    }\n\n    // Unload the medium on each LUN\n    for (uint8_t i = 0; i < nb_lun; i++) {\n        mem_unload(i);\n    }\n\n    // Start the MSC process by waiting for a CBW reception\n    udi_msc_cbw_wait = true;\n\n    // Return true\n    return true;\n}", "CodeBleu_score": 50.876380848072664}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    if (status != UDD_EP_TRANSFER_OK) {\n        /* Wait for a MSC setup reset to restart CBW reception */\n        return;\n    }\n\n    /* Update the sense data */\n    udi_msc_sense_pass();\n\n    /* Decrease the data residue in the CSW by the amount of data sent */\n    udi_msc_csw.dDataResidue -= nb_sent;\n\n    /* Process the updated CSW */\n    udi_msc_csw_process();\n}", "CodeBleu_score": 69.14383696157734}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    if (status != UDD_EP_TRANSFER_OK) {\n        // Wait for a MSC setup reset to restart CBW reception\n        return;\n    }\n\n    // Update the sense data\n    udi_msc_sense_pass();\n\n    // Decrease the data residue in the CSW by the amount of data sent\n    udi_msc_csw_process(nb_sent);\n}", "CodeBleu_score": 54.64334836239492}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t    if (status != UDD_EP_TRANSFER_OK) {\n        // Wait for MSC setup reset to restart CBW reception\n        return;\n    }\n\n    // Update sense data\n    udi_msc_sense_pass();\n\n    // Decrease data residue in CSW by amount of data sent\n    udi_msc_csw.dDataResidue -= nb_sent;\n\n    // Process updated CSW\n    udi_msc_csw_process();\n}", "CodeBleu_score": 69.14383696157734}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\n\tuint32_t data_residue;\n\n\tif (udi_msc_csw.b.data_residue != 0) {\n\t\tif (udi_msc_csw.b.direction == UDI_MSC_CBW_DIR_OUT) {\n\t\t\tudd_ep_set_halt(udi_msc_csw.b.lun, UDI_MSC_EP_IN);\n\t\t} else {\n\t\t\tudd_ep_set_halt(udi_msc_csw.b.lun, UDI_MSC_EP_OUT);\n\t\t}\n\t}\n\n\tudi_msc_csw.b.tag = udi_msc_cbw.b.tag;\n\tdata_residue = udi_msc_csw.b.data_residue;\n\tudi_msc_csw.b.data_residue = 0;\n\tudi_msc_csw.b.status = UDI_MSC_CSW_STATUS_SUCCESS;\n\tudi_msc_csw.b.data_residue = cpu_to_le32(data_residue);\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 48.80028383705205}, {"code": "static void udi_msc_csw_process(void){\n\t    udi_msc_cbw_t *cbw = (udi_msc_cbw_t *)udi_msc_csw_cbw;\n    udi_msc_csw_t *csw = (udi_msc_csw_t *)udi_msc_csw_send;\n\n    if (udi_msc_csw_data_residue) {\n        if (cbw->bCBWCBLength) {\n            udd_ep_set_halt(udi_msc_csw_ep_in);\n        } else {\n            udd_ep_set_halt(udi_msc_csw_ep_out);\n        }\n    }\n\n    csw->dCSWTag = udi_msc_csw_tag;\n    csw->dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n    csw->bCSWStatus = UDI_MSC_CSW_STATUS_OK;\n    csw->dCSWDataResidue = cpu_to_le32(udi_msc_csw_data_residue);\n\n    udi_msc_csw_data_residue = 0;\n\n    udi_msc_csw_send_length = sizeof(udi_msc_csw_t);\n    udi_msc_csw_send_status = UDI_MSC_CSW_SEND_STATUS_OK;\n\n    udi_msc_csw_cbw = NULL;\n    udi_msc_csw_ep_in = NULL;\n    udi_msc_csw_ep_out = NULL;\n}", "CodeBleu_score": 40.14422288608339}, {"code": "static void udi_msc_csw_process(void){\n\t    uint8_t ep_addr;\n    uint32_t residue;\n    uint32_t tag;\n    uint32_t csw_addr;\n    uint8_t csw_data[13];\n\n    ep_addr = udi_msc_csw_ep_addr;\n    residue = udi_msc_csw_residue;\n    tag = udi_msc_csw_tag;\n    csw_addr = udi_msc_csw_csw_addr;\n\n    if (residue) {\n        udd_ep_set_halt(ep_addr);\n    }\n\n    csw_data[0] = 0x53;\n    csw_data[1] = 0x42;\n    csw_data[2] = 0x00;\n    csw_data[3] = 0x00;\n    csw_data[4] = tag & 0xFF;\n    csw_data[5] = (tag >> 8) & 0xFF;\n    csw_data[6] = (tag >> 16) & 0xFF;\n    csw_data[7] = (tag >> 24) & 0xFF;\n    csw_data[8] = 0x00;\n    csw_data[9] = 0x00;\n    csw_data[10] = 0x00;\n    csw_data[11] = 0x00;\n    csw_data[12] = residue & 0xFF;\n    csw_data[13] = (residue >> 8) & 0xFF;\n    csw_data[14] = (residue >> 16) & 0xFF;\n    csw_data[15] = (residue >> 24) & 0xFF;\n\n    udi_msc_csw_send(csw_addr, csw_data, 16);\n}", "CodeBleu_score": 32.15603475301698}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (port == USB_CDC_PORT) {\n        if (b_enable) {\n            usb_cdc_line_rtsdtr_callback(port, true);\n            cancelReset();\n        } else {\n            usb_cdc_line_rtsdtr_callback(port, false);\n            if (usb_cdc_line_coding[port].dwDTERate == 1200) {\n                initiateReset();\n            }\n        }\n    }\n}", "CodeBleu_score": 34.25416576280217}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (port == 0) {\n        if (b_enable) {\n            cancelReset();\n        } else {\n            if (usb_cdc_get_line_coding(port).dwDTERate == 1200) {\n                initiateReset();\n            }\n        }\n    }\n}", "CodeBleu_score": 34.30726249249745}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    // Update the DTR status\n    usb_cdc_dtr[port] = b_enable;\n\n    // Check if the DTR rate is 1200\n    if (usb_cdc_dtr_rate[port] == 1200) {\n        // If the DTR signal is disabled, schedule a delayed system reset\n        if (!b_enable) {\n            // Write to the reset controller\n            reset_controller_write(RESET_CONTROLLER_BASE, RESET_CONTROLLER_SYSTEM_RESET, 1);\n            // Call the \"initiateReset\" function\n            initiateReset();\n        }\n        // If the DTR signal is enabled, cancel any scheduled reset\n        else {\n            // Call the \"cancelReset\" function\n            cancelReset();\n        }\n    }\n}", "CodeBleu_score": 48.25557216682251}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tbool result = false;\n\tswitch (Udd_setup_type) {\n\tcase USB_SETUP_TYPE_STANDARD:\n\t\tswitch (Udd_setup_request) {\n\t\tcase 0x04:\n\t\t\tUdd_setup_payload_ptr = (uint8_t *)&Microsoft_compatible_id_descriptor;\n\t\t\tUdd_setup_payload_size = sizeof(Microsoft_compatible_id_descriptor);\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tUdd_setup_payload_ptr = (uint8_t *)&Microsoft_extended_properties_descriptor;\n\t\t\tUdd_setup_payload_size = sizeof(Microsoft_extended_properties_descriptor);\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn result;\n}", "CodeBleu_score": 20.820303383683374}, {"code": "bool usb_task_other_requests(void){\n\t    switch (Udd_setup_type) {\n    case USB_SETUP_TYPE_STANDARD:\n        if (Udd_setup_request == USB_SETUP_REQUEST_GET_DESCRIPTOR) {\n            if (Udd_setup_value == USB_SETUP_VALUE_DESCRIPTOR_MS_EXTENDED_PROPERTIES) {\n                Udd_control_payload = (uint8_t *)&Udd_ms_extended_properties_descriptor;\n                Udd_control_payload_size = sizeof(Udd_ms_extended_properties_descriptor);\n                return true;\n            }\n            if (Udd_setup_value == USB_SETUP_VALUE_DESCRIPTOR_MS_COMPAT_ID) {\n                Udd_control_payload = (uint8_t *)&Udd_ms_compat_id_descriptor;\n                Udd_control_payload_size = sizeof(Udd_ms_compat_id_descriptor);\n                return true;\n            }\n        }\n        break;\n    }\n    return false;\n}", "CodeBleu_score": 31.52105978716369}, {"code": "bool usb_task_other_requests(void){\n\t\tswitch (Udd_setup_type) {\n\tcase USB_SETUP_TYPE_VENDOR:\n\t\tif (Udd_setup_request == USB_SETUP_REQUEST_VENDOR_DEVICE) {\n\t\t\tif (Udd_setup_index == 0x04) {\n\t\t\t\tUdd_setup_payload = (uint8_t*)&Microsoft_Compatible_ID_Descriptor;\n\t\t\t\tUdd_setup_payload_size = sizeof(Microsoft_Compatible_ID_Descriptor);\n\t\t\t} else if (Udd_setup_index == 0x05) {\n\t\t\t\tUdd_setup_payload = (uint8_t*)&Microsoft_Extended_Properties_Descriptor;\n\t\t\t\tUdd_setup_payload_size = sizeof(Microsoft_Extended_Properties_Descriptor);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}", "CodeBleu_score": 18.12082243001697}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0)\n        return;\n\n    spiRec();\n    while (--nbyte) {\n        spiRec();\n        spiRec();\n        *buf++ = SPI_DATA;\n    }\n    spiRec();\n    *buf = SPI_DATA;\n}", "CodeBleu_score": 38.363046103636336}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0)\n    return;\n  spiRec();\n  while (--nbyte) {\n    spiSend(0xFF);\n    *buf++ = spiRec();\n  }\n  *buf = spiRec();\n}", "CodeBleu_score": 33.73116915830913}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0) return;\n    spiRec();\n    while (--nbyte) {\n        spiRec();\n        *buf++ = SPDR;\n    }\n    *buf = spiRec();\n}", "CodeBleu_score": 32.475968887924836}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler originalHandler;\n    uint32_t *pVectorTable;\n\n    // Get the relocated interrupt vector table address\n    pVectorTable = get_relocated_table_addr();\n\n    // Disable global interrupts to ensure atomic operation\n    __disable_irq();\n\n    // Retrieve the current handler for the specified IRQ\n    originalHandler = (pfnISR_Handler)pVectorTable[irq + 16];\n\n    // Replace the handler with the new handler\n    pVectorTable[irq + 16] = (uint32_t)newHandler;\n\n    // Re-enable global interrupts\n    __enable_irq();\n\n    // Return the original ISR handler\n    return originalHandler;\n}", "CodeBleu_score": 56.11669620790681}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler = NULL;\n    uint32_t *pIntVectorTable = get_relocated_table_addr();\n    uint32_t irq_number = (uint32_t)irq;\n\n    __disable_irq();\n    oldHandler = (pfnISR_Handler)pIntVectorTable[irq_number + 16];\n    pIntVectorTable[irq_number + 16] = (uint32_t)newHandler;\n    __enable_irq();\n\n    return oldHandler;\n}", "CodeBleu_score": 54.709516695163465}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n\n    CRITICAL_SECTION_START\n    {\n        // Get the address of the relocated interrupt vector table\n        uint32_t *vectorTable = get_relocated_table_addr();\n\n        // Disable global interrupts to ensure atomic operation\n        __disable_irq();\n\n        // Get the current handler for the specified IRQ\n        oldHandler = (pfnISR_Handler) vectorTable[irq + 16];\n\n        // Replace the handler with the new handler\n        vectorTable[irq + 16] = (uint32_t) newHandler;\n\n        // Re-enable global interrupts\n        __enable_irq();\n    }\n    CRITICAL_SECTION_END\n\n    return oldHandler;\n}", "CodeBleu_score": 55.2668651271499}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_task_cdc_isenabled()) {\n    int c = udi_cdc_getc();\n    if (c >= 0) {\n      if (TERN_(EMERGENCY_PARSER, ENABLED)) emergency_parser.update(c);\n      return c;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 40.40867188922609}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (is_enabled() && cdc_is_rx_ready()) {\n    char c;\n    cdc_getc(&c);\n    if (TERN_(EMERGENCY_PARSER, emergency_parser.update(c))) return c;\n  }\n  return -1;\n}", "CodeBleu_score": 36.58607056025775}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_task_cdc_isenabled()) {\n    int c = udi_cdc_getc();\n    if (c != -1) {\n      if (TERN_(EMERGENCY_PARSER, ENABLED)) emergency_parser.update(c);\n      return c;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 40.22983580439464}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  int c = -1;\n\n  if (emergency_parser.enabled) {\n    c = emergency_parser.update();\n    if (c > -1) return c;\n  }\n\n  if (usb_task_cdc_isenabled()) {\n    if (udi_cdc_is_rx_ready()) {\n      udi_cdc_getc();\n    }\n  }\n  else\n    c = -1;\n\n  return c;\n}", "CodeBleu_score": 39.258454460232365}, {"code": "int MarlinSerialUSB::read(){\n\t  int c = -1;\n\n  if (usb_task_cdc_isenabled()) {\n    if (emergency_parser.enabled) {\n      c = emergency_parser.update(udi_cdc_getc());\n      if (c >= 0) return c;\n    }\n    if (udi_cdc_is_rx_ready()) return udi_cdc_getc();\n  }\n  return -1;\n}", "CodeBleu_score": 45.715269352369496}, {"code": "int MarlinSerialUSB::read(){\n\t  if (usb_task_cdc_isenabled()) {\n    if (udi_cdc_is_rx_ready()) {\n      uint8_t c;\n      udi_cdc_getc(&c);\n      if (emergency_parser.enabled) emergency_parser.update(c);\n      return c;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 35.05773838699953}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  int n = usb_task_cdc_rx_pending_bytes();\n  if (n) return n;\n  return usb_task_cdc_isenabled() ? 1 : 0;\n}", "CodeBleu_score": 48.082317375296675}, {"code": "int MarlinSerialUSB::available(){\n\t  if (usb_task_cdc_isenabled()) {\n    return 0;\n  }\n  return udi_cdc_is_rx_ready();\n}", "CodeBleu_score": 22.623480048473276}, {"code": "int MarlinSerialUSB::available(){\n\t  if (rx_buffer_head != rx_buffer_tail) {\n    return ((uint32_t)(BUFFER_SIZE + rx_buffer_head - rx_buffer_tail)) % BUFFER_SIZE;\n  }\n  else if (usb_task_cdc_isenabled()) {\n    return 1;\n  }\n  else {\n    return 0;\n  }\n}", "CodeBleu_score": 34.039966446196516}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t c = ee_Read(pos);\n    if (writing) *value++ = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 65.80663681108155}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while(size--) {\n    uint8_t c = ee_Read(pos);\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 69.87951163584879}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while(size--) {\n    uint8_t c = ee_Read(pos);\n    if(writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 72.69575746041967}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t    const uint32_t pwm_pin = pin;\n    const uint32_t pwm_channel = get_pwm_channel(pwm_pin);\n    if (pwm_channel != INVALID_PWM_CHANNEL) {\n        // hardware PWM\n        ledcWrite(pwm_channel, value);\n    } else {\n        // software PWM\n        // find or allocate a new slot\n        int8_t pwm_index = INVALID_PWM_INDEX;\n        for (int i = 0; i < MAX_PWM_COUNT; i++) {\n            if (pwm_pins[i] == pwm_pin) {\n                pwm_index = i;\n                break;\n            }\n            if (pwm_pins[i] == INVALID_PWM_PIN) {\n                pwm_index = i;\n                break;\n            }\n        }\n        if (pwm_index == INVALID_PWM_INDEX) {\n            return;\n        }\n        if (pwm_index >= MAX_PWM_COUNT) {\n            return;\n        }\n        if (pwm_pins[pwm_index] == INVALID_PWM_PIN) {\n            pwm_pins[pwm_index] = pwm_pin;\n            pwm_count++;\n            if (pwm_count == 1) {\n                HAL_timer_start(PWM_TIMER_ID, PWM_TIMER_INTERVAL_US);\n            }\n        }\n        // set PWM value\n        const uint32_t pwm_value = (value * PWM_RESOLUTION) / (1 << res);\n        pwm_values[pwm_index] = pwm_value;\n    }\n}", "CodeBleu_score": 48.299589305280335}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t    if (pin == PIN_NONE) return;\n    if (value == 0) {\n        analogWrite(pin, 0);\n        return;\n    }\n    if (value == PWM_RANGE) {\n        analogWrite(pin, PWM_RANGE);\n        return;\n    }\n\n    const uint16_t pwm_value = value >> (16 - res);\n    const uint16_t pwm_value_max = (1 << res) - 1;\n    if (pwm_value > pwm_value_max) {\n        DEBUGV(\"PWM value %d is out of range (%d)\", pwm_value, pwm_value_max);\n        return;\n    }\n\n    const uint8_t channel = get_pwm_channel(pin);\n    if (channel != PWM_NONE) {\n        ledcWrite(channel, pwm_value);\n        return;\n    }\n\n    const uint8_t state = get_pwm_state(pin);\n    if (state == PWM_NONE) {\n        const uint8_t new_state = allocate_pwm_state(pin, freq, res);\n        if (new_state == PWM_NONE) {\n            DEBUGV(\"No PWM slots available for pin %d\", pin);\n            return;\n        }\n        const uint8_t channel = get_pwm_channel(pin);\n        if (channel == PWM_NONE) {\n            DEBUGV(\"No PWM channels available for pin %d\", pin);\n            return;\n        }\n        ledcWrite(channel, pwm_value);\n        return;\n    }\n\n    ledcWrite(state, pwm_value);\n}", "CodeBleu_score": 38.329863068220206}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t\n  if (pin >= PINS_COUNT) return;\n\n  const pin_t pin_index = pin;\n  const uint8_t pin_number = pin_to_pin_number(pin_index);\n  const uint8_t pin_function = pin_to_function(pin_index);\n\n  if (pin_function == PIN_FUNCTION_PWM) {\n    const uint8_t channel = get_pwm_channel(pin_number);\n    if (channel != INVALID_PWM_CHANNEL) {\n      ledcWrite(channel, value);\n      return;\n    }\n  }\n\n  if (pin_function == PIN_FUNCTION_DIGITAL) {\n    if (value == LOW) {\n      digitalWrite(pin, LOW);\n      return;\n    }\n    if (value == HIGH) {\n      digitalWrite(pin, HIGH);\n      return;\n    }\n  }\n\n  const uint8_t channel = get_pwm_channel(pin_number);\n  if (channel == INVALID_PWM_CHANNEL) {\n    if (used_pwm_channels >= PWM_CHANNELS) return;\n\n    if (used_pwm_channels == 0) {\n      HAL_timer_start(PWM_TIMER, PWM_FREQUENCY);\n    }\n\n    used_pwm_channels++;\n  }\n\n  const uint8_t channel = get_pwm_channel(pin_number);\n  if (channel == INVALID_PWM_CHANNEL) return;\n\n  const uint8_t resolution = res;\n  const uint32_t frequency = freq;\n\n  if (resolution < 1 || resolution > 16) return;\n\n  if (frequency < 1 || frequency > 1000000) return;\n\n  const uint32_t timer_frequency = HAL_timer_get_frequency(PWM_TIMER);\n  const uint32_t timer_counts = timer_frequency / frequency;\n  const uint32_t timer_max_count", "CodeBleu_score": 39.73167971929551}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  // Verify the servo delay array length\n  static_assert(sizeof(SERVO_DELAY) / sizeof(SERVO_DELAY[0]) == NUM_SERVOS, \"SERVO_DELAY array length does not match the number of servos.\");\n\n  // Attach the servo to the specified pin\n  if (attach(SERVO_PIN)) {\n    // Write the desired value to move the servo\n    write(value);\n\n    // Wait for the predefined delay specific to the servo channel\n    safe_delay(SERVO_DELAY[channel]);\n\n    // Optionally, detach the servo after the move\n    #if DEACTIVATE_SERVOS_AFTER_MOVE\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 55.78010840900747}, {"code": "void Servo::move(const int value){\n\t    static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == NUM_SERVOS, \"The servo delay array length does not match the number of servos.\");\n\n    if (attach()) {\n        write(value);\n        safe_delay(servo_delay[channel]);\n\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n        detach();\n#endif\n    }\n}", "CodeBleu_score": 55.454605064420605}, {"code": "void Servo::move(const int value){\n\t    static_assert(sizeof(servo_delay) / sizeof(int) == SERVO_CHANNELS, \"servo_delay array length mismatch\");\n    if (attach(value)) {\n        write(value);\n        safe_delay(servo_delay[channel]);\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n            detach();\n        }\n    }\n}", "CodeBleu_score": 50.62510289097036}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t    for (int i = 0; i < NUM_PINS; i++) {\n        if (pwm_duty_cycles[i] > 0) {\n            pwm_tick_counts[i]--;\n            if (pwm_tick_counts[i] == 0) {\n                pwm_tick_counts[i] = pwm_duty_cycles[i];\n                if (pwm_states[i] == 0) {\n                    pwm_states[i] = 1;\n                    SBI32(GPIO_OUT_W1TS_REG, i);\n                } else {\n                    pwm_states[i] = 0;\n                    CBI32(GPIO_OUT_W1TC_REG, i);\n                }\n            }\n        }\n    }\n    uint32_t port_data = 0;\n    for (int i = 0; i < NUM_PINS; i++) {\n        if (pwm_states[i] == 1) {\n            port_data |= (1 << i);\n        }\n    }\n    dma_buffer[dma_buffer_pos] = port_data;\n    dma_buffer_pos++;\n}", "CodeBleu_score": 39.088773946421064}, {"code": "void i2s_push_sample(){\n\t    for (int i = 0; i < NUM_PINS; i++) {\n        if (pwm_duty[i] > 0) {\n            pwm_tick[i]--;\n            if (pwm_tick[i] <= 0) {\n                pwm_state[i] ^= 1;\n                pwm_tick[i] = pwm_duty[i];\n            }\n        }\n        dma_buffer[dma_pos] |= (pwm_state[i] << i);\n    }\n    dma_pos++;\n}", "CodeBleu_score": 27.036244261599208}, {"code": "void i2s_push_sample(){\n\t    uint32_t mask;\n    uint32_t val;\n    uint32_t i;\n    for (i = 0; i < NUM_I2S_PINS; i++) {\n        if (pwm_duty[i] > 0) {\n            if (pwm_ticks[i] == 0) {\n                if (pwm_state[i] == HIGH) {\n                    pwm_state[i] = LOW;\n                    pwm_ticks[i] = pwm_duty[i];\n                } else {\n                    pwm_state[i] = HIGH;\n                    pwm_ticks[i] = pwm_period[i] - pwm_duty[i];\n                }\n            } else {\n                pwm_ticks[i]--;\n            }\n        }\n    }\n    mask = 0;\n    val = 0;\n    for (i = 0; i < NUM_I2S_PINS; i++) {\n        if (pwm_state[i] == HIGH) {\n            mask |= (1 << i);\n        }\n    }\n    i2s_dma_buffer[i2s_dma_buffer_pos] = mask;\n    i2s_dma_buffer_pos++;\n    if (i2s_dma_buffer_pos == I2S_DMA_BUFFER_SIZE) {\n        i2s_dma_buffer_pos = 0;\n    }\n}", "CodeBleu_score": 29.18162954247859}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t counter_value;\n    if (timer_num == 0) {\n        counter_value = timer_get_counter_value(TIMER0);\n    } else if (timer_num == 1) {\n        counter_value = timer_get_counter_value(TIMER1);\n    } else if (timer_num == 2) {\n        counter_value = timer_get_counter_value(TIMER2);\n    } else if (timer_num == 3) {\n        counter_value = timer_get_counter_value(TIMER3);\n    } else if (timer_num == 4) {\n        counter_value = timer_get_counter_value(TIMER4);\n    } else if (timer_num == 5) {\n        counter_value = timer_get_counter_value(TIMER5);\n    } else {\n        return 0;\n    }\n    return counter_value;\n}", "CodeBleu_score": 39.57156154806151}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    // Check if the timer number is valid\n    if (timer_num >= NUM_TIMERS) {\n        return 0;\n    }\n\n    // Get the current counter value from the timer\n    return timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 20.41684000567291}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    return timer_get_counter_value(timer_num);\n}", "CodeBleu_score": 14.948642288382214}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    uint8_t c = EEPROM.read(pos);\n    if (writing) {\n      *value = c;\n      value++;\n    }\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 65.92146151971062}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; ++i) {\n    uint8_t c = EEPROM.read(pos);\n    if (writing) {\n      *value = c;\n      value++;\n    }\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 63.82184164898376}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  for (size_t i = 0; i < size; i++) {\n    uint8_t c = EEPROM.read(pos);\n    if (writing) {\n      *value = c;\n      value++;\n    }\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 65.92146151971062}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    assert(sdio_handle != NULL);\n    assert(src != NULL);\n\n    for (int i = 0; i < SDIO_RETRY_COUNT; i++) {\n        if (SDIO_WriteBlockRaw(block, src) == true) {\n            return true;\n        }\n    }\n\n    printf(\"SDIO_WriteBlock failed\n\");\n    return false;\n}", "CodeBleu_score": 32.29969996297627}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    assert(sdio_handle);\n    assert(src);\n\n    for (int i = 0; i < SDIO_MAX_RETRY; i++) {\n        if (SDIO_OK == SDIO_WriteBlock(sdio_handle, block, src)) {\n            return true;\n        }\n    }\n\n    printf(\"SDIO_WriteBlock failed\n\");\n    return false;\n}", "CodeBleu_score": 32.93502368842144}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    assert(sdio_handle != NULL);\n    assert(src != NULL);\n\n    for (uint32_t i = 0; i < SDIO_WRITE_RETRIES; i++) {\n        if (SDIO_WriteBlock_WithRetry(block, src)) {\n            return true;\n        }\n    }\n\n    printf(\"SDIO_WriteBlock failed after %d retries\n\", SDIO_WRITE_RETRIES);\n    return false;\n}", "CodeBleu_score": 37.59372190765748}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    switch (timer_num) {\n        case TIMER_CHANNEL_TEMP:\n            timer_num->start(frequency, TEMP_TIMER_PRESCALE);\n            timer_num->setCallbackPriority(TEMP_TIMER_CALLBACK_PRIORITY);\n            break;\n        case TIMER_CHANNEL_STEP:\n            timer_num->start(frequency, STEPPER_TIMER_PRESCALE);\n            timer_num->setCallbackPriority(STEPPER_TIMER_CALLBACK_PRIORITY);\n            break;\n        default:\n            CORE_ASSERT_FAIL(\"Invalid timer channel\");\n    }\n}", "CodeBleu_score": 42.11051549849266}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    if (timer_num == TIMER_TEMPERATURE) {\n        timer_num->start(frequency, TIMER_TEMPERATURE_PRESCALE);\n        timer_num->setCallbackPriority(TIMER_TEMPERATURE_PRIORITY);\n    } else if (timer_num == TIMER_STEP) {\n        timer_num->start(frequency, TIMER_STEP_PRESCALE);\n        timer_num->setCallbackPriority(TIMER_STEP_PRIORITY);\n    } else {\n        CORE_ASSERT_FAIL();\n    }\n}", "CodeBleu_score": 48.509690225163574}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    CORE_DEBUG_PRINTF(\"HAL_timer_start(%d, %d)\n\", timer_num, frequency);\n\n    if (timer_num == TIMER_CHANNEL_TEMP) {\n        timer_num->start(frequency, TIMER_TEMP_PRESCALE);\n        timer_num->setCallbackPriority(TIMER_TEMP_CALLBACK_PRIORITY);\n    } else if (timer_num == TIMER_CHANNEL_STEP) {\n        timer_num->start(frequency, TIMER_STEP_PRESCALE);\n        timer_num->setCallbackPriority(TIMER_STEP_CALLBACK_PRIORITY);\n    } else {\n        CORE_ASSERT_FAIL(\"Invalid timer channel\");\n    }\n}", "CodeBleu_score": 54.74129437250096}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  if (!fopen(this->eeprom_file, \"rb\")) {\n    this->eeprom_file = (char*)0x0;\n    return false;\n  }\n  memset(this->eeprom_buffer,0xff,0x4000);\n  if (ftell(this->eeprom_file) < 0x4000) {\n    fread(this->eeprom_buffer,1,0x4000,this->eeprom_file);\n  }\n  fclose(this->eeprom_file);\n  return true;\n}", "CodeBleu_score": 12.369094572789285}, {"code": "bool PersistentStore::access_start(){\n\t    if (eeprom_file) {\n        fclose(eeprom_file);\n    }\n    eeprom_file = fopen(eeprom_filename, \"r+\");\n    if (!eeprom_file) {\n        eeprom_file = fopen(eeprom_filename, \"w+\");\n    }\n    if (!eeprom_file) {\n        return false;\n    }\n    fseek(eeprom_file, 0, SEEK_END);\n    size_t file_size = ftell(eeprom_file);\n    fseek(eeprom_file, 0, SEEK_SET);\n    if (file_size != EEPROM_SIZE) {\n        memset(eeprom_buffer, erase_value, EEPROM_SIZE);\n        if (file_size) {\n            fread(eeprom_buffer, 1, file_size, eeprom_file);\n        }\n    } else {\n        fread(eeprom_buffer, 1, EEPROM_SIZE, eeprom_file);\n    }\n    return true;\n}", "CodeBleu_score": 45.407753349948464}, {"code": "bool PersistentStore::access_start(){\n\t    if (!fopen(this->eeprom_file, \"rb\")) {\n        return false;\n    }\n    memset(this->eeprom_buffer, this->erase_value, this->eeprom_size);\n    if (ftell(this->eeprom_file) < this->eeprom_size) {\n        return false;\n    }\n    fread(this->eeprom_buffer, this->eeprom_size, 1, this->eeprom_file);\n    fclose(this->eeprom_file);\n    return true;\n}", "CodeBleu_score": 14.938950188025457}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t recv = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tWRITE(SCK, LOW);\n\t\tWRITE(MOSI, (b & 0x80) ? HIGH : LOW);\n\t\tWRITE(SCK, HIGH);\n\t\trecv <<= 1;\n\t\tif (READ(MISO))\n\t\t\trecv |= 0x01;\n\t\tb <<= 1;\n\t}\n\n\tdelaySPIFunc();\n\n\treturn recv;\n}", "CodeBleu_score": 46.68906246965303}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t i;\n    uint8_t r = 0;\n    for (i = 0; i < 8; i++) {\n        WRITE(SPI_CS_PIN, LOW);\n        WRITE(SPI_MOSI_PIN, (b & 0x80) ? HIGH : LOW);\n        WRITE(SPI_SCK_PIN, HIGH);\n        delaySPIFunc(DELAY_NS);\n        r = (r << 1) | READ(SPI_MISO_PIN);\n        WRITE(SPI_SCK_PIN, LOW);\n        delaySPIFunc(DELAY_NS);\n        b <<= 1;\n    }\n    WRITE(SPI_CS_PIN, HIGH);\n    delaySPIFunc(DELAY_NS);\n    return r;\n}", "CodeBleu_score": 48.245646955260725}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t i;\n  uint8_t data = 0;\n  for (i = 0; i < 8; i++) {\n    WRITE(SPI_MOSI_PORT, SPI_MOSI_PIN, (b & 0x80) != 0);\n    WRITE(SPI_SCK_PORT, SPI_SCK_PIN, 1);\n    delaySPIFunc(DELAY_NS);\n    data <<= 1;\n    if (READ(SPI_MISO_PORT, SPI_MISO_PIN)) {\n      data |= 0x01;\n    }\n    WRITE(SPI_SCK_PORT, SPI_SCK_PIN, 0);\n    delaySPIFunc(DELAY_NS);\n    b <<= 1;\n  }\n  delaySPIFunc(DELAY_NS);\n  return data;\n}", "CodeBleu_score": 45.788394834052056}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.69690496231567}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.69690496231567}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.69690496231567}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  if (obj->is_error()) return;\n  if (obj->is_parity_error()) {\n    obj->recv();\n    return;\n  }\n  if (obj->readable()) {\n    uint8_t c = obj->recv();\n    if (rx_buffer_head < RX_BUFFER_SIZE) {\n      rx_buffer[rx_buffer_head] = c;\n      rx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n    }\n    if (emergency_parser.enabled) emergency_parser.update(c);\n  }\n}", "CodeBleu_score": 42.18596593049696}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  if (obj->is_parity_error()) return;\n  if (!obj->is_readable()) return;\n  uint8_t data = obj->read();\n  if (rx_buffer_head < RX_BUFFER_SIZE) {\n    rx_buffer[rx_buffer_head] = data;\n    rx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n  }\n  if (emergency_parser.enabled) emergency_parser.update(data);\n}", "CodeBleu_score": 35.38866373506333}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  // If no parity error occurs\n  if (!(obj->isr & UART_ISR_PE)) {\n    // Read the byte\n    uint8_t c = obj->rxd;\n\n    // Store the byte in the receive buffer if there is space available\n    if (rx_buffer_head < RX_BUFFER_SIZE) {\n      rx_buffer[rx_buffer_head] = c;\n      rx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n    }\n\n    // Calculate the next buffer index\n    uint32_t i = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n\n    // If the buffer is not full\n    if (i != rx_buffer_head) {\n      rx_buffer_tail = i;\n      _rx_buffer_overflow = false;\n    } else {\n      _rx_buffer_overflow = true;\n    }\n  }\n\n  // Update the emergency parser with the received byte\n  if (emergency_parser.enabled) emergency_parser.update(c);\n}", "CodeBleu_score": 34.423923283615565}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (HAL_timer_initialized(timer_num)) {\n        if (timer_instance[timer_num]->hasInterrupt) {\n            return;\n        }\n        switch (timer_num) {\n            case MF_TIMER_STEP:\n                timer_instance[timer_num]->attachInterrupt(Step_Handler);\n                break;\n            case MF_TIMER_TEMP:\n                timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n                break;\n        }\n        timer_instance[timer_num]->hasInterrupt = true;\n    }\n}", "CodeBleu_score": 76.67362019913358}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_instance[timer_num] != NULL && !timer_instance[timer_num]->hasInterrupt) {\n        switch (timer_num) {\n            case MF_TIMER_STEP:\n                timer_instance[timer_num]->attachInterrupt(Step_Handler);\n                break;\n            case MF_TIMER_TEMP:\n                timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n                break;\n        }\n        timer_instance[timer_num]->hasInterrupt = true;\n    }\n}", "CodeBleu_score": 78.0689370383578}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (HAL_timer_initialized(timer_num) && !timer_instance[timer_num]->hasInterrupt) {\n        switch (timer_num) {\n            case MF_TIMER_STEP:\n                timer_instance[timer_num]->attachInterrupt(Step_Handler);\n                break;\n            case MF_TIMER_TEMP:\n                timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n                break;\n        }\n        timer_instance[timer_num]->hasInterrupt = true;\n    }\n}", "CodeBleu_score": 81.67202248883406}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn, m := len(s), len(sep)\n\tswitch any(s).(type) {\n\tcase string:\n\t\tif n < m || m == 0 {\n\t\t\treturn -1\n\t\t}\n\t\tif m == 1 {\n\t\t\treturn strings.LastIndexByte(string(s), sep[0])\n\t\t}\n\tcase []byte:\n\t\tif n < m || m == 0 {\n\t\t\treturn -1\n\t\t}\n\t\tif m == 1 {\n\t\t\treturn bytes.LastIndexByte(s, sep[0])\n\t\t}\n\t}\n\n\thashsep, pow := HashStrRev(sep)\n\tvar h uint32\n\tfor i := 0; i < m; i++ {\n\t\th = h*primeRK + uint32(s[n-m+i])\n\t}\n\tif h == hashsep && Equal(s[n-m:], sep) {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\th *= primeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+m])\n\t\tif h == hashsep && Equal(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 52.66189621841767}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(s)\n\tm := len(sep)\n\td := uint32(1)\n\thsep := uint32(0)\n\th := uint32(0)\n\tfor i := 0; i < m; i++ {\n\t\thsep = (R*hsep + uint32(sep[i])) % Q\n\t\th = (R*h + uint32(s[i])) % Q\n\t}\n\td = 1\n\tfor i := 1; i <= m-1; i++ {\n\t\td = (d * R) % Q\n\t}\n\tfor i := m; i <= n; i++ {\n\t\tif hsep == h && Equal(s[i-m:i], sep) {\n\t\t\treturn i - m\n\t\t}\n\t\tif i < n {\n\t\t\th = (h + Q - d*uint32(s[i-m])%Q) % Q\n\t\t\th = (h*R + uint32(s[i])) % Q\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 39.79500126443474}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\thashSep := HashStrRev(sep)\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\thashSub := HashStrRev(s[i : i+len(sep)])\n\t\tif hashSep == hashSub && Equal(s[i:i+len(sep)], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 31.88864516114941}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.211916470826246}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Len() > 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txBuffer.Get())\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 48.760476939812634}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tinterrupt.Disable()\n\tif usbcdc.txBuffer.Get() > 0 {\n\t\tusbcdc.waitTxc = true\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tinterrupt.Restore()\n}", "CodeBleu_score": 46.42702300866103}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.HasBits(i2c.crReg.ClearInt).Set()\n\ti2c.crReg.HasBits(i2c.crReg.Start).Set()\n\tfor !i2c.crReg.HasBits(i2c.crReg.Int) {\n\t}\n\ti2c.writeByte(address << 1)\n\tif !write {\n\t\ti2c.crReg.HasBits(i2c.crReg.Read).Set()\n\t}\n\ti2c.crReg.HasBits(i2c.crReg.Start).Set()\n\tfor !i2c.crReg.HasBits(i2c.crReg.Int) {\n\t}\n}", "CodeBleu_score": 32.5819922330952}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.crReg.HasBits(i2c.crReg.Get(), i2c.crReg.STOP)\n\ti2c.crReg.HasBits(i2c.crReg.Get(), i2c.crReg.START)\n\ti2c.crReg.HasBits(i2c.crReg.Get(), i2c.crReg.ACK)\n\tif write {\n\t\ti2c.crReg.HasBits(i2c.crReg.Get(), i2c.crReg.WRITE)\n\t}\n\ti2c.writeByte(address)\n}", "CodeBleu_score": 33.68864137950938}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// clear interrupt flag\n\ti2c.crReg.HasBits(i2c.crReg.Get(), i2c.crReg.I2C_CR2_START)\n\t// send start condition\n\ti2c.crReg.HasBits(i2c.crReg.Get(), i2c.crReg.I2C_CR2_START)\n\t// wait for start condition to be transmitted\n\tfor !i2c.crReg.HasBits(i2c.crReg.Get(), i2c.crReg.I2C_CR2_START) {\n\t}\n\t// write peripheral address to bus\n\ti2c.writeByte(uint8(address << 1))\n\tif write {\n\t\t// set read flag\n\t\ti2c.crReg.Set(i2c.crReg.Get(), i2c.crReg.I2C_CR2_RD_WRN)\n\t} else {\n\t\t// clear read flag\n\t\ti2c.crReg.Clear(i2c.crReg.Get(), i2c.crReg.I2C_CR2_RD_WRN)\n\t}\n\t// send peripheral address\n\ti2c.crReg.Set(i2c.crReg.Get(), i2c.crReg.I2C_CR2_START)\n}", "CodeBleu_score": 28.90394341244205}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := uintptr(f.StartAddress + uintptr(start*int64(f.EraseBlockSize)))\n\tendAddress := uintptr(f.StartAddress + uintptr((start+len)*int64(f.EraseBlockSize)))\n\n\twaitForFlashReady()\n\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Een)\n\n\tfor address := startAddress; address < endAddress; address += uintptr(f.EraseBlockSize) {\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(address))\n\t\twaitForFlashReady()\n\t}\n\n\tnrf.NVMC.CONFIG.Set(nrf.NVMC_CONFIG_WEN_Ren)\n\n\treturn nil\n}", "CodeBleu_score": 48.207688566505965}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := uintptr(f.FlashDataStart + start*int64(f.EraseBlockSize))\n\tendAddr := uintptr(f.FlashDataStart + (start+len)*int64(f.EraseBlockSize))\n\n\tnrf.NVMC.SetCONFIG_WEN\n\twaitWhileFlashBusy\n\n\tfor addr := startAddr; addr < endAddr; addr += uintptr(f.EraseBlockSize) {\n\t\tnrf.NVMC.ERASEPAGE.Set(uint32(addr))\n\t\twaitWhileFlashBusy\n\t}\n\n\tnrf.NVMC.SetCONFIG_RWEN\n\treturn nil\n}", "CodeBleu_score": 43.43005106511273}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := f.FlashDataStart + uintptr(start)*f.EraseBlockSize\n\tendAddress := startAddress + uintptr(len)*f.EraseBlockSize\n\tstartAddress -= uintptr(f.FlashDataStart)\n\tendAddress -= uintptr(f.FlashDataStart)\n\n\t// Wait for any flash operations to complete.\n\twaitForFlashReady()\n\n\t// Set flash to erasing mode.\n\tnrf.NVMC.SetCONFIG_WEN\n\n\t// Erase blocks one by one.\n\tfor address := startAddress; address < endAddress; address += f.EraseBlockSize {\n\t\t// Erase the current block.\n\t\tnrf.NVMC.ERASEPAGE.Set(address)\n\n\t\t// Wait until the flash is no longer busy.\n\t\twaitWhileFlashBusy()\n\t}\n\n\t// Set flash back to read mode.\n\tnrf.NVMC.ClearCONFIG_WEN\n\n\treturn nil\n}", "CodeBleu_score": 45.836103495814626}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif uint32(off) >= f.size {\n\t\treturn 0, errFlashOutOfBounds\n\t}\n\n\taddr := f.startAddress + uintptr(off)\n\tlength := uint32(len(p))\n\n\tif uint32(off)+length > f.size {\n\t\tlength = f.size - uint32(off)\n\t}\n\n\tpadding := f.pad(p[:length], f.WriteBlockSize)\n\n\tnrf.NVMC.SetCONFIG_WEN()\n\n\tFlashDataStart(addr)\n\twaitWhileFlashBusy()\n\n\tfor i := uint32(0); i < length; i += f.WriteBlockSize {\n\t\tFlashData(binary.LittleEndian.Uint32((*uint32)(unsafe.Pointer(uintptr(padding) + uintptr(i)))))\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn int(length), nil\n}", "CodeBleu_score": 36.215386579891906}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif uint32(off) >= f.Size() {\n\t\treturn 0, errFlashOutOfBounds\n\t}\n\n\taddr := f.start + uintptr(off)\n\tlength := uint32(len(p))\n\n\tpadding := f.pad(p, length, uint32(addr))\n\tbuffer := f.buffer(length+padding, uint32(addr))\n\tcopy(buffer, p)\n\n\tnrf.NVMC.SetCONFIG_WEN()\n\n\tfor k := uint32(0); k < length; k += f.WriteBlockSize {\n\t\tnrf.NVMC.Write(addr+uintptr(k), buffer[k:k+f.WriteBlockSize])\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn int(length), nil\n}", "CodeBleu_score": 34.27628877845849}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off+int64(len(p)) > f.Size() {\n\t\treturn 0, errFlashOutOfBounds\n\t}\n\n\taddr := uintptr(f.start) + uintptr(off)\n\tbuf := make([]byte, len(p))\n\tcopy(buf, p)\n\tbuf = f.pad(buf)\n\n\tf.f.WriteBlockSize = uint32(len(buf))\n\tnrf.NVMC.SetCONFIG_WEN\n\n\tfor i := 0; i < len(buf); i += flashPageSize {\n\t\tnrf.NVMC.SetCONFIG_WEN\n\t\tf.f.WriteBlock(addr+uintptr(i), binary.LittleEndian.Uint32((*uint32)(unsafe.Pointer(&buf[i]))))\n\t\twaitWhileFlashBusy()\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 40.264189221027785}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tfd2, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err := syscall.Fdopendir(fd2)\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(fd2)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 64.28504220074626}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tfd2, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err := syscall.Fdopendir(fd2)\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(fd2)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 62.34070252775602}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\td, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err := syscall.Fdopendir(d)\n\t\tif err != nil {\n\t\t\tif err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsyscall.Close(d)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t\treturn uintptr(dir), \"\", nil\n\t}\n}", "CodeBleu_score": 58.30110489270604}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    const esp_partition_t *running = esp_ota_get_running_partition();\n    if (!running) {\n        return 0;\n    }\n    if (response == FREE_SKETCH_SPACE) {\n        const esp_partition_t *update = esp_ota_get_next_update_partition(NULL);\n        if (!update) {\n            return 0;\n        }\n        return update->size;\n    }\n    return running->size;\n}", "CodeBleu_score": 45.04862287170993}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t *partition = esp_ota_get_running_partition();\n  if (partition == NULL) {\n    return 0;\n  }\n  if (response == FREE_SKETCH_SPACE) {\n    return partition->size - partition->ota_region->offset;\n  }\n  return partition->ota_region->offset;\n}", "CodeBleu_score": 32.54373611263175}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t *running = esp_ota_get_running_partition();\n  if (!running) {\n    return 0;\n  }\n  if (response == FREE_SKETCH_SPACE) {\n    return running->size - running->ota_region_offset;\n  }\n  return running->ota_region_offset;\n}", "CodeBleu_score": 40.87877243920478}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    bool ret = false;\n    uint32_t required_disk_sectors = msc_update_get_required_disk_sectors();\n    uint8_t *ram_disk = calloc(required_disk_sectors * FAT_SECTOR_SIZE, 1);\n    if (!ram_disk) {\n        log_e(\"Error allocating memory for RAM disk\");\n        return ret;\n    }\n    fat_add_boot_sector(ram_disk, volume_label, serial_number);\n    fat_add_table(ram_disk);\n    if (fat_file_system_type == FAT_FAT16) {\n        fat_add_root_file(ram_disk, \"firmware.bin\");\n    }\n    ret = true;\n    return ret;\n}", "CodeBleu_score": 27.326923193729062}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tFAT_SIZE_TO_SECTORS(fat_file_system_type, fat_size, fat_sectors);\n\tuint32_t required_disk_sectors = msc_update_get_required_disk_sectors(fat_sectors, fat_size);\n\tdisk_sector_size = DISK_SECTOR_SIZE;\n\tdisk_sector_count = required_disk_sectors;\n\tdisk_data = calloc(disk_sector_count, disk_sector_size);\n\tif (!disk_data) {\n\t\tlog_e(\"Failed to allocate %d bytes for disk\", disk_sector_count * disk_sector_size);\n\t\treturn false;\n\t}\n\tfat_add_boot_sector(volume_label, serial_number, disk_sector_size, disk_sector_count, disk_data);\n\tfat_add_table(disk_sector_size, disk_sector_count, disk_data);\n#if defined(ESP32) && CONFIG_IDF_TARGET_ESP32S2\n\tif (fat_file_system_type == FAT_FILE_SYSTEM_TYPE_FAT32) {\n\t\tfat_add_root_file(FIRMWARE_FILENAME, 0, 0, 0, disk_data);\n\t}\n#endif\n\treturn true;\n}", "CodeBleu_score": 41.814841468544316}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t    fat_file_system_type fat_fs_type = FAT_FILE_SYSTEM_TYPE_FAT16;\n    log_e(\"Setting up RAM disk for volume %s\", volume_label);\n    fat_add_boot_sector(volume_label, serial_number, fat_fs_type);\n    fat_add_table();\n    uint32_t required_disk_sectors = msc_update_get_required_disk_sectors();\n    if (required_disk_sectors == 0) {\n        log_e(\"Failed to calculate required disk sectors\");\n        return false;\n    }\n    if (calloc(required_disk_sectors, sizeof(uint8_t)) == NULL) {\n        log_e(\"Failed to allocate memory for RAM disk\");\n        return false;\n    }\n    fat_add_root_file(volume_label, fat_fs_type);\n    return true;\n}", "CodeBleu_score": 30.160441774133407}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t ret = ESP_OK;\n    // Check if the offset is aligned with the flash sector size\n    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        // If not, erase the corresponding sector\n        ret = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (ret != ESP_OK) {\n            log_v(\"Failed to erase sector %d\", offset / SPI_FLASH_SEC_SIZE);\n            return ret;\n        }\n    }\n    // Write the data to the specified offset\n    ret = esp_partition_write(partition, offset, data, size);\n    return ret;\n}", "CodeBleu_score": 60.4456478221312}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n    uint32_t sector_size = partition->size / partition->sector_count;\n    if ((offset % sector_size) == 0) {\n        err = esp_partition_erase_range(partition, offset, sector_size);\n        if (err != ESP_OK) {\n            log_v(\"Failed to erase partition %s at offset %x\", partition->label, offset);\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    return err;\n}", "CodeBleu_score": 62.97239537804265}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n    if (offset % partition->sector_size != 0) {\n        err = esp_partition_erase_range(partition, offset, size);\n        if (err != ESP_OK) {\n            log_v(\"Failed to erase partition %s at offset %08x\", partition->label, offset);\n            return err;\n        }\n    }\n    return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 64.33862332233777}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0, j = 0;\n  unsigned char c;\n\n  while (i < maxlen && in[j]) {\n    if (!hex_char_to_byte(&c, in[j++])) {\n      continue;\n    }\n    out[i++] = c;\n    if (!hex_char_to_byte(&c, in[j++])) {\n      continue;\n    }\n    out[i++] = c;\n  }\n  return i;\n}", "CodeBleu_score": 39.145194036991}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t len = strlen(in);\n  if (len % 2 != 0) {\n    return 0;\n  }\n  size_t outlen = len / 2;\n  if (outlen > maxlen) {\n    return 0;\n  }\n  for (size_t i = 0; i < len; i += 2) {\n    unsigned char c1 = in[i];\n    if (!hex_char_to_byte(c1)) {\n      return 0;\n    }\n    unsigned char c2 = in[i + 1];\n    if (!hex_char_to_byte(c2)) {\n      return 0;\n    }\n    out[i / 2] = (c1 << 4) | c2;\n  }\n  return outlen;\n}", "CodeBleu_score": 42.909621339589506}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t    size_t i, len;\n    unsigned char *p;\n    char c;\n    unsigned char n;\n\n    p = out;\n    len = 0;\n    i = 0;\n    while (i < maxlen && in[i] != '\\0') {\n        c = in[i++];\n        if (c == ' ') {\n            continue;\n        }\n        if ((c >= '0') && (c <= '9')) {\n            n = (unsigned char)(c - '0');\n        } else if ((c >= 'A') && (c <= 'F')) {\n            n = (unsigned char)(c - 'A' + 10);\n        } else if ((c >= 'a') && (c <= 'f')) {\n            n = (unsigned char)(c - 'a' + 10);\n        } else {\n            return 0;\n        }\n        len++;\n        *p++ = n;\n    }\n    return len;\n}", "CodeBleu_score": 35.73197846292076}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t    if (tx_ringbuffer == NULL || tx_ringbuffer_lock == NULL) {\n        return 0;\n    }\n\n    if (xSemaphoreTake(tx_ringbuffer_lock, 100 / portTICK_PERIOD_MS) == pdTRUE) {\n        int free_size = xRingbufferGetCurFreeSize(tx_ringbuffer);\n        xSemaphoreGive(tx_ringbuffer_lock);\n        return free_size;\n    }\n\n    return 0;\n}", "CodeBleu_score": 67.1676171881056}, {"code": "int HWCDC::availableForWrite(void){\n\t  int ret = 0;\n\n  if (tx_ring_buffer == NULL || tx_ring_buffer_lock == NULL) {\n    return 0;\n  }\n\n  if (xSemaphoreTake(tx_ring_buffer_lock, 100 / portTICK_PERIOD_MS) == pdTRUE) {\n    ret = xRingbufferGetCurFreeSize(tx_ring_buffer);\n    xSemaphoreGive(tx_ring_buffer_lock);\n  }\n\n  return ret;\n}", "CodeBleu_score": 63.04715231731469}, {"code": "int HWCDC::availableForWrite(void){\n\t  int ret = 0;\n\n  if (tx_ringbuffer && tx_lock) {\n    if (xSemaphoreTake(tx_lock, (TickType_t)10) == pdTRUE) {\n      ret = xRingbufferGetCurFreeSize(tx_ringbuffer);\n      xSemaphoreGive(tx_lock);\n    }\n  }\n\n  return ret;\n}", "CodeBleu_score": 46.532468316323474}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tHSERIAL_MUTEX_LOCK\n\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\tif (function) {\n\t\tuartSetRxFIFOFull(UART0, _rxFIFOFullThreshold);\n\t\tif (!_eventTask) {\n\t\t\t_eventTask = createEventTask();\n\t\t}\n\t}\n\tHSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 29.23995105088689}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t    HSERIAL_MUTEX_LOCK\n    _onReceiveCB = function;\n    _rxTimeout = onlyOnTimeout;\n    if (_onReceiveCB != nullptr) {\n        // Set the FIFO full threshold\n        uartSetRxFIFOFull(_uart, _rxFIFOFullThreshold);\n        // Create the event task if it does not already exist\n        if (_eventTask == nullptr) {\n            _eventTask = new Task(\n                [this]() {\n                    for (;;) {\n                        // Wait for the event to be triggered\n                        if (uartWaitEvent(_uart, UART_EVENT_RX_FIFO_FULL)) {\n                            // Clear the event\n                            uartClearEvent(_uart, UART_EVENT_RX_FIFO_FULL);\n                            // Call the receive callback function\n                            if (_onReceiveCB != nullptr) {\n                                _onReceiveCB();\n                            }\n                        }\n                    }\n                },\n                TASK_PRIORITY_LOW,\n                TASK_STACK_DEPTH_DEFAULT,\n                \"uartEventTask\");\n        }\n    } else {\n        // Clear the FIFO full threshold\n        uartSetRxFIFOFull(_uart, 0);\n    }\n    HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 48.30706590958027}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t    HSERIAL_MUTEX_LOCK\n    _onReceiveCB = function;\n    _onlyOnTimeout = onlyOnTimeout;\n    if (_onReceiveCB) {\n        _rxFIFOFullThreshold = _rxFIFOFullThreshold == 0 ? 1 : _rxFIFOFullThreshold;\n        if (_eventTask == nullptr) {\n            _eventTask = createEventTask(uartSetRxFIFOFull, &_rxFIFOFullThreshold, 1);\n        }\n    } else {\n        if (_eventTask) {\n            deleteEventTask(_eventTask);\n            _eventTask = nullptr;\n        }\n    }\n    HSERIAL_MUTEX_UNLOCK\n}", "CodeBleu_score": 48.954484560342394}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t    if (length < 1) return 0;\n    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) break;\n        *buffer++ = (char)c;\n        index++;\n    }\n    return index; // return number of characters, not including null terminator\n}", "CodeBleu_score": 87.24080414880157}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) return 0;\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) break;\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index; // return number of characters, not including null terminator\n}", "CodeBleu_score": 86.22803441573788}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) return 0;\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) break;\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index; // return number of characters, not including null terminator\n}", "CodeBleu_score": 86.22803441573788}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    log_e(\"Tone on pin %d with frequency %d and duration %lu\", pin, frequency, duration);\n    if (pin == PIN_UNUSED || pin >= NUM_DIGITAL_PINS) {\n        log_e(\"Pin %d is not available or already in use\", pin);\n        return;\n    }\n    if (digitalPinIsAttached(pin)) {\n        log_e(\"Pin %d is already in use, please stop the current tone on the pin first\", pin);\n        return;\n    }\n    tone_init(pin, frequency, duration);\n    xQueueSend(toneQueue, &pin, portMAX_DELAY);\n}", "CodeBleu_score": 45.59047672700445}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    log_e(\"Tone: pin %d, freq = %d Hz, duration = %d ms\", pin, frequency, duration);\n\n    if (pin >= SOC_GPIO_PIN_COUNT || gpio_is_valid_gpio(pin) == false) {\n        log_e(\"Tone pin number is not valid, please check (0-%d).\", SOC_GPIO_PIN_COUNT);\n        return;\n    }\n\n    if (getPinMode(pin) != MUX_FUNC_GPIO) {\n        log_e(\"Tone pin %d is not a GPIO pin.\", pin);\n        return;\n    }\n\n    if (tone_init(pin) == 0) {\n        xQueueSend(tone_queue, &(queue_item_t) {\n            TONE_START,\n            pin,\n            frequency,\n            duration\n        }, portMAX_DELAY);\n    } else {\n        log_e(\"Tone pin %d is already in use, please stop the current tone first.\", pin);\n    }\n}", "CodeBleu_score": 46.68005520930096}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t    log_e(\"Tone: pin %d, freq = %d, duration = %d\", pin, frequency, duration);\n    if (pin >= NUM_DIGITAL_PINS) {\n        log_e(\"Tone pin number is not valid, please use: 0-%d\", NUM_DIGITAL_PINS - 1);\n        return;\n    }\n    if (ledcRead(pin)) {\n        log_e(\"Tone pin %d is already in use\", pin);\n        log_e(\"chose other pin or call `noTone()` to stop tone.\");\n        return;\n    }\n    ledcAttachPin(pin, pin);\n    xQueueSend(tone_queue, &(tone_t){pin, frequency, duration}, portMAX_DELAY);\n}", "CodeBleu_score": 47.482464232208585}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!_usbStarted) {\n    _webUSBEnabled = enabled;\n    if (enabled) {\n      _usbVersion = max(_usbVersion, 0x0210);\n    }\n    return true;\n  }\n  if (enabled) {\n    usb_webusb_enable();\n  } else {\n    usb_webusb_disable();\n  }\n  return false;\n}", "CodeBleu_score": 42.161451318052414}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (!USB.isStarted()) {\n    _webUSB = enabled;\n    if (enabled) {\n      USB.setVersion(0x0210);\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 41.20744291699644}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (!usb_started) {\n        webUSB_enabled = enabled;\n        if (enabled) {\n            usb_version = 0x0210;\n        }\n        return true;\n    }\n\n    if (enabled) {\n        if (webUSB_enabled) {\n            return false;\n        }\n        webUSB_enabled = true;\n        usb_version = 0x0210;\n        usb_device_descriptor.bcdUSB = 0x0210;\n        usb_device_descriptor.bNumConfigurations = 1;\n        usb_device_descriptor.bDeviceClass = 0x00;\n        usb_device_descriptor.bDeviceSubClass = 0x00;\n        usb_device_descriptor.bDeviceProtocol = 0x00;\n        usb_device_descriptor.bMaxPacketSize0 = 64;\n        usb_device_descriptor.idVendor = 0x16d0;\n        usb_device_descriptor.idProduct = 0x0f37;\n        usb_device_descriptor.bcdDevice = 0x0100;\n        usb_device_descriptor.iManufacturer = 0x01;\n        usb_device_descriptor.iProduct = 0x02;\n        usb_device_descriptor.iSerialNumber = 0x03;\n        usb_device_descriptor.bNumConfigurations = 1;\n        usb_configuration_descriptor.bLength = 0x09;\n        usb_configuration_descriptor.bDescriptorType = 0x02;\n        usb_configuration_descriptor.wTotalLength = 0x0020;\n        usb_configuration_descriptor.bNumInterfaces = 0x01;\n        usb_configuration_descriptor.bConfigurationValue = 0x01;\n        usb_configuration_descriptor.iConfiguration = 0x00;\n        usb_configuration_descriptor.bmAttributes = 0x80;\n        usb_configuration_descriptor.bMaxPower = 0x32;\n        usb_interface_descriptor.bLength = 0x09;\n        usb_interface_descriptor.bDescriptorType = ", "CodeBleu_score": 47.84330876778404}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t    if (_rx_buffer == nullptr) {\n        return;\n    }\n\n    int len = tud_cdc_n_read(_itf, _rx_buffer, _rx_buffer_size);\n    if (len > 0) {\n        if (xQueueSend(_rx_queue, &len, 0) != pdTRUE) {\n            log_e(\"USBCDC RX queue overflow\");\n            tud_cdc_n_write_flush(_itf);\n            tud_cdc_n_write(_itf, (const char *) &len, 4);\n            tud_cdc_n_write_flush(_itf);\n            _rx_overflow++;\n        }\n        _rx_pending = true;\n        _rx_count += len;\n        _rx_pending_count += len;\n        tud_cdc_n_read_flush(_itf);\n        arduino_usb_event_post(ARDUINO_USB_EVENT_CDC_RX, len, 0);\n    }\n}", "CodeBleu_score": 25.080062963280543}, {"code": "void USBCDC::_onRX(){\n\t    uint32_t count = tud_cdc_n_read(_itf, _rx_buffer, sizeof(_rx_buffer));\n\n    for (uint32_t i = 0; i < count; i++) {\n        if (xQueueSend(_rx_queue, &_rx_buffer[i], 0) != pdTRUE) {\n            log_e(\"CDC RX queue overflow\");\n            tud_cdc_n_write_flush(_itf);\n            tud_cdc_n_clear_rx_buffer(_itf);\n            break;\n        }\n    }\n\n    if (count) {\n        tud_cdc_n_clear_rx_buffer(_itf);\n        log_d(\"CDC received %lu bytes\", count);\n        ESP.getEventLoop()->post(\n            arduino_usb_event_post,\n            USB_EVENT_CDC_RX,\n            count,\n            millis()\n        );\n    }\n}", "CodeBleu_score": 39.28103643952292}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t itf = tud_cdc_n_get_rx_if();\n\tuint8_t buf[64];\n\tuint32_t count = tud_cdc_n_read(itf, buf, sizeof(buf));\n\t\n\tusb_event_post(USB_EVENT_CDC_RX, buf, count, tud_cdc_n_get_rx_count());\n\t\n\tif (count) {\n\t\tfor (uint32_t i = 0; i < count; i++) {\n\t\t\tBaseType_t res = xQueueSend(_rx_queue, &buf[i], 0);\n\t\t\tif (res != pdPASS) {\n\t\t\t\tusb_event_post(USB_EVENT_CDC_RX_OVERFLOW, &buf[i], 1, tud_cdc_n_get_rx_count());\n\t\t\t\tESP_LOGE(TAG, \"CDC RX queue overflow\");\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.879536189483865}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(JSONRobot{\n\t\t\tName:  robotName,\n\t\t\tError: \"no robot with name \" + robotName,\n\t\t})\n\t\treturn\n\t}\n\n\tvar devices []gobot.Device\n\trobot.Devices().Each(func(device gobot.Device) {\n\t\tdevices = append(devices, device)\n\t})\n\n\ta.writeJSON(res, JSONRobot{\n\t\tName:    robot.Name,\n\t\tCommands: a.commandsForRobot(robot),\n\t\tDevices:  devices,\n\t})\n}", "CodeBleu_score": 49.21041863460064}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, JSON{\n\t\t\t\"error\": fmt.Sprintf(\"robot with name %s not found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\tdevices := []JSON{}\n\trobot.Devices().Each(func(device gpio.Device) {\n\t\tdevices = append(devices, JSON{\n\t\t\t\"name\": device.Name(),\n\t\t\t\"pin\":  device.Pin(),\n\t\t})\n\t})\n\ta.writeJSON(res, http.StatusOK, JSON{\n\t\t\"devices\": devices,\n\t})\n}", "CodeBleu_score": 46.76367592313652}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(JSON{\n\t\t\t\"error\": \"no robot with name \" + robotName,\n\t\t})\n\t\treturn\n\t}\n\tdevices := []json.Marshaler{}\n\trobot.Devices().Each(func(device gpio.Device) {\n\t\tdevices = append(devices, device)\n\t})\n\tjson.NewEncoder(res).Encode(JSON{\n\t\t\"devices\": devices,\n\t})\n}", "CodeBleu_score": 44.47504043492605}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, &struct{}{})\n\t\treturn\n\t}\n\n\tconnections := []*Connection{}\n\n\trobot.Connections().Each(func(connection gpio.DigitalReader) {\n\t\tconnections = append(connections, &Connection{\n\t\t\tName:    connection.Name(),\n\t\t\tPin:     connection.Pin(),\n\t\t\tCurrent: connection.Read(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, http.StatusOK, connections)\n}", "CodeBleu_score": 50.973611821935236}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, 404, JSON{\n\t\t\t\"error\": fmt.Sprintf(\"Robot with name %s not found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := make([]JSON, 0)\n\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\tconnections = append(connections, connection.ToJSON())\n\t})\n\n\ta.writeJSON(res, 200, connections)\n}", "CodeBleu_score": 51.25485289452184}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, &errorJSON{\n\t\t\tStatus:  http.StatusNotFound,\n\t\t\tMessage: fmt.Sprintf(\"Robot with name %s not found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tconns := []*connectionJSON{}\n\trobot.Connections().Each(func(conn gpio.DigitalReader) {\n\t\tconns = append(conns, &connectionJSON{\n\t\t\tName:    conn.Name(),\n\t\t\tPin:     conn.Pin(),\n\t\t\tReading: conn.Read(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, http.StatusOK, conns)\n}", "CodeBleu_score": 45.61373419524345}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, JSON{\n\t\t\t\"error\": \"Device \" + req.URL.Query().Get(\":device\") + \" on robot \" + req.URL.Query().Get(\":robot\") + \" not found\",\n\t\t})\n\t\treturn\n\t}\n\n\tcommand := device.(gobot.Commander).Command(req.URL.Query().Get(\":command\"))\n\n\tif command == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, JSON{\n\t\t\t\"error\": \"Command \" + req.URL.Query().Get(\":command\") + \" on device \" + req.URL.Query().Get(\":device\") + \" not found\",\n\t\t})\n\t\treturn\n\t}\n\n\ta.executeCommand(robot, device, command, req.URL.Query(), res)\n}", "CodeBleu_score": 48.59034611912222}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, &struct{}{})\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\":command\")\n\n\tswitch device.(type) {\n\tcase gobot.Commander:\n\t\ta.executeCommand(res, req, robot, device.(gobot.Commander), command)\n\tdefault:\n\t\ta.writeJSON(res, http.StatusBadRequest, &struct{}{})\n\t}\n}", "CodeBleu_score": 52.184495088841786}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobot := a.master.Robot(req.URL.Query().Get(\":robot\"))\n\tdevice := robot.Device(req.URL.Query().Get(\":device\"))\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, jsonError{\n\t\t\tMessage: fmt.Sprintf(\"Device %s not found\", req.URL.Query().Get(\":device\")),\n\t\t})\n\t\treturn\n\t}\n\tcommand, err := device.(gobot.Commander).Command(req.URL.Query().Get(\":command\"))\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusNotFound, jsonError{\n\t\t\tMessage: err.Error(),\n\t\t})\n\t\treturn\n\t}\n\ta.executeCommand(robot, device, command)\n}", "CodeBleu_score": 54.09252145695282}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\texpected := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\t\tif expected != r.Header.Get(\"Authorization\") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 63.74803227833918}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t    expectedAuth := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\n    return func(res http.ResponseWriter, req *http.Request) {\n        auth := req.Header.Get(\"Authorization\")\n        if auth != expectedAuth {\n            res.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n            http.Error(res, \"Unauthorized\", http.StatusUnauthorized)\n            return\n        }\n    }\n}", "CodeBleu_score": 71.66007750734069}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\texpectedAuth := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\treturn func(res http.ResponseWriter, req *http.Request) {\n\t\tauth := req.Header.Get(\"Authorization\")\n\t\tif !secureCompare(auth, expectedAuth) {\n\t\t\tres.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 75.0598406482059}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := gobot.ToScale(a.sensorCfg.scale, float64(raw))\n\n\ta.lastRaw = raw\n\ta.lastValue = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 43.53902303670317}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.Connection().AnalogModeSupported() {\n\t\treturn 0, 0.0, fmt.Errorf(\"%s(%s) analog readings not supported\", a.Name(), a.Connection().Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\n\ta.lastRaw = raw\n\ta.lastValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.4733877787726}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor has no connection\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.sensorCfg.scale\n\n\ta.lastRaw = raw\n\ta.lastValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.75147684277765}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := NewAnalogSensorDriver(a, pin, 10*time.Millisecond)\n\n\tn := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: s,\n\t\tDefaultName:        gobot.DefaultName(\"GroveSoundSensor\"),\n\t}\n\n\tfor _, option := range opts {\n\t\toption(n)\n\t}\n\n\treturn n\n}", "CodeBleu_score": 37.47221384083487}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := NewAnalogSensorDriver(a, pin, 1*time.Second, opts...)\n\n\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: s,\n\t\tDefaultName:        gobot.DefaultName(\"GroveSoundSensor\"),\n\t}\n\n\tg.AddEvent(SoundDetected)\n\tg.AddEvent(SoundAbsent)\n\n\treturn g\n}", "CodeBleu_score": 36.58588380113533}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := NewAnalogSensorDriver(a, pin, 1*time.Second, opts...)\n\n\ts.SetName(DefaultName(\"GroveSoundSensor\"))\n\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: s,\n\t}\n}", "CodeBleu_score": 37.343706900390714}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeByteData(CommandReg, SoftReset); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(100 * time.Millisecond)\n\tif _, err := d.readByteData(CommandReg); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 63.28684527678161}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeByteData(CommandReg, SoftReset)\n\ttime.Sleep(5 * time.Millisecond)\n\tvalue, err := d.readByteData(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif value != 0 {\n\t\treturn fmt.Errorf(\"MFRC522Common: soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 52.490701008572}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeByteData(regCommand, softResetCmd); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(100 * time.Millisecond)\n\tval, err := d.readByteData(regCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&(1<<4) != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 73.13476118768499}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn := len(backData)\n\tnBits, err := d.readReg(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif nBits != uint8(n) {\n\t\treturn 0, fmt.Errorf(\"bad length in readFifo(): %d != %d\", nBits, n)\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i], err = d.readReg(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tlastBits, err := d.readReg(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn lastBits & 0x07, nil\n}", "CodeBleu_score": 49.598116632571625}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn := len(backData)\n\tlastBits, err := d.readByteData(FIFOLevelReg)\n\tif err != nil {\n\t\treturn lastBits, err\n\t}\n\tif lastBits > uint8(n)*8 {\n\t\tlastBits = uint8(n) * 8\n\t}\n\n\tfor i := uint8(0); i < lastBits; i++ {\n\t\tnt, err := d.readByteData(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn lastBits, err\n\t\t}\n\t\tif i < uint8(n) {\n\t\t\tbackData[i] = nt\n\t\t}\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 38.51058693799844}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn := len(backData)\n\ti := 0\n\tlastBits := uint8(0)\n\tif n == 0 {\n\t\treturn 0, nil\n\t}\n\tif n > 64 {\n\t\treturn 0, fmt.Errorf(\"too many bytes (%d) to read\", n)\n\t}\n\tst := d.readByteData(FIFOLevelReg) & (BitMaskFIFOLevelRegL | BitMaskFIFOLevelRegH)\n\tif (st & BitMaskFIFOLevelRegL) == 0 {\n\t\tst = d.readByteData(ControlReg) & (BitMaskControlReg0 | BitMaskControlReg1)\n\t\tst = st & (BitMaskControlReg0 | BitMaskControlReg1)\n\t\tif (st & BitMaskControlReg0) == 0 {\n\t\t\tst = st & (BitMaskControlReg0 | BitMaskControlReg1)\n\t\t}\n\t}\n\ti = 0\n\tfor {\n\t\tn--\n\t\tbackData[i] = d.readByteData(FIFODataReg)\n\t\ti++\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tlastBits = d.readByteData(ControlReg) & (BitMaskControlReg0 | BitMaskControlReg1)\n\tif (lastBits & BitMaskControlReg1) != 0 {\n\t\tlastBits = lastBits & (BitMaskControlReg0 | BitMaskControlReg1)\n\t}\n\treturn lastBits, nil\n}", "CodeBleu_score": 35.155060629101406}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debugging {\n\t\tlog.Println(\"Halting PICC...\")\n\t}\n\tbuffer := []byte{0x50, 0x00, 0x00, 0x00}\n\td.calculateCRC(buffer, 4)\n\t_, err := d.communicateWithPICC(0x00, 0x00, buffer)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error while halting PICC: %v\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 26.194830575343264}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debugging {\n\t\td.logger.Debug(\"Halting PICC...\")\n\t}\n\n\tcmd := []uint8{0x50, 0x00, 0x00, 0x00}\n\td.calculateCRC(cmd, 4)\n\n\terr := d.communicateWithPICC(d.PCD_TRANSCEIVE, cmd)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error halting PICC: %v\", err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 22.492174162184735}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.logDebug(\"Halting PICC...\")\n\thaltCommand := []byte{0x50, 0x00, 0x00, 0x00}\n\thaltCRC := d.calculateCRC(haltCommand)\n\thaltCommand = append(haltCommand, haltCRC[0], haltCRC[1])\n\t_, err := d.communicateWithPICC(haltCommand)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error halting PICC: %v\", err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 37.463688277047595}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := make([]byte, 5)\n\tcmd[0] = 0x30\n\tcmd[1] = block\n\tcrc := d.calculateCRC(cmd[:2])\n\tcmd[2] = uint8((crc & 0xFF00) >> 8)\n\tcmd[3] = uint8(crc & 0x00FF)\n\tcmd[4] = 0\n\t_, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata := make([]byte, 16)\n\tn, err := d.communicateWithPICC(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data[:n], nil\n}", "CodeBleu_score": 34.66766432286032}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := []byte{piccRead, block}\n\td.calculateCRC(cmd)\n\t_, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata, err := d.communicateWithPICC([]byte{piccHalt})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}", "CodeBleu_score": 37.343451483964095}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := make([]byte, 4)\n\tcmd[0] = 0x30\n\tcmd[1] = block\n\tcmd[2] = make([]byte, 2)\n\td.calculateCRC(cmd, 2)\n\n\tresponse, err := d.communicateWithPICC(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := append(response[:10], response[12:]...)\n\n\treturn data, nil\n}", "CodeBleu_score": 27.16368528944072}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer must be at least 2 bytes\")\n\t}\n\n\td.clearRegisterBitMask(COLL, 0x80)\n\n\tswitch reqMode {\n\tcase PICC_REQIDL:\n\t\td.clearRegisterBitMask(COLL, 0x20)\n\t\tbreak\n\tcase PICC_REQALL:\n\t\td.setRegisterBitMask(COLL, 0x20)\n\t\tbreak\n\tcase PICC_ANTICOLL:\n\t\td.setRegisterBitMask(COLL, 0x20)\n\t\tbreak\n\t}\n\n\tif reqMode == PICC_ANTICOLL {\n\t\td.clearRegisterBitMask(COLL, 0x80)\n\t}\n\n\t_, err := d.communicateWithPICC(reqMode, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif reqMode == PICC_ANTICOLL {\n\t\td.setRegisterBitMask(COLL, 0x80)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 56.81347438026276}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\td.clearRegisterBitMask(d.collReg, 0x80)\n\tswitch reqMode {\n\tcase PiccCmdMfAuthent:\n\t\td.clearRegisterBitMask(d.collReg, 0x08)\n\t\tbreak\n\tcase PiccCmdMfTransfer:\n\t\td.setRegisterBitMask(d.collReg, 0x08)\n\t\tbreak\n\tdefault:\n\t\tbreak\n\t}\n\n\t_, err := d.communicateWithPICC(PiccCmdMfTransceive, reqMode, answer)\n\treturn err\n}", "CodeBleu_score": 49.270716581278016}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\td.clearRegisterBitMask(CollReg, 0x80)\n\n\tswitch reqMode {\n\tcase PICC_CMD_REQA:\n\t\td.setRegisterBitMask(CollReg, 0x20)\n\t\tbreak\n\tcase PICC_CMD_WUPA:\n\t\td.setRegisterBitMask(CollReg, 0x60)\n\t\tbreak\n\tdefault:\n\t\td.setRegisterBitMask(CollReg, 0x40)\n\t\tbreak\n\t}\n\n\t_, err := d.communicateWithPICC(reqMode, answer)\n\treturn err\n}", "CodeBleu_score": 49.98665629606064}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.digitalWrite(d.stepPin, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\terr = d.digitalWrite(d.stepPin, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == Forward {\n\t\td.stepNumber++\n\t}\n\tif d.direction == Backward {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 73.54728117596106}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.digitalWrite(d.StepPin, 0); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.getDelayPerStep())\n\tif err := d.digitalWrite(d.StepPin, 1); err != nil {\n\t\treturn err\n\t}\n\tif d.Direction == CounterClockwise {\n\t\td.StepNumber++\n\t} else {\n\t\td.StepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 85.70032152046024}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\td.digitalWrite(d.StepPin, 0)\n\ttime.Sleep(d.getDelayPerStep())\n\td.digitalWrite(d.StepPin, 1)\n\n\tif d.Direction == CW {\n\t\td.StepNumber++\n\t} else {\n\t\td.StepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.93539624429344}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor is already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.Name())\n\n\treturn nil\n}", "CodeBleu_score": 82.22139086303719}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}(d.name)\n\n\treturn nil\n}", "CodeBleu_score": 68.21580159749709}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorStopChan != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorStopWaitGroup.Add(1)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\td.distanceMonitorStopWaitGroup.Done()\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped: %v\n\", err)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"continuous distance measurement: %v\n\", distance)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 60.53449052471043}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\treturn func(event int, duration time.Duration, src string, timestamp uint32, seqno uint32) {\n\t\tif event == gpio.FallingEdge {\n\t\t\td.duration <- time.Since(startTimestamp)\n\t\t\tstartTimestamp = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 35.681380378359904}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, eventType string, timestamp uint32, seqno uint32) {\n\t\tif eventType == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if eventType == \"falling\" {\n\t\t\tduration := time.Since(startTimestamp)\n\t\t\td.pulseChannel <- duration\n\t\t\tstartTimestamp = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.138630493380305}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar startTimestamp time.Time\n\treturn func(pin int, duration time.Duration, event string, timestamp uint32, seqno uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\tduration := time.Since(startTimestamp)\n\t\t\td.pulseChannel <- duration\n\t\t\tstartTimestamp = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.098069170043324}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor\n\tif err := d.trigger.Trigger(10 * time.Microsecond); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the echo to be high or for a timeout to occur\n\tstartTime := time.Now()\n\tfor d.echo.Read() == gpio.Low {\n\t\tif time.Since(startTime) > time.Second {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\t}\n\t}\n\n\t// Wait for the echo to be low or for a timeout to occur\n\tstartTime = time.Now()\n\tfor d.echo.Read() == gpio.High {\n\t\tif time.Since(startTime) > time.Second {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\t}\n\t}\n\n\t// Store the measured time in microseconds\n\td.measuredTime = time.Since(startTime)\n\treturn nil\n}", "CodeBleu_score": 60.308794234726626}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.triggerPin.Low()\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Low()\n\n\tselect {\n\tcase <-d.echoPin.WaitForEdge(time.Second):\n\t\treturn nil\n\tcase <-time.After(time.Second):\n\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t}\n}", "CodeBleu_score": 42.8394565677191}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.triggerPin.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Low()\n\n\tselect {\n\tcase <-time.After(d.timeout):\n\t\treturn fmt.Errorf(\"timeout waiting for distance measurement\")\n\tcase <-d.echoPin.WaitForEdge(d.echoTimeout):\n\t}\n\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\td.echoPin.Read()\n\td.measuredTime = time.Since(d.startTime)\n\n\treturn nil\n}", "CodeBleu_score": 48.366045963500696}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if self.access_token:\n        return self.access_token\n\n    if self.refresh_token:\n        try:\n            data = self.fetch_json_data(\n                \"auth.get\",\n                {\n                    \"f\": \"json\",\n                    \"access_token\": self.refresh_token,\n                },\n            )\n            self.set_state_item(\"auth\", data)\n            self.access_token = data[\"access_token\"]\n            self.refresh_token = data[\"refresh_token\"]\n            self.expiration_time = data[\"expires_in\"] + get()\n            return self.access_token\n        except Exception:\n            pass\n\n    if self.get_state_item(\"auth\"):\n        auth = self.get_state_item(\"auth\")\n        if auth[\"expires_in\"] + auth[\"created_at\"] > time():\n            self.access_token = auth[\"access_token\"]\n            self.refresh_token = auth[\"refresh_token\"]\n            self.expiration_time = auth[\"expires_in\"] + auth[\"created_at\"]\n            return self.access_token\n\n    raise AccountNotAuthorized(\n        \"No authentication token available. Please run `app.authorize()` first.\"\n    )\n\n", "CodeBleu_score": 42.63616086118594}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.auth_token:\n        return self.auth_token\n\n    if self.refresh_token:\n        data = self.fetch_json_data(\n            auth.get,\n            params={\n                \"client_id\": self.client_id,\n                \"client_secret\": self.client_secret,\n                \"grant_type\": \"refresh_token\",\n                \"refresh_token\": self.refresh_token,\n            },\n        )\n\n        self.update_local_session(data)\n        return self.auth_token\n\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 30.321863550883705}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.auth_token:\n        return self.auth_token\n\n    if self.refresh_token:\n        try:\n            data = self.fetch_json_data(\n                auth.get,\n                data={\n                    \"grant_type\": \"refresh_token\",\n                    \"refresh_token\": self.refresh_token,\n                },\n            )\n        except Exception as e:\n            self.delete_local_session()\n            raise AccountNotAuthorized() from e\n\n        self.auth_token = data[\"access_token\"]\n        self.refresh_token = data[\"refresh_token\"]\n        self.expires_at = time.time() + data[\"expires_in\"]\n        self.save_local_session()\n\n        return self.auth_token\n\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 37.359452899934865}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.session.post(\n            url=f\"{self.api_url}/v1/logout\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 49.6631303752798}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            url=\"https://api.spotify.com/v1/logout\",\n            method=\"POST\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 50.96856772255304}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.post_json_data(\n            \"/v1/logout\",\n            {\n                \"refresh_token\": refresh_token,\n            },\n        )\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 57.20624704335824}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.get_package().items:\n        if package.optional:\n            continue\n        result.append(package.name + \" \" + package.version)\n        if package.metadata:\n            if \"external\" in package.metadata:\n                result.append(package.metadata[\"external\"][\"source\"])\n    return result\n\n", "CodeBleu_score": 26.893708116860683}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.get_package():\n        if package.is_optional():\n            continue\n        metadata = package.get_metadata()\n        result.append(\n            {\n                \"name\": package.name,\n                \"version\": package.version,\n                \"source\": metadata.get(\"source\", \"\"),\n            }\n        )\n    return result", "CodeBleu_score": 27.91067180450217}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.get_package():\n        if package.is_optional():\n            continue\n        package_name = package.get_name()\n        package_version = package.get_version()\n        package_metadata = package.get_metadata()\n        if package_metadata.get(\"external\", False):\n            package_source = package_metadata.get(\"source\", \"\")\n            result.append(f\"{package_name}=={package_version} ({package_source})\")\n        else:\n            result.append(f\"{package_name}=={package_version}\")\n    return result\n\n", "CodeBleu_score": 27.66946375000404}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform = cls.config.get('env', env)\n    if not platform:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls.new(platform, autoinstall=autoinstall)\n    instance.project_env = env\n    instance.configure_project_packages(env, targets)\n    return instance", "CodeBleu_score": 46.463415152942105}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    spec = config.get('envs', env)\n    if not spec:\n        raise UndefinedEnvPlatformError(env)\n    p = cls(spec, autoinstall=autoinstall)\n    p.env = env\n    p.configure_project_packages(env, targets)\n    return p\n\n", "CodeBleu_score": 52.171165265314535}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_spec = config.get('envs', {}).get(env)\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls.new(platform_spec, autoinstall)\n    instance.set_project_env(env)\n    p.configure_project_packages(instance, env, targets)\n    return instance\n\n", "CodeBleu_score": 28.26816389932945}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, (int)Size);\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire1.read();\n  }\n}", "CodeBleu_score": 97.59822825178871}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, (int)Size);\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire1.read();\n  }\n}", "CodeBleu_score": 97.59822825178871}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire1.beginTransmission(0x34);\n  Wire1.write(Addr);\n  Wire1.endTransmission();\n  Wire1.requestFrom(0x34, (int)Size);\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire1.read();\n  }\n}", "CodeBleu_score": 97.59822825178871}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tesp_sleep_enable_timer_wakeup(time_in_us);\n\t} else {\n\t\tesp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n\t}\n\tesp_deep_sleep_start();\n}", "CodeBleu_score": 64.9342703245996}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.78665494933675}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.78665494933675}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t  int y_prev = tft.getCursorY();\n  int y_new = tft.getCursorY() + tft.fontHeight();\n  if (y_new > tft.height() - 10) {\n    tft.setCursor(0, tft.getScrollAddress() + 1);\n    y_new = tft.getCursorY() + tft.fontHeight();\n  }\n  if (tteBar) {\n    tft.fillRect(0, 25, tft.width(), tft.fontHeight(), color);\n  } else {\n    tft.fillRect(0, 0, tft.width(), tft.fontHeight(), color);\n  }\n  tft.setScrollAddress(tft.getScrollAddress() + 1);\n  return y_prev;\n}", "CodeBleu_score": 23.103696441141455}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = tft.getCursorY();\n  int y_max = tft.height() - 16;\n  int y_min = 16;\n  if (tteBar) {\n    y_min = 32;\n  }\n  if (y >= y_max) {\n    tft.scroll(0, -16);\n    tft.fillRect(0, y_min, tft.width(), 16, color);\n    tft.setCursor(0, y_min);\n  } else {\n    tft.fillRect(0, y, tft.width(), 16, color);\n    tft.setCursor(0, y + 16);\n  }\n  tft.scroll(0, -16);\n  return y;\n}", "CodeBleu_score": 23.77291320171267}, {"code": "int Display::scroll_line(uint32_t color){\n\t    int y = tft.getCursorY();\n    int h = tft.fontHeight();\n    int y_max = tft.height() - tft.fontHeight() - 1;\n    if (tteBar) {\n        y_max = tft.height() - tft.fontHeight() - 1 - tft.fontHeight() - 1;\n    }\n    if (y >= y_max) {\n        tft.scrollAddress(0, y - h);\n        y = 0;\n    } else {\n        y += h;\n    }\n    tft.fillRect(0, y, tft.width(), h, color);\n    tft.setCursor(0, y);\n    return y;\n}", "CodeBleu_score": 26.803636587169148}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->setAP(access_points);\n  this->setHtml(ssids);\n  return this->startPortal();\n}", "CodeBleu_score": 49.173874326521656}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t    // Set the access points\n    if (!this->setAP(ssids, access_points)) {\n        return false;\n    }\n\n    // Set the HTML content\n    if (!this->setHtml()) {\n        return false;\n    }\n\n    // Start the portal\n    startPortal();\n\n    return true;\n}", "CodeBleu_score": 78.3760624956568}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t    this->setAP(ssids, access_points);\n    this->setHtml();\n    return this->startPortal();\n}", "CodeBleu_score": 52.9822435850857}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t    if (this->queue_enabled_flag) {\n        this->flush_queue();\n        this->new_queue();\n    } else {\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 21.83846227522183}, {"code": "void GpsInterface::enable_queue(){\n\t  if (this->queue_enabled_flag) {\n    this->flush_queue();\n    this->new_queue();\n  } else {\n    this->flush_queue();\n    this->queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 24.620216010882867}, {"code": "void GpsInterface::enable_queue(){\n\t    if (this->queue_enabled_flag) {\n        this->flush_queue();\n        this->new_queue();\n    } else {\n        this->flush_queue();\n        this->queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 26.728270704074596}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\n    // Lock the mutex\n    this->queue_mutex.lock();\n\n    // Check if the queue exists and contains elements\n    if (this->queue != nullptr && !this->queue->empty()) {\n\n        // Create a new queue and delete the old one\n        delete this->queue;\n        this->queue = new std::queue<std::string>;\n    } else {\n\n        // Create a new queue if the queue does not exist\n        this->queue = new std::queue<std::string>;\n    }\n\n    // Unlock the mutex\n    this->queue_mutex.unlock();\n}", "CodeBleu_score": 21.63598998222674}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue != nullptr) {\n        if (this->queue->size > 0) {\n            this->new_queue = new Queue<NMEA_t>;\n            delete this->queue;\n            this->queue = this->new_queue;\n        }\n    } else {\n        this->queue = new Queue<NMEA_t>;\n    }\n}", "CodeBleu_score": 23.363279881908657}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue != NULL) {\n        if (this->queue->size > 0) {\n            delete this->queue;\n            this->queue = new Queue<std::string>;\n        }\n    } else {\n        this->queue = new Queue<std::string>;\n    }\n}", "CodeBleu_score": 21.998249768006346}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    /*Get the display object from the disp parameter*/\n    my_disp_t *my_disp = (my_disp_t *)disp->user_data;\n\n    /*Start a write transaction*/\n    my_disp->tft.startWrite();\n\n    /*Set the address window to the specified area*/\n    my_disp->tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\n    /*Iterate through each pixel in the area*/\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        /*Write the corresponding color from the provided color buffer*/\n        my_disp->tft.writeColor(*color_p++, 1);\n      }\n    }\n\n    /*End the write transaction*/\n    my_disp->tft.endWrite();\n\n    /*Notify that the display flush is complete*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 64.22789078855445}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    /*Make sure the area is valid*/\n    if (area->x2 < 0) return;\n    if (area->y2 < 0) return;\n    if (area->x1 > display_obj.tft.width()) return;\n    if (area->y1 > display_obj.tft.height()) return;\n\n    /*Get the display buffer*/\n    uint8_t *buf = (uint8_t *)color_p;\n\n    /*Start a write transaction*/\n    display_obj.tft.startWrite();\n\n    /*Set the address window to the specified area*/\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\n    /*Iterate through each pixel in the area*/\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        /*Write the corresponding color from the provided color buffer*/\n        display_obj.tft.writeColor(*buf, *(buf + 1), *(buf + 2), *(buf + 3));\n\n        /*Increment the buffer pointer*/\n        buf += 4;\n      }\n    }\n\n    /*End the write transaction*/\n    display_obj.tft.endWrite();\n\n    /*Notify that the display flush is complete*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 69.32802866551218}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    // Start a write transaction\n    lv_disp_flush_ready(disp);\n\n    // Set the address window to the specified area\n    display_obj.tft.setAddrWindow(area->x1, area->y1, area->x2, area->y2);\n\n    // Iterate through each pixel in the area\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        // Write the corresponding color from the provided color buffer\n        display_obj.tft.writeColor(*color_p, 1);\n        color_p++;\n      }\n    }\n\n    // End the write transaction\n    display_obj.tft.endWrite();\n\n    // Notify that the display flush is complete\n    lv_disp_flush_done(disp);\n  }", "CodeBleu_score": 65.74500169542885}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  int i;\n  int listSize = menu->list->size();\n  for (i = 0; i < listSize; i++) {\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\"-\");\n    }\n    Serial.print(menu->list->get(i)->name);\n    Serial.println();\n  }\n  Serial.println();\n}", "CodeBleu_score": 64.79343777010162}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  for (int i = 0; i < menu->list->size(); i++) {\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\" \");\n    }\n    Serial.println(menu->list->get(i)->name);\n  }\n  Serial.println();\n}", "CodeBleu_score": 71.86844833910574}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t  for (int i = 0; i < menu->list->size; i++) {\n    Serial.print(menu->list->get(i)->name);\n    Serial.print(\":\");\n    Serial.println(menu->list->get(i)->value);\n  }\n  Serial.println();\n}", "CodeBleu_score": 55.078145631058504}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  int generated = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += (char)random(32, 127);\n    }\n    int channel = random(1, 12);\n    String mac = \"\";\n    for (int j = 0; j < 12; j++) {\n      mac += String(random(0, 16), HEX);\n      if (j % 2 == 1 && j != 11) {\n        mac += \":\";\n      }\n    }\n    ssids->add(ssid);\n    Serial.println(\"SSID: \" + ssid + \" Channel: \" + String(channel) + \" MAC: \" + mac);\n    generated++;\n  }\n  return generated;\n}", "CodeBleu_score": 44.26550974484632}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int generated = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += (char)random(32, 127);\n    }\n    int channel = random(1, 14);\n    String mac = \"\";\n    for (int j = 0; j < 6; j++) {\n      mac += String(random(0, 256), HEX);\n      if (j < 5) {\n        mac += \":\";\n      }\n    }\n    ssids->add(ssid);\n    Serial.println(ssid + \",\" + String(channel) + \",\" + mac);\n    generated++;\n  }\n  return generated;\n}", "CodeBleu_score": 45.32887434166163}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    int generated = 0;\n    for (int i = 0; i < count; i++) {\n        String ssid = \"\";\n        for (int j = 0; j < 6; j++) {\n            ssid += (char) random(33, 126);\n        }\n        int channel = random(1, 13);\n        String mac = \"\";\n        for (int j = 0; j < 6; j++) {\n            mac += String(random(0, 255), HEX);\n            if (j < 5) {\n                mac += \":\";\n            }\n        }\n        ssids->add(new SSID(ssid, channel, mac));\n        Serial.println(ssid + \",\" + String(channel) + \",\" + mac);\n        generated++;\n    }\n    return generated;\n}", "CodeBleu_score": 42.439727389445316}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 49.33548033251296}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 49.33548033251296}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 49.33548033251296}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.utcnow(),\n        'exp': datetime.utcnow() + timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 46.427749314556266}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        'iat': datetime.datetime.utcnow(),\n        # The time the token expires.\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    print(\n        'Creating JWT using {} from private key file {}'.format(\n            algorithm, private_key_file))\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 78.13838633010488}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        \"iat\": datetime.datetime.utcnow(),\n        # The time the token expires.\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        \"aud\": project_id,\n    }\n\n    # Read the private key file.\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    print(\n        \"Creating JWT using {} from private key file {}\".format(\n            algorithm, private_key_file\n        )\n    )\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 64.96658174821921}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Received message '{}' on topic '{}' with QoS {}\".format(payload, message.topic, str(message.qos)))\n    if payload == \"on\":\n        preview_capture()\n        upload_file()\n        parse_command_line_args()\n        unused_client.publish(\n            mqtt_topic,\n            payload=format(\n                \"https://storage.googleapis.com/{}/{}\".format(\n                    bucket_name,\n                    blob_name,\n                )\n            ),\n            qos=1,\n        )\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 35.803789790771255}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload\n    print(\"Received message '{}' on topic '{}' with Qos {}\".format(payload, message.topic, str(message.qos)))\n    if payload == b\"on\":\n        print(\"Turning on the device\")\n        preview_capture()\n        upload_file()\n        print(\"Publishing message to topic {}\".format(mqtt_event_topic))\n        unused_client.publish(mqtt_event_topic, payload.decode(\"utf-8\"))\n    else:\n        print(\"Turning off the device\")\n        print(\"off\")\n\n", "CodeBleu_score": 29.8573496218046}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload\n    print(f\"Received message '{payload.decode()}' from topic '{message.topic}' with QoS {message.qos}\")\n    if payload.decode() == \"on\":\n        preview_capture()\n        upload_file()\n        publish(f\"{args.event_topic}\", f\"{args.file_url}\")\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 19.164888851925983}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=\"Example of MQTT device connection code.\"\n    )\n    parser.add_argument(\n        \"--project_id\",\n        required=False,\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\"--subscription_name\", required=True, help=\"PubSub subscription name\")\n    parser.add_argument(\n        \"--ca_certs\",\n        required=False,\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        required=False,\n        default=os.environ.get(\"PRIVATE_KEY\"),\n        help=\"Path to private key file. This file must be present only when running in a Cloud Function.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=False,\n        default=\"RS256\",\n        help=\"Which encryption algorithm to use to generate the JWT. Supports RS256 and ES256\",\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        required=False,\n        default=\"us-central1\",\n        help=\"GCP cloud region\",\n    )\n    parser.add_argument(\n        \"--registry_id\", required=True, help=\"Cloud IoT Core registry id\"\n    )\n    parser.add_argument(\n        \"--device_id\", required=True, help=\"Cloud IoT Core device id\"\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        required=False,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        required=False,\n        default=\"", "CodeBleu_score": 38.817420489061696}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=\"Example of MQTT device connection code.\"\n    )\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--subscription_name\",\n        required=True,\n        help=\"Name of Cloud IoT Core MQTT subscription\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        required=True,\n        help=\"Indicates whether the message to be published \"\n        \"is a telemetry event or a device state message.\",\n    )\n    parser.add_argument(\n        \"--registry_id\", required=True, help=\"Cloud IoT Core registry id\"\n    )\n    parser.add_argument(\n        \"--device_id\", required=True, help=\"Cloud IoT Core device id\"\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        required=True,\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\"\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\"\n    )\n    parser.add_argument(\n        \"--message_interval\",\n        type=int,\n       ", "CodeBleu_score": 38.254950277319516}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=('Example Google Cloud IoT MQTT device connection code.'))\n    parser.add_argument('--project_id', default=os.environ.get('GOOGLE_CLOUD_PROJECT'), help=('GCP cloud project name'))\n    parser.add_argument('--subscription_name', required=True, help=('Name of Cloud IoT Core MQTT topic subscription'))\n    return parser.parse_args()\n\n", "CodeBleu_score": 50.610687559750936}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version={}'.format(api_version)\n\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    credentials = credentials.with_scopes(api_scopes)\n\n    # Create a client for the Cloud IoT Core service.\n    client = googleapiclient.discovery.build(\n        'cloudiot',\n        api_version,\n        discoveryServiceUrl=discovery_url,\n        credentials=credentials)\n\n    return client\n\n", "CodeBleu_score": 55.73520948063994}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api = 'https://cloudiot.googleapis.com/$discovery/rest?version={}'.format(api_version)\n    service_name = 'cloudiotcore'\n\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n\n    discovery_url = discovery_api\n    service = discovery.build(service_name, api_version, discoveryServiceUrl=discovery_url, credentials=scoped_credentials)\n\n    return service\n\n", "CodeBleu_score": 65.6129147011677}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_name = 'cloudiotcore'\n\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n\n    discovery_url = '{}?version={}'.format(\n        discovery_url, api_version)\n\n    return discovery.build(\n        service_name,\n        api_version,\n        discoveryServiceUrl=discovery_url,\n        credentials=scoped_credentials)\n\n", "CodeBleu_score": 67.42761247195291}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1 = _get_asn1(hash_method)\n    if not asn1:\n        raise ValueError(\"unsupported hash type\")\n    hash_info = asn1 + hash_value\n    padded_hash = _pad_for_signing(hash_info, priv_key.size_in_bytes())\n    sig = priv_key.blinded_encrypt(padded_hash, randfunc=None)\n    return sig\n\n", "CodeBleu_score": 27.451793960625814}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method = get_hash_method(hash_method)\n    if hash_method is None:\n        raise ValueError(\"Invalid hash method\")\n    asn1_code = get_asn1_code(hash_method)\n    hash_value = asn1_code + hash_value\n    padded_hash = _pad_for_signing(hash_value, priv_key.size_in_bytes())\n    encrypted_signature = priv_key.blinded_encrypt(padded_hash)\n    return encrypted_signature\n\n", "CodeBleu_score": 36.98009815530794}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = get_asn1_code(hash_method)\n    if asn1_code is None:\n        raise ValueError(\"Invalid hash method\")\n    hash_value = asn1_code + hash_value\n    padded_hash = _pad_for_signing(hash_value, priv_key.size_in_bytes())\n    encrypted_hash = priv_key.blinded_encrypt(padded_hash)\n    return encrypted_hash\n\n", "CodeBleu_score": 31.68322000793532}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    hash_method = _find_method_hash(pub_key)\n    hash_size = hash_method().digest_size\n    if len(signature) != hash_size:\n        raise VerificationError(\"Signature length is wrong\")\n    signature = transform.bytes2int(signature)\n    clear_sig = core.decrypt_int(signature, pub_key.e, pub_key.n)\n    expected_hash = _pad_for_signing(compute_hash(message), hash_size)\n    if clear_sig != expected_hash:\n        raise VerificationError(\"Signature is invalid\")\n    return hash_method.__name__\n\n", "CodeBleu_score": 38.73985740564721}, {"code": "def verify(message, signature, pub_key)\n\t\n    hash_method = pub_key.default_hash_alg()\n    hash_size = hash_method.digest_size\n    if len(signature) != hash_size:\n        raise VerificationError(\"Signature length is wrong\")\n    signature = transform.bytes2int(signature)\n    clear_sign = core.decrypt_int(signature, pub_key.e, pub_key.n)\n    hash_method = _find_method_hash(hash_method)\n    hashed = hash_method.new(message).digest()\n    padded = _pad_for_signing(hashed, pub_key.size_in_bytes())\n    if transform.bytes2int(padded) != clear_sign:\n        raise VerificationError(\"Padding is incorrect\")\n    return hash_method.name", "CodeBleu_score": 41.28529950054334}, {"code": "def verify(message, signature, pub_key)\n\t\n    hash_method = _find_method_hash(pub_key)\n    hash_size = common.byte_size(pub_key.n)\n    clearsig = core.decrypt_int(pub_key, signature)\n    if len(clearsig) != 2 * hash_size:\n        raise ValueError(\"Signature length is invalid\")\n    left_size = hash_size + clearsig[hash_size]\n    left = clearsig[:left_size]\n    right = clearsig[left_size:]\n    expected_hash = transform.bytes2int(hash_method(message).digest())\n    expected_hash = _pad_for_signing(expected_hash, left_size)\n    if left != expected_hash:\n        raise VerificationError(\"Signature verification failed\")\n    return hash_method.__name__", "CodeBleu_score": 41.17661711300673}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t  time_t now;\n  time(&now);\n  if (now > 0) {\n    updateJWT(now);\n  }\n  MQTT_CLIENT_connect();\n  send_mqtt_subscribe = true;\n  debug_print(\"MQTT Connect Attempt\");\n}", "CodeBleu_score": 26.731875627573174}, {"code": "static void connectMQTT(){\n\t    // Get current time\n    time_t now = time(NULL);\n    if (now < 0) {\n        // Error getting time\n        return;\n    }\n\n    // Update JWT with current time\n    updateJWT(now);\n\n    // Connect to MQTT client\n    MQTT_CLIENT_connect();\n\n    // Set flag to send MQTT SUBSCRIBE packet after connection\n    send_subscribe_packet = true;\n\n    // Print debug message\n    debug_print(\"Attempting MQTT connection\n\");\n}", "CodeBleu_score": 33.66622632595797}, {"code": "static void connectMQTT(){\n\t    time_t now = time(NULL);\n    if (now > 0) {\n        updateJWT(now);\n    }\n    MQTT_CLIENT_connect();\n    sendMQTTSubscribe = 1;\n    debug_print(\"MQTT connection attempt\n\");\n}", "CodeBleu_score": 31.17018922658388}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    for (int i = 0; i < width; i++) {\n        uint8_t ch = str[i];\n        if (ch < '0' || ch > '9') {\n            return str;\n        }\n        value = value * 10 + (ch - '0');\n    }\n    *num = value;\n    return str + width;\n}", "CodeBleu_score": 24.70820281416789}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    int i;\n    uint32_t n = 0;\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        n = n * 10 + (str[i] - '0');\n    }\n    *num = n;\n    return str + i;\n}", "CodeBleu_score": 26.115056914993755}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    for (int i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        value = value * 10 + (str[i] - '0');\n    }\n    *num = value;\n    return str + width;\n}", "CodeBleu_score": 25.59542155904565}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = ATCACERT_E_INTERNAL;\n    if (build_state != NULL) {\n        if (build_state->cert_def != NULL) {\n            if (build_state->cert_def->cert_size > 0) {\n                if (build_state->cert_def->cert_size <= build_state->cert_bytes_used) {\n                    ret = ATCACERT_E_OK;\n                }\n                else {\n                    ret = ATCACERT_E_INVALID_SIZE;\n                }\n            }\n            else {\n                ret = ATCACERT_E_INVALID_SIZE;\n            }\n        }\n        else {\n            ret = ATCACERT_E_INVALID_PARAM;\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 45.03510534670842}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = ATCACERT_E_BAD_PARAMS;\n    if (build_state != NULL) {\n        if (build_state->cert_def != NULL) {\n            if (build_state->cert_def->cert_size != 0) {\n                if (build_state->cert_def->cert_size <= build_state->cert_bytes_used) {\n                    ret = ATCACERT_E_BUFFER_TOO_SMALL;\n                }\n                else {\n                    ret = ATCACERT_E_SUCCESS;\n                }\n            }\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 45.39714833071855}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    if (build_state->cert_def.cert_template.cert_format == ATCACERT_FORMAT_DER) {\n        // Build DER certificate\n        return atcacert_build_der_cert(build_state);\n    }\n    else {\n        // Build PEM certificate\n        return atcacert_build_pem_cert(build_state);\n    }\n}", "CodeBleu_score": 16.32569341092068}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    uint8_t tbs_digest[32];\n    if (atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest) != ATCACERT_E_SUCCESS) {\n        return ATCACERT_E_BAD_CERT;\n    }\n\n    uint8_t signature[64];\n    if (atcacert_get_signature(cert_def, cert, cert_size, signature) != ATCACERT_E_SUCCESS) {\n        return ATCACERT_E_BAD_CERT;\n    }\n\n    int verify_result = atcab_verify_extern(tbs_digest, signature, ca_public_key);\n    if (verify_result == 0) {\n        return ATCACERT_E_SUCCESS;\n    } else {\n        return ATCACERT_E_VERIFY;\n    }\n}", "CodeBleu_score": 61.167423774745465}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcab_verify_extern(tbs_digest, signature, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 83.11015985422281}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcab_verify_extern(tbs_digest, signature, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 83.11015985422281}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if (timer == NULL)\n    {\n        return false;\n    }\n\n    if (*list == timer)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *prev = *list;\n    timerStruct_t *curr = prev->next;\n\n    while (curr != NULL)\n    {\n        if (curr == timer)\n        {\n            prev->next = curr->next;\n            return true;\n        }\n\n        prev = curr;\n        curr = curr->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 37.906096404580104}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if (timer->next != NULL)\n    {\n        timer->next->prev = timer->prev;\n    }\n\n    if (timer->prev != NULL)\n    {\n        timer->prev->next = timer->next;\n    }\n\n    if (*list == timer)\n    {\n        *list = timer->next;\n    }\n\n    return true;\n}", "CodeBleu_score": 22.797549954938535}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t  bool retVal_2;\n  timerStruct_t * volatile *list_0;\n  timerStruct_t * volatile *list_1;\n  timerStruct_t * volatile *list_2;\n  timerStruct_t * volatile *list_3;\n  timerStruct_t * volatile *list_4;\n  timerStruct_t * volatile *list_5;\n  timerStruct_t * volatile *list_6;\n  timerStruct_t * volatile *list_7;\n  timerStruct_t * volatile *list_8;\n  timerStruct_t * volatile *list_9;\n  timerStruct_t * volatile *list_10;\n  timerStruct_t * volatile *list_11;\n  timerStruct_t * volatile *list_12;\n  timerStruct_t * volatile *list_13;\n  timerStruct_t * volatile *list_14;\n  timerStruct_t * volatile *list_15;\n  timerStruct_t * volatile *list_16;\n  timerStruct_t * volatile *list_17;\n  timerStruct_t * volatile *list_18;\n  timerStruct_t * volatile *list_19;\n  timerStruct_t * volatile *list_20;\n  timerStruct_t * volatile *list_21;\n  timerStruct_t * volatile *list_22;\n  timerStruct_t * volatile *list_23;\n  timerStruct_t * volatile *list_24;\n  timerStruct_t * volatile *list_25;\n  timerStruct_t * volatile *list_26;\n  timerStruct_t * volatile *list_27;\n  timerStruct_t * volatile *list_28;\n  timerStruct_t * volatile *list_29;\n  timerStruct_t * volatile *list_30;\n  timerStruct_t * volatile *list_31;\n  timerStruct_t * volatile *list_32;\n  timerStruct_t * volatile *list_33;\n  timerStruct_t * volatile *list_34;\n  timerStruct_t * volatile *list_35;\n  timerStruct_t * volatile *list_", "CodeBleu_score": 8.143629671815281}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t    struct SocketInfo *socketInfo = getSocketInfo(socket);\n    if (socketInfo == NULL) {\n        return BSD_ERROR;\n    }\n    socketInfo->state = NOT_A_SOCKET;\n    int ret = close(socket);\n    if (ret < 0) {\n        bsd_setErrNo(errno);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 28.18109590755686}, {"code": "int BSD_close(int socket){\n\t    struct sockaddr_in *sockInfo = getSocketInfo(socket);\n    if (sockInfo == NULL) {\n        return BSD_ERROR;\n    }\n    sockInfo->state = NOT_A_SOCKET;\n    int ret = close(socket);\n    if (ret < 0) {\n        bsd_setErrNo(errno);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 27.890377086691885}, {"code": "int BSD_close(int socket){\n\t  struct socketInfo *socketInfo = getSocketInfo(socket);\n  if (socketInfo != NULL) {\n    socketInfo->state = NOT_A_SOCKET;\n  }\n  int result = close(socket);\n  if (result == -1) {\n    bsd_setErrNo();\n    return BSD_ERROR;\n  }\n  return BSD_SUCCESS;\n}", "CodeBleu_score": 25.749272472566243}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t    int result = listen(socket, backlog);\n    if (result < 0) {\n        bsd_setErrNo(errno);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 20.84257608737559}, {"code": "int BSD_listen(int socket, int backlog){\n\t    int response = listen(socket, backlog);\n    if (response < 0) {\n        bsd_setErrNo(errno);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 21.155600218800867}, {"code": "int BSD_listen(int socket, int backlog){\n\t    int response;\n\n    response = listen(socket, backlog);\n    if (response < 0) {\n        bsd_setErrNo(errno);\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 26.059560045498582}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t  int ret;\n  struct sockaddr * addr_p;\n  socklen_t addrlen_v;\n\n  if (addr != NULL) {\n    addr_p = (struct sockaddr *) addr;\n    addrlen_v = * addrlen;\n  } else {\n    addr_p = NULL;\n    addrlen_v = 0;\n  }\n\n  ret = accept(socket, addr_p, addrlen_v);\n  if (ret < 0) {\n    if (addr != NULL) {\n      * addrlen = addrlen_v;\n    }\n\n    bsd_setErrNo();\n    return -1;\n  }\n\n  if (addr != NULL) {\n    * addrlen = addrlen_v;\n  }\n\n  return ret;\n}", "CodeBleu_score": 33.88941495184915}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    struct sockaddr * sockaddr = (struct sockaddr *) addr;\n    socklen_t sockaddrlen = * addrlen;\n    int ret;\n\n    switch (addr -> sa_family) {\n    case AF_INET:\n        sockaddrlen = sizeof(struct sockaddr_in);\n        break;\n    case AF_INET6:\n        sockaddrlen = sizeof(struct sockaddr_in6);\n        break;\n    default:\n        bsd_setErrNo(EAFNOSUPPORT);\n        return -1;\n    }\n\n    ret = accept(socket, sockaddr, & sockaddrlen);\n    if (ret < 0) {\n        bsd_setErrNo(errno);\n        return -1;\n    }\n\n    * addrlen = sockaddrlen;\n    return ret;\n}", "CodeBleu_score": 44.16505892176151}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    int ret;\n    struct sockaddr_in * addr_in;\n    struct sockaddr_in6 * addr_in6;\n    struct sockaddr * addr_ptr;\n    socklen_t addr_len;\n\n    if (socket < 0) {\n        return -1;\n    }\n\n    switch (addr->sa_family) {\n        case AF_INET:\n            addr_in = (struct sockaddr_in *) addr;\n            addr_ptr = (struct sockaddr *) addr_in;\n            addr_len = sizeof(struct sockaddr_in);\n            break;\n        case AF_INET6:\n            addr_in6 = (struct sockaddr_in6 *) addr;\n            addr_ptr = (struct sockaddr *) addr_in6;\n            addr_len = sizeof(struct sockaddr_in6);\n            break;\n        default:\n            bsd_setErrNo(EAFNOSUPPORT);\n            return -1;\n    }\n\n    ret = accept(socket, addr_ptr, addrlen);\n    if (ret < 0) {\n        bsd_setErrNo(errno);\n        return -1;\n    }\n\n    return ret;\n}", "CodeBleu_score": 50.16994589679179}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t  // Get the current time in UNIX format\n  time_t now = time(NULL);\n\n  // Check if the time is valid\n  if (now < 0) {\n    debug_print(\"Error: Invalid time\n\");\n    return;\n  }\n\n  // Update the JWT with the current time offset\n  updateJWT(now);\n\n  // Initiate the MQTT connection\n  MQTT_CLIENT_connect();\n\n  // Print a debug message to indicate the connection attempt\n  debug_print(\"MQTT: Connecting...\n\");\n\n  // Set the flag to send an MQTT SUBSCRIBE packet once the connection is established\n  send_subscribe = 1;\n}", "CodeBleu_score": 54.83837563428842}, {"code": "static void connectMQTT(){\n\t  time_t current_time = time(NULL);\n  if (current_time < 0) {\n    Serial.println(\"Failed to retrieve current time\");\n    return;\n  }\n\n  updateJWT(current_time);\n  MQTT_CLIENT_connect();\n  debug_print(\"MQTT_CLIENT_connect()\");\n  send_subscribe_packet = true;\n}", "CodeBleu_score": 32.632383871177225}, {"code": "static void connectMQTT(){\n\t    uint32_t now = get_time_unix();\n    if (now > 0) {\n        updateJWT(now);\n        debug_print(\"Connecting to MQTT broker\\r\n\");\n        MQTT_CLIENT_connect(mqtt_client, mqtt_broker, mqtt_port, mqtt_user, mqtt_password, mqtt_client_id, mqtt_keepalive, mqtt_clean_session, mqtt_will_topic, mqtt_will_message, mqtt_will_qos, mqtt_will_retain, mqtt_ssl_ca_pem, mqtt_ssl_client_pem, mqtt_ssl_client_key, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n        MQTT_CLIENT_set_callback(mqtt_client, mqtt_callback);\n        send_mqtt_subscribe = true;\n    }\n}", "CodeBleu_score": 43.181498478012834}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t    debug_printError(\"Disconnecting from cloud service\n\");\n    if (MQTT_GetConnectionState() == CONNECTED) {\n        MQTT_GetClientConnectionInfo();\n        MQTT_Disconnect();\n    }\n}", "CodeBleu_score": 70.80571964009864}, {"code": "void CLOUD_disconnect(void){\n\t    MQTT_Connection_t connection;\n    MQTT_GetConnectionState(&connection);\n    if (connection == MQTT_CONNECTED) {\n        MQTT_Client_t client;\n        MQTT_GetClientConnectionInfo(&client);\n        MQTT_Disconnect(&client);\n    }\n    debug_printError(\"Disconnected from cloud\");\n}", "CodeBleu_score": 46.35648733205508}, {"code": "void CLOUD_disconnect(void){\n\t    MQTT_Connection_t connection;\n    MQTT_GetConnectionState(&connection);\n\n    if (connection == MQTT_CONNECTED) {\n        MQTT_GetClientConnectionInfo(&connection);\n        MQTT_Disconnect(&connection);\n    }\n\n    debug_printError(\"Disconnected from cloud service\n\");\n}", "CodeBleu_score": 46.94294069390935}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\n    // Check if new credentials are provided\n    if (passed_wifi_creds) {\n        // Connect using new credentials\n        if (!m2m_wifi_connect(\n                (char *)&wifi_creds.ssid,\n                strlen((char *)&wifi_creds.ssid),\n                M2M_WIFI_SEC_WPA_PSK,\n                (char *)&wifi_creds.pass,\n                strlen((char *)&wifi_creds.pass))) {\n            // Connection failed\n            debug_printError(\"WiFi connection failed. Error: %d\n\", m2m_wifi_get_connection_status());\n            // Update networking error status\n            networking_error_status = M2M_ERR_CONN_FAILED;\n            // Return false\n            return false;\n        }\n    } else {\n        // Connect using default credentials\n        if (!m2m_wifi_default_connect()) {\n            // Connection failed\n            debug_printError(\"WiFi connection failed. Error: %d\n\", m2m_wifi_get_connection_status());\n            // Update networking error status\n            networking_error_status = M2M_ERR_CONN_FAILED;\n            // Return false\n            return false;\n        }\n    }\n\n    // Connection succeeded\n    return true;\n}", "CodeBleu_score": 44.47733855280836}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t  if (passed_wifi_creds) {\n    if (m2m_wifi_connect(wifi_ssid,\n                         m2m_wifi_security_type,\n                         wifi_password,\n                         &wifi_credentials_callback) == false) {\n      debug_printError(ERROR_WIFI_CONNECT);\n      wifi_error_status = true;\n      return false;\n    }\n  } else {\n    if (m2m_wifi_default_connect(&wifi_credentials_callback) == false) {\n      debug_printError(ERROR_WIFI_CONNECT);\n      wifi_error_status = true;\n      return false;\n    }\n  }\n  return true;\n}", "CodeBleu_score": 41.11692805286648}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    if (passed_wifi_creds) {\n        if (!m2m_wifi_connect(wifi_ssid, strlen(wifi_ssid), wifi_auth, wifi_pass, strlen(wifi_pass))) {\n            debug_printError(\"Failed to connect to AP\");\n            update_networking_error_status();\n            return false;\n        }\n    } else {\n        if (!m2m_wifi_default_connect()) {\n            debug_printError(\"Failed to connect to AP\");\n            update_networking_error_status();\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 43.36165900492623}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t    const client = generateClient();\n    const response = await client.graphql(\n        `\n        query {\n            listSensors {\n                items {\n                    id\n                    name\n                    geo {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        }\n        `\n    );\n    if (response.data) {\n        console.log('Retrieved sensors');\n        response.data.listSensors.items.forEach((sensor) => {\n            const marker = CreateSensorMarker(sensor);\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 53.616592057345805}, {"code": "async function DisplaySensors(map){\n\t  // Generate a client\n  const client = generateClient();\n\n  // Send a GraphQL query to fetch sensor data\n  const response = await client.graphql(`\n    query {\n      listSensors {\n        items {\n          id\n          geo {\n            latitude\n            longitude\n          }\n        }\n      }\n    }\n  `);\n\n  // Log the API response\n  console.log(response);\n\n  // If the response contains data, log the retrieval of sensors and iterate through each sensor\n  if (response.data) {\n    console.log('Retrieved sensors');\n    response.data.listSensors.items.forEach((sensor) => {\n      // Create a marker for the sensor\n      const marker = CreateSensorMarker(sensor);\n\n      // Place the marker on the map at the sensor's geographical coordinates\n      new Marker({ element: marker })\n        .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n        .addTo(map);\n    });\n  }\n}", "CodeBleu_score": 59.581658667103966}, {"code": "async function DisplaySensors(map){\n\t    // Generate a client to interact with the API\n    const client = generateClient();\n\n    // Send a GraphQL query to fetch sensor data\n    const response = await client.graphql(`\n        query {\n            listSensors {\n                items {\n                    id\n                    geo {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        }\n    `);\n\n    // Log the response from the API\n    console.log(response);\n\n    // If the response contains data, log the retrieval of sensors\n    if (response.data) {\n        console.log(\"Retrieved sensors\");\n\n        // Iterate through each sensor and create a marker\n        response.data.listSensors.items.forEach((sensor) => {\n            // Create a marker element\n            const marker = document.createElement(\"div\");\n            marker.className = \"marker\";\n\n            // Create a new Marker object with the marker element\n            new Marker({ element: marker })\n                // Set the longitude and latitude of the marker to the sensor's coordinates\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                // Add the marker to the map\n                .addTo(map);\n        });\n    }\n}", "CodeBleu_score": 54.25547029753241}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t  let marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"marker\";\n  marker.style.backgroundColor = \"red\";\n  marker.style.border = \"1px solid black\";\n  return marker;\n}", "CodeBleu_score": 45.63826560054432}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.classList.add(\"marker\");\n    marker.style.backgroundColor = \"red\";\n    marker.style.border = \"2px solid black\";\n    return marker;\n}", "CodeBleu_score": 47.41332225754364}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div')\n    marker.id = sensor.id\n    marker.className = 'sensor-marker'\n    marker.style.backgroundColor = sensor.color\n    marker.style.border = `2px solid ${sensor.color}`\n    return marker\n}", "CodeBleu_score": 49.74091088275584}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{__package__}.mfa.{module_name}\"\n    try:\n        module = import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Unable to load MFA module %s: %s\", module_name, err)\n        raise HomeAssistantError(f\"Unable to load MFA module {module_name}: {err}\") from err\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        processed = hass.data.get(DATA_MFA_PROCESSED, set())\n        if module_path not in processed:\n            await async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n            processed.add(module_path)\n            hass.data[DATA_MFA_PROCESSED] = processed\n\n    return module\n\n", "CodeBleu_score": 54.43549822009981}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{__package__}.mfa.{module_name}\"\n    try:\n        module = await async_import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Error importing %s: %s\", module_name, err)\n        raise HomeAssistantError() from err\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        processed = hass.data.get(DATA_PIP_LOCK, set())\n        if module_path not in processed:\n            await requirements.async_process_requirements(\n                hass, module_name, module.REQUIREMENTS\n            )\n            processed.add(module_path)\n    return module\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 49.8221278824455}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{__package__}.{module_name}\"\n    _LOGGER.debug(\"Loading MFA module: %s\", module_path)\n    try:\n        module = await async_import_module(module_path)\n    except (ImportError, ValueError) as err:\n        _LOGGER.error(\"Error loading MFA module %s: %s\", module_path, err)\n        raise HomeAssistantError(\"Module not found\") from err\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        processed = hass.data.setdefault(DATA_PIP_LOCK, set())\n        if module_path not in processed:\n            await requirements.async_process_requirements(\n                hass, module_path, module.REQUIREMENTS\n            )\n            processed.add(module_path)\n\n    return module\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 52.24068653343765}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data.append({\"user_id\": user_id, \"pin\": pin})\n    return True\n", "CodeBleu_score": 42.69068525821667}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for index, entry in enumerate(self._data[\"users\"]):\n        if entry[\"user_id\"] == user_id:\n            self._data[\"users\"][index][\"pin\"] = pin\n            return\n    self._data[\"users\"].append({\"user_id\": user_id, \"pin\": pin})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 52.93797902862778}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for entry in self.data[\"users\"]:\n        if entry[\"user_id\"] == user_id:\n            entry[\"pin\"] = pin\n            return self.async_create_entry(title=\"\", data=self.data)\n    self.data[\"users\"].append({\"user_id\": user_id, \"pin\": pin})\n    return self.async_create_entry(title=\"\", data=self.data)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 52.135964927915715}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._data is not None:\n            return\n\n        data = await self._store.async_load()\n\n        if data is None:\n            data = {}\n\n        self._data = {\n            user_id: NotifySetting(\n                user_id=user_id,\n                **(\n                    {\n                        \"notify_level\": NotifyLevel.NOTIFY_LEVEL_DEFAULT,\n                        \"notify_service\": NotifyService.NOTIFY_SERVICE_DEFAULT,\n                    }\n                    if user_data is None\n                    else user_data\n                )\n            )\n            for user_id, user_data in data.items()\n        }\n\n", "CodeBleu_score": 40.13846245847824}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._lock:\n        if self._loaded:\n            return\n        self._loaded = True\n        data = await self._store.async_load()\n        if data is None:\n            data = {}\n        for user_id, user_data in data.items():\n            user_settings = {}\n            for item in user_data.get(\"items\", []):\n                user_settings[item[\"id\"]] = NotifySetting(\n                    item[\"id\"], item[\"name\"], item[\"enabled\"]\n                )\n            self.data[user_id] = user_settings\n\n", "CodeBleu_score": 36.46609582715439}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._lock:\n        if self._initialized:\n            return\n\n        data = await self._store.async_load()\n        if data is None:\n            data = {}\n\n        self._items = {\n            user_id: NotifySetting(user_id, data.get(user_id, {}))\n            for user_id in self._user_ids\n        }\n\n        self._initialized = True\n\n", "CodeBleu_score": 39.69691700059403}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load(user_id)\n    settings = self._user_settings.get(user_id)\n    if settings is None:\n        return False\n    otp = user_input.get(CONF_OTP)\n    if otp is None:\n        return False\n    result = await self._hass.async_add_executor_job(\n        self._verify_otp, otp, settings.secret\n    )\n    return result", "CodeBleu_score": 51.21616027491071}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load(user_id)\n    settings = self._user_settings.get(user_id)\n    if settings is None:\n        return False\n    otp = user_input.get(CONF_OTP)\n    if otp is None:\n        return False\n    return await self.hass.async_add_executor_job(\n        self._validate_otp, settings.secret, otp\n    )\n\n", "CodeBleu_score": 53.73510838644917}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load()\n    user_settings = self._user_settings.get(user_id)\n    if user_settings is None:\n        return False\n    notification_settings = user_settings.notification_settings\n    otp = user_input.get(\"otp\")\n    if otp is None:\n        return False\n    otp = str(otp)\n    if len(otp) != 6:\n        return False\n    if await self.hass.async_add_executor_job(self._validate_otp, otp, notification_settings):\n        return True\n    return False\n\n", "CodeBleu_score": 51.00019778703589}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_id = entity_entry.device_id\n    if device_id is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 67.62416786281416}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n\n    if entity_entry is None:\n        return None\n\n    device_entry = None\n\n    if entity_entry.device_id is not None:\n        device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n\n    if device_entry is None or device_entry.area_id is None:\n        return None\n\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 81.77781972303501}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n    device_id = entity_entry.device_id\n    if device_id is None:\n        return None\n    device_entry = perm_lookup.device_registry.async_get(device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 67.62416786281416}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen: set[CategoryType] = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen:\n                seen.add(category)\n                merged_policy[category] = [\n                    set(item) for item in zip(*[policy[category]] * len(policies))\n                ]\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 58.694250083397804}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for p in policies:\n        for category, value in p.items():\n            if category not in seen:\n                seen.add(category)\n                policy[category] = value\n            else:\n                policy[category] = cast(\n                    PolicyType,\n                    merge_categories(\n                        [\n                            policy[category],\n                            value,\n                        ],\n                    ),\n                )\n    return cast(PolicyType, policy)", "CodeBleu_score": 46.73610785252289}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    merged_policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy in policies:\n        for category, subcategories in policy.items():\n            if category not in seen:\n                seen.add(category)\n                merged_policy[category] = merge_categories(\n                    [\n                        subcategories,\n                        *[p[category] for p in policies if category in p],\n                    ]\n                )\n    return cast(PolicyType, merged_policy)\n", "CodeBleu_score": 53.27972644738948}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\"Error setting up auth provider %s: %s\", provider, err)\n        raise HomeAssistantError() from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not hasattr(module, \"async_get_auth_provider\"):\n        return module\n\n    processed = hass.data.get(DATA_PROVIDER_MODULE_LOADED)\n    if not processed:\n        processed = hass.data[DATA_PROVIDER_MODULE_LOADED] = set()\n\n    if module in processed:\n        return module\n\n    if not hasattr(module, \"async_setup\") and hasattr(module, \"async_setup_auth_provider\"):\n        module.async_setup = module.async_setup_auth_provider\n\n    if not hasattr(module, \"async_setup\") and hasattr(module, \"async_setup_legacy_auth_provider\"):\n        module.async_setup = module.async_setup_legacy_auth_provider\n\n    if not hasattr(module, \"async_setup\"):\n        return module\n\n    processed.add(module)\n    await requirements.async_process_requirements(\n        hass, module.DOMAIN, module.REQUIREMENTS\n    )\n\n    return module", "CodeBleu_score": 49.96176295187308}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\"Error loading auth provider %s: %s\", provider, err)\n        raise HomeAssistantError() from err\n\n    if not hasattr(module, \"async_get_auth_provider\"):\n        # Not a valid auth module\n        return None\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed = hass.data.get(DATA_PROVIDER_MODULE_PROCESSED)\n    if processed is None:\n        hass.data[DATA_PROVIDER_MODULE_PROCESSED] = processed = set()\n\n    if provider in processed:\n        return module\n\n    processed.add(provider)\n\n    await requirements.async_process_requirements(\n        hass, module.REQUIREMENTS, Action.LOAD\n    )\n\n    return module\n\n", "CodeBleu_score": 53.49402394264694}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    module_name = f\"{__package__}.auth_providers.{provider}\"\n    try:\n        module = await async_import_module(module_name)\n    except ImportError as err:\n        _LOGGER.error(\"Error loading auth provider %s: %s\", provider, err)\n        raise HomeAssistantError() from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if module.REQUIREMENTS and not hass.config.skip_pip:\n        processed.add(provider)\n        await requirements.async_process_requirements(\n            hass, module_name, module.REQUIREMENTS\n        )\n\n    return module\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 43.64053301380055}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    self._data = await self.store.async_load()\n    if self._data is None:\n        self._data = {\"users\": []}\n    self._async_check_for_not_normalized_usernames()\n    self._users = [User(**user_data) for user_data in self._data[\"users\"]]\n\n", "CodeBleu_score": 41.6430201892578}, {"code": "async def async_load(self) -> None\n\t\n    try:\n        data = await self._store.async_load()\n    except FileNotFoundError:\n        data = None\n\n    if data is None:\n        self.users = []\n    else:\n        self.users = list(data[\"users\"])\n\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 38.84798230714199}, {"code": "async def async_load(self) -> None\n\t\n    data = await self._store.async_load()\n    if data is None:\n        data = {\n            \"users\": []\n        }\n    self._users = data[\"users\"]\n    self._async_check_for_not_normalized_usernames()\n\n", "CodeBleu_score": 39.3872527186277}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\n    for user in self.users:\n        if username == user['username']:\n            stored_hash = base64.b64decode(user['password'].encode('utf-8'))\n            if not bcrypt.checkpw(password.encode('utf-8'), stored_hash):\n                raise InvalidAuth\n            return\n    bcrypt.checkpw(password.encode('utf-8'), dummy_hash.encode('utf-8'))\n    raise InvalidAuth", "CodeBleu_score": 42.83021838472128}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self._normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode()\n\n    for user in self.users:\n        if user.get('username') == username:\n            stored_hash = user.get('password')\n            is_correct_password = bcrypt.checkpw(\n                password.encode('utf-8'),\n                stored_hash.encode('utf-8'))\n            if not is_correct_password:\n                raise InvalidAuth\n            return\n\n    # To prevent timing attacks, do a dummy check even if user not found\n    bcrypt.checkpw(password.encode('utf-8'), dummy_hash.encode('utf-8'))\n    raise InvalidAuth\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 43.98699399891998}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self._normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(\"utf-8\"), bcrypt.gensalt()).decode()\n\n    for user in self.users:\n        if user.username == username:\n            stored_hash = base64.b64decode(user.password.encode())\n            if not bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                raise InvalidAuth(\"Invalid password\")\n            return\n\n    bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash.encode())\n    raise InvalidAuth(\"Invalid username\")\n\n", "CodeBleu_score": 40.53297003071741}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    found = None\n    for i, user in enumerate(self.users):\n        if user.username == username:\n            found = i\n            break\n    if found is None:\n        raise InvalidUser(\"user_not_found\")\n    self.users.pop(found)\n\n", "CodeBleu_score": 52.88277083764058}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    try:\n        self.users.pop(username)\n    except KeyError:\n        raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 23.783382756920226}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    try:\n        self.users.pop(self.users.index(username))\n    except ValueError:\n        raise InvalidUser(\"user_not_found\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 25.807271448837092}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.initialized:\n        await self.async_initialize()\n    try:\n        self.auth_manager.remove_auth(credentials.data[\"username\"])\n        await self.async_save()\n    except InvalidUserError:\n        pass\n\n", "CodeBleu_score": 52.44368120741555}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.data:\n        await self.async_initialize()\n    try:\n        self.data.pop(credentials.data[\"username\"])\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 50.24816753072658}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        await self.async_initialize()\n    try:\n        del self._data[credentials.data[\"username\"]]\n    except KeyError:\n        pass\n    else:\n        await self.async_save()\n\n", "CodeBleu_score": 47.018915763391625}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        remaining = timeout - (time.monotonic() - thread._log_thread_running_at_shutdown)\n        if remaining <= 0:\n            joined.add(thread)\n            continue\n        thread.join(timeout=remaining)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log.warning(\n                \"Thread %s did not stop after %.3fs\", thread.name, timeout\n            )\n        with contextlib.suppress(SystemExit):\n            async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 54.47078402844999}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    for thread in threads:\n        timeout_for_this_thread = timeout - (time.time() - thread.start_time)\n        thread.join(timeout=timeout_for_this_thread)\n        if not thread.is_alive() or thread.ident is None:\n            joined.add(thread)\n    if log:\n        _log_thread_running_at_shutdown(threads - joined)\n    for thread in threads - joined:\n        async_raise(thread.ident, SystemExit)\n    return joined\n\n", "CodeBleu_score": 59.88418265130582}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    timeout_per_thread = timeout / len(threads)\n    for thread in threads:\n        thread.join(timeout=timeout_per_thread)\n        if not thread.is_alive() or thread.ident is None:\n            joined.add(thread)\n        if log:\n            if thread.is_alive():\n                _log_thread_running_at_shutdown(thread)\n            async_raise(thread.ident, SystemExit)\n    return joined", "CodeBleu_score": 66.42162689845634}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n\n", "CodeBleu_score": 0.5}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n\n", "CodeBleu_score": 0.5}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n\n", "CodeBleu_score": 0.5}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_state:\n        async_dispatcher_send_internal(\n            self._hass, self._signal, remaining_with_setup_started\n        )\n    self._previous_state = remaining_with_setup_started\n\n", "CodeBleu_score": 54.250794204650255}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_state:\n        async_dispatcher_send_internal(self._hass, self._signal, remaining_with_setup_started)\n    self._previous_state = remaining_with_setup_started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 55.0913630909172}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_remaining:\n        async_dispatcher_send_internal(self._hass, self._signal_remaining, remaining_with_setup_started)\n    self._previous_remaining = remaining_with_setup_started\n\n", "CodeBleu_score": 53.8253242616419}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config_cache = config.cache_path / \"bluetooth.json\"\n\n    if not config.specific_integrations:\n        current = fp.read(bluetooth_path)\n        new = generate_and_validate(integrations, config)\n        if current != new:\n            config.add_error(\n                \"bluetooth\",\n                \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n                fixable=True,\n            )\n        return\n\n    new = generate_and_validate(integrations, config)\n\n    if config_cache.is_file():\n        cache = json.loads(config_cache.read_text())\n        if cache.get(str(config.specific_integrations)) == new:\n            return\n\n    with open(str(config_cache), \"w\") as outp:\n        outp.write(json.dumps(cache))\n\n", "CodeBleu_score": 63.40788464768764}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate(integrations, config)\n\n    if not config.specific_integrations:\n        return\n\n    with open(str(bluetooth_path)) as fp:\n        current = fp.read().strip()\n\n    if current != content:\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n\n    with open(str(bluetooth_path), \"w\") as fp:\n        fp.write(content)\n", "CodeBleu_score": 77.70924066405213}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate(integrations, config)\n\n    if not bluetooth_path.is_file():\n        return\n\n    current = bluetooth_path.read_text()\n\n    if current != content:\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n\n    with open(str(bluetooth_path)) as fp:\n        config.cache[\"bluetooth\"] = fp.read()\n\n    if not config.specific_integrations:\n        return\n\n    for domain in config.specific_integrations:\n        if domain in integrations:\n            validate_integration(config, domain)\n\n", "CodeBleu_score": 76.12604975822296}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken  string `json:\"access_token\"`\n\t\tTokenType    string `json:\"token_type\"`\n\t\tExpiresIn    int    `json:\"expires_in\"`\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t\tScope        string `json:\"scope\"`\n\t\tUID          string `json:\"uid\"`\n\t\tAccountID    string `json:\"account_id\"`\n\t}\n\tvar e struct {\n\t\tError            string `json:\"error\"`\n\t\tErrorDescription string `json:\"error_description\"`\n\t}\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(\"https://api.dropboxapi.com/oauth2/token\")\n\tif err != nil {\n\t\tlogger.Error(\"Request Error:\", err)\n\t\treturn err\n\t}\n\tif res.StatusCode() != 200 {\n\t\tlogger.Error(\"Request Status:\", res.Status())\n\t\treturn fmt.Errorf(res.String())\n\t}\n\tif e.Error != \"\" {\n\t\tlogger.Error(\"Request Error:\", e.Error)\n\t\treturn fmt.Errorf(e.Error)\n\t}\n\td.AccessToken = resp.AccessToken\n\treturn nil\n}", "CodeBleu_score": 65.01206935710022}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tScope       string `json:\"scope\"`\n\t\tUid         string `json:\"uid\"`\n\t}\n\tvar e struct {\n\t\tError            string `json:\"error\"`\n\t\tErrorDescription string `json:\"error_description\"`\n\t}\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(\"https://api.dropboxapi.com/oauth2/token\")\n\tif err != nil {\n\t\tlogger.Error(\"Failed to refresh token for dropbox:\", err)\n\t\treturn err\n\t}\n\tif res.StatusCode() != 200 {\n\t\tlogger.Error(\"Failed to refresh token for dropbox:\", res.String())\n\t\treturn fmt.Errorf(\"failed to refresh token for dropbox: %s\", res.String())\n\t}\n\tif e.Error != \"\" {\n\t\tlogger.Error(\"Failed to refresh token for dropbox:\", e.Error, e.ErrorDescription)\n\t\treturn fmt.Errorf(\"failed to refresh token for dropbox: %s %s\", e.Error, e.ErrorDescription)\n\t}\n\td.AccessToken = resp.AccessToken\n\tlogger.Info(\"Dropbox token refreshed\")\n\treturn nil\n}", "CodeBleu_score": 60.770954883412564}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tvar resp struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}\n\tvar e struct {\n\t\tError            string `json:\"error\"`\n\t\tErrorDescription string `json:\"error_description\"`\n\t}\n\tres, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(d.Endpoint.TokenURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif e.Error != \"\" {\n\t\tlogger.Error(\"Failed to refresh token, %s\", res.String())\n\t\treturn fmt.Errorf(e.ErrorDescription)\n\t}\n\td.AccessToken = resp.AccessToken\n\td.ExpiresAt = time.Now().Add(time.Duration(resp.ExpiresIn) * time.Second)\n\treturn nil\n}", "CodeBleu_score": 67.68861534426901}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.StatusCode() == 401 {\n\t\td.refreshToken()\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\tif res.StatusCode() >= 400 {\n\t\treturn nil, fmt.Errorf(\"request error: %s\", res.String())\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 67.37825927719166}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}(res.Body)\n\tif res.StatusCode == 401 {\n\t\td.refreshToken()\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"request failed, status code: %d, body: %s\", res.StatusCode, string(body))\n\t}\n\treturn body, nil\n}", "CodeBleu_score": 73.2119065156303}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq := base.RestyClient.R()\n\treq.SetHeader(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.SetQueryParam(\"supportsAllDrives\", \"true\")\n\treq.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.SetResult(resp)\n\t}\n\tvar e Error\n\treq.SetError(&e)\n\tres, err := req.Execute(method, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif e.Error.Status != \"\" {\n\t\tif e.Error.Status == \"401\" {\n\t\t\tif err := d.refreshToken(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"%s: %s\", e.Error.Status, e.Error.Message)\n\t}\n\treturn res.Body(), nil\n}", "CodeBleu_score": 80.83284053923205}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size based on the file size\n\tchunkSize := int64(200 * 1024 * 1024)\n\tif stream.GetSize() < 200*1024*1024 {\n\t\tchunkSize = stream.GetSize()\n\t}\n\n\t// Create a new HTTP request with the specified URL\n\treq := d.request(url, \"PUT\")\n\n\t// Initialize the finish variable to keep track of the number of bytes uploaded\n\tfinish := int64(0)\n\n\t// Loop until the entire file is uploaded\n\tfor {\n\t\t// Check if the context has been canceled\n\t\tif utils.IsCanceled(ctx) {\n\t\t\t// Return an error if the context has been canceled\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Calculate the start and end indices of the current chunk\n\t\tstart := finish\n\t\tend := start + chunkSize\n\t\tif end > stream.GetSize() {\n\t\t\tend = stream.GetSize()\n\t\t}\n\n\t\t// Set the headers for the current chunk\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\n\t\t// Execute the HTTP request\n\t\tif err := req.Do(); err != nil {\n\t\t\t// Return the error if the request fails\n\t\t\treturn err\n\t\t}\n\n\t\t// Check if the entire file has been uploaded\n\t\tif end == stream.GetSize() {\n\t\t\t// Complete the upload and return nil if the entire file has been uploaded\n\t\t\treturn d.completeUpload(ctx, stream.GetName(), req.Response.Header.Get(\"Location\"))\n\t\t}\n\n\t\t// Update the finish variable for the next chunk\n\t\tfinish = end\n\t}\n}", "CodeBleu_score": 61.94135731286138}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := d.getChunkSize(stream.GetSize())\n\tfinish := 0\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\treq := d.request(\"PUT\", url, stream.GetName(), stream.GetMimeType(), stream.GetSize())\n\t\t\treq.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\t\tres, err := req.Send()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfinish += chunkSize\n\t\t\tif finish >= int(stream.GetSize()) {\n\t\t\t\tif res.StatusCode != 200 {\n\t\t\t\t\treturn fmt.Errorf(\"upload failed\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 54.13563011874345}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := d.config.ChunkSize\n\tif chunkSize == 0 {\n\t\tchunkSize = defaultChunkSize\n\t}\n\tfinish := int64(0)\n\tfor {\n\t\treq := d.request(url, \"PUT\", nil)\n\t\treq.SetHeaders(map[string]string{\n\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n\t\tres, err := req.Do()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tif res.StatusCode != 200 && res.StatusCode != 201 {\n\t\t\treturn fmt.Errorf(\"upload failed with code %d\", res.StatusCode)\n\t\t}\n\t\tfinish += chunkSize\n\t\tif finish >= stream.GetSize() {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 59.546935471892795}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ClientError(err))\n\t}\n\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.ClientError(errors.New(\"mount_point is required\")))\n\t}\n\n\tmountPoint := strings.ReplaceAll(req.MountPoint, \"\\\\\", \"/\")\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ServerError(err))\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.ServerError(err))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.Success(\"unmount success\"))\n}", "CodeBleu_score": 41.73733304731613}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tdata := new(struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t})\n\n\tif err := ctx.Bind(data); err != nil {\n\t\treturn common_err.GetMsg(common_err.BindJsonFail, err)\n\t}\n\n\tif data.MountPoint == \"\" {\n\t\treturn common_err.GetMsg(common_err.ErrParam, \"mount_point is empty\")\n\t}\n\n\tif err := service.MyService.Storage().UnmountStorage(data.MountPoint); err != nil {\n\t\treturn common_err.GetMsg(common_err.ErrStorage, err.Error())\n\t}\n\n\tif err := service.MyService.Storage().DeleteConfigByName(data.MountPoint); err != nil {\n\t\treturn common_err.GetMsg(common_err.ErrDatabase, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, &Response{\n\t\tMessage: \"success\",\n\t})\n}", "CodeBleu_score": 43.91252814287826}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from request context\n\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\n\t// Check if mount point is empty\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(errors.New(\"mount_point is empty\")))\n\t}\n\n\t// Replace any occurrences of \"../\" in the mount point with an empty string\n\tmountPoint := strings.ReplaceAll(req.MountPoint, \"../\", \"\")\n\n\t// Attempt to unmount the storage at the specified mount point\n\tif err := service.MyService.Storage().UnmountStorage(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := service.MyService.Storage().DeleteConfigByName(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, make(map[string]interface{}))\n}", "CodeBleu_score": 42.06853098084453}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(\"File path is required\"))\n\t}\n\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg(\"File not found\"))\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 34.803234905991886}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg{\n\t\t\tMessage: \"path is missing\",\n\t\t})\n\t}\n\n\tif !file.Exists(filePath) {\n\t\treturn ctx.JSON(http.StatusNotFound, common_err.GetMsg{\n\t\t\tMessage: \"file not found\",\n\t\t})\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 40.29137133654861}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.FILE_PATH_MISSING))\n\t}\n\n\tif !file.Exists(path) {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(common_err.FILE_NOT_EXISTS))\n\t}\n\n\treturn ctx.File(path)\n}", "CodeBleu_score": 47.50712179197512}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, common_err.GetMsg(err))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.SUCCESS)\n}", "CodeBleu_score": 64.46752015879056}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err))\n\t}\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn err\n\t}\n\treturn ctx.JSON(http.StatusOK, common_err.SUCCESS)\n}", "CodeBleu_score": 61.53104112149003}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err.Error()))\n\t}\n\n\tif err := service.MyService.Notify().SendNotify(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, common_err.GetMsg(err.Error()))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.SUCCESS)\n}", "CodeBleu_score": 65.17855750063536}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP GET request to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections\n\twsConn = append(wsConn, ws)\n\t// Ensure that the message sending service is running\n\tgo SendMeg()\n\t// Continuously read messages from the WebSocket connection\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(string(message))\n\t}\n\treturn nil\n}", "CodeBleu_score": 45.5694000014357}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections\n\twsConnections = append(wsConnections, ws)\n\t// Ensure that the message sending service is running\n\tif !service.SendMeg {\n\t\tgo service.SendMessage()\n\t}\n\t// Continuously read messages from the WebSocket connection\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.55895656790691}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upGrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer ws.Close()\n\n\tconnections = append(connections, ws)\n\n\tif !isSending {\n\t\tisSending = true\n\t\tgo SendMeg()\n\t}\n\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.168315512294356}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveModel, driveArchitecture := GetDriveInfo()\n\tcpuInfo, err := GetCpuInfo()\n\tif err != nil {\n\t\tcpuInfo = \"nil\"\n\t}\n\n\tdata := map[string]interface{}{\n\t\t\"drive_model\":        driveModel,\n\t\t\"drive_architecture\": driveArchitecture,\n\t\t\"cpu_info\":           cpuInfo,\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS, data))\n}", "CodeBleu_score": 22.619677700188433}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveModel, driveArchitecture := GetDriveInfo()\n\tcpuInfo, err := GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SYSTEM_HARDWARE_INFO_ERROR))\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS).AddData(\"drive_model\", driveModel).AddData(\"drive_architecture\", driveArchitecture).AddData(\"cpu_info\", cpuInfo))\n}", "CodeBleu_score": 22.519885417247387}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveModel, driveArchitecture, err := service.MyService.System().GetDriveInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SystemErr))\n\t}\n\tcpuInfo, err := service.MyService.System().GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SystemErr))\n\t}\n\n\tdata := make(map[string]interface{}, 2)\n\tdata[\"driveModel\"] = driveModel\n\tdata[\"driveArchitecture\"] = driveArchitecture\n\tif cpuInfo != nil {\n\t\tdata[\"cpuInfo\"] = cpuInfo\n\t}\n\n\treturn ctx.JSON(http.StatusOK, common_err.GetMsg(common_err.SUCCESS).AddData(data))\n}", "CodeBleu_score": 32.401778359681096}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 76.90254304404401}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 75.81318203044482}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 75.85713975490513}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tevent := &messagebus.Event{\n\t\tName:    name,\n\t\tPayload: message,\n\t}\n\tjsonStrings := make(map[string]string)\n\tfor key, value := range message {\n\t\tjsonString, err := json.Marshal(value)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to marshal message value\", zap.String(\"key\", key), zap.Any(\"value\", value), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tjsonStrings[key] = string(jsonString)\n\t}\n\tresponse, err := i.MyService.MessageBus().PublishEventWithResponse(context.Background(), event)\n\tif err != nil {\n\t\tlogger.Error(\"failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"failed to send notification\", zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 53.51054657266665}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageString := make(map[string]string)\n\tfor key, value := range message {\n\t\tvalueJson, err := json.Marshal(value)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"failed to marshal message value\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tmessageString[key] = string(valueJson)\n\t}\n\n\tresponse, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), name, messageString)\n\tif err != nil {\n\t\tlogger.Error(\"failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"failed to send notification\", zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 55.90145683517201}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageStr := make(map[string]string)\n\tfor k, v := range message {\n\t\tmessageStr[k] = v.(string)\n\t}\n\tresponse, err := i.MessageBus().PublishEventWithResponse(context.Background(), name, messageStr)\n\tif err != nil {\n\t\tlogger.Error(\"failed to publish event\", zap.Error(err))\n\t\treturn\n\t}\n\tif response.StatusCode != http.StatusOK {\n\t\tlogger.Error(\"failed to publish event\", zap.Any(\"response\", response))\n\t}\n}", "CodeBleu_score": 59.128126894757706}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\taddress, err := external.GetMessageBusAddress(c.RuntimePath)\n\tif err != nil {\n\t\taddress = \"error: unable to get message bus address\"\n\t}\n\tclient := message_bus.NewClientWithResponses(address)\n\treturn client\n}", "CodeBleu_score": 33.968947468267615}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\truntimePath := \"/message-bus/api/v1/address\"\n\tmessageBusAddress, err := c.getAddress(runtimePath)\n\tif err != nil {\n\t\tmessageBusAddress = \"error\"\n\t}\n\n\tclient := message_bus.NewClientWithResponses(c.runtime.GetConfig().Host, message_bus.WithRequestEditorFn(c.setHeaders))\n\tclient.Server = messageBusAddress\n\treturn client\n}", "CodeBleu_score": 41.110345372998374}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient, err := message_bus.NewClientWithResponses(c.runtimePath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\taddress, err := external.GetMessageBusAddress(c.runtimePath)\n\tif err != nil {\n\t\tclient.Server = \"error getting message bus address\"\n\t\treturn client\n\t}\n\n\tclient.Server = address\n\treturn client\n}", "CodeBleu_score": 53.658536035615015}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif len(ip) == 0 {\n\t\tip = request.RemoteAddr\n\t}\n\n\tip = strings.Split(ip, \":\")[0]\n\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = strings.TrimPrefix(ip, \"::ffff:\")\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 59.7423406473283}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \"::1\") || strings.Contains(ip, \"::ffff:127.0.0.1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 48.58413728897624}, {"code": "func GetIP(request *http.Request) string{\n\t\tforwarded := request.Header.Get(\"x-forwarded-for\")\n\tif forwarded != \"\" {\n\t\tip := strings.Split(forwarded, \",\")[0]\n\t\treturn ip\n\t}\n\tip := strings.Split(request.RemoteAddr, \":\")[0]\n\tif ip == \"[\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 43.369589882734225}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesPath := filepath.Join(c.config.ModulesPath)\n\tentryFilePath := filepath.Join(c.config.ModulesPath, \"entry.json\")\n\n\tif file.IsNotExistCreateFile(entryFilePath) {\n\t\tlogger.Error(\"create entry file error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tfiles, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(\"read dir error\", zap.Error(err))\n\t\treturn\n\t}\n\n\tvar entry []byte\n\tfor _, v := range files {\n\t\tif v.IsDir() {\n\t\t\tentryFilePath := filepath.Join(modulesPath, v.Name(), \"entry.json\")\n\t\t\tentryBytes, err := os.ReadFile(entryFilePath)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"read file error\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tentry = append(entry, entryBytes...)\n\t\t}\n\t}\n\n\terr = os.WriteFile(entryFilePath, entry, 0644)\n\tif err != nil {\n\t\tlogger.Error(\"write file error\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 59.13748107975208}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesPath := filepath.Join(c.config.BasePath, \"modules\")\n\tentryFilePath := filepath.Join(c.config.BasePath, \"entry.json\")\n\n\tfile.IsNotExistCreateFile(entryFilePath)\n\n\tmodulesDir, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(\"Error reading modules directory:\", zap.Error(err))\n\t\treturn\n\t}\n\n\tvar jsonData []byte\n\tfor _, moduleDir := range modulesDir {\n\t\tif moduleDir.IsDir() {\n\t\t\tentryFilePath := filepath.Join(modulesPath, moduleDir.Name(), \"entry.json\")\n\t\t\tentryFileData, err := os.ReadFile(entryFilePath)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"Error reading entry file:\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tjsonData = append(jsonData, entryFileData...)\n\t\t}\n\t}\n\n\terr = os.WriteFile(entryFilePath, jsonData, 0644)\n\tif err != nil {\n\t\tlogger.Error(\"Error writing entry file:\", zap.Error(err))\n\t\treturn\n\t}\n\n\tlogger.Info(\"System entry file generated successfully\")\n}", "CodeBleu_score": 52.682833132057205}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesPath := \"./modules\"\n\tentryFilePath := \"./entry.json\"\n\n\t_, err := os.Stat(entryFilePath)\n\tif os.IsNotExist(err) {\n\t\t_, err := os.Create(entryFilePath)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to create entry file\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}\n\n\tdirs, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to read modules directory\", zap.Error(err))\n\t\treturn\n\t}\n\n\tvar entries []string\n\tfor _, dir := range dirs {\n\t\tif dir.IsDir() {\n\t\t\tentryFile := filepath.Join(modulesPath, dir.Name(), \"entry.json\")\n\t\t\tcontent, err := os.ReadFile(entryFile)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"Failed to read entry file\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tentries = append(entries, string(content))\n\t\t}\n\t}\n\n\tjsonArray := \"[\" + strings.Join(entries, \",\") + \"]\"\n\terr = os.WriteFile(entryFilePath, []byte(jsonArray), 0644)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to write to entry file\", zap.Error(err))\n\t\treturn\n\t}\n}", "CodeBleu_score": 59.987943472926794}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := MyService.System().GetNet()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 64.25488972299573}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t    interfaces, err := net.Interfaces()\n    if err != nil {\n        return \"\", err\n    }\n    netNames, err := MyService.System().GetNet()\n    if err != nil {\n        return \"\", err\n    }\n    for _, i := range interfaces {\n        for _, n := range netNames {\n            if i.Name == n {\n                return i.HardwareAddr.String(), nil\n            }\n        }\n    }\n    return \"\", errors.New(\"No matching interface found\")\n}", "CodeBleu_score": 70.0847518971799}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t    ifaces, err := net.Interfaces()\n    if err != nil {\n        return \"\", err\n    }\n    nets, err := MyService.System().GetNet()\n    if err != nil {\n        return \"\", err\n    }\n    for _, iface := range ifaces {\n        for _, net := range nets {\n            if iface.Name == net.Name {\n                return iface.HardwareAddr.String(), nil\n            }\n        }\n    }\n    return \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 62.08467640303046}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  if (pRequest == NULL || pTscObj == NULL) {\n    return TSDB_CODE_TSC_INVALID_ARGUMENT;\n  }\n\n  atomic_add_fetch_64(&pRequest->ref, 1);\n  atomic_add_fetch_64(&pTscObj->requests, 1);\n\n  if (pTscObj->pAppInfo != NULL) {\n    pTscObj->pAppInfo->totalRequests++;\n    pTscObj->pAppInfo->currentRequests++;\n  }\n\n  tscDebug(\"tsc:%p, app:%p, add request:%p, total requests:%lld, current requests:%lld\", pTscObj, pTscObj->pAppInfo, pRequest,\n           pTscObj->requests, pTscObj->pAppInfo->currentRequests);\n\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 43.15583334379545}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    pRequest->ref = 1;\n    atomic_add_fetch_64(&pTscObj->requestCount, 1);\n\n    if (pTscObj->pAppInfo) {\n        pTscObj->pAppInfo->requestSummary.totalRequests++;\n        pTscObj->pAppInfo->requestSummary.currentRequests++;\n    }\n\n    tscDebug(\"tsc:%s, app:%s, register request:%p, total requests:%d, current requests:%d\",\n             pTscObj->label, pTscObj->pAppInfo ? pTscObj->pAppInfo->label : \"null\", pRequest,\n             pTscObj->requestCount, pTscObj->pAppInfo ? pTscObj->pAppInfo->requestSummary.currentRequests : 0);\n\n    return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 39.10150680046925}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t  if (pRequest == NULL || pTscObj == NULL) {\n    return TSDB_CODE_CLI_OUT_OF_MEMORY;\n  }\n\n  atomic_add_fetch_64(&pRequest->ref, 1);\n  atomic_add_fetch_64(&pTscObj->requestCount, 1);\n\n  if (pTscObj->pAppInfo != NULL) {\n    pTscObj->pAppInfo->totalReq++;\n    pTscObj->pAppInfo->currentReq++;\n  }\n\n  tscDebug(\"tsc:%p, app:%p, register request:%p\", pTscObj, pTscObj->pAppInfo, pRequest);\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 36.82119012562564}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (pRequest->pDb != NULL && strcmp(pRequest->pDb, exceptDb) != 0) {\n    return true;\n  }\n  if (pRequest->dbList != NULL) {\n    int32_t numDb = taosArrayGetSize(pRequest->dbList);\n    for (int32_t i = 0; i < numDb; ++i) {\n      char *db = taosArrayGet(pRequest->dbList, i);\n      char *p = strchr(db, '.');\n      if (p != NULL) {\n        *p = '\\0';\n      }\n      if (strcmp(db, exceptDb) != 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "CodeBleu_score": 68.68288845126833}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t  if (strcmp(pRequest->pDb, exceptDb) != 0) {\n    for (int32_t i = 0; i < pRequest->numOfDb; ++i) {\n      char *db = pRequest->dbList[i];\n      char *p = strchr(db, '.');\n      if (p != NULL) {\n        *p = '\\0';\n      }\n      if (strcmp(db, exceptDb) == 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}", "CodeBleu_score": 61.32214110857348}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    char *dbName = pRequest->pDb;\n    if (dbName == NULL) {\n        return true;\n    }\n\n    if (strcmp(dbName, exceptDb) == 0) {\n        return false;\n    }\n\n    int32_t numOfDb = taosArrayGetSize(pRequest->pDbList);\n    for (int32_t i = 0; i < numOfDb; ++i) {\n        char *db = taosArrayGet(pRequest->pDbList, i);\n        if (db == NULL) {\n            continue;\n        }\n\n        char *dbName = strchr(db, '.');\n        if (dbName == NULL) {\n            if (strcmp(db, exceptDb) == 0) {\n                return false;\n            }\n        } else {\n            if (strcmp(dbName + 1, exceptDb) == 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 58.621863834897866}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == NEED_REDIRECT_ERROR) {\n        switch (msgType) {\n            case TMSG_BCAST:\n            case TMSG_RESPONSE:\n            case TMSG_RESPONSE_NACK:\n            case TMSG_RESPONSE_ACK:\n                return false;\n            default:\n                return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 38.76482737073401}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code != NEED_REDIRECT_ERROR) {\n        return false;\n    }\n    return (msgType != TMSG_REDIRECT_REQ) && (msgType != TMSG_REDIRECT_RESP) && (msgType != TMSG_REDIRECT_REQ_ACK);\n}", "CodeBleu_score": 42.60610504904923}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == NEED_REDIRECT_ERROR) {\n        switch (msgType) {\n            case MSG_TYPE_REDIRECT:\n            case MSG_TYPE_REDIRECT_REPLY:\n            case MSG_TYPE_REDIRECT_REPLY_REPLY:\n            case MSG_TYPE_REDIRECT_REPLY_REPLY_REPLY:\n            case MSG_TYPE_REDIRECT_REPLY_REPLY_REPLY_REPLY:\n                return false;\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 41.296370211038955}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t    SHashIter iter;\n    SRequest *pRequest;\n    taosHashIterInit(&iter, pRequests);\n    while ((pRequest = (SRequest *)taosHashIterNext(&iter)) != NULL) {\n        acquireRequest(pRequest);\n        if (pRequest->pQuery != NULL) {\n            taos_stop_query(pRequest->pQuery);\n        }\n        releaseRequest(pRequest);\n    }\n}", "CodeBleu_score": 49.31881340530801}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SHashIter *pIter = taosHashIterate(pRequests);\n  while (taosHashIterHasNext(pIter)) {\n    SRequest *pRequest = (SRequest *)taosHashIterNext(pIter);\n    if (pRequest->pQuery != NULL) {\n      taos_stop_query(pRequest->pQuery);\n    }\n    taosHashIterRelease(pIter);\n  }\n  taosHashReleaseIterator(pIter);\n}", "CodeBleu_score": 38.565253480010036}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SHashIter iter;\n  SRequest *pRequest;\n\n  pRequests = taosHashIterate(pRequests, &iter);\n  while (pRequests) {\n    pRequest = (SRequest *)pRequests;\n    if (pRequest->pQuery) {\n      taos_stop_query(pRequest->pQuery);\n    }\n    releaseRequest(pRequest);\n    pRequests = taosHashIterate(pRequests, &iter);\n  }\n}", "CodeBleu_score": 46.05840394161406}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t  if (!gReportCrashes) {\n    return;\n  }\n  int32_t old = 1;\n  if (!atomic_val_compare_exchange_32(&gClientStop, &old, 0)) {\n    taosLog(\"Crash report thread already stopped\");\n    return;\n  }\n  while (gClientStop) {\n    taosMsleep(100);\n  }\n}", "CodeBleu_score": 61.865385762278436}, {"code": "void tscStopCrashReport(){\n\t    if (!gReportCrash) return;\n    if (atomic_val_compare_exchange_32(&gClientStop, 0, 1) == 0) {\n        taosLog(\"Crash report thread is already stopped\");\n        return;\n    }\n\n    while (gClientStop) {\n        taosMsleep(10);\n    }\n}", "CodeBleu_score": 56.680248909714514}, {"code": "void tscStopCrashReport(){\n\t  if (!gEnableCrashReport) {\n    taosLog(\"Crash reporting is not enabled.\");\n    return;\n  }\n\n  if (!atomic_val_compare_exchange_32(&gClientStop, 0, 1)) {\n    taosLog(\"Crash report thread is already stopped.\");\n    return;\n  }\n\n  while (gClientStop != 0) {\n    taosMsleep(10);\n  }\n}", "CodeBleu_score": 61.33627720156669}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  SHeartbeatRsp *pRsp = (SHeartbeatRsp *)value;\n  int32_t        code = 0;\n\n  if (pRsp->numOfViews == 0) {\n    return 0;\n  }\n\n  tVariant *pArray = taosDeserializeSViewHbRsp(pRsp, &code);\n  if (code != 0) {\n    taosMemoryFreeClear(pArray, pRsp->numOfViews * sizeof(tVariant));\n    return code;\n  }\n\n  int32_t numOfViews = taosArrayGetSize(pArray);\n  for (int32_t i = 0; i < numOfViews; ++i) {\n    tVariant *pView = taosArrayGetP(pArray, i);\n    int32_t   numCols = taosArrayGetSize(pView);\n    if (numCols == 0) {\n      catalogRemoveViewMeta(pCatalog, pView);\n    } else {\n      catalogUpdateViewMeta(pCatalog, pView);\n    }\n  }\n\n  taosArrayDestroyEx(pArray, pRsp->numOfViews);\n  return 0;\n}", "CodeBleu_score": 42.23549077796279}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  int32_t code = 0;\n  SArray *pArray = NULL;\n  SViewMeta *pViewMeta = NULL;\n  int32_t numOfViews = 0;\n  int32_t i = 0;\n\n  pArray = taosDeserializeSViewHbRsp(value, valueLen, &code);\n  if (pArray == NULL) {\n    taosMemoryFreeClear(value, valueLen);\n    return code;\n  }\n\n  numOfViews = taosArrayGetSize(pArray);\n  for (i = 0; i < numOfViews; ++i) {\n    pViewMeta = (SViewMeta *)taosArrayGetP(pArray, i);\n    if (pViewMeta->numOfColumns == 0) {\n      catalogRemoveViewMeta(pCatalog, pViewMeta->vgId, pViewMeta->dbId, pViewMeta->id);\n    } else {\n      catalogUpdateViewMeta(pCatalog, pViewMeta);\n    }\n  }\n\n  taosArrayDestroyEx(pArray, (void (*)(void *))tFreeSViewMetaRsp);\n  taosMemoryFreeClear(value, valueLen);\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 46.990549464634945}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t  SViewMetaRsp *pRsp = (SViewMetaRsp *)value;\n  int32_t        code;\n\n  if (pRsp == NULL) {\n    return TSDB_CODE_SUCCESS;\n  }\n\n  code = taosDeserializeSViewHbRsp(pRsp, value, valueLen);\n  if (code != TSDB_CODE_SUCCESS) {\n    hbCleanUp(pRsp);\n    return code;\n  }\n\n  for (int32_t i = 0; i < pRsp->numOfViews; ++i) {\n    SViewMeta *pView = &pRsp->views[i];\n\n    if (pView->numOfColumns == 0) {\n      catalogRemoveViewMeta(pCatalog, pView->db, pView->view);\n    } else {\n      catalogUpdateViewMeta(pCatalog, pView);\n    }\n  }\n\n  hbCleanUp(pRsp);\n\n  return TSDB_CODE_SUCCESS;\n}", "CodeBleu_score": 41.738496212338816}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    S3ListBucketContent *content = (S3ListBucketContent *)callbackData;\n    if (properties->getContentLength() > 0) {\n        content->contentLength = properties->getContentLength();\n    } else {\n        content->contentLength = 0;\n    }\n    return status;\n}", "CodeBleu_score": 59.38398537311844}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    S3_GET_RESPONSE_PROPERTIES(properties);\n    if (properties->contentLength > 0) {\n        S3_FREE_MEM(properties->contentLanguage);\n        S3_FREE_MEM(properties->contentType);\n        S3_FREE_MEM(properties->serverSideEncryption);\n        S3_FREE_MEM(properties->versionId);\n        S3_FREE_MEM(properties->expirationTime);\n        S3_FREE_MEM(properties->expirationTimeRuleId);\n        S3_FREE_MEM(properties->replicationStatus);\n        S3_FREE_MEM(properties->requestCharged);\n        S3_FREE_MEM(properties->restore);\n        S3_FREE_MEM(properties->deleteMarker);\n        S3_FREE_MEM(properties->tagCount);\n        S3_FREE_MEM(properties->objectLockMode);\n        S3_FREE_MEM(properties->objectLockLegalHoldStatus);\n        S3_FREE_MEM(properties->objectLockRetainUntilDate);\n        S3_FREE_MEM(properties->storageClass);\n        S3_FREE_MEM(properties->websiteRedirectLocation);\n        S3_FREE_MEM(properties->crc32C);\n        S3_FREE_MEM(properties->missingMeta);\n        S3_FREE_MEM(properties->sseKMSKeyId);\n        S3_FREE_MEM(properties->sseKMSEncryptionContext);\n        S3_FREE_MEM(properties->sseCAlgorithm);\n        S3_FREE_MEM(properties->sseCKeyMD5);\n        S3_FREE_MEM(properties->sseCKey);\n        S3_FREE_MEM(properties->sseCKeySHA256);\n        S3_FREE_MEM(properties->sseCOAlgorithm);\n        S3_FREE_MEM(properties->sse", "CodeBleu_score": 44.34807727390164}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    struct S3CallbackData *data = (struct S3CallbackData *) callbackData;\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 76.655123907215}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t  if (system(uError(\"mkdir -p %s\", checkpointBackupDir)) != 0) {\n    taosLog(\"ERROR: failed to create checkpoint backup directory: %s\", checkpointBackupDir);\n    return;\n  }\n\n  removeEmptyDir(checkpointBackupDir);\n\n  if (generateConfigFile(rsyncConfigFile) != 0) {\n    taosLog(\"ERROR: failed to generate Rsync configuration file: %s\", rsyncConfigFile);\n    return;\n  }\n\n  char cmd[256];\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --port=%d --config=%s\", rsyncPort, rsyncConfigFile);\n\n  if (system(cmd) == 0) {\n    taosLog(\"INFO: Rsync server started successfully\");\n  } else {\n    taosLog(\"ERROR: failed to start Rsync server\");\n  }\n}", "CodeBleu_score": 38.6316935428564}, {"code": "void startRsync(){\n\t  int32_t ret = taosMkdir(tsCheckpointDir, 0755);\n  if (ret < 0) {\n    uError(\"failed to create checkpoint dir:%s, error:%d\", tsCheckpointDir, errno);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char configFile[128] = {0};\n  snprintf(configFile, sizeof(configFile), \"%s/rsyncd.conf\", tsCheckpointDir);\n  ret = generateConfigFile(configFile);\n  if (ret < 0) {\n    uError(\"failed to generate rsync config file:%s, error:%d\", configFile, errno);\n    return;\n  }\n\n  char cmd[256] = {0};\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --port=%d --config=%s\", tsCheckpointPort, configFile);\n  uDebug(\"start rsync:%s\", cmd);\n  ret = system(cmd);\n  if (ret < 0) {\n    uError(\"failed to start rsync, error:%d\", errno);\n  } else {\n    uDebug(\"start rsync successfully\");\n  }\n}", "CodeBleu_score": 51.912791787559485}, {"code": "void startRsync(){\n\t  int32_t ret = 0;\n  char   cmd[256];\n\n  snprintf(cmd, sizeof(cmd), \"mkdir -p %s\", checkpointDir);\n  ret = system(cmd);\n  if (ret != 0) {\n    uError(\"mkdir %s failed:%d\", checkpointDir, ret);\n    return;\n  }\n\n  removeEmptyDir(checkpointDir);\n  ret = generateConfigFile();\n  if (ret != 0) {\n    uError(\"generate config file failed:%d\", ret);\n    return;\n  }\n\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --port %d --config=%s\", rsyncPort, configFile);\n  ret = system(cmd);\n  if (ret != 0) {\n    uError(\"start rsync server failed:%d\", ret);\n    return;\n  }\n\n  uDebug(\"start rsync server success\");\n}", "CodeBleu_score": 47.98451134696594}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.shutdownNow();\n        dispatchers.remove(dispatcherId);\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n}", "CodeBleu_score": 71.34248639350147}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n    }\n}", "CodeBleu_score": 83.1119417764633}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n    }\n    dispatcher.getExecutor().shutdownNow();\n}", "CodeBleu_score": 70.43674004509407}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        get(parent).forEach(childId -> {\n            if (childFilter.test(childId)) {\n                try {\n                    if (highPriority) {\n                        tell(childId, msg, ActorRef.noSender());\n                    } else {\n                        get(childId).tell(msg, ActorRef.noSender());\n                    }\n                } catch (Exception e) {\n                    warn(\"Failed to send message to child actor [{}]: {}\", childId, e.getMessage());\n                }\n            }\n        });\n    }", "CodeBleu_score": 42.03608254721279}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Map<TbActorId, TbActorCtx> children = get(parent).getChildren();\n        if (children != null) {\n            forEach(children.entrySet(), entry -> {\n                TbActorId childId = entry.getKey();\n                if (childFilter.test(childId)) {\n                    TbActorCtx childCtx = entry.getValue();\n                    if (childCtx != null) {\n                        try {\n                            childCtx.tell(msg, highPriority);\n                        } catch (Exception e) {\n                            warn(\"Failed to send message [{}] to child actor [{}]\", msg, childId);\n                        }\n                    } else {\n                        warn(\"Child actor [{}] is not registered\", childId);\n                    }\n                }\n            });\n        }\n    }", "CodeBleu_score": 49.869652385056774}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        Map<TbActorId, TbActorCtx> children = get(parent).getChildren();\n        forEach(children, childFilter, child -> {\n            try {\n                if (highPriority) {\n                    tell(child.getActorRef(), msg, child.getDispatcher());\n                } else {\n                    tell(child.getActorRef(), msg);\n                }\n            } catch (Exception e) {\n                warn(\"Failed to send message to child actor: [{}]\", child.getActorId());\n            }\n        });\n    }", "CodeBleu_score": 48.47498017146352}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destructionInProgress) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue();\n    } else if (msg.getMsgType().equals(TbActorMsgType.RULE_NODE_UPDATED_MSG)) {\n        if (initFailure && msg.getMsgType().equals(TbActorMsgType.RULE_NODE_UPDATED_MSG)) {\n            initActor();\n        }\n    } else {\n        msg.getCallback().onTbActorStopped();\n    }\n}", "CodeBleu_score": 54.0665081005018}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destructionInProgress) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue();\n    } else {\n        if (msg.getMsgType().equals(RULE_NODE_UPDATED_MSG)) {\n            if (initializationFailed) {\n                reinit();\n            }\n        } else {\n            msg.onTbActorStopped();\n        }\n    }\n}", "CodeBleu_score": 43.408190174633425}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t    if (!destructionInProgress) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue();\n    } else if (msg.getMsgType().equals(RULE_NODE_UPDATED_MSG)) {\n        if (msg.getData() == null && !initSuccess) {\n            initActor();\n        }\n    } else {\n        msg.getCallback().onTbActorStopped();\n    }\n}", "CodeBleu_score": 47.324129677297776}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    // Iterate through the high and normal priority queues\n    for (Queue<Message> queue : queues) {\n        // Process messages from the queue up to the specified throughput limit\n        for (int i = 0; i < actorThroughput; i++) {\n            Message message = queue.poll();\n            if (message == null) {\n                // No more messages, set the actor's status to free and schedule a queue processing attempt\n                setStatus(Status.FREE);\n                scheduleQueueProcessing();\n                return;\n            }\n            try {\n                // Attempt to process the message using the actor's process method\n                process(message);\n            } catch (InitializationFailureException e) {\n                // Initialization failure, set a stop reason and destroy the actor\n                setStopReason(e);\n                destroy();\n                return;\n            } catch (Exception e) {\n                // Log the failure and apply the actor's process failure strategy\n                logger.log(Level.SEVERE, \"Exception occurred during message processing.\", e);\n                actor.processFailure(e);\n                if (actor.isStop()) {\n                    // Actor is stopped, set a stop reason and destroy the actor\n                    setStopReason(new StopReason(actor.getClass(), actor.getId(), actor.getStopReason().getReason()));\n                    destroy();\n                    return;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 37.01507784535522}, {"code": "private void processMailbox(){\n\t    // Get the actor's throughput limit\n    int throughput = actor.getActorThroughput();\n\n    // Process high priority messages up to the throughput limit\n    for (int i = 0; i < throughput; i++) {\n        // Get the next high priority message from the queue\n        Message message = actor.getHighPriorityQueue().poll();\n\n        // If there are no more messages, break the loop\n        if (message == null) {\n            break;\n        }\n\n        // Process the message using the actor's process method\n        try {\n            actor.process(message);\n        } catch (ActorInitializationException e) {\n            // If an initialization failure occurs, set a stop reason and destroy the actor\n            actor.setStopReason(e.getCause());\n            actor.destroy();\n            break;\n        } catch (Exception e) {\n            // For other exceptions, log the failure and apply the actor's process failure strategy\n            log.error(\"Processing message failed\", e);\n            actor.onProcessFailure(e);\n\n            // If the actor is now stopped, break the loop\n            if (actor.isStop()) {\n                break;\n            }\n        }\n    }\n\n    // Process normal priority messages up to the throughput limit\n    for (int i = 0; i < throughput; i++) {\n        // Get the next normal priority message from the queue\n        Message message = actor.getNormalPriorityQueue().poll();\n\n        // If there are no more messages, break the loop\n        if (message == null) {\n            break;\n        }\n\n        // Process the message using the actor's process method\n        try {\n            actor.process(message);\n        } catch (ActorInitializationException e) {\n            // If an initialization failure occurs, set a stop reason and destroy the actor\n            actor.setStopReason(e.getCause());\n            actor.destroy();\n            break;\n        } catch (Exception e) {\n            // For other exceptions, log the failure and apply the actor's process failure strategy\n            log.error(\"Processing message failed\", e);\n            actor.onProcessFailure(e);\n\n            // If the actor is now stopped,", "CodeBleu_score": 40.003701326305766}, {"code": "private void processMailbox(){\n\t    int throughput = 0;\n    try {\n        // Iterate through the high priority queue\n        while (highPriorityQueue.size() > 0 && throughput < actorThroughput) {\n            // Get the next message from the queue\n            Message message = highPriorityQueue.poll();\n            // Process the message using the actor's process method\n            process(message);\n            // Increment the throughput counter\n            throughput++;\n        }\n        // Iterate through the normal priority queue\n        while (normalPriorityQueue.size() > 0 && throughput < actorThroughput) {\n            // Get the next message from the queue\n            Message message = normalPriorityQueue.poll();\n            // Process the message using the actor's process method\n            process(message);\n            // Increment the throughput counter\n            throughput++;\n        }\n        // If there are no more messages, set the actor's status to free\n        if (throughput == 0) {\n            setStatus(Status.FREE);\n            // Schedule a queue processing attempt\n            scheduleQueueProcessing();\n        }\n    } catch (ActorInitializationException e) {\n        // If an initialization failure occurs, set a stop reason and destroy the actor\n        setStopReason(e.getCause());\n        destroy();\n    } catch (Exception e) {\n        // For other exceptions, log the failure and apply the actor's process failure strategy\n        log.error(\"Processing mailbox failed\", e);\n        actor.onProcessFailure(e);\n        // If the actor's process failure strategy requires a stop, stop the actor\n        if (actor.getProcessFailureStrategy() == ProcessFailureStrategy.STOP) {\n            stop();\n        }\n    }\n}", "CodeBleu_score": 28.202376299389826}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (this.stopReason == null) {\n        this.stopReason = cause;\n    }\n    this.destructionInProgress = true;\n    this.dispatcher.getExecutor().execute(new Runnable() {\n        public void run() {\n            try {\n                Actor.this.setReady(false);\n                Actor.this.destroy(Actor.this.stopReason, cause);\n                Actor.this.notifyStopped();\n            } catch (Throwable t) {\n                Actor.this.dispatcher.getLogger().warn(\"Exception occurred while destroying actor \" + Actor.this.getPath(), t);\n            }\n        }\n    });\n}", "CodeBleu_score": 34.25353447455271}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason.get() == null) {\n        stopReason.set(cause);\n    }\n    if (destructionInProgress.compareAndSet(false, true)) {\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                setNotReady();\n                actor.destroy(stopReason.get(), cause);\n                notifyAllQueuedMessages();\n            } catch (Exception e) {\n                dispatcher.getLogger().warn(\"Exception during destroy of actor \" + actor.getClass().getName(), e);\n            }\n        });\n    }\n}", "CodeBleu_score": 34.888286401459546}, {"code": "public void destroy(Throwable cause){\n\t    if (this.stopReason == null) {\n        this.stopReason = new Stopped(this, cause);\n    }\n\n    if (!this.isDestroyInProgress) {\n        this.isDestroyInProgress = true;\n        this.dispatcher.getExecutor().execute(this::destroyActor);\n    }\n}", "CodeBleu_score": 16.666317499843835}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    RateLimitConfiguration rateLimitConfiguration = profileConfiguration.getRateLimitConfiguration();\n    RateLimitKey key = RateLimitKey.builder().api(api).tenantId(tenantId).level(level).build();\n    RateLimitResult rateLimitResult = rateLimitConfiguration.checkRateLimit(key);\n    if (!rateLimitResult.isSuccess()) {\n        processRateLimitNotification(api, tenantId, rateLimitResult);\n    }\n    return rateLimitResult.isSuccess();\n}", "CodeBleu_score": 41.88323867368078}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    ProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    RateLimitConfiguration rateLimitConfiguration = profileConfiguration.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimitKey key = RateLimitKey.builder().api(api).tenantId(tenantId).limitLevel(level).build();\n    boolean success = rateLimitConfiguration.getRateLimits().get(api).getOrElse(key, RateLimit.DEFAULT_RATE_LIMIT).checkRateLimit(key);\n    if (!success) {\n        processRateLimitNotification(tenantId, api, rateLimitConfiguration.getRateLimitNotificationStrategy());\n    }\n    return success;\n}", "CodeBleu_score": 47.618546472900675}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (isSysTenantId(tenantId)) {\n        return true;\n    }\n    TenantProfileConfiguration profileConfiguration = getProfileConfiguration(tenantId, ignoreTenantNotFound);\n    RateLimitConfiguration rateLimitConfiguration = profileConfiguration.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimitKey key = RateLimitKey.builder().api(api).tenantId(tenantId).level(level).build();\n    RateLimitResult result = rateLimitConfiguration.getRateLimit(key).checkRateLimit();\n    if (result.isExceeded()) {\n        processRateLimitNotification(tenantId, api, result.getLimitLevel(), result.getRateLimit());\n    }\n    return result.isSuccess();\n}", "CodeBleu_score": 45.02765693462652}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.trace(\"DTLS session {} has been evicted due to inactivity\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 53.37720317727659}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.trace(\"DTLS session {} has been evicted due to inactivity timeout\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 53.08138197261878}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.trace(\"DTLS session {} removed due to inactivity timeout\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 53.750963641499304}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n\n    return timeseries.entrySet().stream().flatMap(entry -> {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        return values.stream().map(value -> {\n            long ts = value.get(\"ts\").asLong();\n            JsonNode val = value.get(\"value\");\n            return new TsKvEntry(ts, key, val);\n        });\n    }).collect(Collectors.toList());\n}", "CodeBleu_score": 44.89724551662402}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> result = new ArrayList<>();\n    timeseries.forEach((key, value) -> {\n        for (JsonNode jsonNode : value) {\n            result.add(new TsKvEntry(key, jsonNode.asLong()));\n        }\n    });\n    return result;\n}", "CodeBleu_score": 35.87801520629005}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    return timeseries.entrySet()\n            .stream()\n            .flatMap(entry -> {\n                List<TsKvEntry> tsEntries = entry.getValue()\n                        .stream()\n                        .map(jsonNode -> {\n                            long ts = parseValue(jsonNode, \"ts\", JsonNode::asLong);\n                            JsonNode value = parseValue(jsonNode, \"value\", JsonNode::asLong);\n                            return new TsKvEntry(ts, entry.getKey(), value);\n                        })\n                        .collect(Collectors.toList());\n                return tsEntries.stream();\n            })\n            .collect(Collectors.toList());\n}", "CodeBleu_score": 43.04794575374093}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\"refresh_token\", tokenInfo.getRefreshToken());\n\n    ResponseEntity<Object> response = restTemplate.postForEntity(authenticationEndpoint, request, Object.class);\n\n    tokenInfo.setTimestamp(currentTimeMillis());\n    tokenInfo.setTokenInfo(response.getBody());\n}", "CodeBleu_score": 47.588945588476776}, {"code": "public void refreshToken(){\n\t    // Create a request map containing the current refresh token\n    Map<String, String> request = new HashMap<>();\n    request.put(\"refresh_token\", getTokenInfo().getRefreshToken());\n\n    // Send a POST request to the authentication endpoint\n    ResponseEntity<String> response = postForEntity(\n            authEndpoint,\n            request,\n            String.class\n    );\n\n    // Update the token information with the current timestamp and the response body\n    setTokenInfo(\n            new TokenInfo(\n                    response.getBody(),\n                    currentTimeMillis(),\n                    getTokenInfo().getRefreshToken()\n            )\n    );\n}", "CodeBleu_score": 42.33588671024259}, {"code": "public void refreshToken(){\n\t    Map<String, String> request = new HashMap<>();\n    request.put(\"refresh_token\", this.tokenInfo.getRefreshToken());\n    ResponseEntity<String> response = this.restTemplate.postForEntity(this.authenticationEndpoint, request, String.class);\n    this.tokenInfo.setTimestamp(currentTimeMillis());\n    this.tokenInfo.setBody(response.getBody());\n}", "CodeBleu_score": 51.185143967312044}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t    long currentTimeMillis = System.currentTimeMillis();\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", \"admin\");\n    loginRequest.put(\"password\", \"admin\");\n    ResponseEntity<String> response = restTemplate.postForEntity(\n            \"http://localhost:8080/api/auth/login\",\n            loginRequest,\n            String.class\n    );\n    tokenInfo.setTokenInfo(response.getBody(), currentTimeMillis);\n}", "CodeBleu_score": 61.71553878167933}, {"code": " private void doLogin(){\n\t        long currentTimeMillis = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<Map<String, Object>> response = restTemplate.postForEntity(baseUrl + \"/api/auth/login\", loginRequest, Map.class);\n        updateTokenInfo(response.getBody(), currentTimeMillis);\n    }", "CodeBleu_score": 74.91998062750585}, {"code": " private void doLogin(){\n\t    long currentTimeMillis = System.currentTimeMillis();\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", \"admin\");\n    loginRequest.put(\"password\", \"admin\");\n    ResponseEntity<Map> response = restTemplate.postForEntity(\n            \"http://localhost:8080/api/auth/login\",\n            loginRequest,\n            Map.class);\n    setTokenInfo(response.getBody(), currentTimeMillis);\n}", "CodeBleu_score": 62.17091404914117}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (HttpClientErrorException e) {\n        throw e;\n    }\n}", "CodeBleu_score": 52.20332467121489}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getValue());\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (HttpClientErrorException e) {\n        throw e;\n    }\n}", "CodeBleu_score": 54.66275912218722}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getValue());\n        if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 65.36168413732135}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        Request request = new Request(device, credentials);\n        return Optional.of(restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class).getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (RestClientException e) {\n        throw e;\n    }\n}", "CodeBleu_score": 40.645843060138944}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n        ResponseEntity<Device> response = restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    }\n}", "CodeBleu_score": 50.89485005258454}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        Request request = new Request(device, credentials);\n        return Optional.of(restTemplate.postForEntity(\"/api/device-with-credentials\", request, Device.class).getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 53.133820358583115}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t  if (val !== undefined) {\n    this.send(addr, val);\n  } else {\n    this.map(val);\n  }\n  return this;\n}", "CodeBleu_score": 33.34650106704265}, {"code": "brightness(addr, val){\n\t    if (val == null) {\n        val = addr;\n        addr = null;\n    }\n    if (addr == null) {\n        this.each(function (dev) {\n            dev.brightness(val);\n        });\n    } else {\n        this.send(addr, 'brightness', val);\n    }\n    return this;\n}", "CodeBleu_score": 57.14931387450463}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n        this.each(function(dev) {\n            dev.brightness(val);\n        });\n    } else {\n        this.send(addr, 'brightness', val);\n    }\n    return this;\n}", "CodeBleu_score": 50.23182815872035}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    const obj = {};\n    Object.getOwnPropertyNames(LedControl.prototype).forEach(key => {\n        obj[key] = this[key].bind(this, addr);\n    });\n    Object.keys(this).forEach(key => {\n        obj[key] = this[key].bind(this, addr);\n    });\n    return obj;\n}", "CodeBleu_score": 62.805126187800106}, {"code": "device(addr){\n\t    const obj = {};\n    Object.getOwnPropertyNames(LedControl.prototype).forEach(key => {\n        obj[key] = this[key].bind(this, addr);\n    });\n    Object.keys(this).forEach(key => {\n        obj[key] = this[key].bind(this, addr);\n    });\n    return obj;\n}", "CodeBleu_score": 62.805126187800106}, {"code": "device(addr){\n\t  const obj = {}\n  Object.getOwnPropertyNames(LedControl.prototype).forEach(key => {\n    obj[key] = this[key].bind(this, addr)\n  })\n  Object.keys(this).forEach(key => {\n    obj[key] = this[key].bind(this, addr)\n  })\n  return obj\n}", "CodeBleu_score": 49.725800135049646}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[method] = function (duration = 1000, callback) {\n      duration = Number(duration) || 1000\n      callback = typeof callback === 'function' ? callback : () => {}\n      const promises = this.map(i => {\n        return new Promise(resolve => {\n          setTimeout(() => {\n            i[method]()\n            resolve()\n          }, duration)\n        })\n      })\n      Promise.all(promises).then(callback)\n    }\n  })\n}", "CodeBleu_score": 38.93055122486758}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  for (const method of methods) {\n    target[method] = (duration = 1000, callback) => {\n      const promises = [];\n      for (const i in this) {\n        promises.push(this[i][method]());\n      }\n      Promise.all(promises).then(callback);\n    }\n  }\n}", "CodeBleu_score": 19.556231420410374}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = (duration = 1000, callback) => {\n            const signals = [];\n            this.forEach(i => {\n                signals.push(new Promise(resolve => {\n                    setTimeout(() => {\n                        i[method]();\n                        resolve();\n                    }, duration);\n                }));\n            });\n            Promise.all(signals).then(callback);\n        }\n    });\n}", "CodeBleu_score": 31.337720671821202}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t    let input = '';\n    this.io.serialRead(this.priv.get('port'), (data) => {\n        input += data.toString();\n        let sentences = input.split('\\r\n');\n        input = sentences.pop();\n        sentences.forEach(sentence => {\n            this.parseNmeaSentence(sentence);\n        });\n    });\n}", "CodeBleu_score": 32.19921405996657}, {"code": "listen(){\n\t    let input = '';\n    this.io.serialRead(this.priv.get('port'), (data) => {\n        input += data.toString();\n        const sentences = input.split('\\r\n');\n        input = sentences.pop();\n        sentences.forEach(sentence => this.parseNmeaSentence(sentence));\n    });\n}", "CodeBleu_score": 31.74170703349678}, {"code": "listen(){\n\t  let input = \"\";\n  this.io.serialRead(this.priv.get(\"port\"), (data) => {\n    input += new Buffer(data).toString();\n    let sentences = input.split(\"\\r\n\");\n    input = sentences.pop();\n    sentences.forEach((sentence) => {\n      this.parseNmeaSentence(sentence);\n    });\n  });\n}", "CodeBleu_score": 37.63554355687408}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t num_channels = sequence->options->extra_samplings + 1;\n\tuint32_t buffer_size = sequence->options->buf_size;\n\tuint32_t num_active_channels = POPCOUNT(sequence->channels);\n\tuint32_t needed_buffer_size = num_channels * num_active_channels;\n\n\tif (buffer_size < needed_buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.58970305191312}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\n    /* Calculate the number of active channels */\n    uint8_t num_channels = sequence->options->channels;\n    uint8_t active_channels = POPCOUNT(num_channels);\n\n    /* Calculate the needed buffer size */\n    uint32_t needed_buffer_size = active_channels * sequence->options->resolution;\n\n    /* Check if the provided buffer size is sufficient */\n    if (sequence->buffer_size < needed_buffer_size) {\n        return -ENOMEM;\n    }\n\n    return 0;\n}", "CodeBleu_score": 45.37360118464051}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t needed_size;\n\tuint32_t active_channels = 0;\n\n\tfor (uint8_t i = 0; i < sequence->channels_count; i++) {\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tactive_channels |= 1 << sequence->channels[i];\n\t}\n\tactive_channels = POPCOUNT(active_channels);\n\tneeded_size = active_channels * sequence->resolution;\n\n\tif (sequence->options) {\n\t\tneeded_size *= 2;\n\t}\n\tif (sequence->buffer_size < needed_size) {\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 44.293208613983296}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    const struct adc_ad559x_config *config = dev->config;\n    const struct adc_ad559x_data *data = dev->data;\n    uint8_t buffer[AD559X_BUFFER_SIZE];\n    uint8_t ch_mask = 0;\n    int err;\n\n    if (sequence->resolution != config->resolution) {\n        LOG_ERR(\"Resolution not supported\");\n        return -EINVAL;\n    }\n\n    for (size_t i = 0; i < sequence->channels_count; i++) {\n        if (sequence->channels[i]->channel_id >= config->num_channels) {\n            LOG_ERR(\"Invalid channel\");\n            return -EINVAL;\n        }\n\n        ch_mask |= BIT(sequence->channels[i]->channel_id);\n    }\n\n    err = adc_ad559x_validate_buffer_size(sequence, buffer);\n    if (err) {\n        return err;\n    }\n\n    data->buffer = buffer;\n    data->buffer_size = sizeof(buffer);\n    data->ch_mask = ch_mask;\n\n    err = adc_context_start_read(dev, sequence);\n    if (err) {\n        return err;\n    }\n\n    err = adc_context_wait_for_completion(dev);\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}", "CodeBleu_score": 45.489167411564544}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t    const struct adc_ad559x_config *config = dev->config;\n    const struct adc_channel_cfg *channels = sequence->channels;\n    const struct adc_ad559x_chan_cfg *chan_cfg;\n    int err;\n\n    if (sequence->resolution != config->resolution) {\n        LOG_ERR(\"Resolution mismatch\");\n        return -EINVAL;\n    }\n\n    if (sequence->num_channels != config->num_channels) {\n        LOG_ERR(\"Channel count mismatch\");\n        return -EINVAL;\n    }\n\n    for (uint8_t i = 0; i < sequence->num_channels; i++) {\n        chan_cfg = adc_ad559x_get_chan_cfg(dev, channels[i].channel_id);\n        if (!chan_cfg) {\n            LOG_ERR(\"Invalid channel\");\n            return -EINVAL;\n        }\n    }\n\n    err = adc_ad559x_validate_buffer_size(dev, sequence);\n    if (err) {\n        return err;\n    }\n\n    adc_context_start_read(dev, sequence);\n    adc_context_wait_for_completion(dev);\n\n    return 0;\n}", "CodeBleu_score": 47.80237488011381}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t  int err;\n  struct adc_ad559x_data *data = dev->data;\n  const struct adc_ad559x_config *config = dev->config;\n  const struct adc_channel_cfg *channel_cfg;\n  uint8_t channel_count;\n  uint8_t i;\n  uint8_t channel_mask;\n  uint8_t resolution;\n  uint8_t buffer_size;\n  uint8_t buffer[AD559X_BUFFER_SIZE];\n  uint8_t *buf_ptr;\n  uint8_t *buf_end;\n  uint8_t *buf_start;\n  uint8_t *buf_next;\n  uint8_t *buf_last;\n  uint8_t *buf_first;\n  uint8_t *buf_last_ptr;\n  uint8_t *buf_first_ptr;\n  uint8_t *buf_next_ptr;\n  uint8_t *buf_end_ptr;\n  uint8_t *buf_start_ptr;\n  uint8_t *buf_ptr_ptr;\n  uint8_t *buf_ptr_end;\n  uint8_t *buf_ptr_start;\n  uint8_t *buf_ptr_next;\n  uint8_t *buf_ptr_last;\n  uint8_t *buf_ptr_first;\n  uint8_t *buf_ptr_last_ptr;\n  uint8_t *buf_ptr_first_ptr;\n  uint8_t *buf_ptr_next_ptr;\n  uint8_t *buf_ptr_end_ptr;\n  uint8_t *buf_ptr_start_ptr;\n  uint8_t *buf_ptr_ptr_ptr;\n  uint8_t *buf_ptr_ptr_end;\n  uint8_t *buf_ptr_ptr_start;\n  uint8_t *buf_ptr_ptr_next;\n  uint8_t *buf_ptr_ptr_last;\n  uint8_t *buf_ptr_ptr_first;\n  uint8_t *buf_ptr_", "CodeBleu_score": 15.146761740864267}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = ctx->data;\n    struct device *adc = data->adc;\n\n    /* Set the channels to be sampled */\n    for (int i = 0; i < data->num_channels; i++) {\n        int err = adc_channel_setup(adc, &data->channels[i]);\n        if (err) {\n            printk(\"Error setting up ADC channel %d: %d\n\", i, err);\n            return;\n        }\n    }\n\n    /* Initialize the repeat buffer with the data buffer */\n    struct adc_sequence *seq = &data->sequence;\n    seq->buffer = data->buffer;\n    seq->buffer_size = data->buffer_size;\n    seq->resolution = data->resolution;\n\n    /* Release a semaphore to signal the start of sampling */\n    k_sem_give(&ctx->sem);\n}", "CodeBleu_score": 32.310925744918784}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = CONTAINER_OF(ctx, struct adc_data, ctx);\n    struct adc_driver_api *api = (struct adc_driver_api *)data->dev->api;\n\n    api->set_channels(data->dev, data->channels);\n    api->set_buffer(data->dev, data->repeat_buf, sizeof(data->repeat_buf));\n\n    k_sem_give(&data->sem);\n}", "CodeBleu_score": 53.51627367437819}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tadc_context_init_repeat_buffer(ctx);\n\n\tadc_context_set_channels(ctx);\n\n\tk_sem_give(&ctx->sem);\n}", "CodeBleu_score": 36.73198162786605}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_data_container *container = ctx->container;\n    if (repeat_sampling) {\n        container->buffer = container->repeat_buffer;\n    }\n}", "CodeBleu_score": 52.14028832765403}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_data_container *data_container = adc_context_get_data_container(ctx);\n    if (repeat_sampling) {\n        adc_data_container_set_buffer_pointer(data_container, adc_data_container_get_repeat_buffer(data_container));\n    } else {\n        adc_data_container_set_buffer_pointer(data_container, adc_data_container_get_buffer(data_container));\n    }\n}", "CodeBleu_score": 28.91818859714046}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    if (repeat_sampling) {\n        ctx->adc_data_container->buffer = ctx->repeat_buffer;\n    } else {\n        ctx->adc_data_container->buffer = ctx->buffer;\n    }\n}", "CodeBleu_score": 46.21350514400218}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    while (1) {\n        k_sem_take(&data->sem, K_FOREVER);\n\n        for (uint8_t i = 0; i < data->num_channels; i++) {\n            if (!data->active_channels[i]) {\n                continue;\n            }\n\n            int32_t value = adc_ad559x_read_channel(data->dev, i);\n            if (value < 0) {\n                LOG_ERR(\"Failed to read ADC channel %d\", i);\n                adc_context_on_sampling_done(data->context, i, value);\n                adc_context_complete(data->context);\n                continue;\n            }\n\n            adc_context_on_sampling_done(data->context, i, value);\n        }\n\n        adc_context_on_sampling_done(data->context, data->num_channels, 0);\n    }\n}", "CodeBleu_score": 38.583635924225646}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (uint8_t i = 0; i < ADC_AD559X_MAX_CHANNELS; i++) {\n\t\t\tif (!data->active_channels[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuint16_t value;\n\t\t\tint err = adc_ad559x_read_channel(data, i, &value);\n\t\t\tif (err) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", i, err);\n\t\t\t\tdata->context.complete = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdata->context.buffer[i] = value;\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->context);\n\t}\n}", "CodeBleu_score": 40.04774843432551}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t    while (true) {\n        k_sem_take(&data->sem, K_FOREVER);\n\n        for (size_t i = 0; i < data->channel_count; i++) {\n            if (!data->channels[i].active) {\n                continue;\n            }\n\n            int16_t value;\n            int ret = adc_ad559x_read_channel(data, i, &value);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to read channel %d\", i);\n                adc_context_on_sampling_done(data->context, i, NULL, 0);\n                continue;\n            }\n\n            adc_context_on_sampling_done(data->context, i, &value, sizeof(value));\n        }\n\n        adc_context_complete(data->context);\n    }\n}", "CodeBleu_score": 45.32075373466113}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    int ret;\n    uint8_t status;\n    uint32_t ready_time_us;\n    struct ads1112_data *data = dev->data;\n\n    /* Read the configuration register to get the ready time */\n    ret = ads1112_read_reg(dev, ADS1112_CONFIG_REG, &status);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to read the configuration register\");\n        return ret;\n    }\n\n    /* Calculate the ready time in microseconds */\n    ready_time_us = (status & ADS1112_CONFIG_DR_MASK) >> ADS1112_CONFIG_DR_SHIFT;\n    ready_time_us = (ready_time_us + 1) * 100;\n\n    /* Wait for the device to be ready */\n    while (!(status & ADS1112_CONFIG_DR_MASK)) {\n        k_sleep(K_USEC(100));\n        ret = ads1112_read_reg(dev, ADS1112_CONFIG_REG, &status);\n        if (ret < 0) {\n            LOG_ERR(\"Failed to read the configuration register\");\n            return ret;\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 55.621575178938}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    int ret;\n    uint8_t reg;\n\n    k_sleep(K_USEC(ADS1112_READY_TIME_US));\n\n    do {\n        ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg);\n        if (ret < 0) {\n            return ret;\n        }\n    } while (!(reg & ADS1112_CONFIG_DRDY));\n\n    return 0;\n}", "CodeBleu_score": 31.643279898691684}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t    int ret;\n    uint8_t status;\n\n    k_sleep(K_USEC(ADS1112_READY_TIME));\n\n    do {\n        ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &status);\n        if (ret) {\n            return ret;\n        }\n    } while (!(status & ADS1112_CONFIG_DRDY));\n\n    return 0;\n}", "CodeBleu_score": 31.79224112744807}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t  size_t buffer_size = sequence->options ? sequence->options->extra_samplings + 1 : 1;\n\n  if (sequence->buffer_size < buffer_size) {\n    LOG_ERR(\"buffer size %zu is smaller than required buffer size %zu\",\n            sequence->buffer_size, buffer_size);\n    return -EMSGSIZE;\n  }\n\n  return 0;\n}", "CodeBleu_score": 41.285303452067126}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    size_t buffer_size = sequence->options->extra_samplings + 1;\n    if (sequence->buffer_size < buffer_size) {\n        LOG_ERR(\"Buffer size %d is smaller than required %d\", sequence->buffer_size, buffer_size);\n        return -EINVAL;\n    }\n    return 0;\n}", "CodeBleu_score": 41.39401536097493}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    const struct ads1112_data *data = sequence->dev->data;\n    size_t buffer_size = sequence->options->buffer_size;\n    size_t num_samplings = sequence->options->extra_samplings + sequence->num_samplings;\n    size_t required_buffer_size = num_samplings * data->resolution;\n\n    if (buffer_size < required_buffer_size) {\n        LOG_ERR(\"Buffer size %zu is not sufficient for %zu samplings\", buffer_size, num_samplings);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 37.9402417655242}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tint result;\n\n\tresult = ads1112_validate_sequence(dev, sequence);\n\tif (result != 0) {\n\t\treturn result;\n\t}\n\n\tresult = adc_context_start_read(dev, sequence, wait);\n\tif (result != 0) {\n\t\treturn result;\n\t}\n\n\tif (wait) {\n\t\tresult = adc_context_wait_for_completion(dev);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 54.289162830802425}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tadc_context_start_read(dev, sequence);\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(dev);\n\t} else {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 49.8239434445055}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tint ret;\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"ADS1112 does not support any options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tret = adc_context_start_read(dev, sequence, wait);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(dev);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 55.6637497340672}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    int ret;\n    struct device *dev;\n    struct audio_codec_data data;\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"device %s not found\", argv[1]);\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_properties(dev, &data);\n    if (ret) {\n        shell_error(sh, \"apply properties failed: %d\", ret);\n        return ret;\n    }\n\n    return 0;\n}", "CodeBleu_score": 55.10633401269271}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t  const char *dev_name = argv[1];\n  struct device *dev;\n\n  dev = device_get_binding(dev_name);\n  if (!dev) {\n    shell_error(sh, \"Cannot get device %s\", dev_name);\n    return -ENODEV;\n  }\n\n  return audio_codec_apply_properties(dev);\n}", "CodeBleu_score": 70.77776444461325}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    int ret;\n    struct audio_codec_cfg cfg;\n    struct audio_codec_properties prop;\n    const struct device *dev = device_get_binding(argv[1]);\n\n    if (!dev) {\n        shell_error(sh, \"device not found\");\n        return -EINVAL;\n    }\n\n    cfg.codec_name = argv[2];\n    cfg.codec_id = atoi(argv[3]);\n    cfg.codec_sample_rate = atoi(argv[4]);\n    cfg.codec_bits_per_sample = atoi(argv[5]);\n    cfg.codec_channels = atoi(argv[6]);\n    cfg.codec_format = atoi(argv[7]);\n    cfg.codec_type = atoi(argv[8]);\n\n    prop.sample_rate = cfg.codec_sample_rate;\n    prop.bits_per_sample = cfg.codec_bits_per_sample;\n    prop.channels = cfg.codec_channels;\n    prop.format = cfg.codec_format;\n    prop.type = cfg.codec_type;\n\n    ret = audio_codec_apply_properties(dev, &prop);\n    if (ret) {\n        shell_error(sh, \"failed to apply properties: %d\", ret);\n        return ret;\n    }\n\n    return 0;\n}", "CodeBleu_score": 52.560301281697996}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    const struct mpxxdtyy_i2s_config *config = dev->config;\n    int ret;\n    uint8_t i2s_cmd;\n    uint8_t i2s_state;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            i2s_cmd = config->i2s_cmd_start;\n            i2s_state = config->i2s_state_start;\n            break;\n        case DMIC_TRIGGER_STOP:\n            i2s_cmd = config->i2s_cmd_stop;\n            i2s_state = config->i2s_state_stop;\n            break;\n        default:\n            LOG_ERR(\"Unsupported trigger command: %d\", cmd);\n            return -ENOTSUP;\n    }\n\n    ret = i2s_send_cmd(dev, i2s_cmd);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to send I2S command: %d\", ret);\n        return ret;\n    }\n\n    ret = i2s_set_state(dev, i2s_state);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to set I2S state: %d\", ret);\n        return ret;\n    }\n\n    return 0;\n}", "CodeBleu_score": 50.03596129401424}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    const struct mpxxdtyy_config *config = dev->config;\n    struct mpxxdtyy_data *data = dev->data;\n    int ret;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state != DMIC_STATE_CONFIGURED) {\n                LOG_ERR(\"DMIC device not in configured state\");\n                return -ENOTSUP;\n            }\n            ret = i2s_trigger(data->i2s, I2S_TRIGGER_START);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to trigger I2S start\");\n                return ret;\n            }\n            data->state = DMIC_STATE_ACTIVE;\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (data->state != DMIC_STATE_ACTIVE) {\n                LOG_ERR(\"DMIC device not in active state\");\n                return -ENOTSUP;\n            }\n            ret = i2s_trigger(data->i2s, I2S_TRIGGER_STOP);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to trigger I2S stop\");\n                return ret;\n            }\n            data->state = DMIC_STATE_CONFIGURED;\n            break;\n\n        default:\n            LOG_ERR(\"Invalid DMIC trigger command\");\n            return -ENOTSUP;\n    }\n\n    return 0;\n}", "CodeBleu_score": 57.47598703225897}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    int ret;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (i2s_trigger_state == I2S_TRIGGER_STATE_CONFIGURED) {\n                ret = i2s_trigger(dev, I2S_TRIGGER_START);\n                if (ret == 0) {\n                    i2s_trigger_state = I2S_TRIGGER_STATE_ACTIVE;\n                } else {\n                    LOG_ERR(\"Failed to trigger I2S start: %d\", ret);\n                }\n            } else {\n                LOG_ERR(\"I2S trigger state is not configured\");\n                ret = -EINVAL;\n            }\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (i2s_trigger_state == I2S_TRIGGER_STATE_ACTIVE) {\n                ret = i2s_trigger(dev, I2S_TRIGGER_STOP);\n                if (ret == 0) {\n                    i2s_trigger_state = I2S_TRIGGER_STATE_CONFIGURED;\n                } else {\n                    LOG_ERR(\"Failed to trigger I2S stop: %d\", ret);\n                }\n            } else {\n                LOG_ERR(\"I2S trigger state is not active\");\n                ret = -EINVAL;\n            }\n            break;\n\n        default:\n            LOG_ERR(\"Invalid DMIC trigger command: %d\", cmd);\n            ret = -EINVAL;\n            break;\n    }\n\n    return ret;\n}", "CodeBleu_score": 50.54221946581943}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    struct auxdisplay_hd44780_data *data = dev->data;\n    uint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n    if (enabled) {\n        cmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_ON;\n    }\n    if (data->cursor_blink) {\n        cmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK;\n    }\n    if (data->cursor_position) {\n        cmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_POSITION;\n    }\n\n    auxdisplay_hd44780_command(dev, cmd);\n}", "CodeBleu_score": 66.34737483033103}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    const struct auxdisplay_hd44780_config *config = dev->config;\n    struct auxdisplay_hd44780_data *data = dev->data;\n\n    uint8_t command = config->display_mode;\n\n    if (enabled) {\n        command |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n    }\n\n    auxdisplay_hd44780_command(dev, command);\n\n    data->display_enabled = enabled;\n}", "CodeBleu_score": 48.74108511185507}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t    const struct auxdisplay_hd44780_config *config = dev->config;\n    uint8_t cmd = config->display_mode;\n\n    if (enabled) {\n        cmd |= HD44780_CMD_DISPLAY_ON;\n    } else {\n        cmd &= ~HD44780_CMD_DISPLAY_ON;\n    }\n\n    auxdisplay_hd44780_command(dev, cmd);\n}", "CodeBleu_score": 39.14342027864125}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n    if (config->busy_gpio.port == NULL) {\n        return -ENOTSUP;\n    }\n    return gpio_pin_get_dt(&config->busy_gpio);\n}", "CodeBleu_score": 56.22469803049395}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t  const struct auxdisplay_itron_config *config = dev->config;\n  int status;\n\n  if (config->busy_gpio == NULL) {\n    return -ENOTSUP;\n  }\n\n  status = gpio_pin_get_dt(config->busy_gpio);\n  if (status < 0) {\n    return status;\n  }\n\n  return status;\n}", "CodeBleu_score": 71.98599048261644}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n\n    if (!config->busy_gpio.port) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get_dt(&config->busy_gpio);\n}", "CodeBleu_score": 47.27498086380455}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tint rc = i2c_write_dt(&config->i2c, buffer, sizeof(buffer));\n\n\tk_sleep(K_MSEC(config->delay_ms));\n\n\treturn rc;\n}", "CodeBleu_score": 75.44449606185445}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t data[2];\n\n\tdata[0] = config->special_command_prefix;\n\tdata[1] = command;\n\n\treturn i2c_write_dt(&config->i2c, data, sizeof(data),\n\t\t\t    K_MSEC(config->special_command_delay_ms));\n}", "CodeBleu_score": 64.11025644346194}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[AUXDISPLAY_SERLCD_SPECIAL_COMMAND_SIZE];\n\n\tbuf[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuf[1] = command;\n\n\tint rc = i2c_write_dt(&config->i2c, buf, sizeof(buf));\n\n\tk_msleep(config->delay);\n\n\treturn rc;\n}", "CodeBleu_score": 68.94514919672004}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tbbram_emul_check_invalid(dev, offset, size);\n\n\tmemcpy(data, &bbram_emul_data[offset], size);\n\treturn 0;\n}", "CodeBleu_score": 41.132800561249}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tARG_UNUSED(dev);\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &bbram_emul_mem[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 41.99486963141889}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tARG_UNUSED(dev);\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &bbram_emul_mem[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 41.99486963141889}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t    struct bbram_emul_dev *bbram_dev = dev->data;\n\n    if (size == 0) {\n        return 0;\n    }\n\n    if (size != 1 && size != 2 && size != 4) {\n        return -EINVAL;\n    }\n\n    if (offset + size > bbram_dev->size) {\n        return -EINVAL;\n    }\n\n    if (bbram_dev->invalid) {\n        return -EINVAL;\n    }\n\n    memcpy(&bbram_dev->data[offset], data, size);\n\n    return 0;\n}", "CodeBleu_score": 52.100053591160254}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_is_invalid(dev)) {\n\t\treturn -ENODEV;\n\t}\n\n\tmemcpy(bbram_emul_get_mem(dev) + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 55.2133146587695}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tARG_UNUSED(dev);\n\tARG_UNUSED(offset);\n\tARG_UNUSED(size);\n\tARG_UNUSED(data);\n\n\treturn 0;\n}", "CodeBleu_score": 31.7949649120011}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst char *dev_name;\n\tint ret;\n\n\t/* Check arguments */\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_name = argv[1];\n\n\t/* Get device binding */\n\t*bbram_dev = device_get_binding(dev_name);\n\tif (!(*bbram_dev)) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_init(*bbram_dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to initialize BBRAM\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.07174053797233}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tuint32_t dev_num;\n\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device number argument\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_num = strtoul(argv[1], NULL, 0);\n\t*bbram_dev = device_get_binding(DEVICE_DT_NAME(dev_num));\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_init(*bbram_dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to initialize BBRAM\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 70.15196156320515}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst char *bbram_dev_name;\n\tint ret;\n\n\t/* Check that the device name is provided */\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing BBRAM device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbbram_dev_name = argv[1];\n\n\t/* Get the device handle for the specified device */\n\t*bbram_dev = device_get_binding(bbram_dev_name);\n\tif (!(*bbram_dev)) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Verify that the device is ready */\n\tret = device_is_ready(*bbram_dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Device not ready\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.82979667266451}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t    /*\n     * Calculate the number of bytes already read.\n     */\n    uint32_t remaining_bytes = sizeof(hdr) - hdr_bytes_read;\n    /*\n     * Attempt to read the remaining bytes from the UART FIFO into the header buffer.\n     */\n    int ret = uart_fifo_read(dev, &hdr[hdr_bytes_read], remaining_bytes);\n    /*\n     * If the read operation fails, log an error message.\n     */\n    if (ret < 0) {\n        LOG_ERR(\"Failed to read header data from UART device: %d\", ret);\n    }\n    /*\n     * Otherwise, update the remaining byte count based on the number of bytes successfully read.\n     */\n    else {\n        hdr_bytes_read += ret;\n    }\n}", "CodeBleu_score": 29.514129325388893}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    int ret;\n    int bytes_read = sizeof(struct h4_hdr);\n    int bytes_remaining = sizeof(struct h4_hdr) - bytes_read;\n    struct h4_hdr *hdr = (struct h4_hdr *)&uart_buffer[0];\n\n    while (bytes_remaining > 0) {\n        ret = uart_fifo_read(dev, &uart_buffer[bytes_read], bytes_remaining);\n        if (ret < 0) {\n            LOG_ERR(\"Error reading from UART device: %d\", ret);\n            return;\n        }\n        bytes_read += ret;\n        bytes_remaining = sizeof(struct h4_hdr) - bytes_read;\n    }\n\n    /* Check if the header is valid */\n    if (hdr->magic != H4_MAGIC) {\n        LOG_ERR(\"Invalid header magic: %x\", hdr->magic);\n        return;\n    }\n\n    /* Check if the header length is valid */\n    if (hdr->length > H4_MAX_PAYLOAD_SIZE) {\n        LOG_ERR(\"Invalid header length: %d\", hdr->length);\n        return;\n    }\n\n    /* Check if the header checksum is valid */\n    if (hdr->checksum != h4_checksum(hdr)) {\n        LOG_ERR(\"Invalid header checksum: %x\", hdr->checksum);\n        return;\n    }\n\n    /* Check if the payload length is valid */\n    if (hdr->length != hdr->payload_length) {\n        LOG_ERR(\"Invalid payload length: %d\", hdr->payload_length);\n        return;\n    }\n}", "CodeBleu_score": 32.51704579741745}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t    int rc;\n    const uint8_t *hdr_ptr;\n    size_t hdr_len;\n    size_t hdr_bytes_read;\n    size_t hdr_bytes_remaining;\n\n    /* Calculate the number of bytes already read */\n    hdr_ptr = (const uint8_t *)&h4.hdr;\n    hdr_len = sizeof(struct h4_hdr);\n    hdr_bytes_read = hdr_len - h4.hdr_bytes_remaining;\n\n    /* Attempt to read remaining bytes from UART FIFO into header buffer */\n    rc = uart_fifo_read(dev, &hdr_ptr[hdr_bytes_read], h4.hdr_bytes_remaining);\n    if (rc) {\n        LOG_ERR(\"Failed to read header data from UART FIFO\");\n        return;\n    }\n\n    /* Update remaining byte count based on number of bytes successfully read */\n    hdr_bytes_remaining = hdr_len - (hdr_bytes_read + rc);\n    h4.hdr_bytes_remaining = hdr_bytes_remaining;\n}", "CodeBleu_score": 44.13380263090248}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    size_t i = 0;\n    uint8_t tmp[33];\n    int rc;\n\n    while (i < len) {\n        rc = uart_fifo_read(uart, &tmp[i], MIN(len - i, sizeof(tmp)));\n        if (rc < 0) {\n            LOG_ERR(\"UART FIFO read error %d\", rc);\n            return 0;\n        }\n        i += rc;\n    }\n    return i;\n}", "CodeBleu_score": 44.44579447155412}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t  uint8_t buf[33];\n  size_t rc;\n\n  rc = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n  if (rc < 0) {\n    LOG_ERR(\"uart_fifo_read error %d\", rc);\n    return 0;\n  }\n\n  return rc;\n}", "CodeBleu_score": 60.86034296199955}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t rx_len = 0;\n\tuint8_t buf[33];\n\n\twhile (len) {\n\t\trx_len = MIN(len, sizeof(buf));\n\t\tif (uart_fifo_read(uart, buf, rx_len) < 0) {\n\t\t\tLOG_ERR(\"uart_fifo_read failed\");\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= rx_len;\n\t}\n\treturn rx_len;\n}", "CodeBleu_score": 42.9224056455318}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    uint8_t hop = 0;\n    uint8_t prio;\n\n    zbus_spinlock_lock(&chan->lock);\n    for (uint8_t i = 0; i < chan->num_observers; i++) {\n        prio = chan->observers[i].priority;\n        if (chan->observers[i].enabled && prio < hop) {\n            hop = prio;\n        }\n    }\n    chan->highest_observer_priority = hop;\n    zbus_spinlock_unlock(&chan->lock);\n}", "CodeBleu_score": 24.463159117486295}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    uint32_t hop = 0;\n    uint32_t i;\n\n    spinlock_acquire(&chan->lock);\n\n    for (i = 0; i < chan->nobservers; i++) {\n        struct zbus_observer *obs = &chan->observers[i];\n        if (obs->enabled && obs->priority < hop) {\n            hop = obs->priority;\n        }\n    }\n\n    chan->hop = hop;\n\n    spinlock_release(&chan->lock);\n}", "CodeBleu_score": 23.768168964709798}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    struct zbus_channel_data *chan_data = (struct zbus_channel_data *)chan;\n    struct zbus_observer *obs;\n    int hop = -1;\n\n    k_spinlock_key_t key = k_spin_lock(&chan_data->lock);\n    sys_slist_t *item = sys_slist_peek_head(&chan_data->observers);\n    while (item != NULL) {\n        obs = CONTAINER_OF(item, struct zbus_observer, node);\n        if (obs->enabled && (hop == -1 || obs->priority < hop)) {\n            hop = obs->priority;\n        }\n        item = sys_slist_peek_next(&chan_data->observers, item);\n    }\n    chan_data->highest_observer_priority = hop;\n    k_spin_unlock(&chan_data->lock, key);\n}", "CodeBleu_score": 39.36303341954896}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_chan_obs *chan_obs = NULL;\n    struct zbus_chan *chan = NULL;\n    struct zbus_observer *obs_tmp = NULL;\n\n    ZBUS_LIST_FOREACH(chan_obs, &chan_obs_list, list) {\n        chan = chan_obs->chan;\n        obs_tmp = chan_obs->obs;\n        if (obs == obs_tmp) {\n            update_channel_hop(chan);\n        }\n    }\n}", "CodeBleu_score": 18.36509010080437}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel *chan;\n    struct zbus_channel_observation *obs_chan;\n    zbus_chan_foreach(chan, obs_chan) {\n        if (obs_chan->observer == obs) {\n            update_channel_hop(chan);\n        }\n    }\n}", "CodeBleu_score": 24.89428846597746}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t    struct zbus_channel_hop *chan;\n    zbus_chan_hop_foreach(chan) {\n        if (chan->observer == obs) {\n            chan_update_hop(chan);\n        }\n    }\n}", "CodeBleu_score": 23.25894629520763}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    K_SPINLOCK_DEFINE(lock, 0);\n    k_spinlock_key_t key;\n    k_spinlock_init(&lock);\n    k_spinlock_key_t key = k_spinlock_lock(&lock);\n    K_ASSERT(!k_is_in_isr());\n    K_ASSERT(obs);\n    obs->priority = K_LOWEST_THREAD_PRIO;\n    update_all_channels_hop(obs);\n    k_spinlock_unlock(&lock, key);\n    return 0;\n}", "CodeBleu_score": 49.25155814507045}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    K_SPINLOCK(obs->lock);\n    k_is_in_isr();\n    _ZBUS_ASSERT(obs != NULL);\n    update_all_channels_hop(obs);\n    return 0;\n}", "CodeBleu_score": 21.23050335489162}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t    K_SPINLOCK(zbus_observer_lock);\n    K_ASSERT(!k_is_in_isr());\n    K_ASSERT(obs != NULL);\n    k_spinlock_key_t key = k_spin_lock(&zbus_observer_lock);\n    obs->priority = K_LOWEST_THREAD_PRIO;\n    update_all_channels_hop(obs);\n    k_spin_unlock(&zbus_observer_lock, key);\n    return 0;\n}", "CodeBleu_score": 52.30712058829735}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    int ret = 0;\n    k_tid_t thread = k_current_get();\n    k_is_in_isr();\n    zbus_vded_exec();\n    chan_lock(chan);\n    k_tid_t curr_thread = k_current_get();\n    k_tid_t prev_thread = chan->context.prev_thread;\n    k_tid_t next_thread = chan->context.next_thread;\n    k_tid_t notify_thread = chan->context.notify_thread;\n    k_tid_t wait_thread = chan->context.wait_thread;\n    k_tid_t notify_thread_next = chan->context.notify_thread_next;\n    k_tid_t wait_thread_next = chan->context.wait_thread_next;\n    k_tid_t notify_thread_prev = chan->context.notify_thread_prev;\n    k_tid_t wait_thread_prev = chan->context.wait_thread_prev;\n    int notify_thread_prio = chan->context.notify_thread_prio;\n    int wait_thread_prio = chan->context.wait_thread_prio;\n    k_timeout_t end_time = sys_timepoint_calc(timeout);\n    int notify_thread_prio_prev = chan->context.notify_thread_prio_prev;\n    int wait_thread_prio_prev = chan->context.wait_thread_prio_prev;\n    int notify_thread_prio_next = chan->context.notify_thread_prio_next;\n    int wait_thread_prio_next = chan->context.wait_thread_prio_next;\n    int notify_thread_prio_prev_next = chan->context.notify_thread_prio_prev_next;\n    int wait_thread_prio_prev_next = chan->context.wait_thread_prio_prev_next;\n    int notify_thread_prio_next_", "CodeBleu_score": 12.666055138588703}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    int err;\n    k_timepoint_t end_time;\n    int context_priority;\n\n    ZBUS_ASSERT(chan != NULL);\n\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    end_time = sys_timepoint_calc(timeout);\n\n    context_priority = k_curr_prio_get();\n\n    chan_lock(chan);\n\n    err = zbus_vded_exec(chan, end_time, context_priority);\n\n    chan_unlock(chan);\n\n    return err;\n}", "CodeBleu_score": 49.39476427042583}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t    int ret;\n    k_timeout_t end_time;\n    int context_priority;\n\n    if (chan == NULL) {\n        return -EINVAL;\n    }\n\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    end_time = sys_timepoint_calc(timeout);\n    context_priority = _zbus_vded_exec(chan->context);\n\n    chan_lock(chan);\n    ret = zbus_chan_notify_impl(chan, end_time, context_priority);\n    chan_unlock(chan);\n\n    return ret;\n}", "CodeBleu_score": 47.79739484522864}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  uint32_t tmpreg = 0;\n\n  assert_param(IS_ETH_INT(Int));\n\n  tmpreg = ETH->DMASR;\n\n  if (enable) {\n    if (IS_ETH_INT_ABNORMAL(Int)) {\n      ETH->DMASR |= Int;\n    } else {\n      ETH->DMASR &= ~(ETH_DMASR_RXOV | ETH_DMASR_TXUR | ETH_DMASR_RXUR);\n      ETH->DMASR |= Int;\n    }\n  } else {\n    ETH->DMASR &= ~Int;\n\n    if (ETH->DMASR & ETH_DMASR_RXOV) {\n      ETH->DMASR |= ETH_DMASR_RXOV;\n    }\n    if (ETH->DMASR & ETH_DMASR_TXUR) {\n      ETH->DMASR |= ETH_DMASR_TXUR;\n    }\n    if (ETH->DMASR & ETH_DMASR_RXUR) {\n      ETH->DMASR |= ETH_DMASR_RXUR;\n    }\n  }\n}", "CodeBleu_score": 51.231452065438575}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    uint32_t tmp = 0;\n    uint32_t itmask = 0;\n    uint32_t itmask2 = 0;\n    uint32_t itenable = 0;\n    uint32_t itpend = 0;\n\n    assert_param(IS_ETH_INT(Int));\n\n    if (enable) {\n        itmask = ETH->DMASR & Int;\n        itmask2 = ETH->DMASR & (Int >> 16);\n\n        if (IS_ETH_INT_NORMAL(Int)) {\n            itenable = ETH->DMACR;\n            if (itmask == 0) {\n                itenable |= Int;\n            }\n            tmp = itenable;\n        }\n        if (IS_ETH_INT_ABNORMAL(Int)) {\n            itenable = ETH->DMABSR;\n            if (itmask2 == 0) {\n                itenable |= (Int >> 16);\n            }\n            tmp |= (itenable << 16);\n        }\n        ETH->DMASR = tmp;\n    } else {\n        itpend = ETH->DMASR & Int;\n        itpend |= (ETH->DMASR & (Int >> 16)) << 16;\n        if (itpend != 0) {\n            ETH->DMASR = Int;\n        } else {\n            ETH->DMASR &= ~Int;\n        }\n    }\n}", "CodeBleu_score": 51.363735491192955}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  uint32_t tmp = 0;\n  uint32_t tmp_normal = 0;\n  uint32_t tmp_abnormal = 0;\n  uint32_t tmp_normal_enable = 0;\n  uint32_t tmp_abnormal_enable = 0;\n  uint32_t tmp_normal_disable = 0;\n  uint32_t tmp_abnormal_disable = 0;\n\n  assert_param(IS_ETH_INT(Int));\n\n  if (enable == TRUE) {\n    if (IS_ETH_INT_NORMAL(Int)) {\n      tmp = ETH->ETH_IER;\n      tmp |= Int;\n      ETH->ETH_IER = tmp;\n    } else {\n      tmp_normal = ETH->ETH_NISR;\n      tmp_normal_enable = tmp_normal & Int;\n      if (tmp_normal_enable != (uint32_t)RESET) {\n        tmp = ETH->ETH_IER;\n        tmp |= Int;\n        ETH->ETH_IER = tmp;\n      }\n    }\n  } else {\n    if (IS_ETH_INT_NORMAL(Int)) {\n      tmp = ETH->ETH_IER;\n      tmp &= (~Int);\n      ETH->ETH_IER = tmp;\n    } else {\n      tmp_normal = ETH->ETH_NISR;\n      tmp_normal_disable = tmp_normal & Int;\n      if (tmp_normal_disable == (uint32_t)RESET) {\n        tmp = ETH->ETH_IER;\n        tmp &= (~Int);\n        ETH->ETH_IER = tmp;\n      }\n    }\n  }\n}", "CodeBleu_score": 48.04648145878442}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t  ETH_TX_DESC *txDesc = ETH_GetCurrentTxDesc();\n  ETH_TX_DESC *startDesc = txDesc;\n\n  do {\n    if (txDesc->status & ETH_TX_STATUS_OWN) {\n      txDesc = txDesc->nextTxDescAddr;\n    } else {\n      return txDesc;\n    }\n  } while (txDesc != startDesc);\n\n  return 0;\n}", "CodeBleu_score": 44.45571191825785}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc;\n    uint32_t txDescAddr;\n\n    txDescAddr = ETH->DMADSCADDR;\n    txDesc = (ETH_TX_DESC *)txDescAddr;\n\n    while (txDesc->OWN) {\n        txDescAddr = (uint32_t)txDesc->NXTDES;\n        txDesc = (ETH_TX_DESC *)txDescAddr;\n        if (txDesc == (ETH_TX_DESC *)ETH->DMADSCADDR) {\n            return 0;\n        }\n    }\n\n    return txDesc;\n}", "CodeBleu_score": 53.273925728346214}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *desc;\n    desc = (ETH_TX_DESC *)ETH_TX_DESC_ADDRESS;\n    while (desc->OWN) {\n        desc++;\n        if (desc == (ETH_TX_DESC *)ETH_TX_DESC_ADDRESS) {\n            return 0;\n        }\n    }\n    return desc;\n}", "CodeBleu_score": 37.762118169491345}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    struct cyp_dac_device *cyp_device = (struct cyp_dac_device *)device;\n    struct cyp_dac_channel *cyp_channel = (struct cyp_dac_channel *)device->channel;\n    RT_ASSERT(cyp_channel != RT_NULL);\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_device->base, cyp_channel->channel, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"Failed to enable DAC output\");\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 55.68178828004662}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    struct cyp_dac_device *cyp_device = (struct cyp_dac_device *)device;\n    struct cyp_dac_channel *cyp_channel = &cyp_device->channels[channel];\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_channel->base, cyp_channel->channel, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"Failed to enable DAC output for channel %d\", channel);\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 56.33142250999615}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    struct cy_csdidac_device *cy_device = (struct cy_csdidac_device *)device;\n    struct cy_csdidac_channel *cy_channel = &cy_device->channels[channel];\n    if (Cy_CSDIDAC_OutputEnable(cy_channel->obj, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"Failed to enable DAC output\");\n        return -RT_ERROR;\n    }\n    return RT_EOK;\n}", "CodeBleu_score": 56.13705946591114}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > FLASH_END_ADDR) {\n        LOG_E(\"read flash outrange\");\n        return -RT_EINVAL;\n    }\n\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 46.71797036152769}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t end_addr = addr + size;\n    if (end_addr > FLASH_END_ADDRESS) {\n        LOG_E(\"Flash read operation would exceed flash memory's end address\");\n        return -EINVAL;\n    }\n\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *) (addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 46.59487539725726}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > IFX_FLASH_END_ADDR) {\n        LOG_E(\"Read flash address out of range\");\n        return -EINVAL;\n    }\n\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t*)(addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 45.303064103231584}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 31.751041619710936}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer);\n    cyhal_timer_t *cyhal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(cyhal_timer);\n}", "CodeBleu_score": 26.68826440771872}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 31.751041619710936}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    rt_err_t result;\n\n    result = rt_mutex_take(DFS_LOCK, RT_WAITING_FOREVER);\n    RT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 14.655274110298516}, {"code": "void dfs_lock(void){\n\t    rt_err_t result;\n    result = rt_mutex_take(DFS_LOCK, RT_WAITING_FOREVER);\n    RT_ASSERT(result == RT_EOK);\n}", "CodeBleu_score": 14.655274110298516}, {"code": "void dfs_lock(void){\n\t    rt_mutex_take(dfs_lock_mutex, RT_WAITING_FOREVER);\n}", "CodeBleu_score": 4.942244434243107}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n    int fd;\n\n    /* Search for an empty slot starting from the specified index */\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fds[i] == NULL) {\n            fd = i;\n            break;\n        }\n    }\n\n    /* If no empty slot is found, attempt to expand the fd table */\n    if (i == fdt->maxfd) {\n        fd = fd_slot_expand(fdt, fdt->maxfd);\n    }\n\n    return fd;\n}", "CodeBleu_score": 40.81069683542202}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fd[i] == NULL) {\n            return i;\n        }\n    }\n\n    if (fdt->maxfd == NR_OPEN) {\n        return -1;\n    }\n\n    if (fd_slot_expand(fdt, fdt->maxfd + 1) == -1) {\n        return -1;\n    }\n\n    return i;\n}", "CodeBleu_score": 42.22084452761921}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int i;\n\n    for (i = startfd; i < fdt->size; i++) {\n        if (fdt->fds[i] == NULL) {\n            return i;\n        }\n    }\n\n    if (fd_slot_expand(fdt) == 0) {\n        return fd_slot_alloc(fdt, startfd);\n    }\n\n    return -1;\n}", "CodeBleu_score": 39.10517116747321}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    int i;\n    if (error < 0) {\n        error = -error;\n    }\n    for (i = 0; i < sizeof(rt_errlist) / sizeof(rt_errlist[0]); i++) {\n        if (rt_errlist[i].err_code == error) {\n            return rt_errlist[i].err_msg;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 71.85789687970103}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n\n    for (int i = 0; i < sizeof(rt_err_str) / sizeof(rt_err_str[0]); i++) {\n        if (rt_err_str[i].code == error) {\n            return rt_err_str[i].str;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 65.52836214633165}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (size_t i = 0; i < sizeof(rt_errors) / sizeof(rt_errors[0]); i++) {\n        if (rt_errors[i].code == error) {\n            return rt_errors[i].message;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 65.00746331955133}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_uint32_t i;\n\n    rt_spin_lock_irqsave(&idle_lock, level);\n    for (i = 0; i < RT_THREAD_HOOK_MAX; i++) {\n        if (idle_hook[i] == RT_NULL) {\n            idle_hook[i] = hook;\n            rt_spin_unlock_irqrestore(&idle_lock, level);\n            return RT_EOK;\n        }\n    }\n    rt_spin_unlock_irqrestore(&idle_lock, level);\n    return -RT_EFULL;\n}", "CodeBleu_score": 60.489262466178516}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_spinlock_t *lock;\n    rt_uint32_t i;\n\n    lock = &idle_hook_lock;\n    rt_spin_lock_irqsave(lock);\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n        if (idle_hook[i] == RT_NULL) {\n            idle_hook[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n    if (i == RT_THREAD_IDLE_HOOK_MAX) {\n        result = -RT_EFULL;\n    }\n    rt_spin_unlock_irqrestore(lock);\n    return result;\n}", "CodeBleu_score": 64.6707978692499}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_int32_t index;\n    rt_base_t level;\n\n    /* Lock the spinlock to ensure thread safety */\n    level = rt_hw_interrupt_disable();\n\n    /* Iterate through the idle hook list to find an empty slot */\n    for (index = 0; index < RT_THREAD_IDLE_HOOK_MAX; index++) {\n        if (rt_thread_idle_hook[index] == RT_NULL) {\n            /* Assign the hook to the empty slot */\n            rt_thread_idle_hook[index] = hook;\n\n            /* Release the spinlock and return success */\n            rt_hw_interrupt_enable(level);\n            return RT_EOK;\n        }\n    }\n\n    /* Release the spinlock and return failure */\n    rt_hw_interrupt_enable(level);\n    return -RT_EFULL;\n}", "CodeBleu_score": 54.882531904376506}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_list_t *node;\n    rt_uint8_t ret = RT_ERROR;\n    RT_ASSERT(hook != RT_NULL);\n    rt_spin_lock_irqsave(&rt_idle_hook_list.lock, &level);\n    node = rt_idle_hook_list.head;\n    while (node != RT_NULL) {\n        if (node->hook == hook) {\n            node->hook = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n        node = node->next;\n    }\n    rt_spin_unlock_irqrestore(&rt_idle_hook_list.lock, level);\n    return ret;\n}", "CodeBleu_score": 51.38083370583448}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_list_t *node;\n    rt_uint32_t i;\n    rt_err_t result = -RT_ERROR;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    rt_spin_lock_irqsave(&idle_hook_lock, &i);\n\n    node = rt_list_find(&idle_hook_list, (void *)hook);\n    if (node != RT_NULL) {\n        rt_list_remove(&idle_hook_list, node);\n        result = RT_EOK;\n    }\n\n    rt_spin_unlock_irqrestore(&idle_hook_lock, i);\n\n    return result;\n}", "CodeBleu_score": 35.76714606127681}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_list_t *node;\n    rt_err_t result = -RT_ERROR;\n\n    level = rt_hw_interrupt_disable();\n    node = rt_list_find(&idle_hook_list, hook);\n    if (node) {\n        rt_list_remove(&idle_hook_list, node);\n        result = RT_EOK;\n    }\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 29.225361835132674}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_err_t result;\n\n    rt_sched_lock();\n\n    while (susp_list->next != susp_list) {\n        rt_thread_t *thread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n        rt_list_remove(&thread->tlist);\n        thread->error = thread_error;\n        thread->stat = RT_THREAD_READY;\n        result = rt_thread_resume(thread);\n        if (result != RT_EOK) {\n            return result;\n        }\n    }\n\n    rt_sched_unlock();\n\n    return RT_EOK;\n}", "CodeBleu_score": 30.51868695898844}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_base_t level;\n    rt_thread_t thread;\n\n    level = rt_hw_interrupt_disable();\n\n    while (!rt_list_isempty(susp_list)) {\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n        rt_thread_resume(thread);\n        thread->error = thread_error;\n        rt_schedule();\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.557166535279514}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    rt_err_t result = RT_EOK;\n\n    rt_enter_critical();\n    rt_scheduler_unlock();\n\n    while (!rt_list_isempty(susp_list)) {\n        thread = rt_susp_list_dequeue(susp_list, thread_error);\n        if (thread != RT_NULL) {\n            result = rt_thread_resume(thread);\n        }\n    }\n\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 47.56220512993503}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = rt_console;\n    if (rt_strcmp(name, RT_CONSOLE_DEVICE_NAME) == 0) {\n        return old_console;\n    }\n    rt_device_t new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        return old_console;\n    }\n    if (new_console == old_console) {\n        return old_console;\n    }\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n    rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    rt_console = new_console;\n    return old_console;\n}", "CodeBleu_score": 55.8470146162587}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device = rt_console;\n    if (rt_strcmp(name, RT_CONSOLE_DEVICE_NAME) == 0) {\n        return old_device;\n    }\n    rt_device_t new_device = rt_device_find(name);\n    if (new_device == RT_NULL) {\n        return old_device;\n    }\n    if (old_device != new_device) {\n        if (old_device != RT_NULL) {\n            rt_device_close(old_device);\n        }\n        rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        rt_console = new_device;\n    }\n    return old_device;\n}", "CodeBleu_score": 69.94967186192184}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = rt_console;\n    rt_device_t new_console = rt_device_find(name);\n\n    if (new_console != RT_NULL) {\n        if (new_console != old_console) {\n            if (old_console != RT_NULL) {\n                rt_device_close(old_console);\n            }\n            rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n            rt_console = new_console;\n        }\n    }\n    return old_console;\n}", "CodeBleu_score": 58.40104479233222}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object_information *info;\n    unsigned long flags;\n\n    info = rt_object_get_information(type);\n    if (!info) {\n        return -1;\n    }\n\n    rt_spin_lock_irqsave(&info->lock, flags);\n\n    struct rt_object *object = info->object_list.next;\n    while (object != &info->object_list) {\n        count++;\n        object = object->list.next;\n    }\n\n    rt_spin_unlock_irqrestore(&info->lock, flags);\n\n    return count;\n}", "CodeBleu_score": 47.60076287574314}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object_information *info;\n    int count = 0;\n\n    info = rt_object_get_information(type);\n    if (!info) {\n        return -1;\n    }\n\n    rt_spin_lock_irqsave(&info->lock, flags);\n\n    rt_list_for_each(node, &info->object_list) {\n        count++;\n    }\n\n    rt_spin_unlock_irqrestore(&info->lock, flags);\n\n    return count;\n}", "CodeBleu_score": 42.009044179098744}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object_information *info;\n    int count;\n\n    info = rt_object_get_information(type);\n    if (info == NULL) {\n        return -1;\n    }\n\n    rt_spin_lock_irqsave(&info->lock, flags);\n    count = 0;\n    rt_list_for_each(pos, &info->object_list) {\n        count++;\n    }\n    rt_spin_unlock_irqrestore(&info->lock, flags);\n\n    return count;\n}", "CodeBleu_score": 40.22470092556459}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    RT_ASSERT(object != RT_NULL);\n\n    rt_object_information_t info = object->information;\n\n    rt_spinlock_t *lock = &(info->lock);\n\n    rt_spin_lock_irqsave(lock, &lock_flag);\n\n    rt_list_remove(&(info->object_list));\n\n    rt_spin_unlock_irqrestore(lock, lock_flag);\n\n    object->type = 0;\n}", "CodeBleu_score": 33.32282033679262}, {"code": "void rt_object_detach(rt_object_t object){\n\t    RT_ASSERT(object != RT_NULL);\n\n    /* call object hook */\n    RT_OBJECT_HOOK_CALL(detach, object);\n\n    struct rt_object_information *information = object->information;\n\n    /* lock object */\n    rt_spin_lock_irqsave(&information->lock, flag);\n\n    /* remove object */\n    rt_list_remove(&information->object_list, &object->list);\n\n    /* unlock object */\n    rt_spin_unlock_irqrestore(&information->lock, flag);\n\n    /* set object type */\n    object->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 45.5901691612199}, {"code": "void rt_object_detach(rt_object_t object){\n\t    RT_ASSERT(object != RT_NULL);\n\n    rt_object_information_t info = rt_object_get_information(object);\n\n    rt_spinlock_t *lock = &(info->lock);\n\n    rt_spin_lock_irqsave(lock);\n    rt_list_remove(&(info->object_list));\n    rt_spin_unlock_irqrestore(lock);\n\n    info->type = 0;\n\n    RT_OBJECT_HOOK_CALL(detach, object);\n}", "CodeBleu_score": 38.888818517757215}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_OK;\n    rt_custom_object_t cobj = (rt_custom_object_t)obj;\n    if (cobj != RT_NULL) {\n        if (cobj->destroy != RT_NULL) {\n            result = cobj->destroy(cobj);\n        }\n        rt_object_delete(obj);\n    }\n    return result;\n}", "CodeBleu_score": 47.41461970524984}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_custom_object_t cobj = (rt_custom_object_t)obj;\n    rt_err_t res = RT_OK;\n\n    if (cobj == NULL) {\n        return RT_ERR_INVALID_ARG;\n    }\n\n    if (cobj->class != RT_CUSTOM_OBJECT_CLASS) {\n        return RT_ERR_INVALID_CLASS;\n    }\n\n    if (cobj->destroy != NULL) {\n        res = cobj->destroy(cobj);\n    }\n\n    rt_object_delete(cobj);\n\n    return res;\n}", "CodeBleu_score": 49.017305472491834}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_custom_object_t cobj = (rt_custom_object_t)obj;\n    rt_err_t res = RT_OK;\n    if (cobj && cobj->class->destroy) {\n        res = cobj->class->destroy(cobj);\n    }\n    rt_object_delete(obj);\n    return res;\n}", "CodeBleu_score": 34.750005317504915}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t  rt_thread_t thread = rt_thread_self();\n\n  rt_enter_critical();\n  rt_thread_close(thread);\n  rt_exit_critical_safe();\n\n  rt_schedule();\n}", "CodeBleu_score": 27.46987891397214}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n\n    thread = rt_thread_self();\n\n    rt_enter_critical();\n    rt_thread_close(thread);\n    rt_exit_critical_safe();\n\n    rt_schedule();\n}", "CodeBleu_score": 34.43224974146622}, {"code": "static void _thread_exit(void){\n\t  rt_thread_t thread = rt_thread_self();\n  rt_enter_critical();\n  rt_thread_close(thread);\n  rt_exit_critical_safe();\n  rt_schedule();\n}", "CodeBleu_score": 27.46987891397214}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n    RT_ASSERT(parameter != RT_NULL);\n    thread = (struct rt_thread *)parameter;\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n    thread->error = -RT_ETIMEOUT;\n    thread->stat = RT_THREAD_READY;\n    rt_sched_lock();\n    rt_list_remove(&(thread->list));\n    rt_sched_insert_thread(thread);\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 54.81773691440658}, {"code": "static void _thread_timeout(void *parameter){\n\t    rt_thread_t thread;\n\n    thread = (rt_thread_t)parameter;\n    RT_ASSERT(thread != RT_NULL);\n\n    /* lock scheduler */\n    rt_sched_lock();\n\n    /* check the thread is suspended */\n    RT_ASSERT(rt_sched_thread_is_suspended(thread));\n\n    /* set the thread's error number to timeout */\n    thread->error = -RT_ETIMEOUT;\n\n    /* remove the thread from suspend list */\n    rt_list_remove(&(thread->tlist));\n\n    /* insert the thread into ready list */\n    rt_sched_insert_thread(thread);\n\n    /* unlock scheduler to reschedule */\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 48.59262131264832}, {"code": "static void _thread_timeout(void *parameter){\n\t    struct rt_thread *thread;\n\n    thread = (struct rt_thread *)parameter;\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);\n\n    rt_sched_lock();\n    thread->error = -RT_ETIMEOUT;\n    rt_list_remove(&(thread->list));\n    rt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]), &(thread->list));\n    rt_sched_unlock_n_resched();\n}", "CodeBleu_score": 57.599986619538036}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_err_t result;\n    rt_list_t list;\n    rt_mutex_t mutex;\n    rt_uint8_t *level_p;\n\n    /* Get the thread's spinlock */\n    level_p = &thread->spinlock_level;\n\n    /* Lock the spinlock */\n    rt_spin_lock_irqsave(level_p);\n\n    /* Check if the thread is waiting on a mutex */\n    if (thread->pending_obj != RT_NULL) {\n        /* Get the mutex from the pending object */\n        mutex = (rt_mutex_t)thread->pending_obj;\n\n        /* Remove the thread from the mutex's waiting list */\n        rt_list_remove(&mutex->wait_list, &thread->tlist);\n\n        /* Clear the pending object */\n        thread->pending_obj = RT_NULL;\n\n        /* Release the mutex */\n        result = rt_mutex_release(mutex);\n        if (result != RT_EOK) {\n            /* Handle error */\n        }\n    }\n\n    /* Release all mutexes the thread has taken */\n    rt_list_for_each_safe(list, &thread->mutex_list) {\n        /* Get the mutex from the list entry */\n        mutex = rt_list_entry(list, struct rt_mutex, tlist);\n\n        /* Release the mutex */\n        result = rt_mutex_release(mutex);\n        if (result != RT_EOK) {\n            /* Handle error */\n        }\n    }\n\n    /* Restore the spinlock state */\n    rt_spin_unlock_irqrestore(level_p);\n}", "CodeBleu_score": 53.3110834847391}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_base_t level;\n    rt_mutex_t mutex;\n\n    level = rt_hw_interrupt_disable();\n\n    /* check if the thread is waiting on a mutex */\n    mutex = thread->pending_mutex;\n    if (mutex) {\n        /* remove the thread from the mutex's waiting list */\n        rt_list_remove(&thread->tlist);\n        thread->pending_mutex = RT_NULL;\n        thread->pending_obj = RT_NULL;\n\n        /* release all mutexes the thread has taken */\n        _thread_release_mutex(thread);\n    }\n\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 23.47067693697836}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_err_t result;\n    rt_list_t list;\n    rt_mutex_t mutex;\n\n    /* Lock the thread's spinlock */\n    rt_spin_lock_irqsave(&thread->spinlock, result);\n\n    /* Check if the thread is waiting on a mutex */\n    if (thread->pending_object != RT_NULL) {\n        /* Get the mutex from the pending object */\n        mutex = (rt_mutex_t)thread->pending_object;\n\n        /* Remove the thread from the mutex's waiting list */\n        rt_list_for_each_safe(list, &mutex->wait_list) {\n            if (list->owner == thread) {\n                rt_list_remove(list);\n                break;\n            }\n        }\n\n        /* Clear the pending object */\n        thread->pending_object = RT_NULL;\n    }\n\n    /* Release all mutexes the thread has taken */\n    rt_mutex_release(thread);\n\n    /* Restore the spinlock state */\n    rt_spin_unlock_irqrestore(&thread->spinlock, result);\n}", "CodeBleu_score": 42.82069830646654}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->current_priority == -1);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type(thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup, name:%s, tick:%d, period:%d\",\n          thread->name,\n          thread->init_tick,\n          thread->init_priority);\n\n    /* set thread priority */\n    thread->current_priority = thread->init_priority;\n    thread->number_mask = 1L << thread->current_priority;\n    thread->priority_changed = 0;\n\n    /* reset thread error number */\n    thread->error = RT_EOK;\n\n    /* set thread state to suspended */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    rt_thread_resume(thread);\n\n    /* trigger scheduler */\n    if (rt_scheduler_get_rr_thread() == RT_NULL) {\n        rt_scheduler_rr_get();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 51.56585119680479}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type(thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup, name:%s, tid:%d, prio:%d\", thread->name, thread->tid, thread->current_priority);\n\n    /* calculate thread priority attributes */\n    thread->priority_bitmap = (1 << thread->current_priority);\n    thread->priority_bitmap |= thread->priority_bitmap - 1;\n    thread->priority_bitmap = ~thread->priority_bitmap;\n\n    /* reset thread state */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    rt_thread_resume(thread);\n\n    /* trigger scheduler */\n    if (rt_scheduler_get_rr_thread() == RT_NULL) {\n        rt_scheduler_rr_get();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 53.085629209007024}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->current_priority == -1);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type(thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"Thread %s started. Priority: %d\", thread->name, thread->init_priority);\n\n    thread->current_priority = thread->init_priority;\n    thread->number_mask = 1 << thread->current_priority;\n    thread->stat = RT_THREAD_SUSPEND;\n\n    rt_thread_resume(thread);\n\n    if (rt_scheduler_get_rr_thread() == RT_NULL) {\n        rt_scheduler_startup(thread);\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 54.13067770530595}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *list = &timer_list[0];\n    if (rt_list_isempty(list)) {\n        return -RT_ERROR;\n    }\n    rt_timer_t *timer = rt_list_entry(list->next, struct rt_timer, list);\n    *timeout_tick = timer->timeout;\n    return RT_EOK;\n}", "CodeBleu_score": 31.13961455099212}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *entry;\n\n    /* Check if the highest level of the timer skip list is not empty */\n    if (rt_list_isempty(&timer_list[0])) {\n        return -RT_ETIMEOUT;\n    }\n\n    /* Get the first timer entry */\n    entry = rt_list_entry(timer_list[0].next, struct rt_timer, list);\n\n    /* Set the provided timeout tick to the timer's timeout value */\n    *timeout_tick = entry->timeout;\n\n    return RT_EOK;\n}", "CodeBleu_score": 37.001574220355046}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *list;\n    rt_timer_t *timer;\n\n    if (rt_list_isempty(&timer_list[0]))\n        return -RT_ETIMEOUT;\n\n    list = rt_list_first(&timer_list[0]);\n    timer = rt_list_entry(list, struct rt_timer, list);\n    *timeout_tick = timer->timeout;\n\n    return RT_EOK;\n}", "CodeBleu_score": 46.46909167449649}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n\n    timer = (rt_timer_t)rt_object_allocate(sizeof(struct rt_timer),\n                                            RT_Object_Class_Timer);\n    if (timer != RT_NULL) {\n        /* initialize timer */\n        rt_timer_init(timer, name, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}", "CodeBleu_score": 57.35042378309291}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    /* allocate memory for the timer object */\n    rt_timer_t timer = (rt_timer_t)rt_object_allocate(sizeof(struct rt_timer),\n                                                      RT_Object_Class_Timer);\n    if (timer != RT_NULL) {\n        /* initialize the timer */\n        rt_timer_init(timer, name, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}", "CodeBleu_score": 52.32901451363412}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate memory for the timer object */\n    timer = (rt_timer_t)rt_object_allocate(sizeof(struct rt_timer),\n                                           RT_Object_Class_Timer);\n    if (timer != RT_NULL) {\n        /* initialize the timer object */\n        rt_timer_init(timer, name, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}", "CodeBleu_score": 57.34926873113997}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 60.65462504923077}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\thandler := a.router\n\thandler.ServeHTTP(rec, req)\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 70.46630417359714}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\n\t\trec.Header().Del(\"Content-Type\")\n\t\trec.Header().Del(\"Date\")\n\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 85.53926549170876}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := a.Asset(req.URL.Path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tswitch {\n\tcase strings.HasSuffix(req.URL.Path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase strings.HasSuffix(req.URL.Path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(req.URL.Path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 56.04992341902031}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := a.Asset(req.URL.Path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch {\n\tcase strings.HasSuffix(req.URL.Path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase strings.HasSuffix(req.URL.Path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(req.URL.Path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tdefault:\n\t\tres.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t}\n\n\t_, err = res.Write(asset)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}", "CodeBleu_score": 62.425225140237586}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tasset, err := a.Asset(req.URL.Path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch {\n\tcase strings.HasSuffix(req.URL.Path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase strings.HasSuffix(req.URL.Path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(req.URL.Path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t_, err = res.Write(asset)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 58.1594174676038}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\trobot := a.master.Robot(robotName)\n\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, JSON{\n\t\t\t\"error\": \"no robot with name \" + robotName + \" found\",\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := []JSON{}\n\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\tconnections = append(connections, JSON{\n\t\t\t\"name\":    connection.Name(),\n\t\t\t\"adaptor\": connection.GetAdaptor().Name(),\n\t\t\t\"source\":  connection.GetSource().Name(),\n\t\t\t\"dest\":    connection.GetDest().Name(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, http.StatusOK, JSON{\n\t\t\"robot\":       robotName,\n\t\t\"connections\": connections,\n\t})\n}", "CodeBleu_score": 50.50560529135162}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, JSON{\n\t\t\t\"error\": fmt.Sprintf(\"robot with name %q not found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := []*gobot.Connection{}\n\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\tconnections = append(connections, &connection)\n\t})\n\n\ta.writeJSON(res, http.StatusOK, JSON{\n\t\t\"connections\": connections,\n\t})\n}", "CodeBleu_score": 51.7592293413743}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"name\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, JSON{\n\t\t\t\"error\": fmt.Sprintf(\"robot with name %q not found\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := []JSON{}\n\trobot.Connections().Each(func(connection gobot.Connection) {\n\t\tconnections = append(connections, JSON{\n\t\t\t\"name\":    connection.Name(),\n\t\t\t\"adaptor\": connection.GetAdaptor().Name(),\n\t\t})\n\t})\n\n\ta.writeJSON(res, http.StatusOK, JSON{\n\t\t\"robot\":      robotName,\n\t\t\"connections\": connections,\n\t})\n}", "CodeBleu_score": 49.73195651357721}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauth := strings.SplitN(authHeader, \" \", 2)\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair) != 2 || !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.971041343193}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\treqUsername, reqPassword, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(username, reqUsername) || !secureCompare(password, reqPassword) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Please enter your username and password for this site\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 54.993276215273454}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\treqUsername, reqPassword, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(reqUsername, username) || !secureCompare(reqPassword, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Please enter your username and password for this site\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Your handler logic here\n\t}\n}", "CodeBleu_score": 53.06205334857664}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.63205197792933}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tscale := (toMax - toMin) / (fromMax - fromMin)\n\toffset := toMin - fromMin*scale\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(input*scale + offset)\n\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn value\n\t}\n}", "CodeBleu_score": 52.66490043166432}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept for the scaling transformation\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\t// Create a function that performs the scaling\n\tscaler := func(input float64) (value int) {\n\t\t// Apply the scaling transformation\n\t\tvalue = int(slope*input + intercept)\n\n\t\t// Clamp the output value within the target range\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn value\n\t}\n\n\treturn scaler\n}", "CodeBleu_score": 51.32961812757597}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor has been removed\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\traw = int(gobot.ToScale(gobot.FromScale(float64(raw), 0, 1024), 0, 1024))\n\tscaled := gobot.ToScale(gobot.FromScale(float64(raw), 0, 1024), 0, 1024)\n\n\ta.lastRaw = raw\n\ta.lastValue = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 53.35518239678172}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0.0, fmt.Errorf(\"analog sensor has been removed\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\ta.lastRaw = raw\n\tscaled, err := a.Scale(float64(raw))\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\ta.lastValue = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 46.061985210017845}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.Connection() == nil {\n\t\treturn 0, 0, fmt.Errorf(\"AnalogSensorDriver %v not connected\", a.Name())\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastValue = float64(raw) * a.sensorCfg.scale\n\treturn raw, a.lastValue, nil\n}", "CodeBleu_score": 56.11012375817478}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 50.014168640519465}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(input int) float64 {\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 54.37277789197652}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\n\treturn func(input int) float64 {\n\t\treturn m * float64(input) + n\n\t}\n}", "CodeBleu_score": 52.72203710343628}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, 1*time.Second, opts...)\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\td.AddEvent(Vibration)\n\n\tif err := d.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: d,\n\t}\n}", "CodeBleu_score": 63.39889668935705}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 1*time.Second, opts...),\n\t\tEventer:           gobot.NewEventer(),\n\t}\n\n\td.AddEvent(Vibration)\n\n\tgobot.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 50.179220859027716}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, 1*time.Second, opts...)\n\td.AddEvent(Vibration)\n\td.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\"))\n\n\td.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 54.31265174780242}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\td.p.Lock()\n\tdefer d.p.Unlock()\n\n\ttonePeriod := int64(1000000 / hz)\n\ttempo := int64(600000 / d.bpm)\n\n\td.On()\n\ttime.Sleep(time.Duration(tonePeriod/2) * time.Microsecond)\n\td.Off()\n\ttime.Sleep(time.Duration(tonePeriod/2) * time.Microsecond)\n\n\tfor i := 0; i < int(duration*1000000/float64(tempo)); i++ {\n\t\td.On()\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Microsecond)\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Microsecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 32.70808004820033}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := uint64(1000000.0 / hz)\n\ttempo := uint64(60.0 * 1000000.0 / d.bpm)\n\tsteps := uint64(duration/(tempo/1000000.0)) + 1\n\n\td.On()\n\tfor i := uint64(0); i < steps; i++ {\n\t\ttime.Sleep(time.Duration(tempo))\n\t\td.Off()\n\t\ttime.Sleep(time.Duration(tempo))\n\t\td.On()\n\t}\n\td.Off()\n\n\treturn nil\n}", "CodeBleu_score": 35.02919180851784}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := int(1000000 / hz)\n\ttempo := 60 / d.bpm\n\tsteps := int(duration/1000/tempo) - 1\n\n\tfor i := 0; i < steps; i++ {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 69.50209539994302}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.stopIfRunning()\n\td.sleepPin.Low()\n\td.isSleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.77240270918952}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.stopIfRunning()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.675466392120484}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\n\td.stopIfRunning()\n\td.sleepPin.Low()\n\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 31.047270859026366}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Must initialize pins before use\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, pin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnewPin := sys.NewAnalogPin(path, pin)\n\ta.pins[id] = newPin\n\treturn newPin, nil\n}", "CodeBleu_score": 52.79138390323398}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Must initialize analog pins before use\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpath, pin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = sys.NewAnalogPin(path, pin)\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 53.90849990155554}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"analogPin: no pins map initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, pin, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = a.sys.NewAnalogPin(path, pin)\n\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 56.27856743270681}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsystem.WithPinDirectionOutput(pin)\n\treturn pin.Write(val)\n}", "CodeBleu_score": 69.56783489561688}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(int(val))\n}", "CodeBleu_score": 76.385731078308}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := system.WithPinDirectionOutput(id, a.i2c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 69.16208461944977}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"No pins are registered\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = a.sys.NewDigitalPin(chip, line)\n\t\tif pin == nil {\n\t\t\treturn nil, fmt.Errorf(\"Error creating new digital pin for chip %d and line %d\", chip, line)\n\t\t}\n\n\t\ta.pins[id] = pin\n\t}\n\n\tpin.ApplyOptions(opts...)\n\n\treturn pin, nil\n}", "CodeBleu_score": 55.000454202058236}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"Not connected to any pins\")\n\t}\n\topts = append(a.digitalPinOptions, opts...)\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = a.sys.NewDigitalPin(chip, line)\n\t\tif err := a.initialize(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = pin\n\t}\n\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\treturn nil, err\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 63.92040841932506}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"No pins available\")\n\t}\n\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tchip, line, err := a.translate(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = a.sys.NewDigitalPin(chip, line)\n\t\tif pin == nil {\n\t\t\treturn nil, fmt.Errorf(\"Error creating digital pin\")\n\t\t}\n\t\ta.pins[id] = pin\n\t}\n\n\tpin.ApplyOptions(opts...)\n\n\tif err := a.initialize(pin); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 64.49633202066663}]}
