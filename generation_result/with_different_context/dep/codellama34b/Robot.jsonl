{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Retrieve the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n    if (download) {\n      for (auto &file : required_files) {\n        // Check if the file exists locally\n        if (!FileTransfer::FileExists(file)) {\n          // Request the file from the server and log the download action\n          RequestFile(file);\n          Log::Info(\"Downloaded file '\" + file + \"'\");\n        } else {\n          // Log that the file is found in the cache\n          Log::Info(\"Found file '\" + file + \"' in cache\");\n        }\n      }\n    }\n    return required_files;\n  }", "CodeBleu_score": 68.07987563366851}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // If the download flag is set to true, check if each file exists locally\n    if (download) {\n      // For each file in the list\n      for (const auto &file : required_files) {\n        // If the file does not exist locally\n        if (!FileTransfer::FileExists(file)) {\n          // Request the file and log the download action\n          RequestFile(file);\n          Logger::Log(file + \" downloaded\", true);\n        }\n        // Otherwise, log that the file is found in the cache\n        else Logger::Log(file + \" found in cache\", true);\n      }\n    }\n\n    // Return the list of required files\n    return required_files;\n  }", "CodeBleu_score": 65.71077134964484}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files from the server\n  auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n  // Check if each file exists locally\n  if (download) {\n    for (auto it = files.begin(); it != files.end(); ++it) {\n      // Check if the file exists\n      if (!FileTransfer::FileExists(*it)) {\n        // Request the file\n        RequestFile(*it);\n        // Log the download action\n        _pimpl->LogDownload(*it);\n      }\n      else {\n        // Log the file found in the cache\n        _pimpl->LogCache(*it);\n      }\n    }\n  }\n\n  return files;\n}", "CodeBleu_score": 57.974585913371094}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tREQUIRE_CARLA_EPISODE();\n  return episode_proxy_->SpawnActorWithParent(\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}", "CodeBleu_score": 25.88385416167256}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t// TODO: check if parent is a null pointer\n  // TODO: check if parent is a RigidActor\n  // TODO: check if parent is dynamic\n  // TODO: check if parent is kinematic\n  // TODO: check if parent is static\n  // TODO: check if parent is a Walker\n  // TODO: check if parent is a Vehicle\n  // TODO: check if parent is a TrafficSign\n  // TODO: check if parent is a TrafficLight\n  // TODO: check if parent is a Simulation\n  // TODO: check if parent is a Controller\n  // TODO: check if parent is a Camera\n  // TODO: check if parent is a Lidar\n  // TODO: check if parent is a Gnss\n  // TODO: check if parent is a IMU\n  // TODO: check if parent is a Radar\n  // TODO: check if parent is a CollisionObject\n  // TODO: check if parent is a TrafficLightManager\n  // TODO: check if parent is a TrafficLightGroup\n  // TODO: check if parent is a TrafficLightState\n  // TODO: check if parent is a TrafficLightCycle\n  // TODO: check if parent is a TrafficLightStage\n  // TODO: check if parent is a TrafficLightSignal\n  // TODO: check if parent is a TrafficLightController\n  // TODO: check if parent is a TrafficLightGroupController\n  // TODO: check if parent is a TrafficLightManager\n  // TODO: check if parent is a TrafficLight\n  // TODO: check if parent is a TrafficLightGroup\n  // TODO: check if parent is a TrafficLightState\n  // TODO: check if parent is a TrafficLightCycle\n  // TODO: check if parent is a TrafficLightStage\n  // TODO: check if parent is a TrafficLightSignal\n  // TODO: check if parent is a TrafficLightController\n  // TODO: check if parent is a TrafficLightGroupController\n  // TODO: check if parent is a TrafficLightManager\n  // TODO: check if parent is a TrafficLight\n  // TODO: check if parent is a TrafficLightGroup\n  // TODO: check if parent is a TrafficLightState\n  // TODO: check if parent is a", "CodeBleu_score": 8.448293765341496}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t// If the attachment type is SpringArm or SpringArmGhost,\n  // check the validity of the transformation to avoid ill-formed\n  // transformations when the translation is only in the 'z' axis.\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f) {\n      log_warning(\n          \"A SpringArm or SpringArmGhost attachment was spawned with a \"\n          \"translation with only a z value. This is usually a mistake. \"\n          \"Please use a translation with x and y values as well.\");\n    }\n  }\n  // Call the internal function to complete the actor spawning process.\n  return SpawnActorImpl(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 43.12798256303012}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the token\n   auto token = GetGBufferToken(ActorId, GBufferId);\n\n   // Copy the token\n   auto token_data = CopyToken(token);\n\n   // Subscribe to the streaming client\n   SubscribeToStreamingClient(token_data, callback);\n}", "CodeBleu_score": 32.482073555196436}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Retrieve a token for the G-buffer.\n   auto token = GetGBufferToken(ActorId, GBufferId);\n\n   // Copy the token data.\n   Buffer buffer;\n   buffer.data = std::make_unique<char[]>(token.size());\n   buffer.size = token.size();\n   std::memcpy(buffer.data.get(), token.data(), token.size());\n\n   // Subscribe to the streaming client using the provided callback function.\n   SubscribeToStream(\n         buffer,\n         std::move(callback));\n}", "CodeBleu_score": 45.13945966544626}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Retrieve the token for the G-buffer.\n    auto token = GetToken(ActorId, GBufferId);\n\n    // Copy the token data.\n    auto token_data = token.GetData();\n\n    // Subscribe to the streaming client using the provided callback function.\n    _streaming_client->Subscribe(token_data, callback);\n}", "CodeBleu_score": 35.671636885526446}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> nav = GetNavigation();\n  if (nav == nullptr) {\n    nav = std::make_shared<WalkerNavigation>(GetActorRegistry());\n    SetNavigation(nav);\n  }\n  return nav;\n}", "CodeBleu_score": 43.41280815761922}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> walker_nav = GetWalkerNavigation();\n  if (walker_nav == nullptr) {\n    walker_nav = std::make_shared<WalkerNavigation>();\n    SetWalkerNavigation(walker_nav);\n  }\n  return walker_nav;\n}", "CodeBleu_score": 40.73250534266775}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = GetNavigation();\n  if (!navigation) {\n    navigation = std::make_shared<WalkerNavigation>(*this);\n    SetNavigation(navigation);\n  }\n  return navigation;\n}", "CodeBleu_score": 34.48334250463995}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\ttime_point start_time = time_now();\n  while (episode.GetFrame() < frame) {\n    if ((time_now() - start_time) > timeout) {\n      return false;\n    }\n    this_thread::yield();\n  }\n  episode.Tick(frame);\n  return true;\n}", "CodeBleu_score": 28.48096212042568}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\ttime_point start_time = time_now();\n    time_duration elapsed_time = time_duration::zero();\n    while (episode.GetFrame() < frame) {\n        if (elapsed_time > timeout) {\n            return false;\n        }\n        this_thread::yield();\n        elapsed_time = time_now() - start_time;\n    }\n    episode.Tick(elapsed_time.to_chrono_microseconds());\n    return true;\n}", "CodeBleu_score": 35.06834983281256}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\ttime_point start_time = time_now();\n  time_duration time_since_start;\n  while (episode.GetCurrentFrame() < frame) {\n    if ((time_since_start = time_now() - start_time) > timeout) {\n      return false;\n    }\n    this_thread::yield();\n  }\n  episode.Tick(time_since_start.to_chrono_microseconds().count());\n  return true;\n}", "CodeBleu_score": 34.233411362950164}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tauto map = _client.get_world().get_map();\n    if (map_name.empty()) {\n      map_name = map->get_name();\n    }\n    auto settings = _client.get_world().get_settings();\n    if (reset_settings) {\n      _client.get_world().apply_settings(settings);\n    }\n    _client.set_timeout_seconds(10u);\n    _client.LoadEpisode(map_name, map_layers);\n    _client.set_timeout_seconds(DEFAULT_TIMEOUT);\n    return GetCurrentEpisode();\n  }", "CodeBleu_score": 36.4720045747586}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tauto client = _client.lock();\n    if (!client) {\n      throw_exception(std::runtime_error(\"Client is not initialized.\"));\n    }\n\n    if (map_name.empty()) {\n      throw_exception(std::invalid_argument(\"Invalid map name.\"));\n    }\n\n    // get the current episode id\n    auto episode_id = GetEpisodeId();\n\n    // load the new episode\n    client->LoadEpisode(map_name, reset_settings, map_layers);\n\n    // wait for the new episode to be loaded\n    const uint32_t MAX_ATTEMPTS = 10;\n    for (uint32_t i = 0; i < MAX_ATTEMPTS; ++i) {\n      auto new_episode_id = GetEpisodeId();\n      if (new_episode_id != episode_id) {\n        GetReadyCurrentEpisode();\n        return EpisodeProxy{shared_from_this()};\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n\n    throw_exception(std::runtime_error(\"Failed to connect to new episode.\"));\n}", "CodeBleu_score": 49.94304507105998}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tauto episode = GetCurrentEpisode();\n    if (episode.GetMapName() != map_name) {\n        episode.LoadNewEpisode(map_name);\n    }\n    episode.SetMapLayer(map_layers);\n    episode.ResetSettings(reset_settings);\n    return episode;\n}", "CodeBleu_score": 27.224584281438446}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tauto walker = GetWalker(controller.GetWalkerID());\n    if (!walker) {\n        throw std::invalid_argument(\"Walker not found\");\n    }\n\n    if (!_episode) {\n        throw std::runtime_error(\"Episode not found\");\n    }\n\n    if (!_navigation) {\n        _navigation = std::make_shared<Navigation>();\n    }\n\n    _navigation->RegisterWalker(walker);\n    _ai_controllers.emplace(controller.GetID(), controller);\n}", "CodeBleu_score": 47.91071856578281}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tauto walker = GetWalker(controller.GetWalkerID());\n    if (walker == nullptr) {\n        throw std::invalid_argument(\"Walker not found\");\n    }\n    if (controller.GetEpisode() == nullptr) {\n        throw std::invalid_argument(\"Episode not found\");\n    }\n    if (controller.GetNavigation() == nullptr) {\n        controller.SetNavigation(controller.GetEpisode()->GetNavigation());\n    }\n    controller.RegisterWalker(walker);\n    controller.SetID(controller.GetWalkerID());\n}", "CodeBleu_score": 51.854180477342226}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tauto walker = GetWalker(controller.GetWalkerID());\n    if (walker == nullptr) {\n        throw std::invalid_argument(\"Walker with ID \" + std::to_string(controller.GetWalkerID()) + \" does not exist\");\n    }\n\n    if (controller.GetEpisode() == nullptr) {\n        throw std::invalid_argument(\"Episode must not be null\");\n    }\n\n    if (walker->GetNavigation() == nullptr) {\n        walker->SetNavigation(std::make_shared<Navigation>(*walker));\n    }\n\n    walker->RegisterController(controller);\n}", "CodeBleu_score": 51.89316881702942}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tauto actor = ActorFactory::MakeActor(blueprint, transform, parent, attachment_type, socket_name);\n  if (actor == nullptr) {\n    return nullptr;\n  }\n\n  _episode->RegisterActor(actor);\n  _episode->RegisterActorForGarbageCollection(actor, gc);\n  _episode->LogActorCreation(actor);\n\n  return actor;\n}", "CodeBleu_score": 31.187762395877687}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tRELEASE_ASSERT(Episode != nullptr);\n    auto *actor = new Actor(Episode, blueprint, transform, parent, attachment_type, socket_name);\n    ActorPtr result(actor);\n    result->_gc = gc;\n    Episode->RegisterActor(result);\n    Log->Info(\"Spawning actor: \", *result);\n    return result;\n  }", "CodeBleu_score": 33.91041785075232}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tRELEASE_ASSERT(Episode != nullptr);\n    auto *actor = new ActorProxy{Episode, blueprint, transform, parent, attachment_type, socket_name};\n    actor->SetGarbageCollectionPolicy(gc);\n    Episode->RegisterActor(actor);\n    Episode->LogActorCreation(actor);\n    return SharedPtr<Actor>{actor};\n  }", "CodeBleu_score": 32.4031058058704}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tif (!Episode->IsValid()) {\n    throw_simulation_error(\"invalid episode\");\n  }\n\n  auto stream = sensor.GetStreamType();\n  auto endpoint = sensor.GetStreamEndpoint();\n  auto token = Client->SubscribeToStream(\n      stream, endpoint,\n      [=](SharedPtr<const carla::client::SensorData> data_ptr) {\n        auto data = boost::static_pointer_cast<sensor::SensorData>(data_ptr);\n        data->SetEpisode(*Episode);\n        callback(std::move(data));\n      });\n  _sensors.insert(std::make_pair(sensor.GetId(), std::move(token)));\n}", "CodeBleu_score": 53.420336907985}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tif (!Episode) {\n        throw_exception(std::runtime_error(\"invalid episode\"));\n    }\n    auto delegate = std::make_shared<StreamCallbackDelegate<sensor::SensorData>>(\n            sensor.GetActorDescription().Uuid,\n            sensor.GetActorDescription().Id,\n            sensor.GetSensorDescription().Id,\n            sensor.GetSensorDescription().Type,\n            callback);\n    auto query = Client->SubscribeToStream(\n            sensor.GetActorDescription().Uuid,\n            sensor.GetActorDescription().Id,\n            sensor.GetSensorDescription().Id,\n            delegate->GetCallback());\n    if (query.empty()) {\n        throw_exception(std::runtime_error(\"unable to subscribe to sensor \" + sensor.GetSensorDescription().Id));\n    }\n    Episode->SensorSubscriptions.insert({sensor.GetId(), query});\n    Episode->SensorData.insert({sensor.GetId(), {}});\n    Episode->SensorDataAvailableConditions.insert({sensor.GetId(), {}});\n}", "CodeBleu_score": 38.057233491855854}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tif (sensor.IsNull()) {\n    throw_exception(std::runtime_error(\"sensor is null\"));\n  }\n  if (sensor->GetParent() == nullptr) {\n    throw_exception(std::runtime_error(\"sensor has no parent\"));\n  }\n  if (sensor->GetParent()->GetId() != GetEpisode().GetId()) {\n    throw_exception(std::runtime_error(\"sensor's parent is not part of this episode\"));\n  }\n  client.SubscribeToStream(\n      sensor->GetTopic(),\n      [=](SharedPtr<const sensor::SensorData> data) {\n        auto sensor_data = std::make_shared<sensor::SensorData>();\n        sensor_data->Get(data);\n        sensor_data->SetEpisode(GetEpisode());\n        callback(sensor_data);\n      });\n}", "CodeBleu_score": 43.08222133894788}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// get the current walkers\n  std::vector<WalkerHandle> walkers = GetWalkers();\n\n  // if no walkers, return\n  if (walkers.size() == 0)\n    return;\n\n  // get current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // check for walker existence\n  CheckIfWalkerExist(walkers, *state);\n\n  // update the vehicles in the crowd\n  UpdateVehiclesInCrowd(episode, false);\n\n  // update the crowd\n  _nav.Update(1.0f / 20.0f);\n\n  // get the walker transforms and speeds\n  std::vector<carla::nav::WalkerTransformAndSpeed> transforms_and_speeds;\n  for (auto &&walker : walkers) {\n    // get the snapshot\n    ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n    // add to the vector\n    transforms_and_speeds.emplace_back(carla::nav::WalkerTransformAndSpeed{snapshot.transform, snapshot.velocity});\n  }\n\n  // apply the states in a batch\n  _nav.ApplyBatch(transforms_and_speeds);\n\n  // check if any walker has been killed\n  for (auto &&walker : walkers) {\n    // get the snapshot\n    ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n    // if the walker is dead, remove it from the crowd\n    if (snapshot.health <= 0.0f) {\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n  }\n}", "CodeBleu_score": 47.764151645436876}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// get the current walkers\n  std::vector<WalkerHandle> walkers = GetWalkers();\n\n  // check if the list is empty\n  if (walkers.empty())\n    return;\n\n  // get the current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // check if walkers exist\n  CheckIfWalkerExist(walkers, *state);\n\n  // update vehicles in crowd\n  UpdateVehiclesInCrowd(episode, false);\n\n  // update crowd\n  _nav.UpdateCrowd(0.01f);\n\n  // get the current time\n  double now = episode->GetElapsedGameTime();\n\n  // for each walker\n  for (auto &&walker : walkers) {\n\n    // get the transform and speed\n    ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n    carla::geom::Transform transform = snapshot.transform;\n    float speed = snapshot.speed;\n\n    // apply the transform and speed to the crowd\n    _nav.ApplyTransformAndSpeed(walker.walker, transform, speed);\n\n    // get the walker controller\n    std::shared_ptr<WalkerController> controller = _simulator.lock()->GetActor<WalkerController>(walker.controller);\n\n    // check if the walker has been killed\n    if (controller->IsDead()) {\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n  }\n}", "CodeBleu_score": 50.284571873878235}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// get the current walkers\n    std::vector<WalkerHandle> walkers = GetWalkers();\n\n    // check if there are any walkers\n    if (walkers.empty()) return;\n\n    // get the current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // remove any walkers that no longer exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update crowd\n    _nav.UpdateCrowd(1.0f / 60.0f);\n\n    // apply walker states\n    for (auto &&walker : walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n\n      // get the transform\n      carla::geom::Transform transform = snapshot.transform;\n\n      // get the speed\n      float speed = snapshot.speed;\n\n      // apply the transform and speed\n      _nav.ApplyWalkerTransformAndSpeed(walker.walker, transform, speed);\n    }\n\n    // check if any walker has been killed\n    CheckIfWalkerDead(walkers, *state);\n  }", "CodeBleu_score": 38.74563701546524}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.set_uid(uid);\n  description.set_id(id);\n  description.mutable_attributes()->Reserve(attributes.size());\n  for (const auto &pair : attributes) {\n    description.add_attributes()->CopyFrom(pair.second);\n  }\n  return description;\n}", "CodeBleu_score": 63.00272105368858}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.uid = uid;\n  description.id = id;\n  description.attributes.reserve(attributes.size());\n  for (const auto &attribute : attributes) {\n    description.attributes.emplace_back(attribute.first, attribute.second);\n  }\n  return description;\n}", "CodeBleu_score": 76.27057498453604}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.uid = uid;\n  description.id = id;\n  description.attributes.reserve(attributes.size());\n  for (auto &&attribute : attributes) {\n    description.attributes.push_back(attribute.second->MakeDescription());\n  }\n  return description;\n}", "CodeBleu_score": 72.52725010912218}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\treturn SharedPtr<BlueprintLibrary>(new BlueprintLibrary(\n            _blueprint_library->FilterByAttribute(TCHAR_TO_UTF8(*FString(name.c_str())), TCHAR_TO_UTF8(*FString(value.c_str())))));\n}", "CodeBleu_score": 22.447168924324885}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\treturn SharedPtr<BlueprintLibrary>(new BlueprintLibrary(\n        _blueprints.FilterByAttribute(name, value)));\n}", "CodeBleu_score": 15.891768815703184}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (auto bp : blueprints_) {\n    if (bp->HasAttribute(name)) {\n      if (bp->GetAttribute(name).compare(value) == 0) {\n        result->RegisterBlueprint(bp);\n      }\n    } else if (bp->HasRecommendedAttribute(name)) {\n      for (auto rec_value : bp->GetRecommendedAttributes(name)) {\n        if (rec_value.compare(value) == 0) {\n          result->RegisterBlueprint(bp);\n        }\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 44.27340075700703}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string fullPath = baseFolder + path;\n\t\n\tstd::string versionPath = GetVersionPath(fullPath);\n\tif (versionPath.empty()) {\n\t\treturn false;\n\t}\n\n\tstd::ofstream file(versionPath, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\tfile.write((char*)content.data(), content.size());\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 44.29123353703016}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string fullPath = basePath + path;\n\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\tfile.write((char*)&content[0], content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 38.23519085325208}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string fullPath = baseFolder + path;\n    std::string versionPath = baseFolder + versionFolder;\n\n    if (!ValidateFilePath(fullPath)) {\n        return false;\n    }\n\n    std::ofstream file(fullPath, std::ios::binary);\n\n    if (file.is_open()) {\n        file.write((char*)&content[0], content.size());\n        file.close();\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 41.14366741068739}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tgeom::Location location = Rotate(transform.GetYaw(), transform.GetLocation());\n    location.x += _bounds.location.x;\n    location.y += _bounds.location.y;\n\n    const float c = std::cos(transform.GetYaw() * geom::Math::Pi<float>() / 180.0f);\n    const float s = std::sin(transform.GetYaw() * geom::Math::Pi<float>() / 180.0f);\n    const float x_extent = _bounds.extent.x * c + _bounds.extent.y * s;\n    const float y_extent = _bounds.extent.x * s + _bounds.extent.y * c;\n\n    const geom::Location front_left = {\n        location.x - x_extent,\n        location.y - y_extent,\n        location.z};\n    const geom::Location front_right = {\n        location.x + x_extent,\n        location.y - y_extent,\n        location.z};\n    const geom::Location back_left = {\n        location.x - x_extent,\n        location.y + y_extent,\n        location.z};\n    const geom::Location back_right = {\n        location.x + x_extent,\n        location.y + y_extent,\n        location.z};\n\n    return std::make_shared<const Bounds>(\n        frame,\n        front_left,\n        front_right,\n        back_left,\n        back_right);\n  }", "CodeBleu_score": 40.33762824375389}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tgeom::Location location = transform.location;\n    location.x += transform.GetForwardVectorX();\n    location.y += transform.GetForwardVectorY();\n    location.z += transform.GetForwardVectorZ();\n    const geom::Rotation rotation = transform.rotation;\n    const float yaw = rotation.yaw;\n    const float pitch = rotation.pitch;\n    const float roll = rotation.roll;\n    const geom::Vector3D extents = _bounds_extents;\n    const float x_front = extents.x;\n    const float y_front = extents.y;\n    const float x_rear = -x_front;\n    const float y_rear = -y_front;\n    const float z_top = extents.z;\n    const float z_bottom = -z_top;\n    const float cos_yaw = std::cos(yaw);\n    const float sin_yaw = std::sin(yaw);\n    const float cos_pitch = std::cos(pitch);\n    const float sin_pitch = std::sin(pitch);\n    const float cos_roll = std::cos(roll);\n    const float sin_roll = std::sin(roll);\n    const float x_front_cos_yaw = x_front * cos_yaw;\n    const float y_front_cos_yaw = y_front * cos_yaw;\n    const float x_front_sin_yaw = x_front * sin_yaw;\n    const float y_front_sin_yaw = y_front * sin_yaw;\n    const float x_rear_cos_yaw = x_rear * cos_yaw;\n    const float y_rear_cos_yaw = y_rear * cos_yaw;\n    const float x_rear_sin_yaw = x_rear * sin_yaw;\n    const float y_rear_sin_yaw = y_rear * sin_yaw;\n    const float z_top_cos_pitch = z_top * cos_pitch;\n    const float z_top_sin_pitch = z_top * sin", "CodeBleu_score": 32.80866751804725}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tgeom::Location location = transform.location;\n    location.x += transform.bounding_box.location.x;\n    location.y += transform.bounding_box.location.y;\n    location.z += transform.bounding_box.location.z;\n    std::vector<geom::Vector3D> corners;\n    corners.reserve(4);\n    for (const geom::Vector3D &corner : transform.bounding_box.extent) {\n        corners.push_back(Rotate(transform.rotation.yaw, corner));\n    }\n    return std::make_shared<const Bounds>(frame, location, corners);\n  }", "CodeBleu_score": 39.19758957530586}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> guard(lights_mutex);\n\t// Get the current state of the lights from the server\n\tstd::vector<LightState> light_states = server->GetLightStates();\n\t// Update the local light states\n\tfor (LightState& light_state : light_states) {\n\t\t// If the light is not in the map, add it\n\t\tif (_lights.find(light_state.id) == _lights.end()) {\n\t\t\t_lights[light_state.id] = new Light(light_state);\n\t\t}\n\t\t// Update the light state\n\t\t_lights[light_state.id]->UpdateState(light_state);\n\t}\n}", "CodeBleu_score": 30.449716369587076}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t// Lock the mutex to ensure thread safety\n    _lightsMutex.lock();\n    // Query the server for the current state of the lights\n    std::vector<LightState> lightsState = _lightsServer->GetLightsState();\n    // Iterate through the lights states\n    for (auto lightState : lightsState) {\n        // Check if the light is already in the _lights map\n        if (_lights.find(lightState.GetId()) == _lights.end()) {\n            // Create a new light object with the given light state\n            _lights[lightState.GetId()] = new Light(lightState);\n        } else {\n            // Update the light object with the given light state\n            _lights[lightState.GetId()]->SetLightState(lightState);\n        }\n    }\n    // Unlock the mutex\n    _lightsMutex.unlock();\n}", "CodeBleu_score": 28.036509769497226}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t// Lock the mutex to ensure thread safety\n    std::lock_guard<std::mutex> guard(m_lightsMutex);\n\n    // Get the current state of lights from the server\n    auto lights = m_lightsApi.getLights();\n\n    // Update the local light states and create new light objects if they do not already exist in the _lights map\n    for (auto& light : lights) {\n        auto lightId = light.getId();\n        auto lightIter = m_lights.find(lightId);\n        if (lightIter == m_lights.end()) {\n            // Create a new light object if it does not already exist in the _lights map\n            m_lights[lightId] = std::make_shared<Light>(light);\n        }\n        else {\n            // Update the local light state\n            lightIter->second->setLight(light);\n        }\n    }\n}", "CodeBleu_score": 36.30442975574641}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t// Lock the mutex\n    std::lock_guard<std::mutex> guard(lights_mutex);\n\n    // If there are no changes, return\n    if (!dirty) {\n        return;\n    }\n\n    // Create the message\n    Message msg;\n    msg.type = MessageType::LIGHTS;\n    msg.lights_state.lights_count = lights_state.size();\n    msg.lights_state.lights = new LightState[msg.lights_state.lights_count];\n\n    // Copy the lights state\n    for (int i = 0; i < msg.lights_state.lights_count; i++) {\n        msg.lights_state.lights[i] = lights_state[i];\n    }\n\n    // Send the message\n    if (discard_client) {\n        msg.lights_state.discard_client = 1;\n    }\n    else {\n        msg.lights_state.discard_client = 0;\n    }\n    SendMessage(msg);\n\n    // Clear the changes\n    changes.clear();\n\n    // Reset the dirty flag\n    dirty = false;\n}", "CodeBleu_score": 40.40990235949551}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tif (discard_client) {\n\t\tthis->discard_client = true;\n\t}\n\tif (this->discard_client) {\n\t\tthis->discard_client = false;\n\t\treturn;\n\t}\n\tif (this->dirty) {\n\t\tthis->dirty = false;\n\t\tthis->mutex.lock();\n\t\tif (this->dirty) {\n\t\t\tthis->dirty = false;\n\t\t\tthis->mutex.unlock();\n\t\t\treturn;\n\t\t}\n\t\tif (this->lights.size() == 0) {\n\t\t\tthis->mutex.unlock();\n\t\t\treturn;\n\t\t}\n\t\tMessage msg;\n\t\tmsg.header.type = MessageType::LIGHT_STATE;\n\t\tmsg.header.size = this->lights.size() * sizeof(LightState);\n\t\tmsg.header.seq = this->seq;\n\t\tmsg.header.timestamp = this->timestamp;\n\t\tmsg.header.version = this->version;\n\t\tmsg.header.status = this->status;\n\t\tmsg.header.flags = 0;\n\t\tmsg.header.reserved = 0;\n\t\tmsg.header.reserved2 = 0;\n\t\tmsg.header.reserved3 = 0;\n\t\tmsg.header.reserved4 = 0;\n\t\tmsg.header.reserved5 = 0;\n\t\tmsg.header.reserved6 = 0;\n\t\tmsg.header.reserved7 = 0;\n\t\tmsg.header.reserved8 = 0;\n\t\tmsg.header.reserved9 = 0;\n\t\tmsg.header.reserved10 = 0;\n\t\tmsg.header.reserved11 = 0;\n\t\tmsg.header.reserved12 = 0;\n\t\tmsg.header.reserved13 = 0;\n\t\tmsg.header.reserved14 = 0;\n\t\tmsg.header.reserved15 = 0;\n\t\tmsg.header.reserved16 = 0;", "CodeBleu_score": 16.724074735499215}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tif (!server) {\n        return;\n    }\n\n    std::lock_guard<std::mutex> lock(lights_mutex);\n\n    if (!dirty) {\n        return;\n    }\n\n    if (discard_client) {\n        for (auto& light : lights) {\n            light.second.client_state = light.second.server_state;\n        }\n    }\n\n    Message msg;\n    msg.header.type = MessageType::LIGHTS_STATE;\n    msg.header.size = 0;\n\n    for (auto& light : lights) {\n        if (light.second.client_state != light.second.server_state) {\n            msg.header.size += sizeof(uint8_t) + sizeof(uint8_t);\n            light.second.server_state = light.second.client_state;\n        }\n    }\n\n    if (msg.header.size == 0) {\n        return;\n    }\n\n    msg.data = new uint8_t[msg.header.size];\n    uint8_t* ptr = msg.data;\n\n    for (auto& light : lights) {\n        if (light.second.client_state != light.second.server_state) {\n            *ptr++ = light.first;\n            *ptr++ = light.second.client_state;\n        }\n    }\n\n    server->SendMessage(msg);\n    delete[] msg.data;\n    dirty = false;\n}", "CodeBleu_score": 40.57397381635395}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t// Log a debug message\n    _plugin->LogDebug(\"ServerSideSensor::Send called\");\n\n    // Check if the sensor's ID is \"sensor.other.v2x_custom\"\n    if (this->GetId() != \"sensor.other.v2x_custom\") {\n        // Log a warning\n        _plugin->LogWarning(\"ServerSideSensor::Send called for sensor with ID \" + this->GetId());\n        return;\n    }\n\n    // Send a message to the episode using the sensor's context\n    this->GetEpisode().Lock()->Send(message);\n}", "CodeBleu_score": 49.31067266789806}, {"code": "void ServerSideSensor::Send(std::string message){\n\tstd::string sensor_id = GetId();\n    if (sensor_id != \"sensor.other.v2x_custom\") {\n        Log::Debug(\"Sensor ID is not 'sensor.other.v2x_custom'\");\n        return;\n    }\n    Log::Warning(\"Sending a message from the server side sensor\");\n    GetEpisode().Lock()->SendMessage(message);\n}", "CodeBleu_score": 55.62795891374761}, {"code": "void ServerSideSensor::Send(std::string message){\n\t// Log a debug message\n    Log::Debug(\"ServerSideSensor::Send called\");\n\n    // Check if the sensor's ID is \"sensor.other.v2x_custom\"\n    if (GetId() == \"sensor.other.v2x_custom\") {\n        // Log a warning\n        Log::Warning(\"Sensor ID is sensor.other.v2x_custom\");\n    } else {\n        // Log a warning\n        Log::Warning(\"Sensor ID is not sensor.other.v2x_custom\");\n        return;\n    }\n\n    // Send a message to the episode using the sensor's context\n    GetContext()->Send(message);\n}", "CodeBleu_score": 52.20767086434288}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t}", "CodeBleu_score": 4.055752836348062}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n        if (this->autopilot_enabled) return;\n        this->autopilot_enabled = true;\n        this->tm_port = tm_port;\n        this->tm_client = new TrafficManagerClient(this->tm_port);\n        this->tm_client->SetVehicle(this->GetId());\n        this->RegisterAtTrafficManager();\n    } else {\n        if (!this->autopilot_enabled) return;\n        this->autopilot_enabled = false;\n        this->DeregisterAtTrafficManager();\n        delete this->tm_client;\n        this->tm_client = nullptr;\n    }\n}", "CodeBleu_score": 32.034986563911396}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n    if (!autopilot_enabled) {\n      autopilot_enabled = true;\n      traffic_manager_port = tm_port;\n      if (traffic_manager_port != 0) {\n        TrafficManager *tm = GetWorld()->GetTrafficManager(traffic_manager_port);\n        if (tm != nullptr) {\n          tm->RegisterVehicles({this});\n        } else {\n          autopilot_enabled = false;\n          traffic_manager_port = 0u;\n          throw_exception(std::runtime_error(\"no traffic manager at port specified\"));\n        }\n      }\n    }\n  } else {\n    if (autopilot_enabled) {\n      autopilot_enabled = false;\n      if (traffic_manager_port != 0) {\n        TrafficManager *tm = GetWorld()->GetTrafficManager(traffic_manager_port);\n        if (tm != nullptr) {\n          tm->UnregisterVehicles({this});\n        }\n      }\n      traffic_manager_port = 0u;\n    }\n  }\n}", "CodeBleu_score": 37.32056990986666}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\n\tWalker = Cast<AWalker>(GetPawn());\n\tif (Walker) {\n\t\tWalker->GetMovementComponent()->StopMovementImmediately();\n\t\tWalker->GetMovementComponent()->DisableMovement();\n\t\tWalker->GetMovementComponent()->SetMovementMode(MOVE_None);\n\t\tWalker->GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\n\t\t// Register the walker with the navigation system\n\t\tWalker->GetMovementComponent()->GetNavAgentPropertiesRef().bCanCrouch = true;\n\t\tWalker->GetMovementComponent()->GetNavAgentPropertiesRef().bCanFly = true;\n\t\tWalker->GetMovementComponent()->GetNavAgentPropertiesRef().bCanSwim = true;\n\t\tWalker->GetMovementComponent()->GetNavAgentPropertiesRef().bCanWalk = true;\n\t\tWalker->GetMovementComponent()->GetNavAgentPropertiesRef().bCanJump = true;\n\t\tWalker->GetMovementComponent()->GetNavAgentPropertiesRef().bCanClimb = true;\n\n\t\tWalker->GetMovementComponent()->SetNavAgentPropertiesRef(Walker->GetMovementComponent()->GetNavAgentPropertiesRef());\n\t\tWalker->GetMovementComponent()->SetNavAgentLocation(Walker->GetActorLocation());\n\t\tWalker->GetMovementComponent()->RequestDirectMove(Walker->GetActorLocation(), Walker->GetActorRotation().Vector(), true);\n\t}\n}", "CodeBleu_score": 28.238001885483683}, {"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\t\n\twalker = Cast<AWalker>(GetPawn());\n\tif (walker) {\n\t\twalker->GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t\twalker->GetMesh()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t\twalker->GetMesh()->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);\n\t\twalker->GetMesh()->SetSimulatePhysics(false);\n\t\t\n\t\twalker->GetCapsuleComponent()->SetSimulatePhysics(false);\n\t\t\n\t\twalker->GetMesh()->SetAllBodiesBelowSimulatePhysics(false);\n\t\t\n\t\t\n\t\t\n\t\twalker->GetMesh()->SetAllBodiesSimulatePhysics(false);", "CodeBleu_score": 35.666137703691334}, {"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n    // Get the walker actor\n    walker = Cast<AWalker>(GetPawn());\n    // Add the walker to the navigation system\n    walker->navMeshComp->EnableNavigationSystem(GetWorld()->GetNavigationSystem());\n    // Disable the physics simulation and collisions for the walker\n    walker->GetMesh()->SetSimulatePhysics(false);\n    walker->GetMesh()->SetEnableGravity(false);\n    walker->GetMesh()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}", "CodeBleu_score": 35.71292940367552}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tif (GetNavInstance() == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: NavInstance is nullptr.\"));\n\t\treturn;\n\t}\n\tif (GetPawn() == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Pawn is nullptr.\"));\n\t\treturn;\n\t}\n\tif (GetPawn()->GetClass()->ImplementsInterface(UWalker::StaticClass())) {\n\t\tUWalker* walker = Cast<UWalker>(GetPawn());\n\t\tif (walker->SetMaxSpeed(max_speed)) {\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"WalkerAIController::SetMaxSpeed: Maximum speed set to %f.\"), max_speed);\n\t\t}\n\t\telse {\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set maximum speed.\"));\n\t\t}\n\t}\n\telse {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Pawn does not implement the UWalker interface.\"));\n\t}\n}", "CodeBleu_score": 45.30654470992251}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t// Retrieve the navigation instance.\n\tconst auto nav = GetNavigationSystem();\n\n\t// Check if the navigation instance is valid.\n\tif (nav) {\n\t\t// Retrieve the walker.\n\t\tconst auto walker = GetWalker();\n\n\t\t// Check if the walker is valid.\n\t\tif (walker) {\n\t\t\t// Attempt to set the walker's maximum speed.\n\t\t\tif (nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\t\t// Log success.\n\t\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Maximum speed set to %f.\"), max_speed);\n\t\t\t} else {\n\t\t\t\t// Log failure.\n\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Failed to set maximum speed to %f.\"), max_speed);\n\t\t\t}\n\t\t} else {\n\t\t\t// Log failure.\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Failed to set maximum speed to %f. Walker not found.\"), max_speed);\n\t\t}\n\t} else {\n\t\t// Log failure.\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Failed to set maximum speed to %f. Navigation system not found.\"), max_speed);\n\t}\n}", "CodeBleu_score": 47.971441887079806}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto *navigation = GetWorld()->GetNavigationSystem();\n\tif (navigation) {\n\t\tauto *walker = Cast<AWalker>(GetPawn());\n\t\tif (walker) {\n\t\t\tif (!navigation->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\t\tUE_LOG(LogWalkerAIController, Warning, TEXT(\"Failed to set max speed for walker %s\"), *walker->GetName());\n\t\t\t}\n\t\t} else {\n\t\t\tUE_LOG(LogWalkerAIController, Warning, TEXT(\"Failed to get walker for AI controller %s\"), *GetName());\n\t\t}\n\t} else {\n\t\tUE_LOG(LogWalkerAIController, Warning, TEXT(\"Failed to get navigation system\"));\n\t}\n}", "CodeBleu_score": 49.84930286430849}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n\n    std::vector<WaypointPtr> retrieved = _map->GetPrevious(this->GetPtr(), distance);\n\n    for (auto &waypoint : retrieved) {\n        result.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n    }\n\n    return result;\n}", "CodeBleu_score": 56.437643941236736}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n\n    std::vector<SharedPtr<Waypoint>> previous_waypoints = _map->GetPreviousWaypoints(this->GetTransform(), distance);\n\n    for (auto &waypoint : previous_waypoints) {\n        result.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint->GetTransform(), _map)));\n    }\n\n    return result;\n}", "CodeBleu_score": 56.03709144709585}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n\n    // Get the previous waypoints from the parent map.\n    std::vector<WaypointPtr> waypoints = _map->GetPreviousWaypoints(this, distance);\n\n    // For each waypoint, create a new Waypoint object and add it to the result vector.\n    for (auto &waypoint : waypoints) {\n        result.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n    }\n\n    return result;\n}", "CodeBleu_score": 55.26424220084096}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> landmarks;\n\n   // Get all signals in the given distance\n   std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\n   // Create a landmark for each signal and add it to the list\n   for (auto& signal : signals) {\n      // Check if the signal is already in the list\n      bool is_duplicate = false;\n      for (auto& landmark : landmarks) {\n         if (landmark->GetSignal() == signal) {\n            is_duplicate = true;\n            break;\n         }\n      }\n\n      // If it's not a duplicate, add it to the list\n      if (!is_duplicate) {\n         auto landmark = MakeShared<Landmark>(signal);\n         landmarks.push_back(landmark);\n      }\n   }\n\n   return landmarks;\n}", "CodeBleu_score": 44.92405864346982}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t// Get all signals in range.\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\n  // Filter out repeated signals.\n  std::vector<SharedPtr<Landmark>> landmarks;\n  for (auto &signal : signals) {\n    bool is_repeated = false;\n    for (auto &landmark : landmarks) {\n      if (landmark->GetSignal()->GetId() == signal->GetId()) {\n        is_repeated = true;\n        break;\n      }\n    }\n    if (is_repeated) {\n      continue;\n    }\n\n    // Add new landmark.\n    SharedPtr<Waypoint> new_waypoint = _map->GetClosestWaypointOnRoad(signal->GetTransform().location);\n    SharedPtr<Landmark> new_landmark = SharedPtr<Landmark>(new Landmark(new_waypoint, signal));\n    landmarks.push_back(new_landmark);\n  }\n\n  return landmarks;\n}", "CodeBleu_score": 46.91476973907514}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> landmarks;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  for (auto &signal : signals) {\n    if (signal->GetType() == Signal::SignalType::UNKNOWN ||\n        signal->GetType() == Signal::SignalType::STOP) {\n      continue;\n    }\n    if (signal->GetType() == Signal::SignalType::JUNCTION &&\n        stop_at_junction) {\n      break;\n    }\n    if (signal->GetWaypoint().get() == this) {\n      continue;\n    }\n    if (std::find_if(landmarks.begin(), landmarks.end(),\n                     [&signal](SharedPtr<Landmark> landmark) {\n                       return landmark->GetSignal()->GetId() ==\n                              signal->GetId();\n                     }) == landmarks.end()) {\n      SharedPtr<Landmark> landmark =\n          std::make_shared<Landmark>(signal->GetTransform(), signal);\n      landmarks.push_back(landmark);\n    }\n  }\n  return landmarks;\n}", "CodeBleu_score": 40.301648067900445}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    uint64_t id = _episode.Lock()->ApplyEpisodeSettings(settings, local_timeout);\n    if (settings.fixed_delta_seconds > 0.0) {\n      const double expected_duration = settings.fixed_delta_seconds;\n      double max_error = 0.0;\n      double sum_error = 0.0;\n      double sum_abs_error = 0.0;\n      double max_error_time = 0.0;\n      double sum_error_time = 0.0;\n      double sum_abs_error_time = 0.0;\n      double error = 0.0;\n      double time = 0.0;\n      double dt = 0.0;\n      uint64_t start_time = _episode.Lock()->GetEpisodeStartTime();\n      uint64_t prev_time = start_time;\n      uint64_t end_time = start_time + static_cast<uint64_t>(settings.max_substep_delta_time * 1000.0);\n      uint64_t i = 0u;\n      while (time < settings.max_substep_delta_time) {\n        if (i > 0u) {\n          prev_time = start_time + static_cast<uint64_t>(time * 1000.0);\n        }\n        _episode.Lock()->Tick(local_timeout);\n        uint64_t current_time = _episode.Lock()->GetEpisodeStartTime();\n        dt = (current_time - prev_time) / 1000.0;\n        time = (current_time - start_time) / 1000.0;\n        error = std::abs(dt - expected_duration);\n        max_error = std::max(max_error, error);\n        sum_error += error;\n        sum_abs_error += std::abs(error);\n        if (error > 0.0", "CodeBleu_score": 50.52984116352178}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->ApplySettings(settings, local_timeout);\n  }", "CodeBleu_score": 21.1666198964955}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->ApplyEpisodeSettings(settings, local_timeout);\n  }", "CodeBleu_score": 20.385968728711845}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat segmentLengthSquared = (segmentEnd.x - segmentStart.x) * (segmentEnd.x - segmentStart.x) + (segmentEnd.y - segmentStart.y) * (segmentEnd.y - segmentStart.y);\n\tfloat segmentLength = std::sqrt(segmentLengthSquared);\n\tif (segmentLength == 0.0f) {\n\t\tfloat distanceToStart = (point.x - segmentStart.x) * (point.x - segmentStart.x) + (point.y - segmentStart.y) * (point.y - segmentStart.y);\n\t\tfloat distanceToEnd = (point.x - segmentEnd.x) * (point.x - segmentEnd.x) + (point.y - segmentEnd.y) * (point.y - segmentEnd.y);\n\t\tif (distanceToStart < distanceToEnd) {\n\t\t\treturn std::make_pair(0.0f, distanceToStart);\n\t\t}\n\t\treturn std::make_pair(0.0f, distanceToEnd);\n\t}\n\tfloat projection = ((point.x - segmentStart.x) * (segmentEnd.x - segmentStart.x) + (point.y - segmentStart.y) * (segmentEnd.y - segmentStart.y)) / segmentLengthSquared;\n\tif (projection < 0.0f) {\n\t\tfloat distanceToStart = (point.x - segmentStart.x) * (point.x - segmentStart.x) + (point.y - segmentStart.y) * (point.y - segmentStart.y);\n\t\treturn std::make_pair(0.0f, distanceToStart);\n\t}\n\tif (projection > 1.0f) {\n\t\tfloat distanceToEnd = (point.x - segmentEnd.x) * (point.x - segmentEnd.x) + (point.y - segmentEnd.y) * (point.y - segmentEnd.y);\n\t\treturn std::make_pair(0.0f, distanceToEnd);\n\t}\n\tfloat projectionX = segmentStart.x + projection * (segmentEnd.x - segmentStart.x);\n\tfloat projectionY = segmentStart.y", "CodeBleu_score": 32.461584979890304}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat lensq = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n\tfloat len = std::sqrt(lensq);\n\n\tif (lensq == 0.0f)\n\t\treturn std::pair<float, float>(0.0f, Math::Distance(a, p));\n\n\tfloat t = Math::Clamp(((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / lensq, 0.0f, 1.0f);\n\tVector2 projection = a + t * (b - a);\n\n\treturn std::pair<float, float>(t * len, Math::Distance(projection, p));\n}", "CodeBleu_score": 42.13474151369696}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat t;\n\tfloat d;\n\tfloat dist;\n\tfloat seg_len;\n\tfloat seg_len_sq;\n\tfloat pt_x;\n\tfloat pt_y;\n\tfloat seg_x;\n\tfloat seg_y;\n\tfloat seg_x_delta;\n\tfloat seg_y_delta;\n\tfloat proj_x;\n\tfloat proj_y;\n\n\tseg_x = seg_pt_a.x - seg_pt_b.x;\n\tseg_y = seg_pt_a.y - seg_pt_b.y;\n\tseg_len_sq = seg_x * seg_x + seg_y * seg_y;\n\tseg_len = sqrt(seg_len_sq);\n\tif (seg_len == 0.0f) {\n\t\tdist = Math::DistancePointToPoint(pt, seg_pt_a);\n\t\treturn std::pair<float, float>(0.0f, dist);\n\t}\n\tseg_x_delta = seg_x / seg_len;\n\tseg_y_delta = seg_y / seg_len;\n\tpt_x = pt.x - seg_pt_a.x;\n\tpt_y = pt.y - seg_pt_a.y;\n\tt = pt_x * seg_x_delta + pt_y * seg_y_delta;\n\tif (t < 0.0f) {\n\t\tdist = Math::DistancePointToPoint(pt, seg_pt_a);\n\t\treturn std::pair<float, float>(0.0f, dist);\n\t}\n\tif (t > seg_len) {\n\t\tdist = Math::DistancePointToPoint(pt, seg_pt_b);\n\t\treturn std::pair<float, float>(seg_len, dist);\n\t}\n\tproj_x = seg_pt_a.x + t * seg_x_delta;\n\tproj_y = seg_pt_a.y + t * seg_y_delta;\n\tdist = Math::DistancePointToPoint(pt, proj);\n\treturn std::pair<float, float>(t, dist);\n}", "CodeBleu_score": 36.485989359690755}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tassert(vertices.size() >= 3);\n    const index_type initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 50.6972310299164}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tassert(vertices.size() >= 3);\n    size_t initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 51.099051154063424}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tassert(vertices.size() >= 3);\n    size_t initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 0; i < vertices.size() - 2; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i + 1);\n      AddIndex(initial_index + i + 2);\n    }\n  }", "CodeBleu_score": 50.8489493796223}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tif (message->size() > 1024u * 1024u) {\n    throw std::invalid_argument(\"message too large\");\n  }\n  _strand.post([this, message]() {\n    if (_socket.is_open()) {\n      SetTimeout(_socket, _timeout);\n      boost::asio::async_write(\n          _socket,\n          boost::asio::buffer(message->data(), message->size()),\n          [this, message](boost::system::error_code ec, std::size_t) {\n            if (ec) {\n              log_error(ec, \"cannot write message to server\");\n              Close();\n            }\n          });\n    }\n  });\n}", "CodeBleu_score": 29.954655495602122}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t// Ensure the message is valid.\n  if (!message) {\n    return;\n  }\n  // Post a lambda to the strand for execution.\n  _strand.post([this, message]() {\n    // Ensure the socket is open.\n    if (!_socket.is_open()) {\n      return;\n    }\n    // Set a timeout.\n    _socket.expires_after(std::chrono::seconds(10));\n    // Initiate an asynchronous write.\n    boost::asio::async_write(\n        _socket,\n        boost::asio::buffer(message->data(), message->size()),\n        [this, message](boost::system::error_code ec, std::size_t) {\n          // Handle the result.\n          if (ec) {\n            log_error(\"error sending message\", ec);\n            _socket.close();\n          }\n        });\n  });\n}", "CodeBleu_score": 31.491062458425674}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tif (!message) {\n    return;\n  }\n  _io_context.post([=, this]() {\n    if (!_socket.is_open()) {\n      return;\n    }\n    asio::async_write(\n        _socket,\n        asio::buffer(message->data(), message->size()),\n        [=, this](boost::system::error_code ec, size_t) {\n          if (ec) {\n            log_error(ec, \"write\");\n            Close();\n          }\n        });\n  });\n}", "CodeBleu_score": 25.97243183358875}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (ec) {\n\t\tLog::Error(\"Error closing socket: \", ec.message());\n\t}\n\tif (socket_.is_open()) {\n\t\tboost::system::error_code ignored_ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t\tsocket_.close(ignored_ec);\n\t}\n\tif (on_closed_) {\n\t\ton_closed_();\n\t}\n\tLog::Info(\"Session closed\");\n}", "CodeBleu_score": 53.07131523396821}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (ec) {\n\t\tstd::cerr << \"Error: \" << ec.message() << std::endl;\n\t}\n\tif (socket_.is_open()) {\n\t\tboost::system::error_code ignored_ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t\tsocket_.close(ignored_ec);\n\t}\n\ton_closed();\n\tstd::cout << \"Session closed\" << std::endl;\n}", "CodeBleu_score": 49.19026829937384}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif(deadline_timer.expires_at() > boost::posix_time::ptime())\n\t\tdeadline_timer.cancel();\n\n\tif(!ec && socket.is_open()) {\n\t\tboost::system::error_code ignored_ec;\n\t\tsocket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t\tsocket.close();\n\t}\n\n\ton_closed(ec);\n\tLog(\"Session closed\");\n}", "CodeBleu_score": 51.1295330082175}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t// Create the message\n    char message[100];\n    sprintf(message, \"Are you alive?\");\n    // Log the message\n    Log::Inst()->Log(message, Log::LogLevels::INFO);\n    // Create the buffer\n    char buffer[100];\n    sprintf(buffer, \"%s\", message);\n    // Send the message\n    WriteToNextRouter(buffer, YOU_ALIVE);\n    // Wait for the response\n    char response[100];\n    ReadFromNextRouter(response);\n    // Log the response\n    Log::Inst()->Log(response, Log::LogLevels::INFO);\n}", "CodeBleu_score": 40.74751985197322}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tchar message[100];\n    strcpy(message, \"Are you alive?\");\n    LogSend(message);\n    SendMessage(message, YOU_ALIVE);\n    WaitForResponse();\n}", "CodeBleu_score": 16.274145652903677}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t// Create the message\n    char message[20] = \"Are you alive?\";\n    // Create the buffer\n    char buffer[20];\n    // Log the sending action\n    Log::WriteMessage(Log::MessageType::Info, \"Sending message: Are you alive?\");\n    // Write the message to the buffer\n    memcpy(buffer, message, sizeof(message));\n    // Write the buffer to the next router with the command YOU_ALIVE\n    WriteToNextRouter(buffer, sizeof(buffer), YOU_ALIVE);\n    // Wait for and log the response from the system\n    Log::WriteMessage(Log::MessageType::Info, \"Response: \", ReadFromNextRouter());\n}", "CodeBleu_score": 36.03231907784664}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Check if sensor is already enabled\n\tif (sensor_enabled[sensor_id]) {\n\t\tcout << \"Sensor \" << sensor_id << \" is already enabled.\n\";\n\t\treturn;\n\t}\n\n\t// Check if sensor is available on any secondary server\n\tint server_id = -1;\n\tfor (int i = 0; i < num_servers; i++) {\n\t\tif (server_sensor_enabled[i][sensor_id]) {\n\t\t\tserver_id = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If sensor is not available on any server, log an error message\n\tif (server_id == -1) {\n\t\tcout << \"Sensor \" << sensor_id << \" is not available on any server.\n\";\n\t\treturn;\n\t}\n\n\t// Create a buffer with the sensor ID\n\tchar buffer[sizeof(sensor_id)];\n\tmemcpy(buffer, &sensor_id, sizeof(sensor_id));\n\n\t// Send an ENABLE_ROS command to the server using the router\n\trouter.SendToServer(server_id, ENABLE_ROS, buffer, sizeof(sensor_id));\n\n\t// Wait for and process the server's response\n\tchar response[sizeof(sensor_id)];\n\trouter.ReceiveFromServer(server_id, response, sizeof(sensor_id));\n\tmemcpy(&sensor_id, response, sizeof(sensor_id));\n\n\t// If the sensor was successfully enabled, log a message\n\tif (sensor_id >= 0) {\n\t\tcout << \"Sensor \" << sensor_id << \" successfully enabled.\n\";\n\t\tsensor_enabled[sensor_id] = true;\n\t}\n\t// Otherwise, log an error message\n\telse {\n\t\tcout << \"Sensor \" << sensor_id << \" could not be enabled.\n\";\n\t}\n}", "CodeBleu_score": 36.22399529124368}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Search for sensor on secondary servers\n\tint server_id = FindSensorOnSecondaryServers(sensor_id);\n\tif (server_id == -1) {\n\t\tLogError(\"Sensor not found on any secondary server.\");\n\t\treturn;\n\t}\n\n\t// Create buffer to send to server\n\tchar buffer[MAX_BUFFER_SIZE];\n\tint bytes_sent = CreateEnableForROSCommand(buffer, sensor_id);\n\n\t// Send command to server\n\tint bytes_received = SendCommandToServer(buffer, bytes_sent, server_id);\n\n\t// Process response from server\n\tProcessEnableForROSResponse(buffer, bytes_received, sensor_id);\n}", "CodeBleu_score": 35.159212661263126}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\tint i, j, k, l;\n\tint sensor_found = 0;\n\tint sensor_type;\n\tint sensor_index;\n\tint sensor_server;\n\tint sensor_port;\n\tint sensor_enabled;\n\tint sensor_enabled_on_server;\n\tint sensor_enabled_on_primary;\n\tint sensor_enabled_on_secondary;\n\tint sensor_enabled_on_any_server;\n\tint sensor_server_count;\n\tint sensor_server_list[MAX_SERVER_COUNT];\n\tint sensor_port_list[MAX_SERVER_COUNT];\n\tint sensor_enabled_list[MAX_SERVER_COUNT];\n\tint sensor_enabled_on_server_list[MAX_SERVER_COUNT];\n\tint sensor_enabled_on_primary_list[MAX_SERVER_COUNT];\n\tint sensor_enabled_on_secondary_list[MAX_SERVER_COUNT];\n\tint sensor_enabled_on_any_server_list[MAX_SERVER_COUNT];\n\tint sensor_server_count_list[MAX_SERVER_COUNT];\n\tint sensor_server_list_list[MAX_SERVER_COUNT][MAX_SERVER_COUNT];\n\tint sensor_port_list_list[MAX_SERVER_COUNT][MAX_SERVER_COUNT];\n\tint sensor_enabled_list_list[MAX_SERVER_COUNT][MAX_SERVER_COUNT];\n\tint sensor_enabled_on_server_list_list[MAX_SERVER_COUNT][MAX_SERVER_COUNT];\n\tint sensor_enabled_on_primary_list_list[MAX_SERVER_COUNT][MAX_SERVER_COUNT];\n\tint sensor_enabled_on_secondary_list_list[MAX_SERVER_COUNT][MAX_SERVER_COUNT];\n\tint sensor_enabled_on_any_server_list_list[MAX_SERVER_COUNT][MAX_SERVER_COUNT];\n\tint sensor_server_count_list_list[MAX_SERVER_COUNT][MAX_SERVER_COUNT];\n\tchar sensor_name[MAX_SENSOR_NAME_LENGTH];\n\tchar sensor_type_name[MAX_SENSOR_TYPE_NAME_LENGTH];\n\tchar sensor_type_units[MAX_SENS", "CodeBleu_score": 10.671680973212542}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_info(\"getting a token for sensor \", sensor_id);\n  if (token_map.find(sensor_id) != token_map.end()) {\n    log_info(\"sensor already activated\");\n    return token_map[sensor_id];\n  }\n\n  log_info(\"sensor not activated\");\n  auto new_token = SendGetToken(sensor_id);\n  token_map[sensor_id] = new_token;\n  stream_id_map[new_token.get_port()] = sensor_id;\n  log_info(\"sensor activated\");\n  return new_token;\n}", "CodeBleu_score": 45.6882141484443}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_info(\"getting a token for sensor: \", sensor_id);\n\n  // check if sensor is already activated\n  auto it = _sensor_tokens.find(sensor_id);\n  if (it != _sensor_tokens.end()) {\n    log_info(\"sensor already activated\");\n    return it->second;\n  }\n\n  // sensor is not activated, so activate it\n  log_info(\"sensor not activated, activating it\");\n  auto new_token = SendGetToken(sensor_id);\n  _sensor_tokens.insert(std::make_pair(sensor_id, new_token));\n  _token_to_sensor.insert(std::make_pair(new_token, sensor_id));\n  log_info(\"sensor activated\");\n  return new_token;\n}", "CodeBleu_score": 51.532133089364095}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t// check if the sensor is already activated\n  if (token_map.find(sensor_id) != token_map.end()) {\n    log_info(\"sensor is already activated\");\n    return token_map[sensor_id];\n  }\n\n  // enable the sensor on a secondary server\n  auto new_token = SendGetToken(sensor_id);\n\n  // update the maps\n  token_map[sensor_id] = new_token;\n  stream_map[new_token.get_stream_id()] = sensor_id;\n\n  log_info(\"sensor is now activated\");\n  return new_token;\n}", "CodeBleu_score": 42.46167954325569}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t// If the system is not ready, return false\n\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\n\t// If the crowd is null, return false\n\tif (crowd_ == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Enter a critical section\n\t{\n\t\t// Acquire the lock\n\t\tstd::lock_guard<std::mutex> lock(critical_section_);\n\n\t\t// If the agent is a walker\n\t\tif (walker_manager_.HasAgent(id)) {\n\t\t\t// Remove the walker\n\t\t\treturn RemoveWalker(id);\n\t\t}\n\n\t\t// If the agent is a vehicle\n\t\tif (vehicle_manager_.HasAgent(id)) {\n\t\t\t// Remove the vehicle\n\t\t\treturn RemoveVehicle(id);\n\t\t}\n\n\t\t// If the agent is not found, return false\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 25.382233572083734}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!ready_) {\n    return false;\n  }\n  if (crowd_ == nullptr) {\n    return false;\n  }\n\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  auto it_w = walkers_.find(id);\n  if (it_w != walkers_.end()) {\n    crowd_->removeAgent(it_w->second);\n    walkers_.erase(it_w);\n    return true;\n  }\n\n  auto it_v = vehicles_.find(id);\n  if (it_v != vehicles_.end()) {\n    crowd_->removeAgent(it_v->second);\n    vehicles_.erase(it_v);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 54.70487223642843}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!IsReady()) {\n    return false;\n  }\n\n  assert(crowd != nullptr);\n\n  std::lock_guard<std::mutex> lock(mutex);\n\n  auto walker_it = walker_map.find(id);\n  if (walker_it != walker_map.end()) {\n    crowd->removeAgent(walker_it->second);\n    walker_manager->RemoveAgent(id);\n    walker_map.erase(walker_it);\n    return true;\n  }\n\n  auto vehicle_it = vehicle_map.find(id);\n  if (vehicle_it != vehicle_map.end()) {\n    crowd->removeAgent(vehicle_it->second);\n    vehicle_manager->RemoveAgent(id);\n    vehicle_map.erase(vehicle_it);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 59.342599820047745}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t// Check if the actor is a pedestrian.\n  if (pedestrians.find(id) != pedestrians.end()) {\n    return false;\n  }\n\n  // Check if the actor is a vehicle.\n  if (vehicles.find(id) != vehicles.end()) {\n    return false;\n  }\n\n  // If the actor is not a pedestrian or vehicle, check if it is a walker.\n  if (walkers.find(id) != walkers.end()) {\n\n    // Enter a critical section.\n    boost::unique_lock<boost::shared_mutex> lock(_mutex);\n\n    // Compute the squared distance.\n    float squared_distance = distance * distance;\n\n    // Get the walker's position.\n    carla::geom::Location walker_location = walkers[id]->GetLocation();\n\n    // Check if the walker's position is within the specified distance.\n    if (walker_location.DistanceSquared(direction) <= squared_distance) {\n\n      // Get the walker's crowd agent.\n      const auto &crowd_agent = walkers[id]->GetCrowdAgent();\n\n      // Check if the crowd agent is valid.\n      if (crowd_agent) {\n\n        // Get the walker's crowd agent state.\n        const auto &crowd_agent_state = crowd_agent->GetCrowdAgentState();\n\n        // Check if the walker's crowd agent state is valid.\n        if (crowd_agent_state) {\n\n          // Get the walker's crowd agent state's neighbors.\n          const auto &neighbors = crowd_agent_state->GetNeighbors();\n\n          // Iterate over the neighbors.\n          for (auto &neighbor : neighbors) {\n\n            // Get the neighbor's id.\n            int neighbor_id = neighbor.GetAgentId();\n\n            // Check if the neighbor's id is valid.\n            if (neighbor_id != -1) {\n\n              // Check if the neighbor is a vehicle.\n              if (vehicles", "CodeBleu_score": 43.58203639445263}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tstd::lock_guard<std::mutex> lock(m_vehicle_navigation_lock);\n  auto it = m_vehicle_navigation.find(id);\n  if (it != m_vehicle_navigation.end()) {\n    auto vehicle_actor = it->second;\n    auto vehicle_location = vehicle_actor->GetLocation();\n    auto squared_distance = vehicle_location.DistanceSquared(direction);\n    if (squared_distance < distance * distance) {\n      return m_crowd_manager->IsVehicleNear(vehicle_location, vehicle_actor->GetTransform().GetForwardVector());\n    }\n  }\n  return false;\n}", "CodeBleu_score": 49.38558384093888}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t// Search for the actor in the mapped walkers and vehicles\n\tauto it = _actor_map.find(id);\n\n\t// If the actor is not found, return false\n\tif (it == _actor_map.end()) {\n\t\treturn false;\n\t}\n\n\t// Enter a critical section\n\t{\n\t\t// Compute the squared distance\n\t\tfloat squared_distance = distance * distance;\n\n\t\t// Use the crowd system to determine if a vehicle is nearby\n\t\treturn _crowd_system->HasVehicleNear(it->second, squared_distance, direction);\n\t}\n}", "CodeBleu_score": 40.63958776799348}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t// Retrieve the current route point for the walker\n    RoutePoint *routePoint = info.GetCurrentRoutePoint();\n\n    // Create a WalkerEventVisitor with the current context\n    WalkerEventVisitor visitor(this, id, info, delta);\n\n    // Process the event at the current route point using boost::variant2::visit\n    EventResult result = boost::apply_visitor(visitor, routePoint->GetEvent());\n\n    // Return the result of the event execution\n    return result;\n}", "CodeBleu_score": 52.9201833346318}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t// Retrieve the current route point for the walker\n    const RoutePoint &routePoint = info.route->GetCurrentRoutePoint();\n    // Create a WalkerEventVisitor with the current context\n    WalkerEventVisitor visitor(this, id, info, routePoint, delta);\n    // Process the event at the current route point using boost::variant2::visit\n    return boost::apply_visitor(visitor, routePoint.event);\n}", "CodeBleu_score": 56.143454962087745}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t// Get the current route point\n    auto &route = info.route;\n    auto it = route.GetCurrent();\n    // Create a visitor with the current context\n    WalkerEventVisitor visitor(this, id, info, delta);\n    // Process the event at the current route point\n    return boost::apply_visitor(visitor, *it);\n}", "CodeBleu_score": 56.2781397641547}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        this->publisher_matched = true;\n        this->publisher_matched_count++;\n        if (this->publisher_matched_count == 1) {\n            this->publisher_first_connected = true;\n        } else {\n            this->publisher_first_connected = false;\n        }\n    } else if (info.current_count_change == -1) {\n        this->publisher_matched_count--;\n        if (this->publisher_matched_count == 0) {\n            this->publisher_matched = false;\n        }\n    } else {\n        std::cerr << \"error: publication matched current count change is \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 48.46723999464847}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        if (info.total_count_change == 1) {\n            matched_ = true;\n            first_connected_ = true;\n        } else if (info.total_count_change == 0) {\n            // A new match has been detected\n            if (matched_ == true) {\n                // This is the second time a match is detected, so the topic has been re-matched\n                first_connected_ = false;\n            }\n        } else {\n            logError(CARLA_LISTENER, \"Invalid PublicationMatchedStatus::total_count_change: \" << info.total_count_change);\n        }\n    } else if (info.current_count_change == -1) {\n        if (info.total_count_change == -1) {\n            matched_ = false;\n        } else if (info.total_count_change == 0) {\n            // A match has been lost\n        } else {\n            logError(CARLA_LISTENER, \"Invalid PublicationMatchedStatus::total_count_change: \" << info.total_count_change);\n        }\n    } else {\n        logError(CARLA_LISTENER, \"Invalid PublicationMatchedStatus::current_count_change: \" << info.current_count_change);\n    }\n}", "CodeBleu_score": 56.080304269018356}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        matched_ = info.current_count;\n        first_connected_ = true;\n        std::cout << \"Publication matched\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_ = info.current_count;\n        std::cout << \"Publication unmatched\" << std::endl;\n    } else {\n        std::cout << \"Publication matched change \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 67.43484885886073}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        if (info.total_count == 1) {\n            first_connected = true;\n        }\n        ++matched;\n    } else if (info.current_count_change == -1) {\n        --matched;\n        if (info.total_count == 0) {\n            delete reader;\n        }\n    } else {\n        std::cerr << \"invalid subscription handle\" << std::endl;\n    }\n}", "CodeBleu_score": 52.92492347694478}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched.\n\";\n        ++this->matched;\n        this->first_connected = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched.\n\";\n        --this->matched;\n        if (this->matched == 0) {\n            delete this->subscriber;\n            this->subscriber = nullptr;\n        }\n    } else {\n        std::cerr << \"Invalid subscription change count.\n\";\n    }\n}", "CodeBleu_score": 50.370064882059665}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        this->matched_ = true;\n        this->first_connected_ = true;\n        std::cout << \"Subscriber matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        this->matched_ = false;\n        if (info.current_count == 0) {\n            std::cout << \"Subscriber unmatched.\" << std::endl;\n            delete this->subscriber_;\n            this->subscriber_ = nullptr;\n        }\n    } else {\n        std::cerr << \"Invalid matched status for subscriber.\" << std::endl;\n    }\n}", "CodeBleu_score": 52.41234011348767}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif(!m_isGetKeyDefined)\n        return false;\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    //Objects that represent keys and are going to be serialized should be created in stack\n    m_keyBuffer = p_type->id;\n    if(!force_md5 && m_keyBuffer.size() <=16)\n    {\n        memcpy(handle->value,m_keyBuffer.data(),m_keyBuffer.size());\n    }\n    else\n    {\n        MD5 md5;\n        // Objects in stack may be not aligned => use an aligned buffer for the md5\n        unsigned char buffer[16] __attribute__ ((aligned(4)));\n        md5.init();\n        md5.update(m_keyBuffer.data(), (unsigned int)m_keyBuffer.size());\n        md5.finalize();\n        md5.getDigest(buffer);\n        memcpy(handle->value,buffer,16);\n    }\n    return true;\n}", "CodeBleu_score": 39.8703690749407}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif(!key_ptr)\n        return false;\n    CarlaCollisionEvent* type = static_cast<CarlaCollisionEvent*>(data);\n    //Serialization.\n    SerializedPayload_t payload(static_cast<uint32_t>(getSerializedSizeProvider(data)) + 4);\n    memcpy(payload.data, &type->event_id, 4);\n    payload.length = 4;\n    if (type->collision_actor1.length > 0) {\n        memcpy(payload.data + payload.length, type->collision_actor1.data, type->collision_actor1.length);\n        payload.length += type->collision_actor1.length;\n    }\n    if (type->collision_actor2.length > 0) {\n        memcpy(payload.data + payload.length, type->collision_actor2.data, type->collision_actor2.length);\n        payload.length += type->collision_actor2.length;\n    }\n    if (type->collision_actor1_type.length > 0) {\n        memcpy(payload.data + payload.length, type->collision_actor1_type.data, type->collision_actor1_type.length);\n        payload.length += type->collision_actor1_type.length;\n    }\n    if (type->collision_actor2_type.length > 0) {\n        memcpy(payload.data + payload.length, type->collision_actor2_type.data, type->collision_actor2_type.length);\n        payload.length += type->collision_actor2_type.length;\n    }\n    if (type->collision_impulse.length > 0) {\n        memcpy(payload.data + payload.length, type->collision_impulse.data, type->collision_impulse.length);\n        payload.length += type->collision_impulse.length;\n    }\n    if (type->collision_location.length > 0) {\n        memcpy(payload.data + payload.length, type->collision_location.data, type->collision_location", "CodeBleu_score": 22.939409041942444}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif(!m_isGetKeyDefined)\n        return false;\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Serialization.\n    FastBuffer buffer;\n    buffer.add((char*) data, m_typeSize);\n\n    // Key definition.\n    if(p_type->collision_info.size() > 0) {\n        for(size_t i = 0; i < p_type->collision_info.size(); i++) {\n            buffer.add((char*) &p_type->collision_info[i].first, sizeof(p_type->collision_info[i].first));\n            buffer.add((char*) &p_type->collision_info[i].second, sizeof(p_type->collision_info[i].second));\n        }\n    }\n\n    // Get key.\n    if(!force_md5 && m_KeyBuffer.length() == 16) {\n        *handle = *((InstanceHandle_t*) (m_KeyBuffer.data()));\n    } else {\n        MD5 md5;\n        md5.init();\n        md5.update(buffer.data(), buffer.getSize());\n        md5.finalize();\n        if(force_md5 || m_KeyBuffer.length() != 16) {\n            m_KeyBuffer.assign(md5.digest, 16);\n        }\n        *handle = *((InstanceHandle_t*) (m_KeyBuffer.data()));\n    }\n    return true;\n}", "CodeBleu_score": 47.25644139701336}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t// Object that manages a buffer that can be dynamically resized.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        CarlaEgoVehicleControlPubSubType::serialize(data, &ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n    return true;\n}", "CodeBleu_score": 75.52374396731238}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t// Object that manages a buffer to store serialized data.\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        CarlaEgoVehicleControl *p_type = (CarlaEgoVehicleControl *) data; // Deserialized data.\n        ser << p_type->steer;\n        ser << p_type->throttle;\n        ser << p_type->brake;\n        ser << p_type->hand_brake;\n        ser << p_type->reverse;\n        ser << p_type->manual_gear_shift;\n        ser << p_type->gear;\n        ser << p_type->mode;\n        payload->length = (uint32_t) ser.getSerializedDataLength(); //Get the serialized length\n        return true;\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n}", "CodeBleu_score": 62.61438283319969}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t// Object that manages a buffer of bytes to be used in a serialization.\n    // It allows to serialize data in the buffer, managing its size.\n    // It is always used in the serialization process.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    // It allows to serialize data in the buffer, using different data types.\n    // It is always used in the serialization process.\n    eprosima::fastcdr::Cdr cdr(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = cdr.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    cdr << payload->encapsulation;\n    try\n    {\n        // Serialize the object\n        cdr << *((CarlaEgoVehicleControl*)data);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(cdr.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 66.66230800877175}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t// check if the target is already set\n    if (_target_system_id != 0) {\n        return;\n    }\n\n    switch (msg.msgid) {\n        case MAVLINK_MSG_ID_LOCATION:\n            _target_system_id = msg.sysid;\n            _target_component_id = msg.compid;\n            _target_type = MAV_TYPE_GCS;\n            _target_location = *(mavlink_location_t *)&msg.payload64[0];\n            _target_location_time = hal.scheduler->millis();\n            _target_position = Vector3f(_target_location.vx, _target_location.vy, _target_location.vz);\n            _target_velocity = Vector3f(_target_location.vx_speed, _target_location.vy_speed, _target_location.vz_speed);\n            _target_acceleration = Vector3f(_target_location.vx_accel, _target_location.vy_accel, _target_location.vz_accel);\n            _target_set = true;\n            request_streams();\n            break;\n        case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n            _target_system_id = msg.sysid;\n            _target_component_id = msg.compid;\n            _target_type = MAV_TYPE_FIXED_WING;\n            _target_global_position = *(mavlink_global_position_int_t *)&msg.payload64[0];\n            _target_global_position_time = hal.scheduler->millis();\n            _target_position = Vector3f(_target_global_position.lat/1.0e7, _target_global_position.lon/1.0e7, _target_global_position.alt/100.0);\n            _target_velocity = Vector3f(_target_global_position.vx/100.0, _target_global_position.vy/100.0, _target_global_position.vz/100.0", "CodeBleu_score": 32.653981855052486}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (target_system_id != 0) {\n        // target already set, exit immediately\n        return;\n    }\n\n    switch (msg.msgid) {\n        case MAVLINK_MSG_ID_LOCATION:\n        case MAVLINK_MSG_ID_LOCATION_INT:\n        case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n        case MAVLINK_MSG_ID_GPS_RAW_INT:\n        case MAVLINK_MSG_ID_GPS2_RAW:\n        case MAVLINK_MSG_ID_HIL_GPS:\n        case MAVLINK_MSG_ID_GPS_INJECT_DATA:\n        case MAVLINK_MSG_ID_GPS2_RAW:\n        case MAVLINK_MSG_ID_GPS_STATUS:\n            // target location messages\n            target_system_id = msg.sysid;\n            if (target_system_id != 0) {\n                // request data streams\n                mavlink_msg_request_data_stream_send(chan, target_system_id, target_component_id, MAV_DATA_STREAM_ALL, 1, 1000);\n                mavlink_msg_request_data_stream_send(chan, target_system_id, target_component_id, MAV_DATA_STREAM_EXTRA1, 1, 1000);\n                mavlink_msg_request_data_stream_send(chan, target_system_id, target_component_id, MAV_DATA_STREAM_EXTRA2, 1, 1000);\n                mavlink_msg_request_data_stream_send(chan, target_system_id, target_component_id, MAV_DATA_STREAM_EXTRA3, 1, 1000);\n            }\n            break;\n        case MAVLINK_MSG_ID_ATTITUDE:\n        case MAVLINK_MSG_ID_ATTITUDE_QUATERNION:", "CodeBleu_score": 30.710068892558922}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (target_set) {\n        return;\n    }\n    switch (msg.msgid) {\n    case MAVLINK_MSG_ID_HEARTBEAT:\n        {\n            mavlink_heartbeat_t hb;\n            mavlink_msg_heartbeat_decode(&msg, &hb);\n            if (hb.type == MAV_TYPE_GCS) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_ONBOARD_CONTROLLER) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_GIMBAL) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_ADSB) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_GROUND_ROVER) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_SURFACE_BOAT) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_SUBMARINE) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_HELICOPTER) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_TRICOPTER) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_QUADROTOR) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_HEXAROTOR) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_OCTOROTOR) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_TRICOPTER) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_COAXIAL) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_HELICOPTER) {\n                return;\n            }\n            if (hb.type == MAV_TYPE_ANTEN", "CodeBleu_score": 35.51325213263282}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result;\n\n    result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n\n    if (result == MAV_RESULT_ACCEPTED) {\n        _calibration_needed = true;\n    }\n\n    return result;\n}", "CodeBleu_score": 66.02444952023319}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _calibrate_altitude_next = true;\n    }\n    return result;\n}", "CodeBleu_score": 67.97230770056277}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = _handle_command_preflight_calibration(msg);\n\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_calibration_mask |= SENSOR_BARO;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 41.830844308080465}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    // check command target\n    if (packet.target_system == get_own_system_id() && packet.target_component == get_own_component_id()) {\n\n        // check command parameter\n        if (packet.param1 == 1.0) {\n\n            // arm the servos\n            if (servo_arm(true)) {\n                result = MAV_RESULT_ACCEPTED;\n            }\n        } else if (packet.param1 == 0.0) {\n\n            // disarm the servos\n            if (servo_arm(false)) {\n                result = MAV_RESULT_ACCEPTED;\n            }\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 48.73870323019164}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t// Check if this is the right component\n    if (packet.target_component != _component_id) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    // Check if we can arm\n    if (!hal.util->get_soft_armed()) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if we can arm\n    if (!hal.util->safety_switch_state()) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if we can arm\n    if (hal.gpio->read(hal.gpio->get_pin(HAL_GPIO_1_PIN)) == 0) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if we can arm\n    if (hal.gpio->read(hal.gpio->get_pin(HAL_GPIO_2_PIN)) == 0) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if we can arm\n    if (hal.gpio->read(hal.gpio->get_pin(HAL_GPIO_3_PIN)) == 0) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if we can arm\n    if (hal.gpio->read(hal.gpio->get_pin(HAL_GPIO_4_PIN)) == 0) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if we can arm\n    if (hal.gpio->read(hal.gpio->get_pin(HAL_GPIO_5_PIN)) == 0) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if we can arm\n    if (hal.gpio->read(hal.gpio->get_pin(HAL_GPIO_6_PIN)) == 0) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check", "CodeBleu_score": 40.17608739914472}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n  if (packet.param1 == 1.0) {\n    // arm servos\n    result = MAV_RESULT_ACCEPTED;\n  } else if (packet.param1 == 0.0) {\n    // disarm servos\n    result = MAV_RESULT_ACCEPTED;\n  }\n\n  return result;\n}", "CodeBleu_score": 50.21987799678003}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tuint8_t channel;\n    uint8_t payload_size;\n    uint8_t update_rate;\n    uint8_t payload[10];\n    uint8_t payload_length;\n\n    // iterate over the available channels\n    for (channel = 0; channel < GCS_NUM_CHANNELS; channel++) {\n        // check if the channel is available\n        if (channel_available[channel]) {\n            // check if the payload size is less than the maximum payload size\n            payload_size = sizeof(payload);\n            if (payload_size < GCS_MAX_PAYLOAD_SIZE) {\n                // check if the update rate is less than the maximum update rate\n                update_rate = 10;\n                if (update_rate < GCS_MAX_UPDATE_RATE) {\n                    // build the payload\n                    payload[0] = sysid;\n                    payload[1] = compid;\n                    payload[2] = GCS_MSG_TYPE_POSITION;\n                    payload[3] = update_rate;\n                    payload_length = 4;\n                    // send the request\n                    send_request(channel, GCS_MSG_TYPE_REQUEST_DATASTREAM, payload, payload_length);\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 42.46950542482527}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\tif (sysid == 0 || compid == 0) {\n    return;\n  }\n  // Iterate over all available GCS channels\n  for (uint8_t i = 0; i < GCS_CHANNEL_COUNT; i++) {\n    // Check if the channel is available\n    if (gcs_channels[i].available) {\n      // Check if the channel has enough payload space to stream position\n      if (gcs_channels[i].payload_space >= 10) {\n        // Send a request to start the data stream\n        gcs_channels[i].send_position_request(sysid, compid, 10);\n        // Update the channel's available status\n        gcs_channels[i].available = false;\n        // Update the channel's component ID\n        gcs_channels[i].compid = compid;\n        // Update the channel's system ID\n        gcs_channels[i].sysid = sysid;\n        // Update the channel's payload space\n        gcs_channels[i].payload_space = 0;\n        // Exit the loop\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 44.246421256314186}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// iterate over the available GCS channels\n  for (uint8_t i = 0; i < GCS_NUM_CHANNELS; i++) {\n    // check if the channel is available\n    if (gcs_channel[i].available) {\n      // check if the channel has space for the data\n      if (gcs_channel[i].payload_space >= MAVLINK_MSG_ID_LOCAL_POSITION_NED_LEN) {\n        // send the request to start the data stream\n        mavlink_msg_request_data_stream_send(gcs_channel[i].chan, MAV_COMP_ID_ALL, MAV_COMP_ID_ALL, MAVLINK_DATA_STREAM_POSITION, 10, 1);\n        // set the channel's component ID\n        gcs_channel[i].compid = compid;\n        // set the channel's system ID\n        gcs_channel[i].sysid = sysid;\n        // set the channel's message ID\n        gcs_channel[i].msgid = MAVLINK_MSG_ID_LOCAL_POSITION_NED;\n        // set the channel's available flag\n        gcs_channel[i].available = false;\n        // return\n        return;\n      }\n    }\n  }\n}", "CodeBleu_score": 45.620014504268944}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t// Retrieve the AHRS instance\n\tAHRS* ahrs = ahrs_interface_->get_ahrs();\n\n\t// Check for zero pitch cosine\n\tif (ahrs->getPitch() != 0) {\n\n\t\t// Calculate the earth frame pitch and yaw\n\t\tef_pitch = atan2(ahrs->getRoll() * sin(pitch) + ahrs->getPitch() * cos(pitch), ahrs->getPitch() * sin(pitch) - ahrs->getRoll() * cos(pitch));\n\t\tef_yaw = yaw - ahrs->getYaw();\n\n\t\treturn true;\n\n\t}\n\n\treturn false;\n\n}", "CodeBleu_score": 49.34432383860315}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAHRS *ahrs = ahrs_interface->get_ahrs();\n\n  if (ahrs->getPitchCos() != 0) {\n    ef_pitch = atan2(ahrs->getRollSin() * sin(pitch) + ahrs->getPitchSin() * cos(pitch),\n                     ahrs->getPitchCos() * cos(pitch) - ahrs->getRollSin() * sin(pitch));\n    ef_yaw = yaw - ahrs->getYaw();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 50.50282034330225}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t// Retrieve AHRS instance\n  AHRS* ahrs = ahrs_instance();\n\n  // Check for zero pitch cosine\n  if (ahrs->getPitch() == 0) {\n    return false;\n  }\n\n  // Convert body frame pitch and yaw angles to earth frame angles\n  ef_pitch = atan2(sin(pitch)*cos(yaw), cos(pitch));\n  ef_yaw = atan2(sin(yaw), cos(yaw)*sin(pitch));\n\n  return true;\n\n}", "CodeBleu_score": 45.506743130442054}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t// get the navigation status\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float distance = nav_status.distance;\n    float bearing = nav_status.bearing;\n\n    // get the parameters\n    Parameters &g = tracker.g;\n\n    // check if the target distance is valid or no minimum distance is set\n    if (nav_status.valid || g.min_distance == 0) {\n        // calculate the yaw and pitch in centidegrees\n        float yaw = bearing;\n        float pitch = (distance - g.distance_min) * 100.0f / (g.distance_max - g.distance_min) * g.pitch_max;\n\n        // check if direction is reversed\n        bool direction_reversed = get_ef_yaw_direction();\n\n        // calculate the angle error in earth frame\n        calc_angle_error(pitch, yaw, direction_reversed);\n\n        // update the pitch and yaw servos\n        tracker.pitch_servo_out_filt.set(pitch);\n        tracker.yaw_servo_out_filt.set(yaw);\n    }\n}", "CodeBleu_score": 58.74827711482009}, {"code": "void Mode::update_auto(void){\n\tParameters &g = tracker.g;\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float pitch = 0.0f;\n    float yaw = 0.0f;\n    bool direction_reversed = false;\n\n    // if we are navigating to a waypoint, get the bearing and distance to the waypoint\n    if (nav_status.nav_mode == NavMode::nav_wp) {\n        // get bearing and distance to waypoint\n        float bearing;\n        float distance;\n        tracker.calc_bearing_and_distance(bearing, distance);\n        // set bearing and distance to nav_status\n        nav_status.bearing = bearing;\n        nav_status.distance = distance;\n    }\n\n    // if we are navigating to a waypoint, calculate the pitch and yaw\n    if (nav_status.nav_mode == NavMode::nav_wp) {\n        // calculate pitch and yaw based on distance to waypoint\n        if (nav_status.distance > g.wp_nav_min_dist) {\n            pitch = g.wp_nav_pitch;\n            yaw = nav_status.bearing;\n        } else {\n            pitch = g.wp_nav_pitch_min;\n            yaw = nav_status.bearing;\n        }\n    }\n\n    // if we are navigating to a vehicle, calculate the pitch and yaw\n    if (nav_status.nav_mode == NavMode::nav_vehicle) {\n        // calculate pitch and yaw based on distance to vehicle\n        if (nav_status.distance > g.vehicle_nav_min_dist) {\n            pitch = g.vehicle_nav_pitch;\n            yaw = nav_status.bearing;\n        } else {\n            pitch = g.vehicle_nav_pitch_min;\n            yaw = nav_status.bearing;\n        }\n    }\n\n    // if we are navigating to a location, calculate the pitch and yaw\n    if (nav_status.nav_mode == NavMode::nav_location) {", "CodeBleu_score": 50.80699038688233}, {"code": "void Mode::update_auto(void){\n\tParameters &g = tracker.g;\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    struct Tracker::NavStatus &nav_status_prev = tracker.nav_status_prev;\n    struct Tracker::NavStatus &nav_status_next = tracker.nav_status_next;\n    float yaw;\n    float pitch;\n    bool direction_reversed;\n\n    // set target yaw and pitch\n    if (nav_status.bearing_valid) {\n        // target is valid\n        yaw = nav_status.bearing;\n        pitch = nav_status.altitude;\n    } else {\n        // target is invalid, use previous target\n        yaw = nav_status_prev.bearing;\n        pitch = nav_status_prev.altitude;\n    }\n\n    // check if direction is reversed\n    direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // update pitch and yaw servos\n    if (nav_status.distance_valid || g.min_distance == 0) {\n        // target is valid or no minimum distance is set\n        tracker.update_pitch_yaw(nav_status.angle_error_pitch, nav_status.angle_error_yaw);\n    } else {\n        // target is invalid and minimum distance is set\n        // use previous target\n        tracker.update_pitch_yaw(nav_status_prev.angle_error_pitch, nav_status_prev.angle_error_yaw);\n    }\n}", "CodeBleu_score": 54.73228010806387}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\tif (GPS.last_message_time() != last_message_time_GPS) {\n    last_message_time_GPS = GPS.last_message_time();\n    if (GPS.fix() >= 3) {\n      if (GPS.location().is_valid()) {\n        if (ground_start_countdown > 0) {\n          ground_start_countdown--;\n          if (ground_start_countdown == 1) {\n            set_home_location();\n          }\n        }\n      }\n      else {\n        ground_start_countdown = 5;\n      }\n    }\n  }\n}", "CodeBleu_score": 40.72624444141287}, {"code": "void Tracker::update_GPS(void){\n\t// read data from the GPS in the main loop\n  char c = GPS.read();\n  // if a sentence is received, we can check the checksum, parse it...\n  if (GPS.newNMEAreceived()) {\n    // check if the sentence is valid\n    if (!GPS.parse(GPS.lastNMEA()))\n      return;\n  }\n\n  // if millis() or timer wraps around, we'll just reset it\n  if (timer > millis())\n    timer = millis();\n\n  // approximately every 2 seconds or so, print out the current stats\n  if (millis() - timer > 2000) {\n    timer = millis(); // reset the timer\n\n    if (GPS.lastNMEA()[0] != '$')\n      return;\n\n    if (GPS.fix) {\n      // if the GPS has a fix, update the last_fix_time\n      last_fix_time = millis();\n\n      // if the last fix time is less than 3 seconds old, set the home location\n      if (millis() - last_fix_time < 3000) {\n        if (GPS.fixquality == 3) {\n          // if the GPS has a 3D fix, set the home location\n          home_location.latitude = GPS.latitudeDegrees;\n          home_location.longitude = GPS.longitudeDegrees;\n          home_location.altitude = GPS.altitude;\n          home_location_set = true;\n          Serial.println(\"GPS fix acquired\");\n        }\n      }\n    }\n  }\n\n  // if the GPS has not had a fix in 3 seconds, reset the countdown\n  if (millis() - last_fix_time > 3000) {\n    countdown = 0;\n  }\n\n  // if the GPS has a fix and the countdown is greater than 0, decrement the countdown\n  if (GPS.fix && countdown > 0) {\n    countdown--;\n  }\n\n  // if the countdown is 0, the vehicle is", "CodeBleu_score": 48.81414537347838}, {"code": "void Tracker::update_GPS(void){\n\tGPS_data.update();\n  if (GPS_data.last_message_time != GPS_data.last_message_time_prev) {\n    if (GPS_data.fix_type >= 3) {\n      if (GPS_data.valid) {\n        if (ground_start_countdown > 0) {\n          ground_start_countdown--;\n          if (ground_start_countdown == 1) {\n            set_home_location();\n          }\n        }\n      }\n      else {\n        ground_start_countdown = ground_start_count;\n      }\n    }\n  }\n}", "CodeBleu_score": 35.00565240470082}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t//Serial.print(\"Pitch: \");\n  //Serial.println(pitch);\n  if (pitch < 0) {\n    pitch = 0;\n  }\n  if (pitch > 180) {\n    pitch = 180;\n  }\n  int servo_pos = map(pitch, 0, 180, 1000, 2000);\n  //Serial.print(\"Servo: \");\n  //Serial.println(servo_pos);\n  pitch_onoff_servo.writeMicroseconds(servo_pos);\n}", "CodeBleu_score": 15.617872016009004}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t// Only update the pitch if the pitch has changed\n  if (pitch != pitch_onoff_servo_last) {\n\n    // Update the last pitch\n    pitch_onoff_servo_last = pitch;\n\n    // Update the pitch servo\n    pitch_onoff_servo.write(pitch);\n\n    // If the pitch is less than 10 degrees, turn off the servo\n    if (pitch < 10) {\n      pitch_onoff_servo.detach();\n    } else {\n      pitch_onoff_servo.attach(pitch_onoff_servo_pin);\n    }\n  }\n}", "CodeBleu_score": 21.658391604658732}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\tif (pitch > 0) {\n    digitalWrite(PITCH_ONOFF_SERVO_PIN, HIGH);\n  }\n  else {\n    digitalWrite(PITCH_ONOFF_SERVO_PIN, LOW);\n  }\n}", "CodeBleu_score": 13.326894925690988}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n    if (!arming_checks_enabled(ARMING_CHECK_BARO)) {\n        return true;\n    }\n    if (g.compass_enabled) {\n        // check that we have a barometer reference\n        if (!ahrs.barometer_init_status()) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro ref\"));\n            }\n            return false;\n        }\n        // check that the baro altitude is within 1m of the inertial nav altitude\n        float baro_alt = ahrs.get_barometer_altitude();\n        float inav_alt = inertial_nav.get_altitude();\n        if (abs(baro_alt - inav_alt) > 1.0f) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro diff\"));\n            }\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 50.11685352725915}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (!arm_check(ARMING_CHECK_BARO, display_failure)) {\n        return false;\n    }\n\n    if (baro_alt_max_cm - baro_alt_min_cm > 100) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro Error\"));\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 26.863173059945026}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (arming_checks_enabled(ARMING_CHECK_BARO)) {\n        // check baro\n        if (!g.baro_ref_cm.get() && !g.baro_ref_cm.set_and_save(barometer.get_reference())) {\n            if (display_failure) {\n                GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, \"Failed to set baro reference\");\n            }\n            return false;\n        }\n        if (barometer.get_raw_pressure() <= 0) {\n            if (display_failure) {\n                GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, \"Baro pressure invalid\");\n            }\n            return false;\n        }\n        if (barometer.get_raw_altitude() <= 0) {\n            if (display_failure) {\n                GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, \"Baro altitude invalid\");\n            }\n            return false;\n        }\n        if (labs(barometer.get_altitude() - inertial_nav.get_altitude()) > g.baro_alt_max_cm.get()) {\n            if (display_failure) {\n                GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, \"Baro alt diff exceeded\");\n            }\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 49.498247806343045}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (aparm.rtl_alt_type == AP_RTL::RTL_ALT_TERRAIN) {\n        if (aparm.terrain_source == AP_TERRAIN_SOURCE_TERRAIN) {\n            return true;\n        }\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 46.41284054172051}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (terrain_source() == TerrainSourceRangefinder) {\n        return false;\n    }\n    if (terrain_source() == TerrainSourceTerrainDB &&\n        _rtl_alt_type == RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 54.90652445177302}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t// if we are using rangefinder for terrain, we don't need a terrain database\n    if (ap.land_complete_maybe_kill && ap.land_complete_maybe_kill->using_rangefinder()) {\n        return false;\n    }\n    // if we are using terrain database for terrain, we need a terrain database\n    if (ap.land_complete_maybe_kill && ap.land_complete_maybe_kill->using_terrain_database()) {\n        return true;\n    }\n    // otherwise defer to the base class\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 62.25806199381113}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t// set loop time\n    attitude_control.set_dt(scheduler.interval_100());\n\n    // run attitude controller\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 23.76937819313466}, {"code": "void Copter::run_rate_controller(){\n\t// run attitude controller\n    attitude_control.rate_controller_run();\n\n    // run position controller\n    position_control.rate_controller_run();\n\n    // run motor controllers\n    motors.rate_controller_run();\n}", "CodeBleu_score": 17.121765409013612}, {"code": "void Copter::run_rate_controller(){\n\t// set loop time for attitude and position controllers\n    attitude_control.set_dt(scheduler.interval_100());\n    pos_control.set_dt(scheduler.interval_100());\n\n    // run attitude controller\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 36.498972944073124}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    return mode_guided.update_destination(old_loc, new_loc);\n}", "CodeBleu_score": 38.37259811153257}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // exit if we don't have a valid location\n    if (!new_loc.is_valid()) {\n        return false;\n    }\n\n    // exit if we don't have a valid location\n    if (!old_loc.is_valid()) {\n        return false;\n    }\n\n    // exit if altitude frames don't match\n    if (old_loc.alt_is_relative() != new_loc.alt_is_relative()) {\n        return false;\n    }\n\n    // exit if new location is not a valid waypoint\n    if (!mission.get_next_waypoint_location(new_loc)) {\n        return false;\n    }\n\n    // exit if old location is not a valid waypoint\n    if (!mission.get_next_waypoint_location(old_loc)) {\n        return false;\n    }\n\n    // exit if old and new locations are not the same\n    if (old_loc != new_loc) {\n        return false;\n    }\n\n    // set new location as target\n    mode_guided.set_destination(new_loc);\n\n    return true;\n}", "CodeBleu_score": 53.62658893066155}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    return mode_guided.update_destination(old_loc, new_loc);\n}", "CodeBleu_score": 38.37259811153257}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (aux_switch_pos() == ch_flag) {\n    if (mode != _mode) {\n      set_mode(mode);\n    }\n  } else if (_mode == mode) {\n    rc().reset_mode_switch();\n  }\n}", "CodeBleu_score": 53.595395448474804}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (rc().get_aux_switch_pos(ch_flag) == AuxSwitchPos::HIGH) {\n    copter_->set_mode(mode);\n  } else if (copter_->get_mode() == mode) {\n    rc().reset_mode_switch();\n  }\n}", "CodeBleu_score": 55.914689773455486}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (aux_switch_pos() == ch_flag) {\n    if (mode != mode_switch().get_mode()) {\n      mode_switch().set_mode(mode);\n    } else {\n      rc().reset_mode_switch();\n    }\n  }\n}", "CodeBleu_score": 53.14463639788982}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\tfloat roll_trim, pitch_trim;\n\n    // exit immediately if not armed\n    if (!motors.armed()) {\n        return;\n    }\n\n    // get roll and pitch trim from RC\n    roll_trim = channel_roll->control_in;\n    pitch_trim = channel_pitch->control_in;\n\n    // convert trim to radians\n    roll_trim *= (float)g.trim_roll_max / 4500.0f;\n    pitch_trim *= (float)g.trim_pitch_max / 4500.0f;\n\n    // add trim to ahrs trim\n    ahrs.set_trim(Vector3f(roll_trim, pitch_trim, 0));\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send trim values to GCS\n    gcs_send_text_P(SEVERITY_INFO,PSTR(\"Trim Saved\"));\n}", "CodeBleu_score": 47.55934893960225}, {"code": "void Copter::save_trim(){\n\t// exit immediately if not armed\n    if (!motors.armed()) {\n        return;\n    }\n\n    // get pilot input\n    float roll_in = channel_roll->control_in;\n    float pitch_in = channel_pitch->control_in;\n\n    // convert to radians\n    float roll_trim = radians(roll_in*4500.0f/1000.0f);\n    float pitch_trim = radians(pitch_in*4500.0f/1000.0f);\n\n    // add trim to ahrs\n    ahrs.set_trim(Vector3f(roll_trim, pitch_trim, 0));\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send message\n    gcs_send_text_P(SEVERITY_INFO,PSTR(\"Trim Saved\"));\n}", "CodeBleu_score": 49.29360495122591}, {"code": "void Copter::save_trim(){\n\t// exit immediately if not armed\n    if (!motors.armed()) {\n        return;\n    }\n\n    // exit immediately if not in MANUAL flight mode\n    if (control_mode != MANUAL) {\n        return;\n    }\n\n    // exit immediately if we're not in level mode\n    if (flight_mode != ATTITUDE && flight_mode != ATTITUDE_LEVEL) {\n        return;\n    }\n\n    // get current roll and pitch inputs\n    float roll_input = channel_roll->control_in;\n    float pitch_input = channel_pitch->control_in;\n\n    // exit immediately if not in trim mode\n    if (roll_input != 0 || pitch_input != 0) {\n        return;\n    }\n\n    // get current roll and pitch trim\n    float roll_trim = ahrs.get_trim_roll();\n    float pitch_trim = ahrs.get_trim_pitch();\n\n    // convert to radians\n    roll_trim = radians(roll_trim);\n    pitch_trim = radians(pitch_trim);\n\n    // add trim to ahrs trim\n    ahrs.set_trim(roll_trim, pitch_trim);\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send message\n    gcs_send_text_P(SEVERITY_INFO,PSTR(\"Trim Saved\"));\n}", "CodeBleu_score": 45.848702223342244}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// Retrieve the copter's velocity\n    float velocity[2] = {copter_state.velocity[0], copter_state.velocity[1]};\n\n    // Calculate the speed squared\n    float speed_squared = sq(velocity[0]) + sq(velocity[1]);\n\n    // If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components\n    if (copter_state.position_is_valid && speed_squared > MIN_SPEED_SQUARED) {\n        look_ahead_yaw_angle = atan2f(velocity[1], velocity[0]);\n    }\n\n    // Return the computed look-ahead yaw angle\n    return look_ahead_yaw_angle;\n}", "CodeBleu_score": 45.005513699375335}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat speed_sq = 0.0;\n    float yaw_angle = 0.0;\n\n    // Get the copter's velocity\n    Vector3f vel = _ahrs.get_velocity();\n\n    // Calculate the speed squared\n    speed_sq = vel.length_squared();\n\n    // If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n    if ( _ahrs.get_pos_accuracy() < 100 && speed_sq > 0.1f ) {\n        yaw_angle = atan2( vel.y, vel.x );\n    }\n\n    // Return the computed look-ahead yaw angle\n    return yaw_angle;\n}", "CodeBleu_score": 42.36022553935969}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat speed_sq = 0.0;\n  float look_ahead_yaw = 0.0;\n\n  // Get the velocity of the copter\n  Vector3f velocity = _ahrs.get_velocity();\n\n  // Calculate the speed squared\n  speed_sq = velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z;\n\n  // If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n  if ((_ahrs.get_pos_ok()) && (speed_sq > 0.1)) {\n    // Calculate the look-ahead yaw angle using the arctangent of the velocity components\n    look_ahead_yaw = atan2(velocity.y, velocity.x);\n  }\n\n  // Return the computed look-ahead yaw angle\n  return look_ahead_yaw;\n}", "CodeBleu_score": 45.0873054094056}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER) {\n        if (rudder_arming_disabled() || throttle_zero()) {\n            return false;\n        }\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 32.00340246919138}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t// rudder arming disabled or throttle not zero?\n    if (method == AP_Arming::RUDDER) {\n        if (aparm.rudder_arming_disabled || _throttle_sum > 0.0f) {\n            return false;\n        }\n    }\n\n    // bypass arming checks if we've already armed the watchdog\n    if (method == AP_Arming::WATCHDOG) {\n        if (_watchdog_armed) {\n            return true;\n        }\n    }\n\n    // call parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 39.64561318569769}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER) {\n        if (aparm.rudder_arming == 0 || aparm.throttle_zero) {\n            return false;\n        }\n    }\n    if (aparm.arming_checks == 0 || aparm.watchdog_armed) {\n        return true;\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 45.017718507861645}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t// if we are already armed we don't need to do anything\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // check that we are not in a calibration mode\n    if (plane.gcs_control_in_guided()) {\n        return false;\n    }\n\n    // check that we are not in a calibration mode\n    if (plane.gcs_control_in_calibration()) {\n        return false;\n    }\n\n    // check that the vehicle is not in a flight mode that should prevent arming\n    if (plane.flight_stage == AP_Vehicle::FixedWing::FLIGHT_LAND) {\n        return false;\n    }\n\n    // check that the vehicle is not in a flight mode that should prevent arming\n    if (plane.flight_stage == AP_Vehicle::FixedWing::FLIGHT_LAND) {\n        return false;\n    }\n\n    // check that the vehicle is not in a flight mode that should prevent arming\n    if (plane.flight_stage == AP_Vehicle::FixedWing::FLIGHT_LAND) {\n        return false;\n    }\n\n    // check that the vehicle is not in a flight mode that should prevent arming\n    if (plane.flight_stage == AP_Vehicle::FixedWing::FLIGHT_LAND) {\n        return false;\n    }\n\n    // check that the vehicle is not in a flight mode that should prevent arming\n    if (plane.flight_stage == AP_Vehicle::FixedWing::FLIGHT_LAND) {\n        return false;\n    }\n\n    // check that the vehicle is not in a flight mode that should prevent arming\n    if (plane.flight_stage == AP_Vehicle::FixedWing::FLIGHT_LAND) {\n        return false;\n    }\n\n    // check that the vehicle is not in a flight mode that should prevent arming\n    if (plane.flight_stage == AP_Vehicle::FixedWing::FLIGHT_LAND) {\n        return false", "CodeBleu_score": 33.926354523287884}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t// return immediately if already armed\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // do arming checks\n    if (do_arming_checks) {\n        if (!arming_checks(method)) {\n            return false;\n        }\n    }\n\n    // update home location\n    update_home();\n\n    // set home in AHRS system\n    plane.ahrs.set_home(plane.home);\n\n    // update current location\n    update_current();\n\n    // set armed state\n    hal.util->set_soft_armed(true);\n\n    // set delay arming flag\n    delay_arming = true;\n\n    // send status text\n    plane.gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Throttle armed\"));\n\n    return true;\n}", "CodeBleu_score": 60.76731678054108}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t// exit immediately if already armed\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // check if we are already in the process of arming\n    if (hal.util->get_soft_arming()) {\n        return false;\n    }\n\n    // check if we are in a low battery condition\n    if (hal.util->get_low_battery_voltage()) {\n        return false;\n    }\n\n    // check if we are in a low airspeed condition\n    if (plane.airspeed.get_airspeed() < plane.aparm.airspeed_min_arm) {\n        return false;\n    }\n\n    // check if we are in a low GPS fix condition\n    if (plane.gps.status() < AP_GPS::GPS_OK_FIX_3D) {\n        return false;\n    }\n\n    // check if we are in a high pitch or roll condition\n    if (fabsf(plane.ahrs.pitch_sensor) > AP_ARMING_PITCH_LIMIT_CD || fabsf(plane.ahrs.roll_sensor) > AP_ARMING_ROLL_LIMIT_CD) {\n        return false;\n    }\n\n    // check if we are in a high compass offset condition\n    if (plane.ahrs.compass_use_for_yaw && plane.ahrs.compass.get_offset_length() > AP_ARMING_COMPASS_OFFSET_LIMIT_CD) {\n        return false;\n    }\n\n    // check if we are in a high baro altitude condition\n    if (plane.barometer.get_altitude() > AP_ARMING_BARO_ALT_LIMIT_M) {\n        return false;\n    }\n\n    // check if we are in a high AGL condition\n    if (plane.barometer.get_altitude() - plane.current_loc.alt > AP_ARMING_AGL_LIMIT_M) {\n        return false;\n    }\n\n    // check if we are in a high GPS speed condition\n    if (plane.", "CodeBleu_score": 37.758823980660914}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// if already armed, return true\n    if (armed()) {\n        return true;\n    }\n\n    // check if a disarm button is configured\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, PSTR(\"No disarm button\"));\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.61330735049893}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// if already armed, return true\n    if (armed()) {\n        return true;\n    }\n\n    // if no disarm button is configured, display failure message and return false\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"No disarm button configured\"));\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.04880361262657}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// if already armed, return true\n    if (armed()) {\n        return true;\n    }\n\n    // if no disarm function, return false\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, \"No disarm button\");\n        }\n        return false;\n    }\n\n    // standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 72.18067920512}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x = x*cos(yaw) + y*sin(yaw);\n  float ne_y = -x*sin(yaw) + y*cos(yaw);\n\n  x = ne_x;\n  y = ne_y;\n\n}", "CodeBleu_score": 55.04532096379451}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x = x * cos(ahrs.yaw) + y * sin(ahrs.yaw);\n    float ne_y = -x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 61.58075303597117}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x, ne_y;\n    ne_x = x*cos(ahrs->getYaw()) + y*sin(ahrs->getYaw());\n    ne_y = -x*sin(ahrs->getYaw()) + y*cos(ahrs->getYaw());\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 62.59465391553659}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tfloat yaw_angle = packet.param1;\n    float yaw_speed = packet.param2;\n    float yaw_direction = packet.param3;\n    float yaw_relative = packet.param4;\n\n    if (yaw_angle > 360 || yaw_angle < 0) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (yaw_speed < 0 || yaw_speed > 100) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (yaw_direction != 0 && yaw_direction != 1) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (yaw_relative != 0 && yaw_relative != 1) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set yaw heading\n    if (yaw_relative == 0) {\n        // absolute yaw angle\n        if (yaw_direction == 0) {\n            // clockwise\n            copter.set_yaw_heading(yaw_angle);\n        } else {\n            // counter-clockwise\n            copter.set_yaw_heading(360 - yaw_angle);\n        }\n    } else {\n        // relative yaw angle\n        if (yaw_direction == 0) {\n            // clockwise\n            copter.set_yaw_heading(copter.get_yaw_heading() + yaw_angle);\n        } else {\n            // counter-clockwise\n            copter.set_yaw_heading(copter.get_yaw_heading() - yaw_angle);\n        }\n    }\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 32.27518164908806}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tfloat yaw_angle = packet.param1 * M_PI / 180.0f;\n    float yaw_rate = packet.param2 * M_PI / 180.0f;\n    float direction = packet.param3;\n    float relative_angle = packet.param4 * M_PI / 180.0f;\n\n    if (yaw_angle > 2*M_PI || yaw_angle < 0 || yaw_rate > 2*M_PI || yaw_rate < 0 || direction > 1 || direction < 0 || relative_angle > 2*M_PI || relative_angle < 0) {\n        return MAV_RESULT_DENIED;\n    }\n\n    if (direction == 0) {\n        // absolute angle\n        if (relative_angle != 0) {\n            return MAV_RESULT_DENIED;\n        }\n        _parent->set_yaw_heading(yaw_angle);\n    } else {\n        // relative angle\n        if (yaw_angle != 0) {\n            return MAV_RESULT_DENIED;\n        }\n        _parent->set_yaw_heading_relative(relative_angle);\n    }\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 33.91812505401045}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t// TODO: add your own logic here\n\t//   For example, you can add a new action based on the command\n\t//   or create a new class that handles the action\n\t//   and call the class here\n\n\t// TODO: add your own logic here\n\t//   For example, you can add a new action based on the command\n\t//   or create a new class that handles the action\n\t//   and call the class here\n\n\t// TODO: add your own logic here\n\t//   For example, you can add a new action based on the command\n\t//   or create a new class that handles the action\n\t//   and call the class here\n\n\t// TODO: add your own logic here\n\t//   For example, you can add a new action based on the command\n\t//   or create a new class that handles the action\n\t//   and call the class here\n\n\t// TODO: add your own logic here\n\t//   For example, you can add a new action based on the command\n\t//   or create a new class that handles the action\n\t//   and call the class here\n\n\t// TODO: add your own logic here\n\t//   For example, you can add a new action based on the command\n\t//   or create a new class that handles the action\n\t//   and call the class here\n\n\t// TODO: add your own logic here\n\t//   For example, you can add a new action based on the command\n\t//   or create a new class that handles the action\n\t//   and call the class here\n\n\t// TODO: add your own logic here\n\t//   For example, you can add a new action based on the command\n\t//   or create a new class that handles the action\n\t//   and call the class here\n\n\t// TODO: add your own logic here\n\t//   For example, you can add a new action based on the command\n\t//   or create a new class that handles the action\n\t//   and call the class here\n\n\t// TODO: add your own logic here\n\t//   For example, you can add a new action based on the command\n\t//   or create a new class that handles the action\n\t//   and call the class here\n\n\t// TODO: add your own logic here\n\t//", "CodeBleu_score": 3.5541344618719917}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tif (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED_ARMED || control_mode == MAV_MODE_GUIDED_DISARMED) {\n        return (uint8_t)(((float)waypoint_heading * 180.0f / 1000.0f) / 2.0f);\n    } else {\n        return 0;\n    }\n}", "CodeBleu_score": 44.74776823405948}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tuint8_t tgt_heading = 0;\n    if (control_mode == 4 || control_mode == 3) {\n        tgt_heading = (uint8_t)((waypoint_bearing / 2) & 0xFF);\n    }\n    return tgt_heading;\n}", "CodeBleu_score": 42.016904351264564}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tif (control_mode == MAV_MODE_GUIDED_ARMED || control_mode == MAV_MODE_GUIDED_DISARMED || control_mode == MAV_MODE_AUTO_ARMED || control_mode == MAV_MODE_AUTO_DISARMED) {\n        return (uint8_t)(((float)high_latency_waypoint_heading/100.0f + 180.0f) * 2.0f);\n    } else {\n        return 0;\n    }\n}", "CodeBleu_score": 42.41104612454375}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tLogPacket packet;\n    packet.time = HAL_GetTick();\n    packet.id = id;\n    packet.value = value;\n    Log_Write_Packet(packet);\n}", "CodeBleu_score": 36.196778114896844}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (loggingEnabled) {\n        Log_Packet_t packet;\n        packet.time = millis();\n        packet.id = id;\n        packet.value = value;\n        Log_Write_Packet(packet);\n    }\n}", "CodeBleu_score": 40.10565255026399}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (!log_enabled) return;\n\n    // Create the log packet\n    LogPacket packet;\n    packet.time = millis();\n    packet.id = id;\n    packet.value = value;\n\n    // Write the packet to the logger\n    logger.write_critical_block(&packet, sizeof(packet));\n}", "CodeBleu_score": 41.152892081062916}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\tif (is_flying() && !home_is_set()) {\n        set_home_to_current_location_inflight();\n    }\n}", "CodeBleu_score": 15.39224856445658}, {"code": "void Sub::update_home_from_EKF(){\n\t// exit immediately if home is already set\n    if (g.home_set) {\n        return;\n    }\n\n    // set home to current location in-flight\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n        return;\n    }\n\n    // set home to current location\n    set_home_to_current_location(false);\n}", "CodeBleu_score": 43.46553451136755}, {"code": "void Sub::update_home_from_EKF(){\n\t// exit immediately if home is already set\n    if (home_is_set) {\n        return;\n    }\n\n    // set home to current location in-flight\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n        return;\n    }\n\n    // attempt to set home to current EKF location\n    set_home_to_current_location(false);\n}", "CodeBleu_score": 43.80813073658065}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t// exit immediately if not armed\n  if (!motors.armed()) {\n    motors.set_desired_spool_state(Motor::SpoolState::kIdle);\n    attitude_control.relax_control();\n    return;\n  }\n\n  // set spool state to unlimited throttle\n  motors.set_desired_spool_state(Motor::SpoolState::kUnlimited);\n\n  // convert pilot inputs to desired body frame rates\n  float roll_rate = pilot.sticks.roll * params.acro_rate_max;\n  float pitch_rate = pilot.sticks.pitch * params.acro_rate_max;\n  float yaw_rate = pilot.sticks.yaw * params.acro_rate_max;\n\n  // run attitude controller\n  attitude_control.run(roll_rate, pitch_rate, yaw_rate, imu.get_gyro().z);\n\n  // output pilot's throttle input without angle boost\n  float throttle = pilot.sticks.throttle;\n\n  // set motor inputs\n  motors.set_desired_throttle(throttle);\n  motors.set_desired_rates(attitude_control.get_desired_rates());\n}", "CodeBleu_score": 50.702691322891354}, {"code": "void ModeAcro::run(){\n\t//if motors not armed, set throttle to zero, adjust spool state, and exit\n    if (!motors.armed()) {\n        motors.set_throttle_out(0);\n        motors.spoolup_complete();\n        return;\n    }\n\n    //if armed, set spool state to unlimited throttle\n    motors.spoolup_complete();\n\n    //convert pilot inputs to desired body frame rates\n    float roll_rate = g.acro_rpy_p.get() * (channel_roll->control_in - 0.5f) * g.rc_1.get();\n    float pitch_rate = g.acro_rpy_p.get() * (channel_pitch->control_in - 0.5f) * g.rc_1.get();\n    float yaw_rate = g.acro_rpy_p.get() * (channel_yaw->control_in - 0.5f) * g.rc_1.get();\n\n    //run attitude controller\n    attitude_control.angle_ef_roll_pitch_rate(roll_rate, pitch_rate);\n    attitude_control.set_yaw_target_to_current_heading();\n    attitude_control.set_throttle_out(channel_throttle->control_in,false);\n    attitude_control.relax_bf_rate_controller_at_zero_throttle();\n    attitude_control.update_angle_ef_roll_pitch();\n\n    //output pilot's throttle input without angle boost\n    motors.set_throttle_out(channel_throttle->control_in);\n\n    //set forward and lateral motor inputs based on pilot controls\n    motors.set_desired_roll(roll_rate);\n    motors.set_desired_pitch(pitch_rate);\n    motors.set_desired_yaw(yaw_rate);\n}", "CodeBleu_score": 50.636284514233076}, {"code": "void ModeAcro::run(){\n\t// If not armed, set throttle to zero and relax attitude controllers\n    if (!motors.armed()) {\n        pilot_throttle = 0;\n        attitude_control.relax_controllers();\n        motors.set_desired_spool_state(Motors::SpoolState::kUnlimited);\n        return;\n    }\n\n    // If armed, run the attitude controller\n    motors.set_desired_spool_state(Motors::SpoolState::kUnlimited);\n\n    // Convert pilot inputs to desired body frame rates\n    float roll_rate = pilot_sticks.axis[PilotSticks::kRoll] * params.acro_roll_rate;\n    float pitch_rate = pilot_sticks.axis[PilotSticks::kPitch] * params.acro_pitch_rate;\n    float yaw_rate = pilot_sticks.axis[PilotSticks::kYaw] * params.acro_yaw_rate;\n\n    // Run the attitude controller\n    attitude_control.run(roll_rate, pitch_rate, yaw_rate, 0, 0, 0);\n\n    // Set motor inputs\n    motors.set_desired_rotor_rpm(attitude_control.get_desired_rpm());\n}", "CodeBleu_score": 48.89391801485215}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t// initialise position controller\n    wp_nav.init_wp();\n\n    // set stopping point\n    wp_nav.set_destination(inertial_nav.get_position());\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 26.929638813323226}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set target to stopping point\n    wp_nav.set_wp_destination(inertial_nav.get_position());\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n\n    // initialize wpnav\n    wp_nav.init_wp();\n}", "CodeBleu_score": 26.928573955490155}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// initialize waypoint controller\n    wp_nav.init(true);\n\n    // set target to stopping point\n    wp_nav.set_wp_destination(inertial_nav.get_position());\n\n    // set auto yaw mode\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 27.39871134328473}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// set yaw control mode to pilot controlled\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n\n    // set the velocity controller's vertical acceleration and maximum speed\n    wp_nav.set_speed_xy(g.pilot_velocity_z_max, g.pilot_accel_z);\n\n    // initialize the velocity controller\n    wp_nav.init_vel_controller();\n}", "CodeBleu_score": 29.910941903672505}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set vertical max speed and acceleration\n    pos_control.set_speed_z_max(g.pilot_velocity_z_max, g.pilot_accel_z);\n\n    // initialize vertical and horizontal velocity controllers\n    pos_control.init_z_controller();\n    pos_control.init_xy_controller();\n\n    // set yaw control mode to pilot\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n\n    // set guided mode to velocity controller\n    guided_mode = GUIDED_VEL_CONTROL;\n}", "CodeBleu_score": 38.699749614397135}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set vertical speed and acceleration limits\n    sub.guided_vel_max_cm = sub.pilot_velocity_z_max * 100;\n    sub.guided_accel_cmss = sub.pilot_accel_z * 100;\n\n    // initialize vertical velocity controller\n    sub.guided_vel_z = 0;\n    sub.guided_vel_z_dot = 0;\n\n    // initialize horizontal velocity controller\n    sub.guided_vel_xy = 0;\n    sub.guided_vel_xy_dot = 0;\n\n    // set yaw control mode to pilot controlled\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 26.793344252649927}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t// check if time limit is exceeded\n    if ((hal.scheduler->millis() - guided_mode_start_time) > guided_mode_timeout) {\n        return true;\n    }\n\n    // check if we are above or below the altitude limits\n    if (current_loc.alt < guided_mode_min_alt || current_loc.alt > guided_mode_max_alt) {\n        return true;\n    }\n\n    // check if we have moved more than the horizontal distance limit\n    if (get_distance_to_destination() > guided_mode_horizontal_distance_limit) {\n        return true;\n    }\n\n    // check if we are above or below the vertical limits\n    if (current_loc.alt < guided_mode_min_alt || current_loc.alt > guided_mode_max_alt) {\n        return true;\n    }\n\n    // check if we have moved more than the horizontal distance limit\n    if (get_distance_to_destination() > guided_mode_horizontal_distance_limit) {\n        return true;\n    }\n\n    // check if we are above or below the vertical limits\n    if (current_loc.alt < guided_mode_min_alt || current_loc.alt > guided_mode_max_alt) {\n        return true;\n    }\n\n    // check if we have moved more than the horizontal distance limit\n    if (get_distance_to_destination() > guided_mode_horizontal_distance_limit) {\n        return true;\n    }\n\n    // check if we are above or below the vertical limits\n    if (current_loc.alt < guided_mode_min_alt || current_loc.alt > guided_mode_max_alt) {\n        return true;\n    }\n\n    // check if we have moved more than the horizontal distance limit\n    if (get_distance_to_destination() > guided_mode_horizontal_distance_limit) {\n        return true;\n    }\n\n    // check if we are above or below the vertical limits\n    if (current_loc.alt < guided_mode_min_alt || current_loc.alt > guided_", "CodeBleu_score": 51.01405992318686}, {"code": "bool ModeGuided::guided_limit_check(){\n\t/*\n\t * Check if the guided mode is too old\n\t */\n\tif (guided_mode_timeout > 0 && (current_time - guided_mode_start) > guided_mode_timeout) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * Check if the guided mode is below the minimum altitude\n\t */\n\tif (guided_mode_min_alt > 0 && (current_alt < guided_mode_min_alt)) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * Check if the guided mode is above the maximum altitude\n\t */\n\tif (guided_mode_max_alt > 0 && (current_alt > guided_mode_max_alt)) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * Check if the guided mode has moved too far\n\t */\n\tif (guided_mode_max_dist > 0 && (guided_mode_distance > guided_mode_max_dist)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 28.977661576122365}, {"code": "bool ModeGuided::guided_limit_check(){\n\tif (guided_mode_timeout_check()) {\n        return true;\n    }\n\n    if (guided_mode_alt_check()) {\n        return true;\n    }\n\n    if (guided_mode_distance_check()) {\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 12.501526854084899}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\tif (motor_test_timeout_flag) {\n        // send timeout message\n        send_motor_test_timeout_message();\n        // set pass flag to false\n        motor_test_pass_flag = false;\n        // disable motor test\n        motor_test_enabled = false;\n        // disarm the system\n        send_motor_test_disable_message();\n        // record the failure time\n        motor_test_failure_time = millis();\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 24.19595096158788}, {"code": "bool Sub::verify_motor_test(){\n\t// Check if the motor test is enabled\n  if (motor_test_enabled) {\n    // If the motor test is enabled, check if the motor test is timed out\n    if (motor_test_timer.checkTimer()) {\n      // If the motor test is timed out, send a timeout message\n      comms->send_message(MOTOR_TEST_TIMEOUT_MSG);\n      // Set the motor test pass flag to false\n      motor_test_pass = false;\n      // Disable the motor test\n      motor_test_enabled = false;\n      // Disarm the system\n      arming_state = DISARMED;\n      // Record the motor test failure time\n      motor_test_failure_time = micros();\n      // Return false\n      return false;\n    }\n  }\n  // Return true\n  return true;\n}", "CodeBleu_score": 34.272455948732095}, {"code": "bool Sub::verify_motor_test(){\n\t// Check if motor test request is received at least every 2 Hz\n    if (current_time - last_motor_test_time > 0.5) {\n        // Send timeout message\n        motor_test_timeout_msg.header.stamp = current_time;\n        motor_test_timeout_msg.motor_test_timeout = true;\n        motor_test_timeout_msg.motor_test_timeout_time = current_time;\n        motor_test_timeout_pub.publish(motor_test_timeout_msg);\n\n        // Set pass flag to false\n        motor_test_pass = false;\n\n        // Disable motor test\n        motor_test_msg.header.stamp = current_time;\n        motor_test_msg.motor_test_enable = false;\n        motor_test_msg.motor_test_command = 0;\n        motor_test_msg.motor_test_value = 0;\n        motor_test_msg.motor_test_timeout = 0;\n        motor_test_msg.motor_test_pass = false;\n        motor_test_msg.motor_test_failure_time = current_time;\n        motor_test_pub.publish(motor_test_msg);\n\n        // Disarm the system\n        arm_msg.header.stamp = current_time;\n        arm_msg.arm = false;\n        arm_msg.remaining_attempts = 3;\n        arm_pub.publish(arm_msg);\n\n        // Record failure time\n        motor_test_failure_time = current_time;\n\n        return false;\n    }\n    else {\n        return true;\n    }\n}", "CodeBleu_score": 39.64094914902901}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// calculate targets\n  float target_lateral = wp_nav.get_lateral_target();\n  float target_forward = wp_nav.get_forward_target();\n\n  // constrain targets within specified angle range\n  target_lateral = constrain(target_lateral, -wp_nav.max_angle, wp_nav.max_angle);\n  target_forward = constrain(target_forward, -wp_nav.max_angle, wp_nav.max_angle);\n\n  // normalize targets\n  float target_lateral_norm = target_lateral / wp_nav.max_angle;\n  float target_forward_norm = target_forward / wp_nav.max_angle;\n\n  // assign normalized targets to lateral_out and forward_out\n  lateral_out = target_lateral_norm;\n  forward_out = target_forward_norm;\n}", "CodeBleu_score": 47.301062874378545}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// translate wp_nav targets to lateral and forward\n  // normalize lateral and forward\n  // assign normalized values to lateral_out and forward_out\n  // constrain lateral and forward within a specified maximum angle range\n  // translate wp_nav targets to lateral and forward\n  // normalize lateral and forward\n  // assign normalized values to lateral_out and forward_out\n  // constrain lateral and forward within a specified maximum angle range\n  // translate wp_nav targets to lateral and forward\n  // normalize lateral and forward\n  // assign normalized values to lateral_out and forward_out\n  // constrain lateral and forward within a specified maximum angle range\n  // translate wp_nav targets to lateral and forward\n  // normalize lateral and forward\n  // assign normalized values to lateral_out and forward_out\n  // constrain lateral and forward within a specified maximum angle range\n  // translate wp_nav targets to lateral and forward\n  // normalize lateral and forward\n  // assign normalized values to lateral_out and forward_out\n  // constrain lateral and forward within a specified maximum angle range\n  // translate wp_nav targets to lateral and forward\n  // normalize lateral and forward\n  // assign normalized values to lateral_out and forward_out\n  // constrain lateral and forward within a specified maximum angle range\n  // translate wp_nav targets to lateral and forward\n  // normalize lateral and forward\n  // assign normalized values to lateral_out and forward_out\n  // constrain lateral and forward within a specified maximum angle range\n  // translate wp_nav targets to lateral and forward\n  // normalize lateral and forward\n  // assign normalized values to lateral_out and forward_out\n  // constrain lateral and forward within a specified maximum angle range\n  // translate wp_nav targets to lateral and forward\n  // normalize lateral and forward\n  // assign normalized values to lateral_out and forward_out\n  // constrain lateral and forward within a specified maximum angle range\n  // translate wp_nav targets to lateral and forward\n  // normalize lateral and forward\n  // assign normalized values to lateral_out and forward", "CodeBleu_score": 3.5714088508479964}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Retrieve roll and pitch targets from wp_nav in centidegrees\n  lateral_out = wp_nav.get_roll_cd() * 0.1;\n  forward_out = wp_nav.get_pitch_cd() * 0.1;\n\n  // Constrain targets within a specified maximum angle range\n  // If the targets are outside of the range, constrain them to the maximum angle\n  if (lateral_out > MAX_LATERAL_ANGLE) {\n    lateral_out = MAX_LATERAL_ANGLE;\n  }\n  else if (lateral_out < -MAX_LATERAL_ANGLE) {\n    lateral_out = -MAX_LATERAL_ANGLE;\n  }\n  if (forward_out > MAX_FORWARD_ANGLE) {\n    forward_out = MAX_FORWARD_ANGLE;\n  }\n  else if (forward_out < -MAX_FORWARD_ANGLE) {\n    forward_out = -MAX_FORWARD_ANGLE;\n  }\n\n  // Normalize targets to be within the range [-1, 1]\n  lateral_out /= MAX_LATERAL_ANGLE;\n  forward_out /= MAX_FORWARD_ANGLE;\n}", "CodeBleu_score": 31.684816584238153}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t// Read the barometer\n  if (baro.read()) {\n    // If the altitude is above zero, update the calibration\n    if (baro.getAltitude() > 0) {\n      baro.calibrate();\n    }\n\n    // Update the sensor health status based on the barometer's health\n    if (baro.getHealth() == 0) {\n      sensor_health.baro_health = 0;\n    }\n    else if (baro.getHealth() == 1) {\n      sensor_health.baro_health = 1;\n    }\n    else if (baro.getHealth() == 2) {\n      sensor_health.baro_health = 2;\n    }\n  }\n}", "CodeBleu_score": 54.94552770059906}, {"code": "void Sub::read_barometer(){\n\tif (millis() - baro_last_update >= baro_update_rate) {\n    baro_last_update = millis();\n    // Read the barometer\n    float baro_pressure = baro.getPressure();\n    // Update the barometer calibration\n    if (baro_pressure > 0) {\n      baro_calibration_factor = 101325 / baro_pressure;\n    }\n    // Update the sensor health status\n    if (depth_sensor_present) {\n      if (baro_pressure > 0) {\n        sensor_health_status.baro = true;\n      }\n      else {\n        sensor_health_status.baro = false;\n      }\n    }\n  }\n}", "CodeBleu_score": 36.686262925181914}, {"code": "void Sub::read_barometer(){\n\t// Read the barometer\n    baro.read();\n\n    // Update the altitude\n    altitude = baro.getAltitude();\n\n    // Update the barometer calibration\n    if (altitude > 0) {\n        baro.calibrate();\n    }\n\n    // Update the sensor health status\n    if (depth_sensor.get_status() != SENSOR_HEALTH_OK) {\n        if (baro.getPressure() > 1000) {\n            depth_sensor.set_status(SENSOR_HEALTH_OK);\n        } else {\n            depth_sensor.set_status(SENSOR_HEALTH_ERROR);\n        }\n    }\n}", "CodeBleu_score": 55.71724688442544}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\tif (!ekf_inertial_nav_ok()) {\n\t\treturn false;\n\t}\n\tif (!motors_armed) {\n\t\treturn true;\n\t}\n\tif (!ekf_position_fusion_healthy()) {\n\t\treturn false;\n\t}\n\tif (ekf_constant_position_mode()) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 15.016496413102942}, {"code": "bool Sub::ekf_position_ok(){\n\tif ( !_ekf->get_inertial_nav_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_ekf_use_baro_hgt()) {\n    return false;\n  }\n  if ( !_ekf->get_terrain_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_pos_horiz_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_pos_vert_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_vel_horiz_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_vel_vert_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_pos_horiz_accuracy_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_pos_vert_accuracy_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_vel_horiz_accuracy_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_vel_vert_accuracy_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_pos_horiz_ratio_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_pos_vert_ratio_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_vel_horiz_ratio_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_vel_vert_ratio_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_pos_horiz_test_ratio_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_pos_vert_test_ratio_valid()) {\n    return false;\n  }\n  if ( !_ekf->get_vel_horiz_test_ratio", "CodeBleu_score": 46.5171792590102}, {"code": "bool Sub::ekf_position_ok(){\n\tif ( !ekf_status.flags.inertial_nav ) {\n        return false;\n    }\n    if ( !motors.armed() ) {\n        return true;\n    }\n    if ( !ekf_status.flags.position_ok ) {\n        return false;\n    }\n    if ( ekf_status.flags.constant_pos_mode ) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 48.13603448592224}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!_arming.require_GPS()) {\n        return true;\n    }\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n    if (!_ahrs.get_gps().status().flags.position_ok) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"GPS position not valid\"));\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 31.458467171681008}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// return true if we don't need a GPS fix\n    if (!_arming.require_GPS_for_ARMED()) {\n        return true;\n    }\n\n    // call parent class's GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ahrs.initialised()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: Compass not initialised\"));\n        }\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (ahrs.get_ekf_status().failsafe) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: EKF failsafe active\"));\n        }\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!ahrs.get_position().is_valid()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: No position lock\"));\n        }\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 56.90397623890999}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// if not using GPS, always return true\n    if (!_aparm.require_GPS) {\n        return true;\n    }\n\n    // call parent class's GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ahrs.initialised()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: AHRS not ready\"));\n        }\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (ahrs.get_ekf_status().failsafe) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: EKF failsafe active\"));\n        }\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!ahrs.get_position().is_valid()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: EKF position estimate invalid\"));\n        }\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 57.178296555175535}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tAP_Arming::ArmingError result = AP_Arming::OK;\n\n    // check that we are not already armed\n    if (is_armed()) {\n        result = AP_Arming::ALREADY_ARMED;\n    }\n\n    // check that we have a valid GPS lock\n    if (result == AP_Arming::OK && do_arming_checks) {\n        if (!hal.util->get_soft_armed() && !hal.util->get_hard_armed() && !_gps.status().status) {\n            result = AP_Arming::NO_GPS_LOCK;\n        }\n    }\n\n    // check that the vehicle is not in a manual flight mode\n    if (result == AP_Arming::OK && do_arming_checks) {\n        if (!hal.util->get_soft_armed() && !hal.util->get_hard_armed() && !_vehicle.control_mode_flag_armed()) {\n            result = AP_Arming::MANUAL_MODE;\n        }\n    }\n\n    // check that the vehicle is not in a takeoff flight mode\n    if (result == AP_Arming::OK && do_arming_checks) {\n        if (!hal.util->get_soft_armed() && !hal.util->get_hard_armed() && _vehicle.control_mode_flag_takeoff()) {\n            result = AP_Arming::TAKEOFF_MODE;\n        }\n    }\n\n    // check that the vehicle is not in a landing flight mode\n    if (result == AP_Arming::OK && do_arming_checks) {\n        if (!hal.util->get_soft_armed() && !hal.util->get_hard_armed() && _vehicle.control_mode_flag_land()) {\n            result = AP_Arming::LAND_MODE;\n        }\n    }\n\n    // check that the vehicle is not in a rtl flight mode\n    if (result == AP_Arming::OK && do_arming_checks) {\n        if (!hal.util->get_soft_ar", "CodeBleu_score": 40.35180396791561}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (do_arming_checks && !pre_arm_checks(true)) {\n        return false;\n    }\n\n    // set armed state\n    armed_state = AP_Arming::Armed;\n\n    // set armed time\n    armed_time_ms = hal.scheduler->millis();\n\n    // set home location\n    set_home_to_current_location();\n\n    // initialise the simple mode heading\n    init_simple_mode();\n\n    // record the home heading for sail vehicles\n    record_home_heading();\n\n    // update soft armed status\n    update_soft_armed();\n\n    // send arm/disarm status text\n    send_arm_disarm_msg();\n\n    // log the arm event\n    Log_Write_Event(DATA_ARM_E);\n\n    return true;\n}", "CodeBleu_score": 37.19910766712924}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// return immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // check if we are in a low battery\n    if (do_arming_checks && hal.util->battery_voltage() < AP_ARMING_LOW_BATTERY_THRESHOLD) {\n        arming_failed(AP_ARMING_LOW_BATTERY_THRESHOLD);\n        return false;\n    }\n\n    // check if we are in a low battery\n    if (do_arming_checks && hal.util->battery_voltage() < AP_ARMING_LOW_BATTERY_THRESHOLD) {\n        arming_failed(AP_ARMING_LOW_BATTERY_THRESHOLD);\n        return false;\n    }\n\n    // check if we are in a low battery\n    if (do_arming_checks && hal.util->battery_voltage() < AP_ARMING_LOW_BATTERY_THRESHOLD) {\n        arming_failed(AP_ARMING_LOW_BATTERY_THRESHOLD);\n        return false;\n    }\n\n    // check if we are in a low battery\n    if (do_arming_checks && hal.util->battery_voltage() < AP_ARMING_LOW_BATTERY_THRESHOLD) {\n        arming_failed(AP_ARMING_LOW_BATTERY_THRESHOLD);\n        return false;\n    }\n\n    // check if we are in a low battery\n    if (do_arming_checks && hal.util->battery_voltage() < AP_ARMING_LOW_BATTERY_THRESHOLD) {\n        arming_failed(AP_ARMING_LOW_BATTERY_THRESHOLD);\n        return false;\n    }\n\n    // check if we are in a low battery\n    if (do_arming_checks && hal.util->battery_", "CodeBleu_score": 43.91891606248938}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\tif (charging_allowed && !charging_enabled && checkShouldCharge()) {\n        charging_enabled = true;\n        charging_disabled_time = 0;\n    } else if (!charging_allowed && charging_enabled) {\n        charging_enabled = false;\n        charging_disabled_time = now();\n    } else if (!charging_allowed && !charging_enabled && now() - charging_disabled_time > CHARGING_DISABLED_TIMEOUT) {\n        charging_enabled = true;\n        charging_disabled_time = 0;\n    }\n}", "CodeBleu_score": 38.36718603113062}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed && !status_message.charging_enabled) {\n        // Charging is allowed but not enabled, so enable it\n        status_message.charging_enabled = true;\n        charging_enabled_time = now();\n    } else if (!charging_allowed && status_message.charging_enabled) {\n        // Charging is not allowed but is enabled, so disable it\n        status_message.charging_enabled = false;\n        charging_disabled_time = now();\n    } else if (!charging_allowed && !status_message.charging_enabled && now() - charging_disabled_time > 10000) {\n        // Charging is not allowed and has been disabled for a while, so retry enabling it\n        status_message.charging_enabled = true;\n        charging_enabled_time = now();\n    }\n}", "CodeBleu_score": 36.76320928586433}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed && !charging_enabled) {\n        charging_enabled = true;\n        charging_disabled_time = 0;\n    } else if (!charging_allowed && charging_enabled) {\n        charging_enabled = false;\n        charging_disabled_time = millis();\n    } else if (!charging_allowed && !charging_enabled && millis() - charging_disabled_time > 60000) {\n        charging_enabled = true;\n        charging_disabled_time = 0;\n    }\n}", "CodeBleu_score": 39.21899263459063}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t// Check if ROS is running\n  if (!rosRunning) {\n    return;\n  }\n  // Check if the message size is at least 4 bytes\n  if (size < 4) {\n    return;\n  }\n  // Calculate the CRC\n  uint32_t crc = crc32((uint8_t *)message, size);\n  // Copy the CRC to the message\n  memcpy((uint8_t *)message + size, &crc, 4);\n  // Send the message\n  packetSerial.send(message, size + 4);\n}", "CodeBleu_score": 46.66222634751257}, {"code": "void sendMessage(void *message, size_t size){\n\tif (rosRunning && size >= 4) {\n    uint32_t crc = crc32((uint8_t *)message, size);\n    packetSerial.send(message, size);\n    packetSerial.send(&crc, sizeof(crc));\n  }\n}", "CodeBleu_score": 36.982011600508294}, {"code": "void sendMessage(void *message, size_t size){\n\tif (ros.isConnected()) {\n    if (size >= 4) {\n      uint32_t crc = calculateCRC((uint8_t *)message, size);\n      memcpy((uint8_t *)message + size, &crc, 4);\n      packetSerial.send(message, size + 4);\n    }\n  }\n}", "CodeBleu_score": 39.41778121925475}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\tif (!_mp3.begin()) {\n    Serial.println(F(\"MP3 Initialization Failed\"));\n    return false;\n  }\n  _mp3.setVolume(20, 20);\n  _mp3.setLoopMode(MP3_LOOP_ALL);\n  _mp3.setPlayMode(MP3_PLAY_ALL);\n  _mp3.setSource(MP3_SRC_SDCARD);\n  _mp3.setPlayMode(MP3_PLAY_ALL);\n  _mp3.setLoopMode(MP3_LOOP_ALL);\n  _mp3.setPlayMode(MP3_PLAY_ALL);\n  _mp3.setSource(MP3_SRC_SDCARD);\n  _mp3.setVolume(20, 20);\n  _mp3.setLoopMode(MP3_LOOP_ALL);\n  _mp3.setPlayMode(MP3_PLAY_ALL);\n  _mp3.setSource(MP3_SRC_SDCARD);\n  _mp3.setVolume(20, 20);\n  _mp3.setLoopMode(MP3_LOOP_ALL);\n  _mp3.setPlayMode(MP3_PLAY_ALL);\n  _mp3.setSource(MP3_SRC_SDCARD);\n  _mp3.setVolume(20, 20);\n  _mp3.setLoopMode(MP3_LOOP_ALL);\n  _mp3.setPlayMode(MP3_PLAY_ALL);\n  _mp3.setSource(MP3_SRC_SDCARD);\n  _mp3.setVolume(20, 20);\n  _mp3.setLoopMode(MP3_LOOP_ALL);\n  _mp3.setPlayMode(MP3_PLAY_ALL);\n  _mp3.setSource(MP3_SRC_SDCARD);\n  _mp3.setVolume(20, 20);\n  _mp3.setLoopMode(MP3_LOOP_ALL);\n  _mp3.setPlayMode(MP3_PLAY_ALL);", "CodeBleu_score": 36.453303553183616}, {"code": "bool MP3Sound::begin(){\n\t// Initialize the serial communication\n  Serial1.begin(9600);\n\n  // Clear any existing data in the buffer\n  while (Serial1.available()) {\n    Serial1.read();\n  }\n\n  // Initialize the sound module\n  Serial1.print(\"AT+QIOSTATE=1\\r\n\");\n\n  // Wait for a response from the sound module\n  if (waitForResponse(\"OK\", 5000)) {\n    Serial.println(\"Sound module initialized.\");\n  }\n  else {\n    Serial.println(\"Sound module not initialized.\");\n    return false;\n  }\n\n  // Retrieve the number of sound files available on the SD card\n  Serial1.print(\"AT+QFLDS=(0,1)\\r\n\");\n\n  // Wait for a response from the sound module\n  if (waitForResponse(\"OK\", 5000)) {\n    Serial.println(\"Sound files retrieved.\");\n  }\n  else {\n    Serial.println(\"Sound files not retrieved.\");\n    return false;\n  }\n\n  // Return true if there are one or more sound files available\n  if (soundFiles > 0) {\n    return true;\n  }\n  else {\n    return false;\n  }\n}", "CodeBleu_score": 45.482562799490175}, {"code": "bool MP3Sound::begin(){\n\t// Initialize serial communication with sound module\n  _soundModule.begin(9600);\n  // Clear any existing data in the buffer\n  while (_soundModule.available()) {\n    _soundModule.read();\n  }\n  // Initialize sound module\n  _soundModule.write(0x7E);\n  _soundModule.write(0xFF);\n  _soundModule.write(0x06);\n  _soundModule.write(0x0F);\n  _soundModule.write(0x00);\n  _soundModule.write(0x00);\n  _soundModule.write(0x00);\n  _soundModule.write(0x00);\n  _soundModule.write(0x00);\n  _soundModule.write(0xEF);\n  // Wait for a response\n  if (_soundModule.available()) {\n    if (_soundModule.read() == 0x7E) {\n      if (_soundModule.read() == 0xFF) {\n        if (_soundModule.read() == 0x06) {\n          if (_soundModule.read() == 0x00) {\n            if (_soundModule.read() == 0xEF) {\n              // Retrieve the number of sound files available\n              _soundModule.write(0x7E);\n              _soundModule.write(0xFF);\n              _soundModule.write(0x06);\n              _soundModule.write(0x47);\n              _soundModule.write(0x00);\n              _soundModule.write(0x00);\n              _soundModule.write(0x00);\n              _soundModule.write(0x00);\n              _soundModule.write(0x00);\n              _soundModule.write(0xEF);\n              // Wait for a response\n              if (_soundModule.available()) {\n                if (_soundModule.read() == 0x7E) {\n                  if (_soundModule.read() == 0xFF) {\n                    if (_soundModule.read() == 0x06) {\n                      if (_soundModule.read() == 0x47)", "CodeBleu_score": 36.23377643167605}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\tint numActiveSounds = getNumActiveSounds();\n\tif (numActiveSounds == 0 || isPlaying()) {\n\t\treturn numActiveSounds;\n\t}\n\telse {\n\t\tSound *sound = getActiveSound(numActiveSounds - 1);\n\t\tplaySound(sound);\n\t\tremoveActiveSound(sound);\n\t\treturn getNumActiveSounds();\n\t}\n}", "CodeBleu_score": 31.363851542600596}, {"code": "int MP3Sound::processSounds(){\n\tif (numActiveSounds == 0 || playingMP3) {\n\t\treturn numActiveSounds;\n\t}\n\t\n\t// Get the last sound from the active sounds list\n\tactiveSound = activeSounds.back();\n\tactiveSounds.pop_back();\n\t\n\t// Decrement the number of active sounds\n\tnumActiveSounds--;\n\t\n\t// Play the sound\n\tplaySound(activeSound);\n\t\n\t// Return the updated number of active sounds\n\treturn numActiveSounds;\n}", "CodeBleu_score": 40.47715968238661}, {"code": "int MP3Sound::processSounds(){\n\tif (numActiveSounds == 0 || isPlaying()) return numActiveSounds;\n\tif (activeSounds.size() > 0) {\n\t\tMP3Sound* sound = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\tsound->play();\n\t\treturn numActiveSounds;\n\t}\n\treturn numActiveSounds;\n}", "CodeBleu_score": 44.61681989708137}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tAbstractCamera *ac = d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      if (ac->memory_mapped_file_request)\n        wb_file_request_cleanup(ac->memory_mapped_file_request);\n      ac->memory_mapped_file_request = r;\n      return true;\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 57.39605283688708}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *ac = (WbAbstractCamera *)d->pdata;\n  bool command_handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (ac->memory_mapped_file)\n        wb_memory_mapped_file_delete(ac->memory_mapped_file);\n      ac->memory_mapped_file = wb_memory_mapped_file_new(r);\n      break;\n    }\n    default:\n      command_handled = false;\n      break;\n  }\n  return command_handled;\n}", "CodeBleu_score": 68.17696523935636}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tbool command_handled = true;\n  AbstractCamera *ac = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      wb_abstract_camera_cleanup_memory_mapped_file(ac);\n      ac->memory_mapped_file_request = r;\n      ac->memory_mapped_file_size = request_read_uint32(r);\n      ac->memory_mapped_file_buffer = request_read_data(r, ac->memory_mapped_file_size, NULL);\n      ac->memory_mapped_file_buffer_size = ac->memory_mapped_file_size;\n      ac->memory_mapped_file_buffer_index = 0;\n      break;\n    }\n    default:\n      command_handled = false;\n  }\n  return command_handled;\n}", "CodeBleu_score": 63.18726064688267}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\treturn -1;\n}", "CodeBleu_score": 2.171236856941886}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tWbAbstractCamera *ac = d->pdata;\n  int result;\n  wb_mutex_lock(&ac->mutex);\n  result = ac->height;\n  wb_mutex_unlock(&ac->mutex);\n  return result;\n}", "CodeBleu_score": 52.510786838323064}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint result = -1;\n  robot_mutex_lock_step();\n  WbAbstractCamera *ac = wb_abstract_camera_get_struct(d);\n  if (ac)\n    result = ac->height;\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 69.29291634974892}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period = 0;\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer == NULL) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    return -1;\n  }\n  pthread_mutex_lock(&accelerometer->mutex);\n  sampling_period = accelerometer->sampling_period;\n  pthread_mutex_unlock(&accelerometer->mutex);\n  return sampling_period;\n}", "CodeBleu_score": 61.44531125667028}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  struct wb_accelerometer_struct *accelerometer = wb_accelerometer_get_struct(tag);\n  if (accelerometer == NULL) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    return -1;\n  }\n  pthread_mutex_lock(&accelerometer->mutex);\n  sampling_period = accelerometer->sampling_period;\n  pthread_mutex_unlock(&accelerometer->mutex);\n  return sampling_period;\n}", "CodeBleu_score": 55.14695895242837}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  struct wb_accelerometer *accelerometer = wb_accelerometer_get_struct(tag);\n  if (!accelerometer) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    return -1;\n  }\n  sampling_period = accelerometer->sampling_period;\n  return sampling_period;\n}", "CodeBleu_score": 45.86600807927985}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsString = string(dms);\n    free(dms);\n    return dmsString;\n}", "CodeBleu_score": 46.17924834639015}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result(dms);\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 38.113202109896136}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result(dms);\n    free(dms);\n    return result;\n}", "CodeBleu_score": 39.49280121053885}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT(g && g->type == dBoxClass, \"The argument is not a box geometry.\");\n\n  // Ensure the geometry is a box\n  dGeomBox *box = (dGeomBox *) g;\n\n  // Compute the relative position of the point to the box center\n  dVector3 diff;\n  diff[0] = x - box->final_posr->pos[0];\n  diff[1] = y - box->final_posr->pos[1];\n  diff[2] = z - box->final_posr->pos[2];\n\n  // Check each axis for proximity to the box's surface\n  dReal abs_diff[3];\n  abs_diff[0] = dFabs(diff[0]);\n  abs_diff[1] = dFabs(diff[1]);\n  abs_diff[2] = dFabs(diff[2]);\n\n  // The plane normal is the closest box axis\n  if (abs_diff[0] < abs_diff[1] && abs_diff[0] < abs_diff[2]) {\n    plane[0] = box->final_posr->R[0];\n    plane[1] = box->final_posr->R[4];\n    plane[2] = box->final_posr->R[8];\n  }\n  else if (abs_diff[1] < abs_diff[2]) {\n    plane[0] = box->final_posr->R[1];\n    plane[1] = box->final_posr->R[5];\n    plane[2] = box->final_posr->R[9];\n  }\n  else {\n    plane[0] = box->final_posr->R[2];\n    plane[1] = box->final_posr->R[6];\n    plane[2] = box->final_posr->R[10];\n  }\n\n  // The plane distance is the closest box surface\n  if (diff[0] < 0) plane[3] = -(box->final_posr->pos[0] + box->side[0] / 2);\n  else plane[3]", "CodeBleu_score": 30.104355119830316}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n  dUASSERT(plane, \"argument not a plane\");\n\n  // Ensure the geometry is a box\n  dGeomBox *box = (dGeomBox *) g;\n\n  // Calculate the relative position of the point to the box center\n  dVector3 diff;\n  dSubtractVectors3(diff, g->final_posr->pos, g->final_posr->R, x, y, z);\n\n  // Set the plane's normal and distance based on the closest surface\n  dVector3 normal;\n  plane[3] = 0;\n  if (dFabs(diff[0]) > dFabs(diff[1]) && dFabs(diff[0]) > dFabs(diff[2])) {\n    if (diff[0] < 0) {\n      normal[0] = -1;\n      normal[1] = 0;\n      normal[2] = 0;\n      plane[3] = box->side[0] + diff[0];\n    } else {\n      normal[0] = 1;\n      normal[1] = 0;\n      normal[2] = 0;\n      plane[3] = box->side[0] - diff[0];\n    }\n  } else if (dFabs(diff[1]) > dFabs(diff[2])) {\n    if (diff[1] < 0) {\n      normal[0] = 0;\n      normal[1] = -1;\n      normal[2] = 0;\n      plane[3] = box->side[1] + diff[1];\n    } else {\n      normal[0] = 0;\n      normal[1] = 1;\n      normal[2] = 0;\n      plane[3] = box->side[1] - diff[1];\n    }\n  } else {\n    if (diff[2] < 0) {\n      normal[0] = 0;\n      normal[1] = 0;\n      normal[2] = -1;\n      plane[3] = box", "CodeBleu_score": 32.64386921927659}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n    dUASSERT(plane, \"argument not a plane\");\n\n    const dReal* const center = ((dxBox*)g)->final_posr->pos;\n    const dReal* const R = ((dxBox*)g)->final_posr->R;\n    const dReal* const sides = ((dxBox*)g)->side;\n\n    dReal xrel = x - center[0];\n    dReal yrel = y - center[1];\n    dReal zrel = z - center[2];\n\n    // find closest axis\n    dReal xytheta = dAtan2(yrel, xrel);\n    dReal xythetasq = xytheta * xytheta;\n    dReal ztheta = dAtan2(zrel, dSqrt(xrel * xrel + yrel * yrel));\n    dReal zthetasq = ztheta * ztheta;\n\n    // set plane normal\n    dReal* n = plane;\n    if (xythetasq < zthetasq) {\n        n[0] = 0;\n        n[1] = dCos(xytheta);\n        n[2] = dSin(xytheta);\n    } else {\n        n[0] = dCos(ztheta);\n        n[1] = 0;\n        n[2] = dSin(ztheta);\n    }\n\n    // set plane distance\n    dReal* d = plane + 3;\n    if (xythetasq < zthetasq) {\n        dReal xyproj = dSqrt(xrel * xrel + yrel * yrel);\n        if (xyproj > REAL(0.0)) {\n            dReal inv_xyproj = REAL(1.0) / xyproj;\n            xrel *= inv_xyproj;\n            yrel *= inv_xyproj;\n        }\n        dReal xysq = xrel * xrel + yrel * yrel;\n        if (xysq > sides[0] * sides[0]) {", "CodeBleu_score": 39.51584563487205}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t// check if the box has a body\n  dxBody *b = box->body;\n  if (!b) return 0;\n\n  // check if the flags are valid\n  if (flags & ~(dImmerseBox_All)) return 0;\n\n  // initialize the immersion data structure\n  immersion->g1 = box;\n  immersion->g2 = 0;\n  immersion->normal[0] = fluidPlane[0];\n  immersion->normal[1] = fluidPlane[1];\n  immersion->normal[2] = fluidPlane[2];\n  immersion->depth = 0;\n  immersion->contact[0] = 0;\n  immersion->contact[1] = 0;\n  immersion->contact[2] = 0;\n  immersion->contact[3] = 0;\n  immersion->contact[4] = 0;\n  immersion->contact[5] = 0;\n  immersion->contact[6] = 0;\n  immersion->contact[7] = 0;\n  immersion->contact[8] = 0;\n  immersion->contact[9] = 0;\n  immersion->contact[10] = 0;\n  immersion->contact[11] = 0;\n  immersion->contact[12] = 0;\n  immersion->contact[13] = 0;\n  immersion->contact[14] = 0;\n  immersion->contact[15] = 0;\n  immersion->contact[16] = 0;\n  immersion->contact[17] = 0;\n  immersion->contact[18] = 0;\n  immersion->contact[19] = 0;\n  immersion->contact[20] = 0;\n  immersion->contact[21] = 0;\n  immersion->contact[22] = 0;\n  immersion->contact[23] = 0;\n  immersion->contact[24] = 0;\n  immersion->contact[25] = 0;\n  immersion->contact[2", "CodeBleu_score": 36.21119639983266}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdAASSERT (box && immersion);\n  dUASSERT (box->body, \"Box must be attached to a body.\");\n  dUASSERT (flags & NUMI_MASK, \"At least one type of immersion must be selected.\");\n  dUASSERT ((flags & ~NUMI_MASK) == 0, \"Invalid flags.\");\n\n  // Initialize the immersion object\n  immersion->g1 = box;\n  immersion->g2 = NULL;\n  immersion->normal[0] = fluidPlane[0];\n  immersion->normal[1] = fluidPlane[1];\n  immersion->normal[2] = fluidPlane[2];\n  immersion->depth = 0;\n  immersion->contact.geom.g1 = box;\n  immersion->contact.geom.g2 = NULL;\n  immersion->contact.geom.normal[0] = fluidPlane[0];\n  immersion->contact.geom.normal[1] = fluidPlane[1];\n  immersion->contact.geom.normal[2] = fluidPlane[2];\n  immersion->contact.geom.depth = 0;\n  immersion->contact.side1 = -1;\n  immersion->contact.side2 = -1;\n\n  // Perform the immersion checking\n  return dImmerseBoxBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 42.681823176557636}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdUASSERT(box, \"The box must exist\");\n  dUASSERT(box->body, \"The box must be attached to a body\");\n  dUASSERT(fluidPlane, \"The fluid plane must exist\");\n  dUASSERT(immersion, \"The immersion must exist\");\n  dUASSERT(dGeomGetClass(box) == dBoxClass, \"The geom is not a box\");\n\n  dAASSERT(box->body);\n  dAASSERT(box->fluid);\n\n  immersion->g1 = box;\n  immersion->g2 = 0;\n  immersion->normal[0] = fluidPlane[0];\n  immersion->normal[1] = fluidPlane[1];\n  immersion->normal[2] = fluidPlane[2];\n  immersion->depth = 0;\n  immersion->contact.size = 0;\n  immersion->buoyancy[0] = 0;\n  immersion->buoyancy[1] = 0;\n  immersion->buoyancy[2] = 0;\n  immersion->volume = 0;\n  immersion->projectedArea = 0;\n\n  return dImmerseBoxBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 41.85454047903122}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body && o2->body, \"This pair of geoms has no bodies and hence cannot be tested for immersion into a fluid\");\n\n  dxBox *box = (dxBox*) o1;\n  dxCapsule *capsule = (dxCapsule*) o2;\n\n  // check if the box is actually a box\n  if (box->type != dBoxClass) return 0;\n\n  // check if the capsule is actually a capsule\n  if (capsule->type != dCapsuleClass) return 0;\n\n  // check if the capsule is actually a capsule\n  if (capsule->type != dCapsuleClass) return 0;\n\n  // get axis and radius of the capsule\n  dVector3 axis;\n  dGeomCapsuleGetParams(capsule, axis, immersion->g1_radius);\n  immersion->g1_radius += capsule->radius;\n\n  // find the capsule axis endpoints\n  dVector3 p1, p2;\n  dGeomCapsuleGetEndPoints(capsule, p1, p2);\n\n  // find the box center\n  dVector3 box_center;\n  dGeomBoxGetLengths(box, box_center);\n  box_center[0] *= REAL(0.5);\n  box_center[1] *= REAL(0.5);\n  box_center[2] *= REAL(0.5);\n  dGeomSetPosition(box, box_center[0], box_center[1], box_center[2]);\n\n  // find the box rotation matrix\n  dMatrix3 R;\n  dGeomBoxGetRotation(box, R);\n\n  // find the capsule axis endpoints in the box frame\n  dVector3 q1, q2;\n  dMultiply0_331(q1, R, p1);\n  dMultiply0_331(q2, R, p2);\n\n  // find the capsule axis direction in the box frame", "CodeBleu_score": 45.33239962792109}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body && o2->body, \"Both objects must be attached to a body\");\n\n  dxBox *box = (dxBox*) o1;\n  dxCapsule *capsule = (dxCapsule*) o2;\n\n  // check if the capsule is really a capsule\n  dUASSERT(capsule->type == dCapsuleClass, \"The second argument is not a capsule\");\n\n  // check if the box is really a box\n  dUASSERT(box->type == dBoxClass, \"The first argument is not a box\");\n\n  // check if the box and the capsule are connected\n  dUASSERT(box->body != capsule->body, \"The box and the capsule are connected\");\n\n  // get the box position and rotation\n  const dReal *R = box->final_posr->R;\n  const dReal *pos = box->final_posr->pos;\n\n  // get the capsule position and rotation\n  const dReal *R_c = capsule->final_posr->R;\n  const dReal *pos_c = capsule->final_posr->pos;\n\n  // get the capsule axis\n  const dReal *axis = capsule->final_posr->R + 2;\n\n  // get the capsule radius\n  dReal radius = capsule->radius;\n\n  // get the capsule length\n  dReal length = capsule->lz * REAL(2.0);\n\n  // compute the position of the center of the box\n  dVector3 center;\n  dMultiply0_331 (center, R, box->final_posr->pos);\n\n  // compute the position of the center of the capsule\n  dVector3 center_c;\n  dMultiply0_331 (center_c, R_c, pos_c);\n\n  // compute the position of the center of the capsule relative to the box\n  dVector3 delta;\n  dSubtractVectors3(delta, center_c, center);\n\n  //", "CodeBleu_score": 44.12984204888076}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule must be a box and the second must be a fluid\");\n\n  dxBox *box = (dxBox*) o1;\n  dxCapsule *capsule = (dxCapsule*) o2;\n\n  // get axis and radius of the capsule\n  dVector3 axis;\n  dGeomCapsuleGetParams(capsule, NULL, axis);\n  dReal radius = dGeomCapsuleGetRadius(capsule);\n\n  // get position of the capsule\n  dVector3 pos;\n  dGeomGetRelPointPos(capsule->gflags, capsule->final_posr->pos, capsule->final_posr->R, 0, pos);\n\n  // get the box rotation matrix\n  dMatrix3 R;\n  dRSetIdentity(R);\n  dGeomGetRelRotation(box->gflags, box->final_posr->R, R);\n\n  // get the box position\n  dVector3 box_pos;\n  dGeomGetRelPointPos(box->gflags, box->final_posr->pos, box->final_posr->R, 0, box_pos);\n\n  // get the box size\n  dVector3 box_size;\n  dGeomBoxGetLengths(box, box_size);\n\n  // compute the position of the capsule in the box frame\n  dVector3 pos_in_box;\n  dSubtractVectors3(pos_in_box, pos, box_pos);\n  dMultiply1_331(pos_in_box, R, pos_in_box);\n\n  // compute the capsule axis in the box frame\n  dVector3 axis_in_box;\n  dMultiply1_331(axis_in_box, R, axis);\n\n  // compute the capsule radius in the box frame\n  dReal radius_in_box = radius;\n\n  // check if the capsule is colliding with the", "CodeBleu_score": 45.651810975909434}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t// Integration limits\n    const dReal theta0 = atan(tanTheta0);\n    const dReal theta1 = asin(sinTheta1);\n\n    // Integration constants\n    const dReal theta0Squared = theta0 * theta0;\n    const dReal theta1Squared = theta1 * theta1;\n    const dReal theta0Cubed = theta0Squared * theta0;\n    const dReal theta1Cubed = theta1Squared * theta1;\n    const dReal theta0ToTheFourth = theta0Cubed * theta0;\n    const dReal theta1ToTheFourth = theta1Cubed * theta1;\n    const dReal theta0ToTheFifth = theta0ToTheFourth * theta0;\n    const dReal theta1ToTheFifth = theta1ToTheFourth * theta1;\n    const dReal theta0ToTheSixth = theta0ToTheFifth * theta0;\n    const dReal theta1ToTheSixth = theta1ToTheFifth * theta1;\n    const dReal theta0ToTheSeventh = theta0ToTheSixth * theta0;\n    const dReal theta1ToTheSeventh = theta1ToTheSixth * theta1;\n    const dReal theta0ToTheEighth = theta0ToTheSeventh * theta0;\n    const dReal theta1ToTheEighth = theta1ToTheSeventh * theta1;\n\n    // Integration coefficients\n    const dReal c0 = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "CodeBleu_score": 35.55237714695202}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tdReal volume = 0;\n\n  // Calculate the volume of the first half of the hemisphere\n  volume += simpsonsRuleIntegration(zIOverR, tanTheta0, 0, sinTheta1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "CodeBleu_score": 20.752270895576807}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t// The normalized volume of the immersed hemisphere is calculated using Simpson's rule for numerical integration.\n    // The integration is performed in two parts to handle potential singularities.\n    // The first part integrates from the top of the hemisphere to the point of immersion.\n    // The second part integrates from the point of immersion to the bottom of the hemisphere.\n\n    // The first part integrates from the top of the hemisphere to the point of immersion.\n    // The integration is performed in two parts to handle potential singularities.\n    // The first part integrates from the top of the hemisphere to the point of immersion.\n    // The second part integrates from the point of immersion to the bottom of the hemisphere.\n    dReal zI = m_zI;\n    dReal z0 = m_z0;\n    dReal z1 = m_z1;\n    dReal z0OverR = m_z0OverR;\n    dReal z1OverR = m_z1OverR;\n    dReal tanTheta0 = m_tanTheta0;\n    dReal tanTheta1 = m_tanTheta1;\n    dReal sinTheta1 = m_sinTheta1;\n    dReal cosTheta1 = m_cosTheta1;\n    dReal zIOverR = m_zIOverR;\n    dReal tanThetaI = m_tanThetaI;\n    dReal sinThetaI = m_sinThetaI;\n    dReal cosThetaI = m_cosThetaI;\n    dReal tanTheta0OverR = m_tanTheta0OverR;\n    dReal tanTheta1OverR = m_tanTheta1OverR;\n    dReal tanThetaIOverR = m_tanThetaIOverR;\n    dReal tanTheta0Squared = m_tanTheta0Squared;\n    dReal tanTheta1Squared = m_tanTheta1Squared;\n    dReal tanThetaISquared = m_tanThetaISquared;\n    dReal tanTheta0OverRSquared = m_tanTheta0OverRSquared;\n    dReal tanTheta1OverRSquared = m_tanTheta1OverRSquared;", "CodeBleu_score": 16.90175948951891}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tdReal xBuoyancyCenter = 0;\n    dReal dz = zIOverR / (s_fNumSegments + 1);\n    for (int i = 0; i < s_fNumSegments; i++) {\n        dReal z = (i + 1) * dz;\n        dReal theta = asin(z);\n        dReal x = (tanTheta0 * z - sinTheta1) / (z - sinTheta1);\n        dReal f = x * cos(theta);\n        if (i % 2 == 0) xBuoyancyCenter += f;\n        else xBuoyancyCenter += 4 * f;\n    }\n    xBuoyancyCenter *= dz / 3;\n    xBuoyancyCenter -= volume * (tanTheta0 + sinTheta1) / 3;\n    return xBuoyancyCenter;\n}", "CodeBleu_score": 40.16508652763922}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tconst dReal x0 = 0.0;\n    const dReal y0 = 0.0;\n    const dReal z0 = 0.0;\n    const dReal x1 = 0.0;\n    const dReal y1 = 0.0;\n    const dReal z1 = zIOverR;\n    const dReal x2 = 0.0;\n    const dReal y2 = 0.0;\n    const dReal z2 = zIOverR;\n    const dReal x3 = 0.0;\n    const dReal y3 = 0.0;\n    const dReal z3 = zIOverR;\n    const dReal x4 = 0.0;\n    const dReal y4 = 0.0;\n    const dReal z4 = zIOverR;\n    const dReal x5 = 0.0;\n    const dReal y5 = 0.0;\n    const dReal z5 = zIOverR;\n    const dReal x6 = 0.0;\n    const dReal y6 = 0.0;\n    const dReal z6 = zIOverR;\n    const dReal x7 = 0.0;\n    const dReal y7 = 0.0;\n    const dReal z7 = zIOverR;\n    const dReal x8 = 0.0;\n    const dReal y8 = 0.0;\n    const dReal z8 = zIOverR;\n    const dReal x9 = 0.0;\n    const dReal y9 = 0.0;\n    const dReal z9 = zIOverR;\n    const dReal x10 = 0.0;\n    const dReal y10 = 0.0;\n    const dReal z10 = zIOverR;\n    const dReal x11 = 0.0;\n    const dReal y11 = 0.0;\n    const dReal z11 = zIOverR;\n    const dReal x12 = 0.0;\n    const dReal y12 = 0.0;\n    const dReal z12 = zI", "CodeBleu_score": 14.571793853688042}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tdReal xBuoyancyCenter = 0;\n    dReal z = zIOverR;\n    dReal dz = 2 * zIOverR / (sNumIntegrationSegments - 1);\n    dReal theta = asin(tanTheta0);\n    dReal dtheta = (asin(sinTheta1) - theta) / (sNumIntegrationSegments - 1);\n    for (int i = 0; i < sNumIntegrationSegments; i++) {\n        dReal r = sqrt(1 - z * z);\n        dReal x = r * cos(theta);\n        dReal y = r * sin(theta);\n        dReal xBuoyancyCenterSegment = x * (y * y + z * z);\n        xBuoyancyCenter += (i == 0 || i == sNumIntegrationSegments - 1) ? xBuoyancyCenterSegment : 4 * xBuoyancyCenterSegment;\n        theta += dtheta;\n        z += dz;\n    }\n    xBuoyancyCenter *= 3 * dz / (8 * volume);\n    return xBuoyancyCenter;\n}", "CodeBleu_score": 39.82412914386203}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"The first argument of dImmerseCapsuleTrimesh has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->type == dTriMeshClass, \"The second argument of dImmerseCapsuleTrimesh must be a trimesh\");\n\n  dxTriMesh *trimesh = (dxTriMesh *) o2;\n  dUASSERT(trimesh->doImmerseFaces, \"The second argument of dImmerseCapsuleTrimesh has not been set up for immersion testing\");\n\n  sCapsuleTrimeshImmersionData data(o1, trimesh, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 43.554638802470635}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body and/or the second argument has no fluid\");\n\n  dxCapsule *capsule = (dxCapsule*) o1;\n  dxTriMesh *mesh = (dxTriMesh*) o2;\n\n  sCapsuleTrimeshImmersionData data(capsule, mesh, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 42.70009390931094}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"The first argument has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->type == dTriMeshClass, \"The second argument is not a trimesh\");\n\n  dxTriMesh *trimesh = (dxTriMesh*) o2;\n  sCapsuleTrimeshImmersionData data(trimesh, (dxCapsule*) o1, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 44.34266232855128}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\tNodeStatus ret = SUCCESS;\n  if (!getInput<int>(\"ms\", &duration_)) {\n    ret = FAILURE;\n  } else if (duration_ <= 0) {\n    ret = SUCCESS;\n  } else {\n    setStatus(RUNNING);\n    timer_waiting_ = true;\n    timer_.setCallback(boost::bind(&SleepNode::wakeUp, this));\n    timer_.start(duration_);\n  }\n  return ret;\n}", "CodeBleu_score": 38.11597509909783}, {"code": "NodeStatus SleepNode::onStart(){\n\t// get the sleep duration in milliseconds\n  auto duration = getInput<double>(0);\n  if (!duration) {\n    return Status::SUCCESS;\n  }\n  if (*duration <= 0) {\n    return Status::SUCCESS;\n  }\n  // set the node status to RUNNING\n  setStatus(Status::RUNNING);\n  // start the timer\n  timer_waiting_ = true;\n  timer_.start(*duration, [this]() {\n    timer_waiting_ = false;\n    emit(SIGNAL(wakeUp()));\n  });\n  return Status::RUNNING;\n}", "CodeBleu_score": 44.712221211890856}, {"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the sleep duration in milliseconds from the input\n    std::chrono::milliseconds sleep_duration = getInput<std::chrono::milliseconds>(0);\n    // If the duration is missing or non-positive, return SUCCESS\n    if (!sleep_duration.count() || sleep_duration.count() < 0) {\n        return NodeStatus::SUCCESS;\n    }\n    // Set the node status to RUNNING\n    setStatus(NodeStatus::RUNNING);\n    // Start a timer\n    timer_waiting_ = true;\n    timer_ = std::make_shared<Timer>(sleep_duration);\n    timer_->setCallback([this]() {\n        // Emit a wake-up signal\n        emitSignal(kWakeUp);\n        // Set the node status to SUCCESS\n        setStatus(NodeStatus::SUCCESS);\n        // Reset the timer_waiting_ flag\n        timer_waiting_ = false;\n    });\n    timer_->start();\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 53.55485316350717}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\tNodeStatus status = NodeStatus::FAILURE;\n\t\n\t// get the entry\n\tstd::string entry_name = this->getInput<std::string>(\"Entry\");\n\tstd::shared_ptr<BlackboardEntry> entry = this->getBlackboard()->getEntry(entry_name);\n\t\n\t// if the entry exists\n\tif (entry != nullptr) {\n\t\t// lock the mutex\n\t\tstd::lock_guard<std::mutex> guard(entry->mtx);\n\t\t\n\t\t// compare the sequence ID\n\t\tif (entry->sequence_id != this->sequence_id) {\n\t\t\tthis->sequence_id = entry->sequence_id;\n\t\t\tstatus = NodeStatus::SUCCESS;\n\t\t}\n\t}\n\t\n\treturn status;\n}", "CodeBleu_score": 34.48573065063818}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tNodeStatus result = NodeStatus::FAILURE;\n\tstd::string entry_name = getInput<std::string>(\"entry_name\");\n\tstd::string entry_value = getInput<std::string>(\"entry_value\");\n\tstd::string entry_value_type = getInput<std::string>(\"entry_value_type\");\n\tstd::string entry_sequence_id = getInput<std::string>(\"entry_sequence_id\");\n\tstd::string entry_sequence_id_type = getInput<std::string>(\"entry_sequence_id_type\");\n\n\t// Retrieve the entry\n\tBT::Blackboard::Ptr blackboard = getInput<BT::Blackboard::Ptr>(\"blackboard\");\n\tif(blackboard == nullptr) {\n\t\tthrow BT::RuntimeError(\"error reading port [blackboard]: null pointer\");\n\t}\n\tBT::Blackboard::Ptr blackboard_entry = blackboard->getBlackboard(entry_name);\n\tif(blackboard_entry == nullptr) {\n\t\tthrow BT::RuntimeError(\"error reading port [blackboard]: blackboard does not exist\");\n\t}\n\n\t// Lock the entry\n\tblackboard_entry->lock();\n\n\t// Compare the sequence ID\n\tstd::string sequence_id;\n\tstd::string value;\n\tif(entry_value_type == \"int\") {\n\t\tint value_int = blackboard_entry->get<int>(entry_value);\n\t\tvalue = std::to_string(value_int);\n\t} else if(entry_value_type == \"float\") {\n\t\tfloat value_float = blackboard_entry->get<float>(entry_value);\n\t\tvalue = std::to_string(value_float);\n\t} else if(entry_value_type == \"bool\") {\n\t\tbool value_bool = blackboard_entry->get<bool>(entry_value);\n\t\tvalue = std::to_string(value_bool);\n\t} else if(entry_value_type == \"string\") {\n\t\tvalue = blackboard_entry->get<std::string>(entry_value);\n\t} else {\n\t\tthrow BT::RuntimeError", "CodeBleu_score": 35.71834545500853}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tROS_DEBUG_NAMED(\"EntryUpdatedAction\", \"EntryUpdatedAction::tick()\");\n\n\tstd::string entry_name = getInput<std::string>(\"entry_name\");\n\tstd::string entry_value;\n\tint sequence_id;\n\n\t// get the entry from the blackboard\n\tif (!blackboard_ptr_->get(entry_name, entry_value, sequence_id)) {\n\t\tROS_ERROR_NAMED(\"EntryUpdatedAction\", \"Failed to get entry '%s' from blackboard\", entry_name.c_str());\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// lock the entry's mutex\n\tstd::unique_lock<std::mutex> lock(*blackboard_ptr_->getMutex(entry_name));\n\n\t// compare the current sequence ID with the previously stored sequence ID\n\tif (sequence_id != stored_sequence_id_) {\n\t\t// store the new sequence ID\n\t\tstored_sequence_id_ = sequence_id;\n\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 42.09672654329953}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tif (success_threshold < 0) {\n        return static_cast<size_t>(std::max(1, std::abs(success_threshold) * children.size()));\n    }\n    return static_cast<size_t>(success_threshold);\n}", "CodeBleu_score": 55.0710792313845}, {"code": "size_t ParallelNode::successThreshold() const{\n\tint successThreshold = this->success_threshold;\n\tif (successThreshold < 0) {\n\t\tsuccessThreshold = -successThreshold;\n\t\tif (successThreshold > this->children.size()) {\n\t\t\tsuccessThreshold = this->children.size();\n\t\t}\n\t}\n\treturn successThreshold;\n}", "CodeBleu_score": 42.03821067605046}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (successThreshold_ < 0) {\n        return (size_t)(-successThreshold_ * (float)children_.size());\n    } else {\n        return (size_t)successThreshold_;\n    }\n}", "CodeBleu_score": 56.9306889658004}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile (ros::ok()) {\n    ros::Duration(0.01).sleep();\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    if (_p->heartbeat_active) {\n      ros::Time current_time = ros::Time::now();\n      ros::Duration diff = current_time - _p->heartbeat_last_received;\n      if (diff.toSec() > _p->heartbeat_timeout) {\n        ROS_INFO(\"heartbeat timeout, disabling breakpoints\");\n        _p->heartbeat_active = false;\n        enableAllHooks(false);\n      }\n    }\n  }\n}", "CodeBleu_score": 37.90966020556307}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile(ros::ok()) {\n    ros::Duration(0.01).sleep();\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    if(_p->heartbeat_status) {\n      if(_p->heartbeat_timer.elapsed().toSec() > _p->heartbeat_timeout) {\n        _p->heartbeat_status = false;\n        _p->heartbeat_timer.stop();\n        _p->heartbeat_timer.reset();\n        ROS_WARN(\"Groot2Publisher: Heartbeat timeout. Disabling all breakpoints.\");\n        enableAllHooks(false);\n      }\n    }\n    else {\n      if(_p->heartbeat_timer.elapsed().toSec() > _p->heartbeat_timeout) {\n        _p->heartbeat_status = true;\n        _p->heartbeat_timer.stop();\n        _p->heartbeat_timer.reset();\n        ROS_WARN(\"Groot2Publisher: Heartbeat detected. Enabling all breakpoints.\");\n        enableAllHooks(true);\n      }\n    }\n  }\n}", "CodeBleu_score": 31.965319897095}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile(_p->heartbeat_thread_running) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n    if(_p->heartbeat_active && std::chrono::steady_clock::now() - _p->heartbeat_last_received > std::chrono::milliseconds(1000)) {\n      _p->heartbeat_active = false;\n      std::cout << \"Groot2Publisher: Heartbeat stopped. Disabling all breakpoints.\" << std::endl;\n      enableAllHooks(false);\n    } else if(!_p->heartbeat_active && std::chrono::steady_clock::now() - _p->heartbeat_last_received < std::chrono::milliseconds(1000)) {\n      _p->heartbeat_active = true;\n      std::cout << \"Groot2Publisher: Heartbeat started. Enabling all breakpoints.\" << std::endl;\n      enableAllHooks(true);\n    }\n  }\n}", "CodeBleu_score": 45.25561474271177}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> dump;\n    std::vector<std::string> bb_names;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n\n    while (std::getline(ss, bb_name, ',')) {\n        bb_names.push_back(bb_name);\n    }\n\n    nlohmann::json j;\n\n    for (std::string bb_name : bb_names) {\n        std::shared_ptr<Blackboard> bb = this->getBlackboard(bb_name);\n        if (bb) {\n            std::lock_guard<std::mutex> lock(bb->getMutex());\n            if (bb->isValid()) {\n                j[bb_name] = bb->toJson();\n            }\n        }\n    }\n\n    dump = nlohmann::json::to_msgpack(j);\n    return dump;\n}", "CodeBleu_score": 43.610991848831034}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> dump;\n\n  std::vector<std::string> bb_names = split(bb_list, \",\");\n\n  std::cout << \"Dumping blackboards: \" << bb_list << std::endl;\n\n  rapidjson::Document document;\n  document.SetObject();\n  rapidjson::Document::AllocatorType& allocator = document.GetAllocator();\n\n  for (std::string bb_name : bb_names) {\n    std::cout << \"Dumping blackboard: \" << bb_name << std::endl;\n    std::lock_guard<std::mutex> lock(blackboard_mutexes[bb_name]);\n    if (blackboards[bb_name].isValid()) {\n      std::cout << \"Blackboard is valid\" << std::endl;\n      rapidjson::Document bb_json;\n      blackboards[bb_name].toJSON(bb_json, allocator);\n      rapidjson::Value bb_name_json;\n      bb_name_json.SetString(bb_name.c_str(), allocator);\n      document.AddMember(bb_name_json, bb_json, allocator);\n    } else {\n      std::cout << \"Blackboard is invalid\" << std::endl;\n    }\n  }\n\n  rapidjson::StringBuffer buffer;\n  rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);\n  document.Accept(writer);\n\n  std::string json_string = buffer.GetString();\n  std::vector<uint8_t> json_string_bytes(json_string.begin(), json_string.end());\n\n  std::cout << \"JSON string: \" << json_string << std::endl;\n\n  dump = msgpack::rpc::to_msgpack(json_string_bytes);\n\n  return dump;\n}", "CodeBleu_score": 39.77396442544927}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> result;\n    std::vector<std::string> bb_names;\n    std::vector<std::string>::iterator it;\n\n    // Split the string of blackboard names by comma\n    boost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\n    // Iterate through the blackboard names\n    for (it = bb_names.begin(); it != bb_names.end(); it++) {\n\n        // Get the subtree of the blackboard\n        const Groot2::Blackboard* bb = groot2_->getBlackboard(*it);\n\n        // Check if the subtree is valid\n        if (bb != NULL) {\n\n            // Lock the subtree\n            bb->lock();\n\n            // Export the blackboard to JSON\n            std::string json_bb = bb->toJSON();\n\n            // Add the blackboard to the JSON object\n            json_object_[*it] = json::parse(json_bb);\n\n            // Unlock the subtree\n            bb->unlock();\n\n        }\n\n    }\n\n    // Convert the JSON object to MessagePack format\n    result = json::to_msgpack(json_object_);\n\n    // Return the result\n    return result;\n\n}", "CodeBleu_score": 42.791608610945495}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hooks = pos == Position::PRE ? &_p->pre_hooks : &_p->post_hooks;\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto bk_it = hooks->find(node_uid);\n  if(bk_it == hooks->end())\n  {\n    return false;\n  }\n  auto hook = bk_it->second;\n  std::unique_lock<std::mutex> lk2(hook->mutex);\n  if(hook->mode == Monitor::Hook::Mode::BREAKPOINT)\n  {\n    hook->mode = Monitor::Hook::Mode::READY;\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->cond_var.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 62.93926878718056}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hooks = pos == Position::PRE ? &_p->pre_hooks : &_p->post_hooks;\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto bk_it = hooks->find(node_uid);\n  if(bk_it == hooks->end())\n  {\n    return false;\n  }\n  auto hook = bk_it->second;\n  std::unique_lock<std::mutex> lk_hook(hook->mutex);\n  if(hook->mode != HookMode::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->mode = HookMode::READY;\n  hook->result = result;\n  hook->remove = remove;\n  hook->cv.notify_all();\n  return true;\n}", "CodeBleu_score": 57.433456033678375}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hooks = pos == Position::PRE ? &_p->pre_hooks : &_p->post_hooks;\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto bk_it = hooks->find(node_uid);\n  if (bk_it == hooks->end()) {\n    return false;\n  }\n  auto hook = bk_it->second;\n  std::unique_lock<std::mutex> hook_lk(hook->mutex);\n  if (hook->status == NodeStatus::BREAKPOINT) {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->cv.notify_all();\n  }\n  return true;\n}", "CodeBleu_score": 56.98189348975175}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  halt_requested_.store(false);\n  try {\n    std::future<NodeStatus> future = std::async(std::launch::async, [this] {\n      return tick_functor_(*this);\n    });\n    future.wait();\n    NodeStatus status = future.get();\n    if(status != prev_status) {\n      setStatus(status);\n    }\n  } catch(std::exception& e) {\n    RCLCPP_ERROR(node_->get_logger(), \"Exception in ThreadedAction: %s\", e.what());\n    setStatus(NodeStatus::IDLE);\n  }\n  rethrowExceptionIfAny();\n  return status();\n}", "CodeBleu_score": 45.842507125883245}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n  if(prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  if(prev_status == NodeStatus::RUNNING) {\n    halt_requested_.store(false);\n    std::thread tick_thread([this]() {\n      try {\n        NodeStatus status = tick_functor_(*this);\n        if(status != prev_status) {\n          setStatus(status);\n        }\n      } catch(std::exception& e) {\n        std::string msg = \"Exception in threaded tick function: \";\n        msg += e.what();\n        RCLCPP_ERROR(node_->get_logger(), msg);\n        setStatus(NodeStatus::IDLE);\n      }\n    });\n    tick_thread.detach();\n  }\n\n  if(stored_exception_) {\n    std::exception_ptr e = stored_exception_;\n    stored_exception_ = nullptr;\n    std::rethrow_exception(e);\n  }\n\n  return status();\n}", "CodeBleu_score": 50.65350497813987}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n    halt_requested_.store(false);\n    std::thread([this] {\n      try {\n        NodeStatus status = tick_functor_(*this);\n        if(status != prev_status)\n        {\n          setStatus(status);\n        }\n      } catch(std::exception& e) {\n        RCLCPP_ERROR(node_->get_logger(), \"Exception caught in ThreadedAction: %s\", e.what());\n        setStatus(NodeStatus::IDLE);\n      }\n    }).detach();\n  }\n  if(exception_) {\n    std::exception_ptr e = exception_;\n    exception_ = nullptr;\n    std::rethrow_exception(e);\n  }\n  return status();\n}", "CodeBleu_score": 51.656364940891756}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tauto print_node = [&](const TreeNode* node, int depth) {\n\t\tstream << std::string(depth * 2, ' ') << node->name() << std::endl;\n\t\tif (node->is_control_node()) {\n\t\t\tfor (const auto& child : node->children()) {\n\t\t\t\tprint_node(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (node->is_decorator_node()) {\n\t\t\tprint_node(node->child(), depth + 1);\n\t\t}\n\t};\n\tstream << \"------------------------------------------------------------------------------------------------------------------------------\" << std::endl;\n\tprint_node(root_node, 0);\n\tstream << \"------------------------------------------------------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 36.318393767167336}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// lambda function for printing a node\n\tauto print_node = [&stream](const TreeNode* node, int depth) {\n\t\t// indent based on depth\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"  \";\n\t\t}\n\t\t// print node name\n\t\tstream << node->name() << std::endl;\n\t};\n\n\t// print separator line\n\tstream << \"--------------------------------------------------------------------------------\" << std::endl;\n\n\t// print root node\n\tprint_node(root_node, 0);\n\n\t// print children of root node\n\troot_node->printChildren(print_node, 1);\n\n\t// print separator line\n\tstream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 35.542091934668655}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// Recursive lambda function to print the tree\n    auto print_tree = [&stream, &print_tree](const TreeNode* node, int depth) {\n        // Print a separator line\n        stream << std::string(depth, '-') << \"> \" << node->name() << std::endl;\n\n        // Recursively print the children\n        if (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n            for (auto child : control_node->children()) {\n                print_tree(child, depth + 1);\n            }\n        }\n        else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n            print_tree(decorator_node->child(), depth + 1);\n        }\n    };\n\n    // Print the root node\n    print_tree(root_node, 0);\n}", "CodeBleu_score": 38.329724760027325}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.65854358087711}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.65854358087711}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.65854358087711}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builders.find(manifest.registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder: Registration ID \" +\n                                    manifest.registrationID + \" already exists.\");\n    }\n\n    builders[manifest.registrationID] = builder;\n    manifests[manifest.registrationID] = manifest;\n}", "CodeBleu_score": 44.84491912172726}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builders.find(manifest.registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"Error: a builder with the registration ID \\\"\" + manifest.registrationID + \"\\\" is already registered.\");\n    }\n    builders[manifest.registrationID] = builder;\n    manifests[manifest.registrationID] = manifest;\n}", "CodeBleu_score": 45.70532574590437}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builders.find(manifest.registrationId) != builders.end()) {\n        throw BehaviorTreeException(\"Builder with registration ID \\\"\" + manifest.registrationId + \"\\\" already exists.\");\n    }\n    builders[manifest.registrationId] = builder;\n    manifests[manifest.registrationId] = manifest;\n}", "CodeBleu_score": 45.110653832669726}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor, ports);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = NodeType::ACTION;\n  manifest.registration_ID = ID;\n  manifest.ports = ports;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 66.0213888308262}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n  };\n\n  TreeNodeManifest manifest = {\n      NodeType::ACTION, ID, std::move(ports), std::move(builder)};\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 75.4347555844155}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tauto builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor, ports);\n  };\n\n  TreeNodeManifest manifest(ID, ActionNode::TYPE, ports);\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 60.47962599950354}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> blackboard_backups;\n  blackboard_backups.reserve(tree.size());\n  for (const auto& subtree : tree) {\n    Blackboard::Ptr blackboard_backup(new Blackboard());\n    blackboard_backup->Clone(*subtree->blackboard());\n    blackboard_backups.push_back(blackboard_backup);\n  }\n  return blackboard_backups;\n}", "CodeBleu_score": 51.84422562129451}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> blackboard_backups;\n  blackboard_backups.reserve(tree.size());\n  for (const auto& node : tree) {\n    Blackboard::Ptr blackboard_backup = Blackboard::Create();\n    blackboard_backup->Clone(*node->blackboard());\n    blackboard_backups.push_back(blackboard_backup);\n  }\n  return blackboard_backups;\n}", "CodeBleu_score": 51.79335216235461}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> blackboard_backups;\n  blackboard_backups.reserve(tree.size());\n  for (const auto& subtree : tree) {\n    Blackboard::Ptr blackboard_backup = Blackboard::create();\n    blackboard_backup->clone(*subtree.blackboard());\n    blackboard_backups.push_back(blackboard_backup);\n  }\n  return blackboard_backups;\n}", "CodeBleu_score": 52.705086145985234}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor)\n  {\n    return executor.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 96.15955515290304}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor) {\n    return executor.value()(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 94.95952810948299}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto result = ParseScript(script);\n  if(result.has_value())\n  {\n    return result.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(result.error());\n  }\n}", "CodeBleu_score": 69.96473983782967}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t// Lock the mutex\n    std::lock_guard<std::mutex> lock(mutex_);\n\n    // Check if the library is already loaded\n    if (handle_) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n\n    // Attempt to load the library\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    // Check if the load failed\n    if (!handle_) {\n        throw RuntimeError(dlerror());\n    }\n\n    // Store the library path\n    path_ = path;\n}", "CodeBleu_score": 50.66610422345177}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::unique_lock<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle == nullptr) {\n        throw RuntimeError(dlerror());\n    }\n    loaded = true;\n    libraryPath = path;\n}", "CodeBleu_score": 53.43575004765096}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\"SharedLibrary::load: Library already loaded\");\n    }\n\n    // attempt to load the library\n    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(\"SharedLibrary::load: dlopen failed: \" + std::string(dlerror()));\n    }\n\n    // if we got here, the load was successful; save the path\n    loaded = true;\n    libPath = path;\n}", "CodeBleu_score": 53.31300641627112}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.length() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped.front() != '{' || stripped.back() != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer != nullptr) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.length() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 24.602364325830205}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size() < 3) {\n    return false;\n  }\n  StringView stripped = str.trim();\n  if (stripped.size() < 3) {\n    return false;\n  }\n  if (stripped[0] != '{' || stripped[stripped.size() - 1] != '}') {\n    return false;\n  }\n  if (stripped_pointer != nullptr) {\n    *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n  }\n  return true;\n}", "CodeBleu_score": 28.244105294167078}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t// Minimum length is 3 characters\n    if (str.length() < 3) {\n        return false;\n    }\n\n    // Strip leading and trailing spaces\n    StringView stripped = str.substr(str.find_first_not_of(\" \"), str.length());\n    stripped = stripped.substr(0, stripped.find_last_not_of(\" \") + 1);\n\n    // Check if the string starts with '{' and ends with '}'\n    if (stripped[0] != '{' || stripped[stripped.length() - 1] != '}') {\n        return false;\n    }\n\n    // Assign the inner content to stripped_pointer\n    if (stripped_pointer != nullptr) {\n        *stripped_pointer = stripped.substr(1, stripped.length() - 2);\n    }\n\n    return true;\n}", "CodeBleu_score": 31.57525952367908}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble lineCost = 0;\n    LineIterator line(x0, y0, x1, y1);\n    for( ; !line.done(); line.advance()) {\n      double pointCost = pointCost(line.x, line.y);\n      if(pointCost < 0)\n        return pointCost;\n      if(pointCost > lineCost)\n        lineCost = pointCost;\n    }\n    return lineCost;\n  }", "CodeBleu_score": 61.84209318774903}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble lineCost = 0;\n    double pointCost = 0;\n    unsigned char cost = 0;\n\n    LineIterator line(x0, y0, x1, y1);\n\n    for(; !line.done(); line.advance()) {\n      cost = costmap_.getCost(line.getX(), line.getY());\n      //if the cell is in an obstacle the path is invalid\n      if(cost == NO_INFORMATION)\n        return -2;\n      if(cost == LETHAL_OBSTACLE)\n        return -1;\n\n      pointCost = cost;\n      if(pointCost < 0)\n        return pointCost;\n      if(pointCost > lineCost)\n        lineCost = pointCost;\n    }\n\n    return lineCost;\n  }", "CodeBleu_score": 61.599057432674506}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble line_cost = 0;\n    LineIterator line(x0, y0, x1, y1);\n\n    //iterate through each point on the line\n    for(; !line.done(); line.advance()) {\n      double point_cost = pointCost(line.x(), line.y());\n      if(point_cost < 0) {\n        return point_cost;\n      }\n      if(point_cost > line_cost) {\n        line_cost = point_cost;\n      }\n    }\n    return line_cost;\n  }", "CodeBleu_score": 70.06103862982252}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t// Check that the path is not empty\n\tif(path.empty())\n\t\treturn;\n\n\t// Create a Path message\n\tnav_msgs::Path gui_path;\n\n\t// Copy the header from the first pose in the path\n\tgui_path.header = path[0].header;\n\n\t// Copy the poses from the plan to the Path message\n\tgui_path.poses.reserve(path.size());\n\tfor(unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses.push_back(path[i]);\n\t}\n\n\t// Publish the plan\n\tpub.publish(gui_path);\n}", "CodeBleu_score": 62.684743111138964}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path path_msg;\n  path_msg.header.frame_id = path[0].header.frame_id;\n  path_msg.header.stamp = path[0].header.stamp;\n  path_msg.poses = path;\n  pub.publish(path_msg);\n}", "CodeBleu_score": 47.08422695470749}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif(path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  for(std::size_t i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 84.47024913314594}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\tif ((fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) && (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity)) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 57.184731841893196}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t// Check if the angular velocity is below the rotational stopped velocity threshold\n  if (base_odom.twist.twist.angular.z <= rot_stopped_velocity) {\n    // Check if the linear velocity is below the translational stopped velocity threshold\n    if (base_odom.twist.twist.linear.x <= trans_stopped_velocity) {\n      // The robot is stopped\n      return true;\n    }\n  }\n  // The robot is not stopped\n  return false;\n}", "CodeBleu_score": 45.80872187341928}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t// Check if the robot is rotating\n  if (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n    // Check if the robot is translating\n    if (abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 57.15625269162972}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t// Setup\n    if (!setup_) {\n        // Setup default limits\n        default_limits_.max_vel_x = config.max_vel_x;\n        default_limits_.min_vel_x = config.min_vel_x;\n        default_limits_.max_vel_y = config.max_vel_y;\n        default_limits_.min_vel_y = config.min_vel_y;\n        default_limits_.max_vel_th = config.max_vel_th;\n        default_limits_.min_vel_th = config.min_vel_th;\n        default_limits_.acc_lim_x = config.acc_lim_x;\n        default_limits_.acc_lim_y = config.acc_lim_y;\n        default_limits_.acc_lim_th = config.acc_lim_th;\n        default_limits_.dec_lim_x = config.dec_lim_x;\n        default_limits_.dec_lim_y = config.dec_lim_y;\n        default_limits_.dec_lim_th = config.dec_lim_th;\n        default_limits_.yaw_rate_lim = config.yaw_rate_lim;\n        default_limits_.v_x_lim = config.v_x_lim;\n        default_limits_.v_y_lim = config.v_y_lim;\n        default_limits_.w_lim = config.w_lim;\n        default_limits_.v_x_offset = config.v_x_offset;\n        default_limits_.v_y_offset = config.v_y_offset;\n        default_limits_.w_offset = config.w_offset;\n        default_limits_.v_x_scale = config.v_x_scale;\n        default_limits_.v_y_scale = config.v_y_scale;\n        default_limits_.w_scale = config.w_scale;\n        default_limits_.v_x_max = config.v_x_max;\n        default_limits_.v_y_max = config.v_y_max;\n        default_limits_.w_max = config.w_max;\n        default_limits_.v", "CodeBleu_score": 22.37754829153351}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup) {\n\t\tif (restore_defaults) {\n\t\t\tconfig = default_config;\n\t\t}\n\t}\n\telse {\n\t\tdefault_config = config;\n\t\tsetup = true;\n\t}\n\n\tconfig_mutex.lock();\n\tcurrent_config = config;\n\tconfig_mutex.unlock();\n}", "CodeBleu_score": 46.000851851522825}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup) {\n        if (restore_defaults) {\n            config.max_speed_xy = 1.0;\n            config.max_speed_z = 1.0;\n            config.max_acc_xy = 1.0;\n            config.max_acc_z = 1.0;\n            config.max_jerk_xy = 1.0;\n            config.max_jerk_z = 1.0;\n            config.max_snap_xy = 1.0;\n            config.max_snap_z = 1.0;\n            config.max_tang_acc_xy = 1.0;\n            config.max_rot_speed = 1.0;\n            config.max_yaw_rate = 1.0;\n            config.min_turning_radius = 1.0;\n            config.wheel_base = 1.0;\n            config.front_wheel_offset = 1.0;\n            config.rear_wheel_offset = 1.0;\n            config.wheel_radius = 1.0;\n            config.max_steer_angle = 1.0;\n            config.max_steer_angle_rate = 1.0;\n            config.max_trailer_angle = 1.0;\n            config.max_trailer_angle_rate = 1.0;\n            config.max_trailer_sideslip_angle = 1.0;\n            config.max_trailer_sideslip_angle_rate = 1.0;\n            config.max_trailer_offset_distance = 1.0;\n            config.max_trailer_offset_distance_rate = 1.0;\n            config.max_trailer_wheel_angle = 1.0;\n            config.max_trailer_wheel_angle_rate = 1.0;\n            config.max_trailer_wheel_speed = 1.0;\n            config.max_trailer_wheel_speed_rate = 1.0;\n            config.max_trailer_wheel_acceleration", "CodeBleu_score": 20.46006910626422}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t//check the cost of the cell\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n  //if the cell is an obstacle, set the target distance to the max obstacle cost and return false\n  if(cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = costmap.getSizeInCellsX() + costmap.getSizeInCellsY();\n    return false;\n  }\n\n  //calculate the new target distance\n  unsigned int new_target_distance = current_cell->target_distance + 1;\n\n  //if the new target distance is less than the current target distance, update the target distance and return true\n  if(new_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_target_distance;\n    return true;\n  }\n\n  //if the new target distance is greater than the current target distance, return false\n  return false;\n}", "CodeBleu_score": 61.98021252390517}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// First, check the cost of the cell\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\n  // If the cell is an obstacle, set the target distance to the maximum cost and return\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = cost * cost;\n    return false;\n  }\n\n  // If the cell is not an obstacle, calculate a new target distance\n  int dX = check_cell->x - current_cell->x;\n  int dY = check_cell->y - current_cell->y;\n  int new_target_dist = current_cell->target_dist + (dX * dX + dY * dY);\n\n  // If the new distance is shorter, update the cell's target distance and return true\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n    return true;\n  }\n\n  // Otherwise, return false\n  return false;\n}", "CodeBleu_score": 71.81756630729406}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// get the cost of the cell\n  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\n  // if the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = costmap_2d::LETHAL_OBSTACLE;\n    return false;\n  }\n\n  // calculate the new target distance\n  double new_target_dist = current_cell->target_dist + 1.0;\n\n  // if the new distance is shorter, update the target distance and return true\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n    return true;\n  }\n\n  // otherwise, return false\n  return false;\n}", "CodeBleu_score": 68.6720322097361}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble footprint_cost = 0.0;\n  double scale = 1.0;\n  double total_cost = 0.0;\n  double scaling_speed = 0.0;\n  double max_trans_vel = 0.0;\n  double max_scaling_factor = 0.0;\n  std::vector<geometry_msgs::Point> footprint_spec;\n\n  //we'll scale the footprint based on the speed of the robot\n  if (traj.getVelocity() > 0.0) {\n    scaling_speed = scaling_speed_;\n    max_trans_vel = max_trans_vel_;\n    max_scaling_factor = max_scaling_factor_;\n    scale = getScalingFactor(traj, scaling_speed, max_trans_vel, max_scaling_factor);\n  }\n\n  //if the footprint is empty, we won't score it\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"The footprint is empty. Please set the footprint for the robot.\");\n    return -9.0;\n  }\n\n  //we'll score each point in the trajectory\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    footprint_cost = footprintCost(traj.getX(i), traj.getY(i), traj.getTheta(i), scale, footprint_spec_, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      total_cost += footprint_cost;\n    }\n    else {\n      total_cost = std::max(total_cost, footprint_cost);\n    }\n  }\n  return total_cost;\n}", "CodeBleu_score": 60.93672309112933}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //if the footprint is empty, we won't be able to score the trajectory\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"The footprint is empty. This can be caused by an empty footprint in the costmap, or by not having properly set the footprint for the robot. This could also be caused by having a footprint that is too large for the space on the costmap.\");\n    return -9.0;\n  }\n\n  //iterate over every point in the trajectory\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double x = traj.x_[i];\n    double y = traj.y_[i];\n    double th = traj.th_[i];\n\n    //calculate the footprint cost\n    double footprint_cost = footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n\n    //if the footprint cost is negative, we'll return it immediately\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    //if we're summing the cost, add the cost to the total\n    if (sum_scores_) {\n      cost += footprint_cost;\n    }\n\n    //if we're taking the max, take the max\n    else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  //return the total cost\n  return cost;\n}", "CodeBleu_score": 66.13405399483942}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = 1.0;\n\n  //if the footprint is empty, then we'll just return a cost of 0\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"The footprint of the robot is empty, which means that we'll always return a cost of 0. This is probably not what you want\");\n    return 0.0;\n  }\n\n  //we'll scale the footprint based on the speed of the trajectory\n  scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //we'll sum up the cost of each point in the trajectory\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double x = traj.x_[i];\n    double y = traj.y_[i];\n    double th = traj.theta_[i];\n\n    double footprint_cost = footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n\n    //if the footprint is in an invalid or unknown space, we'll return a cost of 0\n    //since we're assuming that the trajectory is safe\n    if (footprint_cost < 0) {\n      return 0.0;\n    }\n\n    //we'll either sum the cost or take the max\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 65.23188192443344}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// Scale the footprint\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        footprint_spec[i].x *= scale;\n        footprint_spec[i].y *= scale;\n    }\n\n    // Rotate the footprint into the frame of the robot\n    std::vector<geometry_msgs::Point> rotated_footprint = rotateFootprint(th, footprint_spec);\n\n    // Translate the points into the frame of the costmap\n    std::vector<geometry_msgs::Point> translated_footprint = translateFootprint(x, y, rotated_footprint);\n\n    // Check if any of the points are off the costmap\n    for (unsigned int i = 0; i < translated_footprint.size(); i++) {\n        if (!costmap->worldToMap(translated_footprint[i].x, translated_footprint[i].y, translated_footprint[i].x, translated_footprint[i].y)) {\n            return -7.0;\n        }\n    }\n\n    // Get the costmap cost of the footprint\n    double footprint_cost = world_model->footprintCost(translated_footprint, costmap);\n\n    // Get the costmap cost of the center point\n    unsigned char cost;\n    if (!costmap->getCost(x, y, cost)) {\n        return -7.0;\n    }\n\n    // If the footprint cost is negative, return -6.0\n    if (footprint_cost < 0.0) {\n        return -6.0;\n    }\n\n    // Otherwise, return the maximum cost of the footprint and the center point\n    return std::max(footprint_cost, cost);\n}", "CodeBleu_score": 56.315879256221166}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// scale the footprint\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point pt;\n    pt.x = x + (footprint_spec[i].x * cos(th) - footprint_spec[i].y * sin(th)) * scale;\n    pt.y = y + (footprint_spec[i].x * sin(th) + footprint_spec[i].y * cos(th)) * scale;\n    scaled_footprint.push_back(pt);\n  }\n\n  // compute the footprint cost\n  double footprint_cost = 0.0;\n  for (unsigned int i = 0; i < scaled_footprint.size(); i++) {\n    unsigned int mx, my;\n    if (!costmap->worldToMap(scaled_footprint[i].x, scaled_footprint[i].y, mx, my)) {\n      return -7.0;\n    }\n    unsigned char cost = costmap->getCost(mx, my);\n    if (cost == costmap_2d::NO_INFORMATION) {\n      double wx, wy;\n      costmap->mapToWorld(mx, my, wx, wy);\n      cost = world_model->footprintCost(wx, wy, footprint_spec);\n    }\n    if (cost < 0)\n      return -6.0;\n    footprint_cost = std::max(footprint_cost, (double)cost);\n  }\n\n  // compute the cell cost\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n  unsigned char cost = costmap->getCost(mx, my);\n  if (cost == costmap_2d::NO_INFORMATION) {\n    double wx, wy;\n    costmap->mapToWorld(mx, my, wx, wy);\n    cost = world_model->footprintCost(wx, wy, footprint_spec);", "CodeBleu_score": 60.36674015858424}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// If the footprint is empty, return a cost of zero.\n    if (footprint_spec.empty())\n        return 0.0;\n\n    // If the scale is negative, return a cost of zero.\n    if (scale < 0.0)\n        return 0.0;\n\n    // If the scale is zero, return a cost of zero.\n    if (scale == 0.0)\n        return 0.0;\n\n    // If the world model is null, return a cost of zero.\n    if (!world_model)\n        return 0.0;\n\n    // If the costmap is null, return a cost of zero.\n    if (!costmap)\n        return 0.0;\n\n    // If the costmap is not yet initialized, return a cost of zero.\n    if (!costmap->getSizeX() || !costmap->getSizeY())\n        return 0.0;\n\n    // If the position is off the map, return -7.0.\n    if (!costmap->worldToMap(x, y, cell_x, cell_y))\n        return -7.0;\n\n    // If the position is outside the map bounds, return -7.0.\n    if (cell_x < 0 || cell_y < 0 || cell_x >= costmap->getSizeInCellsX() || cell_y >= costmap->getSizeInCellsY())\n        return -7.0;\n\n    // Compute the footprint in the frame of the costmap.\n    std::vector<geometry_msgs::Point> footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        geometry_msgs::Point pt = footprint_spec[i];\n        pt.x = pt.x * scale;\n        pt.y = pt.y * scale;\n        pt.x = pt.x * cos(th) - pt.y * sin(th);\n        pt.y = pt.x * sin(th) + pt.y * cos(th);\n        footprint.push_back(pt);\n    }\n\n    // Compute the footprint cost.\n    double footprint", "CodeBleu_score": 55.05753712848751}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.73339564111626}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic_ != odom_topic) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.73339564111626}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = node_->subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.82824651715629}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist_sq = (pos - prev).squaredNorm();\n  float angle = acos(pos.dot(prev) / (pos.norm() * prev.norm()));\n\n  if (dist_sq > 0.0000001 || angle > 0.0000001) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 32.09586321095126}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist_sq = (pos - prev).squaredNorm();\n  float angle = std::abs(atan2(pos.y() - prev.y(), pos.x() - prev.x()));\n\n  if(dist_sq > 0.01f) {\n    resetOscillationFlags();\n  }\n\n  if(angle > 0.1f) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 36.403184971916666}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist_sq = (pos - prev).squaredNorm();\n  float angle = acos(pos.dot(prev) / (pos.norm() * prev.norm()));\n\n  if (dist_sq > dist_threshold_ * dist_threshold_) {\n    resetOscillationFlags();\n  }\n\n  if (angle > angle_threshold_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 41.034111116893136}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //now we need to check what cells could contain the nearest neighbor\n    geometry_msgs::Point32 check_point;\n    double sq_dist = DBL_MAX;\n    double neighbor_sq_dist = DBL_MAX;\n    \n    //left\n    if(gx > 0){\n      check_point.x = lower_left.x;\n      check_point.y = pt.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        return;\n    }\n\n    //upper left\n    if(gx > 0 && gy < height_ - 1){\n      check_point.x = lower_left.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        return;\n    }\n\n    //top\n    if(gy < height_ - 1){\n      check_point.x = pt.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        return;\n    }\n\n    //upper right\n    if(gx < width_ - 1 && gy < height_ - 1){\n      check_point.x = upper_right.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        return;\n    }\n\n    //right\n    if(gx < width_ - 1){\n      check_point.x = upper_right.", "CodeBleu_score": 46.014196321956994}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //check if the point is outside the grid bounds\n    if(gx >= width_ || gy >= height_){\n      ROS_ERROR(\"Point %f, %f is outside the grid bounds\", pt.x, pt.y);\n      return;\n    }\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //now we need to check what cells could contain the nearest neighbor\n    geometry_msgs::Point32 check_point;\n    double sq_dist = DBL_MAX;\n    double neighbor_sq_dist = DBL_MAX;\n    \n    //left\n    if(gx > 0){\n      check_point.x = lower_left.x;\n      check_point.y = pt.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy));\n    }\n\n    //upper left\n    if(gx > 0 && gy < height_ - 1){\n      check_point.x = lower_left.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy + 1));\n    }\n\n    //top\n    if(gy < height_ - 1){\n      check_point.x = pt.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)", "CodeBleu_score": 45.403929758056925}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  gridCoords(pt, gx, gy);\n\n  //get the bounds of the grid cell in world coords\n  geometry_msgs::Point lower_left, upper_right;\n  getCellBounds(gx, gy, lower_left, upper_right);\n\n  //check if the point is too close to its nearest neighbor\n  if(nearestNeighborDistance(pt) < sq_min_separation_)\n    return;\n\n  //if the point is valid, insert it into the grid\n  unsigned int index = gx + gy * width_;\n  cells_[index].push_back(pt);\n}", "CodeBleu_score": 69.82972386964394}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = vel[i] + std::min(acclimits[i], sample_target_vel[i] - vel[i]);\n        } else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = vel[i] - std::min(acclimits[i], vel[i] - sample_target_vel[i]);\n        } else {\n            new_vel[i] = vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 62.46366798664934}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            if (sample_target_vel[i] - vel[i] < acclimits[i] * dt) {\n                new_vel[i] = sample_target_vel[i];\n            } else {\n                new_vel[i] = vel[i] + acclimits[i] * dt;\n            }\n        } else if (sample_target_vel[i] < vel[i]) {\n            if (vel[i] - sample_target_vel[i] < acclimits[i] * dt) {\n                new_vel[i] = sample_target_vel[i];\n            } else {\n                new_vel[i] = vel[i] - acclimits[i] * dt;\n            }\n        } else {\n            new_vel[i] = vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 69.0477518067597}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n    // For each of the three velocity components, increase or decrease the current velocity towards the target velocity within the acceleration limits.\n    for (int i = 0; i < 3; i++) {\n        // If the current velocity is less than the target velocity, increase it within the acceleration limits.\n        if (vel(i) < sample_target_vel(i)) {\n            // If the current velocity is already at the acceleration limit, don't increase it.\n            if (vel(i) >= acclimits(i)) {\n                new_vel(i) = vel(i);\n            }\n            // Otherwise, increase the current velocity within the acceleration limits.\n            else {\n                new_vel(i) = vel(i) + acclimits(i) * dt;\n            }\n        }\n        // If the current velocity is greater than the target velocity, decrease it within the acceleration limits.\n        else if (vel(i) > sample_target_vel(i)) {\n            // If the current velocity is already at the acceleration limit, don't decrease it.\n            if (vel(i) <= -acclimits(i)) {\n                new_vel(i) = vel(i);\n            }\n            // Otherwise, decrease the current velocity within the acceleration limits.\n            else {\n                new_vel(i) = vel(i) - acclimits(i) * dt;\n            }\n        }\n        // If the current velocity is equal to the target velocity, keep it the same.\n        else {\n            new_vel(i) = vel(i);\n        }\n    }\n\n    return new_vel;\n}", "CodeBleu_score": 53.954624998451536}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tdouble goal_x;\n  double goal_y;\n  double goal_heading;\n\n  double heading_diff;\n\n  double min_heading_diff = DBL_MAX;\n\n  //Iterate through the plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  for (int i = plan.size() - 1; i >= 0; i--) {\n    //Convert the goal cell coordinates to world coordinates\n    goal_x = plan[i].x * map->getResolution() + map->getOriginX();\n    goal_y = plan[i].y * map->getResolution() + map->getOriginY();\n\n    //Calculate the shortest angular distance between the current heading and the direction to the goal point\n    goal_heading = atan2(goal_y - y, goal_x - x);\n    heading_diff = fabs(angles::shortest_angular_distance(heading, goal_heading));\n\n    //If the heading difference is smaller than the previous smallest heading difference, update the minimum heading difference\n    if (heading_diff < min_heading_diff) {\n      min_heading_diff = heading_diff;\n    }\n\n    //If the current cell is a clearing, break out of the loop\n    if (map->getCost(cell_x, cell_y) == costmap_2d::FREE_SPACE) {\n      break;\n    }\n  }\n\n  //If no valid point is found, return DBL_MAX\n  if (min_heading_diff == DBL_MAX) {\n    return DBL_MAX;\n  }\n\n  //Return the minimum heading difference\n  return min_heading_diff;\n}", "CodeBleu_score": 48.765652438303654}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t//Iterate through the global plan in reverse\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    //Get the coordinates of the current point in the global plan\n    int x_i = (int) global_plan_[i].pose.position.x;\n    int y_i = (int) global_plan_[i].pose.position.y;\n\n    //Check if the current point is in the same cell as the robot\n    if (x_i == cell_x && y_i == cell_y) {\n      //Get the coordinates of the goal point in the global plan\n      int x_goal = (int) global_plan_[global_plan_.size() - 1].pose.position.x;\n      int y_goal = (int) global_plan_[global_plan_.size() - 1].pose.position.y;\n\n      //Get the coordinates of the goal point in the robot's frame of reference\n      double x_goal_robot = x_goal - x;\n      double y_goal_robot = y_goal - y;\n\n      //Get the angle to the goal point\n      double angle_to_goal = atan2(y_goal_robot, x_goal_robot);\n\n      //Get the difference between the current heading and the angle to the goal point\n      double heading_diff = fabs(angle_to_goal - heading);\n\n      //Check if the angle to the goal point is within the robot's field of view\n      if (heading_diff < fov_ / 2) {\n        return heading_diff;\n      }\n    }\n  }\n\n  return DBL_MAX;\n}", "CodeBleu_score": 52.456661458082834}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tdouble goal_x, goal_y;\n  double goal_heading;\n  double heading_diff;\n\n  int index = global_plan_.size() - 1;\n  while (index >= 0) {\n    goal_x = global_plan_[index].pose.position.x;\n    goal_y = global_plan_[index].pose.position.y;\n\n    //Check if the goal cell is in the robot's FOV\n    if (fov_->inFov(cell_x, cell_y, goal_x, goal_y)) {\n      //Check if the goal cell is in the robot's FOV\n      if (fov_->inFov(cell_x, cell_y, goal_x, goal_y)) {\n        //Check if the goal cell is in the robot's FOV\n        if (fov_->inFov(cell_x, cell_y, goal_x, goal_y)) {\n          //Check if the goal cell is in the robot's FOV\n          if (fov_->inFov(cell_x, cell_y, goal_x, goal_y)) {\n            //Check if the goal cell is in the robot's FOV\n            if (fov_->inFov(cell_x, cell_y, goal_x, goal_y)) {\n              //Check if the goal cell is in the robot's FOV\n              if (fov_->inFov(cell_x, cell_y, goal_x, goal_y)) {\n                //Check if the goal cell is in the robot's FOV\n                if (fov_->inFov(cell_x, cell_y, goal_x, goal_y)) {\n                  //Check if the goal cell is in the robot's FOV\n                  if (fov_->inFov(cell_x, cell_y, goal_x, goal_y)) {\n                    //Check if the goal cell is in the robot's FOV\n                    if (fov_->inFov(cell_x, cell_y, goal_x, goal_y)) {\n                      //Check if the goal cell is in the robot", "CodeBleu_score": 41.979977992550886}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if( cost < 0.0 ) {\n      ROS_WARN(\"TrajectoryPlanner::checkTrajectory: trajectory with sample velocities (%f, %f, %f) has cost %f\", vx_samp, vy_samp, vtheta_samp, cost);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 77.38587211111411}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tdouble cost = scoreTrajectory(x, y, theta,\n                                  vx, vy, vtheta,\n                                  vx_samp, vy_samp, vtheta_samp);\n\n    if (cost < 0) {\n        ROS_WARN(\"Cost of trajectory is negative: %f\", cost);\n        ROS_WARN(\"vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", vx_samp, vy_samp, vtheta_samp);\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 68.19098811254152}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if(cost >= 0) {\n      return true;\n    } else {\n      ROS_WARN(\"Trajectory invalid with cost %f, vx_samp=%f, vy_samp=%f, vtheta_samp=%f\",\n               cost, vx_samp, vy_samp, vtheta_samp);\n      return false;\n    }\n  }", "CodeBleu_score": 78.56350842294114}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (costmap_ros_ == NULL) {\n    ROS_ERROR(\"The costmap_ros_ member pointer is NULL. Make sure to call initialize before runBehavior.\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"The global_costmap_ member pointer is NULL. Make sure to call initialize before runBehavior.\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"The local_costmap_ member pointer is NULL. Make sure to call initialize before runBehavior.\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside of the specified area.\");\n  }\n\n  ros::Time start = ros::Time::now();\n\n  if (affected_maps_ & AFFECT_GLOBAL_MAP) {\n    if (invert_area_to_clear_) {\n      clearMap(global_costmap_->getCostmap(), x_, y_);\n    } else {\n      clearMap(global_costmap_->getCostmap(), x_, y_, x_min_, x_max_, y_min_, y_max_);\n    }\n    if (force_update_) {\n      global_costmap_->updateMap(x_min_, x_max_, y_min_, y_max_, true);\n    }\n  }\n\n  if (affected_maps_ & AFFECT_LOCAL_MAP) {\n    if (invert_area_to_clear_) {\n      clearMap(local_costmap_->getCostmap(), x_, y_);\n    } else {\n      clearMap(local_costmap_->getCostmap(), x_, y_, x_min_, x_max_, y_min_, y_max_);\n    }\n    if (force_update_) {\n      local_costmap_->updateMap(x_min_, x_max_, y_min_, y_max_, true);\n    }\n  }", "CodeBleu_score": 50.998896743434315}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t// Check if the object is initialized\n  if(!initialized_){\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  // Check if the costmaps are not NULL\n  if(global_costmap_ == NULL || local_costmap_ == NULL){\n    ROS_ERROR(\"The costmaps passed to this object cannot be NULL\");\n    return;\n  }\n\n  // Log a warning if the area to clear is inside the specified area\n  if(invert_area_to_clear_){\n    ROS_WARN(\"The area to clear is inside the specified area\");\n  }\n\n  // Clear the global and/or local costmap\n  if(affected_maps_ == AFFECTED_MAPS_GLOBAL || affected_maps_ == AFFECTED_MAPS_BOTH){\n    ROS_INFO(\"Clearing the global costmap\");\n    clearMap(global_costmap_, x_min_, y_min_, x_max_, y_max_, invert_area_to_clear_);\n  }\n\n  if(affected_maps_ == AFFECTED_MAPS_LOCAL || affected_maps_ == AFFECTED_MAPS_BOTH){\n    ROS_INFO(\"Clearing the local costmap\");\n    clearMap(local_costmap_, x_min_, y_min_, x_max_, y_max_, invert_area_to_clear_);\n  }\n\n  // Optionally force an update\n  if(force_update_){\n    ROS_INFO(\"Forcing an update of the global costmap\");\n    global_costmap_->updateMap();\n\n    ROS_INFO(\"Forcing an update of the local costmap\");\n    local_costmap_->updateMap();\n  }\n}", "CodeBleu_score": 52.21780672508294}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_){\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if(!costmap_ || !local_costmap_){\n    ROS_ERROR(\"The costmap and local costmap pointers must not be null\");\n    return;\n  }\n\n  if(invert_area_to_clear_){\n    ROS_WARN(\"Clearing inside an area\");\n  }\n  else{\n    ROS_WARN(\"Clearing outside an area\");\n  }\n\n  ros::WallTime start = ros::WallTime::now();\n  if(affected_maps_ & costmap_2d::FREE_SPACE){\n    clear(costmap_);\n    if(force_update_){\n      costmap_->updateMap(0,0,costmap_->getSizeInCellsX(), costmap_->getSizeInCellsY());\n    }\n  }\n  if(affected_maps_ & costmap_2d::INVALIDATED){\n    clear(local_costmap_);\n    if(force_update_){\n      local_costmap_->updateMap(0,0,local_costmap_->getSizeInCellsX(), local_costmap_->getSizeInCellsY());\n    }\n  }\n  ros::WallTime end = ros::WallTime::now();\n  ros::WallDuration d = end - start;\n  ROS_INFO(\"Clearing the costmap took %.3f ms\", d.toSec() * 1000.0);\n}", "CodeBleu_score": 48.160000881665624}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tPolygonOutlineCells poly_cells;\n  for (size_t i = 0; i < polygon.size(); ++i) {\n    raytraceLine(polygon[i], polygon[(i + 1) % polygon.size()], poly_cells);\n  }\n  if (polygon.size() > 2) {\n    raytraceLine(polygon.back(), polygon.front(), poly_cells);\n  }\n  poly_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 44.13951667765237}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t// TODO: this should be a method of PolygonOutlineCells\n    if (polygon.size() == 0) {\n        return;\n    }\n\n    PolygonOutlineCells cells;\n    for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n        raytraceLine(polygon[i], polygon[i + 1], cells);\n    }\n    raytraceLine(polygon.back(), polygon.front(), cells);\n\n    // TODO: this should be a method of PolygonOutlineCells\n    // TODO: this is inefficient, but we can't use std::set because MapLocation is not hashable\n    polygon_cells.reserve(cells.size());\n    for (const auto& cell : cells) {\n        if (std::find(polygon_cells.begin(), polygon_cells.end(), cell) == polygon_cells.end()) {\n            polygon_cells.push_back(cell);\n        }\n    }\n}", "CodeBleu_score": 54.85491478938533}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tpolygon_cells.clear();\n    PolygonOutlineCells cells;\n    for (unsigned int i = 0; i < polygon.size(); ++i) {\n        unsigned int j = (i + 1) % polygon.size();\n        raytraceLine(polygon[i], polygon[j], cells);\n    }\n    if (polygon.size() > 2) {\n        raytraceLine(polygon.back(), polygon.front(), cells);\n    }\n    cells.getCells(polygon_cells);\n}", "CodeBleu_score": 52.01771189504287}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 64.70573755156508}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 96.07644084284831}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 64.70573755156508}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t// lock the costmap mutex\n  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  // get the map resolution\n  double resolution = costmap_->getResolution();\n  // set the header information of the grid\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  // set the size of the grid\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  // convert the origin of the costmap to world coords\n  costmap_->mapToWorld(0, 0, grid_.info.origin.position.x, grid_.info.origin.position.y);\n  // save the origin for later use\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n  // resize the grid's data\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  // populate the costmap\n  unsigned int index = 0;\n  for (unsigned int iy = 0; iy < grid_.info.height; ++iy) {\n    for (unsigned int ix = 0; ix < grid_.info.width; ++ix) {\n      unsigned char cost = costmap_->getCost(ix, iy);\n      grid_.data[index] = cost;\n      ++index;\n    }\n  }\n}", "CodeBleu_score": 64.69901714999105}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  geometry_msgs::Point origin;\n  origin.x = costmap_->getOriginX();\n  origin.y = costmap_->getOriginY();\n  origin.z = 0.0;\n  grid_.info.origin = origin;\n\n  // save the origin coordinates\n  origin_x_ = origin.x;\n  origin_y_ = origin.y;\n\n  // resize the grid\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // populate the grid\n  unsigned int index = 0;\n  for (unsigned int i = 0; i < grid_.info.height; ++i) {\n    for (unsigned int j = 0; j < grid_.info.width; ++j) {\n      unsigned char value = costmap_->getCharMap()[index];\n      grid_.data[index] = costTranslationTable_[value];\n      ++index;\n    }\n  }\n}", "CodeBleu_score": 64.51567632977475}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  //convert the origin of the costmap to world coords\n  costmap_->mapToWorld(0, 0, grid_.info.origin.position.x, grid_.info.origin.position.y);\n  tf::Quaternion q;\n  q.setEuler(0, 0, costmap_->getAngle());\n  grid_.info.origin.orientation.x = q.x();\n  grid_.info.origin.orientation.y = q.y();\n  grid_.info.origin.orientation.z = q.z();\n  grid_.info.origin.orientation.w = q.w();\n\n  //save the origin for later use\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n\n  //resize the grid to match the size of the costmap\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n}", "CodeBleu_score": 54.28217028745815}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n    return;\n\n  std::vector<geometry_msgs::Point> new_footprint;\n  if (new_config.footprint != old_config.footprint) {\n    if (!parseFootprint(new_config.footprint, new_footprint)) {\n      ROS_ERROR(\"Invalid footprint specification: %s. Footprint not updated.\", new_config.footprint.c_str());\n      return;\n    }\n  } else {\n    double radius = new_config.robot_radius;\n    new_footprint.clear();\n    new_footprint.push_back(toPoint(0, radius));\n    new_footprint.push_back(toPoint(radius, 0));\n    new_footprint.push_back(toPoint(0, -radius));\n    new_footprint.push_back(toPoint(-radius, 0));\n  }\n  setUnpaddedRobotFootprint(new_footprint);\n}", "CodeBleu_score": 63.978165032303046}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t// if the footprint and radius are the same, we don't need to do anything\n  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // if we have a valid footprint string, we'll use that\n  if (!new_config.footprint.empty()) {\n    if (new_config.footprint[0] == '(') {\n      std::vector<geometry_msgs::Point> points;\n      if (parseFootprint(new_config.footprint, points)) {\n        setUnpaddedRobotFootprint(points);\n        return;\n      } else {\n        ROS_ERROR(\"The footprint specified in the costmap configuration is not a valid polygon\");\n        return;\n      }\n    } else {\n      ROS_ERROR(\"The footprint specified in the costmap configuration is not a valid polygon\");\n      return;\n    }\n  }\n\n  // otherwise, we'll just use the radius\n  std::vector<geometry_msgs::Point> points;\n  double radius = new_config.robot_radius;\n  if (radius > 0) {\n    points.resize(4);\n    points[0].x = -radius;\n    points[0].y = -radius;\n    points[1].x = -radius;\n    points[1].y = radius;\n    points[2].x = radius;\n    points[2].y = radius;\n    points[3].x = radius;\n    points[3].y = -radius;\n  } else {\n    points.resize(0);\n  }\n  setUnpaddedRobotFootprint(points);\n}", "CodeBleu_score": 63.287656382621314}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> points;\n    if (costmap_2d::parseFootprint(new_config.footprint, points)) {\n      setUnpaddedRobotFootprint(points);\n    } else {\n      ROS_ERROR(\"Invalid footprint specification: %s\", new_config.footprint.c_str());\n    }\n  } else {\n    setUnpaddedRobotFootprint(costmap_2d::makeFootprintFromRadius(new_config.robot_radius));\n  }\n}", "CodeBleu_score": 70.85390302014203}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Failed to get robot pose. Cancelling reconfiguration.\");\n    return;\n  }\n  if (!moving_ && !footprint_clearing_enabled_) {\n    ROS_DEBUG_NAMED(\"costmap\", \"Robot has stopped moving. Cancelling reconfiguration.\");\n    return;\n  }\n  moving_ = false;\n  reconfigureCallback(config_, level_);\n}", "CodeBleu_score": 58.76870654534246}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Failed to get robot pose, cancelling reconfiguration.\");\n    return;\n  }\n  double diff_x = fabs(new_pose.pose.position.x - last_pose_.pose.position.x);\n  double diff_y = fabs(new_pose.pose.position.y - last_pose_.pose.position.y);\n  double diff_rot = fabs(tf2::getYaw(new_pose.pose.orientation) - tf2::getYaw(last_pose_.pose.orientation));\n  if (diff_x > min_x_range_ || diff_y > min_y_range_ || diff_rot > min_rot_range_) {\n    reconfigureCB(config_);\n    last_pose_ = new_pose;\n  }\n}", "CodeBleu_score": 58.9466361878867}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Failed to get robot pose. Cancelling reconfiguration\");\n    return;\n  }\n  reconfigureCB(new_pose);\n}", "CodeBleu_score": 67.79490848782059}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t// Retrieve the list of plugins\n  std::vector<boost::shared_ptr<layer::Layer> > plugins = getPlugins();\n\n  // Check if the costmap was stopped\n  if (stopped_) {\n    // Re-subscribe to topics by activating each plugin\n    for (unsigned int i = 0; i < plugins.size(); ++i) {\n      plugins[i]->activate();\n    }\n\n    // Set the stopped flag to false\n    stopped_ = false;\n  }\n\n  // Set stop_updates_ to false\n  stop_updates_ = false;\n\n  // Wait until ROS is running, the costmap is initialized, and the map update thread is active\n  while (ros::ok() && !is_initialized_ && !map_update_thread_->isRunning()) {\n    ros::Duration(0.1).sleep();\n  }\n}", "CodeBleu_score": 54.67009273879587}, {"code": "void Costmap2DROS::start(){\n\tif (stopped_) {\n    ROS_DEBUG_NAMED(\"costmap\", \"Costmap2DROS::start() resubscribing to topics.\");\n    std::vector< boost::shared_ptr<Layer> >::iterator plugin_iter = plugins_.begin();\n    for (; plugin_iter != plugins_.end(); ++plugin_iter) {\n      boost::shared_ptr<Layer> plugin = *plugin_iter;\n      if (plugin->is_enabled()) {\n        plugin->reconfigure();\n        plugin->reset();\n        plugin->activate();\n      }\n    }\n    stopped_ = false;\n  }\n\n  // wait for the costmap to be fully initialized\n  while (!is_running_ && ros::ok()) {\n    ros::Duration(0.01).sleep();\n  }\n\n  // wait for the costmap to be fully initialized\n  while (!map_update_thread_->is_active() && ros::ok()) {\n    ros::Duration(0.01).sleep();\n  }\n\n  stop_updates_ = false;\n}", "CodeBleu_score": 53.36048653909549}, {"code": "void Costmap2DROS::start(){\n\t// Retrieve the list of plugins\n    std::vector<boost::shared_ptr<Layer> > plugins = getPlugins();\n\n    // Check if the costmap was stopped\n    if (stopped_) {\n\n        // Re-subscribe to topics by activating each plugin\n        for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins.begin(); plugin != plugins.end(); ++plugin) {\n            (*plugin)->activate();\n        }\n\n        // Set the stopped flag to false\n        stopped_ = false;\n\n        // Set stop_updates_ to false\n        stop_updates_ = false;\n\n        // Wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n        while (!costmap_initialized_ || !map_update_thread_->isRunning()) {\n            usleep(100000);\n        }\n    }\n}", "CodeBleu_score": 65.5492014664519}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == ros::Duration(0)) {\n    // we are only keeping the most recent observation, so if the list is longer than\n    // one, we need to delete the old ones\n    if (observations_.size() > 1) {\n      observations_.erase(observations_.begin(), --(observations_.end()));\n    }\n  } else {\n    // we have a keep time, so we need to iterate through the list and remove any\n    // observations that are older than the specified keep time\n    ros::Time latest_allowed_time = ros::Time::now() - observation_keep_time_;\n    for (ObservationList::iterator it = observations_.begin(); it != observations_.end();) {\n      if (it->header.stamp < latest_allowed_time) {\n        it = observations_.erase(it);\n      } else {\n        // since the list is sorted with most recent at the end, we can stop deleting\n        // once we reach the first valid observation\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 46.80559411430851}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t// If we're not keeping any observations, clear the list and return\n  if (observation_keep_time_ == 0.0) {\n    ROS_DEBUG_NAMED(\"local_topo_hssh\", \"Purging all observations from the buffer.\");\n    clear();\n    return;\n  }\n\n  ROS_DEBUG_NAMED(\"local_topo_hssh\", \"Purging stale observations from the buffer.\");\n\n  // Iterate through the observations and remove any that are older than the specified time\n  auto iter = begin();\n  while (iter != end()) {\n    if (time - iter->time > observation_keep_time_) {\n      iter = erase(iter);\n    } else {\n      ++iter;\n    }\n  }\n}", "CodeBleu_score": 29.2126525192117}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == 0.0) {\n    // keep most recent observation only\n    while (observations_.size() > 1) {\n      observations_.pop_front();\n    }\n    return;\n  }\n\n  // keep observations that are newer than the keep time\n  ros::Time keep_time = ros::Time::now() - ros::Duration(observation_keep_time_);\n  while (!observations_.empty() && observations_.front().header.stamp < keep_time) {\n    observations_.pop_front();\n  }\n}", "CodeBleu_score": 31.089042931308498}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// Calculate the start and end angles\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Calculate the angular difference\n  double diff = angles::shortest_angular_distance(start_angle, end_angle);\n\n  // Calculate the incremental change in angle\n  double delta = diff / (end_index - start_index);\n\n  // Update the orientation of each pose in the path\n  for (int i = start_index; i <= end_index; i++) {\n    double angle = start_angle + delta * (i - start_index);\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 68.50412899620018}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tif (start_index < 0 || end_index < 0 || start_index >= path.size() || end_index >= path.size() || start_index > end_index) {\n    return;\n  }\n\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n  double delta_angle = angles::shortest_angular_distance(start_angle, end_angle);\n  double angle_increment = delta_angle / (end_index - start_index);\n\n  for (int i = start_index; i <= end_index; i++) {\n    double angle = start_angle + (i - start_index) * angle_increment;\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 63.18534330311437}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// Extract the start and end angles\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end angles\n  double angle_distance = angles::shortest_angular_distance(start_angle, end_angle);\n\n  // Calculate the incremental change in angle for each pose\n  double angle_increment = angle_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    set_angle(&path[i], start_angle + (i - start_index) * angle_increment);\n  }\n}", "CodeBleu_score": 61.06406515082525}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t// Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(req.start, req.goal, path);\n\n  // Update the response with the success status and the generated path if a plan is found\n  resp.plan_found = success;\n  if (success) {\n    resp.path = path;\n  }\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 89.71048204868382}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tROS_INFO(\"makePlanService\");\n\n  // Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(req.start, req.goal, path);\n\n  // Update the response with the success status and the generated path if a plan is found\n  resp.plan_found = success;\n  if (success) {\n    resp.path = path;\n  }\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 80.94056045521239}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tROS_DEBUG_NAMED(\"make_plan\", \"Got a request to make a plan from (%f, %f, %f) to (%f, %f, %f)\",\n                  req.start.pose.position.x, req.start.pose.position.y, req.start.pose.position.z,\n                  req.goal.pose.position.x, req.goal.pose.position.y, req.goal.pose.position.z);\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(req.start, req.goal, path);\n  resp.plan_found = success;\n  resp.path = path;\n  return true;\n}", "CodeBleu_score": 67.9914973424584}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\",\n                                                 &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 63.33648456346438}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tros::NodeHandle pn(\"~\");\n    ros::NodeHandle n;\n\n    cmap_ = cmap;\n    cmap_ros_ = cmap;\n    cmap_->getCostmap()->getSizeInCells(width_, height_);\n    cmap_->getCostmap()->getResolution(resolution_);\n    cmap_->getCostmap()->getOriginX(origin_x_);\n    cmap_->getCostmap()->getOriginY(origin_y_);\n\n    map_frame_ = cmap_->getGlobalFrameID();\n    map_width_ = width_;\n    map_height_ = height_;\n    map_resolution_ = resolution_;\n    map_origin_x_ = origin_x_;\n    map_origin_y_ = origin_y_;\n    map_origin_z_ = 0.0;\n    map_width_m_ = map_width_ * map_resolution_;\n    map_height_m_ = map_height_ * map_resolution_;\n    map_origin_x_m_ = map_origin_x_ * map_resolution_;\n    map_origin_y_m_ = map_origin_y_ * map_resolution_;\n    map_origin_z_m_ = 0.0;\n\n    make_plan_srv_ = n.advertiseService(name + \"/make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = n.subscribe(name + \"/goal\", 1, &PlannerWithCostmap::goalCallback, this);\n    map_sub_ = n.subscribe(name + \"/map\", 1, &PlannerWithCostmap::mapCallback, this);\n    map_update_sub_ = n.subscribe(name + \"/map_update\", 1, &PlannerWithCostmap::mapUpdateCallback, this);\n    map_metadata_sub_ = n.subscribe(name + \"/map_metadata\", 1, &PlannerWithCostmap::mapMetadataCallback, this);\n\n    // initialize the costmap\n    costmap_ = cmap_->getCostmap();\n    costmap_->getSizeInCells(width_, height_);", "CodeBleu_score": 47.96618902336943}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tros::NodeHandle private_nh(\"~\");\n    make_plan_srv_ = private_nh.advertiseService(name + \"/make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe(name + \"/goal\", 1, &PlannerWithCostmap::goalCallback, this);\n    plan_pub_ = private_nh.advertise<nav_msgs::Path>(name + \"/plan\", 1);\n    //initialize the plan\n    plan_.header.frame_id = cmap->getGlobalFrameID();\n    plan_.header.stamp = ros::Time::now();\n}", "CodeBleu_score": 59.021347202721984}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t// check if the world coordinates are within the bounds of the costmap\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    return false;\n  }\n\n  // convert from world coordinates to map coordinates\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // check if the map coordinates are within the bounds of the costmap\n  if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 50.202101700406075}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t// check if the world coordinate is within bounds of the costmap\n  if (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    ROS_WARN(\"wx:%f, wy:%f, originX:%f, originY:%f, sizeX:%f, sizeY:%f\",\n             wx, wy, costmap_->getOriginX(), costmap_->getOriginY(),\n             costmap_->getSizeInMetersX(), costmap_->getSizeInMetersY());\n    ROS_ERROR(\"Computing map coordinates outside of costmap bounds, world coordinates: (%f, %f)\", wx, wy);\n    return false;\n  }\n\n  // convert from world to map coordinates\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // check if the map coordinates are within the costmap's size limits\n  if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n    return true;\n  }\n  ROS_ERROR(\"Computed map coordinates outside of costmap size limits, computed map coordinates: (%f, %f)\", mx, my);\n  return false;\n}", "CodeBleu_score": 46.05437883063493}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn (mx >= 0 && mx < costmap_->getSizeInCellsX() && my >= 0 && my < costmap_->getSizeInCellsY());\n}", "CodeBleu_score": 35.407932979717685}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t// create a message for the plan\n\tnav_msgs::Path plan;\n\tplan.poses.resize(path.size());\n\n\t// copy all points\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tplan.poses[i] = path[i];\n\t}\n\n\tplan.header.stamp = ros::Time::now();\n\tplan.header.frame_id = frame_id_;\n\n\tplan_pub_.publish(plan);\n}", "CodeBleu_score": 82.62170548324718}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  //create a message for the plan\n  nav_msgs::Path plan;\n  plan.poses.resize(path.size());\n  plan.header.stamp = ros::Time::now();\n  plan.header.frame_id = frame_id_;\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    plan.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(plan);\n}", "CodeBleu_score": 84.62026181201848}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.17316777026511}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG_NAMED(\"move_base\", \"Received new goal\");\n\n  move_base_msgs::MoveBaseActionGoal action_goal;\n\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 74.71772799425278}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG(\"In goalCB\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 68.07404810522004}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG(\"In goalCB\");\n  move_base_msgs::MoveBaseGoal action_goal;\n  action_goal.target_pose = *goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 54.89073361784712}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() >= sq_distance_limit_) {\n    ROS_INFO_STREAM(\"MoveSlowAndClear: Distance check passed. Removing speed limit.\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 54.865876307487525}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"Robot has moved far enough. Removing speed limit.\");\n    if (remove_limit_thread_ != nullptr) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 54.105385184924515}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tdouble sq_distance = getSqDistance();\n  double sq_limit_distance = speed_limit_pose_.pose.position.z * speed_limit_pose_.pose.position.z;\n\n  if (sq_distance > sq_limit_distance) {\n    ROS_INFO_STREAM(\"Robot has moved far enough, removing speed limit.\");\n    if (remove_limit_thread_ != nullptr) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = nullptr;\n    }\n    remove_limit_thread_ = new std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 58.018272654155986}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\tROS_INFO(\"NavfnWithCostmap::poseCallback\");\n  // Get the current robot pose\n  geometry_msgs::PoseStamped robot_pose;\n  if (!getRobotPose(robot_pose)) {\n    ROS_WARN(\"NavfnWithCostmap::poseCallback: failed to get robot pose\");\n    return;\n  }\n\n  // Generate a plan from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> path;\n  if (!makePlan(robot_pose, *goal, path)) {\n    ROS_WARN(\"NavfnWithCostmap::poseCallback: failed to generate plan\");\n    return;\n  }\n\n  // Publish the plan\n  publishPlan(path);\n}", "CodeBleu_score": 46.89286728815412}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// Retrieve the current global pose of the robot\n    tf::Stamped<tf::Pose> global_pose;\n    getRobotPose(global_pose);\n\n    // Generate a path from the current pose to the goal pose\n    makePlan(global_pose, *goal, path_);\n}", "CodeBleu_score": 48.59488889037522}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// TODO: Fill in this function\n\n    // Get the global pose of the robot\n    geometry_msgs::PoseStamped global_pose = getRobotPose();\n\n    // Make a path from the global pose to the goal\n    nav_msgs::Path path;\n    makePlan(global_pose, *goal, path);\n\n    // Publish the plan for visualization purposes\n    plan_pub.publish(path);\n}", "CodeBleu_score": 64.65148260557702}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create the service request\n\tparam_set_request_.request.param_id = param_set.param_id;\n\tparam_set_request_.request.value = param_set.value;\n\t// Call the service\n\tif (!param_set_client_.call(param_set_request_)) {\n\t\tROS_ERROR(\"Failed to call service param_set\");\n\t}\n}", "CodeBleu_score": 47.606070143920284}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create a ParamSet request\n\tparam_set_srv_.request.param_id = param_set.param_id;\n\tparam_set_srv_.request.param_value = param_set.param_value;\n\t// Call the param_set service\n\tif (param_set_client_.call(param_set_srv_)) {\n\t\tROS_INFO(\"ParamSet request sent\");\n\t} else {\n\t\tROS_ERROR(\"Failed to call service ParamSet\");\n\t}\n}", "CodeBleu_score": 46.27334586938008}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create a request message.\n\tparam_set_srv::Request req;\n\n\t// Assign the parameter ID and value from the provided GimbalParamSet structure to the service request.\n\treq.param_id = param_set.param_id;\n\treq.param_value = param_set.param_value;\n\n\t// Call the param_set_client_ to send the request.\n\tparam_set_client_.call(req, param_set_resp_);\n\n\t// Print the result of the service call.\n\tif (param_set_resp_.success) {\n\t\tROS_INFO(\"Successfully set gimbal parameter %d to %d.\", req.param_id, req.param_value);\n\t} else {\n\t\tROS_ERROR(\"Failed to set gimbal parameter %d to %d.\", req.param_id, req.param_value);\n\t}\n}", "CodeBleu_score": 43.1479636670722}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t// Create a socket\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        ROS_ERROR(\"ERROR opening socket\");\n        return;\n    }\n\n    // Bind the socket to the port\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    serv_addr.sin_port = htons(port);\n    if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n        ROS_ERROR(\"ERROR on binding\");\n        return;\n    }\n\n    // Listen on the socket\n    listen(sockfd, 5);\n    ROS_INFO(\"Waiting for a connection...\");\n\n    // Accept a connection\n    socklen_t clilen;\n    struct sockaddr_in cli_addr;\n    int newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n    if (newsockfd < 0) {\n        ROS_ERROR(\"ERROR on accept\");\n        return;\n    }\n\n    // Receive data\n    char buffer[1024];\n    int n;\n    while (true) {\n        n = recv(newsockfd, buffer, 1024, 0);\n        if (n < 0) {\n            ROS_ERROR(\"ERROR reading from socket\");\n            return;\n        }\n        if (n == 0) {\n            ROS_ERROR(\"ERROR: Received message length is 0\");\n            return;\n        }\n        buffer[n] = '\\0';\n        ROS_INFO(\"Message received: %s\", buffer);\n\n        // Process the message\n        processMessage(buffer);\n    }\n\n    // Close the socket\n    close(newsockfd);\n    close(sockfd);\n}", "CodeBleu_score": 47.63501686860222}, {"code": "void CommunicationBridge::serverFun(){\n\tint newsockfd, clilen;\n    char buffer[256];\n    struct sockaddr_in serv_addr, cli_addr;\n    int n;\n    int socketfd;\n\n    socketfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (socketfd < 0) {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    bzero((char *) &serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    serv_addr.sin_port = htons(port);\n    if (bind(socketfd, (struct sockaddr *) &serv_addr,\n             sizeof(serv_addr)) < 0) {\n        perror(\"ERROR on binding\");\n        exit(1);\n    }\n    listen(socketfd, 5);\n    clilen = sizeof(cli_addr);\n\n    while (1) {\n        newsockfd = accept(socketfd,\n                           (struct sockaddr *) &cli_addr, &clilen);\n        if (newsockfd < 0) {\n            perror(\"ERROR on accept\");\n            exit(1);\n        }\n\n        bzero(buffer, 256);\n        n = read(newsockfd, buffer, 255);\n        if (n < 0) {\n            perror(\"ERROR reading from socket\");\n            exit(1);\n        }\n        if (n == 0) {\n            ROS_ERROR(\"Received message length is zero or less\");\n            exit(1);\n        }\n\n        std::string receivedMessage(buffer);\n        ROS_INFO(\"Received: %s\", receivedMessage.c_str());\n        std::string decodedMessage = decodeMessage(receivedMessage);\n        ROS_INFO(\"Decoded: %s\", decodedMessage.c_str());\n        publishMessage(decodedMessage);\n        close(newsockfd);\n    }\n}", "CodeBleu_score": 50.18455372161408}, {"code": "void CommunicationBridge::serverFun(){\n\tint sockfd, newsockfd, portno;\n    socklen_t clilen;\n    char buffer[256];\n    struct sockaddr_in serv_addr, cli_addr;\n    int n;\n    if (sockfd < 0) {\n        error(\"ERROR opening socket\");\n    }\n\n    bzero((char *) &serv_addr, sizeof(serv_addr));\n    portno = 5001;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    serv_addr.sin_port = htons(portno);\n    if (bind(sockfd, (struct sockaddr *) &serv_addr,\n             sizeof(serv_addr)) < 0) {\n        error(\"ERROR on binding\");\n    }\n    listen(sockfd, 5);\n    clilen = sizeof(cli_addr);\n\n    while (1) {\n        newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n        if (newsockfd < 0) {\n            error(\"ERROR on accept\");\n        }\n\n        bzero(buffer, 256);\n        n = read(newsockfd, buffer, 255);\n        if (n < 0) {\n            error(\"ERROR reading from socket\");\n        }\n\n        if (n == 0) {\n            ROS_ERROR(\"Received zero-length message from ground station. Closing socket.\");\n            close(newsockfd);\n        } else {\n            ROS_INFO(\"Received message from ground station. Decoding...\");\n            string msg = buffer;\n            decode(msg);\n            close(newsockfd);\n        }\n    }\n    close(sockfd);\n}", "CodeBleu_score": 50.45446179514026}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t// ROS_INFO(\"[%s]: Received command for UAV %d\", ros::this_node::getName().c_str(), uav_cmd.uav_id);\n  if (simulation_mode_) {\n    for (int i = 0; i < swarm_control_simulation_.uavs.size(); i++) {\n      if (swarm_control_simulation_.uavs[i].uav_id == uav_cmd.uav_id) {\n        swarm_control_simulation_.uavs[i].uav_basic_.publish(uav_cmd);\n        return;\n      }\n    }\n  } else {\n    uav_basic_.publish(uav_cmd);\n  }\n}", "CodeBleu_score": 40.62281401355312}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t// If the command is to change the mode, then change the mode.\n    if (uav_cmd.command == UAVCommand::SWARM_COMMAND_MODE) {\n        if (uav_cmd.mode == UAVCommand::SWARM_MODE_SIMULATION) {\n            swarm_mode_ = UAVCommand::SWARM_MODE_SIMULATION;\n            ROS_INFO(\"SWARM_MODE_SIMULATION\");\n        } else if (uav_cmd.mode == UAVCommand::SWARM_MODE_REAL) {\n            swarm_mode_ = UAVCommand::SWARM_MODE_REAL;\n            ROS_INFO(\"SWARM_MODE_REAL\");\n        } else {\n            ROS_ERROR(\"Unknown mode: %d\", uav_cmd.mode);\n        }\n    }\n    // If the command is to change the formation, then change the formation.\n    else if (uav_cmd.command == UAVCommand::SWARM_COMMAND_FORMATION) {\n        if (uav_cmd.formation == UAVCommand::SWARM_FORMATION_SQUARE) {\n            swarm_formation_ = UAVCommand::SWARM_FORMATION_SQUARE;\n            ROS_INFO(\"SWARM_FORMATION_SQUARE\");\n        } else if (uav_cmd.formation == UAVCommand::SWARM_FORMATION_CIRCLE) {\n            swarm_formation_ = UAVCommand::SWARM_FORMATION_CIRCLE;\n            ROS_INFO(\"SWARM_FORMATION_CIRCLE\");\n        } else if (uav_cmd.formation == UAVCommand::SWARM_FORMATION_TRIANGLE) {\n            swarm_formation_ = UAVCommand::SWARM_FORMATION_TRIANGLE;\n            ROS_INFO(\"SWARM_FORMATION_TRIANGLE\");\n        } else {\n            ROS_ERROR(\"Unknown formation: %d\", uav_cmd.formation);\n        }\n    }\n    // If the command is to change the formation, then change", "CodeBleu_score": 35.945106183790635}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t// If in simulation mode, find the corresponding UAV by ID and publish the command\n    if (simulation_mode_) {\n        for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n            if (swarm_control_simulation_[i].id_ == uav_cmd.id_) {\n                swarm_control_simulation_[i].uav_basic_.publish(uav_cmd);\n                break;\n            }\n        }\n    }\n    // If not in simulation mode, publish the command to a single UAV\n    else {\n        uav_basic_.publish(uav_cmd);\n    }\n}", "CodeBleu_score": 42.34759038665216}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == 1) {\n        createMode(mode_selection.mode);\n    }\n    else if (mode_selection.use_mode == 2) {\n        deleteMode(mode_selection.mode);\n    }\n    else if (mode_selection.use_mode == 3) {\n        // Reboot the Switch\n        system(\"reboot\");\n    }\n    else if (mode_selection.use_mode == 4) {\n        // Exit the application\n        exit(0);\n    }\n    else {\n        // Do nothing\n    }\n}", "CodeBleu_score": 46.665242366250226}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode) {\n    if (mode_selection.mode == Mode::REBOOTNX) {\n      system(\"sudo reboot\");\n    } else if (mode_selection.mode == Mode::EXITNX) {\n      system(\"sudo shutdown\");\n    } else {\n      createMode(mode_selection.mode);\n    }\n  } else {\n    deleteMode(mode_selection.mode);\n  }\n}", "CodeBleu_score": 47.71142132239918}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == 1) {\n\t\tcreateMode(mode_selection);\n\t}\n\telse if (mode_selection.use_mode == 2) {\n\t\tdeleteMode(mode_selection);\n\t}\n\telse if (mode_selection.use_mode == 3) {\n\t\texecuteCommand(mode_selection);\n\t}\n\telse if (mode_selection.use_mode == 4) {\n\t\texecuteCommand(mode_selection);\n\t}\n\n}", "CodeBleu_score": 58.71594125852665}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\tif (heartbeat_counter == 0) {\n    // If the heartbeat counter is 0, then we have missed the heartbeat.\n    heartbeat_counter++;\n    if (heartbeat_counter == 1) {\n      ROS_WARN(\"Missed heartbeat from %s. Checking again...\", vehicle_type_.c_str());\n    } else if (heartbeat_counter == 2) {\n      ROS_WARN(\"Missed heartbeat from %s. Checking again...\", vehicle_type_.c_str());\n    } else if (heartbeat_counter == 3) {\n      ROS_WARN(\"Missed heartbeat from %s. Checking again...\", vehicle_type_.c_str());\n    } else if (heartbeat_counter == 4) {\n      ROS_WARN(\"Missed heartbeat from %s. Checking again...\", vehicle_type_.c_str());\n    } else if (heartbeat_counter == 5) {\n      ROS_WARN(\"Missed heartbeat from %s. Checking again...\", vehicle_type_.c_str());\n    } else if (heartbeat_counter == 6) {\n      ROS_WARN(\"Missed heartbeat from %s. Checking again...\", vehicle_type_.c_str());\n    } else if (heartbeat_counter == 7) {\n      ROS_WARN(\"Missed heartbeat from %s. Checking again...\", vehicle_type_.c_str());\n    } else if (heartbeat_counter == 8) {\n      ROS_WARN(\"Missed heartbeat from %s. Checking again...\", vehicle_type_.c_str());\n    } else if (heartbeat_counter == 9) {\n      ROS_WARN(\"Missed heartbeat from %s. Checking again...\", vehicle_type_.c_str());\n    } else if (heartbeat_counter == 10) {\n      ROS_WARN(\"Missed heartbeat from %s. Checking again...\", vehicle_type_.c_str());\n    } else if (heartbeat_", "CodeBleu_score": 36.086456045629944}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// Check for missed heartbeats\n    if (heartbeat_counter == heartbeat_counter_limit) {\n        // Print error message\n        ROS_ERROR(\"[%s]: Lost connectivity with vehicle\", __FUNCTION__);\n\n        // Set disconnect flag\n        disconnect_flag = true;\n\n        // Reset counter\n        heartbeat_counter = 0;\n    } else {\n        // Increment counter\n        heartbeat_counter++;\n    }\n}", "CodeBleu_score": 15.944553198610418}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\tif (heartbeat_counter_ > 0) {\n    heartbeat_counter_--;\n  }\n  else {\n    if (vehicle_type_ == \"UGV\") {\n      ROS_ERROR(\"[%s]: UGV heartbeat lost\", node_name_.c_str());\n      disconnect_flag_ = true;\n    }\n    else if (vehicle_type_ == \"UAV\") {\n      ROS_ERROR(\"[%s]: UAV heartbeat lost\", node_name_.c_str());\n      disconnect_flag_ = true;\n    }\n    else if (vehicle_type_ == \"swarm\") {\n      ROS_ERROR(\"[%s]: swarm heartbeat lost\", node_name_.c_str());\n      disconnect_flag_ = true;\n    }\n  }\n}", "CodeBleu_score": 30.798788623714557}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\tint drone_id = msg->drone_id;\n    int traj_num = msg->traj_num;\n    int traj_id = 0;\n    int traj_len = 0;\n    int knot_num = 0;\n    int knot_dim = 0;\n    int knot_dof = 0;\n    int knot_index = 0;\n    int point_num = 0;\n    int point_dim = 0;\n    int point_dof = 0;\n    int point_index = 0;\n    int yaw_num = 0;\n    int yaw_dim = 0;\n    int yaw_dof = 0;\n    int yaw_index = 0;\n\n    for (int i = 0; i < traj_num; i++) {\n        traj_id = msg->traj_id[i];\n        traj_len = msg->traj_len[i];\n        knot_num = msg->knot_num[i];\n        knot_dim = msg->knot_dim[i];\n        knot_dof = msg->knot_dof[i];\n        knot_index = msg->knot_index[i];\n        point_num = msg->point_num[i];\n        point_dim = msg->point_dim[i];\n        point_dof = msg->point_dof[i];\n        point_index = msg->point_index[i];\n        yaw_num = msg->yaw_num[i];\n        yaw_dim = msg->yaw_dim[i];\n        yaw_dof = msg->yaw_dof[i];\n        yaw_index = msg->yaw_index[i];\n\n        Bspline bspline;\n        bspline.drone_id = drone_id;\n        bspline.traj_id = traj_id;\n        bspline.traj_len = traj_len;\n        bspline.knot_num = knot_num;\n        bspline.knot_dim = knot", "CodeBleu_score": 41.52944993183113}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\tint drone_id = msg->drone_id;\n    int num_traj = msg->num_traj;\n    int num_knots = msg->num_knots;\n    int num_points = msg->num_points;\n    int num_yaw_points = msg->num_yaw_points;\n\n    // \u5faa\u73af\u5904\u7406\u6bcf\u4e00\u4e2a\u8f68\u8ff9\n    for (int i = 0; i < num_traj; i++) {\n        // \u521d\u59cb\u5316Bspline\u7ed3\u6784\u4f53\n        Bspline bspline;\n        // \u8bbe\u7f6e\u7ed3\u6784\u4f53\u5c5e\u6027\n        bspline.set_d_order(msg->d_order);\n        bspline.set_dim(msg->dim);\n        bspline.set_n_ctrl_pts(msg->n_ctrl_pts);\n        bspline.set_knot_smoothness(msg->knot_smoothness);\n        bspline.set_continuity_order(msg->continuity_order);\n        bspline.set_max_point_deviation(msg->max_point_deviation);\n        bspline.set_max_yaw_deviation(msg->max_yaw_deviation);\n        bspline.set_max_yaw_rate(msg->max_yaw_rate);\n        bspline.set_max_vel(msg->max_vel);\n        bspline.set_max_acc(msg->max_acc);\n        bspline.set_max_jerk(msg->max_jerk);\n        bspline.set_max_snap(msg->max_snap);\n        bspline.set_max_t(msg->max_t);\n        bspline.set_max_u(msg->max_u);\n        bspline.set_max_v(msg->max_v);\n        bspline.set_max_w(msg->max_w);\n        bspline.set_max_x_acc(msg->max_x_acc);\n        bspline.set_max_y_acc(msg->max", "CodeBleu_score": 32.34103563062345}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\tint drone_id = msg->drone_id;\n    int num_traj = msg->num_traj;\n\n    // \u6bcf\u4e2a\u98de\u673a\u7684\u8f68\u8ff9\n    for(int i=0; i<num_traj; i++)\n    {\n        prometheus_msgs::Bspline bspline;\n\n        bspline.order = msg->traj[i].order;\n        bspline.start_time = msg->traj[i].start_time;\n        bspline.duration = msg->traj[i].duration;\n\n        bspline.knots = msg->traj[i].knots;\n        bspline.points = msg->traj[i].points;\n        bspline.yaw = msg->traj[i].yaw;\n\n        // \u53d1\u5e03\u8f68\u8ff9\n        traj_pub.publish(bspline);\n\n        // \u53d1\u5e03\u8f68\u8ff9\u70b9\n        trajectory_pub.publish(bspline);\n\n        // \u53d1\u5e03\u8f68\u8ff9\u70b9\uff08\u5e26yaw\uff09\n        trajectory_pub_yaw.publish(bspline);\n\n        // \u53d1\u5e03\u8f68\u8ff9\u70b9\uff08\u5e26yaw\uff09\n        trajectory_pub_yaw_raw.publish(bspline);\n\n        // \u53d1\u5e03\u8f68\u8ff9\u70b9\uff08\u5e26yaw\uff09\n        trajectory_pub_yaw_raw_viz.publish(bspline);\n\n        // \u53d1\u5e03\u8f68\u8ff9\u70b9\uff08\u5e26yaw\uff09\n        trajectory_pub_yaw_raw_viz_rviz.publish(bspline);\n\n        // \u53d1\u5e03\u8f68\u8ff9\u70b9\uff08\u5e26yaw\uff09\n        trajectory_pub_yaw_raw_viz_rviz_rviz.publish(bspline);\n\n        // \u53d1\u5e03\u8f68\u8ff9\u70b9\uff08\u5e26yaw\uff09\n        trajectory_pub_yaw_raw_viz_rviz_rviz_rviz.publish(bspl", "CodeBleu_score": 42.396726276564515}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.05);\n\toctree.setInputCloud(cloud);\n\toctree.addPointsFromInputCloud();\n\tsensor_msgs::PointCloud2 compressed;\n\toctree.getCompressedPointCloud(compressed);\n\treturn compressed;\n}", "CodeBleu_score": 28.279458086318325}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\n\t// Compress the point cloud\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> *compressor = new pcl::octree::OctreePointCloudCompression<pcl::PointXYZ>(0.01);\n\tcompressor->setInputCloud(cloud);\n\tcompressor->addPointsFromInputCloud();\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr compressedCloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tcompressor->getCompressedCloud(compressedCloud);\n\n\t// Store the compressed data\n\tcompressed_data.resize(compressor->getSerializedTreeByteSize());\n\tcompressor->serializeTree(compressed_data.data());\n\n\t// Convert the compressed point cloud to a PointCloud2 message and return it\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tpcl::toROSMsg(*compressedCloud, compressed_msg);\n\n\t// Release dynamically allocated memory\n\tdelete compressor;\n\tdelete cloud;\n\tdelete compressedCloud;\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 40.99392562165403}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the PointCloud2 message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZRGB>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> *compressor = new pcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB>(0.001);\n    compressor->setInputCloud(cloud);\n    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_out(new pcl::PointCloud<pcl::PointXYZRGB>);\n    compressor->encodePointCloud(cloud_out);\n\n    // Store the compressed data\n    compressed_data = compressor->getSerializedTreeData();\n\n    // Convert the compressed point cloud back to a PointCloud2 message\n    sensor_msgs::PointCloud2 msg_out;\n    pcl::toROSMsg(*cloud_out, msg_out);\n\n    // Release dynamically allocated memory\n    delete compressor;\n    delete cloud;\n\n    return msg_out;\n}", "CodeBleu_score": 34.93189699941294}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n    if (multi_uav_state_[i].id == uav_state.id) {\n      multi_uav_state_[i] = uav_state;\n    }\n  }\n}", "CodeBleu_score": 53.85637364991577}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].id == uav_state.id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 52.117211632281425}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 57.86750434643246}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize the MultiUGVState message\n  mavros_msgs::MultiUGVState multi_ugv_state_msg;\n  // Iterate through each UGV\n  for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n    // Initialize the UGVState message\n    mavros_msgs::UGVState ugv_state_msg;\n    // Populate the UGVState message\n    ugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n    ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n    ugv_state_msg.position = m_multi_ugv_state.ugv_state[i].position;\n    ugv_state_msg.velocity = m_multi_ugv_state.ugv_state[i].velocity;\n    ugv_state_msg.attitude = m_multi_ugv_state.ugv_state[i].attitude;\n    // Add the UGVState message to the MultiUGVState message\n    multi_ugv_state_msg.ugv_state.push_back(ugv_state_msg);\n  }\n  // Set the UGV count\n  multi_ugv_state_msg.ugv_count = m_multi_ugv_state.ugv_count;\n  // Publish the MultiUGVState message\n  m_ugv_state_pub.publish(multi_ugv_state_msg);\n}", "CodeBleu_score": 38.24018941798171}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize the MultiUGVState message\n\tswarmus_ros_simulation_msgs::MultiUGVState multi_ugv_state_msg;\n\t\n\t// Iterate through each UGV state in the provided MultiUGVState structure\n\tfor(int i=0; i<m_multi_ugv_state.ugv_count; i++) {\n\t\t\n\t\t// Initialize the UGVState message\n\t\tswarmus_ros_simulation_msgs::UGVState ugv_state_msg;\n\t\t\n\t\t// Populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n\t\tugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n\t\tugv_state_msg.attitude.z =", "CodeBleu_score": 33.68482935372334}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Create a MultiUGVState message\n  multi_ugv_state_msg.ugv_count = 0;\n  multi_ugv_state_msg.ugv_state_list.clear();\n  // Iterate through each UGV state in the provided MultiUGVState structure\n  for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n    // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n    ugv_state_msg.ugv_id = m_multi_ugv_state.ugv_state_list[i].ugv_id;\n    ugv_state_msg.battery_percentage = m_multi_ugv_state.ugv_state_list[i].battery_percentage;\n    ugv_state_msg.position.x = m_multi_ugv_state.ugv_state_list[i].position.x;\n    ugv_state_msg.position.y = m_multi_ugv_state.ugv_state_list[i].position.y;\n    ugv_state_msg.position.z = m_multi_ugv_state.ugv_state_list[i].position.z;\n    ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state_list[i].velocity.x;\n    ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state_list[i].velocity.y;\n    ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state_list[i].velocity.z;\n    ugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state_list[i].attitude.x;\n    ugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state_list[i].attitude.y;\n    ugv_state_msg.attitude.z = m_", "CodeBleu_score": 43.40093915751221}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0;\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    for (int i = 0; i < q.rows(); ++i) {\n        for (int j = 0; j < q.cols(); ++j) {\n            double x = q(i, j);\n            double y = q(i + 1, j);\n            double z = q(i + 2, j);\n\n            // calculate the distance between the current control point and moving objects\n            for (int k = 0; k < moving_objects_.size(); ++k) {\n                double dist = moving_objects_[k]->distance(x, y, z);\n\n                // if the distance is less than the clearance, update the cost and gradient\n                if (dist < moving_objects_[k]->clearance) {\n                    double dist_cost = moving_objects_[k]->cost(dist);\n                    cost += dist_cost;\n\n                    Eigen::Vector3d dist_grad = moving_objects_[k]->gradient(dist);\n                    gradient(i, j) += dist_grad(0);\n                    gradient(i + 1, j) += dist_grad(1);\n                    gradient(i + 2, j) += dist_grad(2);\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 41.462748721420176}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    int seg_num = q.cols() / 3 - 1;\n    int control_num = q.cols();\n    double seg_length = 1.0 / seg_num;\n\n    Eigen::MatrixXd P = q;\n    Eigen::MatrixXd Pdot = Eigen::MatrixXd::Zero(P.rows(), P.cols());\n    Eigen::MatrixXd Pddot = Eigen::MatrixXd::Zero(P.rows(), P.cols());\n    Eigen::MatrixXd Pdddot = Eigen::MatrixXd::Zero(P.rows(), P.cols());\n\n    // get the derivative of the trajectory\n    for (int i = 0; i < seg_num; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            Pdot.block(0, 3 * i + j, P.rows(), 1) = (P.block(0, 3 * i + 3 + j, P.rows(), 1) - P.block(0, 3 * i + j, P.rows(), 1)) / seg_length;\n            Pddot.block(0, 3 * i + j, P.rows(), 1) = (Pdot.block(0, 3 * i + 3 + j, P.rows(), 1) - Pdot.block(0, 3 * i + j, P.rows(), 1)) / seg_length;\n            Pdddot.block(0, 3 * i + j, P.rows(), 1) = (Pddot.block(0, 3 * i + 3 + j, P.rows(), 1) - Pddot.block(0, 3 * i + j, P.rows(), 1)) / seg_length;\n        }\n    }\n\n    // get the predicted position of the moving object\n    for (int i = 0; i < moving_objs_.size(); ++i) {\n        Eigen::MatrixXd moving_obj = moving_objs", "CodeBleu_score": 36.40512326005619}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// initialize\n  cost = 0.0;\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n  // get the current time\n  double time = ros::Time::now().toSec();\n\n  // get the current position of the moving objects\n  vector<Eigen::Vector3d> obj_pos;\n  for (int i = 0; i < moving_objects_.size(); ++i) {\n    obj_pos.push_back(moving_objects_[i]->getPosition(time));\n  }\n\n  // iterate through control points\n  for (int i = 0; i < q.cols(); ++i) {\n    // get the current control point\n    Eigen::Vector3d cp = q.block<3, 1>(0, i);\n\n    // iterate through moving objects\n    for (int j = 0; j < obj_pos.size(); ++j) {\n      // get the position of the moving object\n      Eigen::Vector3d obj_p = obj_pos[j];\n\n      // compute the distance between the control point and the object\n      double dist = (cp - obj_p).norm();\n\n      // if the distance is less than the clearance\n      if (dist < clearance_) {\n        // update cost\n        cost += pow(dist - clearance_, 2);\n\n        // update gradient\n        Eigen::Vector3d grad = 2.0 * (cp - obj_p) / dist;\n        gradient.block<3, 1>(0, i) += grad;\n        gradient.block<3, 1>(0, i) += grad;\n      }\n    }\n  }\n}", "CodeBleu_score": 46.125835013483105}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// Initialize cost and gradient\n    cost = 0;\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    // Iterate through the control points of the trajectory\n    for (int i = 0; i < q.cols(); i++) {\n        // Compute the positional error relative to reference points\n        Eigen::Vector3d error;\n        error = q.col(i) - ref_points_.col(i);\n\n        // Compute the velocity vector\n        Eigen::Vector3d vel;\n        vel = (q.col(i) - q.col(i - 1)) / delta_t_;\n\n        // Compute the cost\n        cost += a2_ * error.dot(error) + b2_ * vel.dot(vel);\n\n        // Compute the gradient\n        gradient.col(i) = 2 * (a2_ * error + b2_ * vel);\n    }\n}", "CodeBleu_score": 26.578012655716954}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0;\n  gradient.setZero(q.rows(), q.cols());\n\n  for (int i = 0; i < q.cols(); i++) {\n\n    Eigen::Vector3d p_i = q.block<3, 1>(0, i);\n    Eigen::Vector3d v_i = q.block<3, 1>(3, i);\n\n    Eigen::Vector3d p_r;\n    Eigen::Vector3d v_r;\n\n    if (i == 0) {\n      p_r = p_i;\n      v_r = v_i;\n    }\n    else {\n      p_r = ref_points_.block<3, 1>(0, i);\n      v_r = ref_points_.block<3, 1>(3, i);\n    }\n\n    Eigen::Vector3d p_e = p_i - p_r;\n    Eigen::Vector3d v_e = v_i - v_r;\n\n    double p_e_dot = p_e.dot(p_e);\n    double v_e_dot = v_e.dot(v_e);\n    double p_e_cross = p_e.cross(p_e).norm();\n    double v_e_cross = v_e.cross(v_e).norm();\n\n    double p_cost = a2_ * p_e_dot + b2_ * p_e_cross;\n    double v_cost = a2_ * v_e_dot + b2_ * v_e_cross;\n\n    cost += p_cost + v_cost;\n\n    Eigen::Vector3d p_e_grad = 2 * a2_ * p_e;\n    Eigen::Vector3d v_e_grad = 2 * a2_ * v_e;\n\n    Eigen::Vector3d p_e_cross_grad = 2 * b2_ * p_e_cross * p_e.normalized();\n    Eigen::Vector3d v_e_cross_grad = 2 * b2_ * v_e_cross * v_e.", "CodeBleu_score": 40.31956016850581}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// Initialize cost to zero\n  cost = 0.0;\n\n  // Initialize gradient to zero\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n  // Iterate through each control point\n  for (int i = 0; i < q.cols(); i++) {\n\n    // Compute the positional error vector\n    Eigen::Vector3d error = q.col(i) - ref_pts_.col(i);\n\n    // Compute the velocity vector\n    Eigen::Vector3d vel = (q.col(i + 1) - q.col(i - 1)) / (2.0 * dt_);\n\n    // Compute the cost\n    cost += (a2_ * error.transpose() * error + b2_ * vel.transpose() * vel)(0, 0);\n\n    // Compute the gradient\n    gradient.col(i) = (2.0 * a2_ * error.transpose() + 2.0 * b2_ * vel.transpose()) * vel;\n  }\n}", "CodeBleu_score": 27.054642190209933}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tEigen::MatrixXd ctp = getDerivativeControlPoints();\n  UniformBspline derivative(ctp, p_ - 1, interval_);\n\n  /* cut the first and last knot */\n  Eigen::VectorXd knot(u_.rows() - 2);\n  knot = u_.segment(1, u_.rows() - 2);\n  derivative.setKnot(knot);\n\n  /* calculate the jerk */\n  ctp = derivative.getDerivativeControlPoints();\n  UniformBspline jerk(ctp, p_ - 1, interval_);\n\n  /* cut the first and last knot */\n  knot = u_.segment(1, u_.rows() - 2);\n  jerk.setKnot(knot);\n\n  double jerk_value = 0.0;\n  for (int i = 0; i < ctp.cols(); i++) {\n    for (int j = 0; j < ctp.rows(); j++) {\n      jerk_value += pow(ctp(j, i), 2) * (knot(j + 1) - knot(j));\n    }\n  }\n\n  return jerk_value;\n}", "CodeBleu_score": 54.92391625535782}, {"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk = getDerivative().getDerivative().getDerivative();\n  Eigen::VectorXd knot = jerk.getKnot();\n  Eigen::MatrixXd ctp = jerk.getControlPoint();\n\n  double jerk_value = 0;\n  for (int i = 0; i < ctp.rows(); i++) {\n    for (int j = 0; j < ctp.cols(); j++) {\n      jerk_value += pow(ctp(i, j), 2) * (knot(i + 1) - knot(i));\n    }\n  }\n  return jerk_value;\n}", "CodeBleu_score": 62.42795679166684}, {"code": "double UniformBspline::getJerk(){\n\t/* calculate the third derivative of the spline */\n  Eigen::MatrixXd ctp = getDerivative().getDerivative().getDerivative().getControlPoints();\n\n  /* retrieve the knot times and control points of the jerk trajectory */\n  Eigen::VectorXd knot = getDerivative().getDerivative().getDerivative().getKnot();\n  Eigen::MatrixXd ctrlPt = getDerivative().getDerivative().getDerivative().getControlPoints();\n\n  /* iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times */\n  double jerk = 0;\n  for (int i = 0; i < ctrlPt.rows(); i++) {\n    for (int j = 0; j < ctrlPt.cols(); j++) {\n      jerk += pow(ctrlPt(i, j), 2) * (knot(i + 1) - knot(i));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 55.63646757160804}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n    return pos;\n}", "CodeBleu_score": 48.85975746010875}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n    return pos;\n}", "CodeBleu_score": 48.85975746010875}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n    return pos;\n}", "CodeBleu_score": 48.85975746010875}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n\t\trcvDroneOdomCallbackBase(odom, odom.child_frame_id.substr(0, odom.child_frame_id.find(\"/\")));\n\t} catch (std::exception& e) {\n\t\tROS_ERROR(\"Exception: %s\", e.what());\n\t}\n}", "CodeBleu_score": 37.234814254026226}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n        rcvDroneOdomCallbackBase(odom, odom.child_frame_id.substr(0, odom.child_frame_id.find('/')));\n    } catch (std::exception& e) {\n        ROS_ERROR_STREAM(e.what());\n    }\n}", "CodeBleu_score": 39.3388301863247}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n        // Extract drone ID from odometry message\n        std::string drone_id = odom.child_frame_id.substr(1);\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (std::exception& e) {\n        ROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: Error extracting drone ID from odometry message: %s\", e.what());\n    }\n}", "CodeBleu_score": 51.467099633355375}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Get the drone's ID\n    int drone_id = drone_id;\n\n    // Get the drone's true position in the world frame\n    Eigen::Vector3d true_position = true_positions[drone_id];\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position_camera = camera_frame.get_camera_coordinates(true_position);\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position_camera = camera_frame.get_camera_coordinates(true_position);\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position_camera = camera_frame.get_camera_coordinates(true_position);\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position_camera = camera_frame.get_camera_coordinates(true_position);\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position_camera = camera_frame.get_camera_coordinates(true_position);\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position_camera = camera_frame.get_camera_coordinates(true_position);\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position_camera = camera_frame.get_camera_coordinates(true_position);\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position_camera = camera_frame.get_camera_coordinates(true_position);\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position_camera = camera_frame.get_camera_coordinates(true_position);\n\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position_camera = camera_frame.get_camera_coordinates(true_position);", "CodeBleu_score": 27.02129660489203}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// TODO: Fill in this function\n\n  // Compute the true pose of the drone in the camera frame\n  Eigen::Vector3d true_drone_pose_camera;\n  true_drone_pose_camera << true_pixel(0), true_pixel(1), 0;\n\n  // Check for the presence of the drone\n  bool is_drone_present = false;\n\n  // Compute the pose error between the camera and world coordinates\n  Eigen::Vector3d pose_error;\n\n  // Update the debug result\n  // If the drone is present, set the drone ID and the drone pose in the camera frame\n  // If the drone is not present, set the drone ID to -1\n\n  // Publish the pose error\n\n}", "CodeBleu_score": 11.455162756500895}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Find the drone's pose in the camera frame\n  Eigen::Matrix4d T_C_D = find_drone_pose(drone_id, true_pixel);\n\n  // If the drone was found, compute the pose error and publish it\n  if (T_C_D(0, 3) != 0) {\n    // Find the drone's pose in the world frame\n    Eigen::Matrix4d T_W_D = T_W_C * T_C_D;\n\n    // Compute the pose error\n    Eigen::Vector3d pose_error = compute_pose_error(T_W_D);\n\n    // Update the debug result\n    update_debug_result(drone_id, true_pixel, pose_error, true);\n\n    // Publish the pose error\n    publish_pose_error(drone_id, pose_error);\n  }\n\n  // Otherwise, update the debug result to indicate failure\n  else {\n    update_debug_result(drone_id, true_pixel, Eigen::Vector3d::Zero(), false);\n  }\n}", "CodeBleu_score": 28.197224867743397}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n}", "CodeBleu_score": 90.74899131089721}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 93.490496894465}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 98.26143553100475}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// First, convert the start and end points to grid indices.\n  if (!ConvertToIndex(start_pt, start_idx) || !ConvertToIndex(end_pt, end_idx)) {\n    ROS_ERROR(\"Failed to convert start or end point to grid index.\");\n    return false;\n  }\n\n  // If the start point is in an obstacle, move it away from the end point until it is not.\n  if (IsInsideObstacle(start_idx)) {\n    ROS_WARN(\"Start point is inside obstacle. Attempting to move it away from the end point.\");\n    if (!AdjustStartPoint(start_pt, end_pt, start_idx)) {\n      ROS_ERROR(\"Failed to adjust start point away from end point.\");\n      return false;\n    }\n  }\n\n  // If the end point is in an obstacle, move it away from the start point until it is not.\n  if (IsInsideObstacle(end_idx)) {\n    ROS_WARN(\"End point is inside obstacle. Attempting to move it away from the start point.\");\n    if (!AdjustEndPoint(start_pt, end_pt, end_idx)) {\n      ROS_ERROR(\"Failed to adjust end point away from start point.\");\n      return false;\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 41.62860062623376}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tstart_idx = ConvertToIndex(start_pt);\n\tend_idx = ConvertToIndex(end_pt);\n\tif (start_idx.x < 0 || start_idx.x >= map_size_3d_.x || start_idx.y < 0 || start_idx.y >= map_size_3d_.y || start_idx.z < 0 || start_idx.z >= map_size_3d_.z) {\n\t\tcout << \"start point is outside the map\" << endl;\n\t\treturn false;\n\t}\n\tif (end_idx.x < 0 || end_idx.x >= map_size_3d_.x || end_idx.y < 0 || end_idx.y >= map_size_3d_.y || end_idx.z < 0 || end_idx.z >= map_size_3d_.z) {\n\t\tcout << \"end point is outside the map\" << endl;\n\t\treturn false;\n\t}\n\tif (map_[start_idx.x][start_idx.y][start_idx.z] == 1) {\n\t\tcout << \"start point is inside an obstacle\" << endl;\n\t\tif (!AdjustStartPoint(start_pt, end_pt, start_idx)) {\n\t\t\tcout << \"failed to adjust start point\" << endl;\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (map_[end_idx.x][end_idx.y][end_idx.z] == 1) {\n\t\tcout << \"end point is inside an obstacle\" << endl;\n\t\tif (!AdjustEndPoint(start_pt, end_pt, end_idx)) {\n\t\t\tcout << \"failed to adjust end point\" << endl;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 36.00845150050005}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// convert the start and end points to grid indices\n  if (!ConvertToIndex(start_pt, start_idx)) {\n    return false;\n  }\n  if (!ConvertToIndex(end_pt, end_idx)) {\n    return false;\n  }\n\n  // if the start or end point is inside an obstacle, adjust it\n  if (IsInsideObstacle(start_idx)) {\n    if (!AdjustStartPoint(start_idx, end_idx)) {\n      return false;\n    }\n  }\n  if (IsInsideObstacle(end_idx)) {\n    if (!AdjustEndPoint(start_idx, end_idx)) {\n      return false;\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 32.71140934805074}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t// 1. get the index of the min and max pos\n  Eigen::Vector3i min_id;\n  Eigen::Vector3i max_id;\n  bool is_success = getIndex(min_pos, min_id);\n  is_success = is_success && getIndex(max_pos, max_id);\n  if (!is_success) {\n    ROS_ERROR(\"[GridMap::resetBuffer]: min or max pos is out of bound\");\n    return;\n  }\n\n  // 2. iterate over the buffer and reset the value\n  for (int x = min_id(0); x <= max_id(0); ++x) {\n    for (int y = min_id(1); y <= max_id(1); ++y) {\n      for (int z = min_id(2); z <= max_id(2); ++z) {\n        Eigen::Vector3i idx(x, y, z);\n        int id = getLinearIndexFromIndex(idx);\n        occupancy_buffer_inflate_(id) = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 65.50951020127049}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tEigen::Vector3i min_id, max_id;\n    if (!getIndex(min_pos, min_id)) {\n        ROS_ERROR(\"[GridMap::resetBuffer]: min_pos is out of map range!\");\n        return;\n    }\n    if (!getIndex(max_pos, max_id)) {\n        ROS_ERROR(\"[GridMap::resetBuffer]: max_pos is out of map range!\");\n        return;\n    }\n\n    for (int x = min_id(0); x <= max_id(0); ++x)\n        for (int y = min_id(1); y <= max_id(1); ++y)\n            for (int z = min_id(2); z <= max_id(2); ++z) {\n                Eigen::Vector3i idx(x, y, z);\n                occupancy_buffer_inflate_(x, y, z) = 0;\n            }\n}", "CodeBleu_score": 66.68441956737156}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tIndex min_id, max_id;\n  if (!getIndex(min_pos, min_id) || !getIndex(max_pos, max_id)) {\n    ROS_ERROR(\"[GridMap::resetBuffer]: Position is out of map bounds.\");\n    return;\n  }\n  for (int i = min_id(0); i <= max_id(0); ++i) {\n    for (int j = min_id(1); j <= max_id(1); ++j) {\n      for (int k = min_id(2); k <= max_id(2); ++k) {\n        occupancy_buffer_inflate_(i, j, k) = 0.0;\n      }\n    }\n  }\n}", "CodeBleu_score": 49.09351295438819}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t// Compute the difference vector between the point and the camera position\n    Eigen::Vector3d diff = pt - camera_pt;\n\n    // Determine the maximum and minimum translation coefficients along each axis\n    double max_x = diff.x() > 0 ? (map_size_ - camera_pt.x()) / diff.x() : (camera_pt.x() + map_size_) / diff.x();\n    double min_x = diff.x() < 0 ? (map_size_ + camera_pt.x()) / diff.x() : (camera_pt.x() - map_size_) / diff.x();\n\n    double max_y = diff.y() > 0 ? (map_size_ - camera_pt.y()) / diff.y() : (camera_pt.y() + map_size_) / diff.y();\n    double min_y = diff.y() < 0 ? (map_size_ + camera_pt.y()) / diff.y() : (camera_pt.y() - map_size_) / diff.y();\n\n    double max_z = diff.z() > 0 ? (map_size_ - camera_pt.z()) / diff.z() : (camera_pt.z() + map_size_) / diff.z();\n    double min_z = diff.z() < 0 ? (map_size_ + camera_pt.z()) / diff.z() : (camera_pt.z() - map_size_) / diff.z();\n\n    // Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n    double scale_x = 1;\n    if (max_x < 1) {\n        scale_x = max_x;\n    }\n    if (min_x > 0) {\n        scale_x = min_x < scale_x ? scale_x : min_x;\n    }\n\n    double scale_y = 1;\n    if (max_y < 1) {\n        scale_y = max_y;\n    }\n    if (min_y > 0) {\n        scale_y = min_y < scale_y ? scale_y : min_", "CodeBleu_score": 41.462552869183725}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t// Calculate the difference vector between the point and the camera position\n    Eigen::Vector3d diff = pt - camera_pt;\n\n    // Determine the maximum and minimum translation coefficients along each axis\n    Eigen::Vector3d max_translation_coefficients;\n    Eigen::Vector3d min_translation_coefficients;\n    max_translation_coefficients << (width_ - 1) / 2, (height_ - 1) / 2, 0;\n    min_translation_coefficients << -(width_ - 1) / 2, -(height_ - 1) / 2, 0;\n\n    // Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n    for (int i = 0; i < 3; i++) {\n        if (diff(i) > max_translation_coefficients(i)) {\n            double scale = max_translation_coefficients(i) / diff(i);\n            if (scale < 1) {\n                diff = diff * scale;\n            }\n        } else if (diff(i) < min_translation_coefficients(i)) {\n            double scale = min_translation_coefficients(i) / diff(i);\n            if (scale < 1) {\n                diff = diff * scale;\n            }\n        }\n    }\n\n    // Return the adjusted point near the boundary\n    return camera_pt + diff;\n}", "CodeBleu_score": 44.88593952727813}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t// Calculate the difference vector between the point and the camera position\n  Eigen::Vector3d diff = pt - camera_pt;\n  // Determine the maximum and minimum translation coefficients along each axis\n  double max_t_x = (size_x_ - 1 - camera_pt.x()) / diff.x();\n  double max_t_y = (size_y_ - 1 - camera_pt.y()) / diff.y();\n  double max_t_z = (size_z_ - 1 - camera_pt.z()) / diff.z();\n  double min_t_x = (0 - camera_pt.x()) / diff.x();\n  double min_t_y = (0 - camera_pt.y()) / diff.y();\n  double min_t_z = (0 - camera_pt.z()) / diff.z();\n\n  // Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n  double scale = 1;\n  if (max_t_x < scale)\n    scale = max_t_x;\n  if (max_t_y < scale)\n    scale = max_t_y;\n  if (max_t_z < scale)\n    scale = max_t_z;\n  if (min_t_x > scale)\n    scale = min_t_x;\n  if (min_t_y > scale)\n    scale = min_t_y;\n  if (min_t_z > scale)\n    scale = min_t_z;\n\n  // Return the adjusted point near the boundary\n  return camera_pt + diff * scale;\n}", "CodeBleu_score": 43.48521491550161}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update the last occupancy update time.\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // If an update is needed, update the occupancy.\n  if (update_occupancy_) {\n\n    // Update the occupancy.\n    updateOccupancy();\n\n    // Clear and inflate the local map.\n    clearAndInflateLocalMap();\n\n    // Reset the update flag.\n    update_occupancy_ = false;\n\n    // Reset the depth image update flag.\n    depth_image_updated_ = false;\n\n    // Reset the odometry update flag.\n    odom_updated_ = false;\n  }\n\n  // If we haven't received a depth image in a while, set the flag.\n  if (ros::Time::now() - depth_image_time_ > depth_image_timeout_) {\n    depth_image_updated_ = false;\n  }\n\n  // If we haven't received odometry in a while, set the flag.\n  if (ros::Time::now() - odom_time_ > odom_timeout_) {\n    odom_updated_ = false;\n  }\n}", "CodeBleu_score": 31.474114598102453}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update last occupancy update time.\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // Check if an update is needed.\n  if (!need_update_) {\n    return;\n  }\n  need_update_ = false;\n\n  // Process depth image.\n  sensor_msgs::PointCloud2 cloud;\n  projectDepthImageIntoPointCloud(depth_image_, depth_camera_info_, &cloud);\n  processPointCloud(cloud, &cloud);\n\n  // Check if the local map has been updated.\n  if (local_map_updated_) {\n    // Clear local map.\n    clearLocalMap();\n\n    // Inflate local map.\n    inflateLocalMap();\n\n    // Reset local map update flag.\n    local_map_updated_ = false;\n  }\n}", "CodeBleu_score": 30.648555232587782}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// update last update time\n  last_update_time_ = ros::Time::now();\n\n  // check if an update is needed\n  if (!update_requested_) {\n    return;\n  }\n\n  // reset update requested flag\n  update_requested_ = false;\n\n  // get depth image from depth image queue\n  sensor_msgs::ImageConstPtr depth_image_msg;\n  if (!depth_image_queue_.get(depth_image_msg)) {\n    ROS_WARN(\"Could not get depth image from queue.\");\n    return;\n  }\n\n  // get depth image from depth image queue\n  sensor_msgs::ImageConstPtr depth_image_msg;\n  if (!depth_image_queue_.get(depth_image_msg)) {\n    ROS_WARN(\"Could not get depth image from queue.\");\n    return;\n  }\n\n  // get depth image from depth image queue\n  sensor_msgs::ImageConstPtr depth_image_msg;\n  if (!depth_image_queue_.get(depth_image_msg)) {\n    ROS_WARN(\"Could not get depth image from queue.\");\n    return;\n  }\n\n  // get depth image from depth image queue\n  sensor_msgs::ImageConstPtr depth_image_msg;\n  if (!depth_image_queue_.get(depth_image_msg)) {\n    ROS_WARN(\"Could not get depth image from queue.\");\n    return;\n  }\n\n  // get depth image from depth image queue\n  sensor_msgs::ImageConstPtr depth_image_msg;\n  if (!depth_image_queue_.get(depth_image_msg)) {\n    ROS_WARN(\"Could not get depth image from queue.\");\n    return;\n  }\n\n  // get depth image from depth image queue\n  sensor_msgs::ImageConstPtr depth_image_msg;\n  if (!depth_image_queue_.get(depth_image_msg)) {\n    ROS_WARN(\"Could not get depth image from queue.\");\n    return;\n  }\n\n  // get depth image from depth image queue\n  sensor_msgs::ImageConstPtr depth_image_msg;\n  if (!depth", "CodeBleu_score": 32.17252721098656}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t// Initialize the accumulator\n    float sum_fmeasure(0.f);\n\n    // Iterate through the image filenames\n    for (unsigned int i = 0; i < image_fns.size(); ++i) {\n        // Load the image\n        Mat3b img = imread(image_fns[i]);\n        if (img.empty()) {\n            cout << \"Error loading: \" << image_fns[i] << endl;\n            continue;\n        }\n\n        // Load the ground truth ellipses\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        // Load the detected ellipses\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        // Evaluate the detection performance\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\n        // Accumulate the F-measure\n        sum_fmeasure += fmeasure;\n    }\n\n    // Return the average F-measure\n    return sum_fmeasure / image_fns.size();\n}", "CodeBleu_score": 62.275876163353786}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tfloat fmeasure = 0.f;\n    unsigned n = image_fns.size();\n    for (unsigned i = 0; i < n; ++i)\n    {\n        vector<Ellipse> gt_ellipses;\n        vector<Ellipse> dt_ellipses;\n\n        // Load ground-truth ellipses\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        // Load detected ellipses\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        // Load image\n        Mat3b img = imread(image_fns[i]);\n\n        fmeasure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n    }\n\n    return fmeasure / float(n);\n}", "CodeBleu_score": 60.31219856669703}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tfloat avg_fmeasure = 0.f;\n    int n = image_fns.size();\n\n    for (int i = 0; i < n; ++i)\n    {\n        string image_fn = image_fns[i];\n        string gt_fn = gt_fns[i];\n        string dt_fn = dt_fns[i];\n\n        Mat3b img = imread(image_fn);\n\n        vector<Ellipse> ell_gt;\n        vector<Ellipse> ell_dt;\n\n        _load_ellipse_GT(gt_fn, ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fn, ell_dt, false);\n\n        avg_fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, img);\n    }\n    avg_fmeasure /= float(n);\n\n    return avg_fmeasure;\n}", "CodeBleu_score": 58.89744392001053}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tif (foci == NULL) {\n        return 0.0f;\n    }\n    float angle_a = atan2(y - foci[1], x - foci[0]);\n    float angle_b = atan2(y - foci[3], x - foci[2]);\n    return angle_diff_signed(angle_a, angle_b);\n}", "CodeBleu_score": 38.01388191694707}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat angle_a = atan2(y - foci[1], x - foci[0]);\n    float angle_b = atan2(y - foci[3], x - foci[2]);\n    float angle_diff = angle_diff_signed(angle_a, angle_b);\n    return angle_diff / 2;\n}", "CodeBleu_score": 35.58955655128803}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a, b;\n    if (foci == NULL) {\n        return 0.0;\n    }\n    a = atan2(foci[1] - y, foci[0] - x);\n    b = atan2(foci[3] - y, foci[2] - x);\n    return angle_diff_signed(a, b);\n}", "CodeBleu_score": 29.670918507475196}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint min_x = INT_MAX;\n\tint min_y = INT_MAX;\n\tint max_x = INT_MIN;\n\tint max_y = INT_MIN;\n\tint i;\n\tfor (i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\tint integral_above = 0;\n\tint integral_below = 0;\n\tfor (i = min_x; i <= max_x; i++) {\n\t\tint min_y_above = INT_MAX;\n\t\tint max_y_above = INT_MIN;\n\t\tint min_y_below = INT_MAX;\n\t\tint max_y_below = INT_MIN;\n\t\tfor (int j = start; j <= end; j++) {\n\t\t\tif (vp1[j].x == i) {\n\t\t\t\tif (vp1[j].y < min_y_above) min_y_above = vp1[j].y;\n\t\t\t\tif (vp1[j].y > max_y_above) max_y_above = vp1[j].y;\n\t\t\t}\n\t\t\tif (vp1[j].x == i - 1) {\n\t\t\t\tif (vp1[j].y < min_y_below) min_y_below = vp1[j].y;\n\t\t\t\tif (vp1[j].y > max_y_below) max_y_below = vp1[j].y;\n\t\t\t}\n\t\t}\n\t\tintegral_above += (max_y_above - min_y_above);\n\t\tintegral_", "CodeBleu_score": 37.2610076762118}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t// Calculate the minimum and maximum x and y coordinates of the points in the section\n\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\telse if (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\telse if (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\t// Calculate the integral above and below the polygon section\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x > vp1[start].x) {\n\t\t\tif (vp1[i].y > vp1[start].y) {\n\t\t\t\tintegral_above += (vp1[i].x - vp1[start].x) * (vp1[i].y - vp1[start].y);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tintegral_below += (vp1[i].x - vp1[start].x) * (vp1[i].y - vp1[start].y);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (vp1[i].y > vp1[start].y) {\n\t\t\t\tintegral_above += (vp1[start].x - v", "CodeBleu_score": 31.31805745974071}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tdouble xmin = vp1[start].x;\n\tdouble xmax = vp1[start].x;\n\tdouble ymin = vp1[start].y;\n\tdouble ymax = vp1[start].y;\n\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < xmin) {\n\t\t\txmin = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > xmax) {\n\t\t\txmax = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < ymin) {\n\t\t\tymin = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > ymax) {\n\t\t\tymax = vp1[i].y;\n\t\t}\n\t}\n\n\tdouble dx = xmax - xmin;\n\tdouble dy = ymax - ymin;\n\n\tdouble area_above = 0;\n\tdouble area_below = 0;\n\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x == xmax) {\n\t\t\tarea_above += vp1[i].y - ymin;\n\t\t}\n\t\telse {\n\t\t\tarea_above += vp1[i].y - ymin + (xmax - vp1[i].x) * dy / dx;\n\t\t}\n\t}\n\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x == xmin) {\n\t\t\tarea_below += vp1[i].y - ymin;\n\t\t}\n\t\telse {\n\t\t\tarea_below += vp1[i].y - ymin + (xmin - vp1[i].x) * dy / dx;\n\t\t}\n\t}\n\n\tif (area_above < area_below) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 40.75548648559929}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->detected_infos.size(); ++i) {\n        if (msg->detected_infos[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        }\n        else {\n            num_regain = 0;\n            num_lost++;\n        }\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n        if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n        ellipse_det.sight_angle = msg->detected_infos[i].sight_angle;\n    }\n}", "CodeBleu_score": 60.873659315514864}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->detected_info.size(); i++) {\n        if (msg->detected_info[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n        if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n        ellipse_det.pose.position.x = msg->detected_info[i].position[0];\n        ellipse_det.pose.position.y = msg->detected_info[i].position[1];\n        ellipse_det.pose.position.z = msg->detected_info[i].position[2];\n        ellipse_det.pose.orientation.x = msg->detected_info[i].attitude[0];\n        ellipse_det.pose.orientation.y = msg->detected_info[i].attitude[1];\n        ellipse_det.pose.orientation.z = msg->detected_info[i].attitude[2];\n        ellipse_det.pose.orientation.w = msg->detected_info[i].attitude[3];\n        ellipse_det.sight_angle = msg->detected_info[i].sight_angle;\n    }\n}", "CodeBleu_score": 61.33828108325007}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tint num_lost = 0;\n    int num_regain = 0;\n    for (int i = 0; i < msg->det_info.size(); i++) {\n        if (msg->det_info[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        }\n        else {\n            num_lost++;\n            num_regain = 0;\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    else if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n    ellipse_det.detected = is_detected;\n    ellipse_det.num_detected = msg->det_info.size();\n    ellipse_det.sight_angle = msg->sight_angle;\n}", "CodeBleu_score": 63.82055321969815}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tif (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 47.40889897505076}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t/* ---------- check the safety of the current position ---------- */\n  bool is_safety = true;\n\n  // safety check\n  if (cur_pos(0) > limit_x_max || cur_pos(0) < limit_x_min || cur_pos(1) > limit_y_max || cur_pos(1) < limit_y_min || cur_pos(2) > limit_z_max || cur_pos(2) < limit_z_min) {\n    is_safety = false;\n    return is_safety;\n  }\n\n  // safety check\n  for (int i = 0; i < 3; ++i) {\n    if (cur_pos(i) > limit_x_max || cur_pos(i) < limit_x_min || cur_pos(i) > limit_y_max || cur_pos(i) < limit_y_min || cur_pos(i) > limit_z_max || cur_pos(i) < limit_z_min) {\n      is_safety = false;\n      return is_safety;\n    }\n  }\n\n  // safety check\n  if (occupy_map_ptr->getOccupancy(cur_pos(0), cur_pos(1), cur_pos(2))) {\n    is_safety = false;\n    return is_safety;\n  }\n\n  // safety check\n  if (occupy_map_ptr->getNearestDistance(cur_pos) < safe_distance) {\n    is_safety = false;\n    return is_safety;\n  }\n\n  return is_safety;\n}", "CodeBleu_score": 42.61560501165821}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tif (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 47.86084853188067}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t// If the end node is the start node, the path is already complete.\n\tif (end_node == start_node_) {\n\t\treturn;\n\t}\n\n\t// Otherwise, follow the parent pointers back to the start node.\n\twhile (end_node->parent_ != NULL) {\n\t\tpath_nodes_.push_back(end_node);\n\t\tend_node = end_node->parent_;\n\t}\n\n\t// The end node is the start node, so add it to the path.\n\tpath_nodes_.push_back(end_node);\n\n\t// Reverse the order of the path nodes.\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 48.97640224822309}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t// Create a path_node_ to store the coordinates of the end node\n\tpath_nodes_.push_back(end_node);\n\n\t// Set the parent of the end node to current_node\n\tNodePtr current_node = end_node->parent_;\n\n\t// Iterate from the end node to the start node\n\twhile (current_node) {\n\n\t\t// Add the parent of the current node to the path\n\t\tpath_nodes_.push_back(current_node);\n\n\t\t// Set the parent of the current node to be the new current node\n\t\tcurrent_node = current_node->parent_;\n\t}\n\n\t// Reverse the path to return the result from the start to the end node\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 57.685404975808765}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tNodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 66.93696605492471}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t//ROS_INFO(\"nei_odom_cb\");\n    //ROS_INFO(\"nei_odom_cb: id = %d\", id);\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n    state_nei[id][3] = odom->pose.pose.orientation.w;\n    state_nei[id][4] = odom->pose.pose.orientation.x;\n    state_nei[id][5] = odom->pose.pose.orientation.y;\n    state_nei[id][6] = odom->pose.pose.orientation.z;\n\n    //ROS_INFO(\"nei_odom_cb: state_nei[id][0] = %f\", state_nei[id][0]);\n    //ROS_INFO(\"nei_odom_cb: state_nei[id][1] = %f\", state_nei[id][1]);\n    //ROS_INFO(\"nei_odom_cb: state_nei[id][2] = %f\", state_nei[id][2]);\n    //ROS_INFO(\"nei_odom_cb: state_nei[id][3] = %f\", state_nei[id][3]);\n    //ROS_INFO(\"nei_odom_cb: state_nei[id][4] = %f\", state_nei[id][4]);\n    //ROS_INFO(\"nei_odom_cb: state_nei[id][5] = %f\", state_nei[id][5]);\n    //ROS_INFO(\"nei_odom_cb: state_nei[id][6] = %f\", state_nei[id][6]);\n\n    //ROS_INFO(\"nei_odom_cb: state_nei[id][0] = %f\", state_nei[id][0]);\n    //ROS_INFO", "CodeBleu_score": 38.85723569835595}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"GlobalPlannerUGV::nei_odom_cb: %d\", id);\n\n\t//ROS_INFO(\"Global", "CodeBleu_score": 3.16992491450739}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t//ROS_INFO(\"nei_odom_cb\");\n    if (id == 1) {\n        state_nei[0] = odom->pose.pose.position.x;\n        state_nei[1] = odom->pose.pose.position.y;\n        state_nei[2] = odom->pose.pose.position.z;\n    }\n    if (simulation) {\n        if (sqrt(pow(odom->pose.pose.position.x - state_start[0], 2) + pow(odom->pose.pose.position.y - state_start[1], 2)) > 5) {\n            get_nei_state = false;\n        } else {\n            get_nei_state = true;\n        }\n    }\n}", "CodeBleu_score": 37.96246329249327}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: received point cloud data.\");\n    // If the odometry is not ready, return immediately.\n    if (!odom_ready) {\n        return;\n    }\n    //ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: odometry is ready.\");\n    // If the sensor_ready flag is false, set it to true and return.\n    if (!sensor_ready) {\n        sensor_ready = true;\n        return;\n    }\n    //ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor is ready.\");\n    // If the update counter is less than 5, increment it and return.\n    if (update_counter < 5) {\n        update_counter++;\n        return;\n    }\n    //ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: update counter is 5.\");\n    // Reset the update counter.\n    update_counter = 0;\n    //ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: reset update counter.\");\n    // Convert the point cloud to a pcl::PointCloud<pcl::PointXYZ>.\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*msg, cloud);\n    //ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: converted point cloud to pcl::PointCloud<pcl::PointXYZ>.\");\n    // Update the Astar map with the new point cloud data.\n    astar_planner.updateMap(cloud);\n    //ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: updated Astar map with new point cloud data.\");\n}", "CodeBleu_score": 54.39492628171997}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: msg->header.frame_id = %s\", msg->header.frame_id.c_str());\n\n    if (!odom_ready) {\n        return;\n    }\n\n    if (!sensor_ready) {\n        sensor_ready = true;\n    }\n\n    if (sensor_ready) {\n        sensor_update_counter++;\n    }\n\n    if (sensor_update_counter == 5) {\n        sensor_update_counter = 0;\n        //ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_update_counter = %d\", sensor_update_counter);\n        sensor_msgs::PointCloud2 msg_new;\n        pcl_ros::transformPointCloud(msg->header.frame_id, msg, msg_new, *tf_);\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(msg_new, *cloud);\n        //ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: cloud->size() = %d\", cloud->size());\n        astar_->updateMap(cloud);\n    }\n}", "CodeBleu_score": 56.45449389127211}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter > 4) {\n        update_counter = 0;\n        if (map_ready) {\n            // Update map\n            pcl::PointCloud<pcl::PointXYZ> cloud;\n            pcl::fromROSMsg(*msg, cloud);\n            map.updateMap(cloud);\n            map_ready = false;\n        }\n    }\n}", "CodeBleu_score": 62.280180775954854}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (!get_gpcl) {\n        get_gpcl = true;\n        pcl::PointCloud<pcl::PointXYZ> latest_global_pcl_;\n        pcl::fromROSMsg(*global_point, latest_global_pcl_);\n        global_pcl = latest_global_pcl_;\n        has_global_point = true;\n        inflate_global_pcl();\n    }\n}", "CodeBleu_score": 60.19252654330855}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (get_gpcl == 0) {\n        get_gpcl = 1;\n        // cout << \"gpcl\" << endl;\n        pcl::PointCloud<pcl::PointXYZ> latest_global_cloud;\n        pcl::fromROSMsg(*global_point, latest_global_cloud);\n        global_cloud = latest_global_cloud;\n        inflate_point_cloud_2_mat(global_cloud, global_pcl_inflate);\n        // cout << \"gpcl\" << endl;\n    }\n\n}", "CodeBleu_score": 50.880132415533176}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (get_gpcl == 0) {\n        get_gpcl = 1;\n        global_map_pcl.reset(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*global_point, *global_map_pcl);\n        global_pcl_ptr = global_map_pcl;\n        inflate_global_map(global_pcl_ptr);\n    }\n}", "CodeBleu_score": 52.893591415147945}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// This is the laser scan data in PointCloud2 format\n    sensor_msgs::PointCloud2 local_map;\n\n    // This is the laser scan data in pcl::PointCloud format\n    pcl::PointCloud<pcl::PointXYZ> latest_scan_pcl;\n\n    // This is the laser scan data in pcl::PointCloud format, transformed to the odometry frame\n    pcl::PointCloud<pcl::PointXYZ> latest_scan_pcl_odom;\n\n    // This is the laser scan data in pcl::PointCloud format, transformed to the odometry frame and projected into the map frame\n    pcl::PointCloud<pcl::PointXYZ> latest_scan_pcl_map;\n\n    // This is the laser scan data in pcl::PointCloud format, transformed to the odometry frame and projected into the map frame\n    pcl::PointCloud<pcl::PointXYZ> latest_scan_pcl_map_vox;\n\n    // This is the laser scan data in pcl::PointCloud format, transformed to the odometry frame and projected into the map frame\n    pcl::PointCloud<pcl::PointXYZ> latest_scan_pcl_map_vox_filtered;\n\n    // This is the laser scan data in pcl::PointCloud format, transformed to the odometry frame and projected into the map frame\n    pcl::PointCloud<pcl::PointXYZ> latest_scan_pcl_map_vox_filtered_downsampled;\n\n    // This is the laser scan data in pcl::PointCloud format, transformed to the odometry frame and projected into the map frame\n    pcl::PointCloud<pcl::PointXYZ> latest_scan_pcl_map_vox_filtered_downsampled_filtered;\n\n    // This is the laser scan data in pcl::PointCloud format, transformed to the odometry frame and projected into the map frame\n    pcl::PointCloud<pcl::PointXYZ> latest_scan_pcl_map_vox_filtered_downsampled_filtered_pcd;\n\n    // This is the laser", "CodeBleu_score": 14.215098441085056}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// If not in simulation mode, update the map with odometry information\n    if (!simulation_mode) {\n        geometry_msgs::Pose2D odom_pose;\n        odom_pose.x = odom.pose.pose.position.x;\n        odom_pose.y = odom.pose.pose.position.y;\n        odom_pose.theta = tf::getYaw(odom.pose.pose.orientation);\n        map_update_odom(odom_pose);\n    }\n\n    // Get the pose of the robot in the map frame\n    geometry_msgs::Pose2D pose_map;\n    pose_map.x = odom.pose.pose.position.x;\n    pose_map.y = odom.pose.pose.position.y;\n    pose_map.theta = tf::getYaw(odom.pose.pose.orientation);\n\n    // Create a PointCloud2 from the laser scan\n    sensor_msgs::PointCloud2 cloud;\n    projector_.transformLaserScanToPointCloud(\"base_link\", *local_point, cloud, listener_);\n\n    // Convert the PointCloud2 to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ> cloud_pcl;\n    pcl::fromROSMsg(cloud, cloud_pcl);\n\n    // Update the map with the laser scan\n    map_update_laser_pcl(cloud_pcl, pose_map);\n\n}", "CodeBleu_score": 45.72139415962456}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// Transform the laser scan into a PointCloud2 format\n    sensor_msgs::PointCloud2 cloud;\n    projector_.transformLaserScanToPointCloud(\"base_link\", *local_point, cloud, listener_);\n\n    // Transform the PointCloud2 into a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ> cloud_pcl;\n    pcl::fromROSMsg(cloud, cloud_pcl);\n\n    // If not in simulation mode, update the local map with odometry information\n    if (simulation_mode_ == false) {\n        // Update the local map with odometry information\n        update_local_map(odom);\n    }\n\n    // Update the local map with the laser scan\n    update_local_map(cloud_pcl);\n}", "CodeBleu_score": 48.488029412298125}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tif (!has_map_) {\n    return;\n  }\n  sensor_msgs::PointCloud2 global_pcl, inflate_pcl;\n  pcl::toROSMsg(*global_pcl_, global_pcl);\n  pcl::toROSMsg(*inflate_pcl_, inflate_pcl);\n  global_pcl.header.frame_id = \"world\";\n  inflate_pcl.header.frame_id = \"world\";\n  global_pcl_pub_.publish(global_pcl);\n  inflate_pcl_pub_.publish(inflate_pcl);\n}", "CodeBleu_score": 55.460344217639836}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tif (!has_map_) {\n        return;\n    }\n\n    sensor_msgs::PointCloud2 map_pcl_msg;\n    pcl::toROSMsg(*global_pcl_, map_pcl_msg);\n    map_pcl_msg.header.stamp = ros::Time::now();\n    map_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub_.publish(map_pcl_msg);\n\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(*inflate_pcl_, inflate_pcl_msg);\n    inflate_pcl_msg.header.stamp = ros::Time::now();\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub_.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 59.36312235652468}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\tpcl::PointCloud<pcl::PointXYZ> pcl_global_map;\n  pcl::PointCloud<pcl::PointXYZ> pcl_inflate_map;\n  pcl::PointXYZ pt;\n  int num_points = 0;\n  for (int i = 0; i < 1000; i++) {\n    for (int j = 0; j < 1000; j++) {\n      if (occupancy_buffer_[i][j] == 1) {\n        pt.x = i / 10.0;\n        pt.y = j / 10.0;\n        pt.z = 0.0;\n        pcl_global_map.push_back(pt);\n        num_points++;\n      }\n    }\n  }\n  ROS_INFO(\"num_points: %d\", num_points);\n  pcl_global_map.header.frame_id = \"world\";\n  pcl_global_map.header.stamp = ros::Time::now();\n  global_pcl_pub.publish(pcl_global_map);\n  for (int i = 0; i < 1000; i++) {\n    for (int j = 0; j < 1000; j++) {\n      if (occupancy_buffer_inflate_[i][j] == 1) {\n        pt.x = i / 10.0;\n        pt.y = j / 10.0;\n        pt.z = 0.0;\n        pcl_inflate_map.push_back(pt);\n        num_points++;\n      }\n    }\n  }\n  ROS_INFO(\"num_points: %d\", num_points);\n  pcl_inflate_map.header.frame_id = \"world\";\n  pcl_inflate_map.header.stamp = ros::Time::now();\n  inflate_pcl_pub.publish(pcl_inflate_map);\n}", "CodeBleu_score": 52.7554815193478}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"Lpointcloud_cb\");\n    if (!odom_ready) {\n        ROS_WARN(\"Odom not ready\");\n        return;\n    }\n    sensor_ready = true;\n\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*msg, cloud);\n\n    //ROS_INFO(\"cloud size: %d\", cloud.size());\n\n    //update map\n    //ROS_INFO(\"Updating map...\");\n    astar.updateMap(cloud, odom_x, odom_y, odom_z);\n\n    //ROS_INFO(\"map updated\");\n}", "CodeBleu_score": 65.08154906025469}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"GlobalPlanner: received pointcloud\");\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  pcl::fromROSMsg(*msg, cloud);\n  //ROS_INFO(\"GlobalPlanner: pointcloud received and converted\");\n  if (odom_ready) {\n    sensor_ready = true;\n  }\n  if (sensor_ready) {\n    //ROS_INFO(\"GlobalPlanner: sensor ready\");\n    a_star.set_map(cloud, odom);\n  }\n}", "CodeBleu_score": 49.934070609821624}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"Point cloud received\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t\n\tif (!odom_ready) {\n\t\tROS_WARN(\"Odometry not ready. Waiting for odometry message.\");\n\t\treturn;\n\t}\n\t\n\tsensor_ready = true;\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud_cb: sensor_ready = true\");\n\t\n\t//ROS_INFO(\"Lpointcloud", "CodeBleu_score": 36.15951734581099}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// get the current time\n    ros::Time time = ros::Time::now();\n\n    // calculate the time elapsed since the last control loop\n    ros::Duration dt = time - last_loop_time_;\n    last_loop_time_ = time;\n\n    // get the current pose of the quadruped\n    Eigen::Vector3d current_position;\n    Eigen::Quaterniond current_orientation;\n    if (in_gazebo_) {\n        // get the current pose of the quadruped from gazebo\n        gazebo::math::Pose gazebo_pose = gazebo_model_->GetWorldPose();\n        current_position = Eigen::Vector3d(gazebo_pose.pos.x, gazebo_pose.pos.y, gazebo_pose.pos.z);\n        current_orientation = Eigen::Quaterniond(gazebo_pose.rot.w, gazebo_pose.rot.x, gazebo_pose.rot.y, gazebo_pose.rot.z);\n    }\n    else {\n        // get the current pose of the quadruped from the odometry topic\n        nav_msgs::Odometry::ConstPtr odom = ros::topic::waitForMessage<nav_msgs::Odometry>(\"odom\", ros::Duration(0.5));\n        current_position = Eigen::Vector3d(odom->pose.pose.position.x, odom->pose.pose.position.y, odom->pose.pose.position.z);\n        current_orientation = Eigen::Quaterniond(odom->pose.pose.orientation.w, odom->pose.pose.orientation.x, odom->pose.pose.orientation.y, odom->pose.pose.orientation.z);\n    }\n\n    // get the current velocity of the quadruped\n    Eigen::Vector3d current_velocity;\n    if (in_gazebo_) {\n        // get the current velocity of the quadruped from gazebo\n        gazebo::math::Vector3 gazebo_velocity = gazebo_model_->GetWorldLinearVel", "CodeBleu_score": 33.726809594081786}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\tif (in_gazebo_ && !in_gazebo_control_loop_)\n    {\n        //This is the first time the control loop is called in Gazebo\n        //We need to initialize the body controller with the current robot state\n        in_gazebo_control_loop_ = true;\n        body_controller_.initialize(base_.getBodyState());\n    }\n\n    //Get the desired pose\n    champ::Pose desired_pose = pose_handler_.getDesiredPose();\n\n    //Get the current robot state\n    champ::RobotState current_state = base_.getBodyState();\n\n    //Get the target foot positions\n    std::vector<champ::Point> target_foot_positions = body_controller_.calculateTargetFootPositions(desired_pose, current_state);\n\n    //Calculate the leg commands\n    std::vector<champ::LegCommand> leg_commands = base_.calculateLegCommands(target_foot_positions);\n\n    //Calculate the joint positions\n    float joint_positions[12];\n    base_.calculateJointPositions(joint_positions, leg_commands);\n\n    //Publish the joint positions\n    publishJoints_(joint_positions);\n\n    //Publish the foot contacts\n    publishFootContacts_(base_.getFootContacts());\n\n    //Publish the current state\n    publishState_(current_state, leg_commands);\n}", "CodeBleu_score": 45.902086417060474}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the current time\n    ros::Time current_time = ros::Time::now();\n\n    // Get the current state of the robot\n    quad_utils::QuadKD quadKD = getRobotState();\n\n    // Get the desired state of the robot\n    quad_utils::QuadKD quadKD_des = getDesiredState();\n\n    // Get the desired state of the robot\n    quad_utils::QuadKD quadKD_des_prev = getPrevDesiredState();\n\n    // Get the desired state of the robot\n    quad_utils::QuadKD quadKD_des_prev_prev = getPrevPrevDesiredState();\n\n    // Get the desired state of the robot\n    quad_utils::QuadKD quadKD_des_prev_prev_prev = getPrevPrevPrevDesiredState();\n\n    // Get the desired state of the robot\n    quad_utils::QuadKD quadKD_des_prev_prev_prev_prev = getPrevPrevPrevPrevDesiredState();\n\n    // Get the desired state of the robot\n    quad_utils::QuadKD quadKD_des_prev_prev_prev_prev_prev = getPrevPrevPrevPrevPrevDesiredState();\n\n    // Get the desired state of the robot\n    quad_utils::QuadKD quadKD_des_prev_prev_prev_prev_prev_prev = getPrevPrevPrevPrevPrevPrevDesiredState();\n\n    // Get the desired state of the robot\n    quad_utils::QuadKD quadKD_des_prev_prev_prev_prev_prev_prev_prev = getPrevPrevPrevPrevPrevPrevPrevDesiredState();\n\n    // Get the desired state of the robot\n    quad_utils::QuadKD quadKD_des_prev_prev_prev_prev_prev_prev_prev_prev = getPrevPrevPrevPrevPrevPrevPrevPrevDesiredState();\n\n    // Get the desired state of the robot\n    quad_utils::QuadKD quadKD_des_prev", "CodeBleu_score": 16.0631431763779}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    quad_msgs::FootContactsStamped msg;\n    msg.header.stamp = ros::Time::now();\n    for (int i = 0; i < 4; i++) {\n      msg.contacts[i] = foot_contacts[i];\n    }\n    foot_contacts_publisher_.publish(msg);\n  }\n}", "CodeBleu_score": 46.60171862538597}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t// Check if foot contact publishing is enabled and if we are not in Gazebo\n  if (foot_contacts_publishing_enabled_ && !gazebo_simulation_) {\n    // Create a ContactsStamped message\n    quad_msgs::ContactsStamped contacts_msg;\n    // Set the header of the message\n    contacts_msg.header.stamp = ros::Time::now();\n    contacts_msg.header.frame_id = \"odom\";\n    // Set the gait phase of each leg\n    for (int leg_index = 0; leg_index < 4; leg_index++) {\n      // If the leg is in contact with the ground, set the gait phase to 1, otherwise set it to 0\n      if (foot_contacts[leg_index]) {\n        contacts_msg.contacts.push_back(1);\n      } else {\n        contacts_msg.contacts.push_back(0);\n      }\n    }\n    // Publish the message\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 57.57984798588207}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t// Create a message to publish the foot contacts\n  if (publish_foot_contacts_) {\n    quad_msgs::FootContactsStamped contacts_msg;\n\n    // Populate the message\n    contacts_msg.header.stamp = ros::Time::now();\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts[i] = foot_contacts[i];\n    }\n\n    // Publish the message\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n\n}", "CodeBleu_score": 59.65531354139281}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t# Create a minimal joints message with the first 12 joint positions\n    msg = Joints()\n    msg.header.stamp = rospy.Time.now()\n    msg.name = joints.name\n    msg.position = joints.position[:12]\n    self.pub_joints.publish(msg)\n\n    # Create a joint trajectory message with the same positions and a specified duration\n    msg = JointTrajectory()\n    msg.header.stamp = rospy.Time.now()\n    msg.joint_names = joints.name\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[:12]\n    point.time_from_start = rospy.Duration.from_sec(1.0)\n    msg.points.append(point)\n    self.pub_traj.publish(msg)\n}", "CodeBleu_score": 48.79789550808288}, {"code": "def joints_cmd_callback(self, joints){\n\t// Create a minimal joints message with the first 12 joint positions\n    self.joints_msg = JointState()\n    self.joints_msg.header.stamp = rospy.Time.now()\n    self.joints_msg.name = joints.name[0:12]\n    self.joints_msg.position = joints.position[0:12]\n\n    // Publish the joints message\n    self.joints_pub.publish(self.joints_msg)\n\n    # Create a joint trajectory message\n    self.traj_msg = JointTrajectory()\n    self.traj_msg.header.stamp = rospy.Time.now()\n    self.traj_msg.joint_names = joints.name[0:12]\n    self.traj_msg.points = [JointTrajectoryPoint()]\n    self.traj_msg.points[0].time_from_start = rospy.Duration.from_sec(self.traj_duration)\n    self.traj_msg.points[0].positions = joints.position[0:12]\n\n    # Publish the trajectory message\n    self.traj_pub.publish(self.traj_msg)\n}", "CodeBleu_score": 41.31861452769121}, {"code": "def joints_cmd_callback(self, joints){\n\t// Create minimal joints message\n    self.joints_msg.header = joints.header\n    self.joints_msg.name = joints.name[0..11]\n    self.joints_msg.position = joints.position[0..11]\n\n    // Publish joints message\n    self.joints_pub.publish(self.joints_msg)\n\n    // Create joint trajectory message\n    self.traj_msg.header = joints.header\n    self.traj_msg.joint_names = joints.name[0..11]\n    self.traj_msg.points = [new TrajectoryPoint()]\n    self.traj_msg.points[0].positions = joints.position[0..11]\n    self.traj_msg.points[0].time_from_start = new Duration(1.0)\n\n    // Publish trajectory message\n    self.traj_pub.publish(self.traj_msg)\n}", "CodeBleu_score": 31.514608811758947}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfor (int i = 0; i < 4; i++) {\n    foot_contact_states_[i] = false;\n  }\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::string name1 = _msg->contact(i).collision1();\n    std::string name2 = _msg->contact(i).collision2();\n\n    // Check if any contact is detected on the feet\n    if (name1.find(\"_foot_\") != std::string::npos) {\n      if (name1.find(\"left\") != std::string::npos) {\n        foot_contact_states_[0] = true;\n      } else if (name1.find(\"right\") != std::string::npos) {\n        foot_contact_states_[1] = true;\n      }\n    } else if (name2.find(\"_foot_\") != std::string::npos) {\n      if (name2.find(\"left\") != std::string::npos) {\n        foot_contact_states_[0] = true;\n      } else if (name2.find(\"right\") != std::string::npos) {\n        foot_contact_states_[1] = true;\n      }\n    }\n\n    // Check if any contact is detected on the front of the robot\n    if (name1.find(\"_foot_\") != std::string::npos) {\n      if (name1.find(\"front\") != std::string::npos) {\n        foot_contact_states_[2] = true;\n      }\n    } else if (name2.find(\"_foot_\") != std::string::npos) {\n      if (name2.find(\"front\") != std::string::npos) {\n        foot_contact_states_[2] = true;\n      }\n    }\n\n    // Check if any contact is detected on the back of the robot\n    if (name1.find(\"_foot_\") != std::string::npos) {\n      if (name1.find(\"back\") != std::string::npos) {\n        foot_contact_states_[3] = true", "CodeBleu_score": 48.46855560028594}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize all foot contact states to false\n  right_contact = false;\n  left_contact = false;\n  for (int i = 0; i < _msg->contact_size(); ++i) {\n    // Split the collision1_name and collision2_name strings by the '/' character\n    std::string name1 = _msg->contact(i).collision1_name();\n    std::string name2 = _msg->contact(i).collision2_name();\n    std::size_t found1 = name1.find_last_of('/');\n    std::size_t found2 = name2.find_last_of('/');\n    std::string name1_1 = name1.substr (found1+1);\n    std::string name2_1 = name2.substr (found2+1);\n    // Check if the foot links are in contact\n    if (name1_1 == \"right_foot_link\" || name2_1 == \"right_foot_link\") {\n      right_contact = true;\n    }\n    if (name1_1 == \"left_foot_link\" || name2_1 == \"left_foot_link\") {\n      left_contact = true;\n    }\n  }\n}", "CodeBleu_score": 41.5325287544042}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize foot contact states to false\n  foot_contact_states_.left_contact = false;\n  foot_contact_states_.right_contact = false;\n\n  // Loop through all the contacts\n  for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n    // Split the collision string into left and right\n    std::string left_side = _msg->contact(i).collision1().substr(0, 5);\n    std::string right_side = _msg->contact(i).collision2().substr(0, 5);\n\n    // Check if the collision is left or right, and set the corresponding foot contact state to true\n    if (left_side == \"left_\") {\n      foot_contact_states_.left_contact = true;\n    } else if (right_side == \"right_\") {\n      foot_contact_states_.right_contact = true;\n    }\n  }\n}", "CodeBleu_score": 37.25970621095408}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::Vector3d thrust;\n  thrust = -acceleration;\n\n  Eigen::Vector3d thrust_and_angular_acceleration;\n  thrust_and_angular_acceleration = thrust + angular_acceleration;\n\n  Eigen::Matrix3d rotor_thrust_matrix;\n  rotor_thrust_matrix << 1, 1, 1,\n                         1, -1, -1,\n                         -1, -1, 1;\n\n  *rotor_velocities = rotor_thrust_matrix * thrust_and_angular_acceleration;\n\n  for (int i = 0; i < rotor_count_; ++i) {\n    (*rotor_velocities)(i) = std::sqrt(std::max(0.0, (*rotor_velocities)(i)));\n  }\n}", "CodeBleu_score": 52.911349569662015}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->size());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::Vector3d thrust;\n  thrust = acceleration + angular_acceleration.cross(vehicle_parameters_.inertia_ * angular_acceleration);\n  thrust[2] += vehicle_parameters_.mass_ * vehicle_parameters_.gravity_;\n\n  Eigen::Vector4d omega;\n  omega = vehicle_parameters_.rotor_configuration_.transpose() * thrust;\n\n  // Ensure that the rotor velocities are non-negative.\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    if (omega[i] < 0) {\n      omega[i] = 0;\n    }\n  }\n\n  // Compute rotor velocities.\n  *rotor_velocities = vehicle_parameters_.rotor_configuration_matrix_ * omega;\n\n  // Ensure that the rotor velocities are non-negative.\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    if ((*rotor_velocities)[i] < 0) {\n      (*rotor_velocities)[i] = 0;\n    }\n  }\n\n  // Ensure that the rotor velocities are below the maximum.\n  double rotor_velocity_squared_norm = rotor_velocities->squaredNorm();\n  if (rotor_velocity_squared_norm > vehicle_parameters_.max_rotor_speed_ * vehicle_parameters_.max_rotor_speed_) {\n    *rotor_velocities *= vehicle_parameters_.max_rotor_speed_ / sqrt", "CodeBleu_score": 62.88131879222314}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!IsControllerActive()) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->size());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z-axis.\n  Eigen::Vector3d thrust = acceleration + angular_acceleration.cross(command_trajectory_.position_W);\n  thrust[2] = -thrust.norm();\n\n  // Combine thrust and angular acceleration.\n  Eigen::Vector4d combined_vector;\n  combined_vector << thrust, angular_acceleration;\n\n  // Rotor velocities.\n  *rotor_velocities = rotor_matrix_ * combined_vector;\n\n  // Ensure that the rotor velocities are non-negative.\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    if ((*rotor_velocities)[i] < 0) {\n      (*rotor_velocities)[i] = 0;\n    }\n  }\n\n  // Ensure that the rotor velocities are below the maximum.\n  double max_rotor_velocity = GetMaximumRotorVelocity();\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    if ((*rotor_velocities)[i] > max_rotor_velocity) {\n      (*rotor_velocities)[i] = max_rotor_velocity;\n    }\n  }\n}", "CodeBleu_score": 59.8620696959477}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t/*\n   * This function, LeePositionController::ComputeDesiredAcceleration, calculates the desired acceleration for the vehicle.", "CodeBleu_score": 11.19326866286382}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tassert(acceleration);\n\n  // Get the vehicle's current position and velocity in the world frame.\n  const Eigen::Vector3d position = odometry_.pose.pose.position;\n  const Eigen::Vector3d velocity = odometry_.twist.twist.linear;\n\n  // Get the vehicle's current position and velocity in the local frame.\n  const Eigen::Vector3d position_local =\n      transform_.InverseTransform(position);\n  const Eigen::Vector3d velocity_local =\n      transform_.InverseTransform(velocity);\n\n  // Get the vehicle's current yaw angle in the world frame.\n  const double yaw = tf2::getYaw(odometry_.pose.pose.orientation);\n\n  // Get the vehicle's current yaw angle in the local frame.\n  const double yaw_local =\n      transform_.InverseTransform(Eigen::Vector3d(0.0, 0.0, yaw)).z();\n\n  // Get the desired position and velocity in the local frame.\n  const Eigen::Vector3d position_desired_local =\n      transform_.InverseTransform(position_desired_);\n  const Eigen::Vector3d velocity_desired_local =\n      transform_.InverseTransform(velocity_desired_);\n\n  // Compute the position and velocity errors.\n  const Eigen::Vector3d position_error = position_desired_local - position_local;\n  const Eigen::Vector3d velocity_error = velocity_desired_local - velocity_local;\n\n  // Compute the desired acceleration in the local frame.\n  Eigen::Vector3d acceleration_local;\n  acceleration_local.x() =\n      position_gain_.x() * position_error.x() +\n      velocity_gain_.x() * velocity_error.x() +\n      acceleration_desired_.x();\n  acceleration_local.y() =\n      position_gain_.y() * position_error.y() +\n      velocity_gain_.y() * velocity_error.y() +\n      acceleration_desired_.y();\n  acceleration_local.z() =\n      position_gain_.", "CodeBleu_score": 44.11785619435154}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tEigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  Eigen::Vector3d position_command;\n  Eigen::Vector3d velocity_command;\n\n  // Get the position and velocity errors.\n  GetPositionAndVelocityErrors(&position_error, &velocity_error);\n\n  // Get the position and velocity commands.\n  GetPositionAndVelocityCommands(&position_command, &velocity_command);\n\n  // Compute the desired acceleration.\n  *acceleration = position_error.cwiseProduct(position_gains_) +\n                  velocity_error.cwiseProduct(velocity_gains_) +\n                  mass_ * gravity_ -\n                  mass_ * velocity_command.cwiseProduct(velocity_command);\n}", "CodeBleu_score": 37.4859853748021}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // Check for valid inputs\n  assert(attitude_thrust_reference_valid_);\n  assert(mass_ > 0);\n  assert(inertia_(0, 0) > 0 && inertia_(1, 1) > 0 && inertia_(2, 2) > 0);\n  assert(arm_length_ > 0);\n\n  // Resize rotor velocities\n  rotor_velocities->resize(rotor_configuration_.rotors.size());\n\n  // Compute desired angular acceleration\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // Compute desired rotor velocities\n  Eigen::Vector3d rotor_velocities_desired;\n  rotor_velocities_desired << control_attitude_thrust_reference_(3),\n                              control_attitude_thrust_reference_(4),\n                              control_attitude_thrust_reference_(5);\n\n  Eigen::Vector3d rotor_velocities_desired_in_body = R_.transpose() * rotor_velocities_desired;\n\n  Eigen::Matrix3d R_des;\n  double yaw = atan2(R_(1, 0), R_(0, 0));\n  R_des = Eigen::AngleAxisd(yaw, Eigen::Vector3d::UnitZ()) // yaw\n        * Eigen::AngleAxisd(control_attitude_thrust_reference_(0), Eigen::Vector3d::UnitX()) // roll\n        * Eigen::AngleAxisd(control_attitude_thrust_reference_(1), Eigen::Vector3d::UnitY()); // pitch\n\n  Eigen::Vector3d b3_des = R_.transpose() * R_des.col(2);\n  Eigen::Vector3d angle_error = b3_des.cross(Eigen::Vector3d::UnitZ());\n\n  Eigen::Vector3d angular_rate_des(Eigen::Vector3d::Zero());\n  angular_rate", "CodeBleu_score": 39.82914632436798}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // Ensure the input and parameters are valid\n  assert(attitude_thrust_reference_.size() == 4);\n  assert(rotor_velocities->size() == 4);\n\n  // Resize the rotor velocities vector to match the number of rotors\n  rotor_velocities->resize(rotor_velocities_.size());\n\n  // Calculate the desired angular acceleration\n  Eigen::Vector3d desired_angular_acceleration;\n  ComputeDesiredAngularAcc(&desired_angular_acceleration);\n\n  // Combine the desired angular acceleration and thrust reference into a single vector\n  Eigen::Vector4d desired_acceleration;\n  desired_acceleration << desired_angular_acceleration, attitude_thrust_reference_.tail<1>();\n\n  // Calculate the rotor velocities\n  *rotor_velocities = rotor_velocities_.cwiseProduct(desired_acceleration);\n\n  // Ensure the rotor velocities are at least one\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    if ((*rotor_velocities)[i] < 1) {\n      (*rotor_velocities)[i] = 1;\n    }\n  }\n\n  // Take the square root of each component\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 55.95704866672923}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd input(6);\n  input << angular_acceleration, control_attitude_thrust_reference_;\n\n  *rotor_velocities = rotor_thrust_to_velocity_ * input;\n\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    if ((*rotor_velocities)[i] < 1.0) {\n      (*rotor_velocities)[i] = 1.0;\n    }\n    (*rotor_velocities)[i] = sqrt((*rotor_velocities)[i]);\n  }\n}", "CodeBleu_score": 53.67697339355493}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\tstart_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    sliced_obj = copy.deepcopy(self)\n    sliced_obj.time = self.time[start_index:end_index]\n    sliced_obj.value = self.value[start_index:end_index]\n    sliced_obj.uncertainty = self.uncertainty[start_index:end_index]\n    return sliced_obj", "CodeBleu_score": 31.325223865117398}, {"code": "def slice(self, start_time, end_time)\n\t# Find the indices for the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Slice each attribute\n    sliced_object.time = self.time[start_index:end_index]\n    sliced_object.value = self.value[start_index:end_index]\n\n    # Return the sliced object\n    return sliced_object\n\n", "CodeBleu_score": 32.97337211632296}, {"code": "def slice(self, start_time, end_time)\n\t# Find the indices corresponding to the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # Create a copy of the object\n    new_object = deepcopy(self)\n    # Update each attribute of the copied object to contain only the sliced data\n    new_object.time = self.time[start_index:end_index]\n    new_object.x = self.x[start_index:end_index]\n    new_object.y = self.y[start_index:end_index]\n    new_object.z = self.z[start_index:end_index]\n    return new_object\n", "CodeBleu_score": 29.459664296195438}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t# Extract position and rotation\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    yaw = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])[2]\n    # Create Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if current waypoint is different from the last one\n    if point != self.last_point or yaw != self.last_yaw:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n        # Update last point and yaw\n        self.last_point = point\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 29.69177080739244}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tposition = waypoint_msg.pose.pose.position\n    orientation = waypoint_msg.pose.pose.orientation\n    yaw = euler_from_quaternion(orientation.x, orientation.y, orientation.z, orientation.w)[2]\n    point = Point(position.x, position.y, position.z)\n    if not self.last_point or self.last_point != point or self.last_yaw != yaw:\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n        self.last_point = point\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 20.236336164022152}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tposition = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    yaw = euler_from_quaternion(\n        [rotation.x, rotation.y, rotation.z, rotation.w])[2]\n    point = Point(position.x, position.y, position.z)\n    if point != self.last_point or yaw != self.last_yaw:\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)\n        self.last_point = point\n        self.last_yaw = yaw\n\n", "CodeBleu_score": 30.20373437806696}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == self.imu_topics[0]:\n        self.imu_accel_x.append_times(msg.linear_acceleration.x, bag_time)\n    elif topic == self.imu_topics[1]:\n        self.imu_accel_y.append_times(msg.linear_acceleration.y, bag_time)\n    elif topic == self.imu_topics[2]:\n        self.imu_accel_z.append_times(msg.linear_acceleration.z, bag_time)\n\n", "CodeBleu_score": 22.6121865745509}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == self.imu_topic_1:\n        self.imu_1.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.imu_1.x = numpy.append(self.imu_1.x, msg.linear_acceleration.x)\n        self.imu_1.y = numpy.append(self.imu_1.y, msg.linear_acceleration.y)\n        self.imu_1.z = numpy.append(self.imu_1.z, msg.linear_acceleration.z)\n    elif topic == self.imu_topic_2:\n        self.imu_2.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.imu_2.x = numpy.append(self.imu_2.x, msg.linear_acceleration.x)\n        self.imu_2.y = numpy.append(self.imu_2.y, msg.linear_acceleration.y)\n        self.imu_2.z = numpy.append(self.imu_2.z, msg.linear_acceleration.z)\n    elif topic == self.imu_topic_3:\n        self.imu_3.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.imu_3.x = numpy.append(self.imu_3.x, msg.linear_acceleration.x)\n        self.imu_3.y = numpy.append(self.imu_3.y, msg.linear_acceleration.y)\n        self.imu_3.z = numpy.append(self.imu_3.z, msg.linear_acceleration.z)\n    elif topic == self.imu_topic_4:\n        self.imu_4.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.imu_4.x = numpy.append(self.imu_4.x, msg.linear_ac", "CodeBleu_score": 29.36253042425423}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == \"/imu_raw\":\n        self.acceleration.x = numpy.append(self.acceleration.x, msg.linear_acceleration.x)\n        self.acceleration.y = numpy.append(self.acceleration.y, msg.linear_acceleration.y)\n        self.acceleration.z = numpy.append(self.acceleration.z, msg.linear_acceleration.z)\n        self.acceleration.append_times(msg.header.stamp.to_sec(), bag_time)\n    elif topic == \"/imu_raw_2\":\n        self.acceleration2.x = numpy.append(self.acceleration2.x, msg.linear_acceleration.x)\n        self.acceleration2.y = numpy.append(self.acceleration2.y, msg.linear_acceleration.y)\n        self.acceleration2.z = numpy.append(self.acceleration2.z, msg.linear_acceleration.z)\n        self.acceleration2.append_times(msg.header.stamp.to_sec(), bag_time)\n    elif topic == \"/imu_raw_3\":\n        self.acceleration3.x = numpy.append(self.acceleration3.x, msg.linear_acceleration.x)\n        self.acceleration3.y = numpy.append(self.acceleration3.y, msg.linear_acceleration.y)\n        self.acceleration3.z = numpy.append(self.acceleration3.z, msg.linear_acceleration.z)\n        self.acceleration3.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 27.65675769490869}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\tfig = plt.figure()\n    fig.suptitle(self.title)\n    ax = fig.add_subplot(1, 1, 1)\n    for accel_data in self.accelerations:\n        ax.plot(accel_data.time, accel_data.x, label=accel_data.label + \" x\")\n        ax.plot(accel_data.time, accel_data.y, label=accel_data.label + \" y\")\n        ax.plot(accel_data.time, accel_data.z, label=accel_data.label + \" z\")\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (g)\")\n    ax.legend()\n    if self.save_plots:\n        filename = self.plot_prefix + \"-accelerations\"\n        if plot_suffix is not None:\n            filename += \"-\" + plot_suffix\n        filename += \".png\"\n        fig.savefig(filename)\n    plt.show()\n    plt.close(fig)\n\n", "CodeBleu_score": 37.06755470967361}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Create a figure with a title and a subplot for accelerations.\n    fig = plt.figure(figsize=(10, 6))\n    fig.suptitle('Accelerations')\n    ax = fig.add_subplot(111)\n\n    # Plot the x, y, and z components over time with different colors and labels.\n    ax.plot(self.time, self.accelerations_x, label='x', color='red')\n    ax.plot(self.time, self.accelerations_y, label='y', color='green')\n    ax.plot(self.time, self.accelerations_z, label='z', color='blue')\n\n    # Add labels for the x and y axes.\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Include a legend.\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file.\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        plot_filename = 'accelerations' + plot_suffix + '.png'\n        plot_filename = os.path.join(self.plots_dir, plot_filename)\n        plt.savefig(plot_filename)\n\n    # Show the plot.\n    plt.show()\n\n", "CodeBleu_score": 38.44475432336502}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Plot accelerations\n    fig = plt.figure()\n    fig.suptitle('Accelerations')\n    ax = fig.add_subplot(1, 1, 1)\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Plot the x, y, and z components of each acceleration dataset\n    for accel_data in self.accelerations:\n        ax.plot(accel_data['time'], accel_data['x'], label='x')\n        ax.plot(accel_data['time'], accel_data['y'], label='y')\n        ax.plot(accel_data['time'], accel_data['z'], label='z')\n\n    # Add a legend and save the figure\n    ax.legend()\n    if self.save_plots:\n        filename = self.plot_prefix + '_accelerations'\n        if plot_suffix:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        fig.savefig(filename)", "CodeBleu_score": 37.17867822652151}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Implement this function\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for collision in self.wrench:\n        if start_time is None and end_time is None:\n            collision_times.append(collision.time)\n        elif start_time is not None and end_time is not None:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None:\n            if start_time <= collision.time:\n                collision_times.append(collision.time)\n        elif end_time is not None:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            raise ValueError(\"Both start_time and end_time cannot be None.\")\n    return collision_times\n\n", "CodeBleu_score": 39.43426353929799}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for collision in self.wrench:\n        if start_time is None and end_time is None:\n            collision_times.append(collision.time)\n        elif start_time is not None and end_time is not None:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None and end_time is None:\n            if start_time <= collision.time:\n                collision_times.append(collision.time)\n        elif start_time is None and end_time is not None:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n    return collision_times\n\n\n\n", "CodeBleu_score": 39.15373720476465}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n\n    for collision in self.wrench:\n        if start_time < collision[0] < end_time:\n            collision_times.append(collision[0])\n\n    return collision_times\n\n", "CodeBleu_score": 34.46190757629863}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])", "CodeBleu_score": 87.43368823459195}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {\n    return;\n  }\n  const float multiplier = 1.0f / this->GetMultiplier(width, height);\n  Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic,\n                           Eigen::RowMajor>>\n      data_map(data, height, width);\n  const float rms_noise = this->GetRMSNoise(width, height);\n  const float noise_values = this->GetNoiseValues(width, height);\n  for (uint32_t i = 0; i < height; i++) {\n    for (uint32_t j = 0; j < width; j++) {\n      float depth = data_map(i, j);\n      if (this->InRange(depth)) {\n        depth += (rms_noise * multiplier) *\n                 (rand() / static_cast<float>(RAND_MAX)) -\n                 (noise_values * multiplier);\n        data_map(i, j) = depth;\n      } else {\n        data_map(i, j) = BAD_POINT;\n      }\n    }\n  }\n}", "CodeBleu_score": 44.540316541321864}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check for null pointer\n  if (data == nullptr) {\n    return;\n  }\n\n  // Compute multiplier\n  const float multiplier = this->ComputeMultiplier(width, height);\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_map(data, width * height);\n\n  // Compute RMS noise and noise values\n  const float rms_noise = this->ComputeRMSNoise(multiplier);\n  const float noise_values = this->ComputeNoiseValues(multiplier, rms_noise);\n\n  // Add noise to data\n  for (uint32_t i = 0; i < data_map.size(); i++) {\n    if (this->InRange(data_map(i))) {\n      data_map(i) += noise_values;\n    } else {\n      data_map(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 46.39743540186208}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n\n  // Calculate multiplier\n  float multiplier = (this->max_depth - this->min_depth) / 1000.0f;\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>> eigen_data(data, width * height);\n\n  // Calculate RMS noise\n  float rms_noise = this->noise_factor * multiplier;\n\n  // Calculate noise values\n  Eigen::Matrix<float, Eigen::Dynamic, 1> noise_values =\n      eigen_data.unaryExpr([this, &multiplier](float x) {\n        return this->rng_.RandGaussianAsymmetric(0.0f, this->noise_factor * multiplier);\n      });\n\n  // Add noise to data\n  eigen_data += noise_values;\n\n  // Set bad points\n  eigen_data = eigen_data.unaryExpr([this](float x) {\n    return this->InRange(x) ? x : this->bad_point;\n  });\n}", "CodeBleu_score": 36.683216694245374}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time\n  common::Time sim_time = this->world->GetSimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time;\n  ros_time.sec = sim_time.sec;\n  ros_time.nsec = sim_time.nsec;\n\n  // Write the trajectory message to a bag file using the specified namespace and waypoint topic\n  this->bag.write(this->ns + this->waypoint_topic, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 49.16985032836905}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time.\n  common::Time sim_time = world_->GetSimTime();\n\n  // Convert simulation time to ROS time.\n  ros::Time ros_time = ros::Time(sim_time.sec, sim_time.nsec);\n\n  // Write the trajectory message to a bag file using the specified namespace and waypoint topic.\n  bag_.write(namespace_ + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 61.13654296443034}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time\n  gazebo::common::Time gz_time_now = this->world_->GetSimTime();\n  // Convert simulation time to ROS time\n  ros::Time ros_time_now = gazebo::convert<ros::Time>(gz_time_now);\n\n  // Write the trajectory message to the bag file\n  this->bag_.write(this->waypoint_topic_, ros_time_now, *trajectory_msg);\n}", "CodeBleu_score": 44.928692531486305}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert simulation time to ROS time\n  ros::Time time_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare message for motor velocities\n  mav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators);\n\n  // Set the timestamp\n  actuator_msg->header.stamp = time_now;\n\n  // Iterate through the motor joints\n  for (int i = 0; i < this->motor_joints_.size(); i++) {\n\n    // Get the current joint velocity\n    double joint_velocity = this->motor_joints_[i]->GetVelocity(0);\n\n    // Slow down the joint velocity to 1/2 of its maximum value\n    double slowed_velocity = joint_velocity / 2;\n\n    // Assign the slowed-down joint velocity to the message\n    actuator_msg->angular_velocities.push_back(slowed_velocity);\n\n  }\n\n  // Write the message to the bag file using the specified namespace and motor topic\n  this->motor_velocity_bag_.write(this->motor_velocity_topic_, time_now, *actuator_msg);\n\n}", "CodeBleu_score": 42.9237672018672}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert the Gazebo time to ROS time\n  ros::Time time_now = ros::Time::now();\n\n  // Prepare a message for the motor velocities\n  mav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators);\n  actuator_msg->header.stamp = time_now;\n  actuator_msg->header.frame_id = namespace_;\n\n  // Iterate through the motor joints\n  for (int i = 0; i < rotor_joints_.size(); i++) {\n    // Calculate the slowed-down rotational velocities\n    double rotor_velocity = rotor_joints_[i]->GetVelocity(0) / slow_down_;\n\n    // Assign the velocities to the message\n    actuator_msg->angular_velocities.push_back(rotor_velocity);\n  }\n\n  // Write the data to a bag file\n  motor_velocities_pub_.publish(actuator_msg);\n}", "CodeBleu_score": 40.60238328909269}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert simulation time to ROS time\n\tros::Time sim_time = ros::Time(now.sec, now.nsec);\n\tros::Time ros_time = sim_time + ros_start_time_;\n\n\t// Prepare message\n\tmav_msgs::ActuatorsPtr actuators_msg(new mav_msgs::Actuators);\n\tactuators_msg->header.stamp = ros_time;\n\n\t// Iterate through motors\n\tfor (int i = 0; i < n_rotors_; i++) {\n\t\t// Calculate slowed-down rotational velocity\n\t\tdouble vel = rotor_velocities_[i];\n\t\tif (slow_motors_down_) {\n\t\t\tvel = rotor_velocities_[i] * rotor_slowdown_sim_;\n\t\t}\n\n\t\t// Assign velocity to message\n\t\tactuators_msg->angular_velocities.push_back(vel);\n\t}\n\n\t// Write message to bag file\n\tmotor_velocities_pub_.publish(actuators_msg);\n}", "CodeBleu_score": 38.120115745311494}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t// Print debug message\n  if (debug_print_) {\n    std::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called.\" << std::endl;\n  }\n\n  // Convert normalized input values to control surface angles\n  aileron_left_angle_ = NormalizedInputToAngle(aileron_left_, roll_pitch_yawrate_thrust_msg->roll);\n  aileron_right_angle_ = NormalizedInputToAngle(aileron_right_, -roll_pitch_yawrate_thrust_msg->roll);\n  elevator_angle_ = NormalizedInputToAngle(elevator_, roll_pitch_yawrate_thrust_msg->pitch);\n  rudder_angle_ = NormalizedInputToAngle(rudder_, -roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set throttle\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust;\n}", "CodeBleu_score": 45.653832489557814}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_printing_) {\n    gzdbg << __FUNCTION__ << \" called.\" << std::endl;\n  }\n\n  // Convert normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  double aileron_angle = NormalizedInputToAngle(surfaces_[kAileron],\n                                               roll_pitch_yawrate_thrust_msg->roll());\n  double elevator_angle = NormalizedInputToAngle(surfaces_[kElevator],\n                                                roll_pitch_yawrate_thrust_msg->pitch());\n  double rudder_angle = NormalizedInputToAngle(surfaces_[kRudder],\n                                              roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Set the control surface angles and throttle.\n  SetControlSurfaceAngles(aileron_angle, elevator_angle, rudder_angle);\n  SetThrottle(throttle);\n}", "CodeBleu_score": 53.20718600271339}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t// Log that the callback was called.\n  if (debug_print_) {\n    std::cout << \"RollPitchYawrateThrustCallback called.\" << std::endl;\n  }\n\n  // Convert normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  aileron_left_control_surface_.deflection = NormalizedInputToAngle(aileron_left_control_surface_, roll_pitch_yawrate_thrust_msg->roll);\n  aileron_right_control_surface_.deflection = NormalizedInputToAngle(aileron_right_control_surface_, roll_pitch_yawrate_thrust_msg->roll);\n  elevator_control_surface_.deflection = NormalizedInputToAngle(elevator_control_surface_, roll_pitch_yawrate_thrust_msg->pitch);\n  rudder_control_surface_.deflection = NormalizedInputToAngle(rudder_control_surface_, roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set the throttle value from the thrust message.\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust;\n}", "CodeBleu_score": 47.985591847111586}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t// poll\n  struct timeval timeout;\n  fd_set fds;\n  int ret;\n\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000UL;\n\n  FD_ZERO(&fds);\n  FD_SET(STDIN_FILENO, &fds);\n\n  ret = select(STDIN_FILENO + 1, &fds, NULL, NULL, &timeout);\n\n  if (ret > 0) {\n    // input available\n    char c;\n    int i = 0;\n    while (read(STDIN_FILENO, &c, 1) > 0 && i < _dt * 1e6) {\n      i++;\n      switch (mavlink_parse_char(MAVLINK_COMM_0, c, &last_message_, &status_)) {\n        case MAVLINK_FRAMING_INCOMPLETE:\n          break;\n        case MAVLINK_OK:\n          handle_message(&last_message_);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n}", "CodeBleu_score": 51.27152358961009}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t// Poll sockets.\n  struct timeval tv;\n  tv.tv_sec = 0;\n  tv.tv_usec = _timeoutMs * 1000;\n\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(STDIN_FILENO, &fds);\n  FD_SET(_fd, &fds);\n\n  int ret = select(_fd + 1, &fds, nullptr, nullptr, &tv);\n\n  if (ret == -1) {\n    gzerr << \"Failed to select on sockets \n\";\n  }\n\n  if (ret > 0) {\n    // Receive UDP packets from QGC\n    if (FD_ISSET(_fd, &fds)) {\n      int len = recvfrom(_fd, _buf, sizeof(_buf), 0,\n                         (struct sockaddr*)&srcaddr_, &addrlen_);\n      if (len > 0) {\n        mavlink_message_t msg;\n        mavlink_status_t status;\n\n        for (unsigned i = 0; i < len; ++i) {\n          if (mavlink_parse_char(MAVLINK_COMM_0, _buf[i], &msg, &status)) {\n            handle_message(&msg);\n          }\n        }\n      }\n    }\n\n    // Receive TCP data from QGC\n    if (FD_ISSET(STDIN_FILENO, &fds)) {\n      int len = read(STDIN_FILENO, _buf, sizeof(_buf));\n      if (len > 0) {\n        mavlink_message_t msg;\n        mavlink_status_t status;\n\n        for (unsigned i = 0; i < len; ++i) {\n          if (mavlink_parse_char(MAVLINK_COMM_0, _buf[i], &msg, &status)) {\n            handle_message(&msg);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 61.05314430941806}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t// poll for messages\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000UL;\n\n  struct timeval tv_start, tv_end;\n  gettimeofday(&tv_start, nullptr);\n\n  // XXX: This is a hack to get around the fact that the QNX\n  // implementation of poll() cannot be interrupted.\n  // This may lead to problems if the timeout is too small.\n  // If there is no data within the timeout, this will return\n  // immediately.\n  while (true) {\n    fd_set fds;\n    FD_ZERO(&fds);\n    FD_SET(_fd, &fds);\n\n    int ret = select(_fd + 1, &fds, nullptr, nullptr, &tv);\n\n    if (ret == -1 && errno != EINTR) {\n      gzerr << \"poll error", "CodeBleu_score": 36.69466904808945}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\tstd::lock_guard<std::mutex> lock(mutex);\n  if (this->is_open) {\n    this->is_open = false;\n    this->io_service.stop();\n    this->serial_dev.close();\n    if (this->io_thread.joinable()) {\n      this->io_thread.join();\n    }\n  }\n}", "CodeBleu_score": 34.46869426740423}, {"code": "void GazeboMavlinkInterface::close() {\n\t// Lock the mutex\n  std::lock_guard<std::mutex> lock(mutex);\n\n  // Check if the interface is open\n  if (!is_open) {\n    return;\n  }\n\n  // Stop the I/O service\n  io_service.stop();\n\n  // Close the serial device\n  serial_dev.close();\n\n  // If the I/O thread is joinable, join it to clean up resources\n  if (io_thread.joinable()) {\n    io_thread.join();\n  }\n\n  // Set the open flag to false\n  is_open = false;\n}", "CodeBleu_score": 60.9473699277465}, {"code": "void GazeboMavlinkInterface::close() {\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n  if (!is_open) {\n    return;\n  }\n\n  io_service.stop();\n  serial_dev.close();\n\n  if (io_thread.joinable()) {\n    io_thread.join();\n  }\n\n  is_open = false;\n}", "CodeBleu_score": 61.03460506545265}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x,\n    double y,\n    double z,\n    double x1,\n    double y1,\n    double z1,\n    double x2,\n    double y2,\n    double z2,\n    double x3,\n    double y3,\n    double z3\n}", "CodeBleu_score": 13.00978205624674}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t//! [LinearInterpolation]\n    //! [LinearInterpolation_1]\n    //! [LinearInterpolation_2]\n    //! [LinearInterpolation_3]\n    //! [LinearInterpolation_4]\n    //! [LinearInterpolation_5]\n    //! [LinearInterpolation_6]\n    //! [LinearInterpolation_7]\n    //! [LinearInterpolation_8]\n    //! [LinearInterpolation_9]\n    //! [LinearInterpolation_10]\n    //! [LinearInterpolation_11]\n    //! [LinearInterpolation_12]\n    //! [LinearInterpolation_13]\n    //! [LinearInterpolation_14]\n    //! [LinearInterpolation_15]\n    //! [LinearInterpolation_16]\n    //! [LinearInterpolation_17]\n    //! [LinearInterpolation_18]\n    //! [LinearInterpolation_19]\n    //! [LinearInterpolation_20]\n    //! [LinearInterpolation_21]\n    //! [LinearInterpolation_22]\n    //! [LinearInterpolation_23]\n    //! [LinearInterpolation_24]\n    //! [LinearInterpolation_25]\n    //! [LinearInterpolation_26]\n    //! [LinearInterpolation_27]\n    //! [LinearInterpolation_28]\n    //! [LinearInterpolation_29]\n    //! [LinearInterpolation_30]\n    //! [LinearInterpolation_31]\n    //! [LinearInterpolation_32]\n    //! [LinearInterpolation_33]\n    //! [LinearInterpolation_34]\n    //! [LinearInterpolation_35]\n    //! [LinearInterpolation_36]\n    //! [LinearInterpolation_37]\n    //! [LinearInterpolation_38]\n    //! [LinearInterpolation_39]\n    //! [", "CodeBleu_score": 4.221251991922846}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\tif (time != _time) {\n\t\ttime = _time;\n\t\tif (looping) {\n\t\t\tif (time < 0.0) {\n\t\t\t\ttime += (int)(time / length) * length;\n\t\t\t}\n\t\t\tif (time > length) {\n\t\t\t\ttime -= (int)(time / length) * length;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (time < 0.0) {\n\t\t\t\ttime = 0.0;\n\t\t\t}\n\t\t\tif (time > length) {\n\t\t\t\ttime = length;\n\t\t\t}\n\t\t}\n\t\tUpdate();\n\t}\n}", "CodeBleu_score": 36.76018268328923}, {"code": "void Animation::SetTime(double _time){\n\tif (time != _time) {\n\t\ttime = _time;\n\t\tif (looping) {\n\t\t\ttime = fmod(time, length);\n\t\t\tif (time < 0.0)\n\t\t\t\ttime += length;\n\t\t}\n\t\telse {\n\t\t\tif (time < 0.0)\n\t\t\t\ttime = 0.0;\n\t\t\telse if (time > length)\n\t\t\t\ttime = length;\n\t\t}\n\t\tUpdate();\n\t}\n}", "CodeBleu_score": 36.536069682566215}, {"code": "void Animation::SetTime(double _time){\n\tif (_time != time) {\n\t\ttime = _time;\n\t\tif (looping) {\n\t\t\ttime = fmod(time, length);\n\t\t\tif (time < 0.0) {\n\t\t\t\ttime += length;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (time < 0.0) {\n\t\t\t\ttime = 0.0;\n\t\t\t}\n\t\t\telse if (time > length) {\n\t\t\t\ttime = length;\n\t\t\t}\n\t\t}\n\t\tUpdate();\n\t}\n}", "CodeBleu_score": 36.935604043620486}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.local_position.pose.position.x, y=self.local_position.pose.position.y, z=self.local_position.pose.position.z, yaw=self.local_position.pose.orientation.yaw)\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n", "CodeBleu_score": 63.603830343279164}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_raw_pose = self.construct_target(x=self.local_pose.pose.position.x, y=self.local_pose.pose.position.y, z=self.local_pose.pose.position.z, yaw=self.euler_from_quaternion(self.local_pose.pose.orientation)[2])\n    print(\"Vehicle Type:\", self.vehicle_type, \"Vehicle ID:\", self.vehicle_id, \"Flight Mode:\", self.flight_mode)\n", "CodeBleu_score": 56.876368696954984}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(self.local_position.pose.position.x, self.local_position.pose.position.y, self.local_position.pose.position.z, 0, 0, 0, 0, 0, 0, self.local_position.pose.orientation.yaw, 0)\n    self.set_target(target_raw_pose)\n    print(\"Vehicle type: {}", "CodeBleu_score": 53.081779716059565}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service(custom_mode=self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode changed to \"+self.flight_mode)\n            return True\n        except rospy.ServiceException:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Failed to change flight mode to \"+self.flight_mode)\n            return False\n\n", "CodeBleu_score": 56.88801861983698}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except rospy.ServiceException:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":Flight Mode Switch Failed\")\n            return False\n\n", "CodeBleu_score": 56.047463506122654}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+\"Flight mode switch failed\")\n            return False\n\n", "CodeBleu_score": 58.79488714494544}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\tif self.hover_flag == 0:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.flight_mode = 'OFFBOARD'\n            self.hover_flag = 1\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    else:\n        if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n            self.flight_mode = 'HOVER'\n            self.hover_flag = 0\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n\n", "CodeBleu_score": 60.23217757629713}, {"code": "def hover_state_transition(self, x, y, z, w)\n\tif x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n    elif self.flight_mode != 'HOVER' and self.hover_flag == 1:\n        self.flight_mode = 'HOVER'\n        self.hover()\n\n", "CodeBleu_score": 52.22074419791098}, {"code": "def hover_state_transition(self, x, y, z, w)\n\tif self.hover_flag == 0:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    elif self.hover_flag == 1:\n        if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.offboard()", "CodeBleu_score": 68.4575072277451}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        yaw = q.yaw()\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        yaw = q.yaw()\n    return yaw\n", "CodeBleu_score": 42.55278739119881}, {"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n\n", "CodeBleu_score": 16.806809161752323}, {"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 38.011354780892425}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\tself.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=0, y=0, z=0, yaw=0)\n    self.set_target(target_raw_pose)\n    print(\"Vehicle type:\", self.vehicle_type, \"Vehicle ID:\", self.vehicle_id, \"Flight mode:\", self.flight_mode)\n\n", "CodeBleu_score": 29.802515594532096}, {"code": "def hover(self)\n\tself.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.motion_type = 0\n\n    self.target_raw_pose = self.construct_target(x=0, y=0, z=0, yaw=self.current_yaw)\n    self.send_target_raw_pose()\n\n    print(self.vehicle_type + \" \" + self.vehicle_id + \" hovering\")\n\n", "CodeBleu_score": 35.1243016399416}, {"code": "def hover(self)\n\tself.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.motion_type = 0\n\n    self.vehicle_type = self.get_vehicle_type()\n    self.vehicle_id = self.get_vehicle_id()\n    self.flight_mode = self.get_flight_mode()\n\n    target_raw_pose = self.construct_target(x=self.local_position[0], y=self.local_position[1], z=self.local_position[2], yaw=self.local_position[3])\n    self.set_position_target_local_ned(target_raw_pose)\n\n    print(f\"Vehicle Type: {self.vehicle_type}\")\n    print(f\"Vehicle ID: {self.vehicle_id}\")\n    print(f\"Flight Mode: {self.flight_mode}\")\n\n", "CodeBleu_score": 32.156050809437595}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service call failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 54.76881581725822}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(0, self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service did not process request: \" + str(e))\n            return False\n\n", "CodeBleu_score": 47.209442454423645}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(0, self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service call failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 51.69527778082502}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.26923076876874}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.26923076876874}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n\n", "CodeBleu_score": 55.26923076876874}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\tif msg.index == i:\n        self.local_pose[i] = msg\n        if self.gcs_command[i] == 1:\n            self.takeoff_target_pose[i] = msg\n        if self.gcs_command[i] == 2:\n            self.hover_target_pose[i] = msg\n        self.global_pose[i].pose.position.x = msg.pose.position.x + self.pose_bias[i][0]\n        self.global_pose[i].pose.position.y = msg.pose.position.y + self.pose_bias[i][1]\n        self.global_pose[i].pose.position.z = msg.pose.position.z + self.pose_bias[i][2]\n        self.global_pose[i].pose.orientation = msg.pose.orientation\n\n\n", "CodeBleu_score": 31.127262481028346}, {"code": "def local_pose_callback(self, msg, i)\n\tif msg.index == i:\n        self.local_pose[i] = msg\n        if self.command[i] == 'takeoff':\n            self.takeoff_target_pose[i] = msg\n        elif self.command[i] == 'hover':\n            self.hover_target_pose[i] = msg\n        elif self.command[i] == 'land':\n            self.land_target_pose[i] = msg\n\n        self.global_pose[i].pose.position.x = msg.pose.position.x + self.bias[i][0]\n        self.global_pose[i].pose.position.y = msg.pose.position.y + self.bias[i][1]\n        self.global_pose[i].pose.position.z = msg.pose.position.z + self.bias[i][2]\n        self.global_pose[i].pose.orientation = msg.pose.orientation\n\n", "CodeBleu_score": 29.991246541818278}, {"code": "def local_pose_callback(self, msg, i)\n\tif msg.index == i:\n        self.local_pose[i] = msg\n        if self.gcs_command[i] == 1:\n            self.takeoff_target_pose[i] = msg\n        elif self.gcs_command[i] == 2:\n            self.hover_target_pose[i] = msg\n        elif self.gcs_command[i] == 3:\n            self.landing_target_pose[i] = msg\n        self.global_pose[i].pose.position.x = msg.pose.position.x + self.bias[i][0]\n        self.global_pose[i].pose.position.y = msg.pose.position.y + self.bias[i][1]\n        self.global_pose[i].pose.position.z = msg.pose.position.z + self.bias[i][2]\n        self.global_pose[i].pose.orientation = msg.pose.orientation\n        self.global_pose[i].header = msg.header\n\n", "CodeBleu_score": 28.788038550373486}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\tif self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.889133687930844}, {"code": "def takeoff_detection(self)\n\tif self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.889133687930844}, {"code": "def takeoff_detection(self)\n\tif self.local_position[2] > 0.2 and self.arming_state.armed:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 65.61048771074441}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t# Build a distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i, j] = int(50 - np.linalg.norm(orig_formation[i] - change_formation[j]))\n\n    return dist_matrix\n\n", "CodeBleu_score": 25.951225721006253}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t# construct a distance matrix\n    distance_matrix = []\n    # calculate the pairwise distances between UAVs in the original and changed formations using the Euclidean norm\n    for i in range(len(orig_formation)):\n        distance_row = []\n        for j in range(len(change_formation)):\n            distance = np.linalg.norm(np.array(orig_formation[i]) - np.array(change_formation[j]))\n            distance = 50 - distance\n            distance = int(distance)\n            distance_row.append(distance)\n        distance_matrix.append(distance_row)\n    return distance_matrix\n\n", "CodeBleu_score": 25.959355958443155}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t# build graph\n    graph = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            graph[i][j] = int(50 - np.linalg.norm(orig_formation[i] - change_formation[j]))\n    return graph\n\n", "CodeBleu_score": 26.45535286620791}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False", "CodeBleu_score": 53.39383775657488}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.39383775657488}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.39383775657488}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t# Initialize slack variables and visit arrays\n    self.slack_right = [0 for _ in range(self.num_right)]\n    self.visit_left = [False for _ in range(self.num_left)]\n    self.visit_right = [False for _ in range(self.num_right)]\n\n    # Iterate over UAVs\n    for i in range(self.num_left):\n        # Initialize slack variables and visit arrays\n        self.slack_right = [0 for _ in range(self.num_right)]\n        self.visit_left = [False for _ in range(self.num_left)]\n        self.visit_right = [False for _ in range(self.num_right)]\n\n        # Find path\n        self.find_path(i)\n\n    # Adjust labels and repeat\n    for i in range(self.num_left):\n        for j in range(self.num_right):\n            if self.visit_right[j]:\n                continue\n            self.label_right[j] += self.slack_right[j]\n    return self.match_right", "CodeBleu_score": 27.5452909879556}, {"code": "def KM(self)\n\tself.init_slack()\n    for i in range(self.num_left):\n        self.visit_left = [False] * self.num_left\n        self.visit_right = [False] * self.num_right\n        if self.find_path(i):\n            continue\n        self.update_label()\n        self.init_slack()\n    return self.match_right", "CodeBleu_score": 12.898817233658374}, {"code": "def KM(self)\n\tself.initialize_arrays()\n    for i, _ in enumerate(self.label_left, start=0):\n        self.initialize_slack_variables()\n        if not self.find_path(i):\n            self.adjust_labels()\n    return self.match_right\n\n", "CodeBleu_score": 9.102942638129697}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\timage = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask = mask)\n    return result\n", "CodeBleu_score": 26.844190465385303}, {"code": "def yellow_dectection(image)\n\t#convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    #define the yellow color range and create a mask\n    lower = np.array([20,100,100])\n    upper = np.array([50,255,255])\n    mask = cv2.inRange(hsv, lower, upper)\n\n    #apply the mask to the image\n    result = cv2.bitwise_and(image, image, mask = mask)\n\n    return result\n\n\n\n\n", "CodeBleu_score": 36.01421743890864}, {"code": "def yellow_dectection(image)\n\t# Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds of the yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([50, 255, 255])\n\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n\n", "CodeBleu_score": 30.535780286037383}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\tstd::map<unsigned int, StandaloneTagDescription>::const_iterator it = standalone_tag_descriptions_.find(id);\n  if (it == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN(\"Standalone tag description with ID %d not found.\", id);\n    }\n    return false;\n  }\n  descriptionContainer = it->second;\n  return true;\n}", "CodeBleu_score": 43.140126027777406}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tStandaloneTagDescription* descriptionContainer;\n\tbool printWarning;\n\tbool found;\n}", "CodeBleu_score": 0.8058907093932995}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t// Check if the tag description is in the map\n\tstd::map<int, TagDescription>::iterator it = standalone_tag_descriptions_.find(id);\n\tif (it == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tROS_WARN(\"Standalone tag description for ID %d was not found.\", id);\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Set the descriptionContainer to the tag's description\n\tdescriptionContainer = it->second;\n\treturn true;\n}", "CodeBleu_score": 43.92152570170303}]}
