{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\twhile (desc->bDescriptorType != USB_DESC_TYPE_INTERFACE) {\n\t\tif (desc->bDescriptorType == desc_id)\n\t\t\treturn desc;\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc +\n\t\t\t\tdesc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 35.13401554738119}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\twhile (desc->bDescriptorType != USB_DESC_TYPE_END) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 40.35734201266985}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\twhile (desc->bDescriptorType != USB_DESC_TYPE_INTERFACE_END) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc +\n\t\t\t\tdesc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 40.93685130411941}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tstruct usb_desc_header *desc;\n\tstruct usb_iface_desc *iface_desc;\n\tbool found = false;\n\tuint8_t iface_setting_num;\n\n\tif (!udc_device.config) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_device.config->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tdesc = (struct usb_desc_header *) udc_device.config;\n\twhile (desc) {\n\t\tif (desc->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tiface_desc = (struct usb_iface_desc *) desc;\n\t\t\tiface_setting_num = iface_desc->bAlternateSetting;\n\t\t\tif ((iface_desc->bInterfaceNumber == iface_num) && (iface_setting_num == setting_num)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdesc = (struct usb_desc_header *) ((uint32_t) desc + desc->bLength);\n\t}\n\n\treturn found;\n}", "CodeBleu_score": 40.259375980842535}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t// check if there is a valid configuration\n\tif (udc_config_desc == NULL) {\n\t\treturn false;\n\t}\n\t// check if the interface number is within bounds\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\t// get the beginning of the configuration descriptor\n\tuint8_t *conf_desc_start = (uint8_t *)udc_config_desc;\n\t// get the length of the configuration descriptor\n\tuint16_t conf_desc_len = udc_config_desc->wTotalLength;\n\t// iterate through the descriptors, starting from the beginning of the configuration descriptor\n\tuint8_t *desc_ptr = conf_desc_start;\n\twhile (desc_ptr < conf_desc_start + conf_desc_len) {\n\t\t// get the descriptor type\n\t\tuint8_t desc_type = desc_ptr[0];\n\t\t// check if the descriptor type is an interface descriptor\n\t\tif (desc_type == USB_DT_INTERFACE) {\n\t\t\t// get the interface number and setting number of the interface descriptor\n\t\t\tuint8_t desc_iface_num = desc_ptr[2];\n\t\t\tuint8_t desc_setting_num = desc_ptr[3];\n\t\t\t// check if the interface number and setting number match the specified interface number and setting number\n\t\t\tif ((desc_iface_num == iface_num) && (desc_setting_num == setting_num)) {\n\t\t\t\t// return true\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// get the length of the descriptor\n\t\tuint8_t desc_len = desc_ptr[0];\n\t\t// move the descriptor pointer forward by the length of the descriptor\n\t\tdesc_ptr += desc_len;\n\t}\n\t// return false\n\treturn false;\n}", "CodeBleu_score": 41.955259031660354}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tuint8_t\t\t\t\t\t*ptr = NULL;\n\tstruct usb_iface_desc\t*iface_desc = NULL;\n\t\n\tif (udc_config_desc == NULL) {\n\t\treturn false;\n\t}\n\t\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\t\n\tptr = (uint8_t *)udc_config_desc;\n\tptr += udc_config_desc->bLength;\n\t\n\twhile (ptr < (uint8_t *)udc_config_desc + udc_config_desc->wTotalLength) {\n\t\tiface_desc = (struct usb_iface_desc *)ptr;\n\t\tif (iface_desc->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tif (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tptr += iface_desc->bLength;\n\t}\n\t\n\treturn false;\n}", "CodeBleu_score": 43.56086952817184}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\tif (udd_g_ctrlreq.req.wLength != 2) {\n\t\treturn false;\n\t}\n\tudd_g_ctrlreq.payload[0] = (udd_ep_is_halted(udd_g_ctrlreq.req.wIndex & 0xFF) ? 1 : 0);\n\tudd_g_ctrlreq.payload[1] = 0;\n\tudd_g_ctrlreq.payload_size = 2;\n\treturn true;\n}", "CodeBleu_score": 36.97636192439327}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tif (udc_req.wLength != 2) {\n\t\treturn false;\n\t}\n\n\tuint8_t ep_num = udc_req.wIndex & 0x0F;\n\tuint8_t ep_status = 0;\n\n\tif (udc_req.wIndex & 0x80) {\n\t\tif (udc_ep_in_is_halted(ep_num)) {\n\t\t\tep_status = 1;\n\t\t}\n\t} else {\n\t\tif (udc_ep_out_is_halted(ep_num)) {\n\t\t\tep_status = 1;\n\t\t}\n\t}\n\n\tudc_payload_write((uint8_t *) &ep_status, 2);\n\n\treturn true;\n}", "CodeBleu_score": 32.49950466451662}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tif (udc_payload_len != 2) {\n        return false;\n    }\n    uint8_t ep = udc_payload[0] & 0x0f;\n    uint8_t status = 0;\n    if (udc_ep_is_halted(ep)) {\n        status = 1;\n    }\n    udc_payload[0] = status;\n    udc_payload[1] = 0;\n    return true;\n}", "CodeBleu_score": 32.77880744192272}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t// Check if the device is in a configured state\n\tif (USB_CONFIGURED != udc_device.state) {\n\t\tudc_stall_data();\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is valid\n\tif (udc_req.wIndex > udc_ptr_conf->desc->bNumInterfaces) {\n\t\tudc_stall_data();\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(udc_req.wIndex, 0)) {\n\t\tudc_stall_data();\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(udc_req.wIndex, udc_req.wValue)) {\n\t\tudc_stall_data();\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\treturn udc_ptr_iface->udi_api->setup(udc_req.bRequest,\n\t\t\tudc_req.bRequestType, udc_req.wValue, udc_req.wIndex,\n\t\t\tudc_req.wLength);\n}", "CodeBleu_score": 44.309139834054974}, {"code": "static bool udc_req_iface(void){\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\t// Check if the device is in a configured state\n\tif (USB_CONFIGURED != udc_device.status) {\n\t\treturn false;\n\t}\n\n\t// Get interface number and alternate setting number\n\tiface_num = udc_setup_req.wIndex & 0xFF;\n\tsetting_num = (udc_setup_req.wValue >> 8) & 0xFF;\n\n\t// Check if the interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\treturn udc_ptr_iface->udi_api->setup(&udc_setup_req);\n}", "CodeBleu_score": 53.70309434048857}, {"code": "static bool udc_req_iface(void){\n\tbool status;\n\tuint8_t iface_num;\n\n\tif (USB_CONFIGURED != udc_device.status) {\n\t\t// Device not configured\n\t\tudc_stall_data();\n\t\treturn false;\n\t}\n\n\tiface_num = udc_setup_received.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\t// Interface number not supported\n\t\tudc_stall_data();\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\t// Interface descriptor not found\n\t\tudc_stall_data();\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current setting\n\tif (!udc_update_iface_desc(iface_num, udc_device.configuration)) {\n\t\t// Interface descriptor not found\n\t\tudc_stall_data();\n\t\treturn false;\n\t}\n\n\t// Forward setup request to the UDI\n\tstatus = udc_ptr_iface->udi_api->setup(udc_setup_received.bRequest,\n\t\t\tudc_setup_received.bmRequestType,\n\t\t\tudc_setup_received.wValue,\n\t\t\tudc_setup_received.wIndex,\n\t\t\tudc_setup_received.wLength);\n\treturn status;\n}", "CodeBleu_score": 58.64958302241483}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\tudi_msc_b_cbw_invalid_field = false;\n  udi_msc_b_sense_key = 0;\n  udi_msc_b_sense_code = 0;\n  udi_msc_b_sense_qualifier = 0;\n  udi_msc_b_unit_attention = false;\n  udi_msc_b_msc_reset_running = false;\n  udi_msc_b_read_run = false;\n  udi_msc_b_write_run = false;\n  udi_msc_b_read_enable = false;\n  udi_msc_b_write_enable = false;\n  udi_msc_b_trans_req = false;\n  udi_msc_b_trans_running = false;\n  udi_msc_b_trans_error_flag = false;\n  udi_msc_b_cbw_error_flag = false;\n  udi_msc_b_sense_running = false;\n  udi_msc_b_sense_error_flag = false;\n  udi_msc_b_lun_state_sense = 0;\n  udi_msc_b_lun_state_read = 0;\n  udi_msc_b_lun_state_write = 0;\n  udi_msc_b_lun_state_init = 0;\n  udi_msc_b_lun_state_test = 0;\n  udi_msc_b_lun_state_prevent = 0;\n  udi_msc_b_lun_state_ready = 0;\n  udi_msc_b_lun_state_busy = 0;\n  udi_msc_b_lun_state_fail = 0;\n  udi_msc_b_lun_state_locked = 0;\n  udi_msc_b_lun_state_lba_supported = 0;\n  udi_msc_b", "CodeBleu_score": 12.312408266173854}, {"code": "bool udi_msc_enable(void){\n\tudi_msc_b_cbw_invalid_field = false;\n  udi_msc_b_sense_key = UDI_MSC_SENSE_KEY_NO_SENSE;\n  udi_msc_b_sense_code = UDI_MSC_ASC_NO_ADDITIONAL_SENSE;\n  udi_msc_b_sense_qualifier = UDI_MSC_ASCQ_NO_QUALIFIER;\n  udi_msc_b_state = UDI_MSC_STATE_CBW_WAIT;\n  udi_msc_b_lun = 0;\n  udi_msc_b_trans_req = false;\n  udi_msc_b_trans_running = false;\n  udi_msc_b_trans_block_rem = 0;\n  udi_msc_b_trans_block_size = 0;\n  udi_msc_b_trans_block_addr = 0;\n  udi_msc_b_trans_direction = TRA_READ;\n  udi_msc_b_trans_status = UDI_MSC_TRANS_STATUS_OK;\n  udi_msc_b_trans_reset = false;\n\n  // Get number of LUNs\n  udi_msc_b_lun_nb = udi_msc_lun_get_nb();\n  if (udi_msc_b_lun_nb == 0) {\n    return false;\n  }\n\n  // Check if one LUN is available\n  if (!udi_msc_lun_test_unit_ready(0)) {\n    return false;\n  }\n\n  // Unload all LUNs\n  for (udi_msc_b_lun = 0; udi_msc_b_lun < udi_msc_b_lun_nb; udi_msc_b_lun++) {\n    udi_msc_lun_unload_media(udi_msc_b_lun);\n  }\n\n  //", "CodeBleu_score": 44.5613104842074}, {"code": "bool udi_msc_enable(void){\n\tudi_msc_b_cbw_invalid_field = false;\n  udi_msc_b_sense_key = UDI_MSC_SENSE_NO_SENSE;\n  udi_msc_b_sense_code = UDI_MSC_SC_OK;\n  udi_msc_b_sense_ASC = 0;\n  udi_msc_b_sense_ASCQ = 0;\n  udi_msc_b_sense_valid = false;\n  udi_msc_b_state = UDI_MSC_STATE_CBW_WAIT;\n  udi_msc_b_trans_req = false;\n  udi_msc_b_trans_running = false;\n  udi_msc_b_trans_status = UDI_MSC_TRANS_STATUS_OK;\n  udi_msc_b_trans_tag = 0;\n  udi_msc_b_trans_lun = 0;\n  udi_msc_b_trans_length = 0;\n  udi_msc_b_trans_nb_block = 0;\n  udi_msc_b_trans_data_pos = 0;\n  udi_msc_b_trans_data_start = NULL;\n  udi_msc_b_trans_data_end = NULL;\n  udi_msc_b_trans_data_run = NULL;\n  udi_msc_b_trans_data_trans = NULL;\n  udi_msc_b_trans_data_rem = NULL;\n  udi_msc_b_trans_data_size = 0;\n  udi_msc_b_trans_data_check = NULL;\n  udi_msc_b_trans_data_check_ins = NULL;\n  udi_msc_b_trans_data_check_outs = NULL;\n  udi_msc_b_trans_data_check_size = 0;\n  udi_msc_b_trans_data_check_nb_block =", "CodeBleu_score": 27.45010721240686}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(ep);\n  // Check status of transfer\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Transfer aborted then wait a reset\n    udi_msc_reset_all();\n    return;\n  }\n  // Update sense data\n  udi_msc_sense_pass();\n  // Update residue\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 83.60353212001601}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tUNUSED(ep);\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Wait a reset recovery before continuing\n    udi_msc_reset_recovery();\n    return;\n  }\n  udi_msc_sense_pass();\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  udi_msc_csw_process();\n}", "CodeBleu_score": 83.03603657102995}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t// Check status of transfer\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Transfer aborted then wait a setup reset\n    udi_msc_reset_all();\n    return;\n  }\n  // Update sense data\n  udi_msc_clear_sense();\n  // Update data residue in CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 71.8633689346593}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t// Fill CSW\n  udi_msc_csw.dCSWSignature = CSW_SIGNATURE;\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n  udi_msc_csw.bCSWStatus = udi_msc_scsi_status;\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 56.99628094802679}, {"code": "static void udi_msc_csw_process(void){\n\t// Fill CSW\n  udi_msc_csw.dCSWSignature = CSW_SIGNATURE;\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n  udi_msc_csw.bCSWStatus = udi_msc_csw_status;\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 56.923703695044736}, {"code": "static void udi_msc_csw_process(void){\n\t// Check if there is a non-zero data residue\n  if (udi_msc_cbw.data_length) {\n    // Stall the next request on the appropriate endpoint\n    udd_ep_set_halt(udi_msc_cbw.bm_cbw_flags.direction ?\n            UDI_MSC_EP_IN : UDI_MSC_EP_OUT);\n  }\n\n  // Prepare the CSW\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.data_length);\n  udi_msc_csw.bCSWStatus = udi_msc_scsi_status;\n\n  // Send the CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 62.98104139404721}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t}", "CodeBleu_score": 10.474702755761884}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (usb_cdc_is_dtr_on(port) != b_enable) {\n        usb_cdc_set_dtr(port, b_enable);\n        if (b_enable) {\n            cancelReset();\n        } else {\n            if (usb_cdc_get_baud(port) == 1200) {\n                initiateReset();\n            }\n        }\n    }\n}", "CodeBleu_score": 40.81101983126288}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t// Update DTR status\n\tif (b_enable) {\n\t\tusb_device_cdc_dtr_enable[port] = true;\n\t} else {\n\t\tusb_device_cdc_dtr_enable[port] = false;\n\t}\n\n\t// Check if DTR rate is 1200\n\tif (usb_device_cdc_baud[port] == 1200) {\n\n\t\t// Check if DTR is disabled\n\t\tif (!b_enable) {\n\n\t\t\t// Schedule a delayed system reset\n\t\t\tusb_device_cdc_dtr_reset_timer[port] = 500;\n\t\t\tusb_device_cdc_dtr_reset_enable[port] = true;\n\n\t\t} else {\n\n\t\t\t// Cancel scheduled system reset\n\t\t\tusb_device_cdc_dtr_reset_enable[port] = false;\n\n\t\t}\n\n\t}\n\n}", "CodeBleu_score": 34.65628022692048}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\tswitch (USB_SetupRequest.bRequest) {\n\t\tcase REQ_GetReport:\n\t\t\tEndpoint_ClearSETUP();\n\n\t\t\t/* Write the report data to the control endpoint */\n\t\t\tEndpoint_Write_Control_Stream_LE(&keyboard_report_data, sizeof(keyboard_report_data));\n\t\t\tEndpoint_ClearOUT();\n\n\t\t\t/* Wait until the data has been sent to the host */\n\t\t\twhile (!(Endpoint_IsOUTReady())) {\n\t\t\t\tif (USB_DeviceState == DEVICE_STATE_Unattached)\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase REQ_SetReport:\n\t\t\tEndpoint_ClearSETUP();\n\n\t\t\t/* Wait until the LED report has been sent by the host */\n\t\t\twhile (!(Endpoint_IsOUTReceived())) {\n\t\t\t\tif (USB_DeviceState == DEVICE_STATE_Unattached)\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/* Read in the LED report from the host */\n\t\t\tEndpoint_Read_Control_Stream_LE(&keyboard_report_data, sizeof(keyboard_report_data));\n\t\t\tEndpoint_ClearOUT();\n\n\t\t\tEndpoint_ClearStatusStage();\n\n\t\t\tbreak;\n\t\tcase REQ_GetIdle:\n\t\t\tEndpoint_ClearSETUP();\n\n\t\t\t/* Write the current idle duration value to the control endpoint */\n\t\t\tEndpoint_Write_Control_Stream_LE(&keyboard_idle_duration, sizeof(keyboard_idle_duration));\n\t\t\tEndpoint_ClearIN();\n\n\t\t\t/* Wait until the idle value has been sent to the host */\n\t\t\twhile (!(Endpoint_IsINReady())) {\n\t\t\t\tif (USB_DeviceState == DEVICE_STATE_Unattached)\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase REQ_SetIdle:\n\t\t\tEndpoint_ClearSETUP();\n\n\t\t\t/* Read the idle value set by the host */", "CodeBleu_score": 25.051254316133676}, {"code": "bool usb_task_other_requests(void){\n\t// Vendor requests\n    if (USB_bmRequestType == 0x40) {\n        switch (USB_bRequest) {\n            case 0x04: // MSFT_VENDOR_CODE\n                if (USB_wValue == 0x0004) {\n                    USB_ControlRequest.wLength = sizeof(msft_compatible_id_descriptor);\n                    USB_ControlRequest.pData = (uint8_t*)&msft_compatible_id_descriptor;\n                    return true;\n                } else if (USB_wValue == 0x0005) {\n                    USB_ControlRequest.wLength = sizeof(msft_extended_properties_descriptor);\n                    USB_ControlRequest.pData = (uint8_t*)&msft_extended_properties_descriptor;\n                    return true;\n                }\n                break;\n            case 0x05: // MSFT_VENDOR_CODE\n                if (USB_wValue == 0x0004) {\n                    USB_ControlRequest.wLength = sizeof(msft_compatible_id_descriptor);\n                    USB_ControlRequest.pData = (uint8_t*)&msft_compatible_id_descriptor;\n                    return true;\n                } else if (USB_wValue == 0x0005) {\n                    USB_ControlRequest.wLength = sizeof(msft_extended_properties_descriptor);\n                    USB_ControlRequest.pData = (uint8_t*)&msft_extended_properties_descriptor;\n                    return true;\n                }\n                break;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 33.08584104761707}, {"code": "bool usb_task_other_requests(void){\n\tif (USB_SetupRequest.bmRequestType == 0x21) {\n        if (USB_SetupRequest.bRequest == 0x04) {\n            USB_ControlRequest.Header.DeviceAddress = USB_DeviceAddress;\n            USB_ControlRequest.Header.InterfaceNumber = 0;\n            USB_ControlRequest.Header.EndpointAddress = 0;\n            USB_ControlRequest.Header.Size = 0;\n            USB_ControlRequest.Header.RequestType = 0xA1;\n\n            USB_ControlRequest.Data = (void*)&USB_Descriptor_MSCompatibleID;\n            USB_ControlRequest.Size = USB_Descriptor_MSCompatibleID.Header.Size;\n            return true;\n        }\n        else if (USB_SetupRequest.bRequest == 0x05) {\n            USB_ControlRequest.Header.DeviceAddress = USB_DeviceAddress;\n            USB_ControlRequest.Header.InterfaceNumber = 0;\n            USB_ControlRequest.Header.EndpointAddress = 0;\n            USB_ControlRequest.Header.Size = 0;\n            USB_ControlRequest.Header.RequestType = 0xA1;\n\n            USB_ControlRequest.Data = (void*)&USB_Descriptor_MSExtendedProperties;\n            USB_ControlRequest.Size = USB_Descriptor_MSExtendedProperties.Header.Size;\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 28.334435765928777}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n\n\tif (nbyte == 0)\n\t\treturn;\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(0xFF);\n\t\tbuf[i] = spiRec();\n\t}\n\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 48.74490370966015}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tif (nbyte == 0) return;\n\n\tfor (uint16_t i = 0; i < nbyte - 1; i++) {\n\t\tbuf[i] = spiRec();\n\t}\n\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 48.70616449856848}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tif (nbyte == 0) return;\n  for (uint16_t i = 0; i < nbyte - 1; i++) {\n    spiSend(0XFF);\n    buf[i] = spiRec();\n  }\n  buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 54.228300275848284}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t// Get the address of the relocated interrupt vector table\n\tuint32_t *vectTable = (uint32_t *)SCB->VTOR;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Get the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = (pfnISR_Handler)(vectTable[irq + 16]);\n\n\t// Replace the current handler for the specified IRQ with the new handler\n\tvectTable[irq + 16] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original ISR handler\n\treturn oldHandler;\n}", "CodeBleu_score": 57.79121176512211}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n    uint32_t *vect = (uint32_t *)SCB->VTOR;\n\n    // Disable global interrupts\n    __disable_irq();\n\n    // Get the old handler\n    oldHandler = (pfnISR_Handler)vect[irq + 16];\n\n    // Replace the old handler with the new one\n    vect[irq + 16] = (uint32_t)newHandler;\n\n    // Enable global interrupts\n    __enable_irq();\n\n    // Return the old handler\n    return oldHandler;\n}", "CodeBleu_score": 58.24063166895323}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tuint32_t *vectorTable = (uint32_t *)SCB->VTOR;\n    uint32_t oldHandler;\n\n    // Disable global interrupts\n    __disable_irq();\n\n    // Get the old handler\n    oldHandler = vectorTable[irq + 16];\n\n    // Replace the old handler with the new handler\n    vectorTable[irq + 16] = (uint32_t)newHandler;\n\n    // Enable global interrupts\n    __enable_irq();\n\n    // Return the old handler\n    return (pfnISR_Handler)oldHandler;\n}", "CodeBleu_score": 55.01011928959787}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\tif (pending_rx_count > 0) {\n    return rx_buffer.buffer[rx_buffer.tail];\n  }\n  else {\n    return -1;\n  }\n}", "CodeBleu_score": 17.25000305576163}, {"code": "int MarlinSerialUSB::peek(){\n\tif (cdc_rx_buffer_head == cdc_rx_buffer_tail) return -1;\n  return cdc_rx_buffer[cdc_rx_buffer_tail];\n}", "CodeBleu_score": 14.953917454582141}, {"code": "int MarlinSerialUSB::peek(){\n\tuint8_t c;\n  if (cdc_rx_buffer_head == cdc_rx_buffer_tail) return -1;\n  c = cdc_rx_buffer[cdc_rx_buffer_tail];\n  return c;\n}", "CodeBleu_score": 21.933898662560182}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\tuint8_t c;\n\n  // If we have a pending character from the USART, then return it without\n  // trying to get a character from the USB interface.\n  if (MarlinSerialUSB::available()) {\n    c = MarlinSerialUSB::dtrState() ? MarlinSerialUSB::rx_buffer_index_read : MarlinSerialUSB::rx_buffer_index_write;\n    if (++MarlinSerialUSB::rx_buffer_index_read >= RX_BUFFER_SIZE)\n      MarlinSerialUSB::rx_buffer_index_read = 0;\n    return c;\n  }\n\n  // If the USB isn't configured, there's nothing more to do right now.\n  if (!usb_configuration) return -1;\n\n  // If we've already read all the bytes that the host sent, then we need to\n  // ask for more.  We do this by sending a \"receive\" request over USB.  When\n  // the host gets this request, it will send the data.  We don't request more\n  // bytes than we can store in the receive buffer.\n  if (rx_buffer_index_read == rx_buffer_index_write) {\n    if (rx_buffer_index_write == RX_BUFFER_SIZE) {\n      // Buffer is full, so we don't ask for more data.  This will cause the\n      // host to stop sending bytes.\n      usb_configuration = false;\n      return -1;\n    }\n    // We ask for more data by sending a \"receive\" request.\n    if (!usb_configuration) return -1;\n    usb_request_t *request = &rx_buffer_request;\n    request->bmRequestType = REQUEST_DEVICETOHOST | REQUEST_STANDARD | REQUEST_DATA;\n    request->bRequest = REQUEST_GETSTATUS;\n    request->wValue = 0;\n    request->wIndex = CDC_RX_ENDPOINT;\n    request->wLength = (rx_buffer_index_write < RX_BUFFER_SIZE) ? (RX_BUFFER_SIZE - rx_buffer", "CodeBleu_score": 37.71815954748335}, {"code": "int MarlinSerialUSB::read(){\n\tint c;\n  if (pending_rx_count) {\n    c = pending_rx_buffer[pending_rx_index];\n    --pending_rx_count;\n    if (++pending_rx_index >= TX_BUFFER_SIZE) pending_rx_index = 0;\n    return c;\n  }\n  if (!usb_configuration) return -1;\n  c = usb_serial_getchar();\n  if (c < 0) return -1;\n  if (emergency_parser.enabled) emergency_parser.update(static_cast<char>(c));\n  return c;\n}", "CodeBleu_score": 51.69741054199304}, {"code": "int MarlinSerialUSB::read(){\n\tuint8_t c;\n\n  // If we have a character waiting in the buffer, then return it without checking for any others.\n  if (rx_buffer_head != rx_buffer_tail) {\n    c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n    return c;\n  }\n\n  // If we don't have a character waiting, then check if the USB is configured and ready to read\n  if (!usb_configuration) return -1;\n\n  // If we are not online, then wait for the host to configure the device.\n  if (!usb_online) return -1;\n\n  // If there is no data waiting, then return now.\n  if (!usb_cdc_rx_ready()) return -1;\n\n  // Read the next character from the USB receive buffer and then return it.\n  c = usb_cdc_rx_get();\n  if (c == 0x08) c = '\\b';\n  if (c == 0x0A) c = '\n';\n  if (c == 0x0D) c = '\\r';\n  return c;\n}", "CodeBleu_score": 38.46754203631182}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\tif (pending_rx_length) return pending_rx_length;\n  return CDC_Device_BytesReceived(&USB_Serial_CDC_Interface);\n}", "CodeBleu_score": 31.761017479007148}, {"code": "int MarlinSerialUSB::available(){\n\tif (pending_count) return pending_count;\n  if (!usb_configuration) return 0;\n  return usb_available();\n}", "CodeBleu_score": 38.030590479037144}, {"code": "int MarlinSerialUSB::available(){\n\tif (cdc_rx_buffer_head == cdc_rx_buffer_tail) {\n    if (cdc_rx_buffer_overflowed) {\n      cdc_rx_buffer_overflowed = false;\n      return -1;\n    }\n    return 0;\n  }\n  return ((int)(SERIAL_BUFFER_SIZE + cdc_rx_buffer_head - cdc_rx_buffer_tail)) % SERIAL_BUFFER_SIZE;\n}", "CodeBleu_score": 26.08541492875608}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\twhile (size--) {\n    uint8_t c = ee_Read(pos);\n    if (writing) *value++ = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 65.53535771844292}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\twhile (size--) {\n    uint8_t c = ee_Read(pos);\n    if (writing) *value++ = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 65.53535771844292}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\twhile (size--) {\n    uint8_t c = ee_Read(pos, true);\n    if (writing) *value++ = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 64.67688112155147}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (WITHIN(pin, 0, MAX_PWM_IOPIN)) {\n    if (pin == 255) return; // Ignore pin 255, used for analogWrite(255, 0) to turn off all LEDs\n    if (value == 0) {\n      digitalWrite(pin, LOW);\n      return;\n    }\n    if (value == PWM_MAX_DUTY) {\n      digitalWrite(pin, HIGH);\n      return;\n    }\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n    }\n    else {\n      if (WITHIN(pin, 0, 15)) {\n        // Software PWM on GPIO0-GPIO15\n        if (pwm_soft_count == 0) {\n          // Start the timer if this is the first PWM pin used\n          timer_config_t config = {\n            .divider = 0,\n            .counter_en = TIMER_PAUSE,\n            .intr_type = TIMER_INTR_LEVEL,\n            .counter_dir = TIMER_COUNT_UP,\n            .auto_reload = 1,\n            .alarm_en = 0,\n            .alarm_val = 0\n          };\n          timer_init(TIMER_GROUP_0, TIMER_0, &config);\n          timer_set_counter_value(TIMER_GROUP_0, TIMER_0, 0);\n          timer_start(TIMER_GROUP_0, TIMER_0);\n        }\n        pwm_soft_count++;\n        pwm_soft[pin] = value;\n      }\n      else {\n        // Software PWM on GPIO16-GPIO33\n        if (pwm_soft_count2 == 0) {\n          // Start the timer if this is the first PWM pin used\n          timer_config_t config = {\n            .divider = 0", "CodeBleu_score": 46.059895081081656}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (WITHIN(pin, 0, MAX_PWM_IOPIN)) {\n    // Hardware PWM\n    if (get_pwm_channel(pin, freq, res) >= 0) {\n      ledcWrite(pin, value);\n      return;\n    }\n  }\n  // Software PWM\n  int8_t cid = get_sw_pwm_channel(pin);\n  if (cid >= 0) {\n    if (value == 0) {\n      // Disable software PWM\n      if (--sw_pwm_used <= 0) {\n        // Disable software PWM timer\n        timer1_disable();\n      }\n      sw_pwm_pin[cid] = 0;\n    }\n    else {\n      sw_pwm_pin[cid] = value;\n      if (sw_pwm_used++ == 0) {\n        // Enable software PWM timer\n        timer1_enable(freq);\n      }\n    }\n    return;\n  }\n  // No hardware or software PWM available\n  if (value == 0) return;\n  // Allocate a new software PWM slot\n  if (sw_pwm_used >= MAX_SW_PWM_CHANNELS) return;\n  sw_pwm_pin[sw_pwm_used] = value;\n  if (sw_pwm_used++ == 0) {\n    // Enable software PWM timer\n    timer1_enable(freq);\n  }\n}", "CodeBleu_score": 47.32755204908017}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (WITHIN(pin, 0, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      uint16_t v = value;\n      if (v > res) v = res;\n      ledcWrite(cid, v);\n    }\n    else\n      SERIAL_ECHOLNPAIR(\"analogWrite failed. No free PWM channels.\");\n  }\n}", "CodeBleu_score": 33.53271406310371}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\tstatic_assert(COUNT(servo_delays) == NUM_SERVOS, \"SERVO_DELAY_ARRAY_SIZE is not equal to the number of EEPROM servo positions.\");\n  if (attach(pin) >= 0) {\n    write(value);\n    safe_delay(servo_delays[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 55.10030104774381}, {"code": "void Servo::move(const int value){\n\tstatic_assert(COUNT(servo_delays) == NUM_SERVOS, \"SERVO_DELAY_ARRAY_SIZE is not equal to the number of E-Steppers.\");\n  if (attach(servo_index_to_pin[index])) {\n    write(value);\n    safe_delay(servo_delays[index]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 51.521387669536956}, {"code": "void Servo::move(const int value){\n\tstatic_assert(COUNT(servo_delays) == NUM_SERVOS, \"SERVO_DELAY_ARRAY_SIZE is not equal to the number of servos!\");\n  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delays[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 60.416767189840414}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\tuint32_t i;\n    uint32_t *buf = (uint32_t *)i2s_get_dma_buffer_pointer();\n    for (i = 0; i < 8; i++) {\n        uint32_t pin_mask = 1 << i;\n        if (pwm_mask & pin_mask) {\n            if (pwm_tick_count[i] == 0) {\n                if (pwm_state[i]) {\n                    pwm_state[i] = 0;\n                    pwm_tick_count[i] = pwm_duty_cycle[i];\n                } else {\n                    pwm_state[i] = 1;\n                    pwm_tick_count[i] = pwm_period - pwm_duty_cycle[i];\n                }\n            } else {\n                pwm_tick_count[i]--;\n            }\n            if (pwm_state[i]) {\n                buf[i2s_sample_pos] |= pin_mask;\n            } else {\n                buf[i2s_sample_pos] &= ~pin_mask;\n            }\n        }\n    }\n    i2s_sample_pos++;\n    if (i2s_sample_pos >= I2S_DMA_BUFFER_LENGTH) {\n        i2s_sample_pos = 0;\n    }\n}", "CodeBleu_score": 38.32070561688021}, {"code": "void i2s_push_sample(){\n\tstatic int16_t i2s_buffer_pos = 0;\n  static uint8_t i2s_buffer_count = 0;\n  static uint32_t i2s_buffer_next_tick = 0;\n  static uint32_t i2s_buffer_next_tick_us = 0;\n\n  // If the DMA buffer is full, wait until it is not full\n  while (i2s_buffer_count >= I2S_BUFFER_COUNT) {\n    ;\n  }\n\n  // If the next tick time has not yet arrived, wait until it does\n  while (micros() < i2s_buffer_next_tick_us) {\n    ;\n  }\n\n  // Update the next tick time\n  i2s_buffer_next_tick_us = i2s_buffer_next_tick;\n\n  // Increment the next tick time\n  i2s_buffer_next_tick += I2S_BUFFER_SAMPLE_TIME_US;\n\n  // If the next tick time is too far in the future, move it back to the current time\n  if (i2s_buffer_next_tick_us - micros() > I2S_BUFFER_SAMPLE_TIME_US * I2S_BUFFER_COUNT) {\n    i2s_buffer_next_tick_us = micros();\n    i2s_buffer_next_tick = i2s_buffer_next_tick_us + I2S_BUFFER_SAMPLE_TIME_US;\n  }\n\n  // Iterate through each pin\n  for (uint8_t pin = 0; pin < NUM_PINS; pin++) {\n    // If the pin has active PWM\n    if (pwm_info[pin].duty_cycle > 0) {\n      // If the pin's tick count is zero\n      if (pwm_info[pin].tick_count == 0) {\n        // Toggle the pin state\n        pwm_info[pin].state = !pwm_info[pin].state;\n\n        // Set the pin's tick count to its period", "CodeBleu_score": 25.498040206113178}, {"code": "void i2s_push_sample(){\n\tstatic uint8_t *sample_data = (uint8_t *)(0x3FFFC000);\n\tstatic uint32_t sample_count = 0;\n\tstatic uint32_t sample_idx = 0;\n\n\tfor (uint32_t i = 0; i < 8; i++) {\n\t\tif (pwm_pins[i].duty_cycle != 0) {\n\t\t\tif (pwm_pins[i].tick_count == 0) {\n\t\t\t\tif (pwm_pins[i].state == 0) {\n\t\t\t\t\tpwm_pins[i].state = 1;\n\t\t\t\t\tpwm_pins[i].tick_count = pwm_pins[i].duty_cycle;\n\t\t\t\t} else {\n\t\t\t\t\tpwm_pins[i].state = 0;\n\t\t\t\t\tpwm_pins[i].tick_count = pwm_pins[i].period - pwm_pins[i].duty_cycle;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpwm_pins[i].tick_count--;\n\t\t\t}\n\t\t}\n\t}\n\n\tsample_data[sample_idx] = (pwm_pins[0].state << 7) | (pwm_pins[1].state << 6) | (pwm_pins[2].state << 5) | (pwm_pins[3].state << 4) | (pwm_pins[4].state << 3) | (pwm_pins[5].state << 2) | (pwm_pins[6].state << 1) | (pwm_pins[7].state << 0);\n\n\tsample_idx++;\n\tif (sample_idx >= 16) {\n\t\tsample_idx = 0;\n\t}\n}", "CodeBleu_score": 26.31950608149679}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t count;\n\tif (timer_num == 0) {\n\t\tcount = TIMER0->TC;\n\t} else if (timer_num == 1) {\n\t\tcount = TIMER1->TC;\n\t} else if (timer_num == 2) {\n\t\tcount = TIMER2->TC;\n\t} else if (timer_num == 3) {\n\t\tcount = TIMER3->TC;\n\t} else {\n\t\tcount = 0;\n\t}\n\treturn count;\n}", "CodeBleu_score": 32.17007942963882}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t count;\n  switch (timer_num) {\n    case 0:\n      count = TIMER0->TCNT;\n      break;\n    case 1:\n      count = TIMER1->TCNT;\n      break;\n    case 2:\n      count = TIMER2->TCNT;\n      break;\n    case 3:\n      count = TIMER3->TCNT;\n      break;\n    default:\n      count = 0;\n      break;\n  }\n  return count;\n}", "CodeBleu_score": 30.9396496185732}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t timer_count = 0;\n    switch (timer_num) {\n        case 0:\n            timer_count = TIMER0->CNT;\n            break;\n        case 1:\n            timer_count = TIMER1->CNT;\n            break;\n        case 2:\n            timer_count = TIMER2->CNT;\n            break;\n        default:\n            break;\n    }\n    return timer_count;\n}", "CodeBleu_score": 32.07321288966802}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (uint16_t cnt = 0; cnt < size; cnt++) {\n    uint8_t c = eeprom_read_byte((uint8_t*)pos);\n    crc16(crc, &c, 1);\n    if (writing) value[cnt] = c;\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 60.3653672014264}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\n    uint8_t c = eeprom_read_byte((uint8_t *)pos);\n    crc16(crc, &c, 1);\n    if (writing) value[i] = c;\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 73.93734315065667}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (uint16_t cnt = 0; cnt < size; cnt++) {\n    uint8_t c = eeprom_read_byte((uint8_t*)pos);\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 58.45695400661275}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (hsd == NULL || src == NULL) {\n        return false;\n    }\n    for (int i = 0; i < 10; i++) {\n        if (HAL_SD_WriteBlocks(&hsd, (uint8_t *)src, block, 1, 100) == HAL_OK) {\n            return true;\n        }\n    }\n    printf(\"Error writing block %lu\n\", block);\n    return false;\n}", "CodeBleu_score": 33.94005550417849}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (hsd == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\tif (HAL_SD_WriteBlocks(hsd, (uint8_t *) src, block, 1, 1000) == HAL_OK) {\n\t\treturn true;\n\t}\n\tprintf(\"ERROR: Failed to write block %d\n\", block);\n\treturn false;\n}", "CodeBleu_score": 26.1884335045118}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (!sdioHandle) {\n\t\treturn false;\n\t}\n\tif (!src) {\n\t\treturn false;\n\t}\n\tint retries = 0;\n\tbool success = false;\n\twhile (retries < 10 && !success) {\n\t\tsuccess = SD_WriteBlock(sdioHandle, block, src, 512);\n\t\tif (!success) {\n\t\t\tretries++;\n\t\t}\n\t}\n\tif (!success) {\n\t\tprintf(\"ERROR: Failed to write block %d to SD card\n\", block);\n\t}\n\treturn success;\n}", "CodeBleu_score": 30.511301592535112}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TIMER_TEMP:\n      TEMP_TIMER_FREQUENCY = frequency;\n      TIMER_SET_PRESCALE(TEMP_TIMER, TEMP_TIMER_PRESCALE);\n      TIMER_SET_FREQUENCY(TEMP_TIMER, frequency);\n      TIMER_ATTACH_INTERRUPT(TEMP_TIMER, HAL_timer_interrupt);\n      TIMER_ENABLE_INTERRUPT(TEMP_TIMER);\n      TIMER_START(TEMP_TIMER);\n      break;\n    case TIMER_STEP:\n      STEP_TIMER_FREQUENCY = frequency;\n      TIMER_SET_PRESCALE(STEP_TIMER, STEP_TIMER_PRESCALE);\n      TIMER_SET_FREQUENCY(STEP_TIMER, frequency);\n      TIMER_ATTACH_INTERRUPT(STEP_TIMER, HAL_timer_interrupt);\n      TIMER_ENABLE_INTERRUPT(STEP_TIMER);\n      TIMER_START(STEP_TIMER);\n      break;\n    default:\n      ASSERT(false);\n      break;\n  }\n}", "CodeBleu_score": 32.56462859791711}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TIMER_TEMP:\n      HAL_timer_temp_start(frequency);\n      break;\n    case TIMER_STEP:\n      HAL_timer_step_start(frequency);\n      break;\n    default:\n      TERN_(HAS_TMC_SW_SERIAL, HAL_timer_tmc_start(timer_num, frequency));\n      break;\n  }\n}", "CodeBleu_score": 23.791181346578863}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TIMER_TEMP:\n      HAL_timer_init(TEMP_TIMER_NUM, TEMP_TIMER_PRESCALE);\n      HAL_timer_set_compare(TEMP_TIMER_NUM, TEMP_TIMER_CHANNEL, TEMP_TIMER_FREQUENCY / frequency);\n      HAL_timer_enable_compare_interrupt(TEMP_TIMER_NUM, TEMP_TIMER_CHANNEL);\n      HAL_timer_isr_prologue(TEMP_TIMER_NUM);\n      break;\n    #if HAS_STEP_TIMER\n      case TIMER_STEP:\n        HAL_timer_init(STEP_TIMER_NUM, STEP_TIMER_PRESCALE);\n        HAL_timer_set_compare(STEP_TIMER_NUM, STEP_TIMER_CHANNEL, STEP_TIMER_FREQUENCY / frequency);\n        HAL_timer_enable_compare_interrupt(STEP_TIMER_NUM, STEP_TIMER_CHANNEL);\n        HAL_timer_isr_prologue(STEP_TIMER_NUM);\n        break;\n    #endif\n    default:\n      ASSERT(false);\n  }\n}", "CodeBleu_score": 31.127955324630598}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\tif (access_started) {\n\t\treturn true;\n\t}\n\tif (access_starting) {\n\t\treturn false;\n\t}\n\taccess_starting = true;\n\taccess_started = false;\n\tif (access_mode == PERSISTENT_STORE_MODE_READ) {\n\t\tif (file_exists(filename)) {\n\t\t\tfile = fopen(filename, \"rb\");\n\t\t\tif (file) {\n\t\t\t\tfseek(file, 0, SEEK_END);\n\t\t\t\tint file_size = ftell(file);\n\t\t\t\tfseek(file, 0, SEEK_SET);\n\t\t\t\tif (file_size < size) {\n\t\t\t\t\tmemset(buffer, erase_value, size);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfread(buffer, 1, size, file);\n\t\t\t\t}\n\t\t\t\tfclose(file);\n\t\t\t\taccess_started = true;\n\t\t\t}\n\t\t}\n\t}\n\telse if (access_mode == PERSISTENT_STORE_MODE_WRITE) {\n\t\tfile = fopen(filename, \"wb\");\n\t\tif (file) {\n\t\t\tfclose(file);\n\t\t\taccess_started = true;\n\t\t}\n\t}\n\taccess_starting = false;\n\treturn access_started;\n}", "CodeBleu_score": 41.0817587731257}, {"code": "bool PersistentStore::access_start(){\n\t// Open the file\n\tif (!(file = SD.open(filename, O_READ))) {\n\t\treturn false;\n\t}\n\n\t// Check the file size\n\tif (file.fileSize() < size) {\n\t\t// If the file is smaller than the expected EEPROM size, fill the remainder of the buffer with a default erase value\n\t\tfor (uint16_t i = file.fileSize(); i < size; i++) {\n\t\t\tbuffer[i] = 0xFF;\n\t\t}\n\t} else {\n\t\t// If the file is of sufficient size, read the file's contents into the buffer\n\t\tfile.read(buffer, size);\n\t}\n\n\t// Close the file\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 21.49698005148189}, {"code": "bool PersistentStore::access_start(){\n\t// open the file\n\tif (!(file = fopen(filename, \"r+b\"))) {\n\t\treturn false;\n\t}\n\n\t// get the file size\n\tfseek(file, 0, SEEK_END);\n\tfile_size = ftell(file);\n\trewind(file);\n\n\t// if the file is smaller than the expected EEPROM size,\n\t// fill the remainder of the buffer with a default erase value\n\tif (file_size < EEPROM_SIZE) {\n\t\tmemset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n\t}\n\n\t// read the file contents into the buffer\n\tif (file_size > 0) {\n\t\tfread(buffer, 1, file_size, file);\n\t}\n\n\t// close the file\n\tfclose(file);\n\n\treturn true;\n}", "CodeBleu_score": 34.38141563401377}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tdigitalWrite(SPI_CLOCK_PIN, LOW);\n\t\tdigitalWrite(SPI_MOSI_PIN, (b & 0x80) ? HIGH : LOW);\n\t\tdigitalWrite(SPI_CLOCK_PIN, HIGH);\n\t\tr <<= 1;\n\t\tr |= digitalRead(SPI_MISO_PIN);\n\t\tb <<= 1;\n\t}\n\tdelayMicroseconds(SPI_DELAY);\n\treturn r;\n}", "CodeBleu_score": 43.667389394744326}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_DigitalWrite(HAL_SPI_STM32_MOSI_PIN, (b & 0x80) != 0);\n\t\tHAL_SPI_STM32_DigitalWrite(HAL_SPI_STM32_SCK_PIN, 0);\n\t\tHAL_SPI_STM32_DigitalWrite(HAL_SPI_STM32_SCK_PIN, 1);\n\t\tif (HAL_SPI_STM32_DigitalRead(HAL_SPI_STM32_MISO_PIN))\n\t\t\tr |= (1 << (7 - i));\n\t\tb <<= 1;\n\t}\n\tHAL_SPI_STM32_DelayMicroseconds(HAL_SPI_STM32_DELAY_MICROSECONDS);\n\treturn r;\n}", "CodeBleu_score": 37.06566329145106}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n    for (int i = 0; i < 8; i++) {\n        HAL_SPI_STM32_SetClockPinLow();\n        HAL_SPI_STM32_SetMosiPin(b & 0x80);\n        HAL_SPI_STM32_SetClockPinHigh();\n        r <<= 1;\n        r |= HAL_SPI_STM32_GetMisoPin();\n        b <<= 1;\n    }\n    HAL_SPI_STM32_Delay();\n    return r;\n}", "CodeBleu_score": 37.38024901960828}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 46.64045728127212}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 46.64045728127212}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 85.71256235579926}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c;\n  if (obj->serial.uart == 0) {\n    c = serial_getc(obj);\n    rx_buffer_index_write[0] = (rx_buffer_index_write[0] + 1) & (RX_BUFFER_SIZE - 1);\n    rx_buffer[0][rx_buffer_index_write[0]] = c;\n    if (rx_buffer_index_write[0] == rx_buffer_index_read[0])\n      rx_buffer_index_read[0] = (rx_buffer_index_read[0] + 1) & (RX_BUFFER_SIZE - 1);\n  }\n  #if defined(SERIAL_PORT_2)\n    else {\n      c = serial_getc(obj);\n      rx_buffer_index_write[1] = (rx_buffer_index_write[1] + 1) & (RX_BUFFER_SIZE - 1);\n      rx_buffer[1][rx_buffer_index_write[1]] = c;\n      if (rx_buffer_index_write[1] == rx_buffer_index_read[1])\n        rx_buffer_index_read[1] = (rx_buffer_index_read[1] + 1) & (RX_BUFFER_SIZE - 1);\n    }\n  #endif\n}", "CodeBleu_score": 31.594944803075553}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tif (obj->rx_buff.head == obj->rx_buff.tail) {\n    // Overflow detected\n    obj->rx_buff.overflow = true;\n    obj->rx_buff.head = (obj->rx_buff.head + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n  else {\n    uint8_t c;\n    // Read byte\n    c = obj->serial->DATA.reg;\n\n    // Calculate buffer index\n    unsigned char i = (unsigned char)(obj->rx_buff.head + 1) % SERIAL_RX_BUFFER_SIZE;\n\n    // Save byte\n    obj->rx_buff.buffer[obj->rx_buff.head] = c;\n\n    // Update head\n    obj->rx_buff.head = i;\n\n    // Update emergency parser\n    if (obj->serial_irq_rx_cb) {\n      obj->serial_irq_rx_cb(obj->serial_irq_rx_cb_data, c);\n    }\n  }\n}", "CodeBleu_score": 43.65999510180315}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t data;\n  if (obj->uart == UART_1) {\n    data = SERIAL_RX_REG(obj->uart);\n    if (obj->databits == UART_DATABITS_9) {\n      data = (data & 0x1FF);\n    }\n    if (obj->rx_buff.head == obj->rx_buff.tail) {\n      // Buffer overflow\n      obj->rx_buff.overflow = 1;\n    }\n    else {\n      // Read data\n      obj->rx_buff.buffer[obj->rx_buff.head] = data;\n      obj->rx_buff.head = (obj->rx_buff.head + 1) % SERIAL_RX_BUFFER_SIZE;\n    }\n  }\n  else {\n    data = SERIAL_RX_REG(obj->uart);\n    if (obj->databits == UART_DATABITS_9) {\n      data = (data & 0x1FF);\n    }\n    if (obj->rx_buff.head == obj->rx_buff.tail) {\n      // Buffer overflow\n      obj->rx_buff.overflow = 1;\n    }\n    else {\n      // Read data\n      obj->rx_buff.buffer[obj->rx_buff.head] = data;\n      obj->rx_buff.head = (obj->rx_buff.head + 1) % SERIAL_RX_BUFFER_SIZE;\n    }\n  }\n}", "CodeBleu_score": 37.3717118283895}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_num == MF_TIMER_STEP) {\n    if (step_timer_is_init && step_timer_is_interrupt_attached == false) {\n      step_timer_is_interrupt_attached = true;\n      attachInterrupt(digitalPinToInterrupt(MF_STEP_TIMER_PIN), Step_Handler, RISING);\n    }\n  }\n  else if (timer_num == MF_TIMER_TEMP) {\n    if (temp_timer_is_init && temp_timer_is_interrupt_attached == false) {\n      temp_timer_is_interrupt_attached = true;\n      attachInterrupt(digitalPinToInterrupt(MF_TEMP_TIMER_PIN), Temp_Handler, RISING);\n    }\n  }\n}", "CodeBleu_score": 31.453712313049103}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (timer_step_init_flag && !timer_step_interrupt_flag) {\n\t\t\ttimer_step_interrupt_flag = true;\n\t\t\tattachInterrupt(digitalPinToInterrupt(MF_TIMER_STEP_PIN), Step_Handler, FALLING);\n\t\t}\n\t}\n\telse if (timer_num == MF_TIMER_TEMP) {\n\t\tif (timer_temp_init_flag && !timer_temp_interrupt_flag) {\n\t\t\ttimer_temp_interrupt_flag = true;\n\t\t\tattachInterrupt(digitalPinToInterrupt(MF_TIMER_TEMP_PIN), Temp_Handler, FALLING);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.120941008854995}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_num == MF_TIMER_STEP) {\n    if (step_timer_is_init && step_timer_interrupt_attached == false) {\n      attachInterrupt(digitalPinToInterrupt(STEP_TIMER_PIN), Step_Handler, RISING);\n      step_timer_interrupt_attached = true;\n    }\n  }\n  else if (timer_num == MF_TIMER_TEMP) {\n    if (temp_timer_is_init && temp_timer_interrupt_attached == false) {\n      attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, RISING);\n      temp_timer_interrupt_attached = true;\n    }\n  }\n}", "CodeBleu_score": 31.992737515111898}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\thashsep, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[len(s)-n+i])\n\t}\n\tif h == hashsep && EqualStrRev(s[len(s)-n:], sep) {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && EqualStrRev(s[i:i+n], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 62.3222487536819}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\thashsep, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[len(s)-n+i])\n\t}\n\tif h == hashsep && EqualStr(s[len(s)-n:], sep) {\n\t\treturn len(s) - n\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[len(s)-i-n])\n\t\th -= pow * uint32(s[len(s)-i])\n\t\ti++\n\t\tif h == hashsep && EqualStr(s[len(s)-i:len(s)-i+n], sep) {\n\t\t\treturn len(s) - i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 47.73374293189882}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\thash, pow := HashStrRev(sep)\n\tn := len(sep)\n\tvar h uint32 = 0\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[len(s)-n+i])\n\t}\n\tif h == hash && Equal(s[len(s)-n:], sep) {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hash && Equal(s[i:i+n], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 60.984187745576946}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\tvar status uint8\n\tstatus = DisableInterrupts()\n\tif (usbcdc.txc) {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tRestoreInterrupts(status)\n}", "CodeBleu_score": 45.68114601166939}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t// disable interrupts\n\tdi()\n\n\t// send data if available\n\tif len(usbcdc.txBuffer) > 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txBuffer)\n\t}\n\n\t// no more data to send\n\tusbcdc.waitTxc = false\n\n\t// enable interrupts\n\tei()\n}", "CodeBleu_score": 26.841640986387144}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t// TODO: Implement this\n}", "CodeBleu_score": 3.0961530768308885}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.setControl(i2c.control &^ (1 << 1))\n\ti2c.setControl(i2c.control | (1 << 0))\n\ti2c.setControl(i2c.control | (1 << 7))\n\ti2c.setControl(i2c.control | (1 << 5))\n\ti2c.setControl(i2c.control &^ (1 << 4))\n\ti2c.setControl(i2c.control &^ (1 << 3))\n\ti2c.setControl(i2c.control &^ (1 << 2))\n\tif !write {\n\t\ti2c.setControl(i2c.control | (1 << 1))\n\t}\n\ti2c.setAddress(address)\n\tfor (i2c.getStatus() & (1 << 7)) == 0 {\n\t}\n}", "CodeBleu_score": 29.402533380890688}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.control.set(i2c.bus, i2c.control.get(i2c.bus)&^i2c.flag.get(i2c.bus))\n\ti2c.control.set(i2c.bus, i2c.control.get(i2c.bus)|i2c.start.get(i2c.bus))\n\tfor !i2c.flag.get(i2c.bus) {\n\t}\n\ti2c.data.set(i2c.bus, (address<<1)|(write<<0))\n\ti2c.control.set(i2c.bus, i2c.control.get(i2c.bus)|i2c.enable.get(i2c.bus))\n}", "CodeBleu_score": 29.877398771119022}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.control.set(0)\n\ti2c.control.set(i2cControlStart)\n\tfor !i2c.control.hasBits(i2cControlStart) {\n\t}\n\ti2c.address.set(address << 1)\n\tif !write {\n\t\ti2c.address.setBit(0)\n\t}\n\tfor !i2c.control.hasBits(i2cControlAddressWritten) {\n\t}\n}", "CodeBleu_score": 33.467980406912304}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif len < 0 {\n\t\treturn errors.New(\"invalid length\")\n\t}\n\n\tif start < 0 || start >= f.numBlocks {\n\t\treturn errors.New(\"invalid start block\")\n\t}\n\n\tif start+len > f.numBlocks {\n\t\treturn errors.New(\"invalid length\")\n\t}\n\n\t// Wait for any ongoing flash operations to complete\n\tf.WaitBusy()\n\n\t// Configure flash for erasing\n\tf.flash.CR.SetBits(stm32.FLASH_CR_PER)\n\n\t// Erase each block\n\tfor i := int64(0); i < len; i++ {\n\t\t// Calculate address of block to erase\n\t\taddr := f.blockSize * (start + i)\n\n\t\t// Set address to erase\n\t\tf.flash.AR.Set(uint32(addr))\n\n\t\t// Start erase operation\n\t\tf.flash.CR.Set(stm32.FLASH_CR_STRT)\n\n\t\t// Wait for completion\n\t\tf.WaitBusy()\n\t}\n\n\t// Set flash back to read mode\n\tf.flash.CR.ClearBits(stm32.FLASH_CR_PER)\n\n\treturn nil\n}", "CodeBleu_score": 37.65077769490861}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif start < 0 || len < 1 || start+len > f.BlockCount {\n\t\treturn errors.New(\"flashBlockDevice: invalid block range\")\n\t}\n\tif f.Busy() {\n\t\treturn errors.New(\"flashBlockDevice: flash is busy\")\n\t}\n\tif f.ReadOnly() {\n\t\treturn errors.New(\"flashBlockDevice: flash is read-only\")\n\t}\n\tf.SetWaitStates(1)\n\tf.SetReadMode()\n\tf.SetEraseMode()\n\tfor i := int64(0); i < len; i++ {\n\t\taddr := uint32(f.BlockSize * (start + i))\n\t\tf.Erase(addr)\n\t\tfor f.Busy() {\n\t\t}\n\t}\n\tf.SetReadMode()\n\tf.SetWaitStates(0)\n\treturn nil\n}", "CodeBleu_score": 32.80422310309336}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t// Check the start and length are valid\n\tif start < 0 || len < 0 {\n\t\treturn flash.ErrInvalidArgs\n\t}\n\t// Check the start and length are within the flash bounds\n\tif start+len > f.Size()/f.BlockSize {\n\t\treturn flash.ErrInvalidArgs\n\t}\n\t// Calculate the start address of the block\n\tstartAddr := f.Base + (start * f.BlockSize)\n\t// Check the start address is aligned to a block boundary\n\tif startAddr%f.BlockSize != 0 {\n\t\treturn flash.ErrInvalidArgs\n\t}\n\t// Wait for any ongoing flash operations to complete\n\tf.Wait()\n\t// Configure the flash for erasing\n\tf.Configure(flash.ModeErase)\n\t// Erase each block\n\tfor i := int64(0); i < len; i++ {\n\t\t// Erase the block\n\t\tf.Erase(startAddr + (i * f.BlockSize))\n\t\t// Wait for the erase to complete\n\t\tf.Wait()\n\t}\n\t// Set the flash back to read mode\n\tf.Configure(flash.ModeRead)\n\t// Return nil to indicate successful completion\n\treturn nil\n}", "CodeBleu_score": 37.43273649641179}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off+int64(len(p)) > f.Size {\n\t\treturn 0, errors.New(\"Write exceeds flash memory bounds\")\n\t}\n\tstartAddr := f.Base + uint32(off)\n\t// Pad the data to fit the write block size\n\tpaddedData := make([]byte, len(p))\n\tcopy(paddedData, p)\n\tpaddedData = append(paddedData, make([]byte, f.WriteBlockSize-len(p)%f.WriteBlockSize)...)\n\n\t// Enable write mode\n\tf.flash.CR.SetBits(stm32.FLASH_CR_PG)\n\n\t// Write data in blocks\n\tfor i := 0; i < len(paddedData); i += f.WriteBlockSize {\n\t\t// Write block\n\t\tf.flash.CR.SetBits(stm32.FLASH_CR_STRT)\n\t\tfor j := 0; j < f.WriteBlockSize; j++ {\n\t\t\tf.flash.CR.SetBits(stm32.FLASH_CR_STRT)\n\t\t\t*(*uint8)(unsafe.Pointer(uintptr(f.Base + startAddr + uint32(i+j)))) = paddedData[i+j]\n\t\t}\n\t\t// Wait for write to complete\n\t\tfor f.flash.SR.HasBits(stm32.FLASH_SR_BSY) {\n\t\t}\n\t}\n\n\t// Disable write mode\n\tf.flash.CR.ClearBits(stm32.FLASH_CR_PG)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 35.07755837746108}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off+int64(len(p)) > int64(len(f.mem)) {\n\t\treturn 0, errors.New(\"write exceeds flash memory bounds\")\n\t}\n\n\tstart := int(off)\n\tif start%f.blockSize != 0 {\n\t\tstart = start - (start % f.blockSize)\n\t}\n\n\tpadded := make([]byte, len(p)+(start-int(off)))\n\tcopy(padded[start-int(off):], p)\n\n\tf.flash.EnableWrite()\n\n\tfor i := 0; i < len(padded); i += f.blockSize {\n\t\tif err := f.flash.Write(start+i, padded[i:i+f.blockSize]); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tf.flash.WaitReady()\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 30.503343438635767}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// Check if the write operation exceeds the flash memory bounds.\n\tif off < 0 || off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, flash.ErrOutOfBounds\n\t}\n\n\t// Calculate the start address for writing.\n\tstart := f.Addr + uint32(off)\n\n\t// Pad the byte slice to fit the write block size.\n\tp = f.pad(p, f.WriteBlockSize)\n\n\t// Enable write mode on the flash memory controller.\n\tif err := f.enableWrite(); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(p); i += f.WriteBlockSize {\n\t\tif err := f.writeBlock(start+uint32(i), p[i:i+f.WriteBlockSize]); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Wait for the flash memory to be ready.\n\tif err := f.waitReady(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 31.745176455565616}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the provided file descriptor.\n\tnewFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"darwinOpenDir: error duplicating file descriptor\", err\n\t}\n\t// Create a pointer to the directory.\n\tvar dir *syscall.Dir\n\t// Attempt to open the directory.\n\tfor {\n\t\tdir, err = syscall.Fdopendir(newFd)\n\t\tif err == nil || err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\t// Check for errors.\n\tif err != nil {\n\t\tsyscall.Close(newFd)\n\t\treturn 0, \"darwinOpenDir: error opening directory\", err\n\t}\n\t// Return the directory pointer.\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 68.054692162228}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the provided file descriptor.\n\tnewFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Attempt to open the directory file descriptor.\n\tvar dir *syscall.Dirent\n\tfor {\n\t\tdir, err = syscall.Fdopendir(newFd)\n\t\tif err == syscall.EINTR {\n\t\t\tcontinue\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\t// If an error occurred, close the duplicated file descriptor and return the error.\n\tif err != nil {\n\t\tsyscall.Close(newFd)\n\t\treturn 0, \"\", err\n\t}\n\t// Return the directory pointer and no error.\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 68.63281769716167}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tfor {\n\t\tdirPtr, err := syscall.Fdopendir(fd)\n\t\tif err != nil {\n\t\t\tif err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsyscall.Close(fd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t\treturn uintptr(dirPtr), \"\", nil\n\t}\n}", "CodeBleu_score": 56.75342546627014}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\tconst esp_partition_t* partition;\n  esp_image_metadata_t data;\n  const esp_partition_t* running;\n  running = esp_ota_get_running_partition();\n  if (running == NULL) {\n    return 0;\n  }\n  if (esp_ota_get_partition_description(running, &partition) != ESP_OK) {\n    return 0;\n  }\n  if (esp_image_verify(ESP_IMAGE_VERIFY, (esp_image_metadata_t*)partition, &data) != ESP_OK) {\n    return 0;\n  }\n  if (response == FREE_SPACE) {\n    return partition->size - data.image_len;\n  }\n  return data.image_len;\n}", "CodeBleu_score": 56.384369533834246}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tconst esp_partition_t* partition = esp_ota_get_running_partition();\n  esp_image_header_t header;\n\n  if (!partition) {\n    Serial.println(\"Failed to get running partition!\");\n    return 0;\n  }\n\n  if (esp_ota_get_partition_description(partition, &header) != ESP_OK) {\n    Serial.println(\"Failed to get partition description\");\n    return 0;\n  }\n\n  uint32_t size = header.image.image_len;\n\n  if (response == FREE_SKETCH_SPACE) {\n    size = partition->size - size;\n  }\n\n  return size;\n}", "CodeBleu_score": 44.43886674921564}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tconst esp_partition_t* partition = esp_ota_get_running_partition();\n  esp_image_header_t image_header;\n  esp_image_metadata_t image_metadata;\n\n  const esp_partition_pos_t running = {\n    .offset = partition->address,\n    .size = partition->size,\n  };\n\n  if (esp_image_load_header(running, &image_header) != ESP_OK) {\n    return 0;\n  }\n\n  if (esp_image_load_metadata(running, &image_metadata) != ESP_OK) {\n    return 0;\n  }\n\n  if (image_header.magic != ESP_IMAGE_HEADER_MAGIC) {\n    return 0;\n  }\n\n  if (image_header.spi_mode != ESP_IMAGE_SPI_MODE_DIO && image_header.spi_mode != ESP_IMAGE_SPI_MODE_QIO &&\n      image_header.spi_mode != ESP_IMAGE_SPI_MODE_DOUT && image_header.spi_mode != ESP_IMAGE_SPI_MODE_FAST_READ &&\n      image_header.spi_mode != ESP_IMAGE_SPI_MODE_SLOW_READ) {\n    return 0;\n  }\n\n  if (response == FREE_SPACE) {\n    return partition->size - image_metadata.image_len;\n  } else {\n    return image_metadata.image_len;\n  }\n}", "CodeBleu_score": 56.53725667588112}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t required_disk_sectors = msc_update_get_required_disk_sectors();\n  msc_disk_buffer = heap_caps_malloc(required_disk_sectors * DISK_SECTOR_SIZE, MALLOC_CAP_8BIT);\n  if (!msc_disk_buffer) {\n    log_e(\"ERROR: Failed to allocate %u bytes for RAM disk\", required_disk_sectors * DISK_SECTOR_SIZE);\n    return false;\n  }\n  memset(msc_disk_buffer, 0, required_disk_sectors * DISK_SECTOR_SIZE);\n  fat_init_media(msc_disk_buffer, required_disk_sectors, DISK_SECTOR_SIZE);\n  fat_set_label(volume_label);\n  fat_set_serial(serial_number);\n  fat_set_fat_type(mcs_is_fat16 ? FAT_TYPE_FAT16 : FAT_TYPE_FAT12);\n  fat_set_cluster_count(data_sectors);\n  fat_set_alloc_table_state(msc_table_sectors, FAT_STATE_ACTIVE);\n  fat_set_cluster_state(0, FAT_STATE_ACTIVE);\n  fat_set_cluster_state(1, FAT_STATE_ACTIVE);\n  fat_set_cluster_state(2, FAT_STATE_ACTIVE);\n  if (msc_run_partition) {\n    fat_set_cluster_state(3, FAT_STATE_ACTIVE);\n    fat_set_cluster_state(4, FAT_STATE_ACTIVE);\n    fat_set_cluster_state(5, FAT_STATE_ACTIVE);\n    fat_set_cluster_state(6, FAT_STATE_ACTIVE);\n    fat_set_cluster_state(7, FAT_STATE_ACTIVE);\n    fat_set_cluster_state(8, FAT_STATE_ACTIVE);\n    fat_set_cluster_state(9, FAT_STATE_ACTIVE);\n    fat_set_cluster_state", "CodeBleu_score": 39.42031463399145}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t required_disk_sectors = msc_update_get_required_disk_sectors();\n  if (required_disk_sectors == 0) {\n    log_e(\"No space for disk\");\n    return false;\n  }\n  msc_disk_sectors = required_disk_sectors;\n  msc_disk_buffer = (uint8_t *)heap_caps_malloc(msc_disk_sectors * DISK_SECTOR_SIZE, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);\n  if (msc_disk_buffer == NULL) {\n    log_e(\"No memory for disk\");\n    return false;\n  }\n  memset(msc_disk_buffer, 0, msc_disk_sectors * DISK_SECTOR_SIZE);\n  fat_init_media(msc_disk_buffer, msc_disk_sectors, DISK_SECTOR_SIZE);\n  fat_set_label(volume_label);\n  fat_set_serial_number(serial_number);\n  if (msc_run_partition) {\n    fat_set_file_attributes(msc_run_partition->label, 0x00);\n  }\n  return true;\n}", "CodeBleu_score": 42.15373560958198}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tmsc_disk_sectors = msc_update_get_required_disk_sectors();\n  msc_disk_buffer = (uint8_t *) calloc(msc_disk_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk_buffer) {\n    log_e(\"Error allocating memory for disk buffer\");\n    return false;\n  }\n  log_d(\"Disk buffer allocated at %p\", msc_disk_buffer);\n  msc_disk_buffer_size = msc_disk_sectors * DISK_SECTOR_SIZE;\n  log_d(\"Disk buffer size: %u (%uKB)\", msc_disk_buffer_size, msc_disk_buffer_size / 1024);\n  if (msc_run_partition) {\n    msc_update_setup_firmware_file();\n  }\n  msc_update_setup_boot_sector(volume_label, serial_number);\n  msc_update_setup_fat();\n  return true;\n}", "CodeBleu_score": 36.683184549110344}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tassert(partition != NULL);\n    assert(data != NULL);\n    assert(size > 0);\n\n    esp_err_t err;\n    if (offset % partition->sector_size != 0) {\n        err = ESP_ERR_INVALID_ARG;\n        ESP_LOGE(TAG, \"msc_update_write: offset is not aligned with flash sector size\");\n    } else {\n        err = esp_partition_erase_range(partition, offset, partition->sector_size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"msc_update_write: failed to erase partition\");\n        } else {\n            err = esp_partition_write(partition, offset, data, size);\n            if (err != ESP_OK) {\n                ESP_LOGE(TAG, \"msc_update_write: failed to write partition\");\n            }\n        }\n    }\n    return err;\n}", "CodeBleu_score": 50.027814148735615}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err = ESP_OK;\n\tif (offset % 4096 == 0) {\n\t\terr = esp_partition_erase_range(partition, offset, 4096);\n\t\tif (err != ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Failed to erase partition (%d)!\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write partition (%d)!\", err);\n\t}\n\treturn err;\n}", "CodeBleu_score": 62.374009694217094}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tif (offset % partition->sector_size != 0) {\n        ESP_LOGE(TAG, \"Offset is not aligned with flash sector size\");\n        return ESP_FAIL;\n    }\n\n    if (size % partition->sector_size != 0) {\n        ESP_LOGE(TAG, \"Size is not aligned with flash sector size\");\n        return ESP_FAIL;\n    }\n\n    esp_err_t err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase partition (%s)\", esp_err_to_name(err));\n        return err;\n    }\n\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write partition (%s)\", esp_err_to_name(err));\n        return err;\n    }\n\n    return ESP_OK;\n}", "CodeBleu_score": 51.201000497341866}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t outlen = 0;\n  uint8_t c;\n  while ((c = *in++)) {\n    uint8_t nibble = hex_char_to_byte(c);\n    if (nibble < 0x10) {\n      if (outlen >= maxlen) {\n        return outlen;\n      }\n      *out = nibble;\n      out++;\n      outlen++;\n    }\n  }\n  return outlen;\n}", "CodeBleu_score": 41.22198464378207}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i;\n  uint8_t c;\n  uint8_t j;\n  uint8_t k;\n  uint8_t n;\n  uint8_t v;\n\n  i = 0;\n  n = 0;\n  while (in[i]) {\n    c = in[i];\n    j = hex_char_to_byte(c);\n    if (j < 0x10) {\n      if (n >= maxlen) {\n        return n;\n      }\n      v = j;\n      i++;\n      c = in[i];\n      k = hex_char_to_byte(c);\n      if (k < 0x10) {\n        out[n] = (v << 4) | k;\n        n++;\n      }\n    }\n    i++;\n  }\n  return n;\n}", "CodeBleu_score": 44.53612036684337}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t len = 0;\n  while (*in && len < maxlen) {\n    uint8_t c = hex_char_to_byte(*in++);\n    if (c < 0x10) {\n      *out = c << 4;\n      c = hex_char_to_byte(*in++);\n      if (c < 0x10) {\n        *out |= c;\n        out++;\n        len++;\n      }\n    }\n  }\n  return len;\n}", "CodeBleu_score": 49.21400572176212}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\tif (tx_buffer == NULL || tx_mutex == NULL) {\n        return 0;\n    }\n\n    if (tx_mutex->trylock_for(1000)) {\n        int ret = tx_buffer->free();\n        tx_mutex->unlock();\n        return ret;\n    }\n    return 0;\n}", "CodeBleu_score": 56.75573901328086}, {"code": "int HWCDC::availableForWrite(void){\n\tif (tx_buffer == NULL) {\n        return 0;\n    }\n\n    if (tx_mutex == NULL) {\n        return 0;\n    }\n\n    if (tx_mutex->trylock_for(SERIAL_TX_WAIT)) {\n        int tx_free = tx_buffer->free();\n        tx_mutex->unlock();\n        return tx_free;\n    }\n\n    return 0;\n}", "CodeBleu_score": 56.38882624707694}, {"code": "int HWCDC::availableForWrite(void){\n\tif (!tx_buffer) {\n        return 0;\n    }\n\n    if (tx_sem->try_acquire(1, _timeout)) {\n        int free = tx_buffer->free();\n        tx_sem->release();\n        return free;\n    }\n    return 0;\n}", "CodeBleu_score": 42.858804812199175}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t// lock the serial mutex\n  xSemaphoreTake(_serialMutex, portMAX_DELAY);\n\n  // assign the callback function\n  _onReceiveCB = function;\n\n  // configure the receive timeout behavior\n  _onlyOnRxTimeout = onlyOnTimeout;\n  if (_onlyOnRxTimeout) {\n    _rxTimeout = 0;\n    _rxTimeoutTicks = 0;\n  } else {\n    _rxTimeout = _rxTimeoutMs;\n    _rxTimeoutTicks = _rxTimeout * portTICK_PERIOD_MS;\n  }\n\n  // if the callback is not NULL, set the FIFO full threshold and create an event task if it does not already exist\n  if (_onReceiveCB) {\n    _uart->set_rx_full_threshold(UART_FIFO_FULL_THRESH_DEFAULT);\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n\n  // unlock the serial mutex\n  xSemaphoreGive(_serialMutex);\n}", "CodeBleu_score": 50.860023048128596}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tif (function) {\n    xSemaphoreTake(_serialMux, portMAX_DELAY);\n    _onReceiveCB = function;\n    _onlyOnReceiveCB = onlyOnTimeout;\n    _rxTimeout = onlyOnTimeout ? 0 : 1;\n    _configRxFifo();\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n    xSemaphoreGive(_serialMux);\n  }\n}", "CodeBleu_score": 37.6337360110617}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tif (function == NULL) {\n    log_e(\" -- onReceive callback function cannot be NULL!\");\n    return;\n  }\n\n  if (xSemaphoreTake(_serialMutex, ARDUINO_SERIAL_MUTEX_TIMEOUT) != pdTRUE) {\n    log_e(\" -- onReceive failed to take _serialMutex!\");\n    return;\n  }\n\n  _onReceiveCB = function;\n\n  if (_onReceiveCB != NULL) {\n    if (onlyOnTimeout) {\n      _rxTimeout = 0;\n    } else {\n      _rxTimeout = ARDUINO_SERIAL_RX_TIMEOUT;\n    }\n\n    _setRxFIFOThreshold();\n\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n\n  xSemaphoreGive(_serialMutex);\n}", "CodeBleu_score": 57.10709818118001}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char) c;\n    index++;\n  }\n  *buffer = '\\0';\n  return index;\n}", "CodeBleu_score": 89.59759126637353}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char)c;\n    index++;\n  }\n  *buffer = '\\0';  // null terminate the string\n  return index;    // return the number of characters, not including null terminator\n}", "CodeBleu_score": 93.1683793391986}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char) c;\n    index++;\n  }\n  *buffer = '\\0';\n  return index;  // return number of characters, not including null terminator\n}", "CodeBleu_score": 94.03616900127501}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_v(\"Tone requested on pin %d with frequency %d Hz and duration %d ms\", pin, frequency, duration);\n  if (pin_in_use(pin)) {\n    log_e(\"Pin %d is in use, please stop the current tone first\", pin);\n    return;\n  }\n  tone_init();\n  tone_msg_t msg;\n  msg.pin = pin;\n  msg.frequency = frequency;\n  msg.duration = duration;\n  msg.command = TONE_START;\n  xQueueSend(_tone_queue, &msg, 0);\n}", "CodeBleu_score": 47.00964909030518}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_v(\"tone(%d, %d, %d)\", pin, frequency, duration);\n  if (pin_in_use(pin)) {\n    log_e(\"Pin %d is already in use\", pin);\n    return;\n  }\n  tone_init();\n  tone_msg_t msg;\n  msg.pin = pin;\n  msg.frequency = frequency;\n  msg.duration = duration;\n  msg.command = TONE_START;\n  xQueueSend(_tone_queue, &msg, 0);\n}", "CodeBleu_score": 43.53586319809985}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_v(\"tone: pin: %d, frequency: %d, duration: %d\", pin, frequency, duration);\n  if (pin_in_use(pin)) {\n    log_e(\"Pin %d is in use. Stop the current tone on this pin first.\", pin);\n    return;\n  }\n  tone_init();\n  tone_msg_t msg = {\n    .pin = pin,\n    .frequency = frequency,\n    .duration = duration,\n  };\n  xQueueSend(_tone_queue, &msg, 0);\n}", "CodeBleu_score": 52.318208748858154}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\tif(!usb_started) {\n\t\twebUSBEnabled = enabled;\n\t\tif(enabled) {\n\t\t\tusb_version = 0x0210;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 41.44563022666982}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (enabled) {\n\t\tif (!_usb_started) {\n\t\t\t_usb_webusb = true;\n\t\t\tif (_usb_version < 0x0210) _usb_version = 0x0210;\n\t\t\treturn true;\n\t\t}\n\t\tif (!_usb_webusb) {\n\t\t\t_usb_webusb = true;\n\t\t\tUSBDevice.attach();\n\t\t}\n\t} else {\n\t\tif (!_usb_started) {\n\t\t\t_usb_webusb = false;\n\t\t\treturn true;\n\t\t}\n\t\tif (_usb_webusb) {\n\t\t\t_usb_webusb = false;\n\t\t\tUSBDevice.detach();\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 41.2814169899187}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (enabled) {\n    if (!usb_started) {\n      usb_version = 0x0210;\n      webusb_enabled = true;\n      return true;\n    }\n    if (usb_version < 0x0210) {\n      usb_version = 0x0210;\n    }\n    webusb_enabled = true;\n    usb_config.bmAttributes |= USB_CONFIG_ATTR_WEBUSB;\n  } else {\n    webusb_enabled = false;\n    usb_config.bmAttributes &= ~USB_CONFIG_ATTR_WEBUSB;\n  }\n  return false;\n}", "CodeBleu_score": 52.76918377053583}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\tuint8_t buffer[64];\n    uint8_t len;\n    while (true) {\n        len = _usb.ep_rx_size(_rx_ep);\n        if (len == 0) {\n            break;\n        }\n        if (len > sizeof(buffer)) {\n            len = sizeof(buffer);\n        }\n        _usb.ep_rx(_rx_ep, buffer, len);\n        for (uint8_t i = 0; i < len; i++) {\n            if (!_rx_queue.write(buffer[i])) {\n                _rx_queue.overflow();\n                _rx_queue.write(buffer[i]);\n            }\n        }\n        _rx_queue.event();\n    }\n}", "CodeBleu_score": 32.17361006249495}, {"code": "void USBCDC::_onRX(){\n\tuint8_t buf[64];\n\tuint32_t len = 0;\n\n\tlen = _usb.readEP(_rxEndpoint, buf, 64);\n\n\tif (len > 0) {\n\t\tfor (uint32_t i = 0; i < len; i++) {\n\t\t\tif (_rxQueue.full()) {\n\t\t\t\t_rxOverflow++;\n\t\t\t\t_rxQueue.post(USBCDC::RX_OVERFLOW, &_rxOverflow);\n\t\t\t\t_rxQueue.post(USBCDC::RX_DATA, &buf[i]);\n\t\t\t} else {\n\t\t\t\t_rxQueue.post(USBCDC::RX_DATA, &buf[i]);\n\t\t\t}\n\t\t}\n\t\t_rxQueue.post(USBCDC::RX_DATA_READY, &len);\n\t}\n}", "CodeBleu_score": 27.928069554371454}, {"code": "void USBCDC::_onRX(){\n\tuint8_t buffer[64];\n    int bytesRead = 0;\n    int bytesRemaining = 0;\n    int bytesSent = 0;\n    int bytesDropped = 0;\n    int bytesToSend = 0;\n    int bytesLeft = 0;\n    int bytesToSendNow = 0;\n\n    /*\n     * Read data into the buffer\n     */\n    bytesRead = readEP(CDC_ENDPOINT_OUT, buffer, sizeof(buffer));\n\n    /*\n     * If data was read, post a receive event\n     */\n    if (bytesRead > 0) {\n        postEvent(USBCDC_EVENT_RX, bytesRead);\n    }\n\n    /*\n     * If the receive queue is full, post an overflow event\n     */\n    if (rxQueue.isFull()) {\n        bytesRemaining = rxQueue.getRemaining();\n        postEvent(USBCDC_EVENT_OVERFLOW, bytesRemaining);\n    }\n\n    /*\n     * Send the data to the receive queue\n     */\n    bytesSent = rxQueue.send(buffer, bytesRead);\n\n    /*\n     * If not all of the data was sent, post an overflow event\n     */\n    if (bytesSent < bytesRead) {\n        bytesDropped = bytesRead - bytesSent;\n        postEvent(USBCDC_EVENT_OVERFLOW, bytesDropped);\n    }\n}", "CodeBleu_score": 32.48455849292304}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\trobotName := mux.Vars(req)[\"robotName\"]\n\n\trobot, err := a.db.GetRobotByName(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif robot == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot found with name %s\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices, err := a.db.GetDevicesByRobotID(robot.ID)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjsonResponse, err := json.Marshal(devices)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonResponse)\n}", "CodeBleu_score": 34.89125708168227}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the request path\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Check if a robot with the given name exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\t// If no robot with the given name exists, return an error message\n\t\thttp.Error(res, \"No robot found with name \"+robotName, http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the devices associated with the robot\n\tdevices, err := a.db.GetRobotDevices(robot)\n\tif err != nil {\n\t\t// If there was an error retrieving the devices, return an error message\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Convert the devices to a JSON format\n\tjsonDevices, err := json.Marshal(devices)\n\tif err != nil {\n\t\t// If there was an error converting the devices to JSON, return an error message\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the JSON response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonDevices)\n}", "CodeBleu_score": 36.58310868547826}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t// Parse the robot name from the request.\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Check if a robot with the given name exists.\n\tif _, ok := a.Robots[robotName]; !ok {\n\t\t// If no robot with the given name exists, return a JSON response with an error message.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"No robot with the specified name exists\"}`))\n\t\treturn\n\t}\n\n\t// Get the robot with the given name.\n\trobot := a.Robots[robotName]\n\n\t// Create a JSON array to store the robot's devices.\n\tdevicesJSON := make([]jsonDevice, len(robot.Devices))\n\n\t// Iterate over the robot's devices and add them to the JSON array.\n\tfor i, device := range robot.Devices {\n\t\tdevicesJSON[i] = jsonDevice{\n\t\t\tName: device.Name,\n\t\t\tType: device.Type,\n\t\t}\n\t}\n\n\t// Write the JSON response to the HTTP response writer.\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(devicesJSON)\n}", "CodeBleu_score": 41.927168149395364}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL\n\trobotName := req.URL.Path[len(\"/robots/\"):]\n\t// Check if the robot exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\t// Create a JSON encoder for the HTTP response\n\tencoder := json.NewEncoder(res)\n\t// Set the response content type to JSON\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t// Iterate through the robot's connections\n\tfor _, connection := range robot.Connections {\n\t\t// Convert the connection to JSON format\n\t\terr := encoder.Encode(connection)\n\t\tif err != nil {\n\t\t\thttp.Error(res, \"Failed to write connection JSON\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 32.01564967276853}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\tvar robotName string\n\tvar err error\n\n\t// Extract the robot name from the request URL\n\trobotName, err = getRobotName(req)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Check if the robot exists\n\trobot, err := a.robotMap.Get(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON format\n\tconnections := make([]*ConnectionJSON, 0, len(robot.Connections))\n\tfor _, connection := range robot.Connections {\n\t\tconnections = append(connections, connection.ToJSON())\n\t}\n\n\t// Write the connections to the HTTP response\n\terr = json.NewEncoder(res).Encode(connections)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 36.15394257089791}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Check if the robot exists\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\t// If the robot is not found, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"Robot \" + robotName + \" not found\"))\n\t\treturn\n\t}\n\n\t// Create an array of connections\n\tconnections := make([]Connection, 0)\n\n\t// Iterate through the robot's connections\n\tfor _, connection := range robot.connections {\n\t\t// Convert the connection to JSON format\n\t\tjsonConnection, err := json.Marshal(connection)\n\t\tif err != nil {\n\t\t\t// If there is an error during conversion, write an error message to the HTTP response\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\tres.Write([]byte(\"Error converting connection to JSON format\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Add the connection to the array of connections\n\t\tconnections = append(connections, Connection{\n\t\t\tName: string(jsonConnection),\n\t\t})\n\t}\n\n\t// Convert the array of connections to JSON format\n\tjsonConnections, err := json.Marshal(connections)\n\tif err != nil {\n\t\t// If there is an error during conversion, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(\"Error converting connections to JSON format\"))\n\t\treturn\n\t}\n\n\t// Write the array of connections to the HTTP response\n\tres.Write(jsonConnections)\n}", "CodeBleu_score": 40.62572596203043}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\tif robotName == \"\" || deviceName == \"\" || command == \"\" {\n\t\thttp.Error(res, \"robot, device and command must be provided\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\trobot, err := a.getRobot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice := robot.GetDevice(deviceName)\n\tif device == nil {\n\t\thttp.Error(res, fmt.Sprintf(\"device %s not found\", deviceName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch command {\n\tcase \"on\":\n\t\tdevice.On()\n\tcase \"off\":\n\t\tdevice.Off()\n\tdefault:\n\t\thttp.Error(res, fmt.Sprintf(\"command %s not found\", command), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(res, \"command %s executed on device %s\", command, deviceName)\n}", "CodeBleu_score": 47.634683891744736}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t// Get the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Retrieve the robot from the database\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Check if the device exists\n\tif !robot.HasDevice(deviceName) {\n\t\thttp.Error(res, \"The specified device does not exist\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Retrieve the device from the robot\n\tdevice := robot.GetDevice(deviceName)\n\n\t// Execute the specified command on the device\n\terr = device.ExecuteCommand(req.Body)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.79778207473855}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t// Get the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robotName\")\n\tdeviceName := req.URL.Query().Get(\"deviceName\")\n\n\t// Retrieve the robot device.\n\trobotDevice, err := a.robotDevices.GetRobotDevice(robotName, deviceName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Execute the specified command on the device.\n\terr = robotDevice.ExecuteCommand(req.Body)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the command execution result as a JSON response.\n\tres.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(robotDevice.GetState())\n}", "CodeBleu_score": 51.204998866248005}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// request is authenticated, proceed with the next handler\n\t}\n}", "CodeBleu_score": 52.251690504797125}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Request is authorized, so call the next handler.\n\t\t// http.FileServer(http.Dir(\"static/\"))(w, r)\n\t\thttp.StripPrefix(\"/static/\", http.FileServer(http.Dir(\"static\"))).ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.57242082261217}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Proceed to the next handler\n\t}\n}", "CodeBleu_score": 52.46233194456654}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.Lock()\n\tdefer a.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"No connection established\")\n\t}\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"Connection does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scaleValue(raw)\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.57365306974982}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"the connection to %s does not support analog reading\", a.Name())\n\t}\n\n\tvalue, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scale(value)\n\ta.lastAnalogReading = value\n\ta.lastAnalogReadingScaled = scaled\n\treturn value, scaled, nil\n}", "CodeBleu_score": 49.4378650405241}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t// Lock the sensor for reading\n\ta.readingLock.Lock()\n\tdefer a.readingLock.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif a.connection.SupportsAnalogReading() {\n\t\t// Read the raw sensor value\n\t\trawValue, err := a.connection.AnalogRead(a.pin)\n\t\tif err != nil {\n\t\t\treturn 0, 0, err\n\t\t}\n\n\t\t// Scale the raw sensor value\n\t\tscaledValue := float64(rawValue)\n\t\tif a.scale != 1 {\n\t\t\tscaledValue = float64(rawValue) * a.scale\n\t\t}\n\n\t\t// Update the last read values\n\t\ta.lastRawValue = rawValue\n\t\ta.lastScaledValue = scaledValue\n\n\t\t// Return the scaled value\n\t\treturn rawValue, scaledValue, nil\n\t}\n\n\t// Return an error if the connection does not support analog reading\n\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n}", "CodeBleu_score": 52.79672090618639}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tdriver := new(GroveSoundSensorDriver)\n\tdriver.Pin = pin\n\tdriver.Name = gobot.DefaultName(\"GroveSoundSensor\")\n\tdriver.AnalogSensorDriver = NewAnalogSensorDriver(a, pin, opts...)\n\treturn driver\n}", "CodeBleu_score": 41.829649402138145}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tdriver := new(GroveSoundSensorDriver)\n\tdriver.Pin = pin\n\tdriver.Name = gobot.DefaultName(\"GroveSoundSensor\")\n\tdriver.analogSensor = NewAnalogSensorDriver(a, pin, opts...)\n\tdriver.Units = \"dB\"\n\tdriver.accuracy = 2\n\tdriver.Gain = 1\n\tdriver.Samples = 3\n\tdriver.Sensitivity = 1.5\n\tdriver.LastValue = 0.0\n\tdriver.LastSound = 0.0\n\tdriver.Active = true\n\tdriver.init()\n\treturn driver\n}", "CodeBleu_score": 34.90557573243946}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tdriver := new(GroveSoundSensorDriver)\n\tdriver.Pin = pin\n\tdriver.Name = gobot.DefaultName(\"GroveSoundSensor\")\n\tdriver.gobot.Eventer = gobot.NewEventer()\n\tdriver.gobot.Commander = gobot.NewCommander()\n\tdriver.AddEvent(Sound)\n\tdriver.AddCommand(\"Sound\", func(params map[string]interface{}) interface{} {\n\t\treturn driver.Sound()\n\t})\n\tdriver.AddEvent(SoundDetected)\n\tdriver.AddCommand(\"SoundDetected\", func(params map[string]interface{}) interface{} {\n\t\tval, _ := driver.SoundDetected()\n\t\treturn val\n\t})\n\tdriver.AddEvent(On)\n\tdriver.AddEvent(Off)\n\tdriver.SetADC(a)\n\treturn driver\n}", "CodeBleu_score": 29.62905951267395}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t// Send the soft reset command\n\terr := d.writeCommand(CommandSoftReset)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait the required delay\n\ttime.Sleep(250 * time.Millisecond)\n\n\t// Verify that the soft reset command was executed correctly\n\tcommandReg, err := d.readCommand()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif commandReg&0xFF != 0x00 {\n\t\treturn errors.New(\"Soft reset command failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 64.14455427190836}, {"code": "func (d *MFRC522Common) softReset() error{\n\t// Send the reset command to the command register\n\tif err := d.writeRegister(d.CommandReg, d.CommandReg.SoftReset()); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the reset to complete\n\ttime.Sleep(d.SoftResetDelay)\n\n\t// Check the command register to see if the reset is complete\n\tif err := d.readRegister(d.CommandReg); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the power-down bit is still set\n\tif d.CommandReg.IsSet(d.CommandReg.PowerDown) {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 61.53558021302678}, {"code": "func (d *MFRC522Common) softReset() error{\n\t// Issue the SoftReset command.\n\tif err := d.writeRegister(CommandReg, PCD_SoftReset); err != nil {\n\t\treturn err\n\t}\n\t// Wait the required 1 ms delay.\n\ttime.Sleep(1 * time.Millisecond)\n\t// Check that the PowerDown bit is cleared.\n\tif err := d.waitForSet(CommandReg, 0x01, 0); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 54.30730856242454}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tlength := len(backData)\n\tif length == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// Check number of bytes in the FIFO\n\tn, err := d.dev.ReadReg(d.reg.FIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif n != uint8(length) {\n\t\treturn 0, fmt.Errorf(\"The number of bytes in the FIFO (%d) does not match the expected length (%d)\", n, length)\n\t}\n\n\t// Read the FIFO\n\terr = d.dev.ReadRegBytes(d.reg.FIFOData, backData)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Read the control register\n\tn, err = d.dev.ReadReg(d.reg.Control)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn n, nil\n}", "CodeBleu_score": 45.48415919609025}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Read the number of bytes stored in the FIFO\n\tn, err := d.readRegister(d.regFifoLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// If the number of bytes doesn't match the expected length, return an error\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"unexpected number of bytes in FIFO: %d\", n)\n\t}\n\n\t// Read each byte from the FIFO buffer\n\tfor i := uint8(0); i < n; i++ {\n\t\tbackData[i], err = d.readRegister(d.regFifoData)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tcontrol, err := d.readRegister(d.regControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn control, nil\n}", "CodeBleu_score": 47.816892148773206}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tvar controlReg byte\n\tvar length uint8\n\tvar err error\n\tvar i uint8\n\tlength, err = d.ReadRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif length != uint8(len(backData)) {\n\t\treturn 0, errors.New(\"backData length does not match FIFO Level\")\n\t}\n\tfor i = 0; i < length; i++ {\n\t\tbackData[i], err = d.ReadRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tcontrolReg, err = d.ReadRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn controlReg, nil\n}", "CodeBleu_score": 43.435404745139564}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t// Log message\n\td.logger.Printf(\"Sending PICC halt command\")\n\n\t// Send halt command\n\tif _, err := d.sendCommand([]byte{d.CommandHaltA, 0}, 0); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the PICC has halted\n\tif _, err := d.readData(1); err != nil {\n\t\treturn err\n\t}\n\n\t// Return nil if the PICC has halted\n\treturn nil\n}", "CodeBleu_score": 29.013574168179673}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t// Log message\n\td.logger.Debug(\"Halting PICC\")\n\n\t// Build command buffer\n\tbuffer := make([]byte, 4)\n\tbuffer[0] = PICC_CMD_HLTA\n\tbuffer[1] = 0\n\t// Calculate CRC\n\tcrc := d.calculateCRC(buffer[:2])\n\tbuffer[2] = crc[0]\n\tbuffer[3] = crc[1]\n\n\t// Send the command to the PICC\n\tif err := d.writeCommand(buffer); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the command to complete\n\tif _, err := d.readResponse(); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the PICC has halted\n\tif d.calculateCRC(buffer[:2])[0] != buffer[2] || d.calculateCRC(buffer[:2])[1] != buffer[3] {\n\t\treturn errors.New(\"PICC did not halt\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 35.41307813859529}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\td.log.Debug(\"Halting PICC\")\n\n\t// Halt command\n\tbuffer := []byte{\n\t\td.CommandHalt,\n\t\t0,\n\t}\n\n\t// Calculate CRC for the halt command\n\tbuffer = append(buffer, d.calculateCRC(buffer)...)\n\n\t// Send the command and expect the error to indicate successful halting.\n\tresponse, err := d.cardWrite(buffer, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif response[0] != d.ErrorOk {\n\t\treturn errors.New(\"Error halting PICC\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 35.24144096831017}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\tvar err error\n\tvar data []byte\n\tvar buffer []byte\n\tvar size uint8\n\n\t// In the data sheet, the PICC_Read command is described as:\n\t// -------------------------------------------------------------------------------------------------------------------------------------------------------------\n\t// | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 |\n\t// -------------------------------------------------------------------------------------------------------------------------------------------------------------\n\t// | 0x30 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 |\n\t// -------------------------------------------------------------------------------------------------------------------------------------------------------------\n\t// | 0x30 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x0", "CodeBleu_score": 5.998744843311534}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\tvar err error\n\tvar response []byte\n\tvar responseLength int\n\tvar readbackLength int\n\tvar length int\n\tvar readback []byte\n\tvar data []byte\n\tvar crc []byte\n\tvar crcResult []byte\n\tvar readbackCRC []byte\n\n\t// Build command buffer\n\t// In the command buffer, the block number is written in big-endian format,\n\t// so the most significant byte is written first\n\tbuffer := []byte{d.PiccCmdRead, block >> 8, block & 0xFF}\n\n\t// Calculate CRC for the command buffer\n\tcrc = d.calculateCRC(buffer)\n\tbuffer = append(buffer, crc...)\n\n\t// Send the command and receive the response\n\tresponse, err = d.sendCommand(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the response is valid and the CRC is correct\n\tresponseLength = len(response)\n\tif responseLength != 18 {\n\t\treturn nil, errors.New(\"Invalid response length\")\n\t}\n\n\tcrcResult = response[responseLength-2:]\n\tif !d.checkCRC(response[:responseLength-2], crcResult) {\n\t\treturn nil, errors.New(\"Invalid CRC\")\n\t}\n\n\t// Extract the data from the response\n\treadbackLength = responseLength - 2\n\treadback = response[1 : readbackLength-1]\n\n\t// Check if the readback equals the data\n\tlength = len(readback)\n\tdata = readback[1 : length-1]\n\treadbackCRC = readback[length-1:]\n\n\tif !d.checkCRC(readback[:length-1], readbackCRC) {\n\t\treturn nil, errors.New(\"Invalid CRC\")\n\t}\n\n\treturn data, nil\n}", "CodeBleu_score": 36.904715084988574}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\tvar err error\n\tvar buffer []byte\n\tvar buffer2 []byte\n\tvar buffer3 []byte\n\tvar buffer4 []byte\n\tvar buffer5 []byte\n\tvar buffer6 []byte\n\tvar buffer7 []byte\n\tvar buffer8 []byte\n\tvar buffer9 []byte\n\tvar buffer10 []byte\n\tvar buffer11 []byte\n\tvar buffer12 []byte\n\tvar buffer13 []byte\n\tvar buffer14 []byte\n\tvar buffer15 []byte\n\tvar buffer16 []byte\n\tvar buffer17 []byte\n\tvar buffer18 []byte\n\tvar buffer19 []byte\n\tvar buffer20 []byte\n\tvar buffer21 []byte\n\tvar buffer22 []byte\n\tvar buffer23 []byte\n\tvar buffer24 []byte\n\tvar buffer25 []byte\n\tvar buffer26 []byte\n\tvar buffer27 []byte\n\tvar buffer28 []byte\n\tvar buffer29 []byte\n\tvar buffer30 []byte\n\tvar buffer31 []byte\n\tvar buffer32 []byte\n\tvar buffer33 []byte\n\tvar buffer34 []byte\n\tvar buffer35 []byte\n\tvar buffer36 []byte\n\tvar buffer37 []byte\n\tvar buffer38 []byte\n\tvar buffer39 []byte\n\tvar buffer40 []byte\n\tvar buffer41 []byte\n\tvar buffer42 []byte\n\tvar buffer43 []byte\n\tvar buffer44 []byte\n\tvar buffer45 []byte\n\tvar buffer46 []byte\n\tvar buffer47 []byte\n\tvar buffer48 []byte\n\tvar buffer49 []byte\n\tvar buffer50 []byte\n\tvar buffer51 []byte\n\tvar buffer52 []byte\n\tvar buffer53 []byte\n\tvar buffer54 []byte\n\tvar buffer55 []byte\n\tvar buffer56 []byte\n\tvar buffer57 []byte\n\tvar buffer58 []byte\n\tvar buffer59 []byte\n\tvar buffer60 []byte\n\tvar buffer61 []byte\n\tvar buffer62 []byte\n\tvar buffer63 []byte\n\tvar buffer64 []byte\n\tvar buffer65", "CodeBleu_score": 4.774754386663577}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// Check if we have space for the answer\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"no room for answer\")\n\t}\n\t// Prepare the request\n\td.clearRegisterBitMask(d.CollReg, 0x80) // Clear the CRC-Result-Bit\n\td.setRegisterBitMask(d.CollReg, 0x40)   // Set the CRC-Calculation-Bit\n\td.writeRegister(d.CommandReg, d.PCD_Transceive)\n\td.writeRegister(d.ModeReg, d.PCD_Transceive)\n\td.writeRegister(d.TransceiveReg, reqMode)\n\t// Transmit the request\n\terr := d.transceiveData(nil, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Check if the response is valid\n\tif d.readRegister(d.TransceiveReg) != 0x10 {\n\t\treturn errors.New(\"invalid response\")\n\t}\n\tif d.readRegister(d.Status2Reg) & 0x08 != 0 {\n\t\treturn errors.New(\"CRC error\")\n\t}\n\tif d.readRegister(d.Status2Reg) & 0x04 != 0 {\n\t\treturn errors.New(\"parity error\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 56.29047973314955}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer too small\")\n\t}\n\n\td.clearBitmask(d.CollReg, 0x80) // ValuesAfterColl=1 => Bits received after collision are cleared.\n\n\td.writeByte(d.BitFramingReg, 0x07) // Transmit only 7 bits of last byte.\n\n\tvar buf []byte\n\tif reqMode == d.PICC_CMD_REQA {\n\t\tbuf = []byte{d.PICC_CMD_REQA, 0x20}\n\t} else if reqMode == d.PICC_CMD_WUPA {\n\t\tbuf = []byte{d.PICC_CMD_WUPA, 0x20}\n\t} else if reqMode == d.PICC_CMD_CT {\n\t\tbuf = []byte{d.PICC_CMD_CT, 0x00}\n\t} else {\n\t\treturn errors.New(\"unsupported request mode\")\n\t}\n\n\terr := d.transceive(buf, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(answer) == 2 && answer[0] == 0 && answer[1] == 0 {\n\t\treturn errors.New(\"PICC did not answer\")\n\t}\n\n\tif d.readBitmask(d.CollReg, 0x80) != 0 {\n\t\treturn errors.New(\"collision detected\")\n\t}\n\n\tif d.readBitmask(d.CollReg, 0x40) != 0 {\n\t\treturn errors.New(\"transmission error\")\n\t}\n\n\tif d.readBitmask(d.CollReg, 0x10) != 0 {\n\t\treturn errors.New(\"receiver overrun\")\n\t}\n\n\tif d.readBitmask(d.CollReg, 0x08) != 0 {\n\t\treturn errors.New(\"parity error\")\n\t}\n\n\tif d.readBitmask(d.CollReg, 0x04)", "CodeBleu_score": 50.03261284311281}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// Check if there is enough room in the answer buffer\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"noRoom\")\n\t}\n\n\t// Clear certain bits in the collision register\n\td.clearRegisterBitMask(CollReg, 0x80) // ValuesAfterColl\n\td.clearRegisterBitMask(CollReg, 0x40) // CollPosNotValid\n\n\t// Set the transmission to use only 7 bits of the last byte\n\tif reqMode == PiccReqID {\n\t\td.setRegisterBitMask(TxModeReg, 0x02) // TxLastBits\n\t} else {\n\t\td.clearRegisterBitMask(TxModeReg, 0x02) // TxLastBits\n\t}\n\n\t// Transmit the request\n\td.writeRegister(TxControlReg, reqMode)\n\n\t// Transceive the request\n\terr := d.transceiveData(answer, 2)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if there was a collision\n\tif d.checkRegisterBitMask(CollReg, 0x80) {\n\t\treturn errors.New(\"collision\")\n\t}\n\n\t// Check if the PICC responded with a valid answer\n\tif !d.checkRegisterBitMask(CollReg, 0x08) {\n\t\treturn errors.New(\"noAnswer\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 55.52079471837437}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.Out(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\terr = d.stepPin.Out(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif d.direction == Clockwise {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 64.10320933076207}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif err := d.setStepPin(0); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\tif err := d.setStepPin(1); err != nil {\n\t\treturn err\n\t}\n\tif d.direction == 1 {\n\t\td.currentStep++\n\t} else {\n\t\td.currentStep--\n\t}\n\treturn nil\n}", "CodeBleu_score": 62.393694210026936}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\terr := d.stepPin.Out(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\terr = d.stepPin.Out(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 63.20243403395399}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor is already running\")\n\t}\n\n\td.distanceMonitorStop = make(chan struct{})\n\td.distanceMonitorWg = &sync.WaitGroup{}\n\td.distanceMonitorWg.Add(1)\n\n\tgo d.monitorDistance()\n\n\td.distanceMonitorRunning = true\n\n\treturn nil\n}", "CodeBleu_score": 34.16844997937414}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.stopChannel != nil {\n\t\treturn errors.New(\"Distance monitor is already running\")\n\t}\n\n\td.stopChannel = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\tgo d.monitorDistance(d.stopChannel, d.wg)\n\treturn nil\n}", "CodeBleu_score": 33.094313471626904}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitoring {\n\t\treturn errors.New(\"distance monitor is already running\")\n\t}\n\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitorWg = &sync.WaitGroup{}\n\td.distanceMonitorWg.Add(1)\n\tgo d.distanceMonitor()\n\td.distanceMonitoring = true\n\treturn nil\n}", "CodeBleu_score": 33.93310486436475}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTime time.Time\n\treturn func(pin int, value time.Duration, edge string, tick uint32, count uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else {\n\t\t\tduration := time.Since(startTime)\n\t\t\td.send(duration)\n\t\t}\n\t}\n}", "CodeBleu_score": 34.97478269917088}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTime time.Time\n\treturn func(pin int, value time.Duration, edge string, tick uint32, count uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else {\n\t\t\tduration := time.Now().Sub(startTime)\n\t\t\td.DistanceChannel <- duration.Seconds() * 34000 / 2\n\t\t\tstartTime = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 37.18064016905499}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTime time.Time\n\treturn func(pin int, value time.Duration, edge string, tick uint32, count uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := time.Since(startTime)\n\t\t\td.Echo.Send(duration.Seconds() * 1000000)\n\t\t}\n\t}\n}", "CodeBleu_score": 36.479221843196534}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor\n\terr := d.trigger.Out(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the sensor to measure the distance\n\ttime.Sleep(d.measurementTimeout)\n\n\t// Check if the sensor timed out\n\tif d.echo.Read() == gpio.Low {\n\t\treturn errors.New(\"timeout\")\n\t}\n\n\t// Store the measured time\n\td.measuredTime = time.Now().UnixNano() / int64(time.Microsecond)\n\n\treturn nil\n}", "CodeBleu_score": 50.99655637087697}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\td.triggerPin.SetValue(gpio.High)\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.SetValue(gpio.Low)\n\n\ttimeout := time.After(d.timeout)\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn errors.New(\"timeout waiting for sensor to respond\")\n\t\tcase <-d.echoPin.WaitForEdge(gpio.RisingEdge):\n\t\t\td.startTime = time.Now()\n\t\t\treturn nil\n\t\t}\n\t}\n}", "CodeBleu_score": 46.6286934134707}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\terr := d.triggerSensor()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td.waitForMeasurement()\n\n\treturn nil\n}", "CodeBleu_score": 38.81150246262609}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t# Check if the token is available in the environment variables\n    if self.token_env_var in os.environ:\n        return os.environ[self.token_env_var]\n    # Check if the token is available in the local state\n    if self.state_file_path.exists():\n        with self.state_file_path.open(\"r\") as file:\n            state = json.load(file)\n        if \"access_token\" in state:\n            access_token = state[\"access_token\"]\n            if \"expires_at\" in state:\n                expires_at = datetime.datetime.fromisoformat(state[\"expires_at\"])\n                if expires_at > datetime.datetime.now():\n                    return access_token\n            if \"refresh_token\" in state:\n                refresh_token = state[\"refresh_token\"]\n                # Attempt to fetch a new access token using the refresh token\n                try:\n                    response = self.session.post(\n                        url=self.api_url + \"/oauth/token\",\n                        data={\n                            \"grant_type\": \"refresh_token\",\n                            \"refresh_token\": refresh_token,\n                            \"client_id\": self.client_id,\n                            \"client_secret\": self.client_secret,\n                        },\n                    )\n                    response.raise_for_status()\n                    response_data = response.json()\n                    access_token = response_data[\"access_token\"]\n                    expires_at = datetime.datetime.now() + datetime.timedelta(\n                        seconds=response_data[\"expires_in\"]\n                    )\n                    state[\"access_token\"] = access_token\n                    state[\"expires_at\"] = expires_at.isoformat()\n                    with self.state_file_path.open(\"w\") as file:\n                        json.dump(state, file, indent=4)\n                    return access_token\n                except HTTPClientError as exc:\n                    raise AccountError(exc) from exc\n            else:\n                return access_token\n    # Raise an exception if no authentication token is available\n    raise AccountNotAuthorized(", "CodeBleu_score": 37.16315664839407}, {"code": "def fetch_authentication_token(self)\n\ttry:\n        token = self.state.get_authentication_token()\n    except (StateError, TypeError):\n        token = None\n\n    if token is None:\n        try:\n            token = self.state.get_refresh_token()\n        except (StateError, TypeError):\n            token = None\n\n    if token is None:\n        raise AccountNotAuthorized()\n\n    try:\n        token_expiration_time = self.state.get_authentication_token_expiration_time()\n    except (StateError, TypeError):\n        token_expiration_time = None\n\n    if token_expiration_time is None:\n        raise AccountNotAuthorized()\n\n    if token_expiration_time <= datetime.now(timezone.utc):\n        try:\n            token = self.refresh_authentication_token(token)\n        except (StateError, TypeError):\n            raise AccountNotAuthorized()\n\n    return token\n\n", "CodeBleu_score": 27.061855498505295}, {"code": "def fetch_authentication_token(self)\n\tif \"ACCESS_TOKEN\" in os.environ:\n        return os.environ[\"ACCESS_TOKEN\"]\n    else:\n        try:\n            with open(self.state_file, \"r\") as f:\n                state = json.load(f)\n            if (\n                state[\"expiration_time\"] > datetime.now().timestamp()\n                and state[\"access_token\"]\n            ):\n                return state[\"access_token\"]\n            elif state[\"refresh_token\"]:\n                response = self.client.post(\n                    \"/auth/token\",\n                    data=json.dumps(\n                        {\n                            \"grant_type\": \"refresh_token\",\n                            \"refresh_token\": state[\"refresh_token\"],\n                        }\n                    ),\n                    headers={\"Content-Type\": \"application/json\"},\n                )\n                data = response.json()\n                if data[\"access_token\"]:\n                    state[\"access_token\"] = data[\"access_token\"]\n                    state[\"expiration_time\"] = (\n                        datetime.now() + timedelta(seconds=data[\"expires_in\"])\n                    ).timestamp()\n                    with open(self.state_file, \"w\") as f:\n                        json.dump(state, f)\n                    return state[\"access_token\"]\n            else:\n                raise AccountNotAuthorized(\n                    \"No access token available. Please run the 'login' command first.\"\n                )\n        except FileNotFoundError:\n            raise AccountNotAuthorized(\n                \"No access token available. Please run the 'login' command first.\"\n            )\n\n", "CodeBleu_score": 36.67317322630722}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\tself.refresh_token = self.session.get(\"refresh_token\")\n    self.session.delete()\n    try:\n        self.post(endpoint=\"/v1/logout\", data={\"refresh_token\": self.refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 46.635600661481895}, {"code": "def logout(self)\n\ttry:\n        self.session.refresh_token = self.session.refresh_token\n        self.session.delete_local_session()\n        self.http.post(\n            endpoint=\"/v1/logout\",\n            json={\n                \"refresh_token\": self.session.refresh_token,\n            },\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 49.800531267801404}, {"code": "def logout(self)\n\ttry:\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.post_request(\"/v1/logout\", json={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 58.459083904749086}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\tpackages = []\n    for pkg in self.get_used_packages():\n        if not pkg.optional:\n            packages.append(\n                {\n                    \"name\": pkg.name,\n                    \"version\": pkg.version,\n                    \"source\": pkg.source if pkg.external else None,\n                }\n            )\n    return packages\n\n", "CodeBleu_score": 23.611909838964273}, {"code": "def dump_used_packages(self)\n\tpackages = []\n    for name in self.get_used_packages():\n        pkg = self.get_package(name)\n        if not pkg.optional:\n            data = {\"name\": pkg.name, \"version\": pkg.version}\n            if pkg.external:\n                data[\"source\"] = pkg.source\n            packages.append(data)\n    return packages", "CodeBleu_score": 32.25399673145128}, {"code": "def dump_used_packages(self)\n\tpackages = []\n    for package in self.get_used_packages():\n        if package.is_optional():\n            continue\n        packages.append({\n            \"name\": package.name,\n            \"version\": package.version,\n            \"source\": package.source,\n        })\n    return packages\n\n", "CodeBleu_score": 21.73717577056282}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif not env:\n        raise exception.UndefinedEnvPlatformError(env)\n    platform_spec = cls.config.get_platform_spec(env)\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.project_env = env\n    instance.configure_project_packages(targets=targets)\n    return instance\n\n", "CodeBleu_score": 39.446007001103915}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif env not in cls.config.envs:\n        raise exception.UndefinedEnvPlatformError(env)\n    env_platform = cls.config.envs[env]\n    instance = cls(env_platform, autoinstall=autoinstall)\n    instance.project_env = env\n    instance.config_packages(targets)\n    return instance\n\n", "CodeBleu_score": 37.317980197728204}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif not isinstance(env, str):\n        raise TypeError(\"env must be a string\")\n    if targets is not None and not isinstance(targets, list):\n        raise TypeError(\"targets must be a list\")\n    if not isinstance(autoinstall, bool):\n        raise TypeError(\"autoinstall must be a boolean\")\n    platform_spec = cls.project.get_platform_spec(env)\n    if platform_spec is None:\n        raise exception.UndefinedEnvPlatformError(env)\n    instance = cls(platform_spec, autoinstall)\n    instance.project_env = env\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 31.776424747498254}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 71.53941436867237}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (int i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 71.53941436867237}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 68.95857331280064}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        uint8_t val = (time_in_us & 0x00FF0000) >> 16;\n        Write1Byte(0x82, val);\n        val = (time_in_us & 0x0000FF00) >> 8;\n        Write1Byte(0x83, val);\n        val = time_in_us & 0x000000FF;\n        Write1Byte(0x84, val);\n        Write1Byte(0x81, 0x01);\n    } else {\n        Write1Byte(0x81, 0x00);\n    }\n    Write1Byte(0x36, 0x17);\n}", "CodeBleu_score": 53.528434220387}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        SetTimer(time_in_us);\n        EnableTimerWakeup();\n    } else {\n        DisableTimerWakeup();\n    }\n    Write1Byte(0x35, 0x00);\n    delay(10);\n}", "CodeBleu_score": 52.7549842987311}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n\n    if (time_in_us) {\n        uint8_t t = (time_in_us / 625 / 1000) & 0x0F;\n        if (t == 0)\n            t = 1;\n        Write1Byte(0x81, t);\n        Write1Byte(0x35, Read8bit(0x35) | (1 << 3));\n    } else {\n        Write1Byte(0x81, 0x00);\n        Write1Byte(0x35, Read8bit(0x35) & 0xF7);\n    }\n\n    Write1Byte(0x36, 0x27);\n}", "CodeBleu_score": 35.5043216321149}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n    int y = scroll_line_y;\n    tft.fillRect(0, y, 240, 16, color);\n    y += 16;\n    if (y >= 320 - BOTTOM_FIXED_AREA) y = TOP_FIXED_AREA;\n    if (y >= TOP_FIXED_AREA_ALT) y = TOP_FIXED_AREA_ALT;\n    scrollAddress(y);\n    scroll_line_y = y;\n    return y;\n  #endif\n}", "CodeBleu_score": 19.434284934851597}, {"code": "int Display::scroll_line(uint32_t color){\n\t// Store current y-coordinate\n  int y = y_coordinate;\n  // Fill rectangle with specified color\n  tft.fillRect(0, y, tft.width(), tft.fontHeight(), color);\n  // Increment y-coordinate\n  y += tft.fontHeight();\n  // Wrap around if y-coordinate exceeds display boundaries\n  if (y >= tft.height() - bottom_fixed_area) {\n    y = top_fixed_area;\n  }\n  // Use alternative top fixed area coordinates if a specific condition is met\n  if (y >= tteBar) {\n    y = top_fixed_area_alt;\n  }\n  // Update scroll address\n  scrollAddress(y);\n  // Return previous y-coordinate\n  return y;\n}", "CodeBleu_score": 18.65271919684965}, {"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n    int y = y_line;\n    if (y >= tft.height() - tft.fontHeight(1) - bottom_fixed_area) {\n      y = top_fixed_area;\n      if (tteBar) {\n        y = top_fixed_area_2;\n      }\n    } else {\n      y += tft.fontHeight(1);\n    }\n    tft.fillRect(0, y, tft.width(), tft.fontHeight(1), color);\n    y_line = y;\n    scrollAddress(y);\n    return y;\n  #endif\n}", "CodeBleu_score": 18.6916818387282}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  // setup access points\n  if (!this->setupAPs()) {\n    return false;\n  }\n\n  // setup HTML content\n  if (!this->setupHTML()) {\n    return false;\n  }\n\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 60.10456322620159}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tif (!this->setSSIDs(ssids)) {\n    return false;\n  }\n\n  if (!this->setAccessPoints(access_points)) {\n    return false;\n  }\n\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 62.06512746755357}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t// set access points\n  this->setAccessPoints(access_points);\n  // set ssids\n  this->setSSIDs(ssids);\n\n  // start portal\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 52.70425853536891}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n\t\tif (queue == NULL) {\n\t\t\tqueue = new std::queue<std::string>();\n\t\t}\n\t\tif (text == NULL) {\n\t\t\ttext = new std::string();\n\t\t}\n\t\tif (text_in == NULL) {\n\t\t\ttext_in = new std::string();\n\t\t}\n\t} else {\n\t\tqueue_enabled_flag = true;\n\t\tflush_queue();\n\t}\n}", "CodeBleu_score": 14.323073108959608}, {"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n    if (!queue) {\n      queue = new Queue<char *>();\n    }\n    if (!text) {\n      text = new String();\n    }\n    if (!text_in) {\n      text_in = new String();\n    }\n  } else {\n    if (queue) {\n      delete queue;\n    }\n    if (text) {\n      delete text;\n    }\n    if (text_in) {\n      delete text_in;\n    }\n    queue = new Queue<char *>();\n    text = new String();\n    text_in = new String();\n    queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 13.429538883070045}, {"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n\t\t// If the queue is already enabled, ensure that the queue, text, and text_in are initialized\n\t\tif (queue == NULL) {\n\t\t\tqueue = new Queue<char>();\n\t\t}\n\t\tif (text == NULL) {\n\t\t\ttext = new Text();\n\t\t}\n\t\tif (text_in == NULL) {\n\t\t\ttext_in = new Text();\n\t\t}\n\t} else {\n\t\t// If the queue is not enabled, flush the existing queue and set the queue_enabled_flag to true\n\t\tflush();\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 12.818561933273024}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\tif (nmea_queue != NULL) {\n\t\tif (nmea_queue->size() > 0) {\n\t\t\tqueue<string> *new_queue = new queue<string>();\n\t\t\tdelete nmea_queue;\n\t\t\tnmea_queue = new_queue;\n\t\t}\n\t} else {\n\t\tnmea_queue = new queue<string>();\n\t}\n\n}", "CodeBleu_score": 43.87739143228061}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif (queue_nmea != NULL) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = new std::queue<std::string>();\n\t}\n\telse {\n\t\tqueue_nmea = new std::queue<std::string>();\n\t}\n}", "CodeBleu_score": 37.7731999046044}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif(queue_nmea != NULL) {\n\t\tqueue_nmea = new std::queue<std::string>();\n\t}\n\telse {\n\t\tqueue_nmea = new std::queue<std::string>();\n\t}\n}", "CodeBleu_score": 35.19162249536406}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t/*Return if the area is out the screen*/\n    if (area->x2 < 0 || area->y2 < 0 || area->x1 > TFT_WIDTH - 1 || area->y1 > TFT_HEIGHT - 1) {\n      lv_disp_flush_ready(disp);\n      return;\n    }\n\n    /*Truncate the area to the screen*/\n    int32_t act_x1 = area->x1 < 0 ? 0 : area->x1;\n    int32_t act_y1 = area->y1 < 0 ? 0 : area->y1;\n    int32_t act_x2 = area->x2 > TFT_WIDTH - 1 ? TFT_WIDTH - 1 : area->x2;\n    int32_t act_y2 = area->y2 > TFT_HEIGHT - 1 ? TFT_HEIGHT - 1 : area->y2;\n\n    /*Write the buffer to the display*/\n    tft.startWrite();\n    tft.setAddrWindow(act_x1, act_y1, (act_x2 - act_x1 + 1), (act_y2 - act_y1 + 1));\n    uint32_t size = (act_x2 - act_x1 + 1) * (act_y2 - act_y1 + 1);\n    tft.pushColors((uint16_t *)&color_p->full, size, true);\n    tft.endWrite();\n\n    /*IMPORTANT!!!\n     * Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 42.91535986260584}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t// Start a write transaction\n    tft.startWrite();\n\n    // Set the address window to the specified area\n    tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n\n    // Iterate through each pixel in the area\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n\n        // Write the corresponding color from the provided color buffer\n        tft.pushColor(color_p->full);\n        color_p++;\n      }\n    }\n\n    // End the write transaction\n    tft.endWrite();\n\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 72.29801472472515}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t/*Return if the area is out the screen*/\n    if (area->x2 < 0 || area->y2 < 0 || area->x1 > disp->hor_res - 1 || area->y1 > disp->ver_res - 1) {\n      lv_disp_flush_ready(disp);\n      return;\n    }\n\n    /*Truncate the area to the screen*/\n    int32_t act_x1 = area->x1 < 0 ? 0 : area->x1;\n    int32_t act_y1 = area->y1 < 0 ? 0 : area->y1;\n    int32_t act_x2 = area->x2 > disp->hor_res - 1 ? disp->hor_res - 1 : area->x2;\n    int32_t act_y2 = area->y2 > disp->ver_res - 1 ? disp->ver_res - 1 : area->y2;\n\n    /*Write the buffer to the display*/\n    uint32_t size = (act_x2 - act_x1 + 1) * (act_y2 - act_y1 + 1) * sizeof(lv_color_t);\n    uint32_t offset = (act_x1 + act_y1 * disp->hor_res) * sizeof(lv_color_t);\n    uint32_t *buf = (uint32_t *)color_p;\n\n    /*Send the buffer to the display*/\n    if (disp->user_data != NULL) {\n      lv_disp_drv_user_data_t *user_data = disp->user_data;\n      user_data->flush(user_data->data, offset, size, buf);\n    }\n\n    /*Tell the graphics library that we are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 39.090918779986694}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tfor (int i = 0; i < menu->getNumberOfNodes(); i++) {\n    for (int j = 0; j < layer; j++) {\n      Serial.print(\" \");\n    }\n    Serial.print(menu->getNode(i)->getName());\n    Serial.println();\n  }\n  Serial.println();\n}", "CodeBleu_score": 65.20342178768631}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t// Iterate through all menu nodes\n\tfor (int i = 0; i < menu->getNumOfNodes(); i++) {\n\t\t// Print menu node name with indentation\n\t\tfor (int j = 0; j < layer; j++)\n\t\t\tcout << \" \";\n\t\tcout << menu->getNode(i)->getName() << endl;\n\t\t// If menu node is a menu, call showMenuList with the menu node as argument\n\t\tif (menu->getNode(i)->getType() == MENU)\n\t\t\tshowMenuList((Menu*)menu->getNode(i), layer + 1);\n\t}\n\t// Print an empty line\n\tcout << endl;\n}", "CodeBleu_score": 46.03412164629406}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tfor (int i = 0; i < menu->getNumberOfNodes(); i++) {\n        for (int j = 0; j < layer; j++) {\n            cout << \"  \";\n        }\n        cout << menu->getNode(i)->getName() << endl;\n    }\n    cout << endl;\n}", "CodeBleu_score": 51.609385578827116}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\tint i = 0;\n  while (i < count) {\n    String ssid = generateRandomSSID();\n    int channel = generateRandomChannel();\n    String mac = generateRandomMAC();\n    addSSID(ssid, channel, mac);\n    i++;\n  }\n  return i;\n}", "CodeBleu_score": 21.184940749430297}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint i = 0;\n  while (i < count) {\n    String ssid = generateSSID();\n    ssidList.add(ssid);\n    Serial.print(\"SSID: \");\n    Serial.println(ssid);\n    i++;\n  }\n  return i;\n}", "CodeBleu_score": 22.32767670412375}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tfor (int i = 0; i < count; i++) {\n\n\t\t// Create a random SSID\n\t\tString ssid = \"\";\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tssid += (char)random(97, 122);\n\t\t}\n\n\t\t// Create a random MAC address\n\t\tString mac = \"\";\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tmac += (char)random(97, 122);\n\t\t}\n\n\t\t// Create a random channel\n\t\tint channel = random(1, 11);\n\n\t\t// Add the generated SSID to the list\n\t\taddSSID(ssid, mac, channel);\n\n\t\t// Print the generated SSID to the serial output\n\t\tSerial.print(\"Generated SSID: \");\n\t\tSerial.print(ssid);\n\t\tSerial.print(\" MAC: \");\n\t\tSerial.print(mac);\n\t\tSerial.print(\" Channel: \");\n\t\tSerial.println(channel);\n\t}\n\n\treturn count;\n}", "CodeBleu_score": 39.97004430946174}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\timport datetime\n    import json\n\n    import jwt\n\n    # The current time in UTC\n    now = datetime.datetime.utcnow()\n\n    # The JWT will expire in one hour\n    exp = now + datetime.timedelta(hours=1)\n\n    # The JWT will be issued now\n    iat = now\n\n    # The JWT will be issued for the provided GCP project ID\n    aud = project_id\n\n    # Read the private key from the file\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    # Create the JWT\n    jwt_token = jwt.encode(\n        {\n            \"aud\": aud,\n            \"iat\": iat,\n            \"exp\": exp,\n        },\n        private_key,\n        algorithm=algorithm,\n    )\n\n    return jwt_token\n\n", "CodeBleu_score": 51.001656032209986}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\timport datetime\n    import json\n\n    from cryptography.hazmat.primitives import serialization\n    from cryptography.hazmat.primitives.asymmetric import padding\n\n    from google.auth.crypt import _fixed_length_padding\n    from google.auth.crypt import _JWTSigner\n\n    # The payload is the JSON representation of the JWT Claims Set.\n    # The payload contains the issuer (iss), the subject (sub), the audience (aud),\n    # the issued at time (iat), and the expiration time (exp).\n    # For more information, see https://tools.ietf.org/html/rfc7519#section-4.1\n    # The payload should be a JSON string that looks like this:\n    # {\n    #   \"iss\": \"service-account-name@project-id.iam.gserviceaccount.com\",\n    #   \"sub\": \"service-account-name@project-id.iam.gserviceaccount.com\",\n    #   \"aud\": \"https://pubsub.googleapis.com/\",\n    #   \"iat\": 1511210460,\n    #   \"exp\": 1511296860\n    # }\n    now = datetime.datetime.utcnow()\n    payload = {\n        \"iss\": \"service-account-name@project-id.iam.gserviceaccount.com\",\n        \"sub\": \"service-account-name@project-id.iam.gserviceaccount.com\",\n        \"aud\": \"https://pubsub.googleapis.com/\",\n        \"iat\": now,\n        \"exp\": now + datetime.timedelta(hours=1),\n    }\n\n    # Read the private key file.\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    # Load the private key.\n    signer = _JWTSigner.from_service_account_info(json.loads(private_key))\n\n    # Get the JWT that was signed.\n    signed_jwt = signer.sign(json.dumps(payload))\n    return signed", "CodeBleu_score": 46.03951118340144}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\timport datetime\n    import json\n    import time\n\n    import jwt\n\n    # Set issued time (iat) to current UTC time and expiration time (exp) to one hour later\n    current_time_utc = datetime.datetime.utcnow()\n    iat = current_time_utc\n    exp = current_time_utc + datetime.timedelta(hours=1)\n\n    # Read private key from file\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    # Create JWT payload\n    payload = {\n        \"iat\": iat,\n        \"exp\": exp,\n        \"aud\": project_id,\n    }\n\n    # Create JWT\n    jwt_token = jwt.encode(payload, private_key, algorithm=algorithm)\n\n    return jwt_token\n\n", "CodeBleu_score": 52.679319694347335}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\tpayload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        print('Capturing preview image...')\n        path = '/tmp/image.jpg'\n        preview_capture(path)\n        print('Preview image captured.')\n        print('Uploading file to Cloud Storage...')\n        url = upload_file(path, bucket_name)\n        print('File uploaded to {}.'.format(url))\n        print('Publishing event message...')\n        client.publish('events', url, qos=1)\n        print('Event message published.')\n    else:\n        print('off')\n\n", "CodeBleu_score": 48.7127328123217}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tpayload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        print('Capturing preview image.')\n        preview_capture('image.jpg')\n        print('Uploading file.')\n        url = upload_file('image.jpg', args.bucket_name)\n        print('File uploaded to {}'.format(url))\n        print('Publishing message to events topic.')\n        client.publish('events', url, qos=1)\n    else:\n        print('off')\n\n", "CodeBleu_score": 49.19064079898665}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print('Capturing preview image...')\n        path = '/home/pi/Desktop/image.jpg'\n        preview_capture(path)\n        print('Uploading image to Cloud Storage...')\n        url = upload_file(path, bucket_name)\n        print('Uploaded image to {}'.format(url))\n        print('Publishing image URL to MQTT event topic...')\n        publish(client, 'events', url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 40.755669415015426}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\timport argparse\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT example. This example connects to the MQTT bridge, sends 10 messages, then exits.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--registry_id\", required=True, help=\"Cloud IoT Core registry id\")\n    parser.add_argument(\"--device_id\", required=True, help=\"Cloud IoT Core device id\")\n    parser.add_argument(\"--private_key_file\", required=True, help=\"Path to private key file.\")\n    parser.add_argument(\"--algorithm\", choices=(\"RS256\", \"ES256\"), default=\"RS256\", help=\"Encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\")\n    parser.add_argument(\"--num_messages\", default=10, type=int, help=\"Number of messages to send.\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", default=\"mqtt.googleapis.com\", help=\"MQTT bridge hostname.\")\n    parser.add_argument(\"--mqtt_bridge_port\", choices=(8883, 443), default=8883, type=int, help=\"MQTT bridge port.\")\n    parser.add_argument(\"--message_type\", default=\"event\", choices=(\"event\", \"state\"), help=\"Indicates whether the message to be sent is a telemetry event or a device state message.\")\n    parser.add_argument(\"--jwt_expires_minutes\", default=20, type=int, help=\"Expiration time, in minutes, for JWT tokens.\")\n    parser.add_argument(\"--ca_certs\", default=\"roots.pem\", help=\"CA root certificate from https://pki.google.com/roots.pem\")\n    return parser.parse_args()\n\n", "CodeBleu_score": 39.084095342662074}, {"code": "def parse_command_line_args()\n\timport argparse\n    import os\n\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT example.')\n    parser.add_argument('--project_id', default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n                        help='GCP cloud project name')\n    parser.add_argument('--registry_id', required=True, help='Cloud IoT Core registry id')\n    parser.add_argument('--device_id', required=True, help='Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', required=True, help='Path to private key file.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), default='RS256',\n                        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--ca_certs', default='roots.pem',\n                        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--num_messages', type=int, default=100,\n                        help='Number of messages to publish.')\n    parser.add_argument('--message_type', choices=('event', 'state'),\n                        default='event', help='Indicates whether the message to be published is a '\n                        'telemetry event or a device state message.')\n    parser.add_argument('--mqtt_bridge_hostname',\n                        default='mqtt.googleapis.com',\n                        help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20,\n                        help='Expiration time, in minutes, for JWT tokens.')\n    return parser.parse_args()\n\n", "CodeBleu_score": 53.49706123541187}, {"code": "def parse_command_line_args()\n\timport argparse\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT device connection example.')\n    parser.add_argument('--project_id', default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n                        help='GCP cloud project name')\n    parser.add_argument('--registry_id', required=True,\n                        help='Cloud IoT Core registry id')\n    parser.add_argument('--device_id', required=True,\n                        help='Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', required=True,\n                        help='Path to private key file.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'),\n                        default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--cloud_region', default='us-central1',\n                        help='GCP cloud region')\n    parser.add_argument('--ca_certs', default='roots.pem',\n                        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--num_messages', type=int, default=100,\n                        help='Number of messages to publish.')\n    parser.add_argument('--message_type', choices=('event', 'state'),\n                        default='event', help='Indicates whether the message to be published is a telemetry event or a device state message.')\n    parser.add_argument('--mqtt_bridge_hostname',\n                        default='mqtt.googleapis.com',\n                        help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883,\n                        type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int,\n                        help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--client_id',", "CodeBleu_score": 37.37628760162301}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\tfrom googleapiclient.discovery import build\n    from google.oauth2 import service_account\n\n    # Define the API scopes\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Define the discovery API URL\n    api_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n\n    # Build the client\n    client = build('cloudiot', 'v1', credentials=credentials, discoveryServiceUrl=api_url)\n\n    return client\n\n", "CodeBleu_score": 44.8264395238053}, {"code": "def get_client(service_account_json)\n\t# Define the necessary API scopes, version, and discovery URL.\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    # Load the service account credentials, scopes them appropriately, and use them to build the client for the Cloud IoT Core service.\n    credentials = ServiceAccountCredentials.from_json_keyfile_name(service_account_json, scopes=scopes)\n    http = httplib2.Http()\n    credentials.authorize(http)\n    service = discovery.build(\n        \"cloudiot\",\n        api_version,\n        discoveryServiceUrl=discovery_url,\n        http=http,\n        cache_discovery=False,\n    )\n    return service\n\n", "CodeBleu_score": 25.417681143058633}, {"code": "def get_client(service_account_json)\n\t# Import the necessary libraries\n    import os\n    from googleapiclient import discovery\n\n    # Define the necessary API scopes, version, and discovery URL\n    SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n    VERSION = 'v1'\n    DISCOVERY_URL = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n\n    # Load the service account credentials, scopes them appropriately, and use them to build the client for the Cloud IoT Core service\n    os.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = service_account_json\n    service_account_credentials = os.environ.get(\"GOOGLE_APPLICATION_CREDENTIALS\")\n    credentials = service_account.Credentials.from_service_account_file(service_account_credentials, scopes=SCOPES)\n    service = discovery.build(\n        'cloudiot',\n        VERSION,\n        discoveryServiceUrl=DISCOVERY_URL,\n        credentials=credentials)\n\n    # Return the client for the Cloud IoT Core service\n    return service\n\n", "CodeBleu_score": 46.35384438343186}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t# Get ASN1 code for the hash method\n    if hash_method == 'sha1':\n        asn1_hash_method = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == 'sha224':\n        asn1_hash_method = b'\\x30\\x2d\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x04\\x05\\x00\\x04\\x1c'\n    elif hash_method == 'sha256':\n        asn1_hash_method = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'sha384':\n        asn1_hash_method = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'sha512':\n        asn1_hash_method = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method", "CodeBleu_score": 11.51995521258772}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\tasn1_code = hash_method_to_asn1[hash_method]\n    if asn1_code is None:\n        raise ValueError('Invalid hash method')\n\n    padded_hash = _pad_for_signing(hash_value, 128)\n    encrypted_hash = _encrypt_with_private_key(padded_hash, priv_key)\n    return b''.join([asn1_code, encrypted_hash])\n\n", "CodeBleu_score": 21.67959641315065}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t# Get the ASN1 code for the hash method\n    asn1_code = hash_method_to_asn1(hash_method)\n\n    # Concatenate the ASN1 code with the hash value\n    concat = asn1_code + hash_value\n\n    # Pad the concatenated value for signing\n    padded = _pad_for_signing(concat, 128)\n\n    # Encrypt the padded value using the private key\n    encrypted = priv_key.encrypt(padded, RSA.pkcs1_padding)\n\n    # Return the encrypted signature\n    return encrypted\n\n", "CodeBleu_score": 11.121396123248122}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t# Convert the signature to an integer\n    sig_int = int(binascii.hexlify(signature), 16)\n\n    # Decrypt the signature to obtain the clear signature\n    clear_sig = rsa.rsa_decrypt(sig_int, pub_key)\n\n    # Determine the hash method used\n    hash_method = _find_method_hash(clear_sig)\n\n    # Compute the hash of the message\n    hash_value = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    padded_hash = _pad_for_signing(hash_value, len(clear_sig))\n\n    # If the expected padded hash does not match the clear signature, raise a verification error\n    if padded_hash != clear_sig:\n        raise VerificationError('Verification failed')\n\n    # If the verification is successful, return the hash method name\n    return hash_method\n", "CodeBleu_score": 20.75120742894106}, {"code": "def verify(message, signature, pub_key)\n\t# convert the signature to an integer\n    signature = int(signature, 16)\n\n    # decrypt the signature to obtain the clear signature\n    clearsig = pow(signature, pub_key.e, pub_key.n)\n\n    # determine the hash method used\n    method_name = _find_method_hash(clearsig)\n\n    # compute the hash of the message\n    msghash = compute_hash(message, method_name)\n\n    # reconstruct the expected padded hash\n    expected_clearsig = _pad_for_signing(msghash, pub_key.size)\n\n    # if the expected padded hash does not match the clear signature, raise a verification error\n    if expected_clearsig != clearsig:\n        raise VerificationError('Verification failed')\n\n    # if the verification is successful, return the hash method name\n    return method_name\n\n", "CodeBleu_score": 27.05400317829831}, {"code": "def verify(message, signature, pub_key)\n\t# Convert the signature to an integer\n    signature = int(signature, 16)\n\n    # Decrypt the signature to obtain the clear signature\n    clearsig = pow(signature, pub_key.e, pub_key.n)\n\n    # Determine the hash method used\n    method_name = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    message_hash = compute_hash(message, method_name)\n\n    # Reconstruct the expected padded hash\n    padded_hash = _pad_for_signing(message_hash, pub_key.size)\n\n    # If the expected padded hash does not match the clear signature, raise a verification error\n    if padded_hash != clearsig:\n        raise VerificationError('Verification failed')\n\n    # If the verification is successful, return the hash method name\n    return method_name\n\n", "CodeBleu_score": 29.11618924390514}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\ttime_t epoch;\n   int res = CRYPTO_CLIENT_getEpochTime(&epoch);\n   if (res == 0) {\n      debug_printInfo(\"MQTT: epoch time: %ld\", epoch);\n      updateJWT(epoch);\n   } else {\n      debug_printError(\"MQTT: Failed to retrieve time\");\n   }\n   mqttConnect();\n   mqttSubscribe = 1;\n   debug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 46.5317908248066}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n   if (getTime(&epoch)) {\n      updateJWT(epoch);\n   }\n   mqttConnected = false;\n   mqttConnect();\n   mqttSubscribe = true;\n   debug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 23.772866263942934}, {"code": "static void connectMQTT(){\n\ttime_t epoch = CRYPTO_CLIENT_getEpochTime();\n   if (epoch > 0) {\n      updateJWT(epoch);\n   }\n\n   mqtt_connect();\n   mqtt_subscribe = 1;\n   debug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 23.961381856038216}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t n = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t c = *str++;\n        if (c < '0' || c > '9') {\n            return str - 1;\n        }\n        n = 10 * n + c - '0';\n    }\n    *num = n;\n    return str;\n}", "CodeBleu_score": 23.820827959287765}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t*num = 0;\n    for (int i = 0; i < width; i++) {\n        if (str[i] >= '0' && str[i] <= '9') {\n            *num *= 10;\n            *num += (str[i] - '0');\n        } else {\n            return str;\n        }\n    }\n    return str + width;\n}", "CodeBleu_score": 24.577688626123837}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tint i;\n    *num = 0;\n    for(i = 0; i < width; i++) {\n        if(str[i] >= '0' && str[i] <= '9') {\n            *num = *num * 10 + (str[i] - '0');\n        } else {\n            return str;\n        }\n    }\n    return str + width;\n}", "CodeBleu_score": 23.939271190219934}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    size_t cert_size = 0;\n    uint8_t cert_sn[32];\n    size_t cert_sn_size = 0;\n    uint8_t cert_sn_src[32];\n    size_t cert_sn_src_size = 0;\n    uint8_t issue_date_raw[DATEFMT_ISO8601_SIZE];\n    size_t issue_date_raw_size = 0;\n    uint8_t expire_date_raw[DATEFMT_ISO8601_SIZE];\n    size_t expire_date_raw_size = 0;\n    atcacert_tm_utc_t issue_date;\n    atcacert_tm_utc_t expire_date;\n    atcacert_tm_utc_t current_date;\n    uint8_t current_date_raw[DATEFMT_ISO8601_SIZE];\n    size_t current_date_raw_size = 0;\n    uint8_t public_key[72];\n    size_t public_key_size = 0;\n    uint8_t public_key_src[72];\n    size_t public_key_src_size = 0;\n    uint8_t signer_id[2];\n    size_t signer_id_size = 0;\n    uint8_t signer_id_src[2];\n    size_t signer_id_src_size = 0;\n    uint8_t auth_key_id[32];\n    size_t auth_key_id_size = 0;\n    uint8_t auth_key_id_src[32];\n    size_t auth_key_id_src_size = 0;\n    uint8_t subj_key_id[32];\n    size_t subj_key_id_size = 0;\n    uint8_t subj_key_id_src[32];\n    size_t subj_key_id_src_size = 0;\n    uint8_t issue", "CodeBleu_score": 10.617346262096092}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    uint8_t sn[32];\n    size_t sn_size = sizeof(sn);\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Generate the serial number if necessary\n    ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->device_sn);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Generate the signature\n    ret = atcacert_get_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, sn, &sn_size);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    ret = atcac_sw_sha2_256(sn, sn_size, build_state->cert_sn_digest);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    ret = atcac_sw_sha2_256(build_state->cert, build_state->cert_size, build_state->cert_sn_digest);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    return atcac_sw_sha2_256(build_state->cert_sn_digest, 32, build_state->cert_sn_digest);\n}", "CodeBleu_score": 64.43897670023651}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    uint8_t cert_sn[32];\n    size_t cert_sn_size = sizeof(cert_sn);\n    uint8_t issue_date_enc[DATE_ENC_SIZE];\n    atcacert_tm_utc_t issue_date;\n\n    if (build_state == NULL || build_state->cert_def == NULL || build_state->cert == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Finish the cert SN\n    if (build_state->cert_def->std_cert_elements[STDCERT_CERT_SN].count > 0)\n    {\n        ret = atcacert_get_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, cert_sn, &cert_sn_size);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->device_sn);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    // Finish the issue date\n    if (build_state->cert_def->std_cert_elements[STDCERT_ISSUE_DATE].count > 0)\n    {\n        ret = atcacert_get_issue_date_enc(build_state->cert_def, build_state->cert, build_state->cert_size, issue_date_enc);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        ret = atcacert_date_dec_rfc5280_utc(issue_date_enc, &issue_date);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        ret = atcacert_set_issue_date(", "CodeBleu_score": 59.649461312967176}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcab_verify_extern(tbs_digest, signature, ca_public_key, NULL);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 84.45390409973317}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint                 ret = 0;\n    uint8_t             tbs_digest[32];\n    uint8_t             signature[64];\n    atcacert_device_loc_t ca_public_key_loc;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the TBS digest and signature from the certificate\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the device location of the CA public key\n    ret = atcacert_get_device_loc(cert_def, ca_public_key, &ca_public_key_loc);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the TBS digest against the signature using the CA public key\n    ret = atcab_verify_extern(tbs_digest, signature, ca_public_key_loc.zone, ca_public_key_loc.slot, ca_public_key_loc.is_genkey);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 82.79259597831592}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint                      ret = 0;\n    uint8_t                  tbs_digest[32];\n    uint8_t                  signature[64];\n    size_t                   tbs_digest_size = 0;\n    size_t                   signature_size = 0;\n    uint8_t                  public_key[72];\n    uint8_t                  public_key_size = 0;\n    atcacert_device_loc_t    ca_public_key_loc;\n    atcacert_device_loc_t    cert_sn_dev_loc;\n    uint8_t                  cert_sn[9];\n    uint8_t                  cert_sn_size = 0;\n    uint8_t                  is_device_sn = 0;\n    uint8_t                  is_device_sn_size = 0;\n    uint8_t                  is_device_sn_buf[4];\n    uint8_t                  is_device_sn_buf_size = 0;\n    uint8_t                  device_sn[9];\n    uint8_t                  device_sn_size = 0;\n    uint8_t                  device_sn_dev_loc;\n    uint8_t                  device_sn_dev_loc_size = 0;\n    uint8_t                  read_key[36];\n    uint8_t                  read_key_size = 0;\n    uint8_t                  read_key_dev_loc;\n    uint8_t                  read_key_dev_loc_size = 0;\n    uint8_t                  slot8_key[36];\n    uint8_t                  slot8_key_size = 0;\n    uint8_t                  slot8_key_dev_loc;\n    uint8_t                  slot8_key_dev_loc_size = 0;\n    uint8_t                  gen_key_id;\n    uint8_t                  gen_key_id_size = 0;\n    uint8_t                  gen_key_id_dev_loc;", "CodeBleu_score": 18.279144415821325}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tif (timer == NULL)\n        return false;\n\n    timerStruct_t * volatile *prev = list;\n    timerStruct_t * volatile *curr = list;\n\n    while (*curr != NULL)\n    {\n        if (*curr == timer)\n        {\n            *prev = (*curr)->next;\n            return true;\n        }\n        prev = curr;\n        curr = &(*curr)->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 27.579052198311704}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\ttimerStruct_t * volatile *current = list;\n    timerStruct_t * volatile *prev = list;\n\n    // Find the timer in the list\n    while (*current != NULL)\n    {\n        if (*current == timer)\n        {\n            // Remove the timer from the list\n            *prev = (*current)->next;\n            return true;\n        }\n        prev = current;\n        current = &((*current)->next);\n    }\n\n    return false;\n}", "CodeBleu_score": 25.49879051207383}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\ttimerStruct_t *current;\n    timerStruct_t *prev;\n\n    if(timer == NULL)\n        return false;\n\n    // Special case for head\n    if(timer == *list)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    current = *list;\n    prev = NULL;\n\n    while(current != NULL)\n    {\n        if(current == timer)\n        {\n            if(prev == NULL)\n                return false;\n\n            prev->next = current->next;\n            return true;\n        }\n\n        prev = current;\n        current = current->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 43.62997132095888}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tint ret = 0;\n\tif (socket < 0 || socket >= MAX_SOCKET) {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\treturn BSD_ERROR;\n\t}\n\tif (gastrSockets[socket].bIsUsed == 1) {\n\t\tret = close(socket);\n\t\tif (ret != BSD_SUCCESS) {\n\t\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\treturn BSD_SUCCESS;\n\t}\n\tbsd_setErrNo(BSD_EBADF);\n\treturn BSD_ERROR;\n}", "CodeBleu_score": 29.458139882946178}, {"code": "int BSD_close(int socket){\n\tint ret;\n\tif(socket < 0 || socket >= MAX_SOCKET) {\n\t\tbsd_setErrNo(EINVAL);\n\t\treturn BSD_ERROR;\n\t}\n\tif(gastrSockets[socket].bIsUsed == 1) {\n\t\tgastrSockets[socket].bIsUsed = 0;\n\t\tret = close(socket);\n\t\tif(ret == SOCK_ERR_NO_ERROR)\n\t\t\treturn BSD_SUCCESS;\n\t\telse {\n\t\t\tbsd_setErrNo(EIO);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(EBADF);\n\t\treturn BSD_ERROR;\n\t}\n}", "CodeBleu_score": 34.088828669304874}, {"code": "int BSD_close(int socket){\n\tint ret = 0;\n\tif(socket >= 0 && socket < MAX_SOCKET) {\n\t\tif(gastrSockets[socket].bIsUsed == 1) {\n\t\t\tret = close(socket);\n\t\t\tif(ret == 0) {\n\t\t\t\treturn BSD_SUCCESS;\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\t\treturn BSD_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\treturn BSD_ERROR;\n\t}\n}", "CodeBleu_score": 25.114773633553007}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tint ret;\n\t\n\tif ((ret = listen(socket, backlog)) != SOCK_ERR_NO_ERROR) {\n\t\tbsd_setErrNo(ret);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 25.725028194853937}, {"code": "int BSD_listen(int socket, int backlog){\n\tint ret = listen(socket, backlog);\n\tif (ret == SOCK_ERR_NO_ERROR) {\n\t\treturn BSD_SUCCESS;\n\t}\n\treturn BSD_ERROR;\n}", "CodeBleu_score": 19.4496222553156}, {"code": "int BSD_listen(int socket, int backlog){\n\tif (socket < 0 || socket >= MAX_SOCKET) {\n\t\tbsd_setErrNo(EBADF);\n\t\treturn SOCK_ERR_INVALID_ARG;\n\t}\n\tif (gastrSockets[socket].bIsUsed == 0) {\n\t\tbsd_setErrNo(ENOTSOCK);\n\t\treturn SOCK_ERR_INVALID_ARG;\n\t}\n\tif (gastrSockets[socket].u8SSLFlags & SSL_FLAGS_ACTIVE) {\n\t\tbsd_setErrNo(EOPNOTSUPP);\n\t\treturn SOCK_ERR_INVALID_ARG;\n\t}\n\treturn listen(socket, backlog);\n}", "CodeBleu_score": 42.6199582634251}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 12.182170557362593}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 12.182170557362593}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 12.182170557362593}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\ttime_t now = time(NULL);\n   if(now < UNIX_OFFSET) {\n      debug_printError(\"MQTT: Invalid time\");\n      return;\n   }\n   updateJWT(now);\n   MQTT_CLIENT_connect(mqttBroker, mqttPort, mqttClientId, mqttUsername, mqttPassword, mqttCleanSession, mqttKeepAlive);\n   debug_printInfo(\"MQTT: Connecting to %s:%d\", mqttBroker, mqttPort);\n}", "CodeBleu_score": 46.083235444788684}, {"code": "static void connectMQTT(){\n\ttime_t epoch = time(NULL);\n   if (epoch < 0) {\n      debug_printError(\"MQTT: Invalid time\");\n      return;\n   }\n   updateJWT(epoch);\n   MQTT_CLIENT_connect(mqttBroker, mqttPort, mqttClientId, mqttUsername, mqttPassword, 0, 1, mqttKeepAlive, 1);\n   debug_printInfo(\"MQTT: Connecting to %s:%d\", mqttBroker, mqttPort);\n   mqttSubscribe = 1;\n}", "CodeBleu_score": 48.05039543237153}, {"code": "static void connectMQTT(){\n\ttime_t epoch = time(NULL);\n   if (epoch > 1577836800) {\n      updateJWT(epoch);\n      mqttConnected = false;\n      mqttClient.connect(mqttBroker, 8883, mqttKeepAlive, mqttPassword, cid, NULL, NULL, 1, 1, \"\");\n      debug_printInfo(\"MQTT: Connecting to %s:%d\", mqttBroker, 8883);\n   }\n   else {\n      debug_printError(\"MQTT: Time not set\");\n   }\n}", "CodeBleu_score": 46.91351449128417}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tif (mqttState == CONNECTED) {\n      mqttContext* connectionInfo = CLOUD_getConnectionInfo();\n      if (connectionInfo != NULL) {\n         mqttCurrentState state = MQTT_Disconnect(connectionInfo);\n         if (state == DISCONNECTED) {\n            DEBUG_PRINT(\"[DEBUG] - MQTT disconnected\n\");\n         } else {\n            DEBUG_PRINT(\"[DEBUG] - MQTT disconnection failed\n\");\n         }\n      }\n   }\n}", "CodeBleu_score": 48.6528396334542}, {"code": "void CLOUD_disconnect(void){\n\tif (mqttState == CONNECTED) {\n      mqttContext* connectionInfo = mqttGetConnectionInfo();\n      MQTT_Disconnect(connectionInfo);\n      mqttState = DISCONNECTED;\n      debug_log(DEBUG_LEVEL_INFO, \"Disconnected from cloud service.\n\");\n   }\n}", "CodeBleu_score": 49.51688841918468}, {"code": "void CLOUD_disconnect(void){\n\tif (mqttState == CONNECTED) {\n      mqttContext* connectionInfo = &mqttConnectionInfo;\n\n      DEBUG_PRINT(\"[CLOUD] Disconnecting from the cloud service\n\");\n\n      MQTT_Disconnect(connectionInfo);\n   }\n}", "CodeBleu_score": 49.68748359172424}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tif (passed_wifi_creds) {\n\t\t// Attempt to connect to the passed Wi-Fi credentials\n\t\tif (M2M_SUCCESS == m2m_wifi_connect((char *)wifi_creds.ssid, strlen(wifi_creds.ssid), wifi_creds.sec_type, wifi_creds.passphrase, M2M_WIFI_CH_ALL)) {\n\t\t\t// If the connection is successful, update the networking error status and return true\n\t\t\tnetworking_err = NETWORKING_ERR_NONE;\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// If the connection fails, log an error message and update the networking error status\n\t\t\tSerial.println(\"Failed to connect to AP\");\n\t\t\tnetworking_err = NETWORKING_ERR_WIFI_CONNECT;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// Attempt to connect to the default Wi-Fi credentials\n\t\tif (M2M_SUCCESS == m2m_wifi_default_connect()) {\n\t\t\t// If the connection is successful, update the networking error status and return true\n\t\t\tnetworking_err = NETWORKING_ERR_NONE;\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// If the connection fails, log an error message and update the networking error status\n\t\t\tSerial.println(\"Failed to connect to AP\");\n\t\t\tnetworking_err = NETWORKING_ERR_WIFI_CONNECT;\n\t\t\treturn false;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.21106721904685}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tif (passed_wifi_creds == 0) {\n\t\tif (m2m_wifi_default_connect() != M2M_SUCCESS) {\n\t\t\tprintf(\"Failed to connect to AP using default credentials!\\r\n\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (m2m_wifi_connect(WIFI_SSID, sizeof(WIFI_SSID) - 1, M2M_WIFI_SEC_WPA_PSK, WIFI_PASSWORD, M2M_WIFI_CH_ALL) != M2M_SUCCESS) {\n\t\t\tprintf(\"Failed to connect to AP using new credentials!\\r\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 43.220476311723715}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tif (passed_wifi_creds) {\n\t\tif (wifi_creds.ssid_len > M2M_MAX_SSID_LEN) {\n\t\t\twifi_creds.ssid_len = M2M_MAX_SSID_LEN;\n\t\t}\n\t\tif (wifi_creds.psk_len > M2M_MAX_PSK_LEN) {\n\t\t\twifi_creds.psk_len = M2M_MAX_PSK_LEN;\n\t\t}\n\t\tif (wifi_creds.security == M2M_WIFI_SEC_WEP) {\n\t\t\twifi_creds.wep_key_idx = 0;\n\t\t}\n\t\tif (M2M_SUCCESS == m2m_wifi_connect((char *)wifi_creds.ssid, wifi_creds.ssid_len, wifi_creds.security, (void *)wifi_creds.psk, wifi_creds.channel)) {\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tif (M2M_SUCCESS == m2m_wifi_default_connect()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 43.11957876889189}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tconst client = new ApolloClient({\n        uri: \"http://localhost:4000/graphql\",\n        cache: new InMemoryCache()\n    });\n\n    const { data } = await client.query({\n        query: gql`\n            {\n                sensors {\n                    id\n                    name\n                    latitude\n                    longitude\n                }\n            }\n        `\n    });\n\n    console.log(data);\n\n    if (data) {\n        console.log(\"Sensors retrieved\");\n        data.sensors.forEach(sensor => {\n            const marker = new google.maps.Marker({\n                position: {\n                    lat: sensor.latitude,\n                    lng: sensor.longitude\n                },\n                map: map,\n                title: sensor.name\n            });\n        });\n    }\n}", "CodeBleu_score": 39.01538035362497}, {"code": "async function DisplaySensors(map){\n\tconst client = new ApolloClient({\n        uri: 'https://api.smartcitizen.me/v0/graphql',\n        cache: new InMemoryCache()\n    });\n\n    const { data } = await client.query({\n        query: gql`\n            query {\n                sensors {\n                    id\n                    location {\n                        latitude\n                        longitude\n                    }\n                    name\n                    updatedAt\n                }\n            }\n        `\n    });\n\n    console.log(data);\n\n    if (data) {\n        console.log(`Retrieved ${data.sensors.length} sensors`);\n\n        for (const sensor of data.sensors) {\n            const marker = new google.maps.Marker({\n                position: {\n                    lat: sensor.location.latitude,\n                    lng: sensor.location.longitude\n                },\n                map,\n                title: sensor.name\n            });\n\n            marker.addListener('click', () => {\n                window.open(`https://www.smartcitizen.me/devices/${sensor.id}`, '_blank');\n            });\n        }\n    }\n}", "CodeBleu_score": 33.85617937229797}, {"code": "async function DisplaySensors(map){\n\t// Create a client\n    const client = new ApolloClient({\n        uri: 'https://api.smartcitizen.me/v0/graphql',\n        cache: new InMemoryCache()\n    });\n\n    // Query for sensors\n    const sensors = await client.query({\n        query: gql`\n        {\n            sensors {\n                id\n                name\n                location {\n                    latitude\n                    longitude\n                }\n            }\n        }\n        `\n    });\n\n    // Log the response\n    console.log(sensors);\n\n    // If the response contains data, log the retrieval of sensors\n    if (sensors.data) {\n        console.log('Sensors retrieved');\n\n        // Iterate through each sensor\n        sensors.data.sensors.forEach(sensor => {\n\n            // Create a marker\n            const marker = new google.maps.Marker({\n                position: {\n                    lat: sensor.location.latitude,\n                    lng: sensor.location.longitude\n                },\n                map: map,\n                title: sensor.name\n            });\n\n            // Add the marker to the map\n            marker.setMap(map);\n        });\n    }\n}", "CodeBleu_score": 39.12660712786461}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n\n    marker.id = sensor.id;\n    marker.className = 'sensor';\n    marker.style.backgroundColor = sensor.color;\n    marker.style.border = '2px solid black';\n\n    return marker;\n\n}", "CodeBleu_score": 46.55831342011577}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t// Create a new marker element.\n  let marker = document.createElement('div');\n\n  // Assign the marker's ID using the sensor's unique ID.\n  marker.id = sensor.id;\n\n  // Assign the marker the class name \"marker\".\n  marker.className = 'marker';\n\n  // Set the marker's default color and border.\n  marker.style.backgroundColor = 'red';\n  marker.style.border = '2px solid black';\n\n  // Return the marker.\n  return marker;\n}", "CodeBleu_score": 43.43184677037273}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"sensor-marker\";\n    marker.style.backgroundColor = \"#000000\";\n    marker.style.border = \"1px solid #000000\";\n    return marker;\n}", "CodeBleu_score": 43.49686899476657}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\n            \"Unable to find the module %s. Please make sure the requirements for this module are installed.\",\n            module_path,\n        )\n        raise\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import %s. Please make sure the requirements for this module are installed. Error: %s\",\n            module_path,\n            err,\n        )\n        raise\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await async_process_deps_reqs(hass, module_name, module)\n\n    return module\n\n", "CodeBleu_score": 43.98367091288953}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to import %s. Make sure requirements are installed\", module_path\n        )\n        raise HomeAssistantError(\n            f\"Unable to import {module_path}. Make sure requirements are installed\"\n        ) from err\n    except Exception as err:\n        _LOGGER.exception(\"Unable to import %s\", module_path)\n        raise HomeAssistantError(f\"Unable to import {module_path}\") from err\n\n    if not hasattr(module, \"CONFIG_SCHEMA\") or not hasattr(\n        module, \"async_setup_entry\"\n    ):\n        raise HomeAssistantError(f\"{module_path} does not support MFA\")\n\n    return module\n\n", "CodeBleu_score": 43.09711538537313}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.components.{module_name}.mfa_module\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to load multi-factor authentication module %s: %s\", module_name, err\n        )\n        return None\n    except Exception as err:  # pylint: disable=broad-except\n        _LOGGER.exception(\n            \"Unable to load multi-factor authentication module %s: %s\", module_name, err\n        )\n        return None\n\n    if not hasattr(module, \"setup\"):\n        _LOGGER.error(\n            \"Unable to load multi-factor authentication module %s: No setup function defined\",\n            module_name,\n        )\n        return None\n\n    if not hasattr(module, \"MFAModule\"):\n        _LOGGER.error(\n            \"Unable to load multi-factor authentication module %s: No MFAModule class defined\",\n            module_name,\n        )\n        return None\n\n    if not hasattr(module, \"STEP_SCHEMA\"):\n        _LOGGER.error(\n            \"Unable to load multi-factor authentication module %s: No STEP_SCHEMA defined\",\n            module_name,\n        )\n        return None\n\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        _LOGGER.error(\n            \"Unable to load multi-factor authentication module %s: No CONFIG_SCHEMA defined\",\n            module_name,\n        )\n        return None\n\n    return module\n\n", "CodeBleu_score": 37.29419722766918}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data[\"pin\"]\n    if self.data.get(user_id) is not None:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n\n", "CodeBleu_score": 35.176971403998095}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data[\"pin\"]\n    self._data.setdefault(user_id, pin)\n    self._data[user_id] = pin\n    return self._data[user_id]\n\n\n", "CodeBleu_score": 34.02616618428045}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tif not isinstance(setup_data, str):\n        raise ValueError(\"Setup data must be a string\")\n\n    pin = setup_data.strip()\n    if not pin.isdigit():\n        raise ValueError(\"Setup data must be a string containing a PIN\")\n\n    self._data.setdefault(user_id, pin)\n    return True\n\n", "CodeBleu_score": 31.644985993786083}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\tif self._initialized:\n            return\n\n        async with self._lock:\n            if self._initialized:\n                return\n\n            if not (data := await self._store.async_load()):\n                self._data = {}\n            else:\n                self._data = {\n                    entry[\"id\"]: NotifySetting(**entry) for entry in data[\"settings\"]\n                }\n\n            self._initialized = True\n\n", "CodeBleu_score": 36.105978241869465}, {"code": "async def _async_load(self) -> None\n\tasync with self._lock:\n        if self._loaded:\n            return\n\n        if data := await self._store.async_load():\n            self._data = {\n                entry[\"id\"]: NotifySetting(**entry) for entry in data[\"notify\"]\n            }\n        else:\n            self._data = {}\n\n        self._loaded = True", "CodeBleu_score": 32.89458903219041}, {"code": "async def _async_load(self) -> None\n\t# Only one thread can access this method at a time\n        async with self._lock:\n            if self._settings is not None:\n                return\n\n            # Load settings from the store\n            data = await self._store.async_load()\n\n            # If no data was loaded, initialize an empty dict\n            if not data:\n                data = {}\n\n            # Initialize the settings dict\n            self._settings = {}\n\n            # Populate the settings dict with NotifySettings objects\n            for user_id, settings in data.items():\n                self._settings[user_id] = NotifySetting(**settings)\n\n", "CodeBleu_score": 39.069316331514486}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self.async_ensure_loaded()\n    settings = self.get(user_id)\n    if not settings:\n        return False\n    result = await self.hass.async_add_executor_job(\n        self.validate, settings, user_input[CONF_CODE]\n    )\n    return result\n\n", "CodeBleu_score": 39.998184041069685}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self._async_ensure_user_settings_loaded(user_id)\n    user_settings = self._users_settings.get(user_id)\n    if user_settings is None:\n        return False\n    return await self._async_validate_user_input(user_settings, user_input)\n\n", "CodeBleu_score": 43.13108375498381}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self.async_ensure_loaded()\n    settings = self._user_settings.get(user_id)\n    if settings is None:\n        return False\n    if await self.hass.async_add_executor_job(\n        validate_code, settings[\"secret\"], user_input[\"code\"]\n    ):\n        return True\n    return False\n\n", "CodeBleu_score": 44.066317981521244}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.perm_entities.get(entity_id)\n    if not entity_entry:\n        return None\n    device_id = entity_entry.device_id\n    device_entry = perm_lookup.perm_devices.get(device_id)\n    if not device_entry:\n        return None\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.7036964503889}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t# Look up entity\n    entity = perm_lookup.entity_registry.async_get(entity_id)\n    if entity is None:\n        return None\n    # Look up device\n    device = perm_lookup.device_registry.async_get(entity.device_id)\n    if device is None:\n        return None\n    # Look up area\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    # Look up permissions\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 60.83958012131833}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_id = entity_entry.device_id\n    device_entry = perm_lookup.devices.get(device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 63.77853974543262}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\treturn cast(PolicyType, _merge_policies(policies))", "CodeBleu_score": 7.399345002443108}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t# When merging policies, the most permissive wins.\n    # This means we order it like this:\n    # True > Dict > None\n    #\n    # True: allow everything\n    # Dict: specify more granular permissions\n    # None: no opinion\n    #\n    # If there are multiple sources with a dict as policy, we recursively\n    # merge each key in the source.\n\n    policy: PolicyType = None\n    seen: set[str] = set()\n    for source in policies:\n        if source is None:\n            continue\n\n        # A source that's True will always win. Shortcut return.\n        if source is True:\n            return True\n\n        assert isinstance(source, dict)\n\n        if policy is None:\n            policy = cast(PolicyType, {})\n\n        assert isinstance(policy, dict)\n\n        for key in source:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [src.get(key) for src in policies if isinstance(src, dict)]\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy", "CodeBleu_score": 46.74088899301836}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\treturn cast(PolicyType, _merge_policies(policies))", "CodeBleu_score": 7.399345002443108}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\tif provider in sys.modules:\n        return _get_module(hass.data.get(DATA_PROVIDER_CACHE), provider)\n\n    if provider in hass.data.get(DATA_PROVIDER_FAILURES):\n        raise HomeAssistantError(f\"Failed to load {provider} auth provider\")\n\n    import_futures = hass.data.get(DATA_PROVIDER_FUTURES)\n    if import_futures is None:\n        import_futures = hass.data[DATA_PROVIDER_FUTURES] = {}\n\n    if future := import_futures.get(provider):\n        return await future\n\n    import_future = hass.loop.create_future()\n    import_futures[provider] = import_future\n    try:\n        module = await hass.async_add_executor_job(\n            _get_module, hass.data.get(DATA_PROVIDER_CACHE), provider\n        )\n        import_future.set_result(module)\n    except BaseException as ex:\n        if isinstance(ex, ModuleNotFoundError):\n            hass.data.setdefault(DATA_PROVIDER_FAILURES, {})[provider] = True\n        import_future.set_exception(ex)\n        with suppress(BaseException):\n            # Set the exception retrieved flag on the future since\n            # it will never be retrieved unless there\n            # are concurrent calls\n            import_future.result()\n        raise HomeAssistantError(f\"Failed to load {provider} auth provider\") from ex\n    finally:\n        del import_futures[provider]\n\n    return module\n\n", "CodeBleu_score": 40.556429605293985}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(hass, f\"homeassistant.auth.{provider}\")\n    except ModuleNotFoundError as err:\n        raise HomeAssistantError(\n            f\"Unable to find the authentication provider {provider}\"\n        ) from err\n    try:\n        processed = hass.data[DATA_PROVIDER_SETUP]\n    except KeyError:\n        processed = hass.data[DATA_PROVIDER_SETUP] = set()\n    if module in processed:\n        return module\n    processed.add(module)\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        return module\n    try:\n        module.CONFIG_SCHEMA(None)\n    except vol.Invalid:\n        pass\n    except vol.MultipleInvalid as err:\n        _LOGGER.error(\n            \"Config schema for %s is invalid: %s\",\n            module.__name__,\n            humanize_error(None, err),\n        )\n        raise HomeAssistantError(\n            f\"Config schema for {module.__name__} is invalid: {humanize_error(None, err)}\"\n        ) from err\n    except vol.Invalid as err:\n        _LOGGER.error(\n            \"Config schema for %s is invalid: %s\",\n            module.__name__,\n            humanize_error(None, err),\n        )\n        raise HomeAssistantError(\n            f\"Config schema for {module.__name__} is invalid: {humanize_error(None, err)}\"\n        ) from err\n    return module\n\n", "CodeBleu_score": 42.02235829929485}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await async_import_module(hass, f\"homeassistant.auth.{provider}\")\n    except ModuleNotFoundError:\n        _LOGGER.error(\n            \"Unable to find an authentication provider module named %s\", provider\n        )\n        raise HomeAssistantError() from None\n    except ImportError as err:\n        _LOGGER.exception(\n            \"Unable to load an authentication provider module named %s: %s\",\n            provider,\n            err,\n        )\n        raise HomeAssistantError() from None\n\n    if not hasattr(module, \"async_setup_auth_provider\"):\n        _LOGGER.error(\n            \"The authentication provider module %s does not have an async_setup_auth_provider function\",\n            provider,\n        )\n        raise HomeAssistantError()\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        try:\n            await async_process_deps_reqs(hass, module.REQUIREMENTS)\n        except RequirementsNotFound:\n            _LOGGER.error(\n                \"Unable to find all requirements for the %s authentication provider module\",\n                provider,\n            )\n            raise HomeAssistantError() from None\n\n    return module", "CodeBleu_score": 38.418531364527496}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = username.lower()\n    dummy_hash = bcrypt.hashpw(b'', bcrypt.gensalt())\n    for user in self.users:\n        if user['username'] == username:\n            password_hash = base64.b64decode(user['password_hash'])\n            if bcrypt.checkpw(password.encode('utf-8'), password_hash):\n                return\n            else:\n                raise InvalidAuth\n    raise InvalidAuth\n\n\n\n", "CodeBleu_score": 41.1783702774228}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b'', bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            password_hash = base64.b64decode(user.password_hash)\n            if bcrypt.checkpw(password.encode('utf-8'), password_hash):\n                return\n            else:\n                raise InvalidAuth\n    raise InvalidAuth\n\n", "CodeBleu_score": 38.45294421806135}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            password_hash = user.password_hash\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid credentials.\")\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth(\"Invalid credentials.\")\n\n", "CodeBleu_score": 36.398041628079945}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\tusername = normalize_username(username)\n    user = self.get_user(username)\n    self.users.remove(user)\n\n\n", "CodeBleu_score": 11.569274910483395}, {"code": "def async_remove_auth(self, username: str) -> None\n\tnormalized_username = self.normalize_username(username)\n    user = self.get_user(normalized_username)\n    self.users.remove(user)\n\n\n", "CodeBleu_score": 13.595030715697625}, {"code": "def async_remove_auth(self, username: str) -> None\n\tnormalized_username = username.lower()\n    if normalized_username not in self.users:\n        raise InvalidUser(message=\"user_not_found\")\n    self.users.remove(normalized_username)", "CodeBleu_score": 25.459545712027044}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        await self.async_load()\n    try:\n        del self._data[credentials.data[\"username\"]]\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 47.56283096953974}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        await self.async_initialize()\n\n    try:\n        self._data.pop(credentials.id)\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 49.48357815600409}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif not self._data:\n        await self.async_load()\n\n    try:\n        del self._data[credentials.data[\"username\"]]\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 44.22659859400937}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        ident = thread.ident\n        if ident is None:\n            joined.add(thread)\n            continue\n        thread_timeout = timeout / len(threads)\n        try:\n            thread.join(thread_timeout)\n        except SystemExit:\n            pass\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, ident)\n        thread.interrupt()\n    return joined\n\n", "CodeBleu_score": 54.618351214144624}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t# Calculate the timeout for each thread\n    now = time.time()\n    deadline = now + timeout\n    # Join all threads\n    joined = set()\n    for thread in threads:\n        # If the thread is not alive, it has already been joined or interrupted\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        # Calculate the remaining timeout\n        remaining = deadline - time.time()\n        if remaining > 0:\n            thread.join(remaining)\n        # If the thread is still alive, it was not joined\n        if thread.is_alive():\n            continue\n        # The thread was joined successfully\n        joined.add(thread)\n    # Log threads that are still running\n    if log:\n        for thread in threads - joined:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    # Attempt to raise a SystemExit exception in any remaining threads\n    for thread in threads - joined:\n        try:\n            # If the thread is no longer alive, it has already been interrupted\n            if not thread.is_alive():\n                continue\n            # Interrupt the thread\n            thread.interrupt()\n            # Log the thread that was interrupted\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n        except Exception:  # pylint: disable=broad-except\n            # Log the thread that could not be interrupted\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n    # Return the set of successfully joined threads\n    return joined\n\n", "CodeBleu_score": 47.742172401580305}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        ident = thread.ident\n        if ident is None:\n            joined.add(thread)\n            continue\n        if timeout is None:\n            thread.join()\n            joined.add(thread)\n            continue\n        thread_timeout = timeout - (time.monotonic() - _START_TIME)\n        if thread_timeout <= 0:\n            continue\n        try:\n            thread.join(thread_timeout)\n        except SystemExit:\n            raise\n        except BaseException:\n            pass\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, ident)\n    return joined\n\n", "CodeBleu_score": 49.541870744064084}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\timport threading\n    import time\n    import logging\n\n    shutdown_timeout = 5\n    threads = threading.enumerate()\n    non_main_threads = [thread for thread in threads if not thread.daemon and thread is not threading.main_thread()]\n    logging.info(f\"Shutting down {len(non_main_threads)} threads.\")\n    for thread in non_main_threads:\n        timeout = shutdown_timeout / len(non_main_threads)\n        logging.info(f\"Joining thread {thread.name} with timeout {timeout}\")\n        thread.join(timeout)\n        if thread.is_alive():\n            logging.warning(f\"Failed to join thread {thread.name} within {timeout} seconds.\")\n    logging.info(\"Shutdown complete.\")", "CodeBleu_score": 37.41230413622287}, {"code": "def deadlock_safe_shutdown() -> None\n\timport threading\n    import time\n    import logging\n    import sys\n    # Get the current thread\n    current_thread = threading.current_thread()\n    # Get all alive threads\n    all_threads = threading.enumerate()\n    # Filter out the main thread and daemon threads\n    remaining_threads = [t for t in all_threads if t is not current_thread and not t.daemon]\n    # Get the current time\n    current_time = time.time()\n    # Get the shutdown timeout\n    shutdown_timeout = float(sys.argv[1])\n    # Calculate the timeout for each thread\n    thread_timeout = shutdown_timeout / len(remaining_threads)\n    # Join each thread within the calculated timeout\n    for t in remaining_threads:\n        # Calculate the timeout for the current thread\n        timeout = current_time + thread_timeout\n        # Attempt to join the thread\n        t.join(timeout)\n        # Check if the thread is still alive\n        if t.is_alive():\n            # Log a warning\n            logging.warning(f\"Failed to join thread {t.name} within {thread_timeout} seconds\")", "CodeBleu_score": 35.68008620585545}, {"code": "def deadlock_safe_shutdown() -> None\n\timport time\n    import threading\n    import logging\n\n    shutdown_timeout = 10.0\n    remaining_threads = [t for t in threading.enumerate() if t != threading.main_thread() and not t.daemon]\n    timeout = shutdown_timeout / len(remaining_threads)\n    for t in remaining_threads:\n        t.join(timeout=timeout)\n        if t.is_alive():\n            logging.warning(f'Failed to join thread {t.name} with id {t.ident} during shutdown.')", "CodeBleu_score": 34.41366864342573}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tremaining_setups = set(remaining_with_setup_started.keys())\n    if remaining_setups or self._previous_remaining_setups:\n        self.dispatch_async(\n            self.SIGNAL_SETUP_STARTED,\n            self._async_dispatch,\n            remaining_setups,\n        )\n    else:\n        self.dispatch_async(self.SIGNAL_SETUP_FINISHED)\n    self._previous_remaining_setups = remaining_setups", "CodeBleu_score": 42.26876659014453}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif remaining_with_setup_started or self._remaining_setups:\n        self._remaining_setups = remaining_with_setup_started\n        self._async_dispatcher_send(self.async_signal_setup_progress, remaining_with_setup_started)\n    else:\n        self._remaining_setups = None", "CodeBleu_score": 42.43418272409555}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif remaining_with_setup_started:\n        self._dispatcher.send_signal(\n            \"setup_started\",\n            remaining_with_setup_started=remaining_with_setup_started,\n        )\n        self._remaining_with_setup_started = remaining_with_setup_started\n    else:\n        self._dispatcher.send_signal(\"setup_finished\")\n        self._remaining_with_setup_started = {}", "CodeBleu_score": 31.234301616030795}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tcurrent_content = \"\"\n    if config.specific_integrations:\n        current_content = generate_and_validate(integrations)\n    else:\n        with open(config.cache.path(\"bluetooth.py\"), encoding=\"utf-8\") as bluetooth_file:\n            current_content = bluetooth_file.read()\n\n    new_content = generate_and_validate(integrations)\n\n    if current_content == new_content:\n        return\n\n    config.cache.write(\"bluetooth.py\", new_content)\n\n    config.add_error(\n        \"bluetooth\",\n        \"Bluetooth data is not up to date.\",\n        hint=\"Run script/gen_requirements_all.py\",\n    )", "CodeBleu_score": 42.54182187500331}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tcurrent_content = get_file_content(config.cache_path, \"bluetooth.py\")\n    generated_content = generate_and_validate(integrations)\n\n    if current_content is not None and current_content != generated_content:\n        config.add_error(\n            \"bluetooth.py is not up to date. Run script/gen_requirements_all.py to update.\",\n            fixable=True,\n            type=ERROR_TYPE_FATAL,\n            edit_suggestion=generated_content,\n        )\n\n    config.cache_content(\"bluetooth.py\", generated_content)", "CodeBleu_score": 39.44766035391099}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tgenerated = generate_and_validate(integrations)\n\n    if not config.specific_integrations:\n        current = read_python_file(config.cache_dir / \"bluetooth.py\")\n\n        if generated == current:\n            return\n\n        config.add_error(\n            \"bluetooth\",\n            \"The bluetooth.py file is not up to date\",\n            hint=f\"Run `{config.name} bluetooth` to update it\",\n        )\n        return\n\n    config.cache_dir.mkdir(parents=True, exist_ok=True)\n    write_python_file(config.cache_dir / \"bluetooth.py\", generated)", "CodeBleu_score": 41.69615535508643}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t// Create a new POST request to the Dropbox OAuth2 token endpoint.\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the required headers to the request.\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Add(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(d.AppKey+\":\"+d.AppSecret)))\n\n\t// Create a new form with the refresh token.\n\tform := url.Values{}\n\tform.Add(\"grant_type\", \"refresh_token\")\n\tform.Add(\"refresh_token\", d.RefreshToken)\n\n\t// Add the form to the request body.\n\treq.Body = ioutil.NopCloser(strings.NewReader(form.Encode()))\n\n\t// Send the request.\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Decode the JSON response.\n\tvar result map[string]interface{}\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn err\n\t}\n\n\t// Check for any errors in the response.\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(result[\"error\"].(string))\n\t}\n\n\t// Update the access token.\n\td.AccessToken = result[\"access_token\"].(string)\n\treturn nil\n}", "CodeBleu_score": 50.475816321470965}, {"code": "func (d *Dropbox) refreshToken() error{\n\t// Build the POST request\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(\"grant_type=refresh_token&refresh_token=\"+d.RefreshToken))\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.SetBasicAuth(d.AppKey, d.AppSecret)\n\n\t// Send the request\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Decode the response\n\tvar t Token\n\terr = json.NewDecoder(resp.Body).Decode(&t)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\t// Update the access token\n\td.AccessToken = t.AccessToken\n\treturn nil\n}", "CodeBleu_score": 51.18973983668992}, {"code": "func (d *Dropbox) refreshToken() error{\n\tif d.refreshToken == \"\" {\n\t\treturn errors.New(\"no refresh token\")\n\t}\n\n\t// Prepare the request.\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(\"grant_type=refresh_token&refresh_token=\"+d.refreshToken))\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.SetBasicAuth(d.appKey, d.appSecret)\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the request.\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Decode the response.\n\tvar data struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}\n\tif err := json.NewDecoder(resp.Body).Decode(&data); err != nil {\n\t\treturn err\n\t}\n\n\t// Update the access token.\n\td.accessToken = data.AccessToken\n\treturn nil\n}", "CodeBleu_score": 51.15109764767001}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tvar body []byte\n\tvar err error\n\tvar req *http.Request\n\tvar respBody []byte\n\tvar respStatus int\n\tvar token string\n\tvar tokenType string\n\n\t// Prepare the request\n\tif req, err = http.NewRequest(method, url, nil); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the authorization header\n\tif token, tokenType, err = d.getToken(); err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"%s %s\", tokenType, token))\n\n\t// Set the parameters for supporting all drives\n\tq := req.URL.Query()\n\tq.Add(\"supportsAllDrives\", \"true\")\n\tq.Add(\"includeItemsFromAllDrives\", \"true\")\n\treq.URL.RawQuery = q.Encode()\n\n\t// Customize the request\n\tif callback != nil {\n\t\tif err = callback(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Send the request\n\tvar client = &http.Client{}\n\tvar respObj *http.Response\n\tif respObj, err = client.Do(req); err != nil {\n\t\treturn nil, err\n\t}\n\tdefer respObj.Body.Close()\n\n\t// Check the response status\n\tif respStatus = respObj.StatusCode; respStatus != 200 {\n\t\tif respStatus == 401 {\n\t\t\t// Refresh the token and retry\n\t\t\tif token, tokenType, err = d.refreshToken(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"%s %s\", tokenType, token))\n\t\t\tif respObj, err = client.Do(req); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdefer respObj.Body.Close()\n\t\t\trespStatus = respObj.StatusCode\n\t\t}\n\t\tif respStatus != 200 {", "CodeBleu_score": 43.640794615676306}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tvar err error\n\tvar response *http.Response\n\tvar body []byte\n\tvar bodyReader io.ReadCloser\n\n\t// Set the authorization header with the access token\n\tvar authHeader = \"Bearer \" + d.AccessToken\n\tvar headers = map[string]string{\n\t\t\"Authorization\": authHeader,\n\t}\n\n\t// Set the parameters for supporting all drives\n\tvar parameters = map[string]string{\n\t\t\"supportsAllDrives\": \"true\",\n\t}\n\n\t// If a callback is provided, it customizes the request\n\tif callback != nil {\n\t\tcallback(&headers, &parameters)\n\t}\n\n\t// Set the request body\n\tvar bodyReader io.Reader\n\tif method == \"POST\" || method == \"PUT\" {\n\t\tbodyReader = bytes.NewReader(body)\n\t}\n\n\t// Set the request URL\n\tvar requestURL = url + \"?\" + base.JoinMap(parameters, \"=\", \"&\")\n\n\t// Set the request\n\tvar request *http.Request\n\tif method == \"POST\" || method == \"PUT\" {\n\t\trequest, err = http.NewRequest(method, requestURL, bodyReader)\n\t} else {\n\t\trequest, err = http.NewRequest(method, requestURL, nil)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the headers\n\tfor header, value := range headers {\n\t\trequest.Header.Set(header, value)\n\t}\n\n\t// Set the user agent\n\trequest.Header.Set(\"User-Agent\", \"Sabaki Bot\")\n\n\t// Set the request body\n\tif method == \"POST\" || method == \"PUT\" {\n\t\trequest.Body = ioutil.NopCloser(bodyReader)\n\t}\n\n\t// Send the request\n\tresponse, err = d.Client.Do(request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\n\t// If the response is successful, return the response body\n\tif response.StatusCode == 200 {\n\t\tbody,", "CodeBleu_score": 41.89164478417358}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t// Set the authorization header with the access token.\n\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.Header.Set(\"Accept\", \"application/json\")\n\t// Include parameters for supporting all drives.\n\tq := req.URL.Query()\n\tq.Add(\"supportsAllDrives\", \"true\")\n\treq.URL.RawQuery = q.Encode()\n\t// If a callback is provided, customize the request.\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\t// Send the request.\n\tclient := &http.Client{}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\t// Read the response body.\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// If a response structure is provided, set the request result.\n\tif resp != nil {\n\t\terr = json.Unmarshal(body, resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// If the request was successful, return the response body.\n\tif res.StatusCode == 200 {\n\t\treturn body, nil\n\t}\n\t// If the request failed, return an error.\n\tif res.StatusCode == 401 {\n\t\t// If a 401 error occurred, refresh the token and retry the request.\n\t\terr = d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\treturn nil, errors.New(string(body))\n}", "CodeBleu_score": 62.64741629381167}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t// Calculate the chunk size\n\tchunkSize := int64(d.ChunkSize) * int64(1024*1024)\n\n\t// Calculate the number of chunks\n\tnumChunks := int64(math.Ceil(float64(stream.Size()) / float64(chunkSize)))\n\n\t// Calculate the size of the last chunk\n\tlastChunkSize := stream.Size() - (chunkSize * (numChunks - 1))\n\n\t// Calculate the number of bytes uploaded\n\tbytesUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded\n\tchunksUploaded := int64(0)\n\n\t// Calculate the number of bytes uploaded in the last chunk\n\tlastChunkUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded in the last chunk\n\tlastChunkChunksUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded in the last chunk\n\tlastChunkChunksUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded in the last chunk\n\tlastChunkChunksUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded in the last chunk\n\tlastChunkChunksUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded in the last chunk\n\tlastChunkChunksUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded in the last chunk\n\tlastChunkChunksUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded in the last chunk\n\tlastChunkChunksUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded in the last chunk\n\tlastChunkChunksUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded in the last chunk\n\tlastChunkChunksUploaded := int64(0)\n\n\t// Calculate the number of chunks uploaded in the last chunk\n\tlastChunkChunksUploaded := int64(0", "CodeBleu_score": 15.893268262965565}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t// Calculate the chunk size\n\tchunkSize := int64(d.chunkSize) * 1024 * 1024\n\n\t// Get the file size\n\tsize, err := stream.Size()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the number of chunks\n\tnumChunks := size / chunkSize\n\tif size%chunkSize > 0 {\n\t\tnumChunks++\n\t}\n\n\t// Create a buffer for reading the chunks\n\tbuf := make([]byte, chunkSize)\n\n\t// Set the start and end indexes for the chunks\n\tstart := int64(0)\n\tend := int64(0)\n\n\t// Set the upload type\n\tuploadType := \"resumable\"\n\n\t// Set the content type\n\tcontentType := \"application/octet-stream\"\n\n\t// Set the headers\n\theaders := map[string]string{\n\t\t\"Content-Type\": contentType,\n\t}\n\n\t// Loop over each chunk\n\tfor i := int64(0); i < numChunks; i++ {\n\t\t// Check for context cancellation\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Set the start and end indexes\n\t\tstart = i * chunkSize\n\t\tend = start + chunkSize\n\t\tif end > size {\n\t\t\tend = size\n\t\t}\n\n\t\t// Read the chunk\n\t\t_, err = stream.ReadAt(buf, start)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If this is the first chunk, set the upload type\n\t\tif i == 0 {\n\t\t\tuploadType = \"multipart\"\n\t\t}\n\n\t\t// If this is the last chunk, set the content range\n\t\tif i == numChunks-1 {\n\t\t\theaders[\"Content-Range\"] = fmt.Sprintf(\"bytes %d-%d/%d\", start, end-1, size)\n\t\t}\n\n\t\t// Upload the chunk\n\t\t_, err = d.request(ctx, \"PUT", "CodeBleu_score": 44.15570189112996}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t// Calculate the chunk size.\n\tchunkSize := int64(d.ChunkSize) * 1024 * 1024 // convert MB to bytes\n\n\t// Calculate the number of chunks.\n\tnumChunks := int(math.Ceil(float64(stream.Size()) / float64(chunkSize)))\n\n\t// Calculate the number of bytes to read from the file for each chunk.\n\t// The last chunk might have fewer bytes than the chunk size.\n\tlastChunkSize := stream.Size() % chunkSize\n\tif lastChunkSize == 0 {\n\t\tlastChunkSize = chunkSize\n\t}\n\n\t// Create a buffer for reading the file.\n\tbuf := make([]byte, chunkSize)\n\n\t// Read the file and upload each chunk.\n\tfor i := 0; i < numChunks; i++ {\n\t\t// Check for context cancellation.\n\t\tif err := ctx.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Calculate the number of bytes to read for this chunk.\n\t\tvar chunkSize int64\n\t\tif i == numChunks-1 {\n\t\t\tchunkSize = lastChunkSize\n\t\t} else {\n\t\t\tchunkSize = int64(len(buf))\n\t\t}\n\n\t\t// Read the chunk.\n\t\tn, err := stream.Read(buf[:chunkSize])\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\n\t\t// Create the HTTP request for this chunk.\n\t\treq, err := http.NewRequest(\"PUT\", url, bytes.NewReader(buf[:n]))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the headers for this chunk.\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", i*chunkSize, i*chunkSize+n-1, stream.Size()))\n\t\treq.Header.Set(\"Content-Length\", strconv.FormatInt(n, 10))\n\n\t\t// Send the HTTP request.", "CodeBleu_score": 45.303688562763945}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t// Bind JSON data from the request context\n\tvar jsonData models.UmountStorage\n\tif err := ctx.Bind(&jsonData); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, models.ResponseHTTP{\n\t\t\tSuccess: false,\n\t\t\tMessage: \"Bad request\",\n\t\t})\n\t}\n\t// Get mount_point from the JSON data\n\tmount_point := jsonData.MountPoint\n\t// If the mount point is empty, return a client error response\n\tif mount_point == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, models.ResponseHTTP{\n\t\t\tSuccess: false,\n\t\t\tMessage: \"Bad request\",\n\t\t})\n\t}\n\t// Attempt to unmount the storage at the specified mount point\n\terr := storage.Umount(mount_point)\n\t// If unmounting fails, return a service error response\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, models.ResponseHTTP{\n\t\t\tSuccess: false,\n\t\t\tMessage: \"Internal server error\",\n\t\t})\n\t}\n\t// Delete the corresponding configuration\n\tconfig.DeleteStorage(mount_point)\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, models.ResponseHTTP{\n\t\tSuccess: true,\n\t\tMessage: \"Storage successfully unmounted\",\n\t})\n}", "CodeBleu_score": 41.6155395470338}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tvar mount_point string\n\tvar err error\n\tmount_point = ctx.FormValue(\"mount_point\")\n\tif mount_point == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{Error: \"No mount point specified\"})\n\t}\n\terr = umount(mount_point)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{Error: err.Error()})\n\t}\n\terr = deleteConfig(mount_point)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{Error: err.Error()})\n\t}\n\treturn ctx.JSON(http.StatusOK, struct {\n\t\tMessage string `json:\"message\"`\n\t}{Message: \"Storage unmounted\"})\n}", "CodeBleu_score": 33.90171636596837}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tmount_point := ctx.FormValue(\"mount_point\")\n\n\tif mount_point == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"mount_point is required\")\n\t}\n\n\terr := Unmount(mount_point)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusServiceUnavailable, err.Error())\n\t}\n\n\terr = DeleteConfig(mount_point)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusServiceUnavailable, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"Success\")\n}", "CodeBleu_score": 30.935445211549496}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// If the file path is missing, return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\n\t\t\t\"message\": \"Missing query parameter 'path'\",\n\t\t})\n\t}\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// If the file does not exist, return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusNotFound, echo.Map{\n\t\t\t\"message\": \"File not found\",\n\t\t})\n\t}\n\t// If the file exists, return it to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 36.59284680972183}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Get the file path from the query parameters\n\tfile := ctx.QueryParam(\"file\")\n\n\t// If the file path is missing, return an error message\n\tif file == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"Missing file path\")\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(file); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, \"File not found\")\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(file)\n}", "CodeBleu_score": 32.57926424192512}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"No file path provided\",\n\t\t})\n\t}\n\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"File not found\",\n\t\t})\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 36.31937071401643}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tmessage := new(Message)\n\tif err := ctx.Bind(message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\tif err := notify(name, message); err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.String(http.StatusOK, \"OK\")\n}", "CodeBleu_score": 43.46711492232309}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tmessage := new(Message)\n\tif err := ctx.Bind(message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\tif err := Notify(name, message.Message); err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.NoContent(http.StatusOK)\n}", "CodeBleu_score": 44.32154458582666}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn ctx.String(http.StatusBadRequest, \"missing name\")\n\t}\n\n\tvar m map[string]string\n\tif err := ctx.Bind(&m); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\n\tmsg, ok := m[\"message\"]\n\tif !ok {\n\t\treturn ctx.String(http.StatusBadRequest, \"missing message\")\n\t}\n\n\t// Send notification\n\terr := notify(name, msg)\n\tif err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.String(http.StatusOK, \"sent\")\n}", "CodeBleu_score": 46.86416921923341}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\twebsocket.Handler(func(ws *websocket.Conn) {\n\t\t// Add the new WebSocket connection to the list of connections\n\t\tconnections = append(connections, ws)\n\n\t\t// Ensure that the message sending service is running\n\t\tgo sendMessages()\n\n\t\t// Read messages from WebSocket connection and print them\n\t\tfor {\n\t\t\tmessageType, message, err := ws.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"Received message: %s\", message)\n\t\t\tlog.Printf(\"Message type: %d\", messageType)\n\t\t}\n\t}).ServeHTTP(ctx.Response(), ctx.Request())\n\treturn nil\n}", "CodeBleu_score": 37.152358833848886}, {"code": "func NotifyWS(ctx echo.Context) error{\n\tc, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer c.Close()\n\n\tconnections = append(connections, c)\n\n\tfor {\n\t\tmt, message, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv: %s\", message)\n\t\tlog.Printf(\"recv: %s\", mt)\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.21513419910202}, {"code": "func NotifyWS(ctx echo.Context) error{\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Register our new client\n\tclients[ws] = true\n\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv: %s\", msg)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.41294479948562}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\tvar (\n\t\tdriveModel string\n\t\tarch       string\n\t\tcpu        string\n\t)\n\tdriveModel = GetDriveModel()\n\tarch = GetArchitecture()\n\tcpu = GetCPUInfo()\n\treturn ctx.JSON(http.StatusOK, struct {\n\t\tDriveModel string `json:\"driveModel\"`\n\t\tArch       string `json:\"arch\"`\n\t\tCPU        string `json:\"cpu\"`\n\t}{\n\t\tDriveModel: driveModel,\n\t\tArch:       arch,\n\t\tCPU:        cpu,\n\t})\n}", "CodeBleu_score": 21.10269299332287}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Get the system drive model.\n\tdriveModel, err := system.GetDriveModel()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\n\t\t\t\"error\":   \"Failed to get system drive model.\",\n\t\t\t\"details\": err.Error(),\n\t\t})\n\t}\n\n\t// Get the system architecture.\n\tarchitecture, err := system.GetArchitecture()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\n\t\t\t\"error\":   \"Failed to get system architecture.\",\n\t\t\t\"details\": err.Error(),\n\t\t})\n\t}\n\n\t// Get the system CPU information.\n\tcpu, err := system.GetCPU()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\t\"message\": \"System hardware information retrieved successfully.\",\n\t\t\t\"details\": echo.Map{\n\t\t\t\t\"driveModel\":  driveModel,\n\t\t\t\t\"architecture\": architecture,\n\t\t\t\t\"cpu\":         \"nil\",\n\t\t\t},\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\"message\": \"System hardware information retrieved successfully.\",\n\t\t\"details\": echo.Map{\n\t\t\t\"driveModel\":  driveModel,\n\t\t\t\"architecture\": architecture,\n\t\t\t\"cpu\":         cpu,\n\t\t},\n\t})\n}", "CodeBleu_score": 19.037133157996255}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\tdriveModel, err := GetDriveModel()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\n\t\t\t\"success\": false,\n\t\t\t\"error\":   err.Error(),\n\t\t})\n\t}\n\n\tarchitecture, err := GetArchitecture()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\n\t\t\t\"success\": false,\n\t\t\t\"error\":   err.Error(),\n\t\t})\n\t}\n\n\tcpuInfo, err := GetCPUInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\n\t\t\t\"success\": false,\n\t\t\t\"error\":   err.Error(),\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\"success\": true,\n\t\t\"data\": echo.Map{\n\t\t\t\"driveModel\":  driveModel,\n\t\t\t\"architecture\": architecture,\n\t\t\t\"cpuInfo\": cpuInfo,\n\t\t},\n\t})\n}", "CodeBleu_score": 18.848833249303574}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar running, notRunning []string\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 84.15515592652413}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := make([]string, 0)\n\tnotRunningServices := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Status == \"running\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\n\tservicesMap := make(map[bool]*[]string)\n\tservicesMap[true] = &runningServices\n\tservicesMap[false] = &notRunningServices\n\n\treturn servicesMap, nil\n}", "CodeBleu_score": 59.51370918064873}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 72.93499514945306}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tif i.messageBus == nil {\n\t\tlog.Printf(\"Message bus not initialized. Skipping notification: %s\", name)\n\t\treturn\n\t}\n\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to serialize message for notification: %s. Error: %v\", name, err)\n\t\treturn\n\t}\n\n\terr = i.messageBus.Publish(name, jsonMessage)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to publish notification: %s. Error: %v\", name, err)\n\t}\n}", "CodeBleu_score": 34.12950914851265}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t// Serialize the message to JSON\n\tmessageBytes, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Error serializing message: %v\", err)\n\t\treturn\n\t}\n\tmessageJSON := string(messageBytes)\n\n\t// Publish the event to the message bus\n\tresponse, err := i.messageBus.Publish(name, messageJSON)\n\tif err != nil {\n\t\tlog.Printf(\"Error publishing message: %v\", err)\n\t\treturn\n\t}\n\n\t// Check the response status code\n\tif response.StatusCode != http.StatusOK {\n\t\tlog.Printf(\"Error sending message: %v\", response.Status)\n\t\treturn\n\t}\n}", "CodeBleu_score": 33.852121967359075}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t// Marshal the message map into a JSON string.\n\tmessageBytes, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Error marshalling message map to JSON: %v\", err)\n\t\treturn\n\t}\n\t// Publish the message to the message bus.\n\terr = i.bus.Publish(name, messageBytes)\n\tif err != nil {\n\t\tlog.Printf(\"Error publishing message to bus: %v\", err)\n\t\treturn\n\t}\n\tlog.Printf(\"Published message to bus: %s\", string(messageBytes))\n}", "CodeBleu_score": 32.881893480947355}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\treturn message_bus.NewClientWithResponses(c.MessageBusAddress(), c.httpClient)\n}", "CodeBleu_score": 8.006672848169659}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\treturn message_bus.NewClientWithResponses(c.messageBusAddress)\n}", "CodeBleu_score": 7.395612150280593}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\treturn message_bus.NewClientWithResponses(c.message_bus_address)\n}", "CodeBleu_score": 7.444427270060385}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\tforwarded := request.Header.Get(\"x-forwarded-for\")\n\tif forwarded != \"\" {\n\t\treturn strings.Split(forwarded, \", \")[0]\n\t}\n\tip := strings.Split(request.RemoteAddr, \":\")\n\tif len(ip) > 0 {\n\t\treturn ip[0]\n\t}\n\treturn \"0.0.0.0\"\n}", "CodeBleu_score": 31.988400976580934}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"X-Forwarded-For\")\n\tif ip == \"\" {\n\t\tip = strings.Split(request.RemoteAddr, \":\")[0]\n\t}\n\tif ip == \"::1\" {\n\t\treturn \"127.0.0.1\"\n\t} else if strings.HasPrefix(ip, \"::ffff:\") {\n\t\treturn strings.Split(ip, \"::ffff:\")[1]\n\t}\n\treturn ip\n}", "CodeBleu_score": 50.673805130950164}, {"code": "func GetIP(request *http.Request) string{\n\tvar ip string\n\tfor _, h := range []string{\"X-Forwarded-For\", \"X-Real-Ip\"} {\n\t\tfor _, ip = range strings.Split(request.Header.Get(h), \",\") {\n\t\t\tip = strings.TrimSpace(ip)\n\t\t\tif ip != \"\" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif ip != \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\tif ip == \"\" {\n\t\tip, _, _ = net.SplitHostPort(request.RemoteAddr)\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = strings.TrimPrefix(ip, \"::ffff:\")\n\t}\n\treturn ip\n}", "CodeBleu_score": 52.30843963084393}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Read the modules directory\n\tmodules, err := ioutil.ReadDir(c.ModulesDir)\n\tif err != nil {\n\t\tlog.Println(\"Error reading modules directory:\", err)\n\t}\n\n\t// Create an empty array for the modules\n\tvar modulesArray []Module\n\n\t// Loop through each module directory\n\tfor _, module := range modules {\n\t\t// Check if the module is a directory\n\t\tif module.IsDir() {\n\t\t\t// Read the module directory for an entry.json file\n\t\t\tmoduleEntryFile := c.ModulesDir + \"/\" + module.Name() + \"/\" + \"entry.json\"\n\t\t\tmoduleEntry, err := ioutil.ReadFile(moduleEntryFile)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Error reading module entry file:\", err)\n\t\t\t}\n\n\t\t\t// Unmarshal the entry.json file\n\t\t\tvar moduleEntryJSON Module\n\t\t\terr = json.Unmarshal(moduleEntry, &moduleEntryJSON)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Error unmarshalling module entry:\", err)\n\t\t\t}\n\n\t\t\t// Append the module to the modules array\n\t\t\tmodulesArray = append(modulesArray, moduleEntryJSON)\n\t\t}\n\t}\n\n\t// Marshal the modules array\n\tmodulesJSON, err := json.Marshal(modulesArray)\n\tif err != nil {\n\t\tlog.Println(\"Error marshalling modules:\", err)\n\t}\n\n\t// Write the modules array to the entry file\n\terr = ioutil.WriteFile(c.EntryFile, modulesJSON, 0644)\n\tif err != nil {\n\t\tlog.Println(\"Error writing modules to entry file:\", err)\n\t}\n}", "CodeBleu_score": 43.66475283853783}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Generate a consolidated system entry JSON file.\n\t// It defines paths for the modules directory and the entry file, ensuring the entry file exists.\n\t// It reads each module directory for entry.json files, concatenates their content into a single JSON array, and writes this array to the entry file path.\n\t// Errors encountered during directory reading, file reading, or file writing are logged accordingly.\n\n\t// Read the modules directory\n\t// Ensure the entry file exists\n\t// Read each module directory for entry.json files\n\t// Concatenate their content into a single JSON array\n\t// Write this array to the entry file path\n\t// Errors encountered during directory reading, file reading, or file writing are logged accordingly.\n\n}", "CodeBleu_score": 0.9198829537500017}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Read the modules directory\n\tmodules, err := ioutil.ReadDir(c.modulesPath)\n\tif err != nil {\n\t\tlog.Println(\"Error reading modules directory: \", err)\n\t\treturn\n\t}\n\n\t// Ensure the entry file exists\n\tif _, err := os.Stat(c.entryPath); os.IsNotExist(err) {\n\t\t_, err = os.Create(c.entryPath)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error creating entry file: \", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tvar entries []byte\n\tfor _, module := range modules {\n\t\t// Skip any non-directory files\n\t\tif !module.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Read the entry file\n\t\tentryPath := c.modulesPath + \"/\" + module.Name() + \"/entry.json\"\n\t\tentryFile, err := os.Open(entryPath)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error opening entry file: \", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Read the entry file content\n\t\tentry, err := ioutil.ReadAll(entryFile)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading entry file: \", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Append the entry file content to the entries array\n\t\tentries = append(entries, entry...)\n\t}\n\n\t// Write the entries array to the entry file\n\terr = ioutil.WriteFile(c.entryPath, entries, 0644)\n\tif err != nil {\n\t\tlog.Println(\"Error writing to entry file: \", err)\n\t}\n}", "CodeBleu_score": 46.699919164742326}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, networkName := range networkNames {\n\t\tfor _, i := range interfaces {\n\t\t\tif networkName == i.Name {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 64.38557440727908}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnames, err := c.getNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, name := range names {\n\t\tfor _, iface := range interfaces {\n\t\t\tif name == iface.Name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"No matching interface found\")\n}", "CodeBleu_score": 64.88524513745813}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range ifaces {\n\t\tfor _, n := range names {\n\t\t\tif i.Name == n {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 66.73983812238484}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t iRet = 0;\n    STscAppInfoObj *pAppInfo = NULL;\n    STscRequestSummaryObj *pRequestSummary = NULL;\n\n    /* add reference to the request object */\n    iRet = addRefRequest(pRequest);\n    if (iRet != TSC_SUCCESS) {\n        logError(\"addRefRequest() failed\");\n        return iRet;\n    }\n\n    /* increment request count for the associated TSC object */\n    pTscObj->iRequestCount++;\n\n    /* update application's request summary, if available */\n    pAppInfo = pTscObj->pAppInfo;\n    if (pAppInfo != NULL) {\n        pRequestSummary = pAppInfo->pRequestSummary;\n        if (pRequestSummary != NULL) {\n            pRequestSummary->iTotalRequestCount++;\n            pRequestSummary->iCurrentRequestCount++;\n        }\n    }\n\n    logDebug(\"New request registered\");\n    return iRet;\n}", "CodeBleu_score": 32.76412005266097}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t status = STATUS_SUCCESS;\n\n\tif(pRequest == NULL || pTscObj == NULL) {\n\t\tstatus = STATUS_INVALID_ARG;\n\t\tlogError(\"invalid argument passed to registerRequest\");\n\t\treturn status;\n\t}\n\n\tlogDebug(\"registering request for TSC object %p\", pTscObj);\n\n\t// add reference to request\n\tpRequest->refCount++;\n\n\t// increment request count for TSC object\n\tpTscObj->requestCount++;\n\n\t// update application request summary if application is registered\n\tif(pTscObj->appInfo != NULL) {\n\t\tpTscObj->appInfo->requestSummary.totalRequests++;\n\t\tpTscObj->appInfo->requestSummary.currentRequests++;\n\t}\n\n\tlogDebug(\"request %p registered for TSC object %p\", pRequest, pTscObj);\n\n\treturn status;\n}", "CodeBleu_score": 36.407318796513735}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t iRet = 0;\n\n\t/* Add a reference to the request object. */\n\tpRequest->iRefCount++;\n\n\t/* Increment the request count for the associated TSC object. */\n\tpTscObj->iRequestCount++;\n\n\t/* Update the application's request summary, including total and current request counts. */\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpTscObj->pAppInfo->iTotalRequestCount++;\n\t\tpTscObj->pAppInfo->iCurrentRequestCount++;\n\t}\n\n\t/* Log debug information about the new request. */\n\tif (pRequest->iDebugLevel >= 1) {\n\t\tlogDebugMessage(pRequest->pLogFile, pRequest->iDebugLevel,\n\t\t\t\t\"Registering request %p (%s %s)\n\", pRequest,\n\t\t\t\tpRequest->pRequestMethod, pRequest->pRequestUri);\n\t}\n\n\treturn iRet;\n}", "CodeBleu_score": 35.109684402460715}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tif (strcmp(pRequest->pPrimaryDB, exceptDb) != 0) {\n\t\t// check the list of databases\n\t\tint i;\n\t\tfor (i = 0; i < pRequest->dbCount; i++) {\n\t\t\tchar* db = pRequest->ppDBList[i];\n\t\t\tif (strchr(db, '.') != NULL) {\n\t\t\t\tdb = strchr(db, '.') + 1;\n\t\t\t}\n\t\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 54.26991968046888}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tif(strcmp(pRequest->pszDb, exceptDb) != 0) {\n        char* pszDb = pRequest->pszDb;\n        while(*pszDb != '\\0') {\n            if(*pszDb == '.') {\n                pszDb++;\n            }\n            if(strcmp(pszDb, exceptDb) == 0) {\n                return false;\n            }\n            pszDb++;\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 41.98552518971967}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tif (strcmp(pRequest->priDb, exceptDb) != 0) {\n        int i = 0;\n        for (i = 0; i < pRequest->dbCount; i++) {\n            if (strcmp(pRequest->dbs[i], exceptDb) == 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "CodeBleu_score": 46.405785062330594}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tbool rval = false;\n  if (code == 0) {\n    switch (msgType) {\n    case tmsg_error:\n    case tmsg_error_ack:\n    case tmsg_error_ack_ack:\n    case tmsg_error_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack:\n    case tmsg_error_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack_ack", "CodeBleu_score": 22.535364790774004}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tbool rv = false;\n    if (code == RPC_S_SERVER_UNAVAILABLE ||\n        code == RPC_S_CALL_FAILED_DNE ||\n        code == RPC_S_CALL_FAILED ||\n        code == RPC_S_CALL_FAILED_NO_RESPONSE ||\n        code == RPC_S_CALL_FAILED_TIMEOUT ||\n        code == RPC_S_CALL_FAILED_COMM_FAILURE ||\n        code == RPC_S_CALL_FAILED_INTR ||\n        code == RPC_S_CALL_FAILED_UNSUPPORTED_TRANS_SYN ||\n        code == RPC_S_CALL_FAILED_FRAGMENTED) {\n        if (msgType != tmsg_t::tmsg_t_rpc_req) {\n            rv = true;\n        }\n    }\n    return rv;\n}", "CodeBleu_score": 38.197686706265024}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tbool retval = false;\n\n  if (code == RPC_ERR_REDIRECT) {\n    if (msgType == tmsg_t::TMSG_RPC_REQUEST) {\n      retval = true;\n    }\n  }\n\n  return retval;\n}", "CodeBleu_score": 27.33389309675816}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\t// Iterate through the hash table of requests\n\tfor (int i = 0; i < pRequests->tableSize; i++) {\n\t\tSHashNode *pNode = pRequests->table[i];\n\t\twhile (pNode != NULL) {\n\t\t\t// Get the request ID\n\t\t\tint64_t rid = (int64_t)pNode->key;\n\t\t\t// Acquire the request\n\t\t\tint32_t ret = acquireRequest(rid);\n\t\t\tif (ret == 0) {\n\t\t\t\t// Stop the query if it is valid\n\t\t\t\tif (taosStopQuery(clientReqRefPool, rid) == 0) {\n\t\t\t\t\t// Release the request\n\t\t\t\t\treleaseRequest(rid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpNode = pNode->next;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.10420861013616}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\tint32_t i = 0;\n\tfor (i = 0; i < pRequests->tableSize; i++) {\n\t\tSHashNode *pNode = pRequests->table[i];\n\t\twhile (pNode != NULL) {\n\t\t\tif (pNode->data != NULL) {\n\t\t\t\tTaosQueryInfo *pQueryInfo = (TaosQueryInfo *)pNode->data;\n\t\t\t\tif (pQueryInfo->taos != NULL) {\n\t\t\t\t\ttaos_stop_query(pQueryInfo->taos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpNode = pNode->next;\n\t\t}\n\t}\n}", "CodeBleu_score": 35.439549287754524}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\tfor (int i = 0; i < pRequests->capacity; i++) {\n\t\tSHashEntry *pEntry = pRequests->entries[i];\n\t\twhile (pEntry != NULL) {\n\t\t\tif (pEntry->value != NULL) {\n\t\t\t\tTAOS_RES *res = (TAOS_RES *)pEntry->value;\n\t\t\t\tif (res->taos != NULL) {\n\t\t\t\t\ttaos_cancel_query(res->taos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpEntry = pEntry->next;\n\t\t}\n\t}\n}", "CodeBleu_score": 35.32488223186289}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\tif (crashReportingEnabled == 0) {\n\t\treturn;\n\t}\n\tif (atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n\t\twhile (clientStop == 1) {\n\t\t\tsleep(1);\n\t\t}\n\t} else {\n\t\ttscLog(\"Crash report thread is already stopped.\n\");\n\t}\n}", "CodeBleu_score": 55.735395831516584}, {"code": "void tscStopCrashReport(){\n\tif (!tscIsCrashReportEnabled()) {\n        return;\n    }\n    if (!atomic_compare_exchange_strong(&clientStop, &zero, &one)) {\n        tscLog(TSC_LOG_WARNING, \"crash report thread already stopped\");\n        return;\n    }\n    while (atomic_load(&clientStop) != 0) {\n        sleep(1);\n    }\n}", "CodeBleu_score": 65.9474608392303}, {"code": "void tscStopCrashReport(){\n\tif (tscGetCrashReportEnabled() == 0) {\n\t\treturn;\n\t}\n\n\tint expected = 0;\n\tint desired = 1;\n\tif (!atomic_compare_exchange_strong(&clientStop, &expected, desired)) {\n\t\ttscDebug(\"crash report thread is already stopped\n\");\n\t\treturn;\n\t}\n\n\twhile (clientStop == 1) {\n\t\tusleep(10000);\n\t}\n}", "CodeBleu_score": 49.006264836468006}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t numViews = 0;\n\tint32_t numColumns = 0;\n\tint32_t viewID = 0;\n\tint32_t columnID = 0;\n\tint32_t columnType = 0;\n\tint32_t columnSize = 0;\n\tint32_t columnIndex = 0;\n\tchar *viewName = NULL;\n\tchar *columnName = NULL;\n\tchar *columnTypeName = NULL;\n\tstruct SViewInfo **viewInfo = NULL;\n\tstruct SViewInfo *pViewInfo = NULL;\n\tstruct SColumnInfo *columnInfo = NULL;\n\tstruct SColumnInfo *pColumnInfo = NULL;\n\tstruct SColumnInfo *pColumnInfoPrev = NULL;\n\tstruct SColumnInfo *pColumnInfoNext = NULL;\n\tstruct SColumnInfo *pColumnInfoTemp = NULL;\n\tstruct SColumnInfo **columnInfoArray = NULL;\n\tstruct SColumnInfo **columnInfoArrayPrev = NULL;\n\tstruct SColumnInfo **columnInfoArrayNext = NULL;\n\tstruct SColumnInfo **columnInfoArrayTemp = NULL;\n\tstruct SColumnInfo **columnInfoArrayTemp2 = NULL;\n\n\t/*\n\t * Deserialize the view information response.\n\t */\n\tviewInfo = deserializeViewInfo(value, valueLen, &numViews, &rc);\n\tif (rc != MEMCACHED_SUCCESS) {\n\t\t/*\n\t\t * Deserialization failed.  Clean up and return an error code.\n\t\t */\n\t\tsLogWrite(pCatalog->pLog, QUERY_LOG, \"Error deserializing view information response.", "CodeBleu_score": 20.03383022576314}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t retCode = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t l = 0;\n\tint32_t m = 0;\n\tint32_t n = 0;\n\tint32_t o = 0;\n\tint32_t p = 0;\n\tint32_t q = 0;\n\tint32_t r = 0;\n\tint32_t s = 0;\n\tint32_t t = 0;\n\tint32_t u = 0;\n\tint32_t v = 0;\n\tint32_t w = 0;\n\tint32_t x = 0;\n\tint32_t y = 0;\n\tint32_t z = 0;\n\tint32_t aa = 0;\n\tint32_t bb = 0;\n\tint32_t cc = 0;\n\tint32_t dd = 0;\n\tint32_t ee = 0;\n\tint32_t ff = 0;\n\tint32_t gg = 0;\n\tint32_t hh = 0;\n\tint32_t ii = 0;\n\tint32_t jj = 0;\n\tint32_t kk = 0;\n\tint32_t ll = 0;\n\tint32_t mm = 0;\n\tint32_t nn = 0;\n\tint32_t oo = 0;\n\tint32_t pp = 0;\n\tint32_t qq = 0;\n\tint32_t rr = 0;\n\tint32_t ss = 0;\n\tint32_t tt = 0;\n\tint32_t uu = 0;\n\tint32_t vv = 0;\n\tint32_t ww", "CodeBleu_score": 8.270247419078146}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t l = 0;\n\tint32_t m = 0;\n\tint32_t n = 0;\n\tint32_t o = 0;\n\tint32_t p = 0;\n\tint32_t q = 0;\n\tint32_t r = 0;\n\tint32_t s = 0;\n\tint32_t t = 0;\n\tint32_t u = 0;\n\tint32_t v = 0;\n\tint32_t w = 0;\n\tint32_t x = 0;\n\tint32_t y = 0;\n\tint32_t z = 0;\n\tint32_t aa = 0;\n\tint32_t ab = 0;\n\tint32_t ac = 0;\n\tint32_t ad = 0;\n\tint32_t ae = 0;\n\tint32_t af = 0;\n\tint32_t ag = 0;\n\tint32_t ah = 0;\n\tint32_t ai = 0;\n\tint32_t aj = 0;\n\tint32_t ak = 0;\n\tint32_t al = 0;\n\tint32_t am = 0;\n\tint32_t an = 0;\n\tint32_t ao = 0;\n\tint32_t ap = 0;\n\tint32_t aq = 0;\n\tint32_t ar = 0;\n\tint32_t as = 0;\n\tint32_t at = 0;\n\tint32_t au = 0;\n\tint32_t av = 0;\n\tint32_t aw = 0;\n\tint32_", "CodeBleu_score": 8.062662090435575}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3_put_object_callback_data *data = (S3_put_object_callback_data *) callbackData;\n\n    (void)properties;\n\n    data->contentLength = 0;\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 66.43875276155879}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tstruct callback_data *data = (struct callback_data *) callbackData;\n\n    (void)properties;\n\n    syslog(LOG_DEBUG, \"responsePropertiesCallback: content length %lld\",\n           properties->contentLength);\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    }\n    else {\n        data->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 69.98039997111071}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3Status responseStatus = S3StatusOK;\n    CallbackData *data = (CallbackData *) callbackData;\n    int64_t contentLength = 0;\n\n    // Check the response properties for the content length\n    if (properties->contentLength > 0) {\n        // Set the content length in the callback data structure\n        contentLength = properties->contentLength;\n    }\n    else {\n        // Set the content length to zero in the callback data structure\n        contentLength = 0;\n    }\n\n    // Update the content length in the callback data structure\n    data->contentLength = contentLength;\n\n    // Return S3StatusOK to indicate that response properties processing completed successfully.\n    return responseStatus;\n}", "CodeBleu_score": 60.882831181073925}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tif (tsCheckpointBackupDir == NULL) {\n    uError(\"[rsync] checkpoint backup dir is null\");\n    return;\n  }\n\n  if (taosMkdir(tsCheckpointBackupDir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) != 0) {\n    uError(\"[rsync] make dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) return;\n\n  char cmd[PATH_MAX * 4] = {0};\n  snprintf(cmd, PATH_MAX * 4, \"rsync --daemon --config=%s --port=%d\", confDir, tsRsyncPort);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) != 0) {\n    uError(\"[rsync] start rsync error, cmd:%s\", cmd);\n    return;\n  }\n\n  uDebug(\"[rsync] start rsync success, cmd:%s\", cmd);\n}", "CodeBleu_score": 63.86881041818885}, {"code": "void startRsync(){\n\tuDebug(\"[rsync] start rsync server\");\n\n  if (taosMkdir(tsCheckpointBackupDir, TD_S_IRWXU | TD_S_IRWXG | TD_S_IRWXO) < 0) {\n    uError(\"[rsync] mkdir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupConf) < 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --no-detach --config=%s\", tsCheckpointBackupConf);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) < 0) {\n    uError(\"[rsync] start rsync server error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start rsync server success\");\n  }\n}", "CodeBleu_score": 61.01985424397983}, {"code": "void startRsync(){\n\tuDebug(\"[rsync] start rsync server\");\n  if (mkdir(tsCheckpointBackupDir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) != 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupConf) != 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --no-detach --config=%s\", tsCheckpointBackupConf);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  system(cmd);\n}", "CodeBleu_score": 42.163902596682625}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n    }\n    dispatcher.shutdown();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 64.37331117244707}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new IllegalArgumentException(\"Dispatcher with id \" + dispatcherId + \" not found\");\n    }\n    dispatcher.shutdownNow();\n}", "CodeBleu_score": 61.841020276181204}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" not found\");\n    }\n    dispatcher.shutdownNow();\n}", "CodeBleu_score": 61.61312662401088}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tSet<TbActorId> children = childrenMap.get(parent);\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(childId -> {\n            try {\n                tell(childId, msg, highPriority);\n            } catch (TbActorNotRegisteredException e) {\n                log.warn(\"[{}] Failed to broadcast message to child actor [{}]\", parent.getId(), childId.getId());\n            }\n        });\n    }\n}", "CodeBleu_score": 71.07941969363173}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId[] children = childrenMap.get(parent);\n     if (children != null) {\n         for (TbActorId child : children) {\n             if (childFilter.test(child)) {\n                 tell(child, msg, highPriority);\n             }\n         }\n     }\n }", "CodeBleu_score": 52.06903315021646}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tSet<TbActorId> children = childrenMap.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                try {\n                    tell(child, msg, highPriority);\n                } catch (TbActorException e) {\n                    log.warn(\"[{}] Failed to broadcast msg to child actor [{}]\", parent, child, e);\n                }\n            });\n        }\n    }", "CodeBleu_score": 68.06375965405684}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(true);\n    }", "CodeBleu_score": 28.377653473966113}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(true);\n    }", "CodeBleu_score": 28.377653473966113}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(true);\n    }", "CodeBleu_score": 28.377653473966113}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\tint processed = 0;\n        try {\n            while (processed < maxProcessCount) {\n                processed++;\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    msg = normalPriorityMsgs.poll();\n                }\n                if (msg == null) {\n                    break;\n                }\n                try {\n                    actor.process(msg);\n                } catch (TbActorNotInitializedException e) {\n                    log.trace(\"[{}] Actor is not initialized, ignore message: {}\", selfId, msg);\n                    msg.onTbActorStopped(TbActorStopReason.NOT_INITIALIZED);\n                    stopReason = TbActorStopReason.NOT_INITIALIZED;\n                    destroy(e);\n                    break;\n                } catch (Throwable t) {\n                    log.trace(\"[{}] Failed to process message: {}\", selfId, msg, t);\n                    actor.onProcessFailure(t);\n                    switch (actor.getProcessFailureStrategy()) {\n                        case STOP:\n                            stopReason = TbActorStopReason.PROCESSING_FAILURE;\n                            destroy(t);\n                            break;\n                        case REINIT:\n                            destroy(t);\n                            init(selfId);\n                            break;\n                        case NOOP:\n                            break;\n                    }\n                }\n            }\n        } finally {\n            busy.set(FREE);\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                ready.set(READY);\n            } else {\n                tryProcessQueue(false);\n            }\n        }\n    }", "CodeBleu_score": 48.40487030976176}, {"code": "private void processMailbox(){\n\ttry {\n        if (ready.get() == READY) {\n            int processed = 0;\n            while (processed < dispatcher.getSettings().getProcessingThreadsCount()) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    msg = normalPriorityMsgs.poll();\n                }\n                if (msg != null) {\n                    try {\n                        actor.process(msg);\n                    } catch (TbActorNotInitializedException e) {\n                        stopReason = TbActorStopReason.NOT_INITIALIZED;\n                        destroy(e);\n                        return;\n                    } catch (Throwable t) {\n                        log.warn(\"[{}] Failed to process message: {}\", selfId, msg, t);\n                        if (actor.onProcessFailure(t)) {\n                            stopReason = TbActorStopReason.FAILURE;\n                            destroy(t);\n                            return;\n                        }\n                    }\n                    processed++;\n                } else {\n                    break;\n                }\n            }\n            if (processed == 0) {\n                busy.set(FREE);\n                dispatcher.getExecutor().execute(this::tryProcessQueue);\n            } else {\n                dispatcher.getExecutor().execute(this::processMailbox);\n            }\n        } else {\n            busy.set(FREE);\n            dispatcher.getExecutor().execute(this::tryProcessQueue);\n        }\n    } catch (Throwable t) {\n        log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n        busy.set(FREE);\n        dispatcher.getExecutor().execute(this::tryProcessQueue);\n    }\n}", "CodeBleu_score": 52.67347838524826}, {"code": "private void processMailbox(){\n\tint processed = 0;\n        try {\n            while (processed < throughput) {\n                if (!highPriorityMsgs.isEmpty()) {\n                    TbActorMsg msg = highPriorityMsgs.poll();\n                    if (msg != null) {\n                        try {\n                            actor.process(msg);\n                        } catch (TbActorException e) {\n                            if (e.isCritical()) {\n                                stopReason = e.getStopReason();\n                                destroy(e);\n                                return;\n                            } else {\n                                log.trace(\"[{}] Failed to process message: {}\", selfId, e.getMessage(), e);\n                                applyFailureStrategy(msg, e);\n                            }\n                        } catch (Throwable t) {\n                            log.trace(\"[{}] Failed to process message: {}\", selfId, t.getMessage(), t);\n                            applyFailureStrategy(msg, t);\n                        }\n                    }\n                } else if (!normalPriorityMsgs.isEmpty()) {\n                    TbActorMsg msg = normalPriorityMsgs.poll();\n                    if (msg != null) {\n                        try {\n                            actor.process(msg);\n                        } catch (TbActorException e) {\n                            if (e.isCritical()) {\n                                stopReason = e.getStopReason();\n                                destroy(e);\n                                return;\n                            } else {\n                                log.trace(\"[{}] Failed to process message: {}\", selfId, e.getMessage(), e);\n                                applyFailureStrategy(msg, e);\n                            }\n                        } catch (Throwable t) {\n                            log.trace(\"[{}] Failed to process message: {}\", selfId, t.getMessage(), t);\n                            applyFailureStrategy(msg, t);\n                        }\n                    }\n                } else {\n                    break;\n                }\n                processed++;\n            }\n        } finally {\n            if (processed < throughput) {\n                busy.set(FREE);\n                tryProcessQueue(false);\n            } else {\n                dispatcher.get", "CodeBleu_score": 42.567748673369884}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (TenantId.SYS_TENANT_ID.equals(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitProfile rateLimitProfile = tenantProfile.getRateLimitProfile();\n    if (rateLimitProfile == null) {\n        return true;\n    }\n    RateLimit rateLimit = rateLimitProfile.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitResult result = rateLimitService.checkRateLimit(tenantId, api, rateLimit, level);\n    if (result.isThrottled()) {\n        processRateLimitNotification(tenantId, api, rateLimit, result);\n    }\n    return !result.isThrottled();\n}", "CodeBleu_score": 57.490690117297774}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileService.findTenantProfileById(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    TenantProfileData tenantProfileData = tenantProfile.getProfileData();\n    if (tenantProfileData == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitConfiguration rateLimitConfiguration = tenantProfileData.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitPolicy rateLimitPolicy = rateLimitConfiguration.getPolicy(api);\n    if (rateLimitPolicy == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitPolicyResult result = rateLimitPolicy.checkRateLimit(level);\n    if (result.isThrottling()) {\n        processRateLimitNotification(api, tenantId, rateLimitPolicy, result);\n    }\n    return !result.isThrottling();\n}", "CodeBleu_score": 53.73925927050025}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.isNullUid()) {\n        return true;\n    }\n    TenantProfile tenantProfile;\n    try {\n        tenantProfile = tenantProfileCache.get(tenantId);\n    } catch (Exception e) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    TenantRateLimit rateLimit = tenantProfile.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitStats stats = getOrInitStats(tenantId, api, level);\n    if (rateLimit.isThrottlingEnabled()) {\n        return checkThrottlingRateLimit(api, tenantId, rateLimit, stats);\n    } else {\n        return checkDailyRateLimit(api, tenantId, rateLimit, stats);\n    }\n}", "CodeBleu_score": 57.323097110022495}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tDate expirationTime = new Date(System.currentTimeMillis() - inactivityTimeout);\n    for (Map.Entry<String, DTLSServerSession> entry : sessions.entrySet()) {\n        DTLSServerSession session = entry.getValue();\n        if (session.getLastActivityTime().before(expirationTime)) {\n            logger.info(\"Evicting session \" + entry.getKey() + \" with last activity time \" + session.getLastActivityTime() + \" due to inactivity timeout.\");\n            sessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 36.79829485063434}, {"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSClient> entry : dtlsClients.entrySet()) {\n        DTLSClient dtlsClient = entry.getValue();\n        if (dtlsClient.getLastActivityTime() < expirationTime) {\n            logger.info(\"Evicting DTLS session \" + entry.getKey() + \" due to inactivity timeout\");\n            dtlsClients.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 46.431106704592864}, {"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - inactivityTimeout;\n\tIterator<Map.Entry<String, DTLSConnection>> iterator = dtlsSessions.entrySet().iterator();\n\twhile (iterator.hasNext()) {\n\t\tMap.Entry<String, DTLSConnection> entry = iterator.next();\n\t\tDTLSConnection connection = entry.getValue();\n\t\tif (connection.getLastActivity() < expirationTime) {\n\t\t\tlogger.info(\"Evicting session \" + connection.getSessionId() + \" due to timeout\");\n\t\t\titerator.remove();\n\t\t}\n\t}\n}", "CodeBleu_score": 33.11290535704995}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tList<TsKvEntry> result = new ArrayList<>();\n    if (!timeseries.isEmpty()) {\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            if (values != null) {\n                for (JsonNode value : values) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), parseValue(key, value)));\n                }\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 43.79568701422119}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (!timeseries.isEmpty()) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                if (value.isNumber()) {\n                    parseNumericValue(key, value).getTsKvEntry().ifPresent(result::add);\n                } else if (value.isBoolean()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new BooleanDataEntry(key, value.asBoolean())));\n                } else if (value.isTextual()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.asText())));\n                }\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 44.4261320237952}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> result = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        for (JsonNode value : entry.getValue()) {\n            if (value.isNumber()) {\n                Double v = value.asDouble();\n                if (v.isInfinite() || v.isNaN()) {\n                    continue;\n                }\n            }\n            result.add(new BasicTsKvEntry(System.currentTimeMillis(), parseValue(key, value)));\n        }\n    }\n    return result;\n}", "CodeBleu_score": 44.581969621007644}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", this.refreshToken);\n        try {\n            JsonNode response = this.sendRequest(\"POST\", this.authEndpoint, requestMap);\n            this.setTokenInfo(System.currentTimeMillis(), response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }", "CodeBleu_score": 41.6855803115772}, {"code": "public void refreshToken(){\n\ttry {\n            Map<String, String> request = new HashMap<>();\n            request.put(\"refreshToken\", this.refreshToken);\n            JsonNode response = this.httpClient.post(this.authEndpoint, request);\n            long ts = System.currentTimeMillis();\n            this.setTokenInfo(ts, response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }", "CodeBleu_score": 52.22425952597591}, {"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", this.refreshToken);\n        try {\n            HttpResponse<JsonNode> response = Unirest.post(this.baseUrl + this.refreshTokenEndpoint)\n                    .header(\"Content-Type\", \"application/json\")\n                    .body(requestMap)\n                    .asJson();\n            this.setTokenInfo(System.currentTimeMillis(), response.getBody());\n        } catch (UnirestException e) {\n            e.printStackTrace();\n        }\n    }", "CodeBleu_score": 46.36185744081337}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\tlong ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", this.username);\n        loginRequest.put(\"password\", this.password);\n        try {\n            String response = this.httpClient.sendPost(this.loginUrl, loginRequest);\n            setTokenInfo(ts, new ObjectMapper().readTree(response));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }", "CodeBleu_score": 60.937818176229754}, {"code": " private void doLogin(){\n\tlong ts = System.currentTimeMillis();\n        Map<String, Object> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        JsonNode tokenInfo = doPost(loginRequest, \"/api/auth/login\", null);\n        setTokenInfo(ts, tokenInfo);\n    }", "CodeBleu_score": 66.0034052116658}, {"code": " private void doLogin(){\n\tlong ts = System.currentTimeMillis();\n        Map<String, Object> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", this.username);\n        loginRequest.put(\"password\", this.password);\n        try {\n            ResponseEntity<JsonNode> response = this.restTemplate.postForEntity(this.authEndpoint + \"/api/auth/login\", loginRequest, JsonNode.class);\n            setTokenInfo(ts, response.getBody());\n        } catch (HttpClientErrorException e) {\n            throw new RuntimeException(\"Login failed: \" + e.getResponseBodyAsString());\n        }\n    }", "CodeBleu_score": 66.84530011884807}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\tString url = baseUrl + \"/api/device/\" + deviceId;\n    try {\n        Device device = restTemplate.getForObject(url, Device.class);\n        return Optional.of(device);\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 60.67637692755863}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\treturn getDeviceById(deviceId, false);\n}", "CodeBleu_score": 6.442442105657592}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        final ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId);\n        return Optional.ofNullable(response.getBody());\n    } catch (final HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 62.75354110190106}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tRequest request = new Request(\"POST\", \"/api/device-with-credentials\");\n    request.setBody(new DeviceWithCredentials(device, credentials));\n    try {\n        Response response = client.newCall(request).execute();\n        if (response.code() == 404) {\n            return Optional.empty();\n        } else {\n            return Optional.of(response.body().as(Device.class));\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 48.868895120701325}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\n        DeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n        Request request = new Request.Builder()\n                .url(baseUrl + \"/api/device-with-credentials\")\n                .post(RequestBody.create(MediaType.parse(\"application/json; charset=utf-8\"), gson.toJson(deviceWithCredentials)))\n                .build();\n        Response response = client.newCall(request).execute();\n        if (response.code() == 404) {\n            return Optional.empty();\n        }\n        return Optional.of(gson.fromJson(response.body().string(), Device.class));\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 51.479012127292066}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\n        Request request = Request.create(RequestMethod.POST, \"/api/device-with-credentials\", Device.class);\n        request.setBody(device);\n        request.setCredentials(credentials);\n        Response response = request.send();\n        return Optional.of(response.getBody(Device.class));\n    } catch (RequestException e) {\n        if (e.getStatusCode() == 404) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 51.48614853676769}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n\t\ttarget[method] = (...args) => {\n\t\t\tconst duration = args.length > 1 ? args.shift() : 1000;\n\t\t\tconst callback = args.length > 0 ? args.shift() : null;\n\t\t\tconst promises = this.map(element => {\n\t\t\t\treturn new Promise(resolve => {\n\t\t\t\t\telement[method](...args, () => resolve(element));\n\t\t\t\t});\n\t\t\t});\n\t\t\tPromise.all(promises).then(elements => {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(elements);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 28.20039944362966}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tfor (const method of methods) {\n        target[method] = function (duration, callback) {\n            if (typeof duration === 'function') {\n                callback = duration;\n                duration = 1000;\n            }\n            const promises = this.map(element => new Promise((resolve, reject) => {\n                const start = Date.now();\n                const interval = setInterval(() => {\n                    if (element[method]()) {\n                        clearInterval(interval);\n                        resolve();\n                    } else if (Date.now() - start > duration) {\n                        clearInterval(interval);\n                        reject();\n                    }\n                }, 100);\n            }));\n            Promise.all(promises).then(callback);\n        };\n    }\n}", "CodeBleu_score": 43.88921110440158}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n\t\ttarget[method + 'Callback'] = (duration, callback) => {\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tcallback = () => {};\n\t\t\t}\n\n\t\t\tconst promises = [];\n\t\t\ttarget.forEach(element => {\n\t\t\t\tpromises.push(element[method](duration));\n\t\t\t});\n\n\t\t\tPromise.all(promises).then(callback);\n\t\t};\n\t});\n}", "CodeBleu_score": 25.0801461617155}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct ad559x_config *config = dev->config;\n\tint active_channels = 0;\n\tsize_t needed_buffer_size;\n\tint i;\n\n\tfor (i = 0; i < config->channel_count; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = active_channels * sizeof(uint16_t);\n\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= 2;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\tsequence->buffer_size, needed_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 46.3007261935979}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n    uint32_t needed_buffer_size;\n    uint8_t active_channels = 0U;\n    uint8_t channel_id;\n    int return_value = 0;\n\n    for (channel_id = 0U; channel_id < data->channels; channel_id++) {\n\tif (sequence->channels & BIT(channel_id)) {\n\t    active_channels++;\n\t}\n    }\n\n    needed_buffer_size = active_channels * sizeof(uint16_t);\n\n    if (sequence->options) {\n\tneeded_buffer_size *= 2U;\n    }\n\n    if (sequence->buffer_size < needed_buffer_size) {\n\treturn_value = -ENOMEM;\n    }\n\n    return return_value;\n}", "CodeBleu_score": 39.55327922872737}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_cfg *config = dev->config;\n    uint8_t channels = 0U;\n    size_t needed_buffer_size;\n\n    for (int i = 0; i < sequence->channels; i++) {\n\tif (sequence->channels & BIT(i)) {\n\t    channels++;\n\t}\n    }\n\n    needed_buffer_size = channels * sizeof(uint16_t);\n\n    if (sequence->options) {\n\tneeded_buffer_size *= 2U;\n    }\n\n    if (sequence->buffer_size < needed_buffer_size) {\n\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\tsequence->buffer_size, needed_buffer_size);\n\treturn -ENOMEM;\n    }\n\n    return 0;\n}", "CodeBleu_score": 50.081790486938104}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t channels = sequence->channels;\n\tint err;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"AD559x: unsupported resolution\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (channels != config->channels) {\n\t\tLOG_ERR(\"AD559x: unsupported channels\");\n\t\treturn -ENOTSUP;\n\t}\n\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err) {\n\t\tLOG_ERR(\"AD559x: insufficient buffer size provided\");\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->channels = channels;\n\tdata->repeat_buffer = sequence->buffer_size / sizeof(uint16_t);\n\n\tad_ad559x_start_read(dev);\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}", "CodeBleu_score": 54.400859680573234}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_sequence_options *options;\n\tint error;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"AD559x: unsupported resolution %d\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\toptions = (struct adc_ad559x_sequence_options *)sequence->options;\n\n\tif (options->channel_mask != ADC_AD559X_CHANNEL_MASK) {\n\t\tLOG_ERR(\"AD559x: unsupported channels in mask 0x%x\", options->channel_mask);\n\t\treturn -ENOTSUP;\n\t}\n\n\terror = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (error) {\n\t\tLOG_ERR(\"AD559x: unsufficient buffer size\");\n\t\treturn error;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\terror = adc_context_start_read(&data->ctx, sequence);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\terror = adc_ad559x_read_async(dev, sequence);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}", "CodeBleu_score": 63.560353944714024}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tint error;\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"unsupported resolution %d\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"unsupported oversampling %d\", sequence->oversampling);\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"unsupported calibration\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & ~BIT_MASK(AD559X_NUM_CHANNELS)) {\n\t\tLOG_ERR(\"unsupported channels in mask: 0x%08x\", sequence->channels);\n\t\treturn -ENOTSUP;\n\t}\n\n\terror = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (error) {\n\t\tLOG_ERR(\"adc_ad559x_validate_buffer_size failed with %d\", error);\n\t\treturn error;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\terror = adc_context_wait_for_completion(&data->ctx);\n\tadc_context_on_sampling_done(&data->ctx, error);\n\n\treturn error;\n}", "CodeBleu_score": 67.48653483451702}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_sampling_control *ctrl = &ctx->ctrl;\n\n\t/* Set channels to be sampled */\n\tadc_set_channels(ctrl->dev, ctrl->sequence.channels, ctrl->sequence.length);\n\n\t/* Setup ADC buffer */\n\tadc_set_buffer(ctrl->dev, ctrl->buffer, ctrl->sequence.buffer_length);\n\n\t/* Start sampling */\n\tadc_start(ctrl->dev);\n}", "CodeBleu_score": 46.75624609615946}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_data *data = ctx->data;\n\tuint8_t channels = ctx->channels;\n\tuint8_t i;\n\n\t/* Set channels to be sampled */\n\tdata->channels = channels;\n\n\t/* Initialize repeat buffer */\n\tfor (i = 0; i < ADC_REPEAT_BUFFER_SIZE; i++) {\n\t\tdata->repeat_buffer[i] = data->buffer;\n\t}\n\n\t/* Signal start of sampling */\n\tk_sem_give(&data->sem_start);\n}", "CodeBleu_score": 53.208174519988475}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_dev_s *adc = ctx->adc_dev;\n\tuint8_t channels = ctx->channels;\n\tuint8_t channel;\n\n\tadc->adc_channels = channels;\n\tadc->buffer = ctx->buffer;\n\n\tfor (channel = 0; channel < ADC_MAX_SAMPLES; channel++) {\n\t\tif (channels & (1 << channel)) {\n\t\t\tadc->adc_repeat[channel].sample = 0;\n\t\t}\n\t}\n\n\tsem_post(&adc->sem_excl);\n}", "CodeBleu_score": 48.25285445501141}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tstruct adc_data_container *data_container = ctx->data_container;\n\tif (repeat_sampling) {\n\t\tdata_container = ctx->repeat_data_container;\n\t}\n\tctx->buffer_pointer = data_container->buffer;\n}", "CodeBleu_score": 47.525991147373745}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tstruct adc_data_container *data_container = ctx->data_container;\n\tif (repeat_sampling) {\n\t\tdata_container = ctx->repeat_data_container;\n\t}\n\tctx->buffer_pointer = data_container->buffer;\n}", "CodeBleu_score": 47.525991147373745}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tctx->data_container->buffer_pointer = (repeat_sampling) ? ctx->data_container->repeat_buffer : ctx->data_container->buffer;\n}", "CodeBleu_score": 42.685977139176835}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tstruct adc_sequence *sequence;\n\tuint16_t val;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\t\tsequence = data->sequence;\n\n\t\tfor (size_t i = 0; i < sequence->channels; i++) {\n\t\t\tret = adc_ad559x_read_channel(data->dev, sequence->channels_list[i], &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d (%d)\", sequence->channels_list[i], ret);\n\t\t\t\tadc_context_on_sampling_done(&data->ctx, data->dev);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (sequence->oversampling) {\n\t\t\t\tadc_context_oversampling_buffer_add(&data->ctx, val);\n\t\t\t} else {\n\t\t\t\tadc_context_update_buffer(&data->ctx, val, sequence->channels_list[i]);\n\t\t\t}\n\t\t}\n\n\t\tadc_context_on_sampling_done(&data->ctx, data->dev);\n\n\t\tif (sequence->calibrate) {\n\t\t\tadc_context_release(&data->ctx, data->dev);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.8163572979893}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct device *dev = data->dev;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t channel;\n\tuint16_t val;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\t\tif (data->state != ADC_AD559X_STATE_SAMPLING) {\n\t\t\tLOG_ERR(\"ADC is not sampling\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (channel = 0; channel < config->channel_map_size; channel++) {\n\t\t\tif (!(data->active_channels & BIT(channel))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(dev, channel, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d (err %d)\", channel, ret);\n\t\t\t\tdata->state = ADC_AD559X_STATE_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->buffer[channel] = val;\n\t\t}\n\n\t\tdata->state = ADC_AD559X_STATE_IDLE;\n\t\tk_sem_give(&data->read_sem);\n\t}\n}", "CodeBleu_score": 48.16086294690576}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->channel_count; channel++) {\n\t\t\tif (!data->active_channels[channel]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d (%d)\", channel, ret);\n\t\t\t\tdata->complete = true;\n\t\t\t\tk_sem_give(&data->read_sem);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdata->buffer[channel] = result;\n\t\t}\n\n\t\tdata->complete = true;\n\t\tk_sem_give(&data->read_sem);\n\t}\n}", "CodeBleu_score": 55.339140631939024}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tuint8_t config_reg[1] = {0};\n\tint rc = 0;\n\n\tk_msleep(ADS1112_READY_TIME);\n\tdo {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, config_reg);\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\t\tk_usleep(100);\n\t} while (config_reg[0] & ADS1112_CONFIG_REG_BIT_OS);\n\n\treturn rc;\n}", "CodeBleu_score": 30.940416664229726}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tuint8_t config_val[1] = {0};\n\tint rc = 0;\n\tuint8_t ready = 0;\n\n\t/* Sleep for the device's specified ready time. */\n\tk_usleep(ads1112_ready_time[ads1112_config.rate]);\n\n\t/* Check the device's status. */\n\twhile (!ready) {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, config_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t\tready = config_val[0] & ADS1112_CONFIG_RDY;\n\t\t/* If the device is not ready, sleep for 100 microseconds and check the status again. */\n\t\tif (!ready) {\n\t\t\tk_usleep(100);\n\t\t}\n\t}\n\treturn rc;\n}", "CodeBleu_score": 36.67783956722596}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t config_reg[1] = {0};\n\tint rc;\n\tuint8_t ready = 0;\n\n\tk_sleep(K_USEC(config->ready_time));\n\n\twhile (!ready) {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, config_reg);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tready = config_reg[0] & ADS1112_CONFIG_RDY_MASK;\n\t\tk_sleep(K_USEC(100));\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.08863114911016}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tint buffer_size = sequence->buffer_size;\n\tint required_size = sequence->options & ADC_DMA_MODE ? 2 : 1;\n\n\tif (sequence->options & ADC_REPEAT_SAMPLING) {\n\t\trequired_size *= sequence->samplings * (sequence->oversampling + 1);\n\t} else {\n\t\trequired_size *= sequence->samplings;\n\t}\n\n\tif (buffer_size < required_size) {\n\t\tLOG_ERR(\"Provided buffer is too small. Expected %d, got %d\",\n\t\t\trequired_size, buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.91641794604937}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tsize_t required_buffer_size = 0;\n\n\tif (sequence->options & ADC_SEQ_OPT_CONTINUOUS) {\n\t\tLOG_ERR(\"Continuous sampling is not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\trequired_buffer_size = sequence->options->extra_samplings + sequence->options->oversampling;\n\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\t\tsequence->buffer_size, required_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 53.31605789294386}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tsize_t required_buffer_size;\n\tsize_t actual_buffer_size;\n\tint ret;\n\n\trequired_buffer_size = ads1112_get_required_buffer_size(sequence);\n\tactual_buffer_size = sequence->buffer_size;\n\n\tif (required_buffer_size > actual_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer of %u is too small, requires %u\",\n\t\t\tactual_buffer_size, required_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 37.48665890419654}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tstruct ads1112_data *data = dev->data;\n\tconst struct ads1112_config *config = dev->config;\n\tstruct adc_async_read_ctx *ctx = &data->ctx;\n\tint err;\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tctx->sequence = sequence;\n\tctx->buffer = sequence->buffer;\n\tctx->repeat_buffer = sequence->buffer;\n\tctx->repeat_count = sequence->buffer_size;\n\tctx->channel_id = sequence->channels;\n\tctx->read_calls = 0U;\n\tctx->next_sampling_point = data->hw_start_delay;\n\n\tk_timer_start(&data->timer, K_USEC(data->hw_start_delay), K_NO_WAIT);\n\n\tif (wait) {\n\t\tk_sem_take(&data->sem_sync, K_FOREVER);\n\t\terr = ctx->err;\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 55.66356930610075}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tstruct ads1112_data *data = dev->data;\n\tint err;\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->sequence = sequence;\n\n\terr = ads1112_start_read(dev);\n\n\tif (wait) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 52.01447915477675}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tstruct ads1112_data *data = dev->data;\n\tint err;\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->seq_size = sequence->buffer_size;\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"unsupported resolution %d\", sequence->resolution);\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"unsupported channels 0x%x\", sequence->channels);\n\t\treturn -ENOTSUP;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\terr = ads1112_start_read(dev);\n\n\tif (wait) {\n\t\terr = ads1112_wait_read(dev, sequence->timeout);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 55.35884170002334}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tint ret;\n\tconst struct device *dev;\n\tstruct audio_codec_cfg cfg;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Apply the audio codec properties */\n\tcfg.options = AUDIO_CODEC_DAI_FORMAT_I2S;\n\tcfg.i2s.word_size = 16U;\n\tcfg.i2s.channels = 2U;\n\tcfg.i2s.sample_frequency = 48000U;\n\tcfg.i2s.pcm_mode = false;\n\n\tret = audio_codec_configure(dev, &cfg);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to configure audio codec %d\", ret);\n\t\treturn ret;\n\t}\n\n\tshell_print(sh, \"Audio codec configured successfully\");\n\treturn 0;\n}", "CodeBleu_score": 56.145747937624776}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tstruct device *dev;\n\tint ret;\n\tuint32_t prop_val;\n\tuint32_t prop_id;\n\tuint32_t prop_val_len;\n\tuint32_t prop_id_len;\n\tuint32_t dev_id;\n\tuint32_t dev_id_len;\n\tuint32_t prop_val_offset;\n\tuint32_t prop_id_offset;\n\tuint32_t dev_id_offset;\n\n\tdev_id_offset = 0;\n\tprop_id_offset = 0;\n\tprop_val_offset = 0;\n\n\tdev_id_len = strlen(argv[1]);\n\tprop_id_len = strlen(argv[2]);\n\tprop_val_len = strlen(argv[3]);\n\n\tdev_id = (uint32_t) strtoul(argv[1], NULL, 16);\n\tprop_id = (uint32_t) strtoul(argv[2], NULL, 16);\n\tprop_val = (uint32_t) strtoul(argv[3], NULL, 16);\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = audio_codec_property_set(dev, dev_id, dev_id_len, prop_id, prop_id_len, prop_val, prop_val_len);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply property\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.40375581289959}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tstruct device *dev;\n\tstruct audio_codec_cfg cfg;\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tcfg.dai_type = AUDIO_DAI_TYPE_I2S;\n\tcfg.dai_cfg.i2s.word_size = 16;\n\tcfg.dai_cfg.i2s.channels = 2;\n\tcfg.dai_cfg.i2s.format = AUDIO_I2S_FMT_DATA_FORMAT_I2S;\n\tcfg.dai_cfg.i2s.options = AUDIO_I2S_OPT_FRAME_CLK_SLAVE | AUDIO_I2S_OPT_BIT_CLK_SLAVE;\n\tcfg.dai_cfg.i2s.frame_clk_freq = 48000;\n\tcfg.dai_cfg.i2s.block_size = 1024;\n\n\treturn audio_codec_configure(dev, &cfg);\n}", "CodeBleu_score": 54.013952050525745}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_data *drv_data = dev->data;\n\tint ret = 0;\n\tuint8_t i2s_cmd = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (drv_data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\ti2s_cmd = I2S_CMD_START;\n\t\t\tdrv_data->state = MPXXDTYY_STATE_ACTIVE;\n\t\t} else {\n\t\t\tLOG_ERR(\"Device must be in configured state to start\");\n\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (drv_data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\ti2s_cmd = I2S_CMD_STOP;\n\t\t\tdrv_data->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"Device must be in active state to stop\");\n\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported trigger command\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret == 0) {\n\t\tret = i2s_trigger(drv_data->i2s_dev, i2s_cmd, NULL);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"Failed to trigger I2S device\");\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 57.20760967500521}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_send_command(dev, MPXXDTYY_CMD_START);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"Failed to start device\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t}\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_send_command(dev, MPXXDTYY_CMD_STOP);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"Failed to stop device\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"Unsupported trigger command\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.759850653253835}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_dev_data *const dev_data = DEV_DATA(dev);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (dev_data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_send_command(dev, MPXXDTYY_CMD_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdev_data->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (dev_data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_send_command(dev, MPXXDTYY_CMD_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdev_data->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUP;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 51.09708085073797}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_DISPLAY_MODE_CMD;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK_ON;\n\t}\n\n\tif (config->position_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_POSITION_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 68.61583304679957}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_DISPLAY_MODE_CMD;\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_ON) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_ON;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_CURSOR_MODE_ON) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_MODE_ON;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_CURSOR_MODE_BLINK) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_MODE_BLINK;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_BLINK) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_BLINK;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_ENABLED;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 62.03510378993508}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t display_mode_cmd = AUXDISPLAY_HD44780_DISPLAY_MODE_CMD;\n\n\tif (enabled) {\n\t\tdisplay_mode_cmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_on) {\n\t\tdisplay_mode_cmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (config->cursor_blink_on) {\n\t\tdisplay_mode_cmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, display_mode_cmd, config->mode);\n}", "CodeBleu_score": 64.86611351243083}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tstruct auxdisplay_itron_config *config = (struct auxdisplay_itron_config *)dev->config;\n\tER ercd;\n\tID portid;\n\tbool_t busy;\n\n\tif (config->busy_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tercd = port_open(config->busy_port, &portid);\n\tif (ercd != E_OK) {\n\t\treturn ercd;\n\t}\n\n\tercd = port_read(portid, &busy);\n\tif (ercd != E_OK) {\n\t\treturn ercd;\n\t}\n\n\tercd = port_close(portid);\n\tif (ercd != E_OK) {\n\t\treturn ercd;\n\t}\n\n\treturn busy;\n}", "CodeBleu_score": 55.01797113084541}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint rc;\n\tgpio_flags_t flags;\n\tuint32_t value;\n\n\tif (config->busy_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tflags = GPIO_INPUT;\n\trc = gpio_pin_configure(config->busy_port, config->busy_pin, flags);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\trc = gpio_pin_get(config->busy_port, config->busy_pin, &value);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\treturn value;\n}", "CodeBleu_score": 67.74633179532952}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tstruct auxdisplay_itron_config *config = dev->config;\n\tif (config->busy_gpio_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 66.85863291829605}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint err;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\terr = i2c_write(config->i2c, buffer, sizeof(buffer),\n\t\t\tconfig->i2c_address);\n\tif (err) {\n\t\tLOG_ERR(\"Failed to send special command %d to LCD (err %d)\",\n\t\t\tcommand, err);\n\t\treturn err;\n\t}\n\n\tk_busy_wait(config->special_command_delay);\n\n\treturn err;\n}", "CodeBleu_score": 60.608258632514215}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\tint err;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\terr = i2c_write(data->i2c, buffer, sizeof(buffer),\n\t\t\tdata->i2c_address);\n\n\tk_sleep(data->special_command_delay);\n\n\treturn err;\n}", "CodeBleu_score": 54.42813482785389}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tstruct auxdisplay_serlcd_data *data = dev->driver_data;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tret = i2c_write(data->i2c, buffer, sizeof(buffer), data->i2c_address);\n\n\tk_busy_wait(data->special_command_delay);\n\n\treturn ret;\n}", "CodeBleu_score": 54.00605678188612}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *dev_data = dev->data;\n\tint ret;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\treturn -EFAULT;\n\t}\n\n\tret = memcpy_s(data, size, dev_data->memory + offset, size);\n\tif (ret != 0) {\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 63.27689999131702}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *bbram_data = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tif (offset + size > bbram_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, bbram_data->memory + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 67.31436328277893}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *bbram_data = dev->data;\n\tuint8_t *bbram_mem = bbram_data->bbram_mem;\n\tuint8_t *bbram_invalid_mem = bbram_data->bbram_invalid_mem;\n\tsize_t bbram_size = bbram_data->bbram_size;\n\tsize_t bbram_invalid_size = bbram_data->bbram_invalid_size;\n\tint ret;\n\n\t/* Check if the requested read size is valid */\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested read exceeds the memory bounds */\n\tif ((offset + size) > bbram_size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested read involves invalid memory */\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EACCES;\n\t}\n\n\t/* Copy the data from the specified offset in the device's memory to the provided buffer */\n\tmemcpy(data, &bbram_mem[offset], size);\n\n\t/* Return success */\n\treturn 0;\n}", "CodeBleu_score": 46.08920935631535}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data_dev = dev->data;\n\n\tif (size > BBRAM_DATA_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > BBRAM_DATA_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data_dev->data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.42695344185546}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *dev_data = dev->data;\n\tconst struct bbram_emul_cfg *dev_cfg = dev->config;\n\n\tif (size != 0 && size != 1 && size != 2 && size != 4) {\n\t\tLOG_ERR(\"Invalid write size: %d\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > dev_cfg->size) {\n\t\tLOG_ERR(\"Write out of bounds: offset %d, size %d, BBRAM size %d\",\n\t\t\toffset, size, dev_cfg->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(dev_data->data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.33016419707941}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data_dev = dev->data;\n\n\tif (size > CONFIG_BIG_ENDIAN_EMUL_BBRAM_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > CONFIG_BIG_ENDIAN_EMUL_BBRAM_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_dev->bbram_data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 64.7855176853689}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device name required\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 81.40420926456818}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"BBRAM device not specified\");\n\t\treturn -EINVAL;\n\t}\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"BBRAM device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 82.58229989441045}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"BBRAM device not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"BBRAM device \\\"%s\\\" not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 82.18970393714497}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tstruct bt_hci_h4_dev_data_t * const dev_data = DEV_DATA(dev);\n    u8_t type;\n    u8_t hdr[4];\n    u8_t read;\n    u8_t to_read;\n    u8_t min_len;\n\n    if (dev_data->rx_len) {\n        return;\n    }\n\n    /* Get packet type */\n    if (bt_uart_fifo_read(dev, &type, 1) != 1) {\n        return;\n    }\n\n    /* Check for invalid packet type */\n    if (type > BT_H4_EVT) {\n        BT_WARN(\"Invalid H:4 type %u\", type);\n        return;\n    }\n\n    /* Check for escape sequence */\n    if (type == BT_H4_ESC) {\n        /* Get escape type */\n        if (bt_uart_fifo_read(dev, &type, 1) != 1) {\n            return;\n        }\n\n        /* Check for invalid escape type */\n        if (type > BT_H4_ESC_PKT_MASK) {\n            BT_WARN(\"Invalid H:4 escape type %u\", type);\n            return;\n        }\n    }\n\n    dev_data->rx_type = type;\n\n    /* Get expected length */\n    switch (type) {\n        case BT_H4_CMD:\n            min_len = BT_H4_CMD_HDR_SIZE;\n            break;\n        case BT_H4_ACL:\n            min_len = BT_H4_ACL_HDR_SIZE;\n            break;\n        case BT_H4_SCO:\n            min_len = BT_H4_SCO_HDR_SIZE;\n            break;\n        case BT_H4_EVT:\n        default:\n            min_len = BT_H4_EVT_HDR_SIZE;\n            break;\n    }\n\n    /* Read header */\n    read = bt_uart", "CodeBleu_score": 35.820551401211716}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tstruct h4_dev_data_t *h4 = DEV_DATA(dev);\n    int err;\n    uint8_t *buf = h4->rx_buf;\n    uint32_t read = h4->rx_len;\n    uint32_t remaining = h4->rx_size - h4->rx_len;\n\n    if (remaining > 0) {\n        err = uart_fifo_read(h4->uart, buf + read, remaining);\n        if (err < 0) {\n            BT_ERR(\"Failed to read UART (err %d)\", err);\n            h4->rx_len = 0;\n            h4->rx_size = 0;\n            h4->rx_state = STATE_UART_IDLE;\n            return;\n        }\n\n        read += err;\n\n        if (read < h4->rx_size) {\n            return;\n        }\n\n        h4->rx_len = 0;\n        h4->rx_size = 0;\n    }\n\n    if (read < H4_HDR_SIZE) {\n        BT_ERR(\"Too short H:4 packet\");\n        h4->rx_state = STATE_UART_IDLE;\n        return;\n    }\n\n    h4->rx_state = STATE_UART_ACL;\n    h4->rx_len = 4;\n    h4->rx_size = ALIGN_4(sys_get_le16(&buf[1]));\n\n    if (h4->rx_size < H4_ACL_HDR_SIZE) {\n        BT_ERR(\"Too short ACL packet\");\n        h4->rx_state = STATE_UART_IDLE;\n        return;\n    }\n\n    h4->rx_size -= H4_ACL_HDR_SIZE;\n\n    if (h4->rx_size > *h4->rx_mtu) {\n        BT_ERR(\"ACL packet length is bigger than local MTU\");\n        h4->rx_state = STATE_UART_IDLE;", "CodeBleu_score": 42.65065199004779}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tstruct h4_dev_data_t *h4 = DEV_DATA(dev);\n\tuint8_t *buf = h4->rx_buf;\n\tuint8_t type = h4->rx_frag->type;\n\tint32_t hdr_len = h4->rx_frag->len;\n\tint32_t bytes_read = h4->rx_len;\n\tint32_t remaining = hdr_len - bytes_read;\n\tint32_t read;\n\n\tif (type == H4_ACL) {\n\t\tstruct bt_hci_acl_hdr *acl = (void *)buf;\n\n\t\tif (bytes_read < sizeof(*acl)) {\n\t\t\tread = uart_fifo_read(h4->uart, buf + bytes_read,\n\t\t\t\t\t      remaining);\n\t\t\tbytes_read += read;\n\t\t\tremaining -= read;\n\t\t}\n\n\t\tif (bytes_read == sizeof(*acl)) {\n\t\t\tremaining = acl->len + sizeof(*acl);\n\t\t\tBT_DBG(\"Got ACL header. Payload %u bytes\", acl->len);\n\t\t}\n\t} else if (type == H4_EVT) {\n\t\tstruct bt_hci_evt_hdr *evt = (void *)buf;\n\n\t\tif (bytes_read < sizeof(*evt)) {\n\t\t\tread = uart_fifo_read(h4->uart, buf + bytes_read,\n\t\t\t\t\t      remaining);\n\t\t\tbytes_read += read;\n\t\t\tremaining -= read;\n\t\t}\n\n\t\tif (bytes_read == sizeof(*evt)) {\n\t\t\tremaining = evt->len + sizeof(*evt);\n\t\t\tBT_DBG(\"Got event header. Payload %u bytes\", evt->len);\n\t\t}\n\t} else {\n\t\tBT_ERR(\"Unknown H:4 type %u\", type);\n\t\treturn;\n\t}\n\n\tif (remaining", "CodeBleu_score": 42.042557861340725}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n    size_t total_read = 0;\n    int err;\n\n    while (len) {\n        size_t read = MIN(len, sizeof(buf));\n        size_t read_len = 0;\n\n        err = uart_fifo_read(uart, buf, read, &read_len);\n        if (err) {\n            LOG_ERR(\"Failed to discard FIFO contents (err %d)\", err);\n            return 0;\n        }\n\n        total_read += read_len;\n        len -= read_len;\n    }\n\n    return total_read;\n}", "CodeBleu_score": 50.49497802413614}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n    size_t read;\n    int err;\n\n    while (len) {\n        read = MIN(len, sizeof(buf));\n        err = uart_fifo_read(uart, buf, read);\n        if (err) {\n            LOG_ERR(\"Failed to discard FIFO contents (%d)\", err);\n            return 0;\n        }\n        len -= read;\n    }\n    return read;\n}", "CodeBleu_score": 50.90778300621178}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n\tsize_t rx = 0;\n\twhile (len) {\n\t\tsize_t l = MIN(len, sizeof(buf));\n\t\tint err = uart_fifo_read(uart, buf, l);\n\t\tif (err) {\n\t\t\tLOG_ERR(\"uart_fifo_read failed (err %d)\", err);\n\t\t\treturn rx;\n\t\t}\n\t\tlen -= l;\n\t\trx += l;\n\t}\n\treturn rx;\n}", "CodeBleu_score": 49.82706984806627}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tunsigned int i;\n    unsigned int hop = 0;\n    unsigned int prio;\n    struct zbus_observer *obs;\n\n    for (i = 0; i < chan->obs_count; i++) {\n        obs = chan->obs[i];\n        prio = obs->priority;\n\n        if (obs->enabled && prio < hop) {\n            hop = prio;\n        }\n    }\n\n    chan->highest_observer_priority = hop;\n}", "CodeBleu_score": 25.7633644716648}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tuint32_t hop = 0;\n\tstruct zbus_observer *obs;\n\n\tlist_for_each_entry(obs, &chan->observers, list) {\n\t\tif (obs->priority < hop && obs->enabled)\n\t\t\thop = obs->priority;\n\t}\n\n\tchan->highest_observer_priority = hop;\n}", "CodeBleu_score": 12.180788521879888}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tint hop = INT_MAX;\n\n    pthread_mutex_lock(&chan->lock);\n\n    for (int i = 0; i < MAX_OBSERVERS; i++) {\n        if (chan->observers[i].enabled && chan->observers[i].priority < hop) {\n            hop = chan->observers[i].priority;\n        }\n    }\n\n    chan->highest_observer_priority = hop;\n\n    pthread_mutex_unlock(&chan->lock);\n}", "CodeBleu_score": 24.4881097896032}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tconst int limit = _zbus_channel_observation_end_idx;\n\n\tfor (int16_t i = _zbus_channel_observation_start_idx; i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\tif (observation->obs == obs && !observation_mask->enabled) {\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 21.040504757199212}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_channel_observations_end_idx;\n\n\t\tfor (int16_t i = 0; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_observer *obs_i = observation->obs;\n\n\t\t\tif (obs_i == obs && !observation_mask->enabled) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 20.532676667499114}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tfor (int16_t i = 0; i < CONFIG_ZBUS_CHANNEL_OBSERVATION_MASK_CNT; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\tif (observation_mask->enabled &&\n\t\t\t\tobservation->obs == obs) {\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 21.700443944178595}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tassert(!is_in_isr());\n\tassert(obs != NULL);\n\n\tspinlock_lock(&obs->lock);\n\n\tobs->priority = PRIORITY_MIN;\n\n\tupdate_all_channels_hop(obs);\n\n\tspinlock_unlock(&obs->lock);\n\n\treturn 0;\n}", "CodeBleu_score": 47.8047281555545}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tassert(obs != NULL);\n\tassert(obs->priority != ZBUS_MIN_PRIORITY);\n\n\tspinlock_lock(&obs->lock);\n\tobs->priority = ZBUS_MIN_PRIORITY;\n\tupdate_all_channels_hop(obs);\n\tspinlock_unlock(&obs->lock);\n\n\treturn 0;\n}", "CodeBleu_score": 46.681477974479}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tassert(!is_in_isr());\n\tassert(obs);\n\n\tspinlock_lock(&obs->lock);\n\n\tobs->priority = PRIORITY_MIN;\n\n\tupdate_all_channels_hop(obs);\n\n\tspinlock_unlock(&obs->lock);\n\n\treturn 0;\n}", "CodeBleu_score": 45.384109251017264}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"channel must not be NULL\");\n\n\ttimeout = k_timeout_adjust(timeout);\n\n\tk_timepoint_t end_time = sys_timepoint_get();\n\n\tif (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\tend_time = sys_timepoint_add(end_time, sys_timepoint_ticks_from_ms(timeout.ticks));\n\t}\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 48.5170897973915}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_timepoint_timeout(timeout);\n\n\tint prio = ZBUS_MIN_THREAD_PRIORITY;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 64.10107938522222}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"chan must be not NULL\");\n\n\ttimeout = _zbus_adjust_timeout(timeout);\n\n\tk_timepoint_t end_time = sys_timepoint_get_no_checks();\n\n\tend_time = sys_timepoint_add(end_time, timeout);\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 52.85877492060575}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tif (Int & ETH_IT_NORMAL) {\n\t\tif (enable) {\n\t\t\tETH->DMA_INT_EN |= ETH_DMA_INT_EN_NIE;\n\t\t} else {\n\t\t\tETH->DMA_INT_EN &= ~ETH_DMA_INT_EN_NIE;\n\t\t}\n\t}\n\tif (Int & ETH_IT_ABNORMAL) {\n\t\tif (enable) {\n\t\t\tETH->DMA_INT_EN |= ETH_DMA_INT_EN_AIE;\n\t\t} else {\n\t\t\tETH->DMA_INT_EN &= ~ETH_DMA_INT_EN_AIE;\n\t\t}\n\t}\n}", "CodeBleu_score": 34.82653780596541}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tuint32_t bitpos = 0, enablestatus = 0;\n  uint32_t interruptmask = 0;\n\n  /* Check the parameters */\n  assert_param(IS_ETH_IT(Int));\n\n  /* Get the interrupt bit position */\n  bitpos = (Int & 0x1F);\n\n  /* Get the interrupt enable status */\n  enablestatus = (Int >> 31);\n\n  /* Check if the interrupt is normal or abnormal */\n  if (bitpos < 16) {\n    /* Normal interrupt */\n    interruptmask = (Int & ETH_DMAINTEN_NIS);\n  } else {\n    /* Abnormal interrupt */\n    interruptmask = (Int & ETH_DMAINTEN_AIS);\n  }\n\n  /* Check if the interrupt is enabled or disabled */\n  if (((enablestatus == 0x1) && (enable == TRUE)) || ((enablestatus == 0x0) && (enable == FALSE))) {\n    /* The interrupt is already enabled or disabled */\n    return;\n  }\n\n  /* Disable the interrupt */\n  if (enablestatus == 0x1) {\n    /* Disable the interrupt */\n    if (bitpos < 16) {\n      /* Disable the normal interrupt */\n      ETH->DMAINTEN &= ~(interruptmask);\n    } else {\n      /* Disable the abnormal interrupt */\n      ETH->DMAINTEN &= ~(interruptmask);\n    }\n  } else {\n    /* Enable the interrupt */\n    if (bitpos < 16) {\n      /* Enable the normal interrupt */\n      ETH->DMAINTEN |= interruptmask;\n    } else {\n      /* Enable the abnormal interrupt */\n      ETH->DMAINTEN |= interruptmask;\n    }\n  }\n}", "CodeBleu_score": 42.30548918613356}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tif (Int & ETH_IT_NORMAL_MASK) {\n\t\tif (enable) {\n\t\t\tETH->IER |= (Int & ETH_IT_NORMAL_MASK);\n\t\t} else {\n\t\t\tETH->IER &= ~(Int & ETH_IT_NORMAL_MASK);\n\t\t}\n\t}\n\n\tif (Int & ETH_IT_ABNORMAL_MASK) {\n\t\tif (enable) {\n\t\t\tETH->IER |= (Int & ETH_IT_ABNORMAL_MASK);\n\t\t} else {\n\t\t\tETH->IER &= ~(Int & ETH_IT_ABNORMAL_MASK);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.12165246699402}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc = 0;\n\n\t/* Check if the current descriptor is owned by the device */\n\tif (ETH->DMATXDESCR->DMATXDESCR_OWN != 0) {\n\n\t\t/* Get the current transmit descriptor address */\n\t\tpTxDesc = (ETH_TX_DESC *) ETH->DMATXDESCR->DMATXDESCR_NEXTDESCADD;\n\n\t\t/* Check if the next descriptor is owned by the device */\n\t\tif (pTxDesc->DMATXDESCR_OWN != 0) {\n\n\t\t\t/* Get the next transmit descriptor address */\n\t\t\tpTxDesc = (ETH_TX_DESC *) pTxDesc->DMATXDESCR_NEXTDESCADD;\n\n\t\t\t/* Check if the next descriptor is owned by the device */\n\t\t\tif (pTxDesc->DMATXDESCR_OWN != 0) {\n\n\t\t\t\t/* Get the next transmit descriptor address */\n\t\t\t\tpTxDesc = (ETH_TX_DESC *) pTxDesc->DMATXDESCR_NEXTDESCADD;\n\n\t\t\t\t/* Check if the next descriptor is owned by the device */\n\t\t\t\tif (pTxDesc->DMATXDESCR_OWN != 0) {\n\n\t\t\t\t\t/* Get the next transmit descriptor address */\n\t\t\t\t\tpTxDesc = (ETH_TX_DESC *) pTxDesc->DMATXDESCR_NEXTDESCADD;\n\n\t\t\t\t\t/* Check if the next descriptor is owned by the device */\n\t\t\t\t\tif (pTxDesc->DMATXDESCR_OWN != 0) {\n\n\t\t\t\t\t\t/* Get the next transmit descriptor address */\n\t\t\t\t\t\tpTxDesc = (ETH_TX_DESC *) pTxDesc->DMATXDESCR_NEXTDESCADD;\n\n\t\t\t\t\t\t/*", "CodeBleu_score": 41.90370155112964}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc;\n    uint32_t i;\n\n    /* Get the current Tx descriptor address */\n    pTxDesc = ETH->DMATXDESCR;\n\n    /* Check if the descriptor is owned by the device */\n    for (i = 0; i < ETH_TX_DESC_CNT; i++) {\n        if (!(pTxDesc->status & ETH_DMATXDESC_OWN)) {\n            /* Return the descriptor */\n            return pTxDesc;\n        }\n\n        /* Move to the next descriptor */\n        pTxDesc = (ETH_TX_DESC *) (pTxDesc->buf2_next_desc_addr);\n    }\n\n    /* Return 0 if no free descriptor is found */\n    return 0;\n}", "CodeBleu_score": 50.41606387254431}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *tx_desc;\n    uint32_t i;\n\n    /* Get the current descriptor address */\n    tx_desc = (ETH_TX_DESC *)(ETH->DMATXDESCR);\n\n    /* Check if the descriptor is owned by the device */\n    for (i = 0; i < NUM_TX_DESC; i++) {\n        if (tx_desc->status & ETH_TX_DESC_OWN) {\n            /* Increment the descriptor address */\n            tx_desc = (ETH_TX_DESC *)(tx_desc->next_desc);\n        } else {\n            /* Return the descriptor address */\n            return tx_desc;\n        }\n    }\n\n    /* Return 0 if no free descriptor is found */\n    return 0;\n}", "CodeBleu_score": 51.53944706881062}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tstruct rt_cyp_adc_device *cyp_adc_device = (struct rt_cyp_adc_device *)device;\n    rt_uint32_t cyp_adc_channel = cyp_adc_get_channel(channel);\n    rt_uint32_t cyp_adc_value = *value;\n\n    RT_ASSERT(device != RT_NULL);\n\n    if (cyp_adc_channel == CY_CSDIDAC_A) {\n        if (cyp_adc_value > CY_CSDIDAC_MAX_VALUE) {\n            cyp_adc_value = CY_CSDIDAC_MAX_VALUE;\n        }\n    } else if (cyp_adc_channel == CY_CSDIDAC_B) {\n        if (cyp_adc_value > CY_CSDIDAC_MAX_VALUE) {\n            cyp_adc_value = CY_CSDIDAC_MAX_VALUE;\n        }\n    }\n\n    Cy_CSDIDAC_SetValue(cyp_adc_device->cyp_adc_base, cyp_adc_channel, cyp_adc_value);\n\n    return RT_EOK;\n}", "CodeBleu_score": 48.581122601123404}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tRT_ASSERT(device != RT_NULL);\n\n    rt_uint32_t cyp_adc_channel = cyp_adc_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_adc_channel, *value) != CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"cyp_adc_convert failed!\");\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 56.89075955384848}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tstruct cyp_dac_dev *dac = (struct cyp_dac_dev *)device;\n    rt_uint32_t cyp_dac_channel = 0;\n    cy_rslt_t result = CY_RSLT_SUCCESS;\n\n    RT_ASSERT(dac != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    result = Cy_CSDIDAC_OutputEnable(dac->base, cyp_dac_channel, *value);\n\n    if (CY_RSLT_SUCCESS != result) {\n        LOG_E(\"DAC convert failed with error code %d\", result);\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 62.18027410473398}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tif (addr + size > FLASH_SIZE) {\n\t\tLOG_E(\"Reading out of flash memory bounds\");\n\t\treturn -EINVAL;\n\t}\n\tfor (int i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *) (FLASH_BASE_ADDR + addr + i);\n\t}\n\treturn size;\n}", "CodeBleu_score": 38.37223284807233}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t i;\n\tif (addr + size > FLASH_END_ADDR) {\n\t\tLOG_E(\"read out of flash size!\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *) (addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 49.11839030952233}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tif (addr + size > FLASH_SIZE) {\n\t\tLOG_E(\"Error: Flash read exceeds flash memory size!\n\");\n\t\treturn IFX_I2C_STACK_ERROR_INVALID_ARG;\n\t}\n\tfor (int i = 0; i < size; i++) {\n\t\tbuf[i] = flash_mem[addr + i];\n\t}\n\treturn size;\n}", "CodeBleu_score": 36.1994725035754}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tCY_ASSERT(timer != NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 26.81274834725128}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 32.0215024610336}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 32.0215024610336}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\tint result;\n\n    while ((result = pthread_mutex_lock(&(dfs->lock))) == EBUSY) {\n        continue;\n    }\n\n    if (result != 0) {\n        assert(0);\n    }\n}", "CodeBleu_score": 36.118154309891025}, {"code": "void dfs_lock(void){\n\twhile (1) {\n\t\tif (mutex_trylock(&dfs_mutex) == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 10.631904540704356}, {"code": "void dfs_lock(void){\n\tint err;\n\n\twhile (true) {\n\t\terr = pthread_mutex_lock(&dfs_mutex);\n\t\tif (err == 0) {\n\t\t\treturn;\n\t\t}\n\t\tassert(err == EBUSY);\n\t\tnanosleep((const struct timespec[]){{0, 100000000L}}, NULL);\n\t}\n}", "CodeBleu_score": 26.257919501558224}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (!fdt->fds[fd])\n        {\n            return fd_slot_expand(fdt, fd);\n        }\n    }\n\n    return -1;\n}", "CodeBleu_score": 30.57701400858841}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint index;\n    int fd;\n\n    if (startfd < 0)\n    {\n        startfd = 0;\n    }\n\n    for (index = startfd; index < fdt->maxfd; index++)\n    {\n        if (!fdt->fds[index])\n        {\n            fd = fd_slot_expand(fdt, index);\n            if (fd < 0)\n            {\n                return -1;\n            }\n            fdt->fds[index] = (struct dfs_file *)0x1;\n            return index;\n        }\n    }\n\n    return -1;\n}", "CodeBleu_score": 44.991614175847786}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            break;\n        }\n    }\n    if (fd == fdt->maxfd)\n    {\n        fd = fd_slot_expand(fdt, fd);\n    }\n\n    return fd;\n}", "CodeBleu_score": 37.33634744835788}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\tstatic const char *err_str[] = {\n        \"EOK\",\n        \"EFAIL\",\n        \"EINVAL\",\n        \"ENOMEM\",\n        \"ENODEV\",\n        \"EBUSY\",\n        \"EIO\",\n        \"EINTR\",\n        \"ETIMEOUT\",\n        \"ENOTHREAD\",\n        \"ENOSYS\",\n        \"EUNKNOW\"\n    };\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    if (error >= sizeof(err_str) / sizeof(err_str[0])) {\n        return \"EUNKNOW\";\n    }\n\n    return err_str[error];\n}", "CodeBleu_score": 33.81481785610898}, {"code": "const char *rt_strerror(rt_err_t error){\n\tstatic const char *rt_errstr[] = {\n        \"EOK\",\n        \"EPERM\",\n        \"ENOENT\",\n        \"EIO\",\n        \"ENXIO\",\n        \"EINTR\",\n        \"EINVAL\",\n        \"ENOEXEC\",\n        \"EBADF\",\n        \"ECHILD\",\n        \"EAGAIN\",\n        \"ENOMEM\",\n        \"EACCES\",\n        \"EFAULT\",\n        \"EBUSY\",\n        \"EEXIST\",\n        \"EXDEV\",\n        \"ENODEV\",\n        \"ENOTDIR\",\n        \"EISDIR\",\n        \"EINVAL\",\n        \"ENFILE\",\n        \"EMFILE\",\n        \"ENOTTY\",\n        \"EFBIG\",\n        \"ENOSPC\",\n        \"ESPIPE\",\n        \"EROFS\",\n        \"EMLINK\",\n        \"EPIPE\",\n        \"EDOM\",\n        \"ERANGE\",\n        \"EDEADLK\",\n        \"ENAMETOOLONG\",\n        \"ENOLCK\",\n        \"ENOSYS\",\n        \"ENOTEMPTY\",\n        \"ELOOP\",\n        \"EWOULDBLOCK\",\n        \"ENOMSG\",\n        \"EIDRM\",\n        \"ECHRNG\",\n        \"EL2NSYNC\",\n        \"EL3HLT\",\n        \"EL3RST\",\n        \"ELNRNG\",\n        \"EUNATCH\",\n        \"ENOCSI\",\n        \"EL2HLT\",\n        \"EBADE\",\n        \"EBADR\",\n        \"EXFULL\",\n        \"ENOANO\",\n        \"EBADRQC\",\n        \"EBADSLT\",\n        \"EBFONT\",\n        \"ENOSTR\",\n        \"ENODATA\",\n        \"ETIME\",\n        \"ENOSR\",\n        \"ENONET\",\n        \"ENOPKG\",\n        \"EREMOTE\",\n        \"ENOLINK\",\n        \"EADV\",\n        \"ESRMNT\",\n        \"ECOMM\",\n        \"EPROTO\",", "CodeBleu_score": 5.598907922531332}, {"code": "const char *rt_strerror(rt_err_t error){\n\tif (error < 0) {\n        error = -error;\n    }\n\n    for (int i = 0; i < sizeof(rt_errlist) / sizeof(rt_errlist[0]); i++) {\n        if (rt_errlist[i].err_code == error) {\n            return rt_errlist[i].err_msg;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 64.549994782841}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result;\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* find an empty hook */\n    for (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == RT_NULL) {\n            /* set hook */\n            idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* if no empty hook, return an error */\n    if (i == RT_IDLE_HOOK_LIST_SIZE) {\n        result = -RT_EFULL;\n    }\n\n    /* enable interrupt */\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 66.98033099909277}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result;\n    rt_base_t level;\n    rt_thread_t tid;\n\n    tid = rt_thread_self();\n\n    level = rt_hw_interrupt_disable();\n    if (tid != &rt_thread_idle) {\n        result = -RT_EINVAL;\n    } else {\n        result = rt_thread_idle_register_hook(hook);\n    }\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 20.88932307495624}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result;\n    rt_base_t level;\n    rt_thread_t tid;\n\n    tid = rt_thread_self();\n    if (tid == &rt_thread_idle[0]) {\n        level = rt_hw_interrupt_disable();\n        if (rt_thread_idle_hook_list_size < RT_IDLE_HOOK_LIST_SIZE) {\n            rt_thread_idle_hook_list[rt_thread_idle_hook_list_size] = hook;\n            rt_thread_idle_hook_list_size++;\n            result = RT_EOK;\n        } else {\n            result = -RT_EFULL;\n        }\n        rt_hw_interrupt_enable(level);\n    } else {\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 31.942910945680154}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_err_t result;\n    rt_base_t level;\n    rt_thread_t tid;\n    struct rt_idle_hook *idle_hook;\n\n    level = rt_hw_interrupt_disable();\n    tid = rt_thread_self();\n    idle_hook = tid->idle_hook;\n\n    while (idle_hook != RT_NULL) {\n        if (idle_hook->hook_func == hook) {\n            idle_hook->hook_func = RT_NULL;\n            result = RT_EOK;\n            goto __exit;\n        }\n        idle_hook = idle_hook->next;\n    }\n\n    result = -RT_ERROR;\n\n__exit:\n    rt_hw_interrupt_enable(level);\n    return result;\n}", "CodeBleu_score": 42.50625990893285}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\tint i;\n\trt_err_t result;\n\t\n\trt_enter_critical();\n\t\n\tfor (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == hook) {\n\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\tresult = RT_EOK;\n\t\t\tgoto __exit;\n\t\t}\n\t}\n\t\n\tresult = -RT_ERROR;\n\t\n__exit:\n\trt_exit_critical();\n\t\n\treturn result;\n}", "CodeBleu_score": 60.0917267564651}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_err_t result;\n    rt_base_t level;\n    rt_thread_t thread;\n    rt_list_t *node;\n    struct rt_idle_hook *idle_hook;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* find the idle hook */\n    for (node = (&(rt_thread_idle_obj.list)); node != (&(rt_thread_idle_obj.list)); node = node->next) {\n        idle_hook = rt_list_entry(node, struct rt_idle_hook, list);\n        if (idle_hook->function == hook) {\n            /* remove idle hook */\n            rt_list_remove(node);\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* if hook is not found */\n    if (node == (&(rt_thread_idle_obj.list))) {\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 43.43053396479221}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_thread_t thread;\n\n    /*\n     * Check if the scheduler is locked.\n     */\n    if (rt_scheduler_is_locked()) {\n        return RT_ERROR;\n    }\n\n    /*\n     * Remove each thread from the suspension list and wake it up.\n     */\n    while (!rt_list_isempty(susp_list)) {\n        /*\n         * Remove the first thread from the suspension list.\n         */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, suspend_list);\n        /*\n         * Remove the thread from the suspension list.\n         */\n        rt_list_remove(&thread->suspend_list);\n        /*\n         * Wake up the thread.\n         */\n        rt_thread_resume(thread);\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 38.92213718506273}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_thread_t thread;\n\trt_list_t *node;\n\trt_list_t *next;\n\n\t/*\n\t * The function \"rt_schedule_unlock\" unlocks the scheduler.\n\t */\n\trt_schedule_unlock();\n\n\t/*\n\t * The function \"rt_list_first\" returns the first node of the list.\n\t */\n\tnode = rt_list_first(susp_list);\n\n\t/*\n\t * The function \"rt_list_next\" returns the next node of the list.\n\t */\n\tnext = rt_list_next(susp_list);\n\n\t/*\n\t * The function \"rt_list_next\" returns the next node of the list.\n\t */\n\twhile (node != next) {\n\n\t\t/*\n\t\t * The function \"rt_list_entry\" returns the entry of the list.\n\t\t */\n\t\tthread = rt_list_entry(node, struct rt_thread, tlist);\n\n\t\t/*\n\t\t * The function \"rt_thread_error_set\" sets the error number of a thread.\n\t\t */\n\t\trt_thread_error_set(thread, thread_error);\n\n\t\t/*\n\t\t * The function \"rt_thread_resume\" resumes a thread.\n\t\t */\n\t\trt_thread_resume(thread);\n\n\t\t/*\n\t\t * The function \"rt_list_first\" returns the first node of the list.\n\t\t */\n\t\tnode = rt_list_first(susp_list);\n\n\t\t/*\n\t\t * The function \"rt_list_next\" returns the next node of the list.\n\t\t */\n\t\tnext = rt_list_next(susp_list);\n\t}\n\n\t/*\n\t * The function \"rt_schedule_unlock\" unlocks the scheduler.\n\t */\n\trt_schedule_lock();\n\n\t/*\n\t * The function \"rt_susp_list_resume_all\" resumes all threads in a given suspension list.", "CodeBleu_score": 38.928718472781455}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_thread_t thread;\n    rt_list_t *node;\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    /* resume all suspended threads */\n    while (!rt_list_isempty(susp_list)) {\n        /* get next suspended thread */\n        node = susp_list->next;\n        rt_list_remove(node);\n\n        /* get thread */\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n\n        /* clean thread timer */\n        rt_timer_detach(&(thread->thread_timer));\n\n        /* set error number */\n        thread->error = thread_error;\n\n        /*\n         * insert to ready list\n         * In the function \"rt_thread_ready_priority\", the thread will be inserted into the ready list according to its priority.\n         */\n        rt_thread_ready_priority(thread);\n\n        /* do scheduler */\n        rt_schedule();\n    }\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 30.692580016900862}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t new_device, old_device;\n\n    /* save current device */\n    old_device = rt_console_get_device();\n\n    /* find new console device, and set it up */\n    new_device = rt_device_find(name);\n    if (new_device != old_device) {\n        /* close old fd */\n        if (old_device != RT_NULL) {\n            rt_device_close(old_device);\n        }\n\n        /* set new fd */\n        if (new_device != RT_NULL) {\n            rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        }\n\n        rt_console_set_device(new_device);\n    }\n\n    return old_device;\n}", "CodeBleu_score": 68.04935379391901}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_device;\n\trt_device_t new_device;\n\n\t/* Save the current console device */\n\told_device = rt_console_get_device();\n\n\t/* Find the new console device by its name */\n\tnew_device = rt_device_find(name);\n\tif (new_device == RT_NULL) {\n\t\trt_kprintf(\"WARNING: Can't find the new console device by its name.\n\");\n\t\treturn RT_NULL;\n\t}\n\n\t/* Check if the new console device is the same as the current one */\n\tif (new_device == old_device) {\n\t\trt_kprintf(\"WARNING: The new console device is the same as the current one.\n\");\n\t\treturn old_device;\n\t}\n\n\t/* Close the current console device if it exists */\n\tif (old_device != RT_NULL) {\n\t\trt_device_close(old_device);\n\t}\n\n\t/* Open the new console device with read/write and stream flags */\n\tif (rt_device_open(new_device, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n\t\trt_kprintf(\"WARNING: Can't open the new console device with read/write and stream flags.\n\");\n\t\treturn RT_NULL;\n\t}\n\n\t/* Set the new console device as the current console device */\n\trt_console_set_device(new_device);\n\n\t/* Return the old console device */\n\treturn old_device;\n}", "CodeBleu_score": 61.10495193390357}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_device, new_device;\n\tif (name == RT_NULL)\n\t\treturn RT_NULL;\n\told_device = rt_console_get_device();\n\tnew_device = rt_device_find(name);\n\tif (new_device != old_device) {\n\t\tif (old_device != RT_NULL)\n\t\t\trt_device_close(old_device);\n\t\tif (new_device != RT_NULL\n\t\t\t\t&& rt_device_open(new_device,\n\t\t\t\t\t\tRT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM)\n\t\t\t\t\t\t== RT_EOK) {\n\t\t\trt_console_set_device(new_device);\n\t\t} else {\n\t\t\tnew_device = RT_NULL;\n\t\t}\n\t}\n\treturn old_device;\n}", "CodeBleu_score": 67.71487899362776}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tint i = 0;\n\tstruct rt_object *obj;\n\tstruct rt_list_node *node;\n\trt_base_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\tfor (node = rt_object_container[type].object_list.next; node != &(rt_object_container[type].object_list); node = node->next) {\n\t\tobj = rt_list_entry(node, struct rt_object, list);\n\t\tif (obj->type == type && obj->refcount)\n\t\t\ti++;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn i;\n}", "CodeBleu_score": 32.55503350083153}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tint length = 0;\n\tstruct rt_object *obj;\n\trt_object_list_lock(type);\n\tfor (obj = rt_object_list_first(type); obj != NULL; obj = rt_object_list_next(obj)) {\n\t\tlength++;\n\t}\n\trt_object_list_unlock(type);\n\treturn length;\n}", "CodeBleu_score": 25.503776673412858}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tint length = 0;\n\tstruct rt_object *object;\n\tstruct rt_list_node *node;\n\trt_list_foreach(node, &rt_object_container[type].object_list) {\n\t\tobject = rt_list_entry(node, struct rt_object, list);\n\t\tlength++;\n\t}\n\treturn length;\n}", "CodeBleu_score": 28.524720564012846}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\tstruct rt_object *obj;\n\n    obj = (struct rt_object *)object;\n\n    if (obj == RT_NULL)\n        return;\n\n    rt_object_detach_hook(obj);\n\n    rt_hw_interrupt_disable();\n    rt_list_remove(&(obj->list));\n    rt_hw_interrupt_enable();\n\n    /* unlock the object */\n    rt_spin_unlock(&(obj->spinlock));\n\n    obj->type = 0;\n}", "CodeBleu_score": 32.939222935771085}, {"code": "void rt_object_detach(rt_object_t object){\n\tif (object == 0) {\n    return;\n  }\n  rt_object_detach_hook(object);\n  rt_list_remove(&(object->list));\n  rt_spin_unlock(&(object->spinlock));\n  object->type = 0;\n}", "CodeBleu_score": 20.63169332483402}, {"code": "void rt_object_detach(rt_object_t object){\n\tregister rt_base_t temp;\n\n    /* parameter check */\n    if (object == RT_NULL) return;\n\n    /* lock interrupt */\n    temp = rt_hw_interrupt_disable();\n\n    /* detach object */\n    rt_object_detach_hook(object);\n\n    /* unlock interrupt */\n    rt_hw_interrupt_enable(temp);\n}", "CodeBleu_score": 10.152832958683607}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result = RT_EOK;\n\n    if (obj == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    if (obj->type != RT_Object_Class_Custom) {\n        return -RT_ERROR;\n    }\n\n    if (obj->cleanup != RT_NULL) {\n        result = obj->cleanup(obj);\n    }\n\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 49.40951762910357}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result = RT_EOK;\n    struct rt_custom_object *custom_obj;\n\n    /* check the object */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    custom_obj = (struct rt_custom_object *)obj;\n\n    /* call the destroy function */\n    if (custom_obj->ops->destroy != RT_NULL) {\n        result = custom_obj->ops->destroy(custom_obj);\n    }\n\n    /* delete the object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 51.75857655492182}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t ret = RT_EOK;\n    struct rt_object_information *information;\n\n    information = rt_object_get_information((enum rt_object_class_type)obj->type);\n    RT_ASSERT(information != RT_NULL);\n\n    if (obj->type & RT_Object_Class_Custom) {\n        if (information->ops->destroy != RT_NULL) {\n            ret = information->ops->destroy(obj);\n        }\n    }\n    else {\n        ret = RT_ERROR;\n    }\n\n    if (ret == RT_EOK) {\n        rt_object_delete(obj);\n    }\n\n    return ret;\n}", "CodeBleu_score": 55.03220185032405}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n    rt_base_t lock;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical */\n    lock = rt_hw_interrupt_disable();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    /* switch to next thread */\n    rt_schedule();\n}", "CodeBleu_score": 34.79298839637328}, {"code": "static void _thread_exit(void){\n\trt_base_t lock;\n    rt_thread_t thread;\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* leave critical */\n    rt_exit_critical();\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    /* switch to next task */\n    rt_schedule();\n\n    /* never come here */\n    RT_ASSERT(0);\n}", "CodeBleu_score": 39.561824019821245}, {"code": "static void _thread_exit(void){\n\trt_base_t lock;\n    rt_thread_t thread;\n\n    thread = rt_thread_self();\n    if (thread == RT_NULL) {\n        return;\n    }\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* change stat */\n    rt_sched_thread_exit(thread);\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    /* do scheduling */\n    rt_schedule();\n}", "CodeBleu_score": 62.074514715226584}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\tkthread_t *thread;\n\n\tthread = (kthread_t *)parameter;\n\n\tif (thread == NULL) {\n\t\tkprintf(\"_thread_timeout: thread is NULL\n\");\n\t\treturn;\n\t}\n\n\tif (thread->state != THREAD_STATE_SUSPENDED) {\n\t\tkprintf(\"_thread_timeout: thread is not suspended\n\");\n\t\treturn;\n\t}\n\n\tksched_lock();\n\n\tthread->error = ETIMEDOUT;\n\n\tksched_remove_suspended(thread);\n\tksched_insert_ready(thread);\n\n\tksched_unlock();\n}", "CodeBleu_score": 36.34006071196838}, {"code": "static void _thread_timeout(void *parameter){\n\tkthread_t *thread;\n\n\tthread = (kthread_t *)parameter;\n\n\tif (!thread) {\n\t\treturn;\n\t}\n\n\tif (thread->state != THREAD_STATE_SUSPENDED) {\n\t\treturn;\n\t}\n\n\tthread->error = ETIMEDOUT;\n\n\t_scheduler_lock();\n\n\t_scheduler_remove_suspended(thread);\n\t_scheduler_insert_ready(thread);\n\n\t_scheduler_unlock();\n}", "CodeBleu_score": 33.944361353323686}, {"code": "static void _thread_timeout(void *parameter){\n\tkthread_t *thread = (kthread_t *)parameter;\n\n\tif (thread == NULL) {\n\t\tkpanic();\n\t}\n\n\tif (thread->state != THREAD_SUSPENDED) {\n\t\tkpanic();\n\t}\n\n\tsched_lock();\n\n\tthread->error = ETIMEDOUT;\n\n\tif (thread->flags & THREAD_SUSPEND_LIST) {\n\t\tthread->flags &= ~THREAD_SUSPEND_LIST;\n\t\tlist_remove(&thread->suspend_list, thread->scheduler->suspend_list);\n\t}\n\n\tthread->state = THREAD_READY;\n\tlist_insert(&thread->ready_list, thread->scheduler->ready_list);\n\n\tsched_unlock();\n}", "CodeBleu_score": 37.14515449410695}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n    rt_bool_t state;\n\n    RT_ASSERT(thread != RT_NULL);\n\n    state = rt_hw_interrupt_disable();\n\n    /* get the first mutex */\n    mutex = thread->pending_object;\n    if (mutex != RT_NULL) {\n        /* remove thread from list */\n        rt_list_remove(&(thread->tlist));\n\n        /* clear pending object */\n        thread->pending_object = RT_NULL;\n\n        /* wakeup the next thread */\n        if (!rt_list_isempty(&(mutex->wait_list))) {\n            rt_thread_t thread;\n\n            /* get next thread */\n            thread = rt_list_entry(mutex->wait_list.next, struct rt_thread, tlist);\n\n            /* set new priority */\n            thread->current_priority = thread->init_priority;\n\n            /* insert to ready list */\n            rt_thread_ready(thread);\n\n            /* reschedule */\n            rt_schedule();\n        }\n    }\n\n    /* release all mutexes */\n    while (thread->hold_mutex_list != RT_NULL) {\n        mutex = thread->hold_mutex_list;\n        rt_mutex_release(mutex);\n    }\n\n    rt_hw_interrupt_enable(state);\n}", "CodeBleu_score": 45.58833173133898}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n\n    if (thread->pending_object != NULL) {\n        mutex = (rt_mutex_t)thread->pending_object;\n        rt_spin_lock(&mutex->spinlock);\n        if (mutex->owner == thread) {\n            mutex->owner = NULL;\n        }\n        else {\n            /* Remove thread from mutex's waiting list */\n            rt_list_remove(&thread->tlist);\n        }\n        thread->pending_object = NULL;\n        rt_spin_unlock(&mutex->spinlock);\n    }\n}", "CodeBleu_score": 24.14064476215326}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n    rt_thread_t next;\n    rt_thread_t prev;\n\n    /*\n     * Lock the spinlock.\n     */\n    _thread_spinlock_lock(&thread->spinlock);\n\n    /*\n     * Check if the thread is waiting on a mutex.\n     */\n    if (thread->pending.object.mutex != NULL) {\n\n        /*\n         * Get the mutex.\n         */\n        mutex = thread->pending.object.mutex;\n\n        /*\n         * Lock the mutex's spinlock.\n         */\n        _thread_spinlock_lock(&mutex->spinlock);\n\n        /*\n         * Check if the thread is the first one in the waiting list.\n         */\n        if (mutex->waiting == thread) {\n\n            /*\n             * Set the next thread in the waiting list as the first one.\n             */\n            mutex->waiting = thread->next;\n\n        /*\n         * Check if the thread is in the waiting list.\n         */\n        } else {\n\n            /*\n             * Get the next thread in the waiting list.\n             */\n            next = thread->next;\n\n            /*\n             * Get the previous thread in the waiting list.\n             */\n            prev = thread->prev;\n\n            /*\n             * Remove the thread from the waiting list.\n             */\n            next->prev = prev;\n            prev->next = next;\n        }\n\n        /*\n         * Clear the pending object.\n         */\n        thread->pending.object.mutex = NULL;\n\n        /*\n         * Unlock the mutex's spinlock.\n         */\n        _thread_spinlock_unlock(&mutex->spinlock);\n    }\n\n    /*\n     * Release all mutexes the thread has taken.\n     */\n    while (thread->mutexes != NULL) {\n\n        /*\n         * Get the first mutex.\n         */\n        mutex = thread->mutexes;\n\n        /*\n         * Lock the mutex's spinlock.\n         */\n        _thread_spin", "CodeBleu_score": 43.96788455271066}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    error = rt_sched_thread_ready(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 51.39517308509205}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    error = rt_sched_thread_ready(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 51.39517308509205}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(rt_object_is_systemobject((rt_object_t)thread));\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    /* change stat */\n    thread->stat = RT_THREAD_SUSPEND;\n    /* set thread timer */\n    thread->init_tick = rt_tick_get();\n    /* reset error number */\n    thread->error = RT_EOK;\n\n    /* set priority */\n    rt_sched_set_priority(thread, thread->current_priority);\n\n    /* resume thread */\n    error = rt_sched_thread_ready(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 51.27933900471333}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_tick_t min_timeout_tick = RT_TICK_MAX;\n    rt_tick_t current_tick = rt_tick_get();\n    rt_uint8_t index;\n\n    for (index = 0; index < RT_TIMER_SKIP_LIST_LEVEL; index++) {\n        if (rt_list_isempty(&timer_list[index])) {\n            continue;\n        }\n\n        /* get the first entry */\n        struct rt_timer *timer = rt_list_entry(timer_list[index].next, struct rt_timer, row[index]);\n\n        if (timer->timeout_tick < current_tick) {\n            /* timer has expired */\n            *timeout_tick = 0;\n            return RT_EOK;\n        } else {\n            /* get the timeout tick */\n            if (timer->timeout_tick < min_timeout_tick) {\n                min_timeout_tick = timer->timeout_tick;\n            }\n        }\n    }\n\n    if (min_timeout_tick != RT_TICK_MAX) {\n        *timeout_tick = min_timeout_tick - current_tick;\n        return RT_EOK;\n    }\n\n    return -RT_ETIMEOUT;\n}", "CodeBleu_score": 33.69595700183851}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tstruct rt_timer *timer;\n    rt_list_t *next;\n    rt_list_t *head;\n    rt_tick_t tick;\n    rt_uint8_t index;\n\n    for (index = 0; index < RT_TIMER_SKIP_LIST_LEVEL; index++) {\n        head = &(timer_list[index]);\n\n        /* get next timer */\n        next = head->next;\n        if (next != head) {\n            timer = rt_list_entry(next, struct rt_timer, row[index]);\n            tick = timer->timeout_tick;\n            while (tick < *timeout_tick) {\n                /* get next timer */\n                next = next->next;\n                if (next != head) {\n                    timer = rt_list_entry(next, struct rt_timer, row[index]);\n                    tick = timer->timeout_tick;\n                } else {\n                    *timeout_tick = RT_TICK_MAX;\n                    return -RT_ERROR;\n                }\n            }\n\n            *timeout_tick = tick;\n            return RT_EOK;\n        }\n    }\n\n    *timeout_tick = RT_TICK_MAX;\n    return -RT_ERROR;\n}", "CodeBleu_score": 38.31909339170628}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_tick_t timeout_val;\n    rt_tick_t current_tick;\n    struct rt_timer *timer;\n    rt_uint32_t level;\n    rt_uint32_t mask;\n    rt_list_t *head;\n\n    /* get the next timeout tick */\n    current_tick = rt_tick_get();\n\n    /* start from highest level */\n    level = RT_TIMER_SKIP_LIST_LEVEL;\n    head = timer_list;\n    while (level != 0) {\n        /* check whether the list is empty */\n        if (!rt_list_isempty(head)) {\n            /* get timer entry */\n            timer = rt_list_entry(head->next, struct rt_timer, row[level - 1]);\n            /* get the timeout tick */\n            timeout_val = timer->timeout_tick;\n            /* if the timer is not active, set timeout to the next tick */\n            if (!timer->parent.flag_active) {\n                timeout_val = current_tick;\n            }\n\n            /* convert tick to timeout */\n            *timeout_tick = timeout_val - current_tick;\n\n            /* return */\n            return RT_EOK;\n        }\n\n        /* move to next level */\n        level --;\n        head = head->next;\n    }\n\n    /* no timer exist, set to the next tick */\n    *timeout_tick = 1;\n\n    return RT_ERROR;\n}", "CodeBleu_score": 46.91116107808482}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* allocate object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    /* set flag */\n    timer->parent.flag  = flag;\n\n    /* set deactivated */\n    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;\n\n    timer->timeout_func = timeout;\n    timer->parameter    = parameter;\n\n    timer->timeout_tick = 0;\n    timer->init_tick    = time;\n\n    /* initialize timer list */\n    rt_list_init(&(timer->row[0]));\n\n    return timer;\n}", "CodeBleu_score": 50.28878512616761}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer != RT_NULL)\n    {\n        _timer_init(timer, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}", "CodeBleu_score": 63.237023232360734}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    /* check the timer name */\n    RT_ASSERT(name != RT_NULL);\n\n    /* allocate a timer object */\n    timer = (rt_timer_t) rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 62.31384376460502}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tvar (\n\t\tctx   = req.Context()\n\t\tcode  = http.StatusOK\n\t\tstart = time.Now()\n\t\tpath  = req.URL.Path\n\t\tw     = res.(negroni.ResponseWriter)\n\t\tr     = negroni.NewResponseWriter(w)\n\t)\n\n\tdefer func() {\n\t\tlog := a.log.With(\n\t\t\tzap.Int(\"status\", r.Status()),\n\t\t\tzap.String(\"method\", req.Method),\n\t\t\tzap.String(\"path\", path),\n\t\t\tzap.String(\"ip\", req.RemoteAddr),\n\t\t\tzap.String(\"user-agent\", req.UserAgent()),\n\t\t\tzap.Duration(\"duration\", time.Since(start)),\n\t\t)\n\t\tif len(r.Header().Get(\"X-Request-ID\")) != 0 {\n\t\t\tlog = log.With(zap.String(\"request-id\", r.Header().Get(\"X-Request-ID\")))\n\t\t}\n\t\tlog.Info(\"Served HTTP request\")\n\t}()\n\n\tfor _, handler := range a.middleware {\n\t\thandler.ServeHTTP(r, req, func(err error) {\n\t\t\tcode = http.StatusInternalServerError\n\t\t\thttp.Error(r, err.Error(), code)\n\t\t})\n\t\tif code != http.StatusOK {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif code != http.StatusOK {\n\t\treturn\n\t}\n\n\ta.router.ServeHTTP(r, req)\n}", "CodeBleu_score": 32.10766765842945}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tif a.config.Authenticator != nil {\n\t\tif !a.config.Authenticator.Authenticate(req) {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\tfor _, handler := range a.config.Handlers {\n\t\trecorder := httptest.NewRecorder()\n\t\thandler.ServeHTTP(recorder, req)\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\ta.config.Router.ServeHTTP(res, req)\n}", "CodeBleu_score": 58.834808720334664}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tvar err error\n\tvar status int\n\tvar handler http.Handler\n\tvar recorder *httptest.ResponseRecorder\n\n\t// Create a response recorder\n\trecorder = httptest.NewRecorder()\n\n\t// Sequentially pass the request through the handlers\n\tfor _, handler = range a.handlers {\n\t\thandler.ServeHTTP(recorder, req)\n\t\tif status, err = strconv.Atoi(recorder.Header().Get(\"status\")); err != nil {\n\t\t\tlog.Printf(\"ERROR: %s\n\", err)\n\t\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tif status == http.StatusUnauthorized {\n\t\t\thttp.Error(res, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tfor key, values := range recorder.Header() {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Pass the request to the router for further processing\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 41.81102853409926}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tif path == \"/favicon.ico\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/favicon.ico\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1/robeaux/index.html\" {\n\t\treturn\n\t}\n\tif path == \"/api/v1", "CodeBleu_score": 18.339119551288157}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t// Get the absolute path to prevent directory traversal\n\tpath, err := filepath.Abs(req.URL.Path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Prepend the path with the path to the static directory\n\tpath = filepath.Join(a.staticDir, path)\n\n\t// Check whether a file exists at the given path\n\t_, err = os.Stat(path)\n\tif os.IsNotExist(err) {\n\t\t// Return a 404 status code\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\n\t// If we got this far, we can open the file safely\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\t// Get the file's extension to set the Content-Type header\n\textension := filepath.Ext(path)\n\tcontentType := a.getContentType(extension)\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Write the file's content to the response\n\t_, err = io.Copy(res, file)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}", "CodeBleu_score": 50.78107505687506}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t// Get the path to the asset from the request context.\n\tpath, err := assetPath(req.Context())\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Read the asset from the embedded filesystem.\n\tf, err := fs.Open(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\t// Set the Content-Type header based on the file extension.\n\tswitch ext := filepath.Ext(path); ext {\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript; charset=utf-8\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css; charset=utf-8\")\n\t}\n\n\t// Read the content of the asset into a byte array.\n\tbuf := new(bytes.Buffer)\n\tif _, err := io.Copy(buf, f); err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the asset to the response.\n\tif _, err := res.Write(buf.Bytes()); err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 65.89025492791959}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Find the robot with the specified name\n\trobot := a.master.FindRobot(robotName)\n\n\t// If the robot was found\n\tif robot != nil {\n\t\t// Gather the robot's connections\n\t\tconnections := robot.GetConnections()\n\n\t\t// Convert the connections to JSON format\n\t\tconnectionsJSON, err := json.Marshal(connections)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Write the JSON response\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write(connectionsJSON)\n\t} else {\n\t\t// Write a JSON error message indicating that no robot was found with the specified name\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write([]byte(\"{\\\"error\\\": \\\"No robot found with name \" + robotName + \"\\\"}\"))\n\t}\n}", "CodeBleu_score": 36.831606631116884}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\tvar robotName string\n\tvar robot *Robot\n\tvar err error\n\tvar connections []Connection\n\tvar connectionJSON []byte\n\n\t// Extract the robot name from the request URL\n\trobotName = req.URL.Query().Get(\"robot\")\n\n\t// Find the robot with the specified name\n\trobot, err = a.master.FindRobot(robotName)\n\tif err != nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"No robot found with the specified name\"}`))\n\t\treturn\n\t}\n\n\t// Gather the robot's connections\n\tconnections = robot.GetConnections()\n\n\t// Convert the connections to JSON format\n\tconnectionJSON, err = json.Marshal(connections)\n\tif err != nil {\n\t\t// If the connections cannot be converted to JSON, write a JSON error message\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(`{\"error\": \"Error converting connections to JSON\"}`))\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionJSON)\n}", "CodeBleu_score": 44.010455015863755}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Find the robot with the specified name\n\trobot := a.master.FindRobot(robotName)\n\tif robot == nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"No robot found with the specified name\"}`))\n\t\treturn\n\t}\n\n\t// Gather the robot's connections\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\t// If there is an error in the JSON conversion, write a JSON error message\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(`{\"error\": \"Error converting robot connections to JSON\"}`))\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Header().Set(\"Content-Type\", \"application/json; charset=UTF-8\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 32.014556713720324}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 54.39390717845154}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.251690504797125}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.69381823332551}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.02716425907872}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - (slope * fromMin)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.70828256557575}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.02716425907872}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"The connection to the analog sensor does not support analog reading\")\n\t}\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.scaleRawValue(rawValue)\n\treturn rawValue, a.lastScaledValue, nil\n}", "CodeBleu_score": 56.3642535356007}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Not connected\")\n\t}\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"Connection does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = a.scale(raw)\n\n\treturn raw, a.lastScaledValue, nil\n}", "CodeBleu_score": 55.60036166712228}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.analogPin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.scaleValue(rawValue)\n\n\treturn rawValue, a.lastScaledValue, nil\n}", "CodeBleu_score": 55.96014557045314}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m * fromMin\n\treturn func(x int) float64 {\n\t\treturn math.Max(toMin, math.Min(toMax, m * float64(x) + n))\n\t}\n}", "CodeBleu_score": 44.823024934785245}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(value int) float64 {\n\t\tresult := m*float64(value) + n\n\t\tif result < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif result > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn result\n\t}\n}", "CodeBleu_score": 66.2419433932188}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m * fromMin\n\treturn func(input int) float64 {\n\t\toutput := m * float64(input) + n\n\t\tif output < toMin {\n\t\t\treturn toMin\n\t\t} else if output > toMax {\n\t\t\treturn toMax\n\t\t} else {\n\t\t\treturn output\n\t\t}\n\t}\n}", "CodeBleu_score": 65.64765531511595}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tdriver := &GrovePiezoVibrationSensorDriver{\n\t\tname:     gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tpin:      pin,\n\t\tinterval: 10 * time.Millisecond,\n\t\thalt:     make(chan bool, 0),\n\t\tanalog:   NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\tdriver.AddEvent(Vibration)\n\n\tdriver.analog.AddEvent(Data)\n\tdriver.analog.On(Data, func(data interface{}) {\n\t\tgobot.Publish(driver.Events, Vibration, data)\n\t})\n\n\terr := driver.Start()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn driver\n}", "CodeBleu_score": 50.880139126720756}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tdriver := new(GrovePiezoVibrationSensorDriver)\n\tdriver.Name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\tdriver.Pin = pin\n\tdriver.interval = 10 * time.Millisecond\n\n\tdriver.analogSensorDriver = NewAnalogSensorDriver(a, pin, driver.interval, opts...)\n\n\tdriver.AddEvent(Vibration)\n\n\tdriver.Commands = []string{\n\t\t\"Start\",\n\t\t\"Halt\",\n\t}\n\n\tdriver.Work = func() {\n\t\tdriver.Start()\n\t}\n\n\tdriver.Event(driver.analogSensorDriver.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tdriver.Publish(Vibration, true)\n\t\t}\n\t})\n\n\treturn driver\n}", "CodeBleu_score": 43.077463946121455}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tdriver := new(GrovePiezoVibrationSensorDriver)\n\tdriver.pin = pin\n\tdriver.Name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\tdriver.GrovePiezoVibrationSensor = gpio.NewAnalogSensorDriver(\n\t\ta,\n\t\tpin,\n\t\tdriver.handle,\n\t\topts...,\n\t)\n\tdriver.AddEvent(Vibration)\n\tif err := driver.AddEvent(Vibration); err != nil {\n\t\tpanic(err)\n\t}\n\treturn driver\n}", "CodeBleu_score": 42.14107999380931}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif hz == 0 {\n\t\treturn errors.New(\"invalid tone frequency\")\n\t}\n\tif duration == 0 {\n\t\treturn errors.New(\"invalid tone duration\")\n\t}\n\tif hz < 0 {\n\t\treturn errors.New(\"invalid tone frequency\")\n\t}\n\tif duration < 0 {\n\t\treturn errors.New(\"invalid tone duration\")\n\t}\n\tif d.BPM == 0 {\n\t\treturn errors.New(\"invalid tempo\")\n\t}\n\tif d.BPM < 0 {\n\t\treturn errors.New(\"invalid tempo\")\n\t}\n\tif d.Buzzer == nil {\n\t\treturn errors.New(\"invalid buzzer\")\n\t}\n\n\t// Calculate the tone period\n\tperiod := 1 / hz\n\n\t// Calculate the tempo\n\ttempo := 60 / d.BPM\n\n\t// Calculate the number of times the buzzer should be toggled\n\ttoneCycles := int(duration * tempo)\n\n\t// Calculate the time between each buzzer toggle\n\ttoneDelay := period / 2\n\n\t// Toggle the buzzer on and off for the specified number of times\n\tfor i := 0; i < toneCycles; i++ {\n\t\terr := d.Buzzer.On()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(toneDelay * float64(time.Second)))\n\t\terr = d.Buzzer.Off()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(toneDelay * float64(time.Second)))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 37.63344029855397}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t// Calculate the tone period in milliseconds\n\ttonePeriod := 1000.0 / hz\n\t// Calculate the number of times to toggle the buzzer on and off\n\ttoneCycles := duration * (d.BPM / 60.0) / tonePeriod\n\t// Calculate the time to sleep between toggling the buzzer on and off\n\tsleepTime := tonePeriod / 2.0\n\n\tfor i := 0.0; i < toneCycles; i++ {\n\t\t// Toggle the buzzer on\n\t\terr := d.On()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Sleep for the specified time\n\t\ttime.Sleep(time.Duration(sleepTime) * time.Millisecond)\n\t\t// Toggle the buzzer off\n\t\terr = d.Off()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Sleep for the specified time\n\t\ttime.Sleep(time.Duration(sleepTime) * time.Millisecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 53.9221506075998}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t// TODO: Implement this\n\treturn nil\n}", "CodeBleu_score": 2.6473398808364133}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif !d.sleepPin.IsConnected() {\n\t\treturn errors.New(\"Sleep pin not connected\")\n\t}\n\tif d.sleepPin.Read() == 0 {\n\t\treturn errors.New(\"Sleep pin is already low\")\n\t}\n\td.Stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 32.874311284569636}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif !d.sleepPin.Get() {\n\t\treturn errors.New(\"sleep pin is not set\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 27.314086315461278}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif !d.sleepPin.IsSet() {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 26.815247336609758}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins map is not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, err := a.TranslatePin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := gpio.NewAnalogPin(path)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 50.36807339161364}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, err := a.translatePin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := gpio.NewAnalogPin(path)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 50.53969018030856}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pins not initialized\")\n\t}\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\tpin, err := newAnalogPin(a, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 45.10160863558495}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.pin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 63.084547949348504}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, \"DigitalWrite\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 68.27726135970067}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.digitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 65.7824104214986}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif !a.connected {\n\t\treturn nil, errors.New(\"Not Connected\")\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(&a.digitalPins[id])\n\t}\n\n\tpin, err := a.digitalPins[id].Get()\n\tif err != nil {\n\t\tpin = gpio.NewDirectPin(id)\n\t\ta.digitalPins[id] = gobot.FromDigitalPin(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 33.32510084405443}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.digitalPins) == 0 {\n\t\treturn nil, errors.New(\"Not connected to any pins\")\n\t}\n\n\tif a.digitalPins[id] != nil {\n\t\tfor _, opt := range opts {\n\t\t\topt(a.digitalPins[id])\n\t\t}\n\t\treturn a.digitalPins[id], nil\n\t}\n\n\tchip, line, err := a.translatePin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := gpio.NewPin(chip, line)\n\tif err := pin.Open(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tdPin := gpio.NewDigitalPin(pin)\n\tfor _, opt := range opts {\n\t\topt(dPin)\n\t}\n\ta.digitalPins[id] = dPin\n\treturn a.digitalPins[id], nil\n}", "CodeBleu_score": 48.03836659105893}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif !a.connected {\n\t\treturn nil, errors.New(\"Not connected\")\n\t}\n\n\tif a.pinMap == nil {\n\t\ta.pinMap = make(map[string]*digitalPin)\n\t}\n\n\tpin, ok := a.pinMap[id]\n\tif !ok {\n\t\tchip, line, err := a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = &digitalPin{\n\t\t\tchip: chip,\n\t\t\tline: line,\n\t\t}\n\t\ta.pinMap[id] = pin\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 44.47050078321756}]}
