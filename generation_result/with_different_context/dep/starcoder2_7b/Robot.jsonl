{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\t// Retrieve the list of required files from the server\n\tauto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\t// For each required file\n\tfor (auto &required_file : required_files) {\n\t\t// If the file is not found locally\n\t\tif (!FileTransfer::FileExists(required_file)) {\n\t\t\t// If the download flag is set\n\t\t\tif (download) {\n\t\t\t\t// Log the download action\n\t\t\t\tstd::cout << \"Downloading \" << required_file << std::endl;\n\t\t\t\t// Request the file from the server\n\t\t\t\tRequestFile(required_file);\n\t\t\t}\n\t\t} else {\n\t\t\t// Log that the file is found in the cache\n\t\t\tstd::cout << \"File \" << required_file << \" found in cache\" << std::endl;\n\t\t}\n\t}\n\t// Return the list of required files\n\treturn required_files;\n}", "CodeBleu_score": 61.00152523282342}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t//  std::cout << \"GetRequiredFiles\" << std::endl;\n  // Get the list of required files\n  auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n  // Download the required files if needed\n  if (download) {\n    for (const auto &file : required_files) {\n      if (!FileTransfer::FileExists(file)) {\n        RequestFile(file);\n        std::cout << \"Download \" << file << std::endl;\n      } else {\n        std::cout << \"Found \" << file << std::endl;\n      }\n    }\n  }\n  return required_files;\n}", "CodeBleu_score": 66.34356395943688}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\t// Get the list of required files\n\tauto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\t// Download the required files if the download flag is set to true\n\tif (download) {\n\t\tfor (auto &file : required_files) {\n\t\t\t// Check if the file exists locally\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\t// Download the file if it does not exist\n\t\t\t\tRequestFile(file);\n\t\t\t\t// Log the download action\n\t\t\t\tLog::Info(\"File \" + file + \" downloaded\");\n\t\t\t} else {\n\t\t\t\t// Log that the file is found in the cache\n\t\t\t\tLog::Info(\"File \" + file + \" found in the cache\");\n\t\t\t}\n\t\t}\n\t}\n\t// Return the list of required files\n\treturn required_files;\n}", "CodeBleu_score": 64.067187140972}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifdef ACTOR_CLIENT_DEBUG_MODE\n  std::cout << \"Client::SpawnActorWithParent\" << std::endl;\n#endif\n  // Check the validity of the transformation to avoid ill-formed transformations when the translation is only in the 'z' axis\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.translation().x() == 0.0 && transform.translation().y() == 0.0 && transform.translation().z()!= 0.0) {\n      std::cout << \"Warning: The translation of the provided transform is only in the 'z' axis. The resulting actor may not be attached to the parent correctly.\" << std::endl;\n    }\n  }\n\n  // Create an actor description\n  rpc::ActorDescription actor_description = description;\n\n  // Set the parent ID\n  actor_description.set_parent_id(parent);\n\n  // Set the attachment type\n  actor_description.set_attachment_type(attachment_type);\n\n  // Set the socket name\n  actor_description.set_socket_name(socket_name);\n\n  // Spawn an actor with a specified parent using the provided description, transform, parent ID, attachment type, and socket name\n  return SpawnActorWithParent(actor_description, transform, parent);\n}", "CodeBleu_score": 51.20803500643486}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\treturn SpawnActorWithParent(description, transform, parent, attachment_type, socket_name, 0, false);\n}", "CodeBleu_score": 23.148439354787527}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\tauto actor = SpawnActor(description, transform, parent, attachment_type, socket_name);\n\treturn actor;\n}", "CodeBleu_score": 24.365083368037343}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\t// Create a request for the token.\n\trpc::Request request;\n\trequest.set_type(rpc::Request::GET_GBUFFER_TOKEN);\n\trpc::GetGBufferTokenRequest* token_request = request.mutable_get_gbuffer_token_request();\n\ttoken_request->set_actor_id(ActorId);\n\ttoken_request->set_gbuffer_id(GBufferId);\n\n\t// Send the request to the server.\n\trpc::Response response;\n\tif (!SendRequest(request, response)) {\n\t\treturn;\n\t}\n\n\t// Check the response.\n\tif (response.type()!= rpc::Response::GBUFFER_TOKEN) {\n\t\tstd::cerr << \"ERROR: Received a non-GBUFFER_TOKEN response from the server.\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Copy the token data.\n\trpc::GBufferToken* token = response.mutable_gbuffer_token();\n\tstd::vector<uint8_t> token_data(token->data().begin(), token->data().end());\n\n\t// Subscribe to the G-buffer.\n\tSubscribeToGBuffer(token_data, callback);\n}", "CodeBleu_score": 40.93640542139031}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\t// Create a new GBufferSubscription\n\tauto subscription = std::make_shared<GBufferSubscription>(ActorId, GBufferId);\n\t// Create a new GBufferSubscriptionCallback\n\tauto callback_ = std::make_shared<GBufferSubscriptionCallback>(callback);\n\t// Create a new GBufferSubscriptionToken\n\tauto token = std::make_shared<GBufferSubscriptionToken>(subscription, callback_);\n\t// Add the token to the list of tokens\n\ttokens_.push_back(token);\n\t// Create a new GBufferSubscriptionRequest\n\tauto request = std::make_shared<GBufferSubscriptionRequest>(ActorId, GBufferId, token);\n\t// Add the request to the list of requests\n\trequests_.push_back(request);\n\t// Send the request to the server\n\tSendRequest(request);\n}", "CodeBleu_score": 37.83147901776861}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\t// Create a new GBufferSubscription object\n\tGBufferSubscription *gbufferSubscription = new GBufferSubscription(ActorId, GBufferId, callback);\n\t// Add the subscription to the list of subscriptions\n\tm_subscriptions.push_back(gbufferSubscription);\n\t// Create a new GBufferSubscriptionRequest object\n\tGBufferSubscriptionRequest *gbufferSubscriptionRequest = new GBufferSubscriptionRequest(ActorId, GBufferId);\n\t// Send the request to the server\n\tm_client.send(gbufferSubscriptionRequest);\n}", "CodeBleu_score": 33.2414977996651}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (navigation == nullptr) {\n\t\tnavigation = std::make_shared<WalkerNavigation>(this);\n\t\tif (navigation->Set()) {\n\t\t\treturn navigation;\n\t\t}\n\t\tnavigation = nullptr;\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 39.07028892825785}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (navigation == nullptr) {\n\t\tnavigation = std::make_shared<WalkerNavigation>(this);\n\t\tnavigation->Set();\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 30.778419714079654}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (this->navigation == nullptr) {\n\t\tthis->navigation = std::make_shared<WalkerNavigation>(this->GetWalker());\n\t}\n\treturn this->navigation;\n}", "CodeBleu_score": 17.217989025077763}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\ttime_duration elapsed = 0;\n\twhile (episode.CurrentFrame() < frame) {\n\t\tstd::this_thread::sleep_for(time_duration(1));\n\t\telapsed += time_duration(1);\n\t\tif (elapsed > timeout) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tepisode.TrafficManager().Tick();\n\treturn true;\n}", "CodeBleu_score": 30.372765858172183}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = system_clock::now();\n\twhile (episode.CurrentFrame() < frame) {\n\t\tif (system_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 30.200598927172184}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = steady_clock::now();\n\twhile (episode.CurrentFrame() < frame) {\n\t\tif (steady_clock::now() - start > timeout)\n\t\t\treturn false;\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 29.62678355362233}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tint attempts = 0;\n\tint max_attempts = 10;\n\tint episode_id = -1;\n\twhile (attempts < max_attempts) {\n\t\ttry {\n\t\t\tepisode_id = LoadEpisodeImpl(map_name, reset_settings, map_layers);\n\t\t\tbreak;\n\t\t} catch (std::exception &e) {\n\t\t\tattempts++;\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t\t}\n\t}\n\tif (attempts >= max_attempts) {\n\t\tthrow std::runtime_error(\"Failed to connect to the new episode\");\n\t}\n\treturn EpisodeProxy{shared_from_this(), episode_id};\n}", "CodeBleu_score": 31.5992581170432}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tif (map_name.empty()) {\n\t\tthrow std::runtime_error(\"map_name is empty\");\n\t}\n\n\tif (map_layers == rpc::MapLayer::None) {\n\t\tthrow std::runtime_error(\"map_layers is None\");\n\t}\n\n\t// load episode\n\tauto episode_id = LoadEpisode(map_name, reset_settings, map_layers, 10);\n\n\t// check if episode is loaded\n\tif (episode_id == 0) {\n\t\tthrow std::runtime_error(\"episode is not loaded\");\n\t}\n\n\treturn EpisodeProxy{shared_from_this(), episode_id};\n}", "CodeBleu_score": 31.236489065559052}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tint attempts = 0;\n\twhile (true) {\n\t\ttry {\n\t\t\tEpisodeProxy ep = LoadEpisodeInternal(map_name, reset_settings, map_layers);\n\t\t\tif (ep.GetEpisodeId()!= m_current_episode_id) {\n\t\t\t\tthrow std::runtime_error(\"Episode ID changed while loading episode.\");\n\t\t\t}\n\t\t\treturn ep;\n\t\t} catch (const std::runtime_error& e) {\n\t\t\tif (attempts >= MAX_LOAD_ATTEMPTS) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tattempts++;\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(LOAD_EPISODE_SLEEP_MS));\n\t\t}\n\t}\n}", "CodeBleu_score": 36.93047339347216}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (controller.GetEpisode() == nullptr) {\n\t\tthrow std::runtime_error(\"Episode is null.\");\n\t}\n\tif (controller.GetWalker() == nullptr) {\n\t\tthrow std::runtime_error(\"Walker is null.\");\n\t}\n\tif (controller.GetWalker()->GetNavigation() == nullptr) {\n\t\tcontroller.GetWalker()->SetNavigation(new Navigation(controller.GetWalker()));\n\t}\n\tcontroller.GetEpisode()->RegisterAIController(controller.GetWalker(), controller.GetControllerID());\n}", "CodeBleu_score": 39.71193402952972}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Retrieve the walker associated with the controller\n\tWalker *walker = GetWalker(controller.GetWalkerID());\n\n\t// Throw an exception if the walker is not found\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\n\t// Assert that the episode is not null\n\tassert(m_episode!= nullptr);\n\n\t// Create navigation if it is missing\n\tif (m_navigation == nullptr) {\n\t\tm_navigation = std::make_unique<Navigation>();\n\t}\n\n\t// Register the walker with the controller's ID\n\tm_navigation->RegisterWalker(controller.GetID(), walker);\n}", "CodeBleu_score": 49.84045274792124}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Retrieve the walker associated with the controller\n\tWalker* walker = GetWalker(controller.GetWalkerID());\n\t// Throw an exception if the walker is not found\n\tif (!walker) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\t// Assert that the episode is not null\n\tassert(GetEpisode());\n\t// Create navigation if it is missing\n\tif (!GetEpisode()->GetNavigation()) {\n\t\tGetEpisode()->SetNavigation(new Navigation(GetEpisode()));\n\t}\n\t// Register the walker with the controller's ID\n\tGetEpisode()->GetNavigation()->RegisterWalker(walker, controller.GetID());\n}", "CodeBleu_score": 41.68260253296185}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t//    if (gc == GarbageCollectionPolicy::NO_GC) {\n//      throw std::runtime_error(\"NO_GC is not supported\");\n//    }\n    GetReadyCurrentEpisode();\n    auto actor = std::make_shared<Actor>(this, blueprint, transform, parent, attachment_type, socket_name);\n    current_episode_->AddActor(actor);\n    actor->SetGarbageCollectionPolicy(gc);\n    actor->LogCreationDetails();\n    return actor;\n  }", "CodeBleu_score": 28.899996455428358}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef DEBUG_SIMULATOR\n    std::cout << \"Simulator::SpawnActor\" << std::endl;\n#endif\n    // Check if the blueprint is valid.\n    if (!blueprint.IsValid()) {\n      throw std::invalid_argument(\"Invalid blueprint\");\n    }\n\n    // Check if the parent is valid.\n    if (parent &&!parent->IsValid()) {\n      throw std::invalid_argument(\"Invalid parent actor\");\n    }\n\n    // Check if the attachment type is valid.\n    if (attachment_type!= rpc::AttachmentType::NONE && attachment_type!= rpc::AttachmentType::CHILD && attachment_type!= rpc::AttachmentType::SOCKET) {\n      throw std::invalid_argument(\"Invalid attachment type\");\n    }\n\n    // Check if the socket name is valid.\n    if (attachment_type == rpc::AttachmentType::SOCKET && socket_name.empty()) {\n      throw std::invalid_argument(\"Invalid socket name\");\n    }\n\n    // Create the actor.\n    SharedPtr<Actor> actor = std::make_shared<Actor>(blueprint, transform, parent, attachment_type, socket_name);\n\n    // Register the actor.\n    RegisterActor(actor);\n\n    // Apply the garbage collection policy.\n    ApplyGarbageCollectionPolicy(actor, gc);\n\n    // Log the actor creation.\n    LogActorCreation(actor);\n\n    // Return the actor.\n    return actor;\n  }", "CodeBleu_score": 38.58853973818656}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\tSharedPtr<Actor> actor = std::make_shared<Actor>(blueprint, transform, parent, attachment_type, socket_name);\n    GetReadyCurrentEpisode();\n    current_episode_->AddActor(actor);\n    actor->SetGarbageCollectionPolicy(gc);\n    return actor;\n  }", "CodeBleu_score": 26.1706042242717}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifdef _WIN32\n  auto episode = GetCurrentEpisode();\n  if (episode == nullptr) {\n    throw std::runtime_error(\"No episode is currently active.\");\n  }\n\n  auto sensor_data = std::make_shared<sensor::SensorData>();\n  sensor_data->sensor_id = sensor.id;\n  sensor_data->sensor_type = sensor.type;\n  sensor_data->sensor_name = sensor.name;\n  sensor_data->sensor_description = sensor.description;\n  sensor_data->sensor_data_type = sensor.data_type;\n  sensor_data->sensor_data_subtype = sensor.data_subtype;\n  sensor_data->sensor_data_unit = sensor.data_unit;\n  sensor_data->sensor_data_format = sensor.data_format;\n  sensor_data->sensor_data_size = sensor.data_size;\n  sensor_data->sensor_data_count = sensor.data_count;\n  sensor_data->sensor_data_offset = sensor.data_offset;\n  sensor_data->sensor_data_step = sensor.data_step;\n  sensor_data->sensor_data_precision = sensor.data_precision;\n  sensor_data->sensor_data_min = sensor.data_min;\n  sensor_data->sensor_data_max = sensor.data_max;\n  sensor_data->sensor_data_mean = sensor.data_mean;\n  sensor_data->sensor_data_std = sensor.data_std;\n  sensor_data->sensor_data_timestamp = sensor.data_timestamp;\n\n  auto subscription = std::make_shared<Subscription>(\n      episode,\n      sensor_data,\n      callback);\n\n  client_->SubscribeToStream(\n      episode->stream_id,\n      sensor.id,\n      [subscription, this](const std::string &data) {\n        subscription->Deserialize(data);\n      });\n#endif\n}", "CodeBleu_score": 37.18305743964294}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\tif (episode_ == nullptr) {\n\t\tthrow std::runtime_error(\"Episode is not set.\");\n\t}\n\n\tif (client_ == nullptr) {\n\t\tthrow std::runtime_error(\"Client is not set.\");\n\t}\n\n\tif (sensor.episode_id!= episode_->id) {\n\t\tthrow std::runtime_error(\"Sensor's episode_id does not match the current episode.\");\n\t}\n\n\tclient_->SubscribeToStream(sensor.stream_id, [this, sensor, callback](const std::string &stream_id, const std::string &data) {\n\t\tauto sensor_data = DeserializeSensorData(data);\n\t\tsensor_data->episode_id = episode_->id;\n\t\tsensor_data->sensor_id = sensor.id;\n\t\tcallback(sensor_data);\n\t});\n}", "CodeBleu_score": 38.73132179407842}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\tif (episode_ == nullptr) {\n\t\tthrow std::runtime_error(\"Episode is invalid\");\n\t}\n\n\tauto sensor_data = std::make_shared<sensor::SensorData>();\n\tsensor_data->set_sensor_id(sensor.id());\n\tsensor_data->set_episode_id(episode_->id());\n\n\tauto on_data = [sensor_data, callback](const std::string &data) {\n\t\tsensor_data->ParseFromString(data);\n\t\tcallback(sensor_data);\n\t};\n\n\tclient_->SubscribeToStream(sensor.data_stream(), on_data);\n}", "CodeBleu_score": 39.8970403590711}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t", "CodeBleu_score": 2.1859456278860714}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// Load the current walkers\n    std::vector<WalkerHandle> walkers = GetWalkers();\n    // check if walkers are empty\n    if (walkers.empty()) return;\n// Check if walkers exist\n    CheckIfWalkerExist(walkers, *episode->GetState());\n// Update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode);\n// Update the crowd\n    _nav.UpdateCrowd();\n// Apply walkers states to the simulator\n    for (auto &&walker : walkers) {\n      // get the state\n      const EpisodeState::WalkerSnapshot &snapshot = episode->GetState()->GetWalkerSnapshot(walker.walker);\n      // apply the state\n      ApplyWalkerState(walker, snapshot);\n    }\n// Check if any walker has been killed\n    for (auto &&walker : walkers) {\n      // get the state\n      const EpisodeState::WalkerSnapshot &snapshot = episode->GetState()->GetWalkerSnapshot(walker.walker);\n      // check if the walker is dead\n      if (snapshot.is_dead) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 35.995540166783556}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t", "CodeBleu_score": 4.932770825794737}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\n\tfor (const auto& attribute : attributes) {\n\t\tdescription.add_attributes(attribute);\n\t}\n\n\treturn description;\n}", "CodeBleu_score": 52.77426104910003}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_id(id_);\n\tdescription.set_uid(uid_);\n\tdescription.set_attributes_size(attributes_.size());\n\tfor (const auto& attribute : attributes_) {\n\t\tdescription.add_attributes()->CopyFrom(attribute);\n\t}\n\treturn description;\n}", "CodeBleu_score": 60.44902072708101}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = SharedPtr<BlueprintLibrary>(new BlueprintLibrary());\n\tfor (const auto& blueprint : *this) {\n\t\tif (blueprint->hasAttribute(name)) {\n\t\t\tif (blueprint->getAttribute(name) == value) {\n\t\t\t\tresult->add(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 30.55539487456515}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = SharedPtr<BlueprintLibrary>(new BlueprintLibrary());\n\tfor (auto blueprint : blueprints) {\n\t\tif (blueprint->hasAttribute(name)) {\n\t\t\tif (blueprint->getAttribute(name) == value) {\n\t\t\t\tresult->addBlueprint(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 30.74473232255499}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = make_shared<BlueprintLibrary>();\n\tfor (auto blueprint : blueprints) {\n\t\tif (blueprint->hasAttribute(name)) {\n\t\t\tif (blueprint->getAttribute(name) == value) {\n\t\t\t\tresult->add(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 29.96608595990694}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = this->baseFolder + path;\n\tif (!this->ValidatePath(fullPath)) {\n\t\treturn false;\n\t}\n\n\tstd::ofstream file(fullPath, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\n\tfile.write((char*)content.data(), content.size());\n\tfile.close();\n\n\treturn true;\n}", "CodeBleu_score": 37.55884013982192}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = base_folder + path;\n\tif (!ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream file;\n\tfile.open(full_path, std::ios::out | std::ios::binary);\n\tif (file.is_open()) {\n\t\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.13074786816149}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = GetFullFilePath(path);\n\tif (!ValidateFilePath(fullPath)) {\n\t\treturn false;\n\t}\n\tstd::ofstream file(fullPath, std::ios::binary);\n\tif (file.is_open()) {\n\t\tfile.write((char*)content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 36.6317423955313}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n//    const auto location = transform.location;\n    const auto location = transform.location + parent->GetBounds(frame)->location;\n    const auto yaw = transform.yaw;\n\n    const auto corner1 = Rotate(yaw, {parent->GetBounds(frame)->extents.x, parent->GetBounds(frame)->extents.y, 0});\n    const auto corner2 = Rotate(yaw, {parent->GetBounds(frame)->extents.x, -parent->GetBounds(frame)->extents.y, 0});\n    const auto corner3 = Rotate(yaw, {-parent->GetBounds(frame)->extents.x, -parent->GetBounds(frame)->extents.y, 0});\n    const auto corner4 = Rotate(yaw, {-parent->GetBounds(frame)->extents.x, parent->GetBounds(frame)->extents.y, 0});\n\n    return std::make_shared<Bounds>(frame, location, {std::max(std::max(std::max(corner1.x, corner2.x), corner3.x), corner4.x), std::max(std::max(std::max(corner1.y, corner2.y), corner3.y), corner4.y), 0});\n  }", "CodeBleu_score": 46.32789407585081}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n/*\n * The following code creates a shared pointer to a Bounds object.\n */\n    std::shared_ptr<const LaneInvasionCallback::Bounds> bounds(new Bounds);\n\n/*\n * The following code assigns the frame number and location to the Bounds object.\n */\n    bounds->frame = frame;\n    bounds->location = transform.location;\n\n/*\n * The following code calculates the four corners of the bounding box.\n */\n    const float yaw = transform.yaw * geom::Math::Pi<float>() / 180.0f;\n    const float c = std::cos(yaw);\n    const float s = std::sin(yaw);\n    const float x = c * kExtents.x - s * kExtents.y;\n    const float y = s * kExtents.x + c * kExtents.y;\n    const float x1 = c * kExtents.x + s * kExtents.y;\n    const float y1 = s * kExtents.x - c * kExtents.y;\n    const float x2 = c * -kExtents.x - s * kExtents.y;\n    const float y2 = s * -kExtents.x + c * kExtents.y;\n    const float x3 = c * -kExtents.x + s * kExtents.y;\n    const float y3 = s * -kExtents.x - c * kExtents.y;\n\n    bounds->corners[0] = {x + transform.location.x, y + transform.location.y, transform.location.z};\n    bounds->corners[1] = {x1 + transform.location.x, y1 + transform.location.y, transform.location.z};\n    bounds->corners[2] = {x2 + transform.location.x, y2 + transform.location.y, transform.location.z};\n    bounds->corners[3] = {x3 + transform.location.x, y3 + transform.location.y, transform.location.z};\n\n    return bounds;\n  }", "CodeBleu_score": 40.19684975396803}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t//    const auto location = geom::Location::Add(transform.location, parent.location);\n    const auto location = transform.location;\n    const auto yaw = transform.yaw;\n    const auto &extents = parent.extents;\n    const auto &corners = parent.corners;\n    const auto &rotate = Rotate(yaw, location);\n    return std::make_shared<Bounds>(\n        frame,\n        {\n            {rotate.x - extents.x, rotate.y - extents.y, location.z},\n            {rotate.x - extents.x, rotate.y + extents.y, location.z},\n            {rotate.x + extents.x, rotate.y + extents.y, location.z},\n            {rotate.x + extents.x, rotate.y - extents.y, location.z}\n        });\n  }", "CodeBleu_score": 45.9453319015218}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::unique_lock<std::mutex> lock(_mutex);\n\n\t// Query the current light states from the server\n\tstd::vector<LightState> lightStates = _server->QueryLightsState();\n\n\t// Update the local light states and create new light objects if they do not already exist\n\tfor (LightState lightState : lightStates) {\n\t\tif (_lights.find(lightState.id) == _lights.end()) {\n\t\t\t_lights[lightState.id] = new Light(lightState);\n\t\t} else {\n\t\t\t_lights[lightState.id]->Update(lightState);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.12251004466655}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::unique_lock<std::mutex> lock(mutex);\n\n\t// Query the current state of the lights from the server\n\tstd::vector<LightState> lightStates = lightServer->QueryLightsState();\n\n\t// Update the local light states\n\tfor (LightState lightState : lightStates) {\n\t\t// Check if the light already exists in the _lights map\n\t\tif (_lights.find(lightState.id) == _lights.end()) {\n\t\t\t// Create a new light object and add it to the _lights map\n\t\t\tLight *light = new Light(lightState.id, lightState.color, lightState.intensity, lightState.position, lightState.direction);\n\t\t\t_lights.insert(std::pair<int, Light *>(lightState.id, light));\n\t\t}\n\t\telse {\n\t\t\t// Update the existing light object in the _lights map\n\t\t\t_lights.at(lightState.id)->Update(lightState.color, lightState.intensity, lightState.position, lightState.direction);\n\t\t}\n\t}\n}", "CodeBleu_score": 33.996641903815366}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Create a JSON object to store the response from the server\n\tnlohmann::json response;\n\n\t// Query the server for the light states\n\tif (query_lights_state_from_server(response)) {\n\t\t// Loop through the response and update the local light states\n\t\tfor (auto &light : response[\"lights\"]) {\n\t\t\t// Get the light id\n\t\t\tint light_id = light[\"light_id\"];\n\n\t\t\t// Check if the light exists in the _lights map\n\t\t\tif (_lights.find(light_id)!= _lights.end()) {\n\t\t\t\t// Update the light state\n\t\t\t\t_lights[light_id]->UpdateState(light);\n\t\t\t} else {\n\t\t\t\t// Create a new light object\n\t\t\t\tLight *new_light = new Light(light_id, light);\n\n\t\t\t\t// Add the light to the _lights map\n\t\t\t\t_lights.emplace(light_id, new_light);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 31.6884192003728}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (dirty) {\n\t\tif (discard_client) {\n\t\t\tfor (int i = 0; i < MAX_LIGHTS; i++) {\n\t\t\t\tif (lights[i].dirty) {\n\t\t\t\t\tlights[i].dirty = false;\n\t\t\t\t\tlights[i].client_state = lights[i].server_state;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create message\n\t\tLightStateMessage msg;\n\t\tmsg.lights.resize(MAX_LIGHTS);\n\t\tfor (int i = 0; i < MAX_LIGHTS; i++) {\n\t\t\tmsg.lights[i] = lights[i].server_state;\n\t\t}\n\n\t\t// Send message\n\t\tif (server_connection!= NULL) {\n\t\t\tserver_connection->Send(&msg);\n\t\t}\n\n\t\t// Clear changes\n\t\tdirty = false;\n\t}\n}", "CodeBleu_score": 33.375852483469615}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (dirty) {\n\t\tdirty = false;\n\t\tif (discard_client) {\n\t\t\tfor (auto& light : lights) {\n\t\t\t\tlight.second.discard_client = true;\n\t\t\t}\n\t\t}\n\t\tauto message = std::make_shared<LightMessage>();\n\t\tfor (auto& light : lights) {\n\t\t\tmessage->lights.push_back(light.second);\n\t\t}\n\t\tmessage->type = LightMessage::Type::LIGHT_STATE_UPDATE;\n\t\tif (server) {\n\t\t\tserver->Send(message);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.217456055031725}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\t// Lock mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Check if there are any changes\n\tif (dirty) {\n\t\t// Create message\n\t\tstd::string message = \"light_state:\";\n\n\t\t// Loop through all lights\n\t\tfor (auto light : lights) {\n\t\t\t// Add light to message\n\t\t\tmessage += light->GetLightState();\n\t\t\tmessage += \";\";\n\t\t}\n\n\t\t// Remove trailing \";\"\n\t\tmessage = message.substr(0, message.size() - 1);\n\n\t\t// Send message to server\n\t\tif (discard_client) {\n\t\t\t// Discard client\n\t\t\tclient->Send(message);\n\t\t} else {\n\t\t\t// Send to server\n\t\t\tserver->Send(message);\n\t\t}\n\n\t\t// Clear changes\n\t\tdirty = false;\n\t}\n}", "CodeBleu_score": 28.168693397737577}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (sensor_id_!= \"sensor.other.v2x_custom\") {\n\t\tLOG(WARNING) << \"ServerSideSensor::Send: \" << sensor_id_ << \" is not a valid sensor ID.\";\n\t\treturn;\n\t}\n\tauto context = GetContext();\n\tauto message_ptr = std::make_shared<std::string>(message);\n\tcontext->Send(message_ptr);\n}", "CodeBleu_score": 45.729151210550334}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->GetID()!= \"sensor.other.v2x_custom\") {\n\t\tLOG(WARNING) << \"Sensor ID is not sensor.other.v2x_custom\";\n\t} else {\n\t\tLOG(DEBUG) << \"Sending message: \" << message;\n\t\tthis->GetContext()->Send(message);\n\t}\n}", "CodeBleu_score": 42.20074772592529}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->sensor_id!= \"sensor.other.v2x_custom\") {\n\t\tLOG_WARN(\"Sensor ID does not match the sensor.other.v2x_custom ID. Not sending message.\");\n\t\treturn;\n\t}\n\n\tthis->context->Send(message);\n}", "CodeBleu_score": 43.21409964275628}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm_port = tm_port;\n\t\ttm_enabled = true;\n\t} else {\n\t\ttm_port = 0;\n\t\ttm_enabled = false;\n\t}\n}", "CodeBleu_score": 38.65326304943405}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\tif (tm_port == 0) {\n\t\t\ttm_port = 18401;\n\t\t}\n\t\ttm_port += 10000;\n\t\ttm_port = htons(tm_port);\n\t\tif (sendto(tm_socket, &tm_port, sizeof(uint16_t), 0, (struct sockaddr *) &tm_addr, sizeof(tm_addr)) < 0) {\n\t\t\tperror(\"sendto\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tif (sendto(tm_socket, &tm_port, sizeof(uint16_t), 0, (struct sockaddr *) &tm_addr, sizeof(tm_addr)) < 0) {\n\t\t\tperror(\"sendto\");\n\t\t\texit(1);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.11348887504153}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (enabled) {\n\t\ttm_port_ = tm_port;\n\t\ttm_ = new TrafficManager(tm_port_);\n\t\ttm_->RegisterVehicle(this);\n\t} else {\n\t\tif (tm_) {\n\t\t\ttm_->UnregisterVehicle(this);\n\t\t\tdelete tm_;\n\t\t\ttm_ = nullptr;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.498739022874396}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\t// Get the walker actor\n\twalkerActor = GetWalkerActor();\n\n\t// Add the walker actor to the navigation system\n\tUNavigationSystemV1* navSys = UNavigationSystemV1::GetCurrent(GetWorld());\n\tif (navSys) {\n\t\tnavSys->AddAgent(walkerActor, walkerActor->GetActorLocation());\n\t}\n\n\t// Disable physics simulation and collisions for the walker actor\n\twalkerActor->SetActorEnableCollision(false);\n\twalkerActor->GetWorld()->GetPhysicsScene()->SetSimulatePhysics(false);\n}", "CodeBleu_score": 36.56023328214542}, {"code": "void WalkerAIController::Start(){\n\t\t// Retrieve the walker actor\n\twalker = GetWorld()->GetFirstPlayerController()->GetPawn();\n\n\t// Add the walker to the navigation system with its current location\n\tFVector walkerLocation = walker->GetActorLocation();\n\tUNavigationSystemV1* navSystem = UNavigationSystemV1::GetCurrent(GetWorld());\n\tnavSystem->SimpleMoveToLocation(this, walkerLocation);\n\n\t// Disable the physics simulation and collisions for the walker actor\n\twalker->GetWorld()->GetPhysicsScene()->SetSimulatePhysics(false);\n\twalker->GetWorld()->GetPhysicsScene()->SetEnableGravity(false);\n\twalker->GetWorld()->GetPhysicsScene()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}", "CodeBleu_score": 44.6314630371587}, {"code": "void WalkerAIController::Start(){\n\t\t// Retrieve the walker actor\n\twalkerActor = GetWorld()->GetFirstPlayerController()->GetPawn();\n\n\t// Add the walker actor to the navigation system\n\tUNavigationSystemV1* navigationSystem = UNavigationSystemV1::GetCurrent(GetWorld());\n\tnavigationSystem->RegisterNavigationInvoker(walkerActor);\n\n\t// Disable the physics simulation and collisions for the walker actor\n\twalkerActor->GetWorld()->GetPhysicsScene()->SetFlags(walkerActor->GetWorld()->GetPhysicsScene()->GetFlags() & ~EPhysicsSceneFlags::PSC_Simulation);\n\twalkerActor->GetWorld()->GetPhysicsScene()->SetFlags(walkerActor->GetWorld()->GetPhysicsScene()->GetFlags() & ~EPhysicsSceneFlags::PSC_Collision);\n}", "CodeBleu_score": 44.64325394024035}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (episode_!= nullptr) {\n\t\tNavigation* navigation = episode_->GetNavigation();\n\t\tif (navigation!= nullptr) {\n\t\t\tWalker* walker = parent_walker_->GetWalker();\n\t\t\tif (walker!= nullptr) {\n\t\t\t\tif (navigation->SetMaxSpeed(walker, max_speed)) {\n\t\t\t\t\t// Successfully set the max speed.\n\t\t\t\t\tparent_walker_->SetMaxSpeed(max_speed);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Failed to set the max speed.\n\t\t\t\t\tLOG(WARNING) << \"Failed to set the max speed for the walker.\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Walker not found.\n\t\t\t\tLOG(WARNING) << \"Walker not found.\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Navigation instance not found.\n\t\t\tLOG(WARNING) << \"Navigation instance not found.\";\n\t\t}\n\t}\n\telse {\n\t\t// Episode not found.\n\t\tLOG(WARNING) << \"Episode not found.\";\n\t}\n}", "CodeBleu_score": 43.89725129146772}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (current_episode_!= nullptr) {\n\t\tif (current_episode_->GetNavigation()!= nullptr) {\n\t\t\tWalker* walker = current_episode_->GetWalker();\n\t\t\tif (walker!= nullptr) {\n\t\t\t\tif (current_episode_->GetNavigation()->SetMaxSpeed(walker, max_speed)) {\n\t\t\t\t\twalker->SetMaxSpeed(max_speed);\n\t\t\t\t} else {\n\t\t\t\t\tLOG(WARNING) << \"Failed to set maximum speed for walker \" << walker->GetID() << \" to \" << max_speed;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG(WARNING) << \"Walker \" << walker->GetID() << \" not found in episode\";\n\t\t\t}\n\t\t} else {\n\t\t\tLOG(WARNING) << \"Navigation instance not found in episode\";\n\t\t}\n\t} else {\n\t\tLOG(WARNING) << \"Episode instance not found\";\n\t}\n}", "CodeBleu_score": 45.403595214881136}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (navigation == nullptr) {\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"WalkerAIController::SetMaxSpeed: Navigation instance is null.\"));\n\t\treturn;\n\t}\n\tif (navigation->GetParentWalker() == nullptr) {\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"WalkerAIController::SetMaxSpeed: Walker instance is null.\"));\n\t\treturn;\n\t}\n\tif (!navigation->SetMaxSpeed(max_speed)) {\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set max speed.\"));\n\t\treturn;\n\t}\n}", "CodeBleu_score": 42.26760781825558}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> previousWaypoints = GetMap()->GetPrevious(this, distance);\n\tfor (auto waypoint : previousWaypoints) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n\t}\n\treturn result;\n}", "CodeBleu_score": 53.45712550951865}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> previous;\n\tstd::vector<SharedPtr<Waypoint>> waypoints = GetMap()->GetPrevious(this, distance);\n\tfor (auto it = waypoints.begin(); it!= waypoints.end(); it++) {\n\t\tprevious.push_back(MakeShared<Waypoint>(*it));\n\t}\n\treturn previous;\n}", "CodeBleu_score": 50.895067781567164}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> waypoints = GetMap()->GetPrevious(this, distance);\n\n\tfor (auto waypoint : waypoints) {\n\t\tresult.push_back(std::make_shared<Waypoint>(waypoint));\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 53.31763147265794}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\n\t// Get signals within the distance\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\n\t// Get the signals in the vector, checking for duplicates\n\tfor (auto signal : signals) {\n\t\tif (std::find(result.begin(), result.end(), signal) == result.end()) {\n\t\t\t// Create a new waypoint and landmark\n\t\t\tSharedPtr<Waypoint> waypoint = SharedPtr<Waypoint>(new Waypoint(signal->GetId(), signal->GetPosition(), signal->GetSpeedLimit(), signal->GetLaneCount()));\n\t\t\tSharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(signal, waypoint));\n\n\t\t\t// Add the landmark to the result\n\t\t\tresult.push_back(landmark);\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 47.230305601452415}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\tfor (auto signal : signals) {\n\t\tif (std::find(result.begin(), result.end(), signal->GetLandmark()) == result.end()) {\n\t\t\tresult.push_back(signal->GetLandmark());\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 28.07527366488898}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\n\t// Get all signals within the distance\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\n\t// For each signal, create a new Waypoint and Landmark and add them to the result\n\tfor (auto signal : signals) {\n\t\tSharedPtr<Waypoint> waypoint = GetWaypointForSignal(signal);\n\t\tSharedPtr<Landmark> landmark = GetLandmarkForSignal(signal);\n\n\t\t// Check if the signal is already in the result\n\t\tbool signal_in_result = false;\n\t\tfor (auto result_signal : result) {\n\t\t\tif (result_signal->GetId() == signal->GetId()) {\n\t\t\t\tsignal_in_result = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Add the signal to the result if it's not already there\n\t\tif (!signal_in_result) {\n\t\t\tresult.push_back(landmark);\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 45.938485923269724}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t/    time_duration local_timeout = timeout.milliseconds() == 0?\n//        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->ApplySettings(settings, timeout);\n  }", "CodeBleu_score": 14.97746620905806}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tifdef _WIN32\n    // This is a workaround for a Windows bug in std::chrono.\n    // See https://connect.microsoft.com/VisualStudio/feedback/details/1054785/std-chrono-time-point-has-a-bug-in-windows-7-and-windows-server-2008-r2\n    // This should be removed when the bug is fixed.\n    if (timeout.count() == 0) {\n        timeout = std::chrono::milliseconds(1000);\n    }\n#endif\n    time_duration local_timeout = timeout.count() == 0?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->ApplySettings(settings, local_timeout);\n  }", "CodeBleu_score": 21.295705304637142}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t", "CodeBleu_score": 3.171605579650036}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst Vector2& point,\n\tconst Vector2& segmentStart,\n\tconst Vector2& segmentEnd\n}", "CodeBleu_score": 10.922423612407597}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t", "CodeBleu_score": 3.3301066487392625}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat x, y, dx, dy, t, d;\n\tx = p.x - a.x;\n\ty = p.y - a.y;\n\tdx = b.x - a.x;\n\tdy = b.y - a.y;\n\tt = (dx * x + dy * y) / (dx * dx + dy * dy);\n\tif (t < 0.0f) {\n\t\td = x * x + y * y;\n\t} else if (t > 1.0f) {\n\t\tdx = p.x - b.x;\n\t\tdy = p.y - b.y;\n\t\td = dx * dx + dy * dy;\n\t} else {\n\t\tdx = a.x + t * dx - p.x;\n\t\tdy = a.y + t * dy - p.y;\n\t\td = dx * dx + dy * dy;\n\t}\n\treturn std::make_pair(d, t);\n}", "CodeBleu_score": 36.01465678918579}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t//    std::cout << \"Mesh::AddTriangleFan\" << std::endl;\n    assert(vertices.size() >= 3);\n    index_type initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; i++) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 51.87781304451655}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t//    assert(vertices.size() >= 3);\n    auto index = GetVerticesNum();\n    AddVertices(vertices);\n    for (auto i = 1u; i < vertices.size() - 1; ++i) {\n      AddIndex(index);\n      AddIndex(index + i);\n      AddIndex(index + i + 1);\n    }\n  }", "CodeBleu_score": 46.898456245104256}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tassert(vertices.size() >= 3);\n\tsize_t initialIndex = _vertices.size();\n\tAddVertices(vertices);\n\tfor (size_t i = 0; i < vertices.size() - 2; ++i) {\n\t\tAddIndex(initialIndex);\n\t\tAddIndex(initialIndex + i + 1);\n\t\tAddIndex(initialIndex + i + 2);\n\t}\n  }", "CodeBleu_score": 47.19567542675803}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t", "CodeBleu_score": 3.648604678563731}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (message->IsValid()) {\n\t\tstrand.post([this, message]() {\n\t\t\tif (socket.is_open()) {\n\t\t\t\tsocket.expires_from_now(std::chrono::milliseconds(timeout));\n\t\t\t\tsocket.async_write_some(boost::asio::buffer(message->Serialize()), strand.wrap([this, message](boost::system::error_code ec, std::size_t length) {\n\t\t\t\t\thandle_sent(ec, length, message);\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\t}\n}", "CodeBleu_score": 26.321135424826092}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t", "CodeBleu_score": 3.648604678563731}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer\n\tdeadline_.cancel();\n\n\t// Check if the socket is open\n\tif (socket_.is_open()) {\n\t\t// Attempt to shut down and close the socket\n\t\tboost::system::error_code ignored_ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t\tsocket_.close();\n\t}\n\n\t// Trigger the on_closed callback\n\ton_closed();\n\n\t// Log that the session has been closed\n\tlog_ << \"Session closed.\" << std::endl;\n}", "CodeBleu_score": 43.71761744197881}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer.\n\tdeadline_timer_.cancel();\n\t// If the socket is open, attempt to shut it down and close it.\n\tif (socket_.is_open()) {\n\t\tboost::system::error_code ignored_ec;\n\t\tif (ec) {\n\t\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t\t}\n\t\tsocket_.close(ignored_ec);\n\t}\n\t// Call the on_closed callback.\n\tif (on_closed_) {\n\t\ton_closed_(ec);\n\t}\n\t// Log that the session has been closed.\n\tlog_ << \"Session closed.\" << std::endl;\n}", "CodeBleu_score": 54.15556345202308}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec) {\n\t\t// If the error code is not equal to 0, then the socket connection has failed.\n\t\t// The error code will be logged and the session will be closed.\n\t\tLog::Error(ec, \"Failed to close the socket connection.\");\n\t\treturn;\n\t}\n\n\t// If the socket is open, then we attempt to shut down and close the socket.\n\tif (socket_.is_open()) {\n\t\tboost::system::error_code ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n\t\t// If the socket shutdown was successful, then we close the socket.\n\t\tif (!ec) {\n\t\t\tsocket_.close();\n\t\t}\n\t}\n\n\t// Trigger the on_closed callback.\n\ton_closed(ec);\n\n\t// Log that the socket connection has been closed.\n\tLog::Info(\"Socket connection closed.\");\n}", "CodeBleu_score": 48.47843556001036}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tchar *buffer = new char[1];\n\tbuffer[0] = YOU_ALIVE;\n\n\t// Log the sending action\n\tstd::cout << \"Sending message: \" << buffer << std::endl;\n\n\t// Write the buffer to the next router\n\twrite(nextRouter, buffer, 1);\n\n\t// Wait for and log the response from the system\n\tchar response[1];\n\tread(nextRouter, response, 1);\n\tstd::cout << \"Received message: \" << response << std::endl;\n\n\t// Delete the buffer\n\tdelete[] buffer;\n}", "CodeBleu_score": 36.29722635890044}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create the buffer\n\tchar buffer[100];\n\t// Log the action\n\tcout << \"Sending message: \" << YOU_ALIVE << endl;\n\t// Send the message\n\tsprintf(buffer, YOU_ALIVE);\n\t// Write the buffer to the next router\n\twrite(nextRouter, buffer, sizeof(buffer));\n\t// Wait for the response\n\tchar response[100];\n\tread(nextRouter, response, sizeof(response));\n\t// Log the response\n\tcout << \"Received message: \" << response << endl;\n}", "CodeBleu_score": 35.90648891805206}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create the message buffer\n\tchar buffer[100];\n\tstrcpy(buffer, \"Are you alive?\");\n\n\t// Log the sending action\n\tlog.Log(SENDING_MESSAGE, buffer);\n\n\t// Write the buffer to the next router\n\tnextRouter->Write(buffer);\n\n\t// Wait for a response\n\tchar response[100];\n\tnextRouter->Read(response);\n\n\t// Log the response\n\tlog.Log(RECEIVED_MESSAGE, response);\n}", "CodeBleu_score": 33.31911598887284}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tif (sensor_id == 0) {\n\t\tcout << \"Error: Sensor ID cannot be 0.\" << endl;\n\t\treturn;\n\t}\n\n\t// Create a buffer to hold the sensor ID\n\tchar buffer[4];\n\tmemcpy(buffer, &sensor_id, sizeof(stream_id));\n\n\t// Send the ENABLE_ROS command to the router\n\trouter->SendCommand(ENABLE_ROS, buffer, 4);\n\n\t// Wait for the response from the router\n\tCommand command = router->ReceiveCommand();\n\n\t// Check if the response is valid\n\tif (command.command!= ENABLE_ROS) {\n\t\tcout << \"Error: Invalid response from router.\" << endl;\n\t\treturn;\n\t}\n\n\t// Check if the sensor is activated\n\tif (command.payload[0] == 0) {\n\t\tcout << \"Error: Sensor \" << sensor_id << \" is not activated.\" << endl;\n\t\treturn;\n\t}\n\n\t// If the sensor is activated, send an ENABLE_ROS command to the server\n\tserver->SendCommand(ENABLE_ROS, buffer, 4);\n\n\t// Wait for the response from the server\n\tcommand = server->ReceiveCommand();\n\n\t// Check if the response is valid\n\tif (command.command!= ENABLE_ROS) {\n\t\tcout << \"Error: Invalid response from server.\" << endl;\n\t\treturn;\n\t}\n\n\t// Check if the sensor is activated\n\tif (command.payload[0] == 0) {\n\t\tcout << \"Error: Sensor \" << sensor_id << \" is not activated.\" << endl;\n\t\treturn;\n\t}\n\n\t// If the sensor is activated, log a message\n\tcout << \"Sensor \" << sensor_id << \" activated for ROS.\" << endl;\n}", "CodeBleu_score": 39.275994449414554}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t", "CodeBleu_score": 2.115550583146295}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tif (sensor_id >= 0) {\n\t\t// Create a buffer to store the sensor ID\n\t\tuint8_t buffer[2];\n\t\tbuffer[0] = (uint8_t) sensor_id;\n\t\tbuffer[1] = (uint8_t) (sensor_id >> 8);\n\n\t\t// Send the ENABLE_ROS command to the server using the router\n\t\trouter.SendCommand(ENABLE_ROS, buffer, 2);\n\n\t\t// Wait for and process the server's response\n\t\tif (router.WaitForResponse(ENABLE_ROS, 10000)) {\n\t\t\tuint8_t response_type = router.GetResponseType();\n\t\t\tif (response_type == ENABLE_ROS) {\n\t\t\t\t// The sensor is enabled for ROS\n\t\t\t\tsensor_ids_enabled_for_ros.push_back(sensor_id);\n\t\t\t} else if (response_type == DISABLE_ROS) {\n\t\t\t\t// The sensor is disabled for ROS\n\t\t\t\tsensor_ids_enabled_for_ros.remove(sensor_id);\n\t\t\t} else {\n\t\t\t\t// Unknown response type\n\t\t\t\tLOG(ERROR) << \"Unknown response type: \" << response_type;\n\t\t\t}\n\t\t} else {\n\t\t\t// No response received\n\t\t\tLOG(ERROR) << \"No response received from server\";\n\t\t}\n\t} else {\n\t\t// Invalid sensor ID\n\t\tLOG(ERROR) << \"Invalid sensor ID: \" << sensor_id;\n\t}\n}", "CodeBleu_score": 41.28975705255417}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t#ifdef DEBUG_TOKENS\n  log_info(\"PrimaryCommands::GetToken\");\n#endif\n\n  // Check if the sensor is already activated\n  auto it = _active_sensors.find(sensor_id);\n  if (it!= _active_sensors.end()) {\n    log_info(\"Sensor already activated, returning existing token\");\n    return it->second;\n  }\n\n  // Get a token from the secondary server\n  log_info(\"Sensor not activated, requesting a new token from the secondary server\");\n  token_type new_token = SendGetToken(sensor_id);\n\n  // Update the maps\n  _active_sensors.insert(std::make_pair(sensor_id, new_token));\n  _token_to_sensor.insert(std::make_pair(new_token, sensor_id));\n\n  return new_token;\n}", "CodeBleu_score": 49.14140583757188}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tlog_info(\"asking for a token\");\n\tauto it = _token_map.find(sensor_id);\n\tif (it!= _token_map.end()) {\n\t\tlog_info(\"found an existing token\");\n\t\treturn it->second;\n\t}\n\telse {\n\t\tlog_info(\"didn't find an existing token\");\n\t\tauto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, std::move(carla::Buffer((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id))));\n\t\tauto response = fut.get();\n\t\ttoken_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n\t\tlog_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n\t\t_token_map.insert(std::make_pair(sensor_id, new_token));\n\t\treturn new_token;\n\t}\n}", "CodeBleu_score": 49.76138047845055}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tlog_info(\"asking for a token\");\n\tauto token = _tokens.find(sensor_id);\n\tif (token!= _tokens.end()) {\n\t\tlog_info(\"token found for sensor \", sensor_id, \", \", token->second.get_stream_id(), \", \", token->second.get_port());\n\t\treturn token->second;\n\t} else {\n\t\tauto token = SendGetToken(sensor_id);\n\t\t_tokens.insert(std::make_pair(sensor_id, token));\n\t\treturn token;\n\t}\n}", "CodeBleu_score": 47.12807848873045}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!ready) {\n\t\treturn false;\n\t}\n\tif (crowd == NULL) {\n\t\treturn false;\n\t}\n\tif (id == 0) {\n\t\treturn false;\n\t}\n\n\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (walkers.find(id)!= walkers.end()) {\n\t\twalkers.erase(id);\n\t\tif (walkers.size() == 0) {\n\t\t\tready = false;\n\t\t}\n\t\treturn true;\n\t}\n\tif (vehicles.find(id)!= vehicles.end()) {\n\t\tvehicles.erase(id);\n\t\tif (vehicles.size() == 0) {\n\t\t\tready = false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.18471725204552}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (m_crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\tif (m_crowd->isReady()) {\n\t\tEnterCriticalSection(&m_critSect);\n\t\tif (m_crowd->removeAgent(id)) {\n\t\t\tif (m_vehicleManager!= nullptr) {\n\t\t\t\tm_vehicleManager->RemoveAgent(id);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tm_walkerManager->RemoveAgent(id);\n\t\t\t}\n\t\t\tLeaveCriticalSection(&m_critSect);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tLeaveCriticalSection(&m_critSect);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 35.102880822209755}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\n\tif (m_crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\tstd::unique_lock<std::mutex> lock(m_mutex);\n\n\t// Remove from crowd\n\tm_crowd->RemoveAgent(id);\n\n\t// Remove from walker manager\n\tm_walkerManager->RemoveAgent(id);\n\n\t// Remove from vehicle manager\n\tm_vehicleManager->RemoveAgent(id);\n\n\t// Remove from mapping\n\tm_agentToWalkerMap.erase(id);\n\tm_agentToVehicleMap.erase(id);\n\n\treturn true;\n}", "CodeBleu_score": 30.855226238277883}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\teck if all is ready\n\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\tDEBUG_ASSERT(_crowd!= nullptr);\n\n\t// get the ids of currently mapped vehicles\n\tstd::set<ActorId> current_ids;\n\tfor (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); ++it) {\n\t\tcurrent_ids.insert(it->first);\n\t}\n\n\t// add or update vehicles\n\tfor (auto &vehicle : vehicles) {\n\t\t// add or update\n\t\tif (!AddOrUpdateVehicle(vehicle)) {\n\t\t\treturn false;\n\t\t}\n\t\t// mark as updated\n\t\tcurrent_ids.erase(vehicle.id);\n\t}\n\n\t// remove vehicles\n\tfor (auto &id : current_ids) {\n\t\t// remove\n\t\tif (!RemoveAgent(id)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 45.40430527145055}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\teck if all is ready\nif (!_ready) {\n  return false;\n}\n\nDEBUG_ASSERT(_crowd!= nullptr);\n\n// get the current set of vehicle ids\nstd::set<ActorId> current_vehicles;\nfor (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); ++it) {\n  current_vehicles.insert(it->first);\n}\n\n// add or update vehicles\nfor (auto &vehicle : vehicles) {\n  if (AddOrUpdateVehicle(vehicle)) {\n    current_vehicles.erase(vehicle.id);\n  }\n}\n\n// remove vehicles that are not in the current frame\nfor (auto id : current_vehicles) {\n  RemoveAgent(id);\n}\n\nreturn true;\n  }", "CodeBleu_score": 48.75805485217948}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t#ifdef CARLA_SERVER\n  // Check if the actor is a walker or a vehicle.\n  auto actor = GetActor(id);\n  if (actor == nullptr) {\n    return false;\n  }\n\n  // Check if the actor is a walker or a vehicle.\n  if (actor->GetTypeId() == carla::rpc::ActorType::Walker) {\n    return false;\n  } else if (actor->GetTypeId() == carla::rpc::ActorType::Vehicle) {\n    auto vehicle = std::static_pointer_cast<Vehicle>(actor);\n    // Check if the vehicle is in the crowd system.\n    if (vehicle->GetCrowdActor()!= nullptr) {\n      // Check if the vehicle is in the crowd system.\n      if (vehicle->GetCrowdActor()->GetNavigation()->HasVehicleNear(distance, direction)) {\n        return true;\n      }\n    }\n  }\n#endif\n  return false;\n}", "CodeBleu_score": 37.403904337997126}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tbool found = false;\n\tauto it = m_walkers.find(id);\n\tif (it!= m_walkers.end()) {\n\t\tfound = true;\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\t\tm_crowd->queryNearestVehicle(it->second->m_agent, distance, direction);\n\t}\n\treturn found;\n}", "CodeBleu_score": 38.66598656844993}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// Check if the actor is in the walkers or vehicles map\n\tif (m_walkers.find(id)!= m_walkers.end()) {\n\t\t// Get the walker\n\t\tcarla::client::Walker* walker = m_walkers[id];\n\t\t// Enter a critical section\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\t\t// Compute the squared distance\n\t\tfloat sq_distance = direction.x * direction.x + direction.y * direction.y + direction.z * direction.z;\n\t\t// Check if a vehicle is nearby\n\t\treturn m_crowd->hasVehicleNear(walker->GetActor(), distance, sq_distance);\n\t} else if (m_vehicles.find(id)!= m_vehicles.end()) {\n\t\t// Get the vehicle\n\t\tcarla::client::Vehicle* vehicle = m_vehicles[id];\n\t\t// Enter a critical section\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\t\t// Compute the squared distance\n\t\tfloat sq_distance = direction.x * direction.x + direction.y * direction.y + direction.z * direction.z;\n\t\t// Check if a vehicle is nearby\n\t\treturn m_crowd->hasVehicleNear(vehicle->GetActor(), distance, sq_distance);\n\t}\n\t// If the actor is not found, return false\n\treturn false;\n}", "CodeBleu_score": 45.754381775765474}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto route = info.GetRoute();\n\tauto &event = route.GetCurrentEvent();\n\tif (event.GetEvent() == nullptr) {\n\t\treturn EventResult::Ok;\n\t}\n\tWalkerEventVisitor visitor(info.GetContext());\n\tauto result = boost::apply_visitor(visitor, event.GetEvent());\n\troute.Advance();\n\treturn result;\n}", "CodeBleu_score": 45.02561103376981}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tEventResult result;\n\tauto &current_point = info.route_points[info.current_route_point];\n\tauto event_visitor = WalkerEventVisitor(info.context, info.current_route_point, current_point.event_id, current_point.event_args, delta);\n\tboost::apply_visitor(event_visitor, current_point.event);\n\tresult = event_visitor.GetResult();\n\treturn result;\n}", "CodeBleu_score": 46.385806127094995}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tif (info.current_point < info.route.size()) {\n\t\tauto event = info.route[info.current_point];\n\t\tWalkerEventVisitor visitor(info, delta);\n\t\tboost::variant2::visit(visitor, event);\n\t\treturn visitor.GetResult();\n\t}\n\telse {\n\t\treturn EventResult::DONE;\n\t}\n}", "CodeBleu_score": 40.031770783238485}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n/*\n * Iterate through each road node, extract the road ID, and process each lane section within the lanes node.\n * For each lane section, retrieve the left, center, and right lane nodes and parse them using the ParseLanes method, updating the map builder accordingly.\n */\n    for (pugi::xml_node road_node : xml.children(\"road\")) {\n      const road::RoadId road_id = road_node.attribute(\"id\").as_int();\n      double s = 0.0;\n      for (pugi::xml_node section_node : road_node.children(\"section\")) {\n        const double s_offset = section_node.attribute(\"sOffset\").as_double();\n        s += s_offset;\n        ParseLanes(section_node, road_id, s, map_builder);\n      }\n    }\n  }", "CodeBleu_score": 36.68566237364554}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t//    std::cout << \"Parsing Lanes\" << std::endl;\n    for (pugi::xml_node road_node : xml.child(\"road\")) {\n      const int road_id = road_node.attribute(\"id\").as_int();\n      double s = 0.0;\n      for (pugi::xml_node road_node_section : road_node.children(\"section\")) {\n        const double s_offset = road_node_section.attribute(\"sOffset\").as_double();\n        s += s_offset;\n        ParseLanes(road_node_section, road_id, s, map_builder);\n      }\n    }\n  }", "CodeBleu_score": 36.43255053447218}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.currentCount <= info.totalCount) {\n\t\tif (info.currentCount == 0) {\n\t\t\t// This is the first time that we have received a match\n\t\t\t// Change the status to indicate the first connection\n\t\t\tm_isFirstConnection = true;\n\t\t}\n\t\tm_matchedCount = info.currentCount;\n\t} else {\n\t\t// Error! Mismatched count\n\t\tm_log(k_logError) << \"ERROR! Mismatched count received for writer \" << writer->get_datawriter_guid().to_string() << \" current count \" << info.currentCount << \" total count \" << info.totalCount << efd::endl;\n\t}\n}", "CodeBleu_score": 42.451031932126895}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.currentCountChange == 0) {\n\t\treturn;\n\t}\n\telse if (info.currentCountChange > 0) {\n\t\tif (m_isFirstConnection) {\n\t\t\tm_matchedCount = info.currentCountChange;\n\t\t\tm_isFirstConnection = false;\n\t\t}\n\t\telse {\n\t\t\tm_matchedCount += info.currentCountChange;\n\t\t}\n\t}\n\telse {\n\t\tm_matchedCount += info.currentCountChange;\n\t}\n\tif (m_matchedCount < 0) {\n\t\tm_matchedCount = 0;\n\t\tEFD_LOG(kLog_Error, \"CarlaListenerImpl::on_publication_matched - invalid currentCountChange: %d\", info.currentCountChange);\n\t}\n}", "CodeBleu_score": 51.047607807899}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.currentCount == 0) {\n\t\tif (info.currentCount == 0 && info.previousCount == 1) {\n\t\t\tm_firstConnection = true;\n\t\t}\n\t\tm_matchedCount = info.currentCount;\n\t\treturn;\n\t}\n\n\tif (info.currentCount == info.previousCount) {\n\t\treturn;\n\t}\n\n\tif (info.currentCount == info.previousCount + 1) {\n\t\tm_firstConnection = true;\n\t\tm_matchedCount = info.currentCount;\n\t\treturn;\n\t}\n\n\tif (info.currentCount == info.previousCount - 1) {\n\t\tm_matchedCount = info.currentCount;\n\t\treturn;\n\t}\n\n\tm_log->error(\"Publication matched status has changed for writer '%s' but the count change is not expected.\", writer->getName().c_str());\n}", "CodeBleu_score": 38.28104251720642}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 0) {\n\t\tstd::cout << \"Error: Invalid subscription matched status\" << std::endl;\n\t}\n\telse if (info.current_count_change > 0) {\n\t\tm_matchedCount += info.current_count_change;\n\t\tif (!m_firstConnected) {\n\t\t\tm_firstConnected = true;\n\t\t\tif (m_matchedCount >= m_ddsSubscriber->get_topic_count()) {\n\t\t\t\tstd::cout << \"All data reader match\" << std::endl;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tm_matchedCount += info.current_count_change;\n\t\tif (m_matchedCount == 0) {\n\t\t\tstd::cout << \"All data reader unmatch\" << std::endl;\n\t\t\tm_ddsSubscriber->delete_contained_entities();\n\t\t}\n\t}\n}", "CodeBleu_score": 55.82458800378215}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tm_matched_count++;\n\t\tif (info.current_count_change == 1) {\n\t\t\tm_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tm_matched_count--;\n\t\tif (m_matched_count == 0) {\n\t\t\tm_subscriber->delete_contained_entities();\n\t\t}\n\t} else {\n\t\tstd::stringstream error_message;\n\t\terror_message << \"Error: invalid subscription state: match_count = \" << m_matched_count << \" current_count_change = \" << info.current_count_change;\n\t\tm_logger->error(error_message.str());\n\t}\n}", "CodeBleu_score": 58.770583804531206}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 0) {\n\t\tstd::cerr << \"Error: Invalid change count\" << std::endl;\n\t\treturn;\n\t}\n\n\tif (info.current_count == 1) {\n\t\tm_first_connected = true;\n\t}\n\n\tm_matched_count += info.current_count_change;\n\n\tif (m_matched_count < 0) {\n\t\tm_matched_count = 0;\n\t}\n\n\tif (m_matched_count == 0 && m_first_connected) {\n\t\tstd::cerr << \"Error: No more matched subscriptions\" << std::endl;\n\t\treturn;\n\t}\n}", "CodeBleu_score": 49.14468428112405}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (force_md5) {\n\t\t// force_md5 is true and key retrieval is not defined for this type\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEventPubSubType::getKeyMaxCdrSerializedSize());\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS);\n\tp_type->serializeKey(ser);\n\tif (force_md5) {\n\t\tMD5(fastbuffer.getBuffer(), fastbuffer.getLength(), (unsigned char*)handle->value);\n\t\treturn true;\n\t}\n\telse if (p_type->getKeyMaxCdrSerializedSize() > 16) {\n\t\tmemcpy(handle->value, p_type->getKey(), CarlaCollisionEventPubSubType::getKeyMaxCdrSerializedSize());\n\t\treturn true;\n\t}\n\telse {\n\t\tmemcpy(handle->value, p_type->getKey(), p_type->getKeyMaxCdrSerializedSize());\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 47.623842828703786}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (force_md5) {\n\t\treturn getKeyMD5(data, handle);\n\t}\n\t// This function copies key data into the handle\n\treturn getKeyCopy(data, handle);\n}", "CodeBleu_score": 8.305583988688607}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (force_md5) {\n\t\treturn getKeyMD5(data, handle);\n\t}\n\treturn getKey(data, handle);\n}", "CodeBleu_score": 9.971037319283043}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tpayload->encapsulation = LE_BIG_ENDIAN;\n\tpayload->parentBuffer = reinterpret_cast<eprosima::fastcdr::FastBuffer*>(payload->buffer); // Cast to FastBuffer*\n\t// Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(static_cast<eprosima::fastcdr::FastBuffer*>(payload->buffer), static_cast<eprosima::fastcdr::Cdr::Endianness>(payload->endianness));\n\t// Serialize encapsulation\n\tser.serialize_encapsulation();\n\n\ttry\n\t{\n\t\t// Serialize the object.\n\t\tdata->serialize(ser);\n\t}\n\tcatch (eprosima::fastcdr::exception::Exception& /*exception*/)\n\t{\n\t\treturn false;\n\t}\n\n\t// Get the serialized length\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\treturn true;\n}", "CodeBleu_score": 58.670960121170964}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n\t\t\teprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE; // Set the correct encapsulation.\n\tser.serialize(p_type); // Serialize the object.\n\tpayload->length = (uint32_t)ser.getSerializedDataLength(); // Get the serialized length.\n\treturn true;\n}", "CodeBleu_score": 63.352215057634275}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\t// Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)\n\teprosima::fastcdr::Cdr ser(\n\t\tfastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,\n\t\teprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\t// Serialize encapsulation\n\tser.serialize_encapsulation();\n\n\ttry\n\t{\n\t\tp_type->serialize(ser); // Serialize the object:\n\t}\n\tcatch(eprosima::fastcdr::exception::Exception& /*exception*/)\n\t{\n\t\treturn false;\n\t}\n\n\tpayload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n\treturn true;\n}", "CodeBleu_score": 72.93366515807745}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// Check if the target is already set\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// Decode the MAVLink message\n\tmavlink_message_info_t info;\n\tmavlink_msg_get_message_info(msg, &info);\n\n\t// Check if the message type is one that should be tracked\n\tif (info.msgid!= MAVLINK_MSG_ID_HEARTBEAT && info.msgid!= MAVLINK_MSG_ID_SYS_STATUS && info.msgid!= MAVLINK_MSG_ID_SYS_INFO) {\n\t\treturn;\n\t}\n\n\t// Check if the target system ID is set\n\tif (info.sysid == 0) {\n\t\t// Set the target system ID to the target\n\t\tinfo.sysid = info.compid;\n\n\t\t// Request position and air pressure data streams from the target\n\t\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, info.sysid, info.compid, MAVLINK_MSG_ID_POSITION, 1, 1);\n\t\tmavlink_msg_request_data_stream_send(MAVLINK_COMM_0, info.sysid, info.compid, MAVLINK_MSG_ID_AIR_PRESSURE, 1, 1);\n\n\t\t// Flag that the target has been set\n\t\ttarget_set = true;\n\t}\n}", "CodeBleu_score": 35.508125116785486}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// Handle message with base class\n\tMAV_RESULT result = GCS_MAVLINK::GCS_MAVLINK_Tracker::handle_command_preflight_calibration_baro(msg);\n\n\t// Check result\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t// Set flag\n\t\t_baro_altitude_calibration_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 50.880041579746816}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\t// Handle message with base class\n\tMAV_RESULT result = GCS_MAVLINK::GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(msg);\n\n\t// If the result is ACCEPTED, set the flag\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_altitude_calibration_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 61.822267291575415}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK_Tracker::handle_command_preflight_calibration_baro(msg);\n\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_altitude_calibration_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 53.88850819301221}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 42.634872392902246}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 8.49187098396071}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0f) {\n\t\t// TODO: arm\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0f) {\n\t\t// TODO: disarm\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 42.85542361020984}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// iterate over all available GCS channels\n\tfor (int i = 0; i < NUM_GCS_CHANNELS; i++) {\n\t\t// check if there is available payload space\n\t\tif (gcs[i].get_available_payload_space() > 0) {\n\t\t\t// send a request to start the data stream on the channel with the specified update rate\n\t\t\tgcs[i].request_datastream_position(sysid, compid, 100);\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 29.820770897293936}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate through the available GCS channels\n\tfor (uint8_t i = 0; i < MAX_GCS_CHANNELS; i++) {\n\t\t// Check if the channel is available\n\t\tif (gcs_channels[i].available) {\n\t\t\t// Check if the channel has enough payload space\n\t\t\tif (gcs_channels[i].payload_space >= sizeof(mavlink_message_t)) {\n\t\t\t\t// Send a request to start the data stream on the channel with the specified update rate\n\t\t\t\trequest_datastream_position(i, sysid, compid);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 31.72506910459215}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i = 0; i < NUM_GCS_CHANNELS; i++) {\n\t\tif (gcs_channels[i].available_payload_space(sizeof(mavlink_message_t))) {\n\t\t\tgcs_channels[i].send_request_datastream_position(sysid, compid, MAV_DATA_STREAM_ALL, 10);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.9822210415542}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs.get_cos_pitch()!= 0.0f) {\n\t\tef_pitch = atan2(ahrs.get_sin_pitch(), ahrs.get_cos_pitch());\n\t\tef_yaw = yaw + ahrs.get_yaw();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 34.01681019316081}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (ahrs->get_pitch_cosine() == 0) {\n\t\treturn false;\n\t}\n\telse {\n\t\tef_pitch = atan(pitch / ahrs->get_pitch_cosine());\n\t\tef_yaw = yaw + ahrs->get_roll();\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 39.395433048284076}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tif (pitch == 0) {\n\t\treturn false;\n\t}\n\n\tfloat pitch_cos = cos(pitch);\n\tfloat pitch_sin = sin(pitch);\n\tfloat yaw_cos = cos(yaw);\n\tfloat yaw_sin = sin(yaw);\n\n\tfloat ef_pitch_cos = pitch_cos * yaw_cos;\n\tfloat ef_pitch_sin = pitch_sin * yaw_cos;\n\tfloat ef_yaw_cos = -pitch_sin * yaw_sin;\n\tfloat ef_yaw_sin = pitch_cos * yaw_sin;\n\n\tef_pitch = atan2(ef_pitch_sin, ef_pitch_cos);\n\tef_yaw = atan2(ef_yaw_sin, ef_yaw_cos);\n\n\treturn true;\n}", "CodeBleu_score": 32.63776328350709}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// if we are not tracking, then return\n\tif (!tracker.nav_status.tracking) {\n\t\treturn;\n\t}\n\t// if we are not tracking a target, then return\n\tif (tracker.nav_status.target_distance == 0) {\n\t\treturn;\n\t}\n\t// if we are not tracking a target, then return\n\tif (tracker.nav_status.target_distance < tracker.g.min_distance) {\n\t\treturn;\n\t}\n\t// if we are tracking a target, then calculate the pitch and yaw angles in centidegrees\n\tfloat pitch = tracker.nav_status.target_pitch;\n\tfloat yaw = tracker.nav_status.target_yaw;\n\n\t// calculate the direction of the target in earth frame\n\tbool direction_reversed = get_ef_yaw_direction();\n\n\t// calculate angle error in earth frame\n\tcalc_angle_error(pitch, yaw, direction_reversed);\n\n\t// if we are tracking a target, then update the pitch and yaw servos accordingly\n\tif (tracker.nav_status.target_distance > tracker.g.min_distance) {\n\t\t// if we are tracking a target, then update the pitch and yaw servos accordingly\n\t\tParameters &g = tracker.g;\n\t\tg.pidPitch2Srv.update_pid();\n\t\tg.pidYaw2Srv.update_pid();\n\t\ttracker.pitch_servo_out_filt.update(g.pidPitch2Srv.get_output());\n\t\ttracker.yaw_servo_out_filt.update(g.pidYaw2Srv.get_output());\n\t}\n}", "CodeBleu_score": 40.537913101919585}, {"code": "void Mode::update_auto(void){\n\t\t// get the current navigation status\n\tstruct Tracker::NavStatus &nav_status = tracker.nav_status;\n\t// get the current parameters\n\tParameters &g = tracker.g;\n\n\t// if we are not tracking or not tracking auto, return\n\tif (!nav_status.tracking ||!g.tracking_auto) {\n\t\treturn;\n\t}\n\n\t// if the target distance is invalid, return\n\tif (nav_status.target_distance < 0) {\n\t\treturn;\n\t}\n\n\t// if we are in tracking auto mode, check if we are close enough to the target\n\tif (nav_status.tracking_auto && nav_status.target_distance < g.min_distance) {\n\t\treturn;\n\t}\n\n\t// calculate the target pitch and yaw in centidegrees\n\tfloat target_pitch = nav_status.target_pitch * 100.0f;\n\tfloat target_yaw = nav_status.target_yaw * 100.0f;\n\n\t// check if the direction is reversed\n\tbool direction_reversed = get_ef_yaw_direction();\n\n\t// calculate the angle error\n\tcalc_angle_error(target_pitch, target_yaw, direction_reversed);\n\n\t// convert the angle error from earth frame to body frame\n\tfloat bf_pitch_err;\n\tfloat bf_yaw_err;\n\tconvert_ef_to_bf(nav_status.angle_error_pitch, nav_status.angle_error_yaw, bf_pitch_err, bf_yaw_err);\n\n\t// if the angle error is too large, return\n\tif (fabs(bf_pitch_err) > g.pitch_max || fabs(bf_yaw_err) > g.yaw_range) {\n\t\treturn;\n\t}\n\n\t// update the pitch and yaw servos\n\ttracker.update_pitch_servo(bf_pitch_err);\n\ttracker.update_yaw_servo(bf_yaw_err);\n}", "CodeBleu_score": 58.36598350293222}, {"code": "void Mode::update_auto(void){\n\t\t// get navigation status\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float target_distance = nav_status.distance;\n    float target_bearing = nav_status.bearing;\n    float target_pitch = nav_status.pitch;\n\n    // check if target distance is valid or no minimum distance is set\n    if (target_distance < 0 || target_distance < tracker.g.min_distance) {\n        return;\n    }\n\n    // check if target bearing is valid\n    if (target_bearing < 0) {\n        return;\n    }\n\n    // check if target pitch is valid\n    if (target_pitch < tracker.g.pitch_min || target_pitch > tracker.g.pitch_max) {\n        return;\n    }\n\n    // convert target pitch and bearing to earth frame\n    float target_pitch_ef;\n    float target_yaw_ef;\n    convert_bf_to_ef(target_pitch, target_bearing, target_pitch_ef, target_yaw_ef);\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error\n    calc_angle_error(target_pitch_ef, target_yaw_ef, direction_reversed);\n\n    // update pitch and yaw servos\n    update_pitch_servo();\n    update_yaw_servo();\n}", "CodeBleu_score": 53.809718894446235}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tif (gps.available()) {\n\t\tgps.read();\n\t\tif (gps.time.hour!= last_GPS_time.hour || gps.time.minute!= last_GPS_time.minute || gps.time.second!= last_GPS_time.second) {\n\t\t\tlast_GPS_time = gps.time;\n\t\t\tif (gps.fixquality >= 3) {\n\t\t\t\tif (gps_count == 0) {\n\t\t\t\t\thome_lat = gps.latitudeDegrees;\n\t\t\t\t\thome_lon = gps.longitudeDegrees;\n\t\t\t\t\thome_alt = gps.altitude;\n\t\t\t\t\tgps_count = 1000;\n\t\t\t\t}\n\t\t\t\telse if (gps_count > 0) {\n\t\t\t\t\tgps_count--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgps_count = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.841337206463876}, {"code": "void Tracker::update_GPS(void){\n\t\t// Update GPS data\n\tgps.update();\n\t// Check if the last message time has changed\n\tif (gps.time_last_message!= gps.time_last_message_old) {\n\t\t// Check if the GPS status is at least 3D fix\n\t\tif (gps.fixquality >= 3) {\n\t\t\t// Check if the home location is set\n\t\t\tif (home_location_set == false) {\n\t\t\t\t// Check if the ground start countdown has reached one\n\t\t\t\tif (ground_start_countdown == 1) {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\thome_location_set = true;\n\t\t\t\t\thome_location.latitude = gps.latitude;\n\t\t\t\t\thome_location.longitude = gps.longitude;\n\t\t\t\t\thome_location.altitude = gps.altitude;\n\t\t\t\t} else {\n\t\t\t\t\t// Decrement the ground start countdown\n\t\t\t\t\tground_start_countdown--;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Reset the home location\n\t\t\thome_location_set = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.65317078145948}, {"code": "void Tracker::update_GPS(void){\n\t", "CodeBleu_score": 1.8359599812427831}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t", "CodeBleu_score": 4.6194146543064525}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tpitch_onoff_servo.write(pitch);\n}", "CodeBleu_score": 9.580926579721885}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// check if the last message time has changed\n\tif (last_message_time!= time_since_boot_us()) {\n\t\t// update the last message time\n\t\tlast_message_time = time_since_boot_us();\n\n\t\t// update the GPS\n\t\tupdate_pitch_onoff_servo(pitch);\n\t}\n}", "CodeBleu_score": 14.686255480574015}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// call base class barometer checks\n\tif (!AP_Arming_MultiCopter::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check barometer altitude\n\tif (AP_Param::setup_check_bitmask(AP_Param::AP_PARAM_CHECK_BARO)) {\n\t\tfloat baro_alt = _barometer.get_altitude();\n\t\tfloat inav_alt = _inav.get_altitude();\n\n\t\tif (baro_alt - inav_alt > _baro_alt_max_disparity) {\n\t\t\tif (display_failure) {\n\t\t\t\t// log failure\n\t\t\t\t_failure_flags.set_and_notify(AP_ARMED_FAIL_BARO);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 32.26290451329995}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool ret = AP_Arming::barometer_checks(display_failure);\n\tif (ret && ARMING_CHECK_BARO && _ahrs.get_baro_alt() > _ahrs.get_inav_alt() + ARMING_CHECK_BARO_MAX_DIFF) {\n\t\tif (display_failure) {\n\t\t\t_failure_flags.set_and_alert(FAILFLAG_BARO_TOO_HIGH);\n\t\t}\n\t\tret = false;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 29.95147193137563}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// Call the base class's barometer_checks function\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// If the ARMING_CHECK_BARO is enabled\n\tif (APM_Arming::ARMING_CHECK_BARO) {\n\t\t// Check the barometer reference\n\t\tif (!_barometer_reference_ok) {\n\t\t\t// Log a failure\n\t\t\tif (display_failure) {\n\t\t\t\tap.console->printf_P(PSTR(\"BAROREF\n\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check the barometer altitude\n\t\tif (abs(_barometer_altitude - _inertial_altitude) > ARMING_BARO_ALT_THRESHOLD) {\n\t\t\t// Log a failure\n\t\t\tif (display_failure) {\n\t\t\t\tap.console->printf_P(PSTR(\"BAROALT\n\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 35.337914175652486}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_vehicle_status.terrain_source == Terrain_Source_Rangefinder) {\n\t\treturn false;\n\t}\n\n\tif (_vehicle_status.terrain_source == Terrain_Source_Terrain_Database) {\n\t\tif (_vehicle_status.rtl_altitude_type == RTL_Altitude_Terrain) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn AP_Arming_Base::terrain_database_required();\n}", "CodeBleu_score": 55.25895435488781}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_rangefinder_alt.get() == NULL) {\n\t\treturn false;\n\t}\n\n\tif (_rangefinder_alt->get_source() == RangefinderAltitude::SOURCE_TERRAIN_DB) {\n\t\tif (_rtl_alt_type == RTL_ALT_TYPE_TERRAIN) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn Arming::terrain_database_required();\n}", "CodeBleu_score": 49.336885570870564}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\t// If the terrain source is from a rangefinder, it returns false.\n\tif (_vehicle_status.rangefinder_status.rangefinder_type == RangefinderStatus::RangefinderType::RANGEFINDER_TYPE_NONE) {\n\t\treturn false;\n\t}\n\n\t// If the terrain source is from the terrain database and the RTL altitude type is terrain, it returns true.\n\tif (_vehicle_status.rangefinder_status.rangefinder_type == RangefinderStatus::RangefinderType::RANGEFINDER_TYPE_TERRAIN_DATABASE && _vehicle_status.rangefinder_status.rtl_altitude_type == RangefinderStatus::RtlAltitudeType::RTL_ALTITUDE_TYPE_TERRAIN) {\n\t\treturn true;\n\t}\n\n\t// Otherwise, it defers to the base class implementation of terrain_database_required.\n\treturn AP_Arming_Copter::terrain_database_required();\n}", "CodeBleu_score": 60.15134247403673}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// get the last loop time\n\tconst uint32_t now = hrt_absolute_time();\n\tconst uint32_t dt = now - _last_loop_time;\n\t_last_loop_time = now;\n\n\t// set the loop time for the rate controllers\n\t_rate_controller.set_loop_time(dt);\n\n\t// run the rate controllers\n\t_rate_controller.run();\n}", "CodeBleu_score": 49.064258213278045}, {"code": "void Copter::run_rate_controller(){\n\t\t// Get the last loop time from the scheduler\n\tfloat dt = _scheduler.dt;\n\n\t// Run the low-level rate controllers\n\t_attitude_control.rate_controller_run(dt);\n\n\t// Set the loop time for the high-level rate controllers\n\t_position_control.set_loop_time(dt);\n\t_altitude_control.set_loop_time(dt);\n\t_attitude_control.set_loop_time(dt);\n}", "CodeBleu_score": 50.54133125771213}, {"code": "void Copter::run_rate_controller(){\n\t\t// Run the rate controllers\n\trate_controller_run();\n}", "CodeBleu_score": 6.138967750472809}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// check if old location matches the waypoint\n\tif (!old_loc.is_equal(new_loc)) {\n\t\treturn false;\n\t}\n\n\t// check if old and new locations have the same altitude frames\n\tif (old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\treturn mode_guided.set_destination(new_loc);\n}", "CodeBleu_score": 55.99862334250116}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.get_frame()!= new_loc.get_frame() || old_loc.get_alt()!= new_loc.get_alt()) {\n\t\treturn false;\n\t}\n\n\treturn set_target_location(new_loc);\n}", "CodeBleu_score": 54.857534771902394}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// exit if the altitude frames of the old and new locations are not the same\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// exit if the old location is not the next waypoint location\n\tif (!old_loc.is_next_waypoint()) {\n\t\treturn false;\n\t}\n\n\t// set the new location as the target\n\treturn mode_guided.set_destination(new_loc);\n}", "CodeBleu_score": 51.32962560737383}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (get_mode()!= mode) {\n\t\t\tif (set_mode(mode)) {\n\t\t\t\t// reset the aux switch\n\t\t\t\trc().reset_mode_switch();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (get_mode() == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 54.93884654259804}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (get_mode() == mode) {\n\t\t\treset_mode_switch();\n\t\t} else {\n\t\t\tset_mode(mode);\n\t\t}\n\n\t} else if (get_mode() == mode) {\n\t\treset_mode_switch();\n\t}\n}", "CodeBleu_score": 45.3584884715666}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (get_mode()!= mode) {\n\t\t\tset_mode(mode);\n\t\t}\n\t} else if (get_mode() == mode) {\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 52.120672629821115}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// TODO: Implement Copter::save_trim\n}", "CodeBleu_score": 2.7694730809033348}, {"code": "void Copter::save_trim(){\n\t\t// TODO: Implement Copter::save_trim\n}", "CodeBleu_score": 2.7694730809033348}, {"code": "void Copter::save_trim(){\n\t\t// get the trim values from the control inputs\n\tfloat roll_trim = roll_trim_input - 1500.0f;\n\tfloat pitch_trim = pitch_trim_input - 1500.0f;\n\n\t// convert the trim values to radians\n\troll_trim *= (2.0f * M_PI / 3000.0f);\n\tpitch_trim *= (2.0f * M_PI / 3000.0f);\n\n\t// add the trim values to the AHRS trim\n\tahrs.trim_roll_pitch(roll_trim, pitch_trim);\n\n\t// log the event\n\tlog_event(MAV_SEVERITY_INFO, \"Trim saved\");\n\n\t// send a confirmation message\n\tmavlink_message_t msg;\n\tmavlink_msg_command_ack_pack(get_sysid(), get_compid(), &msg, 0, MAV_CMD_DO_SET_HOME, MAV_RESULT_ACCEPTED, 0, 0, 0, 0, 0, 0);\n\tsend_message(msg);\n}", "CodeBleu_score": 50.81924416297359}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Get the copter's velocity\n\tconst Vector3f velocity = _copter->get_velocity();\n\n\t// Calculate the speed squared\n\tconst float speed_squared = velocity.x() * velocity.x() + velocity.y() * velocity.y();\n\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, calculate the look-ahead yaw angle\n\tif (_copter->get_position().is_valid() && speed_squared > _look_ahead_yaw_min_speed_squared) {\n\t\t// Calculate the look-ahead yaw angle\n\t\t_look_ahead_yaw = atan2f(velocity.y(), velocity.x());\n\t}\n\n\t// Return the look-ahead yaw angle\n\treturn _look_ahead_yaw;\n}", "CodeBleu_score": 49.99497821596207}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat yaw = 0.0f;\n\n\t// Retrieve the copter's velocity\n\tVector3f velocity = _copter->get_velocity();\n\n\t// Calculate the speed squared\n\tfloat speed_squared = velocity.x() * velocity.x() + velocity.y() * velocity.y();\n\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (_copter->get_position().is_valid() && speed_squared > _min_speed_squared) {\n\t\tyaw = atan2f(velocity.y(), velocity.x());\n\t}\n\n\treturn yaw;\n}", "CodeBleu_score": 40.0314982626288}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Get the copter's velocity\n\tconst Vector3f velocity = _copter->velocity();\n\t// Calculate the speed squared\n\tconst float speed_squared = velocity.length_squared();\n\t// Check if the copter's position is valid\n\tif (_copter->position_is_valid() && speed_squared > _min_speed_squared) {\n\t\t// Calculate the look-ahead yaw angle using the arctangent of the velocity components\n\t\t_look_ahead_yaw = atan2f(velocity.y(), velocity.x());\n\t}\n\t// Return the computed look-ahead yaw angle\n\treturn _look_ahead_yaw;\n}", "CodeBleu_score": 48.61896428729656}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (_rudder_arming_disabled || _throttle_zero) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn AP_Arming_Multirotor::arm_checks(method);\n}", "CodeBleu_score": 28.050447212737595}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (rudder_arming_disabled || (throttle_zero &&!rudder_zero)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 29.0029682708864}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (rudder_arming_disabled || _throttle > 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn AP_Arming_Multirotor::arm_checks(method);\n}", "CodeBleu_score": 28.670478537719323}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool result = false;\n\tif (do_arming_checks) {\n\t\tresult = arm_checks(method);\n\t} else {\n\t\tresult = true;\n\t}\n\tif (result) {\n\t\t// set home location\n\t\tif (method == AP_Arming::Method::GPS) {\n\t\t\tahrs.set_home_location(plane.get_location());\n\t\t} else {\n\t\t\tahrs.set_home_location(plane.get_location());\n\t\t}\n\t\t// update current location\n\t\tplane.update_current_location();\n\t\t// change arm state\n\t\tchange_arm_state();\n\t\t// set delay arm flag\n\t\tdelay_arm = true;\n\t\t// send status text\n\t\tsend_status_text(AP_Arming::Status::Armed);\n\t}\n\treturn result;\n}", "CodeBleu_score": 44.26890952802693}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t#if HAL_QUADPLANE_ENABLED\n    if (plane.quadplane.get_armed()) {\n        return false;\n    }\n#endif\n    // if we are already armed, don't do anything\n    if (hal.util->get_arming_state()!= AP_Arming::ARMED) {\n        // if we are not armed, try to arm\n        if (arm_plane(method, do_arming_checks)) {\n            // if we armed successfully, update the home location and set it in the AHRS system\n            update_home_location();\n            ahrs.set_home_location(home_location);\n            // update the current location\n            update_current_location();\n            // change the arm state\n            change_arm_state();\n            // set a delay arming flag\n            delay_arming = true;\n            // send a status text indicating that the throttle is armed\n            hal.console->printf_P(PSTR(\"Armed\n\"));\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 51.09828489094238}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool ret = false;\n\tif (do_arming_checks) {\n\t\tif (do_arming_checks_before_arming(method)) {\n\t\t\tret = true;\n\t\t}\n\t} else {\n\t\tret = true;\n\t}\n\tif (ret) {\n\t\tif (method == AP_Arming::METHOD_GPS_HOME) {\n\t\t\t// set home location\n\t\t\tif (plane.gps->fix_home_location()) {\n\t\t\t\tplane.ahrs.set_home_location(plane.gps->get_location_lat(), plane.gps->get_location_lon());\n\t\t\t}\n\t\t} else if (method == AP_Arming::METHOD_BARO_HOME) {\n\t\t\t// set home location\n\t\t\tif (plane.barometer->get_home_location()) {\n\t\t\t\tplane.ahrs.set_home_location(plane.barometer->get_home_location_lat(), plane.barometer->get_home_location_lon());\n\t\t\t}\n\t\t}\n\t\t// update current location\n\t\tplane.gps->update();\n\t\tplane.ahrs.update();\n\t\t// arm\n\t\tplane.set_armed(true);\n\t\t// set delay arm flag\n\t\tplane.delay_arm_flag = true;\n\t\t// send status text\n\t\tplane.status_text_send_next_available(STATUS_TEXT_ID_ARMING);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 42.552364322090774}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// check if the vehicle is already armed\n\tif (vehicle_armed) {\n\t\treturn true;\n\t}\n\n\t// check if the vehicle has a disarm button assigned\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\t// display a failure message if requested\n\t\t\tfailure_message = \"No disarm button configured\";\n\t\t}\n\t\treturn false;\n\t}\n\n\t// call the parent class pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 69.60429907060421}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t#if CONFIG_APM_SUB_SYSTEM\n    if (AP_Arming::pre_arm_checks(display_failure)) {\n        return true;\n    }\n\n    // if we get here, the vehicle is not armed\n    if (!has_disarm_function) {\n        if (display_failure) {\n            // no disarm button configured, so display a failure message\n            AP_Notify::send_failure_message(AP_Notify::SUBSYSTEM_DISARMED);\n        }\n        return false;\n    }\n#endif\n    return true;\n}", "CodeBleu_score": 57.093834003833145}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t", "CodeBleu_score": 4.868891087689006}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * cos(yaw) + y * sin(yaw);\n\tfloat ne_y = -x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 53.18204260260693}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x, ne_y;\n\n\tne_x = x * cos(yaw) + y * sin(yaw);\n\tne_y = -x * sin(yaw) + y * cos(yaw);\n\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 50.92939002818311}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * cos(yaw) + y * sin(yaw);\n\tfloat ne_y = -x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 53.18204260260693}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT retval;\n\t// TODO: handle packet\n\n\tretval = MAV_RESULT_DENIED;\n\n\treturn retval;\n}", "CodeBleu_score": 13.467110228565677}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT retval = MAV_RESULT_DENIED;\n\n\tif (packet.param1 >= -180 && packet.param1 <= 180 && packet.param4 >= -180 && packet.param4 <= 180) {\n\t\tretval = MAV_RESULT_ACCEPTED;\n\t\t_yaw_setpoint = packet.param1;\n\t\t_yaw_rate_setpoint = packet.param4;\n\t}\n\n\treturn retval;\n}", "CodeBleu_score": 40.940616510792324}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT res = MAV_RESULT_DENIED;\n\tif (packet.param4 >= -180 && packet.param4 <= 180) {\n\t\t// Check if yaw angle is within acceptable range\n\t\tif (packet.param1 >= -180 && packet.param1 <= 180) {\n\t\t\t// Set yaw heading using provided parameters\n\t\t\t_yaw_heading = packet.param1;\n\t\t\t_yaw_speed = packet.param2;\n\t\t\t_yaw_direction = packet.param3;\n\t\t\t_yaw_relative = packet.param4;\n\t\t\tres = MAV_RESULT_ACCEPTED;\n\t\t}\n\t}\n\treturn res;\n}", "CodeBleu_score": 49.015013344115154}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn (uint8_t) (mavlink_msg_high_latency_tgt_heading_get_tgt_heading(msg));\n}", "CodeBleu_score": 7.308295177472815}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn mavlink_msg_high_latency_tgt_heading_get_tgt_heading(msg);\n}", "CodeBleu_score": 6.951057267164113}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn (uint8_t) ((control_mode == AUTO || control_mode == GUIDED)? (int16_t) (wp_bearing / 2) : 0);\n}", "CodeBleu_score": 29.02537766888218}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (Logging_Enabled) {\n\t\tLog_Packet packet;\n\t\tpacket.time = micros();\n\t\tpacket.data_id = id;\n\t\tpacket.value = value;\n\t\tLog_Write_Packet(packet);\n\t}\n}", "CodeBleu_score": 33.76151182287387}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif(log_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.time = HAL_GetTick();\n\t\tpacket.data_id = id;\n\t\tpacket.data = value;\n\t\tpacket.type = LOG_TYPE_INT32;\n\t\tHAL_CRITSECT_ENTER();\n\t\tHAL_LOG_WRITE_CRITICAL(packet);\n\t\tHAL_CRITSECT_EXIT();\n\t}\n}", "CodeBleu_score": 34.64966720494568}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (logger_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.id = id;\n\t\tpacket.time = xTaskGetTickCount();\n\t\tpacket.data = value;\n\t\txQueueSendToBack(logger_queue, &packet, 0);\n\t}\n}", "CodeBleu_score": 34.487824170530615}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_set) {\n\t\treturn;\n\t}\n\n\tif (armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 32.594786488584894}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (!is_home_set()) {\n\t\tif (is_armed()) {\n\t\t\tset_home_to_current_location_inflight();\n\t\t} else {\n\t\t\tset_home_to_current_location(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 29.369595123866514}, {"code": "void Sub::update_home_from_EKF(){\n\t#if defined(CONFIG_EKF2_AID_MASK) && defined(CONFIG_EKF2_HGT_MODE)\n    if (home_set) {\n        return;\n    }\n\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n#endif\n}", "CodeBleu_score": 46.22284675691463}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t\t// If the motors are not armed, set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit.\n\tif (!_motors.armed()) {\n\t\t_motors.set_throttle(0.0f);\n\t\t_motors.set_spool_state(SpoolState::UNLIMITED);\n\t\t_attitude_controller.relax();\n\t\treturn;\n\t}\n\n\t// If armed, set the spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run the attitude controller with these rates.\n\t_motors.set_spool_state(SpoolState::UNLIMITED);\n\t_attitude_controller.set_desired_body_rates(_pilot.get_body_rates());\n\t_attitude_controller.run();\n\n\t// Output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls.\n\t_motors.set_throttle(_pilot.get_throttle_input() * _attitude_controller.get_throttle_boost());\n\t_motors.set_forward_motor_input(_pilot.get_forward_motor_input());\n\t_motors.set_lateral_motor_input(_pilot.get_lateral_motor_input());\n}", "CodeBleu_score": 44.61314003907043}, {"code": "void ModeAcro::run(){\n\t\t//If the motors are not armed, set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit.\n\tif (!_armed) {\n\t\t_throttle = 0;\n\t\t_spool.setSpoolState(Spool::SpoolState::UNLIMITED_THROTTLE);\n\t\t_attitudeController.relax();\n\t\treturn;\n\t}\n\n\t//If armed, set the spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run the attitude controller with these rates.\n\t_spool.setSpoolState(Spool::SpoolState::UNLIMITED_THROTTLE);\n\t_attitudeController.setDesiredRates(_pilot.getRollRate(), _pilot.getPitchRate(), _pilot.getHeadingRate());\n\t_attitudeController.run();\n\n\t//Output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls.\n\t_throttle = _pilot.getThrottle();\n\t_motor.setForward(_throttle + _pilot.getForward());\n\t_motor.setLateral(_throttle + _pilot.getLateral());\n}", "CodeBleu_score": 40.22955726523956}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\n//    // set position control mode\n//    set_mode(POSITION);\n//\n//    // initialize the waypoint controller\n//    wp_control.init();\n//\n//    // set the waypoint destination to the stopping point\n//    // this will be set to the current position if the stopping point is not set\n//    // the waypoint controller will then take care of the rest\n//    wp_control.set_destination(g.stopping_point_WP);\n//\n//    // set the auto yaw mode\n//    set_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 3.006399650678141}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t", "CodeBleu_score": 2.656653974022399}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set mode\n\tset_mode(MODE_GUIDED_POS);\n\t// initialize waypoint controller\n\twp_control.init();\n\t// set destination to stopping point\n\twp_control.set_destination(g.stopping_point_WP);\n\t// set auto yaw mode to default\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 27.691075388399277}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set guided mode to velocity controller\n\tsub.guided_mode = GUIDED_VELOCITY_CONTROL;\n\n\t// initialize vertical maximum speeds and acceleration\n\tsub.v_max_up = pilot_params.guided_v_max_up;\n\tsub.v_max_down = pilot_params.guided_v_max_down;\n\tsub.v_max_up_rate = pilot_params.guided_v_max_up_rate;\n\tsub.v_max_down_rate = pilot_params.guided_v_max_down_rate;\n\tsub.v_max_up_accel = pilot_params.guided_v_max_up_accel;\n\tsub.v_max_down_accel = pilot_params.guided_v_max_down_accel;\n\n\t// initialize vertical and horizontal velocity controllers\n\tv_control.init_params(pilot_params.guided_v_control_kp, pilot_params.guided_v_control_ki, pilot_params.guided_v_control_kd, pilot_params.guided_v_control_min_err, pilot_params.guided_v_control_min_rate, pilot_params.guided_v_control_min_accel);\n\th_control.init_params(pilot_params.guided_h_control_kp, pilot_params.guided_h_control_ki, pilot_params.guided_h_control_kd, pilot_params.guided_h_control_min_err, pilot_params.guided_h_control_min_rate, pilot_params.guided_h_control_min_accel);\n\n\t// set yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tsub.auto_yaw_mode = AUTO_YAW_HOLD;\n}", "CodeBleu_score": 33.037468456970146}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set guided mode to velocity control\n\tsub.guided_mode = GUIDED_MODE_VELOCITY;\n\n\t// initialize vertical maximum speeds and acceleration\n\tsub.max_vertical_speed = pilot_params.max_vertical_speed;\n\tsub.max_vertical_accel = pilot_params.max_vertical_accel;\n\n\t// initialize vertical and horizontal velocity controllers\n\tvel_controller.set_params(pilot_params.max_vertical_speed, pilot_params.max_vertical_accel);\n\thoriz_vel_controller.set_params(pilot_params.max_horizontal_speed, pilot_params.max_horizontal_accel);\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 40.92376992049178}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialize vertical maximum speeds and acceleration using pilot-defined parameters\n\tsub.v_max = pilot_v_max;\n\tsub.v_min = pilot_v_min;\n\tsub.a_max = pilot_a_max;\n\tsub.a_min = pilot_a_min;\n\n\t// initialize the vertical and horizontal velocity controllers\n\tv_control.set_parameters(sub.v_max, sub.v_min, sub.a_max, sub.a_min);\n\th_control.set_parameters(sub.v_max, sub.v_min, sub.a_max, sub.a_min);\n\n\t// set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 26.04913138105125}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// TODO: Implement guided_limit_check()\n\treturn false;\n}", "CodeBleu_score": 2.0176401258941974}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if the timeout has been exceeded\n\tif (_params.timeout_s > 0 && _time_last_guided_command_ms > 0 && (hrt_absolute_time() - _time_last_guided_command_ms) > _params.timeout_s * 1000) {\n\t\tPX4_WARN(\"Timeout exceeded\");\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is below the minimum threshold\n\tif (_params.min_altitude_m > 0 && _local_position_sub.get().alt < _params.min_altitude_m) {\n\t\tPX4_WARN(\"Minimum altitude exceeded\");\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is above the maximum threshold\n\tif (_params.max_altitude_m > 0 && _local_position_sub.get().alt > _params.max_altitude_m) {\n\t\tPX4_WARN(\"Maximum altitude exceeded\");\n\t\treturn true;\n\t}\n\n\t// Check if the horizontal distance moved exceeds the specified limit\n\tif (_params.max_horizontal_distance_m > 0 && _local_position_sub.get().xy_error < _params.max_horizontal_distance_m) {\n\t\tPX4_WARN(\"Maximum horizontal distance exceeded\");\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false\n\treturn false;\n}", "CodeBleu_score": 42.907944656430715}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if timeout has been exceeded\n\tif (hrt_elapsed_time(&_guided_timeout) > _params->guided_timeout) {\n\t\treturn true;\n\t}\n\n\t// Check if current altitude is below minimum altitude\n\tif (_current_position.alt < _params->guided_min_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if current altitude is above maximum altitude\n\tif (_current_position.alt > _params->guided_max_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if horizontal distance moved exceeds limit\n\tif (sqrtf(_current_position.x * _current_position.x + _current_position.y * _current_position.y) > _params->guided_max_distance) {\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false\n\treturn false;\n}", "CodeBleu_score": 32.756555687886376}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t", "CodeBleu_score": 3.6872060888959766}, {"code": "bool Sub::verify_motor_test(){\n\t\tif (motor_test_start_time.is_zero()) {\n\t\tmotor_test_start_time = hrt_absolute_time();\n\t}\n\tif (motor_test_start_time.time_since(hrt_absolute_time()) < 2000000) {\n\t\treturn true;\n\t}\n\n\tif (motor_test_start_time.time_since(hrt_absolute_time()) > 10000000) {\n\t\t//send timeout message\n\t\tsend_message(Message::Type::MOTOR_TEST_TIMEOUT, 0, 0);\n\t\tmotor_test_pass = false;\n\t\tmotor_test_start_time = hrt_absolute_time();\n\t\tdisable_motor_test();\n\t\tdisarm();\n\t\tmotor_test_failure_time = hrt_absolute_time();\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 46.23631175569134}, {"code": "bool Sub::verify_motor_test(){\n\t\t//check if motor test requests are received at least every 2 Hz\n\tif (motor_test_requests.size() < 2) {\n\t\t//send a timeout message\n\t\tsend_timeout_message();\n\t\t//set the pass flag to false\n\t\tpass = false;\n\t\t//disable the motor test\n\t\tmotor_test_enabled = false;\n\t\t//disarm the system\n\t\tdisarm();\n\t\t//record the failure time\n\t\tfailure_time = ros::Time::now();\n\t\t//return false\n\t\treturn false;\n\t}\n\t//if the test passes, return true\n\treturn true;\n}", "CodeBleu_score": 19.136810223357756}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// get the roll and pitch targets from wp_nav\n\tfloat roll_target = wp_nav.roll_target;\n\tfloat pitch_target = wp_nav.pitch_target;\n\n\t// constrain the roll and pitch targets within the maximum angle range\n\tif (roll_target > MAX_ROLL) {\n\t\troll_target = MAX_ROLL;\n\t} else if (roll_target < -MAX_ROLL) {\n\t\troll_target = -MAX_ROLL;\n\t}\n\tif (pitch_target > MAX_PITCH) {\n\t\tpitch_target = MAX_PITCH;\n\t} else if (pitch_target < -MAX_PITCH) {\n\t\tpitch_target = -MAX_PITCH;\n\t}\n\n\t// normalize the roll and pitch targets\n\tfloat roll_target_norm = roll_target / MAX_ROLL;\n\tfloat pitch_target_norm = pitch_target / MAX_PITCH;\n\n\t// assign the normalized values to lateral_out and forward_out\n\tlateral_out = roll_target_norm;\n\tforward_out = pitch_target_norm;\n}", "CodeBleu_score": 36.6603246741624}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = 0.0f;\n\tfloat pitch_target = 0.0f;\n\tfloat roll_max = 0.0f;\n\tfloat pitch_max = 0.0f;\n\n\tif (wp_nav.roll_max_deg > 0.0f) {\n\t\troll_max = wp_nav.roll_max_deg * 10.0f;\n\t} else {\n\t\troll_max = 100.0f;\n\t}\n\n\tif (wp_nav.pitch_max_deg > 0.0f) {\n\t\tpitch_max = wp_nav.pitch_max_deg * 10.0f;\n\t} else {\n\t\tpitch_max = 100.0f;\n\t}\n\n\tif (wp_nav.roll_target_deg > 0.0f) {\n\t\troll_target = wp_nav.roll_target_deg * 10.0f;\n\t}\n\n\tif (wp_nav.pitch_target_deg > 0.0f) {\n\t\tpitch_target = wp_nav.pitch_target_deg * 10.0f;\n\t}\n\n\tfloat roll_norm = 0.0f;\n\tfloat pitch_norm = 0.0f;\n\n\tif (roll_target > 0.0f) {\n\t\troll_norm = roll_target / roll_max;\n\t}\n\n\tif (pitch_target > 0.0f) {\n\t\tpitch_norm = pitch_target / pitch_max;\n\t}\n\n\tif (roll_norm > 1.0f) {\n\t\troll_norm = 1.0f;\n\t}\n\n\tif (pitch_norm > 1.0f) {\n\t\tpitch_norm = 1.0f;\n\t}\n\n\tif (roll_norm < -1.0f) {\n\t\troll_norm = -1.0f;\n\t}\n\n\tif (pitch_norm < -1.0f) {\n\t\tpitch_norm = -1.0f;\n\t}\n\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 36.201407587809015}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav_roll;\n\tfloat pitch_target = wp_nav_pitch;\n\n\t// constrain roll and pitch targets within the maximum angle range\n\tif (roll_target > roll_max) {\n\t\troll_target = roll_max;\n\t} else if (roll_target < -roll_max) {\n\t\troll_target = -roll_max;\n\t}\n\tif (pitch_target > pitch_max) {\n\t\tpitch_target = pitch_max;\n\t} else if (pitch_target < -pitch_max) {\n\t\tpitch_target = -pitch_max;\n\t}\n\n\t// normalize roll and pitch targets\n\tfloat roll_norm = roll_target / roll_max;\n\tfloat pitch_norm = pitch_target / pitch_max;\n\n\t// assign normalized values to lateral_out and forward_out\n\tlateral_out = roll_norm;\n\tforward_out = pitch_norm;\n}", "CodeBleu_score": 30.63703666289767}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\t// TODO: Add code here\n}", "CodeBleu_score": 2.7652140501199507}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer_calibration_ok) {\n\t\tif (barometer_calibration_ok && barometer_altitude_cm > 0) {\n\t\t\tbarometer_calibration_ok = false;\n\t\t\tbarometer_altitude_cm = 0;\n\t\t}\n\t} else {\n\t\tif (barometer_altitude_cm > 0) {\n\t\t\tbarometer_calibration_ok = true;\n\t\t}\n\t}\n\n\tif (depth_sensor_present) {\n\t\tif (barometer_altitude_cm > 0) {\n\t\t\tdepth_sensor_health = 1;\n\t\t} else {\n\t\t\tdepth_sensor_health = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.18992989034582}, {"code": "void Sub::read_barometer(){\n\t\tif (_barometer_sub.updated()) {\n\t\t// copy barometer data into local variable to allow the callback to clear the updated flag\n\t\torb_copy(ORB_ID(sensor_baro), _barometer_sub, &_barometer);\n\n\t\tif (_barometer.alt > 0) {\n\t\t\t// update calibration\n\t\t\t_barometer_calibration.update(_barometer.alt);\n\t\t}\n\n\t\tif (_depth_sensor_sub.updated()) {\n\t\t\t// copy depth sensor data into local variable to allow the callback to clear the updated flag\n\t\t\torb_copy(ORB_ID(sensor_depth), _depth_sensor_sub, &_depth_sensor);\n\n\t\t\tif (_depth_sensor.health_mains > 0) {\n\t\t\t\t// update sensor health\n\t\t\t\t_depth_sensor_health.update(_depth_sensor.health_mains);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.855201712188325}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\t// TODO: Implement\n\treturn false;\n}", "CodeBleu_score": 5.492677746086194}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// Check if inertial navigation is available\n\tif (_inertial_navigation_available) {\n\t\t// Check if the motors are disarmed\n\t\tif (!_motors_armed) {\n\t\t\t// Return true if the EKF is not in constant position mode\n\t\t\treturn (_ekf_pos_h_mode!= EKF_POS_H_MODE_CONST_POS);\n\t\t} else {\n\t\t\t// Return true if the EKF is not in constant position mode and the EKF is not in a bad state\n\t\t\treturn (_ekf_pos_h_mode!= EKF_POS_H_MODE_CONST_POS) && (_ekf_pos_h_bad_state == false);\n\t\t}\n\t} else {\n\t\t// Return true if the EKF is not in constant position mode\n\t\treturn (_ekf_pos_h_mode!= EKF_POS_H_MODE_CONST_POS);\n\t}\n}", "CodeBleu_score": 24.395479988687445}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (vehicle_status.in_air_frame!= 1) {\n\t\treturn false;\n\t}\n\n\tif (vehicle_status.armed_frame!= 1) {\n\t\treturn true;\n\t}\n\n\tif (vehicle_status.mode_frame!= 1) {\n\t\treturn false;\n\t}\n\n\tif (vehicle_status.ekf_ok_frame!= 1) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 37.325592541921736}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (!_gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if the AHRS system is ready\n\tif (ahrs_system_ready()) {\n\t\t// check if the EKF failsafe is active\n\t\tif (!ekf_failsafe_active()) {\n\t\t\t// check if the position estimate is valid\n\t\t\tif (check_position_valid()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 13.486307953955814}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (control_mode!= Control_Mode::GPS_POSITION_HOLD) {\n\t\treturn true;\n\t}\n\n\t// Call the parent class's GPS checks\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// Check if the AHRS system is ready\n\tif (!ahrs.healthy()) {\n\t\tif (display_failure) {\n\t\t\tap_message(MSG_WARNING, \"AHRS system is not ready\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Check if the EKF failsafe is active\n\tif (ekf_failsafe_active) {\n\t\tif (display_failure) {\n\t\t\tap_message(MSG_WARNING, \"EKF failsafe is active\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Check if the position estimate is valid\n\tif (!ahrs.get_position_valid()) {\n\t\tif (display_failure) {\n\t\t\tap_message(MSG_WARNING, \"Position estimate is not valid\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// All checks pass\n\treturn true;\n}", "CodeBleu_score": 50.248722957142576}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (AP_Arming_Base::gps_checks(display_failure)) {\n\t\tif (AP_InertialSensor::get_ahrs()->get_ready() && _ahrs->get_failsafe()) {\n\t\t\tif (_ahrs->get_position_ok()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif (display_failure) {\n\t\t\t\t\tdisplay_gps_failure(GPS_FAIL_NO_POSITION);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (display_failure) {\n\t\t\t\tdisplay_gps_failure(GPS_FAIL_AHRS_NOT_READY);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 30.201317313744013}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t#ifdef DEBUG\n    if (charging_enabled!= charging_allowed) {\n        log(INFO, \"Charging state changed from %s to %s\", charging_enabled? \"enabled\" : \"disabled\", charging_allowed? \"enabled\" : \"disabled\");\n    }\n#endif\n    if (charging_enabled &&!charging_allowed) {\n        log(INFO, \"Disabling charging\");\n        charging_enabled = false;\n        disableCharging();\n        charging_disabled_time = millis();\n    } else if (!charging_enabled && charging_allowed) {\n        log(INFO, \"Enabling charging\");\n        charging_enabled = true;\n        enableCharging();\n        charging_disabled_time = 0;\n    } else if (charging_enabled && charging_allowed) {\n        if (shouldDisableCharging()) {\n            log(INFO, \"Disabling charging\");\n            charging_enabled = false;\n            disableCharging();\n            charging_disabled_time = millis();\n        }\n    }\n}", "CodeBleu_score": 52.31991481246686}, {"code": "void updateChargingEnabled(){\n\t#ifdef DEBUG_PRINT\n    Serial.print(\"Charging enabled: \");\n    Serial.println(charging_enabled);\n#endif\n    if (charging_enabled &&!charging_allowed) {\n        charging_enabled = false;\n        charging_disabled_time = millis();\n        charging_disabled_time_set = true;\n    } else if (!charging_enabled && charging_allowed) {\n        if (millis() - charging_disabled_time >= charging_disabled_time_delay) {\n            charging_enabled = true;\n            charging_disabled_time_set = false;\n        }\n    }\n}", "CodeBleu_score": 44.73869260568761}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed &&!checkShouldCharge()) {\n\t\tif (charging_enabled) {\n\t\t\tROS_INFO(\"Disabling charging\");\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_disabled_time = ros::Time::now();\n\t\t}\n\t} else if (!charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tROS_INFO(\"Disabling charging\");\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_disabled_time = ros::Time::now();\n\t\t}\n\t} else if (!charging_enabled) {\n\t\tif (ros::Time::now() - charging_disabled_time > ros::Duration(charging_retry_delay)) {\n\t\t\tROS_INFO(\"Enabling charging\");\n\t\t\tcharging_enabled = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 41.372338451797575}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t", "CodeBleu_score": 2.8647586569068038}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::running() && size >= 4) {\n\t\tuint16_t crc = crc16_ccitt(message, size);\n\t\tuint8_t *message_ = (uint8_t*) message;\n\t\tmessage_[size] = crc & 0xFF;\n\t\tmessage_[size + 1] = (crc >> 8) & 0xFF;\n\t\tpacketSerial.write(message_, size + 2);\n\t}\n}", "CodeBleu_score": 55.89735915955008}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::running() && size >= 4) {\n\t\tuint16_t crc = crc16(message, size);\n\t\tuint8_t crc_msb = crc >> 8;\n\t\tuint8_t crc_lsb = crc & 0x00FF;\n\t\tuint8_t *message_with_crc = (uint8_t*) malloc(size + 2);\n\t\tmemcpy(message_with_crc, message, size);\n\t\tmessage_with_crc[size] = crc_msb;\n\t\tmessage_with_crc[size + 1] = crc_lsb;\n\t\tpacketSerial.write(message_with_crc, size + 2);\n\t\tfree(message_with_crc);\n\t}\n}", "CodeBleu_score": 44.565284641029706}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\tSerial.begin(9600);\n\twhile (!Serial) {\n\t\t; // wait for serial port to connect. Needed for native USB port only\n\t}\n\tSerial.println(\"Initializing SD card...\");\n\tif (!SD.begin(SD_CS)) {\n\t\tSerial.println(\"initialization failed!\");\n\t\treturn false;\n\t}\n\tSerial.println(\"initialization done.\");\n\n\tmp3.begin(SD_CS);\n\tmp3.setVolume(volume);\n\tmp3.setEQ(0);\n\tmp3.setLoop(0);\n\tmp3.setShuffle(0);\n\tmp3.setRepeat(0);\n\tmp3.setDAC(1);\n\tmp3.setDecoder(0);\n\tmp3.setDAC(0);\n\n\tif (mp3.getFiles()) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 45.742990721080744}, {"code": "bool MP3Sound::begin(){\n\t\t// Initialize serial communication\n\tSerial.begin(115200);\n\t// Clear any existing data in the buffer\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\t// Initialize sound module\n\tSerial.println(\"AT+RESET\");\n\t// Wait for the sound module to initialize\n\tdelay(1000);\n\t// Retrieve the number of sound files available on the SD card\n\tSerial.println(\"AT+GET_FILE_NUM\");\n\t// Wait for the sound module to respond\n\tdelay(1000);\n\t// Check if the sound module responded\n\tif (Serial.available()) {\n\t\t// Read the number of sound files available\n\t\tnumSoundFiles = Serial.parseInt();\n\t\t// Check if there are one or more sound files available\n\t\tif (numSoundFiles > 0) {\n\t\t\t// Return true to indicate successful initialization\n\t\t\treturn true;\n\t\t}\n\t}\n\t// Return false to indicate failed initialization\n\treturn false;\n}", "CodeBleu_score": 48.0922960567794}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (mp3Player.isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\tif (activeSounds.size() > 0) {\n\t\tmp3Player.playMP3(activeSounds.back()->getMP3());\n\t\tactiveSounds.pop_back();\n\t\treturn activeSounds.size();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 38.94805868764229}, {"code": "int MP3Sound::processSounds(){\n\t\tint activeSounds = 0;\n\t// If there are no sounds, return 0\n\tif (sounds.empty()) {\n\t\treturn 0;\n\t}\n\t// If an MP3 is currently playing, return the number of active sounds\n\tif (mp3Playing) {\n\t\treturn sounds.size();\n\t}\n\t// Retrieve and play the last sound from the active sounds list\n\t// Remove it from the list\n\tSound* sound = sounds.back();\n\tsounds.pop_back();\n\tplaySound(sound);\n\tactiveSounds = sounds.size();\n\treturn activeSounds;\n}", "CodeBleu_score": 46.47320186356207}, {"code": "int MP3Sound::processSounds(){\n\t\t// If there are no sounds, return 0\n\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\n\t// If an MP3 is playing, return the number of active sounds\n\tif (mp3IsPlaying) {\n\t\treturn activeSounds.size();\n\t}\n\n\t// If an MP3 is not playing, play the last sound from the list\n\tSound* sound = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplaySound(sound);\n\n\t// Return the updated number of active sounds\n\treturn activeSounds.size();\n}", "CodeBleu_score": 39.90263541914523}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tbool command_handled = false;\n\tif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n\t\tif (d->memory_mapped_file)\n\t\t\tfree(d->memory_mapped_file);\n\t\td->memory_mapped_file = wb_request_get_memory_mapped_file(r);\n\t\tcommand_handled = true;\n\t}\n\treturn command_handled;\n}", "CodeBleu_score": 45.513464216887265}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t}", "CodeBleu_score": 6.617871250854342}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      wb_abstract_camera_handle_memory_mapped_file_command(d, r);\n      break;\n    default:\n      wb_request_set_command_handled(r, false);\n      break;\n  }\n  return wb_request_get_command_handled(r);\n#else\n  wb_request_set_command_handled(r, false);\n  return false;\n#endif\n}", "CodeBleu_score": 51.49767221070191}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint height = -1;\n\tif (d) {\n\t\tWbDeviceTag tag = wb_device_get_tag(d);\n\t\tif (tag) {\n\t\t\tWbCamera *camera = (WbCamera *)tag;\n\t\t\tif (camera) {\n\t\t\t\tpthread_mutex_lock(&camera->mutex);\n\t\t\t\theight = camera->height;\n\t\t\t\tpthread_mutex_unlock(&camera->mutex);\n\t\t\t}\n\t\t}\n\t}\n\treturn height;\n}", "CodeBleu_score": 41.92858090424196}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tAbstractCamera *camera = (AbstractCamera *)wb_device_get_user_data(d);\n\tint height;\n\tif (!camera)\n\t\treturn -1;\n\tif (camera->height == -1)\n\t\treturn -1;\n\tpthread_mutex_lock(&camera->mutex);\n\theight = camera->height;\n\tpthread_mutex_unlock(&camera->mutex);\n\treturn height;\n}", "CodeBleu_score": 39.4897600113207}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tWbDeviceTag tag = wb_device_get_tag(d);\n\tWbCamera *camera = (WbCamera *) wb_device_get_user_data(d);\n\tint height;\n\tif (camera->image == NULL)\n\t\treturn -1;\n\tpthread_mutex_lock(&camera->mutex);\n\theight = camera->image->height;\n\tpthread_mutex_unlock(&camera->mutex);\n\treturn height;\n}", "CodeBleu_score": 36.619245693790624}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint samplingPeriod;\n\taccelerometer *acc = (accelerometer *) wb_device_get_user_data(tag);\n\tif (acc == NULL) {\n\t\tfprintf(stderr, \"wb_accelerometer_get_sampling_period: invalid device tag.\n\");\n\t\treturn -1;\n\t}\n\tpthread_mutex_lock(&acc->mutex);\n\tsamplingPeriod = acc->samplingPeriod;\n\tpthread_mutex_unlock(&acc->mutex);\n\treturn samplingPeriod;\n}", "CodeBleu_score": 47.656624683722335}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\taccelerometer_t *accelerometer = (accelerometer_t *) wb_device_get_node(tag);\n\tif (accelerometer == NULL) {\n\t\tfprintf(stderr, \"accelerometer_get_sampling_period: invalid device tag\n\");\n\t\treturn 0;\n\t}\n\twb_mutex_lock(accelerometer->mutex);\n\tint sampling_period = accelerometer->sampling_period;\n\twb_mutex_unlock(accelerometer->mutex);\n\treturn sampling_period;\n}", "CodeBleu_score": 46.96997776338927}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tAccelerometer *accelerometer = getAccelerometer(tag);\n\tif (accelerometer == NULL) {\n\t\tfprintf(stderr, \"wb_accelerometer_get_sampling_period: invalid device tag.\n\");\n\t\treturn -1;\n\t}\n\tint samplingPeriod = accelerometer->samplingPeriod;\n\tunlockMutex(accelerometer);\n\treturn samplingPeriod;\n}", "CodeBleu_score": 34.62521679201574}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString;\n\tdmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms = dmsString;\n\tfree(dmsString);\n\treturn dms;\n}", "CodeBleu_score": 44.09988095662766}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = NULL;\n\twb_gps_convert_to_degrees_minutes_seconds(decimalDegree, &dmsString);\n\tstring dms(dmsString);\n\tfree(dmsString);\n\treturn dms;\n}", "CodeBleu_score": 43.56715972725267}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tstring dms;\n\tchar *dms_string = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree, &dms);\n\tdms = dms_string;\n\tfree(dms_string);\n\treturn dms;\n}", "CodeBleu_score": 43.09259345141183}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdVector3 pos;\n\tdVector3 normal;\n\tdReal dist;\n\tdGeomBoxData *box;\n\n\tbox = (dGeomBoxData*) dGeomGetData (g);\n\tdGeomBoxPointDepth (g, x, y, z, pos, &dist);\n\tdBoxGetClosestAxis (box, pos, normal);\n\tdVectorSet (plane, normal[0], normal[1], normal[2], dist);\n}", "CodeBleu_score": 14.897862047681476}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdVector3 normal;\n\tdReal dist;\n\tdGeomBoxGetParams (g, &normal[0], &dist);\n\tdVector3 p;\n\tp[0] = x;\n\tp[1] = y;\n\tp[2] = z;\n\tdVector3 rel;\n\tdSubtractVectors3 (rel, p, normal);\n\tdReal d = dVector3Length (rel);\n\tif (d < 0.00001) {\n\t\td = 0.0;\n\t} else {\n\t\td = d / d;\n\t}\n\tdVector3Set (plane, normal[0], normal[1], normal[2], d);\n}", "CodeBleu_score": 18.050527460999813}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdImmersionGeom immersed;\n\tdImmersionGeom *immersedPtr = &immersed;\n\tint immersedResult;\n\tdImmersionGeom *immersedPtrPtr = &immersedPtr;\n\n\tif (box == NULL || fluidPlane == NULL) {\n\t\treturn 0;\n\t}\n\tif (box->body == NULL || flags == 0) {\n\t\treturn 0;\n\t}\n\timmersedResult = dImmerseGeom (box, fluidPlane, flags, immersedPtrPtr);\n\tif (immersedResult) {\n\t\tif (immersion!= NULL) {\n\t\t\t*immersion = *immersedPtr;\n\t\t}\n\t}\n\treturn immersedResult;\n}", "CodeBleu_score": 39.84380102004862}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t#ifdef dDOUBLE\n  dVector3 fluidPlane_d;\n  dCopyVector3 (fluidPlane, fluidPlane_d);\n  return dImmerseBox (box, fluidPlane_d, flags, immersion);\n#else\n  dVector3 fluidPlane_f;\n  dCopyVector3 (fluidPlane, fluidPlane_f);\n  return dImmerseBox (box, fluidPlane_f, flags, immersion);\n#endif\n}", "CodeBleu_score": 41.129798070771606}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT(o1->type == dBoxClass, \"First object must be a box\");\n\tdUASSERT(o2->type == dCapsuleClass, \"Second object must be a capsule\");\n\n\tdxBox *box = (dxBox *) o1;\n\tdxCapsule *capsule = (dxCapsule *) o2;\n\n\t// Check for collisions\n\tdVector3 fluidPlane;\n\tif (dCollideBoxCapsule (box, capsule, fluidPlane)) {\n\t\t// Set the immersion parameters\n\t\timmersion->fluidPlane = fluidPlane;\n\t\timmersion->fluidNormal = dVector3(0, 0, 0);\n\t\timmersion->fluidNormal[2] = 1;\n\t\timmersion->fluidNormal[0] = fluidPlane[0];\n\t\timmersion->fluidNormal[1] = fluidPlane[1];\n\t\timmersion->fluidNormal = dNormalize3(immersion->fluidNormal);\n\t\timmersion->fluidDepth = 0;\n\t\timmersion->fluidDepth = dDot3(fluidPlane, immersion->fluidNormal);\n\t\timmersion->fluidDepth = -immersion->fluidDepth;\n\t\timmersion->fluidDepth = dFabs(immersion->fluidDepth);\n\t\timmersion->fluidDepth = dFmax(immersion->fluidDepth, 0);\n\t\timmersion->fluidDepth = dFmin(immersion->fluidDepth, 0.001);\n\n\t\t// Call dImmerseBox\n\t\treturn dImmerseBox(box, fluidPlane, flags, immersion);\n\t}\n\treturn 0;\n}", "CodeBleu_score": 41.07256421475546}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\tdUASSERT(o2, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsCapsuleImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 32.38230970607798}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\treturn dImmerseCapsuleTrimesh(o1, o2, flags, immersion, 0);\n}", "CodeBleu_score": 14.731066354330425}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT(0, \"dImmerseCapsuleTrimesh not implemented\");\n\treturn 0;\n}", "CodeBleu_score": 5.34816939434737}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// Check if the duration is missing or non-positive\n\tif (duration.get() <= 0) {\n\t\treturn SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(RUNNING);\n\n\t// Start a timer\n\ttimer_waiting_ = true;\n\ttimer.start(duration.get());\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer.onTimeout.connect(this, &SleepNode::onTimerTimeout);\n\n\treturn SUCCESS;\n}", "CodeBleu_score": 23.391346847506256}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (this->input_port_duration_.isMissing()) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tif (this->input_port_duration_.getValue() <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tthis->timer_waiting_ = true;\n\tthis->timer_.start(this->input_port_duration_.getValue());\n\tthis->timer_.onTimeout.connect(this, &SleepNode::wakeup);\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 19.989898379858147}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Retrieve the sleep duration from the input port\n\tdouble sleep_duration = input_port_->get<double>();\n\n\t// Check if the sleep duration is missing or non-positive\n\tif (sleep_duration <= 0.0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tset_status(NodeStatus::RUNNING);\n\n\t// Start the timer\n\ttimer_.start();\n\n\t// Set the callback to emit a wake-up signal when the timer expires\n\ttimer_.setCallback([this]() {\n\t\t// Emit a wake-up signal\n\t\temit_wake_up();\n\n\t\t// Reset the timer_waiting_ flag\n\t\ttimer_waiting_ = false;\n\t});\n\n\t// Return SUCCESS\n\treturn NodeStatus::SUCCESS;\n}", "CodeBleu_score": 32.42471874800687}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (!this->blackboard) {\n\t\tthis->blackboard = this->getBlackboard();\n\t}\n\n\tif (!this->blackboard) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tstd::string key = this->key;\n\tEntry *entry = this->blackboard->getEntry(key);\n\n\tif (!entry) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tentry->lock();\n\n\tif (entry->getSequenceID() == this->lastSequenceID) {\n\t\tentry->unlock();\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tthis->lastSequenceID = entry->getSequenceID();\n\tentry->unlock();\n\treturn NodeStatus::SUCCESS;\n}", "CodeBleu_score": 36.300601604953506}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry\n\tblackboard::Entry* entry = blackboard_interface_->getEntry(entry_id_);\n\tif (entry == NULL) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the mutex\n\tentry->lock();\n\n\t// Check if the sequence ID has changed\n\tif (entry->getSequenceID()!= sequence_id_) {\n\t\t// Update the sequence ID\n\t\tsequence_id_ = entry->getSequenceID();\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Unlock the mutex\n\tentry->unlock();\n\n\t// Return failure if the sequence ID has not changed\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 37.108963128990624}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tEntryID id = getEntryID();\n\tif (id == EntryID::UNKNOWN) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tEntry entry;\n\tif (blackboard->getEntry(id, entry) == false) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tif (entry.getSequenceID() == sequenceID) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\tsequenceID = entry.getSequenceID();\n\treturn NodeStatus::SUCCESS;\n}", "CodeBleu_score": 41.419340250825584}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (this->successThreshold_ < 0) {\n\t\treturn this->successThreshold_ = this->children_.size() - std::abs(this->successThreshold_);\n\t} else {\n\t\treturn this->successThreshold_;\n\t}\n}", "CodeBleu_score": 25.224236244963254}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tsize_t threshold = m_successThreshold;\n\tif (threshold < 0) {\n\t\tthreshold += m_children.size();\n\t\tif (threshold < 0) {\n\t\t\tthreshold = 0;\n\t\t}\n\t}\n\treturn threshold;\n}", "CodeBleu_score": 44.767168174352854}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tsize_t threshold = this->successThreshold_;\n\tif (threshold < 0) {\n\t\tthreshold = this->children_.size();\n\t}\n\treturn threshold;\n}", "CodeBleu_score": 42.089888441297504}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\tstd::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n\twhile(_p->heartbeat_active) {\n\t\tauto now = std::chrono::steady_clock::now();\n\t\tauto diff = now - _p->last_heartbeat;\n\t\tif (diff > std::chrono::milliseconds(1000)) {\n\t\t\t_p->heartbeat_active = false;\n\t\t\tstd::cout << \"Heartbeat timed out, disabling all hooks.\" << std::endl;\n\t\t\tenableAllHooks(false);\n\t\t}\n\t\telse {\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\t}\n\t}\n}", "CodeBleu_score": 48.78077878260948}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n\t\tif (std::chrono::system_clock::now() - _p->last_heartbeat > std::chrono::seconds(5)) {\n\t\t\tenableAllHooks(false);\n\t\t}\n\t\telse {\n\t\t\tenableAllHooks(true);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.189732094643684}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\t\tfor(auto& [node_uid, hook] : _p->pre_hooks) {\n\t\t\tstd::unique_lock<std::mutex> lk(hook->mutex);\n\t\t\tif(hook->enabled) {\n\t\t\t\tif(hook->mode == Monitor::Hook::Mode::BREAKPOINT) {\n\t\t\t\t\tif(hook->heartbeat_timeout_ms > 0 && (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - hook->heartbeat_last_seen).count() > hook->heartbeat_timeout_ms)) {\n\t\t\t\t\t\thook->enabled = false;\n\t\t\t\t\t\thook->wakeup.notify_all();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.275726076665975}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// parse the input string to a vector of blackboard names\n\tstd::vector<std::string> bb_names;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\n\t// create a JSON object to store the blackboard dump\n\tjson bb_dump;\n\n\t// iterate through the blackboard names\n\tfor (const auto& bb_name : bb_names) {\n\t\t// find the subtree corresponding to the blackboard name\n\t\tauto subtree = blackboard_tree_.find(bb_name);\n\n\t\t// check if the subtree is valid\n\t\tif (subtree!= blackboard_tree_.end()) {\n\t\t\t// lock the subtree\n\t\t\tsubtree->second->lock();\n\n\t\t\t// export the subtree to JSON\n\t\t\tauto subtree_json = subtree->second->exportToJSON();\n\n\t\t\t// unlock the subtree\n\t\t\tsubtree->second->unlock();\n\n\t\t\t// add the subtree to the JSON object\n\t\t\tbb_dump[bb_name] = subtree_json;\n\t\t}\n\t}\n\n\t// convert the JSON object to MessagePack format\n\tauto bb_dump_msgpack = bb_dump.dump();\n\n\t// convert the MessagePack string to a vector of uint8_t\n\tstd::vector<uint8_t> bb_dump_msgpack_vec;\n\tstd::copy(bb_dump_msgpack.begin(), bb_dump_msgpack.end(), std::back_inserter(bb_dump_msgpack_vec));\n\n\t// return the vector of uint8_t\n\treturn bb_dump_msgpack_vec;\n}", "CodeBleu_score": 45.53798860268861}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> output;\n\tif (bb_list.empty()) {\n\t\treturn output;\n\t}\n\tstd::vector<std::string> bb_names = split(bb_list, ',');\n\tjson bb_dump;\n\tfor (const auto& bb_name : bb_names) {\n\t\tstd::string bb_name_trimmed = trim(bb_name);\n\t\tBlackboard* bb = getBlackboard(bb_name_trimmed);\n\t\tif (bb!= nullptr) {\n\t\t\tbb->lock();\n\t\t\tbb_dump[bb_name_trimmed] = bb->dump();\n\t\t\tbb->unlock();\n\t\t}\n\t}\n\toutput = json_to_msgpack(bb_dump);\n\treturn output;\n}", "CodeBleu_score": 46.4847409665727}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> bb_dump;\n\ttry {\n\t\tjson bb_dump_json = json::object();\n\t\tstd::vector<std::string> bb_list_split = split(bb_list, ',');\n\t\tfor (std::string bb_name : bb_list_split) {\n\t\t\tstd::string bb_name_trimmed = trim(bb_name);\n\t\t\tif (bb_name_trimmed.empty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (bb_name_trimmed[0] == '/') {\n\t\t\t\tbb_name_trimmed.erase(0, 1);\n\t\t\t}\n\t\t\tif (bb_name_trimmed[bb_name_trimmed.size() - 1] == '/') {\n\t\t\t\tbb_name_trimmed.erase(bb_name_trimmed.size() - 1, 1);\n\t\t\t}\n\t\t\tif (bb_name_trimmed.empty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstd::shared_ptr<Blackboard> bb = _blackboard_tree->find(bb_name_trimmed);\n\t\t\tif (bb == nullptr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstd::lock_guard<std::mutex> bb_lock(bb->getMutex());\n\t\t\tbb_dump_json[bb_name_trimmed] = bb->getJSON();\n\t\t}\n\t\tbb_dump = msgpack::pack(bb_dump_json);\n\t} catch (const std::exception& e) {\n\t\tstd::cerr << \"Error while generating blackboards dump: \" << e.what() << std::endl;\n\t\treturn std::vector<uint8_t>();\n\t}\n\treturn bb_dump;\n}", "CodeBleu_score": 36.20563699778215}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n\tif (!hook) {\n\t\treturn false;\n\t}\n\tstd::unique_lock<std::mutex> lk(hook->mutex);\n\tif (hook->status == NodeStatus::BREAKPOINT) {\n\t\thook->status = result;\n\t\thook->remove = remove;\n\t\thook->ready = true;\n\t\thook->cond.notify_all();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.63597557617876}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t/  std::lock_guard<std::mutex> lk(_p->hooks_map_mutex);\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto bk_it = pos == Position::PRE? _p->pre_hooks.find(node_uid) : _p->post_hooks.find(node_uid);\n  if(bk_it == (pos == Position::PRE? _p->pre_hooks.end() : _p->post_hooks.end()))\n  {\n    return false;\n  }\n  auto hook = bk_it->second;\n  std::unique_lock<std::mutex> hook_lk(hook->mutex);\n  if(hook->mode!= Monitor::Hook::Mode::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->condition.notify_all();\n  return true;\n}", "CodeBleu_score": 57.410135127430465}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n\tif (hook == nullptr) {\n\t\treturn false;\n\t}\n\tstd::unique_lock<std::mutex> lk(hook->mutex);\n\tif (hook->status == Monitor::Hook::Status::BREAKPOINT) {\n\t\thook->status = result;\n\t\thook->remove = remove;\n\t\thook->ready = true;\n\t\thook->cv.notify_all();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.92152066547984}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t}\n\n\tNodeStatus status = tick_functor_(*this);\n\tif (status!= prev_status) {\n\t\tsetStatus(status);\n\t}\n\treturn status;\n}", "CodeBleu_score": 24.74672763043232}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n\tif (prev_status == NodeStatus::IDLE)\n\t{\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t}\n\n\tNodeStatus status = tick_functor_(*this);\n\tif (status!= prev_status)\n\t{\n\t\tsetStatus(status);\n\t}\n\treturn status;\n}", "CodeBleu_score": 24.761290073753443}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::thread t(&BT::ThreadedAction::tick, this);\n\t\tt.detach();\n\t}\n\telse if (prev_status == NodeStatus::RUNNING) {\n\t\tif (halt_requested_) {\n\t\t\thalt_requested_ = false;\n\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t}\n\t}\n\telse {\n\t\t//do nothing\n\t}\n\treturn status();\n}", "CodeBleu_score": 37.83288647416083}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// print the tree structure\n\tstream << \"------------------------------------------------------------------------\" << std::endl;\n\tstream << \"Tree Structure:\" << std::endl;\n\tstream << \"------------------------------------------------------------------------\" << std::endl;\n\tstream << \"Root Node: \" << root_node->getName() << std::endl;\n\tauto printTree = [&stream](const TreeNode* node, int depth) {\n\t\t// print the node's name and depth\n\t\tfor (int i = 0; i < depth; ++i) {\n\t\t\tstream << \"\\t\";\n\t\t}\n\t\tstream << node->getName() << std::endl;\n\t\t// print the children\n\t\tif (node->isControlNode()) {\n\t\t\tfor (const auto& child : node->getChildren()) {\n\t\t\t\tprintTree(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprintTree(node->getChild(), depth + 1);\n\t\t}\n\t};\n\tprintTree(root_node, 1);\n\tstream << \"------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 44.937672371577314}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\tstd::string indent = \"\";\n\tfor (int i = 0; i < root_node->depth; i++) {\n\t\tindent += \"  \";\n\t}\n\tstream << indent << root_node->name << std::endl;\n\tif (root_node->children.size() > 0) {\n\t\tstream << indent << \"{\" << std::endl;\n\t\tfor (int i = 0; i < root_node->children.size(); i++) {\n\t\t\tprintTreeRecursively(root_node->children[i], stream);\n\t\t}\n\t\tstream << indent << \"}\" << std::endl;\n\t}\n}", "CodeBleu_score": 32.64241002252434}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstd::string indent = \"\";\n\tfor (int i = 0; i < root_node->depth; i++) {\n\t\tindent += \"\\t\";\n\t}\n\tstream << indent << \"+\" << root_node->name << std::endl;\n\tif (root_node->children.size() > 0) {\n\t\tfor (auto child : root_node->children) {\n\t\t\tprintTreeRecursively(child, stream);\n\t\t}\n\t}\n}", "CodeBleu_score": 23.888630557763772}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tapplyRecursiveVisitor(node, visitor);\n}", "CodeBleu_score": 14.991219623511448}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (node == nullptr)\n\t{\n\t\tthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (auto control = dynamic_cast<const BT::ControlNode*>(node))\n\t{\n\t\tfor (const auto& child : control->children())\n\t\t{\n\t\t\tapplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n\t\t}\n\t}\n\telse if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n\t{\n\t\tapplyRecursiveVisitor(decorator->child(), visitor);\n\t}\n}", "CodeBleu_score": 88.6331282337413}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tapplyRecursiveVisitor(node, visitor);\n}", "CodeBleu_score": 14.991219623511448}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.id)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with ID \" + manifest.id + \" already registered.\");\n\t}\n\n\tbuilders[manifest.id] = builder;\n\tmanifests[manifest.id] = manifest;\n}", "CodeBleu_score": 40.28071431212516}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.id)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with ID \" + manifest.id + \" already registered!\");\n\t}\n\tbuilders[manifest.id] = builder;\n\tbuildersManifest[manifest.id] = manifest;\n}", "CodeBleu_score": 40.33475481087149}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.registrationID)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"Registration ID already exists\");\n\t}\n\tbuilders[manifest.registrationID] = builder;\n\tmanifests[manifest.registrationID] = manifest;\n}", "CodeBleu_score": 40.658712042830444}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t/  std::cout << \"registering simple action node \" << ID << std::endl;\n  auto builder = [tick_functor, ports](const TreeNodeManifest& manifest) -> TreeNode* {\n    return new SimpleActionNode(tick_functor, ports);\n  };\n  registerBuilder(TreeNodeManifest(SimpleActionNode::type(), ID, ports), builder);\n}", "CodeBleu_score": 42.731725715512844}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t//  auto builder = [tick_functor, ports](const NodeConfiguration& config) -> Node* {\n//    return new SimpleActionNode(tick_functor, ports, config);\n//  };\n//\n//  auto manifest = TreeNodeManifest{\n//      SimpleActionNode::type(),\n//      ID,\n//      ports\n//  };\n//\n//  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 10.819337351164709}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tif defined(BT_USE_LOG_DEBUG)\n  if (ID.empty()) {\n    throw BehaviorTreeException(\"ID cannot be empty\");\n  }\n#endif\n  registerBuilder(TreeNodeManifest(ID, NodeType::SIMPLE_ACTION, ports),\n                  [tick_functor](const TreeNodeManifest& manifest,\n                                 const NodeConfiguration& configuration) {\n                    return std::make_unique<SimpleActionNode>(\n                        tick_functor, manifest, configuration);\n                  });\n}", "CodeBleu_score": 51.51427703944309}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.subtrees.size());\n\tfor (auto subtree : tree.subtrees) {\n\t\tBlackboard::Ptr backup = std::make_shared<Blackboard>(*subtree->blackboard);\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}", "CodeBleu_score": 55.83911026172102}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backup;\n\tbackup.reserve(tree.NumSubtrees());\n\tfor (const auto& subtree : tree.Subtrees()) {\n\t\tauto new_bb = std::make_shared<Blackboard>();\n\t\t*new_bb = *subtree->Blackboard();\n\t\tbackup.push_back(new_bb);\n\t}\n\treturn backup;\n}", "CodeBleu_score": 51.84081015610828}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.Subtrees.size());\n\tfor (auto& subtree : tree.Subtrees) {\n\t\tBlackboard::Ptr backup = std::make_shared<Blackboard>(*subtree.Blackboard);\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}", "CodeBleu_score": 54.06476509308109}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto result = ParseScript(script);\n\tif(result.has_value())\n\t{\n\t\treturn result.value()(env);\n\t}\n\telse\n\t{\n\t\treturn nonstd::make_unexpected(result.error());\n\t}\n}", "CodeBleu_score": 65.86072980462214}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto res = ParseScript(script);\n\tif (res.has_value()) {\n\t\treturn res.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(res.error());\n\t}\n}", "CodeBleu_score": 65.62733010094536}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto result = ParseScript(script);\n\tif (result.has_value()) {\n\t\treturn result.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(result.error());\n\t}\n}", "CodeBleu_score": 66.01586524902739}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\n\tif (loaded) {\n\t\tthrow RuntimeError(\"SharedLibrary::load\", \"Shared library already loaded\");\n\t}\n\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == nullptr) {\n\t\tstd::string error = dlerror();\n\t\tthrow RuntimeError(\"SharedLibrary::load\", error);\n\t}\n\n\tloaded = true;\n\tloaded_path = path;\n\thandle_ = handle;\n}", "CodeBleu_score": 51.8480073446943}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\t// Acquire a unique lock on the mutex.\n\tstd::unique_lock<std::mutex> lock(mutex_);\n\n\t// Check if the library is already loaded.\n\tif (loaded_) {\n\t\tthrow RuntimeError(\"Library already loaded.\");\n\t}\n\n\t// Attempt to load the library using dlopen.\n\tlibrary_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\t// Check if the library was loaded successfully.\n\tif (!library_) {\n\t\t// Retrieve the error message.\n\t\tstd::string error = dlerror();\n\n\t\t// Throw a RuntimeError with the error message.\n\t\tthrow RuntimeError(error);\n\t}\n\n\t// Store the path of the loaded library.\n\tpath_ = path;\n\n\t// Set the loaded flag to true.\n\tloaded_ = true;\n}", "CodeBleu_score": 52.65052660080921}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\t// Lock the mutex\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Check if a library is already loaded\n\tif (loaded) {\n\t\tthrow RuntimeError(\"A library is already loaded.\");\n\t}\n\n\t// Load the library\n\tlib = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\t// Check if the load failed\n\tif (lib == nullptr) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\n\t// Store the path of the loaded library\n\tthis->path = path;\n\n\t// Set the loaded flag to true\n\tloaded = true;\n}", "CodeBleu_score": 48.454643794924415}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3)\n\t\treturn false;\n\tstr = str.strip();\n\tif (str.front()!= '{' || str.back()!= '}')\n\t\treturn false;\n\tif (stripped_pointer)\n\t\t*stripped_pointer = str.substring(1, str.size() - 2);\n\treturn true;\n}", "CodeBleu_score": 18.383467587365026}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\tauto stripped = str.trim();\n\tif (stripped.length() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped.startsWith('{') && stripped.endsWith('}')) {\n\t\tif (stripped_pointer) {\n\t\t\t*stripped_pointer = stripped.substring(1, stripped.length() - 1);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 24.259865680537}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.trim();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped[0]!= '{' || stripped[stripped.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer!= nullptr) {\n\t\t*stripped_pointer = stripped.substring(1, stripped.size() - 1);\n\t}\n\treturn true;\n}", "CodeBleu_score": 25.297996810639745}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tunsigned char point_cost;\n\t//create a line iterator\n\tnav_msgs::MapMetaData info = costmap_.getInfo();\n\t//make sure the line iterator we are creating is valid\n\tif(!line_iterator_.initialize(costmap_, x0, y0, x1, y1)) {\n\t\tROS_ERROR(\"Could not create line iterator for coordinates (%d, %d) to (%d, %d)\", x0, y0, x1, y1);\n\t\treturn -1;\n\t}\n\t//iterate through the line iterator\n\tfor(line_iterator_.reset();!line_iterator_.done(); line_iterator_.step()) {\n\t\t//get the point from the line iterator\n\t\tunsigned char cost = costmap_.getCost(line_iterator_.getX(), line_iterator_.getY());\n\t\t//if the cell is in an obstacle the path is invalid\n\t\tif(cost == NO_INFORMATION)\n\t\t\treturn -2;\n\t\tif(cost == LETHAL_OBSTACLE)\n\t\t\treturn -1;\n\n\t\t//calculate the point cost\n\t\tpoint_cost = cost;\n\t\t//if the point cost is negative, return the point cost immediately\n\t\tif(point_cost < 0)\n\t\t\treturn point_cost;\n\t\t//otherwise, update the line cost if the point cost is higher\n\t\tline_cost += point_cost;\n\t}\n\t//return the total line cost\n\treturn line_cost;\n}", "CodeBleu_score": 48.041659306321684}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\t//create a line iterator\n\tnav_msgs::MapMetaData info = costmap_.getInfo();\n\tnav_msgs::OccupancyGrid costmap = costmap_;\n\tcostmap_2d::LineIterator line_it(costmap, Point(x0, y0), Point(x1, y1));\n\t//iterate through the line\n\tfor(int i = 0; i < line_it.size(); i++) {\n\t\tPoint p = line_it.getPosition();\n\t\tdouble point_cost = pointCost(p.x, p.y);\n\t\tif(point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t} else {\n\t\t\tline_cost += point_cost;\n\t\t}\n\t\tline_it++;\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 49.38517338408928}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0;\n\n\t//create a line iterator\n\t//the line iterator will return the coordinates of the current point\n\t//on the line, as well as the coordinates of the previous point\n\t//on the line\n\tLineIterator it(costmap_, Point(x0, y0), Point(x1, y1));\n\n\tfor(int i = 0; i < it.count; i++, ++it) {\n\t\t//calculate the point cost\n\t\tdouble point_cost = pointCost(it.pos().x, it.pos().y);\n\n\t\t//if the point cost is negative, return it immediately\n\t\tif(point_cost < 0)\n\t\t\treturn point_cost;\n\n\t\t//update the line cost if the point cost is higher\n\t\tif(point_cost > line_cost)\n\t\t\tline_cost = point_cost;\n\t}\n\n\treturn line_cost;\n}", "CodeBleu_score": 60.75176990809046}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.size() == 0) {\n\t\treturn;\n\t}\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\tpath_msg.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tpath_msg.poses[i] = path[i];\n\t}\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 68.41171468239935}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif(path.empty())\n\t\treturn;\n\tnav_msgs::Path pathMsg;\n\tpathMsg.header.frame_id = path[0].header.frame_id;\n\tpathMsg.header.stamp = path[0].header.stamp;\n\tpathMsg.poses.resize(path.size());\n\tfor(int i = 0; i < path.size(); i++) {\n\t\tpathMsg.poses[i] = path[i];\n\t}\n\tpub.publish(pathMsg);\n}", "CodeBleu_score": 70.69499924604217}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\treturn;\n\t}\n\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\tpath_msg.poses = path;\n\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 45.2566225650083}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tdouble rot_vel = base_odom.twist.twist.angular.z;\n\tdouble trans_vel = base_odom.twist.twist.linear.x;\n\n\tif (fabs(rot_vel) <= rot_stopped_velocity && fabs(trans_vel) <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 52.332255183001195}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (base_odom.twist.twist.angular.z <= rot_stopped_velocity) && (base_odom.twist.twist.linear.x <= trans_stopped_velocity);\n}", "CodeBleu_score": 42.76351895282367}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) && (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}", "CodeBleu_score": 54.695409491608004}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// If setup is not yet done, it initializes the default limits with the provided configuration and sets up the flag.\n\tif (!setup_) {\n\t\t// Initialize the default limits with the provided configuration.\n\t\tdefault_limits_ = config;\n\t\t// Set up the flag.\n\t\tsetup_ = true;\n\t}\n\n\t// If the setup flag is true and restore_defaults is requested, it resets the configuration to default limits.\n\tif (setup_ && restore_defaults) {\n\t\t// Reset the configuration to default limits.\n\t\tconfig = default_limits_;\n\t}\n\n\t// Lock the configuration mutex and updates the current limits with the new configuration.\n\tconfig_mutex_.lock();\n\tcurrent_limits_ = config;\n\tconfig_mutex_.unlock();\n}", "CodeBleu_score": 68.63449155008529}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\t// TODO: Implement\n}", "CodeBleu_score": 4.780716794403336}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (setup) {\n\t\tif (restore_defaults) {\n\t\t\tconfig = default_limits;\n\t\t} else {\n\t\t\tdefault_limits = config;\n\t\t}\n\t} else {\n\t\tdefault_limits = config;\n\t\tsetup = true;\n\t}\n\n\tconfig_mutex.lock();\n\tlimits = config;\n\tconfig_mutex.unlock();\n}", "CodeBleu_score": 48.316170899358866}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// Check if the cell is an obstacle or has no information\n\tif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::NO_INFORMATION) {\n\t\tcheck_cell->target_distance = MAX_COST;\n\t\treturn false;\n\t}\n\n\t// Calculate the target distance\n\tdouble new_target_distance = current_cell->target_distance + distanceBetweenCells(current_cell, check_cell);\n\n\t// If the new target distance is shorter, update the cell's target distance\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\tcheck_cell->parent = current_cell;\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 49.60598681590355}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// Get the cost of the cell using the costmap\n\tunsigned char cell_cost = costmap.getCost(check_cell->x, check_cell->y);\n\n\t// If the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false\n\tif (cell_cost == costmap_2d::NO_INFORMATION || cell_cost >= costmap_2d::LETHAL_OBSTACLE) {\n\t\tcheck_cell->target_distance = costmap.getCost(current_cell->x, current_cell->y);\n\t\treturn false;\n\t}\n\n\t// Calculate a new target distance for the cell\n\tunsigned int new_target_distance = current_cell->target_distance + costmap.getCost(current_cell->x, current_cell->y);\n\n\t// If the new target distance is shorter, update the cell's target distance\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\n\t// Return false if the new target distance is not shorter\n\treturn false;\n}", "CodeBleu_score": 55.12936837101792}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// If the cell is an obstacle or has no information, set the cell's target distance to the maximum obstacle cost and return false.\n\tif (check_cell->getCost() >= costmap_2d::LETHAL_OBSTACLE) {\n\t\tcheck_cell->setTargetDistance(costmap.getCost(check_cell->getX(), check_cell->getY()));\n\t\treturn false;\n\t}\n\n\t// Calculate a new target distance and update the cell's target distance if the new distance is shorter.\n\tdouble new_target_distance = current_cell->getTargetDistance() + current_cell->getDistance(check_cell);\n\tif (new_target_distance < check_cell->getTargetDistance()) {\n\t\tcheck_cell->setTargetDistance(new_target_distance);\n\t\treturn true;\n\t}\n\n\t// Otherwise, return false.\n\treturn false;\n}", "CodeBleu_score": 45.52942675408897}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t/  ROS_INFO(\"in scoreTrajectory\");\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"No footprint specified, can't do collision checking\");\n    return -9.0;\n  }\n  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  for(unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    geometry_msgs::Point pt = traj.getPoint(i);\n    double occ_cost = footprintCost(pt.x, pt.y, pt.theta, scale, footprint_spec_, costmap_, world_model_);\n    if (occ_cost < 0) {\n      return occ_cost;\n    }\n    if (sum_scores_) {\n      cost += occ_cost;\n    }\n    else {\n      cost = std::max(cost, occ_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 59.59317340061153}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n\tdouble scale = 1.0;\n\n\tif (traj.xv_ == 0.0 && traj.yv_ == 0.0) {\n\t\treturn -9.0;\n\t}\n\n\t//if we're using a footprint, we'll scale it appropriately\n\tif (!footprint_spec_.empty()) {\n\t\tscale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\t}\n\n\t//for each point in the trajectory, calculate the footprint cost\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble x = traj.xv_ * traj.getPoints()[i].getX();\n\t\tdouble y = traj.yv_ * traj.getPoints()[i].getY();\n\t\tdouble th = traj.th_ * traj.getPoints()[i].getTheta();\n\n\t\tdouble footprint_cost = footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\treturn cost;\n}", "CodeBleu_score": 62.2844775465681}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t/  ROS_DEBUG(\"ObstacleCostFunction::scoreTrajectory\");\n\n  //initialize the cost and scaling factor\n  double cost = 0.0;\n  double scale = 1.0;\n\n  //if the footprint is empty, log an error and return a very high cost\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: Footprint specification is empty!\");\n    return -9.0;\n  }\n\n  //get the scaling factor\n  scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //for each point in the trajectory\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    //get the footprint cost\n    double point_cost = footprintCost(traj.getPointX(i), traj.getPointY(i), traj.getPointTh(i), scale, footprint_spec_, costmap_, world_model_);\n\n    //if the footprint cost is negative, return the cost immediately\n    if (point_cost < 0) {\n      return point_cost;\n    }\n\n    //otherwise, either sum the scores or take the maximum score\n    if (sum_scores_) {\n      cost += point_cost;\n    } else {\n      cost = std::max(cost, point_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 58.760725667573425}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t// Get the footprint cost\n\tdouble footprint_cost = world_model->footprintCost(x, y, th, scale, footprint_spec, costmap);\n\t// If the footprint cost is negative, return -6.0\n\tif (footprint_cost < 0) {\n\t\treturn -6.0;\n\t}\n\t// If the position is off the map, return -7.0\n\tif (costmap->getCost(x, y) == costmap_2d::NO_INFORMATION) {\n\t\treturn -7.0;\n\t}\n\t// Return the maximum cost between the footprint cost and the cell cost at the given position\n\treturn std::max(footprint_cost, costmap->getCost(x, y));\n}", "CodeBleu_score": 34.932239262728295}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\tdouble footprint_cost = 0;\n\tdouble cell_cost = 0;\n\tdouble max_cost = 0;\n\n\t// scale the footprint\n\tstd::vector<geometry_msgs::Point> scaled_footprint;\n\tfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n\t\tgeometry_msgs::Point new_pt;\n\t\tnew_pt.x = footprint_spec[i].x * scale;\n\t\tnew_pt.y = footprint_spec[i].y * scale;\n\t\tscaled_footprint.push_back(new_pt);\n\t}\n\n\t// check if the footprint is off the map\n\tif (!world_model->footprintCost(x, y, th, scaled_footprint, footprint_cost)) {\n\t\treturn -7.0;\n\t}\n\n\t// check if the footprint is in collision\n\tif (footprint_cost < 0) {\n\t\treturn -6.0;\n\t}\n\n\t// get the cell cost at the position\n\tcell_cost = costmap->getCost(static_cast<int>(x), static_cast<int>(y));\n\n\t// get the maximum cost between the footprint cost and the cell cost\n\tmax_cost = std::max(footprint_cost, cell_cost);\n\n\treturn max_cost;\n}", "CodeBleu_score": 67.42036443716624}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_INFO_ONCE(\"odom topic set to %s\", odom_topic.c_str());\n\n  //we assume that the odometry is published in the frame of the base\n  boost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic!= odom_topic_) {\n    if (!odom_topic.empty()) {\n      //subscribe to the odometry topic\n      ROS_INFO(\"Subscribing to odometry topic %s\", odom_topic.c_str());\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      //unsubscribe from the odometry topic\n      ROS_INFO(\"Unsubscribing from odometry topic %s\", odom_topic_.c_str());\n      odom_sub_.shutdown();\n    }\n    odom_topic_ = odom_topic;\n  }\n}", "CodeBleu_score": 43.70906028822695}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Setting odometry topic to: %s\", odom_topic.c_str());\n  if (odom_topic!= odom_topic_) {\n    if (!odom_topic.empty()) {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n    odom_topic_ = odom_topic;\n  }\n}", "CodeBleu_score": 45.78123464553728}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"In setOdomTopic with topic: %s\", odom_topic.c_str());\n  if (odom_topic!= odom_topic_) {\n    if (odom_topic.empty()) {\n      if (odom_sub_) {\n        odom_sub_.shutdown();\n        odom_sub_.unsubscribe();\n        odom_sub_.stop();\n        odom_sub_.clear();\n        odom_sub_ = ros::Subscriber();\n      }\n    } else {\n      odom_sub_ = nh_.subscribe(odom_topic, 10, &OdometryHelperRos::odomCallback, this);\n    }\n    odom_topic_ = odom_topic;\n  }\n}", "CodeBleu_score": 37.16906676762456}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// Calculate the squared distance between the current and previous positions\n\tfloat dist = (pos - prev).squaredNorm();\n\t// Calculate the angular difference between the current and previous positions\n\tfloat ang_diff = std::abs(std::atan2(pos[1] - prev[1], pos[0] - prev[0]) - std::atan2(prev[1], prev[0]));\n\t// If the squared distance exceeds a threshold or the angular difference is greater than a set angle, reset the oscillation flags\n\tif (dist > 0.001 || ang_diff > 0.1) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 43.174875562888666}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t//calculate the squared distance between the current and previous positions\n\tfloat dist_sq = (pos - prev).squaredNorm();\n\n\t//calculate the angular difference between the current and previous positions\n\tfloat angle = std::atan2(pos[1] - prev[1], pos[0] - prev[0]);\n\n\t//if the squared distance is greater than a threshold or the angular difference is greater than a set angle, reset the oscillation flags\n\tif (dist_sq > dist_threshold_ || std::abs(angle) > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 41.023394968898096}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat dist_sq = (pos - prev).squaredNorm();\n\tfloat angle_diff = std::abs(std::atan2(pos(1), pos(0)) - std::atan2(prev(1), prev(0)));\n\n\tif (dist_sq > dist_sq_threshold_ || angle_diff > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 35.667522293529366}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\t//get the bounds of the grid cell in world coords\n\tgeometry_msgs::Point lower_left, upper_right;\n\tgetCellBounds(gx, gy, lower_left, upper_right);\n\n\t//check if the point is within the grid bounds\n\tif (gx >= width_ || gy >= height_) {\n\t\treturn;\n\t}\n\n\t//check if the point is too close to its nearest neighbor\n\tif (nearestNeighborDistance(pt) < sq_min_separation_) {\n\t\treturn;\n\t}\n\n\t//calculate the grid index\n\tunsigned int index = gy * width_ + gx;\n\n\t//insert the point into the grid\n\tgrid_[index].push_back(pt);\n}", "CodeBleu_score": 60.82258551299884}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\t//get the bounds of the grid cell in world coords\n\tgeometry_msgs::Point lower_left, upper_right;\n\tgetCellBounds(gx, gy, lower_left, upper_right);\n\n\t//check if the point is within the grid bounds\n\tif(gx >= width_ || gy >= height_ || gx < 0 || gy < 0)\n\t\treturn;\n\n\t//check if the point is too close to its nearest neighbor\n\tdouble sq_dist = nearestNeighborDistance(pt);\n\tif(sq_dist < sq_min_separation_)\n\t\treturn;\n\n\t//calculate the grid index\n\tunsigned int index = gy * width_ + gx;\n\n\t//insert the point into the cell\n\tcells_[index].push_back(pt);\n}", "CodeBleu_score": 61.66855596828873}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t", "CodeBleu_score": 5.072917382472679}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (vel[i] < sample_target_vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t\telse {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 72.03936849106067}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tif (sample_target_vel[i] - vel[i] > acclimits[i] * dt) {\n\t\t\t\tnew_vel[i] = vel[i] + acclimits[i] * dt;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (vel[i] - sample_target_vel[i] > acclimits[i] * dt) {\n\t\t\t\tnew_vel[i] = vel[i] - acclimits[i] * dt;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 66.34617064742419}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tnew_vel << 0, 0, 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel(i) > vel(i)) {\n\t\t\tnew_vel(i) = vel(i) + acclimits(i) * dt;\n\t\t\tif (new_vel(i) > sample_target_vel(i))\n\t\t\t\tnew_vel(i) = sample_target_vel(i);\n\t\t}\n\t\telse {\n\t\t\tnew_vel(i) = vel(i) - acclimits(i) * dt;\n\t\t\tif (new_vel(i) < sample_target_vel(i))\n\t\t\t\tnew_vel(i) = sample_target_vel(i);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 52.68398586544585}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = DBL_MAX;\n\tdouble goal_x, goal_y;\n\tdouble goal_heading;\n\tdouble goal_distance;\n\n\t//Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan.size() - 1; i >= 0; i--) {\n\t\t//Convert the goal cell coordinates to world coordinates\n\t\tgoal_x = global_plan[i].x;\n\t\tgoal_y = global_plan[i].y;\n\t\tgoal_distance = sqrt(pow(goal_x - x, 2) + pow(goal_y - y, 2));\n\n\t\t//Calculate the shortest angular distance between the current heading and the direction to the goal point\n\t\tgoal_heading = atan2(goal_y - y, goal_x - x);\n\t\tif (goal_heading < 0) {\n\t\t\tgoal_heading += 2 * M_PI;\n\t\t}\n\t\tdiff = min(diff, fabs(wrapToPi(heading - goal_heading)));\n\n\t\t//If a valid point is found, return the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n\t\tif (lineCost(cell_x, global_plan[i].x, cell_y, global_plan[i].y) > 0 && goal_distance > 0.5) {\n\t\t\treturn diff;\n\t\t}\n\t}\n\n\t//If no valid point is found, return DBL_MAX\n\treturn diff;\n}", "CodeBleu_score": 51.51261001680999}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t//Find the farthest point on the path that can be seen from the robot's current cell\n\tfor (int i = path.size() - 1; i >= 0; i--) {\n\t\t//Convert the cell coordinates to world coordinates\n\t\tdouble goal_x = cell_x * resolution + resolution / 2 + x;\n\t\tdouble goal_y = cell_y * resolution + resolution / 2 + y;\n\n\t\t//Calculate the shortest angular distance between the current heading and the direction to the goal point\n\t\tdouble heading_diff = fabs(atan2(goal_y - y, goal_x - x) - heading);\n\n\t\t//Check if the goal point is clear of obstacles\n\t\tif (lineCost(cell_x, path[i].x, cell_y, path[i].y) > 0) {\n\t\t\treturn heading_diff;\n\t\t}\n\t}\n\n\treturn DBL_MAX;\n}", "CodeBleu_score": 44.9666466862067}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = DBL_MAX;\n\tint i = 0;\n\twhile (i < global_plan.size() && diff == DBL_MAX) {\n\t\t//If the goal point is within 1 cell of the current point, return the difference between the goal point and the robot's current heading.\n\t\tif (abs(global_plan[i].x - cell_x) < 2 && abs(global_plan[i].y - cell_y) < 2) {\n\t\t\tdiff = abs(atan2(global_plan[i].y - y, global_plan[i].x - x) - heading);\n\t\t}\n\t\ti++;\n\t}\n\treturn diff;\n}", "CodeBleu_score": 35.41270933857136}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//  ROS_DEBUG_NAMED(\"trajectory_planner\", \"Checking trajectory\");\n\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  if (cost >= 0) {\n    return true;\n  } else {\n    ROS_WARN_THROTTLE(1.0, \"Trajectory cost: %.3f (vx: %.3f, vy: %.3f, vtheta: %.3f)\", cost, vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }\n}", "CodeBleu_score": 75.07905282930602}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n#ifdef DEBUG\n    ROS_DEBUG(\"Checking trajectory %f, %f, %f, %f, %f, %f\", x, y, theta, vx, vy, vtheta);\n#endif\n\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    if (cost >= 0.0) {\n      return true;\n    } else {\n      ROS_WARN(\"The trajectory to (%f, %f, %f) is invalid. The cost is %f.\", x, y, theta, cost);\n      return false;\n    }\n  }", "CodeBleu_score": 69.77521116276634}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\tdouble impossible_cost = path_map_.obstacleCosts();\n    Trajectory t;\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // if the trajectory is valid, return true.\n    if( t.cost_ >= 0 ) {\n      return true;\n    } else {\n      ROS_WARN_STREAM(\"The trajectory to (\" << x << \", \" << y << \") is invalid (cost: \" << t.cost_ << \"). The sample velocities are: [\" << vx_samp << \", \" << vy_samp << \", \" << vtheta_samp << \"]\");\n      return false;\n    }\n  }", "CodeBleu_score": 55.051231063968}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tf (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (costmap_ros_ == NULL) {\n\t\tROS_ERROR(\"The costmap_ros object cannot be NULL. Doing nothing.\");\n\t\treturn;\n\t}\n\n\tif (clear_global_costmap_) {\n\t\tROS_INFO(\"Clearing global costmap\");\n\t\tcostmap_ros_->getGlobalCostmap()->resetMap(0, 0);\n\t\tcostmap_ros_->getGlobalCostmap()->updateMap();\n\t}\n\n\tif (clear_local_costmap_) {\n\t\tROS_INFO(\"Clearing local costmap\");\n\t\tcostmap_ros_->getLocalCostmap()->resetMap(0, 0);\n\t\tcostmap_ros_->getLocalCostmap()->updateMap();\n\t}\n\n\tif (clear_global_costmap_ && clear_local_costmap_) {\n\t\tROS_INFO(\"Clearing global and local costmaps\");\n\t\tcostmap_ros_->getGlobalCostmap()->resetMap(0, 0);\n\t\tcostmap_ros_->getLocalCostmap()->resetMap(0, 0);\n\t\tcostmap_ros_->getGlobalCostmap()->updateMap();\n\t\tcostmap_ros_->getLocalCostmap()->updateMap();\n\t}\n\n\tROS_INFO(\"Done clearing costmaps\");\n}", "CodeBleu_score": 32.13422693421481}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t// Initialize the outline cell collection object\n\tPolygonOutlineCells polygon_outline_cells(this);\n\n\t// Iterate through the polygon vertices\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\t// Get the current and next points\n\t\tMapLocation current = polygon[i];\n\t\tMapLocation next;\n\t\tif (i < polygon.size() - 1) {\n\t\t\tnext = polygon[i + 1];\n\t\t} else {\n\t\t\tnext = polygon[0];\n\t\t}\n\n\t\t// Collect cells between the current and next points\n\t\traytraceLine(current, next, polygon_outline_cells);\n\t}\n\n\t// Close the polygon by connecting the last point to the first\n\tif (!polygon.empty()) {\n\t\traytraceLine(polygon.back(), polygon.front(), polygon_outline_cells);\n\t}\n\n\t// Gather the collected cells\n\tpolygon_outline_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 58.025537778070515}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.empty()) {\n\t\tpolygon_cells.clear();\n\t\treturn;\n\t}\n\n\t// Initialize a PolygonOutlineCells object to collect the cells\n\tPolygonOutlineCells outline_cells;\n\toutline_cells.clear();\n\n\t// Iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points.\n\t// If the polygon is not empty, it also closes the polygon by connecting the last point to the first.\n\tfor (int i = 0; i < polygon.size(); i++) {\n\t\tif (i == 0) {\n\t\t\toutline_cells.raytraceLine(polygon[i], polygon[polygon.size() - 1]);\n\t\t}\n\t\telse {\n\t\t\toutline_cells.raytraceLine(polygon[i], polygon[i - 1]);\n\t\t}\n\t}\n\n\t// Copy the cells to the output vector\n\tpolygon_cells = outline_cells.getPolygonOutlineCells();\n}", "CodeBleu_score": 45.47500787125222}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells polygon_outline_cells(this);\n\tif (polygon.size() > 0) {\n\t\tMapLocation last = polygon.back();\n\t\tfor (std::vector<MapLocation>::const_iterator it = polygon.begin(); it!= polygon.end(); ++it) {\n\t\t\tMapLocation current = *it;\n\t\t\tif (current!= last) {\n\t\t\t\traytraceLine(last, current, polygon_outline_cells);\n\t\t\t}\n\t\t\tlast = current;\n\t\t}\n\t\tif (last!= polygon.front()) {\n\t\t\traytraceLine(last, polygon.front(), polygon_outline_cells);\n\t\t}\n\t}\n\tpolygon_cells = polygon_outline_cells.getPolygonOutlineCells();\n}", "CodeBleu_score": 38.8301577614511}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t", "CodeBleu_score": 10.992937465607893}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap mutex\n\tcostmap_mutex_.lock();\n\n\t// Get the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\n\t// Set the grid's resolution, width, and height\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tgeometry_msgs::Point origin = costmap_->mapToWorld(0, 0);\n\n\t// Set the origin's position and orientation\n\tgrid_.info.origin.position.x = origin.x;\n\tgrid_.info.origin.position.y = origin.y;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Save the origin coordinates\n\torigin_x_ = origin.x;\n\torigin_y_ = origin.y;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < costmap_->getSizeInCellsX(); i++) {\n\t\tfor (unsigned int j = 0; j < costmap_->getSizeInCellsY(); j++) {\n\t\t\tunsigned char cost = costmap_->getCost(i, j);\n\t\t\tgrid_.data[i + (j * grid_.info.width)] = cost_translation_table_[cost];\n\t\t}\n\t}\n\n\t// Unlock the costmap mutex\n\tcostmap_mutex_.unlock();\n}", "CodeBleu_score": 60.885147405312566}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap mutex\n\tcostmap_mutex_.lock();\n\n\t// Retrieve the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header, resolution, width, and height\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin and set the origin's position and orientation\n\tcostmap_->mapToWorld(0, 0, grid_.info.origin.position.x, grid_.info.origin.position.y);\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Save the origin coordinates and resize the grid data vector\n\torigin_x_ = grid_.info.origin.position.x;\n\torigin_y_ = grid_.info.origin.position.y;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < grid_.info.height; i++) {\n\t\tfor (unsigned int j = 0; j < grid_.info.width; j++) {\n\t\t\tunsigned int index = i * grid_.info.width + j;\n\t\t\tgrid_.data[index] = kCostmap2DValueTranslationTable[costmap_->getCharMapValue(j, i)];\n\t\t}\n\t}\n\n\t// Unlock the costmap mutex\n\tcostmap_mutex_.unlock();\n}", "CodeBleu_score": 54.98663489383509}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap mutex\n\tcostmap_mutex_.lock();\n\n\t// Retrieve the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_msg_.header.stamp = ros::Time::now();\n\tgrid_msg_.header.frame_id = frame_id_;\n\n\t// Set the resolution\n\tgrid_msg_.info.resolution = resolution;\n\n\t// Set the width and height\n\tgrid_msg_.info.width = costmap_->getSizeInCellsX();\n\tgrid_msg_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tdouble origin_x, origin_y, origin_th;\n\tcostmap_->getOrigin(origin_x, origin_y, origin_th);\n\n\t// Set the origin's position and orientation\n\tgrid_msg_.info.origin.position.x = origin_x;\n\tgrid_msg_.info.origin.position.y = origin_y;\n\tgrid_msg_.info.origin.position.z = 0.0;\n\tgrid_msg_.info.origin.orientation = tf::createQuaternionMsgFromYaw(origin_th);\n\n\t// Save the origin coordinates\n\torigin_x_ = origin_x;\n\torigin_y_ = origin_y;\n\torigin_th_ = origin_th;\n\n\t// Resize the grid data vector\n\tgrid_msg_.data.resize(grid_msg_.info.width * grid_msg_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < grid_msg_.info.width; i++) {\n\t\tfor (unsigned int j = 0; j < grid_msg_.info.height; j++) {\n\t\t\tint index = i + j * grid_msg_.info.width;\n\t\t\tgrid_msg_.data[index] = translation_table_[costmap_->getCharMap()[i][j]];\n\t\t}\n\t}\n\n\t// Unlock the costmap mutex\n\tcostmap_mutex_.unlock();\n}", "CodeBleu_score": 51.446630429492124}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t#if 0\n  // check if the footprint is the same as the old one\n  if (new_config.footprint == old_config.footprint &&\n      new_config.inflation_radius == old_config.inflation_radius) {\n    return;\n  }\n\n  // check if the footprint is valid\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> footprint;\n    if (!parseFootprintString(new_config.footprint, footprint)) {\n      ROS_ERROR(\"The footprint string is invalid. Using default footprint.\");\n      return;\n    }\n\n    setUnpaddedRobotFootprint(footprint);\n    return;\n  }\n\n  // set the footprint based on the robot radius\n  double radius = new_config.inflation_radius;\n  if (radius <= 0) {\n    ROS_ERROR(\"The inflation radius must be positive. Using default footprint.\");\n    return;\n  }\n\n  setUnpaddedRobotFootprint(getRobotFootprint(radius));\n#endif\n}", "CodeBleu_score": 60.616543034344026}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t//  if (new_config.robot_radius == old_config.robot_radius) {\n//    return;\n//  }\n\n  if (new_config.footprint!= old_config.footprint) {\n    if (new_config.footprint.size() == 0) {\n      ROS_ERROR(\"Footprint string is empty.  Please check your yaml file.\");\n    } else {\n      std::vector<geometry_msgs::Point> points;\n      if (parseFootprintString(new_config.footprint, points)) {\n        setUnpaddedRobotFootprint(points);\n      } else {\n        ROS_ERROR(\"Footprint string is invalid.  Please check your yaml file.\");\n      }\n    }\n  }\n}", "CodeBleu_score": 48.631458363878686}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint == old_config.footprint && new_config.inflation_radius == old_config.inflation_radius) {\n\t\treturn;\n\t}\n\n\tif (new_config.footprint!= \"\") {\n\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\tif (parseFootprintString(new_config.footprint, footprint)) {\n\t\t\tsetUnpaddedRobotFootprint(footprint);\n\t\t} else {\n\t\t\tROS_ERROR(\"Could not read footprint from config, using default\");\n\t\t\tsetUnpaddedRobotFootprint(std::vector<geometry_msgs::Point>());\n\t\t}\n\t} else {\n\t\tsetUnpaddedRobotFootprint(std::vector<geometry_msgs::Point>());\n\t}\n}", "CodeBleu_score": 61.949296464173784}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// get the current robot pose\n  geometry_msgs::PoseStamped global_pose;\n  if (!getRobotPose(global_pose)) {\n    ROS_WARN(\"Failed to get robot pose, cancelling reconfigure callback.\");\n    cancelReconfigure();\n    return;\n  }\n\n  // store the pose in new_pose\n  new_pose = global_pose;\n  new_pose_received_ = true;\n}", "CodeBleu_score": 59.099188818629045}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// get the current pose of the robot\n\tgeometry_msgs::PoseStamped global_pose;\n\tif (!getRobotPose(global_pose))\n\t{\n\t\tROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\t// check if the robot has moved since the last time we were here\n\tif (fabs(global_pose.pose.position.x - last_global_pose_.pose.position.x) < 0.01 &&\n\t\tfabs(global_pose.pose.position.y - last_global_pose_.pose.position.y) < 0.01 &&\n\t\tfabs(global_pose.pose.position.z - last_global_pose_.pose.position.z) < 0.01 &&\n\t\tfabs(tf2::getYaw(global_pose.pose.orientation) - tf2::getYaw(last_global_pose_.pose.orientation)) < 0.01)\n\t{\n\t\treturn;\n\t}\n\t// update the last pose\n\tlast_global_pose_ = global_pose;\n\t// update the costmap\n\tupdateCostmap(global_pose);\n}", "CodeBleu_score": 53.00787633553681}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tgeometry_msgs::PoseStamped global_pose;\n\tif (getRobotPose(global_pose)) {\n\t\tnew_pose_ = global_pose;\n\t} else {\n\t\tROS_WARN_THROTTLE(1.0, \"Could not get robot pose, cancelling reconfigure\");\n\t\tcancelReconfigure();\n\t}\n}", "CodeBleu_score": 70.69493843512194}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\t// TODO: implement\n}", "CodeBleu_score": 1.5748498721036488}, {"code": "void Costmap2DROS::start(){\n\t", "CodeBleu_score": 1.488121648976743}, {"code": "void Costmap2DROS::start(){\n\t\t// Get the list of plugins\n\tstd::vector<std::string> plugins;\n\tif (!nh_.getParam(\"plugins\", plugins)) {\n\t\tROS_WARN(\"No plugins given. Costmap2D will not be initialized.\");\n\t\treturn;\n\t}\n\n\t// Check if the costmap was stopped\n\tbool stopped = false;\n\tif (nh_.getParam(\"stopped\", stopped) && stopped) {\n\t\t// Re-subscribe to topics\n\t\tfor (unsigned int i = 0; i < plugins.size(); i++) {\n\t\t\t// Check if the plugin is active\n\t\t\tbool active = false;\n\t\t\tnh_.getParam(\"plugins/\" + plugins[i] + \"/active\", active);\n\t\t\tif (active) {\n\t\t\t\t// Activate the plugin\n\t\t\t\tactivatePlugin(plugins[i]);\n\t\t\t}\n\t\t}\n\n\t\t// Set the stopped flag to false\n\t\tnh_.setParam(\"stopped\", false);\n\t\tstopped = false;\n\t}\n\n\t// Wait for ROS to be running\n\twhile (!ros::ok()) {\n\t\tROS_INFO(\"Waiting for ROS to be running...\");\n\t\tros::WallDuration(0.5).sleep();\n\t}\n\n\t// Initialize the costmap\n\tif (!initialized_) {\n\t\t// Initialize the costmap\n\t\tinitialize();\n\n\t\t// Wait for the map update thread to be active\n\t\twhile (!map_update_thread_active_) {\n\t\t\tROS_INFO(\"Waiting for the map update thread to be active...\");\n\t\t\tros::WallDuration(0.5).sleep();\n\t\t}\n\t}\n\n\t// Set the stop_updates_ flag to false\n\tstop_updates_ = false;\n\n\t// Start the costmap\n\tROS_INFO(\"Costmap2D is now started.\");\n}", "CodeBleu_score": 45.28427135930125}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If the keep time is zero, we only keep the most recent observation\n\tif (observation_keep_time_ == 0) {\n\t\tif (observations_.size() > 1) {\n\t\t\tobservations_.erase(observations_.begin());\n\t\t}\n\t\treturn;\n\t}\n\n\t// Otherwise, we need to iterate through the list and remove observations that are older than the specified keep time\n\tfor (std::vector<Observation>::iterator it = observations_.begin(); it!= observations_.end(); ++it) {\n\t\tif (it->time_ > (ros::Time::now() - ros::Duration(observation_keep_time_))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// If we get here, we've iterated through the entire list and haven't found a valid observation, so we remove the oldest observation\n\tobservations_.erase(observations_.begin());\n}", "CodeBleu_score": 38.964378038445844}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If the observation_keep_time_ is zero, it keeps only the most recent observation.\n\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\n\t// Otherwise, it iterates through the list and removes observations that are older than the specified keep time, stopping once it finds a valid observation.\n\tfor (auto it = observations_.begin(); it!= observations_.end();) {\n\t\tif (it->first < ros::Time::now() - ros::Duration(observation_keep_time_)) {\n\t\t\tit = observations_.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n}", "CodeBleu_score": 30.60754012424675}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If the keep time is zero, we only keep the most recent observation.\n\tif (observation_keep_time_ == 0) {\n\t\tif (observations_.size() > 1) {\n\t\t\tobservations_.pop_front();\n\t\t}\n\t} else {\n\t\t// Otherwise, we iterate through the list and remove observations that are older than the keep time.\n\t\tfor (auto it = observations_.begin(); it!= observations_.end(); it++) {\n\t\t\tif (it->time_stamp_ < (ros::Time::now() - ros::Duration(observation_keep_time_))) {\n\t\t\t\tobservations_.erase(it);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.01070839782726}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\tdouble angle_diff = shortest_angular_distance(start_yaw, end_yaw);\n\tdouble angle_increment = angle_diff / (end_index - start_index);\n\tfor (int i = start_index; i <= end_index; i++) {\n\t\tdouble angle = start_yaw + angle_increment * (i - start_index);\n\t\tset_angle(&path[i], angle);\n\t}\n}", "CodeBleu_score": 69.76734828453304}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t//  std::cout << \"start_index: \" << start_index << \", end_index: \" << end_index << std::endl;\n  // Calculate the yaw angles at the start and end indices\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end angles\n  double shortest_angle = shortest_angular_distance(start_angle, end_angle);\n\n  // Compute the incremental change in angle for each pose\n  double angle_increment = shortest_angle / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    double angle = start_angle + angle_increment * (i - start_index);\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 64.7188645788997}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t//  std::cout << \"interpolate\" << std::endl;\n  if (path.size() == 0) {\n    return;\n  }\n  double start_angle = get_yaw(path[start_index]);\n  double end_angle = get_yaw(path[end_index]);\n  double angle_diff = end_angle - start_angle;\n  if (angle_diff > M_PI) {\n    angle_diff -= 2 * M_PI;\n  } else if (angle_diff < -M_PI) {\n    angle_diff += 2 * M_PI;\n  }\n  double angle_increment = angle_diff / (end_index - start_index);\n  for (int i = start_index; i <= end_index; i++) {\n    set_angle(&path[i], start_angle + angle_increment * (i - start_index));\n  }\n}", "CodeBleu_score": 50.00080255113307}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Making plan...\");\n\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tbool success = makePlan(req.start, req.goal, resp.plan.poses);\n\n\t// Update the response with the success status and the generated path if a plan is found\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.plan.header.frame_id = \"map\";\n\tresp.success = success;\n\n\treturn true;\n}", "CodeBleu_score": 61.374018380461656}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tif (makePlan(req.start, req.goal, resp.plan.poses)) {\n\t\t// Update the response with the success status and the generated path if a plan is found\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t\tresp.plan.header.frame_id = \"map\";\n\t\tresp.status = navfn::MakeNavPlan::Response::SUCCESS;\n\t} else {\n\t\t// Otherwise, update the response with the failure status\n\t\tresp.status = navfn::MakeNavPlan::Response::FAILURE;\n\t}\n\n\t// Return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 46.55975816517531}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received makePlan request\");\n\t//set the frame_id of the start and goal to \"map\"\n\t//this is required for the GlobalPlanner\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t//call makePlan to generate a path\n\tif (makePlan(req.start, req.goal, resp.plan.poses)) {\n\t\t//update the response with the success status and the generated path\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t\tresp.plan.header.frame_id = \"map\";\n\t\tresp.error_code = resp.error_code.SUCCESS;\n\t} else {\n\t\t//if no plan is found, update the response with the failure status\n\t\tresp.error_code = resp.error_code.FAILURE;\n\t}\n\n\t//return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 46.17697760150779}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t", "CodeBleu_score": 18.432682072468964}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\"~/\" + name);\n\n\t// Create the service\n\tmake_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n\t// Create the goal subscriber\n\tgoal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 68.37756550798804}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t", "CodeBleu_score": 18.432682072468964}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < world_size_x_ / 2 && wx > -world_size_x_ / 2 && wy < world_size_y_ / 2 && wy > -world_size_y_ / 2) {\n\t\tmx = wx / resolution_x_ + origin_x_;\n\t\tmy = wy / resolution_y_ + origin_y_;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 25.697311124981816}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < origin_x_ || wy < origin_y_) {\n\t\tROS_WARN(\"The world coordinates supplied to worldToMap are out of bounds.\n\"\n\t\t\t\"World coordinate x: %f\n\"\n\t\t\t\"World coordinate y: %f\n\"\n\t\t\t\"Origin x: %f\n\"\n\t\t\t\"Origin y: %f\n\"\n\t\t\t\"The costmap will be filled with infs.\n\",\n\t\t\twx, wy, origin_x_, origin_y_);\n\t\tmx = my = std::numeric_limits<double>::infinity();\n\t\treturn false;\n\t}\n\tmx = (wx - origin_x_) / resolution_;\n\tmy = (wy - origin_y_) / resolution_;\n\treturn true;\n}", "CodeBleu_score": 44.340867372466285}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < origin_x_ || wy < origin_y_) {\n\t\tROS_WARN(\"The world coordinates passed to worldToMap are outside the bounds of the costmap. \"\n\t\t\t\t\"They were not mapped.\");\n\t\treturn false;\n\t}\n\n\tmx = (wx - origin_x_) / resolution_;\n\tmy = (wy - origin_y_) / resolution_;\n\n\tif (mx < 0 || mx >= width_ || my < 0 || my >= height_) {\n\t\tROS_WARN(\"The world coordinates passed to worldToMap are outside the bounds of the costmap. \"\n\t\t\t\t\"They were not mapped.\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 42.599873023719404}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\t// Create a nav_msgs::Path message\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\t// Set the header\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Copy the poses from the input path\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\t// Publish the Path message\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.98158984520875}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\t// Create a nav_msgs::Path with the path, using this planner's frame ID\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.98158984520875}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif(!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t// Create a nav_msgs::Path with the custom header needed\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Copy the poses from the input path to the output path\n\tfor(unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\t// Publish the path\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 89.15033241061802}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\t// Create a MoveBaseActionGoal message\n\tactionlib_msgs::MoveBaseActionGoal goal_msg;\n\t// Set the timestamp of the goal message to the current time\n\tgoal_msg.header.stamp = ros::Time::now();\n\t// Assign the received goal to the target_pose\n\tgoal_msg.goal.target_pose = *goal;\n\t// Publish the goal message to the action_goal_pub_ topic\n\taction_goal_pub_.publish(goal_msg);\n\tROS_DEBUG(\"Goal received\");\n}", "CodeBleu_score": 56.360313578946744}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\t// Create a new action goal message\n\tmove_base_msgs::MoveBaseActionGoal goal_msg;\n\n\t// Set the timestamp of the goal message\n\tgoal_msg.header.stamp = ros::Time::now();\n\n\t// Assign the received goal to the target_pose of the goal message\n\tgoal_msg.goal.target_pose = *goal;\n\n\t// Publish the goal message to the action_goal_pub_ topic\n\taction_goal_pub_.publish(goal_msg);\n}", "CodeBleu_score": 53.076584170519816}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t", "CodeBleu_score": 7.204876027809698}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (getSqDistance() > sq_distance_limit_) {\n\t\tROS_INFO(\"Robot has moved sufficient distance, removing speed limit\");\n\t\tif (remove_limit_thread_.joinable()) {\n\t\t\tremove_limit_thread_.join();\n\t\t}\n\t\tremove_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 40.43877391663368}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble sq_dist = getSqDistance();\n\tif (sq_dist > sq_limit_distance_) {\n\t\tROS_INFO(\"Robot moved far enough, removing speed limit\");\n\t\tremove_limit_thread_ = boost::shared_ptr<boost::thread>(new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this)));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 43.263809592473315}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (getSqDistance() > sq_distance_limit_) {\n\t\tROS_INFO(\"Robot has moved far enough, removing speed limit\");\n\t\tif (remove_limit_thread_.joinable()) {\n\t\t\tremove_limit_thread_.join();\n\t\t}\n\t\tremove_limit_thread_ = std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 42.379294635364204}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// get current pose\n\tgeometry_msgs::PoseStamped global_pose;\n\tgetRobotPose(global_pose);\n\n\t// create path\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\tmakePlan(global_pose, *goal, path);\n\n\t// publish path\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.stamp = ros::Time::now();\n\tpath_msg.header.frame_id = global_frame_;\n\tpath_msg.poses.resize(path.size());\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tpath_msg.poses[i] = path[i];\n\t}\n\tpath_pub_.publish(path_msg);\n}", "CodeBleu_score": 60.411390573482436}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t", "CodeBleu_score": 9.194105522934656}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// get the current robot pose\n\tgeometry_msgs::PoseStamped robot_pose;\n\tgetRobotPose(robot_pose);\n\n\t// make a plan to the goal\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\tmakePlan(robot_pose, *goal, path);\n\n\t// publish the path\n\tpublishPlan(path);\n}", "CodeBleu_score": 56.930012495329805}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create a param_set_srv_ request\n\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.param_value = param_set.param_value;\n\tparam_set_srv.request.target_system = param_set.target_system;\n\tparam_set_srv.request.target_component = param_set.target_component;\n\n\t// Send the request\n\tif (!param_set_client_.call(param_set_srv)) {\n\t\tROS_ERROR(\"Failed to call service param_set\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 49.834268935536755}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create a param_set_client_ service request\n\tmavros_msgs::ParamSet srv_set;\n\tsrv_set.request.param_id = param_set.param_id;\n\tsrv_set.request.value = param_set.value;\n\t// Send the service request\n\tif (param_set_client_.call(srv_set)) {\n\t\tROS_INFO(\"Gimbal Param ID: %s, Value: %s\", srv_set.request.param_id.c_str(), srv_set.request.value.c_str());\n\t} else {\n\t\tROS_ERROR(\"Failed to call service param_set\");\n\t\tros::shutdown();\n\t}\n}", "CodeBleu_score": 51.98937677661899}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// create a ParamSet service request\n\tmavros_msgs::ParamSet srv_set;\n\tsrv_set.request.param_id = param_set.param_id;\n\tsrv_set.request.param_value = param_set.param_value;\n\t// send the request\n\tif (param_set_client_.call(srv_set)) {\n\t\tROS_INFO(\"Gimbal ParamSet: %s = %s\", param_set.param_id.c_str(), param_set.param_value.c_str());\n\t} else {\n\t\tROS_ERROR(\"Failed to call service ParamSet\");\n\t}\n}", "CodeBleu_score": 51.197151121050254}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t\t// Create socket and bind to port\n\tint server_socket;\n\tif ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n\t\tstd::cerr << \"Socket creation failed\" << std::endl;\n\t\treturn;\n\t}\n\tstruct sockaddr_in address;\n\taddress.sin_family = AF_INET;\n\taddress.sin_addr.s_addr = INADDR_ANY;\n\taddress.sin_port = htons(port);\n\n\tif (bind(server_socket, (struct sockaddr *) &address, sizeof(address)) < 0) {\n\t\tstd::cerr << \"Socket bind failed\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Listen for connections\n\tif (listen(server_socket, 3) < 0) {\n\t\tstd::cerr << \"Socket listen failed\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Accept a connection\n\tint client_socket;\n\tstruct sockaddr_in client_address;\n\tint addrlen = sizeof(client_address);\n\tif ((client_socket = accept(server_socket, (struct sockaddr *) &client_address, (socklen_t *) &addrlen)) < 0) {\n\t\tstd::cerr << \"Socket accept failed\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Loop to accept connections and process data\n\twhile (true) {\n\t\t// Receive data\n\t\tint recv_len;\n\t\tchar *buffer = new char[256];\n\t\tif ((recv_len = recv(client_socket, buffer, 256, 0)) <= 0) {\n\t\t\tstd::cerr << \"Socket receive failed\" << std::endl;\n\t\t\treturn;\n\t\t}\n\n\t\t// Decode data\n\t\tchar *decoded_buffer = new char[256];\n\t\tdecode(buffer, decoded_buffer);\n\n\t\t// Publish data\n\t\tif (recv_len > 0) {\n\t\t\tstd::string decoded_string(decoded_buffer);\n\t\t\tstd::cout << decoded_string << std::endl;\n\t\t\tpub.publish(decoded_string);\n\t\t}\n\n\t\t// Close connection\n\t\tclose(client_socket);\n\t}\n}", "CodeBleu_score": 43.52582665102496}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\t// If not in simulation mode, publish to a single UAV using uav_basic_\n\tif (!simulation_mode_) {\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n\t// If in simulation mode, find the corresponding UAV by ID and publish to it\n\telse {\n\t\t// Find the corresponding UAV\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].uav_id == uav_cmd.uav_id) {\n\t\t\t\tswarm_control_simulation_[i].uav_basic.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.76026138497398}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (simulation_mode_) {\n\t\t// find the corresponding UAV by ID from swarm_control_simulation_\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].uav_id == uav_cmd.uav_id) {\n\t\t\t\t// publish the command to the matching UAV\n\t\t\t\tuav_basic_pub_[i].publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// publish the command to a single UAV using uav_basic_\n\t\tuav_basic_pub_.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 36.40077121924977}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (!simulation_mode_) {\n\t\tuav_basic_.publish(uav_cmd);\n\t} else {\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].id == uav_cmd.id) {\n\t\t\t\tswarm_control_simulation_[i].uav_basic_.publish(uav_cmd);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.215788025948456}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"reboot nx\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exit nx\");\n\t} else if (mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 49.30237061978035}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif(mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t}\n\telse if(mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exit\");\n\t}\n\telse if(mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection);\n\t}\n\telse if(mode_selection.use_mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 54.60965054882239}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == 0) {\n\t\t//REBOOTNX\n\t\tstd::string command = \"rebootnx\";\n\t\tsystem(command.c_str());\n\t} else if (mode_selection.use_mode == 1) {\n\t\t//EXITNX\n\t\tstd::string command = \"exitnx\";\n\t\tsystem(command.c_str());\n\t} else if (mode_selection.use_mode == 2) {\n\t\t//CREATEMODE\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == 3) {\n\t\t//DELETEMODE\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 48.838938443279375}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (this->is_connected) {\n\t\tthis->heartbeat_count++;\n\t\tif (this->heartbeat_count > this->heartbeat_max_count) {\n\t\t\tthis->disconnect_flag = true;\n\t\t}\n\t}\n\telse {\n\t\tthis->heartbeat_count = 0;\n\t}\n}", "CodeBleu_score": 6.305335211828073}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// If the heartbeat has been received for a certain number of times, it is assumed that the vehicle is still connected\n\tif (heartbeat_count > HEARTBEAT_COUNT_THRESHOLD) {\n\t\t// Reset the heartbeat count\n\t\theartbeat_count = 0;\n\n\t\t// If the vehicle is a swarm, print an error message\n\t\tif (vehicle_type == \"swarm\") {\n\t\t\tROS_ERROR(\"No heartbeat received from swarm. Check connection to vehicle.\");\n\t\t}\n\t\t// If the vehicle is a UAV, print an error message\n\t\telse if (vehicle_type == \"uav\") {\n\t\t\tROS_ERROR(\"No heartbeat received from UAV. Check connection to vehicle.\");\n\t\t}\n\t\t// If the vehicle is a UGV, print an error message\n\t\telse if (vehicle_type == \"ugv\") {\n\t\t\tROS_ERROR(\"No heartbeat received from UGV. Check connection to vehicle.\");\n\t\t}\n\t}\n\t// If the heartbeat has not been received for a certain number of times, it is assumed that the vehicle is disconnected\n\telse {\n\t\t// Increment the heartbeat count\n\t\theartbeat_count++;\n\n\t\t// If the vehicle is a swarm, print an error message\n\t\tif (vehicle_type == \"swarm\") {\n\t\t\tROS_ERROR(\"Swarm heartbeat has not been received for %d attempts. Check connection to vehicle.\", heartbeat_count);\n\t\t}\n\t\t// If the vehicle is a UAV, print an error message\n\t\telse if (vehicle_type == \"uav\") {\n\t\t\tROS_ERROR(\"UAV heartbeat has not been received for %d attempts. Check connection to vehicle.\", heartbeat_count);\n\t\t}\n\t\t// If the vehicle is a UGV, print an error message\n\t\telse if (vehicle_type == \"ugv\") {\n\t\t\tROS_ERROR(\"UGV heartbeat has not been received for %d attempts. Check connection to vehicle.\", heartbeat_count);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.879702713065235}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// Check heartbeat status\n\tif (heartbeat_count_ == 0) {\n\t\t// Check vehicle type\n\t\tif (vehicle_type_ == \"swarm\") {\n\t\t\t// Print error message\n\t\t\tROS_ERROR(\"No heartbeat received from swarm. Disconnecting...\");\n\t\t\t// Set disconnect flag\n\t\t\tdisconnect_flag_ = true;\n\t\t} else if (vehicle_type_ == \"uav\") {\n\t\t\t// Print error message\n\t\t\tROS_ERROR(\"No heartbeat received from UAV. Disconnecting...\");\n\t\t\t// Set disconnect flag\n\t\t\tdisconnect_flag_ = true;\n\t\t} else if (vehicle_type_ == \"ugv\") {\n\t\t\t// Print error message\n\t\t\tROS_ERROR(\"No heartbeat received from UGV. Disconnecting...\");\n\t\t\t// Set disconnect flag\n\t\t\tdisconnect_flag_ = true;\n\t\t} else {\n\t\t\t// Print error message\n\t\t\tROS_ERROR(\"No heartbeat received from vehicle. Disconnecting...\");\n\t\t\t// Set disconnect flag\n\t\t\tdisconnect_flag_ = true;\n\t\t}\n\t}\n\t// Increment heartbeat counter\n\theartbeat_count_++;\n}", "CodeBleu_score": 29.060604762468174}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\tint drone_id;\n\tstd::vector<prometheus_msgs::Bspline> bsplines_vec;\n\tprometheus_msgs::MultiBsplines multi_bsplines;\n\n\t// Extract the drone ID from the message\n\tdrone_id = msg->drone_id;\n\n\t// Extract the bsplines from the message\n\tbsplines_vec = msg->bsplines;\n\n\t// Initialize the MultiBsplines message\n\tmulti_bsplines.drone_id = drone_id;\n\n\t// Iterate through the bsplines vector\n\tfor (int i = 0; i < bsplines_vec.size(); i++) {\n\t\t// Initialize a Bspline struct\n\t\tBspline bspline;\n\n\t\t// Set the attributes of the Bspline struct\n\t\tbspline.num_knots = bsplines_vec[i].num_knots;\n\t\tbspline.num_pos_points = bsplines_vec[i].num_pos_points;\n\t\tbspline.num_yaw_points = bsplines_vec[i].num_yaw_points;\n\t\tbspline.num_yaw_points_per_knot = bsplines_vec[i].num_yaw_points_per_knot;\n\n\t\t// Set the knots of the Bspline struct\n\t\tbspline.knots = bsplines_vec[i].knots;\n\n\t\t// Set the position points of the Bspline struct\n\t\tbspline.pos_points = bsplines_vec[i].pos_points;\n\n\t\t// Set the yaw points of the Bspline struct\n\t\tbspline.yaw_points = bsplines_vec[i].yaw_points;\n\n\t\t// Add the Bspline struct to the MultiBsplines message\n\t\tmulti_bsplines.bsplines.push_back(bspline);\n\t}\n\n\t// Encode the MultiBsplines message\n\tstd::string multi_bsplines_str = multi_bsplines.encode();\n\n\t// Send the MultiBsplines message via TCP\n\tcomm_module->send_tcp(multi_bsplines_str);\n}", "CodeBleu_score": 34.62799912766585}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t//ROS_INFO(\"EGOPlannerSwarm::multitrajSubTcpCb() called\");\n\n\t// Initialize the MultiBsplines message\n\tprometheus_msgs::MultiBsplines multiBsplines;\n\n\t// Iterate through the trajectory data\n\tfor (int i = 0; i < msg->trajectories.size(); i++) {\n\t\t// Extract the drone ID and trajectory data\n\t\tint droneId = msg->trajectories[i].droneId;\n\t\tprometheus_msgs::Trajectory trajectory = msg->trajectories[i].trajectory;\n\n\t\t// Initialize the Bspline struct\n\t\tBspline bspline;\n\n\t\t// Set the attributes of the Bspline struct\n\t\tbspline.droneId = droneId;\n\t\tbspline.time = trajectory.time;\n\t\tbspline.duration = trajectory.duration;\n\t\tbspline.numKnots = trajectory.numKnots;\n\t\tbspline.numPositionPoints = trajectory.numPositionPoints;\n\t\tbspline.numYawPoints = trajectory.numYawPoints;\n\n\t\t// Populate the knots, position points, and yaw points of the Bspline struct\n\t\tbspline.knots = trajectory.knots;\n\t\tbspline.positionPoints = trajectory.positionPoints;\n\t\tbspline.yawPoints = trajectory.yawPoints;\n\n\t\t// Add the Bspline struct to the MultiBsplines message\n\t\tmultiBsplines.trajectories.push_back(bspline);\n\t}\n\n\t// Encode the MultiBsplines message\n\tstd::string encodedMultiBsplines = encodeMultiBsplines(multiBsplines);\n\n\t// Send the MultiBsplines message via TCP\n\ttcpClient->send(encodedMultiBsplines);\n}", "CodeBleu_score": 36.85199229271154}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Create a new PointCloud2 message\n\tsensor_msgs::PointCloud2 compressed_msg;\n\n\t// Create a new PointCloud from the input message\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Create an octree compression object\n\toctomap::OcTree tree(0.05);\n\n\t// Insert the points from the input message into the octree\n\tfor (size_t i = 0; i < cloud.points.size(); i++) {\n\t\ttree.insertRay(octomap::point3d(cloud.points[i].x, cloud.points[i].y, cloud.points[i].z), true);\n\t}\n\n\t// Compress the octree\n\ttree.updateInnerOccupancy();\n\ttree.prune();\n\ttree.updateInnerOccupancy();\n\n\t// Create a new PointCloud2 message from the compressed octree\n\tpcl::toROSMsg(tree, compressed_msg);\n\n\t// Return the compressed message\n\treturn compressed_msg;\n}", "CodeBleu_score": 25.258499342943715}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Create an octree compression object\n\toctomap::OcTree tree(0.05);\n\n\t// Add points to the octree\n\tfor (size_t i = 0; i < cloud.points.size(); i++) {\n\t\ttree.updateNode(octomap::point3d(cloud.points[i].x, cloud.points[i].y, cloud.points[i].z), true);\n\t}\n\n\t// Compress the octree\n\ttree.updateInnerOccupancy();\n\ttree.prune();\n\n\t// Create a new PointCloud2 message with the compressed data\n\tpcl::PointCloud<pcl::PointXYZ> compressed_cloud;\n\toctomap_msgs::pointCloudToPointCloud2(tree, compressed_cloud);\n\tsensor_msgs::PointCloud2 compressed_msg;\n\tpcl::toROSMsg(compressed_cloud, compressed_msg);\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 30.300408035957865}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(msg, *cloud);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\tsor.setInputCloud(cloud);\n\tsor.setLeafSize(0.001f, 0.001f, 0.001f);\n\tsor.filter(*cloud_filtered);\n\tsensor_msgs::PointCloud2 output;\n\tpcl::toROSMsg(*cloud_filtered, output);\n\treturn output;\n}", "CodeBleu_score": 29.38096570732318}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].id == uav_state.id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 52.776897281810065}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\t// Iterate through the list of UAV states and replace the matching UAV state with the new uav_state data based on the UAV ID.\n\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 54.16810391344823}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 58.95573600406434}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_count = m_multi_ugv_state.ugv_count;\n\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tUGVState ugv_state;\n\t\tugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\t\tmulti_ugv_state.ugv_state.push_back(ugv_state);\n\t}\n\n\tm_pub_all_ugv_state.publish(multi_ugv_state);\n}", "CodeBleu_score": 43.388019483098894}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tUGVState ugv_state;\n\t\tugv_state.id = m_multi_ugv_state.ugv_states[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_states[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_states[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_states[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_states[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_states[i].attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_states[i].attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_states[i].attitude.yaw;\n\t\tmulti_ugv_state.ugv_states.push_back(ugv_state);\n\t}\n\tmulti_ugv_state.ugv_count = m_multi_ugv_state.ugv_count;\n\tm_multi_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 43.11682435963188}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tgradient.setZero(q.rows(), q.cols());\n\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\tdouble qi = q(0, i);\n\t\tdouble qdoti = q(1, i);\n\t\tdouble qdotdoti = q(2, i);\n\n\t\t// Predict the position of moving objects\n\t\tEigen::VectorXd obj_pos = predictObjPos(qi, qdoti, qdotdoti);\n\n\t\t// Evaluate the distance between control points and predicted positions of moving objects\n\t\tfor (int j = 0; j < obj_pos.size(); j++) {\n\t\t\tdouble dist = (obj_pos(j) - q(0, i)).norm();\n\t\t\tif (dist < clearance) {\n\t\t\t\tcost += dist;\n\t\t\t\tgradient(0, i) += (obj_pos(j) - q(0, i)) / dist;\n\t\t\t\tgradient(1, i) += (obj_pos(j) - q(0, i)) / dist;\n\t\t\t\tgradient(2, i) += (obj_pos(j) - q(0, i)) / dist;\n\t\t\t}\n\t\t}\n\t}\n\n\tcost *= 0.5;\n}", "CodeBleu_score": 35.20282137253431}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize cost to zero\n\tcost = 0;\n\n\t// Initialize gradient to zero\n\tgradient.setZero(q.rows(), q.cols());\n\n\t// Iterate through control points\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// Compute positional error\n\t\tEigen::Vector3d err = q.col(i) - qRef.col(i);\n\n\t\t// Compute velocity vector\n\t\tEigen::Vector3d vel = (q.col(i) - q.col(i - 1)) / dt;\n\n\t\t// Compute cost function\n\t\tcost += a2 * err.dot(err) + b2 * vel.cross(err).dot(vel);\n\n\t\t// Compute gradient\n\t\tgradient.col(i) = 2 * a2 * err + 2 * b2 * vel.cross(vel);\n\t}\n}", "CodeBleu_score": 23.898708765864612}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize cost to zero\n\tcost = 0;\n\t// Initialize gradient to zero\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through control points\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// Compute positional error\n\t\tEigen::VectorXd error = q.col(i) - q_ref.col(i);\n\t\t// Compute velocity vector\n\t\tEigen::VectorXd velocity = q.col(i) - q.col(i - 1);\n\n\t\t// Update cost\n\t\tcost += a2 * error.dot(error) + b2 * velocity.dot(velocity);\n\n\t\t// Update gradient\n\t\tgradient.col(i) = 2 * (a2 * error + b2 * velocity);\n\t}\n}", "CodeBleu_score": 23.106116925679178}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tUniformBspline jerk = getDerivative().getDerivative();\n\tEigen::VectorXd knot = jerk.getKnot();\n\tEigen::MatrixXd ctp = jerk.getControlPoints();\n\tdouble jerkVal = 0;\n\tfor (int i = 0; i < ctp.rows(); i++) {\n\t\tfor (int j = 0; j < ctp.cols(); j++) {\n\t\t\tjerkVal += ctp(i, j) * ctp(i, j) * (knot(i + 1) - knot(i));\n\t\t}\n\t}\n\treturn jerkVal;\n}", "CodeBleu_score": 57.957296328690866}, {"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd ctp = getDerivativeControlPoints();\n\tUniformBspline jerk(ctp, p_ - 1, interval_);\n\tEigen::VectorXd knot(u_.rows() - 2);\n\tknot = u_.segment(1, u_.rows() - 2);\n\tjerk.setKnot(knot);\n\tdouble jerkValue = 0;\n\tfor (int i = 0; i < jerk.getControlPoints().rows(); i++) {\n\t\tfor (int j = 0; j < jerk.getControlPoints().cols(); j++) {\n\t\t\tjerkValue += jerk.getControlPoints()(i, j) * jerk.getControlPoints()(i, j) * (knot(i + 1) - knot(i));\n\t\t}\n\t}\n\treturn jerkValue;\n}", "CodeBleu_score": 51.42795428146334}, {"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd ctp = getDerivativeControlPoints();\n\tctp = getDerivativeControlPoints();\n\tUniformBspline jerk(ctp, p_ - 1, interval_);\n\n\t/* cut the first and last knot */\n\tEigen::VectorXd knot(u_.rows() - 2);\n\tknot = u_.segment(1, u_.rows() - 2);\n\tjerk.setKnot(knot);\n\n\tdouble jerk_value = 0;\n\tfor (int i = 0; i < ctp.rows(); i++) {\n\t\tfor (int j = 0; j < ctp.cols(); j++) {\n\t\t\tjerk_value += ctp(i, j) * ctp(i, j) * (u_(i + 1) - u_(i));\n\t\t}\n\t}\n\n\treturn jerk_value;\n}", "CodeBleu_score": 58.65453888932963}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 74.49740701774701}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tfloat x = (u - cx_) * depth / fx_;\n\tfloat y = (v - cy_) * depth / fy_;\n\treturn Eigen::Vector4d(x, y, depth, 1);\n}", "CodeBleu_score": 48.717612566245805}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 75.71884142349269}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, odom.child_frame_id);\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR(\"Failed to extract drone ID from odometry message: %s\", e.what());\n\t}\n}", "CodeBleu_score": 38.0403806204549}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\t// Extract the drone ID from the child_frame_id field of the odometry message\n\t\tint drone_id = boost::lexical_cast<int>(odom.child_frame_id.substr(odom.child_frame_id.find_last_of(\"_\") + 1));\n\n\t\t// Call rcvDroneOdomCallbackBase with the odometry data and drone ID\n\t\trcvDroneOdomCallbackBase(drone_id, odom);\n\t} catch (boost::bad_lexical_cast& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 48.18964927288994}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, extractDroneID(odom.child_frame_id));\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR(\"Error extracting drone ID from child_frame_id: %s\", e.what());\n\t}\n}", "CodeBleu_score": 38.476052918495526}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// get drone pose in camera frame\n\tEigen::Vector3d true_position;\n\tEigen::Vector3d true_orientation;\n\tgetDronePose(drone_id, true_position, true_orientation);\n\n\t// get drone pose in world frame\n\tEigen::Vector3d world_position;\n\tEigen::Vector3d world_orientation;\n\tgetDronePose(drone_id, world_position, world_orientation);\n\n\t// get camera pose in world frame\n\tEigen::Vector3d camera_position;\n\tEigen::Vector3d camera_orientation;\n\tgetCameraPose(camera_position, camera_orientation);\n\n\t// compute pose error\n\tEigen::Vector3d camera_position_error = camera_position - true_position;\n\tEigen::Vector3d camera_orientation_error = camera_orientation - true_orientation;\n\n\t// update debug result\n\tif (true_pixel.x() >= 0 && true_pixel.y() >= 0) {\n\t\tdebug_result_.pose_error_x = camera_position_error(0);\n\t\tdebug_result_.pose_error_y = camera_position_error(1);\n\t\tdebug_result_.pose_error_z = camera_position_error(2);\n\t\tdebug_result_.pose_error_roll = camera_orientation_error(0);\n\t\tdebug_result_.pose_error_pitch = camera_orientation_error(1);\n\t\tdebug_result_.pose_error_yaw = camera_orientation_error(2);\n\t} else {\n\t\tdebug_result_.pose_error_x = NAN;\n\t\tdebug_result_.pose_error_y = NAN;\n\t\tdebug_result_.pose_error_z = NAN;\n\t\tdebug_result_.pose_error_roll = NAN;\n\t\tdebug_result_.pose_error_pitch = NAN;\n\t\tdebug_result_.pose_error_yaw = NAN;\n\t}\n\n\t// publish pose error\n\tpose_error_pub_.publish(camera_position_error, camera_orientation_error);\n}", "CodeBleu_score": 31.098055406838686}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Compute the true pose of the drone in the camera frame\n\tEigen::Vector3d true_camera_pose = drone_pose_in_camera_frame(drone_id);\n\n\t// Check if the drone is present\n\tif (true_camera_pose.norm() > 0) {\n\t\t// Compute the pose error between the camera and world coordinates\n\t\tEigen::Vector3d pose_error = true_camera_pose - camera_pose_in_world_frame();\n\n\t\t// Update the debug result\n\t\tdebug_result.pose_error = pose_error;\n\t\tdebug_result.detected = true;\n\t} else {\n\t\t// Update the debug result\n\t\tdebug_result.pose_error = Eigen::Vector3d(0, 0, 0);\n\t\tdebug_result.detected = false;\n\t}\n\n\t// Publish the pose error\n\tpose_error_publisher.publish(debug_result.pose_error);\n}", "CodeBleu_score": 25.997355964071424}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// TODO: implement this function\n\t// Hint: use the drone_id to get the drone's pose in the camera frame\n\t// Hint: use the true_pixel to get the drone's pose in the world frame\n\t// Hint: use the drone's pose in the camera frame to compute the drone's pose in the world frame\n\t// Hint: use the drone's pose in the world frame to compute the pose error\n\t// Hint: use the pose error to update the debug result\n\t// Hint: use the pose error to publish the pose error\n}", "CodeBleu_score": 3.1919984578694347}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\n\twhile (current!= start) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\n\treturn path;\n}", "CodeBleu_score": 69.93685397526156}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (cameFrom.find(current)!= cameFrom.end()) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.04679189896778}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tGridNodePtr previous = cameFrom[current];\n\n\tpath.push_back(current);\n\twhile (previous!= start) {\n\t\tpath.push_back(previous);\n\t\tprevious = cameFrom[previous];\n\t}\n\tpath.push_back(start);\n\treverse(path.begin(), path.end());\n\treturn path;\n}", "CodeBleu_score": 48.52837736365726}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert the coordinates to indices\n\tif (!ConvertToIndex(start_pt, start_idx) ||!ConvertToIndex(end_pt, end_idx)) {\n\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints - Failed to convert start or end point to index\");\n\t\treturn false;\n\t}\n\n\t// Adjust the start point if it is inside an obstacle\n\tif (IsPointInsideObstacle(start_idx)) {\n\t\tif (!AdjustPointToAvoidObstacle(start_idx, start_pt)) {\n\t\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints - Failed to adjust start point\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Adjust the end point if it is inside an obstacle\n\tif (IsPointInsideObstacle(end_idx)) {\n\t\tif (!AdjustPointToAvoidObstacle(end_idx, end_pt)) {\n\t\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints - Failed to adjust end point\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 37.99629935116548}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert points to indices\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Adjust start point\n\tif (IsObstacle(start_idx)) {\n\t\tVector3i new_start_idx = start_idx;\n\t\tif (!AdjustPoint(start_pt, end_pt, new_start_idx)) {\n\t\t\treturn false;\n\t\t}\n\t\tstart_idx = new_start_idx;\n\t}\n\n\t// Adjust end point\n\tif (IsObstacle(end_idx)) {\n\t\tVector3i new_end_idx = end_idx;\n\t\tif (!AdjustPoint(end_pt, start_pt, new_end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t\tend_idx = new_end_idx;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 39.43709272642858}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start point to index\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\t// Convert end point to index\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\t// If start point is inside an obstacle, adjust it until it is no longer inside an obstacle\n\tif (IsObstacle(start_idx)) {\n\t\twhile (IsObstacle(start_idx)) {\n\t\t\tstart_idx -= Vector3i(1, 0, 0);\n\t\t}\n\t\tstart_idx += Vector3i(1, 0, 0);\n\t}\n\t// If end point is inside an obstacle, adjust it until it is no longer inside an obstacle\n\tif (IsObstacle(end_idx)) {\n\t\twhile (IsObstacle(end_idx)) {\n\t\t\tend_idx -= Vector3i(1, 0, 0);\n\t\t}\n\t\tend_idx += Vector3i(1, 0, 0);\n\t}\n\treturn true;\n}", "CodeBleu_score": 35.28502919613039}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// get the grid coordinates corresponding to the min and max positions\n\tEigen::Vector3i min_id = getGridCoordinates(min_pos);\n\tEigen::Vector3i max_id = getGridCoordinates(max_pos);\n\n\t// iterate over the grid coordinates and set the corresponding elements in the occupancy_buffer_inflate_ to zero\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.40765777508038}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\t// Get the minimum and maximum grid coordinates within the specified region\n\tEigen::Vector3i min_id, max_id;\n\tgetGridCoordinates(min_pos, min_id);\n\tgetGridCoordinates(max_pos, max_id);\n\n\t// Iterate over the grid coordinates and set the corresponding elements in the occupancy_buffer_inflate_ to zero\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.5654863712262}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = getGridIndex(min_pos);\n\tEigen::Vector3i max_id = getGridIndex(max_pos);\n\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.6177968844494}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tdouble x_min = -0.5 * m_map_width;\n\tdouble x_max = 0.5 * m_map_width;\n\tdouble y_min = -0.5 * m_map_height;\n\tdouble y_max = 0.5 * m_map_height;\n\tdouble z_min = 0.0;\n\tdouble z_max = m_map_depth;\n\n\tdouble x_diff = pt(0) - camera_pt(0);\n\tdouble y_diff = pt(1) - camera_pt(1);\n\tdouble z_diff = pt(2) - camera_pt(2);\n\n\tdouble x_scale = 1.0;\n\tdouble y_scale = 1.0;\n\tdouble z_scale = 1.0;\n\n\tif (x_diff < 0.0) {\n\t\tx_scale = (x_min - pt(0)) / x_diff;\n\t}\n\telse {\n\t\tx_scale = (x_max - pt(0)) / x_diff;\n\t}\n\n\tif (y_diff < 0.0) {\n\t\ty_scale = (y_min - pt(1)) / y_diff;\n\t}\n\telse {\n\t\ty_scale = (y_max - pt(1)) / y_diff;\n\t}\n\n\tif (z_diff < 0.0) {\n\t\tz_scale = (z_min - pt(2)) / z_diff;\n\t}\n\telse {\n\t\tz_scale = (z_max - pt(2)) / z_diff;\n\t}\n\n\tdouble scale = 1.0;\n\tif (x_scale < y_scale) {\n\t\tscale = x_scale;\n\t}\n\telse {\n\t\tscale = y_scale;\n\t}\n\n\tif (scale > z_scale) {\n\t\tscale = z_scale;\n\t}\n\n\tEigen::Vector3d pt_new;\n\tpt_new = pt + scale * (camera_pt - pt);\n\n\treturn pt_new;\n}", "CodeBleu_score": 29.275574967526662}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t", "CodeBleu_score": 4.826190268379092}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tdouble x_min = -width / 2.0;\n\tdouble x_max = width / 2.0;\n\tdouble y_min = -height / 2.0;\n\tdouble y_max = height / 2.0;\n\tdouble z_min = -depth / 2.0;\n\tdouble z_max = depth / 2.0;\n\n\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble x_scale = 1.0;\n\tdouble y_scale = 1.0;\n\tdouble z_scale = 1.0;\n\n\tif (diff(0) < 0) {\n\t\tx_scale = (x_min - pt(0)) / diff(0);\n\t} else if (diff(0) > 0) {\n\t\tx_scale = (x_max - pt(0)) / diff(0);\n\t}\n\tif (diff(1) < 0) {\n\t\ty_scale = (y_min - pt(1)) / diff(1);\n\t} else if (diff(1) > 0) {\n\t\ty_scale = (y_max - pt(1)) / diff(1);\n\t}\n\tif (diff(2) < 0) {\n\t\tz_scale = (z_min - pt(2)) / diff(2);\n\t} else if (diff(2) > 0) {\n\t\tz_scale = (z_max - pt(2)) / diff(2);\n\t}\n\n\tdouble scale = 1.0;\n\tif (x_scale < y_scale) {\n\t\tscale = x_scale;\n\t} else {\n\t\tscale = y_scale;\n\t}\n\tif (scale > z_scale) {\n\t\tscale = z_scale;\n\t}\n\n\treturn pt + scale * diff;\n}", "CodeBleu_score": 31.232323111236166}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last occupancy update time\n\tlastOccupancyUpdateTime_ = ros::Time::now();\n\n\t// If an update is needed\n\tif (updateNeeded_) {\n\t\t// Project the depth image into points\n\t\tstd::vector<geometry_msgs::Point> points;\n\t\tprojectDepthImageIntoPoints(points);\n\n\t\t// Process the points with raycasting\n\t\tprocessPointsWithRaycasting(points);\n\n\t\t// If the local map has been updated\n\t\tif (localMapUpdated_) {\n\t\t\t// Clear and inflate the local map\n\t\t\tclearAndInflateLocalMap();\n\t\t}\n\n\t\t// Reset the update flag\n\t\tupdateNeeded_ = false;\n\t}\n\n\t// Handle timeout errors for odometry or depth data\n\tif (lastOdometryUpdateTime_ < lastOccupancyUpdateTime_) {\n\t\t// Set the odometry timeout flag\n\t\todometryTimeout_ = true;\n\t}\n\n\tif (lastDepthUpdateTime_ < lastOccupancyUpdateTime_) {\n\t\t// Set the depth timeout flag\n\t\tdepthTimeout_ = true;\n\t}\n}", "CodeBleu_score": 29.352257778638496}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last occupancy update time\n\tlast_occupancy_update_time_ = ros::Time::now();\n\n\t// Check if a new depth image is available\n\tif (depth_image_received_ && depth_image_received_time_ + depth_image_timeout_ < last_occupancy_update_time_) {\n\t\t// Set the depth image timeout flag\n\t\tdepth_image_timeout_ = true;\n\t\t// Reset the depth image received flag\n\t\tdepth_image_received_ = false;\n\t}\n\n\t// Check if a new odometry message is available\n\tif (odometry_received_ && odometry_received_time_ + odometry_timeout_ < last_occupancy_update_time_) {\n\t\t// Set the odometry timeout flag\n\t\todometry_timeout_ = true;\n\t\t// Reset the odometry received flag\n\t\todometry_received_ = false;\n\t}\n\n\t// Check if a new depth image is available\n\tif (depth_image_received_) {\n\t\t// Get the depth image\n\t\tsensor_msgs::Image depth_image = depth_image_buffer_.front();\n\t\t// Reset the depth image received flag\n\t\tdepth_image_received_ = false;\n\n\t\t// Project the depth image into points\n\t\tstd::vector<geometry_msgs::Point> points;\n\t\tprojectDepthImage(depth_image, points);\n\n\t\t// Process the points with raycasting\n\t\tprocessPoints(points);\n\n\t\t// Clear and inflate the local map\n\t\tclearAndInflateLocalMap();\n\t}\n}", "CodeBleu_score": 39.552508731408444}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update last occupancy update time\n\tlast_occupancy_update_time_ = ros::Time::now();\n\n\t// If an update is needed, project the depth image into points and process them with raycasting\n\tif (update_needed_) {\n\t\t// Project depth image into points\n\t\tprojectDepthImageIntoPoints();\n\n\t\t// Process points with raycasting\n\t\tprocessPointsWithRaycasting();\n\n\t\t// If the local map has been updated, clear and inflate the local map\n\t\tif (local_map_updated_) {\n\t\t\tclearLocalMap();\n\t\t\tinflateLocalMap();\n\n\t\t\t// Reset local map updated flag\n\t\t\tlocal_map_updated_ = false;\n\t\t}\n\n\t\t// Reset update needed flag\n\t\tupdate_needed_ = false;\n\t}\n\n\t// Handle timeout errors for odometry or depth data\n\tif (odometry_timeout_error_) {\n\t\t// Clear local map\n\t\tclearLocalMap();\n\n\t\t// Reset odometry timeout error flag\n\t\todometry_timeout_error_ = false;\n\t}\n\n\tif (depth_timeout_error_) {\n\t\t// Reset depth timeout error flag\n\t\tdepth_timeout_error_ = false;\n\t}\n}", "CodeBleu_score": 27.81566158643472}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat sum_fmeasure = 0.f;\n\tfor (unsigned i = 0; i < image_fns.size(); ++i)\n\t{\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tsum_fmeasure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, imread(image_fns[i], IMREAD_GRAYSCALE));\n\t}\n\n\treturn sum_fmeasure / float(image_fns.size());\n}", "CodeBleu_score": 55.8504815019171}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat total_fmeasure = 0.f;\n\tunsigned n = image_fns.size();\n\n\tfor (unsigned i = 0; i < n; ++i)\n\t{\n\t\t// load the ground truth ellipses\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n\t\t// load the detected ellipses\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\t// evaluate the detection performance\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, imread(image_fns[i], IMREAD_GRAYSCALE));\n\t\ttotal_fmeasure += fmeasure;\n\t}\n\n\treturn total_fmeasure / float(n);\n}", "CodeBleu_score": 52.919491430726225}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat f_measure_sum = 0.f;\n\tunsigned num_images = image_fns.size();\n\n\tfor (unsigned i = 0; i < num_images; ++i) {\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tMat3b img = imread(image_fns[i], IMREAD_COLOR);\n\n\t\tf_measure_sum += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t}\n\n\treturn f_measure_sum / num_images;\n}", "CodeBleu_score": 53.88453885346114}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = atan2(y - foci[1], x - foci[0]);\n\tfloat b = atan2(y - foci[3], x - foci[2]);\n\tfloat angle_diff = angle_diff_signed(a, b);\n\tfloat normal_angle = a + angle_diff / 2;\n\twhile (normal_angle <= -M_PI) normal_angle += M_2__PI;\n\twhile (normal_angle >   M_PI) normal_angle -= M_2__PI;\n\treturn normal_angle;\n}", "CodeBleu_score": 52.93191919113956}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = atan2(y - foci[1], x - foci[0]);\n\tfloat b = atan2(y - foci[3], x - foci[2]);\n\tfloat a_b = angle_diff_signed(a, b);\n\tfloat angle = a_b / 2.0;\n\treturn angle;\n}", "CodeBleu_score": 36.27620925727575}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = atan2(y - foci[1], x - foci[0]);\n\tfloat b = atan2(y - foci[3], x - foci[2]);\n\tfloat angle_diff_signed = angle_diff_signed(a, b);\n\treturn angle_diff_signed;\n}", "CodeBleu_score": 34.652639153826634}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tif (start >= end) return false;\n\tint i, j, k;\n\tdouble min_x = vp1[start].x, max_x = vp1[start].x, min_y = vp1[start].y, max_y = vp1[start].y;\n\tdouble sum_above = 0.0, sum_below = 0.0;\n\n\tfor (i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\n\tfor (i = start; i <= end; i++) {\n\t\tfor (j = start; j <= end; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tfor (k = start; k <= end; k++) {\n\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\tif (vp1[i].x == vp1[j].x && vp1[j].x == vp1[k].x) continue;\n\t\t\t\tif (vp1[i].y == vp1[j].y && vp1[j].y == vp1[k].y) continue;\n\t\t\t\tif (vp1[i].x == vp1[k].x && vp1[k].x == vp1[j].x) continue;\n\t\t\t\tif (vp1[i].y == vp1[k].y && vp1[k].y == vp1[j].y) continue;\n\t\t\t\tdouble area = area_of_triangle(vp1[i], vp1[j], vp1[k]);\n\t\t\t\tif (area < 0) sum_above += area;\n\t\t\t\telse sum_below += area;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sum_above < sum_below) return false;\n\treturn true;\n}", "CodeBleu_score": 36.21887724456011}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\telse if (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\telse if (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\n\tdouble integral_above = 0.0;\n\tdouble integral_below = 0.0;\n\tfor (int i = start; i < end; i++) {\n\t\tdouble x1 = vp1[i].x;\n\t\tdouble y1 = vp1[i].y;\n\t\tdouble x2 = vp1[(i + 1) % vp1.size()].x;\n\t\tdouble y2 = vp1[(i + 1) % vp1.size()].y;\n\n\t\tif (y1 < min_y && y2 < min_y) {\n\t\t\tintegral_above += (x2 - x1) * (y2 - y1);\n\t\t} else if (y1 > max_y && y2 > max_y) {\n\t\t\tintegral_below += (x2 - x1) * (y2 - y1);\n\t\t}\n\t}\n\n\tif (integral_above < integral_below)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 43.58978604410745}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = 0;\n\tdouble max_x = 0;\n\tdouble min_y = 0;\n\tdouble max_y = 0;\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t}\n\n\tfor (int i = start; i < end; i++) {\n\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i].y + min_y);\n\t\tintegral_below += (vp1[i].x - min_x) * (vp1[i].y - max_y);\n\t}\n\n\tif (integral_above < integral_below) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 41.37016772525973}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t//ROS_INFO(\"ellipse_det_cb\");\n\t//ROS_INFO(\"msg->detections.size() = %d\", msg->detections.size());\n\tint num_regain = 0;\n\tint num_lost = 0;\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\t//ROS_INFO(\"msg->detections[%d].id = %d\", i, msg->detections[i].id);\n\t\tif (msg->detections[i].id == 1) {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\tif (is_detected) {\n\t\t//ROS_INFO(\"is_detected = true\");\n\t\t//ROS_INFO(\"ellipse_det.sight_angle = %f\", ellipse_det.sight_angle);\n\t\t//ROS_INFO(\"ellipse_det.sight_angle_prev = %f\", ellipse_det.sight_angle_prev);\n\t\tellipse_det.sight_angle_prev = ellipse_det.sight_angle;\n\t\t//ROS_INFO(\"ellipse_det.sight_angle_prev = %f\", ellipse_det.sight_angle_prev);\n\t\t//ROS_INFO(\"ellipse_det.sight_angle = %f\", ellipse_det.sight_angle);\n\t}\n}", "CodeBleu_score": 56.20875086063833}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tif (msg->detections.size() > 0) {\n\t\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\t\tif (msg->detections[i].object_name == \"T\") {\n\t\t\t\tnum_regain++;\n\t\t\t\tnum_lost = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum_regain = 0;\n\t\t\t\tnum_lost++;\n\t\t\t}\n\t\t\tif (num_lost > VISION_THRES) {\n\t\t\t\tis_detected = false;\n\t\t\t}\n\t\t\tif (num_regain > VISION_THRES) {\n\t\t\t\tis_detected = true;\n\t\t\t}\n\t\t}\n\t\t// swap sight_angle values\n\t\tfloat temp = ellipse_det.sight_angle_left;\n\t\tellipse_det.sight_angle_left = ellipse_det.sight_angle_right;\n\t\tellipse_det.sight_angle_right = temp;\n\t}\n}", "CodeBleu_score": 59.12180632455628}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tif (msg->detection_infos.size() == 0) {\n\t\tis_detected = false;\n\t\treturn;\n\t}\n\tis_detected = true;\n\tnum_lost = 0;\n\tnum_regain = 0;\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t\treturn;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tswap(ellipse_det.sight_angle.x, ellipse_det.sight_angle.y);\n}", "CodeBleu_score": 55.92953135658429}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// Check if the position is safe\n\tif (occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 46.348526256023334}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tEigen::Vector3d pos = cur_pos;\n\tpos(2) = 0;\n\tbool is_safe = true;\n\tif (occupy_map_ptr->is_occupied(pos, safe_distance)) {\n\t\tis_safe = false;\n\t}\n\treturn is_safe;\n}", "CodeBleu_score": 52.93210758507493}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t", "CodeBleu_score": 10.461696713377352}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node->getParent()!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->getParent();\n\t}\n\tpath_nodes_.push_back(current_node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 58.40777133352165}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\tpath_nodes_.clear();\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.131228444368475}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr node = end_node;\n\twhile (node->parent!= nullptr) {\n\t\tpath_nodes_.push_back(node);\n\t\tnode = node->parent;\n\t}\n\tpath_nodes_.push_back(node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 59.1133523403093}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"Received odometry data from UGV %d\", id);\n\tif (sim_mode) {\n\t\tfloat dist = sqrt(pow(odom->pose.pose.position.x - start_pos[0], 2) + pow(odom->pose.pose.position.y - start_pos[1], 2));\n\t\tif (dist >= 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\tstate_nei[id].position[0] = odom->pose.pose.position.x;\n\tstate_nei[id].position[1] = odom->pose.pose.position.y;\n\tstate_nei[id].position[2] = odom->pose.pose.position.z;\n\tstate_nei[id].orientation[0] = odom->pose.pose.orientation.x;\n\tstate_nei[id].orientation[1] = odom->pose.pose.orientation.y;\n\tstate_nei[id].orientation[2] = odom->pose.pose.orientation.z;\n\tstate_nei[id].orientation[3] = odom->pose.pose.orientation.w;\n}", "CodeBleu_score": 52.873201794364434}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif(odom->header.frame_id == \"map\") {\n\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\t\tstate_nei[id].y = odom->pose.pose.position.y;\n\t\tstate_nei[id].z = odom->pose.pose.position.z;\n\t\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\t\tstate_nei[id].get_nei_state = true;\n\t}\n\telse {\n\t\tstate_nei[id].get_nei_state = false;\n\t}\n}", "CodeBleu_score": 32.365234413069146}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif (sim_mode) {\n\t\tdouble dist = sqrt(pow(odom->pose.pose.position.x - start_pos.x, 2) + pow(odom->pose.pose.position.y - start_pos.y, 2));\n\t\tif (dist > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n}", "CodeBleu_score": 50.68369324980405}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready)\n\t\treturn;\n\n\tsensor_ready = true;\n\tupdate_counter++;\n\n\tif (update_counter == 5) {\n\t\t// Update the A* map with the new point cloud data\n\t\tstd::vector<std::vector<int> > new_map = astar_map.get_map();\n\t\tfor (int i = 0; i < msg->height; i++) {\n\t\t\tfor (int j = 0; j < msg->width; j++) {\n\t\t\t\tint index = i * msg->width + j;\n\t\t\t\tif (msg->data[index] == 0)\n\t\t\t\t\tnew_map[i][j] = 1;\n\t\t\t\telse\n\t\t\t\t\tnew_map[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tastar_map.set_map(new_map);\n\n\t\t// Reset the update counter\n\t\tupdate_counter = 0;\n\t}\n}", "CodeBleu_score": 48.85754854765961}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\n\tsensor_ready = true;\n\tupdate_counter++;\n\n\tif (update_counter == 5) {\n\t\tupdate_counter = 0;\n\t\tupdateMap(msg);\n\t}\n}", "CodeBleu_score": 51.86071735782616}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odometry_ready) return;\n\tsensor_ready = true;\n\tupdate_counter++;\n\tif (update_counter == 5) {\n\t\tupdate_counter = 0;\n\t\tupdate_map(msg);\n\t}\n}", "CodeBleu_score": 41.76209308162967}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tsensor_msgs::PointCloud2 global_point_inflated;\n\t\tpcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_inflated (new pcl::PointCloud<pcl::PointXYZRGB>);\n\t\tpcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZRGB>);\n\t\tpcl::fromROSMsg(*global_point, *cloud);\n\t\tpcl::fromROSMsg(*global_point, *cloud_inflated);\n\t\tpcl::inflation_radius_filter(cloud, cloud_inflated, 0.001);\n\t\tpcl::toROSMsg(*cloud_inflated, global_point_inflated);\n\t\tglobal_point_inflated.header.frame_id = \"/map\";\n\t\tglobal_point_inflated.header.stamp = ros::Time::now();\n\t\tglobal_map.publish(global_point_inflated);\n\t}\n}", "CodeBleu_score": 47.75706585468814}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(!get_gpcl) {\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr global_point_pcl (new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(*global_point, *global_point_pcl);\n\t\tglobal_point_pcl = inflator.inflate(global_point_pcl, inflation_radius);\n\t\tglobal_map = global_point_pcl;\n\t\tget_gpcl = true;\n\t}\n}", "CodeBleu_score": 54.0987678881484}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\tif (simulation_mode) {\n\t\t// In simulation mode, the odometry data is not used\n\t\tpcl::PointCloud<pcl::PointXYZ> local_map;\n\t\tpcl::fromROSMsg(*local_point, local_map);\n\t\tpcl::PointCloud<pcl::PointXYZ> local_map_transformed;\n\t\tpcl::transformPointCloud(local_map, local_map_transformed, odom.pose.pose);\n\t\tpcl::PointCloud<pcl::PointXYZ> merged_map = local_map_transformed + *map_ptr;\n\t\t*map_ptr = merged_map;\n\t} else {\n\t\t// In real mode, the odometry data is used\n\t\tpcl::PointCloud<pcl::PointXYZ> local_map;\n\t\tpcl::fromROSMsg(*local_point, local_map);\n\t\tpcl::PointCloud<pcl::PointXYZ> local_map_transformed;\n\t\tpcl::transformPointCloud(local_map, local_map_transformed, odom.pose.pose);\n\t\tpcl::PointCloud<pcl::PointXYZ> merged_map = local_map_transformed + *map_ptr;\n\t\t*map_ptr = merged_map;\n\t}\n}", "CodeBleu_score": 42.65561448090588}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert the laser scan to a PointCloud2 format\n\tpcl::PointCloud<pcl::PointXYZ> local_cloud;\n\tlaser_scan_to_point_cloud(local_point, local_cloud);\n\n\t// If not in simulation mode, merge the local map with the provided odometry data\n\tif (!sim_mode) {\n\t\tmerge_map(local_cloud, odom);\n\t}\n\n\t// Update the occupancy map\n\tupdate_map(local_cloud);\n}", "CodeBleu_score": 40.45151638564172}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Publish point cloud\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl;\n\tpcl::PointCloud<pcl::PointXYZ> inflate_pcl;\n\tpcl::PointCloud<pcl::PointXYZ> pcl_tmp;\n\tpcl::PointXYZ pcl_pt;\n\tpcl_tmp.clear();\n\tinflate_pcl.clear();\n\tglobal_pcl.clear();\n\tinflate_pcl.header.frame_id = \"world\";\n\tglobal_pcl.header.frame_id = \"world\";\n\tinflate_pcl.header.stamp = ros::Time::now();\n\tglobal_pcl.header.stamp = ros::Time::now();\n\tinflate_pcl.header.seq = seq_num;\n\tglobal_pcl.header.seq = seq_num;\n\tseq_num++;\n\tfor (int i = 0; i < map_size; i++) {\n\t\tfor (int j = 0; j < map_size; j++) {\n\t\t\tif (map_data[i][j] == 1) {\n\t\t\t\tpcl_pt.x = i * map_resolution;\n\t\t\t\tpcl_pt.y = j * map_resolution;\n\t\t\t\tpcl_pt.z = 0;\n\t\t\t\tpcl_tmp.push_back(pcl_pt);\n\t\t\t}\n\t\t}\n\t}\n\tpcl::toROSMsg(pcl_tmp, global_pcl);\n\tpcl::toROSMsg(pcl_tmp, inflate_pcl);\n\tglobal_pcl_pub.publish(global_pcl);\n\tinflate_pcl_pub.publish(inflate_pcl);\n}", "CodeBleu_score": 51.99324925754776}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert the global map to a ROS message\n\tsensor_msgs::PointCloud2 global_pcl;\n\tpcl::toROSMsg(*global_map_, global_pcl);\n\tglobal_pcl.header.frame_id = \"world\";\n\tglobal_pcl.header.stamp = ros::Time::now();\n\tglobal_pcl.header.seq = global_pcl_seq_;\n\n\t// Convert the inflated map to a ROS message\n\tsensor_msgs::PointCloud2 inflate_pcl;\n\tpcl::toROSMsg(*inflate_map_, inflate_pcl);\n\tinflate_pcl.header.frame_id = \"world\";\n\tinflate_pcl.header.stamp = ros::Time::now();\n\tinflate_pcl.header.seq = inflate_pcl_seq_;\n\n\t// Publish the messages\n\tglobal_pcl_pub_.publish(global_pcl);\n\tinflate_pcl_pub_.publish(inflate_pcl);\n\n\t// Increment the sequence numbers\n\tglobal_pcl_seq_++;\n\tinflate_pcl_seq_++;\n}", "CodeBleu_score": 56.569481176762956}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//If odometry is ready, set sensor_ready flag to true\n\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t}\n\n\t//Update map\n\tupdateMap(msg);\n}", "CodeBleu_score": 40.48074661068005}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\tos::Time start_time = ros::Time::now();\n\tros::Time end_time = start_time;\n\tros::Duration duration = end_time - start_time;\n\n\t//Get current time\n\trosTimeToChampTime(end_time, ros_time_);\n\n\t//Calculate target foot positions based on desired pose\n\tbase_.calculateFootPositions(ros_time_, desired_pose_);\n\n\t//Calculate velocity commands for legs\n\tbase_.calculateLegVelocities(ros_time_, desired_pose_, desired_velocity_);\n\n\t//Perform inverse kinematics to determine target joint positions\n\tbase_.calculateJointPositions(ros_time_, desired_pose_, desired_velocity_, target_joints_);\n\n\t//Publish foot contact information and joint positions\n\tpublishFootContacts_(base_.foot_contacts_);\n\tpublishJoints_(target_joints_);\n\n\t//Calculate duration of control loop\n\tend_time = ros::Time::now();\n\tduration = end_time - start_time;\n\tros::Duration duration_sec(duration.toSec());\n\tROS_INFO_STREAM_THROTTLE(1.0, \"Control loop took \" << duration_sec.toSec() << \" seconds\");\n}", "CodeBleu_score": 44.37909350115115}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t", "CodeBleu_score": 3.1254227762308044}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0 &&!in_gazebo_) {\n\t\t// Create and populate the message\n\t\tstd_msgs::Header header;\n\t\theader.stamp = ros::Time::now();\n\t\theader.frame_id = \"base_link\";\n\t\tstd_msgs::Int32MultiArray gait_phases;\n\t\tgait_phases.data.resize(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tgait_phases.data[i] = foot_contacts[i]? 1 : 0;\n\t\t}\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_.publish(gait_phases);\n\t}\n}", "CodeBleu_score": 47.10141156775727}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t", "CodeBleu_score": 3.1254227762308044}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t", "CodeBleu_score": 0.0}, {"code": "def joints_cmd_callback(self, joints){\n\t\t// create a minimal joints message\n\tvar joints_msg = new std_msgs.msg.Float64MultiArray();\n\tfor (var i = 0; i < 12; i++) {\n\t\tjoints_msg.data.push(joints[i]);\n\t}\n\n\t// publish the minimal joints message\n\tself.joints_pub.publish(joints_msg);\n\n\t// create a joint trajectory message\n\tvar trajectory_msg = new trajectory_msgs.msg.JointTrajectory();\n\ttrajectory_msg.joint_names = joints_msg.joint_names;\n\ttrajectory_msg.points.push(new trajectory_msgs.msg.JointTrajectoryPoint());\n\ttrajectory_msg.points[0].positions = joints_msg.data;\n\ttrajectory_msg.points[0].time_from_start = new ROSLIB.Time(1.0);\n\n\t// publish the joint trajectory message\n\tself.trajectory_pub.publish(trajectory_msg);\n}", "CodeBleu_score": 35.279960555983166}, {"code": "def joints_cmd_callback(self, joints){\n\t\tvar msg = new std_msgs.msg.Float64MultiArray;\n\tmsg.data = joints.position.slice(0, 12);\n\tself.pub.publish(msg);\n\n\tvar trajectory = new trajectory_msgs.msg.JointTrajectory;\n\ttrajectory.joint_names = joints.name;\n\ttrajectory.points.push(new trajectory_msgs.msg.JointTrajectoryPoint);\n\ttrajectory.points[0].positions = joints.position.slice(0, 12);\n\ttrajectory.points[0].time_from_start = rclpy.duration.Duration(1);\n\tself.pub_traj.publish(trajectory);\n}", "CodeBleu_score": 31.605063702568682}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t// Initialize foot contact states to false\n\tfoot_contact_states_[0] = false;\n\tfoot_contact_states_[1] = false;\n\tfoot_contact_states_[2] = false;\n\tfoot_contact_states_[3] = false;\n\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::string collision_string = _msg->contact(i).collision1();\n\t\tstd::string::size_type pos = collision_string.find_last_of(\"/\");\n\t\tstd::string link_name = collision_string.substr(pos + 1);\n\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true\n\t\tif (link_name == \"foot_left\") {\n\t\t\tfoot_contact_states_[0] = true;\n\t\t} else if (link_name == \"foot_right\") {\n\t\t\tfoot_contact_states_[1] = true;\n\t\t} else if (link_name == \"foot_left_back\") {\n\t\t\tfoot_contact_states_[2] = true;\n\t\t} else if (link_name == \"foot_right_back\") {\n\t\t\tfoot_contact_states_[3] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.41897990321702}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision_string = _msg->contact(i).collision1();\n\t\tstd::string foot_link_string = \"leg_\";\n\t\tif (collision_string.find(foot_link_string)!= std::string::npos) {\n\t\t\tif (collision_string.find(\"left\")!= std::string::npos) {\n\t\t\t\tleft_foot_contact_state_ = true;\n\t\t\t} else if (collision_string.find(\"right\")!= std::string::npos) {\n\t\t\t\tright_foot_contact_state_ = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.637406859855325}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); ++i) {\n\t\tstd::string collision_string = _msg->contact(i).collision1();\n\t\tstd::string foot_link_string = \"foot_link\";\n\t\tif (collision_string.find(foot_link_string)!= std::string::npos) {\n\t\t\tstd::string foot_link_name = collision_string.substr(0, collision_string.find(foot_link_string));\n\t\t\tif (foot_link_name == \"left_\") {\n\t\t\t\tleft_foot_contact_state_ = true;\n\t\t\t} else if (foot_link_name == \"right_\") {\n\t\t\t\tright_foot_contact_state_ = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.829401921036364}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n//\n//  if (!active_) {\n//    rotor_velocities->setZero();\n//    return;\n//  }\n//\n//  Eigen::Vector3d desired_acceleration;\n//  ComputeDesiredAcceleration(&desired_acceleration);\n//\n//  Eigen::Vector3d desired_angular_acceleration;\n//  ComputeDesiredAngularAcc(desired_acceleration, &desired_angular_acceleration);\n//\n//  Eigen::Vector3d desired_thrust;\n//  desired_thrust = desired_acceleration + desired_angular_acceleration;\n//\n//  // Project thrust onto body z-axis.\n//  Eigen::Vector3d thrust_z_axis;\n//  thrust_z_axis = desired_thrust.dot(Eigen::Vector3d::UnitZ()) * Eigen::Vector3d::UnitZ();\n//\n//  // Combine angular acceleration and thrust.\n//  desired_thrust -= thrust_z_axis;\n//\n//  Eigen::Vector3d angular_acceleration_thrust;\n//  angular_acceleration_thrust = desired_angular_acceleration.cwiseProduct(Eigen::Vector3d::UnitZ())\n//      + thrust_z_axis;\n//\n//  // Compute rotor velocities.\n//  Eigen::VectorXd rotor_velocities_unconstrained = rotor_velocities_matrix_ * angular_acceleration_thrust;\n//  rotor_velocities_unconstrained = rotor_velocities_unconstrained.cwiseSqrt();\n//\n//  // Ensure non-negative values.\n//  for (int i = 0; i < rotor_velocities_unconstrained.size(); i++) {\n//    rotor_velocities_unconstrained[i] = std::max(rotor_velocities_unconstrained[i], 0.0);\n//  }\n//\n//  *rotor_velocities = rotor_velocities_unconstrained;\n}", "CodeBleu_score": 3.0243722721573207}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\t// If the controller is not active, set all rotor velocities to zero.\n\tif (!command_trajectory_.active) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\t// Compute desired acceleration and angular acceleration.\n\tEigen::Vector3d acceleration;\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAcceleration(&acceleration);\n\tComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n\t// Project thrust onto body z-axis.\n\tEigen::Vector3d thrust_z = acceleration.cross(vehicle_parameters_.inertia_ * angular_acceleration) / vehicle_parameters_.mass_;\n\n\t// Combine angular acceleration and thrust into a single vector.\n\tEigen::Vector3d combined_acceleration = thrust_z + angular_acceleration;\n\n\t// Compute rotor velocities.\n\tEigen::Vector3d rotor_velocities_squared;\n\trotor_velocities_squared = combined_acceleration.cwiseProduct(rotor_velocities_squared_gain_);\n\trotor_velocities_squared = rotor_velocities_squared.cwiseMax(Eigen::Vector3d::Zero());\n\t*rotor_velocities = rotor_velocities_squared.cwiseSqrt();\n}", "CodeBleu_score": 44.50422084157866}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n//  assert(rotor_velocities->size() == vehicle_parameters_.rotor_configuration_.rotors_number);\n\n//  // Check if the controller is active.\n//  if (!active_) {\n//    rotor_velocities->setZero();\n//    return;\n//  }\n\n//  // Compute the desired acceleration and angular acceleration.\n//  Eigen::Vector3d acceleration;\n//  Eigen::Vector3d angular_acceleration;\n//  ComputeDesiredAcceleration(&acceleration);\n//  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n//  // Project thrust onto the body z-axis.\n//  Eigen::Vector3d thrust_vector = acceleration.cwiseProduct(vehicle_parameters_.thrust_to_acceleration_gain_)\n//      + angular_acceleration.cwiseProduct(vehicle_parameters_.thrust_to_angular_acceleration_gain_);\n//  double thrust = thrust_vector.norm();\n//  thrust_vector /= thrust;\n\n//  // Combine angular acceleration and thrust into a single vector.\n//  Eigen::Vector3d combined_vector = thrust_vector + angular_acceleration;\n\n//  // Compute the rotor velocities.\n//  for (int i = 0; i < rotor_velocities->size(); ++i) {\n//    double rotor_velocity = combined_vector.dot(vehicle_parameters_.rotor_configuration_.rotor_positions_[i]);\n//    if (rotor_velocity < 0) {\n//      rotor_velocity = 0;\n//    }\n//    rotor_velocities->coeffRef(i) = sqrt(rotor_velocity);\n//  }\n}", "CodeBleu_score": 3.0243722721573207}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t", "CodeBleu_score": 5.185615338987256}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d position_error = command_position_ - state_.position();\n\tEigen::Vector3d velocity_error = command_velocity_ - state_.velocity();\n\tEigen::Vector3d desired_acceleration = position_error * k_p_position_ + velocity_error * k_p_velocity_ + command_acceleration_;\n\tdesired_acceleration(2) += g_ + mass_ * command_acceleration_(2);\n\t*acceleration = desired_acceleration;\n}", "CodeBleu_score": 30.225252540185092}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// TODO: Implement this function\n\tEigen::Vector3d position_error, velocity_error;\n\tposition_error = current_position_ - command_position_;\n\tvelocity_error = current_velocity_ - command_velocity_;\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error - mass_ * gravity_ + command_acceleration_;\n}", "CodeBleu_score": 18.921182899899254}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n//  assert(rotor_velocities->size() == 0);\n//\n//  // ensure input is valid\n//  if (rotor_velocities->size()!= rotor_count_) {\n//    std::cerr << \"rotor_velocities vector is the wrong size. It should be \" << rotor_count_ << \" long.\" << std::endl;\n//    return;\n//  }\n//\n//  // compute desired angular acceleration\n//  Eigen::Vector3d angular_acceleration;\n//  ComputeDesiredAngularAcc(&angular_acceleration);\n//\n//  // combine desired angular acceleration and thrust reference\n//  Eigen::VectorXd angular_acceleration_thrust_reference(3);\n//  angular_acceleration_thrust_reference << angular_acceleration, control_attitude_thrust_reference_(2);\n//\n//  // compute rotor velocities\n//  Eigen::VectorXd rotor_velocities_tmp = rotor_velocities_matrix_ * angular_acceleration_thrust_reference;\n//\n//  // ensure rotor velocities are at least one\n//  rotor_velocities_tmp = rotor_velocities_tmp.cwiseMax(Eigen::VectorXd::Constant(rotor_count_, 1.0));\n//\n//  // take square root of each rotor velocity\n//  *rotor_velocities = rotor_velocities_tmp.cwiseSqrt();\n}", "CodeBleu_score": 4.0986584859826545}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\tEigen::VectorXd thrust_reference = Eigen::VectorXd::Zero(rotor_velocities->rows());\n\tthrust_reference[0] = control_attitude_thrust_reference_(3);\n\n\tEigen::VectorXd desired_angular_acceleration = Eigen::VectorXd::Zero(rotor_velocities->rows());\n\tdesired_angular_acceleration = angular_acceleration.cwiseProduct(rotor_velocities->array().pow(2));\n\n\tEigen::VectorXd desired_rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n\tdesired_rotor_velocities = (desired_angular_acceleration + thrust_reference).array().sqrt();\n\n\t*rotor_velocities = desired_rotor_velocities;\n}", "CodeBleu_score": 55.004010905918356}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\tEigen::Vector3d thrust_reference = control_attitude_thrust_reference_.head(3);\n\tEigen::Vector3d desired_rotor_velocities = Eigen::Vector3d::Zero();\n\n\tdesired_rotor_velocities = (angular_acceleration + thrust_reference).cwiseMax(Eigen::Vector3d::Zero());\n\tdesired_rotor_velocities = desired_rotor_velocities.array().sqrt();\n\n\t*rotor_velocities = desired_rotor_velocities;\n}", "CodeBleu_score": 44.71125507952866}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # Get the indices of the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # Create a copy of the object\n    sliced_object = copy.deepcopy(self)\n    # Slice the attributes\n    sliced_object.time = self.time[start_index:end_index]\n    sliced_object.data = self.data[start_index:end_index]\n    # Return the sliced object\n    return sliced_object", "CodeBleu_score": 33.014496922854796}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices of the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # Create a copy of the object\n    sliced_obj = copy.deepcopy(self)\n    # Slice the attributes\n    sliced_obj.time = self.time[start_index:end_index]\n    sliced_obj.value = self.value[start_index:end_index]\n    sliced_obj.units = self.units\n    sliced_obj.name = self.name\n    sliced_obj.description = self.description\n    return sliced_obj\n\n", "CodeBleu_score": 31.461337965635906}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    sliced_object = deepcopy(self)\n    sliced_object.time = self.time[start_index:end_index]\n    sliced_object.data = self.data[start_index:end_index]\n    return sliced_object", "CodeBleu_score": 32.03138332984311}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Get the position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert the rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object\n    point = Point(position.x, position.y, position.z, euler[2])\n    # Check if the current waypoint is different from the last one\n    if self.last_point is None or self.last_point.x!= point.x or self.last_point.y!= point.y or self.last_point.yaw!= point.yaw:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(point.yaw)\n        self.append_times(msg_time, bag_time)\n        # Set the current waypoint as the last waypoint\n        self.last_point = point\n", "CodeBleu_score": 26.12702073285826}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if self.last_waypoint is None:\n        self.last_waypoint = Waypoint()\n    elif self.last_waypoint.position.distance(waypoint_msg.position) > self.waypoint_dist_threshold or abs(self.last_waypoint.yaw - waypoint_msg.yaw) > self.waypoint_yaw_threshold:\n        self.last_waypoint.append_point(waypoint_msg)\n        self.last_waypoint.append_yaw(waypoint_msg.yaw)\n        self.last_waypoint.append_times(msg_time, bag_time)\n        self.last_waypoint = Waypoint()\n    else:\n        self.last_waypoint.append_point(waypoint_msg)\n        self.last_waypoint.append_yaw(waypoint_msg.yaw)\n        self.last_waypoint.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 22.384146589605304}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation\n    position = waypoint_msg.pose.pose.position\n    orientation = waypoint_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    yaw = euler_from_quaternion([orientation.x, orientation.y, orientation.z, orientation.w])[2]\n    # Create a Point object\n    point = Point(position.x, position.y, position.z, yaw)\n    # Check if the current waypoint is different from the last one\n    if len(self.points) > 0 and self.points[-1].x == point.x and self.points[-1].y == point.y and self.points[-1].z == point.z and self.points[-1].yaw == point.yaw:\n        # If the waypoint is the same as the last one, append the yaw and times\n        self.yaw = numpy.append(self.yaw, point.yaw)\n        self.append_times(msg_time, bag_time)\n    else:\n        # If the waypoint is different, append the point, yaw, and times\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, point.yaw)\n        self.append_times(msg_time, bag_time)\n", "CodeBleu_score": 31.31933407197365}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/linear_acceleration':\n        self.linear_acceleration_x = numpy.append(self.linear_acceleration_x, msg.linear_acceleration.x)\n        self.linear_acceleration_y = numpy.append(self.linear_acceleration_y, msg.linear_acceleration.y)\n        self.linear_acceleration_z = numpy.append(self.linear_acceleration_z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 32.1521788653342}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    self.imu_time.append_times(msg.header.stamp.to_sec(), bag_time)\n    if topic == '/imu/linear_acceleration':\n        self.imu_lin_acc_x.append(msg.linear_acceleration.x)\n        self.imu_lin_acc_y.append(msg.linear_acceleration.y)\n        self.imu_lin_acc_z.append(msg.linear_acceleration.z)\n    elif topic == '/imu/angular_velocity':\n        self.imu_ang_vel_x.append(msg.angular_velocity.x)\n        self.imu_ang_vel_y.append(msg.angular_velocity.y)\n        self.imu_ang_vel_z.append(msg.angular_velocity.z)\n\n", "CodeBleu_score": 30.652858165303183}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_data.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.imu_data.acc_x = numpy.append(self.imu_data.acc_x, msg.linear_acceleration.x)\n        self.imu_data.acc_y = numpy.append(self.imu_data.acc_y, msg.linear_acceleration.y)\n        self.imu_data.acc_z = numpy.append(self.imu_data.acc_z, msg.linear_acceleration.z)\n    elif topic == '/imu/mag':\n        self.imu_mag.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.imu_mag.mag_x = numpy.append(self.imu_mag.mag_x, msg.magnetic_field.x)\n        self.imu_mag.mag_y = numpy.append(self.imu_mag.mag_y, msg.magnetic_field.y)\n        self.imu_mag.mag_z = numpy.append(self.imu_mag.mag_z, msg.magnetic_field.z)\n    elif topic == '/imu/orientation':\n        self.imu_orientation.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.imu_orientation.orientation_x = numpy.append(self.imu_orientation.orientation_x, msg.orientation.x)\n        self.imu_orientation.orientation_y = numpy.append(self.imu_orientation.orientation_y, msg.orientation.y)\n        self.imu_orientation.orientation_z = numpy.append(self.imu_orientation.orientation_z, msg.orientation.z)\n        self.imu_orientation.orientation_w = numpy.append(self.imu_orientation.orientation_w, msg.orientation.w)\n    elif topic == '/imu/angular_velocity':\n        self.imu_angular_velocity.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.imu_angular_velocity.angular_velocity_x = numpy.append(self.imu_angular_velocity.angular_velocity_x, msg.angular_velocity.x)\n        self.imu_angular", "CodeBleu_score": 27.14861202372592}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n\n    # Create a figure with a title and a subplot for accelerations\n    fig, ax = plt.subplots(1, 1, figsize=(12, 6))\n    fig.suptitle('Accelerations')\n\n    # Plot accelerations for each dataset\n    for i, dataset in enumerate(self.datasets):\n        x = dataset['accelerations']['x']\n        y = dataset['accelerations']['y']\n        z = dataset['accelerations']['z']\n        ax.plot(x, label=f'x{i}', color='C0')\n        ax.plot(y, label=f'y{i}', color='C1')\n        ax.plot(z, label=f'z{i}', color='C2')\n\n    # Add labels for the x and y axes\n    ax.set_xlabel('Time')\n    ax.set_ylabel('Acceleration')\n\n    # Add a legend\n    ax.legend()\n\n    # If saving plots is enabled, save the plot\n    if self.save_plots:\n        # Construct a filename based on a prefix and optional suffix\n        filename = f'accelerations_{self.prefix}'\n        if plot_suffix:\n            filename += f'_{plot_suffix}'\n        filename += '.png'\n\n        # Save the plot as a PNG file\n        plt.savefig(filename)\n\n", "CodeBleu_score": 38.622894986249406}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create figure and subplot\n    fig, ax = plt.subplots()\n    # Set title\n    ax.set_title(f'Accelerations{plot_suffix}')\n    # Plot accelerations\n    for i, data in enumerate(self.accelerations):\n        # Plot x component\n        ax.plot(data.time, data.x, label=f'x{i}', color=f'C{i}')\n        # Plot y component\n        ax.plot(data.time, data.y, label=f'y{i}', color=f'C{i}')\n        # Plot z component\n        ax.plot(data.time, data.z, label=f'z{i}', color=f'C{i}')\n    # Add labels for x and y axes\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    # Add legend\n    ax.legend()\n    # If saving plots is enabled, save plot\n    if self.save_plots:\n        # Construct filename\n        filename = f'accelerations{plot_suffix}.png'\n        # Save plot\n        plt.savefig(filename)\n\n", "CodeBleu_score": 30.39770585084508}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.accelerations is not None:\n        if self.accelerations.empty:\n            return\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        else:\n            plot_suffix = \"_\" + plot_suffix\n        fig, ax = plt.subplots()\n        ax.set_title(\"Accelerations\")\n        ax.set_xlabel(\"Time (s)\")\n        ax.set_ylabel(\"Acceleration (m/s^2)\")\n        for i, col in enumerate(self.accelerations.columns):\n            ax.plot(self.accelerations.index, self.accelerations[col], label=col)\n        ax.legend()\n        if self.save_plots:\n            plot_filename = self.plot_prefix + \"accelerations\" + plot_suffix + \".png\"\n            fig.savefig(plot_filename)\n\n", "CodeBleu_score": 37.94026544661405}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if time >= start_time and time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 33.221366883419925}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is not None and end_time is not None:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None:\n            if start_time <= collision.time:\n                collision_times.append(collision.time)\n        elif end_time is not None:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 40.455347187927224}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if collision.time >= start_time and collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 40.28684565890178}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\n#ifdef DEBUG_NOISE\n  std::cout << \"D435DepthNoiseModel::ApplyNoise\" << std::endl;\n#endif\n\n  if (data == nullptr) {\n    std::cerr << \"D435DepthNoiseModel::ApplyNoise: data is null\" << std::endl;\n    return;\n  }\n\n  const float multiplier = this->GetMultiplier(width, height);\n  Eigen::Map<Eigen::MatrixXf> depth_data(data, height, width);\n\n  float rms_noise = this->GetRMSNoise(width, height);\n  float noise_value = this->GetNoiseValue(width, height);\n\n  for (uint32_t i = 0; i < height; i++) {\n    for (uint32_t j = 0; j < width; j++) {\n      if (this->InRange(depth_data(i, j))) {\n        depth_data(i, j) += multiplier * noise_value;\n      } else {\n        depth_data(i, j) = this->bad_point_value;\n      }\n    }\n  }\n\n#ifdef DEBUG_NOISE\n  std::cout << \"D435DepthNoiseModel::ApplyNoise: rms_noise: \" << rms_noise << std::endl;\n  std::cout << \"D435DepthNoiseModel::ApplyNoise: noise_value: \" << noise_value << std::endl;\n#endif\n}", "CodeBleu_score": 41.59230677673047}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t//  if (data == nullptr) {\n//    return;\n//  }\n//  const float multiplier = this->GetMultiplier(width, height);\n//  Eigen::Map<Eigen::VectorXf> depth_map(data, width * height);\n//  const float rms = this->GetRMSNoise(width, height);\n//  const float noise = this->GetNoise(width, height);\n//  for (uint32_t i = 0; i < width * height; ++i) {\n//    if (this->InRange(depth_map[i])) {\n//      depth_map[i] += (static_cast<float>(rand()) / RAND_MAX - 0.5f) * rms * multiplier;\n//    } else {\n//      depth_map[i] = this->bad_point_value;\n//    }\n//  }\n}", "CodeBleu_score": 2.7370175023774364}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t//  if (data == nullptr) {\n//    return;\n//  }\n//  float multiplier = this->GetMultiplier(width, height);\n//  Eigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n//  float rms_noise = this->GetRmsNoise(width, height);\n//  float noise_value = this->GetNoiseValue(width, height);\n//  for (uint32_t i = 0; i < depth_data.size(); i++) {\n//    if (this->InRange(depth_data[i])) {\n//      depth_data[i] += multiplier * this->GetRandomNoise();\n//    } else {\n//      depth_data[i] = this->bad_point_value;\n//    }\n//  }\n}", "CodeBleu_score": 2.7370175023774364}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get current simulation time\n\tcommon::Time current_time = world_->GetSimTime();\n\n\t// Convert to ROS time\n\tros::Time ros_time = ros::Time(current_time.sec, current_time.nsec);\n\n\t// Write trajectory message to bag file\n\tbag_.write(waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 58.39428545311717}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time\n\tdouble current_time = world_->GetSimTime().Double();\n\n\t// Convert the simulation time to ROS time\n\tros::Time ros_time = ros::Time(current_time);\n\n\t// Write the trajectory message to the bag file\n\tbag_.write(waypoint_topic_, ros_time, trajectory_msg);\n}", "CodeBleu_score": 48.56361687247502}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time\n\tdouble time = world->GetSimTime().Double();\n\n\t// Convert the simulation time to ROS time\n\tros::Time ros_time = ros::Time(time);\n\n\t// Write the trajectory message to the bag file\n\tbag.write(trajectory_msg_topic_, ros_time, trajectory_msg);\n}", "CodeBleu_score": 46.9770429319631}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert simulation time to ROS time\n\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n\t// Create a message for actuator velocities\n\tstd_msgs::Float64MultiArray motor_velocities;\n\n\t// Iterate through the motor joints\n\tfor (std::vector<physics::JointPtr>::iterator it = this->motor_joints.begin(); it!= this->motor_joints.end(); ++it) {\n\t\t// Calculate the slowed-down rotational velocities\n\t\tdouble rotational_velocity = (*it)->GetVelocity(0);\n\t\tdouble slowed_down_rotational_velocity = rotational_velocity / this->slowdown_factor;\n\n\t\t// Assign the slowed-down rotational velocities to the message\n\t\tmotor_velocities.data.push_back(slowed_down_rotational_velocity);\n\t}\n\n\t// Set the message timestamp\n\tmotor_velocities.header.stamp = ros_now;\n\n\t// Write the data to a bag file\n\tthis->bag.write(this->motor_topic, ros_now, motor_velocities);\n}", "CodeBleu_score": 46.272877363484746}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert the simulation time to ROS time\n\tros::Time time = ros::Time(now.sec, now.nsec);\n\n\t// Prepare the message\n\tactuator_msgs::MotorVelocities motor_velocities_msg;\n\tmotor_velocities_msg.header.stamp = time;\n\n\t// Iterate through the motor joints\n\tfor (size_t i = 0; i < motor_joints_.size(); i++) {\n\t\t// Calculate the slowed-down rotational velocity\n\t\tdouble rotational_velocity = motor_joints_[i]->GetVelocity(0);\n\t\tdouble slowed_down_rotational_velocity = rotational_velocity * slow_down_factor_;\n\n\t\t// Assign the slowed-down rotational velocity to the message\n\t\tmotor_velocities_msg.velocities.push_back(slowed_down_rotational_velocity);\n\t}\n\n\t// Write the message to the bag file\n\tmotor_velocities_bag_.write(motor_velocities_namespace_, time, motor_velocities_msg);\n}", "CodeBleu_score": 45.88264093400372}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert the simulation time to ROS time.\n\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n\t// Create a message for actuator velocities.\n\tactuator_msgs::MotorVelocities motor_velocities_msg;\n\n\t// Iterate through the motor joints.\n\tfor (auto motor_joint : this->motor_joints_) {\n\t\t// Calculate the slowed-down rotational velocity.\n\t\tdouble motor_velocity = motor_joint->GetVelocity(0) / this->slow_down_factor_;\n\n\t\t// Assign the slowed-down rotational velocity to the message.\n\t\tmotor_velocities_msg.velocities.push_back(motor_velocity);\n\t}\n\n\t// Set the message timestamp.\n\tmotor_velocities_msg.header.stamp = ros_now;\n\n\t// Write the message to the bag file.\n\tthis->motor_velocities_bag_.write(this->motor_velocities_topic_, ros_now, motor_velocities_msg);\n}", "CodeBleu_score": 41.462845144104165}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT_CALLBACKS\n  std::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\"\n            << std::endl;\n#endif\n\n  // Convert normalized inputs to angles\n  aileron_angle_ = NormalizedInputToAngle(aileron_, roll_pitch_yawrate_thrust_msg->roll);\n  elevator_angle_ = NormalizedInputToAngle(elevator_, roll_pitch_yawrate_thrust_msg->pitch);\n  rudder_angle_ = NormalizedInputToAngle(rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set throttle value\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust;\n}", "CodeBleu_score": 34.92836884209498}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT\n  std::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\n\";\n#endif\n\n  // Convert roll, pitch, yaw rate, and thrust to control surface angles.\n  roll_ = NormalizedInputToAngle(control_surfaces_[0], roll_pitch_yawrate_thrust_msg->roll());\n  pitch_ = NormalizedInputToAngle(control_surfaces_[1], roll_pitch_yawrate_thrust_msg->pitch());\n  yaw_rate_ = NormalizedInputToAngle(control_surfaces_[2], roll_pitch_yawrate_thrust_msg->yaw_rate());\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 44.25864870522794}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t", "CodeBleu_score": 2.6366947450589233}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tf GAZEBO_MAJOR_VERSION >= 8\n  if (serial_enabled_) {\n    // Poll for serial data.\n    int nbytes = 0;\n    struct timeval timeout;\n    timeout.tv_sec = 0;\n    timeout.tv_usec = _timeoutMs * 1000;\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(_fd, &readfds);\n    int n = select(_fd + 1, &readfds, NULL, NULL, &timeout);\n\n    if (n > 0) {\n      // Read data.\n      nbytes = read(_fd, rx_buffer_, MAX_RX_BUFFER_SIZE);\n      if (nbytes > 0) {\n        // Parse MAVLink messages.\n        int num_messages = mavlink_parse_char(\n            MAVLINK_COMM_0, rx_buffer_, nbytes, &mavlink_message_,\n            &mavlink_status_);\n\n        // Handle messages.\n        for (int i = 0; i < num_messages; ++i) {\n          handle_message(&mavlink_message_);\n        }\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 49.04917292824934}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t", "CodeBleu_score": 1.42558760589385}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tfndef _WIN32\n  if (serial_enabled_) {\n    //    struct timeval timeout;\n    //    timeout.tv_sec = 0;\n    //    timeout.tv_usec = _timeoutMs * 1000;\n    //    fd_set readfds;\n    //    FD_ZERO(&readfds);\n    //    FD_SET(_fd, &readfds);\n    //    int ret = select(_fd + 1, &readfds, NULL, NULL, &timeout);\n    //    if (ret == -1) {\n    //      gzerr << \"Error in select() \n\";\n    //      return;\n    //    }\n    //    if (ret) {\n    //      char buffer[256];\n    //      ssize_t len = recv(_fd, buffer, 256, 0);\n    //      if (len > 0) {\n    //        parse_buffer(buffer, len);\n    //      } else {\n    //        gzerr << \"Error in recv() \n\";\n    //      }\n    //    }\n  }\n#endif\n}", "CodeBleu_score": 1.78879458471042}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(this->mutex);\n\n\t// Check if the interface is open\n\tif (this->isOpen) {\n\t\t// Stop the I/O service\n\t\tthis->ioService.stop();\n\n\t\t// Close the serial device\n\t\tthis->serialDevice->close();\n\n\t\t// Check if the I/O thread is joinable\n\t\tif (this->ioThread.joinable()) {\n\t\t\t// Join the I/O thread to clean up resources\n\t\t\tthis->ioThread.join();\n\t\t}\n\n\t\t// Set the interface to closed\n\t\tthis->isOpen = false;\n\t}\n}", "CodeBleu_score": 28.2599434073865}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tif (this->open) {\n\t\tthis->open = false;\n\t\tthis->io_service->stop();\n\t\tthis->serial->close();\n\t\tif (this->io_thread.joinable()) {\n\t\t\tthis->io_thread.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 29.985550348714668}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tif (!this->isOpen()) {\n\t\treturn;\n\t}\n\n\t// Lock the mutex\n\tstd::unique_lock<std::mutex> lock(this->mutex);\n\n\t// Stop the I/O service\n\tthis->ioService.stop();\n\n\t// Close the serial device\n\tthis->serialPort.close();\n\n\t// If the I/O thread is joinable, join it\n\tif (this->ioThread.joinable()) {\n\t\tthis->ioThread.join();\n\t}\n}", "CodeBleu_score": 30.305183211165104}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d(0, 0, 0),\n\tignition::math::Vector3d(0, 0, 0),\n\tignition::math::Vector3d(0, 0, 0)\n}", "CodeBleu_score": 12.356089311776694}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d _position, _position1, _position2;\n\tdouble _value, _value1, _value2;\n\tdouble _t;\n\n\t_value = 0;\n\t_value1 = 0;\n\t_value2 = 0;\n\t_position1 = ignition::math::Vector3d(0, 0, 0);\n\t_position2 = ignition::math::Vector3d(0, 0, 0);\n\t_position = ignition::math::Vector3d(0, 0, 0);\n\t_t = 0;\n\n\treturn _position;\n}", "CodeBleu_score": 31.052473991101305}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (m_bLooping) {\n\t\tif (m_dAnimationTime!= _time) {\n\t\t\tm_dAnimationTime = _time;\n\t\t}\n\t}\n\telse {\n\t\tif (m_dAnimationTime!= _time) {\n\t\t\tm_dAnimationTime = std::clamp(_time, 0.0, m_dAnimationLength);\n\t\t}\n\t}\n}", "CodeBleu_score": 32.70342973897564}, {"code": "void Animation::SetTime(double _time){\n\t\tif (looping) {\n\t\ttime = fmod(_time, length);\n\t}\n\telse {\n\t\ttime = clamp(_time, 0.0, length);\n\t}\n}", "CodeBleu_score": 28.649258821547228}, {"code": "void Animation::SetTime(double _time){\n\t\tif (looping) {\n\t\tif (_time > length) {\n\t\t\ttime = _time - length;\n\t\t}\n\t\telse if (_time < 0) {\n\t\t\ttime = _time + length;\n\t\t}\n\t\telse {\n\t\t\ttime = _time;\n\t\t}\n\t}\n\telse {\n\t\tif (_time > length) {\n\t\t\ttime = length;\n\t\t}\n\t\telse if (_time < 0) {\n\t\t\ttime = 0;\n\t\t}\n\t\telse {\n\t\t\ttime = _time;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.967587363002046}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.position.x, y=self.position.y, z=self.position.z, yaw=self.attitude.yaw)\n    self.set_position_target_local_ned(target_raw_pose, 0, 0, 0, 0)\n    print(\"Vehicle type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight mode: \" + self.flight_mode)\n", "CodeBleu_score": 57.98689739762176}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n\n    target_raw_pose = self.construct_target()\n\n    self.set_position_target(target_raw_pose, 0)\n\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 42.597947921958315}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n\n    target_raw_pose = self.construct_target()\n    self.set_position_target_local_ned(target_raw_pose)\n\n    print(\"Vehicle Type: \" + str(self.vehicle_type))\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: \" + str(self.flight_mode))\n", "CodeBleu_score": 43.06832918507446}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service.set_mode(self.vehicle_type, self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode switched to \"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode switch failed\")\n            return False\n", "CodeBleu_score": 55.96532229188435}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.vehicle_type == 'copter':\n            if self.flight_mode == 'GUIDED':\n                self.flight_mode = 'LAND'\n            elif self.flight_mode == 'LAND':\n                self.flight_mode = 'RTL'\n            elif self.flight_mode == 'RTL':\n                self.flight_mode = 'AUTO'\n            elif self.flight_mode == 'AUTO':\n                self.flight_mode = 'GUIDED'\n            else:\n                print(\"Invalid flight mode\")\n                return False\n        elif self.vehicle_type == 'plane':\n            if self.flight_mode == 'GUIDED':\n                self.flight_mode = 'LAND'\n            elif self.flight_mode == 'LAND':\n                self.flight_mode = 'RTL'\n            elif self.flight_mode == 'RTL':\n                self.flight_mode = 'AUTO'\n            elif self.flight_mode == 'AUTO':\n                self.flight_mode = 'GUIDED'\n            else:\n                print(\"Invalid flight mode\")\n                return False\n        else:\n            print(\"Invalid vehicle type\")\n            return False\n        self.vehicle.mode = VehicleMode(self.flight_mode)\n        print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n        return True\n\n", "CodeBleu_score": 39.41625798406898}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode = self.flight_mode_service.request_flight_mode(self.flight_mode).mode\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+'FAILED TO SWITCH TO '+self.flight_mode+' MODE')\n            return False\n\n", "CodeBleu_score": 45.68980556348243}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n    self.hover_state_transition(x, y, z, w)\n    if self.hover_flag == 0:\n        self.hold_state_transition(x, y, z, w, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n\n", "CodeBleu_score": 40.94830829271195}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.current_velocity.x = msg.linear.x\n    self.current_velocity.y = msg.linear.y\n    self.current_velocity.z = msg.linear.z\n    self.current_angular_velocity.x = msg.angular.x\n    self.current_angular_velocity.y = msg.angular.y\n    self.current_angular_velocity.z = msg.angular.z\n    if (self.hover_flag == 0):\n        self.hover_state_transition(vx=self.current_velocity.x, vy=self.current_velocity.y, vz=self.current_velocity.z,\n                                    w=self.current_angular_velocity.z)\n    if (self.hold_flag == 0):\n        self.hold_state_transition(vel_type='enu', x=self.current_velocity.x, y=self.current_velocity.y, z=self.current_velocity.z,\n                                   w=self.current_angular_velocity.z)\n    if (self.hover_flag == 0 and self.hold_flag == 0):\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=self.current_velocity.x, vy=self.current_velocity.y,\n                                                   vz=self.current_velocity.z, yaw_rate=self.current_angular_velocity.z)\n\n", "CodeBleu_score": 57.082229659677466}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    # print('cmd_vel_enu_callback')\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.42312951090571}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    elif self.hover_flag == 0 and self.flight_mode!= 'HOVER':\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n\n", "CodeBleu_score": 66.47327433703136}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.set_mode('OFFBOARD')\n        print('OFFBOARD')\n    elif self.hover_flag == 0 and self.flight_mode!= 'HOVER':\n        self.hover_flag = 1\n        self.set_mode('HOVER')\n        self.hover()\n        print('HOVER')\n\n", "CodeBleu_score": 41.992035235531}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005):\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n    elif (self.hover_flag == 1 and self.flight_mode!= 'HOVER'):\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n\n", "CodeBleu_score": 57.29425340098447}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 27.52863807726429}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 27.52863807726429}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 2\n    self.motion_type = 3\n    self.target_raw_pose = self.construct_target(self.current_pose.position.x, self.current_pose.position.y, self.current_pose.position.z, 0, 0, 0, 0, 0, 0, self.current_pose.orientation.z, 0)\n    self.print_vehicle_type()\n    self.print_vehicle_id()\n    self.print_flight_mode()\n    self.set_position_target_local_ned(self.target_raw_pose, 0, 0, 0, 0, 0, 0, 0)\n\n", "CodeBleu_score": 41.43605412423382}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 3\n    target_raw_pose = self.construct_target(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.set_position_target_local_ned(target_raw_pose, 0, 0, 0, 0)\n    print(\"Vehicle type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight mode: \" + str(self.mode))\n\n", "CodeBleu_score": 25.323433779725807}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n\n    self.target_raw_pose = self.construct_target(self.x, self.y, self.z, 0, 0, 0, 0, 0, 0, self.yaw, 0)\n\n    print(\"Vehicle Type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight Mode: Hover\")\n\n", "CodeBleu_score": 43.406431704997814}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flight_mode_service.set_mode(self.target_mode).result():\n            self.flight_mode = self.target_mode\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Flight mode set to \" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Failed to set flight mode to \" + self.flight_mode)\n            return False\n\n", "CodeBleu_score": 55.96851145312137}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service.set_mode(self.vehicle_type, self.flight_mode)\n            self.flight_mode = self.flight_mode_service.get_mode(self.vehicle_type).name\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except Exception as e:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":Failed to switch flight mode: \" + str(e))\n            return False\n\n", "CodeBleu_score": 50.446784040198054}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flight_mode_service.switchMode(self.vehicle_type, self.flight_mode).result:\n            self.flight_mode = self.flight_mode_service.getMode().result\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Failed to switch flight mode to \" + self.flight_mode)\n            return False\n\n", "CodeBleu_score": 54.18510283303479}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == i:\n        self.local_pose[i] = msg\n        if msg.command == 1:\n            self.takeoff_target_pose[i] = msg\n        elif msg.command == 2:\n            self.hover_target_pose[i] = msg\n        self.global_pose[i].position.x = self.local_pose[i].position.x + self.global_pose[0].position.x\n        self.global_pose[i].position.y = self.local_pose[i].position.y + self.global_pose[0].position.y\n        self.global_pose[i].position.z = self.local_pose[i].position.z + self.global_pose[0].position.z\n        self.global_pose[i].orientation = self.local_pose[i].orientation\n\n", "CodeBleu_score": 29.206748142256078}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        if self.gcs_command == 1:\n            self.takeoff_target_pose = msg\n        elif self.gcs_command == 2:\n            self.hover_target_pose = msg\n        elif self.gcs_command == 3:\n            self.land_target_pose = msg\n        elif self.gcs_command == 4:\n            self.takeoff_target_pose = msg\n            self.hover_target_pose = msg\n        elif self.gcs_command == 5:\n            self.hover_target_pose = msg\n            self.land_target_pose = msg\n        elif self.gcs_command == 6:\n            self.takeoff_target_pose = msg\n            self.hover_target_pose = msg\n            self.land_target_pose = msg\n        elif self.gcs_command == 7:\n            self.takeoff_target_pose = msg\n            self.hover_target_pose = msg\n            self.land_target_pose = msg\n            self.global_pose = msg\n        elif self.gcs_command == 8:\n            self.takeoff_target_pose = msg\n            self.hover_target_pose = msg\n            self.land_target_pose = msg\n            self.global_pose = msg\n            self.global_pose.position.x += 0.5\n            self.global_pose.position.y += 0.5\n            self.global_pose.position.z += 0.5\n\n", "CodeBleu_score": 15.62045161035264}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        if self.gcs_command == 'takeoff':\n            self.takeoff_target_pose = msg\n            self.hover_target_pose = msg\n        elif self.gcs_command == 'hover':\n            self.hover_target_pose = msg\n        elif self.gcs_command == 'land':\n            self.land_target_pose = msg\n        elif self.gcs_command =='set_target_pose':\n            self.target_pose = msg\n        elif self.gcs_command =='set_target_position':\n            self.target_position = msg\n        elif self.gcs_command =='set_target_velocity':\n            self.target_velocity = msg\n        elif self.gcs_command =='set_target_acceleration':\n            self.target_acceleration = msg\n        elif self.gcs_command =='set_target_yaw':\n            self.target_yaw = msg\n        elif self.gcs_command =='set_target_yaw_rate':\n            self.target_yaw_rate = msg\n        elif self.gcs_command =='set_target_attitude':\n            self.target_attitude = msg\n        elif self.gcs_command =='set_target_thrust':\n            self.target_thrust = msg\n        elif self.gcs_command =='set_target_local_pose':\n            self.target_local_pose = msg\n        elif self.gcs_command =='set_target_global_pose':\n            self.target_global_pose = msg\n        elif self.gcs_command =='set_target_local_position':\n            self.target_local_position = msg\n        elif self.gcs_command =='set_target_global_position':\n            self.target_global_position = msg\n        elif self.gcs_command =='set_target_local_velocity':\n            self.target_local_velocity = msg\n        elif self.gcs_command =='set_target_global_velocity':\n            self.target_global_velocity = msg\n        elif self.gcs_command =='set_target_local_acceleration':\n            self.target_local_acceleration = msg\n        elif self.gcs_command =='set_target_global_acceleration':\n           ", "CodeBleu_score": 14.180621524681861}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.get_altitude() > 0.2 and self.get_arm_state() == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.808182576807155}, {"code": "def takeoff_detection(self)\n\t\n    if self.vehicle.location.global_relative_frame.alt > 0.2 and self.vehicle.armed:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.95685276863904}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == 'active':\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.862379601652705}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Calculate the pairwise distances between UAVs in the original formation\n    orig_distances = np.array([np.linalg.norm(uav_i - uav_j) for uav_i in orig_formation for uav_j in orig_formation])\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    orig_distances = np.round(50 - orig_distances).astype(int)\n    # Calculate the pairwise distances between UAVs in the changed formation\n    change_distances = np.array([np.linalg.norm(uav_i - uav_j) for uav_i in change_formation for uav_j in change_formation])\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    change_distances = np.round(50 - change_distances).astype(int)\n    # Return the distance matrix\n    return orig_distances, change_distances\n\n", "CodeBleu_score": 19.376592278166765}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # calculate the distance matrix for the original formation\n    orig_formation_dist_matrix = np.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            if i!= j:\n                orig_formation_dist_matrix[i][j] = np.linalg.norm(orig_formation[i] - orig_formation[j])\n    # calculate the distance matrix for the changed formation\n    change_formation_dist_matrix = np.zeros((len(change_formation), len(change_formation)))\n    for i in range(len(change_formation)):\n        for j in range(len(change_formation)):\n            if i!= j:\n                change_formation_dist_matrix[i][j] = np.linalg.norm(change_formation[i] - change_formation[j])\n    # adjust the distance matrix for the original formation\n    orig_formation_dist_matrix = 50 - orig_formation_dist_matrix\n    orig_formation_dist_matrix = orig_formation_dist_matrix.astype(int)\n    # adjust the distance matrix for the changed formation\n    change_formation_dist_matrix = 50 - change_formation_dist_matrix\n    change_formation_dist_matrix = change_formation_dist_matrix.astype(int)\n    # return the distance matrices\n    return orig_formation_dist_matrix, change_formation_dist_matrix\n\n", "CodeBleu_score": 20.56786241410317}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n\n    orig_formation_x = []\n    orig_formation_y = []\n    change_formation_x = []\n    change_formation_y = []\n\n    for i in range(len(orig_formation)):\n        orig_formation_x.append(orig_formation[i][0])\n        orig_formation_y.append(orig_formation[i][1])\n\n    for i in range(len(change_formation)):\n        change_formation_x.append(change_formation[i][0])\n        change_formation_y.append(change_formation[i][1])\n\n    # Calculate the pairwise distances between UAVs in the original formation\n    orig_formation_dist_x = np.array(orig_formation_x)[:, None] - np.array(orig_formation_x)\n    orig_formation_dist_y = np.array(orig_formation_y)[:, None] - np.array(orig_formation_y)\n    orig_formation_dist_x = np.sqrt(orig_formation_dist_x ** 2 + orig_formation_dist_y ** 2)\n    orig_formation_dist_x = np.round(orig_formation_dist_x - 50)\n    orig_formation_dist_x = orig_formation_dist_x.astype(int)\n\n    # Calculate the pairwise distances between UAVs in the changed formation\n    change_formation_dist_x = np.array(change_formation_x)[:, None] - np.array(change_formation_x)\n    change_formation_dist_y = np.array(change_formation_y)[:, None] - np.array(change_formation_y)\n    change_formation_dist_x = np.sqrt(change_formation_dist_x ** 2 + change_formation_dist_y ** 2)\n    change_formation_dist_x = np.round(change_formation_dist_x - 50)\n    change_formation_dist_x = change_formation_dist_x.astype(int)\n\n    # Build the distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i, j] = orig_formation", "CodeBleu_score": 18.568852157573733}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n", "CodeBleu_score": 53.62099202107192}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.62099202107192}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.62099202107192}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    for i in range(self.uav_count):\n        self.slack_right = [float('inf')] * self.uav_count\n        while True:\n            self.visit_left = [False] * self.uav_count\n            self.visit_right = [False] * self.uav_count\n            for j in range(self.uav_count):\n                self.slack_right[j] = float('inf')\n            if self.find_path(i):\n                break\n            min_slack = float('inf')\n            for j in range(self.uav_count):\n                if not self.visit_right[j]:\n                    min_slack = min(min_slack, self.slack_right[j])\n            for i in range(self.uav_count):\n                if self.visit_left[i]:\n                    self.label_left[i] -= min_slack\n            for j in range(self.uav_count):\n                if self.visit_right[j]:\n                    self.label_right[j] += min_slack\n    return self.match_right\n\n", "CodeBleu_score": 41.24005089000792}, {"code": "def KM(self)\n\t\n    self.match_right = [-1] * self.n_right\n    self.label_left = [0] * self.n_left\n    self.label_right = [0] * self.n_right\n    self.slack_right = [float('inf')] * self.n_right\n    self.visit_left = [False] * self.n_left\n    self.visit_right = [False] * self.n_right\n    for i in range(self.n_left):\n        self.slack_right = [float('inf')] * self.n_right\n        self.visit_right = [False] * self.n_right\n        self.find_path(i)\n    return self.match_right\n\n", "CodeBleu_score": 22.08893106830007}, {"code": "def KM(self)\n\t\n    self.match_right = [-1] * self.n_right\n    for i in range(self.n_left):\n        self.slack_right = [float('inf')] * self.n_right\n        self.visit_left = [False] * self.n_left\n        self.visit_right = [False] * self.n_right\n        self.label_left = [0] * self.n_left\n        self.label_right = [0] * self.n_right\n        while not self.find_path(i):\n            delta = float('inf')\n            for j in range(self.n_right):\n                if not self.visit_right[j]:\n                    delta = min(delta, self.slack_right[j])\n            for j in range(self.n_right):\n                if self.visit_right[j]:\n                    self.label_right[j] -= delta\n                if not self.visit_right[j]:\n                    self.slack_right[j] -= delta\n            for i in range(self.n_left):\n                if not self.visit_left[i]:\n                    self.label_left[i] += delta\n    return self.match_right\n\n", "CodeBleu_score": 36.41057041581749}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Create a mask for yellow color\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 26.819339810455766}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t(const std::string &tagID, TagDescriptionContainer &descriptionContainer, bool printWarning)\n\t{\n\t\tif (standalone_tag_descriptions_.find(tagID)!= standalone_tag_descriptions_.end())\n\t\t{\n\t\t\tdescriptionContainer = standalone_tag_descriptions_.at(tagID);\n\t\t\treturn true;\n\t\t}\n\t\telse if (printWarning)\n\t\t{\n\t\t\tstd::cout << \"WARNING: Could not find standalone tag description for ID \" << tagID << std::endl;\n\t\t}\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 44.28752956498968}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t(StandaloneTagDescriptionContainer &descriptionContainer, const std::string &id, bool printWarning) {\n\t\tauto it = standalone_tag_descriptions_.find(id);\n\t\tif (it == standalone_tag_descriptions_.end()) {\n\t\t\tif (printWarning) {\n\t\t\t\tstd::string message = \"Tag description with ID \" + id + \" not found.\";\n\t\t\t\tLogger::log(Logger::LogLevel::WARNING, Logger::LogCategory::TAG_DETECTOR, message);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tdescriptionContainer = it->second;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 52.40786784558195}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t(const std::string &tagID, TagDescriptionContainer &descriptionContainer, bool printWarning)\n{\n\t// Search for the tag description in the map\n\tauto tagDescriptionIterator = standalone_tag_descriptions_.find(tagID);\n\tif (tagDescriptionIterator!= standalone_tag_descriptions_.end()) {\n\t\t// The tag description was found\n\t\tdescriptionContainer = tagDescriptionIterator->second;\n\t\treturn true;\n\t}\n\n\t// The tag description was not found\n\tif (printWarning) {\n\t\t// Log a warning message\n\t\tstd::stringstream warningMessage;\n\t\twarningMessage << \"Could not find standalone tag description for tag ID \" << tagID;\n\t\tlogger_->log_warning(warningMessage);\n\t}\n\n\t// Return false\n\treturn false;\n}\n}", "CodeBleu_score": 51.801813883371636}]}
