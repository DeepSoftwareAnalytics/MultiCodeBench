{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len;\n\tuint8_t desc_type;\n\tuint8_t desc_subtype;\n\n\t/*\n\t * Iterate through the descriptors in the interface descriptor to find the specified descriptor type.\n\t */\n\twhile (desc->bLength) {\n\t\tdesc_len = desc->bLength;\n\t\tdesc_type = desc->bDescriptorType;\n\t\tdesc_subtype = desc->bDescriptorSubtype;\n\n\t\tif ((desc_type == USB_DT_INTERFACE) && (desc_subtype == desc_id)) {\n\t\t\treturn desc;\n\t\t}\n\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc\n\t\t\t\t+ desc_len);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 45.60627346136364}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len;\n\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc;\n\n\tnext_desc = desc;\n\n\twhile (next_desc->bDescriptorType!= desc_id) {\n\t\tdesc_len = next_desc->bLength;\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc + desc_len);\n\t\tif (next_desc->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tdesc_len = next_desc->bLength;\n\t\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc + desc_len);\n\t\t} else if (next_desc->bDescriptorType == USB_DT_ENDPOINT) {\n\t\t\tdesc_len = next_desc->bLength;\n\t\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc + desc_len);\n\t\t} else if (next_desc->bDescriptorType == USB_DT_DEVICE) {\n\t\t\tdesc_len = next_desc->bLength;\n\t\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc + desc_len);\n\t\t} else if (next_desc->bDescriptorType == USB_DT_CONFIG) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn next_desc;\n}", "CodeBleu_score": 45.61478660794836}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t desc_len;\n\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc = desc;\n\n\twhile (next_desc->bDescriptorType!= desc_id) {\n\t\tdesc_len = next_desc->bLength;\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc + desc_len);\n\n\t\tif (next_desc->bDescriptorType == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn next_desc;\n}", "CodeBleu_score": 40.194135739488864}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t i;\n\tuint8_t *desc;\n\tuint8_t desc_len;\n\n\tif (udc_config_desc_len == 0) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_config_desc_len) {\n\t\treturn false;\n\t}\n\n\tdesc = udc_config_desc;\n\tdesc_len = udc_config_desc_len;\n\n\tfor (i = 0; i < desc_len; i++) {\n\t\tif (desc[1] == USB_DT_INTERFACE && desc[2] == iface_num && desc[3] == setting_num) {\n\t\t\treturn true;\n\t\t}\n\t\tdesc = desc + desc[0];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 31.503284186023418}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (g_request_length!= sizeof(uint8_t)) {\n\t\treturn false;\n\t}\n\tuint8_t ep_status = 0;\n\tif (g_request_ep_num == 0) {\n\t\tep_status = (uint8_t) (g_ep0_state == EP0_STATE_HALTED);\n\t} else {\n\t\tif (g_ep_state[g_request_ep_num - 1] == EP_STATE_HALTED) {\n\t\t\tep_status = 1;\n\t\t}\n\t}\n\tg_response_payload[0] = ep_status;\n\treturn true;\n}", "CodeBleu_score": 32.1980104657304}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\t// Check if the request length matches the size of the endpoint status variable\n\tif (g_req_length!= sizeof(g_ep_status)) {\n\t\tg_resp_length = 0;\n\t\treturn false;\n\t}\n\n\t// Determine the status of the specified endpoint\n\tif (g_ep_status & 1) {\n\t\tg_ep_status = 0;\n\t} else {\n\t\tg_ep_status = 1;\n\t}\n\n\t// Set up the response payload with the endpoint status\n\tg_resp_payload[0] = g_ep_status;\n\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 23.314997748530512}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_addr;\n\tuint8_t ep_status;\n\tuint8_t ep_type;\n\tuint8_t ep_dir;\n\tuint8_t ep_num;\n\n\tif (usb_req_get_length()!= sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\tep_addr = usb_req_get_value();\n\tep_num = ep_addr & 0x0F;\n\tep_dir = ep_addr & 0x80;\n\tep_type = usb_ep_get_type(ep_num);\n\n\tif (ep_type == USB_EP_TYPE_BULK) {\n\t\tep_status = usb_ep_get_status(ep_num, ep_dir);\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\tusb_req_set_length(sizeof(ep_status));\n\tusb_req_set_data((uint8_t*)&ep_status, sizeof(ep_status));\n\n\treturn true;\n}", "CodeBleu_score": 43.72392614622322}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if the device is in a configured state\n\tif (0 == udc_ptr_conf->state) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is valid\n\tif (udc_ptr_setup->wIndex >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(udc_ptr_setup->wIndex, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(udc_ptr_setup->wIndex,\n\t\t\tudc_ptr_iface->bAlternateSetting)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\treturn udc_ptr_iface->handler(udc_ptr_setup);\n}", "CodeBleu_score": 59.12078053605029}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\t// Check if the device is in a configured state\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tiface_num = udc_setup.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)\n\t\t\tudc_ptr_conf->desc;\n\twhile (iface_num!= udc_ptr_iface->bInterfaceNumber) {\n\t\t// Go to next descriptor\n\t\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (\n\t\t\t\t(uint8_t *) udc_ptr_iface +\n\t\t\t\tudc_ptr_iface->bLength);\n\t}\n\tudc_ptr_iface->bAlternateSetting = 0;\n\n\t// Update the interface descriptor to the current alternate setting\n\tsetting_num = udc_setup.wValue & 0xFF;\n\tif (udc_update_iface_desc(iface_num, setting_num)) {\n\t\t// The interface descriptor is found\n\t\tudc_ptr_iface->bAlternateSetting = setting_num;\n\t} else {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\treturn udc_req_udi();\n}", "CodeBleu_score": 62.18428848705473}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t alt_setting;\n\tbool ret;\n\n\t// Check if the device is configured\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tif (udc_ptr_setup->wIndex >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tret = udc_update_iface_desc(udc_ptr_setup->wIndex, 0);\n\tif (!ret) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current alternate setting\n\talt_setting = udc_ptr_iface->bAlternateSetting;\n\tret = udc_update_iface_desc(udc_ptr_setup->wIndex, alt_setting);\n\tif (!ret) {\n\t\treturn false;\n\t}\n\n\t// Forward SETUP request to UDI handler\n\tret = udc_ptr_iface->handler(UDC_REQ_IFACE);\n\treturn ret;\n}", "CodeBleu_score": 59.00997191841687}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t#if UDI_MSC_LUN_NB > 0\n  // Retrieve number of LUNs\n  uint8_t lun_nb = udi_msc_get_lun_nb();\n\n  // If no LUNs, return false\n  if (lun_nb == 0) {\n    return false;\n  }\n\n  // If external enable function fails, return false\n  if (!udi_msc_ext_enable()) {\n    return false;\n  }\n\n  // Unload medium on each LUN\n  for (uint8_t lun = 0; lun < lun_nb; lun++) {\n    udi_msc_ext_unload_medium(lun);\n  }\n\n  // Start MSC process\n  udi_msc_cbw_wait();\n  return true;\n#else\n  return false;\n#endif\n}", "CodeBleu_score": 39.71969345855756}, {"code": "bool udi_msc_enable(void){\n\t// Retrieve the number of Logical Unit Numbers (LUNs)\n  udi_msc_lun_nb = udi_msc_ext_enable();\n\n  // If no LUNs are available or if the external enable function fails, return false\n  if (udi_msc_lun_nb == 0 ||!udi_msc_lun_nb) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t i = 0; i < udi_msc_lun_nb; i++) {\n    udi_msc_unload_medium(i);\n  }\n\n  // Start the MSC process by waiting for a Command Block Wrapper (CBW) reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 35.91633256843734}, {"code": "bool udi_msc_enable(void){\n\t#if (UDI_MSC_EXT_ENABLE)\n  // Call the external enable function\n  if (!udi_msc_ext_enable()) {\n    return false;\n  }\n#endif\n\n  // Initialize flags\n  udi_msc_cbw_valid = false;\n  udi_msc_cbw_received = false;\n  udi_msc_cbw_phase = UDI_MSC_CBW_PHASE_CBW;\n  udi_msc_cbw_status = UDI_MSC_CBW_STATUS_OK;\n  udi_msc_cbw_lun = 0;\n  udi_msc_cbw_length = 0;\n\n  // Get the number of LUNs\n  udi_msc_cbw_lun = udi_msc_ext_lun_num();\n\n  // Check if there are any LUNs\n  if (udi_msc_cbw_lun == 0) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t lun = 0; lun < udi_msc_cbw_lun; lun++) {\n    if (!udi_msc_ext_lun_unload(lun)) {\n      return false;\n    }\n  }\n\n  // Start the MSC process by waiting for a Command Block Wrapper (CBW) reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 55.00537718678795}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_CBW_BUFFER_SIZE > 0\n  if (UDD_EP_DIR_IN == udd_ep_get_direction(ep)) {\n    // Data sent to USB host\n    if (UDD_EP_TRANSFER_OK == status) {\n      // Data successfully sent\n      udi_msc_csw.dCSWDataResidue -= nb_sent;\n      udi_msc_sense_pass();\n    } else {\n      // Error during data transfer\n      udi_msc_sense_error(USB_CSW_STATUS_FAIL);\n    }\n    udi_msc_csw_process();\n  }\n#endif\n}", "CodeBleu_score": 54.1292324493067}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_CBW_SIZE > UDI_MSC_MAX_DATA_SIZE\n  uint8_t data_size;\n#endif\n\n  if (status!= UDD_EP_TRANSFER_OK) {\n    // Error during data transfer\n    // STALL next request from USB host on corresponding endpoint\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    return;\n  }\n  // Data transfer successful\n  // Update sense data\n  udi_msc_sense_update();\n#if UDI_MSC_CBW_SIZE > UDI_MSC_MAX_DATA_SIZE\n  // Check if data size is greater than maximum data size\n  data_size = udi_msc_cbw.bCBWCB[0];\n  if (data_size > UDI_MSC_MAX_DATA_SIZE) {\n    // Data size is greater than maximum data size\n    // Update data residue in CSW\n    udi_msc_csw.dCSWDataResidue -= data_size;\n    // Update CSW\n    udi_msc_csw_send();\n  } else {\n    // Data size is less than maximum data size\n    // Update data residue in CSW\n    udi_msc_csw.dCSWDataResidue -= data_size;\n    // Process CSW\n    udi_msc_csw_process();\n  }\n#else\n  // Update data residue in CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n#endif\n}", "CodeBleu_score": 56.69037358862121}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_DATA_TRANSFER_CALLBACK\n  UDI_MSC_DATA_TRANSFER_CALLBACK(udi_msc_data_sent_cb, status, nb_sent, ep);\n#else\n  if (UDD_EP_TRANSFER_OK!= status) {\n    // If transfer not successful\n    // then STALL next request from USB host on corresponding endpoint\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n  } else {\n    // Transfer successful\n    // then update the sense data\n    udi_msc_sense.bSenseKey = USB_SENSE_NO_SENSE;\n    udi_msc_sense.bAdditionalSenseCode = USB_SENSE_NO_SENSE;\n    udi_msc_sense.bAdditionalSenseCodeQualifier = USB_SENSE_NO_SENSE;\n    udi_msc_sense.bSenseKeySpecific = 0;\n    // then decrease the data residue in the CSW\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n    // then process the CSW\n    udi_msc_csw_process();\n  }\n#endif\n}", "CodeBleu_score": 57.844531328240535}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n\tif (udi_msc_csw.dCSWDataResidue) {\n\t\tif (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\t// Stall OUT endpoint\n\t\t\tudd_ep_stall(UDI_MSC_EP_OUT);\n\t\t} else {\n\t\t\t// Stall IN endpoint\n\t\t\tudd_ep_stall(UDI_MSC_EP_IN);\n\t\t}\n\t}\n\t// Convert data residue to little-endian format\n\tudi_msc_csw.dCSWDataResidue = UDI_MSC_LITTLE_ENDIAN_DWORD(udi_msc_csw.dCSWDataResidue);\n\t// Send CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 66.06497957430248}, {"code": "static void udi_msc_csw_process(void){\n\t#if UDI_MSC_CBW_DIRECTION == UDI_MSC_CBW_DIRECTION_IN\n  // IN direction\n  if (udi_msc_csw.data_residue) {\n    // Data residue\n    // Stall next request\n    udd_ep_stall(UDI_MSC_EP_IN);\n  }\n#else\n  // OUT direction\n  if (udi_msc_csw.data_residue > 0) {\n    // Data residue\n    // Stall next request\n    udd_ep_stall(UDI_MSC_EP_OUT);\n  }\n#endif\n\n  // Prepare CSW\n  udi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n  udi_msc_csw.tag = udi_msc_cbw.tag;\n  udi_msc_csw.data_residue = udi_msc_cbw.data_length;\n  udi_msc_csw.status = UDI_MSC_CSW_STATUS_OK;\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 49.65235091621482}, {"code": "static void udi_msc_csw_process(void){\n\t#if UDI_MSC_EP_BULK_SIZE < 31\n  // If there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW)\n  if (udi_msc_csw.data_residue) {\n    if (udi_msc_cbw.direction == UDI_MSC_CBW_DIRECTION_IN) {\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    } else {\n      udd_ep_stall(UDI_MSC_EP_IN);\n    }\n  }\n#endif\n\n  // Prepares the CSW by setting its tag and converting the data residue to little-endian format\n  udi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n  udi_msc_csw.tag = udi_msc_cbw.tag;\n  udi_msc_csw.data_residue = udi_msc_cbw.data_len;\n  udi_msc_csw.status = udi_msc_cbw.status;\n  udi_msc_csw.data_residue = cpu_to_le32(udi_msc_csw.data_residue);\n\n  // Sends CSW on IN endpoint\n  udi_msc_csw_send();\n}", "CodeBleu_score": 52.78920450024602}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_MAX_NUM_PORTS) {\n\t\treturn;\n\t}\n\tif (b_enable) {\n\t\tif (usb_cdc_dtr_rate[port] == 1200) {\n\t\t\tcancelReset();\n\t\t}\n\t} else {\n\t\tif (usb_cdc_dtr_rate[port] == 1200) {\n\t\t\tscheduleReset(RESET_CONTROLLER_RESET_USB_DTR_LOW);\n\t\t}\n\t}\n\tusb_cdc_dtr[port] = b_enable;\n}", "CodeBleu_score": 40.99905317097168}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_PORT_COUNT) {\n\t\treturn;\n\t}\n\n\t// Set the DTR state\n\tusb_cdc_dtr[port] = b_enable;\n\n\t// Check if the DTR rate is 1200\n\tif (b_enable && (usb_cdc_dtr_rate[port] == 1200)) {\n\t\t// Schedule a delayed system reset\n\t\tusb_cdc_delayed_reset[port] = true;\n\t\tinitiateReset();\n\t} else {\n\t\t// Cancel any scheduled reset\n\t\tusb_cdc_delayed_reset[port] = false;\n\t\tcancelReset();\n\t}\n}", "CodeBleu_score": 39.791788406646596}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\t// DTR is enabled, so cancel any pending reset\n\t\tcancelReset();\n\t}\n\telse {\n\t\t// DTR is disabled, so check if we need to schedule a reset\n\t\tif (cdc_dtr_rate == 1200) {\n\t\t\t// Schedule a reset\n\t\t\tscheduleReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 24.51007484429949}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tbool request_processed = false;\n\n\tswitch (usb_request.bRequest) {\n\tcase 0x04:\n\t\tif (usb_request.wIndex == 0x04) {\n\t\t\tusb_request.wLength = 2;\n\t\t\tusb_request.pData = (uint8_t *) &usb_id_descriptor;\n\t\t\trequest_processed = true;\n\t\t}\n\t\tbreak;\n\n\tcase 0x05:\n\t\tif (usb_request.wIndex == 0x05) {\n\t\t\tusb_request.wLength = 10;\n\t\t\tusb_request.pData = (uint8_t *) &usb_extended_descriptor;\n\t\t\trequest_processed = true;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn request_processed;\n}", "CodeBleu_score": 20.759498337006224}, {"code": "bool usb_task_other_requests(void){\n\t\tif (usb_setup.bmRequestType == USB_SETUP_REQUEST_TYPE_VENDOR) {\n\t\tif (usb_setup.bRequest == 0x04) {\n\t\t\tif (usb_setup.wIndex == 0x0004) {\n\t\t\t\tusb_setup.wLength = 2;\n\t\t\t\tusb_setup.pPayload = (uint8_t *) &usb_id_descriptor;\n\t\t\t\treturn true;\n\t\t\t} else if (usb_setup.wIndex == 0x0005) {\n\t\t\t\tusb_setup.wLength = sizeof(usb_ext_descriptor);\n\t\t\t\tusb_setup.pPayload = (uint8_t *) &usb_ext_descriptor;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 21.294802738042513}, {"code": "bool usb_task_other_requests(void){\n\t\t// If the request is not a standard request, return false.\n\tif (usb_setup_request.bmRequestType!= (USB_SETUP_TYPE_CLASS | USB_SETUP_RECIPIENT_INTERFACE)) {\n\t\treturn false;\n\t}\n\n\t// If the request is a standard request, return true.\n\treturn true;\n}", "CodeBleu_score": 5.387495717308182}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(0);\n\t\twhile (!(SPSR & (1 << SPIF)))\n\t\t\t;\n\t\tbuf[i] = SPDR;\n\t}\n\tspiSend(0);\n\twhile (!(SPSR & (1 << SPIF)))\n\t\t;\n\tbuf[i] = SPDR;\n\tspiRec();\n}", "CodeBleu_score": 45.16835315106962}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPI0_DR = 0xFF;\n\t\twhile ((SPI0_SR & SPI_SR_RXCTR_MASK) == 0) {\n\t\t}\n\t\tbuf[i] = SPI0_DR;\n\t}\n\tspiRec(buf + i);\n}", "CodeBleu_score": 44.02266485987959}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\tuint8_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPI0_DATA = 0xFF;\n\t\twhile ((SPI0_SR & SPI_SR_RX_EMPTY) == 0)\n\t\t\t;\n\t\tbuf[i] = SPI0_DATA;\n\t}\n\tSPI0_DATA = 0xFF;\n\twhile ((SPI0_SR & SPI_SR_RX_EMPTY) == 0)\n\t\t;\n\tbuf[nbyte - 1] = SPI0_DATA;\n}", "CodeBleu_score": 43.65093965876109}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Retrieve the address of the relocated interrupt vector table\n\tuint32_t *pVectorTable = (uint32_t *) *(uint32_t *) 0x00000000;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Retrieve the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = (pfnISR_Handler) pVectorTable[irq];\n\n\t// Replace the handler with the new handler\n\tpVectorTable[irq] = (uint32_t) newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original ISR handler\n\treturn oldHandler;\n}", "CodeBleu_score": 49.963994751065684}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *relocated_vector_table;\n\n\trelocated_vector_table = (uint32_t *)((uint32_t)SCB->VTOR + 0x200);\n\tDISABLE_INTERRUPTS();\n\toldHandler = relocated_vector_table[irq];\n\trelocated_vector_table[irq] = (uint32_t)newHandler;\n\tENABLE_INTERRUPTS();\n\n\treturn oldHandler;\n}", "CodeBleu_score": 47.871515514353}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *vectorTable = (uint32_t *)SCB->VTOR;\n\tuint32_t *vectorTableOffset = vectorTable + irq;\n\tuint32_t *originalVectorTableOffset = vectorTableOffset;\n\tuint32_t *newVectorTableOffset = vectorTableOffset + 1;\n\tuint32_t *originalHandler = (uint32_t *)*originalVectorTableOffset;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Retrieve the original handler for the specified IRQ\n\toldHandler = (pfnISR_Handler)*originalHandler;\n\n\t// Replace the original handler with the new handler\n\t*newVectorTableOffset = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original handler\n\treturn oldHandler;\n}", "CodeBleu_score": 43.68478661873594}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\t// Check if there is a pending character in the buffer\n\tif (rx_buffer_index!= rx_buffer_head) {\n\t\treturn rx_buffer[rx_buffer_index];\n\t} else {\n\t\treturn -1;\n\t}\n}", "CodeBleu_score": 14.613153283302726}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (CDC_Enabled) {\n\t\treturn USB_Serial_Peek();\n\t} else {\n\t\treturn -1;\n\t}\n}", "CodeBleu_score": 7.712737021228404}, {"code": "int MarlinSerialUSB::peek(){\n\t", "CodeBleu_score": 1.8457006082025527}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char!= -1) {\n\t\treturn pending_char;\n\t}\n\n\tif (CDC_Enabled && CDC_Configured) {\n\t\tif (CDC_Available()) {\n\t\t\treturn CDC_ReadChar();\n\t\t}\n\t}\n\n\treturn -1;\n}", "CodeBleu_score": 18.77173835380713}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending_char) {\n\t\tchar c = pending_char;\n\t\tpending_char = 0;\n\t\treturn c;\n\t}\n\tif (cdc_enabled && cdc_configured) {\n\t\tif (cdc_bytes_available) {\n\t\t\tint c = cdc_read();\n\t\t\tif (emergency_parser && c == 0x03) {\n\t\t\t\temergency_parser->parse();\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 48.29045392305093}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (pending) {\n\t\tchar c = pending;\n\t\tpending = 0;\n\t\treturn c;\n\t}\n\tif (cdc_enabled && cdc_configured) {\n\t\tif (cdc_available) {\n\t\t\treturn cdc_read();\n\t\t}\n\t}\n\treturn -1;\n}", "CodeBleu_score": 31.382539621801293}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t#ifdef USB_CDC_ENABLED\n    if (usb_cdc_enabled) {\n        return usb_cdc_available();\n    }\n#endif\n    return 0;\n}", "CodeBleu_score": 19.027998350218706}, {"code": "int MarlinSerialUSB::available(){\n\t\treturn 0;\n}", "CodeBleu_score": 4.3866218234586185}, {"code": "int MarlinSerialUSB::available(){\n\t\treturn _serial.available();\n}", "CodeBleu_score": 24.10644098623394}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t#ifdef DEBUG_EEPROM\n  Serial.print(F(\"read_data: pos: \"));\n  Serial.print(pos);\n  Serial.print(F(\" value: \"));\n  Serial.print((int)value);\n  Serial.print(F(\" size: \"));\n  Serial.print(size);\n  Serial.print(F(\" crc: \"));\n  Serial.print((int)crc);\n  Serial.print(F(\" writing: \"));\n  Serial.println(writing);\n#endif\n\n  // Check if we are still within the valid range\n  if (pos < 0 || pos >= EEPROMSize)\n    return false;\n\n  // Check if we are still within the valid range\n  if (pos + size > EEPROMSize)\n    size = EEPROMSize - pos;\n\n  // Read data\n  for (size_t i = 0; i < size; i++) {\n    // Read data\n    uint8_t val = ee_Read(pos + i);\n\n    // Write data if needed\n    if (writing)\n      *value = val;\n\n    // Update CRC\n    if (crc)\n      crc16(crc, &val, 1);\n\n    // Increment position\n    pos++;\n\n    // Increment value pointer\n    value++;\n  }\n\n  // Return \"false\" after completing the operation\n  return false;\n}", "CodeBleu_score": 54.59880527432015}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t#ifdef EEPROM_DEBUG\n  Serial.println(\"read_data\");\n#endif\n\n  // Check if there is enough data to be read\n  if (pos + size > EEPROMSize) {\n#ifdef EEPROM_DEBUG\n    Serial.println(\"read_data: Not enough data to be read\");\n#endif\n    return false;\n  }\n\n  // Read data from EEPROM\n  for (size_t i = 0; i < size; i++) {\n\n    // Read the value from the EEPROM\n    uint8_t val = EEPROM.read(pos + i);\n\n    // Update CRC\n    if (crc)\n      crc16(crc, &val, 1);\n\n    // Write to the provided buffer\n    if (value)\n      value[i] = val;\n  }\n\n  // Update the position\n  pos += size;\n\n  // Return success\n  return true;\n}", "CodeBleu_score": 43.93480834706752}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t#if defined(DEBUG)\n  if (pos < 0 || pos >= EEPROMSize) {\n    Serial.print(F(\"PersistentStore::read_data() - pos: \"));\n    Serial.print(pos);\n    Serial.print(F(\" is out of range [0, \"));\n    Serial.print(EEPROMSize);\n    Serial.println(F(\"]\"));\n    return false;\n  }\n  if (value == NULL && writing) {\n    Serial.println(F(\"PersistentStore::read_data() - value is NULL\"));\n    return false;\n  }\n  if (crc == NULL) {\n    Serial.println(F(\"PersistentStore::read_data() - crc is NULL\"));\n    return false;\n  }\n#endif\n\n  // Read the data\n  for (size_t i = 0; i < size; i++) {\n\n    // If we are writing, write the value to the buffer\n    if (writing) {\n      *value = ee_Read(pos, true);\n      value++;\n    }\n\n    // Update the CRC\n    crc16(crc, value, 1);\n\n    // Increment the position\n    pos++;\n  }\n\n  // Return false if we reached the end of the EEPROM\n  return pos < EEPROMSize;\n}", "CodeBleu_score": 45.240651165763005}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tifdef ESP32\n  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n#endif\n  // Not a hardware PWM pin!\n  // Search for an existing software PWM state for the pin\n  for (uint8_t i = 0; i < PWM_MAX_NUM; i++) {\n    if (pwm_pin[i] == pin) {\n      pwm_value[i] = value;\n      return;\n    }\n  }\n  // No PWM state found, allocate a new slot\n  for (uint8_t i = 0; i < PWM_MAX_NUM; i++) {\n    if (pwm_pin[i] == 0) {\n      pwm_pin[i] = pin;\n      pwm_value[i] = value;\n      pwm_freq[i] = freq;\n      pwm_res[i] = res;\n      pwm_timer[i] = timerBegin(0, 80, true);\n      timerAttachInterrupt(pwm_timer[i], &pwm_interrupt, true);\n      timerAlarmWrite(pwm_timer[i], 1000000 / freq, true);\n      timerAlarmEnable(pwm_timer[i]);\n      break;\n    }\n  }\n}", "CodeBleu_score": 56.0242486815275}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif WITH_PWM\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n#endif\n  if (pin == 0) return;\n  int8_t pid = pin_to_pwm_index(pin);\n  if (pid >= 0) {\n    pwm_t *pwm = &pwm_state[pid];\n    pwm->pin = pin;\n    pwm->freq = freq;\n    pwm->res = res;\n    pwm->value = value;\n    pwm->duty = (value << pwm->res) / PWM_MAX_VALUE;\n    return;\n  }\n  for (int i = 0; i < PWM_MAX_PINS; i++) {\n    if (pwm_state[i].pin == 0) {\n      pwm_state[i].pin = pin;\n      pwm_state[i].freq = freq;\n      pwm_state[i].res = res;\n      pwm_state[i].value = value;\n      pwm_state[i].duty = (value << res) / PWM_MAX_VALUE;\n      pwm_state[i].timer = timer_get_new();\n      pwm_state[i].timer->onAlarm(pwm_state[i].timer, pwm_state[i].timer, pwm_state[i].timer);\n      pwm_state[i].timer->setInterval(pwm_state[i].timer, 1000000 / freq);\n      pwm_state[i].timer->enable(pwm_state[i].timer);\n      pwm_state[i].timer->start(pwm_state[i].timer);\n      pwm_state[i].timer->setCount(pwm_state[i].timer, pwm_state[i].duty);\n      return;\n    }\n  }\n}", "CodeBleu_score": 55.470692395725116}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tifdef WITH_PWM_PINS\n  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n#endif\n\n  // Not a hardware PWM pin, or no channel available\n  // Search for existing software PWM state\n  int8_t pid = -1;\n  for (int i = 0; i < PWM_PIN_MAX_NUM; i++) {\n    if (pwm_pin[i].pin == pin) {\n      pid = i;\n      break;\n    }\n  }\n  if (pid >= 0) {\n    pwm_pin[pid].value = value;\n    return;\n  }\n\n  // No existing software PWM state, allocate a new one\n  pid = pwm_pin_count++;\n  pwm_pin[pid].pin = pin;\n  pwm_pin[pid].value = value;\n  pwm_pin[pid].freq = freq;\n  pwm_pin[pid].res = res;\n  pwm_pin[pid].timer = timer_create_default();\n  timer_set_interval(pwm_pin[pid].timer, 1000000 / freq);\n  timer_attachInterrupt(pwm_pin[pid].timer, &pwm_timer_isr, (void*)pid);\n  timer_enable(pwm_pin[pid].timer);\n}", "CodeBleu_score": 64.16091561787458}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#ifdef MOVE_DELAY_ARRAY_LENGTH\n  static_assert(MOVE_DELAY_ARRAY_LENGTH == NUM_SERVOS, \"MOVE_DELAY_ARRAY_LENGTH must equal NUM_SERVOS\");\n#endif\n  if (attach(pin) >= 0) {\n    write(value);\n    safe_delay(MOVE_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 51.55757344315308}, {"code": "void Servo::move(const int value){\n\t#if DEACTIVATE_SERVOS_AFTER_MOVE\n  detach();\n#endif\n  write(value);\n  safe_delay(delays[channel]);\n#if DEACTIVATE_SERVOS_AFTER_MOVE\n  detach();\n#endif\n}", "CodeBleu_score": 39.50174964221261}, {"code": "void Servo::move(const int value){\n\t#ifdef MOVE_DELAY_ARRAY_LENGTH\n  static_assert(MOVE_DELAY_ARRAY_LENGTH == NUM_SERVOS, \"MOVE_DELAY_ARRAY_LENGTH must be equal to NUM_SERVOS\");\n#endif\n  if (channel >= 0) {\n    write(value);\n    safe_delay(MOVE_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 51.500047881972186}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tuint32_t data = 0;\n\tfor (uint8_t i = 0; i < I2S_NUM_PINS; i++) {\n\t\tif (i2s_pins[i].pwm_active) {\n\t\t\tif (i2s_pins[i].pwm_tick_count == 0) {\n\t\t\t\ti2s_pins[i].pwm_tick_count = i2s_pins[i].pwm_period;\n\t\t\t\tif (i2s_pins[i].pwm_state) {\n\t\t\t\t\ti2s_pins[i].pwm_state = 0;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pins[i].pwm_state = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata |= (i2s_pins[i].pwm_state << i2s_pins[i].pin_num);\n\t\t\ti2s_pins[i].pwm_tick_count--;\n\t\t}\n\t}\n\ti2s_dma_buffer[i2s_dma_buffer_position++] = data;\n}", "CodeBleu_score": 26.367211715041062}, {"code": "void i2s_push_sample(){\n\t\t// Get the current DMA buffer position\n\tuint32_t buffer_position = (uint32_t)i2s_dma_buffer_position;\n\n\t// Loop through all pins and update the PWM states\n\tfor (uint32_t pin_index = 0; pin_index < I2S_PIN_COUNT; pin_index++) {\n\t\t// Get the current pin configuration\n\t\ti2s_pin_config_t pin_config = i2s_pin_configs[pin_index];\n\n\t\t// Check if the pin has active PWM\n\t\tif (pin_config.duty_cycle!= 0) {\n\t\t\t// Check if the PWM tick count reaches zero\n\t\t\tif (i2s_pwm_tick_count[pin_index] == 0) {\n\t\t\t\t// Toggle the pin state between high and low based on its current state\n\t\t\t\tif (i2s_pin_states[pin_index] == 0) {\n\t\t\t\t\ti2s_pin_states[pin_index] = 1;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pin_states[pin_index] = 0;\n\t\t\t\t}\n\n\t\t\t\t// Set the PWM tick count for the next transition\n\t\t\t\ti2s_pwm_tick_count[pin_index] = pin_config.duty_cycle;\n\t\t\t}\n\n\t\t\t// Decrement the PWM tick count\n\t\t\ti2s_pwm_tick_count[pin_index]--;\n\t\t}\n\t}\n\n\t// Store the updated port data into the current position of the DMA buffer\n\ti2s_dma_buffer[buffer_position] = i2s_pin_states[0] << 0 | i2s_pin_states[1] << 1 | i2s_pin_states[2] << 2 | i2s_pin_states[3] << 3;\n\n\t// Increment the buffer position\n\ti2s_dma_buffer_position = (buffer_position + 1) % I2S_DMA_BUFFER_SIZE;\n}", "CodeBleu_score": 27.142422017211164}, {"code": "void i2s_push_sample(){\n\t", "CodeBleu_score": 0.663492541703201}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer;\n\ttimer.timer_num = timer_num;\n\ttimer.timer_count = 0;\n\tif(timer_num < 2) {\n\t\ttimer.timer_count = TIMER_0_LOAD_VALUE;\n\t} else if(timer_num < 4) {\n\t\ttimer.timer_count = TIMER_1_LOAD_VALUE;\n\t} else if(timer_num < 6) {\n\t\ttimer.timer_count = TIMER_2_LOAD_VALUE;\n\t} else if(timer_num < 8) {\n\t\ttimer.timer_count = TIMER_3_LOAD_VALUE;\n\t}\n\treturn timer;\n}", "CodeBleu_score": 31.363968530213977}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer_count = 0;\n\tuint32_t timer_base_addr = 0;\n\tuint32_t timer_count_addr = 0;\n\tuint32_t timer_config_addr = 0;\n\tuint32_t timer_config_value = 0;\n\n\tif (timer_num >= HAL_TIMER_NUM) {\n\t\treturn HAL_TIMER_INVALID_TIMER;\n\t}\n\n\ttimer_base_addr = HAL_TIMER_BASE_ADDR + (timer_num * HAL_TIMER_OFFSET);\n\ttimer_count_addr = timer_base_addr + HAL_TIMER_COUNT_OFFSET;\n\ttimer_config_addr = timer_base_addr + HAL_TIMER_CONFIG_OFFSET;\n\n\ttimer_config_value = HAL_timer_read_32(timer_config_addr);\n\tif (timer_config_value & HAL_TIMER_ENABLE_MASK) {\n\t\ttimer_count = HAL_timer_read_32(timer_count_addr);\n\t}\n\n\treturn timer_count;\n}", "CodeBleu_score": 37.020291437601436}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn (hal_timer_t) (timer_num < TIMER_NUM? TIMER_REG[timer_num].TCNT : 0);\n}", "CodeBleu_score": 18.5633394114082}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint8_t data = 0;\n\tfor (int i = 0; i < size; i++) {\n\t\tdata = EEPROM.read(pos++);\n\t\tcrc16(crc, &data, 1);\n\t\tif (writing) {\n\t\t\t*value++ = data;\n\t\t}\n\t}\n\treturn (pos < EEPROM.length());\n}", "CodeBleu_score": 55.50790794870485}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint8_t *ptr = (uint8_t *)value;\n\tfor (size_t i = 0; i < size; i++) {\n\t\t*ptr = EEPROM.read(pos++);\n\t\tif (writing) {\n\t\t\tcrc16(crc, ptr, 1);\n\t\t}\n\t\tptr++;\n\t}\n\treturn (pos >= EEPROM.length());\n}", "CodeBleu_score": 55.7551361896504}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tif (pos + size > EEPROM_SIZE) {\n\t\tpos = EEPROM_SIZE;\n\t\treturn false;\n\t}\n\n\tif (writing) {\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tvalue[i] = EEPROM.read(pos + i);\n\t\t\tcrc16(crc, &value[i], 1);\n\t\t}\n\t} else {\n\t\tcrc16(crc, &value[0], size);\n\t}\n\n\tpos += size;\n\treturn true;\n}", "CodeBleu_score": 59.52427587477327}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tuint32_t i;\n\n\t// Check that the SDIO handle and source pointer are not null\n\tif (sdio_handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\t// Try to write the block\n\tfor (i = 0; i < SDIO_MAX_RETRIES; i++) {\n\t\tif (SDIO_Write(block, src) == true) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Print an error message and return false\n\tprintf(\"SDIO_WriteBlock: write failed\n\");\n\treturn false;\n}", "CodeBleu_score": 26.007118307368916}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (sdio_handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tuint8_t retries = 0;\n\tbool success = false;\n\twhile (retries < SDIO_MAX_RETRIES &&!success) {\n\t\tsuccess = SDIO_WriteBlock_Internal(block, src);\n\t\tretries++;\n\t}\n\tif (!success) {\n\t\tprintf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n\t}\n\treturn success;\n}", "CodeBleu_score": 31.539480384050893}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tuint32_t retries = SDIO_MAX_RETRIES;\n\tuint32_t status;\n\n\tif (block > 0xFFFF) {\n\t\treturn false;\n\t}\n\n\tif (SDIO_Handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\twhile (retries--) {\n\t\tif (HAL_SD_WriteBlocks(SDIO_Handle, (uint8_t *) src, block, 1, 100) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\n\t\tstatus = HAL_SD_GetCardState(SDIO_Handle);\n\n\t\tif (status == HAL_SD_CARD_ERROR) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 38.472454824125194}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMPERATURE_TIMER) {\n\t\ttimer_start(TIMER_0, frequency, TEMPERATURE_TIMER_PRESCALE);\n\t\tNVIC_SetPriority(TIMER0A_IRQn, TEMPERATURE_TIMER_PRIORITY);\n\t} else if (timer_num == STEPPER_TIMER) {\n\t\ttimer_start(TIMER_1, frequency, STEPPER_TIMER_PRESCALE);\n\t\tNVIC_SetPriority(TIMER1A_IRQn, STEPPER_TIMER_PRIORITY);\n\t} else {\n\t\tASSERT(false);\n\t}\n}", "CodeBleu_score": 36.535914131070264}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\ttemperature_timer_start(frequency);\n\t} else if (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\tstepper_timer_start(frequency);\n\t} else {\n\t\tassert_param(false);\n\t}\n}", "CodeBleu_score": 25.849625765778526}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tswitch (timer_num) {\n\tcase TIMER_CHANNEL_0:\n\t\tTIMER_0_CTRL = TIMER_CTRL_PRESCALE(TIMER_0_PRESCALE) | TIMER_CTRL_ENABLE;\n\t\tTIMER_0_LOAD = frequency;\n\t\tTIMER_0_VALUE = 0;\n\t\tNVIC_SetPriority(TIMER0_IRQn, 0);\n\t\tNVIC_EnableIRQ(TIMER0_IRQn);\n\t\tbreak;\n\tcase TIMER_CHANNEL_1:\n\t\tTIMER_1_CTRL = TIMER_CTRL_PRESCALE(TIMER_1_PRESCALE) | TIMER_CTRL_ENABLE;\n\t\tTIMER_1_LOAD = frequency;\n\t\tTIMER_1_VALUE = 0;\n\t\tNVIC_SetPriority(TIMER1_IRQn, 0);\n\t\tNVIC_EnableIRQ(TIMER1_IRQn);\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 26.120000001295224}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tif (file_size > 0) {\n\t\tif (file_size < EEPROM_SIZE) {\n\t\t\tfor (int i = file_size; i < EEPROM_SIZE; i++) {\n\t\t\t\tbuffer[i] = EEPROM_ERASE_VALUE;\n\t\t\t}\n\t\t}\n\t\tif (file.open(EEPROM_FILENAME, O_RDWR)) {\n\t\t\tfile.read(buffer, EEPROM_SIZE);\n\t\t\tfile.close();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 25.219761134567253}, {"code": "bool PersistentStore::access_start(){\n\t\tif (file.open(filename, O_RDWR | O_CREAT)) {\n\t\tif (file.seek(0, SEEK_END) < EEPROM_SIZE) {\n\t\t\t// file is smaller than expected EEPROM size\n\t\t\tfile.seek(0, SEEK_SET);\n\t\t\tfor (int i = 0; i < EEPROM_SIZE; i++) {\n\t\t\t\tfile.write(EEPROM_ERASE_VALUE);\n\t\t\t}\n\t\t}\n\t\tfile.seek(0, SEEK_SET);\n\t\tfile.read(buffer, EEPROM_SIZE);\n\t\tfile.close();\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 26.30182976376273}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open the EEPROM file\n\teeprom_file.open(eeprom_filename, std::ios::in | std::ios::out | std::ios::binary);\n\n\t// Check if the file was opened successfully\n\tif (eeprom_file.is_open()) {\n\t\t// Get the file size\n\t\teeprom_file.seekg(0, std::ios::end);\n\t\tfile_size = eeprom_file.tellg();\n\n\t\t// Check the file size\n\t\tif (file_size < EEPROM_SIZE) {\n\t\t\t// The file is smaller than the expected EEPROM size\n\t\t\t// Fill the remainder of the buffer with a default erase value\n\t\t\tfor (int i = file_size; i < EEPROM_SIZE; i++) {\n\t\t\t\tbuffer[i] = EEPROM_ERASE_VALUE;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// The file is of sufficient size\n\t\t\t// Read the file's contents into the buffer\n\t\t\teeprom_file.seekg(0, std::ios::beg);\n\t\t\teeprom_file.read((char*)buffer, EEPROM_SIZE);\n\t\t}\n\n\t\t// Close the file\n\t\teeprom_file.close();\n\n\t\t// Return true\n\t\treturn true;\n\t}\n\telse {\n\t\t// The file could not be opened\n\t\t// Return false\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 34.39668607903528}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t r = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin,\n\t\t\t\t(b & 0x80)? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_SET);\n\t\tr <<= 1;\n\t\tr |= HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin);\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(1);\n\treturn r;\n}", "CodeBleu_score": 39.20036262353606}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t rx = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SetClockPin(0);\n\t\tHAL_SPI_STM32_SetMosiPin(b & 0x80);\n\t\tHAL_SPI_STM32_SetClockPin(1);\n\t\trx <<= 1;\n\t\trx |= HAL_SPI_STM32_GetMosiPin();\n\t\tb <<= 1;\n\t}\n\treturn rx;\n}", "CodeBleu_score": 35.15558473259938}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t data = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_STM32_SCK_GPIO_Port, SPI_STM32_SCK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_STM32_MOSI_GPIO_Port, SPI_STM32_MOSI_Pin, (b & 0x80)? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI_STM32_SCK_GPIO_Port, SPI_STM32_SCK_Pin, GPIO_PIN_SET);\n\t\tdata <<= 1;\n\t\tdata |= HAL_GPIO_ReadPin(SPI_STM32_MISO_GPIO_Port, SPI_STM32_MISO_Pin);\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(1);\n\treturn data;\n}", "CodeBleu_score": 38.53488994871125}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tRCC_ClocksTypeDef RCC_ClocksStatus;\n\tRCC_GetClocksFreq(&RCC_ClocksStatus);\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 51.01550560109687}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t", "CodeBleu_score": 3.6806732796976527}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c;\n\tif (obj->rx_buf_head!= obj->rx_buf_tail) {\n\t\tc = obj->rx_buf[obj->rx_buf_head];\n\t\tobj->rx_buf_head = (obj->rx_buf_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t\tif (obj->rx_buf_head == obj->rx_buf_tail) {\n\t\t\tobj->rx_buf_head = 0;\n\t\t}\n\t\tif (obj->rx_buf_head == obj->rx_buf_tail) {\n\t\t\tobj->rx_buf_full = true;\n\t\t}\n\t\tif (obj->rx_parser) {\n\t\t\tobj->rx_parser->receive_byte(c);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.35700346840819}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t#ifdef SERIAL_RX_BUFFER_SIZE\n  uint8_t *buffer = obj->rx_buffer;\n  uint8_t *head = obj->rx_buffer_head;\n  uint8_t *tail = obj->rx_buffer_tail;\n  uint8_t *end = obj->rx_buffer_end;\n  uint8_t next_tail = (uint8_t)((tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1));\n  uint8_t next_head = (uint8_t)((head + 1) & (SERIAL_RX_BUFFER_SIZE - 1));\n  uint8_t data = (uint8_t)obj->uart->UART_RHR;\n  if (next_head!= next_tail) {\n    *head = data;\n    head = &buffer[next_head];\n    obj->rx_buffer_head = head;\n  }\n#endif\n}", "CodeBleu_score": 37.31860122281672}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t#if SERIAL_RX_BUFFER_SIZE > 0\n\tuint8_t rx_byte;\n\tuint16_t rx_next_head;\n\tbool parity_error;\n\n\t// Read the received byte\n\trx_byte = obj->serial_read(obj);\n\n\t// Check for parity error\n\tparity_error = (obj->serial_get_status(obj) & SERIAL_STATUS_PARITY_ERROR)!= 0;\n\n\t// Check for buffer overflow\n\tif (!parity_error) {\n\t\t// Read the current head pointer\n\t\trx_next_head = obj->rx_head + 1;\n\n\t\t// Check for buffer overflow\n\t\tif (rx_next_head >= SERIAL_RX_BUFFER_SIZE) {\n\t\t\t// Wrap the head pointer\n\t\t\trx_next_head = 0;\n\t\t}\n\n\t\t// Check for space in the buffer\n\t\tif (rx_next_head!= obj->rx_tail) {\n\t\t\t// Store the byte in the buffer\n\t\t\tobj->rx_buffer[obj->rx_head] = rx_byte;\n\n\t\t\t// Update the head pointer\n\t\t\tobj->rx_head = rx_next_head;\n\t\t}\n\t}\n\n\t// Update the emergency parser\n\tif (obj->emergency_parser!= NULL) {\n\t\tobj->emergency_parser->update(obj->emergency_parser, rx_byte, parity_error);\n\t}\n#endif\n}", "CodeBleu_score": 41.066636408868206}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tswitch(timer_num) {\n\t\tcase MF_TIMER_STEP:\n\t\t\tif(HAL_timer_is_initialized(MF_TIMER_STEP) && HAL_timer_get_interrupt_handler(MF_TIMER_STEP) == NULL) {\n\t\t\t\tHAL_timer_attach_interrupt_handler(MF_TIMER_STEP, Step_Handler);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MF_TIMER_TEMP:\n\t\t\tif(HAL_timer_is_initialized(MF_TIMER_TEMP) && HAL_timer_get_interrupt_handler(MF_TIMER_TEMP) == NULL) {\n\t\t\t\tHAL_timer_attach_interrupt_handler(MF_TIMER_TEMP, Temp_Handler);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 33.859889851652845}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tswitch (timer_num) {\n\tcase MF_TIMER_STEP:\n\t\tNVIC_EnableIRQ(TIMER0_IRQn);\n\t\tbreak;\n\tcase MF_TIMER_TEMP:\n\t\tNVIC_EnableIRQ(TIMER1_IRQn);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 31.852160927422112}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tswitch (timer_num) {\n\tcase MF_TIMER_STEP:\n\t\tif (timer_step_initialized &&!timer_step_interrupt_attached) {\n\t\t\ttimer_step_interrupt_attached = true;\n\t\t\tNVIC_EnableIRQ(TIMER_STEP_IRQn);\n\t\t}\n\t\tbreak;\n\tcase MF_TIMER_TEMP:\n\t\tif (timer_temp_initialized &&!timer_temp_interrupt_attached) {\n\t\t\ttimer_temp_interrupt_attached = true;\n\t\t\tNVIC_EnableIRQ(TIMER_TEMP_IRQn);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 38.703469745879524}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(s) == 0 || len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\treturn strings.LastIndexByte(s, sep[0])\n\t}\n\thash, pow := HashStrRev(sep)\n\tvar h uint32 = 0\n\tfor i := 0; i < len(sep); i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif h == hash && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+len(sep)])\n\t}\n\treturn -1\n}", "CodeBleu_score": 51.19122439263526}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\tif len(sep) == len(s) {\n\t\treturn 0\n\t}\n\tif len(sep) == 1 {\n\t\tfor i := len(s) - 1; i >= 0; i-- {\n\t\t\tif sep[0] == s[i] {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\tvar h, pow uint32\n\th, pow = HashStrRev(sep)\n\tvar hs, pows uint32\n\ths, pows = HashStrRev(s[len(s)-len(sep):])\n\tif h == hs {\n\t\tif sep == s[len(s)-len(sep):] {\n\t\t\treturn len(s) - len(sep)\n\t\t}\n\t}\n\tfor i := len(s) - len(sep); i > 0; i-- {\n\t\ths = hs*PrimeRK + uint32(s[i-1]) - pow*uint32(s[i+len(sep)-1])\n\t\tif h == hs {\n\t\t\tif sep == s[i:i+len(sep)] {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 43.94570503327779}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn -1\n\t}\n\thash, pow := HashStrRev(sep)\n\tvar h uint32\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif i < len(s) - len(sep) {\n\t\t\th = h*PrimeRK + uint32(s[i+len(sep)]) - pow*uint32(s[i])\n\t\t} else {\n\t\t\th = h*PrimeRK + uint32(s[i])\n\t\t}\n\t\tif h == hash && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 49.302507936115276}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tr := usbcdc.usb.DisableInterrupts()\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txc.Length() > 0 {\n\t\t// If there is, send it to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// If not, set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\t// Restore the interrupt mask\n\tusbcdc.usb.RestoreInterrupts(r)\n}", "CodeBleu_score": 43.701210883570305}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tif usbcdc.waitTxc {\n\t\tusbcdc.waitTxc = false\n\t\tusbcdc.SendUSBInPacket()\n\t}\n}", "CodeBleu_score": 23.718675701209136}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.waitTxc = false\n\tif usbcdc.txc > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\tusbcdc.irq.Disable()\n\tif usbcdc.txc > 0 {\n\t\tusbcdc.waitTxc = true\n\t}\n\tusbcdc.irq.Enable()\n}", "CodeBleu_score": 30.714592156673774}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.Set(0)\n\ti2c.control.Set(i2c.control.Get() | (1 << 0))\n\ti2c.control.Set(i2c.control.Get() | (1 << 1))\n\tfor!i2c.control.Get()&(1<<0) == 0 {\n\t}\n\ti2c.data.Set((address << 1) | (uint8(write) << 0))\n}", "CodeBleu_score": 30.29986762644743}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.Set(i2c.control.Get() & ^(1 << 0))\n\ti2c.control.Set(i2c.control.Get() | (1 << 1))\n\ti2c.control.Set(i2c.control.Get() | (1 << 0))\n\tfor i2c.control.Get()&(1<<0)!= 0 {\n\t}\n\ti2c.bus.Set(address << 1)\n\tif write {\n\t\ti2c.bus.Set(i2c.bus.Get() & ^(1 << 0))\n\t}\n}", "CodeBleu_score": 28.83069256035839}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.Clear(i2c.I2C_CR1_START)\n\ti2c.control.Set(i2c.I2C_CR1_START)\n\n\tfor!i2c.control.HasBits(i2c.I2C_SR1_SB) {\n\t}\n\n\ti2c.address.Set(address << 1)\n\tif write {\n\t\ti2c.address.Clear(i2c.I2C_DR_RD)\n\t} else {\n\t\ti2c.address.Set(i2c.I2C_DR_RD)\n\t}\n\n\tfor!i2c.control.HasBits(i2c.I2C_SR1_ADDR) {\n\t}\n}", "CodeBleu_score": 34.38443216822793}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address of the first block to be erased.\n\tstartAddress := start * f.BlockSize\n\n\t// Wait for any ongoing flash operations to complete.\n\tif err := f.Wait(); err!= nil {\n\t\treturn err\n\t}\n\n\t// Configure the flash for erasing.\n\tif err := f.Flash.Erase(startAddress, len); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait until the flash is no longer busy.\n\tif err := f.Wait(); err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the flash back to read mode.\n\tif err := f.Flash.ReadMode(); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 28.04140245210919}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"Invalid start or length\")\n\t}\n\tif start+len > f.Size() {\n\t\treturn errors.New(\"Invalid start or length\")\n\t}\n\tfor i := start; i < start+len; i++ {\n\t\tf.WaitBusy()\n\t\tif err := f.Flash.Erase(i * f.BlockSize); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tf.WaitBusy()\n\t}\n\tf.Flash.ReadMode()\n\treturn nil\n}", "CodeBleu_score": 45.885652111146456}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address based on the block number and block size.\n\tstartAddr := start * f.blockSize\n\n\t// Wait for any ongoing flash operations to complete.\n\tfor f.isBusy {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t}\n\n\t// Configure the flash for erasing.\n\tf.writeEnable()\n\tf.setFlashMode(0x02)\n\n\t// Erase each block in the range.\n\tfor i := int64(0); i < len; i++ {\n\t\t// Calculate the address of the block to erase.\n\t\tblockAddr := startAddr + i*f.blockSize\n\n\t\t// Send the erase command to the flash.\n\t\tf.spi.Tx(nil, []byte{0x20, byte(blockAddr >> 16), byte(blockAddr >> 8), byte(blockAddr)})\n\n\t\t// Wait until the flash is no longer busy.\n\t\tfor f.isBusy {\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t}\n\t}\n\n\t// Set the flash back to read mode.\n\tf.setFlashMode(0x00)\n\n\treturn nil\n}", "CodeBleu_score": 36.75073653992496}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds\n\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"write operation exceeds flash memory bounds\")\n\t}\n\n\t// Calculate the start address for writing\n\tstartAddr := off\n\tif startAddr%f.blockSize!= 0 {\n\t\tstartAddr = startAddr - startAddr%f.blockSize\n\t}\n\n\t// Pad the byte slice to fit the write block size\n\tpaddedLen := len(p)\n\tif len(p)%f.blockSize!= 0 {\n\t\tpaddedLen = paddedLen + f.blockSize - len(p)%f.blockSize\n\t}\n\tpadded := make([]byte, paddedLen)\n\tcopy(padded, p)\n\n\t// Enable write mode on the flash memory controller\n\tf.flash.WriteEnable()\n\n\t// Write the data in blocks\n\tfor i := 0; i < len(padded); i += f.blockSize {\n\t\t// Calculate the end address for writing\n\t\tendAddr := startAddr + int64(f.blockSize)\n\t\tif endAddr > f.Size() {\n\t\t\tendAddr = f.Size()\n\t\t}\n\n\t\t// Write the data\n\t\terr = f.flash.Write(startAddr, padded[i:endAddr])\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// Wait for the flash memory to be ready\n\t\terr = f.flash.WaitReady()\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// Update the start address for writing\n\t\tstartAddr = endAddr\n\t}\n\n\t// Return the number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 34.15899329529949}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds\n\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"WriteAt: write operation exceeds flash memory bounds\")\n\t}\n\n\t// Calculate the start address for writing\n\tstartAddr := off + f.baseAddr\n\n\t// Pad the byte slice to fit the write block size\n\tpaddedP := make([]byte, len(p))\n\tcopy(paddedP, p)\n\n\t// Enable write mode on the flash memory controller\n\tf.flashController.SetWriteMode()\n\n\t// Write the data in blocks\n\tfor i := 0; i < len(paddedP); i += f.writeBlockSize {\n\t\t// Calculate the block address\n\t\tblockAddr := startAddr + int64(i)\n\n\t\t// Calculate the block offset\n\t\tblockOffset := blockAddr % int64(f.writeBlockSize)\n\n\t\t// Calculate the block length\n\t\tblockLength := f.writeBlockSize - int(blockOffset)\n\n\t\t// Calculate the number of bytes to write\n\t\tnumBytesToWrite := len(paddedP[i:])\n\t\tif numBytesToWrite < blockLength {\n\t\t\tblockLength = numBytesToWrite\n\t\t}\n\n\t\t// Write the data to the flash memory\n\t\tf.flashController.Write(blockAddr, paddedP[i:i+blockLength])\n\n\t\t// Wait for the flash memory to be ready\n\t\tf.flashController.WaitReady()\n\t}\n\n\t// Return the number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 30.2896308194038}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, errors.New(\"invalid offset\")\n\t}\n\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"write out of bounds\")\n\t}\n\n\t// Calculate the start address for writing\n\tstartAddress := f.startAddress + uint32(off)\n\n\t// Pad the byte slice to fit the write block size\n\tpaddedSlice := make([]byte, f.writeBlockSize)\n\tcopy(paddedSlice, p)\n\n\t// Enable write mode on the flash memory controller\n\tf.flashMemoryController.SetWriteEnable()\n\n\t// Write the data in blocks\n\tfor i := 0; i < len(paddedSlice); i += f.writeBlockSize {\n\t\t// Calculate the end address for writing\n\t\tendAddress := startAddress + uint32(i+f.writeBlockSize)\n\n\t\t// Check if the end address exceeds the flash memory bounds\n\t\tif endAddress > f.endAddress {\n\t\t\treturn 0, errors.New(\"write out of bounds\")\n\t\t}\n\n\t\t// Write the data to the flash memory\n\t\tf.flashMemoryController.Write(startAddress+uint32(i), paddedSlice[i:i+f.writeBlockSize])\n\n\t\t// Wait for the flash memory to be ready\n\t\tfor!f.flashMemoryController.IsReady() {\n\t\t}\n\t}\n\n\t// Return the number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 30.399553552440118}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to duplicate file descriptor: %v\", err)\n\t}\n\tdefer syscall.Close(dupFd)\n\n\t// Attempt to open the directory.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err!= nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %v\", err)\n\t}\n\n\t// Return the directory pointer.\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 44.64040964346331}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the file descriptor.\n\tfdDup, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, err.Error(), err\n\t}\n\n\t// Attempt to open the directory using syscall.Fdopendir.\n\tdir, err := syscall.Fdopendir(fdDup)\n\tif err!= nil {\n\t\t// If an error other than syscall.EINTR was encountered, close the duplicated file descriptor and return the error.\n\t\tif err!= syscall.EINTR {\n\t\t\tsyscall.Close(fdDup)\n\t\t\treturn 0, err.Error(), err\n\t\t}\n\n\t\t// If syscall.EINTR was encountered, close the duplicated file descriptor and attempt to open the directory again.\n\t\tsyscall.Close(fdDup)\n\t\tdir, err = syscall.Fdopendir(fdDup)\n\t\tif err!= nil {\n\t\t\treturn 0, err.Error(), err\n\t\t}\n\t}\n\n\t// Return the directory pointer.\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 48.72079178703009}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar dir *C.DIR\n\tvar err error\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fd)\n\t\tif err!= nil {\n\t\t\tif err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfd.Close()\n\t\t\treturn 0, \"\", err\n\t\t}\n\t\tbreak\n\t}\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 43.247356946529024}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tuint32_t freeSpace = 0;\n\tesp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n\tesp_partition_t *partition = NULL;\n\twhile ((partition = esp_partition_next(it))!= NULL) {\n\t\tif (partition->type == ESP_PARTITION_TYPE_APP) {\n\t\t\tesp_app_desc_t app_desc;\n\t\t\tesp_ota_get_app_description(&app_desc);\n\t\t\tif (app_desc.version == partition->size) {\n\t\t\t\tif (response) {\n\t\t\t\t\tfreeSpace = partition->size - partition->address;\n\t\t\t\t} else {\n\t\t\t\t\tfreeSpace = partition->size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn freeSpace;\n}", "CodeBleu_score": 33.91717456246302}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tuint32_t size = 0;\n\tesp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n\twhile (it!= NULL) {\n\t\tconst esp_partition_t *partition = esp_partition_get(it);\n\t\tit = esp_partition_next(it);\n\t\tif (partition->type == ESP_PARTITION_TYPE_APP && partition->subtype == ESP_PARTITION_SUBTYPE_APP_FACTORY) {\n\t\t\tesp_image_metadata_t image_meta;\n\t\t\tesp_image_metadata_load(partition, &image_meta);\n\t\t\tif (image_meta.magic == ESP_IMAGE_MAGIC) {\n\t\t\t\tsize = response? image_meta.free_size : image_meta.size;\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}", "CodeBleu_score": 37.402178163897695}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tuint32_t size = 0;\n\tesp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n\tif (it!= NULL) {\n\t\tconst esp_partition_t *part = esp_partition_get(it);\n\t\tesp_image_metadata_t metadata;\n\t\tif (esp_image_metadata_load(part, &metadata) == ESP_OK) {\n\t\t\tif (response == true) {\n\t\t\t\tsize = metadata.size - metadata.offset;\n\t\t\t} else {\n\t\t\t\tsize = metadata.size;\n\t\t\t}\n\t\t}\n\t\tesp_partition_iterator_release(it);\n\t}\n\treturn size;\n}", "CodeBleu_score": 42.3024357207256}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tif (!msc_update_get_required_disk_sectors()) {\n\t\treturn false;\n\t}\n\tmsc_disk = calloc(1, DISK_SECTOR_SIZE * msc_total_sectors);\n\tif (!msc_disk) {\n\t\tlog_e(\"Failed to allocate memory for RAM disk\");\n\t\treturn false;\n\t}\n\tlog_d(\"RAM disk allocated\");\n\tif (!msc_update_setup_boot_sector()) {\n\t\treturn false;\n\t}\n\tlog_d(\"Boot sector setup\");\n\tif (!msc_update_setup_fat()) {\n\t\treturn false;\n\t}\n\tlog_d(\"FAT setup\");\n\tif (msc_run_partition) {\n\t\tif (!msc_update_add_root_entry(volume_label, serial_number)) {\n\t\t\treturn false;\n\t\t}\n\t\tlog_d(\"Root entry added\");\n\t}\n\treturn true;\n}", "CodeBleu_score": 27.656407908917384}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t ret;\n\tuint32_t sector_size = partition->erase_size;\n\tuint32_t sector_offset = offset & ~(sector_size - 1);\n\tif (sector_offset!= offset) {\n\t\tESP_LOGW(TAG, \"offset is not aligned with the flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (sector_offset) {\n\t\tESP_LOGI(TAG, \"erase sector %d\", sector_offset / sector_size);\n\t\tret = esp_partition_erase_range(partition, sector_offset, sector_size);\n\t\tif (ret!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"failed to erase sector %d\", sector_offset / sector_size);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tESP_LOGI(TAG, \"write data to offset %d\", offset);\n\tret = esp_partition_write(partition, offset, data, size);\n\tif (ret!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"failed to write data to offset %d\", offset);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 48.71960990301372}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t ret = ESP_OK;\n\tuint32_t sector_size = partition->erase_size;\n\tuint32_t sector_offset = offset & ~(sector_size - 1);\n\tuint32_t sector_offset_end = (offset + size) & ~(sector_size - 1);\n\tuint32_t sector_count = (sector_offset_end - sector_offset) / sector_size;\n\tuint32_t sector_index;\n\tuint32_t sector_offset_in_sector;\n\tuint32_t sector_size_in_sector;\n\n\tif (sector_count == 0) {\n\t\treturn esp_partition_write(partition, offset, data, size);\n\t}\n\n\tif (sector_offset!= offset) {\n\t\t// The offset is not aligned with the sector size, we need to erase the sector before writing\n\t\tret = esp_partition_erase_range(partition, sector_offset, sector_size);\n\t\tif (ret!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"failed to erase sector at offset 0x%08x\", sector_offset);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (sector_index = 0; sector_index < sector_count; sector_index++) {\n\t\tsector_offset_in_sector = sector_offset + sector_index * sector_size;\n\t\tsector_size_in_sector = MIN(sector_size, sector_offset_end - sector_offset_in_sector);\n\n\t\tret = esp_partition_write(partition, sector_offset_in_sector, (uint8_t *) data + sector_index * sector_size, sector_size_in_sector);\n\t\tif (ret!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"failed to write sector at offset 0x%08x\", sector_offset_in_sector);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 51.44356943710072}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tuint32_t sector_size = partition->sector_size;\n\tuint32_t sector_offset = offset & ~(sector_size - 1);\n\tuint32_t sector_count = (offset + size + sector_size - 1) / sector_size - sector_offset / sector_size;\n\tuint32_t sector_size_aligned = sector_size;\n\tif (sector_size_aligned & (sector_size_aligned - 1)) {\n\t\tsector_size_aligned = 1;\n\t\twhile (sector_size_aligned < sector_size) {\n\t\t\tsector_size_aligned <<= 1;\n\t\t}\n\t}\n\tif (sector_size_aligned!= sector_size) {\n\t\tESP_LOGE(TAG, \"sector_size_aligned is not a power of 2\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (sector_offset & (sector_size_aligned - 1)) {\n\t\tESP_LOGE(TAG, \"sector_offset is not aligned with sector_size_aligned\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (sector_count > 0) {\n\t\tuint32_t sector_start = sector_offset / sector_size;\n\t\tuint32_t sector_end = (offset + size) / sector_size;\n\t\tfor (uint32_t i = sector_start; i < sector_end; i++) {\n\t\t\terr = esp_partition_erase_range(partition, sector_size_aligned * i, sector_size_aligned);\n\t\t\tif (err!= ESP_OK) {\n\t\t\t\tESP_LOGE(TAG, \"failed to erase sector %d\", i);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"failed to write data to partition\");\n\t}\n\treturn err;\n}", "CodeBleu_score": 48.60674159610737}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i = 0;\n\tsize_t j = 0;\n\tuint8_t byte;\n\twhile (in[i]!= '\\0' && j < maxlen) {\n\t\tbyte = hex_char_to_byte(in[i]);\n\t\tif (byte < 0x10) {\n\t\t\tout[j++] = byte << 4;\n\t\t\tbyte = hex_char_to_byte(in[++i]);\n\t\t\tif (byte < 0x10) {\n\t\t\t\tout[j - 1] |= byte;\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\t++i;\n\t}\n\treturn j;\n}", "CodeBleu_score": 41.95175497714797}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i = 0;\n\tsize_t j = 0;\n\tuint8_t byte;\n\tuint8_t nibble;\n\twhile (in[i]!= 0) {\n\t\tbyte = hex_char_to_byte(in[i]);\n\t\tnibble = hex_char_to_byte(in[i + 1]);\n\t\tif (byte < 0x10 && nibble < 0x10) {\n\t\t\tif (j < maxlen) {\n\t\t\t\tout[j] = (byte << 4) | nibble;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti += 2;\n\t}\n\treturn j;\n}", "CodeBleu_score": 38.63410279013028}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t i = 0;\n\tsize_t j = 0;\n\tuint8_t c;\n\tuint8_t b;\n\n\twhile (in[i] && j < maxlen) {\n\t\tc = hex_char_to_byte(in[i++]);\n\t\tif (c < 0x10) {\n\t\t\tb = c << 4;\n\t\t\tc = hex_char_to_byte(in[i++]);\n\t\t\tif (c < 0x10) {\n\t\t\t\tout[j++] = b | c;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn j;\n}", "CodeBleu_score": 37.28332163089861}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif(this->initialized && this->lock) {\n\t\tif(xSemaphoreTake(this->lock, this->timeout) == pdTRUE) {\n\t\t\tint freeSize = this->ringBuffer.availableToWrite();\n\t\t\txSemaphoreGive(this->lock);\n\t\t\treturn freeSize;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 23.02520219924084}, {"code": "int HWCDC::availableForWrite(void){\n\t\tint result = 0;\n\n\tif (transmitBuffer!= NULL && transmitLock!= NULL) {\n\t\tif (xSemaphoreTake(transmitLock, portMAX_DELAY) == pdTRUE) {\n\t\t\tresult = transmitBuffer->availableForWrite();\n\t\t\txSemaphoreGive(transmitLock);\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 47.818940863524965}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_ring_buffer!= NULL && tx_ring_buffer->lock!= NULL) {\n\t\tif (xSemaphoreTake(tx_ring_buffer->lock, 1000) == pdTRUE) {\n\t\t\tint available = tx_ring_buffer->free_size;\n\t\t\txSemaphoreGive(tx_ring_buffer->lock);\n\t\t\treturn available;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 36.99433034838615}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#if!defined(ARDUINO_ARCH_ESP32)\n  // Locking the serial mutex\n  xSemaphoreTake(_mutex, portMAX_DELAY);\n\n  // Assigning the provided callback function to \"_onReceiveCB\"\n  _onReceiveCB = function;\n\n  // Configuring the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_rxTimeout > 0) {\n    _rxTimeout = _rxTimeout * 1000;\n  } else {\n    _rxTimeout = -1;\n  }\n\n  // If the callback is not NULL, it sets the FIFO full threshold and creates an event task if it does not already exist\n  if (_onReceiveCB) {\n    if (_rxTimeout > 0) {\n      _rxTimeout = _rxTimeout * 1000;\n    } else {\n      _rxTimeout = -1;\n    }\n    _fifo.setThreshold(UART_FIFO_FULL_THRESHOLD);\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n  }\n\n  // Unlocking the serial mutex\n  xSemaphoreGive(_mutex);\n#endif\n}", "CodeBleu_score": 47.33965393564585}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#if defined(ARDUINO_ARCH_ESP32)\n  if (onlyOnTimeout) {\n    _rxTimeout = 1000;\n  } else {\n    _rxTimeout = 0;\n  }\n#endif\n  _onReceiveCB = function;\n  if (function) {\n    _rxTimeout = 0;\n    _rxTimeoutCB = NULL;\n    _rxTimeoutOn = false;\n    _fifo.setThreshold(FIFO_FULL_THRESHOLD);\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n  } else {\n    _fifo.setThreshold(FIFO_EMPTY_THRESHOLD);\n  }\n}", "CodeBleu_score": 43.50671063789125}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#if defined(ARDUINO_ARCH_ESP32) || defined(ARDUINO_ARCH_ESP32S2) || defined(ARDUINO_ARCH_ESP32S3)\n  if (function!= NULL) {\n    _onReceiveCB = function;\n    _onlyOnTimeout = onlyOnTimeout;\n    _rxTimeout = 0;\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n  } else {\n    _onReceiveCB = NULL;\n    _onlyOnTimeout = false;\n    _rxTimeout = 0;\n    if (_eventTask!= NULL) {\n      vTaskDelete(_eventTask);\n      _eventTask = NULL;\n    }\n  }\n#else\n  (void)function;\n  (void)onlyOnTimeout;\n#endif\n}", "CodeBleu_score": 46.46021532963541}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\tsize_t index = 0;\n\twhile (index < length - 1) {\n\t\tint c = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index] = c;\n\t\tindex++;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 71.40679627467168}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) {\n\t\treturn 0;\n\t}\n\tsize_t index = 0;\n\twhile (index < length - 1) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = c;\n\t\tindex++;\n\t}\n\t*buffer = 0;\n\treturn index;\n}", "CodeBleu_score": 77.6576894673573}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t#ifdef __AVR__\n  return readBytesUntil(terminator, buffer, length);\n#else\n  if (length < 1) {\n    return 0;\n  }\n\n  size_t index = 0;\n  while (index < length - 1) {\n    int b = timedRead();\n    if (b < 0) {\n      break;\n    }\n    buffer[index] = b;\n    if (b == terminator) {\n      break;\n    }\n    index++;\n  }\n  buffer[index] = 0;\n  return index;\n#endif\n}", "CodeBleu_score": 70.23233271100942}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (pin == 0) {\n\t\tlog_e(\"Invalid pin number\");\n\t\treturn;\n\t}\n\n\tif (pin_is_available(pin)) {\n\t\tlog_v(\"Pin %d is available\", pin);\n\t\ttone_msg_t tone_msg;\n\t\ttone_msg.pin = pin;\n\t\ttone_msg.frequency = frequency;\n\t\ttone_msg.duration = duration;\n\t\ttone_msg.state = TONE_START;\n\t\ttone_msg.pin_state = PIN_STATE_AVAILABLE;\n\t\tif (xQueueSend(_tone_queue, &tone_msg, 0)!= pdTRUE) {\n\t\t\tlog_e(\"Could not send tone message to queue\");\n\t\t\treturn;\n\t\t}\n\t\tlog_v(\"Tone message sent to queue\");\n\t} else if (pin_is_in_use(pin)) {\n\t\tlog_e(\"Pin %d is in use\", pin);\n\t}\n}", "CodeBleu_score": 38.803530144440565}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (pin_available(pin)) {\n\t\ttone_msg_t msg = {.pin = pin,.frequency = frequency,.duration = duration };\n\t\ttone_start(msg);\n\t} else {\n\t\tlog_e(\"Pin %d is not available\", pin);\n\t}\n}", "CodeBleu_score": 29.851658488624956}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_v(\"Tone on pin %d with frequency %d and duration %ld\", pin, frequency, duration);\n\tif (pin_available(pin)) {\n\t\tlog_v(\"Pin %d is available\", pin);\n\t\ttone_msg_t msg;\n\t\tmsg.pin = pin;\n\t\tmsg.frequency = frequency;\n\t\tmsg.duration = duration;\n\t\tmsg.command = TONE_START;\n\t\tif (xQueueSend(_tone_queue, &msg, 0)!= pdTRUE) {\n\t\t\tlog_e(\"Could not send tone start message to queue\");\n\t\t}\n\t} else {\n\t\tlog_e(\"Pin %d is in use\", pin);\n\t}\n}", "CodeBleu_score": 43.81606546253949}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (enabled) {\n\t\tif (webUSBEnabled) return false;\n\t\tif (!started) {\n\t\t\twebUSBEnabled = true;\n\t\t\treturn true;\n\t\t}\n\t\tif (version < 0x0210) {\n\t\t\tversion = 0x0210;\n\t\t\treturn true;\n\t\t}\n\t\twebUSBEnabled = true;\n\t\treturn false;\n\t}\n\tif (webUSBEnabled) {\n\t\twebUSBEnabled = false;\n\t\treturn false;\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.03469300315715}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (enabled) {\n\t\tif (!usbStarted) {\n\t\t\twebUSBEnabled = true;\n\t\t\treturn true;\n\t\t}\n\t\tif (usbVersion < 0x0210) {\n\t\t\twebUSBEnabled = false;\n\t\t\treturn false;\n\t\t}\n\t}\n\twebUSBEnabled = enabled;\n\treturn false;\n}", "CodeBleu_score": 40.53024634727357}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!started) {\n\t\twebUSBEnabled = enabled;\n\t\treturn true;\n\t}\n\tif (enabled &&!webUSBEnabled) {\n\t\tif (version() < 0x0210) {\n\t\t\treturn false;\n\t\t}\n\t\twebUSBEnabled = true;\n\t\tif (version() < 0x0211) {\n\t\t\t// WebUSB requires a USB reset when enabling\n\t\t\treset();\n\t\t}\n\t} else if (!enabled && webUSBEnabled) {\n\t\twebUSBEnabled = false;\n\t}\n\treturn false;\n}", "CodeBleu_score": 45.13382152946326}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t buffer[64];\n\tuint8_t length;\n\tuint8_t i;\n\n\twhile (true) {\n\t\t// Read data from the USB CDC device\n\t\tlength = _device->read(buffer, sizeof(buffer));\n\n\t\t// If the device is disconnected, break out of the loop\n\t\tif (length == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// If there is no room in the receive queue, post an overflow event\n\t\tif (!_receiveQueue.write(buffer, length)) {\n\t\t\t_events.post(USB_CDC_EVENT_RX_OVERFLOW, length);\n\t\t\t_log.error(\"USB CDC receive queue overflow\");\n\t\t\tbreak;\n\t\t}\n\n\t\t// Post a receive event with the length of the received data\n\t\t_events.post(USB_CDC_EVENT_RX_DATA, length);\n\t}\n}", "CodeBleu_score": 16.854715123854696}, {"code": "void USBCDC::_onRX(){\n\t\t// Read data from the USB CDC device.\n\tuint8_t rxBuffer[USB_CDC_BUFFER_SIZE];\n\tuint32_t bytesRead = _cdc->read(rxBuffer, USB_CDC_BUFFER_SIZE);\n\n\t// If there is no data, return.\n\tif (bytesRead == 0) {\n\t\treturn;\n\t}\n\n\t// If the buffer is full, log an error and post an overflow event.\n\tif (_rxBuffer.isFull()) {\n\t\t_log->error(\"USB CDC RX buffer is full.\");\n\t\t_eventManager->postEvent(Event::Type::USB_CDC_RX_OVERFLOW, bytesRead);\n\t\treturn;\n\t}\n\n\t// Add the data to the buffer.\n\t_rxBuffer.push(rxBuffer, bytesRead);\n\n\t// Post a receive event.\n\t_eventManager->postEvent(Event::Type::USB_CDC_RX, bytesRead);\n}", "CodeBleu_score": 16.755027175951593}, {"code": "void USBCDC::_onRX(){\n\t\tif (rx_queue->isFull()) {\n\t\tUSB::event_t event;\n\t\tevent.type = USB::EVENT_RX_OVERFLOW;\n\t\tevent.data.rx_overflow.length = rx_queue->length();\n\t\tUSB::postEvent(event);\n\t\tlog_error(\"RX overflow\");\n\t}\n\telse {\n\t\tuint8_t byte;\n\t\twhile (rx_queue->read(&byte)) {\n\t\t\tUSB::event_t event;\n\t\t\tevent.type = USB::EVENT_RX;\n\t\t\tevent.data.rx.length = 1;\n\t\t\tevent.data.rx.data[0] = byte;\n\t\t\tUSB::postEvent(event);\n\t\t}\n\t}\n}", "CodeBleu_score": 18.88641441931437}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tres.Header().Set(\"Access-Control-Allow-Methods\", \"GET\")\n\n\trobotName := mux.Vars(req)[\"robotName\"]\n\n\trobot, err := a.robotService.GetRobotByName(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(err)\n\t\treturn\n\t}\n\n\tdevices, err := a.deviceService.GetDevicesByRobot(robot)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(err)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 35.99659110032153}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t", "CodeBleu_score": 3.5362673365206354}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot, err := a.robotRepo.GetRobotByName(robotName)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices, err := a.deviceRepo.GetDevicesByRobotID(robot.ID)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tvar deviceIDs []int\n\tfor _, device := range devices {\n\t\tdeviceIDs = append(deviceIDs, device.ID)\n\t}\n\n\tvar deviceInfos []Device\n\tfor _, deviceID := range deviceIDs {\n\t\tdevice, err := a.deviceRepo.GetDeviceByID(deviceID)\n\t\tif err!= nil {\n\t\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdeviceInfos = append(deviceInfos, device)\n\t}\n\n\tjson.NewEncoder(res).Encode(deviceInfos)\n}", "CodeBleu_score": 39.52929285660245}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"name\"]\n\n\t// Check if the robot exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Convert the robot connections to JSON format\n\tconnectionsJSON, err := json.Marshal(robot.Connections)\n\tif err!= nil {\n\t\thttp.Error(res, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the robot connections to the HTTP response\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 28.969275871151257}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobotName = strings.TrimSuffix(robotName, \"/connections\")\n\n\t// Check if the robot exists\n\tif _, ok := a.robots[robotName];!ok {\n\t\t// Write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with the specified name was found\"))\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections\n\tconnectionsJSON, err := json.Marshal(a.robots[robotName].Connections)\n\tif err!= nil {\n\t\t// Write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(\"An error occurred while converting the robot's connections to JSON format\"))\n\t\treturn\n\t}\n\n\t// Write the robot's connections to the HTTP response\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 37.11034490747823}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\turlParts := strings.Split(req.URL.Path, \"/\")\n\trobotName := urlParts[len(urlParts)-1]\n\n\t// Check if the robot exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Convert the robot's connections to JSON format\n\tconnectionsJSON, err := json.Marshal(robot.Connections)\n\tif err!= nil {\n\t\thttp.Error(res, \"Error converting connections to JSON\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the connections to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 33.46241910556127}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tif robotName == \"\" {\n\t\thttp.Error(res, \"Robot name not specified\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Get the device name from the URL query parameters\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tif deviceName == \"\" {\n\t\thttp.Error(res, \"Device name not specified\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Get the command from the URL query parameters\n\tcommand := req.URL.Query().Get(\"command\")\n\tif command == \"\" {\n\t\thttp.Error(res, \"Command not specified\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Get the command arguments from the URL query parameters\n\tcommandArgs := req.URL.Query()[\"args\"]\n\n\t// Get the robot and device from the database\n\trobot, err := a.db.GetRobotByName(robotName)\n\tif err!= nil {\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice, err := a.db.GetDeviceByName(robot.ID, deviceName)\n\tif err!= nil {\n\t\thttp.Error(res, \"Device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Execute the command on the device\n\terr = a.executeCommand(device, command, commandArgs)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the response\n\tres.Write([]byte(\"Command executed successfully\"))\n}", "CodeBleu_score": 46.51175058996907}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Parse the URL query parameters\n\tquery := req.URL.Query()\n\trobotName := query.Get(\"robot\")\n\tdeviceName := query.Get(\"device\")\n\tcommand := query.Get(\"command\")\n\n\t// Check if the device exists\n\tdevice, err := a.robot.GetDevice(deviceName)\n\tif err!= nil {\n\t\t// Write the error message as a JSON response\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\t// Execute the command on the device\n\terr = device.Command(command)\n\tif err!= nil {\n\t\t// Write the error message as a JSON response\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\t// Write a success message as a JSON response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(map[string]string{\"success\": \"Command executed successfully\"})\n}", "CodeBleu_score": 45.30653732857889}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\tif robotName == \"\" || deviceName == \"\" || command == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprintf(res, `{\"error\": \"Bad request. Missing robot, device or command query parameters.\"}`)\n\t\treturn\n\t}\n\n\trobot, err := a.getRobot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, `{\"error\": \"Error retrieving robot: %s\"}`, err)\n\t\treturn\n\t}\n\n\tdevice, err := robot.GetDevice(deviceName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, `{\"error\": \"Error retrieving device: %s\"}`, err)\n\t\treturn\n\t}\n\n\terr = device.Command(command)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, `{\"error\": \"Error executing command: %s\"}`, err)\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(res, `{\"status\": \"Command executed successfully\"}`)\n}", "CodeBleu_score": 44.07438644892845}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\n\t\t// If the header is empty, respond with a \"401 Unauthorized\" status and an error message\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the header into username and password\n\t\tauthHeaderSplit := strings.Split(authHeader, \" \")\n\t\tif len(authHeaderSplit)!= 2 || authHeaderSplit[0]!= \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the base64-encoded username and password\n\t\tdecoded, err := base64.StdEncoding.DecodeString(authHeaderSplit[1])\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the decoded username and password into username and password\n\t\tdecodedSplit := strings.Split(string(decoded), \":\")\n\t\tif len(decodedSplit)!= 2 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Compare the username and password with the expected values\n\t\tif!secureCompare(username, decodedSplit[0]) ||!secureCompare(password, decodedSplit[1]) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the comparison succeeds, proceed to the next handler\n\t\tnext(w, r)\n\t}\n}", "CodeBleu_score": 47.70216805885559}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the \"Authorization\" header from the request\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\t// If the header is empty, respond with a \"401 Unauthorized\" status and an error message\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"401 Unauthorized\n\"))\n\t\t\treturn\n\t\t}\n\t\t// Split the \"Authorization\" header into username and password\n\t\t_, auth := splitAuth(authHeader)\n\t\t// Compare the username and password with the expected credentials\n\t\tif!secureCompare(auth, username+\":\"+password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"401 Unauthorized\n\"))\n\t\t\treturn\n\t\t}\n\t\t// If the comparison succeeds, proceed to the next handler\n\t\tnext(w, r)\n\t}\n}", "CodeBleu_score": 50.70051624149485}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Get the username and password from the authorization header\n\t\t_, token := strings.SplitN(auth, \" \", 2)\n\n\t\t// Decode the token using base64\n\t\ttoken, _ = base64.StdEncoding.DecodeString(token)\n\n\t\t// Split the token into username and password\n\t\tusername, password := strings.SplitN(string(token), \":\", 2)\n\n\t\t// Compare the provided credentials with the ones in the authorization header\n\t\tif secureCompare(username, username) && secureCompare(password, password) {\n\t\t\t// If the comparison succeeds, call the next handler in the chain\n\t\t\tnext(w, r)\n\t\t} else {\n\t\t\t// If the comparison fails, set the \"WWW-Authenticate\" header and respond with a \"401 Unauthorized\" status\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t}\n\t}\n}", "CodeBleu_score": 53.02523837882178}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tvar (\n\t\trawValue int\n\t\tscaled   float64\n\t\terr      error\n\t)\n\n\ta.Lock()\n\tdefer a.Unlock()\n\n\tif!a.connection.supportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\n\trawValue, err = a.connection.analogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled = a.scale(rawValue)\n\n\ta.lastRaw = rawValue\n\ta.lastScaled = scaled\n\n\treturn rawValue, scaled, nil\n}", "CodeBleu_score": 47.230170424714544}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading\n\ta.Lock()\n\tdefer a.Unlock()\n\n\t// Check if the sensor supports analog reading\n\tif!a.supportsAnalogReading {\n\t\treturn 0, 0, errors.New(\"analog sensor does not support analog reading\")\n\t}\n\n\t// Read the raw sensor value\n\trawValue, err := a.sensor.Read()\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaledValue := a.scaleValue(rawValue)\n\n\t// Update the last read values\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\t// Return the raw and scaled values\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 45.62500196506115}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading\n\ta.sensorMutex.Lock()\n\tdefer a.sensorMutex.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif!a.connection.SupportsAnalogReading() {\n\t\treturn -1, -1, errors.New(\"AnalogSensorDriver: Analog reading not supported by connection\")\n\t}\n\n\t// Read the raw sensor value\n\traw, err := a.connection.ReadAnalogSensor(a.sensor)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaled := a.scale(raw)\n\n\t// Update the last read values\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 38.905201487340534}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(GroveSoundSensorDriverName)\n\treturn &d\n}", "CodeBleu_score": 57.96706367723422}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tvar name string\n\tvar err error\n\tif len(opts) > 0 {\n\t\tname, err = getParam(opts[0], \"name\", \"\")\n\t\tif err!= nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tif name == \"\" {\n\t\tname = \"GroveSoundSensor\"\n\t}\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, name, opts...),\n\t}\n}", "CodeBleu_score": 36.477495607659314}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tvar (\n\t\tname string\n\t\terr  error\n\t)\n\n\t// Assign default name if none is provided.\n\tif len(opts) > 0 {\n\t\tname, err = opts[0].(string)\n\t\tif err!= nil {\n\t\t\tname = \"GroveSoundSensor\"\n\t\t}\n\t} else {\n\t\tname = \"GroveSoundSensor\"\n\t}\n\n\t// Create and initialize the driver.\n\tg := GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: AnalogSensorDriver{\n\t\t\tAnalogReader: a,\n\t\t\tPin:          pin,\n\t\t\tName:         name,\n\t\t},\n\t}\n\n\t// Initialize the driver.\n\terr = g.Init()\n\tif err!= nil {\n\t\treturn nil\n\t}\n\n\treturn &g\n}", "CodeBleu_score": 33.01419395113257}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\terr := d.writeRegister(mfrc522.CommandReg, mfrc522.SoftReset)\n\tif err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(10 * time.Millisecond)\n\tstatus, err := d.readRegister(mfrc522.CommandReg)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif (status & mfrc522.SoftReset)!= 0 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.77195888496265}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tif d.debug {\n\t\tfmt.Printf(\"MFRC522Common.softReset()\n\")\n\t}\n\tif err := d.writeRegister(commandReg, softReset); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(time.Millisecond * 10)\n\tif err := d.readRegister(commandReg); err!= nil {\n\t\treturn err\n\t}\n\tif d.debug {\n\t\tfmt.Printf(\"MFRC522Common.softReset() = nil\n\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 52.20236128463054}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(commandReg, softReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tif d.readRegister(commandReg)&softReset == softReset {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 26.059517712329473}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check the FIFO buffer of the MFRC522 device\n\tfifoLevel, err := d.readRegister(MFRC522_RegFIFOLevel)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check the FIFO buffer of the MFRC522 device\n\tif fifoLevel < uint8(len(backData)) {\n\t\treturn 0, errors.New(\"FIFO buffer of the MFRC522 device is too small\")\n\t}\n\n\t// Read the FIFO buffer of the MFRC522 device\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(MFRC522_RegFIFOData)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control and status register of the MFRC522 device\n\tlastBits, err := d.readRegister(MFRC522_RegControl)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 47.71263118099301}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData)!= d.fifoSize {\n\t\treturn 0, errors.New(\"readFifo: backData length does not match fifoSize\")\n\t}\n\t// Read FIFO data\n\tif err := d.readRegister(d.fifoDataReg, backData); err!= nil {\n\t\treturn 0, err\n\t}\n\t// Read control register\n\treturn d.readRegister(d.controlReg)\n}", "CodeBleu_score": 21.08497961122596}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Get the number of bytes in the FIFO\n\tfifoCount, err := d.getFifoCount()\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the number of bytes in the FIFO matches the expected length of the byte slice\n\tif fifoCount!= uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"The number of bytes in the FIFO (%d) does not match the expected length of the byte slice (%d)\", fifoCount, len(backData))\n\t}\n\n\t// Read each byte from the FIFO into the byte slice\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(fifoDataReg)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tlastBits, err := d.readRegister(controlReg)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 56.11144895150676}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.Debug {\n\t\td.DebugLog(\"piccHalt\")\n\t}\n\tcommand := []byte{PICC_HALT}\n\tcommand = append(command, d.calculateCRC(command)...)\n\terr := d.sendCommand(command)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tresponse, err := d.readSingleBlock()\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif response[0]!= 0x0A {\n\t\treturn errors.New(\"piccHalt: Error\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 38.26554432450574}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Println(\"piccHalt\")\n\t}\n\n\t// Create halt command\n\thaltCmd := []byte{MFRC522CommonPICC_CMD_HALT}\n\n\t// Calculate CRC\n\tcrc := d.calculateCRC(haltCmd)\n\n\t// Append CRC\n\thaltCmd = append(haltCmd, crc...)\n\n\t// Send command\n\terr := d.sendCommand(haltCmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Read response\n\t_, err = d.readResponse()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 35.53861996852093}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Println(\"piccHalt\")\n\t}\n\n\t// Create halt command\n\tcmd := make([]byte, 4)\n\tcmd[0] = PICC_CMD_HALT\n\tcmd[1] = 0\n\tcmd[2] = 0\n\tcmd[3] = 0\n\n\t// Calculate CRC\n\tcrc := d.calculateCRC(cmd)\n\n\t// Append CRC\n\tcmd = append(cmd, crc...)\n\n\t// Send command\n\terr := d.sendCommand(cmd)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Receive error\n\terr = d.readError()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 26.118065974496524}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\treturn d.piccReadWithSize(block, 16)\n}", "CodeBleu_score": 5.078948671060423}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tvar err error\n\tvar data []byte\n\tvar dataLen uint8\n\n\tif d.debug {\n\t\tfmt.Printf(\"piccRead(%d)\n\", block)\n\t}\n\n\t// Prepare the read command\n\tcmd := []byte{piccReadReg, block}\n\n\t// Calculate CRC\n\tcrc := d.calcCRC(cmd)\n\tcmd = append(cmd, crc...)\n\n\t// Transmit the command\n\terr = d.transmit(cmd)\n\tif err!= nil {\n\t\treturn data, err\n\t}\n\n\t// Receive the data\n\tdata, err = d.receive(16)\n\tif err!= nil {\n\t\treturn data, err\n\t}\n\n\t// Check for errors\n\tif (data[0] & 0x0F)!= 0x0A {\n\t\treturn data, errors.New(\"piccRead: Error reading data\")\n\t}\n\n\t// Copy the data to the data buffer\n\tdataLen = data[0] & 0x0F\n\tfor i := 0; i < int(dataLen); i++ {\n\t\td.data[i] = data[i+1]\n\t}\n\n\treturn d.data[:dataLen], nil\n}", "CodeBleu_score": 33.3105511281622}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Prepare the command.\n\tcommand := make([]byte, 4)\n\tcommand[0] = PICC_CMD_MF_READ\n\tcommand[1] = block\n\t// Calculate the CRC.\n\tcrc, err := d.calcCRC(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Copy the command to the command buffer.\n\tfor i := 0; i < 4; i++ {\n\t\td.commandBuffer[i] = command[i]\n\t}\n\t// Copy the CRC to the command buffer.\n\tfor i := 0; i < 2; i++ {\n\t\td.commandBuffer[6 + i] = crc[i]\n\t}\n\t// Transmit the command.\n\terr = d.toCard(PICC_CMD_TRANSCEIVE, d.commandBuffer)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\t// Check for success.\n\tif d.responseBuffer[PICC_CMD_MF_READ]!= STATUS_OK {\n\t\treturn nil, errors.New(\"piccRead: Read command failed\")\n\t}\n\t// Store response in the data buffer.\n\tfor i := 0; i < 16; i++ {\n\t\td.dataBuffer[i] = d.responseBuffer[i]\n\t}\n\t// Copy data buffer to data.\n\tdata := make([]byte, 16)\n\tfor i := 0; i < 16; i++ {\n\t\tdata[i] = d.dataBuffer[i]\n\t}\n\treturn data, nil\n}", "CodeBleu_score": 36.29713722476071}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn errors.New(\"piccRequest: buffer too small\")\n\t}\n\t// Clear all bits in the collison register\n\td.writeRegister(RegColl, 0x80)\n\t// Transmit the request\n\terr := d.transceive(answer, reqMode)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Check the number of bytes received\n\tif d.readRegister(RegColl) & 0x08 == 0 {\n\t\treturn errors.New(\"piccRequest: collision error\")\n\t}\n\t// Check the number of bytes received\n\tif d.readRegister(RegColl) & 0x07!= 0 {\n\t\treturn errors.New(\"piccRequest: bit count error\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 54.318743723297814}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t", "CodeBleu_score": 3.6650973421215025}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn errors.New(\"The answer buffer is too small\")\n\t}\n\n\t// Prepare values for bit flips\n\tbitFlips := make([]uint8, 2)\n\tbitFlips[0] = 0x00\n\tbitFlips[1] = 0x00\n\n\t// Tell the PICC we want to transmit and get the answer\n\tstatus, err := d.transceive(append([]byte{reqMode}, bitFlips...), answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check for collisions\n\tif (status & 0x08) == 0x08 {\n\t\t// Collisions are detected\n\t\t// Clear collision bits\n\t\td.writeRegister(CollReg, 0x80)\n\t\t// Inform about collisions\n\t\treturn errors.New(\"A collision has occurred\")\n\t}\n\n\t// Tell the PICC we want to transmit and get the answer\n\tstatus, err = d.transceive(append([]byte{reqMode}, bitFlips...), answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check for errors\n\tif status!= 0x00 {\n\t\treturn errors.New(\"The PICC responded with an error\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.180877677577655}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tif err := d.stepPin.Low(); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(time.Duration(d.delay) * time.Millisecond)\n\tif err := d.stepPin.High(); err!= nil {\n\t\treturn err\n\t}\n\tif d.direction == forward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 64.15910386106074}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\t// Lock the mutex to ensure thread safety\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Check if the step pin is valid\n\tif d.stepPin == 0 {\n\t\treturn errors.New(\"step pin is not set\")\n\t}\n\n\t// Trigger a valid step by setting the step pin low, waiting for a delay, and setting the step pin high\n\tif err := d.digitalWrite(d.stepPin, d.LOW); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.delay)\n\tif err := d.digitalWrite(d.stepPin, d.HIGH); err!= nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction\n\tif d.direction == d.FORWARD {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 63.84474129478275}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\t// Lock the valueMutex to ensure thread safety while accessing shared variables\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a valid step by setting the step pin low, waiting for a delay, and setting the step pin high\n\tif err := d.stepPin.Write(0); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.delay)\n\tif err := d.stepPin.Write(1); err!= nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 63.06299067943595}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitor!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitor = &DistanceMonitor{\n\t\tstop: d.stopDistanceMonitor,\n\t\twg:   &sync.WaitGroup{},\n\t}\n\n\td.wg.Add(1)\n\tgo d.distanceMonitor.run()\n\n\treturn nil\n}", "CodeBleu_score": 37.96493360259373}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.Lock()\n\tdefer d.Unlock()\n\n\tif d.distanceMonitor!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStop = make(chan struct{})\n\td.distanceMonitorWG = &sync.WaitGroup{}\n\tgo d.distanceMonitor()\n\n\treturn nil\n}", "CodeBleu_score": 25.669816575138114}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitor!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitor = &DistanceMonitor{\n\t\tstop:   d.stopDistanceMonitor,\n\t\twg:     &sync.WaitGroup{},\n\t\tdriver: d,\n\t}\n\td.distanceMonitor.wg.Add(1)\n\tgo d.distanceMonitor.run()\n\n\treturn nil\n}", "CodeBleu_score": 38.08762154647363}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, event string, value uint32, timestamp uint32) {\n\t\tif event == \"rising\" {\n\t\t\td.startTimestamp = timestamp\n\t\t} else if event == \"falling\" {\n\t\t\td.duration = time.Duration(timestamp - d.startTimestamp) * time.Nanosecond\n\t\t\td.channel <- d.duration\n\t\t}\n\t}\n}", "CodeBleu_score": 40.57054213133134}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, event string, value uint32, timestamp uint32) {\n\t\tswitch event {\n\t\tcase \"rising\":\n\t\t\td.startTimestamp = timestamp\n\t\tcase \"falling\":\n\t\t\td.channel <- time.Duration(timestamp-d.startTimestamp) * time.Microsecond\n\t\t}\n\t}\n}", "CodeBleu_score": 40.63462526924846}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, name string, value uint32, value2 uint32) {\n\t\tif name == \"rising\" {\n\t\t\td.start = time.Now()\n\t\t} else if name == \"falling\" {\n\t\t\td.duration = time.Since(d.start)\n\t\t\td.channel <- d.duration\n\t\t}\n\t}\n}", "CodeBleu_score": 32.908329020401965}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor\n\td.triggerSensor()\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measurementComplete:\n\t\t// The measurement has completed\n\t\t// Calculate the distance from the measured time\n\t\td.distance = d.calculateDistance(d.measurementTime)\n\tcase <-time.After(d.measurementTimeout):\n\t\t// The measurement timed out\n\t\treturn errors.New(\"measurement timed out\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 39.43071661400801}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\tif err := d.triggerSensor(); err!= nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase <-d.measurementComplete:\n\t\td.distance = d.measurementDuration / 2 / time.Microsecond\n\tcase <-time.After(d.measurementTimeout):\n\t\treturn errors.New(\"timeout\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 52.61419789209859}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger sensor\n\terr := d.trigger()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for measurement to complete\n\tselect {\n\tcase <-d.done:\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\treturn errors.New(\"timeout\")\n\t}\n}", "CodeBleu_score": 39.587197498332294}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    try:\n        token = os.environ.get('AUTH_TOKEN')\n        if token:\n            return token\n        with open(self.state_path, 'r') as state_file:\n            state = json.load(state_file)\n        if 'access_token' in state and 'expiration_time' in state:\n            expiration_time = datetime.fromisoformat(state['expiration_time'])\n            if expiration_time > datetime.now():\n                return state['access_token']\n        refresh_token = os.environ.get('REFRESH_TOKEN')\n        if refresh_token:\n            response = self.fetch_json_data(\n                'POST',\n                self.refresh_token_url,\n                data={\n                    'grant_type':'refresh_token',\n                   'refresh_token': refresh_token,\n                },\n            )\n            self.update_state(response)\n            return response['access_token']\n        raise AccountNotAuthorized()\n    except FileNotFoundError:\n        raise AccountNotAuthorized()\n\n", "CodeBleu_score": 42.37799080058489}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.environ.get('TOKEN')\n    if token:\n        return token\n    state = self.state.get('authentication')\n    if state and state.get('access_token'):\n        if state.get('expires_at') and state.get('expires_at') < datetime.now():\n            if state.get('refresh_token'):\n                try:\n                    self.refresh_authentication_token()\n                except AccountNotAuthorized:\n                    raise AccountNotAuthorized()\n                return state.get('access_token')\n        return state.get('access_token')\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 33.59177356356678}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        token = os.environ[\"AUTH_TOKEN\"]\n    except KeyError:\n        try:\n            token = self.state.get(\"auth_token\")\n            expires_at = self.state.get(\"auth_expires_at\")\n            if token is None or expires_at is None:\n                raise AccountError(\"No authentication token available.\")\n            if expires_at < datetime.now():\n                refresh_token = self.state.get(\"auth_refresh_token\")\n                if refresh_token is None:\n                    raise AccountError(\"Authentication token expired.\")\n                self.fetch_authentication_token(refresh_token=refresh_token)\n            return token\n        except KeyError:\n            raise AccountError(\"No authentication token available.\")\n\n", "CodeBleu_score": 33.2921229681609}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.session.refresh_token\n        self.session.delete()\n        self.session.create()\n        self.fetch_json_data(\n            method=\"POST\",\n            endpoint=\"/v1/logout\",\n            data={\"refresh_token\": refresh_token},\n        )\n        return True\n    except AccountError:\n        return False\n\n", "CodeBleu_score": 47.13950584891966}, {"code": "def logout(self)\n\t\n    try:\n        self.refresh_token = self.get_refresh_token()\n        self.delete_session()\n        self.fetch_json_data(\"/v1/logout\", data={\"refresh_token\": self.refresh_token})\n        return True\n    except AccountError:\n        return False\n\n", "CodeBleu_score": 49.303645977689555}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_session()\n        self.fetch_json_data(\"/v1/logout\", method=\"POST\", data={\"refresh_token\": refresh_token})\n        return True\n    except AccountError:\n        return False\n\n", "CodeBleu_score": 52.512453567253395}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for package in self.pm.packages:\n        if package.optional:\n            continue\n        if package.external:\n            packages.append((package.name, package.version, package.source))\n        else:\n            packages.append((package.name, package.version))\n    return packages\n\n", "CodeBleu_score": 23.10767798040959}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for package in self.get_packages():\n        if package.is_optional:\n            continue\n        if package.is_external:\n            packages.append(\n                (package.name, package.version, package.source_url)\n            )\n        else:\n            packages.append((package.name, package.version))\n    return packages\n\n", "CodeBleu_score": 22.530560826436123}, {"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.pm.get_packages():\n        if package.is_optional():\n            continue\n        if package.is_external():\n            result.append({\n                \"name\": package.name,\n                \"version\": package.version,\n                \"source\": package.source,\n            })\n        else:\n            result.append({\n                \"name\": package.name,\n                \"version\": package.version,\n            })\n    return result\n\n", "CodeBleu_score": 29.652716876075747}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not targets:\n        targets = []\n    project_config = ProjectConfig.from_env(env)\n    platform_config = project_config.get(\"platform\", \"platform\")\n    platform_config = platform_config.split(\",\")\n    if platform_config[0] == \"auto\":\n        platform_config = platform_config[1:]\n    platform_config = [platform.strip() for platform in platform_config]\n    if not platform_config:\n        raise exception.UndefinedEnvPlatformError(env)\n    platform_config = platform_config[0]\n    platform_config = project_config.get(\"platform\", platform_config)\n    project_config.set(\"platform\", \"platform\", platform_config)\n    project_config.set(\"platform\", \"autoinstall\", autoinstall)\n    project_config.set(\"platform\", \"targets\", \",\".join(targets))\n    return cls(project_config)\n\n", "CodeBleu_score": 33.09662432854766}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    project_conf = ProjectConf.from_env(env, targets, autoinstall)\n    return cls(project_conf.platform, autoinstall)\n\n", "CodeBleu_score": 11.869982871588778}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if env is None:\n        env = os.environ.get(\"PYPROJECT_ENV\")\n\n    if env is None:\n        raise exception.UndefinedEnvError()\n\n    platform = cls.config.get(\"platform\", env)\n    if platform is MISSING:\n        raise exception.UndefinedEnvPlatformError(env)\n\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.set_env(env)\n    instance.config_packages(targets)\n    return instance\n\n", "CodeBleu_score": 39.08549973711216}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 66.51085749887085}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(AXP192_SLAVE_ADDRESS);\n\tWire.write(Addr);\n\tWire.endTransmission(false);\n\tWire.requestFrom(AXP192_SLAVE_ADDRESS, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 62.30826160103271}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tuint8_t Data;\n\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tData = Wire.read();\n\t\tBuff[i] = Data;\n\t}\n}", "CodeBleu_score": 63.839491441844324}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef AXP192_DEBUG\n    Serial.print(\"AXP192::DeepSleep(time_in_us=\");\n    Serial.print(time_in_us);\n    Serial.println(\")\");\n#endif\n    SetSleep();\n    if (time_in_us > 0) {\n        Write1Byte(0x21, 0x00);\n        Write1Byte(0x22, (time_in_us >> 16) & 0xFF);\n        Write1Byte(0x23, (time_in_us >> 8) & 0xFF);\n        Write1Byte(0x24, time_in_us & 0xFF);\n        Write1Byte(0x25, 0x01);\n        Write1Byte(0x26, 0x01);\n    } else {\n        Write1Byte(0x25, 0x00);\n        Write1Byte(0x26, 0x00);\n    }\n    Write1Byte(0x31, Read8bit(0x31) & 0x7F);\n    Write1Byte(0x12, Read8bit(0x12) | 0x01);\n}", "CodeBleu_score": 52.49260295560912}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef AXP192_DEBUG\n    Serial.println(\"DeepSleep\");\n#endif\n    SetSleep();\n    if (time_in_us > 0) {\n        Write1Byte(0x32, (uint8_t)(time_in_us >> 8));\n        Write1Byte(0x33, (uint8_t)(time_in_us & 0xFF));\n        Write1Byte(0x30, 0x01);\n    } else {\n        Write1Byte(0x30, 0x00);\n    }\n    Write1Byte(0x30, 0x00);\n}", "CodeBleu_score": 38.41472189325007}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t", "CodeBleu_score": 3.410829817826662}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = tft.getCursorY();\n\tint x = tft.getCursorX();\n\tint w = tft.width();\n\tint h = tft.height();\n\tint y_top = y;\n\tint y_bot = y + h;\n\tint y_fix = 0;\n\tint y_fix_alt = 0;\n\tif (tteBar) {\n\t\ty_fix = y_bot - 15;\n\t\ty_fix_alt = y_fix - 15;\n\t}\n\telse {\n\t\ty_fix = y_top;\n\t\ty_fix_alt = y_top + 15;\n\t}\n\ttft.fillRect(x, y_fix, w, h, color);\n\ty = (y + h) % (h - 15);\n\ttft.setCursor(x, y);\n\tscrollAddress(y);\n\treturn y_top;\n}", "CodeBleu_score": 31.82562314458741}, {"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n  int y = tft.gety();\n  if (y >= (int)tft.height()-tft.getyoffset()-tft.height()-tft.getyoffset()) {\n    tft.sety(0);\n    tft.setx(0);\n    tft.fillscreen(color);\n    tft.sety(y);\n  } else {\n    tft.sety(y+tft.height());\n  }\n  tft.fillrect(0, 0, tft.width(), tft.height(), color);\n  tft.sety(y);\n  scrollAddress(y);\n  return y;\n#endif\n}", "CodeBleu_score": 21.304367853272364}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = y_scroll;\n\tif (y < 0) {\n\t\ty = 0;\n\t}\n\tif (y + tft.height() >= tft.height()) {\n\t\ty = tft.height() - tft.height();\n\t}\n\tif (y + tft.height() >= tft.height() - tft.height()/2) {\n\t\ty = tft.height() - tft.height() + tft.height()/2;\n\t}\n\ttft.fillScreen(color);\n\ty_scroll = y + tft.height();\n\tif (y_scroll >= tft.height() - tft.height()/2) {\n\t\ty_scroll = 0;\n\t}\n\tscrollAddress(y_scroll);\n\treturn y;\n}", "CodeBleu_score": 15.541087883234322}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// setup access points\n\tif (!this->setupAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\t// setup HTML content\n\tif (!this->setupHTMLContent(ssids)) {\n\t\treturn false;\n\t}\n\n\t// start portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 58.5787638919234}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// set up access points\n\tif (!this->setupAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\t// set up HTML content\n\tif (!this->setupHTMLContent(ssids)) {\n\t\treturn false;\n\t}\n\n\t// start portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 58.5787638919234}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// setup access points\n\tif (!this->setupAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\t// setup HTML content\n\tif (!this->setupHTMLContent(ssids)) {\n\t\treturn false;\n\t}\n\n\t// start portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 58.5787638919234}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\t// Queue already enabled, ensure that queue, text, and text_in are initialized\n\t\tif (queue.empty()) {\n\t\t\tqueue.push_back(0);\n\t\t}\n\t\tif (text.empty()) {\n\t\t\ttext.push_back(0);\n\t\t}\n\t\tif (text_in.empty()) {\n\t\t\ttext_in.push_back(0);\n\t\t}\n\t} else {\n\t\t// Queue not enabled, flush queue and set queue_enabled_flag to true\n\t\tqueue.clear();\n\t\tqueue.push_back(0);\n\t\ttext.clear();\n\t\ttext.push_back(0);\n\t\ttext_in.clear();\n\t\ttext_in.push_back(0);\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 11.12593956090288}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (!queue_enabled_flag) {\n\t\tqueue_enabled_flag = true;\n\t\tflush_queue();\n\t}\n}", "CodeBleu_score": 4.666175706815866}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\t// the queue is already enabled\n\t\tif (queue.empty()) {\n\t\t\t// queue is empty, so initialize it\n\t\t\tqueue.push_back(\"text\");\n\t\t\tqueue.push_back(\"text_in\");\n\t\t}\n\t\tif (text.empty()) {\n\t\t\t// text is empty, so initialize it\n\t\t\ttext.push_back(\"text\");\n\t\t\ttext.push_back(\"text_in\");\n\t\t}\n\t\tif (text_in.empty()) {\n\t\t\t// text_in is empty, so initialize it\n\t\t\ttext_in.push_back(\"text\");\n\t\t\ttext_in.push_back(\"text_in\");\n\t\t}\n\t} else {\n\t\t// the queue is not enabled, so flush it\n\t\tqueue.clear();\n\t\ttext.clear();\n\t\ttext_in.clear();\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 10.497189832346896}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea!= NULL) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = NULL;\n\t}\n\tqueue_nmea = new Queue<String>();\n}", "CodeBleu_score": 37.33076757228842}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\t// create a new queue for the NMEA sentences\n\tstd::queue<std::string> *queue_nmea = new std::queue<std::string>;\n\t// delete the old queue\n\tdelete queue_nmea_mutex;\n\tqueue_nmea_mutex = new std::mutex;\n\t// lock the queue\n\tqueue_nmea_mutex->lock();\n\t// set the new queue\n\tqueue_nmea_ = queue_nmea;\n\t// unlock the queue\n\tqueue_nmea_mutex->unlock();\n}", "CodeBleu_score": 37.151282624760206}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = 0;\n\t}\n\n\tqueue_nmea = new Queue();\n}", "CodeBleu_score": 34.75091128084759}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint16_t x, y;\n\tuint16_t width = (area->x2 - area->x1 + 1);\n\tuint16_t height = (area->y2 - area->y1 + 1);\n\tuint16_t x_offset = area->x1;\n\tuint16_t y_offset = area->y1;\n\tuint16_t x_end = area->x2;\n\tuint16_t y_end = area->y2;\n\tuint16_t color_index = 0;\n\tuint16_t color_size = sizeof(lv_color_t);\n\tuint8_t color_bytes[color_size];\n\n\t//Start a write transaction\n\tmy_disp_driver_write_start();\n\n\t//Set the address window to the specified area\n\tmy_disp_driver_set_address_window(x_offset, y_offset, width, height);\n\n\t//Iterate through each pixel in the area\n\tfor (y = y_offset; y <= y_end; y++) {\n\t\tfor (x = x_offset; x <= x_end; x++) {\n\t\t\t//Write the corresponding color from the provided color buffer\n\t\t\tcolor_bytes[0] = (uint8_t) (color_p[color_index].full >> 24);\n\t\t\tcolor_bytes[1] = (uint8_t) (color_p[color_index].full >> 16);\n\t\t\tcolor_bytes[2] = (uint8_t) (color_p[color_index].full >> 8);\n\t\t\tcolor_bytes[3] = (uint8_t) color_p[color_index].full;\n\t\t\tmy_disp_driver_write_data(color_bytes, color_size);\n\t\t\tcolor_index++;\n\t\t}\n\t}\n\n\t//End the write transaction and notify that the display flush is complete\n\tmy_disp_driver_write_end();\n}", "CodeBleu_score": 42.46118029780841}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint16_t x, y;\n\tuint16_t w = (uint16_t)(area->x2 - area->x1 + 1);\n\tuint16_t h = (uint16_t)(area->y2 - area->y1 + 1);\n\tuint32_t buf_size = w * h;\n\tuint32_t buf_size_bytes = buf_size * sizeof(lv_color_t);\n\tuint32_t buf_size_words = buf_size * sizeof(uint16_t);\n\n\tuint16_t *p_buf = (uint16_t *)color_p;\n\tuint16_t *p_buf_end = p_buf + buf_size;\n\n\t/* Start a write transaction */\n\tili9341_start_write();\n\n\t/* Set the address window */\n\tili9341_set_window(area->x1, area->y1, w, h);\n\n\t/* Write the color data */\n\twhile (p_buf < p_buf_end) {\n\t\tili9341_write_data_multiple((uint8_t *)p_buf, buf_size_bytes);\n\t\tp_buf += buf_size_words;\n\t}\n\n\t/* End the write transaction */\n\tili9341_end_write();\n\n\t/* Notify that the display flush is complete */\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 39.3423083414037}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\t// Print the menu name\n\tcout << menu->name << endl;\n\n\t// Iterate through all menu nodes and print their names\n\tfor (int i = 0; i < menu->size; i++) {\n\t\t// Print the menu name with indentation proportional to the layer level\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \"  \";\n\t\t}\n\t\tcout << menu->nodes[i]->name << endl;\n\n\t\t// Recursively call the function for the child menu nodes\n\t\tshowMenuList(menu->nodes[i]->child, layer + 1);\n\t}\n\n\t// Print an empty line after listing all nodes\n\tcout << endl;\n}", "CodeBleu_score": 43.29068040572116}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\tif (menu->first == NULL) {\n\t\treturn;\n\t}\n\tMenuItem * node = menu->first;\n\twhile (node!= NULL) {\n\t\tfor (int i = 0; i < layer; i++) {\n\t\t\tcout << \"    \";\n\t\t}\n\t\tcout << node->name << endl;\n\t\tnode = node->next;\n\t}\n\tcout << endl;\n}", "CodeBleu_score": 43.96013981867563}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu!= NULL) {\n\t\tif (menu->getMenuSize()!= 0) {\n\t\t\tfor (int i = 0; i < menu->getMenuSize(); i++) {\n\t\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\t\tcout << \"\\t\";\n\t\t\t\t}\n\t\t\t\tcout << menu->getMenuNode(i)->getName() << endl;\n\t\t\t\tif (menu->getMenuNode(i)->getMenu()!= NULL) {\n\t\t\t\t\tshowMenuList(menu->getMenuNode(i)->getMenu(), layer + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"Menu is empty\" << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << \"Menu is empty\" << endl;\n\t}\n\tcout << endl;\n}", "CodeBleu_score": 43.04357998856497}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint ssidCount = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char)random(97, 122);\n\t\t}\n\t\tint channel = random(1, 13);\n\t\tString mac = \"00:00:00:00:00:00\";\n\t\taddSSID(ssid, channel, mac);\n\t\tssidCount++;\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 35.66134789892918}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint ssidsGenerated = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = generateSSID();\n\t\tString channel = generateChannel();\n\t\tString mac = generateMAC();\n\t\tString ssidInfo = ssid + \" \" + channel + \" \" + mac;\n\t\tssidsGenerated++;\n\t\tSerial.println(ssidInfo);\n\t}\n\treturn ssidsGenerated;\n}", "CodeBleu_score": 32.03720162349897}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint ssidCount = 0;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid += (char) random(65, 90);\n\t\t}\n\n\t\tint channel = random(1, 13);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 17; j++) {\n\t\t\tmac += (char) random(48, 57);\n\t\t}\n\n\t\tWiFiScan::addSSID(ssid, channel, mac);\n\t\tssidCount++;\n\t}\n\n\treturn ssidCount;\n}", "CodeBleu_score": 38.73212683670806}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    now = datetime.datetime.utcnow()\n    # Create the JWT claim set.\n    # The JWT includes the following three claims:\n    # 1. The JWT ID.\n    # 2. The time the token was issued.\n    # 3. The time the token expires.\n    # 4. The GCP project ID the token is intended for.\n    jwt_claim_set = {\n        'iss': project_id,\n        'iat': now,\n        'exp': now + datetime.timedelta(hours=1),\n        'aud': project_id,\n    }\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    # Encode the JWT.\n    jwt_encoded = jwt.encode(jwt_claim_set, private_key, algorithm=algorithm)\n    return jwt_encoded\n\n", "CodeBleu_score": 50.64661924645719}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    now = datetime.utcnow()\n    msecs_since_epoch = (now - datetime(1970, 1, 1)).total_seconds() * 1000\n    expiration_time = int(msecs_since_epoch + 3600 * 1000)\n    iat = int(msecs_since_epoch)\n    jwt = {\n        'iss': '',\n       'scope': 'https://www.googleapis.com/auth/cloud-platform',\n        'aud': project_id,\n        'exp': expiration_time,\n        'iat': iat,\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    print('Creating new JWT for project:'+ project_id)\n    return jwt_encode(jwt, private_key, algorithm)\n\n", "CodeBleu_score": 47.17377372267286}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    now = datetime.datetime.utcnow()\n    # Set the expiry time to one hour ahead.\n    expiry = now + datetime.timedelta(hours=1)\n    # Create the JWT claims, which will be encoded as a JSON object.\n    claims = {\n        'iss': SERVICE_ACCOUNT_EMAIL,\n       'sub': SERVICE_ACCOUNT_EMAIL,\n        'iat': now,\n        'exp': expiry,\n        'aud': project_id,\n    }\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    # Encode the JWT to the specified algorithm.\n    encoded_jwt = jwt.encode(claims, private_key, algorithm=algorithm)\n    # The token is a string, but it is encoded as a bytes object.\n    return encoded_jwt\n\n", "CodeBleu_score": 55.27929396501576}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message: {}'.format(message))\n    print('Topic: {}'.format(message.topic))\n    print('QoS: {}'.format(message.qos))\n    if message.payload.decode('utf-8') == 'on':\n        path = 'image.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        print('File uploaded to {}'.format(url))\n        publish_event(url)\n    else:\n        print('Received: off')\n\n", "CodeBleu_score": 32.25401876974646}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \"{}\"'.format(message.payload))\n    print('Topic: \"{}\"'.format(message.topic))\n    print('QoS: {}'.format(message.qos))\n    if message.payload.decode() == 'on':\n        preview_capture('preview.jpg')\n        url = upload_file('preview.jpg', args.bucket_name)\n        publish_to_iot_core(url)\n    else:\n        print('off')", "CodeBleu_score": 27.802684075639473}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message: {}'.format(message.payload))\n    print('Topic: {}'.format(message.topic))\n    print('QoS: {}'.format(message.qos))\n    if message.payload.decode('utf-8') == 'on':\n        print('Capturing image...')\n        preview_capture('preview.jpg')\n        print('Uploading image...')\n        url = upload_file('preview.jpg', 'iot-camera-demo')\n        print('Publishing event...')\n        publish_event(url)\n        print('Done!')\n    else:\n        print('Received message: off')", "CodeBleu_score": 29.941700401968856}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description='Cloud IoT Core MQTT device connection')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        help='GCP project ID')\n    parser.add_argument(\n        '--subscription_name',\n        help='Cloud Pub/Sub subscription name')\n    return parser.parse_args()\n\n", "CodeBleu_score": 45.15010810153029}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='GCP project ID where the Cloud IoT Core device is located. '\n        'If not provided, the project ID will be retrieved from the '\n        'GOOGLE_CLOUD_PROJECT environment variable.',\n        required=False)\n    parser.add_argument(\n        '--registry_id',\n        help='Cloud IoT Core registry ID where the device is located. '\n        'If not provided, the registry ID will be retrieved from the '\n        'GOOGLE_CLOUD_PROJECT environment variable.',\n        required=False)\n    parser.add_argument(\n        '--device_id',\n        help='Cloud IoT Core device ID. '\n        'If not provided, the device ID will be retrieved from the '\n        'GOOGLE_CLOUD_PROJECT environment variable.',\n        required=False)\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to the private key file. '\n        'If not provided, the private key will be retrieved from the '\n        'GOOGLE_APPLICATION_CREDENTIALS environment variable.',\n        required=False)\n    parser.add_argument(\n        '--algorithm',\n        help='The encryption algorithm to use. '\n        'If not provided, the algorithm will be retrieved from the '\n        'GOOGLE_APPLICATION_CREDENTIALS environment variable.',\n        required=False)\n    parser.add_argument(\n        '--cloud_region',\n        help='The Cloud region for the Cloud IoT Core registry. '\n        'If not provided, the region will be retrieved from the '\n        'GOOGLE_CLOUD_PROJECT environment variable.',\n        required=False)\n    parser.add_argument(\n        '--ca_certs',\n        help='The path to the root certificate file. '\n        'If not provided, the root certificate will be retrieved from the '\n        'GOOGLE_CLOUD_PROJECT environment variable.',\n        required=False)\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        help='The hostname of the MQTT bridge to use. '\n        'If not provided, the hostname will be retrieved from the '\n        'GOOGLE_CLOUD_PROJECT environment variable.',\n        required=False)\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        help='The port of the MQTT bridge to use. '\n        'If not provided, the port will be retrieved", "CodeBleu_score": 28.273599493664392}, {"code": "def parse_command_line_args()\n\t\n\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection')\n    parser.add_argument('--project_id',\n                        default=os.getenv('GOOGLE_CLOUD_PROJECT'),\n                        help='GCP project ID')\n    parser.add_argument('--subscription_name',\n                        default='projects/{}/subscriptions/{}'.format(\n                            os.getenv('GOOGLE_CLOUD_PROJECT'),\n                            'iot-mqtt-test'),\n                        help='Cloud Pub/Sub subscription name')\n    parser.add_argument('--registry_id',\n                        default='test-registry',\n                        help='Cloud IoT Core registry ID')\n    parser.add_argument('--device_id',\n                        default='test-device',\n                        help='Cloud IoT Core device ID')\n    parser.add_argument('--algorithm',\n                        default='RS256',\n                        help='The algorithm to use to sign the JWT')\n    parser.add_argument('--private_key_file',\n                        default='private.pem',\n                        help='The path to the private key file')\n    parser.add_argument('--public_key_file',\n                        default='public.pem',\n                        help='The path to the public key file')\n    parser.add_argument('--ca_certs',\n                        default='roots.pem',\n                        help='The path to the CA cert file')\n    parser.add_argument('--num_messages',\n                        default=10,\n                        type=int,\n                        help='The number of messages to publish')\n    parser.add_argument('--message_type',\n                        default='event',\n                        help='The type of message to publish')\n    parser.add_argument('--message_data',\n                        default='{}',\n                        help='The data to publish')\n    parser.add_argument('--message_attributes',\n                        default='{}',\n                        help='The message attributes to publish')\n    parser.add_argument('--mqtt_bridge_hostname',\n                        default='mqtt.googleapis.com',\n                        help='The hostname of the MQTT bridge')\n    parser.add_argument('--mqtt_bridge_port',\n                        default=8883,\n                        type=int,\n                        help='The port of the MQTT bridge')\n    parser.add_argument('--mqtt_bridge_use_tls',\n                        action='store_true',\n                        help='Use TLS when connecting to the MQTT bridge')\n    parser.add_argument('--mqtt_bridge_use_alpn',\n                        action='store_true',\n                        help='Use ALPN when connecting to", "CodeBleu_score": 32.14228269655359}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/v1/projects/{}/locations/{}/registries/{}/devices:list'.format(PROJECT_ID, LOCATION, REGISTRY_ID)\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n    credentials = credentials.with_scopes(scopes)\n    client = discovery.build('cloudiot', version, credentials=credentials, discoveryServiceUrl=discovery_url)\n    return client\n\n", "CodeBleu_score": 45.40555919167698}, {"code": "def get_client(service_account_json)\n\t\n\n    # Create the client for the Google Cloud IoT Core service\n    client = discovery.build('cloudiot', 'v1', credentials=service_account.Credentials.from_service_account_file(service_account_json), discoveryServiceUrl='https://cloudiot.googleapis.com/$discovery/rest')\n\n    return client\n\n", "CodeBleu_score": 9.57967730850062}, {"code": "def get_client(service_account_json)\n\t\n    # Use the service account JSON file to create a Google Cloud IoT Core client.\n    client = iot.DeviceManagerClient(client_options={\n        \"api_endpoint\": API_ENDPOINT,\n        \"scopes\": API_SCOPES,\n        \"service_account_json\": service_account_json\n    })\n    return client\n\n", "CodeBleu_score": 9.69356421670425}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t   # Retrieve the ASN1 code for the hash method\n    try:\n        asn1_code = hash_method_to_asn1[hash_method]\n    except KeyError:\n        raise ValueError('Invalid hash method')\n\n    # Concatenate the ASN1 code with the hash value\n    hash_value_with_asn1 = asn1_code + hash_value\n\n    # Pad the hash value for signing\n    padded_hash_value = _pad_for_signing(hash_value_with_asn1, 256)\n\n    # Encrypt the padded hash value\n    encrypted_signature = priv_key.encrypt(padded_hash_value, None)[0]\n\n    return encrypted_signature\n\n", "CodeBleu_score": 34.212264761838036}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t   # Retrieve ASN1 code for the hash method\n    try:\n        asn1_code = hash_methods[hash_method]\n    except KeyError:\n        raise ValueError('Invalid hash method')\n\n    # Concatenate ASN1 code with hash value\n    asn1_hash = asn1_code + hash_value\n\n    # Pad the hash for signing\n    padded_hash = _pad_for_signing(asn1_hash, 256)\n\n    # Encrypt the padded hash\n    encrypted_signature = priv_key.encrypt(padded_hash, None)\n\n    return encrypted_signature\n\n", "CodeBleu_score": 32.48602785723742}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t   # Retrieve the ASN1 code for the hash method\n    hash_asn1 = get_asn1_for_hash_method(hash_method)\n\n    # Concatenate the ASN1 code with the hash value\n    hash_asn1_hash = hash_asn1 + hash_value\n\n    # Pad the hash for signing\n    padded_hash = _pad_for_signing(hash_asn1_hash, get_key_length(priv_key))\n\n    # Encrypt the padded hash\n    encrypted_signature = encrypt_block(padded_hash, priv_key)\n\n    return encrypted_signature\n\n\n", "CodeBleu_score": 13.337369112173608}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t  # convert signature to an integer\n    try:\n        sig_int = int(signature.decode('hex'), 16)\n    except ValueError:\n        raise ValueError('Signature must be a hex string')\n\n    # convert pub_key to an integer\n    try:\n        pub_key_int = int(pub_key.decode('hex'), 16)\n    except ValueError:\n        raise ValueError('Public key must be a hex string')\n\n    # decrypt the signature\n    try:\n        clearsig = rsa.decrypt(sig_int, pub_key_int)\n    except ValueError:\n        raise ValueError('Invalid signature')\n\n    # find the hash method\n    method = _find_method_hash(clearsig)\n\n    # compute the hash of the message\n    hash = compute_hash(message, method)\n\n    # reconstruct the padded hash\n    padded_hash = _pad_for_signing(hash, len(clearsig))\n\n    # check if the padded hash matches the clear signature\n    if padded_hash!= clearsig:\n        raise VerificationError('Verification failed')\n\n    return method\n", "CodeBleu_score": 47.19551305978761}, {"code": "def verify(message, signature, pub_key)\n\t  # Convert the signature to an integer\n    try:\n        signature = int.from_bytes(signature, 'big')\n    except TypeError:\n        raise TypeError('Signature must be a byte string or integer')\n\n    # Decrypt the signature\n    try:\n        clearsig = pub_key.decrypt(signature)\n    except ValueError:\n        raise VerificationError('Verification failed')\n\n    # Find the hash method\n    hash_method = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    hash_of_message = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _pad_for_signing(hash_of_message, pub_key.size)\n\n    # Compare the expected padded hash with the clear signature\n    if clearsig!= expected_padded_hash:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n\n", "CodeBleu_score": 44.82116976242499}, {"code": "def verify(message, signature, pub_key)\n\t  # Convert the signature to an integer\n    try:\n        sig_int = int.from_bytes(signature, byteorder='big')\n    except ValueError:\n        raise VerificationError('Invalid signature')\n\n    # Decrypt the signature\n    try:\n        clearsig = pub_key.decrypt(sig_int)\n    except ValueError:\n        raise VerificationError('Invalid signature')\n\n    # Find the hash method\n    hash_method = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    hash_message = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_hash = _pad_for_signing(hash_message, len(clearsig))\n\n    # Verify the signature\n    if clearsig!= expected_hash:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n", "CodeBleu_score": 45.821376363626264}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint32_t epoch = time(NULL);\n\tif (epoch == (uint32_t)-1) {\n\t\tdebug_printInfo(\"MQTT: Failed to obtain time\");\n\t} else {\n\t\tupdateJWT(epoch);\n\t}\n\tMQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;\n\tconn_opts.keepAliveInterval = 20;\n\tconn_opts.cleansession = 1;\n\tconn_opts.username = cid;\n\tconn_opts.password = ;\n\tMQTTClient_connect(client, &conn_opts);\n\tMQTTClient_setCallbacks(client, NULL, NULL, messageArrived, NULL);\n\tMQTTClient_subscribe(client, mqttTopic, 1);\n\tdebug_printInfo(\"MQTT: Connection attempt\");\n}", "CodeBleu_score": 41.91851142626455}, {"code": "static void connectMQTT(){\n\t\ttime_t t;\n\tt = time(NULL);\n\tdebug_printInfo(\"MQTT: time=%s\", ctime(&t));\n\tif (t > 0) {\n\t\tupdateJWT(t);\n\t}\n\telse {\n\t\tdebug_printInfo(\"MQTT: time is invalid\");\n\t}\n\tmqtt_connect();\n\tmqtt_subscribe = true;\n\tdebug_printInfo(\"MQTT: connectMQTT\");\n}", "CodeBleu_score": 51.58711429773928}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = time(NULL);\n\tif (epoch == (uint32_t)-1) {\n\t\tdebug_printError(\"MQTT: Failed to retrieve current time\");\n\t}\n\telse {\n\t\tupdateJWT(epoch);\n\t\tmqttConnect();\n\t\tmqttSubscribe = true;\n\t\tdebug_printInfo(\"MQTT: Attempting to connect to broker\");\n\t}\n}", "CodeBleu_score": 26.752918431749123}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t n = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] >= '0' && str[i] <= '9') {\n\t\t\tn *= 10;\n\t\t\tn += (uint32_t)(str[i] - '0');\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 24.88638731815362}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\twhile (width-- > 0) {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tresult *= 10;\n\t\tresult += *str++ - '0';\n\t}\n\t*num = result;\n\treturn str;\n}", "CodeBleu_score": 27.290622920542557}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t n = 0;\n\tfor (int i = 0; i < width; i++) {\n\t\tif (str[i] >= '0' && str[i] <= '9') {\n\t\t\tn = n * 10 + (str[i] - '0');\n\t\t} else {\n\t\t\t*num = n;\n\t\t\treturn str;\n\t\t}\n\t}\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 25.907864754469912}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t tbs_digest[ATCA_SHA_DIGEST_SIZE];\n\tuint8_t signature[ATCA_SIG_SIZE];\n\tuint8_t* tbs_ptr = NULL;\n\tsize_t tbs_size = 0;\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Get the size of the TBS portion of the certificate\n\tret = atcacert_get_tbs_size(cert_def, &tbs_size);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Get a pointer to the TBS portion of the certificate\n\ttbs_ptr = (uint8_t*)cert + cert_def->cert_template.offset_tbs;\n\n\t// Get the TBS digest\n\tret = atcacert_get_tbs_digest(cert_def, tbs_ptr, tbs_size, tbs_digest);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Get the signature from the certificate\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\t// Verify the TBS digest against the signature\n\tret = atcacert_verify_signature_hw(cert_def, tbs_digest, signature, ca_public_key);\n\tif (ret!= ATCA_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 69.3485854356496}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t#if defined(ATCA_HW_VERIFY_ENABLED)\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    if (cert_size < cert_def->cert_template.cert_size) {\n        return ATCA_BAD_PARAM;\n    }\n\n    // Verify the certificate's signature\n    return atcacert_verify_cert_hw_inner(cert_def, cert, cert_size, ca_public_key);\n#else\n    return ATCA_GEN_FAIL;\n#endif\n}", "CodeBleu_score": 33.4642394826589}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint result;\n\tuint8_t digest[ATCA_SHA_DIGEST_SIZE];\n\tuint8_t signature[ATCA_SIG_SIZE];\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Get the digest of the TBS portion of the certificate\n\tresult = atcacert_get_cert_tbs_digest(cert_def, cert, cert_size, digest);\n\tif (result!= ATCA_SUCCESS) {\n\t\treturn result;\n\t}\n\n\t// Get the signature from the certificate\n\tresult = atcacert_get_cert_sig(cert_def, cert, cert_size, signature);\n\tif (result!= ATCA_SUCCESS) {\n\t\treturn result;\n\t}\n\n\t// Verify the signature against the TBS digest\n\tresult = atcacert_verify_cert_sig(cert_def, digest, signature, ca_public_key);\n\n\treturn result;\n}", "CodeBleu_score": 57.96122991298329}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t *tmp = *list;\n\tif(tmp == timer)\n\t{\n\t\t*list = tmp->next;\n\t\treturn true;\n\t}\n\twhile(tmp->next!= NULL)\n\t{\n\t\tif(tmp->next == timer)\n\t\t{\n\t\t\ttmp->next = timer->next;\n\t\t\treturn true;\n\t\t}\n\t\ttmp = tmp->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 24.112723590422817}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\n#ifdef DEBUG\n    printf(\"timeout_deleteHelper\n\");\n#endif\n\n    // NOTE: listHead must NOT equal NULL at this point.\n\n    if(*list==NULL)\n    {\n        return false;\n    }\n\n    if(*list==timer)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *prev = *list;\n    timerStruct_t *curr = (*list)->next;\n\n    while(curr!=NULL)\n    {\n        if(curr==timer)\n        {\n            prev->next = timer->next;\n            return true;\n        }\n\n        prev = curr;\n        curr = curr->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 39.380469282907626}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t#ifdef DEBUG\n    printf(\"timeout_deleteHelper: \");\n    printf(\"list: %p\n\", list);\n    printf(\"timer: %p\n\", timer);\n#endif\n    if(list == NULL || timer == NULL)\n    {\n        return false;\n    }\n\n    if(timer->next == NULL)\n    {\n        // this is the last timer in the list\n        if(*list == timer)\n        {\n            // this is the only timer in the list\n            *list = NULL;\n            return true;\n        }\n        // this is the last timer in the list, but not the only timer in the list\n        timerStruct_t *prev = *list;\n        while(prev->next!= timer)\n        {\n            prev = prev->next;\n        }\n        prev->next = NULL;\n        return true;\n    }\n    // this is not the last timer in the list\n    timerStruct_t *prev = *list;\n    while(prev->next!= timer)\n    {\n        prev = prev->next;\n    }\n    prev->next = timer->next;\n    return true;\n}", "CodeBleu_score": 40.063222028868914}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tint status = BSD_ERROR;\n\tif (socket >= 0 && socket < MAX_SOCKETS) {\n\t\tif (gastrSockets[socket].bIsUsed == 1) {\n\t\t\tgastrSockets[socket].bIsUsed = 0;\n\t\t\tgastrSockets[socket].u16SessionID = 0;\n\t\t\tstatus = close(socket);\n\t\t\tif (status == SOCK_ERR_NO_ERROR) {\n\t\t\t\tstatus = BSD_SUCCESS;\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(status);\n\t\t\t\tstatus = BSD_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t}\n\treturn status;\n}", "CodeBleu_score": 40.453779775413985}, {"code": "int BSD_close(int socket){\n\tint status = BSD_ERROR;\n\ttstrSocket *pstrSocket = NULL;\n\tpstrSocket = getSocket(socket);\n\tif(pstrSocket!= NULL) {\n\t\tbsd_setErrNo(BSD_SUCCESS);\n\t\tif(pstrSocket->state == SOCKET_STATE_NOT_A_SOCKET) {\n\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t} else {\n\t\t\tif(close(socket) == SOCK_ERR_NO_ERROR) {\n\t\t\t\tpstrSocket->state = SOCKET_STATE_NOT_A_SOCKET;\n\t\t\t\tstatus = BSD_SUCCESS;\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t}\n\treturn status;\n}", "CodeBleu_score": 43.61220492035765}, {"code": "int BSD_close(int socket){\n\tint status = BSD_ERROR;\n\tif (socket >= 0 && socket < MAX_SOCKETS) {\n\t\tif (gastrSockets[socket].bIsUsed == 1) {\n\t\t\tif (gastrSockets[socket].u8SSLFlags & SSL_FLAGS_ACTIVE) {\n\t\t\t\tstatus = SOCKET_REQUEST(SOCKET_CMD_SSL_CLOSE, (uint8*)&gastrSockets[socket], sizeof(tstrSocket), NULL, 0, 0);\n\t\t\t} else {\n\t\t\t\tstatus = SOCKET_REQUEST(SOCKET_CMD_CLOSE, (uint8*)&gastrSockets[socket], sizeof(tstrSocket), NULL, 0, 0);\n\t\t\t}\n\t\t\tif (status == SOCK_ERR_NO_ERROR) {\n\t\t\t\tgastrSockets[socket].bIsUsed = 0;\n\t\t\t\tgastrSockets[socket].u16SessionID = 0;\n\t\t\t\tstatus = BSD_SUCCESS;\n\t\t\t} else {\n\t\t\t\tbsd_setErrNo(status);\n\t\t\t}\n\t\t} else {\n\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t}\n\treturn status;\n}", "CodeBleu_score": 41.31133095176129}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tsint8 s8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\ts8Ret = listen(socket, backlog);\n\t\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tbsd_setErrNo(s8Ret);\n\t\t\ts8Ret = BSD_ERROR;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts8Ret = BSD_SUCCESS;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 38.44877546532924}, {"code": "int BSD_listen(int socket, int backlog){\n\tsint8 s8Ret = SOCK_ERR_INVALID_ARG;\n\tif (socket >= 0 && socket < BSD_MAX_SOCKETS) {\n\t\ts8Ret = listen(socket, backlog);\n\t\tif (s8Ret!= SOCK_ERR_NO_ERROR) {\n\t\t\tbsd_setErrNo(s8Ret);\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 29.939743108685157}, {"code": "int BSD_listen(int socket, int backlog){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\ttstrListenCmd\t\tstrListen;\n\n\t\tstrListen.sock = socket;\n\t\tstrListen.u8BackLog = backlog;\n\t\tstrListen.u16SessionID\t\t= gastrSockets[socket].u16SessionID;\n\n\t\ts8Ret = SOCKET_REQUEST(SOCKET_CMD_LISTEN, (uint8*)&strListen, sizeof(tstrListenCmd), NULL, 0, 0);\n\t\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 36.196049460483856}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint32 s32Ret = SOCK_ERR_INVALID_ARG;\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(gastrSockets[socket].s32SocketType == SOCK_STREAM)\n\t\t{\n\t\t\ts32Ret = accept(socket, (struct sockaddr *)addr, (uint8 *)addrlen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbsd_setErrNo(SOCK_ERR_INVALID_SOCKET);\n\t\t}\n\t}\n\treturn s32Ret;\n}", "CodeBleu_score": 25.635108295450614}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint s32Ret = SOCK_ERR_INVALID_ARG;\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\ts32Ret = SOCK_ERR_NO_ERROR;\n\t}\n\treturn s32Ret;\n}", "CodeBleu_score": 12.192133776387337}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint32 s32Ret = SOCK_ERR_INVALID_ARG;\n\tif (socket >= 0 && socket < MAX_SOCKETS) {\n\t\tif (gastrSockets[socket].bIsUsed == 1) {\n\t\t\ts32Ret = SOCK_ERR_NO_ERROR;\n\t\t}\n\t}\n\treturn s32Ret;\n}", "CodeBleu_score": 14.933538561934833}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tif (client.connected()) {\n\t\treturn;\n\t}\n\n\ttime_t epoch = time(NULL);\n\tif (epoch == -1) {\n\t\tdebug_printError(\"MQTT: time() failed\");\n\t\treturn;\n\t}\n\n\tupdateJWT(epoch);\n\n\tdebug_printInfo(\"MQTT: Connecting to %s:%d...\", mqttServer, mqttPort);\n\tclient.setServer(mqttServer, mqttPort);\n\tclient.setCallback(callback);\n\tclient.connect(deviceId, mqttUser, mqttToken, willTopic, 0, true, willMessage);\n\tsendSubscribe = true;\n}", "CodeBleu_score": 49.780366522199685}, {"code": "static void connectMQTT(){\n\t\ttime_t t = time(NULL);\n\tif (t == -1) {\n\t\tdebug_printError(\"Failed to retrieve current time.\");\n\t\treturn;\n\t}\n\tdebug_printInfo(\"Current time is %s\", ctime(&t));\n\n\tupdateJWT(t);\n\tif (mqttClient.connect(clientId, mqttUser, mqttPassword) == 0) {\n\t\tdebug_printInfo(\"Connected to MQTT broker\");\n\t\tmqttClient.subscribe(mqttTopic);\n\t\tmqttSubscribed = true;\n\t} else {\n\t\tdebug_printError(\"Failed to connect to MQTT broker\");\n\t}\n}", "CodeBleu_score": 47.042182254602274}, {"code": "static void connectMQTT(){\n\t\tdebug_printInfo(\"MQTT: Connecting to broker\");\n\ttime_t t = time(NULL);\n\tif (t < 1514764800) {\n\t\tdebug_printError(\"MQTT: Invalid time, not connecting\");\n\t\treturn;\n\t}\n\tupdateJWT(t);\n\tMQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;\n\tconn_opts.keepAliveInterval = 20;\n\tconn_opts.cleansession = 1;\n\tconn_opts.username = cid;\n\tconn_opts.password = ;\n\tMQTTClient_connect(client, &conn_opts);\n\tMQTTClient_setCallbacks(client, NULL, connlost, msgarrvd, delivered);\n\tMQTTClient_subscribe(client, mqttTopic, 0);\n\tMQTTClient_setCallbacks(client, NULL, connlost, msgarrvd, delivered);\n\tMQTTClient_subscribe(client, mqttTopic, 0);\n\tdebug_printInfo(\"MQTT: Connected\");\n}", "CodeBleu_score": 41.55953825179635}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t#ifdef MQTT_DEBUG\n   printf(\"CLOUD_disconnect\n\");\n#endif\n   if (mqttState == CONNECTED) {\n      mqttCurrentState = MQTT_Disconnect(&mqttConnectionInfo);\n   }\n}", "CodeBleu_score": 51.595007096838415}, {"code": "void CLOUD_disconnect(void){\n\t#ifdef DEBUG\n   printf(\"MQTT: Disconnecting...\n\");\n#endif\n   mqttCurrentState state = MQTT_GetConnectionState();\n   if (state == CONNECTED) {\n      mqttContext* connectionInfo = MQTT_GetConnectionInfo();\n      mqttDisconnect(connectionInfo);\n   }\n}", "CodeBleu_score": 53.81896612167498}, {"code": "void CLOUD_disconnect(void){\n\t#ifdef DEBUG_MQTT\n   printf(\"MQTT_disconnect\n\");\n#endif\n   if (mqttState == CONNECTED) {\n      mqttCurrentState state = MQTT_Disconnect(&mqttContext);\n      if (state == DISCONNECTED) {\n         printf(\"MQTT_disconnect: Disconnected\n\");\n      } else {\n         printf(\"MQTT_disconnect: Disconnect failed\n\");\n      }\n   }\n}", "CodeBleu_score": 44.95920880746625}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tuint8_t wifi_creds = passed_wifi_creds;\n\tbool success = false;\n\tif (wifi_creds == 0) {\n\t\t// Connect using default credentials\n\t\tif (m2m_wifi_default_connect() == M2M_SUCCESS) {\n\t\t\tsuccess = true;\n\t\t} else {\n\t\t\tlog_printf(\"WiFi connection failed. Attempting to connect using new credentials.\n\");\n\t\t}\n\t} else {\n\t\t// Connect using new credentials\n\t\tif (m2m_wifi_connect(wifi_creds.ssid, wifi_creds.ssid_len, wifi_creds.security, wifi_creds.password, wifi_creds.channel) == M2M_SUCCESS) {\n\t\t\tsuccess = true;\n\t\t} else {\n\t\t\tlog_printf(\"WiFi connection failed. Attempting to connect using default credentials.\n\");\n\t\t}\n\t}\n\n\tif (!success) {\n\t\t// Connection failed\n\t\tlog_printf(\"WiFi connection failed.\n\");\n\t\twifi_error = true;\n\t}\n\n\treturn success;\n}", "CodeBleu_score": 36.42621783866167}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tuint8_t wifi_creds_type = 0;\n\tuint8_t wifi_creds_pass[64];\n\tuint8_t wifi_creds_ssid[32];\n\tuint8_t wifi_creds_pass_len = 0;\n\tuint8_t wifi_creds_ssid_len = 0;\n\tuint8_t wifi_creds_sec_type = 0;\n\tuint8_t wifi_creds_ch = 0;\n\tuint8_t wifi_creds_sec_type_len = 0;\n\tuint8_t wifi_creds_ch_len = 0;\n\n\tif (passed_wifi_creds) {\n\t\twifi_creds_type = 0;\n\t} else {\n\t\twifi_creds_type = 1;\n\t}\n\n\tif (wifi_creds_type == 0) {\n\t\twifi_creds_ssid_len = strlen(wifi_creds_ssid);\n\t\twifi_creds_pass_len = strlen(wifi_creds_pass);\n\t\twifi_creds_sec_type_len = strlen(wifi_creds_sec_type);\n\t\twifi_creds_ch_len = strlen(wifi_creds_ch);\n\t}\n\n\tif (wifi_creds_type == 0) {\n\t\tm2m_wifi_connect(wifi_creds_ssid, wifi_creds_ssid_len, wifi_creds_sec_type, wifi_creds_pass, wifi_creds_ch);\n\t} else {\n\t\tm2m_wifi_default_connect();\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 37.30140882321146}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif (passed_wifi_creds) {\n\t\treturn wifi_connectToApWithCreds(wifi_ssid, wifi_password, wifi_security);\n\t} else {\n\t\treturn wifi_connectToApWithDefaults();\n\t}\n}", "CodeBleu_score": 24.266023295873612}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t\t// Create a new client to communicate with the API.\n\tconst client = new ApolloClient({\n\t\turi: 'https://api.graph.cool/simple/v1/cjm31z489000012q10668678',\n\t});\n\n\t// Create a GraphQL query to retrieve sensor data from the API.\n\tconst query = gql`\n\t\tquery {\n\t\t\tallSensors {\n\t\t\t\tid\n\t\t\t\tlat\n\t\t\t\tlng\n\t\t\t}\n\t\t}\n\t`;\n\n\t// Send the query to the API and retrieve the response.\n\tconst response = await client.query({ query });\n\n\t// Log the response.\n\tconsole.log(response);\n\n\t// If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker.\n\tif (response.data) {\n\t\tconsole.log('Retrieved sensors:');\n\n\t\tresponse.data.allSensors.forEach((sensor) => {\n\t\t\tconst marker = new google.maps.Marker({\n\t\t\t\tposition: {\n\t\t\t\t\tlat: sensor.lat,\n\t\t\t\t\tlng: sensor.lng,\n\t\t\t\t},\n\t\t\t\tmap,\n\t\t\t\ttitle: `Sensor ${sensor.id}`,\n\t\t\t});\n\n\t\t\t// Add a listener to the marker to display a popup when clicked.\n\t\t\tmarker.addListener('click', () => {\n\t\t\t\tconst popup = new google.maps.InfoWindow({\n\t\t\t\t\tcontent: `Sensor ${sensor.id}`,\n\t\t\t\t});\n\n\t\t\t\tpopup.open(map, marker);\n\t\t\t});\n\t\t});\n\t}\n}", "CodeBleu_score": 36.07703980405436}, {"code": "async function DisplaySensors(map){\n\t\ttry {\n\t\tconst client = new ApolloClient({\n\t\t\tcache: new InMemoryCache(),\n\t\t\tlink: new HttpLink({\n\t\t\t\turi: \"https://api.graph.cool/simple/v1/cjt919840004d01365205120a\",\n\t\t\t}),\n\t\t});\n\n\t\tconst { data } = await client.query({\n\t\t\tquery: gql`\n\t\t\t\tquery {\n\t\t\t\t\tsensors {\n\t\t\t\t\t\tid\n\t\t\t\t\t\tname\n\t\t\t\t\t\tlatitude\n\t\t\t\t\t\tlongitude\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t});\n\n\t\tconsole.log(\"Retrieved sensors: \" + data.sensors.length);\n\n\t\tdata.sensors.forEach(function(sensor) {\n\t\t\tconst marker = new google.maps.Marker({\n\t\t\t\tposition: {\n\t\t\t\t\tlat: sensor.latitude,\n\t\t\t\t\tlng: sensor.longitude,\n\t\t\t\t},\n\t\t\t\tmap,\n\t\t\t\ttitle: sensor.name,\n\t\t\t});\n\t\t});\n\t} catch (error) {\n\t\tconsole.log(\"Error retrieving sensors: \" + error);\n\t}\n}", "CodeBleu_score": 31.043848275681015}, {"code": "async function DisplaySensors(map){\n\t\tconst client = new GraphQLClient(API_URL, {\n\t\theaders: {\n\t\t\t\"x-hasura-admin-secret\": API_KEY,\n\t\t},\n\t});\n\n\tconst query = `query {\n\t\tsensors {\n\t\t\tid\n\t\t\tname\n\t\t\tlatitude\n\t\t\tlongitude\n\t\t}\n\t}`;\n\n\tconst response = await client.request(query);\n\tconsole.log(response);\n\n\tif (response.sensors.length > 0) {\n\t\tconsole.log(\"Retrieved sensors: \");\n\t\tresponse.sensors.forEach((sensor) => {\n\t\t\tconsole.log(sensor);\n\t\t\tconst marker = new google.maps.Marker({\n\t\t\t\tposition: { lat: sensor.latitude, lng: sensor.longitude },\n\t\t\t\tmap: map,\n\t\t\t\ttitle: sensor.name,\n\t\t\t});\n\t\t});\n\t}\n}", "CodeBleu_score": 38.39876245625486}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.border = '2px solid'+ sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 48.280236738260726}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 45.95514478587068}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.border = \"2px solid #000000\";\n\treturn marker;\n}", "CodeBleu_score": 45.78544137630784}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        if err.name!= module_path:\n            raise\n        _LOGGER.error(\"Unable to import MFA module: %s\", module_path)\n        raise\n    except Exception as err:  # pylint: disable=broad-except\n        _LOGGER.error(\"Unable to import MFA module: %s\", module_path)\n        _LOGGER.exception(err)\n        raise\n    if module.REQUIREMENTS:\n        if not hass.config.skip_pip:\n            for requirement in module.REQUIREMENTS:\n                if requirement not in hass.data.get(DATA_REQUIREMENTS, []):\n                    hass.data.setdefault(DATA_REQUIREMENTS, []).append(requirement)\n                    try:\n                        await hass.async_add_executor_job(\n                            pip_install, requirement, hass.config.skip_pip\n                        )\n                    except Exception as err:  # pylint: disable=broad-except\n                        _LOGGER.error(\n                            \"Unable to install MFA module requirement: %s\", requirement\n                        )\n                        _LOGGER.exception(err)\n                        raise\n        else:\n            _LOGGER.warning(\n                \"Skipping MFA module requirement installation for %s because pip is disabled.\",\n                module_path,\n            )\n    return module\n\n", "CodeBleu_score": 40.735445716905694}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    # Construct the module path\n    module_path = f\"homeassistant.components.{module_name}\"\n    # Attempt to import the module\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError as error:\n        # Log and raise an error if the import fails\n        _LOGGER.error(\"Failed to import MFA module %s\", module_name)\n        raise error\n    # Check if the module has requirements\n    if hasattr(module, \"REQUIREMENTS\"):\n        requirements = module.REQUIREMENTS\n        # Check if pip installation is skipped\n        if not hass.config.skip_pip:\n            # Process the requirements if not already processed\n            if not hass.data.get(DATA_REQUIREMENTS_PROCESSED, False):\n                # Process the requirements\n                hass.async_create_task(\n                    hass.config_entries.async_forward_entry_setup(\n                        hass.data[MFA_CONFIG_ENTRY], \"mfa\"\n                    )\n                )\n                hass.data[DATA_REQUIREMENTS_PROCESSED] = True\n            # Check if the requirements have already been installed\n            if not hass.data.get(DATA_REQUIREMENTS_INSTALLED, False):\n                # Install the requirements\n                hass.async_create_task(\n                    hass.config_entries.async_forward_entry_setup(\n                        hass.data[MFA_CONFIG_ENTRY], \"mfa\"\n                    )\n                )\n                hass.data[DATA_REQUIREMENTS_INSTALLED] = True\n        else:\n            _LOGGER.warning(\n                \"Skipping pip installation of MFA module requirements for %s\",\n                module_name,\n            )\n    # Return the loaded module\n    return module\n", "CodeBleu_score": 35.62808851085902}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        mfa_module = importlib.import_module(module_path)\n    except ModuleNotFoundError as err:\n        if module_path in _mfa_modules_processed:\n            raise\n        _mfa_modules_processed.add(module_path)\n        if not _skip_pip_install:\n            _process_mfa_requirements(module_name)\n        raise err\n    return mfa_module", "CodeBleu_score": 26.37999078003357}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    self.setup_data = setup_data\n    self.user_id = user_id\n    self.pin = self.setup_data[\"pin\"]\n    self.data = self.hass.data[DOMAIN]\n    if self.data[self.user_id]:\n        self.data[self.user_id][\"pin\"] = self.pin\n    else:\n        self.data[self.user_id] = {\"pin\": self.pin}\n\n", "CodeBleu_score": 32.355349409628}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Extract the PIN from the setup data\n    pin = setup_data[\"pin\"]\n    # Check if the user already has an entry in the internal data list\n    if user_id in self.data:\n        # Update the PIN for the user\n        self.data[user_id][\"pin\"] = pin\n    else:\n        # Add a new entry for the user with the PIN\n        self.data[user_id] = {\"pin\": pin}\n    # Return the setup data\n    return setup_data\n\n", "CodeBleu_score": 37.50703108130836}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data\n    else:\n        self.data[user_id] = {\"pin\": setup_data}\n\n", "CodeBleu_score": 30.07497099649974}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    if self._initialized:\n        return\n    await self._init_lock.acquire()\n    try:\n        if self._initialized:\n            return\n        if not (data := await self._store.async_load()):\n            data = {}\n        self._data = data\n        self._initialized = True\n    finally:\n        self._init_lock.release()\n\n", "CodeBleu_score": 25.969354602155576}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._settings:\n            return\n\n        if data := await self._store.async_load():\n            self._settings = {\n                user: NotifySetting(self, user, data.get(user, {}))\n                for user in data\n            }\n        else:\n            self._settings = {}\n\n", "CodeBleu_score": 37.32520823133468}, {"code": "async def _async_load(self) -> None\n\t\n    if self._async_load_lock.locked():\n        return\n\n    async with self._async_load_lock:\n        if self._user_settings:\n            return\n\n        if not (data := await self._store.async_load()):\n            self._user_settings = {}\n            return\n\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id=user_id,\n                data=data.get(user_id),\n                notify_service=self._notify_service,\n            )\n            for user_id in data\n        }\n\n", "CodeBleu_score": 39.22264691151708}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self.hass is None:\n        return False\n\n    # Load user settings\n    user_settings = await self.hass.async_add_executor_job(\n        self._get_user_settings, user_id\n    )\n    if user_settings is None:\n        return False\n\n    # Retrieve notification settings\n    notification_settings = user_settings.get(NOTIFICATION_SETTINGS)\n    if notification_settings is None:\n        return False\n\n    # Validate OTP\n    otp_code = user_input.get(OTP_CODE)\n    if otp_code is None:\n        return False\n\n    otp_executor = self._get_otp_executor(notification_settings)\n    if otp_executor is None:\n        return False\n\n    otp_executor_job = await self.hass.async_add_executor_job(\n        otp_executor.validate, otp_code\n    )\n    if not otp_executor_job:\n        return False\n\n    return True", "CodeBleu_score": 45.39642577009404}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    # Check if user settings are loaded\n    if not self._user_settings:\n        await self._load_user_settings()\n\n    # Retrieve the notification settings for the user\n    notification_settings = self._user_settings.get(user_id, {})\n\n    # Validate the user input\n    if notification_settings:\n        # Get the OTP from the user input\n        otp = user_input.get(\"otp\")\n\n        # Check if the OTP is valid\n        if otp and self._executor:\n            # Create an executor job to validate the OTP\n            job = self._executor.submit(self._validate_otp, otp)\n\n            # Wait for the executor job to complete\n            result = await job.result()\n\n            # Return True if the OTP is valid\n            return result\n        else:\n            # Return False if the OTP is not valid\n            return False\n    else:\n        # Return False if no settings are found for the user\n        return False", "CodeBleu_score": 46.59737057558155}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if self._user_settings.get(user_id) is None:\n        # Load user settings if not already loaded\n        await self._user_settings.load_user_settings(user_id)\n\n    # Retrieve notification settings for the user\n    notification_settings = self._user_settings.get(user_id)\n    if notification_settings is None:\n        return False\n\n    # Validate the OTP using an executor job\n    await self._executor.submit_job(\n        \"validate_otp\",\n        user_id=user_id,\n        user_input=user_input,\n        notification_settings=notification_settings,\n    )\n\n    return True", "CodeBleu_score": 54.02817373980804}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n\n    area_id = device.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.390134801419954}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity[\"device_id\"])\n    if device is None or \"area_id\" not in device:\n        return None\n    area_id = device[\"area_id\"]\n    if area_id not in area_dict:\n        return None\n    return area_dict[area_id]\n\n", "CodeBleu_score": 52.245674858810396}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device_id = entity.device_id\n    device = perm_lookup.get_device(device_id)\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id, None)\n\n", "CodeBleu_score": 47.674611233137675}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    # When merging policies, the most permissive wins.\n    # This means we order it like this:\n    # True > Dict > None\n    #\n    # True: allow everything\n    # Dict: specify more granular permissions\n    # None: no opinion\n    #\n    # If there are multiple sources with a dict as policy, we recursively\n    # merge each key in the source.\n\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for source in policies:\n        if source is None:\n            continue\n\n        # A source that's True will always win. Shortcut return.\n        if source is True:\n            return True\n\n        assert isinstance(source, dict)\n\n        for key in source:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [src.get(key) for src in policies if isinstance(src, dict)]\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy\n\n", "CodeBleu_score": 50.28627496653071}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for p in policies:\n        for category, value in p.items():\n            if category in seen:\n                continue\n            seen.add(category)\n            policy[category] = _merge_policies([p.get(category), value])\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 55.099840302434785}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_dict in policies:\n        if policy_dict is None:\n            continue\n\n        assert isinstance(policy_dict, dict)\n\n        for category in policy_dict:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            policy[category] = _merge_policies(\n                [policy_dict[category], policy.get(category)]\n            )\n\n    return cast(PolicyType, policy)", "CodeBleu_score": 57.74915327268012}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        if err.name == provider:\n            raise HomeAssistantError(\n                f\"Could not find module {provider} for authentication provider\"\n            ) from err\n        raise HomeAssistantError(\n            f\"Could not find module {provider} for authentication provider, {err.name} was not found\"\n        ) from err\n\n    if not hasattr(module, \"AUTH_PROVIDERS\"):\n        return module\n\n    requirements = set(module.AUTH_PROVIDERS)\n    if not requirements:\n        return module\n\n    if not await async_check_requirements(hass, requirements):\n        raise HomeAssistantError(\n            f\"Could not find module {provider} for authentication provider, \"\n            f\"missing requirements: {', '.join(requirements)}\"\n        )\n\n    hass.data[DATA_AUTH_PROVIDERS].update(requirements)\n    return module", "CodeBleu_score": 38.48754612022942}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Error loading authentication provider %s: %s\", provider, err\n        )\n        raise HomeAssistantError(\n            \"Error loading authentication provider %s: %s\", provider, err\n        ) from err\n\n    # If the module has no additional requirements or the requirements should be skipped, return the module.\n    if not hasattr(module, \"AUTH_PROVIDER_REQUIREMENTS\"):\n        return module\n\n    # Process the module's requirements and update the processed requirements set.\n    requirements = set(module.AUTH_PROVIDER_REQUIREMENTS)\n    processed.update(requirements)\n\n    # Import the requirements.\n    for requirement in requirements:\n        try:\n            await async_import_module(hass, requirement)\n        except ModuleNotFoundError as err:\n            _LOGGER.error(\n                \"Error loading authentication provider %s: %s\", provider, err\n            )\n            raise HomeAssistantError(\n                \"Error loading authentication provider %s: %s\", provider, err\n            ) from err\n\n    return module\n", "CodeBleu_score": 39.237095259721286}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as err:\n        raise HomeAssistantError(\n            f\"Unable to load authentication provider module '{provider}': {err}\"\n        ) from err\n    except Exception as err:\n        raise HomeAssistantError(\n            f\"Unable to load authentication provider module '{provider}': {err}\"\n        ) from err\n\n    if not hasattr(module, \"AUTH_PROVIDERS\"):\n        return module\n\n    # If the module has no requirements, return the module\n    if not module.AUTH_PROVIDERS:\n        return module\n\n    # If the module has requirements, process them\n    requirements = process_requirements(module.AUTH_PROVIDERS)\n\n    # Update the processed requirements set\n    processed.update(requirements)\n\n    return module\n\n", "CodeBleu_score": 41.5348938044311}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    self.username = username.lower()\n    self.password = password.lower()\n    self.dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == self.username:\n            self.stored_hash = user.password_hash\n            if bcrypt.checkpw(self.password.encode(\"utf-8\"), self.stored_hash.encode(\"utf-8\")):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    raise InvalidAuth(\"Invalid username\")\n\n", "CodeBleu_score": 36.912266081225475}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            if bcrypt.checkpw(password.encode(), user[\"password\"].encode()):\n                return\n            else:\n                if bcrypt.checkpw(dummy_hash, user[\"password\"].encode()):\n                    raise InvalidAuth\n                else:\n                    raise InvalidAuth\n    raise InvalidAuth\n\n", "CodeBleu_score": 38.05129871298881}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    # normalize username\n    username = username.lower()\n\n    # initialize dummy hash\n    dummy_hash = bcrypt.gensalt()\n\n    # iterate through all users\n    for user in self.users:\n        # if username matches, check password\n        if user.username == username:\n            if bcrypt.checkpw(password.encode('utf-8'), user.password.encode('utf-8')):\n                return\n            else:\n                raise InvalidAuth()\n\n    # if no matching user is found, perform dummy hash check\n    if bcrypt.checkpw(password.encode('utf-8'), dummy_hash):\n        return\n    else:\n        raise InvalidAuth()\n\n", "CodeBleu_score": 35.08337389244572}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    try:\n        self.users.remove(username)\n    except ValueError:\n        raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 16.66725486221919}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 26.007322982359536}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 26.007322982359536}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.async_initialized:\n        await self.async_initialize()\n    try:\n        self._data.pop(credentials.username)\n        await self.async_save()\n    except KeyError:\n        pass\n", "CodeBleu_score": 46.270248128553305}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._initialized:\n        await self._initialize()\n    try:\n        await self._store.async_remove_credentials(credentials)\n    except InvalidAuth:\n        _LOGGER.debug(\"Ignoring invalid auth for %s\", credentials)\n\n", "CodeBleu_score": 44.42888796255614}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n    try:\n        await self._store.async_remove(credentials.username)\n    except InvalidUsername:\n        pass", "CodeBleu_score": 48.23942997031637}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        thread_timeout = timeout - (time.monotonic() - thread.start_time)\n        if thread_timeout <= 0:\n            _LOGGER.warning(\"Thread[%s] is taking too long to join.\", thread.name)\n            joined.add(thread)\n            continue\n        try:\n            thread.join(thread_timeout)\n        except RuntimeError:\n            _LOGGER.warning(\"Thread[%s] is no longer alive.\", thread.name)\n            joined.add(thread)\n            continue\n        except (KeyboardInterrupt, SystemExit):\n            _LOGGER.warning(\"Thread[%s] was interrupted.\", thread.name)\n            joined.add(thread)\n            continue\n        except Exception:  # noqa: BLE001\n            _LOGGER.exception(\"Thread[%s] failed to join.\", thread.name)\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    for thread in threads:\n        if thread not in joined:\n            try:\n                thread.interrupt()\n            except RuntimeError:\n                _LOGGER.warning(\"Thread[%s] is no longer alive.\", thread.name)\n                joined.add(thread)\n                continue\n            except (KeyboardInterrupt, SystemExit):\n                _LOGGER.warning(\"Thread[%s] was interrupted.\", thread.name)\n                joined.add(thread)\n                continue\n            except Exception:  # noqa: BLE001\n                _LOGGER.exception(\"Thread[%s] failed to interrupt.\", thread.name)\n                joined.add(thread)\n                continue\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n    return joined\n\n", "CodeBleu_score": 48.14736033420801}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout=timeout)\n        except RuntimeError:\n            pass\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            try:\n                thread.raise_exception(SystemExit)\n            except RuntimeError:\n                pass\n            thread.join()\n        else:\n            joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 49.40749185470763}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    # Calculate the timeout for each thread\n    timeout_per_thread = timeout / len(threads)\n\n    # Join or interrupt each thread\n    joined_threads = set()\n    for thread in threads:\n        if thread.is_alive():\n            try:\n                thread.join(timeout_per_thread)\n            except TimeoutError:\n                # Interrupt the thread if it is still alive\n                if thread.is_alive():\n                    thread.interrupt_main()\n            if thread.is_alive():\n                # Add the thread to the set of joined threads if it is still alive\n                joined_threads.add(thread)\n\n    # Log threads that are still running at shutdown\n    if log:\n        for thread in threads - joined_threads:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n\n    # Raise a SystemExit exception in any remaining threads\n    for thread in threads - joined_threads:\n        thread.interrupt_main()\n\n    return joined_threads\n\n", "CodeBleu_score": 45.70831948141089}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Identify all non-main, non-daemon, alive threads\n    non_main_threads = [thread for thread in threading.enumerate() if not thread.is_alive() or thread.daemon or thread.name == \"MainThread\"]\n\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = shutdown_timeout / len(non_main_threads)\n\n    # Attempt to join each thread within the calculated timeout\n    for thread in non_main_threads:\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            logging.warning(f\"Failed to join thread {thread.name} during shutdown\")\n\n", "CodeBleu_score": 28.157862368768193}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get all non-main, non-daemon, alive threads\n    threads = [t for t in threading.enumerate() if t.name!= \"MainThread\" and not t.daemon and t.is_alive()]\n\n    # Calculate the timeout for each thread based on the total shutdown timeout\n    timeout = time.time() + SHUTDOWN_TIMEOUT\n    for thread in threads:\n        timeout = min(timeout, time.time() + SHUTDOWN_TIMEOUT / len(threads))\n\n    # Attempt to join each thread within the calculated timeout\n    for thread in threads:\n        try:\n            thread.join(timeout - time.time())\n        except RuntimeError:\n            # Ignore join failures due to the thread already being dead\n            pass\n\n    # Log a warning if any thread failed to join\n    if any(thread.is_alive() for thread in threads):\n        logger.warning(\"Failed to join all threads during shutdown\")\n\n", "CodeBleu_score": 31.964920289898618}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # The function \"deadlock_safe_shutdown\" performs a shutdown that avoids deadlocks.\n    # It identifies all non-main, non-daemon, alive threads and calculates a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads.\n    # It then attempts to join each thread within the calculated timeout and logs a warning if joining a thread fails.\n    # This function is intended to be used as a replacement for the standard library function \"threading.shutdown_async\" to avoid deadlocks.\n    # The \"deadlock_safe_shutdown\" function should be called at the end of the program to ensure that all threads have been joined and the program can safely exit.\n    # The \"deadlock_safe_shutdown\" function is intended to be used in situations where threads are being created and destroyed frequently, and deadlocks are possible.\n    # By calculating a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads, the \"deadlock_safe_shutdown\" function avoids deadlocks by ensuring that all threads have a chance to join within the calculated timeout.\n    # The \"deadlock_safe_shutdown\" function logs a warning if joining a thread fails. This allows the program to continue running even if some threads are unable to join within the calculated timeout.\n    # This function is useful in situations where threads are being created and destroyed frequently, and deadlocks are possible.\n\n    # Get the current time\n    current_time = time.time()\n\n    # Get a list of all non-main, non-daemon, alive threads\n    all_threads = threading.enumerate()\n    non_main_threads = [thread for thread in all_threads if thread.name!= \"MainThread\" and not thread.daemon]\n\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = total_shutdown_timeout / len(non_main_threads)\n\n    # Attempt to join each thread within the calculated timeout\n    for thread in non_main_threads:\n        try:\n            thread.join(timeout=timeout)\n        except RuntimeError:\n            logger.warning(f\"Thread {thread.name} failed to join within timeout of {timeout} seconds.\")\n\n", "CodeBleu_score": 25.807043144506732}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self.hass.bus.async_fire(DISPATCH_SIGNAL, {\"remaining_with_setup_started\": remaining_with_setup_started})\n    self.hass.data[DATA_SETUP_STARTED] = bool(remaining_with_setup_started)\n\n\n def _async_handle_setup_started(self, event: Event) -> None:\n    \"\"\"The function \"_async_handle_setup_started\" handles the internal dispatcher signal.", "CodeBleu_score": 41.78874231110545}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n      self._dispatch(remaining_with_setup_started)\n      self._remaining_setups = remaining_with_setup_started\n      self._has_remaining_setups = True\n    else:\n      self._has_remaining_setups = False\n      self._dispatch({})\n\n def _async_dispatch_all(self) -> None:\n    \"\"\"The function \"_async_dispatch_all\" dispatches a signal with all remaining setups.", "CodeBleu_score": 38.45337930288768}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if len(remaining_with_setup_started) > 0:\n        self.send(Signal(self.SIGNAL_DISPATCHER, remaining_with_setup_started))\n    self._has_remaining_setups = len(remaining_with_setup_started) > 0\n\n\n def _async_dispatch_setup_finished(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_setup_finished\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 49.38318293051624}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.get(\"bluetooth\", None) is None:\n        config[\"bluetooth\"] = []\n\n    if config.get(\"bluetooth_device_tracker\", None) is None:\n        config[\"bluetooth_device_tracker\"] = []\n\n    if config.get(\"bluetooth_le_tracker\", None) is None:\n        config[\"bluetooth_le_tracker\"] = []\n\n    if config.get(\"bluetooth_tracker\", None) is None:\n        config[\"bluetooth_tracker\"] = []\n\n    if config.get(\"bluetooth_tracker_legacy\", None) is None:\n        config[\"bluetooth_tracker_legacy\"] = []\n\n    if config.get(\"bluetooth_tracker_legacy_legacy\", None) is None:\n        config[\"bluetooth_tracker_legacy_legacy\"] = []\n\n    if config.get(\"bluetooth_tracker_legacy_legacy_legacy\", None) is None:\n        config[\"bluetooth_tracker_legacy_legacy_legacy\"] = []\n\n    if config.get(\"bluetooth_tracker_legacy_legacy_legacy_legacy\", None) is None:\n        config[\"bluetooth_tracker_legacy_legacy_legacy_legacy\"] = []\n\n    if config.get(\"bluetooth_tracker_legacy_legacy_legacy_legacy_legacy\", None) is None:\n        config[\"bluetooth_tracker_legacy_legacy_legacy_legacy_legacy\"] = []\n\n    if config.get(\"bluetooth_tracker_legacy_legacy_legacy_legacy_legacy_legacy\", None) is None:\n        config[\"bluetooth_tracker_legacy_legacy_legacy_legacy_legacy_legacy\"] = []\n\n    if config.get(\"bluetooth_tracker_legacy_legacy_legacy_legacy_legacy_legacy_legacy\", None) is None:\n        config[\"bluetooth_tracker_legacy_legacy_legacy_legacy_legacy_legacy_legacy\"] = []\n\n    if config.get(\"bluetooth_tracker_legacy_legacy_legacy_legacy_legacy_legacy_legacy_legacy\", None) is None:\n        config[\"bluetooth_tracker_legacy_legacy_legacy_legacy_legacy_legacy_legacy_legacy\"] = []\n\n    if config.get(\"bluetooth_tracker_legacy_legacy_legacy_legacy_legacy_legacy_legacy_legacy_legacy\", None) is None:\n        config[\"bluetooth_tracker_legacy_legacy_legacy_legacy_legacy_legacy_legacy_legacy_legacy\"] = []\n\n    if config.get(\"bluetooth_tracker_legacy_legacy_legacy_", "CodeBleu_score": 18.9794939242427}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    try:\n        # Generate the bluetooth.py content\n        bluetooth_content = generate_and_validate(integrations)\n\n        # Check if the bluetooth.py content has changed\n        if bluetooth_content!= config.bluetooth_content:\n            # Add an error to the configuration\n            config.add_error(\n                \"bluetooth.py\",\n                \"bluetooth.py is not up to date. Please run `ha generate bluetooth` to update it.\",\n            )\n\n            # Add a suggestion to the configuration\n            config.add_suggestion(\n                \"bluetooth.py\",\n                \"bluetooth.py is not up to date. Please run `ha generate bluetooth` to update it.\",\n                \"ha generate bluetooth\",\n            )\n\n        # Save the bluetooth.py content to the configuration\n        config.bluetooth_content = bluetooth_content\n    except Exception as err:\n        # Add an error to the configuration\n        config.add_error(\n            \"bluetooth.py\",\n            f\"Failed to generate bluetooth.py. Please check the logs for more information: {err}\",\n        )\n\n        # Add a suggestion to the configuration\n        config.add_suggestion(\n            \"bluetooth.py\",\n            \"Failed to generate bluetooth.py. Please check the logs for more information.\",\n            \"ha generate bluetooth\",\n        )", "CodeBleu_score": 31.066140282269483}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.bluetooth:\n        return\n\n    if not integrations:\n        return\n\n    if config.bluetooth.get(\"bluetooth\", None) is None:\n        config.bluetooth = {\"bluetooth\": []}\n\n    if config.bluetooth.get(\"bluetooth\", None) is not None:\n        # Validate bluetooth.py\n        if config.bluetooth.get(\"bluetooth\", None)!= generate_and_validate(integrations):\n            config.errors.append(\n                \"bluetooth.py is not up to date. Please run `ha generate bluetooth` to update it.\"\n            )\n            return\n\n    # Validate bluetooth.py\n    if config.bluetooth.get(\"bluetooth\", None) is None:\n        config.bluetooth = {\"bluetooth\": []}\n\n    if config.bluetooth.get(\"bluetooth\", None)!= generate_and_validate(integrations):\n        config.errors.append(\n            \"bluetooth.py is not up to date. Please run `ha generate bluetooth` to update it.\"\n        )\n\n", "CodeBleu_score": 34.916033330429656}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t", "CodeBleu_score": 1.0616887050097763}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropboxapi.com/oauth2/token\"\n\tdata := url.Values{}\n\tdata.Add(\"grant_type\", \"refresh_token\")\n\tdata.Add(\"refresh_token\", d.RefreshToken)\n\tdata.Add(\"client_id\", d.AppKey)\n\tdata.Add(\"client_secret\", d.AppSecret)\n\n\treq, err := http.NewRequest(\"POST\", url, strings.NewReader(data.Encode()))\n\tif err!= nil {\n\t\treturn err\n\t}\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Add(\"Content-Length\", strconv.Itoa(len(data.Encode())))\n\n\tresp, err := d.Client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"failed to refresh token: %s\", resp.Status)\n\t}\n\n\tvar token oauth2.Token\n\terr = json.NewDecoder(resp.Body).Decode(&token)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\td.AccessToken = token.AccessToken\n\treturn nil\n}", "CodeBleu_score": 49.98408061527616}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Send the request\n\tres, err := d.post(d.oauth2TokenEndpoint, map[string]string{\n\t\t\"grant_type\":    \"refresh_token\",\n\t\t\"refresh_token\": d.refreshToken,\n\t\t\"client_id\":     d.appKey,\n\t\t\"client_secret\": d.appSecret,\n\t})\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Decode the response\n\tvar oauth2Response Oauth2Response\n\terr = json.Unmarshal(res, &oauth2Response)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Update the access token\n\td.accessToken = oauth2Response.AccessToken\n\n\treturn nil\n}", "CodeBleu_score": 44.73703351292738}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// Create the request.\n\treq, err := http.NewRequest(method, url, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the authorization header.\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\n\t// Set the parameters for supporting all drives.\n\tq := req.URL.Query()\n\tq.Add(\"supportsAllDrives\", \"true\")\n\treq.URL.RawQuery = q.Encode()\n\n\t// If a callback is provided, customize the request.\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\n\t// Send the request.\n\trespBody, err := d.Client.Do(req)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tdefer respBody.Body.Close()\n\n\t// If the response structure is provided, set the request result.\n\tif resp!= nil {\n\t\terr = json.NewDecoder(respBody.Body).Decode(resp)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If the response is an error, handle the error.\n\tif respBody.StatusCode == http.StatusUnauthorized {\n\t\t// Refresh the token and retry the request.\n\t\terr = d.refreshToken()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\t// Return the response body.\n\tbody, err := ioutil.ReadAll(respBody.Body)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn body, nil\n}", "CodeBleu_score": 55.95861363199026}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar (\n\t\terr  error\n\t\trespBody []byte\n\t\trespCode int\n\t)\n\n\t// Set the authorization header with the access token\n\treq := d.client.R().SetAuthToken(d.accessToken)\n\n\t// Include parameters for supporting all drives\n\treq.SetQueryParams(map[string]string{\n\t\t\"supportsAllDrives\": \"true\",\n\t})\n\n\t// If a callback is provided, customize the request\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\n\t// Send the request\n\trespBody, respCode, err = req.Execute().Raw()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// If a response structure is provided, set the request result\n\tif resp!= nil {\n\t\terr = json.Unmarshal(respBody, resp)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If a 401 error occurs, refresh the token and retry the request\n\tif respCode == http.StatusUnauthorized {\n\t\terr = d.refreshToken()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trespBody, respCode, err = req.Execute().Raw()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif resp!= nil {\n\t\t\terr = json.Unmarshal(respBody, resp)\n\t\t\tif err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn respBody, nil\n}", "CodeBleu_score": 47.419668785487666}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tconst chunkSize = 5 * 1024 * 1024\n\tvar (\n\t\toffset int64\n\t\tbuf    = make([]byte, chunkSize)\n\t)\n\tfor {\n\t\tn, err := stream.ReadAt(buf, offset)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif n == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif _, err := d.uploadChunk(ctx, buf[:n], url, offset); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\toffset += int64(n)\n\t}\n\treturn nil\n}", "CodeBleu_score": 34.55014402310155}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Get the file size.\n\tsize, err := stream.Size()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Calculate the chunk size.\n\tchunkSize := d.chunkSize\n\tif chunkSize == 0 {\n\t\tchunkSize = DefaultChunkSize\n\t}\n\tif chunkSize > size {\n\t\tchunkSize = size\n\t}\n\n\t// Upload the file in chunks.\n\tfor offset := int64(0); offset < size; offset += chunkSize {\n\t\t// Calculate the chunk size.\n\t\tend := offset + chunkSize\n\t\tif end > size {\n\t\t\tend = size\n\t\t}\n\n\t\t// Create a request to upload the chunk.\n\t\treq, err := http.NewRequest(\"PUT\", url, nil)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\treq.ContentLength = end - offset\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, end-1, size))\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\n\t\t// Read the chunk from the stream.\n\t\tbuf := make([]byte, end-offset)\n\t\t_, err = stream.ReadAt(buf, offset)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Send the request.\n\t\tresp, err := d.client.Do(req.WithContext(ctx))\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// Check for cancellation.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Check for errors.\n\t\tif resp.StatusCode!= http.StatusCreated {\n\t\t\treturn fmt.Errorf(\"upload error: %s\", resp.Status)\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.66865408305337}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar storage Storage\n\tif err := ctx.Bind(&storage); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\tif storage.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"mount point is empty\")\n\t}\n\tif err := UnmountStorage(storage.MountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\tif err := DeleteStorage(storage.MountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\treturn ctx.JSON(http.StatusOK, \"unmounted storage\")\n}", "CodeBleu_score": 30.341412544959645}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Retrieve the mount point from the request context.\n\tmountPoint := ctx.Get(\"mount_point\").(string)\n\n\t// If the mount point is empty, return a client error response.\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"mount_point is empty\",\n\t\t})\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point.\n\terr := utils.UnmountStorage(mountPoint)\n\n\t// If unmounting fails, return a service error response.\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\t// Delete the corresponding configuration.\n\terr = config.DeleteStorageConfig(mountPoint)\n\n\t// If deleting the configuration fails, return a service error response.\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]string{\n\t\t\"message\": \"storage unmounted\",\n\t})\n}", "CodeBleu_score": 35.475500439787474}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// get request data\n\treqData, err := getRequestData(ctx)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// get mount point\n\tmountPoint := reqData[\"mount_point\"].(string)\n\tif mountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"mount point is empty\")\n\t}\n\t// attempt to unmount the storage\n\tif err := storage.Unmount(mountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\t// delete the corresponding configuration\n\tif err := storage.DeleteConfig(mountPoint); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\t// return success response\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 36.899402056229505}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"file\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\"error\": \"File path is missing\",\n\t\t})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, gin.H{\n\t\t\t\"error\": \"File not found\",\n\t\t})\n\t}\n\n\t// Read the file\n\tfile, err := os.Open(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\"error\": \"Failed to read file\",\n\t\t})\n\t}\n\tdefer file.Close()\n\n\t// Send the file to the client\n\tctx.Response().Header().Set(\"Content-Disposition\", \"attachment; filename=\\\"\"+filepath.Base(filePath)+\"\\\"\")\n\tctx.Response().Header().Set(\"Content-Type\", \"application/octet-stream\")\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 35.6568640294418}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"File path not provided\")\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"File does not exist\")\n\t}\n\n\t// Open the file\n\tfile, err := os.Open(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Error opening file\")\n\t}\n\tdefer file.Close()\n\n\t// Get the file size\n\tfileInfo, err := file.Stat()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Error getting file info\")\n\t}\n\n\t// Set the response headers\n\tctx.Response().Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tctx.Response().Header().Set(\"Content-Disposition\", \"attachment; filename=\"+filepath.Base(filePath))\n\tctx.Response().Header().Set(\"Content-Length\", strconv.FormatInt(fileInfo.Size(), 10))\n\n\t// Copy the file to the response\n\t_, err = io.Copy(ctx.Response().Writer, file)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Error copying file to response\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 35.399636425163195}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided.\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"File path not provided.\"})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(filePath); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"File not found.\"})\n\t}\n\n\t// Read the file and return it to the client.\n\tfile, err := os.Open(filePath)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Internal server error.\"})\n\t}\n\tdefer file.Close()\n\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 36.064800068146155}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]interface{}\n\tname := ctx.Param(\"name\")\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\tif err := notify.Send(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\": \"notification sent\",\n\t})\n}", "CodeBleu_score": 49.332744821387095}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]interface{}\n\tname := ctx.Param(\"name\")\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": err.Error()})\n\t}\n\tif err := notification.SendNotification(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"success\"})\n}", "CodeBleu_score": 50.588331304942834}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the name parameter from the request context\n\tname, err := GetParameter(ctx, \"name\")\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Bind the request body to a message map\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\"\n\tif err := notify.SendNotification(name, message); err!= nil {\n\t\treturn err\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent successfully\"})\n}", "CodeBleu_score": 47.37220823923471}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t", "CodeBleu_score": 1.3086911686044582}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Get the WebSocket connection from the request\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service if it isn't already running\n\tif!messageSendingServiceRunning {\n\t\tmessageSendingServiceRunning = true\n\t\tgo messageSendingService()\n\t}\n\n\t// Enter a loop to read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t// Read the message type and message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Print the message type and message\n\t\tfmt.Printf(\"Message type: %d\nMessage: %s\n\", messageType, string(message))\n\n\t\t// Print any errors\n\t\tif err!= nil {\n\t\t\tfmt.Printf(\"Error: %s\n\", err.Error())\n\t\t}\n\t}\n}", "CodeBleu_score": 42.64957721362399}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t", "CodeBleu_score": 1.3086911686044582}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar systemHardwareInfo SystemHardwareInfo\n\tvar systemHardwareInfoJSON []byte\n\tvar err error\n\n\tsystemHardwareInfo.Architecture, err = GetSystemArchitecture()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tsystemHardwareInfo.DriveModel, err = GetDriveModel()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tsystemHardwareInfoJSON, err = json.Marshal(systemHardwareInfo)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn ctx.JSONBlob(http.StatusOK, systemHardwareInfoJSON)\n}", "CodeBleu_score": 20.07679041120737}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t", "CodeBleu_score": 1.4766480750698492}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the system hardware information\n\tsystemHardwareInfo, err := GetSystemHardwareInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\t// Return the system hardware information\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 12.50264043789031}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif s.systemctl.ServiceStatus(service) == \"active\" {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 60.651117730548364}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 70.18246709532528}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar (\n\t\trunning  []string\n\t\tnotRunning []string\n\t\tservices = make(map[bool]*[]string)\n\t)\n\n\tlist, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, service := range list {\n\t\tif service.Name == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif service.Name[0:7] == \"casaos*\" {\n\t\t\tif service.ActiveState == \"active\" {\n\t\t\t\trunning = append(running, service.Name)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t\t}\n\t\t}\n\t}\n\n\tservices[true] = &running\n\tservices[false] = &notRunning\n\n\treturn services, nil\n}", "CodeBleu_score": 55.00711978057606}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to serialize message: %v\", err)\n\t\treturn\n\t}\n\n\tif _, err := i.publish(name, jsonMessage); err!= nil {\n\t\tlog.Printf(\"Failed to publish event: %v\", err)\n\t}\n}", "CodeBleu_score": 24.62671783238178}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message map to JSON strings\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to serialize message map to JSON: %v\", err)\n\t\treturn\n\t}\n\n\t// Create a new notification event\n\tevent := &notify.Event{\n\t\tName:    name,\n\t\tMessage: string(messageJSON),\n\t}\n\n\t// Publish the notification event to the message bus\n\tresp, err := i.client.Publish(event)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to publish notification event: %v\", err)\n\t\treturn\n\t}\n\n\t// Check the response status code\n\tif resp.StatusCode!= http.StatusOK {\n\t\tlog.Printf(\"Failed to publish notification event: response status code %d\", resp.StatusCode)\n\t\treturn\n\t}\n}", "CodeBleu_score": 33.49724275617198}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message map to JSON\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Error serializing message map to JSON: %v\", err)\n\t\treturn\n\t}\n\n\t// Create a new event with the given name and message\n\tevent := &events.Event{\n\t\tName:    name,\n\t\tMessage: string(messageJSON),\n\t}\n\n\t// Publish the event to the message bus\n\terr = i.messageBus.Publish(event)\n\tif err!= nil {\n\t\tlog.Printf(\"Error publishing event to message bus: %v\", err)\n\t\treturn\n\t}\n\n\t// Check if the response status code is OK\n\tif resp.StatusCode!= http.StatusOK {\n\t\tlog.Printf(\"Failed to send notification: %v\", resp.Status)\n\t\treturn\n\t}\n\n\t// Log the response details\n\tlog.Printf(\"Notification sent successfully: %v\", resp.Status)\n}", "CodeBleu_score": 39.51537722907638}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Initialize the client.\n\tclient := message_bus.NewClientWithResponses()\n\n\t// Attempt to retrieve the message bus address.\n\taddress := c.runtime.GetMessageBusAddress()\n\n\t// If the address is found, set the client's server to the retrieved address.\n\tif address!= \"\" {\n\t\tclient.SetServer(address)\n\t}\n\n\t// Otherwise, set the server to a default error message.\n\telse {\n\t\tclient.SetServer(\"Unable to retrieve the message bus address.\")\n\t}\n\n\t// Return the initialized client.\n\treturn client\n}", "CodeBleu_score": 27.339477268395207}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Initialize the message bus client.\n\tclient := message_bus.NewClientWithResponses()\n\n\t// Attempt to retrieve the message bus address.\n\taddress, err := c.Runtime.Get(\"message_bus\")\n\tif err!= nil {\n\t\t// Set the server to a default error message.\n\t\tclient.SetServer(message_bus.DefaultErrorServer)\n\t} else {\n\t\t// Set the server to the retrieved address.\n\t\tclient.SetServer(address)\n\t}\n\n\t// Return the initialized message bus client.\n\treturn client\n}", "CodeBleu_score": 28.304629073745303}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses()\n\tclient.SetServer(c.address)\n\tif c.address == \"\" {\n\t\tclient.SetServer(message_bus.NewError(\"Could not retrieve message bus address\"))\n\t}\n\treturn client\n}", "CodeBleu_score": 21.986461255057367}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\t// Get the \"x-forwarded-for\" header\n\tforwardedFor := request.Header.Get(\"x-forwarded-for\")\n\t// If the header is not available, use the request's remote address\n\tif forwardedFor == \"\" {\n\t\tforwardedFor = request.RemoteAddr\n\t}\n\t// Extract the first IP\n\tip := strings.Split(forwardedFor, \",\")[0]\n\t// Convert loopback addresses\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 54.454479875152416}, {"code": "func GetIP(request *http.Request) string{\n\t\tforwardedFor := request.Header.Get(\"X-FORWARDED-FOR\")\n\tif forwardedFor!= \"\" {\n\t\treturn forwardedFor\n\t}\n\treturn request.RemoteAddr\n}", "CodeBleu_score": 24.845555975621316}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.44245846638746}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\tfor _, i := range interfaces {\n\t\taddrs, err := i.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i.Flags&net.FlagUp == 0 {\n\t\t\t\tcontinue // interface down\n\t\t\t}\n\t\t\tif i.Flags&net.FlagMulticast!= 0 {\n\t\t\t\tcontinue // ignore multicast interface\n\t\t\t}\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"Unable to find any MAC address\")\n}", "CodeBleu_score": 56.2752810690865}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, i := range interfaces {\n\t\taddrs, err := i.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"failed to get MAC address\")\n}", "CodeBleu_score": 57.84620915939544}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\tvar macAddress string\n\n\tfor _, i := range interfaces {\n\t\taddresses, err := i.Addrs()\n\t\tif err!= nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tfor _, a := range addresses {\n\t\t\tif ipnet, ok := a.(*net.IPNet); ok &&!ipnet.IP.IsLoopback() {\n\t\t\t\tif ipnet.IP.To4()!= nil {\n\t\t\t\t\tmacAddress = i.HardwareAddr.String()\n\t\t\t\t\treturn macAddress, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no MAC address found\")\n}", "CodeBleu_score": 59.1929899167316}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t retCode = 0;\n\n\tif (pTscObj->pRequestList == NULL) {\n\t\tpTscObj->pRequestList = pRequest;\n\t} else {\n\t\tpRequest->pNext = pTscObj->pRequestList;\n\t\tpTscObj->pRequestList = pRequest;\n\t}\n\n\tpTscObj->requestCount++;\n\tif (pTscObj->pAppInfo!= NULL) {\n\t\tpTscObj->pAppInfo->requestCount++;\n\t}\n\n\tif (g_debugLevel >= DEBUG_LEVEL_1) {\n\t\tprintf(\"registerRequest: Request %p added to TSC %p, request count = %d\n\", pRequest, pTscObj, pTscObj->requestCount);\n\t}\n\n\treturn retCode;\n}", "CodeBleu_score": 38.74005517680239}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t iRet = S_OK;\n\tuint32_t i;\n\tuint32_t iReqCount;\n\n\t/*\n\t * Add a reference to the request object and increment the request count for the associated TSC object.\n\t */\n\tiRet = addReference(pRequest);\n\tif (iRet!= S_OK) {\n\t\treturn iRet;\n\t}\n\tiRet = incrementRequestCount(pTscObj);\n\tif (iRet!= S_OK) {\n\t\treturn iRet;\n\t}\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary, including total and current request counts.\n\t */\n\tif (pTscObj->pAppInfo!= NULL) {\n\t\tiReqCount = pTscObj->pAppInfo->iReqCount;\n\t\tiReqCount++;\n\t\tpTscObj->pAppInfo->iReqCount = iReqCount;\n\t\tpTscObj->pAppInfo->iCurReqCount = iReqCount;\n\t}\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tif (pRequest->iReqId!= 0) {\n\t\tlogDebug(\"Request %d registered.\", pRequest->iReqId);\n\t}\n\telse {\n\t\tlogDebug(\"Request registered.\");\n\t}\n\n\t/*\n\t * Return a success code.\n\t */\n\treturn iRet;\n}", "CodeBleu_score": 36.260920038009964}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\n\tif (pRequest == NULL) {\n\t\trc = -1;\n\t} else {\n\t\tif (pTscObj == NULL) {\n\t\t\trc = -1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Add a reference to the request object.\n\t\t\t */\n\t\t\tpRequest->refCount++;\n\n\t\t\t/*\n\t\t\t * Increment the request count for the TSC object.\n\t\t\t */\n\t\t\tpTscObj->requestCount++;\n\n\t\t\t/*\n\t\t\t * Update the application's request summary, if the TSC object has application information.\n\t\t\t */\n\t\t\tif (pTscObj->pAppInfo!= NULL) {\n\t\t\t\tpTscObj->pAppInfo->requestCount++;\n\t\t\t\tpTscObj->pAppInfo->totalRequestCount++;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Log debug information about the new request.\n\t\t\t */\n\t\t\tif (g_debugLevel > 0) {\n\t\t\t\tchar buf[256];\n\t\t\t\tchar *pBuf = buf;\n\t\t\t\tint32_t bufLen = sizeof(buf);\n\t\t\t\tint32_t len;\n\t\t\t\tuint64_t tsc;\n\n\t\t\t\t/*\n\t\t\t\t * Get the current TSC value.\n\t\t\t\t */\n\t\t\t\ttsc = getTsc();\n\n\t\t\t\t/*\n\t\t\t\t * Format the message.\n\t\t\t\t */\n\t\t\t\tlen = snprintf(pBuf, bufLen, \"registerRequest: Request ID = %\" PRIu64 \", TSC = %\" PRIu64 \", TSC delta = %\" PRIu64 \", request count = %\" PRIu64 \", TSC delta = %\" PRIu64 \", TSC delta = %\" PRIu64,\n\t\t\t\t\t\tpRequest->requestID, tsc, tsc - pRequest->tsc, tsc - pRequest->tsc, pTscObj->requestCount, tsc - pTscObj->tsc, tsc - pTscObj->tsc);\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tif (len < bufLen) {\n\t\t\t\t\t\tbufLen -= len;\n\t\t\t\t\t\tpBuf += len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbufLen = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Log the message.\n\t\t\t\t */\n\t\t\t\tlogMessage(g_debugLevel, buf);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 42.71917759838376}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar* dbName = NULL;\n\tchar* p = NULL;\n\tchar* p2 = NULL;\n\tint dbNameLen = 0;\n\tbool isMatch = false;\n\n\t// If the primary database of the request is not the exception database, then the request is not associated with the exception database.\n\tdbName = pRequest->pDbName;\n\tif (dbName!= NULL && strcasecmp(dbName, exceptDb)!= 0) {\n\t\treturn false;\n\t}\n\n\t// Iterate through the list of databases in the request, ignoring any schema prefixes.\n\tp = pRequest->pDbName;\n\tif (p!= NULL) {\n\t\tp2 = strchr(p, '.');\n\t\tif (p2!= NULL) {\n\t\t\tdbName = p2 + 1;\n\t\t\tdbNameLen = strlen(dbName);\n\t\t} else {\n\t\t\tdbName = p;\n\t\t\tdbNameLen = strlen(dbName);\n\t\t}\n\t}\n\twhile (p!= NULL && p2!= NULL) {\n\t\tif (strncasecmp(p, exceptDb, dbNameLen) == 0) {\n\t\t\tisMatch = true;\n\t\t\tbreak;\n\t\t}\n\t\tp = p2 + 1;\n\t\tp2 = strchr(p, '.');\n\t\tif (p2!= NULL) {\n\t\t\tdbName = p2 + 1;\n\t\t\tdbNameLen = strlen(dbName);\n\t\t} else {\n\t\t\tdbName = p;\n\t\t\tdbNameLen = strlen(dbName);\n\t\t}\n\t}\n\n\t// If none of the databases match the exception database, then the request is not associated with the exception database.\n\treturn!isMatch;\n}", "CodeBleu_score": 39.775267252812554}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *primaryDb = NULL;\n\tchar *db = NULL;\n\tbool result = true;\n\n\tprimaryDb = getPrimaryDb(pRequest);\n\tif (primaryDb!= NULL) {\n\t\tif (strcmp(primaryDb, exceptDb)!= 0) {\n\t\t\tresult = false;\n\t\t}\n\t}\n\n\tdb = getDb(pRequest);\n\tif (db!= NULL) {\n\t\tif (strcmp(db, exceptDb)!= 0) {\n\t\t\tresult = false;\n\t\t}\n\t}\n\n\tif (result) {\n\t\tint i;\n\t\tint dbCount = getDbCount(pRequest);\n\t\tfor (i = 0; i < dbCount; i++) {\n\t\t\tdb = getDbAt(pRequest, i);\n\t\t\tif (db!= NULL) {\n\t\t\t\tif (strcmp(db, exceptDb)!= 0) {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 39.92568576982281}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDbName = NULL;\n\tbool isExceptDb = false;\n\tbool isDbMatch = false;\n\n\tif (pRequest == NULL) {\n\t\treturn false;\n\t}\n\n\t// Check if the primary database of the request matches the exception database.\n\tpDbName = getDbName(pRequest);\n\tif (pDbName!= NULL) {\n\t\tif (strcmp(pDbName, exceptDb) == 0) {\n\t\t\tisExceptDb = true;\n\t\t}\n\t}\n\n\t// Check if any of the databases in the request matches the exception database.\n\tif (!isExceptDb) {\n\t\tint i = 0;\n\t\tint numDb = getNumDb(pRequest);\n\t\tfor (i = 0; i < numDb; i++) {\n\t\t\tpDbName = getDbNameFromIndex(pRequest, i);\n\t\t\tif (pDbName!= NULL) {\n\t\t\t\tif (strcmp(pDbName, exceptDb) == 0) {\n\t\t\t\t\tisDbMatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return true if none of the databases match the exception database.\n\tif (isDbMatch) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 43.074745970078276}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == E_RFP_REDIRECT) {\n\t\tswitch (msgType) {\n\t\tcase MSG_RFP_REQUEST:\n\t\tcase MSG_RFP_RESPONSE:\n\t\tcase MSG_RFP_ACK:\n\t\tcase MSG_RFP_NACK:\n\t\tcase MSG_RFP_PING:\n\t\tcase MSG_RFP_PONG:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.0886580551305}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tif (pRequests == NULL) return;\n\tint64_t rid;\n\tfor (int i = 0; i < pRequests->size; i++) {\n\t\tif (pRequests->pEntries[i].pEntry == NULL) continue;\n\t\tSHashEntry *pEntry = pRequests->pEntries[i].pEntry;\n\t\twhile (pEntry!= NULL) {\n\t\t\tif (pEntry->pEntry == NULL) break;\n\t\t\trid = pEntry->pEntry->rid;\n\t\t\tif (rid == 0) break;\n\t\t\tif (taosReleaseRef(clientReqRefPool, rid) > 0) {\n\t\t\t\ttaosStopRequest(rid);\n\t\t\t\ttaosReleaseRef(clientReqRefPool, rid);\n\t\t\t}\n\t\t\tpEntry = pEntry->pNext;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.68254557349907}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tif (pRequests == NULL) return;\n\n\tint64_t rid;\n\tint32_t ret;\n\tfor (int i = 0; i < pRequests->size; i++) {\n\t\tif (pRequests->table[i]!= NULL) {\n\t\t\tfor (int j = 0; j < pRequests->table[i]->size; j++) {\n\t\t\t\tif (pRequests->table[i]->table[j]!= NULL) {\n\t\t\t\t\trid = pRequests->table[i]->table[j]->rid;\n\t\t\t\t\tret = taosStopQuery(pRequests->table[i]->table[j]->pQuery);\n\t\t\t\t\tif (ret == 0) {\n\t\t\t\t\t\ttaosReleaseRef(pRequests->table[i]->table[j]->pQuery, rid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.34763558017396}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint64_t rid;\n\tint32_t status;\n\tint32_t i = 0;\n\tint32_t numRequests = 0;\n\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\t// Get the number of requests in the hash table\n\tnumRequests = pRequests->n;\n\n\t// Iterate through the hash table\n\tfor (i = 0; i < numRequests; i++) {\n\t\t// Get the request ID\n\t\trid = pRequests->keys[i];\n\n\t\t// Acquire the request\n\t\tstatus = taosAcquireRef(clientReqRefPool, rid);\n\n\t\t// Check if the request is valid\n\t\tif (status == 0) {\n\t\t\t// Stop the query associated with the request\n\t\t\ttaosStopQuery(rid);\n\n\t\t\t// Release the request\n\t\t\ttaosReleaseRef(clientReqRefPool, rid);\n\t\t}\n\t}\n}", "CodeBleu_score": 40.91125118254409}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tscIsCrashReportingEnabled()) {\n\t\treturn;\n\t}\n\n\tif (atomic_compare_exchange_strong(&tscCrashReportClientStop, &tscCrashReportClientStop, 1)) {\n\t\ttscLog(TSC_LOG_LEVEL_INFO, \"Stopping crash report thread.\");\n\t\twhile (tscCrashReportClientStop!= 0) {\n\t\t\tusleep(100000);\n\t\t}\n\t} else {\n\t\ttscLog(TSC_LOG_LEVEL_INFO, \"Crash report thread is already stopped.\");\n\t}\n}", "CodeBleu_score": 49.20866258966583}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\tif (!atomic_compare_exchange_strong(&tscClientStop, &tscClientStop, 1)) {\n\t\ttscLog(TSC_LOG_INFO, \"Crash report thread already stopped.\");\n\t\treturn;\n\t}\n\twhile (tscClientStop) {\n\t\tsleep(1);\n\t}\n}", "CodeBleu_score": 56.88836077743205}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\tint stop = 1;\n\twhile (atomic_compare_exchange_strong(&tscCrashReportClientStop, &stop, 0)) {\n\t\ttscLog(TSC_LOG_ERROR, \"Crash report thread is already stopped\");\n\t\treturn;\n\t}\n\twhile (tscCrashReportClientStop) {\n\t\tusleep(1000);\n\t}\n}", "CodeBleu_score": 56.50718994323166}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tif (properties->content_length > 0) {\n\t\t*(int64_t *) callbackData = properties->content_length;\n\t} else {\n\t\t*(int64_t *) callbackData = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 61.7454397857998}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tif (properties->content_length > 0) {\n\t\tS3ResponsePropertiesCallbackData *data = (S3ResponsePropertiesCallbackData *) callbackData;\n\t\tdata->contentLength = properties->content_length;\n\t} else {\n\t\tS3ResponsePropertiesCallbackData *data = (S3ResponsePropertiesCallbackData *) callbackData;\n\t\tdata->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 61.80193497129183}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3PutObjectCallbackData *data = (S3PutObjectCallbackData *) callbackData;\n\n\tif (properties->content_length > 0) {\n\t\tdata->contentLength = properties->content_length;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 65.87514516168413}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] generate checkpoint backup conf file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupPort, tsCheckpointBackupPort);\n  uDebug(\"[rsync] start rsync server cmd:%s\", cmd);\n  int32_t ret = system(cmd);\n  if (ret == -1) {\n    uError(\"[rsync] start rsync server error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  if (WIFEXITED(ret)) {\n    uInfo(\"[rsync] start rsync server success, ret:%d\", WEXITSTATUS(ret));\n  } else if (WIFSIGNALED(ret)) {\n    uError(\"[rsync] start rsync server error, signal:%d\", WTERMSIG(ret));\n  } else if (WIFSTOPPED(ret)) {\n    uError(\"[rsync] start rsync server error, signal:%d\", WSTOPSIG(ret));\n  }\n}", "CodeBleu_score": 60.1844268755367}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) return;\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --port=%d --config=%s\", tsCheckpointPort, tsCheckpointBackupDir);\n  uDebug(\"[rsync] start rsync, cmd:%s\", cmd);\n  if (system(cmd) == 0) {\n    uInfo(\"[rsync] start rsync success, port:%d\", tsCheckpointPort);\n  } else {\n    uError(\"[rsync] start rsync error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  }\n}", "CodeBleu_score": 59.193775245078584}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  uInfo(\"[rsync] start rsync, dir:%s\", tsCheckpointBackupDir);\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] generate config file error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char command[PATH_MAX * 4] = {0};\n  snprintf(command, PATH_MAX * 4,\n#ifdef WINDOWS\n           \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointPort\n#else\n           \"rsync --daemon --config=%srsync.conf --port=%d --no-detach\", tsCheckpointBackupDir, tsCheckpointPort\n#endif\n  );\n  uDebug(\"[rsync] command:%s\", command);\n  int32_t ret = system(command);\n  if (ret!= 0) {\n    uError(\"[rsync] start rsync error, ret:%d,\" ERRNO_ERR_FORMAT, ret, ERRNO_ERR_DATA);\n  } else {\n    uInfo(\"[rsync] start rsync success, dir:%s, port:%d\", tsCheckpointBackupDir, tsCheckpointPort);\n  }\n}", "CodeBleu_score": 53.9469018127752}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatcherId == null) {\n\t\tthrow new IllegalArgumentException(\"The dispatcherId argument is null\");\n\t}\n\tif (dispatcherId.isEmpty()) {\n\t\tthrow new IllegalArgumentException(\"The dispatcherId argument is empty\");\n\t}\n\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\t\tif (dispatcher.isStarted()) {\n\t\t\tdispatcher.stop();\n\t\t}\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"The dispatcher with the specified ID is not registered\");\n\t}\n}", "CodeBleu_score": 51.1415082341657}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"The dispatcher with the specified ID is not registered\");\n\t}\n\tdispatcher.shutdown();\n\tdispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 50.57711231196742}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\t// TODO - implement DispatcherService.destroyDispatcher\n\tthrow new UnsupportedOperationException();\n}", "CodeBleu_score": 5.778696619041726}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t//     TbActorId[] children = getChildren(parent);\n//     if (children == null) {\n//         return;\n//     }\n//     for (TbActorId child : children) {\n//         if (childFilter.test(child)) {\n//             try {\n//                 if (highPriority) {\n//                     send(child, msg, true);\n//                 } else {\n//                     send(child, msg, false);\n//                 }\n//             } catch (ActorNotFoundException e) {\n//                 logger.warn(String.format(\"Actor %s is not registered\", child));\n//             }\n//         }\n//     }\n }", "CodeBleu_score": 13.466092382761225}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tTbActorId[] children = _children.get(parent);\n\tif (children!= null) {\n\t\tfor (TbActorId child : children) {\n\t\t\tif (childFilter.test(child)) {\n\t\t\t\ttell(child, msg, highPriority);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.15380612131667}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tTbActorId[] children = getChildren(parent);\n\tif (children!= null) {\n\t\tfor (TbActorId child : children) {\n\t\t\tif (childFilter.test(child)) {\n\t\t\t\ttry {\n\t\t\t\t\ttell(child, msg, highPriority);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlogger.warn(\"Failed to send message to child actor \" + child + \" of parent actor \" + parent, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 47.23058380014996}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t (destroying.get()) {\n    if (msg.getMsg() == RULE_NODE_UPDATED_MSG) {\n        if (failedDuringInitialization.get()) {\n            dispatcher.getExecutor().execute(() -> tryInit(1));\n        } else {\n            msg.setMsg(STOPPED_MSG);\n        }\n    } else {\n        msg.setMsg(STOPPED_MSG);\n    }\n} else {\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    tryProcessQueue(true);\n}\n}", "CodeBleu_score": 53.198430898178295}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t (destroyed.get()) {\n            if (msg.getMsg() == RULE_NODE_UPDATED_MSG) {\n                if (failed.get()) {\n                    dispatcher.getExecutor().execute(() -> tryInit(0));\n                }\n            } else {\n                msg.getMsg().onStopped(msg.getSelf(), msg.getSender());\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 56.5406562911031}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t (destroying.get()) {\n            if (msg.getMsgType() == RULE_NODE_UPDATED_MSG) {\n                if (!initialized.get()) {\n                    dispatcher.getExecutor().execute(() -> tryInit(1));\n                }\n            } else {\n                msg.setActorStopped(true);\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(false);\n        }\n    }", "CodeBleu_score": 55.70361192966523}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}, {"code": "private void processMailbox(){\n\ty {\n            // Process high priority messages.\n            if (!highPriorityMsgs.isEmpty()) {\n                Iterator<HighPriorityMessage> highPriorityMsgIterator = highPriorityMsgs.iterator();\n                while (highPriorityMsgIterator.hasNext()) {\n                    HighPriorityMessage msg = highPriorityMsgIterator.next();\n                    try {\n                        actor.process(msg);\n                        highPriorityMsgIterator.remove();\n                    } catch (TbActorInitializationException e) {\n                        stopReason = TbActorStopReason.INITIALIZATION_FAILURE;\n                        destroy(e);\n                    } catch (Throwable e) {\n                        log.warn(\"[{}] Failed to process high priority message: {}\", selfId, e);\n                        if (actor.processFailureStrategy() == TbActorProcessFailureStrategy.STOP) {\n                            stopReason = TbActorStopReason.PROCESS_FAILURE;\n                            destroy(e);\n                        }\n                    }\n                }\n            }\n            // Process normal priority messages.\n            if (!normalPriorityMsgs.isEmpty()) {\n                Iterator<NormalPriorityMessage> normalPriorityMsgIterator = normalPriorityMsgs.iterator();\n                while (normalPriorityMsgIterator.hasNext()) {\n                    NormalPriorityMessage msg = normalPriorityMsgIterator.next();\n                    try {\n                        actor.process(msg);\n                        normalPriorityMsgIterator.remove();\n                    } catch (TbActorInitializationException e) {\n                        stopReason = TbActorStopReason.INITIALIZATION_FAILURE;\n                        destroy(e);\n                    } catch (Throwable e) {\n                        log.warn(\"[{}] Failed to process normal priority message: {}\", selfId, e);\n                        if (actor.processFailureStrategy() == TbActorProcessFailureStrategy.STOP) {\n                            stopReason = TbActorStopReason.PROCESS_FAILURE;\n                            destroy(e);\n                        }\n                    }\n                }\n            }\n            // If the mailbox is empty, set the actor's status to free and schedule a queue processing attempt.\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                ready.set(READY);\n                tryProcessQueue(false);\n            }\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n            stopReason = TbActorStopReason.PROCESS_FAILURE;\n            destroy(t);\n        } finally {\n            busy.set(FREE);\n        }\n    }", "CodeBleu_score": 36.7346963389925}, {"code": "private void processMailbox(){\n\t (destroyInProgress.get()) {\n            return;\n        }\n        try {\n            while (true) {\n                if (destroyInProgress.get()) {\n                    return;\n                }\n                if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                    break;\n                }\n                if (highPriorityMsgs.isEmpty()) {\n                    processNormalPriorityQueue();\n                } else {\n                    processHighPriorityQueue();\n                }\n            }\n            if (destroyInProgress.get()) {\n                return;\n            }\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                ready.set(READY);\n                log.trace(\"[{}] MessageBox is empty, ready: {}\", selfId, ready.get());\n            } else {\n                log.trace(\"[{}] MessageBox is not empty, ready: {}\", selfId, ready.get());\n            }\n        } catch (Throwable t) {\n            if (destroyInProgress.get()) {\n                return;\n            }\n            log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n            if (t instanceof TbActorInitializationException) {\n                stopReason = TbActorStopReason.INITIALIZATION_FAILURE;\n                destroy(t);\n            } else {\n                applyProcessFailureStrategy(t);\n            }\n        }\n    }", "CodeBleu_score": 30.774001312116035}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t//TODO: Add implementation\nthrow new RuntimeException(\"Not implemented yet!\");\n}", "CodeBleu_score": 5.698114427099045}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t//        TenantProfile tenantProfile = tenantProfileManager.getTenantProfile(tenantId);\n//        if (tenantProfile == null && ignoreTenantNotFound) {\n//            return true;\n//        }\n//        if (tenantProfile == null) {\n//            throw new TenantProfileNotFoundException(tenantId);\n//        }\n//        RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n//        if (rateLimitConfiguration == null) {\n//            return true;\n//        }\n//        RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n//        if (rateLimit == null) {\n//            return true;\n//        }\n//        if (rateLimit.getLimit() == null || rateLimit.getLimit() <= 0) {\n//            return true;\n//        }\n//        long currentCount = rateLimit.getCurrentCount();\n//        if (currentCount >= rateLimit.getLimit()) {\n//            processRateLimitNotification(api, tenantId, rateLimit);\n//            return false;\n//        }\n//        rateLimit.setCurrentCount(currentCount + 1);\n//        return true;\n}", "CodeBleu_score": 5.316843381303938}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t//\t\tif (tenantId.equals(TenantId.SYSTEM_TENANT_ID)) {\n//\t\t\treturn true;\n//\t\t}\n//\t\tTenantProfile tenantProfile = tenantProfileManager.getTenantProfile(tenantId);\n//\t\tif (tenantProfile == null && ignoreTenantNotFound) {\n//\t\t\treturn true;\n//\t\t}\n//\t\tif (tenantProfile == null) {\n//\t\t\tthrow new TenantProfileNotFoundException(tenantId);\n//\t\t}\n//\t\tRateLimits rateLimits = tenantProfile.getRateLimits();\n//\t\tif (rateLimits == null) {\n//\t\t\treturn true;\n//\t\t}\n//\t\tRateLimits.RateLimit rateLimit = rateLimits.get(api.name());\n//\t\tif (rateLimit == null) {\n//\t\t\treturn true;\n//\t\t}\n//\t\tRateLimitCheckResult result = checkRateLimit(api, tenantId, rateLimit, level);\n//\t\tif (result == RateLimitCheckResult.RATE_LIMIT_EXCEEDED) {\n//\t\t\tprocessRateLimitNotification(api, tenantId, rateLimit, level);\n//\t\t}\n//\t\treturn result == RateLimitCheckResult.SUCCESS;\n\t}", "CodeBleu_score": 5.316843381303938}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - this.inactivityTimeout;\n\tIterator<Map.Entry<String, DTLSClientSession>> iterator = this.dtlsSessions.entrySet().iterator();\n\twhile (iterator.hasNext()) {\n\t\tMap.Entry<String, DTLSClientSession> entry = iterator.next();\n\t\tDTLSClientSession session = entry.getValue();\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\tthis.logger.info(\"Evicting DTLS session with ID: \" + entry.getKey());\n\t\t\titerator.remove();\n\t\t}\n\t}\n}", "CodeBleu_score": 32.88068331834775}, {"code": "public void evictTimeoutSessions(){\n\t\tlong now = System.currentTimeMillis();\n\tlong expirationTime = now - inactivityTimeout;\n\tfor (Map.Entry<String, DTLSServerSession> entry : sessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tsessions.remove(entry.getKey());\n\t\t\tlogger.info(\"Removed DTLS session \" + entry.getKey() + \" due to inactivity timeout.\");\n\t\t}\n\t}\n}", "CodeBleu_score": 39.935667771733904}, {"code": "public void evictTimeoutSessions(){\n\t\t// TODO Auto-generated method stub\n\t\n}", "CodeBleu_score": 1.5735629692275181}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t", "CodeBleu_score": 4.702092680805382}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn new ArrayList<>();\n\t}\n\tList<TsKvEntry> result = new ArrayList<>();\n\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\tString key = entry.getKey();\n\t\tList<JsonNode> values = entry.getValue();\n\t\tList<KvEntry> tsValues = new ArrayList<>();\n\t\tfor (JsonNode value : values) {\n\t\t\ttsValues.add(parseValue(key, value));\n\t\t}\n\t\tresult.add(new TsKvEntry(key, tsValues));\n\t}\n\treturn result;\n}", "CodeBleu_score": 35.92563895948533}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t", "CodeBleu_score": 4.702092680805382}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tMap<String, String> request = new HashMap<>();\nrequest.put(\"refreshToken\", refreshToken);\n\n// Send a POST request to the authentication endpoint\nMap<String, String> response = sendPost(this.authEndpoint, request);\n\n// Update the token information\nsetTokenInfo(System.currentTimeMillis(), response.get(\"body\"));\n}", "CodeBleu_score": 38.11073000209817}, {"code": "public void refreshToken(){\n\t\n}", "CodeBleu_score": 1.6078250809239212}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", this.refreshToken);\n\tJsonNode response = this.sendRequest(requestMap, \"POST\", \"/refreshToken\");\n\tif (response == null) {\n\t\treturn;\n\t}\n\tthis.setTokenInfo(System.currentTimeMillis(), response);\n}", "CodeBleu_score": 39.55023143182025}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\tlong ts = System.currentTimeMillis();\n\tMap<String, Object> loginRequest = new HashMap<String, Object>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", );\n\ttry {\n\t\tJsonNode response = sendRequest(ts, \"/api/auth/login\", loginRequest, HttpMethod.POST);\n\t\tsetTokenInfo(ts, response);\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t}\n}", "CodeBleu_score": 56.95617838782534}, {"code": " private void doLogin(){\n\t//        System.out.println(\"Doing login\");\n        try {\n            long ts = System.currentTimeMillis();\n            Map<String, String> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", username);\n            loginRequest.put(\"password\", );\n            String loginResponse = sendPost(loginUrl, loginRequest);\n            JsonNode tokenInfo = mapper.readTree(loginResponse);\n            setTokenInfo(ts, tokenInfo);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }", "CodeBleu_score": 67.35006021888829}, {"code": " private void doLogin(){\n\t//        try {\n//            //Get the current timestamp\n//            long ts = System.currentTimeMillis();\n//            //Create a login request map with the credentials\n//            Map<String, String> loginRequest = new HashMap<>();\n//            loginRequest.put(\"username\", username);\n//            loginRequest.put(\"password\", );\n//            //Send the request to the \"/api/auth/login\" URL\n//            HttpResponse<JsonNode> response = Unirest.post(this.authenticationEndpoint + \"/api/auth/login\")\n//                   .header(\"Content-Type\", \"application/json\")\n//                   .body(loginRequest)\n//                   .asJson();\n//            //Update the token information with the response data and the timestamp\n//            setTokenInfo(ts, response.getBody());\n//        } catch (UnirestException e) {\n//            e.printStackTrace();\n//        }\n    }", "CodeBleu_score": 1.452003087170041}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\treturn Optional.ofNullable(client.get(String.format(\"/api/device/%s\", deviceId.getValue()), Device.class));\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 35.39353548100669}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\treturn Optional.of(\n\t\t\t\trestTemplate.getForObject(\n\t\t\t\t\t\tbaseUrl + \"/api/device/\" + deviceId.getValue(),\n\t\t\t\t\t\tDevice.class\n\t\t\t\t)\n\t\t);\n\t} catch (HttpClientErrorException ex) {\n\t\tif (ex.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow ex;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.41081115898532}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\tString url = String.format(URL_DEVICE, deviceId.getId());\n\treturn get(url, Device.class);\n}", "CodeBleu_score": 21.887746339847414}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(baseUrl + \"/api/device-with-credentials\")\n\t\t\t\t.post(RequestBody.create(MediaType.parse(\"application/json\"), gson.toJson(new DeviceWithCredentials(device, credentials))))\n\t\t\t\t.build();\n\n\t\tResponse response = client.newCall(request).execute();\n\n\t\tif (response.code() == 200) {\n\t\t\treturn Optional.of(gson.fromJson(response.body().string(), Device.class));\n\t\t} else if (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Unexpected response code: \" + response.code());\n\t\t}\n\t} catch (IOException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 49.46918394116409}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tString url = this.baseUrl + \"/api/device-with-credentials\";\n\tRequest request = Request.builder()\n\t\t.url(url)\n\t\t.method(\"POST\")\n\t\t.header(\"Content-Type\", \"application/json\")\n\t\t.body(new Gson().toJson(new DeviceWithCredentials(device, credentials)))\n\t\t.build();\n\n\ttry {\n\t\tResponse response = this.client.newCall(request).execute();\n\t\tif (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn Optional.of(new Gson().fromJson(response.body().string(), Device.class));\n\t} catch (IOException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 45.932758058043426}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\t// create a request object containing the device and its credentials\n\tRequest request = new Request.Builder()\n\t\t\t.url(BASE_URL + \"/api/device-with-credentials\")\n\t\t\t.post(RequestBody.create(MediaType.parse(\"application/json; charset=utf-8\"), new Gson().toJson(device)))\n\t\t\t.addHeader(\"Authorization\", \"Bearer \" + credentials.getToken())\n\t\t\t.build();\n\n\t// attempt to send the request\n\ttry (Response response = client.newCall(request).execute()) {\n\t\t// if the request was successful, return an Optional containing the saved device\n\t\tif (response.isSuccessful()) {\n\t\t\treturn Optional.of(new Gson().fromJson(response.body().string(), Device.class));\n\t\t}\n\t\t// if a 404 error occurs, return an empty Optional\n\t\telse if (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\t// otherwise, rethrow any other exceptions encountered\n\t\telse {\n\t\t\tthrow new RuntimeException(response.body().string());\n\t\t}\n\t}\n\tcatch (IOException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 45.00400263454259}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tval = addr;\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness(device, val);\n\t\t});\n\t} else {\n\t\tthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n\t}\n\treturn this;\n}", "CodeBleu_score": 95.67310060368143}, {"code": "brightness(addr, val){\n\t\n}", "CodeBleu_score": 2.8022481803282675}, {"code": "brightness(addr, val){\n\t\n}", "CodeBleu_score": 2.8022481803282675}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tconst bound = {};\n\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\n  bound[key] = this[key].bind(this, addr);\n});\n\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\n  if (this[key] && typeof this[key] === \"function\") {\n    bound[key] = this[key].bind(this, addr);\n  }\n});\nreturn bound;\n}", "CodeBleu_score": 97.50366938393864}, {"code": "device(addr){\n\t\tconst bound = {};\n\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}, {"code": "device(addr){\n\t\tconst bound = {};\n\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach((method) => {\n\t\ttarget[method] = (...args) => {\n\t\t\tconst promises = [];\n\t\t\tconst callback = args.pop();\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('The last argument must be a function.');\n\t\t\t}\n\t\t\targs.forEach((arg) => {\n\t\t\t\tpromises.push(target[method](arg));\n\t\t\t});\n\t\t\tPromise.all(promises).then(callback);\n\t\t};\n\t});\n}", "CodeBleu_score": 28.89695242621227}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = (duration = 1000, callback) => {\n\t\t\tif (typeof callback!== \"function\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\ttarget.forEach(element => {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(element[method]());\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 27.22443699358018}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method + 'CallbackReconciliation'] = (duration = 1000, callback) => {\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tcallback = () => {};\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\ttarget.forEach(element => {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\telement[method]();\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 27.23240290601353}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 74.03081486126135}, {"code": "listen(){\n\t", "CodeBleu_score": 1.3029767937853085}, {"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 74.03081486126135}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t buffer_size;\n\tint ret;\n\n\t/* Calculate the number of active channels */\n\tuint8_t num_active_channels = 0;\n\tfor (uint8_t i = 0; i < sequence->channels_length; i++) {\n\t\tif (sequence->channels[i] < data->num_channels) {\n\t\t\tnum_active_channels++;\n\t\t}\n\t}\n\n\t/* Calculate the needed buffer size */\n\tbuffer_size = num_active_channels * sequence->buffer_size;\n\n\t/* Validate the buffer size */\n\tret = 0;\n\tif (buffer_size > data->buffer_size) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 32.74026853520142}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tint ret = 0;\n\tsize_t buffer_size;\n\n\t/* Calculate the number of active channels in the sequence. */\n\tint active_channels = 0;\n\tfor (int i = 0; i < sequence->channels_length; i++) {\n\t\tif (sequence->channels[i] < data->num_channels) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\t/* Calculate the needed buffer size. */\n\tbuffer_size = active_channels * sizeof(uint16_t);\n\n\t/* Check if the provided buffer size is sufficient. */\n\tif (sequence->buffer_size < buffer_size) {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 44.01962506219781}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tsize_t active_channels = 0;\n\tsize_t buffer_size = 0;\n\n\tfor (size_t i = 0; i < sequence->channels_used; i++) {\n\t\tif (sequence->channel_buf_info[i].buffer_size <\n\t\t    sizeof(uint16_t)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tactive_channels++;\n\t\tbuffer_size += sequence->channel_buf_info[i].buffer_size;\n\t}\n\n\tif (active_channels > data->channels_per_chip) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (buffer_size < (active_channels * sizeof(uint16_t))) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.39491766729003}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_ad559x_cfg *cfg = dev->config;\n\tuint8_t channels;\n\tsize_t needed;\n\tint ret;\n\n\t/* Check if the resolution is valid */\n\tif (sequence->resolution!= cfg->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the channels are valid */\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > cfg->channels) {\n\t\tLOG_ERR(\"Invalid channels\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the buffer size is valid */\n\tneeded = channels * sizeof(uint16_t);\n\tif (sequence->buffer_size < needed) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Start the ADC read context */\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* Wait for the read operation to complete */\n\tret = adc_context_wait_for_completion(&data->ctx);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 63.24629790364196}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution!= data->resolution) {\n\t\tLOG_ERR(\"ADC resolution does not match device\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > data->channels) {\n\t\tLOG_ERR(\"ADC channels do not match device\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"ADC buffer size is insufficient\");\n\t\treturn ret;\n\t}\n\n\tret = adc_context_buffer_set(data->ctx, sequence->buffer, sequence->buffer_size, sequence->resolution);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tadc_context_start_read(data->ctx);\n\n\treturn adc_context_wait_for_completion(data->ctx, K_FOREVER);\n}", "CodeBleu_score": 65.0809969075446}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution!= data->resolution) {\n\t\tLOG_ERR(\"Invalid resolution %d, expected %d\", sequence->resolution, data->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > MAX_CHANNELS) {\n\t\tLOG_ERR(\"Too many channels %d\", channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Invalid buffer size %d\", sequence->buffer_size);\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tret = adc_ad559x_start_read_context(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to start read context\");\n\t\treturn ret;\n\t}\n\n\tret = adc_ad559x_wait_read_complete(dev);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to wait for read completion\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 68.39880708017233}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\t/* Retrieve the ADC data structure from the context */\n\tstruct adc_data *adc_data = ctx->adc_data;\n\n\t/* Set the channels to be sampled */\n\tadc_data->channel_mask = ctx->channel_mask;\n\n\t/* Initialize the repeat buffer with the data buffer */\n\tmemcpy(adc_data->repeat_buffer, adc_data->data_buffer, sizeof(adc_data->data_buffer));\n\n\t/* Release a semaphore to signal the start of sampling */\n\txSemaphoreGive(adc_data->start_sampling_semaphore);\n}", "CodeBleu_score": 40.9240870383345}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\t/* Get the ADC data structure from the context */\n\tstruct adc_data *data = ctx->data;\n\n\t/* Set the channels to be sampled */\n\tdata->adc->CHER = ctx->channels;\n\n\t/* Initialize the repeat buffer with the data buffer */\n\tdata->adc->RPR = (uint32_t) data->buffer;\n\tdata->adc->RCR = data->buffer_size;\n\n\t/* Release a semaphore to signal the start of sampling */\n\txSemaphoreGive(data->semaphore);\n}", "CodeBleu_score": 50.257015224313825}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\t// Retrieve the ADC data structure from the context\n\tstruct adc_data *data = ctx->data;\n\n\t// Set the channels to be sampled\n\tadc_set_channels(data->adc, ctx->channels);\n\n\t// Initialize the repeat buffer with the data buffer\n\tadc_repeat_buffer_init(data->adc, data->data, data->size);\n\n\t// Release a semaphore to signal the start of sampling\n\txSemaphoreGive(data->semaphore);\n}", "CodeBleu_score": 49.96658853925367}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (ctx->data_container!= NULL) {\n\t\tif (repeat_sampling) {\n\t\t\tctx->data_container->buffer_pointer = ctx->data_container->repeat_buffer;\n\t\t} else {\n\t\t\tctx->data_container->buffer_pointer = ctx->data_container->buffer;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.37454986359778}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data *data = (struct adc_data *)ctx->data;\n\n\tif (repeat_sampling) {\n\t\tdata->buffer_pointer = data->repeat_buffer;\n\t} else {\n\t\tdata->buffer_pointer = data->buffer;\n\t}\n}", "CodeBleu_score": 52.50489264982057}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = ctx->repeat_buffer;\n\t}\n}", "CodeBleu_score": 45.12085574291548}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tonst struct adc_ad559x_config *config = data->config;\n\tstruct adc_context *context = data->context;\n\tstruct adc_sequence seq = {0};\n\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (1) {\n\t\t/* Wait for semaphore to be released */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Iterate through active channels */\n\t\tfor (channel = 0; channel < config->channels_num; channel++) {\n\t\t\t/* Read channel */\n\t\t\tret = adc_ad559x_read_channel(config->dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\tcontext->done = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Store result */\n\t\t\tseq.buffer = &result;\n\t\t\tseq.buffer_size = sizeof(result);\n\t\t\tseq.options = 0;\n\t\t\tseq.resolution = config->resolution;\n\t\t\tseq.channel_id = channel;\n\t\t\tseq.buffer_list = &seq.buffer;\n\t\t\tseq.buffer_count = 1;\n\n\t\t\tret = adc_context_update(context, &seq, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to update context: %d\", ret);\n\t\t\t\tcontext->done = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Signal that sampling is done */\n\t\tk_sem_give(&data->sem);\n\t}\n}", "CodeBleu_score": 48.63429266805762}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tonst struct adc_ad559x_config *config = data->config;\n\tstruct adc_sequence sequence = {\n\t\t.options = ADC_FLAGS(ADC_UPDATE_ON_READ),\n\t\t.buffer = data->buffer,\n\t\t.buffer_size = data->buffer_size,\n\t\t.resolution = config->resolution,\n\t\t.channels = BIT(config->channel_count),\n\t\t.oversampling = config->oversampling,\n\t};\n\tstruct adc_context context = {\n\t\t.buffer = data->buffer,\n\t\t.buffer_size = data->buffer_size,\n\t\t.resolution = config->resolution,\n\t\t.oversampling = config->oversampling,\n\t};\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t\tdata->active = true;\n\n\t\tfor (int i = 0; i < config->channel_count; i++) {\n\t\t\tsequence.channel_id = i;\n\t\t\tret = adc_read(config->adc_dev, &context, &sequence);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", i, ret);\n\t\t\t\tdata->active = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tk_sem_give(&data->sem);\n\t}\n}", "CodeBleu_score": 43.481088218000934}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tonst struct adc_ad559x_config *config = data->dev->config;\n\tstruct adc_sequence sequence = {\n\t\t.options = 0,\n\t\t.buffer = data->buffer,\n\t\t.buffer_size = sizeof(data->buffer),\n\t};\n\tuint8_t channel;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->num_channels; channel++) {\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &sequence.buffer[channel]);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\tdata->state = ADC_AD559X_STATE_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (data->state == ADC_AD559X_STATE_ERROR) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata->state = ADC_AD559X_STATE_COMPLETE;\n\t\tk_sem_give(&data->sem);\n\t}\n}", "CodeBleu_score": 49.10737884868546}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc = 0;\n\tint i = 0;\n\n\tdo {\n\t\tk_sleep(K_MSEC(config->ready_time));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc < 0) {\n\t\t\treturn rc;\n\t\t}\n\t\ti++;\n\t} while (!(reg_val & ADS1112_CONFIG_DRDY));\n\n\tif (i > 1) {\n\t\tLOG_WRN(\"ADS1112_REG_CONFIG: %02x\", reg_val);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.27313435950622}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tint rc = 0;\n\tuint8_t reg_val = 0;\n\n\tk_sleep(K_MSEC(config->ready_time_ms));\n\n\tdo {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t\tk_sleep(K_USEC(100));\n\t} while ((reg_val & ADS1112_CONFIG_DRDY) == 0);\n\n\treturn rc;\n}", "CodeBleu_score": 46.74041619152193}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t buf[3] = {0};\n\tint rc = 0;\n\n\tk_sleep(config->ready_time);\n\n\tdo {\n\t\trc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\t\tk_sleep(K_USEC(100));\n\t} while ((buf[2] & ADS1112_REG_CONFIG_RDY)!= ADS1112_REG_CONFIG_RDY);\n\n\treturn rc;\n}", "CodeBleu_score": 30.301217080063143}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_buffer_size = 0;\n\tsize_t samples_per_channel = sequence->options & ADC_SEQ_OPTIONS_SAMPLES_PER_CHANNEL_MASK;\n\tsize_t extra_samples = sequence->options & ADC_SEQ_OPTIONS_EXTRA_SAMPLES_MASK;\n\tsize_t channels = sequence->channels;\n\tsize_t buffer_size = sequence->buffer_size;\n\tsize_t extra_buffer_size = extra_samples * channels;\n\n\t/* Calculate the required buffer size based on the number of samples per channel and the number of extra samples. */\n\trequired_buffer_size = samples_per_channel * channels + extra_buffer_size;\n\n\t/* Check if the buffer size is sufficient. */\n\tif (buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size is insufficient for the ADC sequence.\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 35.103397056314954}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tif (sequence->options & ADC_SEQ_OPTION_EXTRA_SAMPLING) {\n\t\tif (sequence->buffer_length < (sequence->length + sequence->options & ADC_SEQ_OPTION_EXTRA_SAMPLING)) {\n\t\t\tLOG_ERR(\"Buffer size is not sufficient for the ADC sequence\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (sequence->buffer_length < sequence->length) {\n\t\t\tLOG_ERR(\"Buffer size is not sufficient for the ADC sequence\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 37.3047871340782}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = 0;\n\tint num_samplings = 0;\n\tint extra_samplings = 0;\n\tint required_buffer_size = 0;\n\tint ret = 0;\n\n\tif (sequence == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer_size = sequence->buffer_size;\n\tnum_samplings = sequence->options.extra_samplings + 1;\n\textra_samplings = sequence->options.extra_samplings;\n\n\trequired_buffer_size = (num_samplings + extra_samplings) * sizeof(struct ads1112_sample);\n\n\tif (buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size is not sufficient for the sequence.\");\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 40.96496908341092}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\n\tif (adc_context_is_valid(&data->adc_context)) {\n\t\tLOG_ERR(\"ADC already running\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (ads1112_validate_sequence(dev, sequence) < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tdata->adc_context.sequence = sequence;\n\tdata->adc_context.wait = wait;\n\n\tadc_context_start_read(&data->adc_context);\n\n\treturn 0;\n}", "CodeBleu_score": 49.95178252551361}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = ads1112_start_read_context(dev);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = ads1112_wait_for_read_context(dev);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 58.97749707857945}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = ads1112_adc_start_read_context(dev, wait);\n\n\treturn ret;\n}", "CodeBleu_score": 56.772309262450825}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t", "CodeBleu_score": 34.52460135924148}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t", "CodeBleu_score": 34.52460135924148}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t", "CodeBleu_score": 34.52460135924148}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *data = dev->data;\n\tuint32_t i2s_cmd;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device already active\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tif (data->state == MPXXDTYY_STATE_CONFIG) {\n\t\t\ti2s_cmd = I2S_CMD_START;\n\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t} else {\n\t\t\tLOG_ERR(\"Device not configured\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIG) {\n\t\t\tLOG_ERR(\"Device not active\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\ti2s_cmd = I2S_CMD_STOP;\n\t\t\tdata->state = MPXXDTYY_STATE_CONFIG;\n\t\t} else {\n\t\t\tLOG_ERR(\"Device not configured\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2s_send_cmd(data->i2s, i2s_cmd);\n\tif (ret) {\n\t\tLOG_ERR(\"I2S send command failed\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 58.267318314481884}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret = 0;\n\n\tif (data->i2s_cmd == NULL) {\n\t\tLOG_ERR(\"I2S command not set\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Device already active\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tret = data->i2s_cmd(data->i2s_cmd_arg, I2S_CMD_START);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"I2S start command failed\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_INACTIVE) {\n\t\t\tLOG_ERR(\"Device already inactive\");\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tret = data->i2s_cmd(data->i2s_cmd_arg, I2S_CMD_STOP);\n\t\tif (ret!= 0) {\n\t\t\tLOG_ERR(\"I2S stop command failed\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->state = DMIC_STATE_INACTIVE;\n\t\tbreak;\n\n\tdefault:\n\t\tLOG_ERR(\"Unsupported trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 54.97334731757765}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tint ret = 0;\n\tstruct mpxxdtyy_data *data = dev->data;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == DMIC_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"DMIC already active\");\n\t\t\treturn -EALREADY;\n\t\t}\n\t\tdata->i2s_cmd = I2S_CMD_START;\n\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == DMIC_STATE_INACTIVE) {\n\t\t\tLOG_ERR(\"DMIC already inactive\");\n\t\t\treturn -EALREADY;\n\t\t}\n\t\tdata->i2s_cmd = I2S_CMD_STOP;\n\t\tdata->state = DMIC_STATE_INACTIVE;\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported DMIC trigger command\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2s_write(data->i2s_dev, &data->i2s_cmd, sizeof(data->i2s_cmd));\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to send I2S command\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.14026771492039}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t mode = AUXDISPLAY_HD44780_MODE_4_BIT;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\n\tif (config->display_mode.display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK) {\n\t\tmode |= AUXDISPLAY_HD44780_MODE_BLINK;\n\t\tif (config->display_mode.cursor_position == AUXDISPLAY_HD44780_CURSOR_POSITION_LEFT) {\n\t\t\tmode |= AUXDISPLAY_HD44780_MODE_CURSOR_LEFT;\n\t\t}\n\t} else if (config->display_mode.display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON) {\n\t\tmode |= AUXDISPLAY_HD44780_MODE_CURSOR_ON;\n\t\tif (config->display_mode.cursor_position == AUXDISPLAY_HD44780_CURSOR_POSITION_LEFT) {\n\t\t\tmode |= AUXDISPLAY_HD44780_MODE_CURSOR_LEFT;\n\t\t}\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, mode);\n}", "CodeBleu_score": 58.103396352739026}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (config->display_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON_CURSOR_BLINK;\n\t}\n\n\tif (config->display_cursor) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON_CURSOR;\n\t}\n\n\tif (config->display_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON_CURSOR_BLINK;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 67.48519507732509}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0x00;\n\n\tcmd |= (enabled? 0x08 : 0x00);\n\tcmd |= (config->display_blink? 0x01 : 0x00);\n\tcmd |= (config->display_cursor? 0x02 : 0x00);\n\tcmd |= (config->display_cursor_blink? 0x01 : 0x00);\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 34.777426601438954}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tconst struct auxdisplay_itron_data *data = dev->data;\n\tint ret = -ENOTSUP;\n\n\tif (config->busy_gpio_port!= NULL) {\n\t\tret = gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 61.17600683203551}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (!config->busy_gpio.port) {\n\t\tLOG_ERR(\"Busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(&config->busy_gpio);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get busy GPIO status\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 67.55696641950217}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tstruct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\n\tif (data->busy_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(data->busy_port, data->busy_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret == 0? 0 : -EBUSY;\n}", "CodeBleu_score": 58.38544051661666}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tstruct i2c_msg msg[2];\n\tuint8_t buffer[3];\n\tint ret;\n\n\t/* Construct the command buffer */\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\tbuffer[2] = '\\0';\n\n\t/* Construct the I2C message */\n\tmsg[0].buf = buffer;\n\tmsg[0].len = 3;\n\tmsg[0].flags = 0;\n\tmsg[1].buf = NULL;\n\tmsg[1].len = 0;\n\tmsg[1].flags = I2C_MSG_STOP;\n\n\t/* Send the command */\n\tret = i2c_transfer(config->i2c, &msg[0], 1, config->i2c_slave_addr);\n\n\t/* Introduce a delay */\n\tk_sleep(K_MSEC(config->delay_after_special_command_ms));\n\n\treturn ret;\n}", "CodeBleu_score": 59.46770096676124}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tif (i2c_write(config->i2c, config->i2c_address, buffer, 2)!= 0) {\n\t\treturn -EIO;\n\t}\n\n\tk_sleep(K_MSEC(config->special_command_delay));\n\n\treturn 0;\n}", "CodeBleu_score": 61.48806209091593}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tstruct i2c_msg msg;\n\tuint8_t buffer[2];\n\tint ret;\n\n\t/* Construct the buffer containing the special command prefix and the command itself */\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\t/* Construct the I2C message */\n\tmsg.buf = buffer;\n\tmsg.len = 2;\n\tmsg.flags = 0;\n\n\t/* Send the I2C message */\n\tret = i2c_write(config->i2c, &msg);\n\n\t/* Introduce a delay specified in the device configuration */\n\tk_msleep(config->delay_after_special_command);\n\n\treturn ret;\n}", "CodeBleu_score": 60.28207539497461}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_p = dev->data;\n\n\tif (size > data_p->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_p->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_p->status.is_invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, data_p->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 63.42494422769285}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\tuint8_t *mem = data_->mem;\n\tuint8_t *mem_end = mem + data_->size;\n\tuint8_t *mem_offset = mem + offset;\n\tuint8_t *mem_offset_end = mem_offset + size;\n\n\tif (mem_offset_end > mem_end) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, mem_offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 48.0151761624535}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\tuint8_t *mem = data_->mem;\n\tint err;\n\n\tif (size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tfor (size_t i = 0; i < size; i++) {\n\t\tdata[i] = mem[offset + i];\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.675237882038836}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\tuint8_t *dst = data_->mem + offset;\n\tsize_t end = offset + size;\n\n\tif (offset + size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (dst < data_->mem || dst >= data_->mem + data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(dst, data, size);\n\treturn 0;\n}", "CodeBleu_score": 53.88499965350795}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\tuint8_t *mem = data_->mem;\n\tsize_t mem_size = data_->mem_size;\n\n\tif (size > mem_size - offset) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 62.714560111834494}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\n\tif (size > BBRAM_EMUL_MAX_WRITE_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_->data + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 67.00935784026328}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\treturn 0;\n}", "CodeBleu_score": 74.16643140972245}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint rc;\n\tstruct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing argument for device\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = device_get_binding(argv[1]);\n\tif (rc) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 72.69798407671712}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = device_get_binding(argv[1], bbram_dev);\n\tif (err) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 63.71577463455558}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_uart_data *data = dev->data;\n\tconst struct h4_uart_config *config = dev->config;\n\tuint32_t bytes_read = 0;\n\tint err;\n\n\tif (data->rx_bytes_read < H4_UART_HDR_SIZE) {\n\t\tbytes_read = H4_UART_HDR_SIZE - data->rx_bytes_read;\n\t\terr = uart_fifo_fill(config->uart_dev, data->rx_buf + data->rx_bytes_read, bytes_read);\n\t\tif (err) {\n\t\t\tLOG_ERR(\"Error reading header\");\n\t\t} else {\n\t\t\tdata->rx_bytes_read += bytes_read;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.85653262272514}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_uart_data *data = dev->data;\n\tsize_t bytes_read = 0;\n\tint err = 0;\n\n\tif (data->bytes_remaining == 0) {\n\t\treturn;\n\t}\n\n\terr = uart_fifo_read(data->uart_dev, data->buf + data->bytes_read, data->bytes_remaining, &bytes_read);\n\tif (err!= 0) {\n\t\tLOG_ERR(\"UART read error %d\", err);\n\t\treturn;\n\t}\n\n\tdata->bytes_remaining -= bytes_read;\n\tdata->bytes_read += bytes_read;\n}", "CodeBleu_score": 45.03962919079208}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tconst struct h4_uart_config *config = dev->config;\n\tstruct h4_uart_data *data = dev->data;\n\n\tuint32_t bytes_read = 0;\n\tuint32_t bytes_remaining = data->hdr_bytes_remaining;\n\n\tif (uart_fifo_read(config->base, data->hdr_buf + data->hdr_bytes_read, bytes_remaining, &bytes_read)) {\n\t\tdata->hdr_bytes_read += bytes_read;\n\t\tdata->hdr_bytes_remaining -= bytes_read;\n\t} else {\n\t\tLOG_ERR(\"UART FIFO read failed\");\n\t}\n}", "CodeBleu_score": 49.82976050074361}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t i;\n\tuint8_t buf[33];\n\tsize_t read_len;\n\n\tfor (i = 0; i < len; i += read_len) {\n\t\tread_len = min(len - i, sizeof(buf));\n\t\tif (uart_fifo_read(uart, buf, read_len)!= 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART FIFO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn len;\n}", "CodeBleu_score": 39.8972555931458}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t ret = 0;\n\n\twhile (len) {\n\t\tsize_t read = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n\n\t\tif (read > 0) {\n\t\t\tret += read;\n\t\t\tlen -= read;\n\t\t} else {\n\t\t\tLOG_ERR(\"Failed to discard %zu bytes\", ret);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 52.472193376908436}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tif (uart == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (len == 0) {\n\t\treturn 0;\n\t}\n\n\tuint8_t temp_buffer[33];\n\tsize_t bytes_read = 0;\n\tsize_t bytes_remaining = len;\n\tsize_t bytes_to_read = MIN(bytes_remaining, sizeof(temp_buffer));\n\n\twhile (bytes_remaining > 0) {\n\t\tbytes_read += uart_fifo_read(uart, temp_buffer, bytes_to_read);\n\t\tbytes_remaining -= bytes_read;\n\t\tbytes_to_read = MIN(bytes_remaining, sizeof(temp_buffer));\n\t}\n\n\treturn len - bytes_remaining;\n}", "CodeBleu_score": 30.986019367699935}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *chan_data = chan->data;\n\tuint8_t highest_hop = 0;\n\tuint8_t i;\n\tstruct zbus_observer *obs;\n\n\tif (chan_data == NULL) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < chan_data->num_observers; i++) {\n\t\tobs = chan_data->observers[i];\n\t\tif (obs->enabled && obs->priority < highest_hop) {\n\t\t\thighest_hop = obs->priority;\n\t\t}\n\t}\n\n\tchan_data->highest_hop = highest_hop;\n}", "CodeBleu_score": 25.43778248869816}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tstruct zbus_channel_data *data = chan->data;\n\tint32_t highest_priority = ZBUS_OBS_PRIO_DEFAULT;\n\n\tif (data == NULL) {\n\t\treturn;\n\t}\n\n\tzbus_mutex_lock(&data->lock);\n\n\tfor (obs = data->observers; obs!= NULL; obs = obs->next) {\n\t\tif (obs->enabled && obs->priority < highest_priority) {\n\t\t\thighest_priority = obs->priority;\n\t\t}\n\t}\n\n\tdata->highest_priority = highest_priority;\n\tzbus_mutex_unlock(&data->lock);\n}", "CodeBleu_score": 29.540602703428576}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tif (chan->data_lock) {\n\t\tchan->data_lock->lock(chan->data_lock);\n\t}\n\tint i;\n\tint highest = -1;\n\tfor (i = 0; i < chan->observers_size; i++) {\n\t\tstruct zbus_observer *obs = chan->observers[i];\n\t\tif (obs->enabled && obs->priority < highest) {\n\t\t\thighest = obs->priority;\n\t\t}\n\t}\n\tchan->highest_priority = highest;\n\tif (chan->data_lock) {\n\t\tchan->data_lock->unlock(chan->data_lock);\n\t}\n}", "CodeBleu_score": 26.216718079922032}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->channels_end_idx;\n\n\t\tfor (int16_t i = obs->data->channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\tif (!observation->obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (obs->data->priority > observation->obs->data->priority) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 23.614902363384637}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\tstruct zbus_channel *chan;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tfor (int16_t i = 0; i < _zbus_chan_data.observers_end_idx; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\tif (observation->obs!= obs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan = observation->chan;\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 21.427451141522575}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel *chan;\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tfor (int16_t i = 0; i < _zbus_chan_section_size; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel, i, &chan);\n\n\t\t\tif (chan == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst int limit = chan->data->observers_end_idx;\n\n\t\t\tfor (int16_t j = chan->data->observers_start_idx; j < limit; ++j) {\n\t\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, j, &observation);\n\t\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, j, &observation_mask);\n\n\t\t\t\tif (observation->obs == obs) {\n\t\t\t\t\tchan_update_hop(chan);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 19.23502842787389}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tif (in_interrupt()) {\n\t\treturn -EPERM;\n\t}\n\n\tif (!obs) {\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&obs_lock);\n\n\tif (obs->priority!= ZBUS_OBS_PRIORITY_MIN) {\n\t\tobs->priority = ZBUS_OBS_PRIORITY_MIN;\n\t\tupdate_all_channels_hop(obs);\n\t}\n\n\tspin_unlock(&obs_lock);\n\n\treturn 0;\n}", "CodeBleu_score": 48.10120916467165}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tassert(obs!= NULL);\n\tif (zbus_is_isr_context()) {\n\t\treturn -1;\n\t}\n\n\tstruct zbus_observer_thread *thread = obs->thread;\n\tif (thread == NULL) {\n\t\treturn -1;\n\t}\n\n\tzbus_spinlock_lock(&thread->lock);\n\tif (thread->obs!= NULL) {\n\t\tzbus_spinlock_unlock(&thread->lock);\n\t\treturn -1;\n\t}\n\n\tthread->obs = obs;\n\tzbus_spinlock_unlock(&thread->lock);\n\treturn 0;\n}", "CodeBleu_score": 39.005187766474606}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t", "CodeBleu_score": 4.3557409704423655}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tnt err = 0;\n\tint prio = 0;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"zbus channel must be not NULL\");\n\n\tk_timeout_t end_time = sys_timepoint_timeout(timeout);\n\n\tif (k_is_in_isr()) {\n\t\tend_time = K_NO_WAIT;\n\t}\n\n\t/* Locking the channel */\n\terr = chan_lock(chan, end_time, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t/* Executing the notification logic */\n\terr = _zbus_vded_exec(chan, end_time);\n\n\t/* Unlocking the channel */\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 63.42319717632885}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tZBUS_ASSERT(chan!= NULL, \"channel must be not NULL\");\n\n\tk_timeout_t end_time;\n\tint prio = 0;\n\tint err = 0;\n\n\tif (k_is_in_isr()) {\n\t\tend_time = k_uptime_get();\n\t} else {\n\t\tend_time = k_uptime_get() + timeout;\n\t}\n\n\terr = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 58.607056880303034}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tnt err = 0;\n\tint prio = ZBUS_MIN_THREAD_PRIORITY;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"channel must be not NULL\");\n\t_ZBUS_ASSERT(timeout >= 0, \"timeout must be >= 0\");\n\n\tk_timeout_t end_time = k_uptime() + timeout;\n\n\tif (k_is_in_isr()) {\n\t\tend_time = k_uptime_to_idle_timeout(timeout);\n\t}\n\n\terr = chan_lock(chan, end_time, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 60.606312393280795}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (enable) {\n\t\tETH->DMAIER |= Int;\n\t} else {\n\t\tETH->DMAIER &= ~Int;\n\t}\n}", "CodeBleu_score": 18.716272014954484}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (enable) {\n\t\tETH->DMAIER |= Int;\n\t} else {\n\t\tETH->DMAIER &= ~Int;\n\t}\n}", "CodeBleu_score": 18.716272014954484}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (enable) {\n\t\tETH->MACIMR |= Int;\n\t} else {\n\t\tETH->MACIMR &= ~Int;\n\t}\n}", "CodeBleu_score": 18.714431656719665}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\t// Local variables\n\tETH_TX_DESC *pTxDesc;\n\tuint32_t ulTxDescIndex;\n\n\t// Get the current transmit descriptor address\n\tpTxDesc = (ETH_TX_DESC *) (ETH_BASE + ETH_TX_DESC_BASE);\n\n\t// Check if the descriptor is owned by the device\n\tif ((pTxDesc->ulControlStatus & ETH_TX_DESC_OWN) == 0) {\n\t\t// Get the descriptor index\n\t\tulTxDescIndex = pTxDesc->ulControlStatus & ETH_TX_DESC_INDEX;\n\n\t\t// Return the descriptor\n\t\treturn (pTxDesc);\n\t}\n\n\t// Loop through the list of descriptors\n\tdo {\n\t\t// Increment the descriptor index\n\t\tulTxDescIndex++;\n\n\t\t// Check if the index is greater than the maximum number of descriptors\n\t\tif (ulTxDescIndex >= ETH_TX_DESC_NUM) {\n\t\t\t// Wrap the index\n\t\t\tulTxDescIndex = 0;\n\t\t}\n\n\t\t// Get the next descriptor\n\t\tpTxDesc = (ETH_TX_DESC *) (ETH_BASE + ETH_TX_DESC_BASE + (ulTxDescIndex * ETH_TX_DESC_SIZE));\n\t} while ((pTxDesc->ulControlStatus & ETH_TX_DESC_OWN)!= 0);\n\n\t// Return the descriptor\n\treturn (pTxDesc);\n}", "CodeBleu_score": 41.837298430987204}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tuint32_t i;\n\tETH_TX_DESC *tx_desc;\n\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\ttx_desc = &ETH_TxDesc[i];\n\t\tif (tx_desc->Status & ETH_TX_DESC_OWN) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn tx_desc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 26.459221065506377}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc = 0;\n\tuint32_t tx_desc_addr;\n\tuint32_t tx_desc_addr_next;\n\n\ttx_desc_addr = ETH->DMATXDESC;\n\tdo {\n\t\ttx_desc_addr_next = tx_desc_addr;\n\t\ttx_desc_addr_next += sizeof(ETH_TX_DESC);\n\t\tif (tx_desc_addr_next >= ETH_BASE + ETH_DMATXDESC_OFFSET + ETH_DMATXDESC_COUNT * sizeof(ETH_TX_DESC)) {\n\t\t\ttx_desc_addr_next = ETH_BASE + ETH_DMATXDESC_OFFSET;\n\t\t}\n\t\ttx_desc = (ETH_TX_DESC *) tx_desc_addr;\n\t\tif ((tx_desc->status & ETH_TX_DESC_OWN) == 0) {\n\t\t\ttx_desc->status |= ETH_TX_DESC_OWN;\n\t\t\tETH->DMATXDESC = tx_desc_addr_next;\n\t\t\treturn tx_desc;\n\t\t}\n\t\ttx_desc_addr = tx_desc_addr_next;\n\t} while (tx_desc_addr!= ETH->DMATXDESC);\n\treturn 0;\n}", "CodeBleu_score": 43.4884109400812}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\trt_uint32_t cyp_dac_channel = 0;\n\n\tif (device == RT_NULL) {\n\t\trt_kprintf(\"device is null\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\tcyp_dac_channel = cyp_dac_get_channel(channel);\n\n\tif (Cy_CSDIDAC_OutputEnable(cyp_dac_channel, *value)!= CY_CSDIDAC_STATUS_SUCCESS) {\n\t\trt_kprintf(\"cyp_dac_convert: failed to enable the DAC output\n\");\n\t\tresult = RT_ERROR;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 51.4649613995103}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t ret = RT_EOK;\n\trt_uint32_t cyp_adc_channel = 0;\n\n\tif (device == RT_NULL) {\n\t\treturn RT_ENOSYS;\n\t}\n\n\tcyp_adc_channel = cyp_adc_get_channel(channel);\n\n\tif (cyp_adc_channel == 0) {\n\t\treturn RT_ENOSYS;\n\t}\n\n\t/* Start the conversion */\n\tif (Cy_CSD_ADC_StartConvert(device->parent.user_data, cyp_adc_channel)!= CY_CSD_ADC_SUCCESS) {\n\t\treturn RT_ENOSYS;\n\t}\n\n\t/* Wait for the conversion to complete */\n\twhile (Cy_CSD_ADC_IsEndConversion(device->parent.user_data, cyp_adc_channel)!= CY_CSD_ADC_SUCCESS) {\n\t\t/* Wait */\n\t}\n\n\t/* Read the conversion result */\n\t*value = Cy_CSD_ADC_GetResult(device->parent.user_data, cyp_adc_channel);\n\n\treturn ret;\n}", "CodeBleu_score": 46.347600674916684}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\trt_uint32_t cyp_adc_channel = 0;\n\trt_uint32_t cyp_adc_value = 0;\n\n\tif (device == RT_NULL) {\n\t\trt_kprintf(\"cyp_adc_convert: device is null\n\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tcyp_adc_channel = cyp_adc_get_channel(channel);\n\n\tif (cyp_adc_channel == 0) {\n\t\trt_kprintf(\"cyp_adc_convert: cyp_adc_channel is null\n\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tcyp_adc_value = Cy_CSD_ADC_ReadChannel(device->parent.user_data, cyp_adc_channel);\n\n\t*value = cyp_adc_value;\n\n\treturn result;\n}", "CodeBleu_score": 48.57340180181491}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tint ret = 0;\n\trt_uint32_t read_size = 0;\n\n\tif (addr + size > FLASH_END_ADDR) {\n\t\tLOG_ERROR(\"The read operation would exceed the flash memory's end address\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\twhile (read_size < size) {\n\t\trt_uint32_t read_size_temp = size - read_size;\n\t\tif (read_size_temp > 32768) {\n\t\t\tread_size_temp = 32768;\n\t\t}\n\t\tret = ifx_flash_read(addr + read_size, buf + read_size, read_size_temp);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERROR(\"Failed to read from flash memory\");\n\t\t\treturn ret;\n\t\t}\n\t\tread_size += ret;\n\t}\n\n\treturn read_size;\n}", "CodeBleu_score": 37.728696679633224}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tint ret = 0;\n\tif (addr + size > 0x100000) {\n\t\trt_kprintf(\"ifx_flash_read_32k: invalid argument\n\");\n\t\tret = -RT_EINVAL;\n\t} else {\n\t\tret = ifx_flash_read(addr, buf, size);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 21.507710116568802}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t temp;\n\n\tif (addr + size > 0x001FFFFF) {\n\t\trt_kprintf(\"ERROR: ifx_flash_read_32k: address + size exceeds flash memory end address\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\ttemp = ifx_flash_read_8(addr + i);\n\t\tbuf[i] = (rt_uint8_t) temp;\n\t}\n\n\treturn i;\n}", "CodeBleu_score": 44.51649971586006}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tstruct rt_hwtimer_info *info = (struct rt_hwtimer_info *)timer->parent.user_data;\n\treturn cyhal_timer_read(info->timer, info->timer_num);\n}", "CodeBleu_score": 17.328843017589445}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\trt_uint32_t count = 0;\n\trt_uint32_t *timer_obj = (rt_uint32_t *)timer->parent.user_data;\n\tcyhal_timer_read((cyhal_timer_t *)timer_obj, &count);\n\treturn count;\n}", "CodeBleu_score": 50.90482360081603}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\trt_uint32_t count = 0;\n\tcyhal_timer_t *cy_timer = timer->parent.user_data;\n\tcount = cyhal_timer_read(cy_timer);\n\treturn count;\n}", "CodeBleu_score": 50.24403080469708}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\twhile (mutex_trylock(&dfs_mutex)!= 0) {\n\t\tassert(0);\n\t}\n}", "CodeBleu_score": 16.090061116433702}, {"code": "void dfs_lock(void){\n\t\twhile (mutex_trylock(&dfs_mutex)!= 0) {\n\t\tassert(0);\n\t}\n}", "CodeBleu_score": 16.090061116433702}, {"code": "void dfs_lock(void){\n\t\tint ret;\n\tdo {\n\t\tret = pthread_mutex_lock(&dfs_mutex);\n\t} while (ret!= 0);\n}", "CodeBleu_score": 6.290580755175331}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint fd;\n\n\tif (startfd < 0)\n\t{\n\t\tstartfd = 0;\n\t}\n\tfor (i = startfd; i < fdt->maxfd; i++)\n\t{\n\t\tif (fdt->fds[i] == NULL)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\tfd = fd_slot_expand(fdt, startfd);\n\tif (fd < 0)\n\t{\n\t\treturn -1;\n\t}\n\treturn fd;\n}", "CodeBleu_score": 40.08007560130363}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint nr;\n\tint index;\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\n\tif (startfd >= fdt->maxfd) {\n\t\tif (fd_slot_expand(fdt, startfd) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tnr = fdt->maxfd;\n\tfor (i = startfd; i < nr; i++) {\n\t\tif (!fdt->fds[i]) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= nr) {\n\t\tif (fd_slot_expand(fdt, nr) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tindex = nr;\n\t}\n\n\treturn index;\n}", "CodeBleu_score": 47.0718458479937}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint index;\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\tfd = index;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index == fdt->maxfd) {\n\t\tfd = fd_slot_expand(fdt, startfd);\n\t\tif (fd < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 45.943509536468895}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < NUM_ERRORS; i++) {\n\t\tif (error == error_strings[i].error_code) {\n\t\t\treturn error_strings[i].error_string;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 49.290378573341705}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < sizeof(rt_error_strings) / sizeof(rt_error_strings[0]); i++) {\n\t\tif (rt_error_strings[i].code == error) {\n\t\t\treturn rt_error_strings[i].string;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 60.125776677793475}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < ERR_MAX; i++) {\n\t\tif (error == err_table[i].code) {\n\t\t\treturn err_table[i].string;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 47.60022491687684}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (rt_thread_idle_hook_list[rt_thread_idle_hook_pos]!= RT_NULL) {\n\t\tresult = -RT_EFULL;\n\t} else {\n\t\trt_thread_idle_hook_list[rt_thread_idle_hook_pos] = hook;\n\t\tresult = RT_EOK;\n\t\trt_thread_idle_hook_pos++;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 28.509351204031834}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\trt_thread_t thread;\n\n\t/* Get the current thread. */\n\tthread = rt_thread_self();\n\n\t/* Lock the spinlock. */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* Iterate through the idle hook list. */\n\tfor (int i = 0; i < RT_THREAD_IDLE_HOOK_SIZE; i++) {\n\t\t/* Check if the slot is empty. */\n\t\tif (rt_thread_idle_hook_list[i] == RT_NULL) {\n\t\t\t/* Assign the hook to the slot. */\n\t\t\trt_thread_idle_hook_list[i] = hook;\n\t\t\t/* Exit the loop. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Check if the slot is empty. */\n\tif (rt_thread_idle_hook_list[RT_THREAD_IDLE_HOOK_SIZE - 1]!= RT_NULL) {\n\t\t/* Return an error code. */\n\t\tresult = -RT_EFULL;\n\t}\n\n\t/* Release the spinlock. */\n\trt_hw_interrupt_enable(level);\n\n\t/* Return the result. */\n\treturn result;\n}", "CodeBleu_score": 43.20310319217499}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result;\n\trt_uint8_t i;\n\n\t/* lock the spinlock */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* iterate through the idle hook list */\n\tfor (i = 0; i < RT_THREAD_IDLE_HOOK_SIZE; i++) {\n\t\t/* if the slot is empty */\n\t\tif (rt_thread_idle_hook_table[i] == RT_NULL) {\n\t\t\t/* assign the hook to the slot */\n\t\t\trt_thread_idle_hook_table[i] = hook;\n\t\t\t/* set the result to success */\n\t\t\tresult = RT_EOK;\n\t\t\t/* break the loop */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* if the loop has not broken */\n\tif (i == RT_THREAD_IDLE_HOOK_SIZE) {\n\t\t/* set the result to full */\n\t\tresult = -RT_EFULL;\n\t}\n\n\t/* release the spinlock */\n\trt_hw_interrupt_enable(level);\n\n\t/* return the result */\n\treturn result;\n}", "CodeBleu_score": 61.50918712924237}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_thread_t thread;\n\trt_list_t *list;\n\trt_list_t *node;\n\trt_list_t *next;\n\trt_err_t result = RT_EOK;\n\n\t/*\n\t * Lock the spinlock to ensure thread safety.\n\t */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/*\n\t * Iterate through the idle hook list to find the specified hook.\n\t */\n\tlist = &rt_thread_idle_list;\n\tnode = list->next;\n\twhile (node!= list) {\n\t\tthread = rt_list_entry(node, rt_thread_t, tlist);\n\t\tnext = node->next;\n\t\tif (thread->tid == RT_THREAD_IDLE) {\n\t\t\tif (thread->thread_idle_hook == hook) {\n\t\t\t\tthread->thread_idle_hook = RT_NULL;\n\t\t\t\tresult = RT_EOK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnode = next;\n\t}\n\n\t/*\n\t * Unlock the spinlock and return the result.\n\t */\n\trt_hw_interrupt_enable(level);\n\treturn result;\n}", "CodeBleu_score": 42.12807231170128}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\trt_thread_t thread;\n\n\tthread = rt_thread_self();\n\n\t/*\n\t * The function \"rt_thread_self\" returns the current thread handle.\nIt is used to retrieve the current thread, which is required for the removal of the idle hook.\n\t */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/*\n\t * The function \"rt_list_remove\" removes a specified entry from the specified list.\nIt iterates through the list and finds the specified entry.\nIf found, it removes the entry from the list and returns a success code.\nIf the entry is not found, it returns an error code indicating that the operation is not supported.\nFinally, it returns the result.\n\t */\n\tresult = rt_list_remove(&thread->thread_idle_hook, &hook);\n\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 15.331079022720031}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_thread_t *thread;\n\trt_err_t result;\n\n\t/* Lock the spinlock to ensure thread safety */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* Iterate through the idle hook list to find the specified hook */\n\tfor (thread = rt_thread_idle_entry; thread!= RT_NULL; thread = thread->next) {\n\t\t/* If found, set the corresponding entry to null and return a success code */\n\t\tif (thread->hook == hook) {\n\t\t\tthread->hook = RT_NULL;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If the hook is not found, return an error code indicating that the operation is not supported */\n\tif (thread == RT_NULL) {\n\t\tresult = -RT_ENOSYS;\n\t}\n\n\t/* Unlock the spinlock and return the result */\n\trt_hw_interrupt_enable(level);\n\treturn result;\n}", "CodeBleu_score": 44.96033232338398}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_base_t level;\n\trt_thread_t *thread;\n\n\t/*\n\t * Ensure the scheduler is unlocked before proceeding.\n\t */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/*\n\t * Dequeue and wake up each suspended thread from the list one by one until the list is empty.\n\t */\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n\t\trt_list_remove(&(thread->tlist));\n\t\trt_thread_wakeup(thread);\n\t}\n\n\t/*\n\t * Restore the interrupt level and return.\n\t */\n\trt_hw_interrupt_enable(level);\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.289861541362583}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t *thread;\n\trt_base_t level;\n\trt_list_t *node;\n\trt_list_t *next;\n\n\t/*\n\t * Check if the scheduler is locked.\n\t */\n\tif (rt_scheduler_is_locked()) {\n\t\treturn -RT_EBUSY;\n\t}\n\n\t/*\n\t * Lock the scheduler.\n\t */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/*\n\t * Dequeue and wake up each suspended thread from the list one by one until the list is empty.\n\t */\n\tfor (node = susp_list->next; node!= susp_list; node = next) {\n\t\t/*\n\t\t * Get the next node.\n\t\t */\n\t\tnext = node->next;\n\n\t\t/*\n\t\t * Get the thread from the node.\n\t\t */\n\t\tthread = rt_list_entry(node, rt_thread_t, tlist);\n\n\t\t/*\n\t\t * Remove the thread from the suspension list.\n\t\t */\n\t\trt_list_remove(&thread->tlist);\n\n\t\t/*\n\t\t * Wake up the thread.\n\t\t */\n\t\trt_thread_wakeup(thread, thread_error);\n\t}\n\n\t/*\n\t * Unlock the scheduler.\n\t */\n\trt_hw_interrupt_enable(level);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 33.90070826982363}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_base_t level;\n\tstruct rt_thread *thread;\n\trt_err_t result = RT_EOK;\n\n\tRT_ASSERT(susp_list!= RT_NULL);\n\n\t/*\n\t * If the scheduler is locked, then the scheduler cannot be unlocked and the thread cannot be resumed.\n\t * In this case, the thread error code is returned to indicate the error.\n\t */\n\tif (rt_scheduler_lock == RT_TRUE) {\n\t\treturn thread_error;\n\t}\n\n\t/*\n\t * Acquire the scheduler lock and ensure that the scheduler is unlocked.\n\t * If the scheduler is locked, then the scheduler cannot be unlocked and the thread cannot be resumed.\n\t * In this case, the thread error code is returned to indicate the error.\n\t */\n\tlevel = rt_hw_interrupt_disable();\n\tif (rt_scheduler_lock == RT_TRUE) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn thread_error;\n\t}\n\n\t/*\n\t * Dequeue and wake up each suspended thread from the list one by one until the list is empty.\n\t * If the thread is not suspended, then it is not dequeued from the list and the thread error code is returned to indicate the error.\n\t */\n\twhile ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist))!= RT_NULL) {\n\t\tif (thread->stat!= RT_THREAD_SUSPEND) {\n\t\t\tresult = thread_error;\n\t\t\tbreak;\n\t\t}\n\t\trt_list_remove(&(thread->tlist));\n\t\trt_thread_resume(thread);\n\t}\n\n\t/*\n\t * Release the scheduler lock and ensure that the scheduler is locked.\n\t * If the scheduler is locked, then the scheduler cannot be unlocked and the thread cannot be resumed.\n\t * In this case, the thread error code is returned to indicate the error.\n\t */\n\trt_hw_interrupt_enable(level);\n\tif (rt_scheduler_lock == RT_FALSE) {\n\t\treturn thread_error;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 38.60724604707489}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = rt_console_get_device();\n\trt_device_t new_console;\n\n\tif (name == NULL) {\n\t\treturn old_console;\n\t}\n\n\tnew_console = rt_device_find(name);\n\n\tif (new_console!= old_console && new_console!= RT_NULL) {\n\t\tif (old_console!= RT_NULL) {\n\t\t\trt_device_close(old_console);\n\t\t}\n\n\t\trt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\n\t\trt_console_set_device(new_console);\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 46.68166964384187}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console_device = rt_console_get_device();\n\trt_device_t new_console_device = rt_device_find(name);\n\tif (new_console_device!= RT_NULL && new_console_device!= old_console_device) {\n\t\trt_console_set_device(new_console_device);\n\t}\n\treturn old_console_device;\n}", "CodeBleu_score": 33.191020465520374}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_device = RT_NULL;\n\trt_device_t new_device = RT_NULL;\n\n\t/* Find the new console device by its name */\n\tnew_device = rt_device_find(name);\n\n\t/* Check if the new console device is valid */\n\tif (new_device!= RT_NULL) {\n\t\t/* Check if the new console device is the same as the current console device */\n\t\tif (new_device!= rt_console_device) {\n\t\t\t/* Save the current console device */\n\t\t\told_device = rt_console_device;\n\n\t\t\t/* Close the current console device if it exists */\n\t\t\tif (rt_console_device!= RT_NULL) {\n\t\t\t\trt_device_close(rt_console_device);\n\t\t\t}\n\n\t\t\t/* Open the new console device with read/write and stream flags */\n\t\t\tif (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\t/* Set the new console device as the current console device */\n\t\t\t\trt_console_device = new_device;\n\t\t\t} else {\n\t\t\t\t/* Set the old console device as the current console device */\n\t\t\t\trt_console_device = old_device;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return the old console device */\n\treturn old_device;\n}", "CodeBleu_score": 63.87425429197337}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint length = 0;\n\tstruct rt_object *obj;\n\tstruct rt_object_class *class;\n\n\tclass = rt_object_class_get(type);\n\tif (class == NULL) {\n\t\treturn 0;\n\t}\n\n\trt_spinlock_acquire(&class->lock);\n\tlist_for_each_entry(obj, &class->list, list) {\n\t\tlength++;\n\t}\n\trt_spinlock_release(&class->lock);\n\n\treturn length;\n}", "CodeBleu_score": 27.99555970476829}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint length = 0;\n\tstruct rt_object_class *object_class = rt_object_class_get(type);\n\tif (object_class!= NULL) {\n\t\trt_spinlock_lock(&(object_class->lock));\n\t\tlength = object_class->length;\n\t\trt_spinlock_unlock(&(object_class->lock));\n\t}\n\treturn length;\n}", "CodeBleu_score": 27.739793681479853}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint length = 0;\n\trt_object_t *object;\n\n\tif (type == RT_OBJECT_CLASS_TYPE_ALL) {\n\t\treturn rt_object_get_length(RT_OBJECT_CLASS_TYPE_TASK) + rt_object_get_length(RT_OBJECT_CLASS_TYPE_THREAD) + rt_object_get_length(RT_OBJECT_CLASS_TYPE_MUTEX) + rt_object_get_length(RT_OBJECT_CLASS_TYPE_SEMAPHORE);\n\t}\n\n\trt_spinlock_lock(&rt_object_list_lock);\n\tfor (object = rt_object_list; object!= NULL; object = object->next) {\n\t\tif (object->type == type) {\n\t\t\tlength++;\n\t\t}\n\t}\n\trt_spinlock_unlock(&rt_object_list_lock);\n\n\treturn length;\n}", "CodeBleu_score": 39.506747286675235}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tif (object!= RT_NULL) {\n\t\trt_object_info_t *object_info = &object->info;\n\n\t\trt_object_detach_hook(object);\n\n\t\trt_spinlock_lock(&object_info->lock);\n\n\t\trt_list_remove(&object_info->list);\n\n\t\trt_spinlock_unlock(&object_info->lock);\n\n\t\tobject->type = RT_Object_Type_None;\n\t}\n}", "CodeBleu_score": 28.48894576790288}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_base_t level;\n\trt_object_info_t *info;\n\n\tRT_ASSERT(object!= RT_NULL);\n\n\t/* detach object */\n\tlevel = rt_hw_interrupt_disable();\n\n\tinfo = object->type->info;\n\n\t/* call the hook function for detachment */\n\tif (info->detach!= RT_NULL) {\n\t\tinfo->detach(object);\n\t}\n\n\t/* remove the object from the list */\n\trt_list_remove(&object->list);\n\n\t/* unlock the spinlock */\n\trt_hw_spin_unlock(&info->lock);\n\n\t/* set the object type to zero */\n\tobject->type = RT_NULL;\n\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 34.99613330236463}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_base_t level;\n\n\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* call hook function */\n\tif (rt_object_type_hook[object->type - 1].detach!= RT_NULL) {\n\t\trt_object_type_hook[object->type - 1].detach(object);\n\t}\n\n\t/* lock the object */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* remove the object from its list */\n\trt_list_remove(&object->list);\n\n\t/* unlock the object */\n\trt_hw_interrupt_enable(level);\n\n\t/* set the object type to zero */\n\tobject->type = RT_Object_Class_Unknown;\n}", "CodeBleu_score": 30.403871019318373}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\tif (obj->destroy) {\n\t\trt_err_t result = obj->destroy(obj);\n\t\trt_object_delete(obj);\n\t\treturn result;\n\t}\n\n\trt_object_delete(obj);\n\treturn RT_EOK;\n}", "CodeBleu_score": 44.54327737277038}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result = RT_EOK;\n\trt_base_t level;\n\tstruct rt_object_information *information;\n\n\t/* object check */\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(!(obj->type & RT_Object_Class_Static));\n\n\t/* get object information */\n\tinformation = rt_object_get_information((enum rt_object_class_type)obj->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n\n\t/* remove from old list */\n\trt_list_remove(&(obj->list));\n\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\t/* reset object type */\n\tobj->type = RT_Object_Class_Null;\n\n\t/* free the memory of object */\n\tRT_KERNEL_FREE(obj);\n\n\treturn result;\n}", "CodeBleu_score": 42.43950400080499}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\tif (obj->destroy) {\n\t\trt_err_t err = obj->destroy(obj);\n\t\trt_object_delete(obj);\n\t\treturn err;\n\t} else {\n\t\trt_object_delete(obj);\n\t\treturn RT_EOK;\n\t}\n}", "CodeBleu_score": 37.98309426840112}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\tdef RT_USING_SMP\n    rt_thread_t thread;\n#endif\n    /* enter critical */\n    rt_enter_critical();\n\n    /* get current thread */\n#ifndef RT_USING_SMP\n    thread = rt_thread_self();\n#endif\n\n    /* close current thread */\n    rt_thread_close(thread);\n\n    /* exit critical */\n    rt_exit_critical();\n\n    /* trigger a context switch to the next thread */\n    rt_schedule();\n}", "CodeBleu_score": 35.748847199270315}, {"code": "static void _thread_exit(void){\n\tef RT_USING_HOOK\n    rt_thread_t thread = rt_thread_self();\n    rt_thread_t next_thread;\n\n    /* invoke thread exit hook */\n    if (thread->exit_hook)\n        thread->exit_hook(thread);\n#endif\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* remove from schedule */\n    rt_sched_remove_thread(thread);\n\n    /* add to defunct list */\n    thread->stat = RT_THREAD_DEFUNCT;\n    rt_list_insert_before(&(rt_thread_defunct_list), &(thread->tlist));\n\n    /* exit critical */\n    rt_exit_critical();\n\n    /* schedule */\n    next_thread = rt_schedule();\n\n    /* switch to next thread */\n    rt_schedule_to_thread(next_thread);\n}", "CodeBleu_score": 58.52459152812317}, {"code": "static void _thread_exit(void){\n\tthread_t thread;\n\trt_base_t level;\n\trt_list_t *list;\n\trt_list_t *next;\n\trt_list_t *prev;\n\trt_list_t *tmp;\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* enter critical */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check if the thread is already closed */\n\tif (thread->stat == RT_THREAD_CLOSE)\n\t{\n\t\t/* leave critical */\n\t\trt_hw_interrupt_enable(level);\n\t\treturn;\n\t}\n\n\t/* remove from schedule */\n\trt_sched_remove_thread(thread);\n\n\t/* release thread timer */\n\trt_timer_detach(&(thread->thread_timer));\n\n\t/* change stat */\n\trt_sched_thread_close(thread);\n\n\t/* leave critical */\n\trt_hw_interrupt_enable(level);\n\n\t/* add to defunct list */\n\tlist = &(rt_thread_defunct_list);\n\tprev = list;\n\tnext = list->next;\n\n\twhile (next!= list)\n\t{\n\t\t/* find the last defunct thread */\n\t\tprev = next;\n\t\tnext = next->next;\n\t}\n\n\t/* add to the last defunct thread */\n\tprev->next = &(thread->thread_list);\n\tthread->thread_list.next = list;\n\n\t/* trigger a context switch */\n\trt_schedule();\n\n\t/* never reach here */\n\treturn;\n}", "CodeBleu_score": 54.12008158214885}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\tthread_t *thread = (thread_t *) parameter;\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\t_lock_scheduler();\n\tif (thread->state!= THREAD_SUSPENDED) {\n\t\t_unlock_scheduler();\n\t\treturn;\n\t}\n\tthread->error = ETIME;\n\t_remove_from_list(thread);\n\t_insert_into_ready(thread);\n\t_unlock_scheduler();\n\t_schedule();\n}", "CodeBleu_score": 33.079688601385584}, {"code": "static void _thread_timeout(void *parameter){\n\t\tthread *thread = (thread*) parameter;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\tif (thread->state!= SUSPENDED) {\n\t\treturn;\n\t}\n\n\t_lock_scheduler();\n\n\tthread->error = THREAD_ERROR_TIMEOUT;\n\n\t_remove_thread_from_suspend_list(thread);\n\t_insert_thread_into_ready_list(thread);\n\n\t_unlock_scheduler();\n}", "CodeBleu_score": 33.4947539954525}, {"code": "static void _thread_timeout(void *parameter){\n\t\tthread_t *thread = (thread_t *)parameter;\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\t/* Lock the scheduler */\n\t_scheduler_lock();\n\n\t/* Verify the thread is suspended */\n\tif (thread->state!= THREAD_SUSPENDED) {\n\t\t_scheduler_unlock();\n\t\treturn;\n\t}\n\n\t/* Set the thread's error number */\n\tthread->error = THREAD_ERROR_TIMEOUT;\n\n\t/* Remove the thread from the suspend list */\n\t_list_remove(&thread->suspend_list);\n\n\t/* Insert the thread into the ready list */\n\t_list_insert(&ready_list, &thread->ready_list);\n\n\t/* Unlock the scheduler */\n\t_scheduler_unlock();\n\n\t/* Reschedule */\n\t_scheduler_reschedule();\n}", "CodeBleu_score": 30.758465557971824}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spinlock_lock(&_thread_spinlock);\n\tif (thread->state == RT_THREAD_WAITING) {\n\t\trt_mutex_t mutex = thread->waiting_on;\n\t\tif (mutex) {\n\t\t\trt_mutex_remove_waiting_thread(mutex, thread);\n\t\t\tmutex->pending_thread = NULL;\n\t\t}\n\t}\n\trt_spinlock_unlock(&_thread_spinlock);\n}", "CodeBleu_score": 18.312566213833424}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spinlock_lock(&_thread_spinlock);\n\n\tif (thread->mutex_pending!= NULL) {\n\t\t_mutex_remove_from_wait_list(thread);\n\t\tthread->mutex_pending = NULL;\n\t}\n\n\t_mutex_remove_from_taken_list(thread);\n\n\trt_spinlock_unlock(&_thread_spinlock);\n}", "CodeBleu_score": 13.873188457942117}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_mutex_t mutex;\n\trt_spinlock_t *spinlock;\n\trt_list_t *list;\n\trt_list_t *next;\n\n\tspinlock = &thread->spinlock;\n\trt_spinlock_lock(spinlock);\n\tlist = thread->waiting_list;\n\twhile (list!= NULL) {\n\t\tnext = list->next;\n\t\tmutex = (rt_mutex_t) list->object;\n\t\trt_mutex_unlock(mutex);\n\t\trt_mutex_remove_from_waiting_list(mutex, thread);\n\t\tlist = next;\n\t}\n\trt_spinlock_unlock(spinlock);\n}", "CodeBleu_score": 31.96008772147636}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\trt_thread_priority_t priority;\n\trt_thread_t self;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n\tself = rt_thread_self();\n\tif (self == RT_NULL)\n\t{\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check thread state */\n\tif (thread->stat!= RT_THREAD_INIT)\n\t{\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check thread type */\n\tif (thread->type!= RT_Thread_Type_Normal)\n\t{\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* log thread name and priority */\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\t/* calculate thread priority */\n\tpriority = rt_thread_priority_group_to_max(thread->group);\n\n\t/* reset thread state */\n\tthread->stat = RT_THREAD_SUSPEND;\n\tthread->priority = priority;\n\n\t/* resume thread */\n\terror = rt_thread_resume(thread);\n\n\t/* trigger scheduler if available */\n\tif (error == RT_EOK)\n\t{\n\t\trt_schedule();\n\t}\n\n\treturn error;\n}", "CodeBleu_score": 49.57988819116853}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\trt_uint32_t prio;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n\t/* check the thread is in the initialization state */\n\tif (thread->stat!= RT_THREAD_INIT)\n\t{\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* check the thread is not null */\n\tif (thread->parent.name == RT_NULL)\n\t{\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* log the thread's name and priority */\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\tLOG_D(\"thread priority: %d\", thread->current_priority);\n\n\t/* calculate the thread's priority attributes */\n\tprio = rt_thread_prio_to_bfp(thread->current_priority);\n\n\t/* reset the thread's state to suspended */\n\tthread->stat = RT_THREAD_SUSPEND;\n\n\t/* resume the thread and trigger a scheduler if available */\n\terror = rt_thread_resume(thread);\n\n\t/* return the result */\n\treturn error;\n}", "CodeBleu_score": 52.5080472716792}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\t/* thread startup */\n\terror = rt_thread_startup_hook(thread);\n\n\t/* thread startup failed */\n\tif (error!= RT_EOK)\n\t{\n\t\tLOG_E(\"thread startup failed: %s\", thread->parent.name);\n\t\treturn error;\n\t}\n\n\t/* thread startup successfully */\n\treturn rt_thread_resume(thread);\n}", "CodeBleu_score": 51.75436231635231}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *timer_list_head;\n\trt_timer_t *timer;\n\trt_tick_t timeout_tick_temp;\n\n\tif (timer_list[0].next == &timer_list[0]) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\ttimer_list_head = (rt_list_t *)timer_list[0].next;\n\ttimer = (rt_timer_t *)timer_list_head;\n\n\ttimeout_tick_temp = timer->timeout;\n\t*timeout_tick = timeout_tick_temp;\n\treturn RT_EOK;\n}", "CodeBleu_score": 34.17834642418604}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_timer_t *timer;\n\trt_tick_t tick;\n\n\tlist = &timer_list[0];\n\tif (list->next == list) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\ttimer = rt_list_entry(list->next, rt_timer_t, timer_list);\n\ttick = timer->timeout;\n\tif (tick > *timeout_tick) {\n\t\t*timeout_tick = tick;\n\t}\n\treturn RT_EOK;\n}", "CodeBleu_score": 41.58210910187642}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list_head;\n\trt_tick_t timeout_tick_tmp;\n\trt_timer_t *timer;\n\n\tlist_head = &(timer_list[0]);\n\tif (rt_list_isempty(list_head) == RT_FALSE) {\n\t\ttimer = (rt_timer_t *) rt_list_entry(list_head->next, rt_timer_t, timer_list);\n\t\ttimeout_tick_tmp = timer->timeout;\n\t\tif (timeout_tick_tmp < *timeout_tick) {\n\t\t\t*timeout_tick = timeout_tick_tmp;\n\t\t}\n\t\treturn RT_EOK;\n\t}\n\treturn -RT_ETIMEOUT;\n}", "CodeBleu_score": 43.757780539582406}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\ttimer = rt_malloc(sizeof(struct rt_timer));\n\tif (timer!= RT_NULL) {\n\t\t/* initialize timer */\n\t\t_timer_init(timer, timeout, parameter, time, flag);\n\n\t\t/* add timer to timer system */\n\t\t_timer_add(timer);\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 44.62495452093025}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_HEAP\n    rt_timer_t timer;\n\n    /* check timer name */\n    RT_ASSERT(name!= RT_NULL);\n\n    /* check timeout function */\n    RT_ASSERT(timeout!= RT_NULL);\n\n    /* check time */\n    RT_ASSERT(time > 0);\n\n    /* check flag */\n    RT_ASSERT(flag & RT_TIMER_FLAG_ONE_SHOT);\n\n    /* allocate memory for timer object */\n    timer = (rt_timer_t) rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* set timer name */\n    rt_strncpy(timer->parent.name, name, RT_NAME_MAX);\n\n    /* add timer to timer list */\n    rt_list_insert_after(&(rt_timer_list.timer_list), &(timer->parent.list));\n\n    return timer;\n#else\n    RT_ASSERT(0);\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 63.473887775521185}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer = RT_NULL;\n\n\t/* check parameter */\n\tif (timeout == RT_NULL)\n\t{\n\t\treturn RT_NULL;\n\t}\n\n\t/* allocate memory for timer object */\n\ttimer = (rt_timer_t) rt_malloc(sizeof(struct rt_timer));\n\tif (timer == RT_NULL)\n\t{\n\t\treturn RT_NULL;\n\t}\n\n\t/* initialize timer object */\n\t_timer_init(timer, timeout, parameter, time, flag);\n\n\t/* insert to timer list */\n\trt_list_insert_after(&(timer_list), &(timer->parent.list));\n\n\treturn timer;\n}", "CodeBleu_score": 60.997693399972285}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a recorder to capture the response.\n\trecorder := httptest.NewRecorder()\n\n\t// Pass the request through the handlers.\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(recorder, req)\n\n\t\t// Copy the recorder's headers to the original response.\n\t\tfor name, values := range recorder.Header() {\n\t\t\tres.Header()[name] = values\n\t\t}\n\n\t\t// If the handler returned a 401 Unauthorized status, send a \"Not Authorized\" error response and stop further processing.\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// If all handlers pass without unauthorized status, forward the request to the router for further handling.\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 64.69474239295407}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\n\t// Loop through the handlers\n\tfor _, handler := range a.handlers {\n\t\t// Call the handler and capture the response\n\t\thandler.ServeHTTP(recorder, req)\n\n\t\t// Copy the recorder's headers to the original response\n\t\tfor key, values := range recorder.Header() {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\n\t\t// If the handler returned a \"401 Unauthorized\" status, send a \"Not Authorized\" error response and stop further processing\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// If all handlers pass without unauthorized status, forward the request to the router for further handling\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 53.36699864985237}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder.\n\trecorder := httptest.NewRecorder()\n\t// Create a new request with the same method and URL as the original request.\n\trequest := *req\n\trequest.URL = req.URL\n\trequest.Method = req.Method\n\t// Create a new response with the same status code as the original response.\n\tresponse := &http.Response{\n\t\tStatusCode: res.StatusCode(),\n\t\tStatus:     http.StatusText(res.StatusCode()),\n\t\tProto:      \"HTTP/1.1\",\n\t\tProtoMajor: 1,\n\t\tProtoMinor: 1,\n\t\tHeader:     make(http.Header),\n\t\tBody:       io.NopCloser(bytes.NewReader([]byte(\"\"))),\n\t}\n\t// Iterate through all handlers.\n\tfor _, handler := range a.handlers {\n\t\t// Call the handler.\n\t\thandler(recorder, &request)\n\t\t// If the status code is 401, send a \"Not Authorized\" error response and stop further processing.\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Copy the recorder's headers to the original response.\n\t\tfor key, values := range recorder.HeaderMap {\n\t\t\tfor _, value := range values {\n\t\t\t\tresponse.Header.Add(key, value)\n\t\t\t}\n\t\t}\n\t}\n\t// If all handlers pass without unauthorized status, forward the request to the router for further handling.\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 48.97755543520582}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the URL path\n\tpath := req.URL.Path\n\t// Check if the path is empty\n\tif path == \"\" {\n\t\t// If it is, set the path to the index.html file\n\t\tpath = \"index.html\"\n\t}\n\t// Get the file extension of the path\n\text := filepath.Ext(path)\n\t// Check if the file extension is empty\n\tif ext == \"\" {\n\t\t// If it is, set the file extension to.html\n\t\text = \".html\"\n\t}\n\t// Get the file extension without the dot\n\text = ext[1:]\n\t// Get the file path based on the path and file extension\n\tfile, err := a.assets.Open(path)\n\t// Check for errors\n\tif err!= nil {\n\t\t// If there are errors, return a 404 error\n\t\thttp.Error(res, \"404 Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\t// Get the file content type based on the file extension\n\tcontentType := http.DetectContentType(file)\n\t// Set the Content-Type header based on the file extension\n\tres.Header().Set(\"Content-Type\", contentType)\n\t// Write the file content to the response\n\t_, err = io.Copy(res, file)\n\t// Check for errors\n\tif err!= nil {\n\t\t// If there are errors, return a 500 error\n\t\thttp.Error(res, \"500 Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}", "CodeBleu_score": 41.71302530332659}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the URL path\n\tpath := req.URL.Path\n\n\t// Check if the path is a static asset\n\tif strings.HasPrefix(path, \"/static\") {\n\t\t// Get the requested asset\n\t\tasset := a.assets.Get(path)\n\n\t\t// Check if the asset is found\n\t\tif asset == nil {\n\t\t\t// Return a 404 error if the asset is not found\n\t\t\thttp.NotFound(res, req)\n\t\t\treturn\n\t\t}\n\n\t\t// Set the appropriate Content-Type header based on the file extension\n\t\tcontentType := \"text/plain\"\n\t\tswitch filepath.Ext(path) {\n\t\tcase \".js\":\n\t\t\tcontentType = \"application/javascript\"\n\t\tcase \".css\":\n\t\t\tcontentType = \"text/css\"\n\t\tcase \".html\":\n\t\t\tcontentType = \"text/html\"\n\t\t}\n\t\tres.Header().Set(\"Content-Type\", contentType)\n\n\t\t// Write the asset content to the response\n\t\tres.Write(asset)\n\t\treturn\n\t}\n\n\t// If the path is not a static asset, return a 404 error\n\thttp.NotFound(res, req)\n}", "CodeBleu_score": 43.776052798754925}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// The path of the requested asset\n\tpath := req.URL.Path[1:]\n\n\t// The full path of the requested asset\n\tfullPath := a.assetsPath + \"/\" + path\n\n\t// The file extension of the requested asset\n\text := filepath.Ext(path)\n\n\t// The content type of the requested asset\n\tcontentType := \"text/plain\"\n\n\t// If the file extension is.js, set the content type to \"application/javascript\"\n\tif ext == \".js\" {\n\t\tcontentType = \"application/javascript\"\n\t}\n\n\t// If the file extension is.css, set the content type to \"text/css\"\n\tif ext == \".css\" {\n\t\tcontentType = \"text/css\"\n\t}\n\n\t// If the file extension is.html, set the content type to \"text/html\"\n\tif ext == \".html\" {\n\t\tcontentType = \"text/html\"\n\t}\n\n\t// Open the requested asset\n\tfile, err := os.Open(fullPath)\n\n\t// If an error occurs while opening the asset, return a 404 error\n\tif err!= nil {\n\t\thttp.Error(res, \"Not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Close the asset file when the function returns\n\tdefer file.Close()\n\n\t// Set the content type header of the response\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Write the asset content to the response\n\tio.Copy(res, file)\n}", "CodeBleu_score": 41.61378810912327}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\n\t// Extract robot name from request URL\n\tname := mux.Vars(req)[\"name\"]\n\n\t// Find robot with specified name\n\trobot, err := a.master.FindRobot(name)\n\n\t// If robot is found, gather its connections and convert them to JSON\n\tif err == nil {\n\t\tconnections := robot.GetConnections()\n\t\tjson, err := json.Marshal(connections)\n\t\tif err!= nil {\n\t\t\thttp.Error(res, \"Error converting connections to JSON\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Write JSON response\n\t\t_, err = res.Write(json)\n\t\tif err!= nil {\n\t\t\thttp.Error(res, \"Error writing response\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\t// If robot is not found, write JSON error message\n\t\tjson, err := json.Marshal(struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{\"No robot found with name \" + name})\n\t\tif err!= nil {\n\t\t\thttp.Error(res, \"Error converting error message to JSON\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Write JSON response\n\t\t_, err = res.Write(json)\n\t\tif err!= nil {\n\t\t\thttp.Error(res, \"Error writing response\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 39.8746127939015}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Find the robot with the specified name using the master instance\n\trobot, err := a.master.GetRobot(robotName)\n\n\t// If the robot is not found, write a JSON error message\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{\n\t\t\tError: \"Robot not found\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{\n\t\t\tError: \"Failed to marshal connections\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 37.18789624586746}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tres.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type\")\n\n\t// Extract the robot name from the request URL\n\tpath := req.URL.Path\n\trobotName := path[len(\"/api/v1/robots/\"):]\n\n\t// Find the robot with the specified name\n\trobot, err := a.master.GetRobot(robotName)\n\tif err!= nil {\n\t\t// If the robot is not found, write an error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\n\t\t\t\"error\": \"No robot found with the specified name\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Gather the robot's connections\n\tconnections := robot.GetConnections()\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// If there is an error converting the connections to JSON, write an error message\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\n\t\t\t\"error\": \"Error converting connections to JSON\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 36.15641732926424}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Basic Authentication credentials\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Set the response header to \"Basic realm=Restricted\"\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\t// Set the response status code to 200 OK\n\t\tw.WriteHeader(http.StatusOK)\n\t}\n}", "CodeBleu_score": 49.54774566239563}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorised.\n\"))\n\t\t\treturn\n\t\t}\n\t\t// Get the Basic Authentication credentials\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorised.\n\"))\n\t\t\treturn\n\t\t}\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorised.\n\"))\n\t\t\treturn\n\t\t}\n\t\tw.Write([]byte(\"Authorised.\n\"))\n\t}\n}", "CodeBleu_score": 46.87182188030078}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method!= \"GET\" && r.Method!= \"HEAD\" {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\t// Get the Basic Authentication credentials\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth)!= 2 || auth[0]!= \"Basic\" {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the credentials\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[1])\n\t\tif err!= nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Delegate request to the given handler\n\t\thandler(w, r)\n\t}\n}", "CodeBleu_score": 48.70694865985196}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.63205197792933}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t} else if value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 52.23528045001541}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.980882267028065}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif!a.connected {\n\t\treturn 0, 0, errors.New(\"The connection is not valid\")\n\t}\n\tif!a.analogReadingSupported {\n\t\treturn 0, 0, errors.New(\"The connection does not support analog reading\")\n\t}\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaledValue := float64(rawValue) * a.scaleFactor\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 53.50152061427107}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif!a.connected {\n\t\treturn 0, 0.0, errors.New(\"analog sensor not connected\")\n\t}\n\tif!a.analog {\n\t\treturn 0, 0.0, errors.New(\"analog sensor not configured for analog reading\")\n\t}\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\traw, err := a.pin.Read()\n\tif err!= nil {\n\t\treturn 0, 0.0, err\n\t}\n\ta.lastRaw = raw\n\tscaled := a.scale(raw)\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 42.07879688718845}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn -1, -1, errors.New(\"No connection\")\n\t}\n\tif!a.connection.AnalogReadSupported {\n\t\treturn -1, -1, errors.New(\"AnalogRead not supported\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn -1, -1, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.scale(rawValue)\n\n\treturn rawValue, a.lastScaledValue, nil\n}", "CodeBleu_score": 50.606153084844216}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(value int) float64 {\n\t\treturn toMin + (float64(value)-float64(fromMin))*(toMax-toMin)/(float64(fromMax)-float64(fromMin))\n\t}\n}", "CodeBleu_score": 31.177973707187455}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(value int) float64 {\n\t\tslope := (toMax - toMin) / float64(fromMax-fromMin)\n\t\tintercept := toMin - slope*float64(fromMin)\n\t\treturn slope*float64(value) + intercept\n\t}\n}", "CodeBleu_score": 48.512542012378226}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}", "CodeBleu_score": 47.26855408000424}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td, err := NewAnalogSensorDriver(a, pin, opts...)\n\tif err!= nil {\n\t\tpanic(err)\n\t}\n\n\td.Name = \"Grove Piezo Vibration Sensor\"\n\td.AddEvent(VibrationEvent)\n\n\td.AddEventListener(func(e Event) {\n\t\tif e.Type == DataEvent {\n\t\t\tif e.Data.(int) > 1000 {\n\t\t\t\td.Publish(VibrationEvent, nil)\n\t\t\t}\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 34.50378657990079}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t// Create a new Grove Piezo Vibration Sensor driver.\n\tg := GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\t// Set the default name.\n\tg.SetName(DefaultGrovePiezoVibrationSensorDriverName)\n\n\t// Add a vibration event.\n\tg.AddEvent(VibrationEvent)\n\n\t// Set up an event listener for data events.\n\tg.AddEventListener(func(e Event) {\n\t\tif e.Name() == DataEvent {\n\t\t\tif e.Value().(float64) > 1000 {\n\t\t\t\tg.Publish(VibrationEvent, nil)\n\t\t\t}\n\t\t}\n\t})\n\n\t// Return the initialized driver.\n\treturn &g\n}", "CodeBleu_score": 35.77287918081647}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tvar (\n\t\tname = \"Grove Piezo Vibration Sensor\"\n\t\terr  error\n\t)\n\n\t// Initialize the driver with an AnalogSensorDriver using the provided analog reader, pin, and optional parameters.\n\td := NewAnalogSensorDriver(a, pin, opts...)\n\n\t// Set a default name for the driver.\n\td.SetName(name)\n\n\t// Add a vibration event.\n\td.AddEvent(VibrationEvent)\n\n\t// Set up an event listener for data events that publishes a vibration event if the data exceeds a threshold value of 1000.\n\tif err = d.AddEventListener(func(e *Event) {\n\t\tif e.Data.(int) > 1000 {\n\t\t\td.PublishEvent(VibrationEvent)\n\t\t}\n\t}); err!= nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 40.605220161276684}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn errors.New(\"Tone: frequency must be greater than zero\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"Tone: duration must be greater than zero\")\n\t}\n\n\tperiod := 1000000.0 / hz\n\ttempo := 60000.0 / d.bpm\n\tif tempo < 0 {\n\t\treturn errors.New(\"Tone: bpm must be greater than zero\")\n\t}\n\n\tfor i := 0; i < int(duration*60/tempo); i++ {\n\t\td.on()\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t\td.off()\n\t\ttime.Sleep(time.Duration(tempo-period) * time.Microsecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 44.0194379952056}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn errors.New(\"Tone: invalid frequency\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"Tone: invalid duration\")\n\t}\n\tif d.hz == 0 {\n\t\treturn errors.New(\"Tone: buzzer not initialized\")\n\t}\n\tif d.bpm == 0 {\n\t\treturn errors.New(\"Tone: invalid bpm\")\n\t}\n\t// Calculate the tone period and the number of iterations based on the given frequency and tempo.\n\ttonePeriod := float64(1000000) / (d.hz * 2)\n\titerations := int(tonePeriod * d.bpm / 60000)\n\t// Toggle the buzzer on and off at intervals determined by the tone period.\n\tfor i := 0; i < iterations; i++ {\n\t\tif err := d.Toggle(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Microsecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 44.84433090327231}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif hz <= 0 {\n\t\treturn errors.New(\"Tone: hz must be greater than 0\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"Tone: duration must be greater than 0\")\n\t}\n\tif d.bpm <= 0 {\n\t\treturn errors.New(\"Tone: bpm must be greater than 0\")\n\t}\n\n\tif d.isToneRunning {\n\t\treturn errors.New(\"Tone: tone already running\")\n\t}\n\n\td.isToneRunning = true\n\n\t// Calculate tone period in milliseconds\n\ttonePeriod := 1000.0 / hz\n\n\t// Calculate number of iterations based on tone period and duration\n\titerations := int(duration / tonePeriod)\n\n\t// Calculate delay between iterations in milliseconds\n\tdelay := int(tonePeriod * 1000.0 / d.bpm)\n\n\t// Toggle buzzer on and off at intervals determined by tone period and delay\n\tfor i := 0; i < iterations; i++ {\n\t\terr := d.toggle()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(delay) * time.Millisecond)\n\t}\n\n\t// Turn buzzer off\n\terr := d.toggle()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\td.isToneRunning = false\n\n\treturn nil\n}", "CodeBleu_score": 41.56633045633237}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn errors.New(\"Sleep pin not set\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 28.344536593047398}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\n\td.stopAllOperations()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 29.190280104968135}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn errors.New(\"no sleep pin configured\")\n\t}\n\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 28.381275569618087}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tpin := a.newAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 52.58570982772402}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif!a.pinsMapInitialized {\n\t\treturn nil, errors.New(\"pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pinsMap[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpin, err := a.translateAnalogPin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\ta.pinsMap[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 41.64487653577877}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif!a.initialized {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor not initialized\")\n\t}\n\n\tif a.pins[id]!= nil {\n\t\treturn a.pins[id], nil\n\t}\n\n\tpin, err := a.translatePin(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = a.newAnalogPin(pin)\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 40.336019632820964}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\terr = pin.Write(val)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 65.64749422283256}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.pins.Get(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 60.26343197474298}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 60.38588669940239}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.connected {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor is not connected\")\n\t}\n\n\t// Check if the pin exists.\n\tif pin, ok := a.pins[id]; ok {\n\t\t// Apply the provided options to the pin.\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\t// Translate the ID to obtain chip and line information.\n\tchip, line, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new digital pin and initialize it.\n\tpin := NewDigitalPin(a, chip, line)\n\tpin.Apply(opts...)\n\n\t// Store the pin.\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 43.405336103526686}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor is not connected to any pins\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\tvar err error\n\tvar chip, line int\n\tif chip, line, err = a.translate(id); err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := gobot.NewDigitalPin(id, chip, line)\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 46.33770387653847}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.connected {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor is not connected\")\n\t}\n\n\tpin, err := a.Pin(id)\n\tif err == nil {\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\t\treturn pin, nil\n\t}\n\n\tchip, line, err := a.translate(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin = a.newDigitalPin(chip, line)\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\terr = a.storePin(pin)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 50.730497441205436}]}
