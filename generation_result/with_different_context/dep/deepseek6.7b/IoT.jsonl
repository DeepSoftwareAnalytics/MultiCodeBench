{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * desc_ptr = desc;\n\tuint8_t desc_len;\n\twhile (desc_ptr->bLength) {\n\t\tdesc_len = desc_ptr->bLength;\n\t\tif (desc_ptr->bDescriptorType == desc_id)\n\t\t\treturn desc_ptr;\n\t\tdesc_ptr = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t UDC_DESC_STORAGE *)desc_ptr + desc_len);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 39.07240183924308}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t * ptr = (uint8_t *) desc;\n\tuint8_t * end = (uint8_t *) desc + desc->bLength;\n\twhile (ptr < end) {\n\t\tif (*ptr == desc_id)\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) ptr;\n\t\tptr += *(ptr + 1);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.108407535081255}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *desc_ptr = (uint8_t *) desc;\n\tuint8_t desc_len = desc_ptr[1];\n\n\twhile (desc_len > 0) {\n\t\tuint8_t desc_id_in_desc = desc_ptr[0];\n\t\tif (desc_id_in_desc == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\t}\n\t\tdesc_ptr += desc_len;\n\t\tdesc_len = desc_ptr[1];\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 35.37824870771337}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    struct usb_config_descriptor *config;\n    struct usb_interface_descriptor *iface;\n    struct usb_interface_setting_descriptor *setting;\n\n    if (!udc_cur_config)\n        return false;\n\n    if (iface_num >= udc_cur_config->bNumInterfaces)\n        return false;\n\n    config = &udc_cur_config->descriptor;\n    iface = &config->interface[iface_num];\n\n    if (iface->bNumEndpoints == 0)\n        return false;\n\n    setting = &iface->altsetting[0];\n    if (setting->bInterfaceNumber != iface_num ||\n        setting->bAlternateSetting != setting_num)\n        return false;\n\n    return true;\n}", "CodeBleu_score": 23.03370107078099}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    uint8_t *desc_ptr;\n    uint8_t desc_len;\n    uint8_t desc_type;\n    uint8_t desc_index;\n    uint8_t desc_num;\n    uint8_t desc_value;\n\n    if (usb_config_num == 0) {\n        return false;\n    }\n\n    if (iface_num >= usb_config_desc.num_ifaces) {\n        return false;\n    }\n\n    desc_ptr = (uint8_t *)usb_config_desc.desc_ptr;\n    desc_len = usb_config_desc.desc_len;\n    desc_type = *desc_ptr;\n    desc_index = 1;\n    desc_num = 0;\n    desc_value = 0;\n\n    while (desc_index < desc_len) {\n        desc_num++;\n        desc_index += desc_ptr[desc_index];\n\n        if (desc_ptr[desc_index] == desc_type) {\n            desc_value = desc_ptr[desc_index + 2];\n\n            if (desc_value == setting_num) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 46.432607238210096}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    uint8_t *desc = (uint8_t *) &udc_conf_desc;\n    uint8_t desc_len = udc_conf_desc.bLength;\n    uint8_t iface_num_found = 0;\n    uint8_t setting_num_found = 0;\n\n    while (desc_len > 0) {\n        if (desc[1] == USB_DESC_TYPE_INTERFACE) {\n            if (iface_num_found == iface_num) {\n                if (setting_num_found == setting_num) {\n                    return true;\n                }\n                setting_num_found++;\n            }\n            iface_num_found++;\n        }\n        desc_len = desc[0];\n        desc += desc_len;\n    }\n    return false;\n}", "CodeBleu_score": 34.8796511190787}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t    /* Check if the request length matches the size of the endpoint status variable */\n    if (req.wLength != sizeof(uint8_t)) {\n        return false;\n    }\n\n    /* Determine the status of the specified endpoint */\n    uint8_t ep_status = 0;\n    if (ep_halted[req.wIndex]) {\n        ep_status = USB_ENDPOINT_HALTED;\n    }\n\n    /* Set up the response payload with the endpoint status */\n    res.data[0] = ep_status;\n    res.wLength = 1;\n\n    return true;\n}", "CodeBleu_score": 39.366965488802336}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t", "CodeBleu_score": 3.3394715816443945}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t  uint8_t *p = (uint8_t *)&ep_status;\n  uint8_t len = sizeof(ep_status);\n\n  if (req.wLength < len)\n    return false;\n\n  if (ep_halted[req.wIndex])\n    ep_status = USB_ENDPOINT_STATUS_HALTED;\n  else\n    ep_status = USB_ENDPOINT_STATUS_NORMAL;\n\n  usbd_ep_setup_xfer(req.wIndex, req.wLength, p);\n\n  return true;\n}", "CodeBleu_score": 50.58951595825949}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tbool result;\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tiface_num = udc_setup_req.wIndex.bytes[0];\n\tsetting_num = udc_setup_req.wIndex.bytes[1];\n\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tif (false == udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\tif (false == udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\tresult = udc_udi_req_iface(udc_setup_req.wIndex.bytes[0],\n\t\t\tudc_setup_req.wIndex.bytes[1]);\n\n\treturn result;\n}", "CodeBleu_score": 65.42869215622385}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num = udc_setup_req.wIndex.bytes[0];\n\tuint8_t setting_num = udc_setup_req.wIndex.bytes[1];\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\treturn udc_udi_setup();\n}", "CodeBleu_score": 58.92909119771447}, {"code": "static bool udc_req_iface(void){\n\t", "CodeBleu_score": 1.917982802830473}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t  // Initialize MSC\n  udi_msc_cbw.signature = UDI_MSC_CBW_SIGNATURE;\n  udi_msc_cbw.tag = 0;\n  udi_msc_cbw.transfer_length = 0;\n  udi_msc_cbw.flags = 0;\n  udi_msc_cbw.lun = 0;\n  udi_msc_cbw.length = 10;\n\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 22.589969963849555}, {"code": "bool udi_msc_enable(void){\n\t  // Initialization of the MSC interface\n  udi_msc_cbw_state = UDI_MSC_CBW_STATE_NONE;\n  udi_msc_cbw_lun = 0;\n  udi_msc_cbw_lun_count = udi_msc_get_lun_count();\n  if (udi_msc_cbw_lun_count == 0 || !udi_msc_ext_enable())\n    return false;\n\n  // Unload all LUNs\n  for (udi_msc_cbw_lun = 0; udi_msc_cbw_lun < udi_msc_cbw_lun_count; udi_msc_cbw_lun++)\n    udi_msc_unload_medium(udi_msc_cbw_lun);\n\n  // Start the MSC process\n  udi_msc_cbw_wait();\n  return true;\n}", "CodeBleu_score": 44.10609813525136}, {"code": "bool udi_msc_enable(void){\n\t  // Check if the USB device is already enabled\n  if (udd_is_enabled()) {\n    // If so, then check if the MSC is already enabled\n    if (udi_msc_enabled) {\n      return true;\n    }\n\n    // Get the number of LUNs\n    udi_msc_num_luns = udi_msc_get_num_luns();\n\n    // Check if there are any LUNs\n    if (udi_msc_num_luns == 0) {\n      return false;\n    }\n\n    // Unload the medium on each LUN\n    for (uint8_t lun = 0; lun < udi_msc_num_luns; lun++) {\n      udi_msc_unload_medium(lun);\n    }\n\n    // Enable the MSC interface\n    udi_msc_enabled = true;\n\n    // Wait for a CBW reception\n    udi_msc_cbw_wait();\n  }\n\n  return false;\n}", "CodeBleu_score": 43.6260481813358}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_STATUS_OK) {\n    // Transfer failed\n    // Wait for MSC setup reset\n    udi_msc_sense_set(USB_SENSE_KEY_ILLEGAL_REQUEST,\n        USB_SENSE_ASC_ILLEGAL_REQUEST, USB_SENSE_ASCQ_ILLEGAL_REQUEST);\n    udi_msc_csw.bCSWStatus = USB_CSW_STATUS_FAILED;\n    udi_msc_csw.dCSWDataResidue = 0;\n    udi_msc_csw_process();\n    return;\n  }\n  // Transfer successful\n  // Update sense data\n  if (udi_msc_cbw.bmCBWFlags & USB_CBW_DATA_IN) {\n    udi_msc_sense_set(USB_SENSE_KEY_NO_SENSE, 0, 0);\n  } else {\n    udi_msc_sense_set(USB_SENSE_KEY_NO_SENSE, 0, 0);\n  }\n  // Decrease CSW data residue\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  if (0 == udi_msc_csw.dCSWDataResidue) {\n    udi_msc_sense_pass();\n  }\n  udi_msc_csw_process();\n}", "CodeBleu_score": 50.89512094367199}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  // Check status\n  if (USB_EP_STATUS_OK != status) {\n    // Transfer not successful\n    // then wait for MSC setup reset\n    udi_msc_wait_for_reset();\n  } else {\n    // Transfer successful\n    // then update sense data\n    udi_msc_update_sense();\n    // decrease CSW data residue by amount of data sent\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n    // process CSW\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 62.645031348598245}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_STATUS_OK) {\n    // Transfer failed\n    // Wait for MSC setup reset to restart CBW reception\n    udi_msc_wait_reset();\n    return;\n  }\n  // Transfer successful\n  // Update sense data\n  udi_msc_sense_pass();\n  // Decrease CSW data residue by amount of data sent\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 70.36099432504056}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t  // if there is a non-zero data residue\n  if (udi_msc_cbw.data_residue) {\n    // stall next request from the USB host on the appropriate endpoint based on the direction of the CBW\n    udd_ep_stall(udi_msc_cbw.direction ? UDI_MSC_EP_IN : UDI_MSC_EP_OUT);\n  }\n\n  // prepare CSW\n  // set tag\n  udi_msc_csw.tag = udi_msc_cbw.tag;\n  // convert data residue to little-endian format\n  udi_msc_csw.data_residue = udi_msc_cbw.data_residue;\n}", "CodeBleu_score": 39.631988780465576}, {"code": "static void udi_msc_csw_process(void){\n\t  // Prepare CSW\n  udi_msc_csw.dwSignature = UDI_MSC_CSW_SIGNATURE;\n  udi_msc_csw.dwTag = udi_msc_cbw.dwTag;\n  udi_msc_csw.dwDataResidue = udi_msc_cbw.dwDataLength - udd_ep_get_xferred(UDI_MSC_EP_IN);\n  udi_msc_csw.bStatus = udi_msc_cbw.bStatus;\n  udi_msc_csw.bStatus = (uint8_t) (udi_msc_csw.bStatus | udi_msc_cbw.bStatus);\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 52.53061033463591}, {"code": "static void udi_msc_csw_process(void){\n\t  uint32_t residue;\n  uint32_t csw_tag;\n  uint8_t *csw_ptr;\n  uint8_t *cbw_ptr;\n  uint8_t cbw_dir;\n\n  csw_ptr = (uint8_t *) & udi_msc_csw;\n  cbw_ptr = (uint8_t *) & udi_msc_cbw;\n\n  // Get data residue\n  residue = udi_msc_cbw.datalen - udi_msc_cbw.data_residue;\n\n  // Get tag from CBW\n  csw_tag = udi_msc_cbw.tag;\n\n  // Get direction from CBW\n  cbw_dir = (cbw_ptr[7] & 0x80) >> 7;\n\n  // Set tag in CSW\n  csw_ptr[0] = csw_tag;\n  csw_ptr[1] = csw_tag >> 8;\n  csw_ptr[2] = csw_tag >> 16;\n  csw_ptr[3] = csw_tag >> 24;\n\n  // Convert data residue to little-endian format\n  csw_ptr[4] = residue;\n  csw_ptr[5] = residue >> 8;\n  csw_ptr[6] = residue >> 16;\n  csw_ptr[7] = residue >> 24;\n\n  // Set CSW status\n  csw_ptr[8] = udi_msc_cbw.status;\n\n  // Send CSW\n  udi_msc_csw_send();\n\n  // If there is a non-zero data residue\n  if (residue) {\n    // Stall the next request on the appropriate endpoint\n    if (cbw_dir) {\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    } else {\n      udd_ep_stall(UDI_MSC_EP_IN);\n    }\n  }\n}", "CodeBleu_score": 41.59459491686389}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t  // If the DTR signal is enabled, cancel any scheduled reset\n  if (b_enable) {\n    cancelReset();\n  }\n\n  // If the DTR signal is disabled, schedule a reset if the rate is 1200\n  else {\n    if (g_usb_cdc_dtr_rate[port] == 1200) {\n      initiateReset();\n    }\n  }\n\n  // Update the DTR status\n  g_usb_cdc_dtr_status[port] = b_enable;\n}", "CodeBleu_score": 44.31140804021981}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    // Check if the DTR signal is enabled or disabled\n    if (b_enable) {\n        // Update the DTR status\n        usb_task_cdc_dtr_status[port] = true;\n        // If the DTR rate is 1200 and the DTR signal is disabled, schedule a delayed system reset\n        if (usb_task_cdc_dtr_rate[port] == USB_CDC_DTR_RATE_1200 && !usb_task_cdc_dtr_status[port]) {\n            // Write to the reset controller\n            reset_controller_write(RESET_CONTROLLER_RESET_TYPE_SYSTEM, RESET_CONTROLLER_RESET_ACTION_RESET);\n            // Call the \"initiateReset\" function\n            initiateReset();\n        }\n    } else {\n        // Update the DTR status\n        usb_task_cdc_dtr_status[port] = false;\n        // If the DTR signal is enabled, cancel any scheduled reset\n        if (usb_task_cdc_dtr_status[port]) {\n            // Call the \"cancelReset\" function\n            cancelReset();\n        }\n    }\n}", "CodeBleu_score": 32.55895664169444}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t", "CodeBleu_score": 10.31471527023918}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t  bool result = false;\n  uint8_t request_type = usb_get_request_type();\n  uint8_t request_index = usb_get_request_index();\n\n  if (request_type == USB_REQUEST_TYPE_VENDOR) {\n    if (request_index == 0x04) {\n      uint16_t descriptor_size = usb_get_descriptor_size();\n      uint8_t *descriptor_pointer = usb_get_descriptor_pointer();\n      uint16_t *descriptor_size_pointer = (uint16_t *) descriptor_pointer;\n      uint8_t *descriptor_pointer_pointer = descriptor_pointer + 2;\n\n      *descriptor_size_pointer = usb_get_descriptor_size();\n      *descriptor_pointer_pointer = usb_get_descriptor_pointer()[0];\n\n      usb_set_descriptor_size(sizeof(uint16_t));\n      usb_set_descriptor_pointer((uint8_t *) descriptor_size_pointer);\n\n      result = true;\n    } else if (request_index == 0x05) {\n      uint16_t descriptor_size = usb_get_descriptor_size();\n      uint8_t *descriptor_pointer = usb_get_descriptor_pointer();\n      uint16_t *descriptor_size_pointer = (uint16_t *) descriptor_pointer;\n      uint8_t *descriptor_pointer_pointer = descriptor_pointer + 2;\n\n      *descriptor_size_pointer = usb_get_descriptor_size();\n      *descriptor_pointer_pointer = usb_get_descriptor_pointer()[0];\n\n      usb_set_descriptor_size(sizeof(uint16_t));\n      usb_set_descriptor_pointer((uint8_t *) descriptor_size_pointer);\n\n      result = true;\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 17.39888853504035}, {"code": "bool usb_task_other_requests(void){\n\t    if (usb_request_type == USB_REQUEST_TYPE_VENDOR) {\n        switch (usb_request_index) {\n            case 0x04:\n                usb_control_request_payload = (uint8_t *) &usb_microsoft_id_descriptor;\n                usb_control_request_size = sizeof(usb_microsoft_id_descriptor);\n                return true;\n            case 0x05:\n                usb_control_request_payload = (uint8_t *) &usb_microsoft_extended_properties_descriptor;\n                usb_control_request_size = sizeof(usb_microsoft_extended_properties_descriptor);\n                return true;\n            default:\n                return false;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 22.753994813408777}, {"code": "bool usb_task_other_requests(void){\n\t  // Check if the request type is vendor-specific and the request index is either 0x04 or 0x05\n  if (usb_request.bmRequestType == (USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_IN) && (usb_request.bRequest == 0x04 || usb_request.bRequest == 0x05)) {\n    // Set up pointers and sizes for Microsoft-compatible ID and extended properties descriptors\n    uint8_t *id_ptr = (uint8_t *)&usb_request.wValue;\n    uint8_t *ext_ptr = (uint8_t *)&usb_request.wIndex;\n    uint8_t id_size = *id_ptr;\n    uint8_t ext_size = *ext_ptr;\n\n    // Update the control request payload and size accordingly\n    usb_request.wLength = id_size + ext_size;\n    usb_request.data = (uint8_t *)&usb_request.wValue;\n\n    // Return true to indicate that the request is processed\n    return true;\n  }\n\n  // Return false to indicate that the request index is not recognized\n  return false;\n}", "CodeBleu_score": 20.915730941666926}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0) {\n    return;\n  }\n  for (uint16_t i = 0; i < nbyte - 1; i++) {\n    spiTrans(0x00);\n    buf[i] = spiRec();\n  }\n  buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 55.667710828053615}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    uint8_t dummy = 0x00;\n    if (!nbyte) return;\n    for (uint16_t i = 0; i < nbyte; i++) {\n        spiSend(dummy);\n        buf[i] = spiRec();\n    }\n    spiSend(dummy);\n    buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 60.152323376681096}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  uint16_t i;\n\n  if (!nbyte)\n    return;\n  for (i = 0; i < nbyte; i++)\n    buf[i] = spiRec();\n  spiRec();\n}", "CodeBleu_score": 47.28633850784405}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  pfnISR_Handler originalHandler;\n  pfnISR_Handler *pISR = (pfnISR_Handler *)&NVIC_VECTTAB[irq];\n\n  // Disable interrupts\n  __disable_irq();\n\n  // Get the current handler\n  originalHandler = *pISR;\n\n  // Replace the handler\n  *pISR = newHandler;\n\n  // Enable interrupts\n  __enable_irq();\n\n  return originalHandler;\n}", "CodeBleu_score": 48.19062158092008}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    uint32_t *vectors = (uint32_t *)0x20000000;\n    uint32_t *oldHandler = (uint32_t *)vectors[irq];\n    uint32_t *newHandlerVec = (uint32_t *)newHandler;\n\n    disable_interrupts();\n    vectors[irq] = (uint32_t)newHandlerVec;\n    enable_interrupts();\n\n    return (pfnISR_Handler)oldHandler;\n}", "CodeBleu_score": 44.93023870285831}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t  pfnISR_Handler oldHandler;\n  uint32_t *pISR_Table = (uint32_t *)NVIC_BASE;\n  uint32_t *pISR_Table_Offset = pISR_Table + irq;\n  uint32_t oldISR = *pISR_Table_Offset;\n  uint32_t newISR = (uint32_t)newHandler;\n\n  // disable interrupts\n  __disable_irq();\n\n  // save the old ISR\n  oldHandler = (pfnISR_Handler)oldISR;\n\n  // set the new ISR\n  *pISR_Table_Offset = newISR;\n\n  // enable interrupts\n  __enable_irq();\n\n  // return the old ISR\n  return oldHandler;\n}", "CodeBleu_score": 44.89840883851094}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t    if (!enabled || !configured) {\n        return -1;\n    }\n    if (usb_serial.available()) {\n        int c = usb_serial.read();\n        if (emergency_parser) {\n            emergency_parser->process(c);\n        }\n        return c;\n    }\n    return -1;\n}", "CodeBleu_score": 26.83533516028907}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (cdc_enabled && cdc_configured && cdc_connected) {\n    int c = -1;\n    if (usb_serial.available()) {\n      c = usb_serial.read();\n      if (emergency_parser_enabled && emergency_parser_parser) {\n        emergency_parser_parser->parse(c);\n      }\n    }\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 37.46584790939805}, {"code": "int MarlinSerialUSB::peek(){\n\t  int c = -1;\n  if (cdc_enable) {\n    if (usb_serial_available()) {\n      c = usb_serial_getchar();\n      if (emergency_parser_enabled) {\n        emergency_parser(c);\n      }\n    }\n  }\n  return c;\n}", "CodeBleu_score": 35.71955825273312}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t    int ch = -1;\n\n    if (emergency_parser_enabled) {\n        ch = emergency_parser.read();\n    }\n    if (ch == -1) {\n        if (!usb_cdc_enabled || !usb_cdc_configured) {\n            return -1;\n        }\n        ch = usb_serial.read();\n        if (ch == -1) {\n            return -1;\n        }\n        emergency_parser.parse(ch);\n    }\n    return ch;\n}", "CodeBleu_score": 41.744137862603395}, {"code": "int MarlinSerialUSB::read(){\n\t    // Check if there is a pending character\n    if (pendingChar >= 0) {\n        int c = pendingChar;\n        pendingChar = -1;\n        return c;\n    }\n\n    // Check if the USB CDC is enabled and configured\n    if (!usbCdcEnabled || !usbCdcConfigured) {\n        return -1;\n    }\n\n    // Check if there are any bytes available to read from the PC\n    if (!usbCdc.available()) {\n        return -1;\n    }\n\n    // Read a byte from the PC\n    int c = usbCdc.read();\n\n    // Update the emergency parser if enabled\n    if (emergencyParserEnabled) {\n        emergencyParser.parse(c);\n    }\n\n    return c;\n}", "CodeBleu_score": 51.33138671710482}, {"code": "int MarlinSerialUSB::read(){\n\t  // Check if there is a pending character\n  if (pendingChar != -1) {\n    int c = pendingChar;\n    pendingChar = -1;\n    return c;\n  }\n\n  // Check if the USB CDC is enabled and configured\n  if (!usb_serial_enabled || !usb_serial_configured) {\n    return -1;\n  }\n\n  // Check if there are any bytes available to read from the PC\n  if (!usb_serial_available()) {\n    return -1;\n  }\n\n  // Read the byte and update the emergency parser if enabled\n  int c = usb_serial_getchar();\n  if (emergency_parser_enabled) {\n    emergency_parser.feed(c);\n  }\n\n  return c;\n}", "CodeBleu_score": 48.02020630851169}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t  if (USB_SERIAL_AVAILABLE()) {\n    return USB_SERIAL_AVAILABLE();\n  } else {\n    return USB_SERIAL_CDC_AVAILABLE();\n  }\n}", "CodeBleu_score": 32.92376811424149}, {"code": "int MarlinSerialUSB::available(){\n\t  if (SerialUSB.available())\n    return SerialUSB.available();\n  else\n    return (usb_cdc_enabled && usb_cdc_ready) ? 1 : 0;\n}", "CodeBleu_score": 42.91754727206632}, {"code": "int MarlinSerialUSB::available(){\n\t  if (USB_SERIAL_AVAILABLE()) {\n    return USB_SERIAL_AVAILABLE();\n  }\n  return (int)USB_SERIAL_CDC_READY();\n}", "CodeBleu_score": 32.905512140445644}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  uint8_t b;\n  while (size--) {\n    b = ee_Read(pos++);\n    if (writing)\n      *value++ = b;\n    crc16(crc, &b, 1);\n  }\n  return false;\n}", "CodeBleu_score": 51.9571961587568}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (!size) return true;\n  if (pos < 0) return false;\n  if (pos >= EEPROMSize) return false;\n  if (pos + size > EEPROMSize) return false;\n  if (!value && !crc) return false;\n\n  while (size--) {\n    uint8_t b = ee_Read(pos++);\n    if (value) *value++ = b;\n    if (crc) *crc = (uint16_t)((*crc << 8) ^ (uint16_t)b);\n  }\n\n  return true;\n}", "CodeBleu_score": 45.89887963876593}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  if (pos < 0)\n    return false;\n\n  while (size--) {\n    uint8_t c = ee_Read(pos++);\n    if (crc)\n      crc16(crc, &c, 1);\n    if (value && writing)\n      *value++ = c;\n  }\n  return false;\n}", "CodeBleu_score": 60.663506685005196}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n  // Software PWM\n  if (pin >= MAX_PWM_IOPIN) return; // Not a PWM pin\n  uint8_t pwm = value >> 1;\n  if (pwm == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (pwm == 255) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  uint8_t *p = pwm_state;\n  for (uint8_t i = 0; i < PWM_MAX_NUM; i++) {\n    if (p[0] == pin) {\n      p[1] = pwm;\n      return;\n    }\n    p += 2;\n  }\n  // Not found, allocate new slot\n  if (pwm_num >= PWM_MAX_NUM) return;\n  p = pwm_state + pwm_num * 2;\n  p[0] = pin;\n  p[1] = pwm;\n  pwm_num++;\n  if (pwm_num == 1) {\n    ledcSetup(0, freq, res);\n    ledcAttachPin(pin, 0);\n  }\n  ledcWrite(0, pwm);\n}", "CodeBleu_score": 52.170632292988095}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) {\n      ledcWrite(cid, value);\n      return;\n    }\n  }\n  // Software PWM\n  if (pin >= MAX_PWM_IOPIN) return;\n  uint8_t pwm_value = value >> 1; // convert to 7-bit\n  if (pwm_value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (pwm_value == 255) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  if (pwm_value > 255) pwm_value = 255;\n  uint8_t slot = find_pwm_slot(pin);\n  if (slot == -1) {\n    slot = alloc_pwm_slot(pin);\n    if (slot == -1) return;\n  }\n  pwm_slot[slot].value = pwm_value;\n  if (pwm_slot[slot].value == 0) {\n    digitalWrite(pin, LOW);\n  }\n  else {\n    if (pwm_slot[slot].value == 255) {\n      digitalWrite(pin, HIGH);\n    }\n    else {\n      if (pwm_slot[slot].value > pwm_slot[slot].last_value) {\n        pwm_slot[slot].last_value = pwm_slot[slot].value;\n        pwm_slot[slot].timer.begin(pwm_slot[slot].freq, pwm_slot[slot].value);\n      }\n      else {\n        pwm_slot[slot].timer.update(pwm_slot[slot].value);\n      }\n    }\n  }\n}", "CodeBleu_score": 50.652072810286754}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n  // No PWM channels available?\n  for (int i = 0; i < PWM_MAX_CHANNELS; i++) {\n    if (pwm_state[i].pin == pin) {\n      pwm_state[i].value = value;\n      return;\n    }\n  }\n  // No PWM state for this pin, allocate a new slot\n  for (int i = 0; i < PWM_MAX_CHANNELS; i++) {\n    if (pwm_state[i].pin == 0) {\n      pwm_state[i].pin = pin;\n      pwm_state[i].value = value;\n      pwm_state[i].freq = freq;\n      pwm_state[i].res = res;\n      pwm_state[i].used = 1;\n      if (i == 0) start_pwm_timer(); // First PWM pin, start timer\n      return;\n    }\n  }\n}", "CodeBleu_score": 62.34958457220014}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == NUM_SERVO_CHANNELS, \"Servo delay array length does not match the number of servo channels.\");\n  if (attach()) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 56.334886516465346}, {"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == NUM_SERVOS,\n                \"servo_delay array length does not match number of servos\");\n  if (attach(pin)) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 56.11992046540968}, {"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == NUM_SERVOS, \"Servo delay array length does not match the number of servos.\");\n  if (attach(pin)) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 56.29973877205603}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t  for (int i = 0; i < NUM_PINS; i++) {\n    if (pwm_state[i].duty_cycle == 0) {\n      continue;\n    }\n    if (pwm_state[i].tick_count == 0) {\n      pwm_state[i].port_data ^= pwm_state[i].pin_mask;\n      pwm_state[i].tick_count = pwm_state[i].duty_cycle;\n    } else {\n      pwm_state[i].tick_count--;\n    }\n    pwm_state[i].dma_buffer[pwm_state[i].dma_pos] = pwm_state[i].port_data;\n    pwm_state[i].dma_pos++;\n    if (pwm_state[i].dma_pos == DMA_BUFFER_SIZE) {\n      pwm_state[i].dma_pos = 0;\n    }\n  }\n}", "CodeBleu_score": 35.06739273447832}, {"code": "void i2s_push_sample(){\n\t  // Loop through all pins\n  for (int i = 0; i < NUM_PINS; i++) {\n    // Check if the pin has active PWM\n    if (pwm_pins[i].duty_cycle > 0) {\n      // Decrement the PWM tick count\n      pwm_pins[i].tick_count--;\n\n      // If the PWM tick count reaches zero, toggle the pin state\n      if (pwm_pins[i].tick_count == 0) {\n        // Toggle the pin state\n        pwm_pins[i].state = !pwm_pins[i].state;\n\n        // Set the tick count for the next transition\n        pwm_pins[i].tick_count = pwm_pins[i].duty_cycle;\n      }\n\n      // Update the port data for the pin\n      if (pwm_pins[i].state) {\n        // Set the pin high\n        port_data |= (1 << i);\n      } else {\n        // Set the pin low\n        port_data &= ~(1 << i);\n      }\n    }\n  }\n\n  // Write the updated port data to the DMA buffer\n  *dma_buffer_ptr = port_data;\n\n  // Increment the DMA buffer position\n  dma_buffer_ptr++;\n}", "CodeBleu_score": 38.97406364517314}, {"code": "void i2s_push_sample(){\n\t  // Update PWM states for each pin\n  for (int i = 0; i < NUM_PINS; i++) {\n    if (pins[i].pwm_enabled) {\n      if (pins[i].pwm_tick_count == 0) {\n        pins[i].pwm_state = !pins[i].pwm_state;\n        pins[i].pwm_tick_count = pins[i].pwm_tick_high;\n      } else {\n        pins[i].pwm_tick_count--;\n      }\n    }\n  }\n\n  // Write updated port data to DMA buffer\n  uint32_t port_data = 0;\n  for (int i = 0; i < NUM_PINS; i++) {\n    if (pins[i].pwm_enabled) {\n      port_data |= (pins[i].pwm_state << pins[i].pin_number);\n    }\n  }\n  dma_buffer[dma_buffer_pos] = port_data;\n  dma_buffer_pos++;\n}", "CodeBleu_score": 36.03702504428152}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t  uint8_t i;\n  hal_timer_t count = 0;\n\n  /*\n   * Check if the timer number is valid.\n   */\n  if (timer_num > TIMER_COUNT) {\n    return count;\n  }\n\n  /*\n   * Loop through the timer configuration array and find the timer with the specified number.\n   */\n  for (i = 0; i < TIMER_COUNT; i++) {\n    if (timer_config[i].timer_num == timer_num) {\n      /*\n       * If the timer is configured as a 16-bit timer, read the counter value from the appropriate register.\n       */\n      if (timer_config[i].timer_type == TIMER_16BIT) {\n        count = timer_config[i].timer_reg->TIMx_CNT;\n      }\n      /*\n       * If the timer is configured as a 32-bit timer, read the counter value from the appropriate register.\n       */\n      else if (timer_config[i].timer_type == TIMER_32BIT) {\n        count = timer_config[i].timer_reg->TIMx_CNT;\n      }\n      /*\n       * If the timer is configured as a 16-bit auto-reload timer, read the counter value from the appropriate register.\n       */\n      else if (timer_config[i].timer_type == TIMER_16BIT_AUTORELOAD) {\n        count = timer_config[i].timer_reg->TIMx_CNT;\n      }\n      /*\n       * If the timer is configured as a 32-bit auto-reload timer, read the counter value from the appropriate register.\n       */\n      else if (timer_config[i].timer_type == TIMER_32BIT_AUTORELOAD) {\n        count = timer_config[i].timer_reg->TIMx_CNT;\n      }\n    }\n  }\n\n  /*\n   * Return the counter value.\n   */\n  return count;\n}", "CodeBleu_score": 40.377040993361845}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\n  hal_timer_t timer_count;\n\n  switch (timer_num) {\n\n    case 0:\n      timer_count = TIMER_0_COUNT;\n      break;\n\n    case 1:\n      timer_count = TIMER_1_COUNT;\n      break;\n\n    case 2:\n      timer_count = TIMER_2_COUNT;\n      break;\n\n    case 3:\n      timer_count = TIMER_3_COUNT;\n      break;\n\n    default:\n      timer_count = 0;\n      break;\n  }\n\n  return timer_count;\n}", "CodeBleu_score": 29.40100995114654}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t timer_count;\n\n    if (timer_num < HAL_TIMER_NUM) {\n        timer_count = timer_config[timer_num].timer_count;\n    } else {\n        timer_count = HAL_TIMER_ERROR;\n    }\n\n    return timer_count;\n}", "CodeBleu_score": 36.88920604028407}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint16_t crc_calc = 0;\n  for (size_t i = 0; i < size; i++) {\n    uint8_t b = EEPROM.read(pos + i);\n    crc16(&crc_calc, &b, 1);\n    if (writing)\n      value[i] = b;\n  }\n  if (crc)\n    *crc = crc_calc;\n  pos += size;\n  return false;\n}", "CodeBleu_score": 68.33973910791681}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint16_t crc_tmp = 0;\n  uint16_t crc_read = 0;\n  uint8_t *ptr = value;\n  for (size_t i = 0; i < size; i++) {\n    uint8_t data = EEPROM.read(pos);\n    pos++;\n    if (writing)\n      *ptr = data;\n    ptr++;\n    crc_tmp = (uint16_t)(crc_tmp ^ (uint16_t)(((uint16_t)data) << 8));\n    for (uint8_t i = 0; i < 8; i++)\n      crc_tmp = (uint16_t)((crc_tmp & 0x8000) ? ((uint16_t)(crc_tmp << 1) ^ 0x1021) : (crc_tmp << 1));\n  }\n  crc_read = EEPROM.read(pos) << 8;\n  pos++;\n  crc_read |= EEPROM.read(pos);\n  pos++;\n  if (crc_read != crc_tmp) {\n    return false;\n  }\n  if (crc)\n    *crc = crc_read;\n  return true;\n}", "CodeBleu_score": 51.46740963526235}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  uint16_t crc_calc = 0;\n  for (size_t i = 0; i < size; i++) {\n    value[i] = EEPROM.read(pos + i);\n    crc16(&crc_calc, &value[i], 1);\n    if (writing)\n      EEPROM.write(pos + i, value[i]);\n  }\n  if (crc) {\n    *crc = crc_calc;\n    if (crc_calc != EEPROM.read(pos + size) || crc_calc != EEPROM.read(pos + size + 1))\n      return false;\n  }\n  pos += size + 2;\n  return true;\n}", "CodeBleu_score": 59.26415470912851}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  uint8_t retryCount = 0;\n  while (retryCount < MAX_RETRY_COUNT) {\n    if (SDIO_WriteBlock_Retry(block, src)) {\n      return true;\n    }\n    retryCount++;\n  }\n  printf(\"SDIO_WriteBlock failed after %d retries\n\", MAX_RETRY_COUNT);\n  return false;\n}", "CodeBleu_score": 26.89136809612268}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  uint8_t retries = 0;\n  while (retries < 3) {\n    if (SDIO_WriteBlock_Internal(block, src)) {\n      return true;\n    }\n    retries++;\n  }\n  printf(\"SDIO_WriteBlock: failed to write block %d\n\", block);\n  return false;\n}", "CodeBleu_score": 21.793826551426086}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  int32_t retries = 0;\n  bool success = false;\n\n  /* Check if the SDIO handle and source pointer are not null. */\n  if (sdio_handle == NULL || src == NULL) {\n    return false;\n  }\n\n  /* Try to write the block, retrying up to a defined number of times if the write operation fails. */\n  while (retries < SDIO_MAX_RETRIES && !success) {\n    /* Send the command to write a block of data to the SD card. */\n    SDIO_SendCommand(sdio_handle, SDIO_CMD_WRITE_MULTIPLE_BLOCK, block, SDIO_WRITE_MULTIPLE_BLOCK_LENGTH, SDIO_WRITE_MULTIPLE_BLOCK_ARGUMENTS);\n\n    /* Wait for the response to the command. */\n    SDIO_WaitForResponse(sdio_handle, SDIO_CMD_WRITE_MULTIPLE_BLOCK);\n\n    /* Send the data to the SD card. */\n    SDIO_SendData(sdio_handle, src, SDIO_WRITE_MULTIPLE_BLOCK_LENGTH);\n\n    /* Wait for the response to the data. */\n    SDIO_WaitForResponse(sdio_handle, SDIO_CMD_WRITE_MULTIPLE_BLOCK);\n\n    /* Check if the write operation was successful. */\n    if (SDIO_GetResponse(sdio_handle, SDIO_CMD_WRITE_MULTIPLE_BLOCK) == SDIO_RESPONSE_ACCEPTED) {\n      success = true;\n    } else {\n      /* If the write operation failed, retry up to a defined number of times. */\n      retries++;\n    }\n  }\n\n  /* If the write operation succeeded, return true. */\n  if (success) {\n    return true;\n  }\n\n  /* If the write operation failed after all retries, print an error message and return false. */\n  printf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n  return false;\n}", "CodeBleu_score": 40.17924305472605}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  switch (timer_num) {\n    case TEMPERATURE_TIMER:\n      // Set the timer prescaler to 1024\n      TIM1->PSC = 1024 - 1;\n      // Set the timer period to achieve the desired frequency\n      TIM1->ARR = (uint32_t) ((16000000 / (1024 * frequency)) - 1);\n      // Enable the timer update interrupt\n      TIM1->DIER |= TIM_DIER_UIE;\n      // Set the callback priority for temperature\n      NVIC_SetPriority(TIM1_UP_IRQn, TEMPERATURE_TIMER_PRIORITY);\n      // Enable the timer update interrupt in the NVIC\n      NVIC_EnableIRQ(TIM1_UP_IRQn);\n      // Enable the timer\n      TIM1->CR1 |= TIM_CR1_CEN;\n      break;\n    case STEPPER_TIMER:\n      // Set the timer prescaler to 1024\n      TIM2->PSC = 1024 - 1;\n      // Set the timer period to achieve the desired frequency\n      TIM2->ARR = (uint32_t) ((16000000 / (1024 * frequency)) - 1);\n      // Enable the timer update interrupt\n      TIM2->DIER |= TIM_DIER_UIE;\n      // Set the callback priority for stepper\n      NVIC_SetPriority(TIM2_IRQn, STEPPER_TIMER_PRIORITY);\n      // Enable the timer update interrupt in the NVIC\n      NVIC_EnableIRQ(TIM2_IRQn);\n      // Enable the timer\n      TIM2->CR1 |= TIM_CR1_CEN;\n      break;\n    default:\n      // Trigger an assertion failure if the timer channel is invalid\n      assert_param(0);\n  }\n}", "CodeBleu_score": 30.535639798831614}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\n  switch (timer_num) {\n    case TEMPERATURE_TIMER:\n      timer_start(TEMPERATURE_TIMER_CHANNEL, frequency, TEMPERATURE_TIMER_PRESCALE, TEMPERATURE_TIMER_PRIORITY);\n      break;\n    case STEPPER_TIMER:\n      timer_start(STEPPER_TIMER_CHANNEL, frequency, STEPPER_TIMER_PRESCALE, STEPPER_TIMER_PRIORITY);\n      break;\n    default:\n      assert_param(0);\n      break;\n  }\n}", "CodeBleu_score": 23.44378580001726}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t  // Check if the timer channel is valid\n  if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n    // Start the temperature timer with the given frequency and temperature timer prescale\n    timer_start(TEMPERATURE_TIMER, frequency, TIMER_PRESCALE_TEMPERATURE);\n    // Set the callback priority for temperature\n    timer_set_callback_priority(TEMPERATURE_TIMER, TIMER_CALLBACK_PRIORITY_TEMPERATURE);\n  } else if (timer_num == TIMER_CHANNEL_STEPPER) {\n    // Start the step timer with the given frequency and stepper timer prescale\n    timer_start(STEPPER_TIMER, frequency, TIMER_PRESCALE_STEPPER);\n    // Set the callback priority for stepper\n    timer_set_callback_priority(STEPPER_TIMER, TIMER_CALLBACK_PRIORITY_STEPPER);\n  } else {\n    // Trigger an assertion failure if the timer channel is invalid\n    assert_param(0);\n  }\n}", "CodeBleu_score": 39.699808915729115}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  if (EEPROM.begin(EEPROM_SIZE)) {\n    EEPROM.get(EEPROM_SIZE - sizeof(uint32_t), _eraseValue);\n    if (EEPROM.size() < EEPROM_SIZE) {\n      memset(EEPROM.getDataPtr(), _eraseValue, EEPROM_SIZE - EEPROM.size());\n    }\n    EEPROM.end();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 21.5905466487864}, {"code": "bool PersistentStore::access_start(){\n\t  if (!SD.begin(SD_CS)) {\n    return false;\n  }\n\n  File file = SD.open(FILE_NAME);\n  if (!file) {\n    return false;\n  }\n\n  size_t file_size = file.size();\n  if (file_size < EEPROM_SIZE) {\n    memset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n  }\n\n  file.read(buffer, EEPROM_SIZE);\n  file.close();\n  return true;\n}", "CodeBleu_score": 34.42504586112197}, {"code": "bool PersistentStore::access_start(){\n\t  // Open the file\n  if (!file.open(fileName, O_RDWR | O_CREAT)) {\n    return false;\n  }\n\n  // Check the file size\n  size_t fileSize = file.size();\n  if (fileSize < EEPROM_SIZE) {\n    // Fill the remainder of the buffer with a default erase value\n    memset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE - fileSize);\n  }\n\n  // Read the file's contents into the buffer\n  file.read(buffer, EEPROM_SIZE);\n\n  // Close the file\n  file.close();\n\n  return true;\n}", "CodeBleu_score": 24.267583593617935}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t r = 0;\n  uint8_t i;\n  for (i = 0; i < 8; i++) {\n    HAL_SPI_STM32_Set_Clock_Pin(LOW);\n    HAL_SPI_STM32_Set_Mosi_Pin((b & 0x80) != 0);\n    HAL_SPI_STM32_Set_Clock_Pin(HIGH);\n    r <<= 1;\n    if (HAL_SPI_STM32_Get_Miso_Pin()) {\n      r |= 1;\n    }\n    b <<= 1;\n  }\n  HAL_SPI_STM32_Delay_us(1);\n  return r;\n}", "CodeBleu_score": 41.31121641114092}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t r = 0;\n  uint8_t i;\n\n  for (i = 0; i < 8; i++) {\n    // Set the clock pin low\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);\n\n    // Write the most significant bit of the byte to the MOSI pin\n    if (b & 0x80) {\n      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_SET);\n    } else {\n      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_RESET);\n    }\n\n    // Toggle the clock pin high\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);\n\n    // Read the bit from the MISO pin\n    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14) == GPIO_PIN_SET) {\n      r |= 0x80;\n    }\n\n    // Shift the byte left\n    b <<= 1;\n  }\n\n  // Return the received byte\n  return r;\n}", "CodeBleu_score": 38.923208655121734}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t  uint8_t i;\n  uint8_t r = 0;\n  for (i = 0; i < 8; i++) {\n    HAL_SPI_STM32_Set_Clock_Low();\n    HAL_SPI_STM32_Set_Mosi(b & 0x80);\n    HAL_SPI_STM32_Set_Clock_High();\n    r = (r << 1) | HAL_SPI_STM32_Get_Miso();\n    b = b << 1;\n  }\n  HAL_SPI_STM32_Delay_us(1000);\n  return r;\n}", "CodeBleu_score": 37.04276141221929}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 48.78704953512367}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 48.78704953512367}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 48.78704953512367}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  // If there is no parity error, read the byte and store it in the receive buffer\n  if (!(obj->hw->status & SERIAL_STATUS_PARITY_ERROR)) {\n    uint8_t data = obj->hw->data;\n    if (obj->rx_buffer_head < obj->rx_buffer_tail + obj->rx_buffer_size) {\n      obj->rx_buffer[obj->rx_buffer_head & (obj->rx_buffer_size - 1)] = data;\n      obj->rx_buffer_head++;\n    }\n  }\n\n  // Calculate the next buffer index and update the head pointer\n  obj->rx_buffer_head &= (obj->rx_buffer_size - 1);\n\n  // If enabled, update the emergency parser with the received byte\n  if (obj->emergency_parser_enabled) {\n    obj->emergency_parser_update(data);\n  }\n}", "CodeBleu_score": 38.307448431709815}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t    // If the serial port is not enabled, we don't need to do anything\n    if (!(obj->port->CR1 & USART_CR1_UE))\n        return;\n\n    // Get the serial object from the USART object\n    MarlinSerial *serial = static_cast<MarlinSerial *>(obj->port);\n\n    // Check if there is space in the receive buffer\n    if (serial->_rx_buffer_head < SERIAL_RX_BUFFER_SIZE) {\n        // Read the received byte\n        uint8_t byte = obj->port->RDR;\n\n        // Check if there is space in the emergency parser buffer\n        if (serial->_emergency_parser_head < SERIAL_RX_BUFFER_SIZE) {\n            // Store the byte in the emergency parser buffer\n            serial->_emergency_parser_buffer[serial->_emergency_parser_head] = byte;\n            // Increment the head pointer\n            serial->_emergency_parser_head++;\n        }\n\n        // Store the byte in the receive buffer\n        serial->_rx_buffer[serial->_rx_buffer_head] = byte;\n        // Increment the head pointer\n        serial->_rx_buffer_head++;\n    }\n\n    // Calculate the next buffer index\n    serial->_rx_buffer_head &= SERIAL_RX_BUFFER_SIZE - 1;\n}", "CodeBleu_score": 37.25773013358156}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  if (obj->rx_buffer) {\n    // Get the byte and update the index\n    uint8_t b = obj->uart->getc();\n    obj->rx_index = (obj->rx_index + 1) & (obj->rx_buffer_size - 1);\n\n    // Check if the buffer is full\n    if (obj->rx_index == obj->rx_buffer_head) {\n      // If so, discard the byte\n      //obj->uart->putc(b);\n      return;\n    }\n\n    // Store the byte in the buffer\n    obj->rx_buffer[obj->rx_index] = b;\n\n    // Update the head pointer\n    obj->rx_buffer_head = obj->rx_index;\n\n    // If enabled, update the emergency parser with the received byte\n    if (obj->emergency_parser) {\n      obj->emergency_parser->rx_char(b);\n    }\n  }\n}", "CodeBleu_score": 39.9499185479108}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\n    if (timer_num == MF_TIMER_STEP) {\n        TIMER_STEP_IRQ_attach(Step_Handler);\n    } else if (timer_num == MF_TIMER_TEMP) {\n        TIMER_TEMP_IRQ_attach(Temp_Handler);\n    }\n}", "CodeBleu_score": 21.65896604099405}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (timer_num == MF_TIMER_STEP) {\n    TIMER_STEP_IRQ_ENABLE();\n    TIMER_STEP_IRQ_SET_PRIORITY(TIMER_STEP_IRQ_PRIORITY);\n  } else if (timer_num == MF_TIMER_TEMP) {\n    TIMER_TEMP_IRQ_ENABLE();\n    TIMER_TEMP_IRQ_SET_PRIORITY(TIMER_TEMP_IRQ_PRIORITY);\n  }\n}", "CodeBleu_score": 21.206272389936125}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        attachInterrupt(digitalPinToInterrupt(MF_TIMER_STEP_PIN), Step_Handler, CHANGE);\n    } else if (timer_num == MF_TIMER_TEMP) {\n        attachInterrupt(digitalPinToInterrupt(MF_TIMER_TEMP_PIN), Temp_Handler, CHANGE);\n    }\n}", "CodeBleu_score": 31.030836116533322}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\thash, pow := HashStrRev(sep)\n\tfor i := len(s); i >= len(sep); i-- {\n\t\tif s[i-1] != sep[len(sep)-1] {\n\t\t\tcontinue\n\t\t}\n\t\th := uint32(0)\n\t\tfor j := 0; j < len(sep); j++ {\n\t\t\th = h*PrimeRK + uint32(s[i+j-1])\n\t\t}\n\t\tif h == hash && s[i-1:i+len(sep)-1] == sep {\n\t\t\treturn i - 1\n\t\t}\n\t\thash *= pow\n\t\thash += uint32(s[i-1])\n\t}\n\treturn -1\n}", "CodeBleu_score": 39.20177461075599}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\thash, pow := HashStrRev(sep)\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif s[i+len(sep)-1] != sep[len(sep)-1] {\n\t\t\tcontinue\n\t\t}\n\t\tif hash*pow == HashStr(s[i:i+len(sep)]) {\n\t\t\tif s[i:i+len(sep)] == sep {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 32.00190102487087}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\thashSep, pow := HashStrRev(sep)\n\thash := uint32(0)\n\tfor i := len(sep) - 1; i >= 0; i-- {\n\t\thash = hash*PrimeRK + uint32(s[i])\n\t}\n\tif hash == hashSep && s[len(s)-len(sep):] == sep {\n\t\treturn len(s) - len(sep)\n\t}\n\tfor i := len(s) - len(sep) - 1; i >= 0; i-- {\n\t\thash *= PrimeRK\n\t\thash += uint32(s[i])\n\t\thash -= pow * uint32(s[i+len(sep)])\n\t\tif hash == hashSep && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 51.53627152311737}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.waitTxc = false\n\tusbcdc.txc = false\n\tusbcdc.txc = false\n\tusbcdc.waitTxc = false\n}", "CodeBleu_score": 18.906491653722924}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t", "CodeBleu_score": 2.9310803108831127}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tirqMask := usbcdc.DisableInterrupts()\n\ttxc := usbcdc.GetTxc()\n\tif txc > 0 {\n\t\tusbcdc.SendUSBInPacket(txc)\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tusbcdc.RestoreInterrupts(irqMask)\n}", "CodeBleu_score": 50.39164116696848}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.ctrl.Clear().Start().Set()\n\ti2c.waitForInterrupt(i2c.ctrl.HasStarted())\n\ti2c.write(address << 1 | i2c.writeFlag(write))\n}", "CodeBleu_score": 27.44786306231385}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.ctrl.Set(I2C_CTRL_START)\n\ti2c.waitForInterrupt(I2C_CTRL_START)\n\ti2c.data.Set(address << 1)\n\tif !write {\n\t\ti2c.data.Set(i2c.data.Get() | 0x01)\n\t}\n\ti2c.ctrl.Set(i2c.ctrl.Get() | I2C_CTRL_TX)\n\ti2c.waitForInterrupt(I2C_CTRL_TX)\n}", "CodeBleu_score": 32.01674840629797}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.Set(i2c.control.Get() | sclk.I2C_CTRL_I2CEN | sclk.I2C_CTRL_MST | sclk.I2C_CTRL_TX | sclk.I2C_CTRL_STT)\n\tfor i2c.control.Get() & sclk.I2C_CTRL_I2CEN == 0 {\n\t}\n\ti2c.data.Set(address << 1)\n\tif write {\n\t\ti2c.data.Set(i2c.data.Get() &^ sclk.I2C_DATA_RD)\n\t} else {\n\t\ti2c.data.Set(i2c.data.Get() | sclk.I2C_DATA_RD)\n\t}\n}", "CodeBleu_score": 30.261391925686652}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tstartAddr := f.startAddr + uint32(start)*uint32(f.blockSize)\n\tendAddr := startAddr + uint32(len)*uint32(f.blockSize)\n\n\tf.waitForFlash()\n\tf.flash.Erase(startAddr, endAddr)\n\n\tfor f.flash.IsBusy() {\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\n\tf.flash.SetReadMode()\n\treturn nil\n}", "CodeBleu_score": 31.34812638355968}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tf.WaitForNotBusy()\n\tf.config.Erase()\n\n\tfor i := start; i < start+len; i++ {\n\t\taddr := uint32(i * f.config.BlockSize)\n\t\tf.flash.EraseBlock(addr)\n\t\tf.WaitForNotBusy()\n\t}\n\n\tf.config.Read()\n\treturn nil\n}", "CodeBleu_score": 37.23561130810455}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif f.busy {\n\t\treturn ErrBusy\n\t}\n\n\tif start < 0 || len < 0 {\n\t\treturn ErrInvalid\n\t}\n\n\tstartAddr := uint32(start) * uint32(f.blockSize)\n\n\tf.busy = true\n\n\tf.flash.Erase(startAddr, uint32(len)*uint32(f.blockSize))\n\n\tfor f.flash.Busy() {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\tf.flash.Configure(machine.FLASH_MODE_READ)\n\n\tf.busy = false\n\n\treturn nil\n}", "CodeBleu_score": 34.14017097479515}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\n\tstart := f.offset + off\n\tend := start + int64(len(p))\n\n\tif start < f.offset || end > f.offset+f.size {\n\t\treturn 0, ErrOutOfBounds\n\t}\n\n\tpad := int64(f.writeBlockSize) - (end-start)%int64(f.writeBlockSize)\n\n\tif pad < int64(len(p)) {\n\t\tp = append(p, make([]byte, pad)...)\n\t}\n\n\tif err := f.controller.EnableWrite(); err != nil {\n\t\treturn 0, err\n\t}\n\n\tfor i := start; i < end; i += int64(f.writeBlockSize) {\n\t\tif err := f.controller.Write(i, p[i-start:i-start+int64(f.writeBlockSize)]); err != nil {\n\t\t\treturn int(i - start), err\n\t\t}\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 35.25763495735533}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\t// Check if the write operation exceeds the flash memory bounds\n\tif off < 0 || off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, ErrInvalidWriteOffset\n\t}\n\n\t// Calculate the start address for writing\n\tstart := uint32(off)\n\n\t// Pad the byte slice to fit the write block size\n\tpad := f.WriteBlockSize() - (start % f.WriteBlockSize())\n\tif pad > uint32(len(p)) {\n\t\tpad = uint32(len(p))\n\t}\n\tp = append(p[:pad], make([]byte, f.WriteBlockSize()-pad)...)\n\n\t// Enable write mode on the flash memory controller\n\tf.controller.EnableWriteMode()\n\n\t// Write the data in blocks\n\tfor i := uint32(0); i < uint32(len(p)); i += f.WriteBlockSize() {\n\t\t// Calculate the block address\n\t\taddr := start + i\n\n\t\t// Wait for the flash memory to be ready\n\t\tf.controller.WaitReady()\n\n\t\t// Write the block data\n\t\tf.controller.Write(addr, p[i:i+f.WriteBlockSize()])\n\t}\n\n\t// Wait for the flash memory to be ready\n\tf.controller.WaitReady()\n\n\t// Disable write mode on the flash memory controller\n\tf.controller.DisableWriteMode()\n\n\t// Return the number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 36.43997589435494}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off >= f.size {\n\t\treturn 0, ErrOutOfRange\n\t}\n\tif off+int64(len(p)) > f.size {\n\t\treturn 0, ErrOutOfRange\n\t}\n\n\tstart := off\n\tend := off + int64(len(p))\n\n\t// Pad the input data to the block size\n\tpad := f.blockSize - len(p)%f.blockSize\n\tp = append(p, make([]byte, pad)...)\n\n\t// Enable write mode\n\tif err := f.enableWriteMode(); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Write the data in blocks\n\tfor start < end {\n\t\tblock := p[start-off : start-off+int64(f.blockSize)]\n\t\tif err := f.writeBlock(start, block); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tstart += int64(f.blockSize)\n\t}\n\n\t// Wait for the flash memory to be ready\n\tif err := f.waitForReady(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 33.87957226796885}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar err error\n\tvar dir uintptr\n\n\tfd2, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fd2)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(fd2)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 78.68797342620391}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar err error\n\tvar dir *syscall.Dirent\n\tvar dirp *os.File\n\tvar fd2 syscallFd\n\tvar n int\n\n\tfd2, err = syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdirp, err = syscall.Fdopendir(fd2)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tsyscall.Close(fd2)\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tn, err = dirp.Readdir([]syscall.Dirent{dir})\n\t\tif n == 1 {\n\t\t\tbreak\n\t\t}\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tdirp.Close()\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\n\tdirp.Close()\n\treturn uintptr(fd2), dir.Name, nil\n}", "CodeBleu_score": 58.348148133403136}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tfd2, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdirp, err := syscall.Fdopendir(fd2)\n\t\tif err != nil {\n\t\t\tsyscall.Close(fd2)\n\t\t\tif err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn 0, \"\", err\n\t\t}\n\t\treturn uintptr(fd2), dirp.Name, nil\n\t}\n}", "CodeBleu_score": 60.84013992995112}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t", "CodeBleu_score": 2.073033576343574}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  uint32_t size = 0;\n\n  if (response == sketchSize_t::FREE_SPACE) {\n    size = ESP.getFreeSketchSpace();\n  } else {\n    size = ESP.getSketchSize();\n  }\n\n  return size;\n}", "CodeBleu_score": 22.609091168058665}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    if (response == sketchSize_t::free) {\n        return ESP.getFreeSketchSpace();\n    }\n    return ESP.getSketchSize();\n}", "CodeBleu_score": 14.124188122352866}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t required_sectors = msc_update_get_required_disk_sectors();\n  if (required_sectors == 0) {\n    log_e(\"Not enough memory to setup disk\");\n    return false;\n  }\n  if (!msc_update_disk_alloc(required_sectors)) {\n    log_e(\"Not enough memory to setup disk\");\n    return false;\n  }\n  msc_update_boot_sector_setup(volume_label, serial_number);\n  msc_update_fat_setup();\n  if (msc_run_partition) {\n    msc_update_add_root_dir_entry(msc_run_partition);\n  }\n  return true;\n}", "CodeBleu_score": 27.130466750138304}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    if (offset % SPI_FLASH_SEC_SIZE) {\n        ESP_LOGE(TAG, \"offset is not aligned with sector size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"offset + size is greater than partition size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        esp_err_t err = esp_partition_erase_range(partition, offset, size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase sector at offset 0x%08x: %s\", offset, esp_err_to_name(err));\n            return err;\n        }\n    }\n\n    esp_err_t err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data to partition at offset 0x%08x: %s\", offset, esp_err_to_name(err));\n    }\n    return err;\n}", "CodeBleu_score": 51.666431497042}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    if (offset % partition->flash_size != 0) {\n        ESP_LOGE(TAG, \"Offset is not aligned with flash sector size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    if (offset % partition->flash_size == 0) {\n        esp_err_t err = esp_partition_erase_range(partition, offset, size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase sector at offset 0x%08x: %s\", offset, esp_err_to_name(err));\n            return err;\n        }\n    }\n\n    esp_err_t err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write to partition: %s\", esp_err_to_name(err));\n    }\n\n    return err;\n}", "CodeBleu_score": 54.07709435767243}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    size_t sector_size = esp_partition_get_sector_size(partition);\n    if (offset % sector_size != 0) {\n        ESP_LOGE(TAG, \"offset 0x%08x is not aligned with sector size 0x%08x\", offset, sector_size);\n        return ESP_FAIL;\n    }\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"offset 0x%08x + size 0x%08x exceeds partition size 0x%08x\", offset, size, partition->size);\n        return ESP_FAIL;\n    }\n    if (offset % sector_size == 0 && size >= sector_size) {\n        err = esp_partition_erase_range(partition, offset, size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"erase failed: %s\", esp_err_to_name(err));\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"write failed: %s\", esp_err_to_name(err));\n        return err;\n    }\n    return ESP_OK;\n}", "CodeBleu_score": 54.2108052844636}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  while (i < maxlen && *in) {\n    uint8_t a = hex_char_to_byte(*in++);\n    uint8_t b = hex_char_to_byte(*in++);\n    if (a != 0x10 && b != 0x10) {\n      out[i++] = (a << 4) | b;\n    }\n  }\n  return i;\n}", "CodeBleu_score": 36.37838752218177}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t outlen = 0;\n  while (*in && outlen < maxlen) {\n    uint8_t c = *in++;\n    if (c == ' ' || c == '\\t' || c == '\\r' || c == '\n') continue;\n    uint8_t n = hex_char_to_byte(c);\n    if (n == 0x10) break;\n    c = *in++;\n    if (c == ' ' || c == '\\t' || c == '\\r' || c == '\n') continue;\n    n |= hex_char_to_byte(c) << 4;\n    *out++ = n;\n    outlen++;\n  }\n  return outlen;\n}", "CodeBleu_score": 42.261223596737466}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t len = 0;\n  uint8_t c;\n  while ((c = *in++) != 0) {\n    if (len >= maxlen)\n      break;\n    uint8_t b = hex_char_to_byte(c);\n    if (b >= 0x10)\n      continue;\n    c = *in++;\n    if (c == 0)\n      break;\n    b = (b << 4) | hex_char_to_byte(c);\n    if (b >= 0x10)\n      continue;\n    out[len++] = b;\n  }\n  return len;\n}", "CodeBleu_score": 45.09437062953746}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t  if (!tx_ring_buffer || !tx_lock) {\n    return 0;\n  }\n\n  if (!xSemaphoreTake(tx_lock, 1000)) {\n    return 0;\n  }\n\n  int free_size = tx_ring_buffer->availableForWrite();\n  xSemaphoreGive(tx_lock);\n\n  return free_size;\n}", "CodeBleu_score": 53.65507563400359}, {"code": "int HWCDC::availableForWrite(void){\n\t  if (!_tx_ring_buffer || !_tx_ring_buffer_lock) return 0;\n  if (!xSemaphoreTake(_tx_ring_buffer_lock, _lock_timeout)) return 0;\n  int free_size = _tx_ring_buffer->availableForWrite();\n  xSemaphoreGive(_tx_ring_buffer_lock);\n  return free_size;\n}", "CodeBleu_score": 44.99465181404022}, {"code": "int HWCDC::availableForWrite(void){\n\t  int freeSize = 0;\n  if (transmitRingBuffer == NULL || transmitRingBufferLock == NULL) {\n    return 0;\n  }\n  if (xSemaphoreTake(transmitRingBufferLock, 1000) == pdTRUE) {\n    freeSize = xRingbufferGetFreeSize(transmitRingBuffer);\n    xSemaphoreGive(transmitRingBufferLock);\n  }\n  return freeSize;\n}", "CodeBleu_score": 57.97941637338479}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  // Locking the serial mutex\n  lock();\n  // Assigning the provided callback function to \"_onReceiveCB\"\n  _onReceiveCB = function;\n  // Configuring the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n  if (onlyOnTimeout) {\n    _rxTimeout = millis() + _rxTimeout;\n  } else {\n    _rxTimeout = 0;\n  }\n  // If the callback is not NULL, it sets the FIFO full threshold and creates an event task if it does not already exist\n  if (_onReceiveCB) {\n    // Setting the FIFO full threshold\n    _fifo.setThreshold(ARDUINO_SERIAL_RX_FIFO_FULL_THRESHOLD);\n    // Creating an event task if it does not already exist\n    if (!_eventTask) {\n      _createEventTask(NULL);\n    }\n  }\n  // Unlocking the serial mutex\n  unlock();\n}", "CodeBleu_score": 42.10863284168239}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  // Locking the serial mutex\n  _lock();\n\n  // Assigning the provided callback function to \"_onReceiveCB\"\n  _onReceiveCB = function;\n\n  // Configuring the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n  if (onlyOnTimeout) {\n    // If \"onlyOnTimeout\" is true, set the FIFO full threshold to 0 and the receive timeout to 0\n    _rxTimeout = 0;\n    _fifo_full_threshold = 0;\n  } else {\n    // If \"onlyOnTimeout\" is false, set the FIFO full threshold to 0 and the receive timeout to the value of \"_rxTimeout\"\n    _fifo_full_threshold = 0;\n  }\n\n  // If the callback is not NULL, set the FIFO full threshold and create an event task if it does not already exist\n  if (_onReceiveCB != NULL) {\n    _fifo_full_threshold = _rx_buffer.size() - 1;\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n  }\n\n  // Unlocking the serial mutex\n  _unlock();\n}", "CodeBleu_score": 47.02119327793175}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  if (function == NULL) {\n    _onReceiveCB = NULL;\n    return;\n  }\n  if (onlyOnTimeout) {\n    _rxTimeout = 0;\n  }\n  _onReceiveCB = function;\n  if (_onReceiveCB != NULL) {\n    // Set FIFO full threshold\n    uart_fifo_format(this->_uart_nr, UART_FIFO_FULL_TRIGGER_THRESHOLD, 1);\n    // Create event task if not already created\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n  }\n}", "CodeBleu_score": 40.328697793089816}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t i = 0;\n  while (i < length) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    buffer[i++] = (char)c;\n    if ((char)c == terminator) {\n      break;\n    }\n  }\n  buffer[i] = 0;  // null terminate the string\n  return i;\n}", "CodeBleu_score": 77.14419618632087}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t i = 0;\n  while (i < length) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    buffer[i++] = (char)c;\n    if ((char)c == terminator) {\n      break;\n    }\n  }\n  buffer[i] = 0;\n  return i;\n}", "CodeBleu_score": 74.39818799252404}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    }\n    buffer[index++] = (char)c;\n    if ((char)c == terminator) {\n      break;\n    }\n  }\n  buffer[index] = '\\0';\n  return index;\n}", "CodeBleu_score": 80.29336179154411}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_v(\"tone(pin=%d, frequency=%d, duration=%lu)\", pin, frequency, duration);\n\n  // Check if the pin is available or already in use\n  if (tone_is_available(pin)) {\n    // Initialize the tone\n    tone_init();\n\n    // Send a start command with the pin, frequency, and duration to a queue\n    tone_msg_t msg = {\n      .cmd = TONE_START,\n      .pin = pin,\n      .frequency = frequency,\n      .duration = duration\n    };\n    xQueueSend(_tone_queue, &msg, portMAX_DELAY);\n  } else {\n    log_e(\"Pin %d is already in use\", pin);\n  }\n}", "CodeBleu_score": 57.15675123269695}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  if (_tone_queue == NULL) {\n    tone_init();\n  }\n  if (_tone_task == NULL) {\n    tone_init();\n  }\n\n  log_v(\"tone(%d, %d, %d)\", pin, frequency, duration);\n  if (tone_is_available(pin)) {\n    tone_init_pin(pin);\n    tone_msg_t msg;\n    msg.pin = pin;\n    msg.frequency = frequency;\n    msg.duration = duration;\n    msg.type = TONE_START;\n    xQueueSend(_tone_queue, &msg, 0);\n  } else {\n    log_e(\"Tone on pin %d is already in use\", pin);\n  }\n}", "CodeBleu_score": 49.036405005992265}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  if (_tone_queue == NULL) {\n    tone_init();\n  }\n\n  if (tone_is_pin_available(pin)) {\n    tone_init_pin(pin);\n    tone_msg_t msg = {\n      .type = TONE_START,\n      .pin = pin,\n      .frequency = frequency,\n      .duration = duration\n    };\n    if (xQueueSend(_tone_queue, &msg, 0) == pdFALSE) {\n      log_e(\"Could not send start command to queue\");\n    }\n  } else {\n    log_e(\"Tone on pin %d is already in use. Stop the current tone first.\", pin);\n  }\n}", "CodeBleu_score": 55.04298658312958}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (!_usbStarted) {\n        _webUSBBusy = true;\n        _webUSBBusy = false;\n        return true;\n    }\n    if (enabled) {\n        if (_usbVersion < 0x0210) {\n            return false;\n        }\n        _webUSBBusy = true;\n        _webUSBBusy = false;\n        return true;\n    }\n    _webUSBBusy = true;\n    _webUSBBusy = false;\n    return true;\n}", "CodeBleu_score": 31.900679053970737}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (usb_started) {\n    if (enabled) {\n      usb_set_config(0x0210);\n    }\n    usb_webusb_enable(enabled);\n  }\n  return !usb_started;\n}", "CodeBleu_score": 43.692228965454184}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t  if (usb_started) {\n    return false;\n  }\n  webusb_enabled = enabled;\n  if (enabled) {\n    usb_version = 0x0210;\n  }\n  return true;\n}", "CodeBleu_score": 47.53649251951655}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t  int len = _serial->available();\n  if (len > 0) {\n    int i = 0;\n    while (i < len) {\n      uint8_t b = _serial->read();\n      if (!_rx_queue.push(b)) {\n        _overflow_count++;\n        _overflow_event.post(1);\n        _logger->log(LogLevel::Error, \"USBCDC: RX queue overflow, dropped %d bytes\", _overflow_count);\n      }\n      i++;\n    }\n    _rx_event.post(len);\n  }\n}", "CodeBleu_score": 20.865208595147404}, {"code": "void USBCDC::_onRX(){\n\t    int n = usb_serial_available();\n    if (n <= 0) return;\n    if (n > RX_BUF_SIZE) {\n        n = RX_BUF_SIZE;\n        usb_serial_flush_input();\n    }\n    int nr = usb_serial_read(rx_buf, n);\n    if (nr <= 0) return;\n    for (int i = 0; i < nr; i++) {\n        if (!rx_queue.push(rx_buf[i])) {\n            if (overflow_cb) overflow_cb(nr - i);\n            break;\n        }\n    }\n    if (rx_cb) rx_cb(nr);\n}", "CodeBleu_score": 31.47442785356821}, {"code": "void USBCDC::_onRX(){\n\t    int len = _dev->read(_buf, sizeof(_buf));\n    if (len > 0) {\n        for (int i = 0; i < len; i++) {\n            if (!_rx_queue.push(_buf[i])) {\n                _overflow_count++;\n                _dev->error(\"USBCDC receive queue overflow, dropped %d bytes\", _overflow_count);\n            }\n        }\n        _dev->post_event(EVENT_RX, len);\n    }\n}", "CodeBleu_score": 26.370817513826488}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\trobotName := mux.Vars(req)[\"robotName\"]\n\n\trobot, err := a.store.GetRobot(robotName)\n\tif err != nil {\n\t\ta.respond(res, req, http.StatusNotFound, errorResponse{Error: err.Error()})\n\t\treturn\n\t}\n\n\tdevices, err := a.store.GetDevices(robot)\n\tif err != nil {\n\t\ta.respond(res, req, http.StatusInternalServerError, errorResponse{Error: err.Error()})\n\t\treturn\n\t}\n\n\ta.respond(res, req, http.StatusOK, devices)\n}", "CodeBleu_score": 35.32567108208122}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot, err := a.robots.GetByName(robotName)\n\tif err != nil {\n\t\ta.respond(res, http.StatusNotFound, \"no robot found with name \"+robotName)\n\t\treturn\n\t}\n\n\tdevices, err := a.devices.GetByRobotID(robot.ID)\n\tif err != nil {\n\t\ta.respond(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\ta.respond(res, http.StatusOK, devices)\n}", "CodeBleu_score": 31.25841391097773}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\n\tname := chi.URLParam(req, \"name\")\n\trobot, err := a.store.GetRobot(name)\n\tif err != nil {\n\t\ta.respond(res, req, http.StatusNotFound, errorResponse{Error: \"no robot found with that name\"})\n\t\treturn\n\t}\n\n\tdevices, err := a.store.GetDevices(robot.ID)\n\tif err != nil {\n\t\ta.respond(res, req, http.StatusNotFound, errorResponse{Error: \"no devices found for that robot\"})\n\t\treturn\n\t}\n\n\ta.respond(res, req, http.StatusOK, devices)\n}", "CodeBleu_score": 34.520341051778004}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobotName = strings.TrimSuffix(robotName, \"/connections\")\n\n\trobot, err := a.robotStore.FindByName(robotName)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"No robot with the name %s was found\", robotName)))\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\n\tconnectionsJson, err := json.Marshal(connections)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJson)\n}", "CodeBleu_score": 38.9720289683695}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with the specified name was found\"))\n\t\treturn\n\t}\n\n\tconnections := make([]string, 0, len(robot.Connections))\n\tfor _, conn := range robot.Connections {\n\t\tconnections = append(connections, conn.String())\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(fmt.Sprintf(`{\"connections\": %s}`, connections)))\n}", "CodeBleu_score": 43.68237743798574}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robot/\")\n\trobotName = strings.TrimSuffix(robotName, \"/connections\")\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with the specified name was found\"))\n\t\treturn\n\t}\n\n\tconnections := []Connection{}\n\tfor _, connection := range robot.connections {\n\t\tconnections = append(connections, connection)\n\t}\n\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(\"Error marshaling connections to JSON\"))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 38.185141465964755}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\trobot, err := a.robotManager.GetRobot(robotName)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\tdevice, err := robot.GetDevice(deviceName)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\tswitch command {\n\tcase \"on\":\n\t\tdevice.On()\n\tcase \"off\":\n\t\tdevice.Off()\n\tcase \"toggle\":\n\t\tdevice.Toggle()\n\tdefault:\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"Invalid command\"))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(\"Command executed successfully\"))\n}", "CodeBleu_score": 48.553535762248906}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"Robot not found\"))\n\t\treturn\n\t}\n\n\tdevice, ok := robot.Devices[deviceName]\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"Device not found\"))\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\"command\")\n\tvalue := req.URL.Query().Get(\"value\")\n\n\terr := device.Command(command, value)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(\"Command executed successfully\"))\n}", "CodeBleu_score": 49.354564631633316}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\trobot := a.Robots[robotName]\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Robot %s not found\", robotName)))\n\t\treturn\n\t}\n\n\tdevice := robot.Devices[deviceName]\n\tif device == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Device %s not found\", deviceName)))\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\"command\")\n\terr := device.Command(command)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(fmt.Sprintf(\"Error executing command: %s\", err.Error())))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(fmt.Sprintf(\"Command %s executed on device %s\", command, deviceName)))\n}", "CodeBleu_score": 49.31887505648014}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(username, pair[0]) || !secureCompare(password, pair[1]) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tr.SetBasicAuth(pair[0], pair[1])\n\t}\n}", "CodeBleu_score": 48.66388734556545}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\tuserColonPass, err := base64.StdEncoding.DecodeString(strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(userColonPass), \":\", 2)\n\t\tif len(pair) != 2 || !secureCompare(username, pair[0]) || !secureCompare(password, pair[1]) {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 50.69810826116262}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(username, user) || !secureCompare(password, pass) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.849850766632834}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scaleRaw(raw)\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 45.64367624202885}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.supportsAnalogRead {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor does not support analog reading\")\n\t}\n\n\trawValue, err := a.sensor.ReadAnalog()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaledValue := a.scaleValue(rawValue)\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 50.314282448599556}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.supportsAnalog {\n\t\treturn 0, 0, fmt.Errorf(\"sensor %s does not support analog reading\", a.name)\n\t}\n\n\traw, err := a.readAnalog()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.config.Scale\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 47.59058360725021}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(\"Grove Sound Sensor\")\n\treturn d\n}", "CodeBleu_score": 47.92224044321126}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\tg.SetName(\"Grove Sound Sensor\")\n\treturn g\n}", "CodeBleu_score": 46.177977365000224}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tparams := parseOptions(opts).(GroveSoundSensorParams)\n\n\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, params.Name, params.Interval),\n\t}\n\n\treturn g\n}", "CodeBleu_score": 32.53536294005592}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write the soft reset command to the command register\n\td.writeReg(MFRC522_REG_COMMAND, MFRC522_PCD_RESETPHASE_2)\n\n\t// Wait for the initialization time\n\ttime.Sleep(MFRC522_RESET_DELAY)\n\n\t// Read the command register\n\tcommand, err := d.readReg(MFRC522_REG_COMMAND)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the power-down bit is still set\n\tif (command & MFRC522_PCD_RESETPHASE_2) != 0 {\n\t\treturn errors.New(\"MFRC522 initialization failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 51.31266655749541}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(MFRC522_REG_COMMAND, MFRC522_PCD_RESETPHASE)\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tval, err := d.readRegister(MFRC522_REG_COMMAND)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif val&0x01 != 0 {\n\t\treturn errors.New(\"Soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 49.984783928228715}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(d.CommandReg, SoftReset)\n\ttime.Sleep(150 * time.Millisecond)\n\tstatus, err := d.readRegister(d.CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status&0x01 != 0 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 46.04847809094162}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn, err := d.ReadRegister(FIFO_LEVEL)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"unexpected FIFO data length: %d\", n)\n\t}\n\t_, err = d.ReadRegister(FIFO_DATA, backData)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tcontrol, err := d.ReadRegister(CONTROL)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn control & 0x07, err\n}", "CodeBleu_score": 44.992244938084184}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\td.spi.SetSpeed(d.spiSpeed)\n\td.spi.SetMode(d.spiMode)\n\td.spi.SetBitsPerWord(d.spiBitsPerWord)\n\td.spi.SetCS(d.spiCS)\n\n\td.spi.Lock()\n\tdefer d.spi.Unlock()\n\n\tbackLen := len(backData)\n\n\tdata := make([]byte, 1)\n\n\td.write(0x00, []byte{0x00})\n\td.read(0x00, data)\n\n\tbackBit := data[0]\n\n\tif backBit != byte(backLen) {\n\t\treturn 0, errors.New(\"backLen error\")\n\t}\n\n\tfor i := 0; i < backLen; i++ {\n\t\td.read(0x00, data)\n\t\tbackData[i] = data[0]\n\t}\n\n\treturn backBit, nil\n}", "CodeBleu_score": 30.209001745779666}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\td.writeReg(RegBitFramingControl, 0x07)\n\tcount, err := d.readReg(RegFIFOLevel)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif count != uint8(len(backData)) {\n\t\treturn 0, errors.New(\"backData len error\")\n\t}\n\t_, err = d.readRegs(RegFIFOData, backData)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tcontrol, err := d.readReg(RegControl)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn control & 0x07, nil\n}", "CodeBleu_score": 44.67845978758114}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.logDebug(\"piccHalt()\")\n\n\t// Create the command.\n\tcmd := []byte{0x50, 0x00, 0x00, 0x00}\n\n\t// Calculate the CRC for the command.\n\tcrc := d.calcCRC(cmd)\n\n\t// Append the CRC to the command.\n\tcmd = append(cmd, crc...)\n\n\t// Send the halt command to the PICC.\n\terr := d.sendCommand(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Expect an error to indicate successful halting.\n\terr = d.waitForError()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 36.74465978440156}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.debugPrint(\"Halting PICC\")\n\tcmdHalt := []byte{0x50, 0x00, 0x00, 0x00}\n\t_, err := d.calculateCRC(cmdHalt)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = d.write(cmdHalt)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = d.read(0x00, 0x00)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.debugPrint(\"PICC halted\")\n\treturn nil\n}", "CodeBleu_score": 41.38906458322147}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\t// Log debug message if debugging is enabled\n\td.logDebug(\"Halting PICC...\")\n\n\t// Create a halt command\n\tcmd := []byte{0x50, 0x00, 0x00, 0x00}\n\n\t// Calculate the CRC for the command\n\tcrc := d.calculateCRC(cmd)\n\n\t// Append the CRC result to the command\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Send the halt command to the PICC\n\t_, err := d.spiWrite(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Expect an error to indicate successful halting\n\tresp, err := d.spiRead(4)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the response is an error\n\tif resp[0] != 0x90 || resp[1] != 0x00 || resp[2] != 0x00 || resp[3] != 0x00 {\n\t\treturn errors.New(\"PICC halt failed\")\n\t}\n\n\t// Return nil if the halt was successful\n\treturn nil\n}", "CodeBleu_score": 39.86672637204855}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tdata := make([]byte, 18)\n\tdata[0] = 0xFF\n\tdata[1] = 0xCA\n\tdata[2] = 0x00\n\tdata[3] = block\n\tdata[4] = 0x00\n\n\t// Calculate the CRC for the command\n\tcrc := d.calculateCRC(data[0:5])\n\n\t// Append the CRC to the command\n\tdata[5] = crc[0]\n\tdata[6] = crc[1]\n\n\t// Communicate with the RFID card using the command\n\terr := d.write(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the response from the RFID card\n\tresponse, err := d.read()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the response is valid\n\tif response[0] != 0x90 || response[1] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"invalid response from RFID card: %v\", response)\n\t}\n\n\t// Extract the data from the response\n\tdata = response[2:18]\n\n\treturn data, nil\n}", "CodeBleu_score": 34.288902076667966}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Create a buffer to hold the command data\n\tcmd := make([]byte, 18)\n\t// Set the command header\n\tcmd[0] = 0xFF // PICC_CMD_MF_READ\n\t// Set the block address\n\tcmd[1] = block\n\t// Calculate the CRC for the command\n\tcrc := d.calcCRC(cmd[:2])\n\t// Append the CRC to the command\n\tcmd[2] = crc[0]\n\tcmd[3] = crc[1]\n\t// Send the command to the RFID card\n\td.rfid.Write(cmd)\n\t// Read the response from the RFID card\n\tresp, err := d.rfid.Read()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Check the response status\n\tif resp[0] != 0x90 || resp[1] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"RFID card read failed: %v\", resp)\n\t}\n\t// Extract the data from the response\n\tdata := resp[2 : 2+16]\n\t// Return the data\n\treturn data, nil\n}", "CodeBleu_score": 33.17238676960813}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Create the command byte\n\tcommand := []byte{0x30, block}\n\n\t// Calculate the CRC for the command\n\tcrc := d.calcCRC(command)\n\n\t// Append the CRC to the command\n\tcommand = append(command, crc...)\n\n\t// Communicate with the RFID card using the command\n\tdata, err := d.communicateWithCard(command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the response is valid\n\tif len(data) < 18 {\n\t\treturn nil, fmt.Errorf(\"invalid response length\")\n\t}\n\n\t// Check if the response is valid\n\tif data[0] != 0x00 || data[1] != 0x00 || data[2] != 0x00 || data[3] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"invalid response header\")\n\t}\n\n\t// Check if the response is valid\n\tif data[4] != block {\n\t\treturn nil, fmt.Errorf(\"invalid response block\")\n\t}\n\n\t// Check if the response is valid\n\tif data[5] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"invalid response trailer\")\n\t}\n\n\t// Check if the response is valid\n\tif d.calcCRC(data[:16]) != data[16:18] {\n\t\treturn nil, fmt.Errorf(\"invalid response CRC\")\n\t}\n\n\t// Return the data\n\treturn data[6:16], nil\n}", "CodeBleu_score": 44.09195945873425}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tanswerLen := len(answer)\n\tif answerLen < 2 {\n\t\treturn errors.New(\"answer buffer is too short\")\n\t}\n\tanswer[0] = 0x00\n\tanswer[1] = 0x00\n\n\td.collReg = 0x80\n\td.collReg = d.collReg | reqMode\n\n\tif reqMode == REQA {\n\t\td.txLastBits = 0x07\n\t} else {\n\t\td.txLastBits = 0x00\n\t}\n\n\terr := d.transceive(answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 40.27654249667396}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\td.clearBitsInBitFramingReg()\n\td.setBitFramingReg(reqMode)\n\n\td.setBit(d.cmdReg, 7) // StartSend=1, transmission of data starts\n\n\t_, err := d.transceive(answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td.clearBit(d.cmdReg, 7) // StartSend=0, transmission of data stops\n\n\treturn nil\n}", "CodeBleu_score": 43.4777918110535}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t", "CodeBleu_score": 3.6650973421215025}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\td.stepPin.Low()\n\ttime.Sleep(d.stepDelay)\n\td.stepPin.High()\n\tif d.direction == CLOCKWISE {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 34.089158436965796}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.DigitalWrite(false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\terr = d.stepPin.DigitalWrite(true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == CW {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 63.16428530636002}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.Write(0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(time.Duration(d.stepDelay) * time.Millisecond)\n\n\terr = d.stepPin.Write(1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == \"CW\" {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 62.90751754975905}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor is already running\")\n\t}\n\td.stopDistanceMonitor = make(chan struct{})\n\td.distanceMonitorRunning = true\n\tgo d.distanceMonitor()\n\treturn nil\n}", "CodeBleu_score": 25.254329759298876}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopChan = make(chan struct{})\n\td.distanceMonitorRunning = true\n\n\tgo func() {\n\t\tticker := time.NewTicker(d.distanceMonitorInterval)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\td.distanceMonitorRunning = false\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error measuring distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.distance = distance\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 41.797334883435305}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn ErrDistanceMonitorAlreadyRunning\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorWaitGroup.Add(1)\n\n\tgo d.distanceMonitor()\n\n\td.distanceMonitorRunning = true\n\treturn nil\n}", "CodeBleu_score": 43.06973290120427}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, d time.Duration, event string, ticks uint32, ticksPerSecond uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\td.durationChan <- time.Since(start)\n\t\t}\n\t}\n}", "CodeBleu_score": 35.406628259175946}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, event string, sequenceNumber uint32, value uint32) {\n\t\tif event == \"rising\" {\n\t\t\td.start = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\td.duration = time.Since(d.start)\n\t\t\td.ch <- d.duration\n\t\t}\n\t}\n}", "CodeBleu_score": 33.326405029054776}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, edge string, value uint32, timestamp uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\td.channel <- time.Since(start)\n\t\t}\n\t}\n}", "CodeBleu_score": 35.142807891669676}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t", "CodeBleu_score": 1.8836688096722443}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the measurement\n\td.triggerPin.High()\n\ttime.Sleep(time.Microsecond * 10)\n\td.triggerPin.Low()\n\n\t// Wait for the measurement to complete\n\tvar startTime time.Time\n\tvar timeout time.Duration = 500 * time.Millisecond\n\tfor {\n\t\tif d.echoPin.Read() == gpio.High {\n\t\t\tstartTime = time.Now()\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(startTime) > timeout {\n\t\t\treturn errors.New(\"timeout waiting for echo\")\n\t\t}\n\t}\n\n\tfor {\n\t\tif d.echoPin.Read() == gpio.Low {\n\t\t\td.measurement = time.Since(startTime)\n\t\t\treturn nil\n\t\t}\n\t}\n}", "CodeBleu_score": 43.86244102578832}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor.\n\tif err := d.trigger.High(); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur.\n\ttime.Sleep(time.Microsecond * 10)\n\tif err := d.trigger.Low(); err != nil {\n\t\treturn err\n\t}\n\n\tstart := time.Now()\n\tfor {\n\t\tif d.echo.Read() == gpio.High {\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(start) > d.timeout {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\t}\n\t}\n\n\tstart = time.Now()\n\tfor {\n\t\tif d.echo.Read() == gpio.Low {\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(start) > d.timeout {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\t}\n\t}\n\n\td.measurement = time.Since(start)\n\treturn nil\n}", "CodeBleu_score": 56.19240592719497}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return os.environ[\"AUTH_TOKEN\"]\n    except KeyError:\n        try:\n            access_token = self.state[\"access_token\"]\n            expires_at = self.state[\"expires_at\"]\n            if expires_at > datetime.now().timestamp():\n                return access_token\n        except KeyError:\n            pass\n        try:\n            refresh_token = self.state[\"refresh_token\"]\n            access_token = self.fetch_access_token(refresh_token)\n            self.state[\"access_token\"] = access_token\n            self.state[\"expires_at\"] = (\n                datetime.now() + timedelta(minutes=59)\n            ).timestamp()\n            return access_token\n        except KeyError:\n            raise AccountNotAuthorized(\"No authentication token found.\")\n\n", "CodeBleu_score": 37.95474014342324}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return self.authentication_token\n    except AttributeError:\n        pass\n\n    try:\n        access_token = os.environ[\"ACCESS_TOKEN\"]\n        expiration_time = os.environ[\"EXPIRATION_TIME\"]\n        if int(expiration_time) > int(time.time()):\n            self.authentication_token = access_token\n            return access_token\n    except KeyError:\n        pass\n\n    try:\n        refresh_token = os.environ[\"REFRESH_TOKEN\"]\n        access_token, expiration_time = self.fetch_new_access_token(\n            refresh_token\n        )\n        self.authentication_token = access_token\n        self.expiration_time = expiration_time\n        return access_token\n    except KeyError:\n        pass\n\n    raise AccountNotAuthorized(\n        \"No authentication token found. Please provide a valid access token or refresh token.\"\n    )\n\n", "CodeBleu_score": 32.46968855095311}, {"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return os.environ[\"AUTH_TOKEN\"]\n    except KeyError:\n        pass\n    try:\n        access_token = self.local_state[\"access_token\"]\n        expiration_time = self.local_state[\"expiration_time\"]\n        if expiration_time > time.time():\n            return access_token\n    except KeyError:\n        pass\n    try:\n        refresh_token = self.local_state[\"refresh_token\"]\n        access_token = self.fetch_access_token(refresh_token)\n        self.local_state[\"access_token\"] = access_token\n        self.local_state[\"expiration_time\"] = time.time() + 3500\n        return access_token\n    except KeyError:\n        raise AccountNotAuthorized\n\n", "CodeBleu_score": 29.60080737726117}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            data={\"refresh_token\": refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 66.70552913607206}, {"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"POST\",\n            f\"{self.base_url}/v1/logout\",\n            json={\"refresh_token\": refresh_token},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 58.345085602744476}, {"code": "def logout(self)\n\t\n    refresh_token = self.refresh_token\n    self.delete_local_session()\n    try:\n        self.request(\n            \"POST\",\n            \"/v1/logout\",\n            json={\"refresh_token\": refresh_token},\n        )\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 56.044520524411354}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    used_packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        package_info = {\n            \"name\": package.name,\n            \"version\": package.version,\n            \"source\": package.source,\n        }\n        if package.external:\n            package_info[\"source\"] = package.source\n        used_packages.append(package_info)\n    return used_packages\n\n", "CodeBleu_score": 29.04431325219009}, {"code": "def dump_used_packages(self)\n\t\n    used_packages = []\n    for package in self.packages:\n        if package.is_optional:\n            continue\n        metadata = package.get_metadata()\n        if metadata.get(\"external\"):\n            used_packages.append({\"name\": package.name, \"version\": package.version, \"url\": metadata.get(\"url\")})\n        else:\n            used_packages.append({\"name\": package.name, \"version\": package.version})\n    return used_packages\n\n", "CodeBleu_score": 28.14819126075101}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for pkg in self.get_packages():\n        if pkg.is_optional():\n            continue\n        metadata = pkg.get_metadata()\n        if metadata.get('external'):\n            source = metadata.get('source')\n            if source:\n                packages.append(f\"{pkg.get_name()} {pkg.get_version()} ({source})\")\n        else:\n            packages.append(f\"{pkg.get_name()} {pkg.get_version()}\")\n    return packages\n\n", "CodeBleu_score": 28.706365906862885}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if targets is None:\n        targets = []\n    platform = cls.get_platform_spec(env)\n    if not platform:\n        raise exception.UndefinedEnvPlatformError(env)\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.set_project_env(env)\n    instance.configure_packages(targets)\n    return instance\n\n", "CodeBleu_score": 36.494915321173636}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform_spec = cls.config.get_platform_spec(env)\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.project_env = env\n    instance.configure_packages(targets)\n    return instance\n\n", "CodeBleu_score": 26.571603819396067}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    platform = cls.config.get_platform(env)\n    if not platform:\n        raise exception.UndefinedEnvPlatformError(env)\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.set_project_env(env)\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 25.56947253351555}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(AXP192_ADDRESS);\n  Wire.write(Addr);\n  Wire.endTransmission();\n\n  Wire.requestFrom(AXP192_ADDRESS, Size);\n  while (Wire.available() < Size);\n\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 61.51137137233241}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire.beginTransmission(0x34);\n    Wire.write(Addr);\n    Wire.endTransmission();\n    Wire.requestFrom(0x34, Size);\n    uint8_t i = 0;\n    while (Wire.available()) {\n        Buff[i] = Wire.read();\n        i++;\n    }\n}", "CodeBleu_score": 57.10631338632104}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(AXP192_ADDRESS);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(AXP192_ADDRESS, Size);\n  uint8_t i = 0;\n  while (Wire.available()) {\n    Buff[i] = Wire.read();\n    i++;\n  }\n}", "CodeBleu_score": 50.911515002148434}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us != 0) {\n        Write32bit(0x33, time_in_us);\n        Write1Byte(0x32, Read8bit(0x32) | 0x01);\n    } else {\n        Write1Byte(0x32, Read8bit(0x32) & 0xFE);\n    }\n    Write1Byte(0x30, 0x02);\n    delay(1);\n    Write1Byte(0x30, 0x00);\n}", "CodeBleu_score": 40.078619380913885}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us != 0) {\n        Write32bit(0x33, time_in_us);\n        Write1Byte(0x32, 0x81);\n    } else {\n        Write1Byte(0x32, 0x01);\n    }\n    Write1Byte(0x30, 0x01);\n    delay(1);\n}", "CodeBleu_score": 40.07812034622547}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        Write32bit(0x33, time_in_us);\n        Write1Byte(0x12, Read8bit(0x12) | 0x20);  // Enable timer wakeup\n    } else {\n        Write1Byte(0x12, Read8bit(0x12) & 0xDF);  // Disable timer wakeup\n    }\n    Write1Byte(0x32, 0x02);  // Enter deep sleep\n}", "CodeBleu_score": 43.209423230547564}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t  int prev_y = y;\n  y += text_height;\n  if (y >= tft.height() - bottom_fixed_area) y = 0;\n  tft.fillRect(0, prev_y, tft.width(), text_height, color);\n  scrollAddress(y);\n  return prev_y;\n}", "CodeBleu_score": 16.236455307443965}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y1 = tft.get_y();\n  tft.fillRect(0, y1, tft.width(), tft.height() - tft.get_y(), color);\n  tft.set_y(y1 + tft.get_y_text_height());\n  if (tteBar) {\n    if (tft.get_y() > tft.height() - tft.get_y_text_height() - tft.get_y_text_height()) {\n      tft.set_y(tft.get_y_text_height());\n    }\n  } else {\n    if (tft.get_y() > tft.height() - tft.get_y_text_height()) {\n      tft.set_y(0);\n    }\n  }\n  scrollAddress(tft.get_y());\n  return y1;\n}", "CodeBleu_score": 20.94367065116628}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y0 = tft.get_y();\n  tft.fillRect(0, y0, tft.get_width(), tft.get_height(), color);\n  int y1 = y0 + tft.get_text_height();\n  if (y1 >= tft.get_height() - tft.get_bottom_fixed_area()) {\n    y1 = tft.get_bottom_fixed_area();\n  }\n  if (tteBar) {\n    y1 = tft.get_top_fixed_area();\n  }\n  tft.set_y(y1);\n  scrollAddress(y1);\n  return y0;\n}", "CodeBleu_score": 19.089050502586343}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  if (!this->setSSIDs(ssids)) {\n    return false;\n  }\n\n  if (!this->setAccessPoints(access_points)) {\n    return false;\n  }\n\n  if (!this->setHTMLContent()) {\n    return false;\n  }\n\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 59.49688403861373}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->ssids = ssids;\n  this->access_points = access_points;\n\n  // set up access points\n  if (!this->setUpAccessPoints()) {\n    return false;\n  }\n\n  // set up HTML content\n  if (!this->setUpHTML()) {\n    return false;\n  }\n\n  // start portal\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 59.31029810625317}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->ssids = ssids;\n  this->access_points = access_points;\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 51.49622486031882}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t  if (queue_enabled_flag) {\n    if (!queue_initialized) {\n      queue_initialized = true;\n      text = (char*)malloc(sizeof(char)*text_size);\n      text_in = (char*)malloc(sizeof(char)*text_size);\n    }\n  } else {\n    queue_initialized = false;\n    queue_enabled_flag = true;\n    queue_length = 0;\n    queue_head = 0;\n    queue_tail = 0;\n    queue_available = false;\n    queue_full = false;\n    queue_empty = true;\n  }\n}", "CodeBleu_score": 11.881426334322065}, {"code": "void GpsInterface::enable_queue(){\n\t  if (queue_enabled_flag == false) {\n    queue_enabled_flag = true;\n    queue.clear();\n    text.clear();\n    text_in.clear();\n  }\n}", "CodeBleu_score": 8.3945227476446}, {"code": "void GpsInterface::enable_queue(){\n\t  if (queue_enabled_flag) {\n    text = (char *) malloc(sizeof(char) * text_size);\n    text_in = (char *) malloc(sizeof(char) * text_size);\n  } else {\n    flush_queue();\n    queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 13.84040085922694}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t  if (queue_nmea != NULL) {\n    if (queue_nmea->size() > 0) {\n      queue_nmea = new Queue<String>();\n    }\n  } else {\n    queue_nmea = new Queue<String>();\n  }\n}", "CodeBleu_score": 43.46937212017861}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (queue_nmea.size() > 0) {\n        queue_nmea = std::queue<std::string>();\n    }\n}", "CodeBleu_score": 34.254984141151354}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea != NULL) {\n\t\tqueue_nmea = new std::queue<std::string>;\n\t}\n}", "CodeBleu_score": 29.454879480464335}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    // Start a write transaction\n    lcd_start_write();\n\n    // Set the address window\n    lcd_set_addr_win(area->x1, area->y1, area->x2, area->y2);\n\n    // Iterate through each pixel in the area\n    for (int y = area->y1; y <= area->y2; y++) {\n        for (int x = area->x1; x <= area->x2; x++) {\n            // Get the color for the current pixel\n            lv_color_t color = color_p[y * disp->hor_res + x];\n\n            // Write the color to the display\n            lcd_write_color(color);\n        }\n    }\n\n    // End the write transaction\n    lcd_end_write();\n\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 57.19526294756092}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t  /*\n   * Initialize the display\n   */\n  // Initialize the display\n  // ...\n\n  /*\n   * Update the specified area on the display\n   */\n  // Start a write transaction\n  // ...\n\n  // Set the address window\n  // ...\n\n  // Iterate through each pixel in the area\n  for (int y = area->y1; y <= area->y2; y++) {\n    for (int x = area->x1; x <= area->x2; x++) {\n      // Get the color for the current pixel\n      lv_color_t color = color_p[y * LV_HOR_RES + x];\n\n      // Write the color to the display\n      // ...\n    }\n  }\n\n  // End the write transaction\n  // ...\n\n  // Notify that the display flush is complete\n  // ...\n}", "CodeBleu_score": 35.38086142431605}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    uint32_t i;\n    uint32_t x_start = area->x1;\n    uint32_t x_end = area->x2;\n    uint32_t y_start = area->y1;\n    uint32_t y_end = area->y2;\n\n    /* Start write transaction */\n    my_disp_write_start();\n\n    /* Set address window */\n    my_disp_set_address_window(x_start, x_end, y_start, y_end);\n\n    /* Iterate through each pixel in the area and write the corresponding color */\n    for (i = 0; i < (x_end - x_start + 1) * (y_end - y_start + 1); i++) {\n        my_disp_write_color(color_p[i]);\n    }\n\n    /* End write transaction */\n    my_disp_write_end();\n\n    /* Notify that the display flush is complete */\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 44.73793029985465}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    for (int i = 0; i < menu->getMenuNodeCount(); i++) {\n        std::cout << std::string(layer * 2, ' ') << menu->getMenuNode(i)->getName() << std::endl;\n    }\n    std::cout << std::endl;\n}", "CodeBleu_score": 45.505840211588975}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    if (menu->getMenuListSize() == 0) {\n        return;\n    }\n\n    for (int i = 0; i < menu->getMenuListSize(); i++) {\n        for (int j = 0; j < layer; j++) {\n            cout << \"\\t\";\n        }\n        cout << menu->getMenuNode(i)->getName() << endl;\n    }\n    cout << endl;\n}", "CodeBleu_score": 49.35488018670362}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    for (int i = 0; i < menu->getSize(); i++) {\n        for (int j = 0; j < layer; j++) {\n            cout << \"  \";\n        }\n        cout << menu->getMenuNode(i)->getName() << endl;\n    }\n    cout << endl;\n}", "CodeBleu_score": 52.035950197284194}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t  Serial.println(\"Generating \" + String(count) + \" SSIDs\");\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += (char) (random(0, 26) + 'a');\n    }\n    ssid += String(i);\n    int channel = random(1, 14);\n    String mac = \"\";\n    for (int j = 0; j < 6; j++) {\n      mac += String(random(0, 16), HEX);\n      if (j < 5) {\n        mac += \":\";\n      }\n    }\n    ssids.push_back(SSID(ssid, channel, mac));\n    Serial.println(\"SSID \" + String(i + 1) + \": \" + ssid + \" (\" + String(channel) + \")\" + \" (\" + mac + \")\");\n  }\n  return ssids.size();\n}", "CodeBleu_score": 45.13847555275944}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int i;\n  for (i = 0; i < count; i++) {\n    char ssid[32];\n    char channel[3];\n    char mac[18];\n    randomSSID(ssid);\n    randomMAC(mac);\n    randomChannel(channel);\n    WiFiScan::ssids.push_back(ssid);\n    WiFiScan::channels.push_back(channel);\n    WiFiScan::macs.push_back(mac);\n    Serial.println(ssid);\n  }\n  return i;\n}", "CodeBleu_score": 29.533777164848345}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t    int ssids = 0;\n    for (int i = 0; i < count; i++) {\n        String ssid = \"\";\n        for (int j = 0; j < 6; j++) {\n            ssid += (char) (random(0, 26) + 'a');\n        }\n        ssid += (char) (random(0, 10) + '0');\n        ssids++;\n        Serial.println(ssid);\n    }\n    return ssids;\n}", "CodeBleu_score": 39.58377412707071}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(\"Topic created: {}\".format(topic))\n\n", "CodeBleu_score": 53.58447548238634}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    from google.oauth2 import service_account\n    from datetime import datetime, timedelta\n    from google.auth.transport.requests import Request\n    from google.oauth2.credentials import Credentials\n    from google.auth.transport.requests import Request\n    from google.oauth2.service_account import Credentials\n\n    # Set the issued time (iat) to the current UTC time\n    iat = datetime.utcnow()\n\n    # Set the expiration time (exp) to one hour later\n    exp = iat + timedelta(hours=1)\n\n    # Set the audience (aud) field to the provided GCP project ID\n    aud = project_id\n\n    # Read the private key from the specified file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT payload\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': aud\n    }\n\n    # Create the JWT using the specified algorithm\n    credentials = Credentials.from_service_account_info(\n        {\n            \"type\": \"service_account\",\n            \"project_id\": project_id,\n            \"private_key_id\": \"90809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809809", "CodeBleu_score": 44.80927057860878}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    from datetime import datetime, timedelta\n    from google.oauth2 import service_account\n    from google.auth.transport.requests import Request\n    from google.oauth2.credentials import Credentials\n    from google.auth.jwt import _crypt, _jwt_encode\n    import json\n\n    # Set the issued time (iat) to the current UTC time\n    iat = datetime.utcnow()\n\n    # Set the expiration time (exp) to one hour later\n    exp = iat + timedelta(hours=1)\n\n    # Create the payload for the JWT\n    payload = {\n        \"iat\": iat.timestamp(),\n        \"exp\": exp.timestamp(),\n        \"aud\": project_id\n    }\n\n    # Read the private key from the specified file\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    # Create the credentials object\n    credentials = Credentials(\n        token=None,\n        refresh_token=None,\n        token_uri=\"https://oauth2.googleapis.com/token\",\n        client_id=None,\n        client_secret=None,\n        scopes=None\n    )\n\n    # Create the JWT using the specified algorithm\n    encoded_jwt = _jwt_encode(\n        credentials,\n        private_key,\n        payload,\n        algorithm\n    )\n\n    return encoded_jwt\n\n", "CodeBleu_score": 42.305050000542664}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    from datetime import datetime, timedelta\n    from google.oauth2 import service_account\n    import jwt\n\n    # Set the issued time (iat) to the current UTC time\n    iat = datetime.utcnow()\n\n    # Set the expiration time (exp) to one hour later\n    exp = iat + timedelta(hours=1)\n\n    # Set the audience (aud) field to the provided GCP project ID\n    aud = project_id\n\n    # Read the private key from the specified file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT payload\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': aud\n    }\n\n    # Create the JWT using the specified algorithm\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n\n    return encoded_jwt\n\n\n\n", "CodeBleu_score": 52.24710351767685}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        message.payload.decode('utf-8'), message.topic, str(message.qos)))\n    if message.payload.decode('utf-8') == 'on':\n        path = '/tmp/image.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        client.publish(\n            'events/{}'.format(args.device_id),\n            '{}'.format(url),\n            qos=1)\n    else:\n        print('off')\n\n", "CodeBleu_score": 46.45291176746297}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload)\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        payload, message.topic, str(message.qos)))\n    if payload == \"on\":\n        path = 'preview.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        print(url)\n        client.publish(\n            'events/{}'.format(args.device_id),\n            payload=url,\n            qos=1)\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 48.84039568733613}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message from \\'{}\\' topic=\\'{}\\': {}'.format(\n        message.topic, message.qos, message.payload))\n    if message.payload == b'on':\n        path = '/tmp/image.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        client.publish(\n            'events',\n            payload=url,\n            qos=1)\n    else:\n        print('off')\n\n", "CodeBleu_score": 32.14942258416471}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection code.')\n    parser.add_argument('--project_id', required=False, default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n                        help='GCP cloud project name.')\n    parser.add_argument('--subscription', required=True, help='Cloud IoT Core subscription name.')\n    parser.add_argument('--algorithm', default='RS256',\n                        choices=('RS256', 'ES256'),\n                        required=False,\n                        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--ca_certs', default='roots.pem',\n                        help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument('--num_messages', type=int, default=100,\n                        help='Number of messages to receive.')\n    parser.add_argument('--cloud_region', default='us-central1',\n                        help='GCP cloud region')\n    parser.add_argument('--registry_id', default='my-registry',\n                        help='Cloud IoT Core registry id')\n    parser.add_argument('--device_id', default='my-device',\n                        help='Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', default='rsa_private.pem',\n                        help='Path to private key file.')\n    parser.add_argument('--client_email',\n                        help=('Email address of service account. '\n                              'If not specified, the client will look for '\n                              'credentials in the environment.'))\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int,\n                        help=('Expiration time, in minutes, for JWT '\n                              'assertions.'))\n    parser.add_argument('--message_type', default='event',\n                        choices=('event', 'state'),\n                        help=('Indicates", "CodeBleu_score": 39.005866697967754}, {"code": "def parse_command_line_args()\n\t\n    import argparse\n    import os\n\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection code.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        required=True,\n        help='GCP cloud project name.')\n    parser.add_argument(\n        '--subscription_name',\n        default='mqtt-sub',\n        required=True,\n        help='Cloud IoT Core subscription name.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region',\n        default='us-central1',\n        help='GCP cloud region')\n    parser.add_argument(\n        '--registry_id',\n        default='my-registry',\n        help='Cloud IoT Core registry id')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to receive.')\n\n    return parser.parse_args()\n\n\n", "CodeBleu_score": 67.25544099446839}, {"code": "def parse_command_line_args()\n\t\n    import argparse\n    import os\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection code example.')\n    parser.add_argument('--project_id', required=True, help='GCP cloud project name.')\n    parser.add_argument('--subscription', required=True, help='Cloud IoT Core subscription name.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), required=True, help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--ca_certs', default='roots.pem', help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument('--num_messages', type=int, default=100, help='Number of messages to receive.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--registry_id', required=True, help='Cloud IoT Core registry id')\n    parser.add_argument('--device_id', required=True, help='Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', required=True, help='Path to private key file.')\n    parser.add_argument('--client_email', required=True, help='Service account email associated with the private key.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    args = parser.parse_args()\n    return args\n\n", "CodeBleu_score": 56.83063296211513}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    import google.auth\n    from google.oauth2 import service_account\n    from googleapiclient import discovery\n\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(scopes)\n\n    return discovery.build(\n        'cloudiot',\n        api_version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n\n\n\n", "CodeBleu_score": 56.26585638114305}, {"code": "def get_client(service_account_json)\n\t\n    import google.auth\n    from googleapiclient import discovery\n    from google.oauth2 import service_account\n\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(scopes)\n\n    return discovery.build(\n        \"cloudiot\",\n        api_version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n\n", "CodeBleu_score": 53.6272863854296}, {"code": "def get_client(service_account_json)\n\t\n    import google.auth\n    import google.auth.transport.requests\n    from google.oauth2 import service_account\n    import googleapiclient.discovery\n    import googleapiclient.errors\n\n    # Define the API scopes to be used\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Load the service account credentials from the JSON file\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n\n    # Get the ID token for the credentials\n    credentials.refresh(google.auth.transport.requests.Request())\n\n    # Build the client for the Cloud IoT Core service\n    client = googleapiclient.discovery.build('cloudiot', 'v1', credentials=credentials, cache_discovery=False)\n\n    return client\n\n", "CodeBleu_score": 40.54590153887895}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = get_asn1_code(hash_method)\n    if asn1_code is None:\n        raise ValueError('Invalid hash method: %s' % hash_method)\n\n    message = asn1_code + hash_value\n    message = _pad_for_signing(message, 128)\n    signature = priv_key.encrypt(message)\n    return signature\n\n\n", "CodeBleu_score": 31.388021339653747}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    # Retrieve the ASN1 code for the hash method\n    hash_method_asn1 = getattr(hash_method, 'asn1', None)\n    if hash_method_asn1 is None:\n        raise ValueError('Unknown hash method')\n\n    # Concatenate the ASN1 code with the hash value\n    hash_value_with_asn1 = hash_method_asn1 + hash_value\n\n    # Pad the result for signing\n    padded_hash = _pad_for_signing(hash_value_with_asn1, 128)\n\n    # Encrypt the padded hash using the private key\n    encrypted_signature = priv_key.encrypt(padded_hash)\n\n    return encrypted_signature\n\n", "CodeBleu_score": 30.376492699371994}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    asn1_code = get_asn1_code(hash_method)\n    if asn1_code is None:\n        raise ValueError('Invalid hash method: %s' % hash_method)\n\n    hash_value_with_asn1 = b''.join([asn1_code, hash_value])\n    padded_hash = _pad_for_signing(hash_value_with_asn1, 128)\n    return encrypt(padded_hash, priv_key)\n\n\n", "CodeBleu_score": 23.171138282794328}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    try:\n        signature = b64decode(signature)\n    except TypeError:\n        raise TypeError('Signature must be a string or bytes')\n    except binascii.Error:\n        raise VerificationError('Signature is not valid base64')\n\n    try:\n        clearsig = rsa.decrypt(signature, pub_key)\n    except rsa.pkcs1.DecryptionError:\n        raise VerificationError('Signature is not valid')\n\n    hashmethod = _find_method_hash(clearsig)\n    hashvalue = compute_hash(message, hashmethod)\n    paddedhash = _pad_for_signing(hashvalue, len(clearsig))\n\n    if paddedhash != clearsig:\n        raise VerificationError('Signature is not valid')\n\n    return hashmethod\n", "CodeBleu_score": 39.77736238248749}, {"code": "def verify(message, signature, pub_key)\n\t\n\n    # Convert the signature to an integer\n    signature_int = signature_to_int(signature)\n\n    # Decrypt the signature using the public key\n    clearsig = decrypt(signature_int, pub_key)\n\n    # Find the hash method\n    hashname = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    hash = compute_hash(message, hashname)\n\n    # Reconstruct the expected padded hash\n    padded_hash = _pad_for_signing(hash, len(clearsig))\n\n    # Check if the expected padded hash matches the clear signature\n    if padded_hash != clearsig:\n        raise VerificationError('Verification failed')\n\n    # Return the hash method name\n    return hashname\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 20.350340872414108}, {"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer\n    signature_int = int.from_bytes(signature, byteorder='big')\n\n    # Decrypt the signature using the public key\n    clear_signature = pow(signature_int, pub_key.e, pub_key.n)\n\n    # Convert the clear signature to bytes\n    clear_signature_bytes = clear_signature.to_bytes((clear_signature.bit_length() + 7) // 8, byteorder='big')\n\n    # Find the hash method used\n    hash_method = _find_method_hash(clear_signature_bytes)\n\n    # Compute the hash of the message\n    message_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_hash = _pad_for_signing(message_hash, len(clear_signature_bytes))\n\n    # Compare the expected padded hash with the clear signature\n    if expected_hash != clear_signature_bytes:\n        raise VerificationError('Verification failed')\n\n    # Return the hash method name\n    return hash_method\n", "CodeBleu_score": 30.99923750794251}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t    time_t current_time;\n    time(&current_time);\n    if (current_time != -1) {\n        uint32_t epoch = (uint32_t)current_time;\n        updateJWT(epoch);\n    }\n\n    if (MQTT_connect(mqttClient, mqttHost, mqttPort, mqttUsername, mqttPassword, mqttTopic, cid, mqttClientId, mqttKeepalive, mqttCleanSession, mqttWillTopic, mqttWillMessage, mqttWillQos, mqttWillRetain) == 0) {\n        MQTT_set_send_subscribe_after_connect(mqttClient, 1);\n        debug_printInfo(\"MQTT: Connected to %s:%d\", mqttHost, mqttPort);\n    } else {\n        debug_printInfo(\"MQTT: Failed to connect to %s:%d\", mqttHost, mqttPort);\n    }\n}", "CodeBleu_score": 37.24190968335126}, {"code": "static void connectMQTT(){\n\t   time_t now;\n   time(&now);\n\n   if (now > 0) {\n      updateJWT(now);\n   }\n\n   debug_printInfo(\"MQTT: Attempting to connect...\");\n   mqtt_connect(mqttClient, mqttTopic, cid, mqttPassword, 0, 0);\n   mqtt_set_subscribe_after_connect(mqttClient, true);\n}", "CodeBleu_score": 44.79144415737045}, {"code": "static void connectMQTT(){\n\t    time_t now;\n    time(&now);\n    if (now > 0) {\n        updateJWT(now);\n    }\n    mqtt_connect();\n    mqtt_set_send_subscribe_after_connect(1);\n    debug_printInfo(\"MQTT: Connecting to %s\", mqttHost);\n}", "CodeBleu_score": 21.821006628471228}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t  uint32_t n = 0;\n  int i;\n  for (i = 0; i < width; i++) {\n    if (str[i] < '0' || str[i] > '9')\n      return str;\n    n = n * 10 + (str[i] - '0');\n  }\n  *num = n;\n  return str + i;\n}", "CodeBleu_score": 23.630095078623945}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t val = 0;\n    while (width-- > 0) {\n        if (*str < '0' || *str > '9')\n            return str;\n        val = val * 10 + (*str++ - '0');\n    }\n    *num = val;\n    return str;\n}", "CodeBleu_score": 25.047466670704438}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t  uint32_t n = 0;\n  int i;\n  for (i = 0; i < width; i++) {\n    if (str[i] < '0' || str[i] > '9')\n      return str;\n    n = n * 10 + str[i] - '0';\n    if (n > 0xFFFFFFFFUL / 10)\n      return str;\n  }\n  *num = n;\n  return str + i;\n}", "CodeBleu_score": 26.994855713580872}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if ((cert_def == NULL) || (cert == NULL) || (ca_public_key == NULL)) {\n        return ATCA_BAD_PARAM;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcab_verify_extern(tbs_digest, signature, ca_public_key);\n    if (ret != ATCA_SUCCESS) {\n        return ret;\n    }\n\n    return ATCA_SUCCESS;\n}", "CodeBleu_score": 73.06540974267566}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t  int ret;\n\n  if (cert_def == NULL) {\n    return ATCACERT_ERR_BAD_PARAM;\n  }\n\n  if (cert == NULL) {\n    return ATCACERT_ERR_BAD_PARAM;\n  }\n\n  if (cert_size == 0) {\n    return ATCACERT_ERR_BAD_PARAM;\n  }\n\n  if (ca_public_key == NULL) {\n    return ATCACERT_ERR_BAD_PARAM;\n  }\n\n  ret = atcab_verify_cert_hw(cert_def->key_id,\n                             cert,\n                             cert_size,\n                             ca_public_key);\n\n  return ret;\n}", "CodeBleu_score": 31.450105362227298}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t  int ret;\n\n  if ((cert_def == NULL) || (cert == NULL) || (ca_public_key == NULL)) {\n    return ATCACERT_ERROR_BAD_PARAM;\n  }\n\n  if (cert_size == 0) {\n    return ATCACERT_ERROR_BAD_PARAM;\n  }\n\n  if (cert_size > ATCACERT_MAX_CERT_SIZE) {\n    return ATCACERT_ERROR_BAD_PARAM;\n  }\n\n  ret = atcacert_get_cert_digest(cert_def, cert, cert_size, ATCACERT_DIGEST_SHA256);\n  if (ret != ATCACERT_SUCCESS) {\n    return ret;\n  }\n\n  ret = atcacert_verify_cert_signature_hw(cert_def, cert, cert_size, ca_public_key);\n  if (ret != ATCACERT_SUCCESS) {\n    return ret;\n  }\n\n  return ATCACERT_SUCCESS;\n}", "CodeBleu_score": 56.177096871546105}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if(timer == NULL)\n        return false;\n\n    if(*list == timer)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *prev = *list;\n    while(prev->next != timer)\n    {\n        if(prev->next == NULL)\n            return false;\n        prev = prev->next;\n    }\n\n    prev->next = timer->next;\n    return true;\n}", "CodeBleu_score": 31.5938812736269}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t *prev = NULL;\n    timerStruct_t *curr = *list;\n\n    while (curr != NULL && curr != timer)\n    {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    if (curr == NULL)\n    {\n        return false;\n    }\n\n    if (prev == NULL)\n    {\n        *list = curr->next;\n    }\n    else\n    {\n        prev->next = curr->next;\n    }\n\n    return true;\n}", "CodeBleu_score": 31.775778560329805}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *prev = list;\n    timerStruct_t * volatile *curr = list;\n    while(*curr != timer)\n    {\n        prev = curr;\n        curr = &(*curr)->next;\n        if(*curr == NULL)\n            return false;\n    }\n    *prev = timer->next;\n    return true;\n}", "CodeBleu_score": 22.670966211658282}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tint status;\n\tbsdErrorNumber = BSD_SUCCESS;\n\t\n\tif (socket < 0) {\n\t\tbsd_setErrNo(BSD_INVALID_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tif (socket >= BSD_MAX_SOCKETS) {\n\t\tbsd_setErrNo(BSD_INVALID_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tif (sockets[socket].state == NOT_A_SOCKET) {\n\t\tbsd_setErrNo(BSD_INVALID_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tstatus = close(sockets[socket].socket);\n\tif (status != SOCK_ERR_NO_ERROR) {\n\t\tbsd_setErrNo(BSD_INVALID_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tsockets[socket].state = NOT_A_SOCKET;\n\t\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 42.84600554490912}, {"code": "int BSD_close(int socket){\n\t\tbsdErrno_t errorNumber = BSD_SUCCESS;\n\ttstrSocket *socketInfo;\n\n\tif (socket < 0 || socket >= MAX_SOCKETS) {\n\t\tbsd_setErrNo(BSD_ERROR_INVALID_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\n\tsocketInfo = &gastrSockets[socket];\n\n\tif (socketInfo->state != NOT_A_SOCKET) {\n\t\tif (socketInfo->state == CONNECTED || socketInfo->state == LISTENING) {\n\t\t\tif (close(socket) != SOCK_ERR_NO_ERROR) {\n\t\t\t\tbsd_setErrNo(BSD_ERROR_CLOSE_SOCKET);\n\t\t\t\treturn BSD_ERROR;\n\t\t\t}\n\t\t}\n\t\tsocketInfo->state = NOT_A_SOCKET;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 44.31313673263778}, {"code": "int BSD_close(int socket){\n\t\tbsd_setErrNo(BSD_SUCCESS);\n\n\tif (socket < 0 || socket >= BSD_MAX_SOCKETS) {\n\t\tbsd_setErrNo(BSD_ERROR);\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (bsdSockets[socket].state == NOT_A_SOCKET) {\n\t\tbsd_setErrNo(BSD_ERROR);\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (close(bsdSockets[socket].socket) < 0) {\n\t\tbsd_setErrNo(BSD_ERROR);\n\t\treturn BSD_ERROR;\n\t}\n\n\tbsdSockets[socket].state = NOT_A_SOCKET;\n\tbsdSockets[socket].socket = -1;\n\tbsdSockets[socket].type = -1;\n\tbsdSockets[socket].protocol = -1;\n\tbsdSockets[socket].port = -1;\n\tbsdSockets[socket].ipAddress = -1;\n\tbsdSockets[socket].socketAddressSize = -1;\n\tbsdSockets[socket].socketAddress = NULL;\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 41.473188980041755}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tbsdErrno_t\terrorNumber;\n\tint\t\t\tresult;\n\n\tresult = listen(socket, backlog);\n\tif (result == SOCK_ERR_NO_ERROR) {\n\t\treturn BSD_SUCCESS;\n\t}\n\terrorNumber = bsd_getErrNo(result);\n\tbsd_setErrNo(errorNumber);\n\treturn BSD_ERROR;\n}", "CodeBleu_score": 31.5653989818162}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint\t\ts8Ret = BSD_ERROR;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\ts8Ret = listen(socket, backlog);\n\t\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tbsd_setErrNo(bsdErrno_t(s8Ret));\n\t\t}\n\t}\n\telse\n\t{\n\t\tbsd_setErrNo(EBADF);\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 29.203267214995172}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tbsdErrno_t bsdErrorNumber = BSD_SUCCESS;\n\n\tif (socket < 0) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tif (gastrSockets[socket].bIsUsed != 1) {\n\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\treturn BSD_ERROR;\n\t}\n\tif (gastrSockets[socket].u8SocketType != SOCK_STREAM) {\n\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (listen(socket, backlog) != SOCK_ERR_NO_ERROR) {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn bsdErrorNumber;\n}", "CodeBleu_score": 45.866941289364945}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = -1;\n\tbsdErrno_t errorNumber = BSD_NO_ERROR;\n\n\tif (socket < 0) {\n\t\terrorNumber = BSD_INVALID_ARG;\n\t} else {\n\t\tswitch (addr->sa_family) {\n\t\t\tcase AF_INET: {\n\t\t\t\tstruct sockaddr_in * addr_in = (struct sockaddr_in *) addr;\n\t\t\t\tret = accept(socket, (struct sockaddr *) addr_in, addrlen);\n\t\t\t\tif (ret == -1) {\n\t\t\t\t\terrorNumber = BSD_ACCEPT_FAILED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AF_INET6: {\n\t\t\t\tstruct sockaddr_in6 * addr_in6 = (struct sockaddr_in6 *) addr;\n\t\t\t\tret = accept(socket, (struct sockaddr *) addr_in6, addrlen);\n\t\t\t\tif (ret == -1) {\n\t\t\t\t\terrorNumber = BSD_ACCEPT_FAILED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\terrorNumber = BSD_UNSUPPORTED_ADDRESS_FAMILY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errorNumber != BSD_NO_ERROR) {\n\t\tbsd_setErrNo(errorNumber);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 47.516225404692825}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint retval = -1;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tswitch (addr->sa_family) {\n\t\t\tcase AF_INET: {\n\t\t\t\tstruct sockaddr_in *in_addr = (struct sockaddr_in *)addr;\n\t\t\t\tif (addrlen == NULL) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t\tretval = SOCK_ERR_INVALID_ARG;\n\t\t\t\t} else {\n\t\t\t\t\tint addr_len = sizeof(struct sockaddr_in);\n\t\t\t\t\tint sock = accept(socket, (struct sockaddr *)in_addr, &addr_len);\n\t\t\t\t\tif (sock == SOCK_ERR_NO_ERROR) {\n\t\t\t\t\t\t*addrlen = addr_len;\n\t\t\t\t\t\tretval = sock;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbsd_setErrNo(sock);\n\t\t\t\t\t\tretval = SOCK_ERR_INVALID_ARG;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AF_INET6: {\n\t\t\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)addr;\n\t\t\t\tif (addrlen == NULL) {\n\t\t\t\t\tbsd_setErrNo(EINVAL);\n\t\t\t\t\tretval = SOCK_ERR_INVALID_ARG;\n\t\t\t\t} else {\n\t\t\t\t\tint addr_len = sizeof(struct sockaddr_in6);\n\t\t\t\t\tint sock = accept(socket, (struct sockaddr *)in6_addr, &addr_len);\n\t\t\t\t\tif (sock == SOCK_ERR_NO_ERROR) {\n\t\t\t\t\t\t*addrlen = addr_len;\n\t\t\t\t\t\tretval = sock;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbsd_setErrNo(sock);\n\t\t\t\t\t\tretval = SOCK_ERR_INVALID_ARG;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbsd_setErrNo(EAFNOSUPPORT);\n\t\t\t\tretval = SOCK_ERR_INVALID_ARG;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn retval;\n}", "CodeBleu_score": 44.113663730304964}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t   time_t now = time(NULL);\n   if (now < 0) {\n      debug_printError(\"MQTT: Time is invalid\");\n      return;\n   }\n   uint32_t epoch = (uint32_t)now + UNIX_OFFSET;\n   updateJWT(epoch);\n\n   int rc = MQTT_Connect(epoch);\n   if (rc != 0) {\n      debug_printError(\"MQTT: Connection failed with code %d\", rc);\n      return;\n   }\n   debug_printInfo(\"MQTT: Connected\");\n   sendSubscribe = true;\n}", "CodeBleu_score": 53.66974526895804}, {"code": "static void connectMQTT(){\n\t    time_t now = time(NULL);\n    if (now == (time_t) -1) {\n        debug_printError(\"MQTT: Failed to get current time.\");\n        return;\n    }\n\n    // Update JWT with current time offset\n    updateJWT((uint32_t) now);\n\n    // Initiate MQTT connection\n    mqtt_connect(mqttClient, cid, mqttTopic, mqttPassword, PASSWORD_SPACE, 0, 0);\n    debug_printInfo(\"MQTT: Connecting to broker...\");\n\n    // Set flag to send SUBSCRIBE packet once connection is established\n    mqttClient->mqtt_flags |= MQTT_FLAG_SUBSCRIBE;\n}", "CodeBleu_score": 45.48535764560426}, {"code": "static void connectMQTT(){\n\t  time_t now = time(NULL);\n  if (now < UNIX_OFFSET) {\n    debug_printInfo(\"MQTT: Time is not valid\");\n    return;\n  }\n  uint32_t epoch = now - UNIX_OFFSET;\n  updateJWT(epoch);\n  debug_printInfo(\"MQTT: Connecting to %s\", mqttServer);\n  if (mqtt_connect(mqttClient, mqttServer, mqttPort, mqttUsername, mqttPassword, cid, mqttTopic, 1) == 0) {\n    debug_printInfo(\"MQTT: Connected\");\n    sendSubscribe = true;\n  } else {\n    debug_printInfo(\"MQTT: Connection failed\");\n  }\n}", "CodeBleu_score": 50.39367960715233}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t   mqttContext* connectionInfo = NULL;\n   if (mqttState == CONNECTED) {\n      connectionInfo = CLOUD_getConnectionInfo();\n      MQTT_Disconnect(connectionInfo);\n      CLOUD_logDebug(\"Disconnected from cloud service\");\n   }\n}", "CodeBleu_score": 53.80350347139701}, {"code": "void CLOUD_disconnect(void){\n\t   mqttContext *connectionInfo;\n   if (mqttState == CONNECTED) {\n      connectionInfo = MQTT_GetConnectionInfo();\n      MQTT_Disconnect(connectionInfo);\n   }\n   LOG_DEBUG(\"Disconnected from cloud service\");\n}", "CodeBleu_score": 54.368675324014774}, {"code": "void CLOUD_disconnect(void){\n\t   mqttContext *connectionInfo = (mqttContext *) MQTT_GetClientContext();\n   if (connectionInfo == NULL) {\n      return;\n   }\n   if (connectionInfo->connected) {\n      LOG_DEBUG(\"Disconnecting from cloud service\");\n      MQTT_Disconnect(connectionInfo);\n   }\n}", "CodeBleu_score": 49.69744829719148}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tuint8_t ssid[32] = { 0 };\n\tuint8_t password[64] = { 0 };\n\tuint8_t sec_type = 0;\n\tuint16_t channel = 0;\n\n\tif (passed_wifi_creds) {\n\t\tstrcpy((char *) ssid, wifi_ssid);\n\t\tstrcpy((char *) password, wifi_password);\n\t\tsec_type = wifi_sec_type;\n\t\tchannel = wifi_channel;\n\t}\n\n\tif (passed_wifi_creds) {\n\t\tif (m2m_wifi_connect(ssid, strlen((char *) ssid), sec_type, password, channel) == M2M_SUCCESS) {\n\t\t\tlog_printf(LOG_INFO, \"Connected to AP: %s\", ssid);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tlog_printf(LOG_ERROR, \"Failed to connect to AP: %s\", ssid);\n\t\t\tupdate_networking_error_status(NETWORKING_ERROR_WIFI_CONNECT);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (m2m_wifi_default_connect() == M2M_SUCCESS) {\n\t\t\tlog_printf(LOG_INFO, \"Connected to default AP\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tlog_printf(LOG_ERROR, \"Failed to connect to default AP\");\n\t\t\tupdate_networking_error_status(NETWORKING_ERROR_WIFI_CONNECT);\n\t\t\treturn false;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.245044808301}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    if (passed_wifi_creds) {\n        // Connect using new credentials\n        // TODO: Implement this\n        // For now, just return true\n        return true;\n    } else {\n        // Connect using default credentials\n        if (m2m_wifi_default_connect() != SUCCESS) {\n            // Log error message\n            // TODO: Implement this\n            // For now, just return false\n            return false;\n        }\n        // Update networking error status\n        // TODO: Implement this\n        // For now, just return true\n        return true;\n    }\n}", "CodeBleu_score": 31.28383544452437}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    // If the passed_wifi_creds is 0, use the default credentials\n    if (passed_wifi_creds == 0) {\n        // Attempt to connect to the default Wi-Fi access point\n        if (m2m_wifi_default_connect() != M2M_SUCCESS) {\n            // Log an error message\n            log_error(\"Failed to connect to default Wi-Fi access point\");\n            // Update the networking error status\n            network_error = true;\n            // Return false\n            return false;\n        }\n    }\n    // If the passed_wifi_creds is not 0, use the passed credentials\n    else {\n        // Attempt to connect to the Wi-Fi access point using the passed credentials\n        if (m2m_wifi_connect(ssid, strlen(ssid), security_type, (void *)password, channel) != M2M_SUCCESS) {\n            // Log an error message\n            log_error(\"Failed to connect to Wi-Fi access point\");\n            // Update the networking error status\n            network_error = true;\n            // Return false\n            return false;\n        }\n    }\n    // If the connection was successful, return true\n    return true;\n}", "CodeBleu_score": 47.437442920461095}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t  const client = await createClient({\n    url: \"https://graphql.contentful.com/content/v1/spaces/4jy051q6qjvf/environments/master\",\n    accessToken: \"39b7d716a6a32e85762c7d8e938045c507810127735136a749a7a664537670d0\",\n  });\n\n  const query = `\n    query {\n      sensorCollection {\n        items {\n          latitude\n          longitude\n        }\n      }\n    }\n  `;\n\n  const response = await client.query({ query });\n  console.log(\"API response:\", response);\n\n  if (response.data.sensorCollection.items.length > 0) {\n    console.log(\"Retrieving sensors...\");\n    response.data.sensorCollection.items.forEach((sensor) => {\n      const marker = new google.maps.Marker({\n        position: { lat: sensor.latitude, lng: sensor.longitude },\n        map,\n      });\n    });\n  } else {\n    console.log(\"No sensors found.\");\n  }\n}", "CodeBleu_score": 38.22795069080181}, {"code": "async function DisplaySensors(map){\n\t    // Create a client object\n    const client = new GraphQLClient(\"https://api.stg.pollen.io/graphql\", {\n        headers: {\n            \"x-api-key\": \"api-key\",\n        },\n    });\n\n    // Define the GraphQL query\n    const query = gql`\n        query {\n            sensors {\n                id\n                latitude\n                longitude\n            }\n        }\n    `;\n\n    // Send the GraphQL query to the API and wait for the response\n    const response = await client.request(query);\n\n    // Log the API response\n    console.log(response);\n\n    // Check if the API response contains data\n    if (response.data) {\n        // Log the retrieval of sensors\n        console.log(\"Sensors retrieved:\", response.data.sensors);\n\n        // Iterate through each sensor in the response\n        response.data.sensors.forEach((sensor) => {\n            // Create a marker for the sensor\n            const marker = new google.maps.Marker({\n                position: {\n                    lat: sensor.latitude,\n                    lng: sensor.longitude,\n                },\n                map: map,\n            });\n\n            // Add a click event listener to the marker\n            marker.addListener(\"click\", () => {\n                // Log the ID of the clicked sensor\n                console.log(\"Sensor ID:\", sensor.id);\n            });\n        });\n    }\n}", "CodeBleu_score": 37.810069265020694}, {"code": "async function DisplaySensors(map){\n\t    // Create a client\n    const client = new GraphQLClient('https://api.github.com/graphql', {\n        headers: {\n            authorization: `Bearer ${process.env.REACT_APP_GITHUB_AUTH_TOKEN}`\n        }\n    });\n\n    // Send a GraphQL query to fetch sensor data\n    const response = await client.request(`\n        {\n            viewer {\n                repositories(first: 100) {\n                    nodes {\n                        name\n                        description\n                        url\n                        languages(first: 100) {\n                            nodes {\n                                name\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    `);\n\n    // Log the API response\n    console.log(response);\n\n    // Check if the response contains data\n    if (response.data) {\n        // Log the retrieval of sensors\n        console.log('Retrieving sensors...');\n\n        // Iterate through each sensor\n        response.data.viewer.repositories.nodes.forEach(sensor => {\n            // Create a marker for the sensor\n            const marker = new google.maps.Marker({\n                position: { lat: sensor.latitude, lng: sensor.longitude },\n                map: map,\n                title: sensor.name,\n                description: sensor.description,\n                url: sensor.url,\n                languages: sensor.languages.nodes\n            });\n\n            // Add a click event listener to the marker\n            google.maps.event.addListener(marker, 'click', function () {\n                // Open a new window with the sensor's URL\n                window.open(sensor.url, '_blank');\n            });\n        });\n    }\n}", "CodeBleu_score": 35.373074749951186}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t", "CodeBleu_score": 0.7059713833405259}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = '#000000';\n  marker.style.border = '1px solid #000000';\n  return marker;\n}", "CodeBleu_score": 43.978538452447324}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"sensor-marker\";\n  marker.style.backgroundColor = \"#FF0000\";\n  marker.style.border = \"2px solid #000000\";\n  return marker;\n}", "CodeBleu_score": 44.947807107846394}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = \".\".join(\n        [\n            MFA_MODULE_PATH,\n            module_name,\n        ]\n    )\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        raise MFAModuleNotFoundError(\n            f\"Unable to load module {module_name} from {module_path}\"\n        ) from err\n\n    if not hasattr(module, \"MFA_MODULE\"):\n        raise MFAModuleNotFoundError(\n            f\"Unable to load module {module_name} from {module_path} as it does not have the required MFA_MODULE attribute\"\n        )\n\n    if not hasattr(module, \"MFA_REQUIREMENTS\"):\n        return module\n\n    requirements = module.MFA_REQUIREMENTS\n    if not requirements:\n        return module\n\n    if not hass.config.skip_pip:\n        if not hass.config.skip_pip_requirements:\n            if not hass.data.get(DATA_MFA_REQUIREMENTS_PROCESSED).get(module_name):\n                await hass.async_add_executor_job(\n                    _process_requirements, hass, requirements, module_name\n                )\n                hass.data[DATA_MFA_REQUIREMENTS_PROCESSED][module_name] = True\n\n    return module\n\n", "CodeBleu_score": 46.970920263912475}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Could not import module %s: %s\", module_path, err)\n        raise\n    if (\n        hasattr(module, \"REQUIREMENTS\")\n        and not hass.config.skip_pip\n        and not hass.data.get(DATA_PROCESSED_REQUIREMENTS).get(module_name)\n    ):\n        await async_process_requirements(hass, module.REQUIREMENTS)\n        hass.data[DATA_PROCESSED_REQUIREMENTS][module_name] = True\n    return module\n\n", "CodeBleu_score": 42.35747756370345}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant_mfa.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as ex:\n        _LOGGER.error(\n            \"Unable to import %s. Please ensure that the required dependencies are installed.\",\n            module_path,\n        )\n        raise ex\n    except Exception as ex:\n        _LOGGER.exception(\"Failed to load %s\", module_path)\n        raise ex\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not hass.config.skip_pip:\n        if hass.config.skip_pip:\n            _LOGGER.warning(\n                \"Skipping pip installation for %s. Please ensure that the required dependencies are installed.\",\n                module_path,\n            )\n            return module\n        try:\n            await hass.helpers.require.process_requirements(\n                hass.config.path(REQUIREMENTS_FILE), module.REQUIREMENTS\n            )\n        except Exception as ex:\n            _LOGGER.exception(\"Failed to install requirements for %s\", module_path)\n            raise ex\n    return module\n\n", "CodeBleu_score": 44.45366878788508}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[CONF_PIN]\n    if self.data.get(user_id):\n        self.data[user_id][CONF_PIN] = pin\n    else:\n        self.data[user_id] = {CONF_PIN: pin}\n    self.save_data()\n    return True\n\n\n\n", "CodeBleu_score": 30.14173820396262}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if \"pin\" not in setup_data:\n        raise InvalidAuthData(\"No PIN provided\")\n    pin = setup_data[\"pin\"]\n    if not is_valid_pin(pin):\n        raise InvalidAuthData(\"Invalid PIN provided\")\n    user_data = self.data.get_user_data(user_id)\n    if user_data is None:\n        self.data.add_user_data(user_id, {\"pin\": pin})\n    else:\n        user_data[\"pin\"] = pin\n        self.data.update_user_data(user_id, user_data)\n    return {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 45.29735460154457}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[CONF_PIN]\n    if not is_valid_pin(pin):\n        raise InvalidPinError\n    if user_id in self._data:\n        self._data[user_id] = pin\n        await self._async_update_data()\n    else:\n        self._data.append({CONF_USER_ID: user_id, CONF_PIN: pin})\n        await self._async_update_data()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 29.39709131137125}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    if self._initialized:\n        return\n\n    with self._init_lock:\n        if self._initialized:\n            return\n\n        if not (data := await self._store.async_load()):\n            self._user_settings = {}\n            return\n\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id=user_id,\n                name=user_data[\"name\"],\n                enabled=user_data[\"enabled\"],\n                phone_numbers=user_data[\"phone_numbers\"],\n                services=user_data[\"services\"],\n                services_data=user_data[\"services_data\"],\n            )\n            for user_id, user_data in data.items()\n        }\n\n", "CodeBleu_score": 39.33323442216022}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._loaded:\n            return\n\n        if not (data := await self._store.async_load()):\n            self._user_data = {}\n            self._loaded = True\n            return\n\n        self._user_data = {\n            user_id: NotifySetting(\n                user_id,\n                data[user_id].get(\"name\", \"\"),\n                data[user_id].get(\"language\", \"\"),\n                data[user_id].get(\"time_zone\", \"\"),\n                data[user_id].get(\"default_offset\", 0),\n                data[user_id].get(\"default_vibrate\", False),\n                data[user_id].get(\"default_visual\", False),\n                data[user_id].get(\"default_audio\", False),\n                data[user_id].get(\"default_notifications\", False),\n                data[user_id].get(\"default_messages\", False),\n                data[user_id].get(\"default_calls\", False),\n                data[user_id].get(\"default_reminders\", False),\n                data[user_id].get(\"default_media\", False),\n                data[user_id].get(\"default_sounds\", False),\n                data[user_id].get(\"default_lights\", False),\n                data[user_id].get(\"default_vibrations\", False),\n                data[user_id].get(\"default_notification_sounds\", False),\n                data[user_id].get(\"default_notification_lights\", False),\n                data[user_id].get(\"default_notification_vibrations\", False),\n                data[user_id].get(\"default_notification_visuals\", False),\n                data[user_id].get(\"default_notification_calls\", False),\n                data[user_id].get(\"default_notification_reminders\", False),\n                data[user_id].get(\"default_notification_messages\", False),\n                data[user_id].get(\"default_notification_media\", False),\n                data[user_id].get(\"default_notification_sounds\", False),", "CodeBleu_score": 20.99175090086258}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is None:\n            try:\n                data = await self._store.async_load()\n            except Exception:  # pylint: disable=broad-except\n                _LOGGER.exception(\"Error loading user settings\")\n                data = {}\n\n            if data is None:\n                data = {}\n\n            self._user_settings = {\n                user_id: {\n                    key: NotifySetting(\n                        user_id,\n                        key,\n                        data.get(user_id, {}).get(key, {}),\n                    )\n                    for key in self._notify_domains\n                }\n                for user_id in data\n            }\n\n", "CodeBleu_score": 39.16359429228569}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._load_user_settings(user_id)\n\n    settings = await self._get_notification_settings(user_id)\n    if settings is None:\n        return False\n\n    # Validate OTP\n    if not await self.hass.async_add_executor_job(\n        self._validate_otp, user_input.get(CONF_OTP)\n    ):\n        return False\n\n    return True\n\n", "CodeBleu_score": 44.887240714409494}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_user_settings(user_id)\n    settings = self.user_settings.get(user_id)\n    if not settings:\n        return False\n\n    # Validate the user input using an executor job\n    return await asyncio.get_running_loop().run_in_executor(\n        None, self._validate_user_input, user_id, user_input, settings\n    )\n\n", "CodeBleu_score": 48.5253096764805}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load_user_settings(user_id)\n\n    if (settings := self._user_settings.get(user_id)) is None:\n        _LOGGER.debug(\"No settings found for user %s\", user_id)\n        return False\n\n    if settings.otp_method == OTP_METHOD_PUSH:\n        _LOGGER.debug(\"OTP method is PUSH, skipping validation\")\n        return True\n\n    if not user_input.get(CONF_OTP):\n        _LOGGER.debug(\"OTP not provided\")\n        return False\n\n    try:\n        await self.hass.async_add_executor_job(\n            self._validate_otp, user_id, user_input[CONF_OTP]\n        )\n    except InvalidOTPError:\n        _LOGGER.debug(\"Invalid OTP\")\n        return False\n\n    return True\n\n", "CodeBleu_score": 50.804929102587046}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entities.get(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.devices.get(entity.device_id)\n    if device is None:\n        return None\n    area = device.area_id\n    if area is None:\n        return None\n    return area_dict.get(area)\n\n", "CodeBleu_score": 56.8861988638793}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.get_entity_entry(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.get_device_entry(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    if device_entry.area_id is None:\n        return None\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 62.918645838745334}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get(entity_id)\n    if entity is None:\n        return None\n\n    device_id = entity.device_id\n    device = perm_lookup.get(device_id)\n    if device is None:\n        return None\n\n    area_id = device.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 52.967804440945244}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_ in policies:\n        assert isinstance(policy_, dict)\n        for category in policy_:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_sources = [policy_.get(category) for policy_ in policies]\n\n            policy[category] = _merge_policies(category_sources)\n\n    return policy\n\n", "CodeBleu_score": 62.096886204268145}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {\n        \"categories\": {},\n        \"permissions\": {},\n    }\n    seen: set[str] = set()\n    for policy_ in policies:\n        assert isinstance(policy_, dict)\n        for key in policy_:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [policy_.get(key) for policy_ in policies]\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy", "CodeBleu_score": 47.60104274387988}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = None\n    seen: set[str] = set()\n    for source in policies:\n        if source is None:\n            continue\n\n        # A source that's True will always win. Shortcut return.\n        if source is True:\n            return True\n\n        assert isinstance(source, dict)\n\n        if policy is None:\n            policy = cast(PolicyType, {})\n\n        assert isinstance(policy, dict)\n\n        for key in source:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [src.get(key) for src in policies if isinstance(src, dict)]\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy\n\n", "CodeBleu_score": 46.74088899301836}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        auth_provider_module = await async_import_module(hass, provider)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Failed to import auth provider %s\", provider)\n        raise HomeAssistantError(\n            \"Failed to import auth provider. \"\n            \"Did you install the required python package?\"\n        ) from None\n\n    if not hasattr(auth_provider_module, \"AUTH_PROVIDER_TYPE\"):\n        _LOGGER.error(\"Auth provider %s has no AUTH_PROVIDER_TYPE\", provider)\n        raise HomeAssistantError(\n            \"Auth provider has no AUTH_PROVIDER_TYPE. \"\n            \"Did you install the required python package?\"\n        )\n\n    if not hasattr(auth_provider_module, \"AUTH_PROVIDER_CONFIG_SCHEMA\"):\n        _LOGGER.error(\"Auth provider %s has no AUTH_PROVIDER_CONFIG_SCHEMA\", provider)\n        raise HomeAssistantError(\n            \"Auth provider has no AUTH_PROVIDER_CONFIG_SCHEMA. \"\n            \"Did you install the required python package?\"\n        )\n\n    if not hasattr(auth_provider_module, \"AUTH_PROVIDER_CREDENTIALS_SCHEMA\"):\n        _LOGGER.error(\n            \"Auth provider %s has no AUTH_PROVIDER_CREDENTIALS_SCHEMA\", provider\n        )\n        raise HomeAssistantError(\n            \"Auth provider has no AUTH_PROVIDER_CREDENTIALS_SCHEMA. \"\n            \"Did you install the required python package?\"\n        )\n\n    if not hasattr(auth_provider_module, \"AUTH_PROVIDER_FLOW_HANDLERS\"):\n        _LOGGER.error(\"Auth provider %s has no AUTH_PROVIDER_FLOW_HANDLERS\", provider)\n        raise HomeAssistantError(\n            \"Auth provider has no AUTH_PROVIDER_FLOW_HANDLERS. \"\n            \"Did you install the required python package?\"\n        )\n\n    if not hasattr(auth_provider_module,", "CodeBleu_score": 23.777976028989112}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError:\n        _LOGGER.exception(\"Error loading auth provider %s\", provider)\n        raise HomeAssistantError(\n            f\"Error loading auth provider {provider}\",\n            \"provider\",\n            provider,\n        ) from None\n\n    if not hasattr(module, \"STORAGE_VERSION\"):\n        return module\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    for req in module.REQUIREMENTS:\n        hass.components.processed.add(req)\n\n    return module\n\n", "CodeBleu_score": 41.09423137680919}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        auth_provider_module = await async_import_module(hass, f\"auth_provider.{provider}\")\n    except ModuleNotFoundError:\n        _LOGGER.exception(\"Failed to import auth provider module %s\", provider)\n        raise HomeAssistantError(\n            f\"Failed to import auth provider module {provider}\"\n        ) from None\n\n    if auth_provider_module.REQUIREMENTS:\n        await async_process_auth_provider_requirements(hass, auth_provider_module)\n\n    return auth_provider_module\n\n", "CodeBleu_score": 30.250141141861338}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(\"utf-8\"), user.password_hash):\n                return user\n            else:\n                raise InvalidAuth\n    if bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        raise InvalidAuth\n\n", "CodeBleu_score": 37.23548844396173}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.strip().lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    user = None\n    for u in self.users:\n        if u.username == username:\n            user = u\n            break\n    if user is None:\n        bcrypt.checkpw(password.encode(), dummy_hash)\n        raise InvalidAuth(\"Invalid username or password\")\n    password_hash = user.password_hash\n    if not bcrypt.checkpw(password.encode(), password_hash):\n        raise InvalidAuth(\"Invalid username or password\")\n    return user\n\n", "CodeBleu_score": 39.00024244478338}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            password_hash = user[\"password\"]\n            if not bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                raise InvalidAuth(\"Invalid username or password\")\n            return\n    if not bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        raise InvalidAuth(\"Invalid username or password\")\n\n\n", "CodeBleu_score": 40.64379548462948}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    if username in self._users:\n        self._users.remove(username)\n        self._save()\n    else:\n        raise InvalidUser(\"user_not_found\")", "CodeBleu_score": 23.08257376961395}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    if username in self.users:\n        self.users.pop(username)\n        self.save()\n    else:\n        raise InvalidUser(\"user_not_found\")", "CodeBleu_score": 22.9960155225275}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    if username in self._users:\n        del self._users[username]\n    else:\n        raise InvalidUser(\"user_not_found\")", "CodeBleu_score": 18.055468433616195}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n    try:\n        await self.async_remove_credentials(credentials)\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 47.203248759718775}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n\n    try:\n        await self._remove_auth(credentials.username)\n    except InvalidUser:\n        pass\n\n    await self.async_save()\n\n", "CodeBleu_score": 52.156177173427174}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n    try:\n        del self._data[credentials.username]\n        await self.async_save()\n    except KeyError:\n        _LOGGER.warning(\"User %s not found\", credentials.username)\n\n", "CodeBleu_score": 49.74698934074063}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        try:\n            thread.join(timeout)\n        except TimeoutError:\n            thread.interrupt_if_running()\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    for thread in threads:\n        if thread in joined:\n            continue\n        thread.interrupt_if_running()\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    for thread in threads:\n        if thread in joined:\n            continue\n        try:\n            sys.exit(1)\n        except SystemExit:\n            joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 46.57953703341683}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined_threads.add(thread)\n            continue\n        if not thread.ident:\n            joined_threads.add(thread)\n            continue\n        thread.join(timeout)\n        if thread.is_alive():\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            thread.raise_exc(SystemExit)\n        joined_threads.add(thread)\n    return joined_threads\n\n", "CodeBleu_score": 49.23167723410911}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        thread.join(timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        thread.raise_exc(SystemExit)\n    return joined\n\n", "CodeBleu_score": 54.33970845333134}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    import threading\n    import time\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.warning(\"Shutting down with deadlock safe shutdown\")\n    threads = threading.enumerate()\n    threads = [t for t in threads if not t.is_main_thread() and not t.is_daemon() and t.is_alive()]\n    timeout = (1000000 / len(threads)) if len(threads) > 0 else 1000000\n    for thread in threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            logger.warning(f\"Thread {thread.name} failed to shutdown\")", "CodeBleu_score": 35.088689306600195}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    import threading\n    import time\n    import logging\n    remaining_threads = [t for t in threading.enumerate() if not t.is_alive() and t is not threading.main_thread() and not t.isDaemon()]\n    timeout = threading.main_thread().get_shutdown_timeout() / len(remaining_threads)\n    for thread in remaining_threads:\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            logging.warning(\"Error joining thread %s: %s\", thread.name, e)\n\n\n", "CodeBleu_score": 49.60776757287012}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    import threading\n    import time\n    import logging\n    import sys\n    from typing import Any\n    logger = logging.getLogger(__name__)\n    logger.info(\"Shutting down...\")\n    threads = threading.enumerate()\n    threads = [t for t in threads if t.name != \"MainThread\" and t.daemon is False and t.is_alive()]\n    timeout = 10\n    for t in threads:\n        t.join(timeout)\n        if t.is_alive():\n            logger.warning(f\"Thread {t.name} did not shut down in time. It will be killed.\")\n            t.join()\n    logger.info(\"Shutdown complete.\")\n\n\n\n\n", "CodeBleu_score": 31.515829783070537}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_internal_dispatcher_send(\n            \"remaining_setups\",\n            remaining_with_setup_started,\n        )\n    self._remaining_setups = bool(remaining_with_setup_started)", "CodeBleu_score": 46.37734991897772}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n        self._async_dispatch_signal(\n            \"setup_started\",\n            {\n                \"setups\": remaining_with_setup_started,\n                \"setups_total\": len(remaining_with_setup_started),\n            },\n        )\n        self._remaining_setups = remaining_with_setup_started\n    elif self._remaining_setups:\n        self._async_dispatch_signal(\n            \"setup_finished\",\n            {\n                \"setups\": self._remaining_setups,\n                \"setups_total\": len(self._remaining_setups),\n            },\n        )\n        self._remaining_setups = {}\n\n\n\n\n def _async_dispatch_signal(self, signal_name: str, data: dict[str, Any]) -> None:\n    \"\"\"The function \"_async_dispatch_signal\" dispatches a signal with the given name and data.", "CodeBleu_score": 44.96569764963222}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._last_remaining_with_setup_started:\n        self._last_remaining_with_setup_started = remaining_with_setup_started\n        self._internal_dispatcher.dispatch(\n            \"remaining_setups\", remaining_with_setup_started\n        )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 41.813766163849344}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Generate and validate bluetooth.py\n    generated_content = generate_and_validate(integrations)\n\n    # Read the current content of bluetooth.py\n    current_content = config.get(\"bluetooth\", \"\")\n\n    # Compare the generated content with the current content\n    if generated_content != current_content:\n        # Add an error to the configuration indicating that bluetooth.py is not up to date\n        config.add_error(\n            \"bluetooth.py is not up to date\",\n            \"bluetooth.py is not up to date. Please run the script to update it.\",\n            fixable=True,\n        )\n\n        # Provide a fixable suggestion to update bluetooth.py\n        config.add_fixable_suggestion(\n            \"Update bluetooth.py\",\n            \"Run the script to update bluetooth.py.\",\n            fix=lambda config: config.set(\"bluetooth\", generated_content),\n        )\n\n", "CodeBleu_score": 41.39799394355891}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    generated_content = generate_and_validate(integrations)\n\n    if config.bluetooth_content != generated_content:\n        config.add_error(\n            \"bluetooth\",\n            \"bluetooth.py is not up to date\",\n            fixable=Fixable(\n                fix=lambda: config.cache.set(\"bluetooth_content\", generated_content)\n            ),\n        )\n\n", "CodeBleu_score": 31.32081930966829}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.get(\"bluetooth\", {}).get(\"validate\", True):\n        return\n\n    if not integrations:\n        return\n\n    generated = generate_and_validate(integrations)\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    # Validate all integrations\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.get(\"bluetooth\", {}).get(\"validate_all\", False):\n        return\n\n    if not config.", "CodeBleu_score": 25.2915635767732}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create a new HTTP client\n\tclient := &http.Client{}\n\n\t// Create a new POST request to the Dropbox OAuth2 token endpoint with the refresh token, app key, and app secret\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers\n\treq.Header.Set(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(d.AppKey+\":\"+d.AppSecret)))\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Set the request body\n\tbody := url.Values{}\n\tbody.Set(\"grant_type\", \"refresh_token\")\n\tbody.Set(\"refresh_token\", d.RefreshToken)\n\n\t// Set the request body as the request's body\n\treq.Body = ioutil.NopCloser(strings.NewReader(body.Encode()))\n\n\t// Send the request\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Read the response body\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Parse the response body as JSON\n\tvar respJSON map[string]interface{}\n\terr = json.Unmarshal(respBody, &respJSON)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the request was successful\n\tif resp.StatusCode != 200 {\n\t\treturn fmt.Errorf(\"refresh token failed: %s\", respJSON[\"error_description\"])\n\t}\n\n\t// Update the access token\n\td.AccessToken = respJSON[\"access_token\"].(string)\n\n\treturn nil\n}", "CodeBleu_score": 49.502045775957306}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropboxapi.com/oauth2/token\"\n\tdata := url.Values{}\n\tdata.Set(\"grant_type\", \"refresh_token\")\n\tdata.Set(\"refresh_token\", d.RefreshToken)\n\tdata.Set(\"client_id\", d.AppKey)\n\tdata.Set(\"client_secret\", d.AppSecret)\n\n\treq, err := http.NewRequest(\"POST\", url, strings.NewReader(data.Encode()))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\tresp, err := d.Client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"error refreshing token: %s\", string(body))\n\t}\n\n\tvar tokenResponse struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\n\tif err := json.Unmarshal(body, &tokenResponse); err != nil {\n\t\treturn err\n\t}\n\n\td.AccessToken = tokenResponse.AccessToken\n\n\treturn nil\n}", "CodeBleu_score": 51.007859457349284}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\turl := \"https://api.dropboxapi.com/oauth2/token\"\n\n\tpayload := strings.NewReader(\"{\n  \\\"grant_type\\\": \\\"refresh_token\\\",\n  \\\"refresh_token\\\": \\\"\" + d.RefreshToken + \"\\\"\n}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(d.AppKey+\":\"+d.AppSecret)))\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\n\tres, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar data map[string]interface{}\n\terr = json.Unmarshal(body, &data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td.AccessToken = data[\"access_token\"].(string)\n\n\treturn nil\n}", "CodeBleu_score": 52.0099717769502}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\trespBody, err := d.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif respBody.StatusCode == 401 {\n\t\td.token, err = d.tokenSource.Token()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\t\trespBody, err = d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif resp != nil {\n\t\terr = json.NewDecoder(respBody.Body).Decode(resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tdefer respBody.Body.Close()\n\n\treturn ioutil.ReadAll(respBody.Body)\n}", "CodeBleu_score": 55.09355771520114}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tclient := &http.Client{}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode == 401 {\n\t\td.token, err = d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\t\tres, err = client.Do(req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif res.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"request failed with status code %d\", res.StatusCode)\n\t}\n\n\tif resp != nil {\n\t\terr = json.NewDecoder(res.Body).Decode(resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}", "CodeBleu_score": 55.06019279656815}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 5\n\n\tfileSize := stream.Size()\n\tchunkCount := int(math.Ceil(float64(fileSize) / float64(chunkSize)))\n\n\tfor i := 0; i < chunkCount; i++ {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tstart := i * chunkSize\n\t\tend := start + chunkSize\n\t\tif end > fileSize {\n\t\t\tend = fileSize\n\t\t}\n\n\t\tchunk := stream.GetChunk(start, end)\n\n\t\treq, err := http.NewRequest(\"PUT\", url, bytes.NewReader(chunk))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", start, end-1, fileSize))\n\n\t\tres, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer res.Body.Close()\n\n\t\tif res.StatusCode != http.StatusOK && res.StatusCode != http.StatusNoContent {\n\t\t\tbody, _ := io.ReadAll(res.Body)\n\t\t\treturn fmt.Errorf(\"failed to upload chunk %d: %s\", i, string(body))\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.371027132797536}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := 1024 * 1024 * 50 // 50 MB\n\tbuffer := make([]byte, chunkSize)\n\tuploaded := 0\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tn, err := stream.Read(buffer)\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif n == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treq, err := http.NewRequest(\"PUT\", url, bytes.NewReader(buffer[:n]))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", uploaded, uploaded+n-1, stream.Size()))\n\n\t\t\tresp, err := d.client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\tif resp.StatusCode != http.StatusOK {\n\t\t\t\treturn fmt.Errorf(\"upload failed with status code %d\", resp.StatusCode)\n\t\t\t}\n\n\t\t\tuploaded += n\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 40.779912619572045}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := d.getChunkSize()\n\tbuffer := make([]byte, chunkSize)\n\n\tfor {\n\t\tn, err := stream.Read(buffer)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\t_, err = d.uploadChunk(ctx, buffer[:n], url)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.224083974725847}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tjsonData := make(map[string]interface{})\n\tif err := ctx.Bind(&jsonData); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": \"Failed to bind JSON data.\",\n\t\t})\n\t}\n\n\tmountPoint, ok := jsonData[\"mount_point\"].(string)\n\tif !ok || mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": \"Invalid mount point.\",\n\t\t})\n\t}\n\n\tif err := unmountStorage(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": \"Failed to unmount storage.\",\n\t\t})\n\t}\n\n\tif err := deleteConfig(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": \"Failed to delete configuration.\",\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\": \"Storage unmounted successfully.\",\n\t})\n}", "CodeBleu_score": 32.824829240190326}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context\n\tvar data struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&data); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Get the mount point from the JSON data\n\tmountPoint := data.MountPoint\n\n\t// Check if the mount point is empty\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"Mount point cannot be empty\")\n\t}\n\n\t// Unmount the storage at the specified mount point\n\tif err := unmountStorage(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := deleteStorageConfig(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, \"Storage unmounted successfully\")\n}", "CodeBleu_score": 34.96166576457587}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind JSON data from the request context to a struct\n\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": err.Error()})\n\t}\n\n\t// Check if the mount point is empty\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"mount_point is required\"})\n\t}\n\n\t// Unmount the storage at the specified mount point\n\tif err := unmountStorage(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": err.Error()})\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := deleteConfig(req.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": err.Error()})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, echo.Map{\"message\": \"Storage unmounted successfully\"})\n}", "CodeBleu_score": 33.91192035537376}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"filePath\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"filePath is required\"})\n\t}\n\n\tfileBytes, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"file not found\"})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"file\": string(fileBytes)})\n}", "CodeBleu_score": 32.66318554421112}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Path parameter is required\"})\n\t}\n\n\tfilePath := filepath.Join(\".\", path)\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 38.90306886387302}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"File path is required\",\n\t\t})\n\t}\n\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"File not found\",\n\t\t})\n\t}\n\tdefer file.Close()\n\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 36.7533493632448}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]interface{}\n\n\tname := ctx.Param(\"name\")\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\tgo func() {\n\t\ttime.Sleep(time.Second)\n\t\tnotification.Send(name, message)\n\t}()\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"status\": \"ok\",\n\t})\n}", "CodeBleu_score": 43.05571399125382}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\tif err := notify.Send(name, message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]string{\n\t\t\"message\": \"Notification sent successfully\",\n\t})\n}", "CodeBleu_score": 55.38060528634756}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.QueryParam(\"name\")\n\n\tmessage := make(map[string]interface{})\n\terr := ctx.Bind(&message)\n\tif err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\terr = Notify(name, message)\n\tif err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"Notification sent\")\n}", "CodeBleu_score": 50.75104730253083}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Start the message sending service if it's not already running\n\tif !messageSendingServiceRunning {\n\t\tgo sendMessages()\n\t\tmessageSendingServiceRunning = true\n\t}\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// If there's an error, remove the WebSocket connection from the list of connections\n\t\t\tremoveConnection(ws)\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(\"Received message:\", mt, string(message), err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.82175867249749}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\n\t// Upgrade the HTTP connection to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service if it is not already running\n\tif !messageSendingServiceRunning {\n\t\tmessageSendingServiceRunning = true\n\t\tgo sendMessages()\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\tmessageType, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tlog.Printf(\"Received message of type %d: %s, %v\", messageType, message, err)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections\n\tfor i, connection := range connections {\n\t\tif connection == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the WebSocket connection\n\treturn ws.Close()\n}", "CodeBleu_score": 47.052555396093545}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service if it is not already running\n\tif !messageSendingServiceRunning {\n\t\tmessageSendingServiceRunning = true\n\t\tgo sendMessages()\n\t}\n\n\t// Continuously read messages from the WebSocket connection\n\tfor {\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// If the WebSocket connection is closed, remove it from the list of connections\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Received message type: %d, message: %s, error: %v\", msgType, msg, err)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 46.5935481685839}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tctx.Response().Header().Set(\"Content-Type\", \"application/json\")\n\n\t// Get the drive model and architecture\n\tdriveModel := \"Unknown\"\n\tarchitecture := \"Unknown\"\n\n\tcmd := exec.Command(\"wmic\", \"diskdrive\", \"get\", \"model,size\")\n\toutput, err := cmd.Output()\n\tif err == nil {\n\t\tlines := strings.Split(string(output), \"\n\")\n\t\tif len(lines) >= 2 {\n\t\t\tdriveModel = strings.TrimSpace(lines[1])\n\t\t\tarchitecture = strings.TrimSpace(lines[2])\n\t\t}\n\t}\n\n\t// Get CPU information\n\tvar cpuInfo string\n\tcmd = exec.Command(\"wmic\", \"cpu\", \"get\", \"name,numberofcores,maxclockspeed\")\n\toutput, err = cmd.Output()\n\tif err == nil {\n\t\tlines := strings.Split(string(output), \"\n\")\n\t\tif len(lines) >= 2 {\n\t\t\tcpuInfo = lines[1]\n\t\t}\n\t}\n\n\t// Create the JSON response\n\tresponse := map[string]interface{}{\n\t\t\"success\": true,\n\t\t\"data\": map[string]interface{}{\n\t\t\t\"drive_model\":    driveModel,\n\t\t\t\"architecture\":   architecture,\n\t\t\t\"cpu_information\": cpuInfo,\n\t\t},\n\t}\n\n\t// Return the JSON response\n\treturn ctx.JSON(http.StatusOK, response)\n}", "CodeBleu_score": 26.97214564788834}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Retrieve the system hardware information\n\tinfo := getSystemHardwareInfo()\n\n\t// Check if CPU information is available\n\tif info.CPU != nil {\n\t\t// Return the system hardware information as a JSON response with a success message\n\t\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\t\"success\": true,\n\t\t\t\"data\":    info,\n\t\t})\n\t}\n\n\t// Return the system hardware information as a JSON response with a failure message\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"success\": false,\n\t\t\"message\": \"No CPU information available\",\n\t})\n}", "CodeBleu_score": 18.280122714853004}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\ttype HardwareInfo struct {\n\t\tDriveModel string `json:\"drive_model\"`\n\t\tArch       string `json:\"arch\"`\n\t\tCpu        string `json:\"cpu\"`\n\t}\n\n\tdriveModel, err := GetDriveModel()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": err.Error()})\n\t}\n\n\tarch, err := GetArchitecture()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": err.Error()})\n\t}\n\n\tcpu, err := GetCpuInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": err.Error()})\n\t}\n\n\thardwareInfo := HardwareInfo{\n\t\tDriveModel: driveModel,\n\t\tArch:       arch,\n\t\tCpu:        cpu,\n\t}\n\n\treturn ctx.JSON(http.StatusOK, echo.Map{\"message\": \"Success\", \"data\": hardwareInfo})\n}", "CodeBleu_score": 22.066162963709594}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif s.systemctl.IsActive(service) {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 63.919498872004965}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tstatus, err := s.systemctl.Status(service)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif status == \"active\" {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 60.884193692871435}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := make([]string, 0)\n\tnotRunningServices := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif s.systemctl.IsRunning(service) {\n\t\t\t\trunningServices = append(runningServices, service)\n\t\t\t} else {\n\t\t\t\tnotRunningServices = append(notRunningServices, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}", "CodeBleu_score": 57.94619923208364}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Println(\"Error marshalling message:\", err)\n\t\treturn\n\t}\n\tctx := context.Background()\n\tresp, err := i.publisher.Publish(ctx, &pb.PublishRequest{\n\t\tName: name,\n\t\tData: jsonMessage,\n\t})\n\tif err != nil {\n\t\tlog.Println(\"Error publishing event:\", err)\n\t\treturn\n\t}\n\tif resp.Status != pb.Status_OK {\n\t\tlog.Println(\"Failed to publish event:\", resp.Message)\n\t}\n}", "CodeBleu_score": 35.764439948018506}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\ti.log.Info(\"SendNotify\", zap.String(\"name\", name))\n\n\tmessageString, err := json.Marshal(message)\n\tif err != nil {\n\t\ti.log.Error(\"SendNotify\", zap.Error(err))\n\t\treturn\n\t}\n\n\tctx := context.Background()\n\tevent := &broker.Event{\n\t\tName: name,\n\t\tData: messageString,\n\t}\n\n\tresp, err := i.bus.Publish(ctx, event)\n\tif err != nil {\n\t\ti.log.Error(\"SendNotify\", zap.Error(err))\n\t\treturn\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\ti.log.Error(\"SendNotify\", zap.String(\"response\", resp.Details))\n\t\treturn\n\t}\n}", "CodeBleu_score": 38.64520139136303}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\ti.log.Info(\"SendNotify\", \"name\", name, \"message\", message)\n\n\tdata, err := json.Marshal(message)\n\tif err != nil {\n\t\ti.log.Error(err, \"failed to marshal message\")\n\t\treturn\n\t}\n\n\tresp, err := i.bus.Publish(name, data)\n\tif err != nil {\n\t\ti.log.Error(err, \"failed to publish event\", \"name\", name, \"message\", message)\n\t\treturn\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\ti.log.Error(errors.New(\"failed to publish event\"), \"failed to publish event\", \"name\", name, \"message\", message, \"status\", resp.Status, \"details\", resp.Details)\n\t}\n}", "CodeBleu_score": 35.10700988911485}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.runtimePath, message_bus.WithHTTPClient(c.httpClient))\n\n\taddress, err := c.getAddress(c.runtimePath)\n\tif err != nil {\n\t\tclient.Server = \"http://localhost:10000\"\n\t} else {\n\t\tclient.Server = address\n\t}\n\n\treturn client\n}", "CodeBleu_score": 54.34531620528259}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.server, message_bus.WithRequestEditorFn(c.requestEditor))\n\n\taddress, err := c.getAddress()\n\tif err != nil {\n\t\tclient.Client.Server = \"Error: \" + err.Error()\n\t} else {\n\t\tclient.Client.Server = address\n\t}\n\n\treturn client\n}", "CodeBleu_score": 41.8365122038308}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\"http://localhost:8080/api/v1/message_bus\")\n\n\taddress, err := c.GetMessageBusAddress()\n\tif err != nil {\n\t\tclient.Server = \"http://localhost:8080/api/v1/message_bus\"\n\t} else {\n\t\tclient.Server = address\n\t}\n\n\treturn client\n}", "CodeBleu_score": 37.011140308965636}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.44245846638746}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\n\tif strings.Contains(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\tif strings.Contains(ip, \"::ffff:127.0.0.1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 50.019559679835204}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\tif strings.Contains(ip, \"::ffff:127.0.0.1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 50.019559679835204}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\n\t// Define paths for the modules directory and the entry file\n\tmodulesDir := \"./modules\"\n\tentryFile := modulesDir + \"/entry.json\"\n\n\t// Ensure the entry file exists\n\t_, err := os.Stat(entryFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\t// Create the entry file\n\t\t\tfile, err := os.Create(entryFile)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\t// Write an empty JSON array to the entry file\n\t\t\t_, err = file.WriteString(\"[]\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t} else {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tvar moduleEntries []map[string]interface{}\n\terr = filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif filepath.Base(path) == \"entry.json\" {\n\t\t\tmoduleEntry, err := c.readModuleEntry(path)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tmoduleEntries = append(moduleEntries, moduleEntry)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Concatenate the module entries into a single JSON array\n\tentryData, err := json.Marshal(moduleEntries)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Write the concatenated JSON array to the entry file\n\terr = ioutil.WriteFile(entryFile, entryData, 0644)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}", "CodeBleu_score": 48.287596682931756}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\n\t// Define the path to the modules directory\n\tmodulesPath := \"./modules\"\n\n\t// Define the path to the entry file\n\tentryFilePath := \"./entry.json\"\n\n\t// Open the entry file for writing\n\tentryFile, err := os.Create(entryFilePath)\n\tif err != nil {\n\t\tlog.Println(\"Error creating entry file:\", err)\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\n\t// Create a new JSON array\n\tentryArray := []interface{}{}\n\n\t// Read each module directory for entry.json files\n\tmoduleDirs, err := os.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlog.Println(\"Error reading module directories:\", err)\n\t\treturn\n\t}\n\n\tfor _, moduleDir := range moduleDirs {\n\t\tif moduleDir.IsDir() {\n\t\t\tmodulePath := filepath.Join(modulesPath, moduleDir.Name())\n\t\t\tentryFilePath := filepath.Join(modulePath, \"entry.json\")\n\t\t\tentryFile, err := os.Open(entryFilePath)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Error opening entry file:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdefer entryFile.Close()\n\n\t\t\t// Read the entry file as a JSON array\n\t\t\tvar entryData []interface{}\n\t\t\terr = json.NewDecoder(entryFile).Decode(&entryData)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Error decoding entry file:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Append the entry data to the entry array\n\t\t\tentryArray = append(entryArray, entryData...)\n\t\t}\n\t}\n\n\t// Write the entry array to the entry file\n\terr = json.NewEncoder(entryFile).Encode(entryArray)\n\tif err != nil {\n\t\tlog.Println(\"Error encoding entry array:\", err)\n\t\treturn\n\t}\n\n\tlog.Println(\"Entry file generated successfully.\")\n}", "CodeBleu_score": 51.8078047496736}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesDir := \"./modules\"\n\tentryFile := \"./entry.json\"\n\n\t// Read each module directory for entry.json files\n\tentries := []string{}\n\tmoduleDirs, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlog.Printf(\"Error reading module directory: %v\", err)\n\t\treturn\n\t}\n\tfor _, moduleDir := range moduleDirs {\n\t\tif !moduleDir.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tentryPath := filepath.Join(modulesDir, moduleDir.Name(), \"entry.json\")\n\t\tentryBytes, err := os.ReadFile(entryPath)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading entry file: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tentries = append(entries, string(entryBytes))\n\t}\n\n\t// Write the concatenated entries to the entry file\n\terr = os.WriteFile(entryFile, []byte(fmt.Sprintf(\"[%s]\", strings.Join(entries, \",\"))), 0644)\n\tif err != nil {\n\t\tlog.Printf(\"Error writing entry file: %v\", err)\n\t}\n}", "CodeBleu_score": 53.11845585548295}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.systemService.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, netName := range netNames {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 65.35980319042245}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t    var err error\n    var result string\n\n    err = c.SystemService.Call(\"GetMacAddress\", nil, &result)\n\n    return result, err\n}", "CodeBleu_score": 24.988566483575102}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, networkName := range networkNames {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == networkName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"no matching interface found\")\n}", "CodeBleu_score": 64.87871835347545}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t result = 0;\n    if (pTscObj->pRequestList == NULL) {\n        pTscObj->pRequestList = pRequest;\n    } else {\n        SRequestObj *pCurrentRequest = pTscObj->pRequestList;\n        while (pCurrentRequest->pNext != NULL) {\n            pCurrentRequest = pCurrentRequest->pNext;\n        }\n        pCurrentRequest->pNext = pRequest;\n    }\n    pRequest->pNext = NULL;\n    pRequest->pTscObj = pTscObj;\n    pTscObj->requestCount++;\n    if (pTscObj->pAppInfo != NULL) {\n        pTscObj->pAppInfo->requestCount++;\n    }\n    logDebug(\"Registering request %p for TSC object %p\", pRequest, pTscObj);\n    return result;\n}", "CodeBleu_score": 37.84093388548989}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t", "CodeBleu_score": 3.907047286077039}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t", "CodeBleu_score": 3.907047286077039}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    bool bRet = true;\n    SRequestDbObj *pDbObj = NULL;\n    SRequestDbObj *pDbObjTmp = NULL;\n    char *pDbName = NULL;\n    char *pDbNameTmp = NULL;\n    char *pDbNameTmp2 = NULL;\n    char *pDbNameTmp3 = NULL;\n\n    if (pRequest == NULL || exceptDb == NULL) {\n        return true;\n    }\n\n    pDbObj = pRequest->pDbObj;\n    if (pDbObj == NULL) {\n        return true;\n    }\n\n    if (strcmp(pDbObj->dbName, exceptDb) != 0) {\n        pDbObjTmp = pDbObj;\n        while (pDbObjTmp != NULL) {\n            pDbName = pDbObjTmp->dbName;\n            if (pDbName != NULL) {\n                pDbNameTmp = strchr(pDbName, '.');\n                if (pDbNameTmp != NULL) {\n                    pDbNameTmp2 = strchr(pDbNameTmp + 1, '.');\n                    if (pDbNameTmp2 != NULL) {\n                        pDbNameTmp3 = strchr(pDbNameTmp2 + 1, '.');\n                        if (pDbNameTmp3 != NULL) {\n                            pDbNameTmp3[0] = '\\0';\n                        }\n                        pDbNameTmp2[0] = '\\0';\n                    }\n                    pDbNameTmp[0] = '\\0';\n                }\n\n                if (strcmp(pDbName, exceptDb) == 0) {\n                    bRet = false;\n                    break;\n                }\n            }\n            pDbObjTmp = pDbObjTmp->pNext;\n        }\n    }\n\n    return bRet;\n}", "CodeBleu_score": 41.04579880696977}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  bool result;\n  if (code != 0) {\n    if (msgType != MSG_TYPE_RPC_RESPONSE) {\n      if (msgType != MSG_TYPE_RPC_RESPONSE_FAIL) {\n        if (msgType != MSG_TYPE_RPC_RESPONSE_REDIRECT) {\n          if (msgType != MSG_TYPE_RPC_RESPONSE_REDIRECT_FAIL) {\n            result = true;\n          } else {\n            result = false;\n          }\n        } else {\n          result = false;\n        }\n      } else {\n        result = false;\n      }\n    } else {\n      result = false;\n    }\n  } else {\n    result = false;\n  }\n  return result;\n}", "CodeBleu_score": 36.59530380468606}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t  if (code == -32603) {\n    if (msgType != tmsg_t_t_call && msgType != tmsg_t_t_notification && msgType != tmsg_t_t_response && msgType != tmsg_t_t_error) {\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 33.465653302964995}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t  if (pRequests == NULL) return;\n\n  int64_t rid;\n  TAOS_RES *pRes;\n  SHashObj *pHash = pRequests;\n\n  for (int i = 0; i < pHash->size; ++i) {\n    if (pHash->pBuckets[i] == NULL) continue;\n\n    SListObj *pList = pHash->pBuckets[i];\n    while (pList != NULL) {\n      rid = (int64_t)pList->pData;\n      pRes = taosGetRef(clientReqRefPool, rid);\n      if (pRes == NULL) {\n        pList = pList->pNext;\n        continue;\n      }\n\n      taosStopQuery(pRes);\n      taosReleaseRef(clientReqRefPool, rid);\n\n      pList = pList->pNext;\n    }\n  }\n}", "CodeBleu_score": 42.095339209880436}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SHashObj *pReq;\n  int64_t   rid;\n  int64_t   i;\n\n  for (i = 0; i < pRequests->nBuckets; ++i) {\n    pReq = pRequests->pBuckets[i];\n    while (pReq) {\n      rid = (int64_t)pReq->pData;\n      if (rid != TAOS_INVALID_REQUEST_ID) {\n        taosReleaseRef(clientReqRefPool, rid);\n      }\n      pReq = pReq->pNext;\n    }\n  }\n}", "CodeBleu_score": 38.66565620941047}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SHashObj *pReq;\n  int32_t  i;\n\n  for (i = 0; i < pRequests->numBuckets; i++) {\n    pReq = pRequests->buckets[i];\n    while (pReq != NULL) {\n      int64_t rid = (int64_t)pReq->data;\n      if (rid > 0) {\n        int32_t ret = taosReleaseRef(clientReqRefPool, rid);\n        if (ret != TAOS_OK) {\n          logError(\"stopAllRequests failed. ret=%d\", ret);\n        }\n      }\n      pReq = pReq->next;\n    }\n  }\n}", "CodeBleu_score": 41.459828732477135}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t    if (!tscIsCrashReportingEnabled()) {\n        return;\n    }\n\n    if (atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n        TSC_LOG_INFO(\"Crash report thread already stopped.\");\n        return;\n    }\n\n    while (clientStop) {\n        sleep(1);\n    }\n}", "CodeBleu_score": 60.86428760167835}, {"code": "void tscStopCrashReport(){\n\t    if (!tscIsCrashReportingEnabled()) {\n        return;\n    }\n    if (!atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n        log_info(\"Crash report thread is already stopped\");\n        return;\n    }\n    while (clientStop) {\n        usleep(1000);\n    }\n}", "CodeBleu_score": 63.35292078701977}, {"code": "void tscStopCrashReport(){\n\t    if (tscCrashReportingEnabled) {\n        if (!atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n            tscLog(TSC_LOG_INFO, \"Crash report thread is already stopped\");\n            return;\n        }\n        while (atomic_load(&clientStop)) {\n            usleep(100000);\n        }\n    }\n}", "CodeBleu_score": 56.92854145475821}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t", "CodeBleu_score": 7.827202749180444}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\n    S3UInt64 contentLength = 0;\n    S3Status status = S3StatusOK;\n\n    if (properties->response.contentLength > 0) {\n        contentLength = properties->response.contentLength;\n    }\n\n    if (callbackData) {\n        S3ResponseContentLength *responseContentLength = (S3ResponseContentLength *) callbackData;\n        responseContentLength->contentLength = contentLength;\n    }\n\n    return status;\n}", "CodeBleu_score": 48.68419479156722}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    S3ResponsePropertiesCallbackData *callbackDataPtr = (S3ResponsePropertiesCallbackData *)callbackData;\n    if (properties->contentLength > 0) {\n        callbackDataPtr->contentLength = properties->contentLength;\n    } else {\n        callbackDataPtr->contentLength = 0;\n    }\n    return status;\n}", "CodeBleu_score": 69.25904674806081}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, sizeof(confDir), \"%srsyncd.conf\", tsCheckpointBackupDir);\n\n  if (taosMkDir(tsCheckpointBackupDir, 0755) < 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(confDir) != 0) return;\n\n  char cmd[PATH_MAX * 4] = {0};\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --config=%s --port=%d\", confDir, tsCheckpointBackupPort);\n  uDebug(\"[rsync] start rsync server, cmd:%s\", cmd);\n\n  int32_t ret = system(cmd);\n  if (ret < 0) {\n    uError(\"[rsync] start rsync server error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  } else {\n    uInfo(\"[rsync] start rsync server success, port:%d\", tsCheckpointBackupPort);\n  }\n}", "CodeBleu_score": 59.89087505054213}, {"code": "void startRsync(){\n\t  if (taosMkDir(tsCheckpointBackupDir, 0755) != 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%s%s\", tsCheckpointBackupDir, \"rsyncd.conf\");\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate config file error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char command[PATH_MAX * 3] = {0};\n  snprintf(command, PATH_MAX * 3, \"rsync --daemon --port=%d --config=%s\", tsCheckpointBackupPort, confDir);\n  int32_t ret = system(command);\n  if (ret == 0) {\n    uInfo(\"[rsync] start rsync server success, port:%d\", tsCheckpointBackupPort);\n  } else {\n    uError(\"[rsync] start rsync server error, port:%d,\" ERRNO_ERR_FORMAT, tsCheckpointBackupPort, ERRNO_ERR_DATA);\n  }\n}", "CodeBleu_score": 62.06028115410912}, {"code": "void startRsync(){\n\t  if (taosMkDir(tsCheckpointBackupDir, 0755) != 0) {\n    uError(\"[rsync] mkdir %s error,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, sizeof(confDir), \"%srsyncd.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate config file error, dir:%s\", tsCheckpointBackupDir);\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, sizeof(cmd), \"rsync --daemon --config=%srsyncd.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort);\n  int32_t ret = system(cmd);\n  if (ret == 0) {\n    uInfo(\"[rsync] start rsync server success\");\n  } else {\n    uError(\"[rsync] start rsync server error, ret:%d\", ret);\n  }\n}", "CodeBleu_score": 57.64489446461475}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n    }\n}", "CodeBleu_score": 79.84386020934956}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.shutdown();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found\");\n    }\n}", "CodeBleu_score": 70.62257774143279}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n    }\n    dispatcher.getExecutor().shutdownNow();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 68.42056161574004}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        if (parent.isNil()) {\n            return;\n        }\n        TbActorId[] children = actorMap.getChildren(parent);\n        if (children == null) {\n            return;\n        }\n        for (TbActorId child : children) {\n            if (childFilter.test(child)) {\n                tell(child, msg, highPriority);\n            }\n        }\n    }", "CodeBleu_score": 53.72837027335508}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        TbActorId[] children = parent.getChildren();\n        for (TbActorId child : children) {\n            if (childFilter.test(child)) {\n                tell(child, msg, highPriority);\n            }\n        }\n    }", "CodeBleu_score": 42.0350688889087}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        // Retrieve the children of the parent actor from the map\n        Set<TbActorId> children = childrenMap.get(parent);\n        if (children == null) {\n            return;\n        }\n\n        // Filter the children based on the provided predicate\n        Set<TbActorId> filteredChildren = new HashSet<>();\n        for (TbActorId child : children) {\n            if (childFilter.test(child)) {\n                filteredChildren.add(child);\n            }\n        }\n\n        // Send the message to each filtered child actor\n        for (TbActorId child : filteredChildren) {\n            if (actorMap.containsKey(child)) {\n                tell(child, msg, highPriority);\n            } else {\n                log.warn(\"Child actor {} not found for parent actor {}\", child, parent);\n            }\n        }\n    }", "CodeBleu_score": 49.68636799776459}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (destruction.get() != IN_PROGRESS) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        } else if (highPriority && msg instanceof RuleNodeUpdatedMsg) {\n            log.trace(\"[{}] Trying to reinitialize actor due to RuleNodeUpdatedMsg\", selfId);\n            tryInit(1);\n        } else {\n            log.trace(\"[{}] Notify actor that it has stopped\", selfId);\n            msg.notifyActorStopped();\n        }\n    }", "CodeBleu_score": 52.04356305525059}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (destructionInProgress.get() == false) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        } else {\n            if (highPriority) {\n                if (msg.getType() == RULE_NODE_UPDATED_MSG) {\n                    log.debug(\"[{}] RULE_NODE_UPDATED_MSG received, actor will reinitialize\", selfId);\n                    tryInit(2);\n                } else {\n                    log.debug(\"[{}] Received a message while destruction is in progress: {}\", selfId, msg.getType());\n                }\n            } else {\n                log.debug(\"[{}] Received a message while destruction is in progress: {}\", selfId, msg.getType());\n            }\n            msg.getSender().tell(new TbActorStoppedMsg(selfId), selfActorRef);\n        }\n    }", "CodeBleu_score": 61.99879082753038}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (destruction.get() == DESTRUCTION_IN_PROGRESS) {\n            if (highPriority && msg.getType() == RULE_NODE_UPDATED_MSG) {\n                log.info(\"[{}] Rule node updated msg received during destruction, reinitializing actor\", selfId);\n                tryInit(1);\n            } else {\n                log.info(\"[{}] Actor is being destroyed, not sending msg\", selfId);\n                msg.notifyStopped();\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 59.138278673696156}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    try {\n        if (actor.init()) {\n            ready.set(READY);\n            while (true) {\n                TbActorMessage msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    msg = normalPriorityMsgs.poll();\n                    if (msg == null) {\n                        break;\n                    }\n                }\n                try {\n                    actor.process(msg);\n                } catch (InitFailureException e) {\n                    stopReason = TbActorStopReason.INIT_FAILED;\n                    destroy(e);\n                    return;\n                } catch (Throwable t) {\n                    log.warn(\"[{}] Failed to process message: {}\", selfId, t);\n                    actor.processFailureStrategy().apply(t);\n                }\n            }\n            ready.set(FREE);\n            scheduleQueueProcessing();\n        } else {\n            stopReason = TbActorStopReason.INIT_FAILED;\n            destroy(null);\n        }\n    } finally {\n        busy.set(FREE);\n    }\n}", "CodeBleu_score": 44.06237562778039}, {"code": "private void processMailbox(){\n\t        long startTime = System.currentTimeMillis();\n        log.trace(\"[{}] Processing mailbox\", selfId);\n        try {\n            while (!highPriorityMsgs.isEmpty() || !normalPriorityMsgs.isEmpty()) {\n                TbActorMessage msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    msg = normalPriorityMsgs.poll();\n                }\n                if (msg != null) {\n                    try {\n                        actor.process(msg);\n                    } catch (TbActorInitializationException e) {\n                        stopReason = TbActorStopReason.INITIALIZATION_FAILED;\n                        destroy(e);\n                        break;\n                    } catch (Exception e) {\n                        log.warn(\"[{}] Failed to process message: {}\", selfId, e);\n                        processFailureStrategy.apply(actor, msg, e);\n                        if (processFailureStrategy.stopActorOnFailure()) {\n                            stopReason = TbActorStopReason.PROCESS_FAILED;\n                            destroy(e);\n                            break;\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                log.trace(\"[{}] Mailbox processing complete\", selfId);\n                ready.set(FREE);\n                tryProcessQueue(false);\n            } else {\n                log.trace(\"[{}] Mailbox processing incomplete\", selfId);\n                tryProcessQueue(false);\n            }\n        } finally {\n            long endTime = System.currentTimeMillis();\n            long duration = endTime - startTime;\n            log.trace(\"[{}] Mailbox processing took {} ms\", selfId, duration);\n        }\n    }", "CodeBleu_score": 45.725003461581295}, {"code": "private void processMailbox(){\n\t    // Process high priority messages\n    while (!highPriorityMsgs.isEmpty()) {\n        TbActorMessage<?> msg = highPriorityMsgs.poll();\n        if (msg == null) {\n            break;\n        }\n        try {\n            actor.process(msg);\n        } catch (TbActorInitializationException e) {\n            stopReason = TbActorStopReason.INITIALIZATION_FAILED;\n            destroy(e);\n            break;\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to process message: {}\", selfId, t);\n            if (actor.getProcessFailureStrategy().isStopOnFailure()) {\n                stopReason = TbActorStopReason.PROCESS_FAILURE;\n                destroy(t);\n                break;\n            }\n        }\n    }\n\n    // Process normal priority messages\n    while (!normalPriorityMsgs.isEmpty()) {\n        TbActorMessage<?> msg = normalPriorityMsgs.poll();\n        if (msg == null) {\n            break;\n        }\n        try {\n            actor.process(msg);\n        } catch (TbActorInitializationException e) {\n            stopReason = TbActorStopReason.INITIALIZATION_FAILED;\n            destroy(e);\n            break;\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to process message: {}\", selfId, t);\n            if (actor.getProcessFailureStrategy().isStopOnFailure()) {\n                stopReason = TbActorStopReason.PROCESS_FAILURE;\n                destroy(t);\n                break;\n            }\n        }\n    }\n\n    // If there are no more messages, set the actor to free and schedule a queue processing attempt\n    if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n        ready.set(FREE);\n        if (busy.compareAndSet(BUSY, FREE)) {\n            tryProcessQueue(false);\n        }\n    }\n}", "CodeBleu_score": 43.055323485778416}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t        if (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.36402548545796}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n      stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n      try {\n        ready.set(NOT_READY);\n        actor.destroy(stopReason, cause);\n        highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n      } catch (Throwable t) {\n        log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n      }\n    });\n  }", "CodeBleu_score": 97.54825946004692}, {"code": "public void destroy(Throwable cause){\n\t        if (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.36402548545796}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    TenantProfile tenantProfile = tenantProfileService.getTenantProfile(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        }\n        throw new TenantProfileNotFoundException(tenantId);\n    }\n    RateLimitConfig rateLimitConfig = tenantProfile.getRateLimitConfig();\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    RateLimit rateLimit = rateLimitConfig.getRateLimit(api, level);\n    if (rateLimit == null) {\n        return true;\n    }\n    if (rateLimit.isExceeded()) {\n        processRateLimitNotification(api, tenantId, rateLimitConfig);\n        return false;\n    }\n    rateLimit.increment();\n    return true;\n}", "CodeBleu_score": 47.85382441246725}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    // TODO: check rate limit\n    return true;\n}", "CodeBleu_score": 7.702648372057689}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.equals(TenantId.SYSTEM)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileRepository.findById(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        }\n        throw new TenantProfileNotFoundException(tenantId);\n    }\n    RateLimit rateLimit = tenantProfile.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitCheckResult result = rateLimit.check(level);\n    if (result.isExceeded()) {\n        rateLimitNotificationService.process(tenantId, api, result);\n    }\n    return result.isAllowed();\n}", "CodeBleu_score": 47.57651661593323}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expiration = System.currentTimeMillis() - this.inactivityTimeout;\n    for (Map.Entry<DTLSClientSession, Long> entry : this.sessions.entrySet()) {\n        if (entry.getValue() < expiration) {\n            this.sessions.remove(entry.getKey());\n            this.logger.log(Level.FINEST, \"Removing session \" + entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 40.75189573428924}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - (inactivityTimeout * 1000);\n    for (Map.Entry<Integer, DtlsSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivity() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.info(\"DTLS session {} evicted due to inactivity\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 46.696650298771324}, {"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSClientSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            log.info(\"Removing DTLS session with id {}\", entry.getKey());\n            dtlsSessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 57.452245243562814}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> tsKvEntries = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        List<KvEntry> kvEntries = new ArrayList<>();\n        for (JsonNode value : values) {\n            kvEntries.add(parseValue(key, value));\n        }\n        tsKvEntries.add(new TsKvEntry(kvEntries));\n    }\n    return tsKvEntries;\n}", "CodeBleu_score": 40.79654430468659}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n\n    List<TsKvEntry> entries = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        List<KvEntry> kvEntries = entry.getValue().stream()\n                .map(value -> parseValue(entry.getKey(), value))\n                .collect(Collectors.toList());\n        entries.add(new TsKvEntry(entry.getKey(), kvEntries));\n    }\n    return entries;\n}", "CodeBleu_score": 42.54897381368954}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    return timeseries.entrySet().stream()\n            .flatMap(entry -> entry.getValue().stream()\n                    .map(value -> parseValue(entry.getKey(), value)))\n            .map(TsKvEntry::new)\n            .collect(Collectors.toList());\n}", "CodeBleu_score": 24.301677011325378}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t        Map<String, String> request = new HashMap<>();\n        request.put(\"refreshToken\", refreshToken);\n        HttpResponse<JsonNode> response = Unirest.post(authEndpoint + \"/refreshToken\").body(request).asJson();\n        if (response.getStatus() != 200) {\n            throw new RuntimeException(\"Could not refresh token\");\n        }\n        setTokenInfo(System.currentTimeMillis(), response.getBody());\n    }", "CodeBleu_score": 50.94492347758578}, {"code": "public void refreshToken(){\n\t        Map<String, Object> request = new HashMap<>();\n        request.put(\"refreshToken\", refreshToken);\n        JsonNode tokenInfo = sendRequest(Request.Post(authUrl).bodyForm(request, Form.form())).asJson();\n        setTokenInfo(System.currentTimeMillis(), tokenInfo);\n    }", "CodeBleu_score": 51.371834091747125}, {"code": "public void refreshToken(){\n\t        Map<String, String> request = new HashMap<>();\n        request.put(\"refreshToken\", this.refreshToken);\n        JsonNode tokenInfo = this.sendRequest(request, \"auth\");\n        setTokenInfo(System.currentTimeMillis(), tokenInfo);\n    }", "CodeBleu_score": 38.41107519330313}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        JsonNode tokenInfo = restTemplate.postForObject(authUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, tokenInfo);\n    }", "CodeBleu_score": 83.10709105640106}, {"code": " private void doLogin(){\n\t        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        try {\n            JsonNode tokenInfo = restTemplate.postForObject(authUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n            setTokenInfo(ts, tokenInfo);\n        } catch (HttpClientErrorException.Unauthorized e) {\n            throw new InvalidCredentialsException(e);\n        }\n    }", "CodeBleu_score": 77.45630587965205}, {"code": " private void doLogin(){\n\t        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        try {\n            JsonNode tokenInfo = restTemplate.postForObject(authUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n            setTokenInfo(ts, tokenInfo);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to login\", e);\n        }\n    }", "CodeBleu_score": 78.2455405162846}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(baseUrl + \"/api/device/{deviceId}\", Device.class, deviceId);\n        if (response.getStatusCode() == HttpStatus.OK) {\n            return Optional.of(response.getBody());\n        } else if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw new RestClientException(\"Unexpected HTTP status code: \" + response.getStatusCode());\n        }\n    } catch (RestClientException e) {\n        throw e;\n    }\n}", "CodeBleu_score": 60.41098444105022}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.exchange(\"/api/device/{deviceId}\", HttpMethod.GET, null, Device.class, deviceId.getValue());\n        if (response.getStatusCode() == HttpStatus.OK) {\n            return Optional.of(response.getBody());\n        } else {\n            return Optional.empty();\n        }\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 67.06259841106947}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId.getValue());\n        if (response.getStatusCode() == HttpStatus.OK) {\n            return Optional.of(response.getBody());\n        } else if (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw new RuntimeException(\"Unexpected HTTP status: \" + response.getStatusCode());\n        }\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 65.85209275503529}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(baseUrl + \"/api/device-with-credentials\"))\n                .POST(HttpRequest.BodyPublishers.ofString(objectMapper.writeValueAsString(new DeviceWithCredentials(device, credentials))))\n                .header(\"Content-Type\", \"application/json\")\n                .build();\n\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        if (response.statusCode() == 200) {\n            return Optional.of(objectMapper.readValue(response.body(), Device.class));\n        } else if (response.statusCode() == 404) {\n            return Optional.empty();\n        } else {\n            throw new RuntimeException(\"Unexpected status code: \" + response.statusCode());\n        }\n    } catch (IOException | InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 49.22811938002463}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpEntity<DeviceWithCredentials> requestEntity = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n        ResponseEntity<Device> response = restTemplate.exchange(deviceWithCredentialsUrl, HttpMethod.POST, requestEntity, Device.class);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpStatusCodeException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 57.49097147511743}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpRequest request = HttpRequest.POST(\"/api/device-with-credentials\", device).header(\"Content-Type\", \"application/json\");\n        HttpResponse<Device> response = httpClient.send(request, Device.class);\n        if (response.statusCode() == 201) {\n            return Optional.of(response.body());\n        } else if (response.statusCode() == 404) {\n            return Optional.empty();\n        } else {\n            throw new RuntimeException(\"Unexpected status code: \" + response.statusCode());\n        }\n    } catch (IOException | InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 51.01977184341231}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 97.94874339045735}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 97.94874339045735}, {"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 97.94874339045735}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    const bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.09390594052935}, {"code": "device(addr){\n\t    const bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.09390594052935}, {"code": "device(addr){\n\t    const bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.09390594052935}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  for (const method of methods) {\n    const methodName = method.name;\n    const methodDuration = method.duration ?? 1000;\n    const methodCallback = method.callback ?? (() => {});\n\n    target[methodName] = (...args) => {\n      const promises = this.map(item => new Promise(resolve => {\n        setTimeout(() => {\n          item[methodName](...args);\n          resolve();\n        }, methodDuration);\n      }));\n\n      Promise.all(promises).then(methodCallback);\n    };\n  }\n}", "CodeBleu_score": 30.625109278725603}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    for (const method of methods) {\n        target[method] = (duration = 1000, callback = () => {}) => {\n            const promises = [];\n            for (const element of this) {\n                const promise = new Promise((resolve) => {\n                    setTimeout(() => {\n                        element[method]();\n                        resolve();\n                    }, duration);\n                });\n                promises.push(promise);\n            }\n            Promise.all(promises).then(callback);\n        };\n    }\n}", "CodeBleu_score": 31.072409535556222}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach((method) => {\n        target[method] = (duration, callback) => {\n            const promises = this.map((item) => {\n                return new Promise((resolve) => {\n                    setTimeout(() => {\n                        resolve(item[method]());\n                    }, duration || 1000);\n                });\n            });\n            Promise.all(promises).then(callback);\n        };\n    });\n}", "CodeBleu_score": 31.456288436126172}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\n    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.00812640651824}, {"code": "listen(){\n\t\n    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.00812640651824}, {"code": "listen(){\n\t    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 90.92172031088639}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t num_active_channels;\n\tuint32_t buffer_size;\n\n\tnum_active_channels = adc_ad559x_get_num_active_channels(dev, sequence);\n\n\tbuffer_size = num_active_channels * sequence->resolution * sequence->length;\n\n\tif (buffer_size > data->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.02048050004538}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tuint8_t num_active_channels;\n\tuint32_t buffer_size;\n\n\t/* Calculate the number of active channels */\n\tnum_active_channels = adc_ad559x_get_num_active_channels(dev,\n\t\t\t\t\t\t\t\tsequence);\n\n\t/* Calculate the buffer size */\n\tbuffer_size = num_active_channels * sequence->resolution;\n\n\t/* Check if the buffer size is sufficient */\n\tif (buffer_size > sequence->buffer_length) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 49.11438728209694}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t buffer_size;\n\n\tbuffer_size = adc_ad559x_get_buffer_size(dev, sequence);\n\n\tif (buffer_size > data->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 30.03546968075464}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint ret;\n\n\tchannels = POPCOUNT(sequence->channels);\n\n\tif (channels > AD559X_MAX_CHANNELS) {\n\t\tLOG_ERR(\"Invalid channel count %d\", channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution != ADC_RES_12_BIT) {\n\t\tLOG_ERR(\"Invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\tLOG_ERR(\"Invalid buffer size %d\", sequence->buffer_size);\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = ad559x_start_read(dev, channels);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tret = ad559x_wait_for_read(dev);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 67.10070040024974}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tstruct ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tsize_t needed;\n\tint ret;\n\n\tif (sequence->resolution != ADC_RES_12_BIT) {\n\t\tLOG_ERR(\"Unsupported resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > AD559X_CHANNELS) {\n\t\tLOG_ERR(\"Too many channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = *sequence;\n\n\tneeded = channels * sizeof(uint16_t);\n\tdata->buffer = (uint16_t *)sequence->buffer;\n\n\tret = ad559x_start_read(data, channels);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tret = ad559x_wait_for_read(data, needed);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 63.8845558118177}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\n\tuint8_t channels;\n\tuint16_t *buffer;\n\tstruct ad559x_config *config = dev->config;\n\tstruct ad559x_data *data = dev->data;\n\tstruct ad559x_context *ctx = &data->ctx;\n\n\t/* Check if the resolution of the ADC sequence matches the expected resolution */\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the specified channels are valid */\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > AD559X_NUM_CHANNELS) {\n\t\tLOG_ERR(\"Invalid channels 0x%x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate the buffer size for the ADC read */\n\tif (adc_ad559x_validate_buffer_size(dev, sequence) < 0) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Set the buffer */\n\tbuffer = sequence->buffer;\n\n\t/* Start the ADC read context */\n\tctx->buffer = buffer;\n\tctx->channels = sequence->channels;\n\tctx->size = channels;\n\tctx->index = 0;\n\tctx->done = false;\n\n\tad559x_read_start(dev, ctx);\n\n\t/* Wait for the read operation to complete */\n\twhile (!ctx->done) {\n\t\tk_sleep(K_MSEC(1));\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 60.97027956377845}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = ctx->data;\n    struct adc_channel_config *channels = data->channels;\n    struct adc_repeat_buffer *repeat_buffer = &data->repeat_buffer;\n    uint8_t channel_count = data->channel_count;\n    uint8_t repeat_buffer_size = data->repeat_buffer_size;\n    uint8_t repeat_buffer_index = 0;\n    uint8_t i;\n\n    // Set the channels to be sampled\n    for (i = 0; i < channel_count; i++) {\n        channels[i].adc_channel = i;\n        channels[i].adc_repeat_buffer_index = repeat_buffer_index++;\n        channels[i].adc_repeat_buffer_index %= repeat_buffer_size;\n    }\n\n    // Initialize the repeat buffer with the data buffer\n    for (i = 0; i < repeat_buffer_size; i++) {\n        repeat_buffer->buffer[i] = data->buffer;\n    }\n\n    // Release a semaphore to signal the start of sampling\n    xSemaphoreGive(data->semaphore);\n}", "CodeBleu_score": 34.24938253551033}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t", "CodeBleu_score": 6.762733993289692}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t", "CodeBleu_score": 6.762733993289692}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    if (repeat_sampling) {\n        ctx->data_container->buffer_ptr = ctx->data_container->repeat_buffer;\n    } else {\n        ctx->data_container->buffer_ptr = ctx->data_container->buffer;\n    }\n}", "CodeBleu_score": 44.1571332918712}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\n    if (repeat_sampling) {\n        ctx->adc_data->buffer_pointer = ctx->adc_data->repeat_buffer;\n    }\n}", "CodeBleu_score": 46.30342702654639}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    if (repeat_sampling) {\n        ctx->adc_data_container.buffer_pointer = ctx->adc_data_container.repeat_buffer;\n    }\n}", "CodeBleu_score": 46.097701848061746}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Read ADC channels */\n\t\tfor (uint8_t i = 0; i < data->channels_count; i++) {\n\t\t\tuint16_t val;\n\t\t\tint ret = adc_ad559x_read_channel(data->dev, data->channels[i], &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read ADC channel %d: %d\", data->channels[i], ret);\n\t\t\t\tdata->done = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->buffer[i] = val;\n\t\t}\n\n\t\tk_sem_give(&data->sem);\n\n\t\tif (data->done) {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.17542365361423}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (int i = 0; i < data->ctx.channels_count; i++) {\n\t\t\tuint16_t val;\n\t\t\tint ret;\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, data->ctx.channels[i], &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", data->ctx.channels[i], ret);\n\t\t\t\tdata->ctx.complete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->ctx.values[i] = val;\n\t\t}\n\n\t\tk_sem_give(&data->sem);\n\n\t\tif (data->ctx.complete) {\n\t\t\tk_sem_give(&data->sem);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.58764300981867}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tuint16_t val;\n\tint ret;\n\tuint8_t channel;\n\n\twhile (1) {\n\t\t/* Wait for semaphore to be released */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Iterate through active channels */\n\t\tfor (channel = 0; channel < data->config->num_channels; channel++) {\n\t\t\tif (!data->active_channels[channel]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Read ADC value */\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %u: %d\", channel, ret);\n\t\t\t\tdata->complete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Store result in buffer */\n\t\t\tdata->buffer[channel] = val;\n\t\t}\n\n\t\t/* Signal that sampling is done */\n\t\tk_sem_give(&data->sem);\n\t}\n}", "CodeBleu_score": 50.9146920730053}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tint rc = 0;\n\n\tk_sleep(K_MSEC(config->ready_time));\n\n\tuint8_t reg_val;\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (rc < 0) {\n\t\treturn rc;\n\t}\n\n\twhile (!(reg_val & ADS1112_REG_CONFIG_OS)) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc < 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 72.49625151481766}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tk_sleep(K_MSEC(config->ready_time));\n\tint rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\twhile (!(reg_val & ADS1112_REG_CONFIG_OS)) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 66.21558982751355}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val;\n\tint rc;\n\n\tk_sleep(K_MSEC(config->ready_time));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\twhile ((reg_val & ADS1112_REG_CONFIG_OS_MASK) != ADS1112_REG_CONFIG_OS_DONE) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 74.50401181328272}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t  int buffer_size = 0;\n  int required_buffer_size = 0;\n  int extra_samplings = 0;\n\n  if (sequence->options & ADC_SEQ_OPT_DIFFERENTIAL) {\n    extra_samplings = 2;\n  }\n\n  if (sequence->options & ADC_SEQ_OPT_CONTINUOUS) {\n    extra_samplings += 2;\n  }\n\n  required_buffer_size = sequence->length * (extra_samplings + 1);\n\n  buffer_size = sequence->buffer_length;\n\n  if (buffer_size < required_buffer_size) {\n    LOG_ERR(\"Buffer size (%d) is not sufficient for %d samplings\", buffer_size, sequence->length);\n    return -EINVAL;\n  }\n\n  return 0;\n}", "CodeBleu_score": 45.02921784130899}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t  struct adc_sequence_options *options = &sequence->options;\n  uint32_t buffer_size;\n  uint32_t required_buffer_size;\n  uint32_t extra_samplings;\n\n  buffer_size = options->buffer_size;\n  extra_samplings = options->extra_samplings;\n\n  required_buffer_size = sequence->length * sizeof(struct ads1112_sample);\n  required_buffer_size += extra_samplings * sizeof(struct ads1112_sample);\n\n  if (buffer_size < required_buffer_size) {\n    LOG_ERR(\"Buffer size (%u) is too small for %u samplings (%u bytes)\",\n            buffer_size, sequence->length, required_buffer_size);\n    return -EINVAL;\n  }\n\n  return 0;\n}", "CodeBleu_score": 41.736639345657586}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t  int buffer_size = sequence->length;\n  int extra_samplings = 0;\n\n  if (sequence->options & ADC_OPTION_CONTINUOUS) {\n    extra_samplings = sequence->options & ADC_OPTION_CONTINUOUS_SAMPLINGS_MASK;\n  }\n\n  buffer_size += extra_samplings;\n\n  if (buffer_size > sequence->buffer_size) {\n    LOG_ERR(\"ADC buffer size too small (%d < %d)\", sequence->buffer_size, buffer_size);\n    return -ENOMEM;\n  }\n\n  return 0;\n}", "CodeBleu_score": 52.39558738676361}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\treturn ads1112_start_read(dev, wait);\n}", "CodeBleu_score": 46.09192045129278}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = ads1112_start_read(dev);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\treturn ads1112_wait_for_read(dev);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 57.91543468880438}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence = sequence;\n\n\tret = ads1112_start_read(dev);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = ads1112_wait_for_completion(dev);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 57.69688856106121}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret;\n\tstruct device *dev;\n\tuint32_t prop_id;\n\n\tif (argc < 3) {\n\t\tshell_print(sh, \"Usage: %s <dev_name> <prop_id> [<prop_val>]\n\",\n\t\t\t    argv[0]);\n\t\treturn -ENOENT;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_print(sh, \"Device %s not found!\n\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = k_strtoul(argv[2], 10, &prop_id);\n\tif (ret) {\n\t\tshell_print(sh, \"Invalid property id!\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (argc == 4) {\n\t\tret = k_strtoul(argv[3], 10, &prop_val);\n\t\tif (ret) {\n\t\t\tshell_print(sh, \"Invalid property value!\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = audio_codec_apply_property(dev, prop_id, prop_val);\n\tif (ret) {\n\t\tshell_print(sh, \"Failed to apply property %d to %s!\n\",\n\t\t\t    prop_id, argv[1]);\n\t\treturn -EINVAL;\n\t}\n\n\tshell_print(sh, \"Property %d applied to %s!\n\", prop_id, argv[1]);\n\treturn 0;\n}", "CodeBleu_score": 46.592969948684}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    struct device *dev;\n    int ret;\n\n    if (argc != 2) {\n        shell_print(sh, \"Usage: apply_prop <device>\");\n        return -ENOEXEC;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Device %s not found\", argv[1]);\n        return -ENOEXEC;\n    }\n\n    ret = apply_prop(dev);\n    if (ret) {\n        shell_error(sh, \"Failed to apply properties to device %s\", argv[1]);\n        return ret;\n    }\n\n    shell_print(sh, \"Properties applied successfully to device %s\", argv[1]);\n    return 0;\n}", "CodeBleu_score": 54.50276009809313}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t  int ret;\n  struct device *dev;\n  struct audio_codec_api *api;\n\n  if (argc < 2) {\n    shell_error(sh, \"Missing argument\");\n    return -ENOENT;\n  }\n\n  dev = device_get_binding(argv[1]);\n  if (dev == NULL) {\n    shell_error(sh, \"Device not found: %s\", argv[1]);\n    return -ENODEV;\n  }\n\n  api = (struct audio_codec_api *)dev->api;\n  if (api == NULL) {\n    shell_error(sh, \"Device has no API: %s\", argv[1]);\n    return -ENODEV;\n  }\n\n  ret = api->apply_prop(dev);\n  if (ret != 0) {\n    shell_error(sh, \"Failed to apply properties: %s\", argv[1]);\n    return -EIO;\n  }\n\n  shell_print(sh, \"Successfully applied properties to %s\", argv[1]);\n  return 0;\n}", "CodeBleu_score": 50.51422375072907}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    struct mpxxdtyy_dev_data *dev_data = dev->data;\n    int ret;\n    uint8_t i2s_cmd;\n    uint8_t state_transition;\n\n    /* Check if the device is in the correct state for the trigger command. */\n    if (cmd == DMIC_TRIGGER_START) {\n        if (dev_data->state != MPXXDTYY_STATE_CONFIGURED) {\n            LOG_ERR(\"Device not in configured state for start command\");\n            return -EINVAL;\n        }\n        i2s_cmd = MPXXDTYY_I2S_START;\n        state_transition = MPXXDTYY_STATE_ACTIVE;\n    } else if (cmd == DMIC_TRIGGER_STOP) {\n        if (dev_data->state != MPXXDTYY_STATE_ACTIVE) {\n            LOG_ERR(\"Device not in active state for stop command\");\n            return -EINVAL;\n        }\n        i2s_cmd = MPXXDTYY_I2S_STOP;\n        state_transition = MPXXDTYY_STATE_CONFIGURED;\n    } else {\n        LOG_ERR(\"Invalid trigger command\");\n        return -EINVAL;\n    }\n\n    /* Send the I2S command to the device. */\n    ret = mpxxdtyy_i2s_write(dev, i2s_cmd);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to send I2S command\");\n        return ret;\n    }\n\n    /* Update the device state. */\n    dev_data->state = state_transition;\n\n    return 0;\n}", "CodeBleu_score": 48.14017623841225}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    struct mpxxdtyy_data *data = dev->data;\n    int err;\n\n    if (cmd == DMIC_START) {\n        if (data->state == MPXXDTYY_STATE_CONFIGURED) {\n            err = mpxxdtyy_i2s_send_cmd(dev, MPXXDTYY_I2S_CMD_START);\n            if (err) {\n                LOG_ERR(\"Failed to send start command (err %d)\", err);\n                return err;\n            }\n            data->state = MPXXDTYY_STATE_ACTIVE;\n        } else {\n            LOG_ERR(\"Invalid state transition (%d -> %d)\", data->state, MPXXDTYY_STATE_ACTIVE);\n            return -EINVAL;\n        }\n    } else if (cmd == DMIC_STOP) {\n        if (data->state == MPXXDTYY_STATE_ACTIVE) {\n            err = mpxxdtyy_i2s_send_cmd(dev, MPXXDTYY_I2S_CMD_STOP);\n            if (err) {\n                LOG_ERR(\"Failed to send stop command (err %d)\", err);\n                return err;\n            }\n            data->state = MPXXDTYY_STATE_CONFIGURED;\n        } else {\n            LOG_ERR(\"Invalid state transition (%d -> %d)\", data->state, MPXXDTYY_STATE_CONFIGURED);\n            return -EINVAL;\n        }\n    } else {\n        LOG_ERR(\"Invalid command (%d)\", cmd);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 37.04246959597558}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t  struct mpxxdtyy_dmic_dev_data *dev_data = dev->data;\n  int ret;\n  uint8_t i2s_cmd;\n\n  if (cmd == DMIC_TRIGGER_START) {\n    i2s_cmd = MPXXDTYY_I2S_CMD_START;\n  } else if (cmd == DMIC_TRIGGER_STOP) {\n    i2s_cmd = MPXXDTYY_I2S_CMD_STOP;\n  } else {\n    LOG_ERR(\"Invalid DMIC trigger command\");\n    return -EINVAL;\n  }\n\n  if (dev_data->state == MPXXDTYY_DMIC_STATE_CONFIGURED) {\n    ret = mpxxdtyy_i2s_send_cmd(dev, i2s_cmd);\n    if (ret < 0) {\n      LOG_ERR(\"Failed to send I2S command (%d)\", ret);\n      return ret;\n    }\n\n    dev_data->state = MPXXDTYY_DMIC_STATE_ACTIVE;\n  } else if (dev_data->state == MPXXDTYY_DMIC_STATE_ACTIVE) {\n    LOG_ERR(\"Device is already active\");\n    return -EBUSY;\n  } else {\n    LOG_ERR(\"Invalid device state\");\n    return -EINVAL;\n  }\n\n  return 0;\n}", "CodeBleu_score": 50.45071302382239}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_CURSOR_ON;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_CURSOR_BLINK_ON;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 71.01406266278649}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_CURSOR_ON;\n\t}\n\n\tif (config->blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 68.76970243946066}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd |= BIT(7);\n\t}\n\n\tif (config->cursor_blink) {\n\t\tcmd |= BIT(5);\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= BIT(4);\n\t}\n\n\tif (config->display_shift) {\n\t\tcmd |= BIT(3);\n\t}\n\n\tif (config->display_lines == 2) {\n\t\tcmd |= BIT(2);\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 51.99718952344776}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n    if (config->busy_gpio_port == NULL) {\n        return -ENOTSUP;\n    }\n    return gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n}", "CodeBleu_score": 70.57781098653221}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n\n    if (!config->busy_gpio) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get_raw(config->busy_gpio, config->busy_gpio_pin);\n}", "CodeBleu_score": 42.35932700981348}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n    int ret;\n\n    if (!config->busy_gpio_port) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to get busy GPIO pin status (%d)\", ret);\n        return ret;\n    }\n\n    return ret;\n}", "CodeBleu_score": 63.377476482784445}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n    const struct auxdisplay_serlcd_config *cfg = dev->config;\n    uint8_t buffer[2];\n\n    buffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n    buffer[1] = command;\n\n    if (i2c_write(dev, buffer, sizeof(buffer), cfg->i2c_address) != 0) {\n\treturn -EIO;\n    }\n\n    k_sleep(K_MSEC(cfg->delay_after_command_ms));\n\n    return 0;\n}", "CodeBleu_score": 60.57707328148649}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tret = i2c_write(config->i2c, buffer, sizeof(buffer), config->i2c_address);\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->delay_after_special_command));\n\n\treturn 0;\n}", "CodeBleu_score": 64.94745577452036}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\n\tuint8_t buffer[2];\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tint ret = i2c_write(data->i2c, buffer, sizeof(buffer), data->i2c_address);\n\n\tk_sleep(K_MSEC(data->config->delay_after_special_command_ms));\n\n\treturn ret;\n}", "CodeBleu_score": 53.96567146266933}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\n\tif (bbram_data->status.is_invalid) {\n\t\treturn -EFAULT;\n\t}\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > bbram_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, bbram_data->data + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 66.54844375366717}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(data, data_ptr->mem + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 68.25498283849083}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\treturn -ENOMEM;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, &data_ptr->memory[offset], size);\n\n\treturn 0;\n}", "CodeBleu_score": 54.06549625816207}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_p = dev->data;\n\n\tif (size > BBRAM_EMUL_MAX_WRITE_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_p->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_p->data + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 66.85267129324653}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\n\tif (size > BBRAM_EMUL_MAX_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_MAX_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_ptr->memory + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 65.1526422594523}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_p = dev->data;\n\n\tif (size > BBRAM_EMUL_SIZE) {\n\t\tLOG_ERR(\"Write size (%zu) exceeds BBRAM size (%zu)\", size,\n\t\t\tBBRAM_EMUL_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\tLOG_ERR(\"Write operation goes beyond BBRAM bounds (offset=%zu, size=%zu)\",\n\t\t\toffset, size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_p->mem + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 59.59431720655023}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\terr = bbram_init(*bbram_dev);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to initialize device %s (%d)\", argv[1], err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 71.56679852397696}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device path\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 81.09832999908059}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing BBRAM device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Invalid BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 82.08989496356432}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t  uint8_t *p = h4_hdr_buf;\n  uint16_t n = H4_HDR_SIZE;\n  uint16_t nr;\n  uint8_t *buf = h4_hdr_buf;\n  int err;\n\n  nr = h4_hdr_size - h4_hdr_nr;\n  if (nr == 0)\n    return;\n\n  if (nr > n)\n    n = nr;\n\n  err = uart_fifo_read(dev, buf, n);\n  if (err < 0) {\n    LOG_ERR(\"h4_read_hdr: uart_fifo_read failed\");\n    return;\n  }\n\n  h4_hdr_nr += err;\n}", "CodeBleu_score": 36.65251498830441}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t  int bytes_read;\n  int bytes_remaining = H4_HDR_SIZE - h4_hdr_bytes_read;\n\n  if (bytes_remaining <= 0) {\n    return;\n  }\n\n  bytes_read = uart_fifo_read(dev, h4_hdr_buf + h4_hdr_bytes_read, bytes_remaining);\n\n  if (bytes_read < 0) {\n    LOG_ERR(\"Error reading header data: %d\", bytes_read);\n    return;\n  }\n\n  h4_hdr_bytes_read += bytes_read;\n}", "CodeBleu_score": 34.42015647794025}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t", "CodeBleu_score": 5.485908994710939}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t  uint8_t buf[33];\n  size_t read = 0;\n  size_t ret;\n\n  while (read < len) {\n    ret = uart_fifo_read(uart, buf, sizeof(buf));\n    if (ret <= 0) {\n      LOG_ERR(\"Failed to read from FIFO: %d\", ret);\n      return 0;\n    }\n    read += ret;\n  }\n\n  return read;\n}", "CodeBleu_score": 47.377988409494506}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t  uint8_t tmp[33];\n  size_t i;\n  for (i = 0; i < len; i += 33) {\n    if (uart_fifo_read(uart, tmp, MIN(33, len - i)) == 0) {\n      LOG_ERR(\"uart_fifo_read failed\");\n      return 0;\n    }\n  }\n  return i;\n}", "CodeBleu_score": 36.924873417367124}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t  uint8_t buf[33];\n  int rc;\n  size_t n = 0;\n\n  while (n < len) {\n    rc = uart_fifo_read(uart, buf, sizeof(buf));\n    if (rc < 0) {\n      LOG_ERR(\"Failed to read from UART: %d\", rc);\n      break;\n    }\n    n += rc;\n  }\n\n  return n;\n}", "CodeBleu_score": 49.09350851036475}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    struct zbus_channel_data *data = chan->data;\n    uint8_t hop = UINT8_MAX;\n    struct zbus_channel_observer *obs = NULL;\n    zbus_lock_channel(chan);\n    zlist_foreach(data->observers, obs) {\n        if (obs->enabled && obs->priority < hop) {\n            hop = obs->priority;\n        }\n    }\n    data->hop = hop;\n    zbus_unlock_channel(chan);\n}", "CodeBleu_score": 17.118899131155665}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    uint8_t highest_priority;\n    struct zbus_observer *obs;\n    uint8_t priority;\n\n    zbus_channel_lock(chan);\n    highest_priority = chan->highest_priority;\n    for (obs = chan->observers; obs; obs = obs->next) {\n        if (obs->enabled) {\n            priority = obs->priority;\n            if (priority < highest_priority) {\n                highest_priority = priority;\n            }\n        }\n    }\n    chan->highest_priority = highest_priority;\n    zbus_channel_unlock(chan);\n}", "CodeBleu_score": 30.77898015773357}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    struct zbus_observer *observer;\n    uint8_t highest_priority;\n\n    chan_lock(chan);\n\n    highest_priority = chan->highest_observer_priority;\n    for (observer = chan->observers; observer; observer = observer->next) {\n        if (observer->enabled && observer->priority < highest_priority) {\n            highest_priority = observer->priority;\n        }\n    }\n    chan->highest_observer_priority = highest_priority;\n\n    chan_unlock(chan);\n}", "CodeBleu_score": 26.97347396293011}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\t__ASSERT(obs != NULL, \"observer must be not NULL\");\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_channels_end_idx;\n\n\t\tfor (int16_t i = _zbus_channels_start_idx; i < limit; ++i) {\n\t\t\tstruct zbus_channel *chan;\n\t\t\tSTRUCT_SECTION_GET(zbus_channel, i, &chan);\n\n\t\t\t__ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\t\t\tif (chan->data->highest_observer_priority > obs->data->priority) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.846413992279725}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tconst struct zbus_channel_observation_mask *obs_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_channel_observation_mask_end_idx;\n\n\t\tfor (int16_t i = _zbus_channel_observation_mask_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &obs_mask);\n\n\t\t\tif (obs_mask->enabled && obs_mask->obs == obs) {\n\t\t\t\tchan_update_hop(obs_mask->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.497548058069768}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel *chan;\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tfor (int16_t i = _zbus_channel_observations_start_idx; i < _zbus_channel_observations_end_idx; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tchan = observation->chan;\n\n\t\t\tif (!chan->data->enabled || !observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (observation->obs != obs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.50233428648886}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tASSERT_NOT_IN_ISR();\n\tASSERT(obs);\n\n\tspinlock_lock(&zbus_observer_lock);\n\tobs->priority = THREAD_PRIORITY_MIN;\n\tupdate_all_channels_hop(obs);\n\tspinlock_unlock(&zbus_observer_lock);\n\n\treturn 0;\n}", "CodeBleu_score": 48.298702619308}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\n\tzbus_obs_lock(obs);\n\n\tobs->priority = zbus_thread_min_priority;\n\n\tupdate_all_channels_hop(obs);\n\n\treturn 0;\n}", "CodeBleu_score": 42.98422978967423}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tassert(obs != NULL);\n\tassert(zbus_is_in_isr() == 0);\n\n\tspin_lock(&obs->lock);\n\tobs->priority = zbus_get_min_thread_priority();\n\tupdate_all_channels_hop(obs);\n\treturn 0;\n}", "CodeBleu_score": 33.78907914152811}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tk_timepoint_t end_time = k_uptime_get() + timeout;\n\n\tint prio;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 45.04798158519673}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tk_timepoint_t end_time;\n\tint prio = 0;\n\n\tLOG_DBG(\"Notifying %s\", _ZBUS_CHAN_NAME(chan));\n\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\ttimeout = _zbus_adjust_timeout(timeout);\n\n\tend_time = k_uptime_get() + timeout;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 51.668105061006365}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tk_timepoint_t end_time;\n\tint prio;\n\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\t/* Adjusting timeout if in an ISR */\n\ttimeout = COND_CODE_1(IS_ENABLED(CONFIG_ZBUS_ISR_SAFE), (timeout), (k_timeout_from_ms(0)));\n\n\tend_time = sys_timepoint_timeout(k_timeout_to_ms_floor(timeout));\n\n\tchan_lock(chan, timeout, &prio);\n\n\tint err = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 45.6033421862245}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t  uint32_t tmpreg;\n  uint32_t itreg;\n\n  /* Check the parameters */\n  assert_param(IS_ETH_INT_OK(Int));\n\n  /* Get the interrupt register address */\n  itreg = (uint32_t) ETH_INT_REG;\n\n  /* Get the interrupt status register address */\n  tmpreg = (uint32_t) ETH_INT_STATUS_REG;\n\n  if (enable != DISABLE) {\n    /* Enable the Ethernet interrupt */\n    if (Int == ETH_INT_ABNORMAL) {\n      /* Set the abnormal interrupt enable bit */\n      SET_BIT(itreg, ETH_IT_ABNORMAL_IE);\n\n      /* Check if the interrupt is normal or abnormal */\n      if ((((uint32_t)(*((volatile uint32_t *)(tmpreg)))) & ETH_IT_ABNORMAL) != 0) {\n        /* Set the normal interrupt enable bit */\n        SET_BIT(itreg, ETH_IT_NORMAL_IE);\n      }\n    } else {\n      /* Set the normal interrupt enable bit */\n      SET_BIT(itreg, ETH_IT_NORMAL_IE);\n    }\n  } else {\n    /* Disable the Ethernet interrupt */\n    if (Int == ETH_INT_ABNORMAL) {\n      /* Clear the abnormal interrupt enable bit */\n      CLEAR_BIT(itreg, ETH_IT_ABNORMAL_IE);\n\n      /* Check if there are any other enabled interrupts */\n      if ((((uint32_t)(*((volatile uint32_t *)(tmpreg)))) & ETH_IT_NORMAL) == 0) {\n        /* Clear the normal interrupt enable bit */\n        CLEAR_BIT(itreg, ETH_IT_NORMAL_IE);\n      }\n    } else {\n      /* Clear the normal interrupt enable bit */\n      CLEAR_BIT(itreg, ETH_IT_NORMAL_IE);\n    }\n  }\n}", "CodeBleu_score": 33.59185040812148}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\n\tuint32_t temp;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT_OK(Int));\n\n\t/* Enable or disable the specified Ethernet interrupt */\n\tif (enable != DISABLE) {\n\t\t/* Enable the specified Ethernet interrupt */\n\t\ttemp = ETH->IMR;\n\t\ttemp |= Int;\n\t\tETH->IMR = temp;\n\t} else {\n\t\t/* Disable the specified Ethernet interrupt */\n\t\ttemp = ETH->IMR;\n\t\ttemp &= (uint32_t) ~Int;\n\t\tETH->IMR = temp;\n\t}\n}", "CodeBleu_score": 34.01779785692071}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc;\n    uint32_t txDescAddr = ETH_TX_DESC_ADDR;\n    uint32_t txDescEndAddr = txDescAddr + (ETH_TX_DESC_NUM * sizeof(ETH_TX_DESC));\n    while (txDescAddr < txDescEndAddr) {\n        txDesc = (ETH_TX_DESC *)txDescAddr;\n        if (txDesc->owner == ETH_DESC_OWNED_BY_DEVICE) {\n            return txDesc;\n        }\n        txDescAddr += sizeof(ETH_TX_DESC);\n    }\n    return 0;\n}", "CodeBleu_score": 38.015850896568615}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc;\n    uint32_t txDescAddr = ETH_TX_DESC_ADDR;\n    uint32_t txDescAddrEnd = txDescAddr + ETH_TX_DESC_SIZE * ETH_TX_DESC_COUNT;\n\n    while (txDescAddr < txDescAddrEnd) {\n        txDesc = (ETH_TX_DESC *)txDescAddr;\n        if (txDesc->descStatus & ETH_TX_DESC_STATUS_OWNED) {\n            txDescAddr += ETH_TX_DESC_SIZE;\n        } else {\n            return txDesc;\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 37.091527257840525}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc;\n    UINT32 txDescAddr;\n    UINT32 txDescAddrMask;\n    UINT32 i;\n\n    /* Get the current transmit descriptor address */\n    txDescAddr = ETH_GetTxDescAddr();\n\n    /* Mask the transmit descriptor address to get the base address */\n    txDescAddrMask = txDescAddr & ~(ETH_TX_DESC_SIZE - 1);\n\n    /* Loop through the transmit descriptors */\n    for (i = 0; i < ETH_TX_DESC_COUNT; i++) {\n        /* Calculate the address of the current transmit descriptor */\n        txDesc = (ETH_TX_DESC *)(txDescAddrMask + i * ETH_TX_DESC_SIZE);\n\n        /* Check if the transmit descriptor is owned by the device */\n        if (txDesc->status & ETH_TX_DESC_STATUS_OWN) {\n            /* Transmit descriptor is owned by the device, return it */\n            return txDesc;\n        }\n    }\n\n    /* No free transmit descriptor found, return 0 */\n    return 0;\n}", "CodeBleu_score": 46.98795285376408}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_err_t ret = RT_EOK;\n    rt_uint32_t cyp_dac_channel;\n    CY_CSDIDAC_Type *dac = device->user_data;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(dac, cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable failed\");\n        ret = -RT_ERROR;\n    }\n\n    return ret;\n}", "CodeBleu_score": 57.765723844332875}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_err_t ret = RT_EOK;\n    rt_uint32_t cyp_dac_channel = 0;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(device->parent.config, cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS) {\n        rt_kprintf(\"[%s] Failed to enable DAC output for channel %d\n\", device->parent.name, channel);\n        ret = -RT_ERROR;\n    }\n\n    return ret;\n}", "CodeBleu_score": 56.313018701439475}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    CY_CSDIDAC_Type *cyp_dac = (CY_CSDIDAC_Type *)device->config.base_addr;\n\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    rt_err_t result = RT_EOK;\n\n    Cy_CSDIDAC_OutputEnable(cyp_dac, cyp_dac_channel, *value);\n\n    if (Cy_CSDIDAC_GetStatus(cyp_dac, cyp_dac_channel) != CY_CSDIDAC_STATUS_OUTPUT_ENABLED)\n    {\n        LOG_E(\"cyp_dac_convert failed\");\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 55.36761211619834}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    rt_uint8_t *p = (rt_uint8_t *)addr;\n\n    if (addr + size > (rt_uint32_t)FLASH_END_ADDR) {\n        rt_kprintf(\"flash read error: addr=0x%08x, size=0x%08x\n\", addr, size);\n        return -EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *p++;\n    }\n\n    return i;\n}", "CodeBleu_score": 48.232024669669634}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    rt_uint32_t i;\n    rt_uint32_t read_size;\n\n    /* Check if the read operation would exceed the flash memory's end address */\n    if ((addr + size) > (FLASH_END_ADDR + 1)) {\n        rt_kprintf(\"ifx_flash_read_32k: read operation would exceed flash memory end address\n\");\n        return -EINVAL;\n    }\n\n    /* Read the specified size of data from the flash memory address into the buffer */\n    for (i = 0; i < size; i++) {\n        buf[i] = *(volatile rt_uint8_t *)(addr + i);\n    }\n\n    /* Return the number of bytes read */\n    read_size = size;\n    return read_size;\n}", "CodeBleu_score": 51.8686505900263}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    if (addr + size > FLASH_END_ADDR) {\n        rt_kprintf(\"flash read error: addr:%d size:%d\n\", addr, size);\n        return -1;\n    }\n    rt_uint32_t i;\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n    return i;\n}", "CodeBleu_score": 50.43707731713846}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 29.114912051891924}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->user_data;\n    return cyhal_timer_read(hal_timer);\n}", "CodeBleu_score": 29.114912051891924}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    rt_hw_timer_t *timer_obj = (rt_hw_timer_t *)timer->user_data;\n    rt_uint32_t count = cyhal_timer_read(timer_obj->timer);\n    return count;\n}", "CodeBleu_score": 57.683712556476394}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    int err;\n    while ((err = pthread_mutex_lock(&dfs_mutex)) != 0) {\n        assert(err == EBUSY);\n    }\n}", "CodeBleu_score": 24.888758168465127}, {"code": "void dfs_lock(void){\n\t    while (1) {\n        if (pthread_mutex_trylock(&dfs_mutex) == 0) {\n            return;\n        }\n        assert(errno == EBUSY);\n    }\n}", "CodeBleu_score": 26.782093741382383}, {"code": "void dfs_lock(void){\n\t  int status;\n  while (1) {\n    status = pthread_mutex_trylock(&dfs_mutex);\n    if (status == 0) {\n      return;\n    }\n    assert(status == EBUSY);\n  }\n}", "CodeBleu_score": 28.096451684845437}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int index;\n    int fd = -1;\n\n    if (startfd < 0)\n    {\n        startfd = 0;\n    }\n\n    for (index = startfd; index < fdt->maxfd; index++)\n    {\n        if (fdt->fds[index] == NULL)\n        {\n            fd = index;\n            break;\n        }\n    }\n\n    if (fd == -1)\n    {\n        fd = fd_slot_expand(fdt, index);\n    }\n\n    return fd;\n}", "CodeBleu_score": 42.72144531072746}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n    int index;\n    struct dfs_file *file;\n\n    if (startfd < 0)\n    {\n        startfd = 0;\n    }\n\n    for (index = startfd; index < fdt->maxfd; index++)\n    {\n        file = fdt->fds[index];\n        if (file == NULL)\n        {\n            fd = index;\n            fdt->fds[index] = file;\n            return fd;\n        }\n    }\n\n    fd = fd_slot_expand(fdt, startfd);\n    if (fd < 0)\n    {\n        return -1;\n    }\n\n    fdt->fds[fd] = NULL;\n    return fd;\n}", "CodeBleu_score": 46.05402677122341}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    fd = fd_slot_expand(fdt, fd);\n    if (fd < 0) {\n        return -1;\n    }\n\n    return fd;\n}", "CodeBleu_score": 42.55329504303922}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < RT_ERR_MAX; i++) {\n        if (error == rt_err_list[i].err_code) {\n            return rt_err_list[i].err_msg;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 55.13671825944899}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < RT_ERR_MAX; i++) {\n        if (error == rt_err_list[i].err_code) {\n            return rt_err_list[i].err_msg;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 55.13671825944899}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < RT_ERR_NUM; i++) {\n        if (error == rt_errno[i].err_code) {\n            return rt_errno[i].err_str;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 55.59009537475368}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t", "CodeBleu_score": 4.801704682804091}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t  rt_err_t result;\n  rt_base_t i;\n  rt_base_t count;\n  rt_base_t index;\n  rt_base_t *list;\n  rt_base_t *item;\n  rt_base_t *next;\n\n  rt_enter_critical();\n\n  list = rt_thread_idle_hook;\n  count = rt_thread_idle_count;\n  index = 0;\n\n  for (i = 0; i < count; i++) {\n    item = list + i;\n\n    if (*item == RT_NULL) {\n      index = i;\n      break;\n    }\n  }\n\n  if (index == 0) {\n    result = -RT_EFULL;\n  } else {\n    *(list + index) = (rt_base_t)hook;\n    result = RT_EOK;\n  }\n\n  rt_exit_critical();\n\n  return result;\n}", "CodeBleu_score": 46.44228890291544}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t", "CodeBleu_score": 4.801704682804091}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t", "CodeBleu_score": 4.801704682804091}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result = RT_EOK;\n    rt_base_t index;\n    rt_base_t *p_idle_hook;\n    rt_base_t *p_idle_hook_next;\n\n    rt_spin_lock(&rt_thread_idle_lock);\n    p_idle_hook = &rt_thread_idle_hook;\n    for (index = 0; index < RT_THREAD_IDLE_HOOK_MAX; index++) {\n        p_idle_hook_next = (rt_base_t *)(*p_idle_hook);\n        if (p_idle_hook_next == (rt_base_t)hook) {\n            *p_idle_hook = (rt_base_t)NULL;\n            result = RT_EOK;\n            break;\n        }\n        p_idle_hook = p_idle_hook_next;\n    }\n    rt_spin_unlock(&rt_thread_idle_lock);\n\n    return result;\n}", "CodeBleu_score": 48.26055781334503}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t", "CodeBleu_score": 4.801704682804091}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_err_t result;\n    rt_base_t level;\n    rt_thread_t thread;\n\n    /* ensure scheduler is unlocked */\n    level = rt_hw_interrupt_disable();\n\n    /* dequeue and wake up each suspended thread from the list */\n    while ((thread = (rt_thread_t)rt_list_entry(susp_list->next, struct rt_thread, tlist))) {\n        rt_list_remove(&thread->tlist);\n        rt_thread_resume(thread);\n    }\n\n    /* restore scheduler lock level */\n    rt_hw_interrupt_set_level(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 32.41241911061036}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_err_t ret = RT_EOK;\n    rt_thread_t *thread;\n\n    /* check the parameter */\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* lock the scheduler */\n    rt_hw_sched_lock();\n\n    /* dequeue and wake up each suspended thread */\n    while (!rt_list_isempty(susp_list)) {\n        /* get the first suspended thread */\n        thread = (rt_thread_t *)rt_list_entry(susp_list->next, rt_list_node_t, list);\n\n        /* remove the suspended thread from the list */\n        rt_list_remove(&(thread->list));\n\n        /* set the thread error code */\n        thread->error = thread_error;\n\n        /* wake up the suspended thread */\n        rt_thread_resume(thread);\n    }\n\n    /* unlock the scheduler */\n    rt_hw_sched_unlock();\n\n    return ret;\n}", "CodeBleu_score": 31.359923723231365}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t *thread;\n    rt_err_t result;\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* resume all suspended threads */\n    while (rt_list_entry(susp_list->next, rt_thread_t, tlist) != NULL) {\n        thread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n        result = rt_thread_resume(thread, thread_error);\n        if (result != RT_EOK) {\n            break;\n        }\n    }\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 41.49834078260478}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t dev, old;\n    int result;\n\n    /* save the current console device */\n    old = rt_console_get_device();\n\n    /* find the new device by its name */\n    dev = rt_device_find(name);\n    if (dev == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* check if it is the same as the current device */\n    if (dev == old) {\n        return old;\n    }\n\n    /* close the current console device if it exists */\n    if (old != RT_NULL) {\n        rt_device_close(old);\n    }\n\n    /* open the new console device with read/write and stream flags */\n    result = rt_device_open(dev, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        return RT_NULL;\n    }\n\n    /* set it as the new console device */\n    rt_console_set_device(dev);\n\n    return old;\n}", "CodeBleu_score": 58.530138016806674}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device = rt_console_get_device();\n    rt_device_t device = RT_NULL;\n    rt_err_t result;\n\n    if (old_device != RT_NULL) {\n        if (strcmp(rt_device_get_name(old_device), name) == 0) {\n            return old_device;\n        }\n\n        rt_device_close(old_device);\n        old_device = RT_NULL;\n    }\n\n    device = rt_device_find(name);\n    if (device == RT_NULL) {\n        return RT_NULL;\n    }\n\n    result = rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        return RT_NULL;\n    }\n\n    rt_console_set_device(device);\n    return old_device;\n}", "CodeBleu_score": 63.941353764859834}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t device;\n    rt_device_t old_device;\n\n    old_device = rt_console_get_device();\n\n    if (old_device != RT_NULL) {\n        rt_device_close(old_device);\n    }\n\n    device = rt_device_find(name);\n    if (device == RT_NULL) {\n        return old_device;\n    }\n\n    if (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        rt_device_close(device);\n        return old_device;\n    }\n\n    rt_console_set_device(device);\n\n    return old_device;\n}", "CodeBleu_score": 60.94650881864088}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object_class *class = rt_object_class_get(type);\n    if (class != NULL) {\n        rt_spinlock_lock(&class->lock);\n        struct rt_object *object = class->head;\n        while (object != NULL) {\n            count++;\n            object = object->next;\n        }\n        rt_spinlock_unlock(&class->lock);\n    }\n    return count;\n}", "CodeBleu_score": 36.78901363755379}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    rt_object_class_t *class;\n    rt_object_t *object;\n\n    class = rt_object_class_get(type);\n    if (class == NULL) {\n        return 0;\n    }\n\n    rt_spinlock_lock(&class->lock);\n\n    object = class->first;\n    while (object != NULL) {\n        count++;\n        object = object->next;\n    }\n\n    rt_spinlock_unlock(&class->lock);\n\n    return count;\n}", "CodeBleu_score": 42.255270282134624}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    struct rt_object_class *class;\n    struct rt_object *object;\n    int count = 0;\n\n    class = rt_object_class_get(type);\n    if (class == NULL) {\n        return 0;\n    }\n\n    rt_spin_lock(&class->lock);\n\n    object = class->head;\n    while (object != NULL) {\n        count++;\n        object = object->next;\n    }\n\n    rt_spin_unlock(&class->lock);\n\n    return count;\n}", "CodeBleu_score": 42.8726178088026}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_base_t level;\n    rt_object_info_t *object_info;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* lock the object's spinlock */\n    level = rt_hw_interrupt_disable();\n\n    /* get the object's information structure */\n    object_info = (rt_object_info_t *)object;\n\n    /* remove the object from its list */\n    rt_list_remove(&(object_info->list));\n\n    /* unlock the spinlock */\n    rt_hw_interrupt_enable(level);\n\n    /* set the object's type to zero */\n    object_info->type = 0;\n}", "CodeBleu_score": 28.970849917820207}, {"code": "void rt_object_detach(rt_object_t object){\n\t    rt_object_info_t *object_info;\n    rt_base_t         object_type;\n\n    /* check object */\n    if (object == RT_NULL) {\n        return;\n    }\n\n    /* detach object */\n    object_info = (rt_object_info_t *)object;\n    object_type = object_info->type;\n\n    /* call hook function */\n    if (rt_object_detach_hook != RT_NULL) {\n        rt_object_detach_hook(object);\n    }\n\n    /* lock spinlock */\n    rt_base_t level = rt_hw_interrupt_disable();\n\n    /* remove object from list */\n    if (object_info->list != RT_NULL) {\n        rt_list_remove(&(object_info->list));\n        object_info->list = RT_NULL;\n    }\n\n    /* unlock spinlock */\n    rt_hw_interrupt_enable(level);\n\n    /* set object type */\n    object_info->type = 0;\n}", "CodeBleu_score": 46.179043501232755}, {"code": "void rt_object_detach(rt_object_t object){\n\t  rt_object_info_t *object_info;\n\n  /* check object */\n  if (object == RT_NULL) {\n    return;\n  }\n\n  /* call detach hook */\n  if (object->type != 0) {\n    rt_object_detach_hook(object);\n  }\n\n  /* get object info */\n  object_info = rt_object_get_info(object);\n\n  /* lock spinlock */\n  rt_base_t level = rt_hw_interrupt_disable();\n\n  /* remove object from list */\n  rt_list_remove(&(object_info->list));\n\n  /* unlock spinlock */\n  rt_hw_interrupt_enable(level);\n\n  /* set object type to zero */\n  object->type = 0;\n}", "CodeBleu_score": 40.43794143194841}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(rt_object_get_type(obj) == RT_Object_Class_Custom);\n\n    /* call destroy method */\n    if (obj->destroy != RT_NULL) {\n        result = obj->destroy(obj);\n    } else {\n        result = RT_EOK;\n    }\n\n    /* delete object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 49.04852832395102}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result;\n    struct rt_custom_object *custom_object;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(rt_object_get_type(obj) == RT_Object_Class_Custom);\n\n    custom_object = (struct rt_custom_object *)obj;\n\n    /* destroy the object */\n    if (custom_object->destroy != RT_NULL) {\n        result = custom_object->destroy(obj);\n    } else {\n        result = RT_EOK;\n    }\n\n    /* delete the object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 56.85270017443229}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(rt_object_get_class_type(obj) == RT_Object_Class_Custom);\n\n    /* call destroy method */\n    if (rt_object_get_destroy_method(obj) != RT_NULL) {\n        result = rt_object_get_destroy_method(obj)(obj);\n    }\n\n    /* delete the object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 44.39580084636058}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t self;\n\n    /* get current thread */\n    self = rt_thread_self();\n\n    /* enter critical section */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(self);\n\n    /* exit critical section */\n    rt_exit_critical();\n\n    /* trigger context switch */\n    rt_schedule();\n}", "CodeBleu_score": 30.955665350580645}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t self;\n    rt_base_t lock;\n\n    /* get current thread */\n    self = rt_thread_self();\n\n    /* enter critical section */\n    lock = rt_hw_local_irq_disable();\n\n    /* close thread */\n    rt_thread_close(self);\n\n    /* add to defunct thread list */\n    rt_list_add(&self->list, &rt_thread_defunct_list);\n\n    /* exit critical section */\n    rt_hw_local_irq_enable(lock);\n\n    /* trigger context switch */\n    rt_hw_schedule();\n}", "CodeBleu_score": 35.221785000679176}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n\n    thread = rt_thread_self();\n\n    /* remove thread from schedule */\n    rt_sched_lock_level_t slvl;\n    rt_sched_lock(&slvl);\n    rt_sched_remove_thread(thread);\n    rt_sched_unlock(slvl);\n\n    /* close thread */\n    rt_sched_thread_close(thread);\n\n    /* add thread to defunct list */\n    rt_list_add(&(thread->list), &(rt_thread_defunct_list));\n\n    /* trigger context switch */\n    rt_hw_software_interrupt(RT_SWI_THREAD_EXIT);\n}", "CodeBleu_score": 59.37423462482554}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    Thread *thread = (Thread *) parameter;\n\n    if (thread == NULL) {\n        return;\n    }\n\n    scheduler_lock();\n    if (thread->state != THREAD_SUSPENDED) {\n        thread->error = THREAD_TIMEOUT;\n        thread_list_remove(&thread_suspend_list, thread);\n        thread_list_insert(&thread_ready_list, thread);\n    }\n    scheduler_unlock();\n}", "CodeBleu_score": 32.7883535343682}, {"code": "static void _thread_timeout(void *parameter){\n\t  thread_t *thread = parameter;\n  if (thread == NULL) {\n    return;\n  }\n  scheduler_lock();\n  if (thread->state != THREAD_SUSPENDED) {\n    return;\n  }\n  thread->error = THREAD_ERROR_TIMEOUT;\n  suspend_list_remove(thread);\n  ready_list_insert(thread);\n  scheduler_unlock();\n}", "CodeBleu_score": 33.16728992040379}, {"code": "static void _thread_timeout(void *parameter){\n\t\n    // Get the thread from the parameter\n    struct thread *thread = (struct thread *) parameter;\n\n    // Check if the thread is valid\n    if (thread == NULL) {\n        return;\n    }\n\n    // Lock the scheduler\n    lock_acquire(&scheduler_lock);\n\n    // Check if the thread is suspended\n    if (list_find(&thread->elem, &thread->tid, &thread_list) == NULL) {\n        return;\n    }\n\n    // Set the thread's error number to a timeout value\n    thread->error_code = TIMEOUT;\n\n    // Remove the thread from the suspend list\n    list_remove(&thread->elem);\n\n    // Insert the thread into the ready list\n    list_insert(&thread->elem, &thread_list);\n\n    // Unlock the scheduler\n    lock_release(&scheduler_lock);\n\n    // Reschedule\n    thread_yield();\n}", "CodeBleu_score": 41.025481399350305}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t  rt_base_t level;\n  rt_thread_t cur_thread;\n  rt_mutex_t mutex;\n  rt_list_t *node;\n  rt_base_t status;\n\n  /* lock thread spinlock */\n  level = rt_hw_interrupt_disable();\n\n  /* get current thread */\n  cur_thread = rt_thread_self();\n\n  /* check if the thread is waiting on a mutex */\n  if (cur_thread->wait_mutex != RT_NULL) {\n    /* get the mutex the thread is waiting on */\n    mutex = cur_thread->wait_mutex;\n\n    /* remove the thread from the mutex's waiting list */\n    rt_list_remove(&(mutex->wait_list), &(cur_thread->list_node));\n\n    /* clear the pending object */\n    mutex->pending_object = RT_NULL;\n\n    /* set the thread's wait mutex to NULL */\n    cur_thread->wait_mutex = RT_NULL;\n  }\n\n  /* release all mutexes the thread has taken */\n  node = rt_list_first(&(cur_thread->mutex_list));\n  while (node != RT_NULL) {\n    mutex = rt_list_entry(node, struct rt_mutex, list_node);\n    node = rt_list_next(node);\n\n    /* release the mutex */\n    status = rt_mutex_release(mutex);\n    RT_ASSERT(status == RT_EOK);\n  }\n\n  /* restore the spinlock state */\n  rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 52.71837145304893}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t  rt_base_t level;\n  rt_thread_t current;\n  rt_thread_t next;\n  rt_thread_t prev;\n  rt_thread_t thread_to_detach;\n  rt_mutex_t mutex;\n  rt_base_t i;\n\n  /* Lock the thread's spinlock */\n  level = rt_hw_interrupt_disable();\n\n  /* Get the current thread */\n  current = rt_thread_self();\n\n  /* If the thread is waiting on a mutex, remove it from the waiting list and clear the pending object */\n  if (current->mutex_waiting) {\n    mutex = current->mutex_waiting;\n    next = mutex->waiting_list;\n    prev = mutex->waiting_list_prev;\n\n    if (next == current) {\n      mutex->waiting_list = RT_NULL;\n    } else {\n      while (next != current) {\n        prev = next;\n        next = next->next;\n      }\n\n      prev->next = next->next;\n    }\n\n    mutex->pending_object = RT_NULL;\n    current->mutex_waiting = RT_NULL;\n  }\n\n  /* Release all mutexes the thread has taken */\n  for (i = 0; i < RT_THREAD_MUTEX_MAX; i++) {\n    thread_to_detach = thread->mutex_taken[i];\n\n    if (thread_to_detach != RT_NULL) {\n      rt_mutex_release(thread_to_detach);\n    }\n  }\n\n  /* Restore the spinlock state */\n  rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 41.42899036136609}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t", "CodeBleu_score": 1.5259533266411016}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->parent.state == RT_Thread_State_Inactive);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* log thread name and priority */\n    LOG_D(\"thread startup: %s, prio: %d\", thread->parent.name, thread->parent.current_priority);\n\n    /* calculate thread priority attributes */\n    thread->parent.init_priority = thread->parent.current_priority;\n    thread->parent.init_priority_offset = rt_sched_get_priority_offset(thread->parent.init_priority);\n\n    /* reset thread state to suspended */\n    thread->parent.state = RT_Thread_State_Suspended;\n\n    /* resume the thread */\n    error = rt_thread_resume(thread);\n\n    if (error == RT_EOK)\n    {\n        /* trigger a scheduler if available */\n        if (rt_thread_self() == RT_NULL)\n        {\n            rt_sched_system_scheduler_locked();\n        }\n    }\n\n    return error;\n}", "CodeBleu_score": 51.796732097634646}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->state == RT_Thread_State_Inactive);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* set thread priority */\n    thread->priority = rt_thread_get_priority(thread);\n    rt_thread_priority_init(thread);\n\n    /* reset thread state */\n    thread->state = RT_Thread_State_Suspended;\n\n    /* resume thread */\n    error = rt_thread_resume(thread);\n\n    /* trigger scheduler */\n    if (error == RT_EOK)\n    {\n        rt_system_scheduler_lock();\n        rt_system_scheduler_unlock();\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 53.857373901719086}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* log thread name and priority */\n    LOG_D(\"thread: %s, priority: %d\", thread->parent.name, thread->parent.current_priority);\n\n    /* calculate thread priority attributes */\n    rt_thread_priority_calc(thread);\n\n    /* reset thread state to suspended */\n    thread->parent.state = RT_Thread_State_Suspended;\n\n    /* resume thread */\n    error = rt_thread_resume(thread);\n\n    return error;\n}", "CodeBleu_score": 56.292047342440995}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t *list;\n    rt_timer_t *timer;\n    rt_uint32_t i;\n\n    /* get the highest level of the timer skip list */\n    for (i = 0; i < RT_TIMER_SKIP_LIST_MAX_LEVEL; i++) {\n        list = &timer_list[i];\n        if (!rt_list_isempty(list)) {\n            break;\n        }\n    }\n\n    /* check if the highest level of the timer skip list is not empty */\n    if (i == RT_TIMER_SKIP_LIST_MAX_LEVEL) {\n        return -RT_ERROR;\n    }\n\n    /* get the first timer entry */\n    list = rt_list_entry(list->next, rt_list_t, next);\n    timer = rt_list_entry(list, rt_timer_t, node);\n\n    /* set the timeout tick to the timer's timeout value */\n    *timeout_tick = timer->timeout;\n\n    return RT_EOK;\n}", "CodeBleu_score": 40.897355859525305}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_timer_t *timer;\n    rt_uint32_t level;\n\n    /* get the highest level of the timer skip list */\n    level = rt_list_get_level(timer_list);\n\n    /* check if the highest level of the timer skip list is not empty */\n    if (level != 0) {\n        /* get the first timer entry */\n        timer = rt_list_entry(timer_list[level - 1].next, struct rt_timer, node);\n\n        /* set the provided timeout tick to the timer's timeout value */\n        *timeout_tick = timer->timeout;\n\n        /* return RT_EOK */\n        return RT_EOK;\n    }\n\n    /* return an error code */\n    return -RT_ERROR;\n}", "CodeBleu_score": 51.71210935445956}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_uint32_t i;\n    rt_timer_t timer;\n    rt_err_t result;\n\n    /* get the highest level of the timer skip list */\n    for (i = 0; i < RT_TIMER_SKIP_LIST_MAX_LEVEL; i++) {\n        if (timer_list[i].next != &timer_list[i]) {\n            break;\n        }\n    }\n\n    /* the highest level of the timer skip list is empty */\n    if (i == RT_TIMER_SKIP_LIST_MAX_LEVEL) {\n        return RT_ETIMEOUT;\n    }\n\n    /* get the first timer entry */\n    timer = RT_LIST_ENTRY(timer_list[i].next, struct rt_timer, entry);\n\n    /* set the timeout tick to the timer's timeout value */\n    *timeout_tick = timer->timeout_tick;\n\n    /* return RT_EOK */\n    return RT_EOK;\n}", "CodeBleu_score": 45.462969902296784}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* check the arguments */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    /* allocate a timer object */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize the timer object */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* initialize the timer object */\n    rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n    return timer;\n}", "CodeBleu_score": 73.81972622987834}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* check the arguments */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time <= RT_TIMER_MAX_TICKS);\n\n    /* allocate memory for the timer object */\n    timer = rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize the timer object */\n    rt_memset(timer, 0, sizeof(struct rt_timer));\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* set timer name */\n    timer->parent.name = name;\n\n    return timer;\n}", "CodeBleu_score": 69.88521528641965}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* check the time */\n    if (time < RT_TIMER_MAX_DELAY)\n    {\n        /* allocate timer object */\n        timer = rt_malloc(sizeof(struct rt_timer));\n        if (timer != RT_NULL)\n        {\n            /* initialize timer */\n            _timer_init(timer, timeout, parameter, time, flag);\n\n            /* set timer name */\n            rt_object_set_name(&(timer->parent), name);\n\n            return timer;\n        }\n    }\n\n    return RT_NULL;\n}", "CodeBleu_score": 61.688485641773774}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\ta.Handler(recorder, req)\n\n\tfor key, value := range recorder.HeaderMap {\n\t\tres.Header()[key] = value\n\t}\n\n\tres.WriteHeader(recorder.Code)\n\tres.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 30.34504759845551}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\n\tfor _, handler := range a.middlewares {\n\t\thandler.ServeHTTP(recorder, req)\n\t\tfor key, values := range recorder.Header() {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\n\t\trecorder.Flush()\n\t\trecorder.Body.Reset()\n\t}\n\n\ta.router.ServeHTTP(recorder, req)\n\n\tfor key, values := range recorder.Header() {\n\t\tfor _, value := range values {\n\t\t\tres.Header().Add(key, value)\n\t\t}\n\t}\n\n\tres.WriteHeader(recorder.Code)\n\tres.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 43.71989486200793}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\thandlers := []Handler{\n\t\ta.authHandler,\n\t\ta.loggerHandler,\n\t}\n\n\tfor _, handler := range handlers {\n\t\thandler(res, req)\n\t\tif res.Header().Get(\"X-Status\") == \"401 Unauthorized\" {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 54.54231099847727}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tpath = \"./frontend\" + path\n\n\tinfo, err := os.Stat(path)\n\tif err != nil {\n\t\ta.error(res, req, http.StatusNotFound, err)\n\t\treturn\n\t}\n\n\tif info.IsDir() {\n\t\tpath += \"/index.html\"\n\t\tinfo, err = os.Stat(path)\n\t\tif err != nil {\n\t\t\ta.error(res, req, http.StatusNotFound, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\ta.error(res, req, http.StatusInternalServerError, err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tcontentType := mime.TypeByExtension(filepath.Ext(path))\n\tif contentType == \"\" {\n\t\tcontentType = \"application/octet-stream\"\n\t}\n\n\tres.Header().Set(\"Content-Type\", contentType)\n\tio.Copy(res, file)\n}", "CodeBleu_score": 39.47458974581337}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tres.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tres.Header().Set(\"Access-Control-Allow-Headers\", \"*\")\n\tres.Header().Set(\"Access-Control-Allow-Methods\", \"*\")\n\tres.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\n\tpath := req.URL.Path\n\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\n\tasset, err := a.assets.Get(path)\n\tif err != nil {\n\t\tres.WriteHeader(404)\n\t\treturn\n\t}\n\n\tcontentType := \"text/plain\"\n\n\tif strings.HasSuffix(path, \".js\") {\n\t\tcontentType = \"application/javascript\"\n\t} else if strings.HasSuffix(path, \".css\") {\n\t\tcontentType = \"text/css\"\n\t} else if strings.HasSuffix(path, \".html\") {\n\t\tcontentType = \"text/html\"\n\t}\n\n\tres.Header().Set(\"Content-Type\", contentType)\n\tres.Write(asset)\n}", "CodeBleu_score": 43.9286907169798}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := a.assets.Get(path)\n\tif err != nil {\n\t\tres.WriteHeader(404)\n\t\treturn\n\t}\n\tswitch path[len(path)-3:] {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 50.69064324143461}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := path.Base(req.URL.Path)\n\trobot, err := a.master.GetRobot(robotName)\n\tif err != nil {\n\t\ta.writeError(res, err)\n\t\treturn\n\t}\n\tconnections, err := robot.GetConnections()\n\tif err != nil {\n\t\ta.writeError(res, err)\n\t\treturn\n\t}\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 27.954778897016553}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Path[len(\"/api/robots/\"):]\n\trobot, err := a.master.GetRobot(robotName)\n\tif err != nil {\n\t\twriteError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\tjsonConnections, err := json.Marshal(connections)\n\tif err != nil {\n\t\twriteError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonConnections)\n}", "CodeBleu_score": 37.6407746862583}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\trobot, err := a.master.GetRobot(robotName)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with name: \" + robotName})\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 30.869622908051742}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair) != 2 || !secureCompare(username, pair[0]) || !secureCompare(password, pair[1]) {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\tw.WriteHeader(http.StatusOK)\n\t}\n}", "CodeBleu_score": 51.521424890751454}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(username, pair[0]) || !secureCompare(password, pair[1]) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.77802914682379}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(username, pair[0]) || !secureCompare(password, pair[1]) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 48.70778540988229}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\n\t// Calculate the slope and intercept of the linear scaling function\n\tslope := float64(toMax - toMin) / float64(fromMax - fromMin)\n\tintercept := float64(toMin) - slope*float64(fromMin)\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\tscaled := slope*input + intercept\n\t\tif scaled < float64(toMin) {\n\t\t\treturn toMin\n\t\t} else if scaled > float64(toMax) {\n\t\t\treturn toMax\n\t\t} else {\n\t\t\treturn int(scaled)\n\t\t}\n\t}\n}", "CodeBleu_score": 56.76462553758868}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tfromMin := fromMin\n\tfromMax := fromMax\n\ttoMin := toMin\n\ttoMax := toMax\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue := int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 52.88790177435667}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tfromMin, fromMax, toMin, toMax = float64(toMin), float64(toMax), float64(toMin), float64(toMax)\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 49.59339291123509}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.IsValid() {\n\t\treturn 0, 0, errors.New(\"connection is invalid\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scaling.Scale(float64(raw))\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 50.62526845032092}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaledValue := float64(rawValue) * a.scale\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 52.41629203072124}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.IsValid() {\n\t\treturn 0, 0, errors.New(\"Invalid connection\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scalingFunction(raw)\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 46.00227609724195}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tfromSpan := fromMax - fromMin\n\ttoSpan := toMax - toMin\n\n\tm := toSpan / fromSpan\n\tn := toMin - m*fromMin\n\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 51.07043341441965}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t", "CodeBleu_score": 6.354275982152914}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\n    // Calculate the slope (m) and intercept (n) for the linear transformation\n    m := (toMax - toMin) / (fromMax - fromMin)\n    n := toMin - m * fromMin\n\n    // Return the scaling function\n    return func(input int) float64 {\n        return m * float64(input) + n\n    }\n}", "CodeBleu_score": 48.843398200119324}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(\"Grove Piezo Vibration Sensor\")\n\n\td.AddEvent(\"vibration\", 1)\n\n\tif err := d.SetDataTransformer(func(raw interface{}) (interface{}, error) {\n\t\tif raw == nil {\n\t\t\treturn 0, nil\n\t\t}\n\t\tv, ok := raw.(float64)\n\t\tif !ok {\n\t\t\treturn 0, fmt.Errorf(\"unexpected value type: %T\", raw)\n\t\t}\n\t\treturn v, nil\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\td.On(Data, func(data interface{}) {\n\t\tif data.(float64) > 1000 {\n\t\t\td.Publish(\"vibration\", 1)\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 50.339661065657474}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{}\n\td.SensorDriver = NewAnalogSensorDriver(a, pin, d, opts...)\n\td.SetName(\"Grove Piezo Vibration Sensor\")\n\n\td.AddEvent(Vibration)\n\n\td.AddEventHandler(d.OnVibration, Vibration)\n\n\tif err := d.SetEventThreshold(Vibration, 1000); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 45.21859632906921}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(\"Grove Piezo Vibration Sensor\")\n\td.AddEvent(\"vibration\", 1*time.Second, func(data interface{}) interface{} {\n\t\treturn data.(float64) > 1000\n\t})\n\n\tif err := d.SetDataPublishHandler(func(data interface{}) {\n\t\td.PublishEvent(\"vibration\", data)\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 52.54288918810194}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := (60 / d.bpm) * 1000 / hz\n\n\tfor i := 0; i < int(duration*1000); i += int(period) {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Millisecond)\n\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 59.7146727661203}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := 1000000 / (hz * d.bpm)\n\tif period < 1 {\n\t\tperiod = 1\n\t}\n\tfor i := 0; i < int(duration*1000); i += period {\n\t\terr := d.On()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t\terr = d.Off()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 59.31482063082116}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := (60 / d.BPM) / hz\n\ttime.Sleep(time.Duration(period * duration))\n\treturn nil\n}", "CodeBleu_score": 11.397602769706138}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\n\td.stop()\n\n\td.setSleepPin(false)\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 27.07785328672533}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn errors.New(\"Sleep pin not configured\")\n\t}\n\n\tif d.isRunning {\n\t\td.Stop()\n\t}\n\n\td.sleepPin.Low()\n\td.isSleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 31.561588409341816}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not configured\")\n\t}\n\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.067607079927328}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.Pins == nil {\n\t\treturn nil, errors.New(\"Pins map is not initialized\")\n\t}\n\tif p, ok := a.Pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpin, err := a.initAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.Pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 46.2503612257507}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.Pins == nil {\n\t\treturn nil, errors.New(\"Analog pins not initialized\")\n\t}\n\tif p, ok := a.Pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpin, err := a.initAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.Pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 46.34657621354512}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.Pins == nil {\n\t\treturn nil, errors.New(\"Pins map not initialized\")\n\t}\n\tif p, ok := a.Pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp, err := a.initAnalogPin(path, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.Pins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 49.388582288370166}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 64.50419399718643}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !pin.IsOutput() {\n\t\treturn fmt.Errorf(\"pin %s is not an output pin\", id)\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 63.74171310289349}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpin.DigitalWrite(val)\n\treturn nil\n}", "CodeBleu_score": 64.03264973727825}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"Adaptor must be connected to pins\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = gpio.NewDigitalPin(a.connection, chip, line)\n\t\ta.pins[id] = pin\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 46.570025891694065}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.connection == nil {\n\t\treturn nil, ErrConnected\n\t}\n\n\tpin, err := a.GetPin(id)\n\tif err != nil {\n\t\tpin = a.NewDigitalPin(id)\n\t\tif err = a.connection.DigitalPin(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err = pin.Init(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err = a.AddPin(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if err = pin.ApplyOptions(opts...); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 55.380934682539376}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"digital pin adaptor not connected to pins\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = gpio.NewDigitalPin(chip, line)\n\t\tpin.SetAdaptor(a)\n\n\t\ta.pins[id] = pin\n\t}\n\n\tpin.ApplyOptions(opts...)\n\n\treturn pin, nil\n}", "CodeBleu_score": 46.26104478800318}]}
