{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    // Retrieve the list of required files from the specified folder\n    auto files = FileTransfer::GetRequiredFiles(folder);\n\n    // Check if the download flag is set to true\n    if (download) {\n        // Iterate through the list of required files\n        for (const auto &file: files) {\n            // Check if the file exists locally\n            if (!FileTransfer::FileExists(file)) {\n                // Request the file from the server and log the download action\n                RequestFile(file);\n                Logger::Log(\"Downloaded \" + file);\n            } else {\n                // Log that the file is found in the cache\n                Logger::Log(\"Found \" + file + \" in cache\");\n            }\n        }\n    }\n\n    // Return the list of required files\n    return files;\n}", "CodeBleu_score": 51.0675259497821}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    // Get the list of required files from the server\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Check if each file exists locally\n    if (download) {\n        for (const auto &file : files) {\n            // Check if the file exists locally\n            if (!FileTransfer::FileExists(file)) {\n                // Request the file from the server\n                RequestFile(file);\n                // Log the download action\n                std::cout << \"Downloaded \" << file << \" from server\" << std::endl;\n            } else {\n                // Log that the file is found in the cache\n                std::cout << \"Found \" << file << \" in cache\" << std::endl;\n            }\n        }\n    }\n\n    // Return the list of required files\n    return files;\n}", "CodeBleu_score": 65.783711259238}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    // Get a list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Check if each file exists locally\n    if (download) {\n        for (const auto &file: required_files) {\n            // Check if the file exists locally\n            if (!FileTransfer::FileExists(file)) {\n                // Request the file and log the download action\n                RequestFile(file);\n                Logger::Log(LogLevel::Info, \"Downloaded file: \" + file);\n            } else {\n                // Log that the file is found in the cache\n                Logger::Log(LogLevel::Info, \"Found file in cache: \" + file);\n            }\n        }\n    }\n\n    return required_files;\n}", "CodeBleu_score": 67.15504052513872}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the attachment type is SpringArm or SpringArmGhost and the translation is only in the 'z' axis\n  if ((attachment_type == rpc::AttachmentType::SpringArm ||\n       attachment_type == rpc::AttachmentType::SpringArmGhost) &&\n      transform.translation().x() == 0 && transform.translation().y() == 0) {\n    // Issue a warning if the translation is only in the 'z' axis\n    LOG_WARNING(\"The translation of the actor is only in the 'z' axis, which is not valid for attachment type {}\",\n                rpc::AttachmentType_Name(attachment_type));\n  }\n\n  // Call an internal function to complete the actor spawning process\n  return SpawnActorWithParentInternal(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 41.08939285228465}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the attachment type is SpringArm or SpringArmGhost\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the translation is only in the 'z' axis\n    if (transform.translation.x == 0.0 && transform.translation.y == 0.0) {\n      // Issue a warning\n      LOG_WARNING(\n          \"The provided transformation is ill-formed when the translation is \"\n          \"only in the 'z' axis. The actor will be spawned with the provided \"\n          \"transformation.\");\n    }\n  }\n\n  // Call the internal function to complete the actor spawning process\n  return SpawnActorWithParentInternal(\n      description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 43.293592974499}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SPRING_ARM ||\n      attachment_type == rpc::AttachmentType::SPRING_ARM_GHOST) {\n    if (transform.translation().x() == 0.0 &&\n        transform.translation().y() == 0.0 &&\n        transform.translation().z() != 0.0) {\n      LOG_WARNING(\"Invalid transformation for attachment type %d, \"\n                  \"using default instead\",\n                  attachment_type);\n    }\n  }\n  return SpawnActorWithParentInternal(description, transform, parent,\n                                      attachment_type, socket_name);\n}", "CodeBleu_score": 39.808639612257295}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n  // Create a new G-buffer subscription request\n  rpc::GBufferSubscriptionRequest request;\n  request.set_actor_id(ActorId);\n  request.set_gbuffer_id(GBufferId);\n\n  // Send the request to the streaming client\n  auto future = streaming_client_->SubscribeToGBuffer(request);\n\n  // Set up a callback to handle the response\n  future.Then([callback](rpc::GBufferSubscriptionResponse response) {\n    // Check if the response contains a token\n    if (response.has_token()) {\n      // Get the token data\n      auto token = response.token();\n      // Copy the token data into a buffer\n      Buffer buffer(token.data(), token.size());\n      // Call the callback with the buffer\n      callback(buffer);\n    }\n  });\n}", "CodeBleu_score": 42.81533908416556}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  rpc::SubscribeToGBufferRequest request;\n  request.set_actor_id(ActorId);\n  request.set_gbuffer_id(GBufferId);\n  auto response = SubscribeToGBuffer(request);\n  if (!response.ok()) {\n    throw std::runtime_error(response.status().error_message());\n  }\n  auto token = response.value();\n  auto buffer = std::make_shared<Buffer>(token.data());\n  SubscribeToGBuffer(buffer, callback);\n}", "CodeBleu_score": 41.97071341489586}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  rpc::SubscribeToGBufferRequest request;\n  request.set_actor_id(ActorId);\n  request.set_g_buffer_id(GBufferId);\n  auto future = stub_->SubscribeToGBuffer(&context_, request);\n  auto status = future.get();\n  if (!status.ok()) {\n    std::cerr << \"SubscribeToGBuffer failed: \" << status.error_message() << std::endl;\n    return;\n  }\n  auto response = future.get();\n  auto token = response.token();\n  Buffer buffer(token.data().begin(), token.data().end());\n  callback(buffer);\n}", "CodeBleu_score": 41.64177757094003}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    std::shared_ptr<WalkerNavigation> navigation = GetNavigation();\n    if (navigation == nullptr) {\n        navigation = std::make_shared<WalkerNavigation>();\n        SetNavigation(navigation);\n    }\n    return navigation;\n}", "CodeBleu_score": 40.60861793774675}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (navigation_ == nullptr) {\n    navigation_ = std::make_shared<WalkerNavigation>();\n  }\n  return navigation_;\n}", "CodeBleu_score": 26.150391574695796}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  std::shared_ptr<WalkerNavigation> navigation;\n  if (!navigation_) {\n    navigation = std::make_shared<WalkerNavigation>();\n    navigation->SetEpisode(shared_from_this());\n    navigation_ = navigation;\n  } else {\n    navigation = navigation_;\n  }\n  return navigation;\n}", "CodeBleu_score": 46.137686173028165}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t    auto start = std::chrono::steady_clock::now();\n    while (episode.GetFrame() < frame) {\n        std::this_thread::yield();\n        if (std::chrono::steady_clock::now() - start > timeout) {\n            return false;\n        }\n    }\n    TrafficManager::Tick();\n    return true;\n}", "CodeBleu_score": 39.18953593337455}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  auto start = high_resolution_clock::now();\n  auto end = start + timeout;\n  while (high_resolution_clock::now() < end) {\n    if (episode.GetFrame() >= frame) {\n      TrafficManager::GetInstance().Tick();\n      return true;\n    }\n    this_thread::yield();\n  }\n  return false;\n}", "CodeBleu_score": 36.42192148655068}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t    auto start = std::chrono::steady_clock::now();\n    auto end = start + timeout;\n\n    while (episode.GetFrame() < frame) {\n        if (std::chrono::steady_clock::now() > end) {\n            return false;\n        }\n\n        std::this_thread::yield();\n    }\n\n    TrafficManager::GetInstance()->Tick();\n\n    return true;\n}", "CodeBleu_score": 44.11371477228601}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    auto episode = std::make_shared<EpisodeProxy>(shared_from_this(), map_name, reset_settings, map_layers);\n    std::string episode_id = episode->GetEpisodeID();\n    int attempts = 0;\n    while (episode_id == GetEpisodeID()) {\n        attempts++;\n        if (attempts > MAX_ATTEMPTS) {\n            throw std::runtime_error(\"Failed to load episode: \" + episode_id);\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(ATTEMPT_INTERVAL_MS));\n        episode_id = episode->GetEpisodeID();\n    }\n    return *episode;\n}", "CodeBleu_score": 40.12561111751624}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    // Check if the episode is already loaded\n    if (episode_id != -1) {\n        throw std::runtime_error(\"Episode is already loaded\");\n    }\n\n    // Load the episode\n    episode_id = rpc.LoadEpisode(map_name, reset_settings, map_layers);\n\n    // Wait for the episode to be ready\n    auto start_time = std::chrono::steady_clock::now();\n    while (episode_id == -1) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        episode_id = rpc.LoadEpisode(map_name, reset_settings, map_layers);\n        if (std::chrono::steady_clock::now() - start_time > std::chrono::seconds(10)) {\n            throw std::runtime_error(\"Failed to load episode within 10 seconds\");\n        }\n    }\n\n    // Return the episode object\n    return EpisodeProxy{shared_from_this()};\n}", "CodeBleu_score": 41.974745746541146}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    int attempts = 0;\n    int episode_id = -1;\n    while (attempts < kMaxAttempts) {\n      if (episode_id != GetEpisodeId()) {\n        episode_id = GetEpisodeId();\n        break;\n      }\n      attempts++;\n      std::this_thread::sleep_for(std::chrono::milliseconds(kAttemptInterval));\n    }\n    if (attempts == kMaxAttempts) {\n      throw std::runtime_error(\"Failed to connect to episode after \" + std::to_string(kMaxAttempts) + \" attempts\");\n    }\n    return EpisodeProxy{shared_from_this()};\n  }", "CodeBleu_score": 28.976403171970023}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  assert(episode != nullptr);\n  auto walker = episode->GetWalker(controller.id);\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker with ID \" + std::to_string(controller.id) + \" not found\");\n  }\n  if (walker->navigation == nullptr) {\n    walker->navigation = std::make_unique<WalkerNavigation>();\n  }\n  walker->navigation->controller = controller;\n}", "CodeBleu_score": 51.866513231062484}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  WalkerPtr walker = GetWalker(controller.GetId());\n  assert(walker != nullptr);\n  assert(episode != nullptr);\n  if (episode->navigation == nullptr) {\n    episode->navigation = std::make_shared<Navigation>();\n  }\n  episode->navigation->RegisterAIController(controller, walker);\n}", "CodeBleu_score": 49.25102243186057}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  assert(episode_ != nullptr);\n  auto walker = GetWalker(controller.GetId());\n  assert(walker != nullptr);\n  if (walker->GetNavigation() == nullptr) {\n    walker->SetNavigation(std::make_unique<WalkerNavigation>());\n  }\n  walker->GetNavigation()->RegisterAIController(controller);\n}", "CodeBleu_score": 51.3392046685877}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    auto actor = SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n    actor->SetGarbageCollectionPolicy(gc);\n    return actor;\n  }", "CodeBleu_score": 24.87012256494101}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    // Check if the blueprint is valid.\n    if (!blueprint.IsValid()) {\n      throw std::runtime_error(\"Invalid blueprint.\");\n    }\n\n    // Create a new actor.\n    auto actor = std::make_shared<Actor>(blueprint, transform, parent,\n                                         attachment_type, socket_name);\n\n    // Register the actor in the current episode.\n    GetReadyCurrentEpisode();\n    auto episode = GetCurrentEpisode();\n    episode->RegisterActor(actor);\n\n    // Apply the garbage collection policy.\n    if (gc == GarbageCollectionPolicy::Always) {\n      episode->CollectGarbage();\n    }\n\n    // Log the creation details.\n    std::stringstream ss;\n    ss << \"Spawned actor \" << actor->GetName() << \" with blueprint \"\n       << blueprint.GetName() << \" at \" << transform.GetTranslation()\n       << \" with parent \" << parent->GetName() << \" with attachment type \"\n       << attachment_type << \" and socket name \" << socket_name;\n    Log(LogLevel::Info, ss.str());\n\n    // Return the new actor.\n    return actor;\n  }", "CodeBleu_score": 44.795794734543165}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    // Check if the blueprint is valid\n    if (!blueprint.IsValid()) {\n      throw std::invalid_argument(\"Invalid blueprint\");\n    }\n\n    // Check if the parent actor is valid\n    if (parent && !parent->IsValid()) {\n      throw std::invalid_argument(\"Invalid parent actor\");\n    }\n\n    // Check if the garbage collection policy is valid\n    if (gc != GarbageCollectionPolicy::AlwaysSpawn &&\n        gc != GarbageCollectionPolicy::CollectExisting &&\n        gc != GarbageCollectionPolicy::NeverSpawn) {\n      throw std::invalid_argument(\"Invalid garbage collection policy\");\n    }\n\n    // Check if the socket name is valid\n    if (!socket_name.empty() &&\n        (attachment_type == rpc::AttachmentType::Socket ||\n         attachment_type == rpc::AttachmentType::SocketOffset)) {\n      if (!blueprint.HasSocket(socket_name)) {\n        throw std::invalid_argument(\"Invalid socket name\");\n      }\n    }\n\n    // Create the actor\n    auto actor = std::make_shared<Actor>(shared_from_this());\n\n    // Spawn the actor\n    actor->Spawn(blueprint, transform, parent, attachment_type, socket_name);\n\n    // Register the actor\n    RegisterActor(actor, gc);\n\n    // Log the actor creation\n    LOG(INFO) << \"Spawned actor: \" << actor->GetName() << \" (\" << actor->GetId() << \")\";\n\n    // Return the actor\n    return actor;\n  }", "CodeBleu_score": 41.448921775524724}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (!episode_) {\n    throw std::runtime_error(\"Episode not running\");\n  }\n  client_->SubscribeToStream(\n      sensor.Name(),\n      [this, callback](const SharedPtr<sensor::SensorData> &data) {\n        data->SetEpisode(episode_);\n        callback(data);\n      });\n}", "CodeBleu_score": 35.523358577662876}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (episode_ == nullptr) {\n    throw std::runtime_error(\"Episode not started.\");\n  }\n  client_->SubscribeToStream(\n      sensor.SensorType(),\n      [this, callback](const std::string &data) {\n        auto sensor_data = sensor::SensorData::FromString(data);\n        sensor_data->SetEpisode(episode_);\n        callback(sensor_data);\n      });\n}", "CodeBleu_score": 43.76400656491409}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (!episode_) {\n    throw std::runtime_error(\"Cannot subscribe to sensor before episode start\");\n  }\n  auto client = client_.lock();\n  if (!client) {\n    throw std::runtime_error(\"Client has been released\");\n  }\n  client->SubscribeToStream(sensor, [callback, this](const std::string &data) {\n    auto sensor_data = sensor::SensorData::Deserialize(data);\n    sensor_data->episode = episode_;\n    callback(sensor_data);\n  });\n}", "CodeBleu_score": 45.71748641568715}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n    // load the walkers\n    std::vector<WalkerHandle> walkers = LoadWalkers();\n\n    // check if the list is empty\n    if (walkers.empty()) return;\n\n    // get the current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // remove any walkers that no longer exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, true);\n\n    // update the crowd itself\n    _nav.UpdateCrowd();\n\n    // for each walker, get their transform and speed\n    for (auto &&walker : walkers) {\n      // get the transform and speed\n      carla::geom::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n      float speed = state->GetActorSnapshot(walker.walker).velocity.Length();\n      // apply the states in a batch\n      _simulator.lock()->ApplyWalkerStates(walker.walker, transform, speed);\n    }\n\n    // check if any walker has been killed\n    for (auto &&walker : walkers) {\n      if (state->GetActorSnapshot(walker.walker).status == ActorStatus::DEAD) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 45.86326508773154}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    // load the walkers\n    std::vector<WalkerHandle> walkers = GetWalkers();\n    // check if empty\n    if (walkers.empty()) return;\n    // get the state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n    // remove any walkers that no longer exist\n    CheckIfWalkerExist(walkers, *state);\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, _show_debug);\n    // update the crowd itself\n    _nav.UpdateCrowd();\n    // for each walker\n    for (auto &&walker : walkers) {\n      // get their transform and speed\n      carla::geom::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n      carla::geom::Vector3D speed = state->GetActorSnapshot(walker.walker).velocity;\n      // apply these states in a batch to the simulator\n      _simulator.lock()->ApplyBatch({\n        carla::rpc::Command::ApplyPhysicsControl {\n          walker.walker,\n          transform,\n          speed,\n          carla::geom::Vector3D(0, 0, 0),\n          carla::geom::Vector3D(0, 0, 0)\n        }\n      });\n    }\n    // check if any walker has been killed\n    CheckIfWalkerKilled(episode, walkers);\n  }", "CodeBleu_score": 41.18790454047384}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    // load the walkers\n    std::vector<WalkerHandle> walkers = GetWalkers();\n    // check if empty\n    if (walkers.empty()) return;\n\n    // get the current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // remove any walkers that no longer exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update the crowd itself\n    _nav.UpdateCrowd();\n\n    // for each walker\n    for (auto &&walker : walkers) {\n      // get the transform\n      carla::geom::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n      // get the speed\n      float speed = state->GetActorSnapshot(walker.walker).velocity.Length();\n      // apply the states in a batch\n      _simulator.lock()->ApplyBatchStates({{walker.walker, transform, speed}}, 0.01f);\n    }\n\n    // check if any walker has been killed\n    for (auto &&walker : walkers) {\n      if (state->GetActorSnapshot(walker.walker).status == ActorStatus::DEAD) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 46.85778965644897}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.set_uid(uid_);\n    description.set_id(id_);\n    description.mutable_attributes()->Reserve(attributes_.size());\n    for (const auto& attribute : attributes_) {\n        description.mutable_attributes()->Add(attribute.MakeActorAttribute());\n    }\n    return description;\n}", "CodeBleu_score": 59.771251439349605}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t", "CodeBleu_score": 4.932770825794737}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.set_uid(uid);\n    description.set_id(id);\n    description.mutable_attributes()->Reserve(attributes.size());\n    for (const auto& attribute : attributes) {\n        description.add_attributes()->CopyFrom(attribute);\n    }\n    return description;\n}", "CodeBleu_score": 61.42735424834789}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  auto result = MakeShared<BlueprintLibrary>();\n\n  for (const auto &blueprint : blueprints_) {\n    if (blueprint->HasAttribute(name)) {\n      const auto &attribute = blueprint->GetAttribute(name);\n\n      if (attribute->IsRecommended()) {\n        const auto &recommended_values = attribute->GetRecommendedValues();\n        if (std::find(recommended_values.begin(), recommended_values.end(), value) != recommended_values.end()) {\n          result->AddBlueprint(blueprint);\n        }\n      } else {\n        if (attribute->GetValue() == value) {\n          result->AddBlueprint(blueprint);\n        }\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 54.05523931245444}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t    SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n    for (const auto& blueprint : blueprints) {\n        if (blueprint->HasAttribute(name)) {\n            const auto& attribute = blueprint->GetAttribute(name);\n            if (attribute->GetValue() == value || attribute->GetRecommendedValues().contains(value)) {\n                result->AddBlueprint(blueprint);\n            }\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 42.53555149078808}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto &blueprint : blueprints_) {\n    if (blueprint->HasAttribute(name)) {\n      const auto& attribute = blueprint->GetAttribute(name);\n      if (attribute.GetValue() == value || attribute.GetRecommendedValues().contains(value)) {\n        result->AddBlueprint(blueprint);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 40.70655405893658}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  std::string fullPath = path + \"/\" + version;\n  if (!ValidatePath(fullPath)) {\n    return false;\n  }\n\n  std::ofstream file(fullPath, std::ios::out | std::ios::binary | std::ios::trunc);\n  if (file.is_open()) {\n    file.write(reinterpret_cast<const char*>(&content[0]), content.size());\n    file.close();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 44.891430012615515}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t  // Construct the full file path using the base folder and version information\n  std::string full_path = path + \"/\" + version;\n\n  // Validate the file path\n  if (!ValidateFilePath(full_path)) {\n    return false;\n  }\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n\n  // Check if the file was successfully opened\n  if (!file.is_open()) {\n    return false;\n  }\n\n  // Write the content to the file\n  file.write(reinterpret_cast<const char*>(content.data()), content.size());\n\n  // Close the file\n  file.close();\n\n  return true;\n}", "CodeBleu_score": 46.66696967679403}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string fullPath = this->baseFolder + path + this->version;\n    if (!this->ValidatePath(fullPath)) {\n        return false;\n    }\n    std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n    file.write(reinterpret_cast<const char*>(content.data()), content.size());\n    file.close();\n    return true;\n}", "CodeBleu_score": 46.31132849403132}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    const geom::Location location = transform.location + parent_->bounds_->location;\n    const float yaw = transform.rotation.yaw * geom::Math::Pi<float>() / 180.0f;\n    const float c = std::cos(yaw);\n    const float s = std::sin(yaw);\n    const geom::Location corners[] = {\n      {c * parent_->bounds_->extents.x + s * parent_->bounds_->extents.y,\n       s * parent_->bounds_->extents.x - c * parent_->bounds_->extents.y,\n       parent_->bounds_->extents.z},\n      {c * parent_->bounds_->extents.x - s * parent_->bounds_->extents.y,\n       s * parent_->bounds_->extents.x + c * parent_->bounds_->extents.y,\n       parent_->bounds_->extents.z},\n      {c * parent_->bounds_->extents.x - s * parent_->bounds_->extents.y,\n       s * parent_-_->bounds_->extents.x + c * parent_->bounds_->extents.y,\n       -parent_->bounds_->extents.z},\n      {c * parent_->bounds_->extents.x + s * parent_->bounds_->extents.y,\n       s * parent_->bounds_->extents.x - c * parent_->bounds_->extents.y,\n       -parent_->bounds_->extents.z}};\n    return std::make_shared<const Bounds>(frame, location, corners);\n  }", "CodeBleu_score": 40.37369387058961}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    const geom::Location location = transform.location + parent_->bounds_->location;\n    const float yaw = transform.rotation.yaw;\n    const geom::Location p1 = Rotate(yaw, {\n        parent_->bounds_->extents.x,\n        parent_->bounds_->extents.y,\n        parent_->bounds_->extents.z});\n    const geom::Location p2 = Rotate(yaw, {\n        parent_->bounds_->extents.x,\n        -parent_->bounds_->extents.y,\n        parent_->bounds_->extents.z});\n    const geom::Location p3 = Rotate(yaw, {\n        -parent_->bounds_->extents.x,\n        parent_->bounds_->extents.y,\n        parent_->bounds_->extents.z});\n    const geom::Location p4 = Rotate(yaw, {\n        -parent_->bounds_->extents.x,\n        -parent_->bounds_->extents.y,\n        parent_->bounds_->extents.z});\n    return std::make_shared<const Bounds>(frame, location, p1, p2, p3, p4);\n  }", "CodeBleu_score": 44.64755488652465}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    // Calculate the location by adding the parent's bounding box location to the transform's location.\n    const geom::Location location = transform.location + parent_->bounds_->location;\n    // Compute the four corners of the bounding box by rotating the extents based on the yaw angle.\n    const geom::Location corners[4] = {\n        Rotate(transform.rotation.yaw, {transform.extents.x / 2.0f, transform.extents.y / 2.0f, 0.0f}),\n        Rotate(transform.rotation.yaw, {transform.extents.x / 2.0f, -transform.extents.y / 2.0f, 0.0f}),\n        Rotate(transform.rotation.yaw, {-transform.extents.x / 2.0f, -transform.extents.y / 2.0f, 0.0f}),\n        Rotate(transform.rotation.yaw, {-transform.extents.x / 2.0f, transform.extents.y / 2.0f, 0.0f})};\n    // Create a shared pointer to a Bounds object containing the frame number and the calculated corners.\n    return std::make_shared<const Bounds>(frame, location, corners);\n  }", "CodeBleu_score": 38.5075298407292}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(lightMutex);\n\n    // Query the current state of lights from the server\n    std::vector<LightState> lightStates = server.GetLightStates();\n\n    // Update the local light states\n    for (const LightState& lightState : lightStates) {\n        // Check if the light already exists in the _lights map\n        auto it = _lights.find(lightState.id);\n        if (it != _lights.end()) {\n            // Update the existing light object\n            it->second->SetState(lightState);\n        } else {\n            // Create a new light object\n            _lights[lightState.id] = std::make_unique<Light>(lightState);\n        }\n    }\n}", "CodeBleu_score": 37.631607119019456}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\n    // Lock the mutex to ensure thread safety\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    // Query the current state of lights from the server\n    std::vector<LightState> lightStates = _server->QueryLightsState();\n\n    // Update the local light states\n    for (const LightState& lightState : lightStates) {\n        if (_lights.find(lightState.GetLightId()) != _lights.end()) {\n            _lights[lightState.GetLightId()]->UpdateState(lightState);\n        } else {\n            _lights[lightState.GetLightId()] = std::make_shared<Light>(lightState);\n        }\n    }\n}", "CodeBleu_score": 33.33137658848168}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(m_mutex);\n    auto lightStates = m_server->GetLightStates();\n    for (auto& lightState : lightStates) {\n        auto light = m_lights.find(lightState.first);\n        if (light == m_lights.end()) {\n            m_lights.insert(std::make_pair(lightState.first, std::make_shared<Light>(lightState.first, lightState.second.color, lightState.second.intensity, m_server, m_mutex)));\n        } else {\n            light->second->SetColor(lightState.second.color);\n            light->second->SetIntensity(lightState.second.intensity);\n        }\n    }\n}", "CodeBleu_score": 39.78040182743506}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(m_mutex);\n    if (m_dirty) {\n        std::vector<std::shared_ptr<Light>> lights;\n        for (auto const& light : m_lights) {\n            lights.push_back(light.second);\n        }\n        std::shared_ptr<LightManager::LightUpdateMessage> message = std::make_shared<LightManager::LightUpdateMessage>(lights);\n        if (!discard_client) {\n            m_server.SendMessage(message);\n        }\n        m_dirty = false;\n    }\n}", "CodeBleu_score": 34.45410939293227}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(m_mutex);\n\n    if (!m_dirty) {\n        return;\n    }\n\n    std::vector<std::shared_ptr<Light>> lights = GetLights();\n    std::vector<LightState> light_states;\n    for (auto light : lights) {\n        LightState light_state;\n        light_state.id = light->GetId();\n        light_state.color = light->GetColor();\n        light_state.intensity = light->GetIntensity();\n        light_state.type = light->GetType();\n        light_states.push_back(light_state);\n    }\n\n    std::shared_ptr<Message> message = std::make_shared<Message>();\n    message->type = MessageType::LIGHT_STATE;\n    message->light_states = light_states;\n\n    if (discard_client) {\n        m_server->SendMessageToClients(message);\n    } else {\n        m_server->SendMessageToServer(message);\n    }\n\n    m_dirty = false;\n}", "CodeBleu_score": 46.35920390587563}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    if (dirty) {\n        std::lock_guard<std::mutex> lock(mutex);\n        if (dirty) {\n            std::vector<uint8_t> data;\n            data.reserve(lights.size() * 2);\n            for (auto& light : lights) {\n                data.push_back(light.first);\n                data.push_back(light.second.state);\n            }\n            if (discard_client) {\n                data.push_back(0xFF);\n            }\n            auto message = std::make_shared<Message>(MessageType::LIGHT_UPDATE, data);\n            Server::GetInstance().SendMessage(message);\n            dirty = false;\n            changes.clear();\n        }\n    }\n}", "CodeBleu_score": 42.241450772251596}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  if (sensor_id_ != \"sensor.other.v2x_custom\") {\n    LOG(WARNING) << \"Sensor ID does not match, ignoring message.\";\n    return;\n  }\n\n  context_->Send(message);\n}", "CodeBleu_score": 39.64263903602683}, {"code": "void ServerSideSensor::Send(std::string message){\n\t    if (sensor_id_ != \"sensor.other.v2x_custom\") {\n        LOG_WARNING(\"Sensor ID does not match\");\n        return;\n    }\n    context_->Send(message);\n}", "CodeBleu_score": 41.80578522521676}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (sensor_id_ != \"sensor.other.v2x_custom\") {\n    LOG(WARNING) << \"Sensor ID does not match. Expected: sensor.other.v2x_custom, Got: \" << sensor_id_;\n    return;\n  }\n  episode_->Send(message);\n}", "CodeBleu_score": 42.75830984000854}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\n    if (enabled) {\n        // Register vehicle with traffic manager\n        // Send registration message to traffic manager\n        // Receive registration response from traffic manager\n        // Update vehicle state\n    } else {\n        // Unregister vehicle from traffic manager\n        // Send unregistration message to traffic manager\n        // Receive unregistration response from traffic manager\n        // Update vehicle state\n    }\n}", "CodeBleu_score": 16.382264261711352}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    // Create a message to send to the vehicle\n    MAVLinkCommandLong command;\n    command.command = MAV_CMD_DO_SET_MODE;\n    command.param1 = MAV_MODE_AUTO_DISARMED;\n    command.param2 = MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;\n    command.param3 = 0;\n    command.param4 = 0;\n    command.param5 = 0;\n    command.param6 = 0;\n    command.param7 = 0;\n    command.target_system = m_system_id;\n    command.target_component = MAV_COMP_ID_ALL;\n    command.confirmation = true;\n\n    // Send the command to the vehicle\n    m_mavlink_comm->SendCommandLong(command);\n\n    // Wait for the vehicle to confirm the command\n    while (!m_mavlink_comm->IsCommandComplete()) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n\n    // If the autopilot is enabled, register the vehicle with the traffic manager\n    if (enabled) {\n        m_tm_comm->RegisterVehicle(m_system_id, tm_port);\n    } else {\n        m_tm_comm->UnregisterVehicle(m_system_id);\n    }\n}", "CodeBleu_score": 36.069482708253986}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        if (tm_port == 0) {\n            tm_port = GetTrafficManagerPort();\n        }\n        if (tm_port == 0) {\n            std::cout << \"Error: No traffic manager port specified\" << std::endl;\n            return;\n        }\n        RegisterVehicle(tm_port);\n    } else {\n        UnregisterVehicle();\n    }\n}", "CodeBleu_score": 36.46814097965017}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t    // Get the walker actor\n    AActor* walkerActor = GetWorld()->SpawnActor<AActor>(walkerClass);\n    if (!walkerActor) {\n        UE_LOG(LogTemp, Error, TEXT(\"Failed to spawn walker actor\"));\n        return;\n    }\n\n    // Add the walker actor to the navigation system\n    UNavigationSystemV1* navSystem = UNavigationSystemV1::GetCurrent(GetWorld());\n    if (navSystem) {\n        FNavLocation navLocation;\n        if (navSystem->GetRandomPointInNavigableRadius(walkerActor->GetActorLocation(), 500.0f, navLocation)) {\n            walkerActor->SetActorLocation(navLocation.Location);\n            navSystem->Add(walkerActor);\n        }\n    }\n\n    // Disable the physics simulation and collisions for the walker actor\n    UPrimitiveComponent* walkerComp = walkerActor->FindComponentByClass<UPrimitiveComponent>();\n    if (walkerComp) {\n        walkerComp->SetSimulatePhysics(false);\n        walkerComp->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n    }\n\n    // Set the walker actor as the target for the AI controller\n    AIController->SetTarget(walkerActor);\n}", "CodeBleu_score": 33.862216075100285}, {"code": "void WalkerAIController::Start(){\n\t    Super::Start();\n    \n    Walker = Cast<AWalker>(GetPawn());\n    if (!Walker) {\n        UE_LOG(LogTemp, Error, TEXT(\"WalkerAIController::Start: Walker is null\"));\n        return;\n    }\n    \n    // Add the walker to the navigation system\n    if (UNavigationSystemV1* NavSystem = UNavigationSystemV1::GetCurrent(GetWorld())) {\n        FNavLocation NavLocation;\n        if (NavSystem->GetRandomReachablePointInRadius(Walker->GetActorLocation(), 1000.0f, NavLocation)) {\n            NavSystem->Add(Walker, NavLocation.Location);\n        }\n    }\n    \n    // Disable physics simulation and collisions for the walker actor\n    Walker->GetMesh()->SetSimulatePhysics(false);\n    Walker->GetMesh()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}", "CodeBleu_score": 39.969974774331696}, {"code": "void WalkerAIController::Start(){\n\t    Super::Start();\n    \n    WalkerActor = Cast<AWalkerActor>(GetPawn());\n    if (WalkerActor) {\n        NavSys->RegisterActor(WalkerActor, WalkerActor->GetActorLocation());\n        WalkerActor->GetStaticMeshComponent()->SetSimulatePhysics(false);\n        WalkerActor->GetStaticMeshComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n    }\n}", "CodeBleu_score": 36.32219139709313}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t    // Get the navigation instance from the current episode\n    auto* navigation_instance = GetEpisode()->GetNavigation();\n    if (navigation_instance) {\n        // Get the parent walker\n        auto* walker = GetParent();\n        if (walker) {\n            // Set the maximum speed using the navigation instance\n            if (!navigation_instance->SetWalkerMaxSpeed(walker, max_speed)) {\n                Logging::Warning(\"Failed to set maximum speed for walker\");\n            }\n        } else {\n            Logging::Warning(\"Walker not found\");\n        }\n    } else {\n        Logging::Warning(\"Navigation instance not found\");\n    }\n}", "CodeBleu_score": 52.72196143249205}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t    // Get the navigation instance from the current episode\n    auto* nav_instance = GetEpisode().GetNavmesh();\n    if (!nav_instance) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation instance not found for walker\"));\n        return;\n    }\n\n    // Get the parent walker\n    auto* walker = GetPawn<AWalker>();\n    if (!walker) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Walker not found for walker AI controller\"));\n        return;\n    }\n\n    // Attempt to set the maximum speed using the navigation instance\n    if (!nav_instance->SetMaxSpeed(walker, max_speed)) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Failed to set maximum speed for walker\"));\n    }\n}", "CodeBleu_score": 45.97871170949889}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t    // Get the navigation instance from the current episode\n    auto* navigation = GetEpisode().GetNavigation();\n    if (!navigation) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation instance not found in current episode\"));\n        return;\n    }\n\n    // Get the parent walker\n    auto* walker = GetParent();\n    if (!walker) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Parent walker not found\"));\n        return;\n    }\n\n    // Attempt to set the maximum speed using the navigation instance\n    if (!navigation->SetWalkerMaxSpeed(walker, max_speed)) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Failed to set walker maximum speed\"));\n    }\n}", "CodeBleu_score": 51.21002468021339}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> waypoints = parentMap->GetPrevious(id, distance);\n    for (auto waypoint : waypoints) {\n        result.push_back(std::make_shared<Waypoint>(waypoint->id, waypoint->latitude, waypoint->longitude, waypoint->elevation, waypoint->name, waypoint->description, waypoint->parentMap));\n    }\n    return result;\n}", "CodeBleu_score": 55.42632886821932}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prevWaypoints = map->GetPrevious(id, distance);\n    for (auto prevWaypoint : prevWaypoints) {\n        result.push_back(SharedPtr<Waypoint>(new Waypoint(prevWaypoint->GetId(), map)));\n    }\n    return result;\n}", "CodeBleu_score": 58.87468069505501}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> waypoints = GetParentMap()->GetPrevious(GetPosition(), distance);\n    for (const auto& waypoint : waypoints) {\n        result.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint->GetPosition(), waypoint->GetParentMap())));\n    }\n    return result;\n}", "CodeBleu_score": 59.802831934084054}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  // Get all signals within the specified distance\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(\n      distance, stop_at_junction);\n\n  // Create a set to store unique signals\n  std::set<SharedPtr<Signal>> unique_signals;\n\n  // Add each signal to the set\n  for (const auto& signal : signals) {\n    unique_signals.insert(signal);\n  }\n\n  // Create a vector to store the landmarks\n  std::vector<SharedPtr<Landmark>> landmarks;\n\n  // Create a landmark for each unique signal\n  for (const auto& signal : unique_signals) {\n    // Create a new landmark\n    SharedPtr<Landmark> landmark = std::make_shared<Landmark>();\n\n    // Set the landmark's signal\n    landmark->SetSignal(signal);\n\n    // Add the landmark to the vector\n    landmarks.push_back(landmark);\n  }\n\n  // Return the vector of landmarks\n  return landmarks;\n}", "CodeBleu_score": 42.059423225182734}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  std::vector<SharedPtr<Landmark>> landmarks;\n  std::set<SharedPtr<Signal>> unique_signals;\n  for (const auto& signal : signals) {\n    unique_signals.insert(signal);\n  }\n  for (const auto& signal : unique_signals) {\n    SharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(signal));\n    landmarks.push_back(landmark);\n  }\n  return landmarks;\n}", "CodeBleu_score": 37.053584577036546}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> landmarks;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::vector<SharedPtr<Signal>> unique_signals;\n  std::vector<SharedPtr<Signal>>::iterator it;\n  for (it = signals.begin(); it != signals.end(); ++it) {\n    if (std::find(unique_signals.begin(), unique_signals.end(), *it) == unique_signals.end()) {\n      unique_signals.push_back(*it);\n    }\n  }\n  for (it = unique_signals.begin(); it != unique_signals.end(); ++it) {\n    SharedPtr<Waypoint> waypoint = SharedPtr<Waypoint>(new Waypoint(*it));\n    SharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(waypoint));\n    landmarks.push_back(landmark);\n  }\n  return landmarks;\n}", "CodeBleu_score": 45.59255137710011}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  time_duration local_timeout = timeout.milliseconds() == 0 ?\n      _episode.Lock()->GetNetworkingTimeout() : timeout;\n  if (settings.fixed_delta_time() > 0.0) {\n    // Verify the fixed delta time.\n    time_duration delta_time = boost::posix_time::milliseconds(static_cast<int>(1000.0 * settings.fixed_delta_time()));\n    int attempts = 0;\n    while (true) {\n      _episode.Lock()->Tick(local_timeout);\n      time_duration actual_delta_time = _episode.Lock()->GetLastTickDuration();\n      if (actual_delta_time < delta_time) {\n        if (++attempts > 10) {\n          LOG(WARNING) << \"Fixed delta time of \" << settings.fixed_delta_time() << \"s was not applied.\";\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  return _episode.Lock()->ApplySettings(settings);\n}", "CodeBleu_score": 43.59993587763874}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t  time_duration local_timeout = timeout.milliseconds() == 0 ?\n      _episode.Lock()->GetNetworkingTimeout() : timeout;\n  uint64_t identifier = _episode.Lock()->ApplySettings(settings);\n  if (settings.fixed_delta_time() > 0.0) {\n    // Verify that the fixed delta time is correct.\n    time_duration dt = time_duration::from_milliseconds(\n        static_cast<int>(1000.0 * settings.fixed_delta_time()));\n    int attempts = 0;\n    while (attempts < 5) {\n      time_duration start = system_clock::now();\n      _episode.Lock()->Tick(local_timeout);\n      time_duration end = system_clock::now();\n      time_duration elapsed = end - start;\n      if (elapsed < dt) {\n        attempts++;\n        continue;\n      }\n      if (elapsed > dt) {\n        LOG(WARNING) << \"Fixed delta time is too slow. Expected \" << dt.total_milliseconds()\n                     << \"ms, got \" << elapsed.total_milliseconds() << \"ms.\";\n      }\n      break;\n    }\n  }\n  return identifier;\n}", "CodeBleu_score": 52.515812683052076}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->ApplySettings(settings, local_timeout);\n  }", "CodeBleu_score": 21.214472503936147}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    std::pair<float, float> const& segmentStart,\n    std::pair<float, float> const& segmentEnd,\n    std::pair<float, float> const& point\n}", "CodeBleu_score": 10.695465046022738}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat const & pointX,\n\tfloat const & pointY,\n\tfloat const & pointZ,\n\tfloat const & segmentStartX,\n\tfloat const & segmentStartY,\n\tfloat const & segmentStartZ,\n\tfloat const & segmentEndX,\n\tfloat const & segmentEndY,\n\tfloat const & segmentEndZ\n}", "CodeBleu_score": 20.296266403442182}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t  float x1, float y1, float x2, float y2, float x3, float y3, float *distance\n}", "CodeBleu_score": 6.748104791376437}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    assert(vertices.size() >= 3);\n    const index_type initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 50.46251375644118}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    assert(vertices.size() >= 3);\n    size_t initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; i++) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 50.730395383654525}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    assert(vertices.size() >= 3);\n    const index_type initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 2; i < vertices.size(); ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i - 1);\n      AddIndex(initial_index + i);\n    }\n  }", "CodeBleu_score": 50.36331081058727}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (!message) {\n    return;\n  }\n  auto self = shared_from_this();\n  _strand.post([self, message]() {\n    if (self->_socket.is_open()) {\n      boost::asio::deadline_timer timer(self->_strand);\n      timer.expires_from_now(boost::posix_time::seconds(1));\n      timer.async_wait([self, message](const boost::system::error_code &error) {\n        if (!error) {\n          boost::asio::async_write(self->_socket, boost::asio::buffer(message->data),\n                                   [self, message](const boost::system::error_code &error, std::size_t) {\n                                     self->_strand.post([self, message, error]() {\n                                       self->HandleSent(message, error);\n                                     });\n                                   });\n        } else {\n          self->_strand.post([self, message, error]() {\n            self->HandleSent(message, error);\n          });\n        }\n      });\n    } else {\n      self->_strand.post([self, message]() {\n        self->HandleSent(message, boost::asio::error::not_connected);\n      });\n    }\n  });\n}", "CodeBleu_score": 44.424242155616184}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (!message) {\n    return;\n  }\n  strand.post([this, message]() {\n    if (socket.is_open()) {\n      boost::asio::deadline_timer timer(socket.get_executor());\n      timer.expires_after(std::chrono::seconds(1));\n      timer.async_wait([this, message](const boost::system::error_code &ec) {\n        if (!ec) {\n          boost::asio::async_write(socket, boost::asio::buffer(message->GetData()),\n                                   [this, message](const boost::system::error_code &ec, size_t) {\n                                     HandleSent(ec, message);\n                                   });\n        } else {\n          HandleSent(ec, message);\n        }\n      });\n    }\n  });\n}", "CodeBleu_score": 37.30910110431297}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t  if (message == nullptr) {\n    throw std::invalid_argument(\"nullptr message\");\n  }\n  _strand.post([this, message]() {\n    if (!_socket.is_open()) {\n      return;\n    }\n    boost::asio::deadline_timer timer(_socket.get_executor());\n    timer.expires_after(std::chrono::seconds(5));\n    timer.async_wait([this](const boost::system::error_code &error) {\n      if (!error) {\n        _socket.close();\n      }\n    });\n    boost::asio::async_write(_socket, boost::asio::buffer(message->data),\n                             boost::asio::bind_executor(_strand, [this](const boost::system::error_code &error, size_t) {\n                               timer.cancel();\n                               if (error) {\n                                 std::cerr << \"write error: \" << error.message() << std::endl;\n                                 _socket.close();\n                               }\n                             }));\n  });\n}", "CodeBleu_score": 40.498798191257556}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if (!ec) {\n    // If we get an error, just log it.\n    if (ec)\n      Log(ec, \"close\");\n\n    // Close the socket if it is open.\n    if (socket_.is_open()) {\n      boost::system::error_code ec;\n      socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n      socket_.close(ec);\n    }\n  }\n\n  // Trigger the on_closed callback.\n  on_closed();\n\n  // Log that the session has been closed.\n  Log(\"Session closed\");\n}", "CodeBleu_score": 58.61290886688254}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  if (ec) {\n    Logger::Log(Logger::LogLevel::ERROR, \"Error closing socket: \" + ec.message());\n  } else {\n    Logger::Log(Logger::LogLevel::INFO, \"Closing socket\");\n    // Close the socket\n    boost::system::error_code ignored_ec;\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n    socket_.close(ignored_ec);\n  }\n\n  // Trigger the on_closed callback\n  if (on_closed_) {\n    on_closed_();\n  }\n}", "CodeBleu_score": 48.71972747303469}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  // Cancel the deadline timer.\n  deadline_.cancel();\n\n  // Close the socket if it is open.\n  if (socket_.is_open()) {\n    boost::system::error_code ignored_ec;\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n    socket_.close(ignored_ec);\n  }\n\n  // If an error code was provided to the function,\n  // notify the user.\n  if (ec) {\n    std::cerr << \"Primary::CloseNow: \" << ec.message() << std::endl;\n  }\n\n  // Trigger the on_closed callback.\n  on_closed_();\n\n  // Log that the session has been closed.\n  std::cout << \"Primary::CloseNow: Session closed\" << std::endl;\n}", "CodeBleu_score": 54.746553666011245}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar buffer[100];\n\tsprintf(buffer, \"%s\", \"Are you alive?\");\n\tlogger->LogSend(buffer);\n\tWriteToNextRouter(YOU_ALIVE);\n\tReadFromNextRouter();\n}", "CodeBleu_score": 19.038995157537723}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar buffer[MAX_MESSAGE_SIZE];\n\tstrcpy(buffer, \"Are you alive?\");\n\tLogging::Log(Logging::LogLevel::INFO, \"Sending \\\"Are you alive?\\\" to next router\");\n\tWriteToNextRouter(buffer, YOU_ALIVE);\n\tLogging::Log(Logging::LogLevel::INFO, \"Waiting for response from next router\");\n\tchar* response = ReadFromNextRouter();\n\tLogging::Log(Logging::LogLevel::INFO, \"Received response from next router: %s\", response);\n}", "CodeBleu_score": 34.94167369300627}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t    char buffer[1024];\n    int bufferSize;\n    int result;\n    int routerId;\n\n    // Create a buffer from the message\n    bufferSize = sprintf(buffer, \"Are you alive?\");\n\n    // Log the sending action\n    Logger::Log(Logger::INFO, \"Sending message: %s\", buffer);\n\n    // Write the buffer to the next router with the command YOU_ALIVE\n    routerId = Network::GetNextRouterId();\n    result = Network::WriteToRouter(routerId, buffer, bufferSize, Network::YOU_ALIVE);\n\n    // Check if the writing was successful\n    if (result != Network::SUCCESS) {\n        // Log the error\n        Logger::Log(Logger::ERROR, \"Failed to send message: %s\", buffer);\n        return;\n    }\n\n    // Wait for and log the response from the system\n    result = Network::ReadFromRouter(routerId, buffer, sizeof(buffer), Network::YOU_ALIVE);\n    if (result != Network::SUCCESS) {\n        // Log the error\n        Logger::Log(Logger::ERROR, \"Failed to receive response from router %d\", routerId);\n        return;\n    }\n    Logger::Log(Logger::INFO, \"Received response from router %d: %s\", routerId, buffer);\n}", "CodeBleu_score": 35.89512037435172}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    // Create a buffer to send the command to the secondary server\n    std::vector<uint8_t> buffer;\n    buffer.push_back(static_cast<uint8_t>(sensor_id));\n    buffer.push_back(static_cast<uint8_t>(CommandType::ENABLE_ROS));\n\n    // Send the command to the secondary server\n    router->Send(buffer, secondary_server_address);\n\n    // Wait for and process the server's response\n    std::vector<uint8_t> response = router->Receive();\n    if (response.size() > 0 && response[0] == static_cast<uint8_t>(CommandType::ENABLE_ROS)) {\n        // If the server responds with an ENABLE_ROS command, it means that the sensor was found on the server\n        // and the ROS interface was enabled successfully\n        std::cout << \"Sensor \" << static_cast<int>(sensor_id) << \" enabled for ROS\" << std::endl;\n    } else {\n        // If the server does not respond with an ENABLE_ROS command, it means that the sensor was not found on the server\n        // and the ROS interface could not be enabled\n        std::cerr << \"Error: Sensor \" << static_cast<int>(sensor_id) << \" not found on secondary server\" << std::endl;\n    }\n}", "CodeBleu_score": 46.56323207272277}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    // Check if the sensor is activated on any secondary server\n    for (auto const& server : secondary_servers) {\n        if (server.second.sensor_ids.find(sensor_id) != server.second.sensor_ids.end()) {\n            // Create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router\n            buffer_t buffer = create_buffer(sensor_id, ENABLE_ROS);\n            router.Send(buffer, server.first);\n\n            // Wait for and process the server's response\n            buffer = router.Receive(server.first);\n            if (buffer.command == ENABLE_ROS_ACK) {\n                // The sensor was enabled on the server\n                std::cout << \"Sensor \" << sensor_id << \" enabled on server \" << server.first << std::endl;\n            } else {\n                // The sensor was not enabled on the server\n                std::cout << \"Failed to enable sensor \" << sensor_id << \" on server \" << server.first << std::endl;\n            }\n            return;\n        }\n    }\n\n    // The sensor was not found on any server\n    std::cout << \"Error: Sensor \" << sensor_id << \" not found on any server\" << std::endl;\n}", "CodeBleu_score": 45.09073183735867}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\n    // Create a buffer to send the sensor ID to the secondary server\n    char buffer[256];\n    sprintf(buffer, \"%d\", sensor_id);\n\n    // Check if the sensor is activated on any secondary server\n    bool found = false;\n    for (int i = 0; i < secondary_servers.size(); i++) {\n        if (secondary_servers[i].activated_sensors.count(sensor_id) > 0) {\n            found = true;\n            break;\n        }\n    }\n\n    // If the sensor is not found on any server, log an error message\n    if (!found) {\n        std::cout << \"Error: Sensor \" << sensor_id << \" not found on any secondary server\" << std::endl;\n        return;\n    }\n\n    // Send an ENABLE_ROS command to the server using the router\n    router->SendCommand(buffer, \"ENABLE_ROS\", secondary_servers[i].address, secondary_servers[i].port);\n\n    // Wait for and process the server's response\n    std::string response = router->ReceiveResponse(secondary_servers[i].address, secondary_servers[i].port);\n    if (response == \"OK\") {\n        std::cout << \"Sensor \" << sensor_id << \" enabled for ROS\" << std::endl;\n    } else {\n        std::cout << \"Error: Failed to enable sensor \" << sensor_id << \" for ROS\" << std::endl;\n    }\n}", "CodeBleu_score": 45.20635721286171}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  if (_sensor_map.find(sensor_id) != _sensor_map.end()) {\n    log_info(\"sensor is already activated\");\n    return _sensor_map[sensor_id];\n  }\n  log_info(\"sensor is not activated\");\n  token_type new_token = SendGetToken(sensor_id);\n  _sensor_map[sensor_id] = new_token;\n  log_info(\"added sensor to map\");\n  return new_token;\n}", "CodeBleu_score": 40.7246857405449}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  if (sensor_id == carla::streaming::detail::INVALID_STREAM_ID) {\n    log_error(\"Invalid sensor id\");\n    return token_type(carla::streaming::detail::INVALID_STREAM_ID, carla::streaming::detail::INVALID_PORT);\n  }\n\n  if (_token_map.count(sensor_id)) {\n    log_info(\"sensor already activated\");\n    return _token_map[sensor_id];\n  }\n\n  log_info(\"sensor not activated, enabling\");\n  token_type new_token = SendGetToken(sensor_id);\n  _token_map[sensor_id] = new_token;\n  _sensor_map[new_token] = sensor_id;\n\n  return new_token;\n}", "CodeBleu_score": 43.42025378204504}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  log_info(\"getting a token for sensor \", sensor_id);\n  if (_tokens.count(sensor_id)) {\n    log_info(\"sensor \", sensor_id, \" is already enabled\");\n    return _tokens[sensor_id];\n  }\n\n  auto new_token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = new_token;\n  log_info(\"sensor \", sensor_id, \" enabled\");\n  return new_token;\n}", "CodeBleu_score": 38.83817864843439}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.74225201289511}, {"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.74225201289511}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f;\n  std::istream_iterator<uint8_t> start(f), end;\n\n  // read the whole file\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> content(start, end);\n  f.close();\n\n  // parse the content\n  return Load(std::move(content));\n}", "CodeBleu_score": 99.76847140907317}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  // Check if the system is ready\n  if (!ready) {\n    return false;\n  }\n\n  // Assert the crowd object is not null\n  if (!crowd) {\n    return false;\n  }\n\n  // Search for the agent id in the walker and vehicle mappings\n  auto walkerIt = walkerMap.find(id);\n  auto vehicleIt = vehicleMap.find(id);\n\n  // If found, enter a critical section to safely remove the agent from the crowd\n  if (walkerIt != walkerMap.end()) {\n    std::lock_guard<std::mutex> lock(mutex);\n    crowd->removeWalker(walkerIt->second);\n    walkerMap.erase(walkerIt);\n  } else if (vehicleIt != vehicleMap.end()) {\n    std::lock_guard<std::mutex> lock(mutex);\n    crowd->removeVehicle(vehicleIt->second);\n    vehicleMap.erase(vehicleIt);\n  } else {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 55.676718149916326}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  assert(m_crowd != nullptr);\n  assert(m_walkerManager != nullptr);\n  assert(m_vehicleManager != nullptr);\n\n  bool result = false;\n\n  if (m_ready) {\n    // Enter a critical section to safely remove the agent from the crowd\n    {\n      std::lock_guard<std::mutex> lock(m_mutex);\n\n      // Search for the agent id in the walker and vehicle mappings\n      auto walkerIt = m_walkerMapping.find(id);\n      if (walkerIt != m_walkerMapping.end()) {\n        // Remove the agent from the walker manager\n        m_walkerManager->Remove(walkerIt->second);\n        m_walkerMapping.erase(walkerIt);\n        result = true;\n      } else {\n        auto vehicleIt = m_vehicleMapping.find(id);\n        if (vehicleIt != m_vehicleMapping.end()) {\n          // Remove the agent from the vehicle manager\n          m_vehicleManager->Remove(vehicleIt->second);\n          m_vehicleMapping.erase(vehicleIt);\n          result = true;\n        }\n      }\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 51.04277471293366}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t  bool result = false;\n\n  // Check if the system is ready\n  if (!IsReady()) {\n    return result;\n  }\n\n  // Assert the crowd object is not null\n  if (m_crowd == nullptr) {\n    return result;\n  }\n\n  // Search for the agent id in the walker and vehicle mappings\n  auto walker_it = m_walker_mapping.find(id);\n  auto vehicle_it = m_vehicle_mapping.find(id);\n\n  if (walker_it != m_walker_mapping.end()) {\n    // Enter a critical section to safely remove the agent from the crowd\n    {\n      tthread::lock_guard<tthread::mutex> lock(m_mutex);\n\n      // Remove the agent from the crowd\n      m_crowd->removeAgent(walker_it->second);\n\n      // Update the walker manager\n      m_walker_manager->RemoveAgent(id);\n\n      // Remove the id from the mappings\n      m_walker_mapping.erase(walker_it);\n    }\n\n    result = true;\n  } else if (vehicle_it != m_vehicle_mapping.end()) {\n    // Enter a critical section to safely remove the agent from the crowd\n    {\n      tthread::lock_guard<tthread::mutex> lock(m_mutex);\n\n      // Remove the agent from the crowd\n      m_crowd->removeAgent(vehicle_it->second);\n\n      // Update the vehicle manager\n      m_vehicle_manager->RemoveAgent(id);\n\n      // Remove the id from the mappings\n      m_vehicle_mapping.erase(vehicle_it);\n    }\n\n    result = true;\n  }\n\n  return result;\n}", "CodeBleu_score": 56.71699345887431}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // get the ids of the mapped vehicles\n    std::unordered_set<ActorId> mapped_vehicles_ids;\n    for (auto &it : _mapped_vehicles_id) {\n      mapped_vehicles_ids.insert(it.first);\n    }\n\n    // for each vehicle\n    for (auto &vehicle : vehicles) {\n      // add or update\n      if (!AddOrUpdateVehicle(vehicle)) {\n        return false;\n      }\n      // mark as updated\n      mapped_vehicles_ids.erase(vehicle.id);\n    }\n\n    // remove unmapped vehicles\n    for (auto &id : mapped_vehicles_ids) {\n      if (!RemoveAgent(id)) {\n        return false;\n      }\n    }\n\n    return true;\n  }", "CodeBleu_score": 47.97478309252072}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  bool result = false;\n  auto actor = GetActor(id);\n  if (!actor) {\n    return false;\n  }\n  auto transform = actor->GetTransform();\n  auto location = transform.location;\n  auto rotation = transform.rotation;\n  auto actor_id = actor->GetId();\n  {\n    std::lock_guard<std::mutex> lock(_mutex);\n    auto actor_id_hash = std::hash<ActorId>{}(actor_id);\n    auto it = _walkers.find(actor_id_hash);\n    if (it != _walkers.end()) {\n      auto walker = it->second;\n      auto walker_location = walker->GetLocation();\n      auto walker_distance = (location - walker_location).LengthSquared();\n      if (walker_distance <= distance * distance) {\n        result = true;\n      }\n    }\n    if (!result) {\n      auto vehicle = _vehicles.find(actor_id_hash);\n      if (vehicle != _vehicles.end()) {\n        auto vehicle_location = vehicle->second->GetLocation();\n        auto vehicle_distance = (location - vehicle_location).LengthSquared();\n        if (vehicle_distance <= distance * distance) {\n          auto vehicle_rotation = vehicle->second->GetTransform().rotation;\n          auto angle = rotation.GetSignedAngle(vehicle_rotation);\n          if (std::abs(angle) <= distance) {\n            result = true;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 50.767151868038404}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  RoutePoint *routePoint = info.GetCurrentRoutePoint();\n  WalkerEventVisitor visitor(info.GetContext(), delta);\n  return boost::variant2::visit(visitor, routePoint->GetEvent());\n}", "CodeBleu_score": 49.06537093575072}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  RoutePoint *routePoint = info.GetRoutePoint();\n  WalkerEventVisitor visitor(info, delta);\n  return boost::apply_visitor(visitor, routePoint->GetEvent());\n}", "CodeBleu_score": 41.37989043082428}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  // Get the current route point for the walker\n  RoutePoint &route_point = info.GetCurrentRoutePoint();\n\n  // Create a WalkerEventVisitor with the current context\n  WalkerEventVisitor visitor(id, info, delta);\n\n  // Use the visitor to process the event at the current route point\n  return boost::variant2::visit(visitor, route_point.GetEvent());\n}", "CodeBleu_score": 46.04099699995162}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.children(\"road\")) {\n    const int id = road_node.attribute(\"id\").as_int();\n    const pugi::xml_node lanes_node = road_node.child(\"lanes\");\n    for (pugi::xml_node lane_section_node : lanes_node.children(\"laneSection\")) {\n      const double s = lane_section_node.attribute(\"s\").as_double();\n      ParseLanes(id, lane_section_node, s, map_builder);\n    }\n  }\n}", "CodeBleu_score": 40.183170522035184}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t  for (pugi::xml_node road_node : xml.children(\"road\")) {\n    const int road_id = road_node.attribute(\"id\").as_int();\n    pugi::xml_node lanes_node = road_node.child(\"lanes\");\n    if (lanes_node) {\n      for (pugi::xml_node lane_section_node : lanes_node.children(\"laneSection\")) {\n        const double s = lane_section_node.attribute(\"s\").as_double();\n        pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n        pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n        pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n        if (left_lane_node) {\n          ParseLanes(road_id, s, left_lane_node, map_builder);\n        }\n        if (center_lane_node) {\n          ParseLanes(road_id, s, center_lane_node, map_builder);\n        }\n        if (right_lane_node) {\n          ParseLanes(road_id, s, right_lane_node, map_builder);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 74.5471343051991}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    std::lock_guard<std::mutex> guard(m_mutex);\n\n    if (info.current_count_change == 1) {\n        m_matched = true;\n        m_first_connection = true;\n    } else if (info.current_count_change == -1) {\n        m_matched = false;\n    } else {\n        std::cout << \"ERROR: on_publication_matched: unexpected count change \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 60.812094082756275}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.total_count_change == 1) {\n        matched_ = true;\n        matched_count_ = info.total_count;\n        std::cout << \"CarlaListenerImpl::on_publication_matched: \" << matched_count_ << \" matched.\" << std::endl;\n    } else if (info.total_count_change == -1) {\n        matched_count_ = info.total_count;\n        std::cout << \"CarlaListenerImpl::on_publication_matched: \" << matched_count_ << \" matched.\" << std::endl;\n    } else {\n        std::cout << \"CarlaListenerImpl::on_publication_matched: Invalid count change \" << info.total_count_change << \".\" << std::endl;\n    }\n}", "CodeBleu_score": 57.734593232855545}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.total_count_change == 1) {\n        if (matched_ == false) {\n            matched_ = true;\n            first_connection_ = true;\n        }\n    } else if (info.total_count_change == -1) {\n        if (matched_ == true) {\n            matched_ = false;\n        }\n    } else {\n        std::cout << \"Invalid publication match count change: \" << info.total_count_change << std::endl;\n    }\n}", "CodeBleu_score": 53.40610329498342}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_ = true;\n        first_connected_ = true;\n    } else if (info.current_count_change == -1) {\n        matched_ = false;\n        if (info.total_count == 0) {\n            destroy_subscriber();\n        }\n    } else {\n        std::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: \"\n                  << \"Invalid current count change: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 62.35511261514013}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_ = true;\n        first_connected_ = true;\n    } else if (info.current_count_change == -1) {\n        matched_ = false;\n        if (info.total_count == 0) {\n            if (subscriber_ != nullptr) {\n                subscriber_->destroy();\n                subscriber_ = nullptr;\n            }\n        }\n    } else {\n        std::cerr << \"ERROR: Subscription count changed by \" << info.current_count_change << \" this should not happen.\" << std::endl;\n    }\n}", "CodeBleu_score": 61.222758932960375}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched\" << std::endl;\n    if (info.current_count_change == 1) {\n        matched_count_++;\n        if (first_connected_ == false) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_count_--;\n        if (matched_count_ == 0 && first_connected_ == true) {\n            std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched - unmatched\" << std::endl;\n            subscriber_.reset();\n        }\n    } else {\n        std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched - invalid count change\" << std::endl;\n    }\n}", "CodeBleu_score": 52.09943116401363}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t", "CodeBleu_score": 2.19844869077013}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t", "CodeBleu_score": 2.19844869077013}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    CarlaCollisionEvent* myData = (CarlaCollisionEvent*) data;\n    if(!CarlaCollisionEventPubSubType::m_md5) {\n        CarlaCollisionEventPubSubType::m_md5 = new unsigned char[MD5_LENGTH];\n    }\n    if(!CarlaCollisionEventPubSubType::m_keyBuffer) {\n        CarlaCollisionEventPubSubType::m_keyBuffer = new char[256];\n    }\n    sprintf(CarlaCollisionEventPubSubType::m_keyBuffer, \"%d\", myData->id);\n    if(force_md5 || DDS_Dynamic_PubSubType_get_key_value(CarlaCollisionEventPubSubType::m_md5, CarlaCollisionEventPubSubType::m_keyBuffer, DDS_HASH_MD5) != 0) {\n        DDS_get_hash_value(CarlaCollisionEventPubSubType::m_md5, CarlaCollisionEventPubSubType::m_keyBuffer, DDS_HASH_MD5);\n        DDS_Dynamic_PubSubType_set_key_value(CarlaCollisionEventPubSubType::m_md5, CarlaCollisionEventPubSubType::m_keyBuffer);\n    }\n    *handle = DDS_HANDLE_NIL;\n    return true;\n}", "CodeBleu_score": 28.13848874796081}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\n    // Serialize encapsulation.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = (uint32_t)ser.getSerializedDataLength();\n    return true;\n}", "CodeBleu_score": 79.60125873069511}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\n    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n\n    try {\n        p_type->serialize(ser);\n        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n        return true;\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n}", "CodeBleu_score": 77.84340565822767}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\n    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n\n    // Serialize encapsulation\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = (uint32_t)ser.getSerializedDataLength();\n    return true;\n}", "CodeBleu_score": 80.63773119514833}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (target_set) {\n        return;\n    }\n    mavlink_status_t status;\n    mavlink_heartbeat_t heartbeat;\n    mavlink_attitude_t attitude;\n    mavlink_vfr_hud_t vfr_hud;\n    mavlink_global_position_int_t global_position;\n    mavlink_local_position_ned_t local_position;\n    mavlink_request_data_stream_t request_data_stream;\n    mavlink_parse_char(MAVLINK_COMM_0, msg.buf[0], &msg, &status);\n    switch (msg.msgid) {\n        case MAVLINK_MSG_ID_HEARTBEAT:\n            mavlink_msg_heartbeat_decode(&msg, &heartbeat);\n            if (heartbeat.type == MAV_TYPE_GCS) {\n                target_sysid = heartbeat.target_system;\n                target_set = true;\n                return;\n            }\n            break;\n        case MAVLINK_MSG_ID_ATTITUDE:\n            mavlink_msg_attitude_decode(&msg, &attitude);\n            break;\n        case MAVLINK_MSG_ID_VFR_HUD:\n            mavlink_msg_vfr_hud_decode(&msg, &vfr_hud);\n            break;\n        case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n            mavlink_msg_global_position_int_decode(&msg, &global_position);\n            break;\n        case MAVLINK_MSG_ID_LOCAL_POSITION_NED:\n            mavlink_msg_local_position_ned_decode(&msg, &local_position);\n            break;\n        case MAVLINK_MSG_ID_REQUEST_DATA_STREAM:\n            mavlink_msg_request_data_stream_decode(&msg, &request_data_stream);\n            break;\n        default:\n            break;\n    }\n}", "CodeBleu_score": 34.38324619565869}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t  if (target_set) return;\n  mavlink_status_t status;\n  mavlink_msg_get_channel_status(msg, &status);\n  if (!status.flags.valid_target_id) return;\n  if (msg.msgid != MAVLINK_MSG_ID_TARGET_REQUEST_DATA_STREAM) return;\n  mavlink_target_request_data_stream_t packet;\n  mavlink_msg_target_request_data_stream_decode(&msg, &packet);\n  if (packet.req_stream_id != MAV_DATA_STREAM_POSITION || packet.req_message_rate != 1000) return;\n  target_sysid = packet.target_system;\n  target_set = true;\n  mavlink_msg_request_data_stream(MAVLINK_COMM_0, target_sysid, MAV_DATA_STREAM_POSITION, 1000, 1, MAV_COMP_ID_ALL);\n  mavlink_msg_request_data_stream(MAVLINK_COMM_0, target_sysid, MAV_DATA_STREAM_EXTRA1, 1000, 1, MAV_COMP_ID_ALL);\n}", "CodeBleu_score": 34.205397579511484}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_baro_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.44552152885447}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        // if the barometer is calibrated, we need to re-calibrate altitude\n        _altitude_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 69.13981398489717}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT res = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (res == MAV_RESULT_ACCEPTED) {\n        _alt_calibration_needed = true;\n    }\n    return res;\n}", "CodeBleu_score": 67.91347276569707}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 > 0) {\n        if (this->_arm_disarm_servos(true)) {\n            return MAV_RESULT_ACCEPTED;\n        }\n        return MAV_RESULT_FAILED;\n    } else if (packet.param1 < 0) {\n        if (this->_arm_disarm_servos(false)) {\n            return MAV_RESULT_ACCEPTED;\n        }\n        return MAV_RESULT_FAILED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 56.19634770273374}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0) {\n        if (gcs_tracker.arm_disarm_servos()) {\n            return MAV_RESULT_ACCEPTED;\n        }\n        return MAV_RESULT_FAILED;\n    }\n    if (packet.param1 == 0.0) {\n        if (gcs_tracker.arm_disarm_servos()) {\n            return MAV_RESULT_ACCEPTED;\n        }\n        return MAV_RESULT_FAILED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 62.86634889773042}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0) {\n        arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0) {\n        disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 53.334953393375116}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\n    // Get the current time\n    uint32_t time_now = AP_HAL::millis();\n\n    // Check if the time has passed the minimum interval between datastream requests\n    if (time_now - _last_datastream_request_time < DATASTREAM_REQUEST_INTERVAL_MS) {\n        return;\n    }\n\n    // Update the last datastream request time\n    _last_datastream_request_time = time_now;\n\n    // Iterate over the available GCS channels\n    for (uint8_t i = 0; i < _num_gcs; i++) {\n\n        // Get the current GCS channel\n        AP_GCS_MAVLINK &gcs = _gcs[i];\n\n        // Check if the GCS channel is connected\n        if (gcs.get_chan() == nullptr) {\n            continue;\n        }\n\n        // Check if the GCS channel is enabled\n        if (!gcs.get_chan()->get_is_enabled()) {\n            continue;\n        }\n\n        // Check if the GCS channel has available payload space\n        if (gcs.get_chan()->available() < MAVLINK_MSG_ID_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n            continue;\n        }\n\n        // Send the data stream request to the GCS channel\n        mavlink_msg_data_stream_send(\n            gcs.get_chan()->get_chan(),\n            sysid,\n            compid,\n            MAV_DATA_STREAM_POSITION,\n            _datastream_update_rate,\n            0\n        );\n\n        // Set the datastream request flag\n        _datastream_request_flag = true;\n\n        // Return from the function\n        return;\n    }\n}", "CodeBleu_score": 41.54726479987083}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    GCS_Tracker_Channel *ch = find_datastream_channel(sysid, compid);\n\n    if (ch != nullptr) {\n        if (ch->datastream_position_enabled) {\n            return;\n        }\n\n        ch->datastream_position_enabled = true;\n        ch->datastream_position_last_update_ms = AP_HAL::millis();\n\n        mavlink_message_t msg;\n        mavlink_msg_request_data_stream_pack(GCS_Tracker::system_id, GCS_Tracker::component_id, &msg, sysid, compid, MAV_DATA_STREAM_POSITION, 1000, 1);\n        GCS_Tracker::send_message(msg);\n    }\n}", "CodeBleu_score": 44.05607785942785}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    if (gcs_channels[GCS_CH_POS].available()) {\n        mavlink_msg_request_data_stream_send(\n            gcs_channels[GCS_CH_POS].get_chan(),\n            sysid,\n            compid,\n            MAV_DATA_STREAM_POSITION,\n            GCS_CH_POS,\n            1000);\n    }\n}", "CodeBleu_score": 35.01462145010032}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    // Get the AHRS instance\n    AHRS* ahrs = AP_AHRS::get_singleton();\n    if (ahrs == NULL) {\n        // AHRS not available, cannot convert\n        return false;\n    }\n\n    // Check for a zero pitch cosine to avoid division by zero\n    float cos_pitch = cosf(pitch);\n    if (cos_pitch < .0001f) {\n        return false;\n    }\n\n    // Calculate the earth frame pitch and yaw using trigonometric conversions\n    ef_pitch = atanf(-ahrs->cos_roll() * sinf(pitch) / cos_pitch);\n    ef_yaw = yaw - asinf(ahrs->sin_roll() * sinf(pitch) / cos_pitch);\n    return true;\n}", "CodeBleu_score": 51.46496229900589}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t  if (ahrs == NULL) {\n    return false;\n  }\n  float cos_pitch = cosf(pitch);\n  if (cos_pitch == 0.0f) {\n    return false;\n  }\n  ef_pitch = asinf(cosf(pitch) * sinf(ahrs->roll));\n  ef_yaw = yaw - ahrs->yaw;\n  return true;\n}", "CodeBleu_score": 42.240772401389904}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    if (ahrs.pitch_cosine() == 0.0f) {\n        return false;\n    }\n    ef_pitch = -asinf(ahrs.cos_roll() * ahrs.pitch_cosine());\n    ef_yaw = wrap_PI(yaw - ahrs.yaw_offset);\n    return true;\n}", "CodeBleu_score": 41.98778674715354}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    Parameters &g = tracker.g;\n\n    // check if target distance is valid\n    bool target_distance_valid = (nav_status.distance_to_target >= g.min_distance);\n\n    // check if the target distance is valid or no minimum distance is set\n    if (!target_distance_valid || g.min_distance == 0) {\n        // calculate yaw and pitch in centidegrees\n        int32_t yaw = wrap_360_cd(nav_status.bearing * 100);\n        int32_t pitch = (nav_status.distance_to_target * 100) / g.distance_scale;\n\n        // check if direction is reversed\n        bool direction_reversed = get_ef_yaw_direction();\n\n        // calculate angle error\n        calc_angle_error(pitch, yaw, direction_reversed);\n\n        // update servos\n        g.pidPitch2Srv.update();\n        g.pidYaw2Srv.update();\n        g.pitch_servo_out_filt.set(g.pidPitch2Srv.get_servo_out());\n        g.yaw_servo_out_filt.set(g.pidYaw2Srv.get_servo_out());\n    }\n}", "CodeBleu_score": 56.166147457910085}, {"code": "void Mode::update_auto(void){\n\t    // get navigation status\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    // get parameters\n    Parameters &g = tracker.g;\n\n    // calculate target yaw and pitch in centidegrees\n    float pitch = nav_status.target_pitch * 100.0f;\n    float yaw = nav_status.target_yaw * 100.0f;\n\n    // check if direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // check if target distance is valid or no minimum distance is set\n    if (nav_status.target_distance_valid || g.min_distance == 0) {\n        // update pitch and yaw servos\n        g.pidPitch2Srv.update();\n        g.pidYaw2Srv.update();\n    }\n}", "CodeBleu_score": 46.4079958461293}, {"code": "void Mode::update_auto(void){\n\t    // get navigation status\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    Parameters &g = tracker.g;\n\n    // get target yaw and pitch\n    float yaw = nav_status.yaw;\n    float pitch = nav_status.pitch;\n\n    // calculate angle error to target\n    bool direction_reversed = get_ef_yaw_direction();\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // if target distance is valid or no minimum distance is set\n    if (nav_status.distance_valid || g.min_distance == 0) {\n        // update pitch and yaw servos\n        g.pidPitch2Srv.update();\n        g.pidYaw2Srv.update();\n    }\n}", "CodeBleu_score": 47.47155506723158}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t", "CodeBleu_score": 1.8359599812427831}, {"code": "void Tracker::update_GPS(void){\n\t\n  if (millis() - last_gps_update > GPS_UPDATE_INTERVAL) {\n    last_gps_update = millis();\n\n    // Update GPS\n    gps.update();\n\n    // Check if the last message time has changed\n    if (gps.last_message_time != last_message_time) {\n      last_message_time = gps.last_message_time;\n\n      // Check if the GPS status is at least 3D fix\n      if (gps.status >= 3) {\n\n        // Check if the current location is valid\n        if (gps.location.is_valid()) {\n          // Set the home location if the countdown is at one\n          if (ground_start_countdown == 1) {\n            home_location = gps.location;\n            ground_start_countdown = 0;\n          }\n        } else {\n          // Reset the countdown if the location is invalid\n          ground_start_countdown = 5;\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 46.80192711111489}, {"code": "void Tracker::update_GPS(void){\n\t", "CodeBleu_score": 1.8359599812427831}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // Set the servo to the desired pitch\n    if (pitch > 180) {\n        pitch = 180;\n    } else if (pitch < 0) {\n        pitch = 0;\n    }\n    servo_pitch.write(pitch);\n}", "CodeBleu_score": 12.877045954995292}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t  if (pitch_onoff_servo_pin != -1) {\n    if (pitch < 20) {\n      digitalWrite(pitch_onoff_servo_pin, LOW);\n    } else {\n      digitalWrite(pitch_onoff_servo_pin, HIGH);\n    }\n  }\n}", "CodeBleu_score": 14.585009465884236}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch > 0) {\n        digitalWrite(PITCH_SERVO_PIN, HIGH);\n        delay(pitch);\n        digitalWrite(PITCH_SERVO_PIN, LOW);\n    }\n}", "CodeBleu_score": 14.676410083276803}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t", "CodeBleu_score": 2.150221949863861}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n    if (checks_to_perform(ARMING_CHECK_BARO)) {\n        // check barometer\n        float baro_alt_diff = (inertial_nav.get_altitude() - barometer.get_altitude());\n        if (baro_alt_diff < -_alt_error_cm) {\n            if (display_failure) {\n                AP_Notify::flags.baro_bad = true;\n            }\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 36.47186298493501}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n#if ARMING_CHECK_BARO\n    // check baro reference\n    if (is_negative(inertial_nav.get_altitude() - baro_reference)) {\n        if (display_failure) {\n            AP_Notify::flags.baro_reference_fail = true;\n        }\n        return false;\n    }\n\n    // check baro altitude\n    if (is_negative(inertial_nav.get_altitude() - baro.get_altitude())) {\n        if (display_failure) {\n            AP_Notify::flags.baro_altitude_fail = true;\n        }\n        return false;\n    }\n#endif\n\n    return true;\n}", "CodeBleu_score": 42.67388706420199}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if we are using rangefinder for altitude and we are not\n    // flying above terrain, we do not need a database\n    if ((copter.ap.terrain_alt_source == AP_TERRAIN_SOURCE_RANGEFINDER) &&\n        (copter.ap.terrain_alt > copter.rangefinder_state.alt_cm_filt)) {\n        return false;\n    }\n\n    // if we are using terrain database and we are flying above terrain, we do\n    // need a database\n    if ((copter.ap.terrain_alt_source == AP_TERRAIN_SOURCE_TERRAINDATABASE) &&\n        (copter.ap.terrain_alt > copter.rangefinder_state.alt_cm_filt)) {\n        return true;\n    }\n\n    // defer to base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 66.90060447877725}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if the terrain source is from a rangefinder, we don't need a\n    // terrain database\n    if (copter.rangefinder_state.source == RangeFinder::Source::RANGEFINDER_TERRAIN) {\n        return false;\n    }\n\n    // if the terrain source is from the terrain database and the RTL altitude type is terrain, we do need a terrain database\n    if (copter.rangefinder_state.source == RangeFinder::Source::RANGEFINDER_TERRAIN && copter.g.rtl_altitude_type == RTL_ALT_TERRAIN) {\n        return true;\n    }\n\n    // otherwise defer to the base class implementation of terrain_database_required\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 67.70886575056977}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if we are using the rangefinder, we do not need a terrain database\n    if (copter.rangefinder_state.alt_healthy && copter.rangefinder_state.alt_valid) {\n        return false;\n    }\n\n    // if we are using the terrain database and the RTL altitude type is terrain, we do need a terrain database\n    if (copter.get_RTL_alt_type() == RTL_ALT_TERRAIN) {\n        return true;\n    }\n\n    // defer to the base class implementation of terrain_database_required\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 61.65128322897404}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    // Get loop delta time\n    float dt = scheduler.get_last_loop_delta_time();\n\n    // run attitude controller\n    attitude_control.rate_controller_run(dt);\n}", "CodeBleu_score": 30.505649195532047}, {"code": "void Copter::run_rate_controller(){\n\t    // set loop rate, and return if not running\n    if (!rate_controller_run()) {\n        return;\n    }\n\n    // run attitude controller\n    attitude_control.rate_controller_run();\n\n    // run position controller, if enabled.  position controller requires all position and attitude information\n    if (g.pos_control == 1) {\n        pos_control.run();\n    }\n\n    // run auto takeoff, if enabled\n    if (auto_takeoff_triggered && !ap.land_complete) {\n        auto_takeoff_run();\n    }\n\n    // run landing controllers\n    if (ap.land_complete) {\n        land_run();\n    }\n}", "CodeBleu_score": 36.19858180326734}, {"code": "void Copter::run_rate_controller(){\n\t    // run the rate controller\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 11.259248511475347}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // check if the new location is the same as the old location\n    if (old_loc == new_loc) {\n        return false;\n    }\n\n    // check if the new location is the same as the old location\n    if (old_loc == new_loc) {\n        return false;\n    }\n\n    // check if the altitude frames are the same\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set the new location as the target\n    return set_target_location(new_loc);\n}", "CodeBleu_score": 61.85663335030277}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // exit immediately if we are not in guided mode or auto-guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // if the old location matches the new waypoint location, and the altitude frames are the same, then we can set the new location as the target\n    if (old_loc.same_latlon(new_loc) && old_loc.relative_alt && new_loc.relative_alt) {\n        // set the new location as the target\n        return mode_guided.set_destination(new_loc);\n    }\n\n    return false;\n}", "CodeBleu_score": 53.3929406817665}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // check if the old location matches this waypoint\n    if (old_loc.lat != new_loc.lat || old_loc.lng != new_loc.lng) {\n        return false;\n    }\n\n    // check if the altitude frames of the old and new locations are the same\n    if (old_loc.relative_alt != new_loc.relative_alt) {\n        return false;\n    }\n\n    // set the new location as the target\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 49.80679960442143}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (mode == Mode::Number::CIRCLE) {\n        // circle mode is not a valid flight mode\n        return;\n    }\n\n    if (ch_flag == AuxSwitchPos::HIGH) {\n        // if the switch is in the HIGH position, set the mode\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else {\n        // if the switch is not in the HIGH position\n        // and the current flight mode matches the given mode\n        // then reset the mode switch\n        if (copter.mode_number() == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 67.54341172748461}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        set_mode(mode);\n    } else {\n        if (copter.mode_number() == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 53.60143035234578}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t", "CodeBleu_score": 6.660368524040123}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t", "CodeBleu_score": 2.5412481981256345}, {"code": "void Copter::save_trim(){\n\t    // get roll and pitch inputs\n    float roll_input = channel_roll->control_in;\n    float pitch_input = channel_pitch->control_in;\n\n    // convert to radians\n    float roll_rad = radians(roll_input);\n    float pitch_rad = radians(pitch_input);\n\n    // add to ahrs\n    ahrs.add_trim(Vector3f(roll_rad, pitch_rad, 0));\n\n    // log event\n    AP_Notify::events.save_trim = true;\n\n    // send message\n    send_notification(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 46.27601900846089}, {"code": "void Copter::save_trim(){\n\t    // calculate the trim values from the control inputs of the roll and pitch channels\n    float roll_trim = channel_roll->control_in * 0.01f;\n    float pitch_trim = channel_pitch->control_in * 0.01f;\n\n    // convert them to radians\n    roll_trim = degreesToRadians(roll_trim);\n    pitch_trim = degreesToRadians(pitch_trim);\n\n    // add them to the AHRS trim\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log the event\n    AP_Notify::flags.save_trim = true;\n\n    // send a confirmation message with MAV_SEVERITY_INFO\n    AP_Notify::flags.save_trim = true;\n    AP_Notify::flags.save_trim_complete = true;\n}", "CodeBleu_score": 49.1359679838033}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // calculate speed\n    float speed = inertial_nav.get_velocity_neu().length();\n    float speed_squared = speed * speed;\n\n    // if we have a valid position and speed is above minimum threshold, then calculate a yaw based on velocity\n    if (ahrs.have_position(true) && speed_squared > MIN_SPEED_SQ) {\n        // get velocity in earth frame\n        Vector3f velocity_neu = inertial_nav.get_velocity_neu();\n\n        // calculate yaw from velocity\n        float yaw = atan2f(velocity_neu.y, velocity_neu.x);\n\n        // ensure yaw is between -pi and pi\n        yaw = wrap_PI(yaw);\n\n        // return yaw\n        return yaw;\n    }\n\n    // if we don't have a valid position, or we are too close to the origin, then return current yaw\n    return ahrs.yaw;\n}", "CodeBleu_score": 48.19889842217472}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // calculate yaw angle to look ahead\n    Vector2f vel = inertial_nav->get_velocity();\n    float speed_sq = vel.length_squared();\n    if (speed_sq >= MIN_SPEED_SQ && ahrs->have_position(true)) {\n        // calculate yaw angle from velocity components\n        float yaw = atan2f(vel.y, vel.x);\n        // ensure yaw is between -pi and pi\n        yaw = wrap_PI(yaw);\n        // ensure yaw is within 45 degrees of current yaw\n        float yaw_diff = wrap_PI(ahrs->yaw - yaw);\n        if (fabsf(yaw_diff) > ToRad(45.0f)) {\n            yaw = ahrs->yaw;\n        }\n        return yaw;\n    }\n    return 0.0f;\n}", "CodeBleu_score": 48.64786294928635}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // get velocity\n    Vector3f vel = inertial_nav.get_velocity();\n    float speed_sq = vel.length_squared();\n    // check if we're doing look-ahead\n    if (speed_sq >= MIN_SPEED_SQ) {\n        // get position\n        Vector3f pos = inertial_nav.get_position();\n        // check if position is valid\n        if (pos.is_zero()) {\n            // if not, use current yaw\n            return ahrs.yaw;\n        }\n        // calculate look-ahead yaw\n        float yaw = atan2f(vel.y, vel.x);\n        // ensure yaw is between -pi and pi\n        yaw = wrap_PI(yaw);\n        // return look-ahead yaw\n        return yaw;\n    }\n    // if we're not doing look-ahead, return current yaw\n    return ahrs.yaw;\n}", "CodeBleu_score": 50.16921094566242}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t", "CodeBleu_score": 3.490344250163065}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (checks_disabled) {\n        return true;\n    }\n    if (watchdog_armed) {\n        return true;\n    }\n\n    switch (method) {\n        case AP_Arming::Method::RUDDER:\n            if (arming.rudder_arming_disabled || hal.rcin->read(CH_THROTTLE) != 0) {\n                return false;\n            }\n            break;\n        default:\n            break;\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 43.54388403912316}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t", "CodeBleu_score": 3.490344250163065}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    // check if arming checks should be performed\n    if (do_arming_checks) {\n        // run arming checks\n        if (!pre_arm_checks()) {\n            // arming checks failed\n            return false;\n        }\n    }\n\n    // set arming method\n    arming_method = method;\n\n    // set arming state\n    set_armed_state(true);\n\n    // update home location\n    update_home_from_GPS();\n\n    // set home location in AHRS\n    ahrs.set_home(ahrs.get_home());\n\n    // update current location\n    current_loc.lat = ahrs.get_latitude();\n    current_loc.lng = ahrs.get_longitude();\n\n    // change arm state\n    change_arm_state();\n\n    // set delay arming flag\n    delay_arming = true;\n\n    // send status text\n    AP_Notify::flags.arming_gcs_change = true;\n\n    // return success\n    return true;\n}", "CodeBleu_score": 55.578907249249234}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // if we are using the throttle arming method, then we have to set the\n    // throttle to the arming throttle value\n    if (method == AP_Arming::Method::THROTTLE) {\n        plane.arming_throttle_pct = plane.channel_throttle->get_control_in();\n    }\n\n    // set the home location if we are using a gps lock\n    if (plane.gps.status() >= AP_GPS::GPS_OK_FIX_2D) {\n        plane.home_is_set = plane.set_home(plane.gps.location());\n    }\n\n    // update the current location\n    plane.current_loc.lat = plane.gps.location().lat;\n    plane.current_loc.lng = plane.gps.location().lng;\n\n    // change the arm state\n    change_arm_state();\n\n    // set the delay arming flag\n    plane.delay_arming = true;\n\n    // send a status text\n    plane.gcs_send_text(MAV_SEVERITY_INFO, \"ThrottleArmed\");\n\n    return true;\n}", "CodeBleu_score": 63.247325590075334}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if we're already armed, we're done\n    if (is_armed()) {\n        return true;\n    }\n\n    // if no disarm button is configured, we're done\n    if (!has_disarm_function) {\n        return false;\n    }\n\n    // perform the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 56.91934706801134}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    // if we're already armed, return true\n    if (is_armed()) {\n        return true;\n    }\n\n    // if there's no disarm button, then we can't arm\n    if (!has_disarm_function) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"No disarm button configured\");\n        }\n        return false;\n    }\n\n    // if we've reached this point, we have a disarm button and can proceed with the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 67.95046930715796}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (is_armed()) {\n        // already armed\n        return true;\n    }\n\n    // if we don't have a disarm button, then we can't arm\n    if (!has_disarm_function) {\n        if (display_failure) {\n            AP_Notify::flags.pre_arm_disarm_button_missing = true;\n        }\n        return false;\n    }\n\n    // run the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 66.51504256667383}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cosf(-ahrs.yaw) - y * sinf(-ahrs.yaw);\n    float ne_y = x * sinf(-ahrs.yaw) + y * cosf(-ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 61.48228977778387}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cosf(-ahrs.yaw) - y * sinf(-ahrs.yaw);\n    float ne_y = x * sinf(-ahrs.yaw) + y * cosf(-ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 61.48228977778387}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\n    // Get the yaw angle from the AHRS\n    float yaw = ahrs->yaw;\n\n    // Calculate the rotation matrix\n    float rotation_matrix[2][2] = {\n        {cos(yaw), -sin(yaw)},\n        {sin(yaw),  cos(yaw)}\n    };\n\n    // Apply the rotation matrix to the x and y coordinates\n    float ne_x = x * rotation_matrix[0][0] + y * rotation_matrix[0][1];\n    float ne_y = x * rotation_matrix[1][0] + y * rotation_matrix[1][1];\n\n    // Update x and y with the new coordinates\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 54.06750941692331}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    if (fabsf(packet.param4) > 180.0f) {\n        return MAV_RESULT_DENIED;\n    }\n    if (is_negative(packet.param5) || is_negative(packet.param6) || is_negative(packet.param7)) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param5 > 360000) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param6 > 360000) {\n        return MAV_RESULT_DENIED;\n    }\n    if (packet.param7 > 360000) {\n        return MAV_RESULT_DENIED;\n    }\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 49.542600140796175}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t", "CodeBleu_score": 3.5541344618719917}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\n    // check if yaw angle is within acceptable range\n    if (packet.param4 > -180.0f && packet.param4 < 180.0f) {\n        // check if param4 is within acceptable range\n        if (packet.param4 > 0.0f && packet.param4 < 360.0f) {\n            // set yaw heading using provided parameters\n            set_yaw_heading(packet.param4);\n            // return MAV_RESULT_ACCEPTED\n            return MAV_RESULT_ACCEPTED;\n        }\n    }\n    // return MAV_RESULT_DENIED\n    return MAV_RESULT_DENIED;\n}", "CodeBleu_score": 46.58564701848174}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == GUIDED || control_mode == AUTO) {\n        return (uint8_t)wp_bearing / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 38.517041838666835}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return (int16_t)(wp_bearing / 2) % 360;\n    }\n    return 0;\n}", "CodeBleu_score": 39.59584078538273}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == GUIDED || control_mode == AUTO) {\n        return (wp_bearing / 2) % 360;\n    }\n    return 0;\n}", "CodeBleu_score": 38.55216160902292}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (logging_enabled) {\n        LogBlock block;\n        block.time = HAL_GetTick();\n        block.id = id;\n        block.value = value;\n        logger.WriteBlock(block);\n    }\n}", "CodeBleu_score": 39.45637639112807}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t  if (logging_enabled) {\n    LogPacket packet;\n    packet.time = millis();\n    packet.id = id;\n    packet.value = value;\n    logger->Write_Critical_Block(&packet, sizeof(packet));\n  }\n}", "CodeBleu_score": 41.99410904062933}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (log_enabled) {\n        LogPacket packet;\n        packet.time = millis();\n        packet.id = id;\n        packet.value = value;\n        logger.Write_Block(packet);\n    }\n}", "CodeBleu_score": 39.52417319774201}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    // if home is already set, exit immediately\n    if (home_is_set) {\n        return;\n    }\n\n    // if motors are armed, set home to current location in-flight\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n        return;\n    }\n\n    // if motors are not armed, attempt to set home to current EKF location\n    set_home_to_current_location(false);\n}", "CodeBleu_score": 43.80813073658065}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (home_is_set) {\n        return;\n    }\n\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 50.55563233041143}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (home_is_set) {\n        return;\n    }\n\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 50.55563233041143}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t    // if not armed set throttle to zero and exit immediately\n    if (!motors->armed()) {\n        motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->relax_attitude_controllers();\n        // exit immediately\n        return;\n    }\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert the input to the desired body frame rate\n    float rate_roll, rate_pitch, rate_yaw;\n    get_pilot_desired_rate(rate_roll, rate_pitch, rate_yaw);\n\n    // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(rate_roll, rate_pitch, rate_yaw);\n\n    // output pilot's throttle without angle boost\n    motors->set_throttle(channel_throttle->norm_input());\n\n    // set motors to full range\n    motors->set_forward(channel_forward->norm_input());\n    motors->set_lateral(channel_lateral->norm_input());\n}", "CodeBleu_score": 54.7811251874553}, {"code": "void ModeAcro::run(){\n\t    float target_roll, target_pitch;\n    float target_yaw_rate;\n    float pilot_throttle_scaled;\n\n    // if not armed set throttle to zero and exit immediately\n    if (!motors->armed()) {\n        motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->set_throttle_out(0.0f, true, g.throttle_filt);\n        attitude_control->relax_attitude_controllers();\n        yaw_control->reset_rate_controller_I_terms();\n        return;\n    }\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert the input to the desired body frame rate\n    get_pilot_desired_angle_rates(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, target_yaw_rate);\n\n    // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yaw_rate);\n\n    // get pilot's desired throttle\n    pilot_throttle_scaled = channel_throttle->norm_input();\n\n    // call attitude controller\n    attitude_control->set_throttle_out(pilot_throttle_scaled, true, g.throttle_filt);\n}", "CodeBleu_score": 62.69981458452389}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set position controller to waypoint control mode\n    sub.pos_control.set_mode(POSITION_CONTROL_TYPE_WAYPOINT);\n\n    // initialise waypoint controller\n    sub.wp_nav.wp_and_spl_init();\n\n    // set stopping point\n    sub.wp_nav.set_wp_destination_pos(sub.pos_control.get_pos_target_z());\n\n    // set yaw state\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 47.05992782720326}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set the mode to position control\n    set_mode(Mode::Number::POSITION_CONTROL);\n\n    // get the stopping point\n    Vector3f stopping_point = get_stopping_point();\n\n    // set the stopping point as the destination\n    wp_nav->set_wp_destination(stopping_point);\n\n    // initialise the yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 34.33865709566907}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set guided_WP_num to next waypoint\n    guided_WP_num = sub.wp_nav.get_wp_num();\n\n    // initialise waypoint controller\n    sub.wp_nav.init_z_controller();\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 31.38452948341566}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t    // initialise vertical speed and acceleration\n    pos_control->set_max_speed_accel_z(-sub.pilot_speed_dn_max, sub.pilot_speed_up_max, sub.pilot_accel_z);\n    pos_control->set_correction_speed_accel_z(-sub.pilot_speed_dn_max, sub.pilot_speed_up_max, sub.pilot_accel_z);\n\n    // initialise horizontal speed and acceleration\n    pos_control->set_max_speed_accel_xy(sub.wp_nav->get_default_speed_xy(), sub.wp_nav->get_default_accel_xy());\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 46.50120276772637}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // initialise vertical speed and acceleration\n    pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), sub.get_pilot_speed_dn_max(), sub.get_pilot_speed_up_max());\n    pos_control->set_correction_speed_accel_z(sub.get_accel_z_max(), sub.get_accel_boost_z());\n\n    // initialise horizontal speed and acceleration\n    pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_default_speed_xy(), sub.get_pilot_speed_xy_max());\n    pos_control->set_correction_speed_accel_xy(sub.get_accel_xy_max(), sub.get_accel_boost_xy());\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 54.13007635320022}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // initialise vertical speed and acceleration\n    pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z);\n    pos_control->set_correction_speed_accel_z(g.speed_down, g.speed_up, g.accel_z);\n\n    // initialise horizontal speed and acceleration\n    pos_control->set_max_speed_accel_xy(g.wp_nav_speed, g.wp_nav_speed, g.wp_nav_accel);\n    pos_control->set_correction_speed_accel_xy(g.speed_xy, g.speed_xy, g.accel_xy);\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 46.81188777841915}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // check timeout\n    if (millis() - guided_start_time > GUIDED_TIMEOUT_MS) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"GUIDED: Timed out\");\n        return true;\n    }\n\n    // check altitude\n    if (current_loc.alt > guided_limits.alt_max) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"GUIDED: Altitude error\");\n        return true;\n    }\n    if (current_loc.alt < guided_limits.alt_min) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"GUIDED: Altitude error\");\n        return true;\n    }\n\n    // check horizontal position\n    if (guided_limits.horiz_max > 0 && get_horizontal_distance_cm(guided_start_loc, current_loc) > guided_limits.horiz_max) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"GUIDED: Horiz error\");\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 45.636293479962816}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have a timeout\n    if (millis() - guided_start_time > GUIDED_TIMEOUT) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Guided: Timeout\");\n        return true;\n    }\n\n    // check if we have a vertical position limit\n    if (guided_pos_xyz[2] > GUIDED_MAX_POS) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Guided: Altitude error\");\n        return true;\n    }\n    if (guided_pos_xyz[2] < GUIDED_MIN_POS) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Guided: Altitude error\");\n        return true;\n    }\n\n    // check if we have a horizontal position limit\n    if (guided_pos_xyz[0] * guided_pos_xyz[0] + guided_pos_xyz[1] * guided_pos_xyz[1] > GUIDED_MAX_POS * GUIDED_MAX_POS) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Guided: Horiz error\");\n        return true;\n    }\n\n    // check if we have a horizontal velocity limit\n    if (guided_vel_xyz[0] * guided_vel_xyz[0] + guided_vel_xyz[1] * guided_vel_xyz[1] > GUIDED_MAX_VEL * GUIDED_MAX_VEL) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Guided: Horiz error\");\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 36.83174647296067}, {"code": "bool ModeGuided::guided_limit_check(){\n\t", "CodeBleu_score": 1.2887052532981327}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t    // Check if motor test requests are received at least every 2 Hz\n    ros::Rate rate(2);\n    while (ros::ok()) {\n        if (motor_test_request_received) {\n            motor_test_request_received = false;\n            break;\n        }\n        rate.sleep();\n    }\n\n    // If the requests time out, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false\n    if (!motor_test_request_received) {\n        ROS_INFO(\"Motor test failed: motor test requests timed out\");\n        motor_test_pass = false;\n        motor_test_enabled = false;\n        arming_client.call(disarm_srv);\n        motor_test_failure_time = ros::Time::now();\n        return false;\n    }\n\n    // If the test passes, return true\n    return true;\n}", "CodeBleu_score": 48.671608670075884}, {"code": "bool Sub::verify_motor_test(){\n\t    if (motor_test_enabled) {\n        // Check if motor test requests are received at least every 2 Hz\n        if (motor_test_request_count < 1) {\n            // Send timeout message\n            send_timeout_message(motor_test_timeout_message);\n            // Set pass flag to false\n            motor_test_pass = false;\n            // Disable motor test\n            motor_test_enabled = false;\n            // Disarm system\n            disarm();\n            // Record failure time\n            motor_test_failure_time = ros::Time::now();\n            // Return false\n            return false;\n        }\n        // Reset motor test request count\n        motor_test_request_count = 0;\n        // Return true\n        return true;\n    }\n    // Return false\n    return false;\n}", "CodeBleu_score": 44.47790507367814}, {"code": "bool Sub::verify_motor_test(){\n\t    // Check if motor test requests are received at least every 2 Hz\n    if (motor_test_request_received_time < ros::Time::now() - ros::Duration(0.5)) {\n        // Send timeout message\n        ROS_ERROR(\"Motor test timed out\");\n        // Set pass flag to false\n        pass = false;\n        // Disable motor test\n        motor_test_enabled = false;\n        // Disarm system\n        disarm();\n        // Record failure time\n        motor_test_failure_time = ros::Time::now();\n        // Return false\n        return false;\n    }\n\n    // Return true\n    return true;\n}", "CodeBleu_score": 37.08346914558904}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t", "CodeBleu_score": 3.4981965412920477}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\n  // retrieve target roll and pitch from wp_nav\n  float target_roll, target_pitch;\n  wp_nav.get_roll_pitch(target_roll, target_pitch);\n\n  // apply roll and pitch limits\n  target_roll = constrain_float(target_roll, -roll_limit, roll_limit);\n  target_pitch = constrain_float(target_pitch, -pitch_limit, pitch_limit);\n\n  // lateral and forward controller outputs\n  lateral_out = 0;\n  forward_out = 0;\n\n  // if we're using centi-degrees, scale up\n  if (wp_nav.get_angle_max_cd() != 0) {\n    target_roll *= wp_nav.get_angle_max_cd() / 100.0f;\n    target_pitch *= wp_nav.get_angle_max_cd() / 100.0f;\n  }\n\n  // normalize roll and pitch\n  float roll_out, pitch_out;\n  wp_nav.get_roll_pitch_out(roll_out, pitch_out, target_roll, target_pitch, 0, 0);\n\n  // apply roll and pitch outputs\n  lateral_out += roll_out;\n  forward_out += pitch_out;\n\n  // normalize lateral and forward outputs\n  lateral_out = constrain_float(lateral_out, -1.0f, 1.0f);\n  forward_out = constrain_float(forward_out, -1.0f, 1.0f);\n}", "CodeBleu_score": 38.02798102893703}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // retrieve roll and pitch targets from wp_nav\n    float roll_target = wp_nav.get_roll();\n    float pitch_target = wp_nav.get_pitch();\n\n    // constrain roll and pitch to the limits\n    roll_target = constrain_float(roll_target, -roll_limit, roll_limit);\n    pitch_target = constrain_float(pitch_target, -pitch_limit, pitch_limit);\n\n    // normalize the roll and pitch targets\n    float roll_out, pitch_out;\n    wp_nav.nav_roll_pitch_rate_controller_out(roll_target, pitch_target, roll_out, pitch_out);\n\n    // convert roll and pitch to lateral and forward\n    lateral_out = cosf(radians(pitch_out)) * sinf(radians(roll_out));\n    forward_out = cosf(radians(pitch_out)) * cosf(radians(roll_out));\n}", "CodeBleu_score": 40.10883979091338}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\n    // read the barometer\n    barometer.update();\n\n    // if we are above zero altitude, then we are in air and need to check the barometer calibration\n    if (altitude > 0.0f) {\n        // check the barometer calibration\n        barometer.check_calibration();\n    }\n\n    // if a depth sensor is present, check the barometer health\n    if (depth_sensor_present) {\n        // check the barometer health\n        barometer.check_health();\n    }\n}", "CodeBleu_score": 50.5134697771505}, {"code": "void Sub::read_barometer(){\n\t    // read the barometer\n    barometer.update();\n    barometer_health = barometer.healthy();\n\n    // update the barometer calibration if we're above zero\n    if (inertial_nav.get_altitude() > 0.0f) {\n        barometer.calibrate(inertial_nav.get_altitude());\n    }\n\n    // update the depth sensor health if we have one\n    if (depth_sensor.present()) {\n        depth_sensor_health = depth_sensor.healthy();\n    }\n}", "CodeBleu_score": 52.40538381965023}, {"code": "void Sub::read_barometer(){\n\t    // read barometer\n    barometer.read();\n    // check if we're in the air\n    if (barometer.get_altitude() > 0.0f) {\n        // update barometer calibration\n        barometer.calibrate();\n        // if a depth sensor is present, check its health\n        if (depth_sensor.healthy()) {\n            // update depth sensor health\n            depth_sensor.update();\n        }\n    }\n}", "CodeBleu_score": 53.05410774463333}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t    // if motors are disarmed, we accept a predicted horizontal position\n    if (!motors.armed()) {\n        return true;\n    }\n\n    // if we don't have a valid position estimate, we don't know where we are\n    if (!ahrs.home_is_set() || !ahrs.healthy() || !ahrs.get_position(ahrs_pos_neu)) {\n        return false;\n    }\n\n    // if we are in constant position mode, we don't know where we are\n    if (flightmode->has_manual_position_control() && !ekf_initialised) {\n        return false;\n    }\n\n    // we're ok\n    return true;\n}", "CodeBleu_score": 46.29711658044117}, {"code": "bool Sub::ekf_position_ok(){\n\t", "CodeBleu_score": 1.8482588980119046}, {"code": "bool Sub::ekf_position_ok(){\n\t", "CodeBleu_score": 1.8482588980119046}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // call parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the AHRS system is ready\n    if (!AP::ahrs().healthy()) {\n        if (display_failure) {\n            AP_Notify::flags.gps_checks_failure = true;\n        }\n        return false;\n    }\n\n    // check if the EKF failsafe is active\n    if (AP::ahrs().in_failure_mode(AHRS_FAILURE_GPS_GLITCH)) {\n        if (display_failure) {\n            AP_Notify::flags.gps_checks_failure = true;\n        }\n        return false;\n    }\n\n    // ensure the position estimate is valid\n    if (!AP::ahrs().prearm_home_is_set()) {\n        if (display_failure) {\n            AP_Notify::flags.gps_checks_failure = true;\n        }\n        return false;\n    }\n\n    // if we got this far we passed all checks\n    return true;\n}", "CodeBleu_score": 45.01706799542729}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // call parent GPS check\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if EKF is in failsafe\n    if (ahrs.prearm_failure_status() & (int)AHRS_Status_Flags::EKF_ATTITUDE) {\n        if (display_failure) {\n            AP_Notify::flags.ekf_bad = true;\n        }\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!ahrs.prearm_failure_status() && !ahrs.prearm_ekf_healthy()) {\n        if (display_failure) {\n            AP_Notify::flags.ekf_bad = true;\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 40.973588746256475}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // call the parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the AHRS system is ready\n    if (!AP::ahrs().prearm_healthy(display_failure)) {\n        return false;\n    }\n\n    // check if the EKF failsafe is active\n    if (AP::ahrs().in_failure_mode(AHRS_FAILURE_EKF_GPS)) {\n        if (display_failure) {\n            AP_Notify::flags.ekf_bad = true;\n        }\n        return false;\n    }\n\n    // ensure the position estimate is valid\n    if (!AP::ahrs().prearm_position_ok()) {\n        if (display_failure) {\n            AP_Notify::flags.ekf_bad = true;\n        }\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}", "CodeBleu_score": 42.48151114292237}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // call parent arm method\n    bool ret = AP_Arming::arm(method, do_arming_checks);\n\n    // if arming failed, return immediately\n    if (!ret) {\n        return false;\n    }\n\n    // set home to current location\n    if (rover.mode_rover.is_boat()) {\n        rover.mode_sail.set_home_to_current_location(true);\n    }\n\n    // set initial simple mode heading\n    rover.mode_simple.set_initial_heading();\n\n    // record home heading for sail vehicles\n    if (rover.mode_rover.is_boat()) {\n        rover.mode_sail.record_home_heading();\n    }\n\n    // update soft armed status\n    update_soft_armed();\n\n    // send arming status text\n    send_arming_status_text();\n\n    return true;\n}", "CodeBleu_score": 55.447953034996104}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    // if already armed, do nothing\n    if (is_armed()) {\n        return true;\n    }\n\n    // if we are not in the correct mode, do nothing\n    if (!ap.mode_rover.is_active()) {\n        return false;\n    }\n\n    // if arming checks are disabled, do nothing\n    if (!do_arming_checks) {\n        return false;\n    }\n\n    // check if arming checks should be run\n    if (!check_pre_arm()) {\n        return false;\n    }\n\n    // arm motors\n    if (!motors.armed()) {\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::ARMING);\n    }\n\n    // send arming status text\n    AP_Notify::flags.arming_check = true;\n\n    // return true if arming was successful\n    return motors.armed();\n}", "CodeBleu_score": 39.53316660444765}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t    if (charging_allowed && !checkShouldCharge()) {\n        charging_allowed = false;\n        disable_charging_time = getTime();\n    }\n\n    if (!charging_allowed) {\n        if (getTime() - disable_charging_time > 300000) {\n            charging_allowed = true;\n            disable_charging_time = 0;\n        }\n    }\n}", "CodeBleu_score": 31.08250849469467}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (charging_enabled) {\n                log_info(\"Charging enabled\");\n                charging_enabled = false;\n                charging_disabled_at = millis();\n            }\n        } else {\n            if (!charging_enabled) {\n                log_info(\"Charging disabled\");\n                charging_enabled = true;\n                charging_disabled_at = 0;\n            }\n        }\n    } else {\n        if (charging_enabled) {\n            log_info(\"Charging disabled due to charging_allowed = false\");\n            charging_enabled = false;\n            charging_disabled_at = millis();\n        } else {\n            if (millis() - charging_disabled_at > CHARGING_RETRY_DELAY) {\n                if (checkShouldCharge()) {\n                    log_info(\"Charging enabled due to charging_allowed = false\");\n                    charging_enabled = true;\n                    charging_disabled_at = 0;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 50.104655629207585}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (!charging_enabled) {\n                charging_enabled = true;\n                charging_enabled_time = millis();\n            }\n        } else {\n            if (charging_enabled) {\n                charging_enabled = false;\n                charging_disabled_time = millis();\n            }\n        }\n    } else {\n        if (charging_enabled) {\n            charging_enabled = false;\n            charging_disabled_time = millis();\n        } else {\n            if (millis() - charging_disabled_time > charging_delay) {\n                charging_enabled = true;\n                charging_enabled_time = millis();\n            }\n        }\n    }\n}", "CodeBleu_score": 57.77606227461036}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t  if (ros_running && size >= 4) {\n    uint32_t crc = calculate_crc(message, size - 4);\n    memcpy(message + size - 4, &crc, 4);\n    packetSerial.write(message, size);\n  }\n}", "CodeBleu_score": 30.855920677288257}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros_running && size >= 4) {\n    uint32_t crc = crc32(0L, Z_NULL, 0);\n    crc = crc32(crc, message, size);\n    uint8_t *message_with_crc = (uint8_t *) malloc(size + 4);\n    memcpy(message_with_crc, message, size);\n    memcpy(message_with_crc + size, &crc, 4);\n    packetSerial.write(message_with_crc, size + 4);\n    free(message_with_crc);\n  }\n}", "CodeBleu_score": 44.17703680237537}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros_running && size >= 4) {\n    uint16_t crc = crc16(message, size - 2);\n    memcpy((char *)message + size - 2, &crc, 2);\n    packetSerial.write(message, size);\n  }\n}", "CodeBleu_score": 36.36205537736442}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\t\n\t// If there are no sounds, return 0.\n\tif (sounds.size() == 0) {\n\t\treturn 0;\n\t}\n\t\n\t// If an MP3 is playing, return the number of active sounds.\n\tif (mp3Player->isPlaying()) {\n\t\treturn sounds.size();\n\t}\n\t\n\t// Otherwise, play the last sound in the list, remove it from the list, and return the updated number of active sounds.\n\tmp3Player->play(sounds.back());\n\tsounds.pop_back();\n\treturn sounds.size();\n}", "CodeBleu_score": 37.8287105932199}, {"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\n\tif (mp3.isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\n\tSound* sound = activeSounds.getLast();\n\tactiveSounds.removeLast();\n\n\tmp3.play(sound->getFilename());\n\n\treturn activeSounds.size();\n}", "CodeBleu_score": 43.4701403288498}, {"code": "int MP3Sound::processSounds(){\n\t", "CodeBleu_score": 1.9429723807293087}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  bool command_handled = false;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (camera->mapped_file != NULL)\n        wb_abstract_camera_cleanup_memory_mapped_file(camera);\n      if (r->size > 0) {\n        if (wb_abstract_camera_setup_memory_mapped_file(camera, r->data[0], r->size) == false)\n          return false;\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  return command_handled;\n}", "CodeBleu_score": 54.946221887098105}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    wb_abstract_camera_cleanup_memory_mapped_file(d);\n    wb_abstract_camera_set_memory_mapped_file(d, r);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 21.522539493005414}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (d->camera_memory_mapped_file)\n        wb_device_memory_mapped_file_delete(d->camera_memory_mapped_file);\n      d->camera_memory_mapped_file = wb_device_memory_mapped_file_new(r);\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 45.51959136350967}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  wb_mutex_lock(&d->mutex);\n  int height = d->camera_data.height;\n  wb_mutex_unlock(&d->mutex);\n  return height;\n}", "CodeBleu_score": 39.54935056651105}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height;\n  wb_mutex_lock(d->mutex);\n  if (d->camera_data)\n    height = d->camera_data->height;\n  else\n    height = -1;\n  wb_mutex_unlock(d->mutex);\n  return height;\n}", "CodeBleu_score": 43.57509469896485}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  wb_mutex_lock(d->mutex);\n  int height = d->camera_data ? d->camera_data->height : -1;\n  wb_mutex_unlock(d->mutex);\n  return height;\n}", "CodeBleu_score": 40.92601127491216}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  wb_lock_mutex(accelerometer_mutex);\n  WbAccelerometer *accelerometer = wb_robot_get_device_by_tag(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    wb_error(\"wb_accelerometer_get_sampling_period: invalid device tag (%d)\", tag);\n  }\n  wb_unlock_mutex(accelerometer_mutex);\n  return sampling_period;\n}", "CodeBleu_score": 50.61890739947792}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  wb_lock(tag);\n  WbDevice *device = wb_robot_get_device(tag);\n  if (device->rtype != WB_NODE_ACCELEROMETER) {\n    wb_error(\"device '%s' is not an accelerometer\", device->name);\n    return -1;\n  }\n  sampling_period = device->fields[WB_ACCELEROMETER_SAMPLING_PERIOD].value;\n  wb_unlock(tag);\n  return sampling_period;\n}", "CodeBleu_score": 45.66494738330078}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  if (tag == NULL) {\n    wb_error(\"wb_accelerometer_get_sampling_period: invalid tag\");\n    return -1;\n  }\n  wb_mutex_lock(tag->mutex);\n  int sampling_period = tag->accelerometer->sampling_period;\n  wb_mutex_unlock(tag->mutex);\n  return sampling_period;\n}", "CodeBleu_score": 45.780658807230054}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsString(dms);\n    free(dms);\n    return dmsString;\n}", "CodeBleu_score": 40.730738173345394}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result = dms;\n    free(dms);\n    return result;\n}", "CodeBleu_score": 43.26594642271182}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t  char *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dms = dmsString;\n  free(dmsString);\n  return dms;\n}", "CodeBleu_score": 45.232810581933194}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dImmersionGeom immersionData;\n  dGeomID geom;\n  int result;\n\n  DXASSERT (box != NULL);\n  DXASSERT (box->body != NULL);\n  DXASSERT (flags & dImmersionFlags_All);\n\n  immersionData.box = box;\n  immersionData.fluidPlane = fluidPlane;\n  immersionData.immersion = immersion;\n  immersionData.flags = flags;\n\n  geom = dBodyGetGeom (box->body);\n  result = dImmerseGeom (geom, &immersionData, dImmerseBoxCallback);\n\n  return result;\n}", "CodeBleu_score": 42.58622737771678}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  int result;\n  dBoxImmersionData data;\n\n  D_ASSERT (box != NULL);\n  D_ASSERT (box->body != NULL);\n  D_ASSERT (flags == D_IMMERSE_ALL || flags == D_IMMERSE_NONE ||\n      flags == D_IMMERSE_FIRST || flags == D_IMMERSE_SECOND ||\n      flags == D_IMMERSE_FIRST_SECOND);\n\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.flags = flags;\n  data.immersion = immersion;\n\n  result = dImmerseBoxCallback (&data);\n\n  return result;\n}", "CodeBleu_score": 42.42348472639812}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  dImmersionGeom immersionData;\n  int result;\n\n  D_ASSERT (box != NULL);\n  D_ASSERT (box->body != NULL);\n  D_ASSERT (immersion != NULL);\n  D_ASSERT (flags & D_IMMERSION_GEOM_ALL);\n\n  /* Initialize the immersion data. */\n  immersionData.box = box;\n  immersionData.fluidPlane = fluidPlane;\n  immersionData.immersion = immersion;\n  immersionData.flags = flags;\n\n  /* Perform the immersion checking. */\n  result = dImmerseBoxData (&immersionData);\n\n  /* Return the result. */\n  return result;\n}", "CodeBleu_score": 43.200036424952025}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dGeomID box, capsule;\n  dReal fluidPlane[4];\n  int result;\n\n  dUASSERT(o1->category == dBoxClass, \"The first argument must be a box\");\n  dUASSERT(o2->category == dCapsuleClass, \"The second argument must be a capsule\");\n\n  box = o1;\n  capsule = o2;\n\n  dUASSERT(box->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(capsule->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  /* Compute the immersion plane for the capsule */\n  dCapsuleImmersionPlane(capsule, fluidPlane);\n\n  result = dImmerseBox(box, fluidPlane, flags, immersion);\n\n  return result;\n}", "CodeBleu_score": 42.53607093534802}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dGeomID g1 = dGeomGetID(o1);\n  dGeomID g2 = dGeomGetID(o2);\n  if (dGeomGetClass(g1) != dBoxClass || dGeomGetClass(g2) != dCapsuleClass) {\n    dERROR(\"dImmerseBoxCapsule: wrong input arguments\");\n    return 0;\n  }\n\n  dReal fluidPlane[4];\n  dReal capsulePlane[4];\n\n  dGeomGetPlane (o2, capsulePlane);\n  dImmerseBoxCapsulePlane(o1, o2, fluidPlane);\n\n  return dImmerseBox(dGeomGetBox(o1), fluidPlane, flags, immersion);\n}", "CodeBleu_score": 38.36820443959288}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1->type == dBoxClass, \"The first argument must be a box\");\n  dUASSERT(o2->type == dCapsuleClass, \"The second argument must be a capsule\");\n  dUASSERT(immersion, \"The immersion object must not be NULL\");\n\n  dImmerseBox(static_cast<dxBox *>(o1), static_cast<dxCapsule *>(o2)->fluidPlane, flags, immersion);\n\n  return 1;\n}", "CodeBleu_score": 28.785152148434}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t\tdReal result = 0;\n\n\t// The integration is split into two parts:\n\t// 1. The first part is from 0 to tanTheta0\n\t// 2. The second part is from tanTheta0 to tanTheta1\n\tdReal tanTheta1 = (zIOverR - 1) / (zIOverR + 1);\n\n\t// Calculate the volume of the first part using Simpson's rule\n\tdReal h = tanTheta0 / 2;\n\tdReal x0 = 0;\n\tdReal x1 = tanTheta0;\n\tdReal x2 = tanTheta0 / 2;\n\tdReal f0 = immersedHemisphereVolume(x0, zIOverR);\n\tdReal f1 = immersedHemisphereVolume(x1, zIOverR);\n\tdReal f2 = immersedHemisphereVolume(x2, zIOverR);\n\tresult += f0 + 4 * f2 + f1;\n\tresult *= h / 3;\n\n\t// Calculate the volume of the second part using Simpson's rule\n\th = tanTheta1 / 2;\n\tx0 = tanTheta0;\n\tx1 = tanTheta1;\n\tx2 = tanTheta1 / 2;\n\tf0 = immersedHemisphereVolume(x0, zIOverR);\n\tf1 = immersedHemisphereVolume(x1, zIOverR);\n\tf2 = immersedHemisphereVolume(x2, zIOverR);\n\tresult += f0 + 4 * f2 + f1;\n\tresult *= h / 3;\n\n\treturn result;\n}", "CodeBleu_score": 40.58395268442426}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    dReal x = 0.0;\n    dReal r = m_radius;\n    dReal d = m_depth;\n    dReal v = volume;\n    dReal z = zIOverR * r;\n\n    // Calculate the x-coordinate of the buoyancy center\n    x = (z * z * (tanTheta0 - sinTheta1) + d * d * (zIOverR * zIOverR - tanTheta0 * tanTheta0) + v * r * r * (sinTheta1 - tanTheta0)) / (z * z * zIOverR * zIOverR - d * d * zIOverR * zIOverR + v * r * r);\n\n    return x;\n}", "CodeBleu_score": 40.61798486978771}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 23.428802612884315}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2, \"This triangle mesh has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 23.515259619213158}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 15.426708583680124}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t    int duration_ms;\n    if (!getParameter(\"duration_ms\", duration_ms)) {\n        return SUCCESS;\n    }\n\n    if (duration_ms <= 0) {\n        return SUCCESS;\n    }\n\n    setStatus(RUNNING);\n    timer_waiting_ = true;\n    timer_.setPeriod(ros::Duration(duration_ms / 1000.0));\n    timer_.start(timer_waiting_);\n    timer_.setCallback(boost::bind(&SleepNode::timerCallback, this, _1));\n\n    return RUNNING;\n}", "CodeBleu_score": 45.87856701277035}, {"code": "NodeStatus SleepNode::onStart(){\n\t  // Get the sleep duration from the input\n  double duration;\n  if (!getInput(\"duration\", duration)) {\n    // If the input is missing or non-positive, return SUCCESS\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  status_ = NodeStatus::RUNNING;\n\n  // Start a timer with the given duration\n  timer_ = std::make_shared<ros::Timer>(nh_.createTimer(ros::Duration(duration), &SleepNode::timerCallback, this));\n\n  // Set a callback to emit a wake-up signal when the timer expires\n  timer_->setCallback(std::bind(&SleepNode::timerCallback, this, std::placeholders::_1));\n\n  // Set the timer_waiting_ flag to true\n  timer_waiting_ = true;\n\n  // Return SUCCESS\n  return NodeStatus::SUCCESS;\n}", "CodeBleu_score": 44.48115114473481}, {"code": "NodeStatus SleepNode::onStart(){\n\t    // Get the sleep duration from the input\n    double duration_ms;\n    if (!getInput(\"duration\", duration_ms)) {\n        return SUCCESS;\n    }\n\n    // Check if the duration is positive\n    if (duration_ms <= 0) {\n        return SUCCESS;\n    }\n\n    // Set the node status to RUNNING and start the timer\n    setStatus(RUNNING);\n    timer_waiting_ = true;\n    timer_.start(duration_ms / 1000.0);\n\n    // Set a callback to emit a wake-up signal when the timer expires\n    timer_.setCallback([this](TimerHandle) {\n        timer_waiting_ = false;\n        emitOutput(\"wakeup\", true);\n    });\n\n    return RUNNING;\n}", "CodeBleu_score": 46.52977814906677}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\n    // Get the entry\n    auto entry = blackboard->get<int>(entry_name);\n\n    // Check if the entry exists\n    if (!entry) {\n        return NodeStatus::FAILURE;\n    }\n\n    // Lock the entry's mutex\n    std::lock_guard<std::mutex> lock(entry->mutex);\n\n    // Check if the sequence ID has changed\n    if (entry->sequence_id != sequence_id) {\n        // Update the sequence ID\n        sequence_id = entry->sequence_id;\n        return NodeStatus::SUCCESS;\n    }\n\n    // Return FAILURE if the sequence ID has not changed\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 42.11695427662184}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // Get the entry from the blackboard\n    const auto entry = blackboard->get<rclcpp_action::ClientGoalHandle<ActionT>::SharedPtr>(entry_name);\n    if (!entry) {\n        return NodeStatus::FAILURE;\n    }\n\n    // Lock the entry's mutex\n    std::unique_lock<std::mutex> lock(*entry->get_mutex());\n\n    // Check if the entry has been updated\n    if (entry->get_goal_status().sequence_id != sequence_id) {\n        // Update the stored sequence ID\n        sequence_id = entry->get_goal_status().sequence_id;\n\n        // Return success\n        return NodeStatus::SUCCESS;\n    }\n\n    // Return failure\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 42.338292649304776}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    // Check if the entry exists and is updated\n    if (blackboard->exists(entry_name)) {\n        // Get the entry\n        Entry* entry = blackboard->getEntry(entry_name);\n        // Lock the entry mutex\n        entry->mutex.lock();\n        // Check if the sequence ID has changed\n        if (entry->sequence_id != last_sequence_id) {\n            // Update the last sequence ID\n            last_sequence_id = entry->sequence_id;\n            // Unlock the entry mutex\n            entry->mutex.unlock();\n            // Return SUCCESS\n            return NodeStatus::SUCCESS;\n        }\n        // Unlock the entry mutex\n        entry->mutex.unlock();\n    }\n    // Return FAILURE\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 38.733425495933204}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t    if (m_successThreshold < 0) {\n        return static_cast<size_t>(m_successThreshold * m_children.size());\n    }\n    return m_successThreshold;\n}", "CodeBleu_score": 50.75696519539004}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold < 0) {\n        return static_cast<size_t>(child_nodes.size() + success_threshold);\n    }\n    return static_cast<size_t>(success_threshold);\n}", "CodeBleu_score": 55.03819065468845}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (success_threshold < 0) {\n        return static_cast<size_t>(static_cast<double>(children.size()) * success_threshold);\n    } else {\n        return static_cast<size_t>(success_threshold);\n    }\n}", "CodeBleu_score": 58.273390092107476}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (!_p->stop_thread) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    if (_p->heartbeat_status != _p->last_heartbeat_status) {\n      enableAllHooks(_p->heartbeat_status == \"active\");\n      _p->last_heartbeat_status = _p->heartbeat_status;\n    }\n  }\n}", "CodeBleu_score": 32.16140957617828}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  while (true) {\n    // Sleep for 10 milliseconds\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n    // Check the current time against the last recorded heartbeat time\n    auto now = std::chrono::steady_clock::now();\n    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - _p->last_heartbeat);\n\n    // If the heartbeat is no longer active, disable all breakpoints\n    if (elapsed > std::chrono::milliseconds(2000)) {\n      for (auto& [node_uid, hook] : _p->pre_hooks) {\n        std::unique_lock<std::mutex> lk(hook->mutex);\n        hook->enabled = false;\n      }\n    }\n\n    // If the heartbeat is active again, enable all breakpoints\n    if (elapsed < std::chrono::milliseconds(2000)) {\n      for (auto& [node_uid, hook] : _p->pre_hooks) {\n        std::unique_lock<std::mutex> lk(hook->mutex);\n        hook->enabled = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 47.69032347500247}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (!_p->stop_heartbeat_thread) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    auto now = std::chrono::steady_clock::now();\n    std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n    for (auto& [node_uid, hook] : _p->pre_hooks) {\n      std::unique_lock<std::mutex> lk(hook->mutex);\n      if (hook->enabled && hook->mode == Monitor::Hook::Mode::HEARTBEAT) {\n        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(now - hook->last_heartbeat);\n        if (duration.count() > _p->heartbeat_timeout_ms) {\n          hook->enabled = false;\n          lk.unlock();\n          hook->wakeup.notify_all();\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 47.961922468973704}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    // Split the input string into a vector of blackboard names\n    std::vector<std::string> bb_names = split(bb_list, ',');\n\n    // Create a JSON object to store the blackboards\n    json blackboards;\n\n    // Iterate through the blackboard names\n    for (const std::string& bb_name : bb_names) {\n        // Find the corresponding subtree\n        auto subtree = blackboard_manager->getSubtree(bb_name);\n\n        // Lock the subtree\n        blackboard_manager->lockSubtree(subtree);\n\n        // Check if the subtree is valid\n        if (subtree) {\n            // Export the blackboard to JSON\n            json bb_json = subtree->getBlackboard();\n\n            // Add the blackboard to the JSON object\n            blackboards[bb_name] = bb_json;\n        }\n\n        // Unlock the subtree\n        blackboard_manager->unlockSubtree(subtree);\n    }\n\n    // Convert the JSON object to MessagePack format\n    std::vector<uint8_t> msgpack_data = json::to_msgpack(blackboards);\n\n    // Return the MessagePack data\n    return msgpack_data;\n}", "CodeBleu_score": 46.74017951533408}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t", "CodeBleu_score": 5.780157160879095}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t  std::vector<uint8_t> msgpack_data;\n  std::stringstream ss(bb_list);\n  std::string bb_name;\n  while (std::getline(ss, bb_name, ',')) {\n    auto subtree = blackboard_manager_->getSubtree(bb_name);\n    if (subtree) {\n      subtree->lock();\n      auto json_data = subtree->toJson();\n      subtree->unlock();\n      msgpack_data = jsonToMsgpack(json_data);\n    }\n  }\n  return msgpack_data;\n}", "CodeBleu_score": 40.17501155505075}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hooks = pos == Position::PRE ? &_p->pre_hooks : &_p->post_hooks;\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto bk_it = hooks->find(node_uid);\n  if(bk_it == hooks->end())\n  {\n    return false;\n  }\n  auto hook = bk_it->second;\n  if(!hook)\n  {\n    return false;\n  }\n  if(hook->getMode() != Monitor::Hook::Mode::BREAKPOINT)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> hlk(hook->getMutex());\n  hook->setStatus(result);\n  hook->setRemove(remove);\n  hook->setReady(true);\n  hook->notifyAll();\n  return true;\n}", "CodeBleu_score": 60.497036086860724}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hooks = pos == Position::PRE ? &_p->pre_hooks : &_p->post_hooks;\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto bk_it = hooks->find(node_uid);\n  if(bk_it == hooks->end())\n  {\n    return false;\n  }\n  auto hook = bk_it->second;\n  if(hook->is_valid() == false)\n  {\n    return false;\n  }\n  hook->lock();\n  if(hook->getMode() != Monitor::Hook::Mode::BREAKPOINT)\n  {\n    hook->unlock();\n    return false;\n  }\n  hook->setStatus(result);\n  hook->setRemove(remove);\n  hook->setReady(true);\n  hook->notify_all();\n  hook->unlock();\n  return true;\n}", "CodeBleu_score": 58.031703414724554}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hooks = pos == Position::PRE ? &_p->pre_hooks : &_p->post_hooks;\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto bk_it = hooks->find(node_uid);\n  if(bk_it == hooks->end())\n  {\n    return false;\n  }\n  auto hook = bk_it->second;\n  if(!hook || !hook->node || !hook->node->isValid())\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> hook_lk(hook->mutex);\n  if(hook->status == HookStatus::BREAKPOINT)\n  {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->cv.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 62.58688079423089}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  NodeStatus prev_status = status();\n\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    std::thread t(&ThreadedAction::tickThread, this);\n    t.detach();\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  if (!halt_requested_.load()) {\n    try {\n      NodeStatus status = tick_functor_(*this);\n      if (status != prev_status) {\n        setStatus(status);\n      }\n    } catch (...) {\n      catch_child_exception(std::current_exception());\n      setStatus(NodeStatus::IDLE);\n    }\n  }\n\n  rethrow_stored_exception();\n  return status();\n}", "CodeBleu_score": 43.99496025789493}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  NodeStatus prev_status = status();\n\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    thread_ = std::thread([this]() {\n      try {\n        tick_functor_(*this);\n      } catch (...) {\n        exception_ = std::current_exception();\n        halt();\n      }\n    });\n  }\n\n  if (halt_requested_.load()) {\n    setStatus(NodeStatus::IDLE);\n    halt_requested_.store(false);\n  }\n\n  if (exception_) {\n    try {\n      std::rethrow_exception(exception_);\n    } catch (...) {\n      exception_ = nullptr;\n      setStatus(NodeStatus::IDLE);\n    }\n  }\n\n  return status();\n}", "CodeBleu_score": 45.6271066470331}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  NodeStatus prev_status = status();\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    thread_ = std::thread(&ThreadedAction::tickThread, this);\n  }\n\n  if (halt_requested_.load()) {\n    setStatus(NodeStatus::IDLE);\n    return NodeStatus::IDLE;\n  }\n\n  if (exception_) {\n    std::rethrow_exception(exception_);\n  }\n\n  return prev_status;\n}", "CodeBleu_score": 29.967104358661334}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    stream << \"---------------------\" << std::endl;\n    std::function<void(const TreeNode*, int)> printTreeRecursivelyLambda = [&printTreeRecursivelyLambda, &stream](const TreeNode* node, int depth) {\n        for (int i = 0; i < depth; ++i) {\n            stream << \"| \";\n        }\n        stream << node->getName() << std::endl;\n        if (node->getType() == TreeNodeType::ControlNode) {\n            const ControlNode* control_node = static_cast<const ControlNode*>(node);\n            for (const auto& child : control_node->getChildren()) {\n                printTreeRecursivelyLambda(child, depth + 1);\n            }\n        } else if (node->getType() == TreeNodeType::DecoratorNode) {\n            const DecoratorNode* decorator_node = static_cast<const DecoratorNode*>(node);\n            printTreeRecursivelyLambda(decorator_node->getChild(), depth + 1);\n        }\n    };\n    printTreeRecursivelyLambda(root_node, 0);\n    stream << \"---------------------\" << std::endl;\n}", "CodeBleu_score": 53.115275448903574}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  stream << \"-----------------------------------------\n\";\n  stream << \"Starting tree printing.\n\";\n  stream << \"-----------------------------------------\n\";\n\n  auto print_node = [&stream](const TreeNode* node, int depth) {\n    std::string indent(depth, ' ');\n    stream << indent << node->getName() << \"\n\";\n  };\n\n  std::function<void(const TreeNode*, int)> print_children;\n  print_children = [&print_node, &print_children](const TreeNode* node, int depth) {\n    for (const auto& child : node->getChildren()) {\n      print_node(child, depth + 2);\n      if (child->getType() == TreeNodeType::Control) {\n        print_children(child, depth + 2);\n      } else if (child->getType() == TreeNodeType::Decorator) {\n        print_node(child->getChild(), depth + 2);\n      }\n    }\n  };\n\n  print_node(root_node, 0);\n  print_children(root_node, 0);\n\n  stream << \"-----------------------------------------\n\";\n  stream << \"Finished tree printing.\n\";\n  stream << \"-----------------------------------------\n\";\n}", "CodeBleu_score": 41.75540780071686}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  stream << \"------------------------\n\";\n  std::function<void(const TreeNode*, int)> print = [&](const TreeNode* node, int depth) {\n    for (int i = 0; i < depth; i++) {\n      stream << \"  \";\n    }\n    stream << node->name << \"\n\";\n    if (node->type == NodeType::Control) {\n      for (const auto& child : node->children) {\n        print(child.get(), depth + 1);\n      }\n    } else if (node->type == NodeType::Decorator) {\n      print(node->child.get(), depth + 1);\n    }\n  };\n  print(root_node, 0);\n  stream << \"------------------------\n\";\n}", "CodeBleu_score": 41.27177852237175}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  applyRecursiveVisitor(node, visitor);\n}", "CodeBleu_score": 14.9915070829085}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  applyRecursiveVisitor(node, visitor);\n}", "CodeBleu_score": 14.9915070829085}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.76380387418072}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t    if (m_builders.find(manifest.id) != m_builders.end()) {\n        throw BehaviorTreeException(\n            \"BehaviorTreeFactory::registerBuilder(): ID '\" + manifest.id +\n            \"' already registered!\");\n    }\n    m_builders.insert(std::make_pair(manifest.id, builder));\n    m_manifests.insert(std::make_pair(manifest.id, manifest));\n}", "CodeBleu_score": 47.25198064401616}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  auto it = builders.find(manifest.registrationID);\n  if (it != builders.end()) {\n    throw BehaviorTreeException(\n        \"BehaviorTreeFactory: registration ID already registered\");\n  }\n\n  builders.insert(std::make_pair(manifest.registrationID, builder));\n  manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 55.684733893660834}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (builders.find(manifest.id) != builders.end()) {\n    throw BehaviorTreeException(\n        \"BehaviorTreeFactory::registerBuilder(): ID already registered: \" +\n        manifest.id);\n  }\n\n  builders.insert(std::make_pair(manifest.id, builder));\n  manifests.insert(std::make_pair(manifest.id, manifest));\n}", "CodeBleu_score": 48.32515378470627}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor](const TreeNode& parent_node,\n                               const BT::NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(parent_node, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest(NodeType::ACTION, ID, std::move(ports));\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 58.86620898036846}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor](const TreeNode& parent_node,\n                               const std::string& name,\n                               const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(parent_node, name, tick_functor,\n                                              config);\n  };\n\n  TreeNodeManifest manifest(TreeNodeType::ACTION, ID, std::move(ports));\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 57.91075280556193}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor](const TreeNode& parent_node, const BT::NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(parent_node, tick_functor, config);\n  };\n  TreeNodeManifest manifest(TreeNodeType::ACTION, ID, ports);\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 55.51886634980539}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        auto backup = std::make_shared<Blackboard>();\n        backup->CopyFrom(*subtree->blackboard);\n        backups.push_back(backup);\n    }\n    return backups;\n}", "CodeBleu_score": 56.17621542556679}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> blackboard_backups;\n    blackboard_backups.reserve(tree.size());\n    for (const auto& subtree : tree) {\n        auto blackboard = std::make_shared<Blackboard>();\n        subtree->blackboard()->CloneInto(blackboard);\n        blackboard_backups.push_back(blackboard);\n    }\n    return blackboard_backups;\n}", "CodeBleu_score": 50.65918302354193}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        auto backup = std::make_shared<Blackboard>();\n        backup->CloneFrom(subtree->blackboard);\n        backups.push_back(backup);\n    }\n    return backups;\n}", "CodeBleu_score": 56.303028591671854}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto parse_result = ParseScript(script);\n  if(parse_result)\n  {\n    return parse_result(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(parse_result.error());\n  }\n}", "CodeBleu_score": 68.07569889611878}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto script_function = ParseScript(script);\n  if(script_function)\n  {\n    return script_function(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(script_function.error());\n  }\n}", "CodeBleu_score": 68.05987111729867}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto script_parse_result = ParseScript(script);\n  if(script_parse_result)\n  {\n    return script_parse_result.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(script_parse_result.error());\n  }\n}", "CodeBleu_score": 71.92360340120523}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(\"Failed to load library: \" + std::string(dlerror()));\n    }\n    loaded = true;\n    this->path = path;\n}", "CodeBleu_score": 58.01215621369904}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    loaded = true;\n    this->path = path;\n}", "CodeBleu_score": 55.0479523853168}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex);\n    if (loaded) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    loaded = true;\n}", "CodeBleu_score": 48.90341411765831}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.size() < 3) {\n    return false;\n  }\n  StringView stripped = str.trim();\n  if (stripped[0] != '{' || stripped[stripped.size() - 1] != '}') {\n    return false;\n  }\n  if (stripped_pointer != nullptr) {\n    *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n  }\n  return true;\n}", "CodeBleu_score": 25.893147141331113}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n    str.strip();\n    if (str.size() < 3) {\n        return false;\n    }\n    if (str[0] != '{' || str[str.size() - 1] != '}') {\n        return false;\n    }\n    if (stripped_pointer) {\n        *stripped_pointer = str.substr(1, str.size() - 2);\n    }\n    return true;\n}", "CodeBleu_score": 26.09425243069372}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    if (str.size() < 3) {\n        return false;\n    }\n\n    // Strip leading and trailing spaces\n    StringView str_stripped = str;\n    str_stripped.trim();\n\n    if (str_stripped.size() < 3) {\n        return false;\n    }\n\n    // Check if the stripped string starts with '{' and ends with '}'\n    if (str_stripped[0] != '{' || str_stripped[str_stripped.size() - 1] != '}') {\n        return false;\n    }\n\n    // Assign the inner content to stripped_pointer if provided\n    if (stripped_pointer) {\n        *stripped_pointer = str_stripped.substr(1, str_stripped.size() - 2);\n    }\n\n    return true;\n}", "CodeBleu_score": 30.237925611567}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    double line_cost = -std::numeric_limits<double>::infinity();\n    //calculate the line cost\n    LineIterator line(x0, y0, x1, y1);\n    //iterate through each point on the line\n    for(int x = line.x0, y = line.y0; line.isValid(); line.advance()) {\n        //calculate the point cost\n        double cost = pointCost(x, y);\n        //if the point cost is negative, return it immediately\n        if(cost < 0)\n          return cost;\n        //update the line cost if the point cost is higher\n        line_cost = std::max(line_cost, cost);\n    }\n    return line_cost;\n  }", "CodeBleu_score": 51.53649306181762}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    double line_cost = -1;\n    double point_cost;\n    LineIterator line(x0, y0, x1, y1);\n    for(unsigned int i = 0; i < line.getNumCells(); line.advanceCell(), i++) {\n        point_cost = pointCost(line.getX(), line.getY());\n        if(point_cost < 0)\n            return point_cost;\n        line_cost = std::max(line_cost, point_cost);\n    }\n    return line_cost;\n}", "CodeBleu_score": 70.19247980312059}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    double line_cost = 0.0;\n    double point_cost;\n    for (LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance()) {\n        point_cost = pointCost(line.getX(), line.getY());\n        if (point_cost < 0) {\n            return point_cost;\n        }\n        line_cost = std::max(line_cost, point_cost);\n    }\n    return line_cost;\n}", "CodeBleu_score": 70.66764016672703}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    if (path.empty()) {\n        return;\n    }\n\n    nav_msgs::Path msg;\n    msg.header.frame_id = path[0].header.frame_id;\n    msg.header.stamp = path[0].header.stamp;\n\n    for (const geometry_msgs::PoseStamped& pose : path) {\n        msg.poses.push_back(pose);\n    }\n\n    pub.publish(msg);\n}", "CodeBleu_score": 50.761197089989516}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  // Create a nav_msgs::Path message\n  nav_msgs::Path path_msg;\n\n  // Initialize the header of the message with the frame_id and timestamp of the first pose in the path\n  path_msg.header.frame_id = path[0].header.frame_id;\n  path_msg.header.stamp = path[0].header.stamp;\n\n  // Copy the poses from the input path to the path message\n  for (const auto& pose : path) {\n    path_msg.poses.push_back(pose);\n  }\n\n  // Publish the path message\n  pub.publish(path_msg);\n}", "CodeBleu_score": 44.770791145408275}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    //ROS_INFO(\"Publishing plan\");\n    if (path.empty()) {\n        ROS_INFO(\"Path is empty\");\n        return;\n    }\n\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = path[0].header.frame_id;\n    path_msg.header.stamp = path[0].header.stamp;\n\n    for (const auto& pose : path) {\n        path_msg.poses.push_back(pose);\n    }\n\n    pub.publish(path_msg);\n}", "CodeBleu_score": 51.194405873636704}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  double rot_vel = std::abs(base_odom.twist.twist.angular.z);\n  double trans_vel = std::abs(base_odom.twist.twist.linear.x);\n  return (rot_vel <= rot_stopped_velocity) && (trans_vel <= trans_stopped_velocity);\n}", "CodeBleu_score": 53.783877277151895}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) &&\n         (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) &&\n         (fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity);\n}", "CodeBleu_score": 68.45110549378161}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\n    // Get the linear and angular velocities from the odometry message\n    double linear_vel = sqrt(pow(base_odom.twist.twist.linear.x, 2) + pow(base_odom.twist.twist.linear.y, 2));\n    double angular_vel = base_odom.twist.twist.angular.z;\n\n    // Check if the linear and angular velocities are below or equal to the given thresholds\n    if (linear_vel <= trans_stopped_velocity && angular_vel <= rot_stopped_velocity) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 52.4706683720094}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  // If the setup flag is true, reset the configuration to default limits.\n  if (restore_defaults) {\n    config = default_limits_;\n  }\n\n  // If setup is not yet done, initialize the default limits with the provided configuration and set up the flag.\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n\n  // Lock the configuration mutex and update the current limits with the new configuration.\n  boost::mutex::scoped_lock lock(configuration_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 73.13636576724876}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t    boost::mutex::scoped_lock l(config_mutex_);\n    if (setup_) {\n        if (restore_defaults) {\n            config = default_limits_;\n        }\n    } else {\n        default_limits_ = config;\n        setup_ = true;\n    }\n    limits_ = config;\n}", "CodeBleu_score": 68.846336840086}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  // If setup is not yet done, initialize the default limits with the provided configuration and set up the flag.\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n\n  // If restore_defaults is true, reset the configuration to default limits.\n  if (restore_defaults) {\n    config = default_limits_;\n  }\n\n  // Lock the configuration mutex and update the current limits with the new configuration.\n  boost::mutex::scoped_lock lock(configuration_mutex_);\n  current_limits_ = config;\n}", "CodeBleu_score": 72.05138204215802}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  // Check if the cell is an obstacle\n  unsigned int check_cell_cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (check_cell_cost == costmap_2d::NO_INFORMATION || check_cell_cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    // If the cell is an obstacle, set the cell's target distance to the maximum obstacle cost\n    check_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  // Calculate the new target distance\n  double new_target_distance = current_cell->target_distance + distance(current_cell->x, current_cell->y, check_cell->x, check_cell->y);\n\n  // Update the cell's target distance if the new distance is shorter\n  if (new_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_target_distance;\n    return true;\n  }\n\n  // Return true if the cell's target distance was updated\n  return true;\n}", "CodeBleu_score": 60.161876695337604}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  // Check if the cell is an obstacle or has no information\n  if (check_cell->cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  // Calculate a new target distance\n  double new_distance = current_cell->distance + getDistance(current_cell, check_cell);\n\n  // Update the cell's target distance if the new distance is shorter\n  if (new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 45.52554145253167}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\n  unsigned int check_cell_index = check_cell->getIndex();\n  unsigned int check_cell_cost = costmap.getCost(check_cell_index);\n  unsigned int check_cell_target_cost = check_cell->getTargetCost();\n\n  if (check_cell_cost == costmap_2d::NO_INFORMATION) {\n    check_cell->setTargetCost(max_obstacle_cost_);\n    return false;\n  }\n\n  if (check_cell_cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->setTargetCost(max_obstacle_cost_);\n    return false;\n  }\n\n  unsigned int new_target_cost =\n      current_cell->getTargetCost() + check_cell_cost;\n\n  if (new_target_cost < check_cell_target_cost) {\n    check_cell->setTargetCost(new_target_cost);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 47.78964759766456}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Attempting to score a trajectory with no footprint specified!\");\n    return -9.0;\n  }\n  for(unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.x_[i], traj.y_[i], traj.th_[i], scale, footprint_spec_, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 63.241413768035095}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Attempting to score a trajectory with an empty footprint\");\n    return -9.0;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double px = traj.x0_ + traj.xv_ * traj.getX(i);\n    double py = traj.y0_ + traj.yv_ * traj.getX(i);\n    double pth = traj.th0_ + traj.thv_ * traj.getX(i);\n\n    double footprint_cost = footprintCost(px, py, pth, scale, footprint_spec_, costmap_, world_model_);\n\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 71.94089871062761}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  //initialize the cost and scaling factor based on the trajectory and speed parameters\n  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //if we have no footprint... then we'll just return zero... or we could return all zeros if we wanted to...\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Attempting to score a trajectory with an empty footprint.\");\n    return -9.0;\n  }\n\n  //now we'll score each cell in the footprint of the trajectory\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = footprintCost(traj.x_[i], traj.y_[i], traj.th_[i], scale, footprint_spec_, costmap_, world_model_);\n\n    //if the footprint is not legal, we can stop checking\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n\n    //add the cost of this footprint to the total cost...\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      if (footprint_cost > cost) {\n        cost = footprint_cost;\n      }\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 61.85792753311377}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t    // Check if the footprint is off the map\n    if (!world_model->footprintCost(x, y, th, footprint_spec, costmap)) {\n        return -7.0;\n    }\n\n    // Scale the footprint\n    std::vector<geometry_msgs::Point> scaled_footprint = footprint_spec;\n    for (unsigned int i = 0; i < scaled_footprint.size(); i++) {\n        scaled_footprint[i].x *= scale;\n        scaled_footprint[i].y *= scale;\n    }\n\n    // Compute the footprint cost\n    double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint, costmap);\n\n    // Return the maximum cost between the footprint cost and the cell cost at the given position\n    double cell_cost = costmap->getCost(costmap->getIndexX(x, y));\n    return std::max(cell_cost, footprint_cost);\n}", "CodeBleu_score": 55.435352214623826}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  boost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic.empty()) {\n    ROS_INFO_NAMED(\"dwa_local_planner\", \"Shutting down odometry helper, odom topic was empty\");\n    if (odom_sub_) {\n      odom_sub_.shutdown();\n    }\n    return;\n  }\n  if (odom_topic != odom_topic_) {\n    ROS_INFO_NAMED(\"dwa_local_planner\", \"Odometry topic set to %s\", odom_topic.c_str());\n    odom_topic_ = odom_topic;\n    if (odom_sub_) {\n      odom_sub_.shutdown();\n    }\n    odom_sub_ = nh_->subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n  }\n}", "CodeBleu_score": 37.6971761762255}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n      ROS_INFO(\"subscribed to odom topic %s\", odom_topic_.c_str());\n    } else {\n      odom_sub_.shutdown();\n      ROS_INFO(\"shutdown odom topic\");\n    }\n  }\n}", "CodeBleu_score": 51.62618801395828}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic != \"\") {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 52.4506110351179}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  Eigen::Vector3f delta_pos = pos - prev;\n  float sq_dist = delta_pos.squaredNorm();\n  float dist = sqrt(sq_dist);\n  float angle = atan2(delta_pos(1), delta_pos(0));\n\n  if (sq_dist > sq_dist_thresh_ || fabs(angle) > angle_thresh_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 37.388701809980795}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  // Calculate squared distance between current and previous position\n  float dist_sq = (pos - prev).squaredNorm();\n\n  // Calculate angular difference between current and previous orientation\n  float angle = std::abs(std::atan2(prev[1], prev[0]) - std::atan2(pos[1], pos[0]));\n\n  // If squared distance exceeds threshold or angular difference is greater than set angle, reset oscillation flags\n  if (dist_sq > dist_threshold_sq_ || angle > angle_threshold_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 43.06515346460723}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  // Calculate the squared distance and the angular difference\n  float dist_sq = (pos - prev).squaredNorm();\n  float ang_diff = std::abs(atan2(pos(1), pos(0)) - atan2(prev(1), prev(0)));\n\n  // If the squared distance exceeds a threshold or the angular difference is greater than a set angle, reset the oscillation flags\n  if (dist_sq > dist_sq_threshold_ || ang_diff > ang_diff_threshold_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 36.86702014341212}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  gridCoords(pt, gx, gy);\n\n  //check if the point is too close to its nearest neighbor\n  if(nearestNeighborDistance(pt) < sq_min_separation_){\n    return;\n  }\n\n  //check if the point is outside the grid bounds\n  if(gx >= width_ || gy >= height_){\n    return;\n  }\n\n  //calculate the grid index\n  unsigned int index = gx + width_ * gy;\n\n  //insert the point into the cell\n  cells_[index].push_back(pt);\n}", "CodeBleu_score": 67.46191893705368}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //get the grid coordinates of the point\n  unsigned int gx, gy;\n  gridCoords(pt, gx, gy);\n\n  //if the point is outside the grid bounds, return\n  if(gx >= width_ || gy >= height_)\n    return;\n\n  //if the point is too close to its nearest neighbor, return\n  if(nearestNeighborDistance(pt) < sq_min_separation_)\n    return;\n\n  //calculate the grid index\n  unsigned int index = gx + gy * width_;\n\n  //insert the point into the corresponding cell\n  grid_[index].push_back(pt);\n}", "CodeBleu_score": 74.76036591215923}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  gridCoords(pt, gx, gy);\n\n  //if the point is outside the grid bounds, return\n  if(gx >= width_ || gy >= height_)\n    return;\n\n  //if the point is too close to its nearest neighbor, return\n  if(nearestNeighborDistance(pt) < sq_min_separation_)\n    return;\n\n  //calculate the grid index\n  unsigned int index = gx + width_ * gy;\n\n  //insert the point\n  points_[index].push_back(pt);\n\n  //increment the number of points in the grid\n  num_points_++;\n}", "CodeBleu_score": 73.2991312407956}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n        }\n        else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n        }\n        else {\n            new_vel[i] = sample_target_vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 73.23629959699578}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n        }\n        else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n        }\n        else {\n            new_vel[i] = sample_target_vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 77.35186119070417}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n    // Initialize new velocity vector to zero\n    Eigen::Vector3f new_vel(0.0, 0.0, 0.0);\n\n    // For each of the three velocity components, increase or decrease the current velocity towards the target velocity within the acceleration limits\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n        } else if (sample_target_vel[i] < vel[i]) {\n            new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n        } else {\n            new_vel[i] = vel[i];\n        }\n    }\n\n    // Return the new velocity vector\n    return new_vel;\n}", "CodeBleu_score": 73.50390561617473}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  //Find the farthest point on the path with a clear line of sight from the current cell\n  int goal_cell_x = cell_x;\n  int goal_cell_y = cell_y;\n\n  for (int i = global_plan.size() - 1; i >= 0; i--) {\n    int x = global_plan[i].x;\n    int y = global_plan[i].y;\n\n    if (lineOfSight(cell_x, cell_y, x, y)) {\n      goal_cell_x = x;\n      goal_cell_y = y;\n      break;\n    }\n  }\n\n  //Convert the goal cell coordinates to world coordinates\n  double goal_x = goal_cell_x * costmap_->getResolution() + costmap_->getOriginX();\n  double goal_y = goal_cell_y * costmap_->getResolution() + costmap_->getOriginY();\n\n  //Calculate the shortest angular distance between the current heading and the direction to the goal point\n  double diff = atan2(goal_y - y, goal_x - x) - heading;\n\n  //Normalize the difference to be between -pi and pi\n  if (diff > M_PI) {\n    diff -= 2 * M_PI;\n  } else if (diff < -M_PI) {\n    diff += 2 * M_PI;\n  }\n\n  return abs(diff);\n}", "CodeBleu_score": 51.960668656809794}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  int goal_x, goal_y;\n  double goal_x_world, goal_y_world;\n  double heading_diff;\n  double min_heading_diff = DBL_MAX;\n  double heading_diff_abs;\n  double dx, dy;\n\n  //Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    goal_x = global_plan_[i].x;\n    goal_y = global_plan_[i].y;\n\n    //Convert the goal cell coordinates to world coordinates\n    goal_x_world = goal_x * costmap_->getResolution() + costmap_->getOriginX();\n    goal_y_world = goal_y * costmap_->getResolution() + costmap_->getOriginY();\n\n    //Calculate the shortest angular distance between the current heading and the direction to the goal point\n    dx = goal_x_world - x;\n    dy = goal_y_world - y;\n    heading_diff = atan2(dy, dx) - heading;\n    heading_diff_abs = fabs(heading_diff);\n\n    //If the heading difference is less than 180 degrees, use the absolute value\n    if (heading_diff_abs < M_PI) {\n      if (heading_diff_abs < min_heading_diff) {\n        min_heading_diff = heading_diff_abs;\n      }\n    }\n    //If the heading difference is greater than 180 degrees, use the complement of the absolute value\n    else {\n      if (2 * M_PI - heading_diff_abs < min_heading_diff) {\n        min_heading_diff = 2 * M_PI - heading_diff_abs;\n      }\n    }\n  }\n\n  return min_heading_diff;\n}", "CodeBleu_score": 47.84464203865249}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  double min_dist = DBL_MAX;\n  double min_angle = DBL_MAX;\n  double dist;\n  double angle;\n\n  // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  for (int i = global_plan.size() - 1; i >= 0; i--) {\n    if (global_plan[i].x == cell_x && global_plan[i].y == cell_y) {\n      // Convert the goal cell coordinates to world coordinates\n      double goal_x = global_plan[i].x * costmap_.getResolution() + costmap_.getOriginX();\n      double goal_y = global_plan[i].y * costmap_.getResolution() + costmap_.getOriginY();\n\n      // Calculate the shortest angular distance between the current heading and the direction to the goal point\n      dist = sqrt(pow(goal_x - x, 2) + pow(goal_y - y, 2));\n      angle = atan2(goal_y - y, goal_x - x) - heading;\n      if (angle > M_PI) {\n        angle -= 2 * M_PI;\n      } else if (angle < -M_PI) {\n        angle += 2 * M_PI;\n      }\n\n      // Update the minimum distance and angle if this point is closer than the previous minimum\n      if (dist < min_dist) {\n        min_dist = dist;\n        min_angle = angle;\n      }\n    }\n  }\n\n  return fabs(min_angle);\n}", "CodeBleu_score": 47.286777317826676}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0)\n      return true;\n    else {\n      ROS_WARN(\"Invalid trajectory: (%.2f, %.2f, %.2f), (%.2f, %.2f, %.2f), cost: %.2f\",\n               x, y, theta, vx, vy, vtheta, cost);\n      return false;\n    }\n  }", "CodeBleu_score": 67.14915576229208}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    Trajectory t;\n    double impossible_cost = path_map_.obstacleCosts();\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // return true if trajectory is valid\n    if ( t.cost_ >= 0 )\n      return true;\n\n    // trajectory is invalid, so log a warning\n    ROS_WARN(\"Trajectory is invalid with cost: %f\", t.cost_);\n    ROS_WARN(\"Trajectory: x:%f, y:%f, theta:%f, vx:%f, vy:%f, vtheta:%f, ax:%f, ay:%f, atheta:%f\",\n             x, y, theta, vx, vy, vtheta,\n             vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }", "CodeBleu_score": 56.01035148988359}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0) {\n      return true;\n    } else {\n      ROS_WARN(\"Trajectory is invalid with cost: %.2f, vx: %.2f, vy: %.2f, vtheta: %.2f\", cost, vx_samp, vy_samp, vtheta_samp);\n      return false;\n    }\n  }", "CodeBleu_score": 77.08129867670004}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  ROS_INFO(\"Running ClearCostmapRecovery\");\n\n  if (!initialized_){\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before runBehavior().\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"ClearCostmapRecovery needs a global and local costmap to work\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"ClearCostmapRecovery: clearing area inside the polygon\");\n  } else {\n    ROS_WARN(\"ClearCostmapRecovery: clearing area outside the polygon\");\n  }\n\n  ros::Time start = ros::Time::now();\n\n  if (affected_maps_ & AffectedMaps::GLOBAL_COSTMAP) {\n    clear(global_costmap_);\n  }\n\n  if (affected_maps_ & AffectedMaps::LOCAL_COSTMAP) {\n    clear(local_costmap_);\n  }\n\n  if (force_update_){\n    if (affected_maps_ & AffectedMaps::GLOBAL_COSTMAP) {\n      global_costmap_->updateMap();\n    }\n\n    if (affected_maps_ & AffectedMaps::LOCAL_COSTMAP) {\n      local_costmap_->updateMap();\n    }\n  }\n\n  ROS_INFO_STREAM(\"ClearCostmapRecovery time: \" << (ros::Time::now() - start).toSec() << \" seconds\");\n}", "CodeBleu_score": 51.22203197572881}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"The global_costmap passed in is null. Cannot clear map.\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"The local_costmap passed in is null. Cannot clear map.\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"This object configured to clear area outside of the specified area\");\n  }\n\n  ros::Time start = ros::Time::now();\n\n  if (affected_maps_ & clearing_robot_local_costmap_) {\n    clear(local_costmap_);\n  }\n\n  if (affected_maps_ & clearing_global_costmap_) {\n    clear(global_costmap_);\n  }\n\n  if (force_update_) {\n    local_costmap_->updateMap(0, 0);\n    global_costmap_->updateMap(0, 0);\n  }\n\n  ROS_INFO(\"Cleared %d maps in %.3f seconds\", affected_maps_, (ros::Time::now() - start).toSec());\n}", "CodeBleu_score": 43.427637790678084}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  // if the polygon is empty, just return\n  if (polygon.empty()) {\n    return;\n  }\n\n  // if the polygon is not empty, close the polygon by connecting the last point to the first\n  std::vector<MapLocation> polygon_closed(polygon);\n  polygon_closed.push_back(polygon[0]);\n\n  // iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points\n  for (unsigned int i = 0; i < polygon_closed.size() - 1; ++i) {\n    raytraceLine(polygon_closed[i], polygon_closed[i + 1], polygon_cells);\n  }\n}", "CodeBleu_score": 43.515027552286725}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  // If the polygon is empty, we're done.\n  if (polygon.empty())\n    return;\n\n  // Add the cells between each consecutive pair of points.\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], polygon_cells);\n  }\n\n  // Connect the last point to the first.\n  if (polygon.size() >= 3) {\n    raytraceLine(polygon.back(), polygon.front(), polygon_cells);\n  }\n}", "CodeBleu_score": 46.70623411383874}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t", "CodeBleu_score": 5.034306355366355}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 97.26861875427473}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t    // Lock the costmap mutex\n    std::lock_guard<std::mutex> lock(costmap_mutex_);\n\n    // Retrieve the resolution\n    double resolution = costmap_->getResolution();\n\n    // Set the grid's header\n    grid_.header.frame_id = costmap_->getGlobalFrameID();\n    grid_.header.stamp = ros::Time::now();\n\n    // Set the grid's resolution\n    grid_.info.resolution = resolution;\n\n    // Set the grid's width and height\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    // Convert the map coordinates to world coordinates for the origin\n    double origin_x = costmap_->getOriginX();\n    double origin_y = costmap_->getOriginY();\n\n    // Set the origin's position and orientation\n    grid_.info.origin.position.x = origin_x;\n    grid_.info.origin.position.y = origin_y;\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    // Save the origin coordinates\n    origin_x_ = origin_x;\n    origin_y_ = origin_y;\n\n    // Resize the grid data vector\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    // Populate the grid data from the costmap's character map using a translation table\n    const unsigned char* costmap_data = costmap_->getCharMap();\n    for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n        grid_.data[i] = costmap_to_grid_[costmap_data[i]];\n    }\n}", "CodeBleu_score": 70.80260335945341}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t    // Lock the costmap mutex\n    std::lock_guard<std::mutex> lock(costmap_mutex_);\n\n    // Get the resolution from the costmap\n    double resolution = costmap_->getResolution();\n\n    // Set the grid's header, resolution, width, and height\n    grid_.header.frame_id = costmap_->getGlobalFrameID();\n    grid_.header.stamp = ros::Time::now();\n    grid_.info.resolution = resolution;\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    // Convert the map coordinates to world coordinates for the origin\n    double origin_x, origin_y;\n    costmap_->mapToWorld(0, 0, origin_x, origin_y);\n\n    // Set the origin's position and orientation\n    grid_.info.origin.position.x = origin_x;\n    grid_.info.origin.position.y = origin_y;\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    // Save the origin coordinates\n    origin_x_ = origin_x;\n    origin_y_ = origin_y;\n\n    // Resize the grid data vector\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    // Populate the grid data from the costmap's character map using a translation table\n    const unsigned char* char_map = costmap_->getCharMap();\n    for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n        unsigned char value = char_map[i];\n        grid_.data[i] = translation_table_[value];\n    }\n}", "CodeBleu_score": 69.66849433851033}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // Lock the costmap mutex\n  boost::unique_lock<boost::mutex> lock(*(costmap->getMutex()));\n\n  // Get the costmap's resolution\n  double resolution = costmap->getResolution();\n\n  // Set the grid's header\n  grid.header.frame_id = costmap->getGlobalFrameID();\n  grid.header.stamp = ros::Time::now();\n\n  // Set the grid's resolution\n  grid.info.resolution = resolution;\n\n  // Set the grid's width and height\n  grid.info.width = costmap->getSizeInCellsX();\n  grid.info.height = costmap->getSizeInCellsY();\n\n  // Convert the map coordinates to world coordinates for the origin\n  double origin_x, origin_y;\n  costmap->mapToWorld(0.0, 0.0, origin_x, origin_y);\n\n  // Set the origin's position and orientation\n  grid.info.origin.position.x = origin_x;\n  grid.info.origin.position.y = origin_y;\n  grid.info.origin.position.z = 0.0;\n  grid.info.origin.orientation.x = 0.0;\n  grid.info.origin.orientation.y = 0.0;\n  grid.info.origin.orientation.z = 0.0;\n  grid.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  origin_x_ = origin_x;\n  origin_y_ = origin_y;\n\n  // Resize the grid data vector\n  grid.data.resize(grid.info.width * grid.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < grid.data.size(); i++) {\n    grid.data[i] = costmap_translation_table_[costmap->getCharMap()[i]];\n  }\n}", "CodeBleu_score": 63.293783467616294}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // check if the footprint and radius are the same\n  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // check if the new config contains a valid footprint string\n  if (!new_config.footprint.empty()) {\n    // convert the footprint string to a vector of points\n    std::vector<geometry_msgs::Point> footprint;\n    if (!parseFootprintFromString(new_config.footprint, footprint)) {\n      ROS_ERROR(\"Failed to parse footprint string: %s\", new_config.footprint.c_str());\n      return;\n    }\n\n    // set the new footprint\n    setUnpaddedRobotFootprint(footprint);\n  } else {\n    // set the new footprint based on the robot radius\n    setUnpaddedRobotFootprint(createFootprintFromRadius(new_config.robot_radius));\n  }\n}", "CodeBleu_score": 71.83358563600407}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint)\n    return;\n\n  if (new_config.footprint.empty()) {\n    ROS_ERROR(\"Footprint string is empty, cannot update footprint from config server\");\n    return;\n  }\n\n  std::vector<geometry_msgs::Point> points;\n  if (!costmap_2d::makeFootprintFromString(new_config.footprint, points)) {\n    ROS_ERROR(\"Error parsing footprint string '%s'\", new_config.footprint.c_str());\n    return;\n  }\n\n  setUnpaddedRobotFootprint(points);\n}", "CodeBleu_score": 49.122573939366156}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  std::vector<geometry_msgs::Point> footprint;\n  if (costmap_2d::makeFootprintFromString(new_config.footprint, footprint)) {\n    setUnpaddedRobotFootprint(footprint);\n  } else {\n    ROS_ERROR(\"Error parsing footprint string '%s'\", new_config.footprint.c_str());\n  }\n}", "CodeBleu_score": 42.515271786909125}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose\");\n    return;\n  }\n\n  // Check if the robot has moved significantly\n  if (new_pose.header.frame_id != global_pose_.header.frame_id) {\n    ROS_ERROR_THROTTLE(1.0, \"Global frame id (%s) does not match robot pose frame id (%s)\",\n                       global_pose_.header.frame_id.c_str(), new_pose.header.frame_id.c_str());\n    return;\n  }\n\n  double dx = new_pose.pose.position.x - global_pose_.pose.position.x;\n  double dy = new_pose.pose.position.y - global_pose_.pose.position.y;\n  double dist = sqrt(dx * dx + dy * dy);\n\n  if (dist > transform_tolerance_) {\n    // Update the global pose\n    global_pose_ = new_pose;\n\n    // Update the costmap\n    costmap_ros_->updateOrigin(global_pose_.pose.position.x, global_pose_.pose.position.y);\n  }\n}", "CodeBleu_score": 60.6604428942661}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t    geometry_msgs::PoseStamped new_pose;\n    if (!getRobotPose(new_pose)) {\n        ROS_WARN_THROTTLE(1.0, \"Could not get robot pose\");\n        return;\n    }\n    // check if the robot has moved far enough for a new map update\n    if (new_pose.header.frame_id != global_frame_) {\n        ROS_ERROR_THROTTLE(1.0, \"Costmap2DROS frame_id, %s, must match global_frame_, %s\",\n                           new_pose.header.frame_id.c_str(), global_frame_.c_str());\n        return;\n    }\n    if (new_pose.header.stamp != ros::Time(0) &&\n        (new_pose.header.stamp.sec != last_transform_timestamp_.sec ||\n         new_pose.header.stamp.nsec != last_transform_timestamp_.nsec)) {\n        last_transform_timestamp_ = new_pose.header.stamp;\n        updateOrigin(new_pose.pose.position.x, new_pose.pose.position.y, new_pose.pose.position.z);\n    }\n}", "CodeBleu_score": 66.75055008503075}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  // Check if the costmap was stopped\n  if (stopped_) {\n    // Get the list of plugins\n    std::vector<std::string> plugins;\n    nh_.param(\"plugins\", plugins, std::vector<std::string>());\n\n    // Re-subscribe to topics by activating each plugin\n    for (std::vector<std::string>::const_iterator plugin = plugins.begin(); plugin != plugins.end(); ++plugin) {\n      // Activate the plugin\n      activatePlugin(*plugin);\n    }\n\n    // Set the stopped flag to false\n    stopped_ = false;\n  }\n\n  // Set the stop_updates_ flag to false\n  stop_updates_ = false;\n\n  // Wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::isInitialized() || !initialized_ || !map_update_thread_) {\n    ros::WallDuration(0.1).sleep();\n  }\n}", "CodeBleu_score": 52.39673470033862}, {"code": "void Costmap2DROS::start(){\n\t  if (!ros::isInitialized()) {\n    ROS_FATAL_STREAM(\"A node for ROS is not initialized, unable to start the \"\n                     \"Costmap2DROS node\");\n    return;\n  }\n\n  if (stopped_) {\n    ROS_INFO(\"Starting the Costmap2DROS node\");\n    stopped_ = false;\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin =\n             plugins_->begin();\n         plugin != plugins_->end(); ++plugin) {\n      (*plugin)->onInitialize();\n    }\n    stop_updates_ = false;\n  }\n\n  while (!ros::isShuttingDown() && !initialized_ && !update_thread_) {\n    usleep(100000);\n  }\n}", "CodeBleu_score": 50.21625275220789}, {"code": "void Costmap2DROS::start(){\n\t  // if the costmap is stopped, reactivate it\n  if (stopped_) {\n    std::vector<std::string> plugin_names;\n    ros::param::get(\"~plugins\", plugin_names);\n\n    // re-subscribe to topics\n    for (unsigned int i = 0; i < plugin_names.size(); ++i) {\n      std::string plugin_name = plugin_names[i];\n      std::vector<std::string>::iterator it = std::find(plugins_.begin(), plugins_.end(), plugin_name);\n      if (it != plugins_.end()) {\n        // re-subscribe to topics\n        plugins_[i]->subscribe();\n      }\n    }\n\n    // re-start the update thread\n    stop_updates_ = false;\n    stopped_ = false;\n    update_thread_ = boost::thread(boost::bind(&Costmap2DROS::updateMap, this));\n  }\n\n  // wait for ROS to come up\n  while (!ros::isInitialized()) {\n    usleep(100000);\n  }\n\n  // wait for costmap to become initialized\n  while (!costmap_->initialized()) {\n    usleep(100000);\n  }\n\n  // wait for the update thread to become active\n  while (!update_thread_.timed_join(boost::posix_time::milliseconds(100))) {\n    usleep(100000);\n  }\n}", "CodeBleu_score": 45.97113340653005}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == 0) {\n    // If we are keeping all observations, do nothing\n    return;\n  }\n  // If we are not keeping all observations, remove outdated observations\n  // from the list.\n  // If the observation_keep_time_ is zero, it keeps only the most recent\n  // observation. Otherwise, it iterates through the list and removes\n  // observations that are older than the specified keep time, stopping once it\n  // finds a valid observation.\n  while (observations_.size() > 1) {\n    // Get the oldest observation\n    const auto oldest = observations_.front();\n    // Get the current time\n    const auto now = ros::Time::now();\n    // If the oldest observation is older than the keep time, remove it\n    if (now - oldest.header.stamp > observation_keep_time_) {\n      observations_.pop_front();\n    } else {\n      // If the oldest observation is not older than the keep time, stop\n      // removing observations\n      break;\n    }\n  }\n}", "CodeBleu_score": 31.03318171758474}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == 0) {\n    return;\n  }\n  for (std::list<Observation>::iterator it = observations_.begin(); it != observations_.end(); it++) {\n    if ((ros::Time::now() - it->timestamp) > observation_keep_time_) {\n      observations_.erase(it);\n      return;\n    }\n  }\n}", "CodeBleu_score": 35.374484264455994}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\n  if (observation_keep_time_ == 0) {\n    // If we are keeping only the most recent observation, then just remove all but the most recent.\n    while (observations_.size() > 1) {\n      observations_.pop_back();\n    }\n  } else {\n    // If we are keeping only the most recent observation, then just remove all but the most recent.\n    while (observations_.size() > 1) {\n      observations_.pop_back();\n    }\n  }\n}", "CodeBleu_score": 18.40489273881656}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  // Calculate the yaw angles at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the two yaw angles\n  double angular_distance = std::fmod(end_yaw - start_yaw + M_PI, 2 * M_PI) - M_PI;\n\n  // Calculate the incremental change in angle for each pose in the specified range\n  double increment = angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; ++i) {\n    double yaw = start_yaw + increment * (i - start_index);\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 64.5402361689848}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  // Get the start and end orientations\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end orientations\n  double angular_distance = std::fmod(end_yaw - start_yaw + M_PI, 2 * M_PI) - M_PI;\n\n  // Compute the incremental change in angle\n  double increment = angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    double yaw = start_yaw + increment * (i - start_index);\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 64.70994125408544}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  // Get the yaw angles at the start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end indices\n  double angular_distance = std::fmod(end_yaw - start_yaw + M_PI, 2 * M_PI) - M_PI;\n\n  // Compute the incremental change in angle\n  double increment = angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    double yaw = start_yaw + increment * (i - start_index);\n    set_angle(&path[i], yaw);\n  }\n}", "CodeBleu_score": 64.70994125408544}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tnav_msgs::Path path;\n\tbool success = makePlan(req.start, req.goal, path);\n\n\t// Update the response with the success status and the generated path if a plan is found\n\tif (success) {\n\t\tresp.plan = path;\n\t}\n\n\t// Return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 70.34899263681977}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    bool result = makePlan(req.start, req.goal, resp.plan.poses);\n\n    // Update the response with the success status and the generated path if a plan is found\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.success = result;\n\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 59.134913184777695}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    bool success = makePlan(req.start, req.goal, resp.plan.poses);\n\n    // Update the response with the success status and the generated path if a plan is found\n    resp.plan.header.stamp = ros::Time::now();\n    resp.plan.header.frame_id = \"map\";\n    resp.success = success;\n\n    // Return true to indicate that the service was processed\n    return true;\n}", "CodeBleu_score": 65.03320427384033}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t", "CodeBleu_score": 18.432682072468964}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle nh(\"~/\" + name);\n    make_plan_srv_ = nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 57.50574026867268}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle nh;\n    make_plan_srv_ = nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 56.76103338036205}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    // Check if the world coordinates are within the bounds of the costmap's origin\n    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n        return false;\n    }\n\n    // Calculate the map coordinates using the costmap's resolution and an offset\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n    // Check if the map coordinates are within the costmap's size limits\n    if (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 48.931957802253464}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  // Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n      wx >= costmap_->getOriginX() + costmap_->getSizeInCellsX() * costmap_->getResolution() ||\n      wy >= costmap_->getOriginY() + costmap_->getSizeInCellsY() * costmap_->getResolution()) {\n    return false;\n  }\n\n  // Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // Check if the map coordinates are within the costmap's size limits\n  if (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 45.54258653070155}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY())\n        return false;\n\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n    if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n        return true;\n\n    return false;\n}", "CodeBleu_score": 54.40754749854014}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = path[0].header.frame_id;\n        gui_path.header.stamp = path[0].header.stamp;\n    }\n\n    // Extract the plan in world co-ordinates, we assume the plan is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 88.50876908068066}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    // Check if the planner is initialized\n    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before using this planner\");\n        return;\n    }\n\n    // Create a Path message\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Copy the poses from the input path\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    // Publish the Path message\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.75993047574744}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t  // Check if the planner is initialized\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // Create a Path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  // Set the header of the Path message\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  // Copy the poses from the input path to the Path message\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  // Publish the Path message\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.3355739336173}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG(\"wrapping goal in an action\");\n  move_base_msgs::MoveBaseGoal action_goal;\n  action_goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 44.26599275684574}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    //log that we're wrapping a new goal\n    ROS_DEBUG(\"Wrapping received Pose -> MoveBaseAction\");\n\n    //create an action message with that goal\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n\n    //publish the action goal\n    action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 70.67934360942509}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG(\"got new goal\");\n  MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 64.85389859134085}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    double sq_dist = getSqDistance();\n    if (sq_dist >= sq_dist_limit_) {\n        ROS_INFO(\"Distance Check: Robot has moved far enough.\");\n        distance_check_timer_.stop();\n        if (remove_limit_thread_ != NULL) {\n            ROS_INFO(\"Distance Check: Removing speed limit.\");\n            remove_limit_thread_->join();\n            delete remove_limit_thread_;\n            remove_limit_thread_ = NULL;\n        }\n        remove_limit_thread_ = new boost::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n        ROS_INFO(\"Distance Check: Started removing speed limit thread.\");\n    }\n}", "CodeBleu_score": 56.13009449898358}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  double sq_distance = getSqDistance();\n  if (sq_distance >= sq_distance_limit_) {\n    ROS_INFO(\"Robot has moved far enough\");\n    distance_check_timer_.stop();\n    remove_speed_limit_thread_.join();\n    remove_speed_limit_thread_ = boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    return;\n  }\n}", "CodeBleu_score": 50.661039488979554}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  double sq_distance = getSqDistance();\n  if (sq_distance > sq_distance_limit_) {\n    ROS_INFO(\"Moving slow and clearing\");\n    remove_speed_limit_thread_.join();\n    remove_speed_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 48.33014010112083}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\n  // Get the current global pose of the robot\n  geometry_msgs::PoseStamped global_pose;\n  if (!costmap_ros_->getRobotPose(global_pose)) {\n    ROS_ERROR(\"Could not get robot pose\");\n    return;\n  }\n\n  // Generate a path from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> plan;\n  if (!makePlan(global_pose, *goal, plan)) {\n    ROS_ERROR(\"Could not generate path\");\n    return;\n  }\n\n  // Publish the path\n  publishPlan(plan);\n}", "CodeBleu_score": 54.17734434498356}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    // Get the current global pose of the robot\n    rm::PoseStamped global_pose;\n    if (!costmap_->getRobotPose(global_pose)) {\n        ROS_ERROR(\"Could not get robot pose\");\n        return;\n    }\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<geometry_msgs::PoseStamped> plan;\n    if (!makePlan(global_pose, *goal, plan)) {\n        ROS_ERROR(\"Could not generate a plan\");\n        return;\n    }\n\n    // Publish the path as a Path message\n    rm::Path path;\n    path.header.stamp = ros::Time::now();\n    path.header.frame_id = costmap_->getGlobalFrameID();\n    for (const auto& pose : plan) {\n        rm::PoseStamped p;\n        p.header = pose.header;\n        p.pose = pose.pose;\n        path.poses.push_back(p);\n    }\n    path_pub_.publish(path);\n}", "CodeBleu_score": 48.26592816717662}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  // Get the current global pose of the robot\n  geometry_msgs::PoseStamped robot_pose;\n  if (!costmap_->getRobotPose(robot_pose)) {\n    ROS_WARN(\"Could not get the current global pose of the robot\");\n    return;\n  }\n\n  // Generate a path from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> plan;\n  if (!makePlan(robot_pose, *goal, plan)) {\n    ROS_WARN(\"Could not generate a path from the current pose to the goal pose\");\n    return;\n  }\n\n  // Publish the path as a Path message\n  nav_msgs::Path path;\n  path.header.stamp = ros::Time::now();\n  path.header.frame_id = costmap_->getGlobalFrameID();\n  path.poses = plan;\n  path_pub_.publish(path);\n}", "CodeBleu_score": 49.38994731586438}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    param_set_client_.request.param_id = param_set.param_id;\n    param_set_client_.request.value = param_set.value;\n\n    if (!param_set_client_.call(param_set_client_.request, param_set_client_.response)) {\n        ROS_ERROR(\"Failed to set gimbal parameter %d to %f\", param_set.param_id, param_set.value);\n    } else {\n        ROS_INFO(\"Gimbal parameter %d set to %f\", param_set.param_id, param_set.value);\n    }\n}", "CodeBleu_score": 45.813098898124615}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    // Create a ParamSet service request\n    param_set_client_.request.param_id = param_set.param_id;\n    param_set_client_.request.value = param_set.value;\n\n    // Call the param_set_client_ to send the request\n    param_set_client_.call(param_set_client_.response);\n}", "CodeBleu_score": 54.320715290759246}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t  param_set_client_.request.param_id = param_set.param_id;\n  param_set_client_.request.value = param_set.value;\n\n  if (!param_set_client_.call(param_set_client_.request, param_set_client_.response)) {\n    ROS_ERROR(\"Failed to call param_set_server\");\n  }\n}", "CodeBleu_score": 49.51610392741137}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\n  // Find the matching UAV in the swarm\n  int uav_id = -1;\n  for (int i = 0; i < swarm_control_simulation_->uavs.size(); i++) {\n    if (uav_cmd.uav_id == swarm_control_simulation_->uavs[i].id) {\n      uav_id = i;\n      break;\n    }\n  }\n\n  if (uav_id == -1) {\n    ROS_ERROR(\"UAV not found in swarm\");\n    return;\n  }\n\n  // Publish the command to the matching UAV\n  swarm_control_simulation_->uavs[uav_id].command = uav_cmd;\n}", "CodeBleu_score": 37.31694440088439}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t", "CodeBleu_score": 2.601564811867212}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    if (!simulation_mode_) {\n        uav_basic_.publish(uav_cmd);\n    }\n    else {\n        for (auto uav : swarm_control_simulation_) {\n            if (uav.first == uav_cmd.id) {\n                uav.second.publish(uav_cmd);\n                break;\n            }\n        }\n    }\n}", "CodeBleu_score": 39.73653778627303}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.mode == Mode::REBOOTNX) {\n        std::cout << \"Rebooting NX...\" << std::endl;\n        system(\"reboot\");\n    }\n    else if (mode_selection.mode == Mode::EXITNX) {\n        std::cout << \"Exiting NX...\" << std::endl;\n        system(\"exit\");\n    }\n    else if (mode_selection.mode == Mode::CREATE_MODE) {\n        std::cout << \"Creating mode...\" << std::endl;\n        createMode(mode_selection.mode_name, mode_selection.use_mode);\n    }\n    else if (mode_selection.mode == Mode::DELETE_MODE) {\n        std::cout << \"Deleting mode...\" << std::endl;\n        deleteMode(mode_selection.mode_name);\n    }\n    else {\n        std::cout << \"Invalid mode selection\" << std::endl;\n    }\n}", "CodeBleu_score": 51.428108688942395}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t  if (mode_selection.mode == Mode::REBOOTNX) {\n    system(\"rebootnx\");\n  } else if (mode_selection.mode == Mode::EXITNX) {\n    system(\"exitnx\");\n  } else if (mode_selection.mode == Mode::CREATE_MODE) {\n    createMode(mode_selection.mode_name);\n  } else if (mode_selection.mode == Mode::DELETE_MODE) {\n    deleteMode(mode_selection.mode_name);\n  }\n}", "CodeBleu_score": 53.23895615971503}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode) {\n        createMode(mode_selection.mode_name);\n    } else {\n        deleteMode(mode_selection.mode_name);\n    }\n\n    if (mode_selection.mode == ModeSelection::REBOOTNX) {\n        system(\"reboot\");\n    } else if (mode_selection.mode == ModeSelection::EXITNX) {\n        system(\"exit\");\n    }\n}", "CodeBleu_score": 48.85224950467399}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\n    // Check if the heartbeat status is received within the specified time interval\n    if (ros::Time::now().toSec() - last_heartbeat_time_ > HEARTBEAT_TIMEOUT) {\n        // Increment the heartbeat counter\n        heartbeat_counter_++;\n        // Check if the heartbeat counter exceeds the maximum allowed value\n        if (heartbeat_counter_ > MAX_HEARTBEAT_COUNTER) {\n            // Print an error message\n            ROS_ERROR(\"Heartbeat lost for %d consecutive times\", MAX_HEARTBEAT_COUNTER);\n            // Trigger appropriate actions for the vehicle type\n            if (vehicle_type_ == \"swarm\") {\n                // Perform actions for swarm vehicles\n                ROS_ERROR(\"Swarm vehicle heartbeat lost\");\n            } else if (vehicle_type_ == \"UAV\") {\n                // Perform actions for UAV vehicles\n                ROS_ERROR(\"UAV vehicle heartbeat lost\");\n            } else if (vehicle_type_ == \"UGV\") {\n                // Perform actions for UGV vehicles\n                ROS_ERROR(\"UGV vehicle heartbeat lost\");\n            }\n            // Set the disconnect flag to true\n            disconnect_flag_ = true;\n        }\n    } else {\n        // Reset the heartbeat counter\n        heartbeat_counter_ = 0;\n    }\n}", "CodeBleu_score": 37.66677830288645}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (heartbeat_status == \"alive\") {\n        heartbeat_counter = 0;\n        if (disconnect_flag) {\n            ROS_WARN_STREAM(\"[CommunicationBridge] Connected to the \" << vehicle_type << \".\");\n            disconnect_flag = false;\n        }\n    } else {\n        heartbeat_counter++;\n        if (heartbeat_counter == heartbeat_timeout) {\n            ROS_WARN_STREAM(\"[CommunicationBridge] Lost connection to the \" << vehicle_type << \".\");\n            disconnect_flag = true;\n        }\n    }\n}", "CodeBleu_score": 31.80691529340366}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  if (heartbeat_status) {\n    heartbeat_count = 0;\n  } else {\n    heartbeat_count++;\n    if (heartbeat_count >= HEARTBEAT_COUNT_LIMIT) {\n      ROS_ERROR(\"Heartbeat lost. Disconnecting...\");\n      heartbeat_count = 0;\n      disconnect_flag = true;\n      if (vehicle_type == VehicleType::UAV) {\n        // Perform UAV-specific actions, e.g., land the UAV\n        ROS_INFO(\"UAV: Landing...\");\n      } else if (vehicle_type == VehicleType::UGV) {\n        // Perform UGV-specific actions, e.g., stop the UGV\n        ROS_INFO(\"UGV: Stopping...\");\n      } else if (vehicle_type == VehicleType::SWARM) {\n        // Perform swarm-specific actions, e.g., stop the swarm\n        ROS_INFO(\"Swarm: Stopping...\");\n      }\n    }\n  }\n}", "CodeBleu_score": 38.10595132927873}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract drone ID from message\n    int droneId = msg->drone_id;\n\n    // Initialize Bspline struct for each trajectory\n    for (int i = 0; i < msg->trajectories.size(); i++) {\n        Bspline bspline;\n        bspline.drone_id = droneId;\n        bspline.trajectory_id = msg->trajectories[i].trajectory_id;\n        bspline.trajectory_type = msg->trajectories[i].trajectory_type;\n        bspline.knots = msg->trajectories[i].knots;\n        bspline.position_points = msg->trajectories[i].position_points;\n        bspline.yaw_points = msg->trajectories[i].yaw_points;\n\n        // Add Bspline to list of Bsplines\n        bsplines.push_back(bspline);\n    }\n\n    // Encode Bsplines data and send via TCP using communication module\n    std::string bsplines_str = encodeBsplines(bsplines);\n    comm_module.sendTcp(bsplines_str);\n}", "CodeBleu_score": 37.845228236379526}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\n    // Create a new PointCloud2 message to store the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n\n    // Convert the input PointCloud2 message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Create an octree object with a resolution of 0.01\n    pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree(0.01);\n\n    // Add the point cloud to the octree\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n\n    // Create a new point cloud to store the compressed data\n    pcl::PointCloud<pcl::PointXYZ>::Ptr compressed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\n    // Iterate through the input point cloud and add the first point in each octree cell to the compressed point cloud\n    for (auto it = cloud->begin(); it != cloud->end(); ++it) {\n        // Get the octree cell index for the current point\n        std::vector<int> pointIdxVec;\n        octree.voxelSearch(it->x, it->y, it->z, pointIdxVec);\n\n        // If the octree cell is empty, add the point to the compressed point cloud\n        if (pointIdxVec.empty()) {\n            compressed_cloud->push_back(*it);\n        }\n    }\n\n    // Convert the compressed point cloud back to a ROS message\n    pcl::toROSMsg(*compressed_cloud, compressed_msg);\n\n    // Set the frame ID of the compressed message\n    compressed_msg.header.frame_id = msg.header.frame_id;\n\n    // Release dynamically allocated memory\n    cloud.reset();\n    compressed_cloud.reset();\n\n    // Return the compressed message\n    return compressed_msg;\n}", "CodeBleu_score": 47.5600024746884}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.01);\n    octree.setInputCloud(cloud);\n    octree.defineCompressionOctree(cloud);\n\n    // Store the compressed data\n    std::vector<int> pointIdxVector;\n    octree.getOccupiedVoxelCenters(pointIdxVector);\n    octree.getPointIndicesFromVoxelCenters(pointIdxVector, pointIdxVector);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::copyPointCloud(*cloud, pointIdxVector, *cloud_compressed);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 msg_compressed;\n    pcl::toROSMsg(*cloud_compressed, msg_compressed);\n\n    // Release dynamically allocated memory\n    cloud.reset();\n    cloud_compressed.reset();\n\n    return msg_compressed;\n}", "CodeBleu_score": 41.947029489650276}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t  for (int i = 0; i < multi_uav_state_.size(); i++) {\n    if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n      multi_uav_state_[i] = uav_state;\n      break;\n    }\n  }\n}", "CodeBleu_score": 61.64500347906683}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_[i] = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 64.4266456128767}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_[i] = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 64.4266456128767}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    MultiUGVState multi_ugv_state_msg;\n    UGVState ugv_state_msg;\n    int ugv_count = 0;\n\n    for (auto &ugv_state : m_multi_ugv_state.ugv_state) {\n        ugv_state_msg.id = ugv_state.id;\n        ugv_state_msg.battery = ugv_state.battery;\n        ugv_state_msg.position.x = ugv_state.position.x;\n        ugv_state_msg.position.y = ugv_state.position.y;\n        ugv_state_msg.position.z = ugv_state.position.z;\n        ugv_state_msg.velocity.x = ugv_state.velocity.x;\n        ugv_state_msg.velocity.y = ugv_state.velocity.y;\n        ugv_state_msg.velocity.z = ugv_state.velocity.z;\n        ugv_state_msg.attitude.roll = ugv_state.attitude.roll;\n        ugv_state_msg.attitude.pitch = ugv_state.attitude.pitch;\n        ugv_state_msg.attitude.yaw = ugv_state.attitude.yaw;\n\n        multi_ugv_state_msg.ugv_state.push_back(ugv_state_msg);\n        ugv_count++;\n    }\n\n    multi_ugv_state_msg.header.stamp = ros::Time::now();\n    multi_ugv_state_msg.header.frame_id = \"world\";\n    multi_ugv_state_msg.ugv_count = ugv_count;\n\n    m_multi_ugv_state_pub.publish(multi_ugv_state_msg);\n}", "CodeBleu_score": 44.054114248251004}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    for (int i = 0; i < q.rows(); i++) {\n        Eigen::Vector3d qi = q.row(i);\n        Eigen::Vector3d qi_pred = qi;\n\n        // Compute the predicted position of the moving object\n        for (int j = 0; j < moving_objs_.size(); j++) {\n            if (moving_objs_[j]->getType() == \"sphere\") {\n                Sphere *sphere = static_cast<Sphere *>(moving_objs_[j]);\n                qi_pred = sphere->predictPosition(qi, t_);\n            } else if (moving_objs_[j]->getType() == \"box\") {\n                Box *box = static_cast<Box *>(moving_objs_[j]);\n                qi_pred = box->predictPosition(qi, t_);\n            }\n        }\n\n        // Calculate the distance between the control point and the predicted position of the moving object\n        double dist = (qi - qi_pred).norm();\n\n        // If the distance is less than the clearance, update the cost and gradient\n        if (dist < clearance_) {\n            double dist_error = dist - clearance_;\n            cost += dist_error * dist_error;\n            gradient.row(i) = -2.0 * dist_error * (qi - qi_pred) / dist;\n        }\n    }\n}", "CodeBleu_score": 47.438081203638596}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n\n    for (int i = 0; i < q.rows(); i++) {\n        Eigen::Vector3d pt = q.row(i);\n        double dist = movingObj->getDistance(pt);\n        if (dist < clearance) {\n            double cost_i = 1.0 / (dist * dist);\n            cost += cost_i;\n\n            Eigen::Vector3d grad_i = movingObj->getGradient(pt);\n            gradient.row(i) += cost_i * grad_i;\n        }\n    }\n}", "CodeBleu_score": 31.921799122243456}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    // Initialize cost and gradient\n    cost = 0.0;\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    // Iterate through control points of the B-spline\n    for (int i = 0; i < q.rows(); i++) {\n        // Compute predicted positions of moving objects\n        Eigen::VectorXd obj_pos = Eigen::VectorXd::Zero(moving_obj_pos.cols());\n        for (int j = 0; j < moving_obj_pos.cols(); j++) {\n            obj_pos(j) = moving_obj_pos(i, j) + moving_obj_vel(i, j) * (i + 1) * m_dt;\n        }\n\n        // Evaluate distance between control point and predicted positions of moving objects\n        double dist = (q.row(i) - obj_pos).norm();\n\n        // Update cost and gradient if distance is less than clearance\n        if (dist < m_clearance) {\n            cost += dist;\n            gradient.row(i) = (q.row(i) - obj_pos) / dist;\n        }\n    }\n}", "CodeBleu_score": 38.57580824081878}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n\n    for (int i = 0; i < q.rows(); i++) {\n        // Compute the positional error relative to reference points\n        Eigen::Vector3d pos_error = q.row(i).head(3) - ref_points_.row(i).head(3).transpose();\n        // Compute the velocity vector\n        Eigen::Vector3d vel = q.row(i).segment(3, 3) - ref_vels_.row(i).transpose();\n\n        // Compute the squared dot product of the positional error and velocity vector\n        double dot_prod = pos_error.dot(vel);\n        double dot_cost = dot_prod * dot_prod;\n        // Compute the squared cross product of the positional error and velocity vector\n        Eigen::Vector3d cross_prod = pos_error.cross(vel);\n        double cross_cost = cross_prod.dot(cross_prod);\n\n        // Update the cost and gradient\n        cost += a2_ * dot_cost + b2_ * cross_cost;\n        gradient.row(i).head(3) += a2_ * 2 * dot_prod * pos_error.transpose();\n        gradient.row(i).segment(3, 3) += b2_ * 2 * cross_prod.transpose();\n    }\n}", "CodeBleu_score": 35.186928570443506}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    // Initialize the cost and gradient to zero\n    cost = 0.0;\n    gradient.setZero();\n\n    // Iterate through the control points of the trajectory\n    for (int i = 0; i < q.rows(); i++) {\n        // Compute the positional error relative to reference points\n        Eigen::Vector3d error = q.row(i) - q_ref.row(i);\n\n        // Compute the velocity vector\n        Eigen::Vector3d velocity;\n        if (i == 0) {\n            // If this is the first point, use the first velocity as the initial velocity\n            velocity = v_ref.row(0);\n        } else {\n            // Otherwise, compute the velocity as the difference between the current and previous points\n            velocity = q.row(i) - q.row(i - 1);\n        }\n\n        // Compute the cost function\n        double c = a2 * error.squaredNorm() + b2 * velocity.squaredNorm();\n\n        // Update the cost\n        cost += c;\n\n        // Compute the gradient\n        Eigen::Vector3d grad = a2 * 2.0 * error + b2 * 2.0 * velocity;\n\n        // Update the gradient for this control point\n        gradient.row(i) = grad;\n    }\n}", "CodeBleu_score": 31.95823553191472}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    // Initialize the cost and gradient to zero\n    cost = 0.0;\n    gradient.setZero();\n\n    // Loop through the control points of the trajectory\n    for (int i = 0; i < q.rows(); i++) {\n        // Compute the positional error and velocity vector\n        Eigen::Vector3d error = q.row(i) - ref_points_.row(i);\n        Eigen::Vector3d velocity = (q.row(i) - q.row(i - 1)) / (time_step_);\n\n        // Compute the squared dot product and cross product of the error and velocity vectors\n        double dot_product = error.dot(velocity);\n        Eigen::Vector3d cross_product = error.cross(velocity);\n\n        // Compute the cost and its derivatives\n        double cost_i = a2_ * dot_product * dot_product + b2_ * cross_product.squaredNorm();\n        Eigen::Vector3d gradient_i = 2 * a2_ * dot_product * velocity + 2 * b2_ * cross_product;\n\n        // Update the cost and gradient\n        cost += cost_i;\n        gradient.row(i) += gradient_i;\n    }\n}", "CodeBleu_score": 37.19058452117425}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t    Eigen::MatrixXd ctp = getDerivativeControlPoints();\n    UniformBspline thirdDerivative(ctp, p_ - 2, interval_);\n\n    /* cut the first and last knot */\n    Eigen::VectorXd knot(u_.rows() - 2);\n    knot = u_.segment(1, u_.rows() - 2);\n    thirdDerivative.setKnot(knot);\n\n    Eigen::VectorXd knotTimes = thirdDerivative.getKnotTimes();\n    Eigen::MatrixXd controlPoints = thirdDerivative.getControlPoints();\n\n    double jerk = 0;\n    for (int i = 0; i < controlPoints.rows(); i++) {\n        for (int j = 0; j < controlPoints.cols(); j++) {\n            jerk += controlPoints(i, j) * controlPoints(i, j) * (knotTimes(i + 1) - knotTimes(i));\n        }\n    }\n\n    return jerk;\n}", "CodeBleu_score": 58.66967395841443}, {"code": "double UniformBspline::getJerk(){\n\t    // Calculate the third derivative of the spline\n    UniformBspline third_derivative = getDerivative().getDerivative();\n\n    // Get the knot times and control points of the jerk trajectory\n    Eigen::VectorXd knot_times = third_derivative.getKnot();\n    Eigen::MatrixXd control_points = third_derivative.getControlPoints();\n\n    double jerk = 0.0;\n\n    // Iterate through the control points and dimensions\n    for (int i = 0; i < control_points.rows(); i++) {\n        for (int j = 0; j < control_points.cols(); j++) {\n            // Sum the squared control point values multiplied by the differences in knot times\n            jerk += control_points(i, j) * control_points(i, j) * (knot_times(i + 1) - knot_times(i));\n        }\n    }\n\n    return jerk;\n}", "CodeBleu_score": 64.38628053089096}, {"code": "double UniformBspline::getJerk(){\n\t  /* Calculate the third derivative of the spline */\n  UniformBspline thirdDerivative = getDerivative().getDerivative();\n\n  /* Retrieve the knot times and control points of the jerk trajectory */\n  Eigen::VectorXd knot = thirdDerivative.getKnot();\n  Eigen::MatrixXd controlPoints = thirdDerivative.getControlPoints();\n\n  /* Calculate the jerk value */\n  double jerk = 0.0;\n  for (int i = 0; i < controlPoints.rows(); i++) {\n    for (int j = 0; j < controlPoints.cols(); j++) {\n      jerk += controlPoints(i, j) * controlPoints(i, j) *\n              (knot(i + 1) - knot(i));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 65.00494089288742}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos[0] = (u - cx_) / fx_ * depth;\n    pos[1] = (v - cy_) / fy_ * depth;\n    pos[2] = depth;\n    pos[3] = 1.0;\n    return pos;\n}", "CodeBleu_score": 55.98942652447525}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    return Eigen::Vector4d(depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1);\n}", "CodeBleu_score": 29.554392682222126}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d p;\n    p << (u - cx_) / fx_ * depth, (v - cy_) / fy_ * depth, depth, 1;\n    return p;\n}", "CodeBleu_score": 41.038710067217224}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    rcvDroneOdomCallbackBase(odom, getDroneIDFromOdomFrame(odom));\n  } catch (std::runtime_error& e) {\n    ROS_ERROR_STREAM(e.what());\n  }\n}", "CodeBleu_score": 35.093218219223196}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t  try {\n    rcvDroneOdomCallbackBase(odom, getDroneIDFromXOdom(odom));\n  } catch (std::exception& e) {\n    ROS_ERROR_STREAM(\"Exception caught in DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n  }\n}", "CodeBleu_score": 38.00227722082948}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        int id = std::stoi(odom.child_frame_id.substr(1, odom.child_frame_id.size()));\n        rcvDroneOdomCallbackBase(odom, id);\n    } catch (std::invalid_argument& e) {\n        ROS_ERROR_STREAM(\"Invalid drone ID: \" << e.what());\n    } catch (std::out_of_range& e) {\n        ROS_ERROR_STREAM(\"Drone ID out of range: \" << e.what());\n    }\n}", "CodeBleu_score": 51.536269719293216}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n    // Get the drone's true position in the camera frame\n    Eigen::Vector3d true_position = drone_id_to_true_position_[drone_id];\n\n    // Check if the drone is in the image\n    if (is_in_image(true_pixel)) {\n\n        // Get the drone's true orientation in the camera frame\n        Eigen::Quaterniond true_orientation = drone_id_to_true_orientation_[drone_id];\n\n        // Get the drone's true position in the world frame\n        Eigen::Vector3d true_position_world = camera_to_world_ * true_position;\n\n        // Get the drone's true orientation in the world frame\n        Eigen::Quaterniond true_orientation_world = camera_to_world_.rotation() * true_orientation;\n\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d position_error = true_position_world - camera_to_world_.translation();\n        Eigen::Quaterniond orientation_error = true_orientation_world.inverse() * camera_to_world_.rotation();\n\n        // Update the debug result\n        debug_result_.detected = true;\n        debug_result_.position_error = position_error;\n        debug_result_.orientation_error = orientation_error;\n\n        // Publish the pose error\n        publish_pose_error(position_error, orientation_error);\n\n    } else {\n\n        // Update the debug result to indicate failure\n        debug_result_.detected = false;\n\n    }\n\n}", "CodeBleu_score": 32.82344310154857}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n    // Compute the true pose of the drone in the camera frame\n    Eigen::Vector3d true_camera_pose = true_camera_poses[drone_id];\n\n    // Check for the presence of the drone in the image\n    bool drone_found = false;\n    for (int i = 0; i < drone_positions.size(); i++) {\n        if (drone_positions[i].id == drone_id) {\n            drone_found = true;\n            break;\n        }\n    }\n\n    // If the drone is found, compute the pose error between the camera and world coordinates\n    if (drone_found) {\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d pose_error = true_camera_pose - camera_pose;\n        // Update the debug result\n        debug_result.detection_success = true;\n        debug_result.pose_error = pose_error;\n        debug_result.true_pixel = true_pixel;\n        debug_result.true_camera_pose = true_camera_pose;\n        debug_result.camera_pose = camera_pose;\n        debug_result.drone_id = drone_id;\n    } else {\n        // Update the debug result to indicate failure\n        debug_result.detection_success = false;\n    }\n\n    // Publish the pose error\n    pose_error_pub.publish(debug_result);\n}", "CodeBleu_score": 40.648395933163215}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Calculate the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = camera_model_->pixelToCamera(true_pixel);\n\n    // Check for the presence of the drone\n    if (true_pose(2) < 0) {\n        // Drone is behind the camera, so it is not detected\n        debug_result_.detected = false;\n        debug_result_.error = Eigen::Vector3d::Zero();\n    } else {\n        // Drone is in front of the camera, so it is detected\n        debug_result_.detected = true;\n\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d error = true_pose - camera_model_->getCameraPose();\n\n        // Update the debug result with the pose error\n        debug_result_.error = error;\n    }\n\n    // Publish the pose error\n    pose_error_pub_.publish(debug_result_);\n}", "CodeBleu_score": 28.918220279369727}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 93.99751622940664}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->parent != nullptr) {\n        current = current->parent;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 83.98978867982879}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getCameFrom() != nullptr) {\n        current = current->getCameFrom();\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 77.40374327276972}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  Vector3i start_idx_temp, end_idx_temp;\n  bool start_in_obstacle, end_in_obstacle;\n  bool start_success, end_success;\n  Vector3d start_pt_temp, end_pt_temp;\n\n  start_success = ConvertToIndex(start_pt, start_idx_temp);\n  end_success = ConvertToIndex(end_pt, end_idx_temp);\n\n  if (!start_success || !end_success) {\n    return false;\n  }\n\n  start_in_obstacle = IsInObstacle(start_idx_temp);\n  end_in_obstacle = IsInObstacle(end_idx_temp);\n\n  if (start_in_obstacle) {\n    start_pt_temp = start_pt;\n    while (IsInObstacle(start_pt_temp, start_idx_temp)) {\n      start_pt_temp += (start_pt - start_pt_temp).normalized() * 0.01;\n    }\n  }\n\n  if (end_in_obstacle) {\n    end_pt_temp = end_pt;\n    while (IsInObstacle(end_pt_temp, end_idx_temp)) {\n      end_pt_temp += (end_pt - end_pt_temp).normalized() * 0.01;\n    }\n  }\n\n  start_idx = start_idx_temp;\n  end_idx = end_idx_temp;\n\n  return true;\n}", "CodeBleu_score": 40.373300226794406}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t  // Convert start and end points to grid indices\n  start_idx = ConvertPointToGridIndex(start_pt);\n  end_idx = ConvertPointToGridIndex(end_pt);\n\n  // Check if start or end point is inside an obstacle\n  if (IsInsideObstacle(start_idx) || IsInsideObstacle(end_idx)) {\n    // If so, adjust start or end point to be outside the obstacle\n    if (IsInsideObstacle(start_idx)) {\n      // Adjust start point\n      while (IsInsideObstacle(start_idx)) {\n        start_idx[0]++;\n      }\n    } else {\n      // Adjust end point\n      while (IsInsideObstacle(end_idx)) {\n        end_idx[0]--;\n      }\n    }\n  }\n\n  // Check if start and end points are still inside the grid\n  if (!IsInsideGrid(start_idx) || !IsInsideGrid(end_idx)) {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 32.29148366855066}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\n    Vector3i start_idx_tmp, end_idx_tmp;\n\n    // Convert start and end points to indices\n    if (!ConvertPointToIndex(start_pt, start_idx_tmp)) {\n        return false;\n    }\n    if (!ConvertPointToIndex(end_pt, end_idx_tmp)) {\n        return false;\n    }\n\n    // If the start or end point is inside an obstacle, adjust it\n    if (IsInsideObstacle(start_idx_tmp)) {\n        if (!AdjustPoint(start_pt, end_pt, start_idx_tmp, end_idx_tmp)) {\n            return false;\n        }\n    }\n    if (IsInsideObstacle(end_idx_tmp)) {\n        if (!AdjustPoint(end_pt, start_pt, end_idx_tmp, start_idx_tmp)) {\n            return false;\n        }\n    }\n\n    // Set the output indices\n    start_idx = start_idx_tmp;\n    end_idx = end_idx_tmp;\n\n    return true;\n}", "CodeBleu_score": 41.46475275895703}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  // get the min and max indices\n  int min_x = (min_pos[0] - origin_[0]) / resolution_;\n  int min_y = (min_pos[1] - origin_[1]) / resolution_;\n  int min_z = (min_pos[2] - origin_[2]) / resolution_;\n  int max_x = (max_pos[0] - origin_[0]) / resolution_;\n  int max_y = (max_pos[1] - origin_[1]) / resolution_;\n  int max_z = (max_pos[2] - origin_[2]) / resolution_;\n\n  // iterate over the grid coordinates\n  for (int x = min_x; x <= max_x; x++) {\n    for (int y = min_y; y <= max_y; y++) {\n      for (int z = min_z; z <= max_z; z++) {\n        // get the index of the grid cell\n        int index = getIndex(x, y, z);\n        // set the occupancy and distance buffer elements to zero\n        occupancy_buffer_inflate_[index] = 0;\n        distance_buffer_inflate_[index] = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 43.97448523916642}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  int min_x = (min_pos(0) - origin_(0)) / resolution_;\n  int min_y = (min_pos(1) - origin_(1)) / resolution_;\n  int min_z = (min_pos(2) - origin_(2)) / resolution_;\n\n  int max_x = (max_pos(0) - origin_(0)) / resolution_;\n  int max_y = (max_pos(1) - origin_(1)) / resolution_;\n  int max_z = (max_pos(2) - origin_(2)) / resolution_;\n\n  for (int x = min_x; x <= max_x; x++) {\n    for (int y = min_y; y <= max_y; y++) {\n      for (int z = min_z; z <= max_z; z++) {\n        int id = getIndex(x, y, z);\n        occupancy_buffer_inflate_[id] = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 51.21687638760487}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  // Get the indices of the grid cells that correspond to the specified region\n  Eigen::Vector3i min_id = getGridIndex(min_pos);\n  Eigen::Vector3i max_id = getGridIndex(max_pos);\n\n  // Iterate over the grid cells within the specified region\n  for (int x = min_id.x(); x <= max_id.x(); x++) {\n    for (int y = min_id.y(); y <= max_id.y(); y++) {\n      for (int z = min_id.z(); z <= max_id.z(); z++) {\n        // Set the occupancy probability of the corresponding grid cell to zero\n        occupancy_buffer_inflate_(x, y, z) = 0.0;\n      }\n    }\n  }\n}", "CodeBleu_score": 46.65017014463606}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    double min_trans_x = std::min(0.0, diff[0]);\n    double min_trans_y = std::min(0.0, diff[1]);\n    double min_trans_z = std::min(0.0, diff[2]);\n    double max_trans_x = std::max(0.0, diff[0]);\n    double max_trans_y = std::max(0.0, diff[1]);\n    double max_trans_z = std::max(0.0, diff[2]);\n\n    double min_trans = std::min(min_trans_x, min_trans_y);\n    min_trans = std::min(min_trans, min_trans_z);\n\n    double max_trans = std::max(max_trans_x, max_trans_y);\n    max_trans = std::max(max_trans, max_trans_z);\n\n    Eigen::Vector3d closest_pt = pt;\n    if (min_trans < 0) {\n        closest_pt = pt + min_trans * diff.normalized();\n    } else if (max_trans > 0) {\n        closest_pt = pt + max_trans * diff.normalized();\n    }\n    return closest_pt;\n}", "CodeBleu_score": 36.45441719189528}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n\n    double max_x_translation = (diff[0] > 0) ? (1 - camera_pt[0]) : (-camera_pt[0]);\n    double max_y_translation = (diff[1] > 0) ? (1 - camera_pt[1]) : (-camera_pt[1]);\n    double max_z_translation = (diff[2] > 0) ? (1 - camera_pt[2]) : (-camera_pt[2]);\n\n    double min_x_translation = (diff[0] > 0) ? (-camera_pt[0]) : (1 - camera_pt[0]);\n    double min_y_translation = (diff[1] > 0) ? (-camera_pt[1]) : (1 - camera_pt[1]);\n    double min_z_translation = (diff[2] > 0) ? (-camera_pt[2]) : (1 - camera_pt[2]);\n\n    double max_x_scaling = max_x_translation / diff[0];\n    double max_y_scaling = max_y_translation / diff[1];\n    double max_z_scaling = max_z_translation / diff[2];\n\n    double min_x_scaling = min_x_translation / diff[0];\n    double min_y_scaling = min_y_translation / diff[1];\n    double min_z_scaling = min_z_translation / diff[2];\n\n    double max_scaling = std::min({max_x_scaling, max_y_scaling, max_z_scaling});\n    double min_scaling = std::max({min_x_scaling, min_y_scaling, min_z_scaling});\n\n    if (max_scaling < 1 && min_scaling > 0) {\n        return camera_pt + diff * max_scaling;\n    } else {\n        return camera_pt + diff * min_scaling;\n    }\n}", "CodeBleu_score": 33.71480132899785}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\n    Eigen::Vector3d diff = pt - camera_pt;\n    double min_x_scale = diff.x() < 0 ? ceil(camera_pt.x() / diff.x()) : floor(camera_pt.x() / diff.x());\n    double max_x_scale = diff.x() < 0 ? floor(camera_pt.x() / diff.x()) : ceil(camera_pt.x() / diff.x());\n    double min_y_scale = diff.y() < 0 ? ceil(camera_pt.y() / diff.y()) : floor(camera_pt.y() / diff.y());\n    double max_y_scale = diff.y() < 0 ? floor(camera_pt.y() / diff.y()) : ceil(camera_pt.y() / diff.y());\n    double min_z_scale = diff.z() < 0 ? ceil(camera_pt.z() / diff.z()) : floor(camera_pt.z() / diff.z());\n    double max_z_scale = diff.z() < 0 ? floor(camera_pt.z() / diff.z()) : ceil(camera_pt.z() / diff.z());\n\n    double min_scale = std::max(std::max(min_x_scale, min_y_scale), min_z_scale);\n    double max_scale = std::min(std::min(max_x_scale, max_y_scale), max_z_scale);\n\n    double scale = std::min(max_scale, std::max(min_scale, 1.0));\n\n    return camera_pt + scale * diff;\n}", "CodeBleu_score": 33.052080083563155}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t    // Update the last occupancy update time\n    last_occupancy_update_time = ros::Time::now();\n\n    // Check if an update is needed\n    if (!need_update) return;\n\n    // Project the depth image into points and process them with raycasting\n    projectDepthImage();\n\n    // Update the local map\n    if (local_map_updated) {\n        local_map_updated = false;\n        clearLocalMap();\n        inflateLocalMap();\n    }\n\n    // Handle timeout errors for odometry or depth data and set relevant flags\n    if (ros::Time::now() - last_odom_update_time > ros::Duration(1.0)) {\n        odom_timeout = true;\n    }\n    if (ros::Time::now() - last_depth_update_time > ros::Duration(1.0)) {\n        depth_timeout = true;\n    }\n}", "CodeBleu_score": 33.254078137105516}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\n  // Update the last occupancy update time\n  last_occupancy_update_time = ros::Time::now();\n\n  // If an update is needed, project the depth image into points and process them with raycasting\n  if (update_needed) {\n    update_needed = false;\n\n    // Project the depth image into points\n    projectDepthImage();\n\n    // Process the points with raycasting\n    raycastPoints();\n\n    // If the local map has been updated, clear and inflate the local map\n    if (local_map_updated) {\n      local_map_updated = false;\n      clearMap();\n      inflateMap();\n    }\n  }\n\n  // Handle timeout errors for odometry or depth data and set relevant flags\n  if (ros::Time::now() - last_odom_update_time > odom_timeout) {\n    odom_timeout_error = true;\n  } else {\n    odom_timeout_error = false;\n  }\n\n  if (ros::Time::now() - last_depth_update_time > depth_timeout) {\n    depth_timeout_error = true;\n  } else {\n    depth_timeout_error = false;\n  }\n\n  // Publish the occupancy grid\n  occupancy_grid_pub.publish(occupancy_grid);\n\n  // Publish the local map\n  local_map_pub.publish(local_map);\n}", "CodeBleu_score": 40.047939412284315}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    // Initialize variables\n    float fmeasure_sum = 0.f;\n    unsigned n = image_fns.size();\n    unsigned n_correct = 0;\n\n    // Iterate through each image\n    for (unsigned i = 0; i < n; ++i) {\n        // Load ground truth and detected ellipses\n        vector<Ellipse> ell_gt;\n        vector<Ellipse> ell_dt;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt, false);\n\n        // Evaluate detection performance\n        float fmeasure = _ellipse_evaluate_one(ell_gt, ell_dt, imread(image_fns[i]));\n\n        // Accumulate F-measure\n        fmeasure_sum += fmeasure;\n\n        // Update number of correct detections\n        n_correct += (fmeasure > 0.f) ? 1 : 0;\n    }\n\n    // Calculate average F-measure\n    float fmeasure_avg = (n > 0) ? fmeasure_sum / float(n) : 0.f;\n\n    // Return average F-measure\n    return fmeasure_avg;\n}", "CodeBleu_score": 59.26187655820465}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    if (image_fns.size() != gt_fns.size() || image_fns.size() != dt_fns.size()) {\n        cout << \"Error: The number of image filenames, ground truth filenames, and detected ellipses filenames must be the same.\" << endl;\n        return 0.f;\n    }\n\n    unsigned sz = image_fns.size();\n\n    float fmeasure_sum = 0.f;\n    for (unsigned i = 0; i < sz; ++i)\n    {\n        // Load the image\n        Mat3b img = imread(image_fns[i]);\n        if (img.empty())\n        {\n            cout << \"Error loading: \" << image_fns[i] << endl;\n            return 0.f;\n        }\n\n        // Load the ground truth ellipses\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        // Load the detected ellipses\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        // Evaluate the detection performance\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\n        // Accumulate the F-measure\n        fmeasure_sum += fmeasure;\n    }\n\n    // Return the average F-measure\n    return fmeasure_sum / sz;\n}", "CodeBleu_score": 51.08638971149665}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float fmeasure_avg(0.f);\n    for (unsigned i = 0; i < image_fns.size(); ++i) {\n        vector<Ellipse> gt_ellipses;\n        vector<Ellipse> dt_ellipses;\n\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        Mat3b img = imread(image_fns[i]);\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        fmeasure_avg += fmeasure;\n    }\n\n    return fmeasure_avg / float(image_fns.size());\n}", "CodeBleu_score": 64.05082131208461}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float a = atan2(foci[1] - y, foci[0] - x);\n    float b = atan2(foci[3] - y, foci[2] - x);\n    float angle_diff = angle_diff_signed(a, b);\n    return angle_diff;\n}", "CodeBleu_score": 25.451340102194823}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float a = atan2(y - foci[1], x - foci[0]);\n    float b = atan2(y - foci[3], x - foci[2]);\n    float c = angle_diff_signed(a, b);\n    return c;\n}", "CodeBleu_score": 33.51050253810539}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    if (foci == NULL) {\n        return 0.0f;\n    }\n    float a = atan2(y - foci[1], x - foci[0]);\n    float b = atan2(y - foci[3], x - foci[2]);\n    return angle_diff_signed(a, b);\n}", "CodeBleu_score": 37.12037564546404}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  // Iterate through each detection info\n  for (int i = 0; i < msg->detection_infos.size(); i++) {\n    // Update the ellipse_det variable with the detection info\n    ellipse_det = msg->detection_infos[i];\n    // If the object is named \"T\", increment the num_regain counter and reset num_lost\n    if (ellipse_det.name == \"T\") {\n      num_regain++;\n      num_lost = 0;\n    }\n    // Otherwise, reset num_regain and increment num_lost\n    else {\n      num_regain = 0;\n      num_lost++;\n    }\n    // If num_lost exceeds VISION_THRES, set is_detected to false\n    if (num_lost > VISION_THRES) {\n      is_detected = false;\n    }\n    // If num_regain exceeds VISION_THRES, set is_detected to true\n    if (num_regain > VISION_THRES) {\n      is_detected = true;\n    }\n    // Swap the sight_angle values of ellipse_det\n    double temp = ellipse_det.sight_angle.x;\n    ellipse_det.sight_angle.x = ellipse_det.sight_angle.y;\n    ellipse_det.sight_angle.y = temp;\n  }\n}", "CodeBleu_score": 68.62516293027548}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  prometheus_msgs::DetectionInfo det_info;\n  prometheus_msgs::EllipseDetectionInfo ellipse_det;\n  int num_regain = 0;\n  int num_lost = 0;\n\n  for (int i = 0; i < msg->detection_info.size(); i++) {\n    det_info = msg->detection_info[i];\n    if (det_info.name == \"T\") {\n      num_regain++;\n      num_lost = 0;\n    } else {\n      num_regain = 0;\n      num_lost++;\n    }\n\n    if (num_lost > VISION_THRES) {\n      is_detected = false;\n    } else if (num_regain > VISION_THRES) {\n      is_detected = true;\n    }\n\n    ellipse_det = det_info.ellipse_detection_info;\n    std::swap(ellipse_det.sight_angle[0], ellipse_det.sight_angle[1]);\n    ellipse_det.sight_angle[0] *= -1;\n    ellipse_det.sight_angle[1] *= -1;\n  }\n}", "CodeBleu_score": 69.4674215088282}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t    // Iterate through each detection info\n    for (const auto &detection : msg->detection_infos) {\n        // Update ellipse_det variable with detection info\n        ellipse_det = detection;\n        // If object named \"T\" is detected, increment num_regain and reset num_lost\n        if (ellipse_det.name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            // Otherwise, reset num_regain and increment num_lost\n            num_regain = 0;\n            num_lost++;\n        }\n        // If num_lost exceeds VISION_THRES, set is_detected to false\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n        // If num_regain exceeds VISION_THRES, set is_detected to true\n        if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n        // Swap the sight_angle values of ellipse_det\n        std::swap(ellipse_det.sight_angle.x, ellipse_det.sight_angle.y);\n    }\n}", "CodeBleu_score": 68.08001421022635}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t  double x = cur_pos(0);\n  double y = cur_pos(1);\n  double z = cur_pos(2);\n  double x_min = x - safe_distance;\n  double x_max = x + safe_distance;\n  double y_min = y - safe_distance;\n  double y_max = y + safe_distance;\n  double z_min = z - safe_distance;\n  double z_max = z + safe_distance;\n  if (x_min < 0 || x_max > Occupy_map_ptr->get_x_size() || y_min < 0 ||\n      y_max > Occupy_map_ptr->get_y_size() || z_min < 0 ||\n      z_max > Occupy_map_ptr->get_z_size()) {\n    return false;\n  }\n  int x_min_index = std::floor(x_min);\n  int x_max_index = std::ceil(x_max);\n  int y_min_index = std::floor(y_min);\n  int y_max_index = std::ceil(y_max);\n  int z_min_index = std::floor(z_min);\n  int z_max_index = std::ceil(z_max);\n  for (int i = x_min_index; i <= x_max_index; i++) {\n    for (int j = y_min_index; j <= y_max_index; j++) {\n      for (int k = z_min_index; k <= z_max_index; k++) {\n        if (Occupy_map_ptr->get_occupancy(i, j, k)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "CodeBleu_score": 39.276999219278416}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t  double x = cur_pos(0);\n  double y = cur_pos(1);\n  double z = cur_pos(2);\n\n  double safety_margin = safe_distance;\n\n  double x_min = x - safety_margin;\n  double x_max = x + safety_margin;\n  double y_min = y - safety_margin;\n  double y_max = y + safety_margin;\n  double z_min = z - safety_margin;\n  double z_max = z + safety_margin;\n\n  for (double i = x_min; i <= x_max; i += safety_margin / 2) {\n    for (double j = y_min; j <= y_max; j += safety_margin / 2) {\n      for (double k = z_min; k <= z_max; k += safety_margin / 2) {\n        Eigen::Vector3d check_point(i, j, k);\n        if (Occupy_map_ptr->isOccupied(check_point)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "CodeBleu_score": 40.317252514668034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    if (Occupy_map_ptr->isOccupied(cur_pos(0), cur_pos(1), cur_pos(2))) {\n        return false;\n    } else {\n        return true;\n    }\n}", "CodeBleu_score": 25.694354660385443}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 67.26908921647082}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n\n    while (current_node != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.40075271088732}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    while (current_node != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.40075271088732}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    if (id == id_ugv) {\n        return;\n    }\n    //std::cout << \"nei_odom_cb \" << id << std::endl;\n    state_nei[id].x = odom->pose.pose.position.x;\n    state_nei[id].y = odom->pose.pose.position.y;\n    state_nei[id].z = odom->pose.pose.position.z;\n    state_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n    state_nei[id].vx = odom->twist.twist.linear.x;\n    state_nei[id].vy = odom->twist.twist.linear.y;\n    state_nei[id].vz = odom->twist.twist.linear.z;\n    state_nei[id].ayaw = tf::getYaw(odom->twist.twist.angular);\n    if (sim_mode) {\n        double dist = sqrt(pow(state_nei[id].x - state_ugv.x, 2) + pow(state_nei[id].y - state_ugv.y, 2));\n        if (dist > 5) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    } else {\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 56.78419019709309}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t  if (id == -1) {\n    return;\n  }\n\n  if (id >= num_ugvs) {\n    return;\n  }\n\n  // Update the state of the neighboring UGV\n  state_nei[id].pose.position.x = odom->pose.pose.position.x;\n  state_nei[id].pose.position.y = odom->pose.pose.position.y;\n  state_nei[id].pose.position.z = odom->pose.pose.position.z;\n  state_nei[id].pose.orientation = odom->pose.pose.orientation;\n\n  // Check if the distance from the start position exceeds 5 meters\n  if (sim_mode) {\n    double distance = sqrt(pow(state_nei[id].pose.position.x - start_pose.pose.position.x, 2) +\n                           pow(state_nei[id].pose.position.y - start_pose.pose.position.y, 2) +\n                           pow(state_nei[id].pose.position.z - start_pose.pose.position.z, 2));\n    if (distance > 5.0) {\n      get_nei_state = false;\n    } else {\n      get_nei_state = true;\n    }\n  } else {\n    get_nei_state = true;\n  }\n}", "CodeBleu_score": 42.315417184059775}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t  if (id != id_ugv) {\n    state_nei[id].pos.x = odom->pose.pose.position.x;\n    state_nei[id].pos.y = odom->pose.pose.position.y;\n    state_nei[id].pos.z = odom->pose.pose.position.z;\n    state_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n    state_nei[id].vel.x = odom->twist.twist.linear.x;\n    state_nei[id].vel.y = odom->twist.twist.linear.y;\n    state_nei[id].vel.z = odom->twist.twist.linear.z;\n    state_nei[id].ang_vel = odom->twist.twist.angular.z;\n  }\n\n  if (sim_mode) {\n    double dist = sqrt(pow(state_nei[id].pos.x - state_ugv.pos.x, 2) + pow(state_nei[id].pos.y - state_ugv.pos.y, 2));\n    if (dist > 5.0) {\n      get_nei_state = false;\n    } else {\n      get_nei_state = true;\n    }\n  } else {\n    get_nei_state = true;\n  }\n}", "CodeBleu_score": 46.678197124923706}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter == 5) {\n        update_counter = 0;\n        update_map(msg);\n    }\n}", "CodeBleu_score": 56.74881254350679}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    // Check if odometry is ready\n    if (!odom_ready) {\n        return;\n    }\n\n    // Increment update counter\n    update_counter++;\n\n    // Update Astar map every fifth update\n    if (update_counter % 5 == 0) {\n        // Reset update counter\n        update_counter = 0;\n\n        // Update Astar map with new point cloud data\n        update_astar_map(msg);\n    }\n}", "CodeBleu_score": 48.131128821417676}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (!odom_ready)\n    return;\n\n  if (update_counter++ % 5 == 0) {\n    ROS_INFO(\"Updating Astar map with new point cloud data\");\n    update_astar_map(msg);\n  }\n}", "CodeBleu_score": 23.82564107204837}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (!get_gpcl) {\n        get_gpcl = true;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr gpcl(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*global_point, *gpcl);\n        gpcl_ptr = gpcl;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inf(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::copyPointCloud(*gpcl, *gpcl_inf);\n        pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree(0.05);\n        octree.setInputCloud(gpcl_inf);\n        octree.addPointsFromInputCloud();\n        for (int i = 0; i < gpcl_inf->points.size(); i++) {\n            std::vector<int> pointIdxNKNSearch(1);\n            std::vector<float> pointNKNSquaredDistance(1);\n            octree.nearestKSearch(gpcl_inf->points[i], 1, pointIdxNKNSearch, pointNKNSquaredDistance);\n            if (pointNKNSquaredDistance[0] > 0.05 * 0.05) {\n                gpcl_inf->points[i].x = gpcl_inf->points[pointIdxNKNSearch[0]].x;\n                gpcl_inf->points[i].y = gpcl_inf->points[pointIdxNKNSearch[0]].y;\n                gpcl_inf->points[i].z = gpcl_inf->points[pointIdxNKNSearch[0]].z;\n            }\n        }\n        gpcl_ptr = gpcl_inf;\n    }\n}", "CodeBleu_score": 48.40758227954647}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t  if (get_gpcl == false) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_cloud);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr global_cloud_inflated(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;\n    voxel_grid.setLeafSize(0.1, 0.1, 0.1);\n    voxel_grid.setInputCloud(global_cloud);\n    voxel_grid.filter(*global_cloud_inflated);\n    *global_cloud = *global_cloud_inflated;\n  }\n}", "CodeBleu_score": 50.82606598470145}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t  pcl::PointCloud<pcl::PointXYZ> laser_cloud;\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  *laser_cloud_ptr = laser_scan_to_cloud(local_point);\n  if (simulation_mode) {\n    *laser_cloud_ptr += *local_map;\n  }\n  else {\n    pcl::PointCloud<pcl::PointXYZ>::Ptr local_map_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n    *local_map_ptr = *local_map;\n    pcl::PointCloud<pcl::PointXYZ>::Ptr odom_map_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n    *odom_map_ptr = odom_to_cloud(odom);\n    *odom_map_ptr += *local_map_ptr;\n    *local_map_ptr = *odom_map_ptr;\n    *local_map = *local_map_ptr;\n    *laser_cloud_ptr += *local_map_ptr;\n  }\n  *local_map = *laser_cloud_ptr;\n}", "CodeBleu_score": 43.50596188750367}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // Convert laser scan to PointCloud2\n    sensor_msgs::PointCloud2 cloud;\n    projector_.projectLaser(*local_point, cloud);\n\n    // Convert PointCloud2 to pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(cloud, *cloud_pcl);\n\n    // Update map using point cloud\n    if (!sim_mode) {\n        // Update map with odometry\n        Eigen::Affine3f transform = Eigen::Affine3f::Identity();\n        transform.translation() << odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z;\n        transform.rotate(Eigen::Quaternionf(odom.pose.pose.orientation.w, odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z));\n        pcl::transformPointCloud(*cloud_pcl, *cloud_pcl, transform);\n    }\n\n    // Merge local map with global map\n    *map_pcl_ += *cloud_pcl;\n}", "CodeBleu_score": 47.96792822111956}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\n    // Convert the laser scan to a PointCloud2 message\n    sensor_msgs::PointCloud2 laser_scan;\n    projector_.projectLaser(*local_point, laser_scan);\n\n    // Convert the PointCloud2 message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(laser_scan, *cloud);\n\n    // If not in simulation mode, merge the local map with the odometry data\n    if (simulation_mode_ == false) {\n        // Create a new PointCloud to hold the merged point cloud\n        pcl::PointCloud<pcl::PointXYZ>::Ptr merged_cloud (new pcl::PointCloud<pcl::PointXYZ>);\n\n        // Merge the local map with the odometry data\n        Eigen::Affine3f transform = Eigen::Affine3f::Identity();\n        transform.translation() << odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z;\n        transform.rotate(Eigen::Quaternionf(odom.pose.pose.orientation.w, odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z));\n        pcl::transformPointCloud(*local_map_, *merged_cloud, transform);\n        *merged_cloud += *cloud;\n\n        // Update the local map with the merged point cloud\n        local_map_ = merged_cloud;\n    }\n\n    // Update the local map with the laser scan data\n    *local_map_ += *cloud;\n\n    // Publish the updated local map\n    pub_map_.publish(*local_map_);\n}", "CodeBleu_score": 47.816168841651354}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_map(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_inflate(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl_map->header.frame_id = \"world\";\n    pcl_inflate->header.frame_id = \"world\";\n    pcl_map->height = 1;\n    pcl_inflate->height = 1;\n    pcl_map->is_dense = true;\n    pcl_inflate->is_dense = true;\n    for (int i = 0; i < map_size; i++) {\n        if (map[i].is_occupied) {\n            pcl_map->points.push_back(map[i].point);\n        }\n    }\n    pcl_map->width = pcl_map->points.size();\n    pcl_inflate->width = pcl_inflate->points.size();\n    global_pcl_pub.publish(pcl_map);\n    inflate_pcl_pub.publish(pcl_inflate);\n}", "CodeBleu_score": 53.369439008550145}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t  // convert the global point cloud map to a ROS message\n  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(*global_pcl, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n\n  // publish the global point cloud map\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // convert and publish the inflated point cloud\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 64.91394254270921}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\n    // Convert the global point cloud map to a ROS message\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(global_pcl, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n\n    // Publish the global point cloud map\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // Convert and publish the inflated point cloud\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(inflate_pcl, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 59.25875744216425}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  ROS_INFO(\"Lpointcloud_cb\");\n  // Check if odometry is ready\n  if (!odom_ready) {\n    ROS_INFO(\"Lpointcloud_cb: odom not ready\");\n    return;\n  }\n\n  // Update the A* algorithm's map using the new point cloud data and current UAV odometry\n  update_map(msg);\n\n  // Set the sensor_ready flag to true\n  sensor_ready = true;\n}", "CodeBleu_score": 53.21466740903864}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t  if (sensor_ready) {\n    // Update the map using the new point cloud data and current UAV odometry\n    update_map(msg, &uav_odom);\n\n    // Publish the updated map\n    publish_map();\n  }\n}", "CodeBleu_score": 38.120369436028}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    // Get the current time\n    rosTimeToChampTime(event.current_real);\n\n    // Get the desired pose from the body controller\n    champ::Pose desired_pose = body_controller_.getDesiredPose();\n\n    // Get the desired foot positions\n    champ::Pose foot_positions[4];\n    base_.getDesiredFootPositions(desired_pose, foot_positions);\n\n    // Compute velocity commands for the legs\n    champ::Velocity leg_velocities[4];\n    base_.getLegVelocities(foot_positions, leg_velocities);\n\n    // Perform inverse kinematics to determine target joint positions\n    float target_joints[12];\n    base_.getTargetJoints(leg_velocities, target_joints);\n\n    // Publish foot contact information\n    bool foot_contacts[4];\n    base_.getFootContacts(foot_contacts);\n\n    // Publish joint positions\n    publishJoints_(target_joints);\n\n    // Publish foot contact information\n    publishFootContacts_(foot_contacts);\n}", "CodeBleu_score": 51.336766243112045}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t    if (enable_foot_contact_publishing_ && !gazebo_) {\n        ContactsStamped foot_contacts_msg;\n        foot_contacts_msg.header.stamp = ros::Time::now();\n        foot_contacts_msg.contacts.resize(4);\n\n        for (int i = 0; i < 4; i++) {\n            foot_contacts_msg.contacts[i].contact_state = foot_contacts[i];\n            foot_contacts_msg.contacts[i].leg_id = i;\n            foot_contacts_msg.contacts[i].phase = gait_phase_;\n        }\n\n        foot_contacts_publisher_.publish(foot_contacts_msg);\n    }\n}", "CodeBleu_score": 60.852848194799414}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t    if (!foot_contacts_publisher_.getTopic().empty() && !in_gazebo_) {\n        ContactsStamped msg;\n        msg.header.stamp = ros::Time::now();\n        msg.contacts.resize(4);\n        for (int i = 0; i < 4; i++) {\n            msg.contacts[i].contact_state = foot_contacts[i];\n            msg.contacts[i].phase = gait_phase_[i];\n        }\n        foot_contacts_publisher_.publish(msg);\n    }\n}", "CodeBleu_score": 56.4862156539314}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (publish_foot_contacts_ && !in_gazebo_) {\n    ContactsStamped contacts_msg;\n    contacts_msg.header.stamp = ros::Time::now();\n    for (int i = 0; i < 4; i++) {\n      contacts_msg.contacts.push_back(foot_contacts[i]);\n    }\n    foot_contacts_publisher_.publish(contacts_msg);\n  }\n}", "CodeBleu_score": 58.65880599636498}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    # Publish a minimal joints message\n    joints_msg = JointState()\n    joints_msg.position = joints.position[:12]\n    self.joints_pub.publish(joints_msg)\n\n    # Construct a joint trajectory message\n    trajectory_msg = JointTrajectory()\n    trajectory_msg.joint_names = joints.name[:12]\n    trajectory_msg.points = [JointTrajectoryPoint(positions=joints.position[:12], time_from_start=Duration(secs=2))]\n\n    # Publish the joint trajectory message\n    self.joint_trajectory_pub.publish(trajectory_msg)\n}", "CodeBleu_score": 40.668924239639395}, {"code": "def joints_cmd_callback(self, joints){\n\t    # construct minimal joints message\n    joints_msg = JointState()\n    joints_msg.header = joints.header\n    joints_msg.position = joints.position[0:12]\n    self.joints_pub.publish(joints_msg)\n\n    # construct trajectory message\n    traj_msg = JointTrajectory()\n    traj_msg.header = joints.header\n    traj_msg.joint_names = joints.name[0:12]\n    traj_msg.points.append(JointTrajectoryPoint(positions=joints.position[0:12], time_from_start=Duration(secs=self.traj_duration)))\n    self.traj_pub.publish(traj_msg)\n}", "CodeBleu_score": 41.94196178438516}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message\n    joints_msg = JointState()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    joints_msg.position = joints\n    self.joints_pub.publish(joints_msg)\n\n    # Create a joint trajectory message\n    trajectory_msg = JointTrajectory()\n    trajectory_msg.header.stamp = rospy.Time.now()\n    trajectory_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    trajectory_msg.points = [JointTrajectoryPoint(positions=joints, time_from_start=rospy.Duration(1.0))]\n    self.trajectory_pub.publish(trajectory_msg)\n}", "CodeBleu_score": 40.299357438575115}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::string link_name = _msg->contact(i).collision1();\n    if (link_name.find(\"left_foot\") != std::string::npos) {\n      left_foot_contact_ = true;\n    } else if (link_name.find(\"right_foot\") != std::string::npos) {\n      right_foot_contact_ = true;\n    }\n  }\n}", "CodeBleu_score": 36.72442996623136}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    if (_msg->contact_size() == 0) {\n        return;\n    }\n\n    // Initialize foot contact states to false\n    for (int i = 0; i < 4; i++) {\n        foot_contact_states_[i] = false;\n    }\n\n    // Process each contact in the message\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        const Contact &contact = _msg->contact(i);\n\n        // Get the collision string from the contact\n        const std::string collision_string = contact.collision1() + \" \" + contact.collision2();\n\n        // Split the collision string to identify the contact link\n        std::istringstream iss(collision_string);\n        std::string link_name;\n        std::vector<std::string> link_names;\n        while (iss >> link_name) {\n            link_names.push_back(link_name);\n        }\n\n        // Check if the contact link matches one of the foot links\n        for (int j = 0; j < 4; j++) {\n            if (link_names[0] == foot_links_[j] || link_names[1] == foot_links_[j]) {\n                foot_contact_states_[j] = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 61.3057190453455}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  // Set foot contact states to false\n  left_foot_contact_ = false;\n  right_foot_contact_ = false;\n\n  // Process contact messages\n  for (int i = 0; i < _msg->contact_size(); ++i) {\n    gz::math::Vector3d position = _msg->contact(i).position();\n    gz::math::Vector3d normal = _msg->contact(i).normal();\n    std::string link_name = _msg->contact(i).collision1();\n\n    // Check if contact is with left foot link\n    if (link_name.find(\"left_foot\") != std::string::npos) {\n      left_foot_contact_ = true;\n    }\n\n    // Check if contact is with right foot link\n    if (link_name.find(\"right_foot\") != std::string::npos) {\n      right_foot_contact_ = true;\n    }\n  }\n}", "CodeBleu_score": 43.77641131228264}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  if (!controller_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::Vector3d acceleration_body = odometry_.orientation.toRotationMatrix().transpose() * acceleration;\n  Eigen::Vector3d angular_acceleration_body = odometry_.orientation.toRotationMatrix().transpose() * angular_acceleration;\n\n  // Project thrust onto the body z-axis.\n  double thrust = acceleration_body.z();\n  thrust = std::max(thrust, 0.0);\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d acceleration_combined = angular_acceleration_body;\n  acceleration_combined.z() = thrust;\n\n  // Calculate rotor velocities.\n  Eigen::VectorXd rotor_velocities_unscaled = rotor_velocity_matrix_ * acceleration_combined;\n  rotor_velocities_unscaled = rotor_velocities_unscaled.cwiseMax(0.0);\n  rotor_velocities_unscaled = rotor_velocities_unscaled.cwiseSqrt();\n\n  *rotor_velocities = rotor_velocities_unscaled;\n}", "CodeBleu_score": 55.92864822544807}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  if (!active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::Vector3d thrust_vector;\n  thrust_vector = angular_acceleration + acceleration * vehicle_parameters_.mass_;\n\n  Eigen::Vector3d rotor_velocities_vector;\n  rotor_velocities_vector = thrust_vector.cwiseProduct(rotor_direction_);\n\n  rotor_velocities->resize(rotor_velocities_vector.size());\n\n  for (int i = 0; i < rotor_velocities_vector.size(); ++i) {\n    (*rotor_velocities)[i] = std::sqrt(std::max(0.0, rotor_velocities_vector[i]));\n  }\n}", "CodeBleu_score": 47.74309133050817}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  if (!controller_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Compute desired acceleration and angular acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust_body = odometry_.orientation.toRotationMatrix().transpose() * acceleration;\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d angular_acceleration_thrust = angular_acceleration + thrust_body;\n\n  // Compute rotor velocities.\n  *rotor_velocities = rotor_velocities_matrix_ * angular_acceleration_thrust;\n\n  // Ensure non-negative values.\n  *rotor_velocities = rotor_velocities->cwiseMax(0);\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 51.53218311164228}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\n  // Calculate the position error\n  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n  // Calculate the velocity error in the world frame\n  Eigen::Vector3d velocity_error = odometry_.velocity - command_trajectory_.velocity;\n\n  // Calculate the desired acceleration\n  *acceleration = position_error.cwiseProduct(position_gains_) + velocity_error.cwiseProduct(velocity_gains_);\n\n  // Adjust for vehicle mass, gravity, and commanded acceleration\n  *acceleration -= odometry_.mass * gravity_ + command_trajectory_.acceleration;\n}", "CodeBleu_score": 33.67105630234058}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\n    // Calculate position error\n    Eigen::Vector3d position_error = trajectory_.GetPosition(current_time_) - odometry_.GetPosition();\n\n    // Calculate velocity error\n    Eigen::Vector3d velocity_error = trajectory_.GetVelocity(current_time_) - odometry_.GetVelocity();\n\n    // Transform velocity error to world frame\n    Eigen::Vector3d velocity_error_world = odometry_.GetRotation().transpose() * velocity_error;\n\n    // Calculate desired acceleration\n    *acceleration = position_error * position_gains_ + velocity_error_world * velocity_gains_ + acceleration_gains_ * acceleration_command_;\n\n    // Adjust for vehicle mass, gravity, and commanded acceleration\n    *acceleration -= odometry_.GetRotation() * (mass_ * gravity_);\n    *acceleration -= acceleration_command_;\n}", "CodeBleu_score": 41.61826297879172}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // Get the current position and velocity from the odometry\n  Eigen::Vector3d position;\n  Eigen::Vector3d velocity;\n  GetOdometry(&position, &velocity);\n\n  // Get the current command trajectory\n  Eigen::Vector3d position_cmd;\n  Eigen::Vector3d velocity_cmd;\n  Eigen::Vector3d acceleration_cmd;\n  GetCommandTrajectory(&position_cmd, &velocity_cmd, &acceleration_cmd);\n\n  // Transform the velocity to the world frame\n  Eigen::Vector3d velocity_world = transform_.rotation() * velocity;\n\n  // Compute the position and velocity errors\n  Eigen::Vector3d position_error = position_cmd - position;\n  Eigen::Vector3d velocity_error = velocity_cmd - velocity_world;\n\n  // Compute the desired acceleration\n  Eigen::Vector3d acceleration_desired =\n      position_gains_ * position_error + velocity_gains_ * velocity_error + acceleration_cmd;\n\n  // Adjust for vehicle mass, gravity, and commanded acceleration\n  acceleration_desired += gravity_ * mass_ - acceleration_cmd;\n\n  // Set the desired acceleration\n  *acceleration = acceleration_desired;\n}", "CodeBleu_score": 49.13246365755862}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  rotor_velocities->resize(num_rotors_);\n\n  // Compute desired angular acceleration\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // Combine desired angular acceleration with thrust reference\n  Eigen::VectorXd desired_velocities(num_rotors_);\n  desired_velocities << angular_acceleration, control_attitude_thrust_reference_(3);\n\n  // Compute rotor velocities\n  *rotor_velocities = rotor_velocity_matrix_ * desired_velocities;\n\n  // Ensure rotor velocities are at least one\n  for (int i = 0; i < num_rotors_; ++i) {\n    if ((*rotor_velocities)[i] < 1.0) {\n      (*rotor_velocities)[i] = 1.0;\n    }\n  }\n\n  // Take square root of each component\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 60.28862658176867}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 3.965771277166072}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n\n  rotor_velocities->resize(rotor_velocities_.size());\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::Vector3d thrust_reference;\n  thrust_reference[0] = control_attitude_thrust_reference_[3];\n  thrust_reference[1] = control_attitude_thrust_reference_[4];\n  thrust_reference[2] = control_attitude_thrust_reference_[5];\n\n  Eigen::Vector3d desired_acceleration = thrust_reference - mass_ * g_;\n\n  Eigen::Vector3d desired_velocity = angular_acceleration.cwiseProduct(inertia_inv_) + desired_acceleration;\n\n  Eigen::Vector3d desired_velocity_body = attitude_.transpose() * desired_velocity;\n\n  Eigen::Matrix3d rotor_velocities_matrix = rotor_velocities_matrix_;\n\n  Eigen::Vector3d rotor_velocities_body = rotor_velocities_matrix * desired_velocity_body;\n\n  for (int i = 0; i < rotor_velocities_body.size(); i++) {\n    (*rotor_velocities)[i] = std::sqrt(std::max(0.0, rotor_velocities_body[i]));\n  }\n}", "CodeBleu_score": 44.464512002449794}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    if start_index == len(self.time):\n        start_index -= 1\n    if end_index == len(self.time):\n        end_index -= 1\n    new_object = copy.deepcopy(self)\n    new_object.time = new_object.time[start_index:end_index]\n    new_object.value = new_object.value[start_index:end_index]\n    new_object.start_time = new_object.time[0]\n    new_object.end_time = new_object.time[-1]\n    return new_object\n\n", "CodeBleu_score": 50.05294977280356}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    new_obj = copy.deepcopy(self)\n    new_obj.time = new_obj.time[start_index:end_index]\n    new_obj.value = new_obj.value[start_index:end_index]\n    return new_obj\n\n", "CodeBleu_score": 31.411346158617093}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    sliced = copy.deepcopy(self)\n    sliced.time = sliced.time[start_index:end_index]\n    sliced.data = sliced.data[start_index:end_index]\n    return sliced\n\n", "CodeBleu_score": 30.591568413206495}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    orientation = [quaternion.x, quaternion.y, quaternion.z, quaternion.w]\n    euler = tf.transformations.euler_from_quaternion(orientation)\n    yaw = euler[2]\n    point = Point(position.x, position.y, position.z)\n    if not (self.last_point and self.last_yaw):\n        self.last_point = point\n        self.last_yaw = yaw\n    elif self.last_point != point or self.last_yaw != yaw:\n        self.last_point = point\n        self.last_yaw = yaw\n        self.append_point(point)\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 28.762306111410645}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    yaw = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])[2]\n\n    # Create a Point object and append it to the arrays\n    point = Point(position.x, position.y, position.z)\n    self.append_point(point)\n\n    # Append the yaw and corresponding times to their respective arrays\n    self.append_yaw(yaw)\n    self.append_times(msg_time, bag_time)\n\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint is not None:\n        if self.last_waypoint.position != point.position or self.last_waypoint.yaw != yaw:\n            self.last_waypoint = point\n            return True\n    else:\n        self.last_waypoint = point\n        return True\n    return False\n\n", "CodeBleu_score": 27.652278366517024}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    quaternion = [rotation.x, rotation.y, rotation.z, rotation.w]\n    euler = tf.transformations.euler_from_quaternion(quaternion)\n    yaw = euler[2]\n    point = Point(position.x, position.y, position.z)\n    if not self.last_point or self.last_point != point or self.last_yaw != yaw:\n        self.last_point = point\n        self.last_yaw = yaw\n        self.append_point(point)\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 27.881028950165977}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topics[0]:\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9, bag_time)\n\n", "CodeBleu_score": 23.969868846105268}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    # convert the message timestamp to seconds\n    msg_time = msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9\n    # for each IMU topic, if the topic matches, append the linear acceleration data to the corresponding x, y, and z attributes\n    if topic == self.imu_topic:\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n        # append the message time and bag time to the time attributes\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 34.92314378344963}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topics[0]:\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9, bag_time)\n    elif topic == self.imu_topics[1]:\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9, bag_time)\n    elif topic == self.imu_topics[2]:\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9, bag_time)\n    elif topic == self.imu_topics[3]:\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.secs + msg.header.st", "CodeBleu_score": 23.099466310115112}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title and a subplot for accelerations\n    fig, ax = plt.subplots(figsize=(10, 6))\n    fig.suptitle(\"Accelerations\")\n\n    # Plot the x, y, and z components of each acceleration dataset with different colors and labels\n    for i, acc_data in enumerate(self.accelerations):\n        ax.plot(acc_data[\"time\"], acc_data[\"x\"], color=\"blue\", label=f\"Acceleration X {i+1}\")\n        ax.plot(acc_data[\"time\"], acc_data[\"y\"], color=\"green\", label=f\"Acceleration Y {i+1}\")\n        ax.plot(acc_data[\"time\"], acc_data[\"z\"], color=\"red\", label=f\"Acceleration Z {i+1}\")\n\n    # Add labels for the x and y axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n    # Include a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename and save the plot as a PNG file\n    if self.save_plots:\n        filename = f\"accelerations{plot_suffix}.png\"\n        plt.savefig(filename)\n        print(f\"Plot saved as {filename}\")\n\n    # Show the plot\n    plt.show()\n\n\n", "CodeBleu_score": 33.27217298574782}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.plot_accelerations:\n        fig = plt.figure(figsize=(15, 10))\n        ax = fig.add_subplot(111)\n        for dataset in self.accelerations:\n            x = dataset['time']\n            y = dataset['x']\n            ax.plot(x, y, label='x')\n            y = dataset['y']\n            ax.plot(x, y, label='y')\n            y = dataset['z']\n            ax.plot(x, y, label='z')\n        ax.set_xlabel('Time (s)')\n        ax.set_ylabel('Acceleration (m/s^2)')\n        ax.legend()\n        if plot_suffix is None:\n            plot_suffix = ''\n        if self.plot_save_enabled:\n            plot_filename = self.plot_prefix + 'accelerations' + plot_suffix + '.png'\n            fig.savefig(plot_filename)\n            print('Plot saved to ' + plot_filename)\n        else:\n            plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 39.17086380693411}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig, ax = plt.subplots()\n    ax.set_title(\"Accelerations\")\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    for accel_name, accel_data in self.accelerations.items():\n        ax.plot(accel_data[\"time\"], accel_data[\"x\"], label=f\"{accel_name} X\")\n        ax.plot(accel_data[\"time\"], accel_data[\"y\"], label=f\"{accel_name} Y\")\n        ax.plot(accel_data[\"time\"], accel_data[\"z\"], label=f\"{accel_name} Z\")\n    ax.legend()\n    if self.save_plots:\n        filename = f\"accelerations{plot_suffix}.png\"\n        fig.savefig(filename)\n        print(f\"Plot saved as {filename}\")\n    plt.show()", "CodeBleu_score": 31.314065549241093}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            xyz_one = self.get_pose_xyz(pose_indeces[i])\n            xyz_two = self.get_pose_xyz(pose_indeces[j])\n            compare_two_xyz(xyz_one, xyz_two)\n\n", "CodeBleu_score": 35.38905095321636}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is not None and end_time is not None:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None:\n            if start_time <= collision.time:\n                collision_times.append(collision.time)\n        elif end_time is not None:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n\n", "CodeBleu_score": 39.56249004507008}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time is not None and end_time is not None:\n            if time >= start_time and time <= end_time:\n                collision_times.append(time)\n        elif start_time is not None and end_time is None:\n            if time >= start_time:\n                collision_times.append(time)\n        elif start_time is None and end_time is not None:\n            if time <= end_time:\n                collision_times.append(time)\n        else:\n            collision_times.append(time)\n    return collision_times\n\n\n\n", "CodeBleu_score": 37.20431347919945}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time and end_time:\n            if start_time <= time <= end_time:\n                collision_times.append(time)\n        else:\n            collision_times.append(time)\n    return collision_times\n\n\n\n\n", "CodeBleu_score": 39.819788976841394}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate the multiplier based on camera parameters\n  const float multiplier = this->GetMultiplier();\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n\n  // Compute the RMS noise and the noise values\n  const float rms_noise = this->GetRMSNoise();\n  const float noise_mean = this->GetNoiseMean();\n  const float noise_stddev = this->GetNoiseStddev();\n\n  // Add noise to the depth data\n  for (int i = 0; i < depth_data.size(); ++i) {\n    if (this->InRange(depth_data[i])) {\n      depth_data[i] = depth_data[i] + noise_mean +\n                      rms_noise * multiplier *\n                          std::normal_distribution<float>(0.0f, noise_stddev)(\n                              this->generator);\n    } else {\n      depth_data[i] = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 54.078063016228924}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate the multiplier based on camera parameters\n  const float multiplier =\n      (this->max_depth - this->min_depth) /\n      (this->max_depth - this->min_depth_without_noise);\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic,\n                           Eigen::RowMajor>>\n      data_vec(data, width, height);\n\n  // Compute the RMS noise and the noise values\n  const float rms_noise =\n      this->rms_noise * multiplier * (this->max_depth - this->min_depth);\n  const float noise_val =\n      this->noise_val * multiplier * (this->max_depth - this->min_depth);\n\n  // Add noise to the data\n  for (int i = 0; i < data_vec.rows(); i++) {\n    for (int j = 0; j < data_vec.cols(); j++) {\n      if (this->InRange(data_vec(i, j))) {\n        data_vec(i, j) += rms_noise *\n                          (static_cast<float>(rand()) / static_cast<float>(RAND_MAX)) +\n                          noise_val;\n      } else {\n        data_vec(i, j) = this->bad_point_val;\n      }\n    }\n  }\n}", "CodeBleu_score": 43.43083589044359}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate multiplier\n  const float multiplier =\n      this->focal_length * this->baseline / this->depth_scale;\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vector(data, width * height);\n\n  // Compute RMS noise\n  const float rms_noise = this->rms_noise_value * multiplier;\n\n  // Compute noise values\n  Eigen::VectorXf noise_values = Eigen::VectorXf::Zero(width * height);\n  for (int i = 0; i < width * height; i++) {\n    noise_values(i) = rms_noise * this->rng.Gaussian();\n  }\n\n  // Add noise to data if in range\n  for (int i = 0; i < width * height; i++) {\n    if (this->InRange(data_vector(i))) {\n      data_vector(i) += noise_values(i);\n    } else {\n      data_vector(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 52.60601490204338}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  common::Time current_time = world->GetSimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time(current_time.sec, current_time.nsec);\n\n  // Write the trajectory message to the bag file\n  bag.write(namespace_ + \"/waypoint\", ros_time, trajectory_msg);\n}", "CodeBleu_score": 58.88325252300458}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Convert the trajectory message to a ROS message\n  trajectory_msgs::MultiDOFJointTrajectory trajectory_ros_msg =\n      *trajectory_msg;\n\n  // Get the current simulation time\n  gazebo::common::Time current_time =\n      gazebo::event::Events::GetClock()->GetSimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = ros::Time::fromBoost(current_time.Double());\n\n  // Write the trajectory message to the bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, trajectory_ros_msg);\n}", "CodeBleu_score": 50.766851301498164}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  common::Time current_time = world->SimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = ros::Time::fromBoost(current_time.Double());\n\n  // Write the trajectory message to the bag file\n  trajectory_bag_writer_->write(ros_time, trajectory_msg);\n}", "CodeBleu_score": 50.32007182791065}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t    // Convert the simulation time to ROS time\n    ros::Time ros_time = ros::Time::now();\n\n    // Prepare the message\n    sensor_msgs::JointState msg;\n    msg.header.stamp = ros_time;\n    msg.name.resize(motor_joints_.size());\n    msg.velocity.resize(motor_joints_.size());\n\n    // Iterate through the motor joints\n    for (int i = 0; i < motor_joints_.size(); i++) {\n        // Calculate the slowed-down rotational velocity\n        double rotational_velocity = motor_joints_[i]->GetVelocity(0);\n        double slowed_down_velocity = rotational_velocity * slowdown_factor_;\n\n        // Assign the slowed-down rotational velocity to the message\n        msg.name[i] = motor_joints_[i]->GetScopedName();\n        msg.velocity[i] = slowed_down_velocity;\n    }\n\n    // Set the message timestamp\n    msg.header.stamp = ros_time;\n\n    // Write the message to the bag file\n    motor_bag_writer_.write(motor_topic_, msg);\n}", "CodeBleu_score": 50.91817514651198}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t    ros::Time ros_time = ros::Time(now.sec, now.nsec);\n    ros::Duration duration = ros_time - start_time;\n\n    // Prepare the message\n    sensor_msgs::JointState msg;\n    msg.header.stamp = ros_time;\n    msg.header.frame_id = \"world\";\n    msg.name.resize(motor_joints_.size());\n    msg.position.resize(motor_joints_.size());\n    msg.velocity.resize(motor_joints_.size());\n    msg.effort.resize(motor_joints_.size());\n\n    // Iterate through the motor joints and set the velocities\n    for (unsigned int i = 0; i < motor_joints_.size(); i++) {\n        msg.name[i] = motor_joints_[i]->GetName();\n        msg.position[i] = motor_joints_[i]->GetAngle(0).Radian();\n        msg.velocity[i] = motor_joints_[i]->GetVelocity(0);\n        msg.effort[i] = 0;\n    }\n\n    // Write the message to the bag file\n    bag_.write(namespace_ + \"/\" + motor_topic_, ros_time, msg);\n}", "CodeBleu_score": 52.638509438059714}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert simulation time to ROS time\n  ros::Time ros_time = ros::Time::fromBoost(now.toSimTime());\n\n  // Prepare message for actuator velocities\n  gazebo_msgs::ActuatorState msg;\n  msg.header.stamp = ros_time;\n  msg.name.resize(motor_joints_.size());\n  msg.state.resize(motor_joints_.size());\n\n  // Iterate through motor joints\n  for (unsigned int i = 0; i < motor_joints_.size(); ++i) {\n    // Get joint name\n    msg.name[i] = motor_joints_[i]->GetName();\n\n    // Get joint velocity\n    double joint_velocity = motor_joints_[i]->GetVelocity(0);\n\n    // Calculate slowed-down rotational velocity\n    double rotational_velocity = joint_velocity * slowdown_factor_;\n\n    // Assign rotational velocity to message\n    msg.state[i] = rotational_velocity;\n  }\n\n  // Set message timestamp\n  msg.header.stamp = ros_time;\n\n  // Write message to bag file\n  bag_.write(motor_topic_, ros_time, msg);\n}", "CodeBleu_score": 50.57356904668796}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_printing_) {\n    ROS_INFO(\"RollPitchYawrateThrustCallback called.\");\n  }\n  roll_surface_.angle = NormalizedInputToAngle(roll_surface_,\n                                               roll_pitch_yawrate_thrust_msg->roll);\n  pitch_surface_.angle = NormalizedInputToAngle(pitch_surface_,\n                                                roll_pitch_yawrate_thrust_msg->pitch);\n  yaw_rate_surface_.angle = NormalizedInputToAngle(yaw_rate_surface_,\n                                                   roll_pitch_yawrate_thrust_msg->yaw_rate);\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust;\n}", "CodeBleu_score": 39.80569298258182}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_printing_enabled_) {\n    ROS_INFO_STREAM(\n        \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called\");\n  }\n\n  // Convert normalized input values to control surface angles\n  double aileron_angle = NormalizedInputToAngle(\n      aileron_control_surface_, roll_pitch_yawrate_thrust_msg->roll);\n  double elevator_angle = NormalizedInputToAngle(\n      elevator_control_surface_, roll_pitch_yawrate_thrust_msg->pitch);\n  double rudder_angle = NormalizedInputToAngle(\n      rudder_control_surface_, roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set control surface angles\n  aileron_joint_->SetAngle(0, aileron_angle);\n  elevator_joint_->SetAngle(0, elevator_angle);\n  rudder_joint_->SetAngle(0, rudder_angle);\n\n  // Set throttle value\n  throttle_joint_->SetVelocity(0, roll_pitch_yawrate_thrust_msg->thrust);\n}", "CodeBleu_score": 40.07011187351427}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_printing_) {\n    ROS_INFO(\"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called.\");\n  }\n\n  double aileron_angle = NormalizedInputToAngle(aileron_,\n                                                roll_pitch_yawrate_thrust_msg->roll);\n  double elevator_angle = NormalizedInputToAngle(elevator_,\n                                                 roll_pitch_yawrate_thrust_msg->pitch);\n  double rudder_angle = NormalizedInputToAngle(rudder_,\n                                               roll_pitch_yawrate_thrust_msg->yaw_rate);\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust;\n\n  if (debug_printing_) {\n    ROS_INFO(\"aileron_angle: %f, elevator_angle: %f, rudder_angle: %f, throttle: %f\",\n             aileron_angle, elevator_angle, rudder_angle, throttle);\n  }\n\n  // TODO: Add support for other control surfaces.\n  // TODO: Add support for more than one control surface.\n  // TODO: Add support for more than one motor.\n  // TODO: Add support for more than one motor per control surface.\n\n  // Set the control surface angles.\n  aileron_joint_->SetAngle(0, aileron_angle);\n  elevator_joint_->SetAngle(0, elevator_angle);\n  rudder_joint_->SetAngle(0, rudder_angle);\n\n  // Set the throttle.\n  throttle_joint_->SetForce(0, throttle);\n}", "CodeBleu_score": 34.6998054220234}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Create a timeval structure for the timeout.\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Create a file descriptor set to poll for data.\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(_fd, &readfds);\n\n  // Poll for data on the file descriptor.\n  int retval = select(_fd + 1, &readfds, NULL, NULL, &timeout);\n\n  // If data is available, receive and parse the data.\n  if (retval > 0) {\n    // Receive the data.\n    char buffer[1024];\n    int bytes_received = recv(_fd, buffer, sizeof(buffer), 0);\n\n    // If there are no bytes received, return.\n    if (bytes_received <= 0) {\n      return;\n    }\n\n    // Parse the MAVLink messages from the buffer.\n    mavlink_message_t msg;\n    mavlink_status_t status;\n    for (int i = 0; i < bytes_received; ++i) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n        // Handle the message.\n        handle_message(&msg);\n      }\n    }\n  }\n}", "CodeBleu_score": 60.02469563436066}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Perform poll operation on file descriptors\n  fd_set read_fds;\n  FD_ZERO(&read_fds);\n  FD_SET(_fd, &read_fds);\n  int ret = select(_fd + 1, &read_fds, nullptr, nullptr, &timeout);\n\n  if (ret > 0) {\n    // Receive data and parse MAVLink messages\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    ssize_t len = recvfrom(_fd, buffer, sizeof(buffer), 0, nullptr, nullptr);\n\n    if (len > 0) {\n      // Parse MAVLink messages from buffer\n      mavlink_message_t msg;\n      mavlink_status_t status;\n      for (int i = 0; i < len; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n          // Optionally forward parsed message to serial connection\n          if (serial_enabled_) {\n            send_mavlink_message(&msg, 0);\n          }\n\n          // Handle parsed message\n          handle_message(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 65.73331610688426}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  // Set up timeout.\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for data.\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(_fd, &readfds);\n  int retval = select(_fd + 1, &readfds, NULL, NULL, &tv);\n\n  if (retval == -1) {\n    gzerr << \"Error polling for MAVLink data.\n\";\n    return;\n  }\n\n  // If data is available, receive and parse MAVLink messages.\n  if (retval > 0) {\n    if (FD_ISSET(_fd, &readfds)) {\n      // Receive data.\n      char buf[1024];\n      ssize_t len = recvfrom(_fd, buf, sizeof(buf), 0, NULL, NULL);\n\n      if (len <= 0) {\n        gzerr << \"Error receiving MAVLink data.\n\";\n        return;\n      }\n\n      // Parse MAVLink messages.\n      mavlink_message_t msg;\n      mavlink_status_t status;\n\n      for (int i = 0; i < len; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status)) {\n          handle_message(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 61.88482004683094}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t    std::lock_guard<std::mutex> lock(mutex_);\n    if (is_open_) {\n        io_service_.stop();\n        serial_device_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n        is_open_ = false;\n    }\n}", "CodeBleu_score": 58.51270637935519}, {"code": "void GazeboMavlinkInterface::close() {\n\t    boost::mutex::scoped_lock lock(mutex);\n    if (isOpen) {\n        io_service.stop();\n        serial_port.close();\n        if (io_thread.joinable()) {\n            io_thread.join();\n        }\n        isOpen = false;\n    }\n}", "CodeBleu_score": 55.83549173061816}, {"code": "void GazeboMavlinkInterface::close() {\n\t  // Lock the mutex to ensure thread safety\n  boost::mutex::scoped_lock lock(mutex_);\n\n  // Check if the interface is open\n  if (open_) {\n    // Stop the I/O service\n    io_service_.stop();\n\n    // Close the serial device\n    serial_device_.close();\n\n    // Join the I/O thread if it is joinable\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n\n    // Set the interface to closed\n    open_ = false;\n  }\n}", "CodeBleu_score": 60.545499790009025}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d p1, ignition::math::Vector3d p2,\n  double x\n}", "CodeBleu_score": 6.844954545372481}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    const ignition::math::Vector3d &_point1,\n    const ignition::math::Vector3d &_point2,\n    const ignition::math::Vector3d &_value1,\n    const ignition::math::Vector3d &_value2,\n    const ignition::math::Vector3d &_position\n}", "CodeBleu_score": 27.815589152709595}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t  ignition::math::Vector3d const &p0,\n  ignition::math::Vector3d const &p1,\n  ignition::math::Vector3d const &v0,\n  ignition::math::Vector3d const &v1,\n  ignition::math::Vector3d const &p\n}", "CodeBleu_score": 25.516656511595997}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t    if (time != _time) {\n        time = _time;\n        if (looping) {\n            time = fmod(time, length);\n            if (time < 0.0) {\n                time += length;\n            }\n        } else {\n            time = glm::clamp(time, 0.0, length);\n        }\n        if (time == length) {\n            time = 0.0;\n        }\n        Update();\n    }\n}", "CodeBleu_score": 40.89455060109663}, {"code": "void Animation::SetTime(double _time){\n\t\tdouble oldTime = time;\n\ttime = _time;\n\tif (time < 0) {\n\t\ttime = 0;\n\t}\n\tif (time > length) {\n\t\ttime = length;\n\t}\n\tif (looping) {\n\t\ttime = fmod(time, length);\n\t}\n\tif (oldTime != time) {\n\t\tUpdate(time);\n\t}\n}", "CodeBleu_score": 24.525102855189523}, {"code": "void Animation::SetTime(double _time){\n\t    if (_time != time) {\n        time = _time;\n        Update();\n    }\n}", "CodeBleu_score": 27.81446245713904}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.send_target(target_raw_pose)\n    print(f'Vehicle type: {self.vehicle_type}')\n    print(f'Vehicle ID: {self.vehicle_id}')\n    print(f'Flight mode: {self.flight_mode}')\n\n", "CodeBleu_score": 41.485215700620955}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_pose = self.construct_target()\n    self.vehicle.send_mavlink(target_pose)\n    print(self.vehicle.vehicle_type, self.vehicle.vehicle_id, self.vehicle.mode.name)\n", "CodeBleu_score": 42.54668660997644}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.position[0], y=self.position[1], z=self.position[2], yaw=self.yaw)\n    self.send_target_raw_pose(target_raw_pose)\n    print(f\"Vehicle Type: {self.vehicle_type}\")\n    print(f\"Vehicle ID: {self.vehicle_id}\")\n    print(f\"Flight Mode: {self.flight_mode}\")\n\n", "CodeBleu_score": 53.8436997826653}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service.set_flight_mode(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+':'+self.flight_mode+' mode switch successful')\n            return True\n        except Exception as e:\n            print(self.vehicle_type+'_'+self.vehicle_id+':'+self.flight_mode+' mode switch failed')\n            return False\n\n", "CodeBleu_score": 61.329508277490405}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode = self.flight_mode_service.switch_to_mode(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except Exception as e:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":Mode switch failed: \"+str(e))\n            return False\n\n", "CodeBleu_score": 56.880427631811926}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        return True\n    else:\n        print(\"Attempting to switch to \"+self.flight_mode+\" mode\")\n        try:\n            self.flight_mode_service = self.vehicle.flight_mode_service\n            self.flight_mode_service.set_flight_mode(self.flight_mode)\n            print(\"Successfully switched to \"+self.flight_mode+\" mode\")\n            return True\n        except:\n            print(\"Failed to switch to \"+self.flight_mode+\" mode\")\n            return False\n\n", "CodeBleu_score": 53.77820589354976}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n    self.hover_state_transition(x, y, z, w)\n    if self.hover_flag == 0:\n        self.hold_state_transition(x, y, z, w, 'enu')\n        if self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n\n", "CodeBleu_score": 36.400778288928635}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n    self.hover_state_transition(x, y, z, w)\n    if self.hover_flag == 0:\n        self.hold_state_transition(x, y, z, w, 'enu')\n        if self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n\n", "CodeBleu_score": 36.400778288928635}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n    self.hover_state_transition(x, y, z, w)\n    if self.hover_flag == 0:\n        self.hold_state_transition(x, y, z, w, 'enu')\n        if self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n\n", "CodeBleu_score": 36.400778288928635}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != 'HOVER':\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.hover_action()\n    else:\n        self.hover_flag = 1\n        self.hover_action()\n\n", "CodeBleu_score": 71.94923612777788}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 0:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            self.hover_action()\n    elif self.hover_flag == 1:\n        if x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            self.hover_action()\n\n", "CodeBleu_score": 45.144935480984294}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 1:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            self.hover_state.hover_flag = 0\n            self.hover_state.hover_action = 0\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, 0, 0)\n            self.hover_state.hover_state_transition(0, 0, ", "CodeBleu_score": 28.209906147273685}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw\n\n\n", "CodeBleu_score": 24.26411761619382}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw\n\n\n", "CodeBleu_score": 24.26411761619382}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw\n\n\n", "CodeBleu_score": 24.26411761619382}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = self.coordinate_frame_map['BODY_FRAME']\n    self.motion_type = self.motion_type_map['HOLD']\n    target_raw_pose = self.construct_target()\n    self.vehicle.send_mavlink(target_raw_pose)\n    print('Vehicle type: %s' % self.vehicle_type)\n    print('Vehicle ID: %s' % self.vehicle_id)\n    print('Flight mode: %s' % self.vehicle.mode.name)\n\n", "CodeBleu_score": 25.092708334222007}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = self.coordinate_frame_global_relative\n    self.motion_type = 1\n    target_raw_pose = self.construct_target()\n    self.vehicle.send_mavlink(target_raw_pose)\n    print(\"vehicle type:\", self.vehicle.vehicle_type, \"vehicle ID:\", self.vehicle.id, \"flight mode:\", self.vehicle.mode.name)\n\n", "CodeBleu_score": 25.648631523727218}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = self.coordinate_frame_mapping[self.vehicle_type]\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0)\n    self.vehicle.mode.set_attitude_target_body_ned(target_raw_pose)\n    print(f\"Vehicle Type: {self.vehicle_type}", "CodeBleu_score": 23.091242388474015}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        self.hover = False\n        try:\n            self.flightModeService.set_flight_mode(self.flight_mode)\n            self.flight_mode = self.flightModeService.get_flight_mode()\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except Exception as e:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + str(e))\n            return False\n\n", "CodeBleu_score": 61.1384298345267}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service.set_flight_mode(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except:\n            print(\"Flight mode switch failed\")\n            return False", "CodeBleu_score": 58.15448698825939}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service.flight_mode = self.flight_mode\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except Exception as e:\n            print(\"Error: Failed to switch flight mode to \" + self.flight_mode + \" for \" + self.vehicle_type + '_' + self.vehicle_id + \": \" + str(e))\n            return False\n\n", "CodeBleu_score": 50.0292047139699}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n\n", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg.pose\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = msg.pose\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = msg.pose\n        self.global_pose = msg.pose\n        self.global_pose.position.x += self.x_bias\n        self.global_pose.position.y += self.y_bias\n        self.global_pose.position.z += self.z_bias\n\n\n", "CodeBleu_score": 26.451013098845404}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg\n        if self.gcs_command == \"TAKEOFF\":\n            self.takeoff_target_pose = msg\n        elif self.gcs_command == \"HOVER\":\n            self.hover_target_pose = msg\n        self.global_pose = self.local_pose\n        self.global_pose.position.x += self.bias_x\n        self.global_pose.position.y += self.bias_y\n        self.global_pose.position.z += self.bias_z\n        self.global_pose.orientation.x += self.bias_roll\n        self.global_pose.orientation.y += self.bias_pitch\n        self.global_pose.orientation.z += self.bias_yaw\n        self.global_pose.orientation.w += self.bias_yaw\n\n\n", "CodeBleu_score": 22.792738474539913}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    # Update the local pose\n    if msg.id == self.id:\n        self.local_pose = msg\n        # Update the takeoff target pose\n        if self.gcs_command == 'takeoff':\n            self.takeoff_target_pose = msg\n        # Update the hover target pose\n        if self.gcs_command == 'hover':\n            self.hover_target_pose = msg\n        # Update the global pose\n        self.global_pose.position.x = msg.position.x + self.bias_x\n        self.global_pose.position.y = msg.position.y + self.bias_y\n        self.global_pose.position.z = msg.position.z + self.bias_z\n        self.global_pose.orientation = msg.orientation\n        # Publish the global pose\n        self.global_pose_pub.publish(self.global_pose)\n\n\n\n\n", "CodeBleu_score": 28.9727135307269}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n\n\n", "CodeBleu_score": 62.862379601652705}, {"code": "def takeoff_detection(self)\n\t\n    if self.arm_state == \"active\" and self.altitude > 0.2:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 60.617887392028216}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n\n\n", "CodeBleu_score": 62.862379601652705}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize the distance matrix\n    dist_mat = np.zeros((len(orig_formation), len(change_formation)))\n\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_mat[i, j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    dist_mat = np.round(50 - dist_mat).astype(int)\n\n    # Return the distance matrix\n    return dist_mat\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 25.244496959496175}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i][j] = int(np.linalg.norm(orig_formation[i] - change_formation[j]) - 50)\n    return distance_matrix\n\n\n", "CodeBleu_score": 26.183548729473454}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    graph = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist = np.linalg.norm(orig_formation[i] - change_formation[j])\n            graph[i][j] = int(50 - dist)\n    return graph\n\n\n\n\n", "CodeBleu_score": 27.99470048233878}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    self.label_left = [0 for _ in range(self.n)]\n    self.label_right = [0 for _ in range(self.m)]\n    self.match_right = [-1 for _ in range(self.m)]\n    self.visit_left = [False for _ in range(self.n)]\n    self.visit_right = [False for _ in range(self.m)]\n    self.slack_right = [sys.maxsize for _ in range(self.m)]\n    for i in range(self.n):\n        while True:\n            self.visit_left = [False for _ in range(self.n)]\n            self.visit_right = [False for _ in range(self.m)]\n            if self.find_path(i):\n                break\n            delta = sys.maxsize\n            for j in range(self.m):\n                if not self.visit_right[j]:\n                    delta = min(delta, self.slack_right[j])\n            for i in range(self.n):\n                if self.visit_left[i]:\n                    self.label_left[i] -= delta\n            for j in range(self.m):\n                if self.visit_right[j]:\n                    self.label_right[j] += delta\n                else:\n                    self.slack_right[j] -= delta\n    return self.match_right\n\n", "CodeBleu_score": 37.64752908335491}, {"code": "def KM(self)\n\t\n    self.match_right = [-1] * self.n_right\n    self.label_left = [0] * self.n_left\n    self.label_right = [0] * self.n_right\n    self.slack_right = [float('inf')] * self.n_right\n    for i in range(self.n_left):\n        self.visit_left = [False] * self.n_left\n        self.visit_right = [False] * self.n_right\n        while True:\n            if self.find_path(i):\n                break\n            delta = float('inf')\n            for j in range(self.n_right):\n                if not self.visit_right[j]:\n                    delta = min(delta, self.slack_right[j])\n            for j in range(self.n_left):\n                if self.visit_left[j]:\n                    self.label_left[j] -= delta\n            for j in range(self.n_right):\n                if self.visit_right[j]:\n                    self.label_right[j] += delta\n                else:\n                    self.slack_right[j] -= delta\n    return self.match_right", "CodeBleu_score": 37.29477307714206}, {"code": "def KM(self)\n\t\n    self.label_left = [0] * len(self.adj_matrix)\n    self.label_right = [0] * len(self.adj_matrix[0])\n    self.match_right = [-1] * len(self.adj_matrix[0])\n    self.visit_left = [False] * len(self.adj_matrix)\n    self.visit_right = [False] * len(self.adj_matrix[0])\n    self.slack_right = [float('inf')] * len(self.adj_matrix[0])\n    for i in range(len(self.adj_matrix)):\n        while True:\n            self.visit_left = [False] * len(self.adj_matrix)\n            self.visit_right = [False] * len(self.adj_matrix[0])\n            if self.find_path(i):\n                break\n            v = float('inf')\n            for j in range(len(self.adj_matrix[0])):\n                if not self.visit_right[j]:\n                    v = min(v, self.slack_right[j])\n            for j in range(len(self.adj_matrix)):\n                if self.visit_left[j]:\n                    self.label_left[j] += v\n            for j in range(len(self.adj_matrix[0])):\n                if self.visit_right[j]:\n                    self.label_right[j] -= v\n                else:\n                    self.slack_right[j] -= v\n    return self.match_right\n\n", "CodeBleu_score": 36.72070021355084}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n\n\n", "CodeBleu_score": 27.864792511395397}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n\n", "CodeBleu_score": 27.864792511395397}, {"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper HSV bounds for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n\n\n\n", "CodeBleu_score": 27.09532694324272}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t    TagDescriptionContainer* descriptionContainer;\n    bool printWarning;\n\n    if (standalone_tag_descriptions_.find(id) != standalone_tag_descriptions_.end()) {\n        descriptionContainer = standalone_tag_descriptions_[id];\n        return true;\n    }\n    else if (printWarning) {\n        std::cerr << \"Warning: Could not find standalone tag description for ID \" << id << std::endl;\n    }\n    return false;\n}", "CodeBleu_score": 43.873403344318056}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  bool found = false;\n  if (standalone_tag_descriptions_.find(id) != standalone_tag_descriptions_.end()) {\n    descriptionContainer = standalone_tag_descriptions_[id];\n    found = true;\n  } else if (printWarning) {\n    ROS_WARN_STREAM(\"Standalone tag description with ID \" << id << \" not found!\");\n  }\n  return found;\n}", "CodeBleu_score": 31.685235635762854}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    const TagDescriptionMap::const_iterator it = standalone_tag_descriptions_.find(id);\n    if (it == standalone_tag_descriptions_.end()) {\n        if (print_warning) {\n            LOG(WARNING) << \"Standalone tag description for ID \" << id << \" not found.\";\n        }\n        return false;\n    }\n    description_container = it->second;\n    return true;\n}", "CodeBleu_score": 39.88351088670813}]}
