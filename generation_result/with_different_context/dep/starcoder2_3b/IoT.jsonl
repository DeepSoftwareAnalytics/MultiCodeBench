{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = NULL;\n\tuint8_t *desc_ptr = (uint8_t *) desc;\n\tuint8_t *end_ptr = desc_ptr + desc->bLength;\n\twhile (desc_ptr < end_ptr) {\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tdesc_ptr += next_desc->bLength;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 43.021031889552305}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tuint8_t *desc_ptr = (uint8_t *) desc;\n\tuint8_t *end_ptr = desc_ptr + desc->wTotalLength;\n\tusb_conf_desc_t UDC_DESC_STORAGE *desc_tmp;\n\twhile (desc_ptr < end_ptr) {\n\t\tdesc_tmp = (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\tif (desc_tmp->bDescriptorType == desc_id) {\n\t\t\treturn desc_tmp;\n\t\t}\n\t\tdesc_ptr += desc_tmp->bLength;\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 42.48693302994427}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc = desc;\n\tuint8_t desc_len;\n\twhile (next_desc!= NULL) {\n\t\tdesc_len = next_desc->bLength;\n\t\tif (desc_len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (desc_len > 0) {\n\t\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\t\treturn next_desc;\n\t\t\t}\n\t\t}\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) next_desc + desc_len);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 44.26596820783343}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *ptr;\n\tuint8_t *end;\n\tuint16_t length;\n\tuint8_t iface_num_in_desc;\n\tuint8_t setting_num_in_desc;\n\tuint8_t desc_type;\n\tbool found_desc = false;\n\n\tif (udc_config_desc_ptr == NULL) {\n\t\treturn false;\n\t}\n\n\tptr = udc_config_desc_ptr;\n\tend = ptr + udc_config_desc_size;\n\n\twhile (ptr < end) {\n\t\tlength = ptr[1];\n\t\tlength = (length << 8) | ptr[0];\n\t\tdesc_type = ptr[2];\n\t\tptr += 3;\n\n\t\tif (length == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ptr + length > end) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (desc_type == USB_INTERFACE_DESCRIPTOR) {\n\t\t\tiface_num_in_desc = ptr[0];\n\t\t\tsetting_num_in_desc = ptr[1];\n\t\t\tif (iface_num == iface_num_in_desc && setting_num == setting_num_in_desc) {\n\t\t\t\tfound_desc = true;\n\t\t\t}\n\t\t}\n\n\t\tptr += length;\n\t}\n\n\treturn found_desc;\n}", "CodeBleu_score": 34.24282103722032}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tbool found = false;\n\tuint8_t *ptr = udc_config_desc_ptr;\n\tuint16_t desc_len = udc_config_desc_len;\n\n\twhile (desc_len > 0) {\n\t\tif (ptr[0] == USB_DESC_INTERFACE) {\n\t\t\tif (ptr[2] == iface_num) {\n\t\t\t\tif (ptr[4] == setting_num) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdesc_len -= ptr[0];\n\t\tptr += ptr[0];\n\t}\n\treturn found;\n}", "CodeBleu_score": 16.71336118192593}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = (uint8_t) (req->wValue & 0x000F);\n\tuint8_t ep_dir = (uint8_t) (req->wValue >> 7);\n\tuint8_t ep_status = 0;\n\n\tif (req->wLength!= 2) {\n\t\treturn false;\n\t}\n\n\tif (ep_dir == 0) {\n\t\tif (ep_num < UDC_EP_NUM) {\n\t\t\tep_status = udc_ep_status[ep_num];\n\t\t}\n\t} else {\n\t\tif (ep_num < UDC_EP_NUM) {\n\t\t\tep_status = udc_ep_status[ep_num + UDC_EP_NUM];\n\t\t}\n\t}\n\n\tif (ep_status == UDC_EP_STATUS_HALTED) {\n\t\tep_status = 1;\n\t} else {\n\t\tep_status = 0;\n\t}\n\n\tres->wLength = 2;\n\tres->data[0] = ep_status;\n\tres->data[1] = 0;\n\n\treturn true;\n}", "CodeBleu_score": 42.24199214832648}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = udc_req.wIndex & 0x0F;\n\tbool is_in = (udc_req.wIndex & 0x80)!= 0;\n\tbool is_halted = udc_ep_status[ep_num].is_halted;\n\tudc_ep_status[ep_num].is_halted = is_halted;\n\tif (udc_req.wLength!= 2) {\n\t\treturn false;\n\t}\n\tudc_resp.wLength = 2;\n\tudc_resp.data[0] = is_in? 0 : 1;\n\tudc_resp.data[1] = is_halted? 1 : 0;\n\treturn true;\n}", "CodeBleu_score": 45.231572764793384}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_addr;\n\tuint8_t ep_status;\n\tuint8_t ep_status_mask;\n\tuint8_t ep_status_shift;\n\n\t/* Check the request length */\n\tif (req->wLength!= 0) {\n\t\treturn false;\n\t}\n\n\t/* Get the endpoint address from the request */\n\tep_addr = req->wIndex & 0x7F;\n\n\t/* Get the endpoint status mask and shift */\n\tep_status_mask = (req->wIndex >> 7) & 0x01;\n\tep_status_shift = (req->wIndex >> 8) & 0x07;\n\n\t/* Get the endpoint status */\n\tep_status = udc_ep_status_get(ep_addr, ep_status_mask, ep_status_shift);\n\n\t/* Set the response payload */\n\tresp->wLength = 0;\n\tresp->wIndex = 0;\n\tresp->wValue = 0;\n\tresp->data[0] = ep_status;\n\n\t/* Return \"true\" to indicate a successful request */\n\treturn true;\n}", "CodeBleu_score": 42.95264638159545}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tuint8_t ret;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Get interface and alternate setting number\n\tiface_num = udc_setup_pkt->wIndex & 0xFF;\n\tsetting_num = udc_setup_pkt->wIndex >> 8;\n\n\t// Check if interface and alternate setting number are valid\n\tif ((iface_num >= udc_ptr_conf->desc->bNumInterfaces) ||\n\t\t\t(setting_num >=\n\t\t\tudc_ptr_conf->desc->bNumInterfaces)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward SETUP request to UDI handler\n\tret = udi_cdc_setup_handler();\n\n\t// Return result of UDI handler\n\treturn ret;\n}", "CodeBleu_score": 69.09281412231213}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tbool ret = false;\n\tuint8_t *ptr_setup_req;\n\n\t// Check if the device is in a configured state\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Get the interface and alternate setting number\n\tiface_num = (uint8_t) udc_setup_req.wIndex.byte.LSB;\n\tsetting_num = (uint8_t) udc_setup_req.wIndex.byte.MSB;\n\n\t// Update the interface descriptor to the default setting\n\tret = udc_update_iface_desc(iface_num, 0);\n\tif (false == ret) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tret = udc_update_iface_desc(iface_num, setting_num);\n\tif (false == ret) {\n\t\treturn false;\n\t}\n\n\t// Get the pointer to the setup request\n\tptr_setup_req = (uint8_t *) &udc_setup_req;\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\tret = udc_udi_req_iface(ptr_setup_req);\n\treturn ret;\n}", "CodeBleu_score": 58.517080951300585}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tbool result;\n\n\t// Check if the device is in a configured state\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is valid\n\tif (0 == udc_num_interface) {\n\t\treturn false;\n\t}\n\n\t// Get the interface number and alternate setting number\n\tiface_num = udc_get_iface_num();\n\tsetting_num = udc_get_iface_alt_num();\n\n\t// Update the interface descriptor to the default setting\n\tif (false == udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (false == udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\tresult = udc_udi_setup(udc_ptr_iface);\n\treturn result;\n}", "CodeBleu_score": 59.269729971666905}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t#if (UDI_MSC_LUN_NUMBER == 0)\n  // No LUN, return error.\n  return false;\n#else\n  // Reset the state machine.\n  udi_msc_state = UDI_MSC_STATE_INIT;\n\n  // Initialize the MSC interface.\n  if (!udi_msc_init()) {\n    // Initialization failed, return error.\n    return false;\n  }\n\n  // Load the medium on each LUN.\n  for (uint8_t i = 0; i < UDI_MSC_LUN_NUMBER; i++) {\n    // Load the medium.\n    if (!udi_msc_load_medium(i)) {\n      // Loading failed, return error.\n      return false;\n    }\n  }\n\n  // Wait for a CBW reception.\n  udi_msc_cbw_wait();\n\n  // Start the MSC process.\n  return true;\n#endif\n}", "CodeBleu_score": 43.60648197405105}, {"code": "bool udi_msc_enable(void){\n\t#if (UDI_MSC_LUN_NBR == 0)\n  return false;\n#else\n  uint8_t i;\n\n  // Initialize the MSC interface\n  udi_msc_state = UDI_MSC_STATE_INIT;\n\n  // Retrieve the number of LUNs\n  udi_msc_lun_nbr = UDI_MSC_LUN_NBR;\n\n  // Initialize the LUNs\n  for (i = 0; i < udi_msc_lun_nbr; i++) {\n    udi_msc_lun_state[i] = UDI_MSC_LUN_STATE_INIT;\n    udi_msc_lun_medium_loaded[i] = false;\n  }\n\n  // Unload the medium on each LUN\n  for (i = 0; i < udi_msc_lun_nbr; i++) {\n    udi_msc_lun_unloaded(i);\n  }\n\n  // Wait for the CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n#endif\n}", "CodeBleu_score": 49.62576377074424}, {"code": "bool udi_msc_enable(void){\n\t#if (UDI_MSC_ENABLE_LUN_COUNT!= 1)\n  // Check if the number of LUNs is correct\n  if (UDI_MSC_ENABLE_LUN_COUNT > UDI_MSC_LUN_COUNT) {\n    return false;\n  }\n#endif\n\n  // Check if the external enable function is available\n  if (udi_msc_enable_cb == NULL) {\n    return false;\n  }\n\n  // Check if the external enable function returns true\n  if (!udi_msc_enable_cb()) {\n    return false;\n  }\n\n  // Initialize the LUNs\n  for (uint8_t lun = 0; lun < UDI_MSC_LUN_COUNT; lun++) {\n    udi_msc_lun[lun].state = UDI_MSC_LUN_STATE_UNLOADED;\n    udi_msc_lun[lun].medium_type = UDI_MSC_MEDIUM_TYPE_UNKNOWN;\n    udi_msc_lun[lun].medium_size = 0;\n    udi_msc_lun[lun].medium_size_exp = 0;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t lun = 0; lun < UDI_MSC_LUN_COUNT; lun++) {\n    udi_msc_unload_medium(lun);\n  }\n\n  // Wait for a CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 50.68431515995913}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_USE_CBW_RESET\n  if (udi_msc_cbw_reset_pending) {\n    udi_msc_cbw_reset_pending = false;\n    // Restart CBW reception\n    udd_ep_start(UDI_MSC_EP_CBW);\n    return;\n  }\n#endif\n  if (status!= UDD_EP_STATUS_OK) {\n    // Transfer not successful\n    // Wait for a MSC setup reset to restart CBW reception\n    udi_msc_cbw_reset_pending = true;\n    return;\n  }\n  // Transfer successful\n  if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n    // IN transfer\n    // Update sense data\n    udi_msc_sense.bSenseKey = USB_SENSE_NO_SENSE;\n    udi_msc_sense.bAdditionalSenseCode = 0;\n    udi_msc_sense.bAdditionalSenseCodeQualifier = 0;\n    udi_msc_sense.bFieldReplaceableUnitCode = 0;\n    udi_msc_sense.bSenseKeySpecific = 0;\n    udi_msc_sense.bAsc = 0;\n    udi_msc_sense.bAscq = 0;\n    udi_msc_sense.bAdditionalSenseLength = 0;\n    udi_msc_sense.bValid = 1;\n    // Update CSW\n    udi_msc_csw.dCSWDataResidue -= nb_sent;\n    udi_msc_csw_process();\n  } else {\n    // OUT transfer\n    // Update CSW\n    udi_msc_csw.dCSWDataResidue += nb_sent;\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 57.19244599647351}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDI_MSC_USE_CBW_RESET == TRUE)\n  if (status == UDD_EP_TRANSFER_STALL) {\n    // STALL\n    // then wait for a MSC setup reset\n    if (udi_msc_cbw_reset_flag == TRUE) {\n      // CBW reset flag set\n      // then restart CBW reception\n      udi_msc_cbw_reset_flag = FALSE;\n      udi_msc_cbw_process();\n    }\n  }\n#endif\n  if (status == UDD_EP_TRANSFER_OK) {\n    // OK\n    // Update CSW\n    udi_msc_csw.dCSWDataResidue -= cpu_to_le32(nb_sent);\n    if (udi_msc_csw.dCSWDataResidue == 0) {\n      // Data residue NULL\n      // then send CSW\n      udi_msc_csw_send();\n    } else {\n      // Data residue not NULL\n      // then process CSW\n      udi_msc_csw_process();\n    }\n  }\n}", "CodeBleu_score": 50.370468254301024}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t", "CodeBleu_score": 15.883820043266303}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t//  uint8_t csw_tag;\n  //uint32_t csw_data_residue;\n  //uint8_t csw_status;\n  //uint8_t csw_direction;\n\n  // Get the CSW tag\n  //csw_tag = udi_msc_cbw.csw.csw_tag;\n\n  // Get the CSW data residue\n  //csw_data_residue = udi_msc_cbw.csw.csw_data_residue;\n\n  // Get the CSW status\n  //csw_status = udi_msc_cbw.csw.csw_status;\n\n  // Get the CSW direction\n  //csw_direction = udi_msc_cbw.csw.csw_direction;\n\n  // Check the CSW status\n  //if (csw_status == UDI_MSC_CSW_STATUS_PASS) {\n    // If the CSW status is PASS, then check the CSW direction\n    //if (csw_direction == UDI_MSC_CBW_DIRECTION_DATA_IN) {\n      // If the CSW direction is DATA IN, then stall the next request from the USB host on the IN endpoint\n      //udi_msc_ep_in_stall();\n    //} else {\n      // If the CSW direction is DATA OUT, then stall the next request from the USB host on the OUT endpoint\n      //udi_msc_ep_out_stall();\n    //}\n  //}\n\n  // Prepare the CSW\n  //udi_msc_csw.csw.csw_tag = csw_tag;\n  //udi_msc_csw.csw.csw_data_residue = UDI_MSC_CSW_DATA_RESIDUE_TO_LE(csw_data_residue);\n  //udi_msc_csw.csw.csw_status = csw_status;\n  //udi_msc_csw.csw.csw_direction = csw_direction;\n\n  // Send the CSW\n  //udi_msc_csw_send();\n}", "CodeBleu_score": 3.0094249779841054}, {"code": "static void udi_msc_csw_process(void){\n\t//  uint8_t * csw_ptr = (uint8_t *) &udi_msc_csw;\n  uint8_t csw_tag;\n  uint32_t csw_data_residue;\n  uint8_t csw_status;\n\n  csw_tag = udi_msc_csw.dTag;\n  csw_data_residue = udi_msc_csw.dDataResidue;\n  csw_status = udi_msc_csw.bStatus;\n\n  if (csw_data_residue!= 0) {\n    // Data residue is non-zero\n    if (udi_msc_cbw.dCBWDataTransferLength > csw_data_residue) {\n      // Data residue is greater than the CBW data transfer length\n      udi_msc_cbw.dCBWDataTransferLength = csw_data_residue;\n    }\n\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_FLAG_DIRECTION_IN) {\n      // IN transfer\n      // Stall the next request from the USB host on the IN endpoint\n      udd_ep_stall_in(UDI_MSC_EP_IN);\n    } else {\n      // OUT transfer\n      // Stall the next request from the USB host on the OUT endpoint\n      udd_ep_stall_out(UDI_MSC_EP_OUT);\n    }\n  }\n\n  // Prepare the CSW\n  udi_msc_csw.dTag = csw_tag;\n  udi_msc_csw.dDataResidue = csw_data_residue;\n  udi_msc_csw.bStatus = csw_status;\n\n  // Send the CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 52.35182195629279}, {"code": "static void udi_msc_csw_process(void){\n\t\t// If the CBW is not empty\n\tif (udi_msc_cbw.dCBWDataTransferLength!= 0) {\n\t\t// If the CBW is for IN data\n\t\tif (udi_msc_cbw.bmCBWFlags & 0x80) {\n\t\t\t// If the CBW is for IN data and the data residue is non-zero\n\t\t\tif (udi_msc_cbw.dCBWDataTransferLength!= 0) {\n\t\t\t\t// Stall the next request from the USB host on the appropriate endpoint\n\t\t\t\tudd_ep_stall(UDI_MSC_EP_OUT);\n\t\t\t}\n\t\t} else {\n\t\t\t// If the CBW is for OUT data and the data residue is non-zero\n\t\t\tif (udi_msc_cbw.dCBWDataTransferLength!= 0) {\n\t\t\t\t// Stall the next request from the USB host on the appropriate endpoint\n\t\t\t\tudd_ep_stall(UDI_MSC_EP_IN);\n\t\t\t}\n\t\t}\n\t}\n\t// Prepare the CSW by setting its tag and converting the data residue to little-endian format\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n\t// Send the CSW\n\tudi_msc_csw_send();\n}", "CodeBleu_score": 62.43907162694732}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\t// Check if the DTR signal is enabled.\n\tif (b_enable) {\n\t\t// Check if the DTR rate is 1200.\n\t\tif (g_cdc_dtr_rate[port] == 1200) {\n\t\t\t// Schedule a delayed system reset.\n\t\t\tinitiateReset(port);\n\t\t}\n\t} else {\n\t\t// Cancel any scheduled reset.\n\t\tcancelReset(port);\n\t}\n}", "CodeBleu_score": 26.108812096962552}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port < USB_CDC_MAX_PORTS) {\n\t\tif (b_enable) {\n\t\t\tif (usb_cdc_dtr_rate[port] == USB_CDC_DTR_RATE_1200) {\n\t\t\t\tif (usb_cdc_dtr_enabled[port] == false) {\n\t\t\t\t\tusb_cdc_dtr_enabled[port] = true;\n\t\t\t\t\tusb_cdc_dtr_rate[port] = USB_CDC_DTR_RATE_1200;\n\t\t\t\t\tusb_cdc_dtr_timer[port] = 0;\n\t\t\t\t\tif (usb_cdc_dtr_timer_enabled[port] == false) {\n\t\t\t\t\t\tusb_cdc_dtr_timer_enabled[port] = true;\n\t\t\t\t\t\tusb_cdc_dtr_timer[port] = 0;\n\t\t\t\t\t\tinitiateReset(RESET_DELAY);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (usb_cdc_dtr_enabled[port] == true) {\n\t\t\t\tusb_cdc_dtr_enabled[port] = false;\n\t\t\t\tusb_cdc_dtr_rate[port] = USB_CDC_DTR_RATE_1200;\n\t\t\t\tusb_cdc_dtr_timer[port] = 0;\n\t\t\t\tcancelReset();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.83130810112487}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port == 0) {\n\t\t// DTR is active low\n\t\tif (b_enable) {\n\t\t\tif (CDC_DTR_PORT_PIN_IN) {\n\t\t\t\t// DTR is already enabled\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// DTR is disabled\n\t\t\tCDC_DTR_PORT_PIN_OUT = 1;\n\t\t\t// Check if the DTR rate is 1200\n\t\t\tif (CDC_DTR_RATE == 1200) {\n\t\t\t\t// DTR rate is 1200\n\t\t\t\tif (!CDC_DTR_RESET_SCHEDULED) {\n\t\t\t\t\t// DTR rate is 1200 and DTR is disabled\n\t\t\t\t\tCDC_DTR_RESET_SCHEDULED = 1;\n\t\t\t\t\t// Schedule a delayed system reset\n\t\t\t\t\tinitiateReset();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// DTR is enabled\n\t\t\tif (!CDC_DTR_PORT_PIN_IN) {\n\t\t\t\t// DTR is already enabled\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// DTR is disabled\n\t\t\tCDC_DTR_PORT_PIN_OUT = 0;\n\t\t\t// Cancel any scheduled reset\n\t\t\tcancelReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 26.83309719558018}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t\tbool request_handled = false;\n\n\tif (usb_device_control_request.bmRequestType.Type == USB_REQUEST_TYPE_VENDOR) {\n\t\tif (usb_device_control_request.bRequest == 0x04) {\n\t\t\t// Microsoft Compatible ID Descriptor Request\n\t\t\tusb_device_control_request.wLength = sizeof(usb_device_ms_compatible_id_descriptor);\n\t\t\tusb_device_control_request.pBuffer = &usb_device_ms_compatible_id_descriptor;\n\t\t\trequest_handled = true;\n\t\t} else if (usb_device_control_request.bRequest == 0x05) {\n\t\t\t// Extended Properties Descriptor Request\n\t\t\tusb_device_control_request.wLength = sizeof(usb_device_extended_properties_descriptor);\n\t\t\tusb_device_control_request.pBuffer = &usb_device_extended_properties_descriptor;\n\t\t\trequest_handled = true;\n\t\t}\n\t}\n\n\treturn request_handled;\n}", "CodeBleu_score": 24.0442324402885}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\tuint8_t dummy = 0x00;\n\tuint16_t i;\n\tfor (i = 0; i < nbyte; i++) {\n\t\tspiSend(dummy);\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[nbyte] = spiRec();\n}", "CodeBleu_score": 52.99579711467104}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\tif (nbyte == 0)\n\t\treturn;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 46.057532209216944}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\tif (nbyte == 0) return;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 46.18325816156005}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler = NULL;\n\tuint32_t *p_vectorTable = (uint32_t *)0xE000ED04;\n\tuint32_t *p_handler = (uint32_t *)0xE000E100 + irq;\n\n\t// Disable interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Save the original handler\n\toldHandler = (pfnISR_Handler)(*p_handler);\n\n\t// Replace the handler with the new one\n\t*p_handler = (uint32_t)newHandler;\n\n\t// Re-enable interrupts\n\t__enable_irq();\n\n\treturn oldHandler;\n}", "CodeBleu_score": 45.737068517657676}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *pTable = (uint32_t *)SCB->VTOR;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Get the current handler for the specified IRQ\n\toldHandler = (pfnISR_Handler)pTable[irq];\n\n\t// Replace the current handler with the new handler\n\tpTable[irq] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\treturn oldHandler;\n}", "CodeBleu_score": 50.28572156271398}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tuint32_t *p_vectorTable = (uint32_t *)((uint32_t)__Vectors);\n\tpfnISR_Handler oldHandler = NULL;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Retrieve the current handler for the specified IRQ\n\toldHandler = (pfnISR_Handler)p_vectorTable[irq];\n\n\t// Replace the current handler with the new handler\n\tp_vectorTable[irq] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\treturn oldHandler;\n}", "CodeBleu_score": 49.24401922444366}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t\tint c;\n\tif (usb_serial_get_control(&serial_port, USB_SERIAL_CTRL_PENDING, &c, 1) < 0) {\n\t\treturn -1;\n\t}\n\treturn c;\n}", "CodeBleu_score": 21.24215291794481}, {"code": "int MarlinSerialUSB::peek(){\n\t\tif (usb_configured() && usb_serial_get_control()) {\n\t\treturn usb_serial_getchar();\n\t} else {\n\t\treturn -1;\n\t}\n}", "CodeBleu_score": 8.77035404295475}, {"code": "int MarlinSerialUSB::peek(){\n\t#ifdef USBCON\n  if (usb_configured() &&!emergency_parser_enabled()) {\n    if (usb_serial_available()) {\n      return usb_serial_getchar();\n    }\n  }\n#endif\n  return -1;\n}", "CodeBleu_score": 14.170492310547145}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t\tif (this->pending) {\n\t\treturn this->pending;\n\t}\n\tif (!this->enabled) {\n\t\treturn -1;\n\t}\n\tif (!this->available()) {\n\t\treturn -1;\n\t}\n\tchar c = this->serial->read();\n\tif (this->emergency) {\n\t\tthis->emergency->parse(c);\n\t}\n\treturn c;\n}", "CodeBleu_score": 26.94138187388635}, {"code": "int MarlinSerialUSB::read(){\n\t", "CodeBleu_score": 1.6377800256158708}, {"code": "int MarlinSerialUSB::read(){\n\t", "CodeBleu_score": 1.6377800256158708}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tif (serial_available) {\n\t\treturn serial_available;\n\t} else {\n\t\treturn SerialUSB.available();\n\t}\n}", "CodeBleu_score": 29.552612805784804}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (SerialUSB.available() > 0) return SerialUSB.available();\n\tif (SerialUSB.CDCisReady()) return 1;\n\treturn 0;\n}", "CodeBleu_score": 40.718447456441694}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_serial_available())\n\t\treturn usb_serial_available();\n\tif (usb_cdc_enabled())\n\t\treturn 0;\n\treturn -1;\n}", "CodeBleu_score": 33.70743712739374}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tifdef DEBUG_EEPROM\n  Serial.print(\"Reading from position \");\n  Serial.print(pos);\n  Serial.print(\" with size \");\n  Serial.println(size);\n#endif\n  uint8_t *ptr = value;\n  while (size--) {\n    if (pos >= EEPROMSize) {\n      return false;\n    }\n    *ptr = ee_Read(pos);\n    if (writing) {\n      if (pos < 1024) {\n        buffer[pos] = *ptr;\n      }\n      else {\n        uint32_t baddr;\n        uint32_t blen;\n\n        // Check that the value is not contained in the RAM buffer\n        uint16_t i = 0;\n        while (i <= (PageSize - 4)) { /* (PageSize - 4) because otherwise, there is not enough room for data and headers */\n\n          // Get the address of the block\n          baddr = buffer[i] | (buffer[i + 1] << 8);\n\n          // Get the length of the block\n          blen = buffer[i + 2];\n\n          // If we reach the end of the list, break loop\n          if (blen == 0xFF)\n            break;\n\n          // Check if data is contained in this block\n          if (pos >= baddr &&\n            pos < (baddr + blen)) {\n\n            // Yes, it is contained. Return it!\n            buffer[i + 3 + pos - baddr] = *ptr;\n            break;\n          }\n\n          // As blocks are always sorted, if the starting address of this block is higher\n          // than the address we are looking for, break loop now - We wont find the value\n          // associated to the address\n          if (baddr > pos)\n            break;\n\n          // Jump to the next block\n          i += 3 + blen;\n        }\n      }\n    }\n    crc16(crc, ptr, 1);\n    ptr++;\n    pos++;\n  }\n  return true;\n}", "CodeBleu_score": 42.61911168923939}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t#ifdef DEBUG_PERSISTENT_STORE\n  Serial.print(\"read_data: \");\n  Serial.print(pos);\n  Serial.print(\" - \");\n  Serial.print(size);\n  Serial.print(\" - \");\n  Serial.println(writing);\n#endif\n\n  // Read data from the storage\n  for (size_t i = 0; i < size; ++i) {\n    value[i] = ee_Read(pos);\n\n    // If we are writing, update the CRC\n    if (writing)\n      *crc = crc16_update(*crc, value[i]);\n\n    // Increment the position\n    ++pos;\n  }\n\n  // Return false if the process has not finished\n  return (size!= 0);\n}", "CodeBleu_score": 46.496876888223156}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tifdef DEBUG_PERSISTENT_STORE\n  Serial.println(\"read_data\");\n#endif\n  uint8_t b;\n  uint8_t *p;\n\n  // If no data is provided, return false\n  if (value == NULL) return false;\n\n  // If no CRC is provided, return false\n  if (crc == NULL) return false;\n\n  // If no size is provided, return false\n  if (size == 0) return false;\n\n  // If the position is out of bounds, return false\n  if (pos < 0 || pos >= EEPROMSize) return false;\n\n  // If the size is greater than the remaining space, return false\n  if (size > (EEPROMSize - pos)) return false;\n\n  // If the CRC is not 0, it means that the CRC is already computed and we have to update it\n  if (*crc!= 0) {\n    // If the CRC is not 0, it means that the CRC is already computed and we have to update it\n    *crc = 0;\n\n    // If the CRC is not 0, it means that the CRC is already computed and we have to update it\n    for (int i = 0; i < size; i++) {\n      b = ee_Read(pos + i);\n      crc16(crc, &b, 1);\n    }\n  }\n\n  // Read the data\n  p = value;\n  for (int i = 0; i < size; i++) {\n    b = ee_Read(pos + i);\n    *p = b;\n    p++;\n  }\n\n  // Update the position\n  pos += size;\n\n  // If we are writing data, update the CRC\n  if (writing) {\n    for (int i = 0; i < size; i++) {\n      b = ee_Read(pos + i);\n      crc16(crc, &b, 1);\n    }\n  }\n\n  // Return true\n  return true;\n}", "CodeBleu_score": 43.30131179068043}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t", "CodeBleu_score": 3.7373796348143205}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t", "CodeBleu_score": 3.7373796348143205}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t", "CodeBleu_score": 3.7373796348143205}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#ifndef DEACTIVATE_SERVOS_AFTER_MOVE\n  static_assert(sizeof(servoDelay) / sizeof(servoDelay[0]) == NUM_SERVOS, \"servoDelay array length mismatch\");\n#endif\n  if (channel >= 0) {\n    write(value);\n    safe_delay(servoDelay[channel]);\n    detach();\n  }\n}", "CodeBleu_score": 56.43265980284357}, {"code": "void Servo::move(const int value){\n\t#ifdef SERVO_DEBUG\n  Serial.print(\"Servo::move(\");\n  Serial.print(value);\n  Serial.print(\") - \");\n  Serial.print(pin);\n  Serial.print(\" - \");\n  Serial.print(channel);\n  Serial.print(\" - \");\n  Serial.println(delays.size());\n#endif\n  static_assert(SERVO_DELAY_ARRAY_LENGTH == SERVO_MAX_CHANNELS, \"Servo::move() - SERVO_DELAY_ARRAY_LENGTH is not equal to SERVO_MAX_CHANNELS\");\n  if (channel >= 0) {\n    write(value);\n    safe_delay(delays[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 50.46404058984747}, {"code": "void Servo::move(const int value){\n\t#if defined(DEACTIVATE_SERVOS_AFTER_MOVE)\n  if (channel >= 0) detach();\n#endif\n  if (channel >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_MS[channel]);\n  }\n}", "CodeBleu_score": 49.024857557815196}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tfor (int i = 0; i < 4; i++) {\n\t\tif (i2s_pins[i].active && i2s_pins[i].pwm_tick_count == 0) {\n\t\t\ti2s_pins[i].pin_state =!i2s_pins[i].pin_state;\n\t\t\ti2s_pins[i].pwm_tick_count = i2s_pins[i].pwm_tick_time;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (i2s_pins[i].active) {\n\t\t\ti2s_pins[i].pwm_tick_count--;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (i2s_pins[i].active) {\n\t\t\tif (i2s_pins[i].pin_state) {\n\t\t\t\t*i2s_dma_buffer = 0x0000;\n\t\t\t} else {\n\t\t\t\t*i2s_dma_buffer = 0xFFFF;\n\t\t\t}\n\t\t} else {\n\t\t\t*i2s_dma_buffer = 0xFFFF;\n\t\t}\n\t\ti2s_dma_buffer++;\n\t}\n}", "CodeBleu_score": 35.585653228969505}, {"code": "void i2s_push_sample(){\n\t\tfor (int i = 0; i < NUM_PINS; i++) {\n\t\tif (pins[i].pwm_ticks == 0) {\n\t\t\tpins[i].state =!pins[i].state;\n\t\t\tpins[i].pwm_ticks = pins[i].pwm_period;\n\t\t}\n\t\tpins[i].pwm_ticks--;\n\t}\n\n\tfor (int i = 0; i < NUM_PINS; i++) {\n\t\tif (pins[i].pwm_period!= 0) {\n\t\t\tif (pins[i].state) {\n\t\t\t\t*dma_buffer = 0xFFFF;\n\t\t\t} else {\n\t\t\t\t*dma_buffer = 0x0000;\n\t\t\t}\n\t\t} else {\n\t\t\t*dma_buffer = 0xFFFF;\n\t\t}\n\t\tdma_buffer++;\n\t}\n}", "CodeBleu_score": 29.92965786496702}, {"code": "void i2s_push_sample(){\n\t\tint i;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (pwm_tick_count[i] == 0) {\n\t\t\tif (pwm_state[i] == 0) {\n\t\t\t\tpwm_state[i] = 1;\n\t\t\t} else {\n\t\t\t\tpwm_state[i] = 0;\n\t\t\t}\n\t\t\tpwm_tick_count[i] = pwm_tick_count_max[i];\n\t\t}\n\t\tpwm_tick_count[i]--;\n\t}\n\t*i2s_dma_buffer = (pwm_state[0] << 3) | (pwm_state[1] << 2) | (pwm_state[2] << 1) | pwm_state[3];\n\ti2s_dma_buffer++;\n}", "CodeBleu_score": 28.002573351531346}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer_count = 0;\n\thal_timer_config_t *timer_config = get_timer_config(timer_num);\n\tif (timer_config!= NULL) {\n\t\ttimer_count = timer_config->current_count;\n\t}\n\treturn timer_count;\n}", "CodeBleu_score": 46.28335231295031}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn HAL_timer_get_count_ext(timer_num, 0);\n}", "CodeBleu_score": 14.428244683174105}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t count;\n\tswitch(timer_num) {\n\tcase 0:\n\t\tcount = TIM0->CNT;\n\t\tbreak;\n\tcase 1:\n\t\tcount = TIM1->CNT;\n\t\tbreak;\n\tcase 2:\n\t\tcount = TIM2->CNT;\n\t\tbreak;\n\tcase 3:\n\t\tcount = TIM3->CNT;\n\t\tbreak;\n\tcase 4:\n\t\tcount = TIM4->CNT;\n\t\tbreak;\n\tcase 5:\n\t\tcount = TIM5->CNT;\n\t\tbreak;\n\tcase 6:\n\t\tcount = TIM6->CNT;\n\t\tbreak;\n\tcase 7:\n\t\tcount = TIM7->CNT;\n\t\tbreak;\n\tcase 8:\n\t\tcount = TIM8->CNT;\n\t\tbreak;\n\tcase 9:\n\t\tcount = TIM9->CNT;\n\t\tbreak;\n\tcase 10:\n\t\tcount = TIM10->CNT;\n\t\tbreak;\n\tcase 11:\n\t\tcount = TIM11->CNT;\n\t\tbreak;\n\tcase 12:\n\t\tcount = TIM12->CNT;\n\t\tbreak;\n\tcase 13:\n\t\tcount = TIM13->CNT;\n\t\tbreak;\n\tcase 14:\n\t\tcount = TIM14->CNT;\n\t\tbreak;\n\tdefault:\n\t\tcount = 0;\n\t\tbreak;\n\t}\n\treturn count;\n}", "CodeBleu_score": 28.077194066422706}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint16_t crc_temp = 0;\n\tuint8_t *ptr = value;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t data = EEPROM.read(pos);\n\t\tif (writing) {\n\t\t\t*ptr = data;\n\t\t}\n\t\tcrc16(&crc_temp, &data, 1);\n\t\tpos++;\n\t}\n\tif (crc!= NULL) {\n\t\t*crc = crc_temp;\n\t}\n\treturn false;\n}", "CodeBleu_score": 52.63167165499885}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint8_t buffer[size];\n\tfor (int i = 0; i < size; i++) {\n\t\tbuffer[i] = EEPROM.read(pos);\n\t\tif (writing)\n\t\t\tvalue[i] = buffer[i];\n\t\tcrc16(crc, &buffer[i], 1);\n\t\tpos++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 59.39958546673449}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tbool status = true;\n\tfor (size_t i = 0; i < size; i++) {\n\t\tuint8_t data;\n\t\tstatus &= eeprom_read_byte(&data, pos);\n\t\tif (writing)\n\t\t\tvalue[i] = data;\n\t\tcrc16(crc, &data, 1);\n\t\tpos++;\n\t}\n\treturn status;\n}", "CodeBleu_score": 61.219162088599354}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (SDIO_Handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tuint32_t retry = SDIO_WRITE_RETRY_COUNT;\n\n\twhile (retry--) {\n\t\tif (SDIO_WriteBlock_Internal(block, src)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprintf(\"SDIO_WriteBlock: Failed to write block %u.\n\", block);\n\treturn false;\n}", "CodeBleu_score": 27.156506327067664}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tbool status = false;\n\tuint32_t retry = 0;\n\tuint32_t error = 0;\n\tuint32_t timeout = 0;\n\n\tif (handle == NULL || src == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: handle or src is null\n\");\n\t\treturn status;\n\t}\n\n\t// Try to write the block\n\tdo {\n\t\tstatus = SDIO_WriteBlock_internal(block, src);\n\t\tif (!status) {\n\t\t\t// If the write fails, increment the retry counter and print an error message\n\t\t\tretry++;\n\t\t\terror = SDIO_GetErrorCode();\n\t\t\tprintf(\"SDIO_WriteBlock: Write failed, error code = %d\n\", error);\n\t\t}\n\t} while (!status && retry < SDIO_MAX_RETRIES);\n\n\t// If all retries fail, print an error message and return \"false\"\n\tif (!status) {\n\t\tprintf(\"SDIO_WriteBlock: All retries failed\n\");\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 37.408390692367675}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (SDIO_Handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tuint32_t retries = 0;\n\twhile (retries < SDIO_MAX_RETRIES) {\n\t\tif (SDIO_WriteBlock_Retry(block, src)) {\n\t\t\treturn true;\n\t\t}\n\t\tretries++;\n\t}\n\n\tprintf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n\treturn false;\n}", "CodeBleu_score": 28.142889301594504}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\tHAL_timer_init(timer_num, frequency, STEPPER_TIMER_PRESCALE);\n\t\tHAL_timer_setCallback(timer_num, HAL_stepper_callback);\n\t\tHAL_timer_setPriority(timer_num, HAL_STEPPER_PRIORITY);\n\t} else if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\tHAL_timer_init(timer_num, frequency, TEMPERATURE_TIMER_PRESCALE);\n\t\tHAL_timer_setCallback(timer_num, HAL_temperature_callback);\n\t\tHAL_timer_setPriority(timer_num, HAL_TEMPERATURE_PRIORITY);\n\t} else {\n\t\tassert_param(false);\n\t}\n}", "CodeBleu_score": 46.8087226077957}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\t// Check if the timer channel is valid\n\tif (timer_num >= TIMER_CHANNEL_COUNT) {\n\t\tassert_param(false);\n\t\treturn;\n\t}\n\n\t// Check if the timer channel corresponds to the temperature timer\n\tif (timer_num == TIMER_CHANNEL_TEMP) {\n\t\t// Start the timer with the given frequency and temperature timer prescale\n\t\tHAL_TIM_Base_Start_IT(&htim_temp, frequency, TEMP_PRESCALER);\n\n\t\t// Set the callback priority for temperature\n\t\tHAL_NVIC_SetPriority(TIM2_IRQn, TEMP_PRIORITY, 0);\n\t\tHAL_NVIC_EnableIRQ(TIM2_IRQn);\n\t}\n\n\t// Check if the timer channel corresponds to the step timer\n\telse if (timer_num == TIMER_CHANNEL_STEP) {\n\t\t// Start the timer with the given frequency and stepper timer prescale\n\t\tHAL_TIM_Base_Start_IT(&htim_step, frequency, STEP_PRESCALER);\n\n\t\t// Set the callback priority for stepper\n\t\tHAL_NVIC_SetPriority(TIM3_IRQn, STEP_PRIORITY, 0);\n\t\tHAL_NVIC_EnableIRQ(TIM3_IRQn);\n\t}\n\n\t// Invalid timer channel\n\telse {\n\t\tassert_param(false);\n\t}\n}", "CodeBleu_score": 39.98867906434834}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TIMER_CHANNEL_TEMP) {\n\t\tHAL_timer_start_temp(frequency);\n\t} else if (timer_num == TIMER_CHANNEL_STEP) {\n\t\tHAL_timer_start_step(frequency);\n\t} else {\n\t\tassert_param(0);\n\t}\n}", "CodeBleu_score": 25.312581999956528}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tif (file.open(EEPROM_FILE_NAME, O_RDWR | O_CREAT | O_TRUNC)) {\n\t\tfile.seek(0, SeekSet);\n\t\tfile.read(buffer, EEPROM_SIZE);\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 9.325850408441886}, {"code": "bool PersistentStore::access_start(){\n\t\tif (!file.open(EEPROM_FILE_NAME, O_RDWR | O_CREAT | O_TRUNC)) {\n\t\treturn false;\n\t}\n\tif (file.seek(0, SeekSet)!= 0) {\n\t\treturn false;\n\t}\n\tif (file.read(buffer, EEPROM_SIZE)!= EEPROM_SIZE) {\n\t\treturn false;\n\t}\n\tfile.close();\n\treturn true;\n}", "CodeBleu_score": 13.877227467442504}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open the file\n\tfile = SD.open(filename, FILE_READ);\n\n\t// Check if the file exists\n\tif (!file) {\n\t\t// The file does not exist\n\t\treturn false;\n\t}\n\n\t// Check the file size\n\tif (file.size()!= EEPROM_SIZE) {\n\t\t// The file is not of the expected size\n\t\t// Fill the remainder of the buffer with a default erase value\n\t\tfor (int i = file.size(); i < EEPROM_SIZE; i++) {\n\t\t\tbuffer[i] = ERASE_VALUE;\n\t\t}\n\t} else {\n\t\t// The file is of the expected size\n\t\t// Read the file's contents into the buffer\n\t\tfor (int i = 0; i < EEPROM_SIZE; i++) {\n\t\t\tbuffer[i] = file.read();\n\t\t}\n\t}\n\n\t// Close the file\n\tfile.close();\n\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 24.426864729686777}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t data = 0;\n\tuint8_t i = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_SPI_STM32_MOSI_HIGH;\n\t\t} else {\n\t\t\tHAL_SPI_STM32_MOSI_LOW;\n\t\t}\n\t\tHAL_SPI_STM32_CLK_HIGH;\n\t\tdata = (data << 1) | HAL_SPI_STM32_MISO;\n\t\tHAL_SPI_STM32_CLK_LOW;\n\t\tb = b << 1;\n\t}\n\tHAL_Delay(1);\n\treturn data;\n}", "CodeBleu_score": 29.87041678365455}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t data = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_STM32_SetPin(SPI_STM32_CLK_GPIO_Port, SPI_STM32_CLK_Pin);\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_STM32_SetPin(SPI_STM32_MOSI_GPIO_Port, SPI_STM32_MOSI_Pin);\n\t\t} else {\n\t\t\tHAL_GPIO_STM32_ResetPin(SPI_STM32_MOSI_GPIO_Port, SPI_STM32_MOSI_Pin);\n\t\t}\n\t\tHAL_GPIO_STM32_ResetPin(SPI_STM32_CLK_GPIO_Port, SPI_STM32_CLK_Pin);\n\t\tdata = (data << 1) | HAL_GPIO_STM32_ReadPin(SPI_STM32_MISO_GPIO_Port, SPI_STM32_MISO_Pin);\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(1);\n\treturn data;\n}", "CodeBleu_score": 38.55606137799604}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t data = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_SPI_STM32_Set_MOSI_High();\n\t\t} else {\n\t\t\tHAL_SPI_STM32_Set_MOSI_Low();\n\t\t}\n\n\t\tHAL_SPI_STM32_Set_CLK_High();\n\n\t\tb <<= 1;\n\n\t\tif (HAL_SPI_STM32_Get_MISO_Pin_State()) {\n\t\t\tdata |= 0x01;\n\t\t}\n\n\t\tHAL_SPI_STM32_Set_CLK_Low();\n\t}\n\n\tHAL_SPI_STM32_Delay_Microseconds(1);\n\n\treturn data;\n}", "CodeBleu_score": 32.991471260099104}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\t/* Enable the AHB peripheral clock */\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\t/* Disable the AHB peripheral clock */\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 42.579826607808776}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t#ifdef ENABLE_EMERGENCY_PARSER\n  if (obj->emergency_parser) {\n    obj->emergency_parser->rx_complete_irq(obj->rx_buffer[obj->rx_head]);\n  }\n#endif\n  if (obj->rx_head == obj->rx_tail) {\n    // buffer is full\n    return;\n  }\n  obj->rx_buffer[obj->rx_head] = obj->serial_read();\n  obj->rx_head = (obj->rx_head + 1) % SERIAL_BUFFER_SIZE;\n}", "CodeBleu_score": 34.935981731952715}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tif (obj->rx_buffer_head == obj->rx_buffer_tail) {\n\t\t// Buffer is empty, start receiving\n\t\tobj->rx_buffer_head = 0;\n\t\tobj->rx_buffer_tail = 0;\n\t\tobj->rx_buffer_count = 0;\n\t\tobj->rx_buffer_overflow = false;\n\t\tobj->rx_buffer_overflow_count = 0;\n\t\tobj->rx_buffer_overflow_total = 0;\n\t}\n\tif (obj->rx_buffer_count < SERIAL_RX_BUFFER_SIZE) {\n\t\t// Read byte and update buffer\n\t\tobj->rx_buffer[obj->rx_buffer_head] = obj->serial.read();\n\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t\tobj->rx_buffer_count++;\n\t} else {\n\t\t// Buffer full, update overflow counter\n\t\tobj->rx_buffer_overflow = true;\n\t\tobj->rx_buffer_overflow_count++;\n\t\tobj->rx_buffer_overflow_total++;\n\t}\n\t// Update emergency parser\n\tif (obj->emergency_parser_enabled) {\n\t\tobj->emergency_parser.update(obj->rx_buffer[obj->rx_buffer_head]);\n\t}\n}", "CodeBleu_score": 32.02214414508582}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t", "CodeBleu_score": 2.355873403718772}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t", "CodeBleu_score": 2.7080419141460643}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (!HAL_timer_is_initialized(MF_TIMER_STEP) &&!HAL_timer_has_interrupt(MF_TIMER_STEP)) {\n\t\t\tHAL_timer_init(MF_TIMER_STEP, HAL_TIMER_MODE_CONTINUOUS, HAL_TIMER_PRESCALER_1024);\n\t\t\tHAL_timer_attach_interrupt(MF_TIMER_STEP, Step_Handler);\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (!HAL_timer_is_initialized(MF_TIMER_TEMP) &&!HAL_timer_has_interrupt(MF_TIMER_TEMP)) {\n\t\t\tHAL_timer_init(MF_TIMER_TEMP, HAL_TIMER_MODE_CONTINUOUS, HAL_TIMER_PRESCALER_1024);\n\t\t\tHAL_timer_attach_interrupt(MF_TIMER_TEMP, Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.38064771982033}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (!timer_step_initialized) {\n\t\t\treturn;\n\t\t}\n\t\tif (timer_step_interrupt_attached) {\n\t\t\treturn;\n\t\t}\n\t\ttimer_step_interrupt_attached = true;\n\t\tHAL_NVIC_EnableIRQ(MF_TIMER_STEP_IRQn);\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (!timer_temp_initialized) {\n\t\t\treturn;\n\t\t}\n\t\tif (timer_temp_interrupt_attached) {\n\t\t\treturn;\n\t\t}\n\t\ttimer_temp_interrupt_attached = true;\n\t\tHAL_NVIC_EnableIRQ(MF_TIMER_TEMP_IRQn);\n\t}\n}", "CodeBleu_score": 29.00824298476342}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\thash, pow := HashStrRev(sep)\n\tvar i, j, n int\n\tfor i = len(s) - len(sep); i >= 0; i-- {\n\t\tif hash == HashStrRev(s[i:i+len(sep)]) {\n\t\t\tfor j = 0; j < len(sep); j++ {\n\t\t\t\tif s[i+j]!= sep[j] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif j == len(sep) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\tif i > 0 {\n\t\t\thash = (hash - uint32(s[i-1])*pow)*PrimeRK + uint32(s[i+len(sep)-1])\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 40.16353196876579}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tif len(s) == 0 {\n\t\treturn -1\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\tvar (\n\t\thashSep, hashS, powSep, powS uint32\n\t\ti, j, k, l, m, n int\n\t)\n\thashSep, powSep = HashStrRev(sep)\n\thashS, powS = HashStr(s)\n\ti, j, k = 0, len(sep), len(s)\n\tfor i < j {\n\t\tif hashS == hashSep && s[i:i+k] == sep {\n\t\t\treturn i\n\t\t}\n\t\tif i < k-1 {\n\t\t\thashS = (hashS - powS*uint32(s[i]))*PrimeRK + uint32(s[i+k])\n\t\t\ti++\n\t\t} else {\n\t\t\ti += k - j + 1\n\t\t\tj, k = k, len(s) - i\n\t\t\thashS, powS = HashStr(s[i:i+k]), powS*PrimeRK\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 37.785248089504606}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\thash, pow := HashStrRev(sep)\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif i+len(sep) > len(s) {\n\t\t\treturn -1\n\t\t}\n\t\tif hash == HashStrRev(s[i:i+len(sep)]) {\n\t\t\tif string(sep) == string(s[i:i+len(sep)]) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\thash -= uint32(s[i]) * pow\n\t\tif i+len(sep) < len(s) {\n\t\t\thash = hash*PrimeRK + uint32(s[i+len(sep)])\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 43.22045993574558}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.mutex.Lock()\n\tdefer usbcdc.mutex.Unlock()\n\n\tusbcdc.waitTxc = false\n\tif usbcdc.txc!= nil && usbcdc.txc.Len() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t}\n}", "CodeBleu_score": 29.9174453472843}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.Lock()\n\tdefer usbcdc.Unlock()\n\n\tif usbcdc.waitTxc {\n\t\tusbcdc.waitTxc = false\n\t\tusbcdc.usb.InterruptDisable()\n\t\tif usbcdc.usb.TxReady() {\n\t\t\tusbcdc.usb.SendUSBInPacket(usbcdc.txBuf, usbcdc.txLen)\n\t\t}\n\t\tusbcdc.usb.InterruptEnable()\n\t}\n}", "CodeBleu_score": 32.193521387628834}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tinterrupt.Disable()\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txc {\n\t\t// Send data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t\t// If there is no data in the transmit buffer, set \"waitTxc\" to false\n\t\tif!usbcdc.txc {\n\t\t\tusbcdc.waitTxc = false\n\t\t}\n\t}\n\t// Restore the interrupt mask\n\tinterrupt.Enable()\n}", "CodeBleu_score": 40.64859759051024}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t", "CodeBleu_score": 3.732474039106109}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear the interrupt flag\n\ti2c.i2c.CR1.Set(i2c.i2c.CR1.I2C_CR1_STOP.Mask())\n\t// Put a start condition on the SDA line\n\ti2c.i2c.CR1.Set(i2c.i2c.CR1.I2C_CR1_START.Mask())\n\t// Enable the I2C module\n\ti2c.i2c.CR1.Set(i2c.i2c.CR1.I2C_CR1_PE.Mask())\n\t// Wait for the start condition to be transmitted\n\tfor!i2c.i2c.SR1.Has(i2c.i2c.SR1.SB.Mask()) {\n\t}\n\t// Write the 7-bit shifted peripheral address to the bus\n\ti2c.i2c.DR.Set(address << 1)\n\t// Set the read flag if needed\n\tif write {\n\t\ti2c.i2c.DR.Set(i2c.i2c.DR.DR_LSB.Mask())\n\t}\n}", "CodeBleu_score": 27.767022090940536}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.ClearIntFlag()\n\ti2c.control.SetStart()\n\ti2c.control.Enable()\n\n\tfor i2c.control.Busy() {\n\t}\n\n\ti2c.data.Write(address<<1 | uint8(write))\n}", "CodeBleu_score": 27.34032696803663}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tif err := f.flash.EraseBlocks(uint32(start), uint32(len)); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 16.1362173529071}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// calculate the start address of the block to be erased\n\taddress := f.BlockSize * start\n\n\t// set the flash to erase mode\n\tf.flash.SetMode(f.flash.ModeErase)\n\n\t// erase the specified number of blocks\n\tfor i := int64(0); i < len; i++ {\n\t\t// wait until the flash is no longer busy\n\t\tf.flash.WaitForReady()\n\n\t\t// erase the next block\n\t\tf.flash.EraseBlock(address)\n\n\t\t// increment the address by the block size\n\t\taddress += f.BlockSize\n\t}\n\n\t// set the flash back to read mode\n\tf.flash.SetMode(f.flash.ModeRead)\n\n\treturn nil\n}", "CodeBleu_score": 30.929799970974337}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// calculate the start address\n\tstartAddr := f.blockSize * start\n\n\t// calculate the end address\n\tendAddr := f.blockSize * (start + len)\n\n\t// configure flash for erasing\n\tf.flash.Erase(startAddr, endAddr)\n\n\t// wait for flash to be no longer busy\n\tfor f.flash.IsBusy() {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t}\n\n\t// set flash back to read mode\n\tf.flash.SetReadMode()\n\n\treturn nil\n}", "CodeBleu_score": 22.515471112462247}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off >= f.Size() {\n\t\treturn 0, errors.New(\"offset is out of bounds\")\n\t}\n\n\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"offset plus length is out of bounds\")\n\t}\n\n\t// pad the data to fit the block size\n\tpad := f.BlockSize() - (len(p) % f.BlockSize())\n\tif pad > 0 {\n\t\tp = append(p, make([]byte, pad)...)\n\t}\n\n\t// enable write mode\n\tf.Flash.EnableWrite()\n\n\t// write the data in blocks\n\tfor i := 0; i < len(p); i += f.BlockSize() {\n\t\tif err = f.Flash.Write(off+int64(i), p[i:i+f.BlockSize()]); err!= nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// wait for the write operation to complete\n\tif err = f.Flash.WaitForWriteCompletion(); err!= nil {\n\t\treturn\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 34.064443679463466}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off >= int64(f.Size()) {\n\t\treturn 0, fmt.Errorf(\"offset out of bounds\")\n\t}\n\n\t// Calculate the start address for writing.\n\tstartAddr := uint32(off)\n\t// Pad the byte slice to fit the write block size.\n\tpaddedSlice := make([]byte, f.BlockSize())\n\tcopy(paddedSlice, p)\n\t// Enable write mode on the flash memory controller.\n\tf.flash.EnableWrite()\n\t// Write the data in blocks.\n\tfor i := 0; i < len(paddedSlice); i += f.BlockSize() {\n\t\t// Calculate the number of bytes to write.\n\t\tnumBytes := f.BlockSize()\n\t\tif i+numBytes > len(paddedSlice) {\n\t\t\tnumBytes = len(paddedSlice) - i\n\t\t}\n\t\t// Write the data to the flash memory.\n\t\terr := f.flash.Write(startAddr+uint32(i), paddedSlice[i:i+numBytes])\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\t// Wait for the flash memory to be ready.\n\t\terr = f.flash.WaitForReady()\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Disable write mode on the flash memory controller.\n\tf.flash.DisableWrite()\n\t// Return the number of bytes written.\n\treturn len(p), nil\n}", "CodeBleu_score": 34.79238438633344}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, errors.New(\"offset must be positive\")\n\t}\n\n\tif off > f.size {\n\t\treturn 0, errors.New(\"offset exceeds the flash memory size\")\n\t}\n\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tstartAddr := off\n\tpadSize := f.writeBlockSize - (off % f.writeBlockSize)\n\tif padSize == f.writeBlockSize {\n\t\tpadSize = 0\n\t}\n\tp = append(make([]byte, padSize), p...)\n\n\tf.flash.EnableWrite()\n\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\tn := f.writeBlockSize\n\t\tif n > len(p)-i {\n\t\t\tn = len(p) - i\n\t\t}\n\t\tf.flash.Write(startAddr+int64(i), p[i:i+n])\n\t\tf.flash.WaitForWriteReady()\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 30.572989568851305}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tvar err error\n\tvar dirFd uintptr\n\n\t// Duplicate the provided file descriptor\n\tdirFd, err = syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory using \"syscall.Fdopendir\"\n\tfor {\n\t\tdirFd, err = syscall.Fdopendir(int(dirFd))\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// If the error is \"syscall.EINTR\", continue to attempt to open the directory\n\t\tif err == syscall.EINTR {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Close the duplicated file descriptor and return the error\n\t\tsyscall.Close(int(dirFd))\n\t\treturn 0, \"\", err\n\t}\n\n\treturn dirFd, \"\", nil\n}", "CodeBleu_score": 48.777222988144196}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicates the provided file descriptor\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Opens the directory using \"syscall.Fdopendir\"\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err!= nil {\n\t\t// Closes the duplicated file descriptor\n\t\t_ = syscall.Close(dupFd)\n\t\treturn 0, \"\", err\n\t}\n\n\t// Closes the duplicated file descriptor\n\t_ = syscall.Close(dupFd)\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 51.38794905537918}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdirFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tvar dir *syscall.Dir\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dirFd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err == syscall.EINTR {\n\t\t\tcontinue\n\t\t}\n\t\tsyscall.Close(dirFd)\n\t\treturn 0, \"\", err\n\t}\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 57.77555850474133}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tif (response == sketchSize_t::RESPONSE_FREE) {\n\t\treturn ESP.getFreeSketchSpace();\n\t} else {\n\t\treturn ESP.getSketchSize();\n\t}\n}", "CodeBleu_score": 15.577094299276546}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_app_desc_t app;\n\tesp_err_t err;\n\tuint32_t size = 0;\n\tif (response == sketchSize_t::free) {\n\t\terr = esp_app_get_running_partition_description(&app);\n\t\tif (err!= ESP_OK) {\n\t\t\treturn 0;\n\t\t}\n\t\tsize = app.size;\n\t} else {\n\t\terr = esp_app_get_binary_description(&app);\n\t\tif (err!= ESP_OK) {\n\t\t\treturn 0;\n\t\t}\n\t\tsize = app.size;\n\t}\n\treturn size;\n}", "CodeBleu_score": 43.068439179771474}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tuint32_t sketchSize = 0;\n\tif (response == SKETCH_SIZE_RESPONSE_FREE) {\n\t\tESP_ERROR_CHECK(esp_partition_info(esp_ota_get_running_partition(), &running_partition));\n\t\tsketchSize = running_partition.size - running_partition.app_offset;\n\t} else {\n\t\tESP_ERROR_CHECK(esp_partition_info(esp_ota_get_running_partition(), &running_partition));\n\t\tsketchSize = running_partition.size;\n\t}\n\treturn sketchSize;\n}", "CodeBleu_score": 32.68523925232563}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tmsc_disk_sectors = msc_update_get_required_disk_sectors();\n\tif (msc_disk_sectors == 0) {\n\t\tlog_e(\"Failed to calculate disk sectors\");\n\t\treturn false;\n\t}\n\tmsc_disk_size = msc_disk_sectors * DISK_SECTOR_SIZE;\n\tmsc_disk = calloc(msc_disk_size, 1);\n\tif (!msc_disk) {\n\t\tlog_e(\"Failed to allocate memory for disk\");\n\t\treturn false;\n\t}\n\tmsc_disk_sectors = msc_update_setup_boot_sector(msc_disk, msc_disk_sectors, volume_label, serial_number);\n\tif (msc_disk_sectors == 0) {\n\t\tlog_e(\"Failed to set up boot sector\");\n\t\treturn false;\n\t}\n\tmsc_disk_sectors = msc_update_setup_fat(msc_disk, msc_disk_sectors, msc_is_fat16);\n\tif (msc_disk_sectors == 0) {\n\t\tlog_e(\"Failed to set up FAT\");\n\t\treturn false;\n\t}\n\tif (msc_run_partition) {\n\t\tmsc_disk_sectors = msc_update_setup_firmware_file(msc_disk, msc_disk_sectors, msc_run_partition);\n\t\tif (msc_disk_sectors == 0) {\n\t\t\tlog_e(\"Failed to set up firmware file\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (msc_ota_partition) {\n\t\tmsc_disk_sectors = msc_update_setup_ota_file(msc_disk, msc_disk_sectors, msc_ota_partition);\n\t\tif (msc_disk_sectors == 0) {\n\t\t\tlog_e(\"Failed to set up OTA file\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 40.1344521788375}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tif (offset % partition->size_page) {\n\t\tESP_LOGE(TAG, \"Offset is not aligned with flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size % partition->size_page) {\n\t\tESP_LOGE(TAG, \"Size is not aligned with flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size == 0) {\n\t\tESP_LOGE(TAG, \"Size is 0\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (offset + size > partition->size) {\n\t\tESP_LOGE(TAG, \"Offset + size exceeds partition size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\terr = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Erase failed\");\n\t\treturn err;\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Write failed\");\n\t\treturn err;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 50.7954479335939}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tesp_partition_erase_range(partition, offset, partition->size - offset);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Partition erase failed\");\n\t\treturn err;\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Partition write failed\");\n\t\treturn err;\n\t}\n\treturn err;\n}", "CodeBleu_score": 55.62442949412927}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tif (offset % partition->size!= 0) {\n\t\tESP_LOGE(TAG, \"Offset is not aligned with the flash sector size\");\n\t\terr = ESP_ERR_INVALID_ARG;\n\t} else {\n\t\terr = esp_partition_erase_range(partition, offset, partition->size);\n\t\tif (err == ESP_OK) {\n\t\t\terr = esp_partition_write(partition, offset, data, size);\n\t\t}\n\t}\n\treturn err;\n}", "CodeBleu_score": 55.158933736127416}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = strlen(in);\n\tsize_t i = 0;\n\tfor (; i < len && i < maxlen; i++) {\n\t\tuint8_t hi = hex_char_to_byte(in[i * 2]);\n\t\tuint8_t lo = hex_char_to_byte(in[i * 2 + 1]);\n\t\tif (hi < 16 && lo < 16) {\n\t\t\tout[i] = (hi << 4) | lo;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}", "CodeBleu_score": 37.32071620390969}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = strlen(in);\n\tsize_t i = 0;\n\tsize_t j = 0;\n\twhile (i < len && j < maxlen) {\n\t\tif (in[i] =='' || in[i] == '\\t' || in[i] == '\n' || in[i] == '\\r') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\tout[j] = (in[i] - '0') << 4;\n\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\tout[j] = (in[i] - 'a' + 10) << 4;\n\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\tout[j] = (in[i] - 'A' + 10) << 4;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tif (in[i] >= '0' && in[i] <= '9') {\n\t\t\tout[j] |= in[i] - '0';\n\t\t} else if (in[i] >= 'a' && in[i] <= 'f') {\n\t\t\tout[j] |= in[i] - 'a' + 10;\n\t\t} else if (in[i] >= 'A' && in[i] <= 'F') {\n\t\t\tout[j] |= in[i] - 'A' + 10;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\treturn j;\n}", "CodeBleu_score": 29.0770135409821}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = strlen(in);\n\tsize_t i = 0;\n\tsize_t j = 0;\n\tsize_t k = 0;\n\n\twhile (i < len) {\n\t\tunsigned char c = hex_char_to_byte(in[i]);\n\t\tif (c < 0x10) {\n\t\t\tout[j] = (out[j] << 4) | c;\n\t\t\tj++;\n\t\t\ti++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t\tk++;\n\t}\n\treturn j;\n}", "CodeBleu_score": 37.261906960042126}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (m_txRingBuffer == NULL || m_txRingBufferSize == 0) {\n\t\treturn 0;\n\t}\n\n\tif (m_txRingBufferLock == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (m_txRingBufferLock->try_lock_for(m_timeout) == false) {\n\t\treturn 0;\n\t}\n\n\tint freeSize = m_txRingBufferSize - m_txRingBuffer->size();\n\n\tm_txRingBufferLock->unlock();\n\n\treturn freeSize;\n}", "CodeBleu_score": 50.069415454081835}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (m_tx_ring_buffer == nullptr || m_tx_ring_buffer_lock == nullptr) {\n\t\treturn 0;\n\t}\n\n\tif (m_tx_ring_buffer_lock->take(m_tx_ring_buffer_lock_timeout)!= 0) {\n\t\treturn 0;\n\t}\n\n\tint free_size = m_tx_ring_buffer->availableForWrite();\n\n\tm_tx_ring_buffer_lock->give();\n\n\treturn free_size;\n}", "CodeBleu_score": 51.034835891714835}, {"code": "int HWCDC::availableForWrite(void){\n\t\tint ret = 0;\n\tif (m_transmitRingBuffer!= NULL && m_transmitRingBufferLock!= NULL) {\n\t\tif (m_transmitRingBufferLock->take(0, 0) == true) {\n\t\t\tret = m_transmitRingBuffer->availableForWrite();\n\t\t\tm_transmitRingBufferLock->give();\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 40.83285779294423}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\tif (function == NULL) {\n\t\treturn;\n\t}\n\n\tif (_onReceiveCB!= NULL) {\n\t\treturn;\n\t}\n\n\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\n\tif (_rxTimeout == 0) {\n\t\t_rxTimeout = 1000;\n\t}\n\n\tif (_eventTask == NULL) {\n\t\t_createEventTask();\n\t}\n\n\t_rxBuffer.setFullThreshold(_rxBuffer.availableForWrite() / 2);\n}", "CodeBleu_score": 46.31545893043276}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#ifdef ARDUINO_SERIAL_MUTEX_DEBUG\n  log_d(\" -- onReceive(%p, %d)\", function, onlyOnTimeout);\n#endif\n  // Lock the serial mutex\n  if (xSemaphoreTake(_mutex, portMAX_DELAY) == pdTRUE) {\n    // Assign the callback function to \"_onReceiveCB\"\n    _onReceiveCB = function;\n    // Configure the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n    if (onlyOnTimeout) {\n      // Set the FIFO full threshold to 0 to indicate that the receive timeout behavior is \"onlyOnTimeout\"\n      _fifoFullThreshold = 0;\n      // Create an event task if it does not already exist\n      _createEventTask();\n    } else {\n      // Set the FIFO full threshold to 1 to indicate that the receive timeout behavior is \"onReceive\"\n      _fifoFullThreshold = 1;\n    }\n    // Unlock the serial mutex\n    xSemaphoreGive(_mutex);\n  }\n}", "CodeBleu_score": 40.64124330952397}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t// Locking the serial mutex\n\txSemaphoreTake(serialMutex, portMAX_DELAY);\n\n\t// Setting the callback function\n\t_onReceiveCB = function;\n\n\t// Configuring the receive timeout behavior\n\t_onlyOnTimeout = onlyOnTimeout;\n\t_rxTimeout = 0;\n\n\t// Setting the FIFO full threshold\n\t_fifoFullThreshold = 0;\n\n\t// Creating the event task if it does not already exist\n\tif (_eventTask == NULL) {\n\t\t_createEventTask();\n\t}\n\n\t// Unlocking the serial mutex\n\txSemaphoreGive(serialMutex);\n}", "CodeBleu_score": 32.273559238881845}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\tint c;\n\twhile (index < length) {\n\t\tc = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index] = c;\n\t\tindex++;\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 57.90752785734783}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\tint c;\n\n\tif (length < 1) {\n\t\treturn 0;\n\t}\n\n\twhile (index < length) {\n\t\tc = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index] = c;\n\t\tindex++;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 67.45950543124681}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tsize_t index = 0;\n\tint c;\n\n\twhile (index < length) {\n\t\tc = timedRead();\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t}\n\t\telse if (c == '\n') {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[index++] = c;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 49.73844689004111}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t#ifdef DEBUG\n  log_v(\"tone: pin %d, freq %d, duration %d\", pin, frequency, duration);\n#endif\n\n  if (!tone_init()) {\n    log_e(\"Tone not initialized\");\n    return;\n  }\n\n  if (pin >= TONE_PINS_COUNT) {\n    log_e(\"Invalid pin\");\n    return;\n  }\n\n  if (_tone_pin[pin]!= TONE_PIN_UNUSED) {\n    log_e(\"Pin already in use\");\n    return;\n  }\n\n  _tone_pin[pin] = pin;\n  _tone_freq[pin] = frequency;\n  _tone_duration[pin] = duration;\n  _tone_queue_item[pin].pin = pin;\n  _tone_queue_item[pin].freq = frequency;\n  _tone_queue_item[pin].duration = duration;\n  xQueueSend(_tone_queue, &_tone_queue_item[pin], 0);\n}", "CodeBleu_score": 45.506118908434836}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t#ifdef DEBUG\n  log_v(\"tone(%d, %d, %lu)\", pin, frequency, duration);\n#endif\n  if (tone_init() == 0) {\n    log_e(\"tone_init() failed\");\n    return;\n  }\n\n  if (pin >= TONE_PINS_COUNT) {\n    log_e(\"Invalid pin %d\", pin);\n    return;\n  }\n\n  if (_tone_pins[pin] == 0) {\n    _tone_pins[pin] = 1;\n    _tone_pin = pin;\n    _tone_freq = frequency;\n    _tone_duration = duration;\n    tone_msg_t msg = {\n     .pin = pin,\n     .freq = frequency,\n     .duration = duration,\n    };\n    xQueueSend(_tone_queue, &msg, 0);\n  } else {\n    log_e(\"Tone already running on pin %d\", pin);\n  }\n}", "CodeBleu_score": 59.32744968038666}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (!tone_init()) return;\n  if (pin == 0) return;\n  if (pin > 15) return;\n  if (frequency == 0) return;\n  if (duration == 0) return;\n\n  log_v(\"tone(%d, %d, %d)\", pin, frequency, duration);\n\n  if (gpio_is_valid(pin)) {\n    log_v(\"gpio_is_valid(%d)\", pin);\n    if (xQueueSendToBack(_tone_queue, &(_tone_msg_t){pin, frequency, duration}, portMAX_DELAY)!= pdPASS) {\n      log_e(\"Could not send to tone queue\");\n    }\n  } else {\n    log_e(\"gpio_is_valid(%d) returned false\", pin);\n  }\n}", "CodeBleu_score": 48.51246151149008}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usbStarted) {\n\t\tif (enabled) {\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\tusbVersion = 0x0210;\n\t\t\t}\n\t\t\twebusbEnabled = true;\n\t\t} else {\n\t\t\twebusbEnabled = false;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 43.97582458405797}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usb_not_started) {\n\t\tif (enabled) {\n\t\t\twebusb_enabled = true;\n\t\t\tif (usb_version < 0x0210) {\n\t\t\t\tusb_version = 0x0210;\n\t\t\t}\n\t\t} else {\n\t\t\twebusb_enabled = false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 53.782899072170096}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usb_state == USB_STATE_DISABLED) {\n\t\treturn false;\n\t}\n\tif (enabled) {\n\t\tusb_webusb_enabled = true;\n\t\tif (usb_state == USB_STATE_UNINITIALIZED) {\n\t\t\tusb_version = 0x0210;\n\t\t}\n\t} else {\n\t\tusb_webusb_enabled = false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 45.37632117152792}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t c;\n\tuint16_t len;\n\n\tlen = _rxBuffer.readBytes(&c, 1);\n\tif (len!= 1) {\n\t\t// If the read fails, post an overflow event with the number of dropped bytes\n\t\t_event.post(EV_USB_RX_OVERFLOW, len);\n\t\treturn;\n\t}\n\n\t// Send the byte to the receive queue\n\tif (!_rxQueue.post(c)) {\n\t\t// If the queue is full, post an overflow event with the number of dropped bytes\n\t\t_event.post(EV_USB_RX_OVERFLOW, len);\n\t}\n}", "CodeBleu_score": 12.296636703423605}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t data[64];\n\tuint32_t n;\n\n\tn = _cdc.read(data, sizeof(data));\n\tif (n == 0) {\n\t\treturn;\n\t}\n\n\tfor (uint32_t i = 0; i < n; i++) {\n\t\tif (_rxQueue.post(data[i]) == false) {\n\t\t\t_rxOverflowCount++;\n\t\t\t_errorCount++;\n\t\t\tLOG_ERROR(\"USB CDC RX queue overflow\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t_rxCount += n;\n\t_rxEvent.post();\n}", "CodeBleu_score": 23.67347933346131}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t buffer[CDC_BUFFER_SIZE];\n\tuint32_t read = 0;\n\tuint32_t len = 0;\n\n\t// Read data from the USB CDC port\n\tread = read(buffer, CDC_BUFFER_SIZE);\n\n\t// If data was read\n\tif (read > 0) {\n\t\t// Send data to the receive queue\n\t\tlen = send(buffer, read);\n\n\t\t// If the queue is full, log an error and post an overflow event\n\t\tif (len < read) {\n\t\t\tLOG_ERROR(\"CDC RX queue overflow! Dropped %d bytes\", read - len);\n\t\t\tpost(CDC_EVENT_OVERFLOW, read - len);\n\t\t}\n\t}\n}", "CodeBleu_score": 16.77261903811477}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request path.\n\trobotName := mux.Vars(req)[\"robot_name\"]\n\n\t// Get the robot from the database.\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the given name\"})\n\t\treturn\n\t}\n\n\t// Get the devices associated with the robot.\n\tdevices, err := a.db.GetDevices(robot)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"An error occurred while trying to retrieve the devices associated with the robot\"})\n\t\treturn\n\t}\n\n\t// Create a JSON response containing the devices.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 37.430797713074575}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tparams := mux.Vars(req)\n\trobotName := params[\"robotName\"]\n\n\trobot, err := a.robotService.GetRobot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the name: \" + robotName})\n\t\treturn\n\t}\n\n\tdevices, err := a.deviceService.GetDevices(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"Error occurred while getting devices: \" + err.Error()})\n\t\treturn\n\t}\n\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 39.427903283458626}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL path\n\trobotName := mux.Vars(req)[\"robotName\"]\n\n\t// Check if a robot with the given name exists\n\trobot, ok := a.Robots[robotName]\n\tif!ok {\n\t\t// If no robot with the given name exists, return a JSON response with an error message indicating that no robot was found with the specified name\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the name \" + robotName})\n\t\treturn\n\t}\n\n\t// If a robot with the given name exists, gather its devices into a JSON format and write this JSON response to the HTTP response writer\n\tdevices := make([]map[string]string, 0)\n\tfor _, device := range robot.Devices {\n\t\tdevices = append(devices, map[string]string{\"name\": device.Name, \"type\": device.Type})\n\t}\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 45.460708823099566}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\t// Check if the robot exists\n\tif _, ok := a.Robots[robotName];!ok {\n\t\t// If the robot does not exist, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\t_, _ = res.Write([]byte(\"No robot with the specified name was found.\"))\n\t\treturn\n\t}\n\n\t// Iterate through the connections of the robot\n\tconnections := make([]string, 0, len(a.Robots[robotName].Connections))\n\tfor connection := range a.Robots[robotName].Connections {\n\t\tconnections = append(connections, connection)\n\t}\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// If there is an error converting the connections to JSON format, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t_, _ = res.Write([]byte(\"Error converting connections to JSON format.\"))\n\t\treturn\n\t}\n\n\t// Write the connections to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t_, _ = res.Write(connectionsJSON)\n}", "CodeBleu_score": 43.228866314307766}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\t// Check if the robot exists\n\tif _, ok := a.robots[robotName];!ok {\n\t\t// Robot not found\n\t\thttp.Error(res, fmt.Sprintf(\"No robot with name %s found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the robot connections\n\trobotConnections := a.robots[robotName].Connections()\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON, err := json.Marshal(robotConnections)\n\tif err!= nil {\n\t\t// Error converting to JSON\n\t\thttp.Error(res, fmt.Sprintf(\"Error converting connections to JSON: %s\", err), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the connections to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 37.582844990819815}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Check if the robot exists\n\tif _, ok := a.robots[robotName];!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(res, \"No robot with the name\", robotName, \"found.\")\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON format\n\tconnections := a.robots[robotName].Connections()\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(res, \"Error converting connections to JSON: \", err)\n\t\treturn\n\t}\n\n\t// Write the JSON-formatted connections to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tfmt.Fprint(res, string(jsonConnections))\n}", "CodeBleu_score": 38.28788893971824}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tvar err error\n\tvar robotName string\n\tvar deviceName string\n\tvar commandName string\n\tvar commandArgs []string\n\tvar command *gobot.Command\n\n\tif req.Method!= \"POST\" {\n\t\tres.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\t// Retrieve the robot and device names from the URL query parameters.\n\trobotName = req.URL.Query().Get(\"robot\")\n\tdeviceName = req.URL.Query().Get(\"device\")\n\tcommandName = req.URL.Query().Get(\"command\")\n\n\t// Retrieve the command arguments from the request body.\n\tcommandArgs, err = a.readCommandArgs(req)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\t// Check if the robot exists.\n\trobot, ok := a.robots[robotName]\n\tif!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Robot %s not found\", robotName)))\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tdevice := robot.GetConnection(deviceName)\n\tif device == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Device %s not found\", deviceName)))\n\t\treturn\n\t}\n\n\t// Check if the command exists.\n\tcommand, ok = device.Commands()[commandName]\n\tif!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"Command %s not found\", commandName)))\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\terr = command.Run(commandArgs...)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\t// Return a successful response.\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(\"Command executed successfully\"))\n}", "CodeBleu_score": 38.012098378659864}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot and device names are valid\n\tif len(robotName) == 0 || len(deviceName) == 0 {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"Invalid robot or device name\"}`))\n\t\treturn\n\t}\n\n\t// Get the robot from the API's robot map\n\trobot, ok := a.robotMap[robotName]\n\tif!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"Robot not found\"}`))\n\t\treturn\n\t}\n\n\t// Get the device from the robot's device map\n\tdevice, ok := robot.Get(deviceName)\n\tif!ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"Device not found\"}`))\n\t\treturn\n\t}\n\n\t// Get the command name from the URL query parameters\n\tcommandName := req.URL.Query().Get(\"command\")\n\n\t// Check if the command name is valid\n\tif len(commandName) == 0 {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"Invalid command name\"}`))\n\t\treturn\n\t}\n\n\t// Execute the command on the device\n\t_, err := device.Command(commandName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(`{\"error\": \"` + err.Error() + `\"}`))\n\t\treturn\n\t}\n\n\t// Send a success response\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(`{\"success\": true}`))\n}", "CodeBleu_score": 44.75927526671711}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\t// Check if the robot and device names are valid\n\tif robotName == \"\" || deviceName == \"\" {\n\t\thttp.Error(res, \"Invalid robot or device name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\t// Check if the robot exists\n\tif _, ok := a.robots[robotName];!ok {\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\t// Check if the device exists\n\trobot := a.robots[robotName]\n\tdevice, ok := robot.Device(deviceName)\n\tif!ok {\n\t\thttp.Error(res, \"Device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\t// Get the command from the request body\n\tvar command string\n\tdecoder := json.NewDecoder(req.Body)\n\terr := decoder.Decode(&command)\n\tif err!= nil {\n\t\thttp.Error(res, \"Invalid command\", http.StatusBadRequest)\n\t\treturn\n\t}\n\t// Execute the command on the device\n\terr = device.Command(command)\n\tif err!= nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\t// Write a success message as a JSON response\n\tjson.NewEncoder(res).Encode(\"Command executed successfully\")\n}", "CodeBleu_score": 44.87531038638076}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"No Authorization header\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!strings.HasPrefix(auth, \"Basic \") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Authorization header format must be `Basic realm=\\\"Restricted\\\"`\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Authorization header must be base64 encoded\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Authorization header must have a username and password\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Authorization header must be valid credentials\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Authenticated, proceed to the next handler\n\t\tr.Header.Set(\"X-Username\", pair[0])\n\t\tr.Header.Set(\"X-Password\", pair[1])\n\t}\n}", "CodeBleu_score": 45.983134526237244}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tauth = strings.SplitN(auth, \" \", 2)[1]\n\t\tauth = strings.Trim(auth, \"\\\"\")\n\n\t\tif!secureCompare(auth, base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Proceed to the next handler\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 54.57473969035663}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor to prevent simultaneous readings.\n\ta.sensorMutex.Lock()\n\tdefer a.sensorMutex.Unlock()\n\n\t// Check if the connection supports analog reading.\n\tif!a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, errors.New(\"The connection does not support analog reading.\")\n\t}\n\n\t// Read the raw sensor value.\n\trawValue, err := a.connection.AnalogRead(a.sensorIndex)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration.\n\tscaledValue := float64(rawValue) * a.sensorConfig.ScaleFactor + a.sensorConfig.Offset\n\n\t// Update the last read values.\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 48.087910857156984}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading\n\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif!a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\n\t// Retrieve the raw sensor value\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaledValue := float64(rawValue) * a.scalingFactor\n\n\t// Update the last read values\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 48.077726988291936}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading\n\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif!a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, errors.New(\"Analog sensor does not support analog reading\")\n\t}\n\n\t// Retrieve the raw sensor value\n\trawValue, err := a.connection.ReadAnalogSensorValue(a.id)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaledValue := a.scale.Scale(rawValue)\n\n\t// Update the last read values\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\t// Return both the raw and scaled values\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 48.34062360613629}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tgroveSoundSensorDriver := GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: AnalogSensorDriver{\n\t\t\tAnalogReader: a,\n\t\t\tPin:          pin,\n\t\t},\n\t}\n\n\tif len(opts) > 0 {\n\t\tif opt, ok := opts[0].(string); ok {\n\t\t\tgroveSoundSensorDriver.Name = opt\n\t\t}\n\t} else {\n\t\tgroveSoundSensorDriver.Name = \"GroveSoundSensorDriver\"\n\t}\n\n\treturn &groveSoundSensorDriver\n}", "CodeBleu_score": 36.97223755953696}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tdriver := NewAnalogSensorDriver(a, pin, opts...)\n\tdriver.name = \"GroveSoundSensorDriver\"\n\treturn driver\n}", "CodeBleu_score": 27.207197553361006}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tdriver := new(GroveSoundSensorDriver)\n\tdriver.AnalogReader = a\n\tdriver.Pin = pin\n\tdriver.Name = \"Grove Sound Sensor\"\n\tdriver.AnalogSensorDriver = NewAnalogSensorDriver(a, pin, opts...)\n\treturn driver\n}", "CodeBleu_score": 31.37450043776883}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Clear MFCrypto1On bit\n\t// Write to the command register\n\tif err := d.writeRegister(regCommand, 0x00); err!= nil {\n\t\treturn err\n\t}\n\t// Wait for the PowerDown bit to be cleared\n\tif err := d.waitForBit(regCommand, 0x01, false); err!= nil {\n\t\treturn err\n\t}\n\t// Reset bit\n\t// Write to the command register\n\tif err := d.writeRegister(regCommand, 0x0F); err!= nil {\n\t\treturn err\n\t}\n\t// Wait for the PowerDown bit to be set\n\tif err := d.waitForBit(regCommand, 0x01, true); err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 55.81240395666656}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Reset the MFRC522\n\tif err := d.writeRegister(CommandReg, 0x0F); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the PowerDown bit in CommandReg to be cleared\n\tif err := d.waitUntil(func() bool { return d.readRegister(CommandReg) == 0x00 }, 1000); err!= nil {\n\t\treturn err\n\t}\n\n\t// Reset ModWidthReg to default value\n\tif err := d.writeRegister(ModWidthReg, 0x26); err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 55.13340122248657}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tvar err error\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\terr = d.writeReg(MFRC522_COMMAND_REG, MFRC522_SOFTRESET)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(time.Millisecond * 10)\n\n\tif d.readReg(MFRC522_COMMAND_REG) == MFRC522_SOFTRESET {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 42.84123550306903}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Read FIFO.\n\tif len(backData)!= 16 {\n\t\treturn 0, errors.New(\"readFifo: Invalid length of byte slice\")\n\t}\n\t// Read data from FIFO.\n\t_, err := d.i2c.ReadBytes(d.i2cAddress, []byte{byte(MFRC522CommandReg)}, backData)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\t// Read control byte.\n\t_, err = d.i2c.ReadBytes(d.i2cAddress, []byte{byte(MFRC522ControlReg)}, backData)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\treturn backData[0], nil\n}", "CodeBleu_score": 32.29299926620849}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check the size of the FIFO\n\tstatus, err := d.readRegister(0x35)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tif status&0x1F!= 0 {\n\t\treturn 0, errors.New(\"FIFO is not empty\")\n\t}\n\t// Read the data from the FIFO\n\tif len(backData)!= int(status&0x1F) {\n\t\treturn 0, errors.New(\"FIFO data length does not match the expected length\")\n\t}\n\tfor i := 0; i < int(status&0x1F); i++ {\n\t\tbackData[i], err = d.readRegister(0x36)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the last bits received from the FIFO\n\tlastBits, err := d.readRegister(0x37)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\treturn lastBits, nil\n}", "CodeBleu_score": 45.42978984933994}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// read the FIFO\n\tif len(backData)!= d.readReg(MFRC522_FIFO_LENGTH_REG) {\n\t\treturn 0, errors.New(\"readFifo: length of backData does not match FIFO length\")\n\t}\n\n\t// read the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i] = d.readReg(MFRC522_FIFO_DATA_REG)\n\t}\n\n\t// read the control register\n\tcontrol := d.readReg(MFRC522_CONTROL_REG)\n\n\treturn control, nil\n}", "CodeBleu_score": 25.997460373685566}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\td.debugLog(\"piccHalt\")\n\t}\n\n\t// Build command buffer\n\thaltCmd := []byte{MFRC522_PICC_HALT}\n\thaltCmd = append(haltCmd, d.crc(haltCmd)...)\n\n\t// Send the command.\n\t// The CRC must be appended to the end of the message\n\t// The PICC will be put to sleep now; sleeping until an ISO14443-3\n\t// request is received will let the PICC wake up again.\n\tif err := d.write(haltCmd); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait an additional time to ensure that the PICC is in sleep mode\n\t// The spec says there may be a max of 5ms, but we set 10\n\ttime.Sleep(10 * time.Millisecond)\n\n\treturn nil\n}", "CodeBleu_score": 32.361437137077196}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Printf(\"MFRC522Common: piccHalt\n\")\n\t}\n\n\t// Build command buffer\n\thaltCommand := []byte{PICC_CMD_HALT}\n\thaltCommand = append(haltCommand, d.crc(haltCommand)...)\n\n\t// Send the command.\n\t// The CRC must be appended to the end of the message\n\t// The PICC will only listen to the request if a valid CRC is received.\n\t// If a CRC does not match, then no response will be sent back.\n\tif err := d.sendCommand(haltCommand, nil); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the PICC to be unpowered\n\t// This is the end of the communication.\n\t// The PICC will now be out of communication range.\n\treturn nil\n}", "CodeBleu_score": 26.163576871860343}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t", "CodeBleu_score": 1.2890370581259236}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build command buffer\n\tcmd := []byte{PICC_CMD_MF_READ, block}\n\t// Calculate CRC_A\n\t// 1. Append CRC_A's 1st byte\n\tcmd = append(cmd, d.crc(cmd)...)\n\t// 2. Send the command\n\tif err := d.writeCommand(cmd); err!= nil {\n\t\treturn nil, err\n\t}\n\t// 3. Read the response\n\treturn d.readData(16)\n}", "CodeBleu_score": 28.938808960082063}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Reset the MFRC522\n\terr := d.reset()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Prepare the MFRC522\n\terr = d.prepare()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// MFRC522 MSB == 0 is the Command Bit.\n\t// MSB == 1 is the Read Block command.\n\tcommand := byte(0x00)\n\tcommand |= block\n\terr = d.communicate(command)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the 16 bytes of data\n\tdata, err := d.communicate(byte(0x00))\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Verify CRC\n\terr = d.verify()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}", "CodeBleu_score": 39.90185855165378}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Build command buffer\n\tcmd := []byte{PICC_CMD_MF_READ, block}\n\n\t// Calculate CRC\n\tcrc, err := d.mfrc522.crc(cmd)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Append CRC to command\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Transmit command\n\tif err = d.mfrc522.transceive(cmd); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Verify response\n\tif len(d.mfrc522.response)!= 16 {\n\t\treturn nil, errors.New(\"piccRead: incorrect response\")\n\t}\n\n\treturn d.mfrc522.response, nil\n}", "CodeBleu_score": 42.67128767288747}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn errors.New(\"Answer buffer is too short\")\n\t}\n\n\t// Clear theCOLL bits\n\td.writeRegister(CollReg, 0x80) // ValuesAfterColl=1\n\n\t// Set bit 4 (OnlyOne) of bitCollReg to 1, enables only one target.\n\td.writeRegister(CollReg, 0x10) // Only 1 target can be used for PICCs\n\td.writeRegister(BitFramingReg, 0x00)\n\n\t// Set the desired mode for the card\n\tswitch reqMode {\n\tcase MFRC522_REQIDL:\n\t\td.writeRegister(BitFramingReg, 0x00)\n\t\tbreak\n\tcase MFRC522_REQALL:\n\t\td.writeRegister(BitFramingReg, 0x07)\n\t\tbreak\n\tdefault:\n\t\treturn errors.New(\"Invalid mode\")\n\t}\n\n\t// Start the PCD\n\td.writeRegister(CommandReg, PCD_Transceive)\n\n\t// Start transmission\n\tif err := d.waitForReady(); err!= nil {\n\t\treturn err\n\t}\n\n\t// Store response in the answer buffer\n\tanswer[0] = d.readRegister(BitFramingReg) & 0x07 // One bit per frame\n\tanswer[1] = 0x00\n\n\t// Transmit the data\n\tif err := d.write(answer[0], answer[1:]); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the PICC to be deactivated\n\tif err := d.waitForReady(); err!= nil {\n\t\treturn err\n\t}\n\n\t// Get the response\n\tif err := d.read(answer[0], answer[1:]); err!= nil {\n\t\treturn err\n\t}\n\n\t// Error checking\n\tif answer[0]!= 0x00 {\n\t\treturn errors.New(\"PICC response error\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 51.33706331855353}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Clear the buffer\n\td.ClearBuffer()\n\n\t// Prepare the command buffer\n\td.buffer[0] = piccRequestCommand\n\td.buffer[1] = reqMode\n\n\t// Transmit the buffer and receive the response\n\tif err := d.transceive(d.buffer, 2, answer, 2); err!= nil {\n\t\treturn err\n\t}\n\n\t// Check that the response is valid\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"Invalid answer length\")\n\t}\n\n\t// Check the SAK (Select Acknowledge)\n\tif answer[0]!= 0x00 {\n\t\treturn errors.New(\"Invalid SAK\")\n\t}\n\n\t// Check bit 7 of the first byte of the response\n\tif (answer[1] & 0x80)!= 0 {\n\t\treturn errors.New(\"Collision detected\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 39.09065304604322}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Calculate CRC_A\n\t// The frame should be at least 1 byte long to apply CRC_A\n\tif len(answer) < 1 {\n\t\treturn errors.New(\"answer buffer too short\")\n\t}\n\t// Clear bits 7 and 8 (these bits are not part of the CRC_A calculation)\n\tanswer[0] = answer[0] & 0x7F\n\t// Calculate CRC_A\n\tif err := d.mfrc522.calculateCRC(answer, answer[0], answer[0]); err!= nil {\n\t\treturn err\n\t}\n\t// Send the command.\n\t// The PICC must be connected (one handshake is always done before transaction)\n\tif err := d.mfrc522.transceive(answer, uint8(len(answer)), answer, uint8(len(answer)), reqMode); err!= nil {\n\t\treturn err\n\t}\n\t// The CRC_A is valid if:\n\t// - the first and second received bytes equal\n\t// - and either:\n\t//\t\t- the third received byte is 0x00\n\t//\t\t- or 0xFF\n\tif answer[0]!= answer[1] || (answer[2]!= 0x00 && answer[2]!= 0xFF) {\n\t\treturn errors.New(\"invalid CRC_A\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 50.59999484141583}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\t// Lock the mutex to ensure thread safety\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Set the step pin low\n\tif err := d.stepPin.Write(gpio.Low); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the delay\n\ttime.Sleep(d.delay)\n\n\t// Set the step pin high\n\tif err := d.stepPin.Write(gpio.High); err!= nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction\n\tif d.direction == forward {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 63.317331877850776}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\t// Lock the value mutex to ensure thread safety\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Set the step pin low\n\terr := d.stepPin.Set(gpio.Low)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the step delay\n\ttime.Sleep(d.stepDelay)\n\n\t// Set the step pin high\n\terr = d.stepPin.Set(gpio.High)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction\n\tif d.direction == FORWARD {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 60.964569529956336}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a step\n\tif d.direction == 0 {\n\t\td.stepPin.Low()\n\t} else {\n\t\td.stepPin.High()\n\t}\n\n\t// Wait for the step delay\n\ttime.Sleep(d.stepDelay)\n\n\t// Increment or decrement the step number\n\tif d.direction == 0 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\t// Set the step pin high\n\tif d.direction == 0 {\n\t\td.stepPin.High()\n\t} else {\n\t\td.stepPin.Low()\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 38.20564712405552}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.lock.Lock()\n\tdefer d.lock.Unlock()\n\n\tif d.stopChannel!= nil {\n\t\treturn errors.New(\"Distance monitor already running\")\n\t}\n\n\td.stopChannel = make(chan struct{})\n\td.waitGroup = &sync.WaitGroup{}\n\td.waitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.waitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChannel:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\td.measureDistance()\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 37.86175856303595}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.lock.Lock()\n\tdefer d.lock.Unlock()\n\n\tif d.stopChannel!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopChannel = make(chan struct{})\n\td.waitGroup = &sync.WaitGroup{}\n\td.waitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.waitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChannel:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\td.measureDistance()\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 37.92820573372937}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\tif d.stopChan!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopChan = make(chan struct{})\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\td.mutex.Lock()\n\t\t\td.measureDistance()\n\t\t\td.mutex.Unlock()\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 27.22854249350594}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\treturn func(pin int, duration time.Duration, _ string, _ uint32, _ uint32) {\n\t\tif duration > 0 {\n\t\t\td.DurationChannel <- duration\n\t\t\tstartTimestamp = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 40.75065122637946}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstartTimestamp := time.Now()\n\treturn func(channel int, duration time.Duration, event string, timestamp uint32, value uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstartTimestamp = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\td.channel <- duration\n\t\t\td.timestamp <- timestamp\n\t\t\td.value <- value\n\t\t\tstartTimestamp = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 40.45677100325793}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, name string, channel uint32, id uint32) {\n\t\tif pin == d.triggerPin {\n\t\t\tstart = time.Now()\n\t\t} else if pin == d.echoPin {\n\t\t\td.durationChan <- time.Since(start)\n\t\t}\n\t}\n}", "CodeBleu_score": 32.16745046482184}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\terr := d.trigger()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the sensor to complete the measurement\n\ttimeout := time.After(d.timeout)\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn errors.New(\"timeout\")\n\t\tcase <-d.done:\n\t\t\treturn nil\n\t\t}\n\t}\n}", "CodeBleu_score": 43.421256682781326}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.trig.Write(gpio.High)\n\ttime.Sleep(100 * time.Microsecond)\n\td.trig.Write(gpio.Low)\n\n\t// Wait for the echo to go high\n\tfor!d.echo.Read() {\n\t\ttime.Sleep(100 * time.Microsecond)\n\t\tif d.timeout > 0 && time.Since(d.start) > d.timeout {\n\t\t\treturn errors.New(\"timeout\")\n\t\t}\n\t}\n\n\t// Wait for the echo to go low\n\tfor d.echo.Read() {\n\t\ttime.Sleep(100 * time.Microsecond)\n\t\tif d.timeout > 0 && time.Since(d.start) > d.timeout {\n\t\t\treturn errors.New(\"timeout\")\n\t\t}\n\t}\n\n\td.distance = (time.Since(d.start) * 17150) / 1000000\n\n\treturn nil\n}", "CodeBleu_score": 45.52507039020562}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor\n\td.triggerPin.Write(gpio.High)\n\ttime.Sleep(time.Microsecond * 10)\n\td.triggerPin.Write(gpio.Low)\n\n\t// Wait for the sensor to complete the measurement or for a timeout to occur\n\tfor d.echoPin.Read() == gpio.High {\n\t\tif time.Since(d.startTime) > d.timeout {\n\t\t\treturn errors.New(\"timeout\")\n\t\t}\n\t}\n\n\t// Calculate the measured time in microseconds\n\tmeasuredTime := time.Since(d.startTime)\n\tmicroseconds := measuredTime.Microseconds()\n\n\t// Store the measured time in microseconds\n\td.distance = microseconds\n\n\treturn nil\n}", "CodeBleu_score": 50.60719504993121}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return self.state.token\n    except AttributeError:\n        pass\n    try:\n        return self.get_local_token()\n    except AccountError as exc:\n        if exc.code == \"invalid_grant\":\n            if self.refresh_token:\n                return self.get_new_token()\n            raise AccountNotAuthorized(\n                \"No valid access token found. Please login to your account.\"\n            ) from exc\n        raise\n    except HTTPClientError as exc:\n        if exc.code == 401:\n            if self.refresh_token:\n                return self.get_new_token()\n            raise AccountNotAuthorized(\n                \"No valid access token found. Please login to your account.\"\n            ) from exc\n        raise\n    raise AccountNotAuthorized(\n        \"No valid access token found. Please login to your account.\"\n    )\n\n", "CodeBleu_score": 31.4615445643614}, {"code": "def fetch_authentication_token(self)\n\t\n    self.logger.debug(\"Fetching authentication token\")\n    if self.token is not None:\n        self.logger.debug(\"Using existing authentication token\")\n        return self.token\n    if self.refresh_token is not None:\n        self.logger.debug(\"Using existing refresh token\")\n        self.token = self.fetch_access_token()\n        self.logger.debug(\"Fetched authentication token\")\n        return self.token\n    if self.access_token is not None:\n        self.logger.debug(\"Using existing access token\")\n        return self.access_token\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 27.873699790549654}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.access_token:\n        return self.access_token\n    if self.refresh_token:\n        try:\n            return self.fetch_json_data(\n                'https://api.intra.42.fr/oauth/token',\n                method='POST',\n                data={\n                    'grant_type':'refresh_token',\n                    'client_id': self.client_id,\n                    'client_secret': self.client_secret,\n                   'refresh_token': self.refresh_token,\n                },\n            )['access_token']\n        except HTTPClientError as exc:\n            if exc.status_code == 400:\n                raise AccountNotAuthorized() from exc\n            raise\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 24.88284169276738}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.session.get(\"refresh_token\")\n    self.session.clear()\n    self.session.delete(\"refresh_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"expires_at\")\n    self.session.delete(\"refresh_token_expires_at\")\n    self.session.delete(\"refresh_token_expires_in\")\n    self.session.delete(\"access_token_expires_at\")\n    self.session.delete(\"access_token_expires_in\")\n    self.session.delete(\"refresh_token_expires_in\")\n    self.session.delete(\"access_token_expires_in\")\n    self.session.delete(\"refresh_token_expires_in\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")\n    self.session.delete(\"access_token\")", "CodeBleu_score": 23.13975616521904}, {"code": "def logout(self)\n\t\n    try:\n        self.refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            headers={\"Authorization\": f\"Bearer {self.refresh_token}\"},\n        )\n        return True\n    except AccountError:\n        return False\n\n", "CodeBleu_score": 47.96003623258008}, {"code": "def logout(self)\n\t\n    refresh_token = self.session.get(\"refresh_token\")\n    self.session.clear()\n    self.session.update({\"refresh_token\": refresh_token})\n    self.fetch_json_data(\n        url=f\"{self.base_url}/v1/logout\",\n        method=\"POST\",\n        headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n    )\n    return True\n\n", "CodeBleu_score": 36.35411687591129}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    used_packages = []\n    for package in self.packages:\n        if not package.is_optional:\n            used_packages.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                    \"external\": package.external,\n                    \"url\": package.url,\n                }\n            )\n    return used_packages\n\n", "CodeBleu_score": 22.77997308665953}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for package in self.get_packages():\n        if package.is_optional():\n            continue\n        packages.append(\n            {\n                \"name\": package.name,\n                \"version\": package.version,\n                \"external\": package.is_external(),\n                \"source\": package.source,\n                \"url\": package.url,\n            }\n        )\n    return packages\n\n", "CodeBleu_score": 24.682318312592873}, {"code": "def dump_used_packages(self)\n\t\n    used = []\n    for package in self.get_packages():\n        if not package.optional:\n            used.append(package.dump())\n    return used\n\n", "CodeBleu_score": 10.885296970034979}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    project_conf = cls.project_conf_class(cls.project_conf_path)\n    project_conf.read()\n    if env not in project_conf.get_envs():\n        raise exception.UndefinedEnvPlatformError(env)\n    platform = project_conf.get_platform(env)\n    project_conf.set_platform(platform)\n    project_conf.set_autoinstall(autoinstall)\n    return cls(platform=platform, targets=targets)\n\n", "CodeBleu_score": 25.491361320093763}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not env:\n        raise exception.UndefinedEnvError(env)\n    project_conf = cls.project_conf\n    env_conf = project_conf.get(\"env\", env)\n    if not env_conf:\n        raise exception.UndefinedEnvPlatformError(env)\n    platform_spec = env_conf.get(\"platform\")\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n    project_packages = env_conf.get(\"packages\")\n    if not project_packages:\n        raise exception.UndefinedEnvPackagesError(env)\n    project_env = cls(platform_spec, autoinstall=autoinstall)\n    project_env.set_project_packages(project_packages, targets=targets)\n    return project_env\n\n", "CodeBleu_score": 36.35760184772293}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    project_config = ProjectConfig(env.project_config_path)\n    platform_spec = project_config.get_platform_spec(env.env_name)\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env.env_name)\n\n    project_env = cls(\n        platform_spec,\n        autoinstall=autoinstall,\n        project_config=project_config,\n        project_path=env.project_path,\n        project_config_path=env.project_config_path,\n        project_env_name=env.env_name,\n        project_env_path=env.project_env_path,\n    )\n    project_env.configure_project_packages(targets)\n    return project_env\n\n", "CodeBleu_score": 26.940797388576186}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(AXP192_I2C_ADDRESS);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(AXP192_I2C_ADDRESS, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 60.54818478880081}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(I2C_ADDR);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(I2C_ADDR, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 60.38386846755457}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 68.97880803785503}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t", "CodeBleu_score": 3.410829817826662}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef AXP192_DEBUG\n    Serial.print(\"DeepSleep: \");\n#endif\n    SetSleep();\n    if (time_in_us) {\n        Write1Byte(0x31, 0x00);\n        Write1Byte(0x90, 0x01);\n        Write1Byte(0x12, 0x09);\n        // Write1Byte(0x12, 0x00);\n        Write1Byte(0x12, Read8bit(0x12) & 0xA1);  // Disable all outputs but DCDC1\n        delayMicroseconds(time_in_us);\n        Write1Byte(0x12, Read8bit(0x12) | 0x01);  // Enable all outputs\n        Write1Byte(0x90, 0x00);\n        Write1Byte(0x31, 0x00);\n    } else {\n        Write1Byte(0x12, Read8bit(0x12) | 0x01);  // Enable all outputs\n        Write1Byte(0x90, 0x00);\n        Write1Byte(0x31, 0x00);\n    }\n#ifdef AXP192_DEBUG\n    Serial.println(\"done\");\n#endif\n}", "CodeBleu_score": 35.302482514186515}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t", "CodeBleu_score": 3.410829817826662}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n  int16_t old_y = tft.getCursorY();\n  tft.fillRect(0, old_y, tft.width(), tft.fontHeight(), color);\n  tft.setCursor(0, old_y);\n  tft.setTextColor(ILI9341_WHITE);\n  tft.setTextSize(1);\n  tft.setTextWrap(true);\n  if (old_y + tft.fontHeight() >= tft.height() - tft.getFixedHeight()) {\n    scrollAddress(0);\n    return tft.height() - tft.getFixedHeight();\n  } else if (old_y + tft.fontHeight() >= tft.height() - tft.getFixedHeight() - tft.fontHeight()) {\n    scrollAddress(tft.getFixedHeight());\n    return tft.height() - tft.getFixedHeight() - tft.fontHeight();\n  } else {\n    scrollAddress(old_y + tft.fontHeight());\n    return old_y + tft.fontHeight();\n  }\n#endif\n  return 0;\n}", "CodeBleu_score": 21.556621680030663}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint16_t y = tft.getCursorY();\n\tif (y >= (tft.height()-tft.getScrollHeight())) {\n\t\ty = 0;\n\t}\n\ttft.fillRect(0, y, tft.width(), tft.getScrollHeight(), color);\n\tscrollAddress(y+tft.getScrollHeight());\n\treturn y;\n}", "CodeBleu_score": 11.170261813652244}, {"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n  int y = tft.getCursorY();\n  if (y < tft.height - tft.fontHeight) {\n    tft.fillRect(0, y, tft.width, tft.fontHeight, color);\n  } else {\n    tft.fillRect(0, tft.height - tft.fontHeight, tft.width, tft.fontHeight, color);\n  }\n  scrollAddress(y + tft.fontHeight);\n  return y;\n#endif\n  return 0;\n}", "CodeBleu_score": 18.382298632386707}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// setup access points\n\tif (!this->setupAP(ssids, access_points)) {\n\t\treturn false;\n\t}\n\n\t// setup HTML content\n\tif (!this->setupHTML()) {\n\t\treturn false;\n\t}\n\n\t// start portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 65.51722388894017}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setupAPs(ssids, access_points)) {\n\t\treturn false;\n\t}\n\n\tif (!this->setupHTML()) {\n\t\treturn false;\n\t}\n\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 65.05767372121191}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// setup access points\n\tthis->setupAPs(ssids, access_points);\n\n\t// setup HTML content\n\tthis->setupHTML();\n\n\t// start the portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 53.10105328307484}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\treturn;\n\t}\n\tqueue_enabled_flag = true;\n\tqueue_text.clear();\n\tqueue_text_in.clear();\n\tflush_queue();\n}", "CodeBleu_score": 7.4706380904073235}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tgps_queue_init();\n\t\tgps_queue_text_init();\n\t\tgps_queue_text_in_init();\n\t} else {\n\t\tgps_queue_flush();\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 10.801452350909061}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag == false) {\n\t\t//flush the queue\n\t\tgps_queue.flush();\n\t\t//initialize the queue\n\t\tgps_queue.init(gps_queue_text, gps_queue_text_size);\n\t\t//initialize the text_in\n\t\tgps_queue.init_text_in(gps_queue_text_in, gps_queue_text_in_size);\n\t\t//set the queue_enabled_flag\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 10.318433002356961}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea!= NULL) {\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new QQueue<QString>();\n}", "CodeBleu_score": 36.316714542448565}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea!= NULL) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = NULL;\n\t}\n\tqueue_nmea = new std::queue<std::string>();\n}", "CodeBleu_score": 35.65957826674118}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea!= NULL) {\n\t\tqueue_nmea->clear();\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new QList<QString>();\n}", "CodeBleu_score": 37.78186526196763}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tint32_t x, y;\n\tuint32_t color;\n\n\t// start write transaction\n\tHAL_GPIO_WritePin(LCD_DC_GPIO_Port, LCD_DC_Pin, GPIO_PIN_RESET);\n\tHAL_SPI_Transmit(&hspi2, (uint8_t *)\"S\", 1, 1000);\n\n\t// set address window to the specified area\n\tHAL_SPI_Transmit(&hspi2, (uint8_t *)\"R\", 1, 1000);\n\tHAL_SPI_Transmit(&hspi2, (uint8_t *)\"X\", 1, 1000);\n\tHAL_SPI_Transmit(&hspi2, (uint8_t *)&area->x1, 1, 1000);\n\tHAL_SPI_Transmit(&hspi2, (uint8_t *)&area->y1, 1, 1000);\n\tHAL_SPI_Transmit(&hspi2, (uint8_t *)&area->x2, 1, 1000);\n\tHAL_SPI_Transmit(&hspi2, (uint8_t *)&area->y2, 1, 1000);\n\n\t// iterate through each pixel in the area\n\tfor(y = area->y1; y <= area->y2; y++) {\n\t\tfor(x = area->x1; x <= area->x2; x++) {\n\t\t\tcolor = color_p->full;\n\t\t\tcolor_p++;\n\t\t\tHAL_SPI_Transmit(&hspi2, (uint8_t *)&color, 1, 1000);\n\t\t}\n\t}\n\n\t// end write transaction\n\tHAL_GPIO_WritePin(LCD_DC_GPIO_Port, LCD_DC_Pin, GPIO_PIN_SET);\n\tHAL_SPI_Transmit(&hspi2, (uint8_t *)\"E\", 1, 1000);\n\n\t// notify that the display flush is complete\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 47.020557291981916}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\t// start write transaction\n\tdisp->buffer->ext_buf = color_p;\n\tdisp->buffer->ext_cb = my_disp_flush_cb;\n\tdisp->buffer->ext_area = *area;\n\tdisp->buffer->ext_flush = true;\n\n\t// set address window\n\tdisp->buffer->ext_area.x1 = 0;\n\tdisp->buffer->ext_area.y1 = 0;\n\tdisp->buffer->ext_area.x2 = 320;\n\tdisp->buffer->ext_area.y2 = 240;\n\n\t// end write transaction\n\tdisp->buffer->ext_flush = false;\n}", "CodeBleu_score": 19.139251713301057}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\tcout << \"The menu is empty\" << endl;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < layer; i++) {\n\t\tcout << \"   \";\n\t}\n\tcout << menu->getName() << endl;\n\tfor (int i = 0; i < menu->getNumberOfNodes(); i++) {\n\t\tshowMenuList(menu->getNode(i), layer + 1);\n\t}\n\tcout << endl;\n}", "CodeBleu_score": 44.97268507637905}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\t// Iterate through all menu nodes and print each node's name with indentation proportional to the layer level\n\tfor (int i = 0; i < menu->size(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \" \";\n\t\t}\n\t\tcout << menu->at(i)->getName() << endl;\n\t}\n\n\t// Print an empty line after listing all nodes\n\tcout << endl;\n}", "CodeBleu_score": 48.841703896437515}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == nullptr) {\n\t\treturn;\n\t}\n\tfor (int i = 0; i < layer; i++) {\n\t\tcout << \" \";\n\t}\n\tcout << menu->getName() << endl;\n\tfor (int i = 0; i < menu->getMenuNodes().size(); i++) {\n\t\tshowMenuList(menu->getMenuNodes()[i], layer + 1);\n\t}\n\tcout << endl;\n}", "CodeBleu_score": 45.403541538585515}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint channel;\n\tchar ssid[10];\n\tchar mac[18];\n\tint ssidCount = 0;\n\tint macCount = 0;\n\tint macAddr[6];\n\tint macAddrCount = 0;\n\n\t//generate random SSIDs\n\tfor (i = 0; i < count; i++) {\n\t\t//generate random MAC address\n\t\tfor (macAddrCount = 0; macAddrCount < 6; macAddrCount++) {\n\t\t\tmacAddr[macAddrCount] = rand() % 256;\n\t\t}\n\n\t\t//generate random SSID\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tssid[j] = rand() % 256;\n\t\t}\n\t\tssid[6] = '\\0';\n\n\t\t//generate random channel\n\t\tchannel = rand() % 15;\n\n\t\t//add SSID to list\n\t\taddSSID(ssid, channel, macAddr);\n\t\tssidCount++;\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 34.35520562684711}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i = 0;\n\tint ssidCount = 0;\n\tint channel;\n\tString ssid;\n\tString mac;\n\tString macAddress;\n\tString ssidAddress;\n\n\t// iterate through the given count\n\tfor (i = 0; i < count; i++) {\n\t\t// generate random SSID\n\t\tssid = generateSSID();\n\t\t// generate random MAC address\n\t\tmacAddress = generateMACAddress();\n\t\t// generate random channel\n\t\tchannel = generateChannel();\n\t\t// generate SSID address\n\t\tssidAddress = generateSSIDAddress(channel, macAddress);\n\t\t// add SSID to SSID list\n\t\tssidList.add(ssidAddress);\n\t\t// print SSID to serial output\n\t\tSerial.println(ssidAddress);\n\t\tssidCount++;\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 34.16860288310431}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint ssidCount = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = generateSSID();\n\t\tString channel = generateChannel();\n\t\tString mac = generateMAC();\n\t\tString mac_addr = mac.substring(0, 2) + \":\" + mac.substring(2, 4) + \":\" + mac.substring(4, 6) + \":\" + mac.substring(6, 8) + \":\" + mac.substring(8, 10) + \":\" + mac.substring(10, 12);\n\t\tString ssid_addr = ssid + \" (\" + channel + \" channel, \" + mac_addr + \" MAC address)\";\n\t\tSerial.println(ssid_addr);\n\t\tssidCount++;\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 38.356451812985185}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    private_key = str.encode(private_key)\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 63.28720782795729}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        \"iss\": project_id,\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        \"aud\": project_id,\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 44.58055223643239}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        \"iat\": datetime.datetime.utcnow(),\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        \"aud\": project_id\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 49.266077566347946}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(message.payload, message.topic, message.qos))\n    if message.payload == b'on':\n        preview_capture('image.jpg')\n        upload_file('image.jpg', args.bucket_name)\n        client.publish(args.cloud_region + '/projects/' + args.project_id + '/locations/us-central1/registries/' + args.registry_id + '/devices/' + args.device_id + '/events', upload_file('image.jpg', args.bucket_name))\n    else:\n        print('off')\n\n", "CodeBleu_score": 33.15621037897841}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(message.payload, message.topic, message.qos))\n    if message.payload == b'on':\n        preview_capture(path)\n        upload_file(path, bucket_name)\n        client.publish(topic='events/image', payload=upload_file(path, bucket_name))\n    else:\n        print('off')\n\n", "CodeBleu_score": 28.354842135459897}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(message.payload, message.topic, message.qos))\n    if message.payload == b'on':\n        preview_capture(path)\n        upload_file(path, bucket_name)\n        client.publish(event_topic, upload_file(path, bucket_name))\n    else:\n        print('off')\n\n", "CodeBleu_score": 28.135436025861583}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n\n    parser = argparse.ArgumentParser(description=\"Connect to Google Cloud IoT MQTT\")\n\n    parser.add_argument(\"--project_id\", help=\"Project ID\", type=str, default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\"--region\", help=\"Cloud IoT Core region\", type=str, default=\"us-central1\")\n    parser.add_argument(\"--registry\", help=\"Cloud IoT Core registry ID\", type=str, required=True)\n    parser.add_argument(\"--device\", help=\"Cloud IoT Core device ID\", type=str, required=True)\n    parser.add_argument(\"--private_key_file\", help=\"Private key file\", type=str, required=True)\n    parser.add_argument(\"--algorithm\", help=\"Algorithm\", type=str, default=\"RS256\")\n    parser.add_argument(\"--ca_certs\", help=\"CA certificates\", type=str, default=None)\n    parser.add_argument(\"--mqtt_bridge\", help=\"MQTT bridge\", type=str, default=\"mqtt.googleapis.com\")\n    parser.add_argument(\"--mqtt_bridge_port\", help=\"MQTT bridge port\", type=int, default=8883)\n    parser.add_argument(\"--mqtt_keepalive\", help=\"MQTT keepalive\", type=int, default=60)\n    parser.add_argument(\"--mqtt_max_inflight\", help=\"MQTT max inflight\", type=int, default=5)\n    parser.add_argument(\"--mqtt_max_retries\", help=\"MQTT max retries\", type=int, default=5)\n    parser.add_argument(\"--mqtt_max_retry_delay\", help=\"MQTT max retry delay\", type=int, default=30)\n    parser.add_argument(\"--mqtt_min_retry_delay\", help=\"MQTT min retry delay\", type=int, default=1)\n    parser.add_argument(\"--mqtt_offline_queue_depth\", help=\"MQTT offline queue depth\", type=int, default=1000)\n    parser.add_argument(\"--mqtt_session_expiry\", help=\"MQTT session expiry\", type=int, default=3600)\n    parser.add_argument(\"--mqtt_session_expiry_grace\", help=\"MQTT session expiry grace\", type=int, default=300)\n    parser.add_argument(\"--mqtt_start_delay\",", "CodeBleu_score": 31.465446655863417}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection.')\n    parser.add_argument('--project_id', help='Your Google Cloud Platform project ID.')\n    parser.add_argument('--registry_id', help='Your Google Cloud IoT Core registry ID.')\n    parser.add_argument('--device_id', help='Your Google Cloud IoT Core device ID.')\n    parser.add_argument('--private_key_file', help='Your Google Cloud IoT Core private key file path.')\n    parser.add_argument('--algorithm', help='Your Google Cloud IoT Core private key algorithm. Default: RS256')\n    parser.add_argument('--ca_certs', help='Your Google Cloud IoT Core CA certificates file path.')\n    parser.add_argument('--cloud_region', help='Your Google Cloud IoT Core cloud region.')\n    parser.add_argument('--num_messages', help='The number of messages to publish. Default: 1000')\n    parser.add_argument('--message_type', help='The message type. Default: PAYLOAD')\n    parser.add_argument('--message_type_payload', help='The message payload. Default: Hello World!')\n    parser.add_argument('--message_type_attributes', help='The message attributes. Default: {\"temperature\": 42}')\n    parser.add_argument('--message_type_binary', help='The message binary. Default: 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696", "CodeBleu_score": 25.015629682951936}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"A Google Cloud IoT MQTT device connection.\")\n    parser.add_argument(\"--project_id\", help=\"The Google Cloud project ID to use for this application.\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\"--subscription_id\", help=\"The Google Cloud IoT MQTT subscription ID to use for this application.\", default=os.environ.get(\"GOOGLE_CLOUD_SUBSCRIPTION_ID\"))\n    parser.add_argument(\"--registry_id\", help=\"The Google Cloud IoT MQTT registry ID to use for this application.\", default=os.environ.get(\"GOOGLE_CLOUD_REGISTRY_ID\"))\n    parser.add_argument(\"--private_key_file\", help=\"The path to the private key file to use for this application.\", default=os.environ.get(\"GOOGLE_CLOUD_PRIVATE_KEY_FILE\"))\n    parser.add_argument(\"--algorithm\", help=\"The algorithm to use for this application.\", default=os.environ.get(\"GOOGLE_CLOUD_ALGORITHM\"))\n    parser.add_argument(\"--ca_certs\", help=\"The path to the CA certificates file to use for this application.\", default=os.environ.get(\"GOOGLE_CLOUD_CA_CERTS\"))\n    parser.add_argument(\"--device_id\", help=\"The device ID to use for this application.\", default=os.environ.get(\"GOOGLE_CLOUD_DEVICE_ID\"))\n    parser.add_argument(\"--message_type\", help=\"The message type to use for this application.\", default=os.environ.get(\"GOOGLE_CLOUD_MESSAGE_TYPE\"))\n    parser.add_argument(\"--message_file\", help=\"The path to the message file to use for this application.\", default=os.environ.get(\"GOOGLE_CLOUD_MESSAGE_FILE\"))\n    return parser.parse_args()\n\n", "CodeBleu_score": 40.92174628423347}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n\n    credentials = ServiceAccountCredentials.from_json_keyfile_name(\n        service_account_json, scopes=scopes\n    )\n    credentials = credentials.create_scoped(scopes)\n\n    return build(\"cloudiot\", version, credentials=credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 20.965576022518512}, {"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    credentials = ServiceAccountCredentials.from_json_keyfile_name(service_account_json, scopes)\n    credentials = credentials.create_scoped(scopes)\n    client = discovery.build(\"cloudiot\", version, credentials=credentials, discoveryServiceUrl=discovery_url)\n    return client\n\n", "CodeBleu_score": 20.45998807174173}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    api_version = \"v1\"\n    api_discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n    service_account_json = service_account_json\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=api_scopes\n    )\n    client = discovery.build(\n        \"cloudiot\",\n        api_version,\n        credentials=credentials,\n        discoveryServiceUrl=api_discovery_url,\n    )\n    return client\n\n", "CodeBleu_score": 27.401050312580278}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t  # Get the ASN1 code for the hash method\n    hash_method_asn1 = hash_method.encode('ascii')\n\n    # Raise an error if the hash method is invalid\n    if hash_method_asn1 not in ('sha1','sha224','sha256','sha384','sha512'):\n        raise ValueError('Invalid hash method')\n\n    # Concatenate the ASN1 code with the hash value\n    message = hash_method_asn1 + hash_value\n\n    # Pad the message for signing\n    message = _pad_for_signing(message, 64)\n\n    # Encrypt the padded hash using the private key\n    signature = priv_key.encrypt(message, 'pkcs1_oaep')[0]\n\n    return signature\n\n", "CodeBleu_score": 26.082112458391066}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t   hash_method_asn1 = _hash_method_to_asn1(hash_method)\n    if not hash_method_asn1:\n        raise ValueError('Invalid hash method: %s' % hash_method)\n\n    message = hash_method_asn1 + hash_value\n    padded_message = _pad_for_signing(message, 64)\n    return priv_key.encrypt(padded_message, 'pkcs1_oaep')\n\n\n", "CodeBleu_score": 24.960870992877364}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t  if hash_method =='sha1':\n        hash_method = 0x01\n    elif hash_method =='sha224':\n        hash_method = 0x02\n    elif hash_method =='sha256':\n        hash_method = 0x03\n    elif hash_method =='sha384':\n        hash_method = 0x04\n    elif hash_method =='sha512':\n        hash_method = 0x05\n    else:\n        raise ValueError('Invalid hash method')\n\n    hash_method_asn1 = _hash_method_to_asn1(hash_method)\n\n    padded_hash = _pad_for_signing(hash_value, 16)\n\n    return _encrypt_block(padded_hash, priv_key) + hash_method_asn1\n\n\n", "CodeBleu_score": 21.8789626717218}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t  # convert signature to integer\n    signature = int.from_bytes(signature, 'big')\n\n    # decrypt signature\n    clearsig = pub_key.decrypt(signature)\n\n    # determine hash method\n    method_name = _find_method_hash(clearsig)\n\n    # compute hash\n    hash = compute_hash(message, method_name)\n\n    # reconstruct padded hash\n    padded_hash = _pad_for_signing(hash, len(clearsig))\n\n    # verify\n    if clearsig!= padded_hash:\n        raise VerificationError('Verification failed')\n\n    return method_name\n", "CodeBleu_score": 41.82828361352484}, {"code": "def verify(message, signature, pub_key)\n\t  clearsig = decrypt(signature, pub_key)\n\n    method_name = _find_method_hash(clearsig)\n\n    if method_name =='sha1':\n        expected_hash = sha1(message).digest()\n    else:\n        expected_hash = compute_hash(message, method_name)\n\n    if expected_hash!= clearsig[2:-6]:\n        raise VerificationError('Verification failed')\n\n    return method_name\n", "CodeBleu_score": 31.808013242474924}, {"code": "def verify(message, signature, pub_key)\n\t  clearsig = _decrypt(signature, pub_key)\n    hashmethod = _find_method_hash(clearsig)\n    hash_of_message = compute_hash(message, hashmethod)\n    expected_hash = _pad_for_signing(hash_of_message, len(clearsig))\n\n    if clearsig!= expected_hash:\n        raise VerificationError('Verification failed')\n\n    return hashmethod\n\n", "CodeBleu_score": 18.12650422800082}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\ttime_t t;\n\tstruct tm *tm;\n\tuint32_t epoch;\n\tchar* mqttServer;\n\tchar* mqttPort;\n\tchar* mqttUsername;\n\tchar* mqttPassword;\n\tchar* mqttClientId;\n\tchar* mqttTopic;\n\tchar* mqttQos;\n\tchar* mqttRetain;\n\tchar* mqttCleanSession;\n\n\tmqttServer = MQTT_SERVER;\n\tmqttPort = MQTT_PORT;\n\tmqttUsername = MQTT_USERNAME;\n\tmqttPassword = ;\n\tmqttClientId = MQTT_CLIENT_ID;\n\tmqttTopic = MQTT_TOPIC;\n\tmqttQos = MQTT_QOS;\n\tmqttRetain = MQTT_RETAIN;\n\tmqttCleanSession = MQTT_CLEAN_SESSION;\n\n\tdebug_printInfo(\"MQTT: mqttServer=%s\", mqttServer);\n\tdebug_printInfo(\"MQTT: mqttPort=%s\", mqttPort);\n\tdebug_printInfo(\"MQTT: mqttUsername=%s\", mqttUsername);\n\tdebug_printInfo(\"MQTT: mqttPassword=%s\", mqttPassword);\n\tdebug_printInfo(\"MQTT: mqttClientId=%s\", mqttClientId);\n\tdebug_printInfo(\"MQTT: mqttTopic=%s\", mqttTopic);\n\tdebug_printInfo(\"MQTT: mqttQos=%s\", mqttQos);\n\tdebug_printInfo(\"MQTT: mqttRetain=%s\", mqttRetain);\n\tdebug_printInfo(\"MQTT: mqttCleanSession=%s\", mqttCleanSession);\n\n\t/* Get the current time */\n\tt = time(NULL);\n\ttm = localtime(&t);\n\tif (tm == NULL) {\n\t\tdebug_printInfo(\"MQTT: Error getting local time\");\n\t\treturn;\n\t}\n\tepoch = mktime(tm);\n\n\t/* Update the JWT */\n\tupdateJWT(epoch);\n\n\t/* Connect to the MQTT client */\n\tmqtt_connect(mqttServer, mqttPort, mqttUsername, mqttPassword, mqttClientId, mqttTopic, mqttQos, mqttRetain, mqttCleanSession);\n\n\t/* Set a flag to send a SUBSCRIBE packet after the connection is established */\n\tmqtt_subscribe_flag = 1;\n\n\tdebug_printInfo(\"MQTT: MQTT connection established\");\n}", "CodeBleu_score": 36.74375653496904}, {"code": "static void connectMQTT(){\n\t\ttime_t t = time(NULL);\n\tif (t == -1) {\n\t\tdebug_printError(\"Error getting the time\");\n\t\treturn;\n\t}\n\tupdateJWT(t);\n\tif (MQTT_CLIENT_connect(cid, mqttTopic, mqttPassword, NULL) == 0) {\n\t\tdebug_printInfo(\"MQTT: Connected\");\n\t\tmqttConnected = 1;\n\t\tsendMQTTSubscribe();\n\t} else {\n\t\tdebug_printError(\"MQTT: Error connecting\");\n\t}\n}", "CodeBleu_score": 48.54934846489966}, {"code": "static void connectMQTT(){\n\t\ttime_t t = time(NULL);\n\tif (t == -1) {\n\t\tdebug_printError(\"Failed to get current time\");\n\t\treturn;\n\t}\n\tt -= UNIX_OFFSET;\n\tupdateJWT(t);\n\tdebug_printInfo(\"MQTT: Connecting to MQTT server at %s\", mqttServer);\n\tint res = mqtt_connect(mqttServer, mqttPort, mqttUsername, mqttPassword, mqttClientId, mqttTopic, 1, 1, 1, 1);\n\tif (res!= 0) {\n\t\tdebug_printError(\"Failed to connect to MQTT server\");\n\t\treturn;\n\t}\n\tmqtt_subscribe(mqttTopic);\n\tdebug_printInfo(\"MQTT: Connected to MQTT server\");\n}", "CodeBleu_score": 43.940388703336396}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t n = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9')\n\t\t\treturn str;\n\t\tn *= 10;\n\t\tn += str[i] - '0';\n\t}\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 24.29961393853747}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tresult *= 10;\n\t\tresult += str[i] - '0';\n\t}\n\t*num = result;\n\treturn str + width;\n}", "CodeBleu_score": 26.400140065656387}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t val = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (!isdigit(*str)) {\n\t\t\treturn str;\n\t\t}\n\t\tval = val * 10 + (*str - '0');\n\t\tif (val > UINT32_MAX) {\n\t\t\treturn str;\n\t\t}\n\t\tstr++;\n\t}\n\t*num = val;\n\treturn str;\n}", "CodeBleu_score": 31.785912916803515}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t#ifdef ATCACERT_HW_ACCEL\n    return atcacert_verify_cert_hw_accel(cert_def, cert, cert_size, ca_public_key);\n#else\n    return ATCACERT_E_HW_ACCEL_NOT_ENABLED;\n#endif\n}", "CodeBleu_score": 16.38041554369496}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\n\t// Check for null parameters\n\tif (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n\t\treturn ATCA_BAD_PARAM;\n\t}\n\n\t// Verify the certificate\n\tret = atcacert_verify_cert_internal(cert_def, cert, cert_size, ca_public_key, 1);\n\n\treturn ret;\n}", "CodeBleu_score": 28.620001319499167}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tif (list == NULL) {\n\t\treturn false;\n\t}\n\tif (timer == NULL) {\n\t\treturn false;\n\t}\n\n\tif (*list == NULL) {\n\t\treturn false;\n\t}\n\n\tif (*list == timer) {\n\t\t*list = (*list)->next;\n\t\treturn true;\n\t}\n\n\ttimerStruct_t *prev = *list;\n\twhile (prev->next!= NULL) {\n\t\tif (prev->next == timer) {\n\t\t\tprev->next = timer->next;\n\t\t\treturn true;\n\t\t}\n\t\tprev = prev->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.4965996267996}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t", "CodeBleu_score": 4.569190813842367}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\tbool result = false;\n\tif (timer!= NULL)\n\t{\n\t\tif (timer->next!= NULL)\n\t\t{\n\t\t\ttimer->next->prev = timer->prev;\n\t\t}\n\t\tif (timer->prev!= NULL)\n\t\t{\n\t\t\ttimer->prev->next = timer->next;\n\t\t}\n\t\tif (timer == *list)\n\t\t{\n\t\t\t*list = timer->next;\n\t\t}\n\t\tif (timer == listHead)\n\t\t{\n\t\t\tlistHead = timer->next;\n\t\t}\n\t\tif (timer == listTail)\n\t\t{\n\t\t\tlistTail = timer->prev;\n\t\t}\n\t\ttimer->prev = NULL;\n\t\ttimer->next = NULL;\n\t\tresult = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 35.64587000371583}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tint s8Ret = BSD_ERROR;\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\tuint8\tu8Cmd = SOCKET_CMD_CLOSE;\n\t\ttstrCloseCmd strclose;\n\t\tstrclose.sock = socket; \n\t\tstrclose.u16SessionID\t\t= gastrSockets[socket].u16SessionID;\n\t\t\n\t\tgastrSockets[socket].bIsUsed = 0;\n\t\tgastrSockets[socket].u16SessionID =0;\n\t\t\n\t\tif(gastrSockets[socket].u8SSLFlags & SSL_FLAGS_ACTIVE)\n\t\t{\n\t\t\tu8Cmd = SOCKET_CMD_SSL_CLOSE;\n\t\t}\n\t\ts8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);\n\t\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t}\n\t\tm2m_memset((uint8*)&gastrSockets[socket], 0, sizeof(tstrSocket));\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 38.39460095999161}, {"code": "int BSD_close(int socket){\n\tint\t\tret = BSD_SUCCESS;\n\tif(socket < 0 || socket >= MAX_SOCKETS)\n\t{\n\t\tret = BSD_ERROR;\n\t\tbsd_setErrNo(BSD_ERR_INVALID_SOCKET);\n\t}\n\telse\n\t{\n\t\tif(gastrSockets[socket].bIsUsed == 1)\n\t\t{\n\t\t\tret = close(socket);\n\t\t\tif(ret!= SOCK_ERR_NO_ERROR)\n\t\t\t{\n\t\t\t\tret = BSD_ERROR;\n\t\t\t\tbsd_setErrNo(BSD_ERR_SOCKET_CLOSE);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = BSD_ERROR;\n\t\t\tbsd_setErrNo(BSD_ERR_SOCKET_NOT_USED);\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 30.57795356961496}, {"code": "int BSD_close(int socket){\n\tif(socket < 0 || socket >= MAX_SOCKETS)\n\t{\n\t\tbsd_setErrNo(BSD_INVALID_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\tif(gastrSockets[socket].bIsUsed == 0)\n\t{\n\t\tbsd_setErrNo(BSD_NOT_A_SOCKET);\n\t\treturn BSD_ERROR;\n\t}\n\tif(gastrSockets[socket].bIsUsed == 1)\n\t{\n\t\tsint8 s8Ret = close(socket);\n\t\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tbsd_setErrNo(BSD_SOCKET_ERROR);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\tgastrSockets[socket].bIsUsed = 0;\n\tgastrSockets[socket].u16SessionID =0;\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 41.67008872500494}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tint\ts8Ret = BSD_ERROR;\n\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\ts8Ret = listen(socket, backlog);\n\t\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tbsd_setErrNo(s8Ret);\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 26.371560791120768}, {"code": "int BSD_listen(int socket, int backlog){\n\tint\ts8Ret = BSD_ERROR;\n\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\ttstrListenCmd\t\tstrListen;\n\n\t\tstrListen.sock = socket;\n\t\tstrListen.u8BackLog = backlog;\n\t\tstrListen.u16SessionID\t\t= gastrSockets[socket].u16SessionID;\n\n\t\ts8Ret = SOCKET_REQUEST(SOCKET_CMD_LISTEN, (uint8*)&strListen, sizeof(tstrListenCmd), NULL, 0, 0);\n\t\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 35.72132757880031}, {"code": "int BSD_listen(int socket, int backlog){\n\tint s8Ret = BSD_ERROR;\n\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\ttstrListenCmd\t\tstrListen;\n\n\t\tstrListen.sock = socket;\n\t\tstrListen.u8BackLog = backlog;\n\t\tstrListen.u16SessionID\t\t= gastrSockets[socket].u16SessionID;\n\n\t\ts8Ret = SOCKET_REQUEST(SOCKET_CMD_LISTEN, (uint8*)&strListen, sizeof(tstrListenCmd), NULL, 0, 0);\n\t\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 35.72720233714294}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint s32Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(gastrSockets[socket].s32Family == AF_INET)\n\t\t{\n\t\t\ts32Ret = accept(socket, (struct sockaddr *)addr, (uint8 *)addrlen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts32Ret = SOCK_ERR_UNSUPPORTED_FAMILY;\n\t\t}\n\t}\n\treturn s32Ret;\n}", "CodeBleu_score": 23.553972470135538}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint\t\ts32Ret = SOCK_ERR_INVALID_ARG;\n\tuint8\tu8AddrLen = 0;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(gastrSockets[socket].s32Family == AF_INET)\n\t\t{\n\t\t\tif(addr!= NULL)\n\t\t\t{\n\t\t\t\tif(addrlen!= NULL)\n\t\t\t\t{\n\t\t\t\t\tu8AddrLen = *addrlen;\n\t\t\t\t\tif(u8AddrLen == sizeof(struct sockaddr_in))\n\t\t\t\t\t{\n\t\t\t\t\t\tstruct sockaddr_in *pstrAddr = (struct sockaddr_in *)addr;\n\t\t\t\t\t\tpstrAddr->sin_family = AF_INET;\n\t\t\t\t\t\tpstrAddr->sin_port = htons(gastrSockets[socket].u16Port);\n\t\t\t\t\t\tpstrAddr->sin_addr.s_addr = gastrSockets[socket].u32IP;\n\t\t\t\t\t\ts32Ret = SOCK_ERR_NO_ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(gastrSockets[socket].s32Family == AF_INET6)\n\t\t{\n\t\t\tif(addr!= NULL)\n\t\t\t{\n\t\t\t\tif(addrlen!= NULL)\n\t\t\t\t{\n\t\t\t\t\tu8AddrLen = *addrlen;\n\t\t\t\t\tif(u8AddrLen == sizeof(struct sockaddr_in6))\n\t\t\t\t\t{\n\t\t\t\t\t\tstruct sockaddr_in6 *pstrAddr = (struct sockaddr_in6 *)addr;\n\t\t\t\t\t\tpstrAddr->sin6_family = AF_INET6;\n\t\t\t\t\t\tpstrAddr->sin6_port = htons(gastrSockets[socket].u16Port);\n\t\t\t\t\t\tpstrAddr->sin6_addr = gastrSockets[socket].u32IP;\n\t\t\t\t\t\ts32Ret = SOCK_ERR_NO_ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn s32Ret;\n}", "CodeBleu_score": 37.49291600917939}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint s8Ret = SOCK_ERR_INVALID_ARG;\n\tstruct bsd_sockaddr_in *pAddr = (struct bsd_sockaddr_in *)addr;\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(pAddr->sa_family == AF_INET)\n\t\t{\n\t\t\ts8Ret = accept(socket, (struct sockaddr *)addr, (uint8 *)addrlen);\n\t\t\tif(s8Ret == SOCK_ERR_NO_ERROR)\n\t\t\t{\n\t\t\t\tgastrSockets[socket].s8Status = SOCK_STATUS_CONNECTED;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 31.499843451882075}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\ttime_t now = time(NULL);\n\tdebug_printInfo(\"MQTT: Connecting to MQTT broker at %s\", ctime(&now));\n\tif (now < UNIX_OFFSET) {\n\t\tdebug_printError(\"MQTT: Invalid time, skipping MQTT connection\");\n\t\treturn;\n\t}\n\tupdateJWT(now);\n\tdebug_printInfo(\"MQTT: Connecting to MQTT broker at %s\", ctime(&now));\n\tif (MQTT_connect(mqttClient, mqttServer, mqttPort, mqttUser, mqttPassword, mqttTopic, 1, 1) == 0) {\n\t\tdebug_printInfo(\"MQTT: Connected to MQTT broker at %s\", ctime(&now));\n\t\tsendMQTTSubscribe();\n\t}\n}", "CodeBleu_score": 44.73349672506147}, {"code": "static void connectMQTT(){\n\t\ttime_t t;\n\ttime(&t);\n\tif (t < UNIX_OFFSET) {\n\t\tdebug_printError(\"MQTT: Invalid time (%s)\", ctime(&t));\n\t\treturn;\n\t}\n\tupdateJWT(t);\n\tdebug_printInfo(\"MQTT: Connecting to MQTT server...\");\n\tif (MQTT_connect()) {\n\t\tdebug_printInfo(\"MQTT: Connection established\");\n\t\tsendSubscribe = true;\n\t}\n}", "CodeBleu_score": 48.1603869360474}, {"code": "static void connectMQTT(){\n\t\ttime_t t;\n\ttime(&t);\n\tdebug_printInfo(\"MQTT: Connecting to MQTT broker at %s\", ctime(&t));\n\tif (timeValid) {\n\t\tupdateJWT(t);\n\t\tdebug_printInfo(\"MQTT: Connected to MQTT broker at %s\", ctime(&t));\n\t\tmqtt_connected = true;\n\t\tmqtt_subscribe = true;\n\t}\n}", "CodeBleu_score": 40.14105021766412}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t#ifdef DEBUG\n   printf(\"CLOUD_disconnect: MQTT_Disconnect\n\");\n#endif\n\n   MQTT_Disconnect(&mqttContext);\n}", "CodeBleu_score": 17.035118489348218}, {"code": "void CLOUD_disconnect(void){\n\t\tMQTT_Disconnect(&mqttContext);\n}", "CodeBleu_score": 4.523282929328049}, {"code": "void CLOUD_disconnect(void){\n\t\tMQTT_Disconnect(mqttContext);\n}", "CodeBleu_score": 4.482085983976874}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif (passed_wifi_creds) {\n\t\treturn m2m_wifi_connect_sc(wifi_ssid, strlen(wifi_ssid), wifi_sec_type, wifi_auth_info, wifi_ch, 0);\n\t}\n\telse {\n\t\treturn m2m_wifi_default_connect();\n\t}\n}", "CodeBleu_score": 34.22244973515546}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t\t// Create a client instance\n\tconst client = new GraphQLClient(endpoint, {\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: 'Bearer'+ token,\n\t\t},\n\t});\n\n\t// Send a GraphQL query to fetch sensor data\n\tconst query = `\n\tquery Sensors {\n\t\tsensors {\n\t\t\tid\n\t\t\tname\n\t\t\tlocation {\n\t\t\t\tlat\n\t\t\t\tlng\n\t\t\t}\n\t\t}\n\t}\n\t`;\n\n\tconst response = await client.request(query);\n\n\t// Log the response\n\tconsole.log(response);\n\n\t// If the response contains data, log the retrieval of sensors\n\tif (response.sensors) {\n\t\tconsole.log('Retrieved sensors:');\n\n\t\t// Iterate through each sensor\n\t\tfor (const sensor of response.sensors) {\n\t\t\t// Create a marker for the sensor\n\t\t\tconst marker = new google.maps.Marker({\n\t\t\t\tposition: sensor.location,\n\t\t\t\tmap: map,\n\t\t\t\ttitle: sensor.name,\n\t\t\t});\n\n\t\t\t// Log the creation of the marker\n\t\t\tconsole.log(`Created marker for sensor ${sensor.name}`);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.11492913566053}, {"code": "async function DisplaySensors(map){\n\t\t// Create a GraphQL client\n\tconst client = new GraphQLClient(endpoint, {\n\t\theaders: {\n\t\t\t\"x-hasura-admin-secret\": adminSecret,\n\t\t},\n\t});\n\n\t// Create a GraphQL query\n\tconst query = `query {\n\t\tsensors {\n\t\t\tid\n\t\t\tname\n\t\t\tlatitude\n\t\t\tlongitude\n\t\t}\n\t}`;\n\n\t// Send the query to the server\n\tconst result = await client.request(query);\n\n\t// Check if the response contains data\n\tif (result.data) {\n\t\t// Log the retrieval of sensors\n\t\tconsole.log(\"Retrieved sensors:\");\n\n\t\t// Iterate through each sensor\n\t\tfor (const sensor of result.data.sensors) {\n\t\t\t// Create a marker for the sensor\n\t\t\tconst marker = new mapboxgl.Marker()\n\t\t\t\t.setLngLat([sensor.longitude, sensor.latitude])\n\t\t\t\t.setPopup(new mapboxgl.Popup({ offset: 25 }).setHTML(`<h3>${sensor.name}</h3>`))\n\t\t\t\t.addTo(map);\n\n\t\t\t// Log the creation of a marker\n\t\t\tconsole.log(`Created marker for sensor ${sensor.name}`);\n\t\t}\n\t} else {\n\t\t// Log an error if the response does not contain data\n\t\tconsole.error(\"Error: No data returned from the server.\");\n\t}\n}", "CodeBleu_score": 34.480944207800825}, {"code": "async function DisplaySensors(map){\n\t\t// Create a client to make requests to the API\n\tconst client = new GraphQLClient(apiUrl, {\n\t\theaders: {\n\t\t\t\"X-Api-Key\": apiKey\n\t\t}\n\t});\n\n\t// Send a query to the API to retrieve sensor data\n\tconst query = `{\n\t\tsensors {\n\t\t\tid\n\t\t\tname\n\t\t\tlatitude\n\t\t\tlongitude\n\t\t}\n\t}`;\n\n\tconst response = await client.request(query);\n\n\t// Log the API response\n\tconsole.log(\"API response:\", response);\n\n\t// Check if the response contains data\n\tif (response.sensors) {\n\t\t// Log the retrieval of sensors\n\t\tconsole.log(\"Retrieved sensors:\");\n\n\t\t// Iterate through each sensor\n\t\tfor (const sensor of response.sensors) {\n\t\t\t// Create a marker for the sensor\n\t\t\tconst marker = new mapboxgl.Marker({\n\t\t\t\tcolor: \"red\"\n\t\t\t})\n\t\t\t\t.setLngLat([sensor.longitude, sensor.latitude])\n\t\t\t\t.setPopup(new mapboxgl.Popup({ offset: 25 }).setHTML(`<h3>${sensor.name}</h3>`))\n\t\t\t\t.addTo(map);\n\n\t\t\t// Log the creation of a marker for the sensor\n\t\t\tconsole.log(`Created marker for sensor ${sensor.name}`);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.1375395956802}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.uniqueId;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 45.48577476532191}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='marker';\n\tmarker.style.backgroundColor ='red';\n\tmarker.style.border ='solid 1px black';\n\treturn marker;\n}", "CodeBleu_score": 43.134364331471474}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.border = \"solid 1px black\";\n\treturn marker;\n}", "CodeBleu_score": 46.84899955126839}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Unable to load MFA module: %s\", module_path)\n        raise\n    except Exception as err:\n        _LOGGER.error(\"Error loading MFA module: %s\", err)\n        raise\n    return module\n", "CodeBleu_score": 23.22674146411049}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Unable to load multi-factor authentication (MFA) module %s: %s\",\n            module_name,\n            err,\n        )\n        raise\n    except Exception as err:\n        _LOGGER.error(\n            \"Unable to load multi-factor authentication (MFA) module %s: %s\",\n            module_name,\n            err,\n        )\n        raise\n    return module\n", "CodeBleu_score": 33.55188097937506}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{module_name}.py\"\n    if module_path in hass.data[DATA_MFA_MODULE_PATHS]:\n        return sys.modules[module_path]\n\n    if not hass.config.skip_pip:\n        requirements = _get_mfa_requirements(module_name)\n        if requirements:\n            await _process_mfa_requirements(hass, module_name, requirements)\n\n    module = _import_module(hass, module_name)\n    hass.data[DATA_MFA_MODULE_PATHS].add(module_path)\n    return module\n\n", "CodeBleu_score": 29.61642454173326}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    # Check if the user already has an entry in the internal data list\n    if user_id in self._data:\n        # Update the PIN for the user\n        self._data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        # Add a new entry to the internal data list\n        self._data[user_id] = {\"pin\": setup_data[\"pin\"]}\n    return True\n\n", "CodeBleu_score": 36.05356085960978}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n    return self.data[user_id]\n\n", "CodeBleu_score": 37.8432738437107}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if not self._is_valid_user_id(user_id):\n        _LOGGER.error(\"User ID is not valid\")\n        return False\n    if self._is_user_id_in_list(user_id):\n        self._update_user_pin(user_id, setup_data)\n        return True\n    else:\n        self._add_user_to_list(user_id, setup_data)\n        return True\n\n", "CodeBleu_score": 28.03510337193325}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    if not self._init_lock.acquire(timeout=0):\n        return\n    try:\n        if self._data is None:\n            self._data = await self._store.async_load()\n            self._data = {} if self._data is None else self._data\n            for user_id in self._data:\n                self._data[user_id] = NotifySetting(\n                    self._hass,\n                    user_id,\n                    self._data[user_id][\"name\"],\n                    self._data[user_id][\"mode\"],\n                    self._data[user_id][\"method\"],\n                    self._data[user_id][\"data\"],\n                    self._data[user_id][\"message_format\"],\n                    self._data[user_id][\"message_template\"],\n                )\n    finally:\n        self._init_lock.release()\n\n", "CodeBleu_score": 27.45943084230906}, {"code": "async def _async_load(self) -> None\n\t\n    if self._lock.locked():\n        return\n\n    async with self._lock:\n        if self._states_data:\n            return\n\n        self._states_data = {}\n\n        if not (data := await self._store.async_load()):\n            self._states_data = {}\n            return\n\n        self._states_data = {\n            entity_id: State(\n                state=data.get(entity_id),\n                attributes=data.get(entity_id + \"_attributes\", {}),\n            )\n            for entity_id in data\n        }\n\n", "CodeBleu_score": 34.46889044910213}, {"code": "async def _async_load(self) -> None\n\t\n    if not self._is_loaded:\n        if self._lock.locked():\n            return\n        async with self._lock:\n            if self._is_loaded:\n                return\n            if not self._store:\n                self._store = UserStore(self._hass)\n            await self._store.async_load()\n            self._is_loaded = True\n\n", "CodeBleu_score": 25.9993270077953}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    user_input = user_input.copy()\n    user_input.setdefault(\"otp\", \"\")\n    user_input.setdefault(\"otp_code\", \"\")\n    user_input.setdefault(\"otp_token\", \"\")\n    user_input.setdefault(\"otp_token_code\", \"\")\n    user_input.setdefault(\"otp_token_code_type\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type_code\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type_code_type\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type_code_type_code\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type_code_type_code_type\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type_code_type_code_type_code\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type_code_type_code_type_code_type\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type_code_type_code_type_code_type_code\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type_code_type_code_type_code_type_code_type\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type_code_type_code_type_code_type_code_type_code\", \"\")\n    user_input.setdefault(\"otp_token_code_type_code_type_code_type_code_type_code_type_code_type_code_type_code_type\", \"\")\n    user_", "CodeBleu_score": 24.413840640944866}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    user_settings = await self.get_user_settings(user_id)\n    if not user_settings:\n        return False\n    user_input_otp = user_input.get(\"otp\")\n    if not user_input_otp:\n        return False\n    user_input_otp = user_input_otp.strip()\n    if not user_input_otp:\n        return False\n    user_input_otp = user_input_otp.upper()\n    if not user_input_otp:\n        return False\n    if len(user_input_otp)!= 6:\n        return False\n    if not user_settings.get(\"otp_enabled\"):\n        return False\n    otp_secret = user_settings.get(\"otp_secret\")\n    if not otp_secret:\n        return False\n    otp_secret = otp_secret.strip()\n    if not otp_secret:\n        return False\n    if len(otp_secret)!= 16:\n        return False\n    if not user_settings.get(\"otp_issuer\"):\n        return False\n    otp_issuer = user_settings.get(\"otp_issuer\")\n    if not otp_issuer:\n        return False\n    otp_issuer = otp_issuer.strip()\n    if not otp_issuer:\n        return False\n    if len(otp_issuer) > 100:\n        return False\n    otp_issuer = otp_issuer.upper()\n    if not otp_issuer:\n        return False\n    otp_issuer = otp_issuer.replace(\" \", \"\")\n    if not otp_issuer:\n        return False\n    if len(otp_issuer) > 100:\n        return False\n    otp_issuer = otp_issuer.replace(\" \", \"\")\n    if not otp_issuer:\n        return False\n    otp_issuer = otp_issuer.replace(\"'\", \"\")\n    if not otp_issuer:\n        return False\n    if len(otp_issuer) > 100:\n        return False\n    otp_issuer = otp_issuer.replace(\"'\", \"\")\n    if not otp_issuer:\n        return False\n    if len(otp_issuer) > 100:\n        return False\n    otp_issuer = otp_issuer.replace(\"'\", \"\")\n    if not otp_issuer:\n        return False\n    if len(otp_issuer) > 100:", "CodeBleu_score": 33.854107819806266}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if not self._user_settings:\n        await self.async_load_user_settings()\n    return await self._validate_user_input(user_id, user_input)", "CodeBleu_score": 28.321270217027294}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device:\n        return None\n    area = area_dict.get(device.area_id)\n    if not area:\n        return None\n    return area.permissions\n\n", "CodeBleu_score": 48.57083409156943}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 51.19814157655775}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.390134801419954}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_ in policies:\n        if policy_ is None:\n            continue\n        assert isinstance(policy_, dict)\n        for category in policy_:\n            if category in seen:\n                continue\n            seen.add(category)\n            category_sources = [policy_.get(category) for policy_ in policies if isinstance(policy_, dict)]\n            policy[category] = _merge_policies(category_sources)\n\n    return policy\n\n", "CodeBleu_score": 58.00080209250913}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for p in policies:\n        for category in p:\n            if category in seen:\n                continue\n            seen.add(category)\n            policy[category] = _merge_policies([p[category], policy.get(category)])\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 58.47296911201659}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_ in policies:\n        for category in policy_:\n            if category in seen:\n                continue\n            seen.add(category)\n            policy[category] = _merge_policies([policy_.get(category) for policy_ in policies if isinstance(policy_, dict)])\n\n    return policy\n\n", "CodeBleu_score": 64.0634864555692}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in hass.data[DATA_AUTH_PROVIDER_MODULES]:\n        return hass.data[DATA_AUTH_PROVIDER_MODULES][provider]\n\n    if provider in hass.data[DATA_AUTH_PROVIDER_FAILURES]:\n        raise HomeAssistantError(\n            f\"Failed to load {provider} auth provider module: {hass.data[DATA_AUTH_PROVIDER_FAILURES][provider]}\"\n        )\n\n    if provider in hass.data[DATA_AUTH_PROVIDER_FUTURES]:\n        return await hass.data[DATA_AUTH_PROVIDER_FUTURES][provider]\n\n    if provider in sys.modules:\n        return _get_module(hass.data[DATA_AUTH_PROVIDER_MODULES], provider)\n\n    import_future = hass.loop.create_future()\n    hass.data[DATA_AUTH_PROVIDER_FUTURES][provider] = import_future\n    try:\n        module = await hass.async_add_executor_job(_get_module, hass.data[DATA_AUTH_PROVIDER_MODULES], provider)\n        import_future.set_result(module)\n    except BaseException as ex:\n        if isinstance(ex, ModuleNotFoundError):\n            hass.data[DATA_AUTH_PROVIDER_FAILURES][provider] = str(ex)\n        import_future.set_exception(ex)\n        with suppress(BaseException):\n            # Set the exception retrieved flag on the future since\n            # it will never be retrieved unless there\n            # are concurrent calls\n            import_future.result()\n        raise\n    finally:\n        del hass.data[DATA_AUTH_PROVIDER_FUTURES][provider]\n\n    return module", "CodeBleu_score": 36.81834292249901}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in hass.data[DATA_AUTH_PROVIDER_MODULES]:\n        return hass.data[DATA_AUTH_PROVIDER_MODULES][provider]\n\n    # If the module has been processed, skip it\n    if provider in hass.data[DATA_AUTH_PROVIDER_PROCESSED]:\n        return hass.data[DATA_AUTH_PROVIDER_PROCESSED][provider]\n\n    # Attempt to import the module\n    try:\n        module = await async_import_module(hass, provider)\n    except ModuleNotFoundError as ex:\n        raise HomeAssistantError(\n            f\"Unable to load authentication provider module {provider}: {ex}\"\n        ) from ex\n\n    # Add the module to the processed modules set\n    hass.data[DATA_AUTH_PROVIDER_PROCESSED].add(provider)\n\n    # Get the module's requirements\n    requirements = getattr(module, \"REQUIREMENTS\", None)\n\n    # If the requirements are not specified, return the module\n    if requirements is None:\n        hass.data[DATA_AUTH_PROVIDER_MODULES][provider] = module\n        return module\n\n    # If the requirements are empty, return the module\n    if not requirements:\n        hass.data[DATA_AUTH_PROVIDER_MODULES][provider] = module\n        return module\n\n    # If the requirements are specified, process them\n    processed_requirements = set()\n    for requirement in requirements:\n        # If the requirement has already been processed, skip it\n        if requirement in processed_requirements:\n            continue\n\n        # If the requirement is a module, import it\n        if \".\" not in requirement:\n            try:\n                await async_import_module(hass, requirement)\n            except ModuleNotFoundError as ex:\n                raise HomeAssistantError(\n                    f\"Unable to load authentication provider module {provider}: {ex}\"\n                ) from ex\n\n        # Add the requirement to the processed requirements set\n        processed_requirements.add(requirement)\n\n    # Add the module to the processed modules set\n    hass.data[DATA_AUTH_PROVIDER_MODULES][provider] = module\n\n    return module", "CodeBleu_score": 43.670061573035625}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in hass.data[DATA_AUTH_PROVIDER_MODULES]:\n        return hass.data[DATA_AUTH_PROVIDER_MODULES][provider]\n\n    module = await async_import_module(hass, AUTH_PROVIDER_MODULES[provider])\n    hass.data[DATA_AUTH_PROVIDER_MODULES][provider] = module\n    return module\n", "CodeBleu_score": 18.513798659397878}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = user.password_hash\n            if bcrypt.checkpw(password.encode(), stored_hash.encode()):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    raise InvalidAuth(\"Invalid username\")\n\n", "CodeBleu_score": 34.41881314408011}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.strip()\n    if not username:\n        raise InvalidAuth(\"Username cannot be empty\")\n    if not password:\n        raise InvalidAuth(\"Password cannot be empty\")\n    if not self.users.get(username):\n        with open(self.path, \"rb\") as f:\n            f.seek(0)\n            f.read(1)\n        raise InvalidAuth(\"Invalid username or password\")\n    with open(self.path, \"rb\") as f:\n        f.seek(self.users[username])\n        stored_hash = f.read(self.hash_size)\n    if not bcrypt.checkpw(password.encode(), stored_hash):\n        raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 33.70407369706093}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = user[\"password\"]\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n        elif user[\"username\"] == username and not bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n            raise InvalidAuth(\"Invalid username\")\n    raise InvalidAuth(\"Invalid username\")\n\n", "CodeBleu_score": 36.21014737930805}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    self.users = [user for user in self.users if user.username!= username]\n\n", "CodeBleu_score": 12.720204174423678}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    normalized_username = self.normalize_username(username)\n    for user in self.users:\n        if user.username == normalized_username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(f\"user_not_found: {username}\")\n\n", "CodeBleu_score": 28.90638394140827}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n   ...\n\n", "CodeBleu_score": 5.037878787878788}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        await self.async_initialize()\n    try:\n        self._data.pop(credentials.username)\n    except KeyError:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 50.11066189779676}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        self._data = await self._store.async_load()\n    try:\n        self._data.pop(credentials.username)\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 48.93284369719496}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    try:\n        self._data = await self._store.async_load()\n        self._data.pop(credentials.username, None)\n        await self.async_save()\n    except (OSError, ValueError):\n        pass", "CodeBleu_score": 42.02204382282132}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident is None:\n                joined_threads.add(thread)\n            else:\n                thread_timeout = timeout / len(threads)\n                try:\n                    thread.join(thread_timeout)\n                except Exception:\n                    _LOGGER.warning(\n                        \"Thread[%s] failed to join within timeout: %s\",\n                        thread.name,\n                        thread_timeout,\n                    )\n                else:\n                    joined_threads.add(thread)\n    if log:\n        for thread in threads - joined_threads:\n            if thread.ident is None:\n                _LOGGER.warning(\"Thread[%s] is not alive\", thread.name)\n            else:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n    if joined_threads:\n        _LOGGER.debug(\n            \"Successfully joined %s threads\",\n            len(joined_threads),\n        )\n    else:\n        _LOGGER.debug(\"No threads joined\")\n    for thread in threads - joined_threads:\n        try:\n            thread.raise_exception(SystemExit)\n        except Exception:\n            _LOGGER.warning(\n                \"Thread[%s] failed to raise SystemExit exception\",\n                thread.name,\n            )\n    return joined_threads", "CodeBleu_score": 45.38656133361493}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread_timeout = timeout\n            if thread.ident is not None:\n                thread_timeout = min(thread_timeout, thread.join(thread_timeout))\n            try:\n                thread.join(thread_timeout)\n                joined_threads.add(thread)\n            except RuntimeError:\n                _LOGGER.warning(\n                    \"Thread[%s] is still running after timeout: %s\",\n                    thread.name,\n                    thread_timeout,\n                )\n            except Exception:\n                _LOGGER.exception(\n                    \"Thread[%s] is still running after timeout: %s\",\n                    thread.name,\n                    thread_timeout,\n                )\n    if log:\n        for thread in threads:\n            if thread not in joined_threads:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n    for thread in threads:\n        if thread not in joined_threads:\n            try:\n                thread.raise_exception(SystemExit(0))\n            except RuntimeError:\n                _LOGGER.warning(\n                    \"Thread[%s] could not be interrupted: %s\",\n                    thread.name,\n                    thread,\n                )\n            except Exception:\n                _LOGGER.exception(\n                    \"Thread[%s] could not be interrupted: %s\",\n                    thread.name,\n                    thread,\n                )\n    return joined_threads", "CodeBleu_score": 42.49095648370576}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads = set()\n    for thread in threads:\n        thread_timeout = timeout\n        if thread.ident is None:\n            joined_threads.add(thread)\n            continue\n        if thread.is_alive():\n            thread_timeout = thread.join(timeout)\n        if thread_timeout is not None:\n            joined_threads.add(thread)\n        elif log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    if log:\n        for thread in threads - joined_threads:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    if joined_threads:\n        raise SystemExit\n    return joined_threads\n\n", "CodeBleu_score": 49.761129845865725}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    global threads\n    global shutdown_timeout\n    global shutdown_timeout_warning_threshold\n    global shutdown_timeout_warning_threshold_reached\n    global shutdown_timeout_warning_threshold_reached_at\n    global shutdown_timeout_warning_threshold_reached_at_thread_id\n    global shutdown_timeout_warning_threshold_reached_at_thread_name\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_id\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_name\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_pid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_ppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_pppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_ppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_pppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_ppppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_pppppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_ppppppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_pppppppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_ppppppppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_pppppppppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_ppppppppppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_pppppppppppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_ppppppppppppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_pppppppppppppppid\n    global shutdown_timeout_warning_threshold_reached_at_thread_process_pppppppppppppppid\n    global shutdown_timeout_warning_threshold_", "CodeBleu_score": 3.520532724448186}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    global _shutdown_timeout\n    global _shutdown_timeout_lock\n    global _shutdown_timeout_remaining\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock\n    global _shutdown_timeout_remaining_lock", "CodeBleu_score": 2.7517639819361452}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    global shutdown_timeout\n    global shutdown_timeout_lock\n    global shutdown_timeout_thread_lock\n    global shutdown_timeout_thread_lock_lock\n    global shutdown_timeout_thread_lock_timeout\n    global shutdown_timeout_thread_lock_timeout_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_lock\n    global shutdown_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock_timeout_thread_lock\n   ", "CodeBleu_score": 2.950361744131918}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if (\n        self._is_setup_running\n        or remaining_with_setup_started\n        and not self._is_setup_completed\n    ):\n        self._async_dispatcher.send(\n            {\n                \"remaining_with_setup_started\": remaining_with_setup_started,\n                \"is_setup_running\": self._is_setup_running,\n                \"is_setup_completed\": self._is_setup_completed,\n            }\n        )\n        self._is_setup_running = False\n        self._is_setup_completed = True\n\n def _async_dispatch_with_setup_started(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatch_with_setup_started\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 48.97897389841825}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if not remaining_with_setup_started:\n      self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n      self._async_dispatcher_signal.clear()\n      self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n      self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_signal.send(remaining_with_setup_started=remaining_with_setup_started)\n    self._async_dispatcher_signal.clear()\n    self._async_dispatcher_", "CodeBleu_score": 42.94860418797719}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if len(remaining_with_setup_started) > 0 or len(self._remaining_with_setup_started) > 0:\n      self._async_dispatcher.send(remaining_with_setup_started=remaining_with_setup_started)\n      self._remaining_with_setup_started = remaining_with_setup_started\n\n def _async_dispatch_with_setup_started(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatch_with_setup_started\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 47.478582734811766}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.bluetooth_py_path:\n        return\n\n    if config.bluetooth_py_path.is_dir():\n        config.bluetooth_py_path = config.bluetooth_py_path / \"bluetooth.py\"\n\n    if not config.bluetooth_py_path.is_file():\n        return\n\n    if not config.integrations:\n        return\n\n    bluetooth_py_content = config.bluetooth_py_path.read_text()\n\n    generated_content = generate_and_validate(integrations)\n\n    if bluetooth_py_content!= generated_content:\n        config.bluetooth_py_path.write_text(generated_content)\n        config.bluetooth_py_path.chmod(0o644)\n\n        config.error(\n            \"bluetooth.py\",\n            \"The bluetooth.py file is not up to date. Please run 'hassfest --fix' to update the file.\",\n        )\n\n", "CodeBleu_score": 41.09336220148596}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.integration_cache.bluetooth_py_content is None:\n        config.integration_cache.bluetooth_py_content = generate_and_validate(integrations)\n\n    if config.integration_cache.bluetooth_py_content!= generate_and_validate(integrations):\n        config.integration_cache.bluetooth_py_content = generate_and_validate(integrations)\n        config.integration_cache.bluetooth_py_content_error = True\n        config.integration_cache.bluetooth_py_content_error_message = (\n            \"The content of bluetooth.py is not up to date. Please run `hassfest generate-bluetooth` to fix this.\"\n        )\n\n", "CodeBleu_score": 34.515295174302814}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.get_value(\"bluetooth_generate_and_validate\"):\n        return\n\n    if not config.get_value(\"bluetooth_generate_and_validate_error_log\"):\n        config.set_value(\"bluetooth_generate_and_validate_error_log\", [])\n\n    generated_bluetooth = generate_and_validate(integrations)\n\n    if not generated_bluetooth:\n        return\n\n    current_bluetooth = config.get_value(\"bluetooth\")\n\n    if current_bluetooth!= generated_bluetooth:\n        config.set_value(\"bluetooth_generate_and_validate_error_log\", [\n            f\"The bluetooth.py file for Home Assistant is not up to date. Please run the following command to update it:\n", "CodeBleu_score": 40.44055765589827}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Get the refresh token\n\trefreshToken := d.config.RefreshToken\n\n\t// Create the request body\n\tbody := url.Values{}\n\tbody.Add(\"grant_type\", \"refresh_token\")\n\tbody.Add(\"refresh_token\", refreshToken)\n\tbody.Add(\"client_id\", d.config.AppKey)\n\tbody.Add(\"client_secret\", d.config.AppSecret)\n\n\t// Send the request\n\tresponse, err := http.PostForm(d.config.TokenEndpoint, body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Read the response body\n\tdefer response.Body.Close()\n\tdata, err := ioutil.ReadAll(response.Body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Parse the response\n\tvar tokenResponse struct {\n\t\tAccessToken  string `json:\"access_token\"`\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t\tExpiresIn    int    `json:\"expires_in\"`\n\t}\n\terr = json.Unmarshal(data, &tokenResponse)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Update the access token\n\td.config.AccessToken = tokenResponse.AccessToken\n\td.config.RefreshToken = tokenResponse.RefreshToken\n\td.config.ExpiresIn = tokenResponse.ExpiresIn\n\n\treturn nil\n}", "CodeBleu_score": 44.56481933466879}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Build the POST request\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\t// Set the request body\n\tbody := strings.NewReader(`{\"grant_type\": \"refresh_token\", \"refresh_token\": \"` + d.refreshToken + `\", \"client_id\": \"` + d.appKey + `\", \"client_secret\": \"` + d.appSecret + `\"}`)\n\treq.Body = ioutil.NopCloser(body)\n\n\t// Send the POST request\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check the response status code\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"refreshToken: error refreshing access token: status code %d\", resp.StatusCode)\n\t}\n\n\t// Parse the response body\n\tvar data map[string]interface{}\n\terr = json.NewDecoder(resp.Body).Decode(&data)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check for errors in the response\n\tif data[\"error\"]!= nil {\n\t\treturn fmt.Errorf(\"refreshToken: error refreshing access token: %v\", data[\"error\"])\n\t}\n\n\t// Update the access token\n\td.accessToken = data[\"access_token\"].(string)\n\n\treturn nil\n}", "CodeBleu_score": 45.880083091619326}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create a new request for the Dropbox OAuth2 token endpoint.\n\ttokenEndpoint := \"https://api.dropbox.com/oauth2/token\"\n\trequest, err := http.NewRequest(\"POST\", tokenEndpoint, nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers.\n\trequest.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Set the request body.\n\tform := url.Values{}\n\tform.Add(\"grant_type\", \"refresh_token\")\n\tform.Add(\"refresh_token\", d.refreshToken)\n\tform.Add(\"client_id\", d.appKey)\n\tform.Add(\"client_secret\", d.appSecret)\n\trequest.PostForm = form\n\n\t// Make the request.\n\tresponse, err := d.httpClient.Do(request)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Close the response body.\n\tdefer response.Body.Close()\n\n\t// Read the response body.\n\tbody, err := ioutil.ReadAll(response.Body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Parse the response body as JSON.\n\tvar data map[string]interface{}\n\tif err := json.Unmarshal(body, &data); err!= nil {\n\t\treturn err\n\t}\n\n\t// Extract the access token from the response.\n\taccessToken, ok := data[\"access_token\"].(string)\n\tif!ok {\n\t\treturn fmt.Errorf(\"access token not found\")\n\t}\n\n\t// Update the access token.\n\td.accessToken = accessToken\n\n\treturn nil\n}", "CodeBleu_score": 47.330861606205175}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\tvar (\n\t\terr error\n\t\treq *http.Request\n\t)\n\tif resp!= nil {\n\t\treq, err = http.NewRequest(method, url, nil)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\treq, err = http.NewRequest(method, url, nil)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treq.Header.Add(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Add(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.accessToken))\n\treq.Header.Add(\"Accept\", \"application/json\")\n\treq.Header.Add(\"User-Agent\", \"google-drive-go-sdk\")\n\tif resp!= nil {\n\t\treq.Header.Add(\"Content-Type\", \"application/json\")\n\t\treq.Header.Add(\"Accept\", \"application/json\")\n\t}\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\tresp, err = d.client.Do(req)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode == 401 {\n\t\td.refreshToken()\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\tif resp.StatusCode!= 200 {\n\t\treturn nil, fmt.Errorf(\"error response: %s\", resp.Status)\n\t}\n\tif resp.Body == nil {\n\t\treturn nil, fmt.Errorf(\"no response body\")\n\t}\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode == 200 {\n\t\tif resp.Header.Get(\"Content-Type\") == \"application/json\" {\n\t\t\tif err = json.Unmarshal(body, &resp); err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\treturn body, nil\n}", "CodeBleu_score": 44.5401801468921}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// Check if the token is expired\n\tif d.token.Expired() {\n\t\t// Refresh the token\n\t\terr := d.refreshToken()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Create the request\n\treq, err := http.NewRequest(method, url, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the authorization header\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\n\t// Execute the request\n\tresp, err = d.httpClient.Do(req)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Handle the response\n\tif resp.StatusCode >= 200 && resp.StatusCode < 300 {\n\t\t// Read the response body\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Call the callback function if provided\n\t\tif callback!= nil {\n\t\t\tcallback(resp, body)\n\t\t}\n\n\t\t// Return the response body\n\t\treturn body, nil\n\t} else if resp.StatusCode == 401 {\n\t\t// Refresh the token\n\t\terr := d.refreshToken()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Retry the request\n\t\treturn d.request(url, method, callback, resp)\n\t} else {\n\t\t// Read the response body\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Return the error\n\t\treturn nil, errors.New(string(body))\n\t}\n}", "CodeBleu_score": 53.35330765874402}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Get the request body as JSON and bind it to a struct\n\tvar requestBody UmountStorageRequestBody\n\terr := ctx.Bind(&requestBody)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, ServiceError{\n\t\t\tCode:    \"invalid_request_body\",\n\t\t\tMessage: \"Invalid request body\",\n\t\t})\n\t}\n\n\t// Validate request body\n\tif requestBody.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, ServiceError{\n\t\t\tCode:    \"invalid_request_body\",\n\t\t\tMessage: \"Mount point must not be empty\",\n\t\t})\n\t}\n\n\t// Get the storage device by mount point\n\tstorageDevice, err := GetStorageDeviceByMountPoint(requestBody.MountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, ServiceError{\n\t\t\tCode:    \"invalid_request_body\",\n\t\t\tMessage: \"Storage device not found\",\n\t\t})\n\t}\n\n\t// Unmount the storage\n\terr = storageDevice.Unmount()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, ServiceError{\n\t\t\tCode:    \"unmount_storage_failed\",\n\t\t\tMessage: \"Failed to unmount storage\",\n\t\t})\n\t}\n\n\t// Delete the storage configuration\n\terr = DeleteStorageConfiguration(requestBody.MountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, ServiceError{\n\t\t\tCode:    \"delete_storage_configuration_failed\",\n\t\t\tMessage: \"Failed to delete storage configuration\",\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, SuccessResponse{\n\t\tMessage: \"Successfully unmounted storage\",\n\t})\n}", "CodeBleu_score": 41.28462517119288}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar err error\n\tvar mount_point string\n\tvar json_data map[string]interface{}\n\tvar config_data map[string]interface{}\n\n\t// Bind JSON data from the request context to a map variable\n\tjson_data, err = ctx.Get(\"json_data\").(map[string]interface{})\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\n\t\t\t\"error\": \"Invalid JSON data\",\n\t\t})\n\t}\n\n\t// Retrieve the \"mount_point\" value from the map\n\tmount_point, ok := json_data[\"mount_point\"].(string)\n\tif!ok {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\n\t\t\t\"error\": \"Invalid JSON data\",\n\t\t})\n\t}\n\n\t// If the mount point is empty, return a client error response\n\tif mount_point == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\n\t\t\t\"error\": \"Invalid mount point\",\n\t\t})\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point\n\terr = unmountStorage(mount_point)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\n\t\t\t\"error\": \"Failed to unmount storage\",\n\t\t})\n\t}\n\n\t// Delete the corresponding configuration\n\tconfig_data, err = deleteConfig(mount_point)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\n\t\t\t\"error\": \"Failed to delete configuration\",\n\t\t})\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, config_data)\n}", "CodeBleu_score": 25.861054478075356}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar requestBody StorageUnmountRequest\n\terr := ctx.Bind(&requestBody)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\n\tmountPoint := requestBody.MountPoint\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"mount point is empty\")\n\t}\n\n\terr = umountStorage(mountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\terr = deleteStorageConfig(mountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 34.01656250630085}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing path parameter\"})\n\t}\n\n\tfile, err := os.Open(path)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\tdefer file.Close()\n\n\tstat, err := file.Stat()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Error getting file information\"})\n\t}\n\n\treturn ctx.Stream(http.StatusOK, stat.Name(), file)\n}", "CodeBleu_score": 41.71388924866341}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the path from the query parameters.\n\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing path parameter\"})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\n\t// Read the file.\n\tdata, err := ioutil.ReadFile(path)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Error reading file\"})\n\t}\n\n\t// Return the file to the client.\n\treturn ctx.JSONBlob(http.StatusOK, data)\n}", "CodeBleu_score": 40.423975132549664}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters.\n\tpath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided.\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"path is missing\"})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"file not found\"})\n\t}\n\n\t// Open the file and return it to the client.\n\tfile, err := os.Open(path)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"error opening file\"})\n\t}\n\tdefer file.Close()\n\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 40.77088495327615}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": err.Error()})\n\t}\n\n\tif err := notification.Send(message[\"name\"], message[\"message\"]); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent successfully\"})\n}", "CodeBleu_score": 43.20084220405971}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tvar msg Message\n\tif err := ctx.Bind(&msg); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\tif err := notifications.Send(ctx.Request().Context(), msg.Name, msg.Message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\": \"Message sent successfully\",\n\t})\n}", "CodeBleu_score": 44.730760419438894}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" parameter from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\t// Send the notification using the \"name\" and \"message\"\n\tif err := sendNotification(name, message); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]string{\n\t\t\"message\": \"Notification sent successfully\",\n\t})\n}", "CodeBleu_score": 51.582338942911846}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Get the WebSocket connection from the request.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the connection to the list of connections.\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service.\n\tgo sendMessages(ws)\n\n\t// Enter a loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read a message from the WebSocket connection.\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Printf(\"Message type: %d, Message: %s, Error: %v\n\", mt, message, err)\n\t}\n}", "CodeBleu_score": 47.560018537296834}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// 1. Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ctx.Response().Writer)\n\n\t// 2. Start the message sending service\n\tgo messageSendingService()\n\n\t// 3. Read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\tmessageType, message, err := ctx.Response().Reader.ReadMessage()\n\t\tif err!= nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Message type:\", messageType)\n\t\tfmt.Println(\"Message:\", string(message))\n\t\tfmt.Println(\"Error:\", err)\n\t}\n\n\t// 4. Remove the WebSocket connection from the list of connections\n\tfor i, connection := range connections {\n\t\tif connection == ctx.Response().Writer {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 37.27872003842088}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Get the WebSocket connection from the context\n\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections\n\tconnections = append(connections, conn)\n\n\t// Start the message sending service\n\tgo sendMessages(conn)\n\n\t// Loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err!= nil {\n\t\t\tfmt.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"Message type: %s\nMessage: %s\n\", conn.RemoteAddr(), message)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections\n\tfor i, c := range connections {\n\t\tif c == conn {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 39.56641945138682}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the system hardware information\n\tsystemHardwareInfo := GetSystemHardware()\n\n\t// Return the system hardware information\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 7.199903790402466}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the system hardware information.\n\tsystemHardwareInfo, err := getSystemHardwareInfo()\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Return the system hardware information.\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 10.735745837318326}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar jsonResponse map[string]interface{}\n\tvar err error\n\n\t// Get the system hardware information\n\thardwareInfo := GetSystemHardwareInfo()\n\n\t// If CPU information is available, add it to the JSON response\n\tif hardwareInfo.CPU!= nil {\n\t\tjsonResponse = map[string]interface{}{\n\t\t\t\"success\": true,\n\t\t\t\"message\": \"System hardware information retrieved successfully\",\n\t\t\t\"data\":    hardwareInfo,\n\t\t}\n\t} else {\n\t\tjsonResponse = map[string]interface{}{\n\t\t\t\"success\": false,\n\t\t\t\"message\": \"System hardware information could not be retrieved\",\n\t\t\t\"data\":    nil,\n\t\t}\n\t}\n\n\t// Return the JSON response\n\treturn ctx.JSON(http.StatusOK, jsonResponse)\n}", "CodeBleu_score": 22.8300178440697}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\t// Get a list of services matching \"casaos*\"\n\tservices, err := s.systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Separate services into running and not running lists based on their status\n\trunningServices := make([]*[]string, 0)\n\tnotRunningServices := make([]*[]string, 0)\n\tfor _, service := range services {\n\t\tif service.Status == \"running\" {\n\t\t\trunningServices = append(runningServices, &service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, &service.Name)\n\t\t}\n\t}\n\n\t// Return a map with boolean keys indicating the running status, each pointing to the corresponding list of service names\n\treturn map[bool]*[]string{\n\t\ttrue:  &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}", "CodeBleu_score": 58.90887352061356}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar services map[bool]*[]string\n\tservices = make(map[bool]*[]string)\n\tservices[true] = new([]string)\n\tservices[false] = new([]string)\n\tservices[true] = new([]string)\n\n\tservicesList, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, service := range servicesList {\n\t\tif strings.HasPrefix(service.Name, \"casaos\") {\n\t\t\tif service.Active {\n\t\t\t\t*services[true] = append(*services[true], service.Name)\n\t\t\t} else {\n\t\t\t\t*services[false] = append(*services[false], service.Name)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn services, nil\n}", "CodeBleu_score": 41.4031777485922}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tvar (\n\t\tservices []string\n\t\terr      error\n\t)\n\n\t// Get the list of services\n\tservices, err = systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a map to hold the running and not running lists\n\trunningServices := make(map[bool]*[]string)\n\n\t// Iterate through the services\n\tfor _, service := range services {\n\t\t// Check if the service name matches the pattern \"casaos*\"\n\t\tif!strings.HasPrefix(service, \"casaos\") {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check the status of the service\n\t\tstatus, err := systemctl.Status(service)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Add the service to the corresponding list\n\t\tif status == \"active\" {\n\t\t\trunningServices[true] = append(*runningServices[true], service)\n\t\t} else {\n\t\t\trunningServices[false] = append(*runningServices[false], service)\n\t\t}\n\t}\n\n\treturn runningServices, nil\n}", "CodeBleu_score": 43.82568245864515}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Get the message map as a JSON string\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Println(\"Error serializing message map to JSON: \", err)\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus\n\terr = i.bus.Publish(name, messageJSON)\n\tif err!= nil {\n\t\tlog.Println(\"Error publishing message: \", err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 28.07409892598419}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tif i.notifyBus == nil {\n\t\treturn\n\t}\n\n\t// Serialize the message values to JSON strings.\n\tjsonMessage, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to serialize message: %v\", err)\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\terr = i.notifyBus.Publish(name, string(jsonMessage))\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to publish message: %v\", err)\n\t\treturn\n\t}\n\n\tlog.Printf(\"Sent notify event: %v\", name)\n}", "CodeBleu_score": 33.33923242449616}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tvar msg = map[string]interface{}{\n\t\t\"name\": name,\n\t\t\"data\": message,\n\t}\n\tvar msgStr, err = json.Marshal(msg)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to marshal message: %v\", err)\n\t\treturn\n\t}\n\tif err := i.bus.Publish(name, msgStr); err!= nil {\n\t\tlog.Printf(\"Failed to publish message: %v\", err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 28.47443643763693}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Create the client\n\tclient := message_bus.NewClientWithResponses()\n\n\t// Attempt to retrieve the message bus address\n\taddress, err := c.runtime.GetAddress(c.busPath)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to retrieve message bus address: %v\n\", err)\n\t\tclient.SetServer(message_bus.NewServer(message_bus.NewErrorMessage(err)))\n\t\treturn client\n\t}\n\n\t// Set the client's server to the retrieved address\n\tclient.SetServer(message_bus.NewServer(address))\n\treturn client\n}", "CodeBleu_score": 38.22915990162693}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Initialize the client and attempt to retrieve the message bus address using a specified runtime path.\n\tclient, err := message_bus.NewClientWithResponses(c.runtimePath)\n\tif err!= nil {\n\t\t// If the address is not found, set the server to a default error message.\n\t\tclient.SetServer(message_bus.DefaultError)\n\t} else {\n\t\t// Otherwise, set the server to the retrieved address.\n\t\tclient.SetServer(client.Server())\n\t}\n\n\treturn client\n}", "CodeBleu_score": 24.931867508038597}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Create the client\n\tclient := message_bus.NewClientWithResponses(c.bus)\n\n\t// Attempt to retrieve the address\n\taddress, err := c.bus.GetAddress(c.runtimePath)\n\tif err!= nil {\n\t\t// Set the server to a default error message\n\t\tclient.SetServer(message_bus.DefaultErrorServer)\n\t} else {\n\t\t// Set the server to the retrieved address\n\t\tclient.SetServer(address)\n\t}\n\n\t// Return the client\n\treturn client\n}", "CodeBleu_score": 30.761963903978362}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip!= \"\" {\n\t\tip = strings.Split(ip, \",\")[0]\n\t} else {\n\t\tip = request.RemoteAddr\n\t}\n\n\tif ip!= \"\" {\n\t\tip = strings.TrimSpace(strings.Split(ip, \":\")[0])\n\t}\n\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 73.62171506205925}, {"code": "func GetIP(request *http.Request) string{\n\t\tif ip := request.Header.Get(\"X-Forwarded-For\"); ip!= \"\" {\n\t\treturn strings.Split(ip, \",\")[0]\n\t}\n\tif ip := request.RemoteAddr; ip!= \"\" {\n\t\tip = strings.Split(ip, \":\")[0]\n\t\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\t\treturn \"127.0.0.1\"\n\t\t}\n\t\treturn ip\n\t}\n\treturn \"\"\n}", "CodeBleu_score": 56.43829963800396}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 52.60912513305412}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tvar err error\n\tvar entry []byte\n\tvar modules []string\n\tvar entryPath string\n\tvar modulePath string\n\tvar moduleEntry []byte\n\tvar moduleEntryJSON map[string]interface{}\n\tvar moduleEntryJSONString string\n\n\t// Get the module directory path from the config\n\tmodulePath = c.Config.ModulePath\n\n\t// Get the entry file path from the config\n\tentryPath = c.Config.EntryPath\n\n\t// Get the module directories\n\tmodules, err = ioutil.ReadDir(modulePath)\n\tif err!= nil {\n\t\tc.Logger.Error(err.Error())\n\t}\n\n\t// Iterate over the modules\n\tfor _, module := range modules {\n\t\t// Get the module entry file path\n\t\tmoduleEntryPath := modulePath + \"/\" + module.Name() + \"/entry.json\"\n\n\t\t// Read the module entry file\n\t\tmoduleEntry, err = ioutil.ReadFile(moduleEntryPath)\n\t\tif err!= nil {\n\t\t\tc.Logger.Error(err.Error())\n\t\t}\n\n\t\t// Convert the module entry file to JSON\n\t\tmoduleEntryJSON = make(map[string]interface{})\n\t\terr = json.Unmarshal(moduleEntry, &moduleEntryJSON)\n\t\tif err!= nil {\n\t\t\tc.Logger.Error(err.Error())\n\t\t}\n\n\t\t// Convert the module entry JSON to a string\n\t\tmoduleEntryJSONString, err = json.Marshal(moduleEntryJSON)\n\t\tif err!= nil {\n\t\t\tc.Logger.Error(err.Error())\n\t\t}\n\n\t\t// Add the module entry string to the entry array\n\t\tentry = append(entry, []byte(moduleEntryJSONString)...)\n\t}\n\n\t// Write the entry file\n\terr = ioutil.WriteFile(entryPath, entry, 0644)\n\tif err!= nil {\n\t\tc.Logger.Error(err.Error())\n\t}\n}", "CodeBleu_score": 38.31344245212818}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\treturn \"\", nil\n}", "CodeBleu_score": 5.035238341068802}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tvar macAddress string\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn macAddress, err\n\t}\n\n\tnetNames, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn macAddress, err\n\t}\n\n\tfor _, netName := range netNames {\n\t\tfor _, netInterface := range interfaces {\n\t\t\tif netName.Name == netInterface.Name {\n\t\t\t\tmacAddress = netInterface.HardwareAddr.String()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn macAddress, nil\n}", "CodeBleu_score": 54.844279101971914}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tvar macAddress string\n\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn macAddress, err\n\t}\n\n\t// handle err\n\tif len(interfaces) == 0 {\n\t\treturn macAddress, errors.New(\"no interfaces found\")\n\t}\n\n\tfor _, i := range interfaces {\n\t\taddrs, err := i.Addrs()\n\t\tif err!= nil {\n\t\t\treturn macAddress, err\n\t\t}\n\n\t\t// handle err\n\t\tif len(addrs) == 0 {\n\t\t\treturn macAddress, errors.New(\"no addresses found\")\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue // not an ipv4 address\n\t\t\t}\n\n\t\t\tmacAddress = i.HardwareAddr.String()\n\t\t}\n\t}\n\n\treturn macAddress, nil\n}", "CodeBleu_score": 50.48044704200942}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t retVal = 0;\n\tSRequestObj *pTmpRequest = NULL;\n\tSRequestObj *pTmpRequestNext = NULL;\n\tuint32_t requestCount = 0;\n\n\tif (NULL == pRequest || NULL == pTscObj) {\n\t\tretVal = -1;\n\t\tgoto exit;\n\t}\n\n\tif (0 == pTscObj->requestCount) {\n\t\tpTscObj->pRequest = pRequest;\n\t\tpRequest->pNextRequest = NULL;\n\t} else {\n\t\tpTmpRequest = pTscObj->pRequest;\n\t\tpTmpRequestNext = pTmpRequest->pNextRequest;\n\t\twhile (NULL!= pTmpRequestNext) {\n\t\t\tpTmpRequest = pTmpRequestNext;\n\t\t\tpTmpRequestNext = pTmpRequestNext->pNextRequest;\n\t\t}\n\t\tpTmpRequest->pNextRequest = pRequest;\n\t\tpRequest->pNextRequest = NULL;\n\t}\n\tpTscObj->requestCount++;\n\trequestCount = pTscObj->requestCount;\n\tif (NULL!= pTscObj->pAppInfo) {\n\t\tpTscObj->pAppInfo->requestCount++;\n\t\tpTscObj->pAppInfo->requestCountCurrent++;\n\t}\n\tif (0 == requestCount % 1000) {\n\t\tDEBUG_PRINT(\"TSC %s: %d requests registered.\n\", pTscObj->tscName, requestCount);\n\t}\n\tretVal = 0;\nexit:\n\treturn retVal;\n}", "CodeBleu_score": 37.64809927139544}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t ret = 0;\n\n\tif (pTscObj == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (pRequest == NULL) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Add a reference to the request object.\n\t */\n\tpRequest->refCount++;\n\n\t/*\n\t * Increment the request count for the associated TSC object.\n\t */\n\tpTscObj->requestCount++;\n\n\t/*\n\t * Update the application's request summary, including total and current request counts.\n\t */\n\tif (pTscObj->appObj.app!= NULL) {\n\t\tpTscObj->appObj.app->totalRequestCount++;\n\t\tpTscObj->appObj.app->currentRequestCount++;\n\t}\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tLOG_DEBUG(\"Request registered: %d\", pRequest->id);\n\n\treturn ret;\n}", "CodeBleu_score": 26.73975990313592}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tbool bFound = false;\n\tchar *pDb = NULL;\n\tchar *pDbPrefix = NULL;\n\tchar *pDbExcept = NULL;\n\tchar *pDbExceptPrefix = NULL;\n\tchar *pDbExceptLower = NULL;\n\tchar *pDbLower = NULL;\n\n\tpDb = getPrimaryDb(pRequest);\n\tif (pDb!= NULL) {\n\t\tpDbPrefix = strchr(pDb, '.');\n\t\tif (pDbPrefix!= NULL) {\n\t\t\tpDbPrefix++;\n\t\t} else {\n\t\t\tpDbPrefix = pDb;\n\t\t}\n\t}\n\n\tpDbExcept = exceptDb;\n\tpDbExceptPrefix = strchr(pDbExcept, '.');\n\tif (pDbExceptPrefix!= NULL) {\n\t\tpDbExceptPrefix++;\n\t} else {\n\t\tpDbExceptPrefix = pDbExcept;\n\t}\n\n\tpDbExceptLower = pDbExcept;\n\tpDbExceptLower = strlwr(pDbExceptLower);\n\n\tif (pDbPrefix!= NULL && pDbExceptPrefix!= NULL) {\n\t\tif (strcmp(pDbPrefix, pDbExceptPrefix)!= 0) {\n\t\t\tbFound = true;\n\t\t}\n\t}\n\n\tif (pDb!= NULL && pDbExcept!= NULL) {\n\t\tpDbLower = pDb;\n\t\tpDbLower = strlwr(pDbLower);\n\t\tpDbExceptLower = pDbExcept;\n\t\tpDbExceptLower = strlwr(pDbExceptLower);\n\t\tif (strcmp(pDbLower, pDbExceptLower)!= 0) {\n\t\t\tbFound = true;\n\t\t}\n\t}\n\n\treturn bFound;\n}", "CodeBleu_score": 30.78438092157506}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *db = NULL;\n\tint i;\n\tfor (i = 0; i < pRequest->dbCount; i++) {\n\t\tdb = pRequest->dbList[i];\n\t\tif (db!= NULL && strcmp(db, exceptDb)!= 0) {\n\t\t\tif (strstr(db, exceptDb) == NULL) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.02790634662282}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar* db = pRequest->pPrimaryDb;\n\tchar* exceptDb_noSchema = getDbNoSchema(exceptDb);\n\tif (strcmp(db, exceptDb_noSchema)!= 0) {\n\t\t// If the primary database of the request is not the exception database, then check the request's list of databases.\n\t\tchar** pDbList = pRequest->pDbList;\n\t\twhile (*pDbList!= NULL) {\n\t\t\tif (strcmp(*pDbList, exceptDb_noSchema)!= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpDbList++;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 32.27144531526914}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool ret = false;\n\tif (code == ETIMEDOUT) {\n\t\tif (msgType!= MSG_TYPE_GET_STATUS) {\n\t\t\tret = true;\n\t\t}\n\t} else if (code == ECONNRESET) {\n\t\tret = true;\n\t} else if (code == ECONNREFUSED) {\n\t\tret = true;\n\t} else if (code == EHOSTDOWN) {\n\t\tret = true;\n\t} else if (code == EHOSTUNREACH) {\n\t\tret = true;\n\t} else if (code == EHOSTNOTFOUND) {\n\t\tret = true;\n\t} else if (code == ENETUNREACH) {\n\t\tret = true;\n\t} else if (code == ENETDOWN) {\n\t\tret = true;\n\t} else if (code == EMSGSIZE) {\n\t\tret = true;\n\t}\n\treturn ret;\n}", "CodeBleu_score": 31.571597318848244}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == -1) {\n\t\tswitch (msgType) {\n\t\t\tcase TMSG_ERROR:\n\t\t\tcase TMSG_FATAL:\n\t\t\tcase TMSG_WARNING:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 28.617388946526663}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint i;\n\tfor (i = 0; i < pRequests->nBuckets; i++) {\n\t\tif (pRequests->pBuckets[i]) {\n\t\t\tSHashObj *pBucket = pRequests->pBuckets[i];\n\t\t\twhile (pBucket) {\n\t\t\t\tSRequest *pRequest = (SRequest *)pBucket->pData;\n\t\t\t\tif (pRequest->pQuery) {\n\t\t\t\t\ttaosStopQuery(pRequest->pQuery);\n\t\t\t\t}\n\t\t\t\tpBucket = pBucket->pNext;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.7530757608576}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashObj *pReq;\n\tint64_t rid;\n\tint32_t ret;\n\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\tpReq = (SHashObj *)taosHashFirst(pRequests);\n\twhile (pReq!= NULL) {\n\t\trid = (int64_t)taosHashKey(pReq);\n\t\tret = taosReleaseRef(pRequests, rid);\n\t\tif (ret == 0) {\n\t\t\ttaosStopQuery(rid);\n\t\t}\n\t\tpReq = (SHashObj *)taosHashNext(pRequests);\n\t}\n}", "CodeBleu_score": 43.033305778642436}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint32_t i;\n\tint32_t n;\n\tint64_t rid;\n\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\tn = shObjSize(pRequests);\n\tfor (i = 0; i < n; i++) {\n\t\trid = shObjKey(pRequests, i);\n\t\tif (rid > 0) {\n\t\t\treleaseRequest(rid);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.48791701539594}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\n\tif (atomic_compare_exchange_strong(&tscClientStop, &tscClientStop, 1)) {\n\t\twhile (tscClientStop) {\n\t\t\tsleep(1);\n\t\t}\n\t} else {\n\t\tLOG(LOG_ERROR, \"Crash report thread already stopped\");\n\t}\n}", "CodeBleu_score": 57.59687128453641}, {"code": "void tscStopCrashReport(){\n\t\tif (crashReportingEnabled) {\n\t\tif (atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n\t\t\twhile (clientStop) {\n\t\t\t\t// wait for the clientStop flag to be 0\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERROR(\"The crash report thread is already stopped.\");\n\t\t}\n\t}\n}", "CodeBleu_score": 36.68496483311278}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\n\tif (!atomic_compare_exchange_strong(&tscClientStop, &tscClientStop, 1)) {\n\t\ttscLog(TSC_LOG_ERROR, \"Crash report thread already stopped\");\n\t\treturn;\n\t}\n\n\ttscLog(TSC_LOG_INFO, \"Stopping crash report thread\");\n\n\twhile (tscClientStop) {\n\t\tusleep(100000);\n\t}\n\n\ttscLog(TSC_LOG_INFO, \"Crash report thread stopped\");\n}", "CodeBleu_score": 56.486324535020756}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3ResponseCallbackData *responseCallbackData = (S3ResponseCallbackData *)callbackData;\n\n\tif (properties->responseCode == S3StatusOK) {\n\t\tif (properties->contentLength > 0) {\n\t\t\tresponseCallbackData->contentLength = properties->contentLength;\n\t\t}\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 57.99779447219653}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tstruct S3ResponseCallbackData *callbackDataPtr = (struct S3ResponseCallbackData *)callbackData;\n\tif (properties->contentLength > 0) {\n\t\tcallbackDataPtr->contentLength = properties->contentLength;\n\t} else {\n\t\tcallbackDataPtr->contentLength = 0;\n\t}\n\treturn status;\n}", "CodeBleu_score": 68.67130638691387}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tS3ResponseCallbackData *responseCallbackData = (S3ResponseCallbackData *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tresponseCallbackData->contentLength = properties->contentLength;\n\t} else {\n\t\tresponseCallbackData->contentLength = 0;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 69.84454933259492}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n  tsCheckpointBackupDir = path;\n#endif\n\n  // Check if the checkpoint backup directory exists and create it if it does not exist.\n  if (taosMkdir(tsCheckpointBackupDir, S_IRWXU) < 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  // Remove empty directories.\n  removeEmptyDir();\n\n  // Generate the configuration file.\n  if (generateConfigFile(tsCheckpointBackupDir) < 0) return;\n\n  // Construct and execute the command to start the Rsync daemon.\n  char command[PATH_MAX * 2] = {0};\n  snprintf(command, PATH_MAX * 2, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort);\n  int32_t ret = system(command);\n\n  // Log whether the Rsync server started successfully or if it encountered an error.\n  if (ret == 0) {\n    uDebug(\"[rsync] start rsync server successfully, port:%d\", tsCheckpointBackupPort);\n  } else {\n    uError(\"[rsync] start rsync server failed, port:%d,\" ERRNO_ERR_FORMAT, tsCheckpointBackupPort, ERRNO_ERR_DATA);\n  }\n}", "CodeBleu_score": 60.183083163010394}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  if (taosIsWindows()) {\n    char path[PATH_MAX] = {0};\n    changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n    tsCheckpointBackupDir = path;\n  }\n#endif\n\n  if (taosMkdir(tsCheckpointBackupDir, 0755) < 0) {\n    uError(\"[rsync] create checkpoint dir error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) < 0) {\n    uError(\"[rsync] generate conf file error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  int32_t ret = system(cmd);\n  if (ret < 0) {\n    uError(\"[rsync] start rsync server error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  uDebug(\"[rsync] start rsync server success\");\n}", "CodeBleu_score": 50.53471974041237}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n  tsCheckpointBackupDir = path;\n#endif\n\n  if (taosMkdir(tsCheckpointBackupDir, 0755) < 0) {\n    uError(\"[rsync] create checkpoint dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) < 0) {\n    uError(\"[rsync] generate conf file error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsRsyncPort);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  int32_t ret = system(cmd);\n  if (ret < 0) {\n    uError(\"[rsync] start rsync daemon error, cmd:%s,\" ERRNO_ERR_FORMAT, cmd, ERRNO_ERR_DATA);\n    return;\n  }\n\n  uDebug(\"[rsync] start rsync daemon success, cmd:%s\", cmd);\n}", "CodeBleu_score": 58.01449093613813}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\t//TODO\n}", "CodeBleu_score": 2.950171161196606}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (this.dispatchers.containsKey(dispatcherId)) {\n\t\tthis.dispatchers.get(dispatcherId).shutdown();\n\t\tthis.dispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found.\");\n\t}\n}", "CodeBleu_score": 44.42517061286797}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatcherId == null) {\n\t\tthrow new IllegalArgumentException(\"The dispatcher ID cannot be null.\");\n\t}\n\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"The dispatcher with the ID '\" + dispatcherId + \"' is not registered.\");\n\t}\n\tdispatchers.remove(dispatcherId);\n\tdispatcher.shutdown();\n}", "CodeBleu_score": 53.810706735847845}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t final Map<TbActorId, TbActor> children = getChildren();\n if (children == null) {\n return;\n }\n final List<TbActorId> filteredChildren = children.keySet().stream().filter(childFilter).collect(Collectors.toList());\n for (TbActorId child : filteredChildren) {\n if (!children.containsKey(child)) {\n LOG.warn(\"Child actor {} not found\", child);\n continue;\n }\n try {\n final TbActor childActor = children.get(child);\n if (childActor == null) {\n LOG.warn(\"Child actor {} not found\", child);\n continue;\n }\n if (highPriority) {\n childActor.tell(parent, msg, true);\n } else {\n childActor.tell(parent, msg);\n }\n } catch (Throwable t) {\n LOG.error(\"Error sending message to child actor {}\", child, t);\n }\n }\n }", "CodeBleu_score": 42.33819840084712}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t List<TbActorId> children = actorMap.get(parent);\n if (children!= null) {\n for (TbActorId child : children) {\n if (childFilter.test(child)) {\n try {\n if (highPriority) {\n send(child, msg, true);\n } else {\n send(child, msg, false);\n }\n } catch (TbActorNotRegisteredException e) {\n log.warn(\"The child actor {} is not registered. Message was not sent.\", child);\n }\n }\n }\n }\n }", "CodeBleu_score": 55.91909700938133}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t TbActorId[] children = getChildren(parent);\n for (TbActorId child : children) {\n if (childFilter.test(child)) {\n try {\n if (highPriority) {\n sendHighPriority(child, msg);\n } else {\n send(child, msg);\n }\n } catch (TbActorException e) {\n log.warn(\"Error sending message to child actor: \" + child, e);\n }\n }\n }\n }", "CodeBleu_score": 38.806767160001165}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t (destroyed.get()) {\n    if (msg instanceof RuleNodeUpdatedMsg) {\n        if (msg.getRuleNode().getRuleNodeId().equals(selfId)) {\n            initActor();\n        }\n    } else {\n        msg.getActor().notifyStopped();\n    }\n} else {\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    tryProcessQueue(true);\n}\n}", "CodeBleu_score": 50.901385533416324}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t (!destroyInProgress.get()) {\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    tryProcessQueue(false);\n} else if (msg instanceof RuleNodeUpdatedMsg) {\n    if (destroyInProgress.get()) {\n        if (selfId == ((RuleNodeUpdatedMsg) msg).getRuleNodeId()) {\n            initActor();\n        }\n    } else {\n        destroyInProgress.set(true);\n        msg.getActor().stop();\n    }\n} else {\n    msg.getActor().stop();\n}\n}", "CodeBleu_score": 54.3114255593582}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t (destroyed.get()) {\n    if (msg instanceof RuleNodeUpdatedMsg) {\n        if (actorState == INITIALIZING) {\n            log.trace(\"[{}] Actor is in initializing state, reinitialize actor\", selfId);\n            initActor();\n        } else {\n            log.trace(\"[{}] Actor is destroyed, do not enqueue message\", selfId);\n            msg.notifyActorStopped();\n        }\n    } else {\n        log.trace(\"[{}] Actor is destroyed, do not enqueue message\", selfId);\n        msg.notifyActorStopped();\n    }\n} else {\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    tryProcessQueue(true);\n}\n}", "CodeBleu_score": 58.10073694034607}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\tyProcessQueue: while (true) {\n            try {\n                if (destroyInProgress.get()) {\n                    break;\n                }\n                if (ready.get() == READY) {\n                    if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                        break tryProcessQueue;\n                    }\n                } else {\n                    break tryProcessQueue;\n                }\n                if (highPriorityMsgs.isEmpty()) {\n                    processMessages(normalPriorityMsgs, MAX_NORMAL_THROUGHPUT);\n                } else {\n                    processMessages(highPriorityMsgs, MAX_HIGH_THROUGHPUT);\n                }\n                if (destroyInProgress.get()) {\n                    break;\n                }\n            } catch (Throwable t) {\n                log.error(\"[{}] Failed to process mailbox: {}\", selfId, t);\n                if (t instanceof RuntimeException) {\n                    throw (RuntimeException) t;\n                }\n                if (actor.processFailureStrategy() == TbActorProcessFailureStrategy.STOP) {\n                    stop(TbActorStopReason.PROCESS_FAILURE);\n                    break;\n                }\n            }\n        }\n        if (destroyInProgress.get()) {\n            return;\n        }\n        ready.set(NOT_READY);\n        tryProcessQueue(false);\n    }", "CodeBleu_score": 36.74610948314281}, {"code": "private void processMailbox(){\n\tocessHighPriorityMsgs: while (!highPriorityMsgs.isEmpty()) {\n            try {\n                TbActorMessage msg = highPriorityMsgs.poll();\n                if (msg!= null) {\n                    actor.process(msg);\n                }\n            } catch (TbActorInitializationException e) {\n                stopReason = TbActorStopReason.INITIALIZATION_EXCEPTION;\n                destroy(e);\n                break processHighPriorityMsgs;\n            } catch (TbActorProcessException e) {\n                stopReason = TbActorStopReason.PROCESS_EXCEPTION;\n                applyProcessFailureStrategy(e);\n                break processHighPriorityMsgs;\n            } catch (Throwable e) {\n                log.warn(\"[{}] Unexpected exception during mailbox processing: {}\", selfId, e);\n                break processHighPriorityMsgs;\n            }\n        }\nprocessNormalPriorityMsgs: while (!normalPriorityMsgs.isEmpty()) {\n            try {\n                TbActorMessage msg = normalPriorityMsgs.poll();\n                if (msg!= null) {\n                    actor.process(msg);\n                }\n            } catch (TbActorInitializationException e) {\n                stopReason = TbActorStopReason.INITIALIZATION_EXCEPTION;\n                destroy(e);\n                break processNormalPriorityMsgs;\n            } catch (TbActorProcessException e) {\n                stopReason = TbActorStopReason.PROCESS_EXCEPTION;\n                applyProcessFailureStrategy(e);\n                break processNormalPriorityMsgs;\n            } catch (Throwable e) {\n                log.warn(\"[{}] Unexpected exception during mailbox processing: {}\", selfId, e);\n                break processNormalPriorityMsgs;\n            }\n        }\nprocessFailure: try {\n            if (destroyInProgress.get()) {\n                break processFailure;\n            }\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                ready.set(NOT_READY);\n            }\n            busy.set(FREE);\n            tryProcessQueue(false);\n        } catch (Throwable e) {\n            log.warn(\"[{}] Unexpected exception during mailbox processing: {}\", selfId, e);\n        }\n    }", "CodeBleu_score": 34.12119474906004}, {"code": "private void processMailbox(){\n\tyProcessQueue: while (true) {\n            try {\n                if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                    ready.set(NOT_READY);\n                    break tryProcessQueue;\n                }\n                if (highPriorityMsgs.size() > 0) {\n                    final TbActorMessage msg = highPriorityMsgs.poll();\n                    if (msg == null) {\n                        break tryProcessQueue;\n                    }\n                    msg.onTbActorStarted(selfId);\n                    msg.onTbActorProcessingStarted();\n                    try {\n                        actor.process(msg);\n                    } catch (Throwable t) {\n                        log.warn(\"[{}] Failed to process message: {}\", selfId, t);\n                        actor.processFailureStrategy.onTbActorProcessFailure(msg, t);\n                        if (actor.processFailureStrategy.shouldStop(msg, t)) {\n                            stop(msg.getSender());\n                        }\n                    } finally {\n                        msg.onTbActorProcessingFinished();\n                    }\n                } else if (normalPriorityMsgs.size() > 0) {\n                    final TbActorMessage msg = normalPriorityMsgs.poll();\n                    if (msg == null) {\n                        break tryProcessQueue;\n                    }\n                    msg.onTbActorStarted(selfId);\n                    msg.onTbActorProcessingStarted();\n                    try {\n                        actor.process(msg);\n                    } catch (Throwable t) {\n                        log.warn(\"[{}] Failed to process message: {}\", selfId, t);\n                        actor.processFailureStrategy.onTbActorProcessFailure(msg, t);\n                        if (actor.processFailureStrategy.shouldStop(msg, t)) {\n                            stop(msg.getSender());\n                        }\n                    } finally {\n                        msg.onTbActorProcessingFinished();\n                    }\n                }\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n                stop(null);\n            }\n        }\n    }", "CodeBleu_score": 41.3393976933867}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.STOPPED;\n\t}\n\tdestroyInProgress.set(true);\n\tdispatcher.getExecutor().execute(() -> {\n\t\ttry {\n\t\t\tready.set(NOT_READY);\n\t\t\tactor.destroy(stopReason, cause);\n\t\t\thighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t\tnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n\t\t}\n\t});\n}", "CodeBleu_score": 92.47258027809767}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}, {"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.STOPPED;\n\t}\n\tdestroyInProgress.set(true);\n\tdispatcher.getExecutor().execute(() -> {\n\t\ttry {\n\t\t\tready.set(NOT_READY);\n\t\t\tactor.destroy(stopReason, cause);\n\t\t\thighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t\tnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n\t\t}\n\t});\n}", "CodeBleu_score": 92.47258027809767}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.isSystemTenant()) {\n\t\treturn true;\n\t}\n\n\tTenantProfile profile = getTenantProfile(tenantId, ignoreTenantNotFound);\n\tif (profile == null) {\n\t\treturn true;\n\t}\n\n\tRateLimitConfiguration rateLimitConfig = profile.getRateLimitConfiguration(level);\n\tif (rateLimitConfig == null) {\n\t\treturn true;\n\t}\n\n\tRateLimit rateLimit = rateLimitConfig.getRateLimit();\n\tif (rateLimit == null) {\n\t\treturn true;\n\t}\n\n\tif (!rateLimit.check(api, tenantId)) {\n\t\tprocessRateLimitNotification(tenantId, rateLimitConfig);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 34.36426389828062}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\t// TODO: Implement checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)\n\treturn false;\n}", "CodeBleu_score": 5.42861630904345}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - this.inactivityTimeout;\n\tMap<DtlsSession, DtlsSession> map = this.dtlsSessions;\n\tfor (Map.Entry<DtlsSession, DtlsSession> entry : map.entrySet()) {\n\t\tDtlsSession session = entry.getValue();\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\tmap.remove(session);\n\t\t\tthis.logger.debug(\"Session {} removed from the DTLS sessions map\", session.getRemoteAddress());\n\t\t}\n\t}\n}", "CodeBleu_score": 37.16236961515187}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - inactivityTimeout;\n\tIterator<Map.Entry<String, DtlsSession>> iterator = dtlsSessions.entrySet().iterator();\n\twhile (iterator.hasNext()) {\n\t\tMap.Entry<String, DtlsSession> entry = iterator.next();\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlog.info(\"Removing DTLS session \" + entry.getKey());\n\t\t\titerator.remove();\n\t\t}\n\t}\n}", "CodeBleu_score": 37.104287925480385}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - (long) this.inactivityTimeout;\n\tIterator<Entry<String, DtlsSession>> iterator = this.sessions.entrySet().iterator();\n\twhile (iterator.hasNext()) {\n\t\tEntry<String, DtlsSession> entry = iterator.next();\n\t\tDtlsSession session = entry.getValue();\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\tlogger.debug(\"Removing DTLS session {} due to timeout\", entry.getKey());\n\t\t\titerator.remove();\n\t\t}\n\t}\n}", "CodeBleu_score": 39.7887749813667}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn new ArrayList<>();\n}\n\nList<TsKvEntry> entries = new ArrayList<>();\nfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\nString key = entry.getKey();\nList<JsonNode> values = entry.getValue();\nif (values.isEmpty()) {\ncontinue;\n}\n\nList<TsKvEntry> parsedValues = values.stream()\n.map(value -> parseValue(key, value))\n.collect(Collectors.toList());\nentries.addAll(parsedValues);\n}\nreturn entries;\n}", "CodeBleu_score": 41.17542929784827}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\nreturn Collections.emptyList();\n} else {\nreturn timeseries.entrySet().stream()\n.flatMap(entry -> entry.getValue().stream()\n.map(value -> parseValue(entry.getKey(), value)))\n.collect(Collectors.toList());\n}\n}", "CodeBleu_score": 19.82101407754512}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\treturn timeseries.entrySet().stream().map(entry -> {\n\t\treturn new TsKvEntry(entry.getKey(), entry.getValue().stream().map(KvEntry::parseValue).collect(Collectors.toList()));\n\t}).collect(Collectors.toList());\n}", "CodeBleu_score": 23.869288964944772}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t//TODO implement this method\n}", "CodeBleu_score": 1.6078250809239212}, {"code": "public void refreshToken(){\n\t//TODO implement refreshToken\n}", "CodeBleu_score": 1.6078250809239212}, {"code": "public void refreshToken(){\n\t\n//TODO: Implement the method\n\n}", "CodeBleu_score": 1.6078250809239212}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t\tlong ts = System.currentTimeMillis();\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", this.username);\n\tloginRequest.put(\"password\", );\n\tloginRequest.put(\"clientId\", this.clientId);\n\tloginRequest.put(\"clientSecret\", this.clientSecret);\n\tloginRequest.put(\"grantType\", \"password\");\n\tloginRequest.put(\"scope\", \"read\");\n\tloginRequest.put(\"clientServerTimeDiff\", Long.toString(this.clientServerTimeDiff));\n\tJsonNode loginResponse = this.postRequest(this.authEndpoint + \"/api/auth/login\", loginRequest);\n\tthis.setTokenInfo(ts, loginResponse);\n}", "CodeBleu_score": 57.66052158178915}, {"code": " private void doLogin(){\n\t long ts = System.currentTimeMillis();\n Map<String, Object> loginRequest = new HashMap<>();\n loginRequest.put(\"username\", this.username);\n loginRequest.put(\"password\", );\n loginRequest.put(\"clientServerTimeDiff\", this.clientServerTimeDiff);\n loginRequest.put(\"clientTimestamp\", ts);\n String loginRequestJson = new ObjectMapper().writeValueAsString(loginRequest);\n HttpHeaders headers = new HttpHeaders();\n headers.setContentType(MediaType.APPLICATION_JSON);\n HttpEntity<String> request = new HttpEntity<>(loginRequestJson, headers);\n ResponseEntity<String> response = restTemplate.postForEntity(this.authUrl + \"/api/auth/login\", request, String.class);\n JsonNode loginResponse = new ObjectMapper().readTree(response.getBody());\n this.setTokenInfo(ts, loginResponse);\n }", "CodeBleu_score": 58.70228857485158}, {"code": " private void doLogin(){\n\t\nlong ts = System.currentTimeMillis();\nMap<String, Object> loginRequest = new HashMap<>();\nloginRequest.put(\"username\", username);\nloginRequest.put(\"password\", );\n\nResponse response = this.postRequest(LOGIN_URL, loginRequest);\n\nif (response.getStatus() == 200) {\nthis.setTokenInfo(ts, response.getBody().getJson());\n} else {\nthrow new RuntimeException(\"Login failed\");\n}\n}", "CodeBleu_score": 62.35552066815146}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\treturn Optional.ofNullable(this.restTemplate.getForObject(this.url + \"/api/device/{deviceId}\", Device.class, deviceId));\n\t} catch (final RestClientException e) {\n\t\tif (e.getMessage().contains(\"404\")) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 30.107161293958352}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\treturn getDeviceById(deviceId, null);\n}", "CodeBleu_score": 6.442408619513598}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\treturn Optional.ofNullable(client.get(DEVICE_URL + \"/\" + deviceId.getId(), Device.class));\n\t} catch (RestClientException e) {\n\t\tif (e.getStatus() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.22625528715449}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tif (device == null) {\n\t\tthrow new IllegalArgumentException(\"Device cannot be null.\");\n\t}\n\tif (credentials == null) {\n\t\tthrow new IllegalArgumentException(\"Credentials cannot be null.\");\n\t}\n\tRequest request = new Request.Builder()\n\t\t.url(baseUrl + \"/api/device-with-credentials\")\n\t\t.post(RequestBody.create(MediaType.parse(\"application/json\"), new Gson().toJson(device)))\n\t\t.build();\n\ttry {\n\t\tResponse response = client.newCall(request).execute();\n\t\tif (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tif (!response.isSuccessful()) {\n\t\t\tthrow new IOException(\"Unexpected code \" + response);\n\t\t}\n\t\treturn Optional.of(new Gson().fromJson(response.body().string(), Device.class));\n\t} catch (IOException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 41.59970083738196}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tRequest request = createRequest(device, credentials);\n\ttry {\n\t\tResponse response = sendRequest(request);\n\t\treturn Optional.of(response.getDevice());\n\t} catch (ResponseException e) {\n\t\tif (e.getStatusCode() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.81019851378128}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tRequest request = new Request.Builder()\n\t\t.url(this.baseUrl + \"/api/device-with-credentials\")\n\t\t.post(RequestBody.create(JSON_MEDIA_TYPE, device.toJson()))\n\t\t.build();\n\n\ttry {\n\t\tResponse response = this.httpClient.newCall(request).execute();\n\n\t\tif (response.code() == 200) {\n\t\t\treturn Optional.of(Device.fromJson(response.body().string()));\n\t\t} else if (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new RuntimeException(response.code() + \": \" + response.message());\n\t\t}\n\t} catch (IOException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 45.82271214726454}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\nval = addr;\nthis.each((device) => {\nthis.brightness(device, val);\n});\n} else {\nthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n}\nreturn this;\n}", "CodeBleu_score": 87.05196664269761}, {"code": "brightness(addr, val){\n\t\n}", "CodeBleu_score": 2.8022481803282675}, {"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tval = addr;\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness(device, val);\n\t\t});\n\t} else {\n\t\tthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n\t}\n\treturn this;\n}", "CodeBleu_score": 95.67310060368143}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\tconst bound = {};\n\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}, {"code": "device(addr){\n\t\n}", "CodeBleu_score": 1.622727129683248}, {"code": "device(addr){\n\t\tconst bound = {};\n\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tif (!target) {\n\t\tthrow new Error(\"Target object is required\");\n\t}\n\tif (!methods ||!methods.length) {\n\t\tthrow new Error(\"Methods are required\");\n\t}\n\tmethods.forEach(method => {\n\t\tif (!target[method]) {\n\t\t\tthrow new Error(`Target object does not have a method called \"${method}\"`);\n\t\t}\n\t\tif (typeof target[method]!== \"function\") {\n\t\t\tthrow new Error(`Target object does not have a method called \"${method}\" that is a function`);\n\t\t}\n\t});\n\ttarget.callbackReconciliation = (method, duration = 1000) => {\n\t\tif (!method) {\n\t\t\tthrow new Error(\"Method is required\");\n\t\t}\n\t\tif (typeof method!== \"function\") {\n\t\t\tthrow new Error(\"Method must be a function\");\n\t\t}\n\t\tconst promises = [];\n\t\tconst collection = this;\n\t\tcollection.forEach(element => {\n\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tresolve(method(element));\n\t\t\t\t}, duration);\n\t\t\t}));\n\t\t});\n\t\treturn Promise.all(promises);\n\t};\n}", "CodeBleu_score": 28.023213242175753}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tlet promises = [];\n\t\t\tthis.forEach(item => {\n\t\t\t\tpromises.push(new Promise(resolve => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(item[method]());\n\t\t\t\t\t}, duration || 1000);\n\t\t\t\t}));\n\t\t\t});\n\t\t\tPromise.all(promises).then(results => {\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\tcallback(results);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 28.61562787454364}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tfor (let method of methods) {\n\t\ttarget[method] = (collection, duration = 1000, callback) => {\n\t\t\tlet promises = [];\n\t\t\tfor (let item of collection) {\n\t\t\t\tpromises.push(new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tresolve(item[method]());\n\t\t\t\t\t}, duration);\n\t\t\t\t}));\n\t\t\t}\n\t\t\tPromise.all(promises).then(values => {\n\t\t\t\tcallback(values);\n\t\t\t});\n\t\t}\n\t}\n}", "CodeBleu_score": 21.955344527452553}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t", "CodeBleu_score": 1.3029767937853085}, {"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\ninput += new Buffer(data).toString(\"ascii\");\nconst sentences = input.split(\"\\r\n\");\n\nif (sentences.length > 1) {\nfor (let i = 0; i < sentences.length - 1; i++) {\nthis.parseNmeaSentence(sentences[i]);\n}\ninput = sentences[sentences.length - 1];\n}\n});\n}", "CodeBleu_score": 71.46663544932532}, {"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\ninput += new Buffer(data).toString(\"ascii\");\nconst sentences = input.split(\"\\r\n\");\n\nif (sentences.length > 1) {\nfor (let i = 0; i < sentences.length - 1; i++) {\nthis.parseNmeaSentence(sentences[i]);\n}\ninput = sentences[sentences.length - 1];\n}\n});\n}", "CodeBleu_score": 71.46663544932532}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tint i;\n\tint num_channels = 0;\n\tint buffer_size = 0;\n\tint num_samples = 0;\n\n\tfor (i = 0; i < sequence->options->sequence_length; i++) {\n\t\tif (sequence->options->channels[i]!= 0) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (num_channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tif (sequence->options->channels[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_samples += config->channel_config[sequence->options->channels[i] - 1].data_size;\n\t}\n\n\tbuffer_size = num_samples * num_channels;\n\n\tif (buffer_size > config->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.804366487238426}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 8.153997662966383}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tint active_channels = 0;\n\tint buffer_size = 0;\n\tint i;\n\n\tfor (i = 0; i < sequence->options; i++) {\n\t\tif (sequence->channels[i] >= config->num_channels) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i]!= ADC_AD559X_CHANNEL_DISABLED) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tbuffer_size = active_channels * sequence->resolution * sizeof(uint16_t);\n\n\tif (buffer_size > config->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 43.374324277788915}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tuint8_t i;\n\tuint16_t *buffer;\n\tint ret;\n\n\t/* Check if the resolution of the ADC sequence matches the expected resolution */\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Resolution mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the specified channels are valid */\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > config->channels) {\n\t\tLOG_ERR(\"Invalid channels\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate the buffer size for the ADC read */\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Buffer size is insufficient\");\n\t\treturn ret;\n\t}\n\n\t/* Set the buffer */\n\tbuffer = sequence->buffer;\n\n\t/* Start the ADC read context */\n\tdata->adc_read_context = adc_read_context_start(dev, sequence);\n\tif (!data->adc_read_context) {\n\t\tLOG_ERR(\"Failed to start ADC read context\");\n\t\treturn -EIO;\n\t}\n\n\t/* Wait for the read operation to complete */\n\tfor (i = 0; i < channels; i++) {\n\t\tret = adc_read_context_wait_for_completion(data->adc_read_context,\n\t\t\t\t\t\t\t   sequence->timeout);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to wait for ADC read completion\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t*buffer++ = adc_read_context_get_result(data->adc_read_context);\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 59.801430853976555}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tuint8_t i;\n\tint ret;\n\tsize_t needed;\n\n\t/* Check if the resolution matches the expected resolution */\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"ADC resolution (%d) does not match expected resolution (%d)\",\n\t\t\tsequence->resolution, config->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the specified channels are valid */\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > config->channels) {\n\t\tLOG_ERR(\"ADC channels (%d) exceed maximum channels (%d)\",\n\t\t\tchannels, config->channels);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate the buffer size for the ADC read */\n\tneeded = channels * sizeof(uint16_t);\n\tif (sequence->buffer_size < needed) {\n\t\tLOG_ERR(\"Buffer size (%zu) is too small for ADC read\",\n\t\t\tsequence->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Set the buffer */\n\tdata->sequence = sequence;\n\n\t/* Start the ADC read context */\n\tret = adc_read_async(&config->adc, sequence, adc_ad559x_read_callback, data);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to start ADC read context: %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Wait for the read operation to complete */\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn ret;\n}", "CodeBleu_score": 58.223286524318254}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tuint16_t *buffer;\n\tuint16_t channel_mask;\n\tuint8_t i;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > config->channels) {\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer = sequence->buffer;\n\tif (sequence->buffer_size < channels * sizeof(uint16_t)) {\n\t\treturn -ENOMEM;\n\t}\n\n\tchannel_mask = 0;\n\tfor (i = 0; i < config->channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tchannel_mask |= BIT(i);\n\t\t}\n\t}\n\n\tif (channel_mask == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tdata->channel_mask = channel_mask;\n\tdata->buffer = buffer;\n\tdata->sequence = sequence;\n\n\tret = adc_read_async(dev, sequence->options);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 47.599791313123696}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *adc_data = ctx->adc_data;\n\tstruct adc_channel *channel;\n\tuint8_t i;\n\n\tadc_data->adc_channels = ctx->adc_channels;\n\tadc_data->adc_channel_count = ctx->adc_channel_count;\n\n\tfor (i = 0; i < adc_data->adc_channel_count; i++) {\n\t\tchannel = &adc_data->adc_channels[i];\n\t\tchannel->adc_buffer = ctx->adc_buffer + i * ADC_SAMPLE_COUNT;\n\t\tchannel->adc_buffer_size = ADC_SAMPLE_COUNT;\n\t\tchannel->adc_buffer_index = 0;\n\t\tchannel->adc_buffer_repeat = ctx->adc_buffer_repeat;\n\t}\n\n\tadc_data->adc_buffer_repeat = ctx->adc_buffer_repeat;\n\tadc_data->adc_buffer_index = 0;\n\tadc_data->adc_buffer_size = ADC_SAMPLE_COUNT * adc_data->adc_channel_count;\n\n\t/* Release the semaphore */\n\tsemaphore_release(&adc_data->adc_semaphore);\n}", "CodeBleu_score": 45.71534766972242}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t", "CodeBleu_score": 6.762733993289692}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t", "CodeBleu_score": 6.762733993289692}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data = &ctx->adc_data;\n\tif (repeat_sampling) {\n\t\tadc_data->buffer_pointer = ctx->repeat_buffer;\n\t} else {\n\t\tadc_data->buffer_pointer = ctx->buffer;\n\t}\n}", "CodeBleu_score": 39.84823701675826}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data *adc_data = ctx->adc_data;\n\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = adc_data->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = adc_data->buffer;\n\t}\n}", "CodeBleu_score": 40.9766328060607}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data *adc_data = ctx->adc_data;\n\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = adc_data->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = adc_data->buffer;\n\t}\n}", "CodeBleu_score": 40.9766328060607}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\ttruct device *dev = data->dev;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (1) {\n\t\t/* Wait for semaphore */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->channels_count; channel++) {\n\t\t\t/* Read channel */\n\t\t\tret = adc_ad559x_read_channel(dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\tdata->complete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->channel_data[channel] = result;\n\t\t}\n\n\t\t/* Signal completion */\n\t\tif (data->complete) {\n\t\t\tk_sem_give(&data->sem);\n\t\t}\n\t}\n}", "CodeBleu_score": 52.28130296086767}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tint16_t result;\n\tint ret;\n\tint i;\n\n\twhile (1) {\n\t\t/* Wait for semaphore */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Iterate through active channels */\n\t\tfor (i = 0; i < data->num_channels; i++) {\n\t\t\t/* Read channel */\n\t\t\tret = adc_ad559x_read_channel(data->dev, data->channels[i], &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", data->channels[i], ret);\n\t\t\t\tdata->complete = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Store result */\n\t\t\tdata->results[i] = result;\n\t\t}\n\n\t\t/* Signal completion */\n\t\tdata->complete = true;\n\t}\n}", "CodeBleu_score": 43.2141017173654}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tnt ret;\n\tuint8_t channel;\n\tuint16_t result;\n\tint i;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem_acq_done, K_FOREVER);\n\n\t\tfor (i = 0; i < data->active_channel_count; i++) {\n\t\t\tchannel = data->active_channels[i];\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->channel_results[i] = result;\n\t\t\t} else {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\tdata->complete = true;\n\t\t\t}\n\t\t}\n\n\t\tdata->complete = true;\n\t\tk_sem_give(&data->sem_acq_done);\n\t}\n}", "CodeBleu_score": 52.40081623817658}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val[2] = {0};\n\tint rc = 0;\n\n\twhile (1) {\n\t\tk_sleep(config->ready_time);\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (reg_val[0] & 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 35.5944581583793}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val[2] = {0};\n\tint rc;\n\n\tk_sleep(config->ready_time);\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\tif ((reg_val[0] & 0x80)!= 0x80) {\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 31.70971325859317}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val[2] = {0};\n\tint rc = 0;\n\tuint8_t status = 0;\n\n\tk_sleep(config->ready_time);\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\tstatus = reg_val[0] & ADS1112_REG_CONFIG_DRDY;\n\n\twhile (status!= ADS1112_REG_CONFIG_DRDY) {\n\t\tk_sleep(K_MSEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t\tstatus = reg_val[0] & ADS1112_REG_CONFIG_DRDY;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 57.87681859056889}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = 0;\n\tint i;\n\n\tfor (i = 0; i < sequence->options; i++) {\n\t\tbuffer_size += sequence->samplings[i];\n\t}\n\n\tbuffer_size += sequence->samplings[i];\n\n\tif (buffer_size < sequence->buffer_size) {\n\t\tLOG_ERROR(\"Buffer size too small: %d < %d\", buffer_size, sequence->buffer_size);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 37.52172264376}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = 0;\n\tint samplings = 0;\n\tint i;\n\tfor (i = 0; i < sequence->options.num_samplings; i++) {\n\t\tsamplings += sequence->options.samplings[i];\n\t}\n\tbuffer_size = (sequence->options.num_samplings + samplings) * sequence->options.num_channels * sizeof(int16_t);\n\tif (buffer_size < sequence->buffer_size) {\n\t\tLOG_ERROR(\"Buffer size is too small for the specified sequence. Required buffer size: %d bytes, actual buffer size: %d bytes\", buffer_size, sequence->buffer_size);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 36.64046543643799}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tuint32_t buffer_size = 0;\n\tuint32_t num_samplings = 0;\n\tuint32_t num_extra_samplings = 0;\n\tuint32_t num_channels = 0;\n\tuint32_t i = 0;\n\n\tif (sequence == NULL) {\n\t\treturn -1;\n\t}\n\n\tnum_samplings = sequence->options & ADC_SEQ_OPTIONS_NUM_SAMPLINGS_MASK;\n\tnum_extra_samplings = sequence->options & ADC_SEQ_OPTIONS_EXTRA_SAMPLINGS_MASK;\n\tnum_channels = sequence->options & ADC_SEQ_OPTIONS_CHANNELS_MASK;\n\n\tif (num_samplings == 0) {\n\t\treturn -1;\n\t}\n\n\tbuffer_size = num_samplings * num_channels;\n\tif (num_extra_samplings!= 0) {\n\t\tbuffer_size += num_extra_samplings * num_channels;\n\t}\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tif (sequence->channels[i].channel == 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (buffer_size < 1) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 42.07015476031245}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t", "CodeBleu_score": 7.040677167376957}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t", "CodeBleu_score": 7.040677167376957}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t", "CodeBleu_score": 7.040677167376957}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t", "CodeBleu_score": 34.52460135924148}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tstruct device *dev_codec;\n\tint err;\n\tint status = 0;\n\n\tif (argc!= 3) {\n\t\tshell_error(sh, \"usage: %s <device> <codec-device>\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_codec = device_get_binding(argv[2]);\n\tif (dev_codec == NULL) {\n\t\tshell_error(sh, \"codec device %s not found\", argv[2]);\n\t\treturn -ENODEV;\n\t}\n\n\terr = device_set_property(dev, dev_codec, DEVICE_AUDIO_CODEC_PROP_NAME);\n\tif (err) {\n\t\tshell_error(sh, \"failed to set audio codec property: %d\", err);\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = device_set_property(dev, dev_codec, DEVICE_AUDIO_CODEC_PROP_NAME);\n\tif (status) {\n\t\tshell_error(sh, \"failed to set audio codec property: %d\", status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 44.35879026488318}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint err;\n\tint ret;\n\tstruct audio_codec_config_set_param param;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Usage: %s <dev_name> <property_name> <property_value>\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[0]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[0]);\n\t\treturn -ENODEV;\n\t}\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Usage: %s <dev_name> <property_name> <property_value>\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (argc < 4) {\n\t\tshell_error(sh, \"Usage: %s <dev_name> <property_name> <property_value>\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (argc < 5) {\n\t\tshell_error(sh, \"Usage: %s <dev_name> <property_name> <property_value>\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tparam.property_name = argv[1];\n\tparam.property_value = argv[2];\n\tparam.property_value_size = strlen(argv[2]);\n\n\tret = device_get_binding(argv[0])->driver_api->apply_config(dev, &param);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply property %s=%s\", argv[1], argv[2]);\n\t\treturn ret;\n\t}\n\n\tshell_print(sh, \"Property %s=%s applied successfully\", argv[1], argv[2]);\n\n\treturn 0;\n}", "CodeBleu_score": 47.83535721065315}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_start(dev);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Device not configured\");\n\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Device not active\");\n\t\t\tret = -EIO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid trigger command\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 53.95326575683429}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret;\n\n\tif (!data) {\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\tret = mpxxdtyy_i2s_cmd(dev, MPXXDTYY_I2S_CMD_START);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\tret = mpxxdtyy_i2s_cmd(dev, MPXXDTYY_I2S_CMD_STOP);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to trigger I2S command (%d)\", ret);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 53.71283726527625}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret = 0;\n\n\tif (data->state == MPXXDTYY_I2S_STATE_IDLE) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t\tret = mpxxdtyy_i2s_set_command(dev, MPXXDTYY_I2S_COMMAND_START);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_IDLE;\n\t\t\tret = mpxxdtyy_i2s_set_command(dev, MPXXDTYY_I2S_COMMAND_STOP);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to trigger I2S command: %d\", ret);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 35.028533777274276}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd = AUXDISPLAY_HD44780_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK;\n\t}\n\n\tif (config->display_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_BLINK;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 63.21427757640863}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0x00;\n\n\tif (enabled) {\n\t\tcmd = 0x0C;\n\t} else {\n\t\tcmd = 0x08;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= 0x01;\n\t}\n\n\tif (config->display_enabled) {\n\t\tcmd |= 0x04;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 43.53295851320523}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tcmd |= (config->cursor_blink? HD44780_DISPLAY_CURSOR_BLINK : 0);\n\tcmd |= (config->display_enabled? HD44780_DISPLAY_ON : 0);\n\tcmd |= (config->display_shift? HD44780_DISPLAY_SHIFT : 0);\n\tcmd |= (config->display_shift? HD44780_DISPLAY_SHIFT_RIGHT : 0);\n\n\tif (enabled) {\n\t\tconfig->display_enabled = true;\n\t} else {\n\t\tconfig->display_enabled = false;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 48.47740918918575}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tstruct auxdisplay_itron_data *data = dev->data;\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = 0;\n\n\tif (config->busy_gpio_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 66.00149061124519}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = 0;\n\tif (config->busy_gpio_port == NULL) {\n\t\tret = -ENOTSUP;\n\t} else {\n\t\tret = gpio_pin_get_dt(config->busy_gpio_port, config->busy_gpio_pin);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 65.74721784297476}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\n\tif (config->busy_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get(config->busy_port, config->busy_pin);\n}", "CodeBleu_score": 69.89813753627206}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tint ret;\n\tuint8_t command_buffer[2];\n\n\t/* Construct the command buffer. */\n\tcommand_buffer[0] = AUXDISPLAY_SERLCD_COMMAND_PREFIX;\n\tcommand_buffer[1] = command;\n\n\t/* Write the command buffer to the device. */\n\tret = i2c_write(dev, command_buffer, sizeof(command_buffer));\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\t/* Introduce a delay based on the device configuration. */\n\tk_sleep(dev->config->delay);\n\n\treturn 0;\n}", "CodeBleu_score": 50.834819834237685}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t", "CodeBleu_score": 9.039500874140998}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *cfg = dev->config;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = cfg->prefix;\n\tbuffer[1] = command;\n\n\treturn auxdisplay_serlcd_write(dev, buffer, sizeof(buffer));\n}", "CodeBleu_score": 54.794921933127696}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tint err_code = 0;\n\tuint8_t *mem_ptr = data_ptr->mem;\n\tuint8_t *mem_end = data_ptr->mem + data_ptr->size;\n\tuint8_t *mem_offset = mem_ptr + offset;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (mem_offset < mem_ptr || mem_offset + size > mem_end) {\n\t\terr_code = -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\terr_code = -EINVAL;\n\t}\n\n\tif (err_code == 0) {\n\t\tmemcpy(data, mem_offset, size);\n\t}\n\n\treturn err_code;\n}", "CodeBleu_score": 44.434468631964165}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tint err = 0;\n\tbool is_invalid = false;\n\n\tif (size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tis_invalid = bbram_emul_check_invalid(dev);\n\tif (is_invalid) {\n\t\treturn -EIO;\n\t}\n\n\tif ((offset + size) > BBRAM_EMUL_SIZE) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, data_ptr->mem + offset, size);\n\treturn err;\n}", "CodeBleu_score": 58.244127843103485}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tuint8_t *mem_ptr = data_ptr->mem;\n\tint rc = 0;\n\n\t/* Check if the requested read size is valid */\n\tif (size == 0 || size > BBRAM_EMUL_MAX_READ_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested read operation exceeds the memory bounds */\n\tif (offset + size > BBRAM_EMUL_MEM_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the requested read operation involves invalid memory */\n\tfor (size_t i = 0; i < size; i++) {\n\t\tif (mem_ptr[offset + i] == BBRAM_EMUL_INVALID_BYTE) {\n\t\t\tdata_ptr->status.is_invalid = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Copy the data from the specified offset in the device's memory to the provided buffer */\n\tfor (size_t i = 0; i < size; i++) {\n\t\tdata[i] = mem_ptr[offset + i];\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 41.00827302612422}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tint ret;\n\n\tif (size > BBRAM_EMUL_MAX_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_MAX_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_ptr->status.is_invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_ptr->memory + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 61.29887651289475}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ptr = dev->data;\n\tuint8_t *memory = data_ptr->memory;\n\tbool is_invalid = data_ptr->status.is_invalid;\n\tbool is_write_size_valid = size <= BBRAM_EMUL_MAX_WRITE_SIZE;\n\tbool is_write_offset_valid = offset <= BBRAM_EMUL_MAX_OFFSET;\n\tbool is_write_offset_within_bounds = offset + size <= BBRAM_EMUL_MAX_OFFSET;\n\tbool is_write_offset_not_in_invalid_state =!is_invalid;\n\n\tif (!is_invalid &&!is_write_size_valid &&!is_write_offset_valid &&!is_write_offset_within_bounds &&!is_write_offset_not_in_invalid_state) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(memory + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 53.342076993543095}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_dev = dev->data;\n\tint ret = 0;\n\n\tif (size > data_dev->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_dev->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_dev->status.is_invalid) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data_dev->mem + offset, data, size);\n\n\treturn ret;\n}", "CodeBleu_score": 60.64799524737856}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint ret;\n\n\tif (argc < 1) {\n\t\tshell_error(sh, \"Missing device name.\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[0]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found.\n\", argv[0]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = device_open(*bbram_dev, DEVICE_MODE_ALL);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Device %s open failed.\n\", argv[0]);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 66.07940376536867}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint ret;\n\tconst struct device *dev;\n\n\tif (argc!= 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = device_open(dev, DEVICE_MODE_ALL);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Device open failed\");\n\t\treturn ret;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}", "CodeBleu_score": 66.23501099884609}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tstruct device *dev;\n\tconst struct device *bbram_dev_found = NULL;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing required argument for device\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tbbram_dev_found = device_get_binding(BBRAM_DEVICE_NAME);\n\tif (bbram_dev_found == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = bbram_dev_found;\n\n\treturn 0;\n}", "CodeBleu_score": 68.11408866727632}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t", "CodeBleu_score": 5.485908994710939}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_uart_data *data = dev->data;\n\tuint8_t *buf = data->hdr_buf;\n\tuint32_t hdr_len = data->hdr_len;\n\tuint32_t hdr_off = data->hdr_off;\n\tuint32_t hdr_rem = data->hdr_rem;\n\n\tuint32_t bytes_read = 0;\n\n\twhile (hdr_rem > 0) {\n\t\tuint32_t hdr_rem_old = hdr_rem;\n\t\tbytes_read = uart_fifo_read(dev, buf + hdr_off, hdr_rem);\n\t\tif (bytes_read == 0) {\n\t\t\tLOG_ERR(\"Failed to read header from UART device %s\", dev->name);\n\t\t\treturn;\n\t\t}\n\t\thdr_off += bytes_read;\n\t\thdr_rem -= bytes_read;\n\t\tif (hdr_rem == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdata->hdr_len = hdr_len;\n\tdata->hdr_off = hdr_off;\n\tdata->hdr_rem = hdr_rem;\n}", "CodeBleu_score": 32.87910732985021}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint ret;\n\tuint8_t *hdr_buf = (uint8_t *) hdr_buf_ptr;\n\tuint16_t hdr_buf_len = hdr_buf_len_ptr;\n\tuint16_t hdr_buf_off = hdr_buf_off_ptr;\n\tuint16_t hdr_buf_sz = hdr_buf_sz_ptr;\n\n\tuint16_t hdr_buf_avail = hdr_buf_sz - hdr_buf_off;\n\n\tuint16_t hdr_buf_read = 0;\n\tuint16_t hdr_buf_remain = hdr_buf_len - hdr_buf_off;\n\n\tif (hdr_buf_remain > hdr_buf_avail) {\n\t\thdr_buf_remain = hdr_buf_avail;\n\t}\n\n\tret = uart_fifo_read(dev, hdr_buf + hdr_buf_off, hdr_buf_remain, &hdr_buf_read);\n\tif (ret!= 0) {\n\t\tLOG_ERR(\"Failed to read header from UART device: %d\", ret);\n\t\treturn;\n\t}\n\n\thdr_buf_off += hdr_buf_read;\n\thdr_buf_remain -= hdr_buf_read;\n\n\tif (hdr_buf_remain == 0) {\n\t\thdr_buf_off = 0;\n\t}\n\n\t*hdr_buf_ptr = hdr_buf;\n\t*hdr_buf_len_ptr = hdr_buf_len;\n\t*hdr_buf_off_ptr = hdr_buf_off;\n\t*hdr_buf_sz_ptr = hdr_buf_sz;\n}", "CodeBleu_score": 38.23583137397654}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read = 0;\n\n\twhile (read < len) {\n\t\tread += uart_fifo_read(uart, buf + read, len - read);\n\t}\n\n\treturn read;\n}", "CodeBleu_score": 34.41371623790239}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buffer[33];\n\tsize_t ret;\n\tsize_t i;\n\n\tfor (i = 0; i < len; i += ret) {\n\t\tret = uart_fifo_read(uart, buffer + i, sizeof(buffer) - i);\n\t\tif (ret == 0) {\n\t\t\tLOG_ERR(\"Error reading from UART FIFO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn len;\n}", "CodeBleu_score": 38.24277911419699}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t bytes_read = 0;\n\tuint8_t buf[33];\n\tint err;\n\n\twhile (len) {\n\t\tsize_t bytes_to_read = len > sizeof(buf)? sizeof(buf) : len;\n\t\terr = uart_fifo_read(uart, buf, bytes_to_read, K_NO_WAIT);\n\t\tif (err == -EAGAIN) {\n\t\t\t/* No data available */\n\t\t\treturn bytes_read;\n\t\t} else if (err) {\n\t\t\tLOG_ERR(\"Failed to read from UART device (%d)\", err);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= bytes_to_read;\n\t\tbytes_read += bytes_to_read;\n\t}\n\treturn bytes_read;\n}", "CodeBleu_score": 48.75731001551489}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tstruct zbus_observer *obs_tmp;\n\tunsigned int highest_priority = 0;\n\tunsigned int i;\n\n\tchan_lock(chan);\n\n\tfor (i = 0; i < chan->n_observers; i++) {\n\t\tobs = &chan->observers[i];\n\t\tif (!obs->enabled)\n\t\t\tcontinue;\n\t\tif (obs->priority > highest_priority)\n\t\t\thighest_priority = obs->priority;\n\t}\n\n\tchan->highest_priority = highest_priority;\n\n\tchan_unlock(chan);\n}", "CodeBleu_score": 29.66312696908902}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tstruct zbus_observer *highest = NULL;\n\tint highest_priority = 0;\n\n\tif (chan == NULL) {\n\t\treturn;\n\t}\n\n\tpthread_mutex_lock(&chan->lock);\n\n\tfor (obs = chan->observers; obs!= NULL; obs = obs->next) {\n\t\tif (obs->enabled) {\n\t\t\tif (obs->priority > highest_priority) {\n\t\t\t\thighest_priority = obs->priority;\n\t\t\t\thighest = obs;\n\t\t\t}\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = highest_priority;\n\tchan->highest_observer = highest;\n\n\tpthread_mutex_unlock(&chan->lock);\n}", "CodeBleu_score": 31.629104283886463}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_observer *obs;\n\tint hop;\n\n\t/* Lock the channel data */\n\tpthread_mutex_lock(&chan->data.lock);\n\n\t/* Iterate through the observers */\n\tfor (obs = chan->data.observers; obs!= NULL; obs = obs->next) {\n\t\t/* Check if the observer is enabled */\n\t\tif (obs->enabled) {\n\t\t\t/* Check if the observer's priority is higher than the current highest */\n\t\t\tif (obs->priority > chan->data.highest_priority) {\n\t\t\t\t/* Update the highest observer priority */\n\t\t\t\tchan->data.highest_priority = obs->priority;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the channel's highest observer priority */\n\thop = chan->data.highest_priority;\n\n\t/* Unlock the channel data */\n\tpthread_mutex_unlock(&chan->data.lock);\n\n\t/* Return the highest observer priority */\n\treturn hop;\n}", "CodeBleu_score": 26.09435944455195}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_data.observers_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_data.observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs!= obs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst struct zbus_channel *chan = observation->chan;\n\n\t\t\tchan_update_hop(chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.22810057637318}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_end_idx;\n\n\t\tfor (int16_t i = 0; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tif (observation_mask->enabled) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 31.09413352589091}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t", "CodeBleu_score": 8.123366737466174}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tif (zbus_in_isr()) {\n\t\treturn -1;\n\t}\n\n\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\n\tspinlock_lock(&zbus_lock);\n\tobs->priority = ZBUS_THREAD_PRIORITY_MIN;\n\tupdate_all_channels_hop(obs);\n\tspinlock_unlock(&zbus_lock);\n\treturn 0;\n}", "CodeBleu_score": 50.77323577611141}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tassert_not_in_isr();\n\tassert_not_null(obs);\n\n\tspinlock_lock(&obs->lock);\n\tobs->priority = zbus_thread_get_priority_min();\n\tupdate_all_channels_hop(obs);\n\tspinlock_unlock(&obs->lock);\n\treturn 0;\n}", "CodeBleu_score": 44.301403208805525}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tassert(zbus_in_isr() == 0);\n\tassert(obs!= NULL);\n\n\tspinlock_lock(&zbus_obs_lock);\n\tzbus_obs_set_priority(obs, ZBUS_THREAD_PRIO_MIN);\n\tupdate_all_channels_hop(obs);\n\tspinlock_unlock(&zbus_obs_lock);\n\n\treturn 0;\n}", "CodeBleu_score": 48.826338188844154}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tnt err;\n\tk_timeout_t end_time;\n\tint prio;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"zbus channel is NULL\");\n\n\tif (IS_ENABLED(CONFIG_ZBUS_PRIORITY_BOOST)) {\n\t\tend_time = k_uptime_add(k_uptime_get(), timeout);\n\t} else {\n\t\tend_time = timeout;\n\t}\n\n\terr = chan_lock(chan, end_time, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 68.32476587962837}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tnt err = 0;\n\tint prio = 0;\n\n\t_ZBUS_ASSERT(chan!= NULL, \"channel must be not NULL\");\n\n\tif (IS_ENABLED(CONFIG_ZBUS_MSG_SUBSCRIBER)) {\n\t\t_ZBUS_ASSERT(chan->data->msg_subscriber_pool!= NULL, \"msg_subscriber_pool must be not NULL\");\n\t}\n\n\tif (IS_ENABLED(CONFIG_ZBUS_RUNTIME_OBSERVERS)) {\n\t\t_ZBUS_ASSERT(chan->data->observers!= NULL, \"observers must be not NULL\");\n\t}\n\n\tif (IS_ENABLED(CONFIG_ZBUS_PRIORITY_BOOST)) {\n\t\tif (!k_is_in_isr()) {\n\t\t\tprio = k_thread_priority_get(k_current_get());\n\n\t\t\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\t\t\tif (prio > chan->data->highest_observer_priority) {\n\t\t\t\t\tchan->data->highest_observer_priority = prio;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tk_timeout_t end_time = k_uptime_get() + timeout;\n\n\tif (IS_ENABLED(CONFIG_ZBUS_MSG_SUBSCRIBER)) {\n\t\t/* When the priority boost is disabled, this IF will be optimized out. */\n\t\tif (IS_ENABLED(CONFIG_ZBUS_PRIORITY_BOOST)) {\n\t\t\tif (prio < ZBUS_MIN_THREAD_PRIORITY) {\n\t\t\t\tk_thread_priority_set(k_current_get(), ZBUS_MIN_THREAD_PRIORITY);\n\t\t\t}\n\t\t}\n\n\t\terr = chan_lock(chan, timeout, &prio);\n\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\n\t\terr = _zbus_vded_exec(chan, end_time);\n\n\t\tchan_unlock(chan, prio);\n\t} else {\n\t\terr = chan_lock(chan, timeout, &prio);\n\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\n\t\terr = _zbus_vded_exec(chan, end_time);\n\n\t\tchan_unlock(chan, prio);\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 53.0404544840775}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tf (!chan) {\n\t\tLOG_ERR(\"Channel is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tk_timeout_t end_time = k_uptime_offset_get() + timeout;\n\n\tif (k_is_in_isr()) {\n\t\tend_time = k_uptime_offset_get() + timeout;\n\t}\n\n\tint prio;\n\tint err = chan_lock(chan, end_time, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 46.78449949036525}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (Int < 32) {\n\t\tif (enable) {\n\t\t\tETH->DMAITR |= (uint32_t) 1 << Int;\n\t\t} else {\n\t\t\tETH->DMAITR &= ~(uint32_t) 1 << Int;\n\t\t}\n\t} else if (Int < 64) {\n\t\tInt -= 32;\n\t\tif (enable) {\n\t\t\tETH->PTPTSCR |= (uint32_t) 1 << Int;\n\t\t} else {\n\t\t\tETH->PTPTSCR &= ~(uint32_t) 1 << Int;\n\t\t}\n\t} else if (Int < 80) {\n\t\tInt -= 64;\n\t\tif (enable) {\n\t\t\tETH->DMAITR |= (uint32_t) 1 << Int;\n\t\t} else {\n\t\t\tETH->DMAITR &= ~(uint32_t) 1 << Int;\n\t\t}\n\t} else {\n\t\tInt -= 80;\n\t\tif (enable) {\n\t\t\tETH->MACITR |= (uint32_t) 1 << Int;\n\t\t} else {\n\t\t\tETH->MACITR &= ~(uint32_t) 1 << Int;\n\t\t}\n\t}\n}", "CodeBleu_score": 24.631754341606456}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t tmpreg = 0;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_IT(Int));\n\n\t/* Get the ETH_IT register value */\n\ttmpreg = ETH->IT;\n\n\t/* Clear the interrupt */\n\ttmpreg &= ~Int;\n\n\t/* Set the interrupt */\n\tif (enable!= FALSE) {\n\t\ttmpreg |= Int;\n\t}\n\n\t/* Update the interrupt mask */\n\tETH->IT = tmpreg;\n}", "CodeBleu_score": 26.974455923176798}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc;\n\tuint32_t temp;\n\tuint32_t tx_desc_index = 0;\n\tuint32_t tx_desc_index_next = 0;\n\n\ttx_desc = (ETH_TX_DESC *)ETH_TX_DESC_LIST_BASE_ADDRESS;\n\ttemp = tx_desc->Status & ETH_TX_DESC_OWN_BIT;\n\n\twhile (temp == 1) {\n\t\ttx_desc_index_next = (tx_desc_index + 1) % ETH_TX_DESC_NUM;\n\t\ttx_desc = (ETH_TX_DESC *) (ETH_TX_DESC_LIST_BASE_ADDRESS + (tx_desc_index_next * ETH_TX_DESC_SIZE));\n\t\ttemp = tx_desc->Status & ETH_TX_DESC_OWN_BIT;\n\t\ttx_desc_index = tx_desc_index_next;\n\t}\n\n\treturn tx_desc;\n}", "CodeBleu_score": 42.71830370726432}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tuint32_t *pDescAddr;\n\n\tpDescAddr = (uint32_t *) ETH_TX_DESC_LIST;\n\n\tdo {\n\t\tpTxDesc = (ETH_TX_DESC *) *pDescAddr;\n\t\tif (pTxDesc->Status & ETH_DMATXDESC_OWN) {\n\t\t\tpTxDesc = 0;\n\t\t} else {\n\t\t\t*pDescAddr = (uint32_t) pTxDesc->NextDescAddr;\n\t\t}\n\t} while (pTxDesc == 0);\n\n\treturn pTxDesc;\n}", "CodeBleu_score": 45.96326077491353}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *TxDesc;\n\tuint32_t TxDescAddr;\n\n\tTxDescAddr = ETH->DMATPDR;\n\tTxDesc = (ETH_TX_DESC *)TxDescAddr;\n\twhile ((TxDesc->Status & ETH_DMATXDESC_OWN)!= (uint32_t)RESET) {\n\t\tTxDesc++;\n\t\tif (TxDesc == (ETH_TX_DESC *)DMATXDESC_RDPTR) {\n\t\t\tTxDesc = (ETH_TX_DESC *)DMATXDESC_BASE;\n\t\t}\n\t}\n\treturn TxDesc;\n}", "CodeBleu_score": 48.23372193295181}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t", "CodeBleu_score": 14.149251500080561}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_uint32_t cyp_adc_channel = 0;\n\trt_uint32_t adc_value = 0;\n\n\tRT_ASSERT(device!= RT_NULL);\n\n\tcyp_adc_channel = cyp_adc_get_channel(channel);\n\tif (cyp_adc_channel == 0) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (Cy_CSDIDAC_OutputEnable(cyp_adc_channel, *value)!= CY_CSDIDAC_SUCCESS) {\n\t\treturn -RT_ERROR;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 54.37353831350797}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\trt_err_t result = RT_EOK;\n\tcy_en_csd_idac_channel_t cyp_adc_channel = cyp_adc_get_channel(channel);\n\tcy_stc_csd_idac_config_t cyp_adc_config;\n\tcy_en_csd_idac_status_t cyp_adc_status;\n\tcy_stc_csd_idac_result_t cyp_adc_result;\n\n\t/* Check for null pointer */\n\tif (device == RT_NULL) {\n\t\treturn RT_ERROR;\n\t}\n\n\t/* Initialize the DAC channel */\n\tcy_en_csd_idac_status_t cyp_adc_status = Cy_CSDIDAC_Init(cyp_adc_channel, &cyp_adc_config);\n\tif (cyp_adc_status!= CY_CSD_IDAC_STATUS_SUCCESS) {\n\t\trt_kprintf(\"cyp_adc_convert: Cy_CSDIDAC_Init failed\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\t/* Enable the DAC output with the specified value */\n\tcyp_adc_status = Cy_CSDIDAC_OutputEnable(cyp_adc_channel, *value);\n\tif (cyp_adc_status!= CY_CSD_IDAC_STATUS_SUCCESS) {\n\t\trt_kprintf(\"cyp_adc_convert: Cy_CSDIDAC_OutputEnable failed\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\t/* Get the DAC result */\n\tcyp_adc_status = Cy_CSDIDAC_GetResult(cyp_adc_channel, &cyp_adc_result);\n\tif (cyp_adc_status!= CY_CSD_IDAC_STATUS_SUCCESS) {\n\t\trt_kprintf(\"cyp_adc_convert: Cy_CSDIDAC_GetResult failed\n\");\n\t\treturn RT_ERROR;\n\t}\n\n\t/* Return the DAC result */\n\t*value = cyp_adc_result.idac_result;\n\n\treturn result;\n}", "CodeBleu_score": 43.48270704870926}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif (addr + size > 0x7FFFF) {\n\t\trt_kprintf(\"flash read error: address out of range\n\");\n\t\treturn -RT_ERROR;\n\t}\n\n\trt_uint32_t i;\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 41.35834192043338}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t addr_end;\n\trt_uint32_t addr_start;\n\trt_uint32_t size_end;\n\trt_uint32_t size_start;\n\trt_uint32_t size_total;\n\n\t/* check the address and size */\n\tif (addr > IFX_FLASH_END_ADDRESS) {\n\t\t/* address is out of range */\n\t\treturn IFX_FLASH_ERROR_ADDRESS;\n\t}\n\n\tif (size > IFX_FLASH_MAX_SIZE) {\n\t\t/* size is out of range */\n\t\treturn IFX_FLASH_ERROR_SIZE;\n\t}\n\n\t/* calculate the start address and size */\n\taddr_start = addr & 0xFFFF0000;\n\tsize_start = addr & 0x0000FFFF;\n\n\t/* calculate the end address and size */\n\taddr_end = addr_start + size_start;\n\tsize_end = IFX_FLASH_END_ADDRESS - addr_end + 1;\n\n\t/* calculate the total size */\n\tsize_total = size_start + size_end;\n\n\t/* check if the read operation would exceed the flash memory's end address */\n\tif (size_total > IFX_FLASH_MAX_SIZE) {\n\t\t/* read operation would exceed the flash memory's end address */\n\t\treturn IFX_FLASH_ERROR_ADDRESS;\n\t}\n\n\t/* read data from flash memory */\n\tfor (i = 0; i < size_start; i++) {\n\t\tbuf[i] = ifx_flash_read_byte(addr_start + i);\n\t}\n\n\tfor (i = 0; i < size_end; i++) {\n\t\tbuf[size_start + i] = ifx_flash_read_byte(addr_end - i);\n\t}\n\n\t/* return the number of bytes read */\n\treturn size_total;\n}", "CodeBleu_score": 39.41141763775812}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t", "CodeBleu_score": 5.618627102069132}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 25.93903568558227}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\n\tcyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(obj);\n}", "CodeBleu_score": 28.50932842614228}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tif (timer == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\tcyhal_timer_t *obj = (cyhal_timer_t *) timer->parent.user_data;\n\treturn cyhal_timer_read(obj);\n}", "CodeBleu_score": 49.53348521244975}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\tif (pthread_mutex_lock(&dfs_mutex)!= 0) {\n\t\tassert(0);\n\t}\n}", "CodeBleu_score": 9.166510219810457}, {"code": "void dfs_lock(void){\n\t\tint ret;\n\tret = pthread_mutex_lock(&dfs_mutex);\n\tif (ret!= 0) {\n\t\tassert(ret == 0);\n\t}\n}", "CodeBleu_score": 7.11745397062465}, {"code": "void dfs_lock(void){\n\t\tint i = 0;\n\twhile (pthread_mutex_trylock(&dfs_mutex)!= 0) {\n\t\ti++;\n\t\tif (i > 500) {\n\t\t\tassert(0);\n\t\t}\n\t}\n}", "CodeBleu_score": 22.850064904272653}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint index;\n\tfor (index = startfd; index < fdt->maxfd; index++) {\n\t\tif (fdt->fds[index] == NULL) {\n\t\t\treturn index;\n\t\t}\n\t}\n\treturn fd_slot_expand(fdt, startfd);\n}", "CodeBleu_score": 29.203514071256897}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint nr;\n\tint index;\n\tstruct dfs_file **fds = NULL;\n\n\tif (startfd < fdt->maxfd) {\n\t\tfor (i = startfd; i < fdt->maxfd; i++) {\n\t\t\tif (!fdt->fds[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\n\tnr = ((fdt->maxfd + 4) & ~3);\n\tif (nr > DFS_FD_MAX) {\n\t\tnr = DFS_FD_MAX;\n\t}\n\tfds = (struct dfs_file **)rt_realloc(fdt->fds, nr * sizeof(struct dfs_file *));\n\tif (!fds) {\n\t\treturn -1;\n\t}\n\n\t/* clean the new allocated fds */\n\tfor (index = fdt->maxfd; index < nr; index++) {\n\t\tfds[index] = NULL;\n\t}\n\tfdt->fds = fds;\n\tfdt->maxfd = nr;\n\n\treturn startfd;\n}", "CodeBleu_score": 43.16827247037022}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint i;\n\tint index;\n\n\tfor (i = startfd; i < fdt->maxfd; i++) {\n\t\tif (fdt->fds[i] == NULL) {\n\t\t\treturn fd_slot_expand(fdt, i);\n\t\t}\n\t}\n\n\t/* no empty slot found, try to expand */\n\tindex = fd_slot_expand(fdt, startfd);\n\tif (index < 0) {\n\t\treturn -1;\n\t}\n\n\treturn index;\n}", "CodeBleu_score": 40.62740982721571}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tchar *errstr = NULL;\n\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (i = 0; rt_err_strings[i].errstr!= NULL; i++) {\n\t\tif (rt_err_strings[i].errnum == error) {\n\t\t\terrstr = rt_err_strings[i].errstr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (errstr == NULL) {\n\t\terrstr = \"EUNKNOWN\";\n\t}\n\treturn errstr;\n}", "CodeBleu_score": 51.093453383337106}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\n\tif (error < 0)\n\t\terror = -error;\n\n\tfor (i = 0; rt_err_strings[i].error!= RT_ERR_UNKNOWN; i++) {\n\t\tif (rt_err_strings[i].error == error)\n\t\t\treturn rt_err_strings[i].string;\n\t}\n\n\treturn \"EUNKNOWN\";\n}", "CodeBleu_score": 56.67989805137626}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\tfor (int i = 0; i < RT_ERR_MAX; i++) {\n\t\tif (error == rt_err_strings[i].code) {\n\t\t\treturn rt_err_strings[i].str;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 49.015328075404064}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\tstruct rt_thread *thread = rt_thread_self();\n\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(thread->stat == RT_THREAD_READY);\n\n\tlevel = rt_hw_spin_lock_irqsave(&thread->lock);\n\n\tif (thread->idle_hook == RT_NULL) {\n\t\tthread->idle_hook = hook;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\n\trt_hw_spin_unlock_irqrestore(&thread->lock, level);\n\n\treturn result;\n}", "CodeBleu_score": 29.582688756730157}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_spin_lock(&idle_hook_lock);\n\tif (idle_hook_count < RT_THREAD_IDLE_HOOK_MAX) {\n\t\tidle_hook_list[idle_hook_count] = hook;\n\t\tidle_hook_count++;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\trt_spin_unlock(&idle_hook_lock);\n\treturn result;\n}", "CodeBleu_score": 26.748608509932804}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t ret = RT_EOK;\n\trt_base_t level;\n\trt_thread_t thread;\n\n\tif (hook == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tthread = rt_thread_self();\n\tif (thread == RT_NULL) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (thread->stat!= RT_THREAD_STAT_IDLE) {\n\t\treturn -RT_ERROR;\n\t}\n\n\tlevel = rt_hw_spin_lock_irqsave();\n\tif (thread->idle_hook_list == RT_NULL) {\n\t\tthread->idle_hook_list = rt_list_create(&thread->idle_hook_list);\n\t\tif (thread->idle_hook_list == RT_NULL) {\n\t\t\trt_hw_spin_unlock_irqrestore(level);\n\t\t\treturn -RT_ENOMEM;\n\t\t}\n\t}\n\n\trt_list_insert_after(thread->idle_hook_list, &thread->idle_hook, hook);\n\trt_hw_spin_unlock_irqrestore(level);\n\n\treturn ret;\n}", "CodeBleu_score": 31.103949942941856}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\n\t/* Lock the spinlock */\n\tlevel = rt_hw_spin_lock_irqsave(&rt_thread_idle_hook_lock);\n\n\t/* Iterate through the idle hook list to find the specified hook */\n\trt_list_t *node = rt_list_get_next(&rt_thread_idle_hook_list);\n\twhile (node!= &rt_thread_idle_hook_list) {\n\t\tif (node->data == hook) {\n\t\t\trt_list_remove(node);\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t\tnode = rt_list_get_next(node);\n\t}\n\n\t/* Unlock the spinlock */\n\trt_hw_spin_unlock_irqrestore(&rt_thread_idle_hook_lock, level);\n\n\treturn result;\n}", "CodeBleu_score": 47.069546604633075}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_list_t *p;\n\trt_list_t *q;\n\trt_list_t *r;\n\trt_spin_lock_irqsave(&idle_hook_list_lock, level);\n\tp = idle_hook_list.next;\n\twhile (p!= &idle_hook_list) {\n\t\tq = p->next;\n\t\tif (p->item.value == (rt_uint32_t)hook) {\n\t\t\tr = p;\n\t\t\tp = q;\n\t\t\trt_list_remove(&r->item);\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t\tp = q;\n\t}\n\trt_spin_unlock_irqrestore(&idle_hook_list_lock, level);\n\treturn result;\n}", "CodeBleu_score": 42.39016213998743}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_spin_lock_irqsave(&_rt_thread_idle_lock, _rt_thread_idle_lock_flag);\n\trt_list_t *list = &_rt_thread_idle_list;\n\trt_list_t *node = list->next;\n\twhile (node!= list) {\n\t\tif (node->data == hook) {\n\t\t\trt_list_remove(node);\n\t\t\tnode->data = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t\tnode = node->next;\n\t}\n\tif (node == list) {\n\t\tresult = RT_EIO;\n\t}\n\trt_spin_unlock_irqrestore(&_rt_thread_idle_lock, _rt_thread_idle_lock_flag);\n\treturn result;\n}", "CodeBleu_score": 42.913072449429826}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_err_t result = RT_EOK;\n\n\trt_enter_critical();\n\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, suspend_list);\n\t\trt_list_remove(susp_list->next);\n\t\trt_thread_resume(thread, thread_error);\n\t}\n\n\trt_exit_critical();\n\n\treturn result;\n}", "CodeBleu_score": 37.197095324464144}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_err_t result;\n\n\tRT_ASSERT(susp_list!= RT_NULL);\n\tRT_ASSERT(rt_thread_scheduler_is_locked() == RT_EOK);\n\n\twhile (!rt_list_isempty(susp_list)) {\n\t\tthread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n\t\trt_list_remove(&thread->tlist);\n\n\t\tresult = rt_thread_resume(thread, thread_error);\n\t\tif (result!= RT_EOK) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 45.93827885902062}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_list_t *node;\n\trt_list_t *next;\n\trt_list_t *tail;\n\n\tif (rt_list_isempty(susp_list)) {\n\t\treturn RT_EOK;\n\t}\n\n\t/* Ensure the scheduler is unlocked */\n\trt_scheduler_lock();\n\n\t/* Dequeue and wake up each suspended thread from the list one by one until the list is empty */\n\ttail = susp_list->prev;\n\tfor (node = susp_list->next; node!= tail; node = next) {\n\t\tnext = node->next;\n\t\tthread = rt_list_entry(node, rt_thread_t, suspend_list);\n\t\trt_thread_resume(thread, thread_error);\n\t}\n\n\t/* Ensure the scheduler is locked */\n\trt_scheduler_unlock();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 37.9383560952867}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_device = rt_console_get_device();\n\trt_device_t new_device = rt_device_find(name);\n\tif (new_device!= RT_NULL && new_device!= old_device) {\n\t\tif (old_device!= RT_NULL) {\n\t\t\trt_device_close(old_device);\n\t\t}\n\t\trt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_OFLAG_STREAM);\n\t\trt_console_set_device(new_device);\n\t}\n\treturn old_device;\n}", "CodeBleu_score": 51.552031092999805}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = rt_console_get_device();\n\trt_device_t new_console = rt_device_find(name);\n\tif (new_console!= RT_NULL && new_console!= old_console) {\n\t\tif (old_console!= RT_NULL) {\n\t\t\trt_device_close(old_console);\n\t\t}\n\t\trt_device_open(new_console, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t\trt_console_set_device(new_console);\n\t}\n\treturn old_console;\n}", "CodeBleu_score": 44.571253365304564}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console = rt_console_get_device();\n\trt_device_t new_console = rt_device_find(name);\n\n\tif (new_console!= RT_NULL) {\n\t\tif (new_console!= old_console) {\n\t\t\tif (old_console!= RT_NULL) {\n\t\t\t\trt_device_close(old_console);\n\t\t\t}\n\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\trt_console_set_device(new_console);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn old_console;\n}", "CodeBleu_score": 50.91671266274558}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_class *class_ptr;\n\tint count = 0;\n\tint i;\n\n\t// get the object class pointer\n\tclass_ptr = rt_object_class_get_ptr(type);\n\n\t// lock the object class spinlock\n\trt_spinlock_lock(&class_ptr->spinlock);\n\n\t// iterate through the object list and count the objects\n\tfor (i = 0; i < class_ptr->object_count; i++) {\n\t\tif (class_ptr->object_list[i]!= NULL) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t// release the object class spinlock\n\trt_spinlock_unlock(&class_ptr->spinlock);\n\n\treturn count;\n}", "CodeBleu_score": 32.66646030053836}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tspinlock_acquire(&object_class_spinlock[type]);\n\tstruct rt_object_class *object_class = &object_class_table[type];\n\tstruct rt_object *object = object_class->head;\n\twhile (object!= NULL) {\n\t\tcount++;\n\t\tobject = object->next;\n\t}\n\tspinlock_release(&object_class_spinlock[type]);\n\treturn count;\n}", "CodeBleu_score": 35.10521194719078}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tspinlock_t *lock;\n\tstruct rt_object_class *class = rt_object_get_class(type);\n\n\tlock = rt_object_get_spinlock(type);\n\tspin_lock(lock);\n\tstruct rt_object *object = class->head;\n\twhile (object!= NULL) {\n\t\tcount++;\n\t\tobject = object->next;\n\t}\n\tspin_unlock(lock);\n\treturn count;\n}", "CodeBleu_score": 32.814593792297444}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\trt_list_t *list;\n\trt_object_t *object_ptr;\n\n\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\tobject_ptr = (rt_object_t *) object;\n\tlist = &object_ptr->parent.list;\n\n\tif (rt_list_isempty(list)) {\n\t\treturn;\n\t}\n\n\trt_list_remove(list);\n\tobject_ptr->parent.type = RT_Object_Type_None;\n}", "CodeBleu_score": 30.96450672599117}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\trt_object_t parent = rt_object_get_parent(object);\n\tif (parent!= RT_NULL) {\n\t\trt_list_remove(&object->parent.list);\n\t}\n\n\trt_spin_lock(&object->lock);\n\tobject->type = RT_Object_Type_None;\n\trt_spin_unlock(&object->lock);\n}", "CodeBleu_score": 27.21641366598833}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\trt_object_t object_parent = object->parent;\n\trt_list_t *list = &object_parent->list;\n\trt_list_remove(list, object);\n\tobject->parent = RT_NULL;\n\tobject->type = RT_Object_Type_None;\n\trt_spin_unlock(&object->lock);\n}", "CodeBleu_score": 34.85216251902217}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result = RT_EOK;\n\trt_object_information_t *information;\n\trt_base_t level;\n\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\tinformation = rt_object_get_information(RT_Object_Class_Custom);\n\tRT_ASSERT(information!= RT_NULL);\n\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n\tif (obj->destroy!= RT_NULL) {\n\t\tresult = obj->destroy(obj);\n\t}\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 42.535471722541644}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t ret = RT_EOK;\n\tstruct rt_object_information *information;\n\n\t/* object check */\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(!(obj->type & RT_Object_Class_Static));\n\n\tinformation = rt_object_get_information((enum rt_object_class_type)obj->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\tif (information->destroy) {\n\t\tret = information->destroy(obj);\n\t}\n\n\trt_object_delete(obj);\n\n\treturn ret;\n}", "CodeBleu_score": 47.62552141531843}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result;\n\trt_object_t object;\n\trt_base_t level;\n\tstruct rt_object_information *information;\n\n\t/* object check */\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(!(obj->type & RT_Object_Class_Static));\n\n\tinformation = rt_object_get_information((enum rt_object_class_type)obj->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\tlevel = rt_spin_lock_irqsave(&(information->spinlock));\n\n\t/* remove from old list */\n\trt_list_remove(&(obj->list));\n\n\trt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n\tobject = rt_object_detach(obj);\n\n\trt_object_delete(obj);\n\n\tif (object->type == RT_Object_Class_Custom) {\n\t\tresult = rt_object_call_destroy(object);\n\t} else {\n\t\tresult = RT_EOK;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 43.40249712206911}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\tdef RT_USING_SMP\n    rt_thread_t thread = rt_thread_self();\n#else\n    rt_thread_t thread = rt_hw_thread_self();\n#endif\n    rt_base_t level;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_thread_defunct(thread);\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* trigger context switch */\n    rt_schedule();\n}", "CodeBleu_score": 63.28164918645466}, {"code": "static void _thread_exit(void){\n\tdefined(RT_USING_HOOK) && defined(RT_USING_HOOK_THREAD_EXIT)\n    rt_uint8_t level;\n\n    level = rt_hw_interrupt_disable();\n    rt_thread_exit(rt_thread_self());\n    rt_hw_interrupt_enable(level);\n#else\n    rt_thread_exit(rt_thread_self());\n#endif\n}", "CodeBleu_score": 55.936708106662934}, {"code": "static void _thread_exit(void){\n\tdef RT_USING_SMP\n    rt_thread_t thread = rt_cpu_self()->current_thread;\n\n    RT_ASSERT(thread!= RT_NULL);\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_list_insert_before(&(rt_thread_defunct_list), &(thread->tlist));\n\n    /* trigger context switch */\n    rt_schedule();\n#else /*!RT_USING_SMP */\n    rt_thread_t thread = rt_thread_self();\n\n    RT_ASSERT(thread!= RT_NULL);\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_list_insert_before(&(rt_thread_defunct_list), &(thread->tlist));\n\n    /* trigger context switch */\n    rt_schedule();\n#endif /* RT_USING_SMP */\n}", "CodeBleu_score": 52.473503702238254}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\tstruct _thread *thread = (struct _thread *) parameter;\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\tif (thread->state!= _thread_state_suspended) {\n\t\treturn;\n\t}\n\t_scheduler_lock();\n\tthread->error = _thread_error_timeout;\n\t_thread_list_remove(&thread->list);\n\t_thread_list_insert(&thread->list, &_scheduler.ready_list);\n\t_scheduler_unlock();\n}", "CodeBleu_score": 32.492995286989355}, {"code": "static void _thread_timeout(void *parameter){\n\t\tThread *thread = (Thread *) parameter;\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\tif (thread->state!= SUSPENDED) {\n\t\treturn;\n\t}\n\tthread->error_number = TIMEOUT;\n\tthread_list_remove(thread);\n\tthread_list_insert(thread);\n\tscheduler_unlock();\n}", "CodeBleu_score": 30.923135230221497}, {"code": "static void _thread_timeout(void *parameter){\n\t\tThread *thread = (Thread *) parameter;\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\tif (thread->state == THREAD_STATE_SUSPENDED) {\n\t\tscheduler_lock();\n\t\tthread->error = THREAD_ERROR_TIMEOUT;\n\t\tthread_list_remove(thread);\n\t\tthread_list_insert(thread);\n\t\tscheduler_unlock();\n\t}\n}", "CodeBleu_score": 32.49080152504001}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spinlock_lock(&thread->spinlock);\n\tif (thread->mutex_wait_on!= NULL) {\n\t\trt_list_remove(&thread->mutex_wait_on->waiting_threads, thread);\n\t\tthread->mutex_wait_on = NULL;\n\t}\n\tif (thread->mutex_taken!= NULL) {\n\t\trt_list_remove(&thread->mutex_taken->taken_threads, thread);\n\t\tthread->mutex_taken = NULL;\n\t}\n\trt_spinlock_unlock(&thread->spinlock);\n}", "CodeBleu_score": 28.36831209352355}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spinlock_acquire(&thread->spinlock);\n\tif (thread->wait_mutex!= NULL) {\n\t\trt_mutex_t mutex = thread->wait_mutex;\n\t\trt_spinlock_acquire(&mutex->spinlock);\n\t\trt_list_remove(&thread->wait_node);\n\t\tthread->wait_mutex = NULL;\n\t\tmutex->pending = NULL;\n\t\trt_spinlock_release(&mutex->spinlock);\n\t}\n\tfor (int i = 0; i < thread->num_mutexes; i++) {\n\t\trt_mutex_t mutex = thread->mutexes[i];\n\t\trt_spinlock_acquire(&mutex->spinlock);\n\t\trt_list_remove(&thread->mutexes[i]->node);\n\t\tthread->mutexes[i] = NULL;\n\t\tmutex->pending = NULL;\n\t\trt_spinlock_release(&mutex->spinlock);\n\t}\n\trt_spinlock_release(&thread->spinlock);\n}", "CodeBleu_score": 40.70235109597264}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\tif (thread->spinlock.lock) {\n\t\t_spinlock_lock(&thread->spinlock);\n\t}\n\tif (thread->waiting_mutex) {\n\t\trt_mutex_t mutex = thread->waiting_mutex;\n\t\t_spinlock_lock(&mutex->spinlock);\n\t\tif (mutex->waiting_threads) {\n\t\t\trt_thread_t *waiting_threads = mutex->waiting_threads;\n\t\t\tint i;\n\t\t\tfor (i = 0; i < mutex->waiting_threads_count; i++) {\n\t\t\t\tif (waiting_threads[i] == thread) {\n\t\t\t\t\twaiting_threads[i] = waiting_threads[mutex->waiting_threads_count - 1];\n\t\t\t\t\twaiting_threads[mutex->waiting_threads_count - 1] = NULL;\n\t\t\t\t\tmutex->waiting_threads_count--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mutex->pending_thread) {\n\t\t\tmutex->pending_thread = NULL;\n\t\t}\n\t\t_spinlock_unlock(&mutex->spinlock);\n\t}\n\tif (thread->spinlock.lock) {\n\t\t_spinlock_unlock(&thread->spinlock);\n\t}\n}", "CodeBleu_score": 37.9278978007056}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t", "CodeBleu_score": 1.899294977411007}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\t/* check thread state */\n\tif (thread->parent.flag!= RT_THREAD_INIT) {\n\t\tLOG_E(\"thread %s is not in init state\", thread->parent.name);\n\t\treturn -RT_EINVAL;\n\t}\n\n\t/* set thread priority */\n\trt_thread_set_priority(thread, thread->parent.priority);\n\n\t/* reset thread state */\n\tthread->parent.flag = RT_THREAD_SUSPEND;\n\n\t/* resume thread */\n\terror = rt_thread_resume(thread);\n\tif (error!= RT_EOK) {\n\t\tLOG_E(\"thread %s startup failed\", thread->parent.name);\n\t\treturn error;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 52.009480829593244}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t", "CodeBleu_score": 1.899294977411007}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_uint8_t level;\n\trt_list_t *timer_entry;\n\n\t/* check if the highest level of the timer skip list is not empty */\n\tif (rt_list_isempty(&timer_list[TIMER_SKIP_LIST_LEVEL_MAX - 1])) {\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get the first timer entry */\n\ttimer_entry = rt_list_first(&timer_list[TIMER_SKIP_LIST_LEVEL_MAX - 1]);\n\n\t/* set the timeout tick to the timer's timeout value */\n\t*timeout_tick = timer_entry->timeout_tick;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 54.29475251128727}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_uint8_t i = 0;\n\trt_list_t *timer_entry = RT_NULL;\n\n\t/* check if the highest level of the timer skip list is not empty */\n\tif (timer_list[0]!= RT_NULL) {\n\t\t/* get the first timer entry */\n\t\ttimer_entry = rt_list_entry(timer_list[0]->next, struct rt_timer, list);\n\t\t/* set the timeout tick to the timer's timeout value */\n\t\t*timeout_tick = timer_entry->timeout;\n\t\t/* return RT_EOK */\n\t\treturn RT_EOK;\n\t}\n\n\t/* if the highest level of the timer skip list is empty, return an error code */\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 46.95927459043329}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t", "CodeBleu_score": 5.182189237133654}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_TIMER_ALL_SOFT\n    rt_timer_t timer;\n\n    RT_ASSERT(timeout!= RT_NULL);\n\n    timer = rt_malloc(sizeof(struct rt_timer));\n    if (timer!= RT_NULL)\n    {\n        _timer_init(timer, timeout, parameter, time, flag);\n        rt_list_init(&(timer->parent.tlist));\n        rt_list_insert_after(&(rt_timer_soft_list), &(timer->parent.tlist));\n        timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;\n        timer->parent.flag &= ~RT_TIMER_FLAG_SOFT_TIMER;\n        rt_timer_init(timer, name, timeout, parameter, time, flag);\n    }\n    return timer;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 54.48492200561308}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_TIMER_ALL_SOFT\n    rt_timer_t timer;\n\n    timer = rt_malloc(sizeof(struct rt_timer_soft));\n    if (timer!= RT_NULL)\n    {\n        _timer_init(timer, timeout, parameter, time, flag);\n        rt_list_init(&(timer->parent.list));\n        rt_list_insert_after(&(timer_list), &(timer->parent.list));\n        rt_timer_control(timer, RT_TIMER_CTRL_SET_TIME, (rt_uint32_t)time);\n        rt_timer_start(timer);\n    }\n    return timer;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 53.084272804731}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_TIMER_ALL_SOFT\n    rt_timer_t timer;\n\n    RT_ASSERT(timeout!= RT_NULL);\n    RT_ASSERT(time!= RT_TICK_MAX);\n\n    timer = rt_malloc(sizeof(struct rt_timer));\n    if (timer!= RT_NULL)\n    {\n        _timer_init(timer, timeout, parameter, time, flag);\n        rt_list_init(&(timer->list));\n        rt_list_insert_after(&(rt_timer_list), &(timer->list));\n\n        rt_kprintf(\"timer %s create success\n\", name);\n    }\n\n    return timer;\n#else\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 57.82803867632498}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\n\t// Create a new context with the original request and response\n\tctx := context.WithValue(req.Context(), ctxKey, req)\n\n\t// Create a new request with the captured context\n\treq = req.WithContext(ctx)\n\n\t// Call the router's ServeHTTP method to process the request\n\ta.router.ServeHTTP(recorder, req)\n\n\t// Copy the recorder's headers to the original response\n\tfor k, v := range recorder.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\n\t// Copy the recorder's status code to the original response\n\tres.WriteHeader(recorder.Code)\n\n\t// Copy the recorder's body to the original response\n\t_, _ = io.Copy(res, recorder.Body)\n}", "CodeBleu_score": 43.02939716375966}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder to capture the response\n\trec := httptest.NewRecorder()\n\n\t// Call the router's ServeHTTP method to process the request\n\ta.Router.ServeHTTP(rec, req)\n\n\t// Copy the recorder's headers to the original response\n\tfor k, v := range rec.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\n\t// Copy the recorder's status code to the original response\n\tres.WriteHeader(rec.Code)\n\n\t// Copy the recorder's body to the original response\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 37.58686965655774}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\n\t// Call the router's ServeHTTP method to process the request\n\ta.Router.ServeHTTP(recorder, req)\n\n\t// Copy the recorder's headers to the original response\n\tfor k, v := range recorder.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\n\t// Copy the recorder's body to the original response\n\tres.WriteHeader(recorder.Code)\n\tres.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 37.25761901940559}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t", "CodeBleu_score": 2.29984901754818}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tif req.Method == \"GET\" {\n\t\tassetName := req.URL.Path[1:]\n\t\tif assetName == \"\" {\n\t\t\tassetName = \"index.html\"\n\t\t}\n\t\tasset, err := a.Asset(assetName)\n\t\tif err!= nil {\n\t\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\text := filepath.Ext(assetName)\n\t\tswitch ext {\n\t\tcase \".js\":\n\t\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\t\tcase \".css\":\n\t\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\t\tcase \".html\":\n\t\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\t}\n\t\tres.Write(asset)\n\t}\n}", "CodeBleu_score": 53.627636228221995}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the URL path from the request.\n\tpath := req.URL.Path\n\t// Check if the path starts with \"/static/\".\n\tif!strings.HasPrefix(path, \"/static/\") {\n\t\t// If the path does not start with \"/static/\", return a 404 error.\n\t\thttp.Error(res, \"404 not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the file name from the path.\n\tfileName := path[8:]\n\n\t// Open the file.\n\tfile, err := os.Open(fileName)\n\tif err!= nil {\n\t\t// If an error occurs while opening the file, return a 404 error.\n\t\thttp.Error(res, \"404 not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Get the file extension from the file name.\n\text := filepath.Ext(fileName)\n\n\t// Set the appropriate Content-Type header based on the file extension.\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tdefault:\n\t\tres.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t}\n\n\t// Write the file content to the response.\n\tio.Copy(res, file)\n}", "CodeBleu_score": 55.786311688720446}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Path[len(\"/robots/\"):]\n\trobot, err := a.master.FindRobot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(`{\"error\": \"No robot found with name %s\"}`, robotName)))\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(robot.ConnectionsJSON())\n}", "CodeBleu_score": 28.779241581390398}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Find the robot using the master instance\n\trobot, ok := a.master.GetRobot(robotName)\n\tif!ok {\n\t\t// No robot was found with the specified name\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"No robot found with the specified name\"}`))\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot\n\tconnections := robot.GetConnections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// An error occurred while converting the connections to JSON\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(`{\"error\": \"An error occurred while converting the connections to JSON\"}`))\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonConnections)\n}", "CodeBleu_score": 32.114253914141976}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\trobotName := mux.Vars(req)[\"robotName\"]\n\n\t// Find the robot using the master instance.\n\trobot, err := a.master.FindRobot(robotName)\n\tif err!= nil {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the specified name.\"})\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot.\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format.\n\tjsonConnections, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// If there is an error converting the connections to JSON format, write a JSON error message indicating the error.\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"An error occurred while converting the connections to JSON format.\"})\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections.\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(jsonConnections)\n}", "CodeBleu_score": 37.23015828306187}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Check the authorization header\n\t\tauth = strings.TrimPrefix(auth, \"Basic \")\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth)\n\t\tif err!= nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Check the username and password\n\t\tif!secureCompare(string(decoded), username+\":\"+password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 49.73495572211159}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Basic Auth credentials from the header\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif len(auth) == 0 {\n\t\t\t// No credentials were provided\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Decode the Basic Auth credentials\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err!= nil {\n\t\t\t// Could not decode the credentials\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Split the credentials into username and password\n\t\tcredentials := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(credentials)!= 2 {\n\t\t\t// Invalid credentials\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Compare the credentials to the provided username and password\n\t\tif!secureCompare(username, credentials[0]) ||!secureCompare(password, credentials[1]) {\n\t\t\t// Invalid credentials\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Credentials were valid, continue with the request\n\t\treturn\n\t}\n}", "CodeBleu_score": 47.77309381729913}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\tif!strings.HasPrefix(auth, \"Basic \") {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[6:])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair)!= 2 ||!secureCompare(pair[0], username) ||!secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\tw.WriteHeader(401)\n\t}\n}", "CodeBleu_score": 49.3450891195405}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept of the scaling transformation\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\t// Calculate the scaled value\n\t\tvalue = int(math.Round(slope*input + intercept))\n\n\t\t// Clamp the value to the target range\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn\n\t}\n}", "CodeBleu_score": 50.18052282120301}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Max(math.Min(slope*input+intercept, float64(toMax)), float64(toMin)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.96773985080796}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) int {\n\t\treturn int(math.Round(slope * input + intercept))\n\t}\n}", "CodeBleu_score": 45.48319735560005}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.connection.IsValid() {\n\t\treturn 0, 0, errors.New(\"connection is not valid\")\n\t}\n\n\tif!a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\n\trawValue, err := a.connection.ReadAnalog(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.scaleValue(rawValue)\n\n\treturn rawValue, a.lastScaledValue, nil\n}", "CodeBleu_score": 57.98671517512104}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.isValid {\n\t\treturn 0, 0, errors.New(\"Connection is not valid\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.scale(rawValue)\n\treturn rawValue, a.lastScaledValue, nil\n}", "CodeBleu_score": 50.76242862689043}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\"Connection is not valid\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 46.41983855516478}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(input int) float64 {\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 42.79973249779121}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\treturn func(input int) float64 {\n\t\tif input < fromMin {\n\t\t\tinput = fromMin\n\t\t}\n\t\tif input > fromMax {\n\t\t\tinput = fromMax\n\t\t}\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\t\tn := toMin - m*fromMin\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 62.856616049007165}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 40.09414721088014}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t// Create the driver.\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\t// Set the name of the driver.\n\td.SetName(\"grove-piezo-vibration-sensor\")\n\n\t// Add the vibration event.\n\td.AddEvent(NewVibrationEvent())\n\n\t// Set up the event listener.\n\td.SetEventListener(func(data interface{}) {\n\t\t// Get the data.\n\t\tdata, ok := data.(float64)\n\t\tif!ok {\n\t\t\tpanic(\"invalid data type\")\n\t\t}\n\n\t\t// Check if the data exceeds the threshold.\n\t\tif data > 1000 {\n\t\t\t// Publish the vibration event.\n\t\t\td.Publish(NewVibrationEvent())\n\t\t}\n\t})\n\n\t// Return the driver.\n\treturn d\n}", "CodeBleu_score": 42.215291370878724}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t// Create a new driver with the provided analog reader and pin.\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\t// Set the default name for the driver.\n\td.SetName(\"Grove Piezo Vibration Sensor\")\n\n\t// Add a vibration event to the driver.\n\td.AddEvent(events.NewEvent(\"Vibration\", events.LevelMedium, events.TypeState))\n\n\t// Set up an event listener for data events that publishes a vibration event if the data exceeds a threshold value of 1000.\n\td.AddEventListener(events.NewEventListener(func(e events.DataEvent) {\n\t\tif e.Data > 1000 {\n\t\t\td.PublishEvent(events.NewEvent(\"Vibration\", true, events.TypeState))\n\t\t}\n\t}))\n\n\t// Return the initialized driver.\n\treturn d\n}", "CodeBleu_score": 39.82964211967908}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t// Initialize the driver with the provided AnalogSensorDriver\n\tdriver := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\t// Set the default name for the driver\n\tdriver.SetName(\"Grove Piezo Vibration Sensor\")\n\n\t// Add the vibration event\n\tdriver.AddEvent(GrovePiezoVibrationSensorEvent{})\n\n\t// Set up the event listener for data events that publishes a vibration event if the data exceeds a threshold value of 1000\n\tdriver.SetEventListener(func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tdriver.Publish(GrovePiezoVibrationSensorEvent{})\n\t\t}\n\t})\n\n\treturn driver\n}", "CodeBleu_score": 40.908741032023386}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency and the tempo.\n\ttonePeriod := 60.0 / (float64(d.bpm) * hz)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period.\n\tfor i := 0; i < int(duration/tonePeriod); i++ {\n\t\terr := d.buzzer.Toggle()\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod*1000000) * time.Microsecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 33.59109842804754}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := float64(60000) / (float64(d.bpm) * hz)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0; i < int(duration/tonePeriod); i++ {\n\t\tif err := d.Toggle(); err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 38.366420793682195}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.bpm <= 0 {\n\t\treturn errors.New(\"buzzer not initialized\")\n\t}\n\tif hz <= 0 {\n\t\treturn errors.New(\"invalid frequency\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"invalid duration\")\n\t}\n\ttonePeriod := 1.0 / (2.0 * hz)\n\tfor i := 0.0; i < duration; i += tonePeriod {\n\t\tif err := d.Toggle(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod*1000000) * time.Microsecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 49.23289375801566}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\n\td.stop()\n\n\tif err := d.setSleepPinLow(); err!= nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 42.44828346479746}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\td.stop()\n\td.sleepPinState = LOW\n\td.setPin(d.sleepPin, d.sleepPinState)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 34.210497738036935}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == -1 {\n\t\treturn errors.New(\"sleep pin not configured\")\n\t}\n\n\td.stop()\n\tdigitalWrite(d.sleepPin, LOW)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 27.263787172380376}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"analog pins not initialized\")\n\t}\n\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\n\tpin = &analogPin{\n\t\tid: id,\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 39.69442533645078}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath := a.pinPath(id)\n\tpin, err := a.newAnalogPin(path)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 46.58321328969339}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"analog pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, err := a.path(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err := a.pin(path)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 48.05464584178172}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tpin, err := a.getPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\terr = pin.Write(val)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.29889424066316}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif pin.direction!= \"output\" {\n\t\treturn errors.New(\"pin is not configured as output\")\n\t}\n\n\tpin.write(val)\n\treturn nil\n}", "CodeBleu_score": 62.642036421124445}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getDigitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tif pin.direction!= \"output\" {\n\t\treturn errors.New(\"pin is not configured as output\")\n\t}\n\treturn pin.write(val)\n}", "CodeBleu_score": 63.69901535449852}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins) == 0 {\n\t\treturn nil, errors.New(\"digital pin not connected\")\n\t}\n\n\tvar pin gobot.DigitalPin\n\tvar err error\n\n\tfor _, o := range opts {\n\t\tif!o(a) {\n\t\t\treturn nil, errors.New(\"invalid option\")\n\t\t}\n\t}\n\n\tif pin, err = a.getPin(id); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 30.488374805248853}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tvar pin gobot.DigitalPin\n\tvar err error\n\tvar ok bool\n\tvar options gobot.DigitalPinOptions\n\n\tif len(opts) > 0 {\n\t\toptions, err = gobot.ParseDigitalPinOptions(opts...)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif pin, ok = a.pins[id];!ok {\n\t\tif len(a.pins) == 0 {\n\t\t\treturn nil, errors.New(\"no digital pins connected\")\n\t\t}\n\n\t\tpin = &DigitalPin{\n\t\t\tID: id,\n\t\t}\n\n\t\ta.pins[id] = pin\n\t}\n\n\tif options!= nil {\n\t\tpin.Options = options\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 41.8247066860439}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.connected == false {\n\t\treturn nil, errors.New(\"not connected\")\n\t}\n\tif a.pin == nil {\n\t\treturn nil, errors.New(\"no pin\")\n\t}\n\tif a.pin.ID()!= id {\n\t\treturn nil, errors.New(\"invalid pin\")\n\t}\n\tfor _, opt := range opts {\n\t\tif opt(a.pin) == false {\n\t\t\treturn nil, errors.New(\"invalid option\")\n\t\t}\n\t}\n\treturn a.pin, nil\n}", "CodeBleu_score": 23.791608650708508}]}
