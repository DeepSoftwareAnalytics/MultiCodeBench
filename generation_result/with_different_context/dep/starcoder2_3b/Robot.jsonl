{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\t// Get the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder, download);\n    return required_files;\n}", "CodeBleu_score": 26.278680521825613}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t", "CodeBleu_score": 8.781990752468507}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\tstd::vector<std::string> requiredFiles;\n\tstd::vector<std::string> files = FileTransfer::GetFiles(folder);\n\tfor (auto &file : files) {\n\t\tif (download) {\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\tRequestFile(file);\n\t\t\t\tLog(\"File \" + file + \" not found locally. Downloading...\");\n\t\t\t} else {\n\t\t\t\tLog(\"File \" + file + \" found in cache.\");\n\t\t\t}\n\t\t}\n\t\trequiredFiles.push_back(file);\n\t}\n\treturn requiredFiles;\n}", "CodeBleu_score": 50.09675803777053}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 8.448293753010953}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\trpc::ActorId actor_id;\n\trpc::ActorDescription actor_description = description;\n\tactor_description.set_parent(parent);\n\tactor_description.set_attachment_type(attachment_type);\n\tactor_description.set_socket_name(socket_name);\n\tactor_description.set_transform(transform);\n\tactor_id = SpawnActor(actor_description);\n\treturn GetActor(actor_id);\n}", "CodeBleu_score": 29.052598615506962}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 8.448293753010953}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\tauto token = gbuffer_manager_.GetGBufferToken(ActorId, GBufferId);\n\tif (token.empty()) {\n\t\tstd::cout << \"GBuffer not found\" << std::endl;\n\t\treturn;\n\t}\n\t// Copy the token data to a new buffer.\n\tstd::vector<uint8_t> token_data(token.begin(), token.end());\n\t// Subscribe to the streaming client.\n\tstreaming_client_->Subscribe(token_data, callback);\n}", "CodeBleu_score": 43.42713557838902}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\t// Get the G-buffer token\n\trpc::GBufferToken token = GetGBufferToken(ActorId, GBufferId);\n\n\t// Copy the token data\n\tstd::vector<uint8_t> token_data(token.data().begin(), token.data().end());\n\n\t// Subscribe to the streaming client using the provided callback function\n\tSubscribeToStreamingClient(token_data, callback);\n}", "CodeBleu_score": 40.37813103099226}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\tstd::string token;\n\trpc::GBufferId gbufferId;\n\tgbufferId.set_id(GBufferId);\n\trpc::SubscribeToGBufferRequest request;\n\trequest.set_allocated_actor_id(ActorId.Serialize());\n\trequest.set_allocated_gbuffer_id(gbufferId.Serialize());\n\trpc::SubscribeToGBufferResponse response;\n\n\t// Create a new streaming client\n\tauto streamingClient = std::make_shared<StreamingClient>(this->connection);\n\n\t// Send the request\n\tthis->connection->SendRequest(request, response);\n\n\t// Retrieve the token\n\ttoken = response.token();\n\n\t// Copy the token\n\tmemcpy(this->token, token.c_str(), token.size());\n\n\t// Subscribe to the streaming client\n\tstreamingClient->SubscribeToGBuffer(this->token, callback);\n}", "CodeBleu_score": 41.84225514300311}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (this->navigation == nullptr) {\n\t\tthis->navigation = std::make_shared<WalkerNavigation>();\n\t}\n\treturn this->navigation;\n}", "CodeBleu_score": 16.15970696996433}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (m_navigation == nullptr) {\n\t\tm_navigation = std::make_shared<WalkerNavigation>();\n\t}\n\treturn m_navigation;\n}", "CodeBleu_score": 25.284897457552415}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (m_navigation == nullptr) {\n\t\tm_navigation = std::make_shared<WalkerNavigation>();\n\t}\n\treturn m_navigation;\n}", "CodeBleu_score": 25.284897457552415}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tconst auto start = std::chrono::steady_clock::now();\n\twhile (true) {\n\t\tif (frame < episode.GetFrame()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (std::chrono::steady_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tif (episode.GetFrame() == frame) {\n\t\t\tTrafficManager::GetInstance()->Tick();\n\t\t\treturn true;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.25151696896103}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tconst auto &episode_state = episode.state();\n\tconst auto &current_state = episode_state.current_state();\n\n\tif (frame >= current_state.frame()) {\n\t\treturn false;\n\t}\n\n\tauto start_time = std::chrono::steady_clock::now();\n\twhile (frame >= current_state.frame()) {\n\t\tif (std::chrono::steady_clock::now() - start_time > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tTrafficManager::instance().tick();\n\t}\n\treturn true;\n}", "CodeBleu_score": 43.82894506635447}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\t//TODO: Implement this function\n\treturn false;\n}", "CodeBleu_score": 2.7368473830596383}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy ep = EpisodeProxy{shared_from_this()};\n\tep.LoadEpisode(map_name, reset_settings, map_layers);\n\treturn ep;\n}", "CodeBleu_score": 19.645411313585072}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t", "CodeBleu_score": 3.4229654508845124}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tEpisodeProxy ep = EpisodeProxy{shared_from_this()};\n\tep.LoadEpisode(map_name, reset_settings, map_layers);\n\treturn ep;\n}", "CodeBleu_score": 19.645411313585072}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// TODO: Implement this function.\n\tif (controller.episode == nullptr) {\n\t\tthrow std::exception();\n\t}\n\tif (controller.episode->navigation == nullptr) {\n\t\tcontroller.episode->navigation = new Navigation(controller.episode->map);\n\t}\n\tcontroller.episode->navigation->RegisterWalker(controller.walkerID, controller.walker);\n}", "CodeBleu_score": 30.439919811952265}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (controller.GetEpisode() == nullptr) {\n\t\tthrow std::invalid_argument(\"Episode is null\");\n\t}\n\tif (controller.GetEpisode()->GetNavigation() == nullptr) {\n\t\tcontroller.GetEpisode()->SetNavigation(new Navigation());\n\t}\n\tcontroller.GetEpisode()->GetNavigation()->RegisterWalker(controller.GetID(), controller.GetWalker());\n}", "CodeBleu_score": 34.45385726471202}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// TODO: Implement this function.\n\tassert(this->episode!= nullptr);\n\tif (this->episode == nullptr) {\n\t\tthrow std::runtime_error(\"Episode is null\");\n\t}\n\tWalker* walker = this->episode->GetWalker(controller.GetID());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker is null\");\n\t}\n\tif (this->navigation == nullptr) {\n\t\tthis->navigation = new Navigation();\n\t}\n\tthis->navigation->RegisterAIController(controller);\n}", "CodeBleu_score": 49.5106954024762}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef _WIN32\n    auto actor = Actor::Spawn(blueprint, transform, parent, attachment_type, gc, socket_name);\n#else\n    auto actor = Actor::Spawn(blueprint, transform, parent, attachment_type, gc, socket_name);\n#endif\n    GetReadyCurrentEpisode();\n    return actor;\n  }", "CodeBleu_score": 29.11499138690519}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 7.364295779925118}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef SIM_LOGGING\n  std::stringstream ss;\n  ss << \"SpawnActor(\" << blueprint.GetName() << \", \" << transform << \", \" << (parent? parent->GetName() : \"null\") << \", \" << attachment_type << \", \" << gc << \", \" << socket_name << \")\";\n  LOG(INFO) << ss.str();\n#endif\n\n  GetReadyCurrentEpisode();\n\n  auto actor = std::make_shared<Actor>(shared_from_this(), blueprint, transform, parent, attachment_type, gc, socket_name);\n\n  if (parent) {\n    parent->AddChild(actor);\n  }\n\n  auto it = std::find(m_actors.begin(), m_actors.end(), actor);\n  if (it == m_actors.end()) {\n    m_actors.push_back(actor);\n  }\n\n  return actor;\n}", "CodeBleu_score": 45.78352482947946}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\t// Check that the episode is valid.\n\tif (!episode_valid_) {\n\t\tthrow std::runtime_error(\"Episode is invalid.\");\n\t}\n\n\t// Subscribe to the sensor's data stream using the client's SubscribeToStream method.\n\tauto sensor_data_stream = client_->SubscribeToStream(sensor.id);\n\n\t// Set up a callback to handle the incoming sensor data.\n\tauto callback_wrapper = [this, callback](const sensor::SensorData &sensor_data) {\n\t\t// Deserialize the incoming data.\n\t\tSharedPtr<sensor::SensorData> deserialized_sensor_data = sensor_data.Deserialize();\n\n\t\t// Associate the deserialized sensor data with the current episode.\n\t\tdeserialized_sensor_data->SetEpisode(episode_);\n\n\t\t// Invoke the provided callback with the sensor data.\n\t\tcallback(deserialized_sensor_data);\n\t};\n\n\t// Register the callback with the sensor data stream.\n\tsensor_data_stream->RegisterCallback(callback_wrapper);\n}", "CodeBleu_score": 38.57039315739404}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\tif (episode_ == nullptr) {\n\t\tthrow std::runtime_error(\"Invalid episode\");\n\t}\n\n\t// Subscribe to the sensor's data stream\n\tclient_->SubscribeToStream(sensor.stream_name, [this, callback](std::string sensor_data) {\n\t\t// Deserialize the incoming data\n\t\tSharedPtr<sensor::SensorData> data = sensor::SensorData::Deserialize(sensor_data);\n\n\t\t// Associate the data with the current episode\n\t\tdata->episode = episode_;\n\n\t\t// Invoke the callback with the sensor data\n\t\tcallback(data);\n\t});\n}", "CodeBleu_score": 38.18090037690046}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\t// TODO: implement this function\n\tif (episode == nullptr) {\n\t\tthrow std::runtime_error(\"Episode is not valid\");\n\t}\n\tsensor.SubscribeToStream(client, callback);\n}", "CodeBleu_score": 18.59453478450586}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n//    if (episode->GetState()->GetEpisodeTime() >= 10000) {\n//        std::cout << \"Episode finished\" << std::endl;\n//        return;\n//    }\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // get all walkers from episode\n    for (auto &&actor : episode->GetActors()) {\n      // only walkers\n      if (actor.description.id.rfind(\"walker.\", 0) == 0) {\n        // get the snapshot\n        ActorSnapshot snapshot = state->GetActorSnapshot(actor.id);\n        // add to the vector\n        _walkers.emplace_back(actor.id, actor.controller);\n        // register walker\n        RegisterWalker(actor.id, actor.controller);\n      }\n    }\n\n    // check if walkers are dead\n    CheckIfWalkerExist(_walkers, *state);\n\n    // update the vehicles found\n    UpdateVehiclesInCrowd(episode, false);\n\n    // get all walkers from episode\n    for (auto &&walker : _walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n      // get the transform\n      carla::geom::Location transform = snapshot.transform.location;\n      // get the speed\n      float speed = snapshot.speed;\n      // get the controller\n      carla::client::Actor controller = walker.controller;\n\n      // apply the states to the simulator\n      _simulator.lock()->ApplyWalkerState(walker.walker, transform, speed);\n\n      // check if the walker is dead\n      if (controller.IsDead()) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 52.369922989647634}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\t// load the walkers\n\tstd::vector<WalkerHandle> walkers = GetWalkers();\n\n\t// check if empty\n\tif (walkers.empty()) return;\n\n\t// get the current state\n\tstd::shared_ptr<const EpisodeState> state = episode->GetState();\n\n\t// remove dead walkers\n\tCheckIfWalkerExist(walkers, *state);\n\n\t// update the vehicles in the crowd\n\tUpdateVehiclesInCrowd(episode, true);\n\n\t// get the current state\n\tstd::shared_ptr<const EpisodeState> state = episode->GetState();\n\n\t// get the current time\n\tfloat time = state->GetTime();\n\n\t// apply the walkers in batch\n\tfor (int i = 0; i < walkers.size(); ++i) {\n\t\t// get the walker\n\t\tWalkerHandle walker = walkers[i];\n\n\t\t// get the transform\n\t\tcarla::geom::Location transform = state->GetActorSnapshot(walker.walker).transform;\n\n\t\t// get the speed\n\t\tfloat speed = state->GetActorSnapshot(walker.walker).speed;\n\n\t\t// apply the walker\n\t\tApplyWalker(walker.controller, transform, speed, time);\n\t}\n}", "CodeBleu_score": 36.59602605721039}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n//  std::cout << \"WalkerNavigation::Tick\" << std::endl;\n\n  // check if empty\n  if (_walkers.empty()) return;\n\n  // get the current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // remove dead walkers\n  CheckIfWalkerExist(_walkers, *state);\n\n  // update the vehicles in the crowd\n  UpdateVehiclesInCrowd(episode, false);\n\n  // get the current state\n  std::shared_ptr<const EpisodeState> current_state = episode->GetState();\n\n  // update the walkers\n  for (auto &&walker : _walkers) {\n\n    // get the walker and controller\n    ActorId walker_id = walker.walker;\n    ActorId controller_id = walker.controller;\n\n    // get the snapshot\n    ActorSnapshot walker_snapshot = current_state->GetActorSnapshot(walker_id);\n    ActorSnapshot controller_snapshot = current_state->GetActorSnapshot(controller_id);\n\n    // get the transform\n    carla::geom::Location walker_transform = walker_snapshot.transform.location;\n    carla::geom::Location controller_transform = controller_snapshot.transform.location;\n\n    // get the speed\n    float walker_speed = walker_snapshot.velocity.Length();\n    float controller_speed = controller_snapshot.velocity.Length();\n\n    // apply the transform and speed in a batch\n    _simulator.lock()->ApplyTransform(walker_id, walker_transform);\n    _simulator.lock()->ApplyTransform(controller_id, controller_transform);\n    _simulator.lock()->ApplyVelocity(walker_id, walker_speed);\n    _simulator.lock()->ApplyVelocity(controller_id, controller_speed);\n\n    // check if the walker is dead\n    if (walker_snapshot.is_alive && controller_snapshot.is_alive) continue;\n\n    // remove from the crowd\n    _nav.RemoveAgent(walker_id);\n\n    // destroy the controller\n    _simulator.lock()->DestroyActor(controller_id);\n\n    // unregister from list\n    UnregisterWalker(walker_id, controller_id);\n\n  }\n\n}", "CodeBleu_score": 46.87965413174686}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription actorDescription;\n\tactorDescription.set_uid(uid);\n\tactorDescription.set_id(id);\n\tfor (const auto& attribute : attributes) {\n\t\trpc::Attribute* attributePtr = actorDescription.add_attributes();\n\t\tattributePtr->set_name(attribute.first);\n\t\tattributePtr->set_value(attribute.second);\n\t}\n\treturn actorDescription;\n}", "CodeBleu_score": 47.94909322457323}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(GetUID());\n\tdescription.set_id(GetID());\n\tfor (const auto& attribute : m_attributes) {\n\t\tdescription.add_attributes()->CopyFrom(attribute);\n\t}\n\treturn description;\n}", "CodeBleu_score": 54.65582603709189}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription actorDescription;\n\tactorDescription.set_uid(GetUID());\n\tactorDescription.set_id(GetID());\n\tfor (auto& attribute : GetAttributes()) {\n\t\tactorDescription.add_attributes()->CopyFrom(attribute);\n\t}\n\treturn actorDescription;\n}", "CodeBleu_score": 49.39078965963368}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> newLibrary = MakeShared<BlueprintLibrary>();\n\tfor (auto& blueprint : blueprints) {\n\t\tif (blueprint->GetAttribute(name) == value) {\n\t\t\tnewLibrary->AddBlueprint(blueprint);\n\t\t}\n\t}\n\treturn newLibrary;\n}", "CodeBleu_score": 25.797569640230545}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n\tfor (const auto& blueprint : blueprints) {\n\t\tif (blueprint->GetAttribute(name) == value) {\n\t\t\tresult->AddBlueprint(blueprint);\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 25.98077635663258}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (const auto& blueprint : blueprints) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tif (blueprint->GetAttributeValue(name) == value) {\n\t\t\t\tresult->blueprints.push_back(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 33.26162652587097}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = baseFolder + \"/\" + path;\n\tif (ValidatePath(fullPath)) {\n\t\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\t\tif (file.is_open()) {\n\t\t\tfile.write((char *) &content[0], content.size());\n\t\t\tfile.close();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.65796443117749}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = this->GetFullFilePath(path);\n\tif (!this->ValidateFilePath(fullPath)) {\n\t\treturn false;\n\t}\n\tstd::ofstream file(fullPath, std::ios::binary);\n\tif (file.is_open()) {\n\t\tfile.write((char*)content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 36.87665852484366}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = baseFolder + path;\n\tif (!ValidatePath(fullPath)) {\n\t\treturn false;\n\t}\n\tstd::ofstream file(fullPath, std::ios::binary);\n\tif (file.is_open()) {\n\t\tfile.write((char *) content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 36.96050313769148}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n//  std::cout << \"MakeBounds\" << std::endl;\n  const geom::Location location = geom::Location::Add(\n      transform.location,\n      geom::Location::Rotate(transform.yaw, parent_bounds_->location));\n\n  const geom::Location extent = geom::Location::Multiply(\n      parent_bounds_->extent,\n      transform.scale);\n\n  const geom::Location corner0 = geom::Location::Add(location,\n      geom::Location::Rotate(transform.yaw - transform.pitch,\n          geom::Location::Rotate(transform.yaw - transform.roll,\n              geom::Location::Rotate(transform.yaw,\n                  geom::Location::Add(\n                      geom::Location::Add(extent, extent),\n                      geom::Location::Add(extent, extent)))));\n\n  const geom::Location corner1 = geom::Location::Add(location,\n      geom::Location::Rotate(transform.yaw + transform.pitch,\n          geom::Location::Rotate(transform.yaw - transform.roll,\n              geom::Location::Rotate(transform.yaw,\n                  geom::Location::Add(\n                      geom::Location::Add(extent, extent),\n                      geom::Location::Add(extent, extent)))));\n\n  const geom::Location corner2 = geom::Location::Add(location,\n      geom::Location::Rotate(transform.yaw + transform.pitch,\n          geom::Location::Rotate(transform.yaw + transform.roll,\n              geom::Location::Rotate(transform.yaw,\n                  geom::Location::Add(\n                      geom::Location::Add(extent, extent),\n                      geom::Location::Add(extent, extent)))));\n\n  const geom::Location corner3 = geom::Location::Add(location,\n      geom::Location::Rotate(transform.yaw - transform.pitch,\n          geom::Location::Rotate(transform.yaw + transform.roll,\n              geom::Location::Rotate(transform.yaw,\n                  geom::Location::Add(\n                      geom::Location::Add(extent, extent),\n                      geom::Location::Add(extent, extent)))));\n\n  return std::make_shared<const Bounds>(frame, corner0, corner1, corner2, corner3);\n}", "CodeBleu_score": 36.16576409166702}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t#if defined(DEBUG)\n  std::cout << \"LaneInvasionCallback::MakeBounds(frame = \" << frame << \", transform = \" << transform << \")\" << std::endl;\n#endif\n  const geom::Location location = transform.location + bounds.location;\n  const geom::Location extent = bounds.extent * transform.rotation;\n  const geom::Location corner0 = Rotate(transform.rotation.yaw, extent) + location;\n  const geom::Location corner1 = Rotate(transform.rotation.yaw + geom::Math::Pi<float>(), extent) + location;\n  const geom::Location corner2 = Rotate(transform.rotation.yaw + geom::Math::Pi<float>() * 2.0f, extent) + location;\n  const geom::Location corner3 = Rotate(transform.rotation.yaw + geom::Math::Pi<float>() * 3.0f, extent) + location;\n  return std::make_shared<const Bounds>(frame, corner0, corner1, corner2, corner3);\n}", "CodeBleu_score": 42.49591722267528}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t#if 0\n  const geom::Location location = geom::Location::Rotate(transform.yaw, transform.location);\n  const geom::Location min = location - transform.extent;\n  const geom::Location max = location + transform.extent;\n  const geom::Location p1 = geom::Location::Rotate(transform.yaw, min);\n  const geom::Location p2 = geom::Location::Rotate(transform.yaw, {min.x, max.y, min.z});\n  const geom::Location p3 = geom::Location::Rotate(transform.yaw, {max.x, max.y, min.z});\n  const geom::Location p4 = geom::Location::Rotate(transform.yaw, {max.x, min.y, min.z});\n  const geom::Location p5 = geom::Location::Rotate(transform.yaw, {min.x, min.y, max.z});\n  const geom::Location p6 = geom::Location::Rotate(transform.yaw, {min.x, max.y, max.z});\n  const geom::Location p7 = geom::Location::Rotate(transform.yaw, {max.x, max.y, max.z});\n  const geom::Location p8 = geom::Location::Rotate(transform.yaw, {max.x, min.y, max.z});\n  return std::make_shared<const Bounds>(frame, p1, p2, p3, p4, p5, p6, p7, p8);\n#endif\n  return nullptr;\n}", "CodeBleu_score": 36.98871560004587}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex\n\t_mutex.lock();\n\n\t// Query the server\n\tstd::vector<LightState> lightStates = _lightServer->QueryLightStates();\n\n\t// Unlock the mutex\n\t_mutex.unlock();\n\n\t// Update the local light states\n\tfor (LightState lightState : lightStates) {\n\t\t// Find the light in the _lights map\n\t\tstd::map<int, Light*>::iterator it = _lights.find(lightState.lightId);\n\n\t\t// If the light does not exist in the _lights map\n\t\tif (it == _lights.end()) {\n\t\t\t// Create a new light object\n\t\t\tLight* light = new Light(lightState.lightId, lightState.lightName, lightState.lightState);\n\n\t\t\t// Add the light to the _lights map\n\t\t\t_lights.insert(std::pair<int, Light*>(lightState.lightId, light));\n\t\t}\n\n\t\t// Update the light state\n\t\t_lights[lightState.lightId]->SetLightState(lightState.lightState);\n\t}\n}", "CodeBleu_score": 34.47580869297448}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Retrieve the light states from the server\n\tstd::vector<LightState> states = _server->QueryLightsState();\n\n\t// Update the local light states\n\tfor (LightState state : states) {\n\t\t// Find the light with the same ID in the local map\n\t\tauto it = _lights.find(state.id);\n\n\t\t// If the light does not exist in the local map, create a new light object\n\t\tif (it == _lights.end()) {\n\t\t\t_lights.insert(std::pair<int, Light>(state.id, Light(state.id, state.name, state.state.on, state.state.bri, state.state.hue, state.state.sat)));\n\t\t}\n\t\t// If the light exists in the local map, update its state\n\t\telse {\n\t\t\tit->second.SetState(state.state.on, state.state.bri, state.state.hue, state.state.sat);\n\t\t}\n\t}\n}", "CodeBleu_score": 33.59586541534277}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Query the server for the current state of lights\n\tstd::string response = _server.QueryLightsState();\n\n\t// Parse the response into a vector of LightState objects\n\tstd::vector<LightState> lightStates = LightState::ParseLightStateResponse(response);\n\n\t// Update the local light states\n\tfor (LightState lightState : lightStates) {\n\t\tauto it = _lights.find(lightState.id);\n\t\tif (it == _lights.end()) {\n\t\t\t// If the light does not exist in the map, create a new light object and add it to the map\n\t\t\tLight *light = new Light(lightState.id, lightState.name, lightState.state);\n\t\t\t_lights.insert(std::make_pair(lightState.id, light));\n\t\t} else {\n\t\t\t// If the light exists in the map, update its state\n\t\t\tit->second->UpdateState(lightState.state);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.933140165577676}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\t//lock mutex\n\tstd::unique_lock<std::mutex> lock(m_mutex);\n\n\t//check if there are any changes\n\tif (m_changes.empty()) {\n\t\treturn;\n\t}\n\n\t//create message\n\tMessage message;\n\tmessage.type = Message::Type::LIGHT_STATE;\n\tmessage.light_state = m_changes;\n\n\t//send message to server\n\tm_server->Send(message, discard_client);\n\n\t//clear changes\n\tm_changes.clear();\n\n\t//reset dirty flag\n\tm_dirty = false;\n}", "CodeBleu_score": 21.81477855061118}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t", "CodeBleu_score": 1.4421612766169787}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\t// Lock the mutex\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// If there are no changes, return\n\tif (!dirty) {\n\t\treturn;\n\t}\n\n\t// Create a message containing the updated light states\n\tstd::vector<char> message;\n\tmessage.push_back(LIGHT_STATE_UPDATE_MESSAGE);\n\tfor (int i = 0; i < num_lights; i++) {\n\t\tmessage.push_back(lights[i].state);\n\t}\n\n\t// Send the message to the server\n\tif (discard_client) {\n\t\tserver->Send(message);\n\t} else {\n\t\tserver->Send(message, client);\n\t}\n\n\t// Clear the changes and reset the dirty flag\n\tdirty = false;\n\tchanges.clear();\n}", "CodeBleu_score": 29.82420492902847}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetID()!= \"sensor.other.v2x_custom\") {\n\t\tstd::cout << \"WARNING: Sensor \" << GetID() << \" is not a custom sensor, and cannot send a message.\" << std::endl;\n\t\treturn;\n\t}\n\tstd::cout << \"DEBUG: ServerSideSensor::Send() called.\" << std::endl;\n\tstd::cout << \"DEBUG: Sending message \\\"\" << message << \"\\\" to episode \" << GetEpisode() << \" using context \" << GetContext() << \".\" << std::endl;\n\tGetEpisode()->Send(message, GetContext());\n}", "CodeBleu_score": 45.53962843803939}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->GetID()!= \"sensor.other.v2x_custom\") {\n\t\tstd::cout << \"Warning: Sensor ID is not \\\"sensor.other.v2x_custom\\\".\" << std::endl;\n\t\treturn;\n\t}\n\n\tstd::cout << \"Sensor \" << this->GetID() << \" is sending a message to episode \" << this->GetEpisodeID() << \".\" << std::endl;\n\tthis->GetEpisode()->Send(this->GetContext(), message);\n}", "CodeBleu_score": 44.960588751291304}, {"code": "void ServerSideSensor::Send(std::string message){\n\t", "CodeBleu_score": 3.3572012675405896}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\t// TODO: Implement this function\n\tif (enabled) {\n\t\t// TODO: Implement this function\n\t\t// Register with the traffic manager\n\t\t// If the registration fails, throw an exception\n\t\t// If the registration succeeds, set the autopilot flag to true\n\t\t// If the registration fails, set the autopilot flag to false\n\t}\n\telse {\n\t\t// TODO: Implement this function\n\t\t// Unregister from the traffic manager\n\t\t// If the unregistration fails, throw an exception\n\t\t// If the unregistration succeeds, set the autopilot flag to false\n\t\t// If the unregistration fails, set the autopilot flag to true\n\t}\n}", "CodeBleu_score": 15.514584277971217}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\t// Get the walker actor\n\twalkerActor = Cast<AWalkerActor>(GetPawn());\n\tif (walkerActor == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::Start: Walker actor is null\"));\n\t\treturn;\n\t}\n\n\t// Add the walker actor to the navigation system\n\twalkerActor->RegisterWithNavMesh();\n\n\t// Disable the physics simulation and collisions for the walker actor\n\twalkerActor->SetActorEnableCollision(false);\n\twalkerActor->SetActorTickEnabled(false);\n\twalkerActor->SetActorTickInterval(0.0f);\n}", "CodeBleu_score": 28.397269372683503}, {"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\tWalkerActor = Cast<AWalker>(GetPawn());\n\tif (WalkerActor) {\n\t\tWalkerActor->GetWorld()->GetNavigationSystem()->RegisterNavigationInvoker(WalkerActor);\n\t\tWalkerActor->DisableComponentsSimulatePhysics();\n\t\tWalkerActor->SetActorEnableCollision(false);\n\t}\n}", "CodeBleu_score": 32.85339826143492}, {"code": "void WalkerAIController::Start(){\n\t", "CodeBleu_score": 1.0949963018106907}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (auto navigation_instance = GetEpisode()->GetNavigationInstance()) {\n\t\tif (auto walker = GetWalker()) {\n\t\t\twalker->SetMaxSpeed(max_speed);\n\t\t} else {\n\t\t\tUE_LOG(LogAI, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Walker not found.\"));\n\t\t}\n\t} else {\n\t\tUE_LOG(LogAI, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Navigation instance not found.\"));\n\t}\n}", "CodeBleu_score": 43.85735181923221}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (auto navigation = GetEpisode()->GetNavigation()) {\n\t\tauto walker = GetWalker();\n\t\tif (walker) {\n\t\t\twalker->SetMaxSpeed(max_speed);\n\t\t} else {\n\t\t\tUE_LOG(LogAI, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Could not find walker in episode.\"));\n\t\t}\n\t} else {\n\t\tUE_LOG(LogAI, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Could not find navigation in episode.\"));\n\t}\n}", "CodeBleu_score": 48.86386167029541}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto navigation_instance = GetEpisode()->GetNavigation();\n\tif (!navigation_instance) {\n\t\tLOG(Error, \"WalkerAIController::SetMaxSpeed: No navigation instance found for episode.\");\n\t\treturn;\n\t}\n\n\tauto walker = Cast<AWalker>(GetPawn());\n\tif (!walker) {\n\t\tLOG(Error, \"WalkerAIController::SetMaxSpeed: No walker found for episode.\");\n\t\treturn;\n\t}\n\n\tif (!navigation_instance->SetMaxSpeed(walker, max_speed)) {\n\t\tLOG(Error, \"WalkerAIController::SetMaxSpeed: Failed to set max speed for walker.\");\n\t}\n}", "CodeBleu_score": 43.38798563175432}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> temp = map->GetPrevious(this, distance);\n\tfor (std::vector<SharedPtr<Waypoint>>::iterator it = temp.begin(); it!= temp.end(); ++it) {\n\t\tresult.push_back(SharedPtr<Waypoint>(*it));\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.43710983571525}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> previous;\n\tstd::vector<Waypoint> previous_wp = this->parent_map->GetPrevious(this->id, distance);\n\tfor (Waypoint wp : previous_wp) {\n\t\tprevious.push_back(SharedPtr<Waypoint>(new Waypoint(wp)));\n\t}\n\treturn previous;\n}", "CodeBleu_score": 44.057130101878386}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> previous = map->GetPrevious(this, distance);\n\tfor (const auto &it : previous) {\n\t\tresult.push_back(it);\n\t}\n\treturn result;\n}", "CodeBleu_score": 46.651886113665455}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> landmarks;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (const SharedPtr<Signal>& signal : signals) {\n\t\tif (signal->GetLandmark()!= nullptr) {\n\t\t\tlandmarks.push_back(signal->GetLandmark());\n\t\t}\n\t}\n\treturn landmarks;\n}", "CodeBleu_score": 29.816709034009133}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> landmarks;\n\n\tauto signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tauto landmark = signal->GetLandmark();\n\t\tif (landmark == nullptr) {\n\t\t\tcontinue;\n\t\t}\n\t\tauto it = std::find(landmarks.begin(), landmarks.end(), landmark);\n\t\tif (it == landmarks.end()) {\n\t\t\tlandmarks.push_back(landmark);\n\t\t}\n\t}\n\n\treturn landmarks;\n}", "CodeBleu_score": 37.69652337994901}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> landmarks_in_distance;\n\tstd::vector<SharedPtr<Landmark>> signals_in_distance = GetSignalsInDistance(distance);\n\tstd::vector<SharedPtr<Landmark>> landmarks_in_distance_temp;\n\n\t// Loop through signals in distance\n\tfor (const SharedPtr<Landmark>& signal : signals_in_distance) {\n\t\t// Check if signal is a junction\n\t\tif (signal->IsJunction()) {\n\t\t\t// If stop_at_junction is true, stop at junction\n\t\t\tif (stop_at_junction) {\n\t\t\t\t// Add signal to landmarks_in_distance_temp\n\t\t\t\tlandmarks_in_distance_temp.push_back(signal);\n\t\t\t\t// Add signal to landmarks_in_distance\n\t\t\t\tlandmarks_in_distance.push_back(signal);\n\t\t\t\t// Stop at junction\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// If stop_at_junction is false, continue to next signal\n\t\t\telse {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t// If signal is not a junction, add to landmarks_in_distance_temp\n\t\telse {\n\t\t\tlandmarks_in_distance_temp.push_back(signal);\n\t\t}\n\t}\n\n\t// Loop through landmarks_in_distance_temp\n\tfor (const SharedPtr<Landmark>& landmark : landmarks_in_distance_temp) {\n\t\t// Check if landmark is a junction\n\t\tif (landmark->IsJunction()) {\n\t\t\t// Add landmark to landmarks_in_distance\n\t\t\tlandmarks_in_distance.push_back(landmark);\n\t\t}\n\t}\n\n\t// Return landmarks_in_distance\n\treturn landmarks_in_distance;\n}", "CodeBleu_score": 39.63628897432441}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\treturn _episode.Lock()->ApplySettings(settings, timeout);\n}", "CodeBleu_score": 13.739489258329614}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0?\n\t\t_episode.Lock()->GetNetworkingTimeout() : timeout;\n\treturn _episode.Lock()->ApplySettings(settings, local_timeout);\n}", "CodeBleu_score": 19.922130866587516}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tifdef DEBUG\n    std::cout << \"World::ApplySettings: settings: \" << settings << \" timeout: \" << timeout << std::endl;\n#endif\n    if (settings.has_fixed_delta_time()) {\n        int64_t fixed_delta_time = settings.fixed_delta_time();\n        int64_t local_timeout = timeout.milliseconds() == 0?\n            _episode.Lock()->GetNetworkingTimeout().milliseconds() : timeout.milliseconds();\n        int64_t max_attempts = local_timeout / fixed_delta_time;\n        int64_t attempts = 0;\n        bool is_applied = false;\n        while (!is_applied && attempts < max_attempts) {\n            attempts++;\n            is_applied = _episode.Lock()->ApplySettings(settings);\n            if (!is_applied) {\n                std::cout << \"World::ApplySettings: Warning: Could not apply settings to world after \" << attempts << \" attempts.\" << std::endl;\n            }\n        }\n        if (!is_applied) {\n            std::cout << \"World::ApplySettings: Warning: Could not apply settings to world after \" << attempts << \" attempts.\" << std::endl;\n        }\n    } else {\n        _episode.Lock()->ApplySettings(settings);\n    }\n    return _episode.Lock()->GetSettingsIdentifier();\n}", "CodeBleu_score": 48.585567586876955}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tstatic_cast<float>(0),\n\tstatic_cast<float>(0)\n}", "CodeBleu_score": 4.945347496879055}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tstatic auto GetFunction() { return NativeFunction::Get<Math::DistanceSegmentToPoint>(); }\n\tstatic void Initialize() {\n\t\tNativeFunction::Register(\"Math::DistanceSegmentToPoint\", &Math::DistanceSegmentToPoint);\n\t}\n}", "CodeBleu_score": 8.42403404267354}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t", "CodeBleu_score": 3.3301066487392625}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tassert(vertices.size() >= 3);\n\t_indexes.push_back(vertices[0].index);\n\tfor (size_t i = 1; i < vertices.size(); i++) {\n\t\t_indexes.push_back(vertices[i].index);\n\t}\n }", "CodeBleu_score": 31.154324148681876}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tassert(vertices.size() >= 3);\n\tindex_type initial_index = _indexes.size();\n\tfor (size_t i = 0; i < vertices.size(); i++) {\n\t\tAddVertex(vertices[i]);\n\t}\n\tfor (size_t i = 2; i < vertices.size(); i++) {\n\t\tAddIndex(initial_index);\n\t\tAddIndex(initial_index + i);\n\t\tAddIndex(initial_index + i - 1);\n\t}\n}", "CodeBleu_score": 45.37061695641618}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t//    assert(vertices.size() > 2);\n    index_type initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (int i = 1; i < vertices.size(); i++) {\n        AddIndex(initial_index);\n        AddIndex(initial_index + i);\n        AddIndex(initial_index + i + 1);\n    }\n}", "CodeBleu_score": 46.436448161785975}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\tLOG_ERROR(\"Invalid message to send.\");\n\t\treturn;\n\t}\n\n\tauto strand = GetStrand();\n\tstrand->post([=]() {\n\t\tif (!GetSocket()) {\n\t\t\tLOG_ERROR(\"Socket is not open.\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!GetSocket()->is_open()) {\n\t\t\tLOG_ERROR(\"Socket is not open.\");\n\t\t\treturn;\n\t\t}\n\n\t\tGetSocket()->expires_from_now(boost::posix_time::seconds(5));\n\t\tGetSocket()->async_write(\n\t\t\tboost::asio::buffer(message->GetData(), message->GetSize()),\n\t\t\t[=](const boost::system::error_code& ec, std::size_t) {\n\t\t\t\tif (ec) {\n\t\t\t\t\tLOG_ERROR(\"Error writing message: \" << ec.message());\n\t\t\t\t\tClose();\n\t\t\t\t} else {\n\t\t\t\t\tLOG_DEBUG(\"Message sent.\");\n\t\t\t\t}\n\t\t\t});\n\t});\n}", "CodeBleu_score": 34.834477665612326}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message->IsValid()) {\n\t\tLOG_ERROR << \"Message is not valid\";\n\t\treturn;\n\t}\n\n\tauto strand = std::make_shared<asio::strand<asio::io_context::executor_type>>(io_context_);\n\n\tstrand->post([=]() {\n\t\tif (socket_.is_open()) {\n\t\t\tauto timeout = std::make_shared<asio::steady_timer>(io_context_);\n\t\t\ttimeout->expires_after(std::chrono::seconds(10));\n\n\t\t\tauto handle_sent = [=](const asio::error_code& error) {\n\t\t\t\tif (error) {\n\t\t\t\t\tLOG_ERROR << \"Error sending message: \" << error.message();\n\t\t\t\t} else {\n\t\t\t\t\tLOG_DEBUG << \"Message sent\";\n\t\t\t\t}\n\n\t\t\t\tif (socket_.is_open()) {\n\t\t\t\t\ttimeout->expires_after(std::chrono::seconds(10));\n\t\t\t\t\ttimeout->async_wait(handle_timeout);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tasio::async_write(socket_, asio::buffer(message->GetMessage(), message->GetMessageSize()), handle_sent);\n\t\t} else {\n\t\t\tLOG_ERROR << \"Socket is closed\";\n\t\t}\n\t});\n}", "CodeBleu_score": 39.941378122397424}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\treturn;\n\t}\n\n\tif (message->GetMessageType() == carla::streaming::detail::tcp::Message::MessageType::kError) {\n\t\tstd::cerr << \"Error: \" << message->GetErrorMessage() << std::endl;\n\t\treturn;\n\t}\n\n\tif (!m_Socket.is_open()) {\n\t\tstd::cerr << \"Error: Socket is not open.\" << std::endl;\n\t\treturn;\n\t}\n\n\tm_Strand.post([this, message]() {\n\t\tif (!m_Socket.is_open()) {\n\t\t\tstd::cerr << \"Error: Socket is not open.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\n\t\tm_Socket.expires_from_now(std::chrono::seconds(10));\n\n\t\tm_Socket.async_write_some(boost::asio::buffer(message->GetMessageData(), message->GetMessageSize()), [this, message](boost::system::error_code ec, std::size_t bytes_transferred) {\n\t\t\tif (ec) {\n\t\t\t\tstd::cerr << \"Error: \" << ec.message() << std::endl;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tm_Strand.post([this, message]() {\n\t\t\t\tm_Socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, [this, message](boost::system::error_code ec) {\n\t\t\t\t\tif (ec) {\n\t\t\t\t\t\tstd::cerr << \"Error: \" << ec.message() << std::endl;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tm_Socket.close();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n}", "CodeBleu_score": 34.67840524654923}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer.\n\tif (timer.expires_at()!= boost::posix_time::pos_infin)\n\t\ttimer.cancel();\n\n\t// If we get an error code, then we don't close the socket.\n\tif (ec)\n\t\treturn;\n\n\t// Shut down the socket.\n\tboost::system::error_code ignored_ec;\n\tsocket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\n\t// Close the socket.\n\tsocket.close();\n\n\t// Trigger the on_closed callback.\n\ton_closed(this, ec);\n\n\t// Log that the session has been closed.\n\tLog(LogLevel::Info, \"Session closed.\");\n}", "CodeBleu_score": 49.622123071968716}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec) {\n\t\tLOG(ERROR) << \"Error closing socket: \" << ec.message();\n\t}\n\tdeadline_.cancel();\n\tif (socket_.is_open()) {\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t\tsocket_.close();\n\t}\n\ton_closed(ec);\n}", "CodeBleu_score": 43.88007853161676}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (this->IsOpen()) {\n\t\tthis->CancelDeadlineTimer();\n\t\tthis->CloseSocket();\n\t\tthis->on_closed(this->shared_from_this(), ec);\n\t\tthis->Log(\"Session closed\");\n\t}\n}", "CodeBleu_score": 21.52330891589182}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar* buffer = new char[100];\n\tstrcpy(buffer, \"Are you alive?\");\n\tLog::LogMessage(Log::SEND_IS_ALIVE, buffer);\n\twrite(nextRouter, buffer, strlen(buffer) + 1);\n\tchar* response = new char[100];\n\tread(nextRouter, response, 100);\n\tLog::LogMessage(Log::RECEIVE_IS_ALIVE, response);\n\tdelete[] buffer;\n\tdelete[] response;\n}", "CodeBleu_score": 32.8500175708828}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar* buffer = new char[100];\n\tstrcpy(buffer, \"Are you alive?\");\n\tLog::LogMessage(\"Sending message: \", buffer);\n\tSendCommand(buffer, YOU_ALIVE);\n\tdelete buffer;\n\tbuffer = new char[100];\n\tLog::LogMessage(\"Waiting for response...\");\n\tReceiveCommand(buffer);\n\tLog::LogMessage(\"Response: \", buffer);\n\tdelete buffer;\n}", "CodeBleu_score": 25.21517686813502}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar* buffer = new char[100];\n\tstrcpy(buffer, \"Are you alive?\");\n\tLogger::Log(\"Sending message: \", buffer);\n\tif (write(nextRouter, buffer, strlen(buffer)) < 0) {\n\t\tLogger::Log(\"Error: Could not write to next router\");\n\t\texit(1);\n\t}\n\tLogger::Log(\"Waiting for response from next router\");\n\tif (read(nextRouter, buffer, 100) < 0) {\n\t\tLogger::Log(\"Error: Could not read from next router\");\n\t\texit(1);\n\t}\n\tLogger::Log(\"Received message: \", buffer);\n\tdelete buffer;\n}", "CodeBleu_score": 32.0169822735663}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router\n\tuint8_t buffer[2];\n\tbuffer[0] = (uint8_t) sensor_id;\n\tbuffer[1] = (uint8_t) ENABLE_ROS;\n\n\t// Send the ENABLE_ROS command to the server using the router\n\trouter.SendCommand(buffer, 2);\n\n\t// Wait for and process the server's response\n\tWaitForResponse();\n}", "CodeBleu_score": 15.209720539530963}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Create a buffer with the sensor ID\n\tstd::vector<uint8_t> buffer = CreateBuffer(sensor_id);\n\n\t// Send the ENABLE_ROS command to the server using the router\n\trouter.SendCommand(buffer, ENABLE_ROS);\n\n\t// Wait for and process the server's response\n\tWaitForResponse(sensor_id, ENABLE_ROS);\n}", "CodeBleu_score": 18.31685309377111}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tstd::string sensor_id_string = std::to_string(sensor_id);\n\tstd::string command = \"ENABLE_ROS\";\n\tstd::string buffer = command + \" \" + sensor_id_string;\n\tstd::string response;\n\tstd::string server_address;\n\tstd::string server_port;\n\n\t// Check if sensor is enabled on any secondary server\n\tbool found = false;\n\tfor (int i = 0; i < secondary_servers.size(); i++) {\n\t\tserver_address = secondary_servers[i].first;\n\t\tserver_port = std::to_string(secondary_servers[i].second);\n\t\tif (socket_manager.SendCommand(server_address, server_port, buffer, response)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tstd::cout << \"Could not find sensor with ID \" << sensor_id << std::endl;\n\t}\n}", "CodeBleu_score": 38.431860612168975}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t#ifdef CARLA_USE_OPENCL\n  if (sensor_id == 0) {\n    log_info(\"trying to get a token for a sensor that is not enabled\");\n    return token_type();\n  }\n#endif\n  auto it = _token_map.find(sensor_id);\n  if (it!= _token_map.end()) {\n    log_info(\"sensor \", sensor_id, \" is already activated\");\n    return it->second;\n  }\n\n#ifdef CARLA_USE_OPENCL\n  // Check if the sensor is already enabled on the secondary server\n  auto secondary_server = _router->GetSecondaryServer();\n  if (secondary_server!= nullptr) {\n    auto secondary_token = secondary_server->GetToken(sensor_id);\n    if (secondary_token.get_port()!= 0) {\n      log_info(\"sensor \", sensor_id, \" is already enabled on the secondary server\");\n      _token_map[sensor_id] = secondary_token;\n      return _token_map[sensor_id];\n    }\n  }\n#endif\n\n  // If the sensor is not already enabled, enable it on the secondary server\n  auto secondary_server = _router->GetSecondaryServer();\n  if (secondary_server == nullptr) {\n    log_info(\"no secondary server available\");\n    return token_type();\n  }\n  auto new_token = secondary_server->SendGetToken(sensor_id);\n  if (new_token.get_port() == 0) {\n    log_info(\"sensor \", sensor_id, \" is not enabled on the secondary server\");\n    return token_type();\n  }\n  _token_map[sensor_id] = new_token;\n  return _token_map[sensor_id];\n}", "CodeBleu_score": 44.97820494698039}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tif (_tokens.count(sensor_id) == 0) {\n\t\tlog_info(\"sensor \", sensor_id, \" is not activated\");\n\t\t_tokens[sensor_id] = SendGetToken(sensor_id);\n\t\t_tokens_map[sensor_id] = _tokens[sensor_id];\n\t\tlog_info(\"sensor \", sensor_id, \" is activated\");\n\t}\n\telse {\n\t\tlog_info(\"sensor \", sensor_id, \" is already activated\");\n\t}\n\treturn _tokens[sensor_id];\n}", "CodeBleu_score": 31.91440677533589}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t#if defined(CARLA_ENABLE_SENSORS)\n  if (sensor_id >= _sensors.size()) {\n    log_error(\"invalid sensor id: \", sensor_id);\n    return token_type();\n  }\n\n  auto& sensor = _sensors[sensor_id];\n  if (sensor.enabled) {\n    log_info(\"sensor \", sensor_id, \" already enabled\");\n    return sensor.token;\n  }\n\n  auto& secondary = _secondaries[sensor.secondary_server];\n  auto token = SendGetToken(sensor_id);\n  secondary.token_map[sensor_id] = token;\n  sensor.token = token;\n  sensor.enabled = true;\n  log_info(\"sensor \", sensor_id, \" enabled\");\n  return token;\n#else\n  log_error(\"CARLA_ENABLE_SENSORS not defined\");\n  return token_type();\n#endif\n}", "CodeBleu_score": 46.138439215298376}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\tif (walker_manager == nullptr) {\n\t\treturn false;\n\t}\n\n\tif (vehicle_manager == nullptr) {\n\t\treturn false;\n\t}\n\n\tif (id == ActorId::kInvalidId) {\n\t\treturn false;\n\t}\n\n\t// Find the agent in the walker manager and remove it\n\tif (walker_manager->RemoveAgent(id)) {\n\t\t// Find the agent in the vehicle manager and remove it\n\t\tif (vehicle_manager->RemoveAgent(id)) {\n\t\t\t// Find the agent in the walker mappings and remove it\n\t\t\twalker_mappings.erase(id);\n\t\t\t// Find the agent in the vehicle mappings and remove it\n\t\t\tvehicle_mappings.erase(id);\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 30.167550670998743}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!ready) {\n\t\treturn false;\n\t}\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\tif (walker_map.find(id)!= walker_map.end()) {\n\t\t// Enter critical section\n\t\tstd::lock_guard<std::mutex> lock(crowd_mutex);\n\t\t// Update walker\n\t\tcrowd->RemoveAgent(walker_map[id]);\n\t\t// Remove from walker map\n\t\twalker_map.erase(id);\n\t}\n\telse if (vehicle_map.find(id)!= vehicle_map.end()) {\n\t\t// Enter critical section\n\t\tstd::lock_guard<std::mutex> lock(crowd_mutex);\n\t\t// Update vehicle\n\t\tcrowd->RemoveAgent(vehicle_map[id]);\n\t\t// Remove from vehicle map\n\t\tvehicle_map.erase(id);\n\t}\n\telse {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.73657464720947}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\tif (walker_mapping.find(id)!= walker_mapping.end()) {\n\t\tstd::lock_guard<std::mutex> lock(walker_mutex);\n\t\twalker_mapping.erase(id);\n\t}\n\telse if (vehicle_mapping.find(id)!= vehicle_mapping.end()) {\n\t\tstd::lock_guard<std::mutex> lock(vehicle_mutex);\n\t\tvehicle_mapping.erase(id);\n\t}\n\telse {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 38.576329711083154}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\teck if all is ready\n\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\t// update the vehicles\n\tfor (auto vehicle : vehicles) {\n\t\t// check if this actor exists\n\t\tauto it = _mapped_vehicles_id.find(vehicle.id);\n\t\tif (it!= _mapped_vehicles_id.end()) {\n\t\t\t// get the index found\n\t\t\tint index = it->second;\n\t\t\tif (index!= -1) {\n\t\t\t\t// get the agent\n\t\t\t\tdtCrowdAgent *agent;\n\t\t\t\t{\n\t\t\t\t\t// critical section, force single thread running this\n\t\t\t\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\t\t\t\tagent = _crowd->getEditableAgent(index);\n\t\t\t\t}\n\t\t\t\tif (agent) {\n\t\t\t\t\t// update its position\n\t\t\t\t\tagent->npos[0] = vehicle.transform.location.x;\n\t\t\t\t\tagent->npos[1] = vehicle.transform.location.z;\n\t\t\t\t\tagent->npos[2] = vehicle.transform.location.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 38.87702038627478}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\teck if all is ready\n\tif (!_ready) {\n\t\treturn false;\n\t}\n\n\t// get the current set of vehicles\n\tstd::set<ActorId> current_vehicles;\n\t{\n\t\t// critical section, force single thread running this\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\t\tfor (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); it++) {\n\t\t\tcurrent_vehicles.insert(it->first);\n\t\t}\n\t}\n\n\t// add or update vehicles\n\tfor (auto vehicle : vehicles) {\n\t\t// add or update\n\t\tif (AddOrUpdateVehicle(vehicle)) {\n\t\t\t// mark as updated\n\t\t\tcurrent_vehicles.erase(vehicle.id);\n\t\t}\n\t}\n\n\t// remove vehicles\n\tfor (auto id : current_vehicles) {\n\t\tRemoveAgent(id);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 45.99767236742028}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t (!_ready) {\n//    return false;\n//  }\n\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd!= nullptr);\n\n  // get the set of currently mapped vehicles\n  std::set<ActorId> mapped_vehicles;\n  {\n    // critical section, force single thread running this\n    std::lock_guard<std::mutex> lock(_mutex);\n    for (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); it++) {\n      mapped_vehicles.insert(it->first);\n    }\n  }\n\n  // add or update vehicles\n  for (auto vehicle : vehicles) {\n    // check if this vehicle is mapped\n    auto it = mapped_vehicles.find(vehicle.id);\n    if (it!= mapped_vehicles.end()) {\n      // this vehicle is mapped\n      // update the vehicle\n      AddOrUpdateVehicle(vehicle);\n    } else {\n      // this vehicle is not mapped\n      // add the vehicle\n      AddOrUpdateVehicle(vehicle);\n    }\n  }\n\n  // remove vehicles not in the current frame\n  for (auto it = mapped_vehicles.begin(); it!= mapped_vehicles.end(); it++) {\n    // check if this vehicle is mapped\n    auto it2 = std::find_if(vehicles.begin(), vehicles.end(), [it](VehicleCollisionInfo vehicle) { return vehicle.id == *it; });\n    if (it2 == vehicles.end()) {\n      // this vehicle is not mapped\n      // remove the vehicle\n      RemoveAgent(*it);\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 47.1968631563929}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tbool result = false;\n\tstd::lock_guard<std::mutex> lock(mutex);\n\tauto it = walkers.find(id);\n\tif (it!= walkers.end()) {\n\t\tauto walker = it->second;\n\t\tif (walker->GetVehicle()) {\n\t\t\tauto vehicle = walker->GetVehicle();\n\t\t\tresult = crowd->HasVehicleNear(vehicle, distance, direction);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 48.22556468675092}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tbool result = false;\n\tif (id == ActorId::kInvalidId) {\n\t\treturn false;\n\t}\n\tauto it = walkers_.find(id);\n\tif (it!= walkers_.end()) {\n\t\tresult = HasVehicleNear(it->second, distance, direction);\n\t} else {\n\t\tit = vehicles_.find(id);\n\t\tif (it!= vehicles_.end()) {\n\t\t\tresult = HasVehicleNear(it->second, distance, direction);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 53.16711987628674}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tWalkerEventVisitor visitor(info.context, info.routePoint, delta);\n\treturn boost::apply_visitor(visitor, info.event);\n}", "CodeBleu_score": 40.46116952015416}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tWalker *walker = GetWalker(id);\n\tif (!walker) {\n\t\treturn EventResult(false, \"Walker not found\", id);\n\t}\n\n\tWalkerEventVisitor visitor(info, delta);\n\tEventResult result = EventResult(false, \"Unknown event\", id);\n\n\t// Process the event\n\ttry {\n\t\tboost::variant2::visit(visitor, walker->GetCurrentEvent());\n\t\tresult = visitor.GetResult();\n\t} catch (std::exception &e) {\n\t\tresult = EventResult(false, e.what(), id);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 44.49813178539948}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tWalkerEventVisitor visitor(info, delta);\n\tauto event = info.GetEvent(id);\n\treturn boost::variant2::visit(visitor, event);\n}", "CodeBleu_score": 45.809274307612185}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n/*\n * This function, LaneParser::Parse, processes an XML document containing road data and updates a MapBuilder object.\nIt iterates through each road node, extracts the road ID, and processes each lane section within the lanes node.\nFor each lane section, it retrieves the left, center, and right lane nodes and parses them using the ParseLanes method, updating the map builder accordingly.\n */\n  for (pugi::xml_node road_node : xml.children(\"road\")) {\n    road::RoadId road_id = road_node.attribute(\"id\").as_int();\n\n    // Call Map builder create road function\n    map_builder.CreateRoad(road_id);\n\n    for (pugi::xml_node lane_node : road_node.children(\"lanes\")) {\n      const double s = lane_node.attribute(\"s\").as_double();\n\n      ParseLanes(lane_node, road_id, s, map_builder);\n    }\n  }\n}", "CodeBleu_score": 36.1670377077942}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n/*\n * For each road node in the XML document, this loop iterates through each lane section.\n * The first step is to retrieve the road ID and the lane ID from the XML node.\n * The road ID is retrieved using the attribute \"id\" and the lane ID is retrieved using the attribute \"id\".\n * The road ID is then used to retrieve the road from the map builder.\n * The lane ID is then used to retrieve the lane from the road.\n * The ParseLanes method is then called, passing the lane node and the map builder as arguments.\n */\n  for (pugi::xml_node road_node : xml.child(\"roads\").children(\"road\")) {\n\n    road::RoadId road_id = road_node.attribute(\"id\").as_int();\n    road::Road *road = map_builder.GetRoad(road_id);\n\n    for (pugi::xml_node lane_node : road_node.child(\"lanes\").children(\"lane\")) {\n\n      road::LaneId lane_id = lane_node.attribute(\"id\").as_int();\n\n      road::Lane *lane = map_builder.GetLane(road_id, lane_id);\n\n      ParseLanes(lane_node, lane, map_builder);\n    }\n  }\n}", "CodeBleu_score": 39.39934633022528}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node\n  for (pugi::xml_node road_node : xml.children(\"road\")) {\n    const int road_id = road_node.attribute(\"id\").as_int();\n    const double s = road_node.attribute(\"s\").as_double();\n\n    road::Road *road = map_builder.GetRoad(road_id);\n\n    // Process each lane section\n    ParseLanes(road_node, road, s, map_builder);\n  }\n}", "CodeBleu_score": 31.268653345519592}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.get_status() == efd::PublicationMatchedStatus::MATCHED) {\n\t\t// TODO: add logging\n\t\t//std::cout << \"Publication matched: \" << info.get_publication_name() << std::endl;\n\t}\n\telse if (info.get_status() == efd::PublicationMatchedStatus::UNMATCHED) {\n\t\t// TODO: add logging\n\t\t//std::cout << \"Publication unmatched: \" << info.get_publication_name() << std::endl;\n\t}\n\telse {\n\t\t// TODO: add logging\n\t\t//std::cout << \"Publication match status unknown: \" << info.get_publication_name() << std::endl;\n\t}\n}", "CodeBleu_score": 24.36711524232777}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\t// Check the publication for the listener.\n\tif (writer == m_pub_writer) {\n\t\t// Check the status.\n\t\tif (info.status == efd::PublicationMatchedStatus::MATCHED) {\n\t\t\t// Update the matched count.\n\t\t\tm_pub_matched_count++;\n\n\t\t\t// If the first connection, mark it.\n\t\t\tif (m_pub_matched_count == 1) {\n\t\t\t\tm_pub_first_connection = true;\n\t\t\t}\n\t\t}\n\t\telse if (info.status == efd::PublicationMatchedStatus::UNMATCHED) {\n\t\t\t// Update the matched count.\n\t\t\tm_pub_matched_count--;\n\n\t\t\t// If the last connection, mark it.\n\t\t\tif (m_pub_matched_count == 0) {\n\t\t\t\tm_pub_last_connection = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Log an error.\n\t\t\tLOG_ERROR(\"Invalid PublicationMatchedStatus: \" << info.status);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.83880765680165}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.is_match_lost()) {\n\t\tif (info.get_matched_count() == 0) {\n\t\t\t// If we have no more matches, clear the listener's state\n\t\t\tm_listener.clear();\n\t\t} else {\n\t\t\t// Otherwise, decrement the matched count\n\t\t\t--m_listener.m_matched_count;\n\t\t\tif (m_listener.m_matched_count < 0) {\n\t\t\t\tLOG_ERROR(\"Publication matched count is negative: %d\", m_listener.m_matched_count);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Increment the matched count\n\t\t++m_listener.m_matched_count;\n\t\tif (m_listener.m_matched_count < 0) {\n\t\t\tLOG_ERROR(\"Publication matched count is negative: %d\", m_listener.m_matched_count);\n\t\t}\n\n\t\t// If we have a match, mark the first connection\n\t\tif (m_listener.m_matched_count == 1) {\n\t\t\tm_listener.m_first_connection = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.5844031286287}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.subscription_matched_count_change() == efd::SubscriptionMatchedStatus::MATCHED_COUNT_CHANGE_INVALID) {\n\t\tLOG_ERROR(\"Invalid subscription matched count change\");\n\t\treturn;\n\t}\n\n\tif (info.subscription_matched_count_change() == efd::SubscriptionMatchedStatus::MATCHED_COUNT_CHANGE_ADDED) {\n\t\tif (first_connected) {\n\t\t\t// First connected, so subscribe to all available topics\n\t\t\tsubscribe_to_topics();\n\t\t\tfirst_connected = false;\n\t\t}\n\t\tmatched_count++;\n\t\tLOG_INFO(\"New subscription matched: %d\", matched_count);\n\t} else if (info.subscription_matched_count_change() == efd::SubscriptionMatchedStatus::MATCHED_COUNT_CHANGE_REMOVED) {\n\t\tmatched_count--;\n\t\tLOG_INFO(\"Subscription unmatched: %d\", matched_count);\n\t\tif (matched_count == 0) {\n\t\t\t// No more subscriptions are matched, so unsubscribe from all topics\n\t\t\tunsubscribe_from_topics();\n\t\t\t// Destroy the subscriber\n\t\t\tthis->destroy();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.359560101423796}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t", "CodeBleu_score": 6.029623537832621}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.is_new_subscription()) {\n\t\tm_matched_count++;\n\t\tm_first_connected = true;\n\t\tif (m_matched_count == 1) {\n\t\t\tm_subscriber = new CarlaSubscriber(reader);\n\t\t}\n\t} else if (info.is_old_subscription()) {\n\t\tm_matched_count--;\n\t\tif (m_matched_count == 0) {\n\t\t\tdelete m_subscriber;\n\t\t\tm_subscriber = NULL;\n\t\t}\n\t} else {\n\t\tEFD_LOG_ERROR(\"Invalid subscription change count: \" << info.get_change_count());\n\t}\n}", "CodeBleu_score": 40.564936148971356}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tCarlaCollisionEvent* p_type_data = reinterpret_cast<CarlaCollisionEvent*>(data);\n\tif (p_type_data!= nullptr) {\n\t\treturn getKey(p_type_data, handle, force_md5);\n\t}\n\treturn false;\n}", "CodeBleu_score": 13.983529999519867}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tCarlaCollisionEvent* ptr = reinterpret_cast<CarlaCollisionEvent*>(data);\n\tif (!key_defined_) {\n\t\treturn false;\n\t}\n\tchar* md5_buffer = NULL;\n\tbool result = false;\n\tsize_t size;\n\tstd::string tmp_string;\n\tint32_t tmp_int32;\n\tfloat tmp_float;\n\tbool tmp_bool;\n\tuint64_t tmp_uint64;\n\tstd::string tmp_string2;\n\tif (force_md5) {\n\t\t// 1. Generate the md5\n\t\tmd5_buffer = new char[MD5_DIGEST_LENGTH];\n\t\tmemset(md5_buffer, 0, MD5_DIGEST_LENGTH);\n\t\tsize = MD5_DIGEST_LENGTH;\n\t\tresult = getMD5(data, md5_buffer, size);\n\t\tif (!result) {\n\t\t\tdelete[] md5_buffer;\n\t\t\treturn false;\n\t\t}\n\t\t// 2. Set the handle key to the md5 buffer\n\t\thandle->key = md5_buffer;\n\t\thandle->key_length = MD5_DIGEST_LENGTH;\n\t\thandle->key_allocated = MD5_DIGEST_LENGTH;\n\t}\n\telse {\n\t\t// 1. Serialize the data\n\t\tcdrSerialize(data, handle);\n\t\t// 2. Get the md5\n\t\tsize = handle->key_length;\n\t\tmd5_buffer = new char[size];\n\t\tmemset(md5_buffer, 0, size);\n\t\tresult = getMD5(data, md5_buffer, size);\n\t\tif (!result) {\n\t\t\tdelete[] md5_buffer;\n\t\t\treturn false;\n\t\t}\n\t\t// 3. Set the handle key to the md5 buffer\n\t\thandle->key = md5_buffer;\n\t\thandle->key_length = size;\n\t\thandle->key_allocated = size;\n\t}\n\treturn true;\n}", "CodeBleu_score": 36.66163189208355}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (getKeyDefined()) {\n\t\tCarlaCollisionEvent* p_data = (CarlaCollisionEvent*)data;\n\t\tstd::string key = p_data->get_key();\n\t\tif (key.size() > 0) {\n\t\t\tif (force_md5) {\n\t\t\t\t// This is an md5 key\n\t\t\t\tunsigned char md5[16];\n\t\t\t\t(void)MD5((const unsigned char*) key.c_str(), key.size(), md5);\n\t\t\t\tmemcpy(&handle->value[0], &md5[0], 16);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// This is a simple key\n\t\t\t\tmemcpy(&handle->value[0], key.c_str(), key.size());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 26.71096455136294}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t// This function uses the FastBuffer to serialize the data\n// in a buffer, which is the output of this function.\n\n    // serialize the data into the buffer\n\n    // Retrieve the size of the data to be serialized\n    // (prior to serialization)\n    uint32_t dataSize = static_cast<uint32_t>(getSerializedSize(data));\n\n    // Create a buffer with the serialized data\n    SerializedPayload_t payloadBuffer{dataSize, payload->data};\n\n    // Deserialize the data from the buffer into the Cdr object\n    eprosima::fastcdr::FastBuffer fastBuffer(payloadBuffer.buffer, payloadBuffer.buffer_length);\n    eprosima::fastcdr::Cdr ser(fastBuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    ser.serialize_array(data, dataSize);\n\n    // Update the payload length\n    payload->length = payloadBuffer.buffer_length;\n\n    // Return the result\n    return true;\n}", "CodeBleu_score": 40.27331035556714}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t", "CodeBleu_score": 2.5978767707221393}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t#ifdef ENABLE_OBJECT_SERIALIZATION\n    return serialize(data, payload, ENDIANNESS_LITTLE);\n#else\n    return false;\n#endif\n}", "CodeBleu_score": 11.266194141456227}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (msg.msgid == MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED) {\n\t\t// we are tracking a position target\n\t\tif (target_set) {\n\t\t\t// target already set\n\t\t\treturn;\n\t\t}\n\n\t\t// decode the message\n\t\tmavlink_position_target_local_ned_t position_target_local_ned;\n\t\tmavlink_msg_position_target_local_ned_decode(&msg, &position_target_local_ned);\n\n\t\t// set the sysid\n\t\ttarget_sysid = msg.sysid;\n\n\t\t// request position and air pressure data streams from the target\n\t\tmavlink_msg_command_long_send(MAVLINK_COMM_0, target_sysid, MAV_CMD_REQUEST_MESSAGE, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n\t\t// flag that the target has been set\n\t\ttarget_set = true;\n\t}\n}", "CodeBleu_score": 29.82380684449958}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED:\n\tcase MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT:\n\tcase MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT_V2:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_V2:\n\tcase MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED:\n\t\ttarget_sysid = msg.sysid;\n\t\ttarget_set = true;\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_REQUEST_DATA_STREAM:\n\t\tif (msg.sysid == target_sysid) {\n\t\t\tmavlink_request_data_stream(target_sysid, 0, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t}\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 29.58003535507721}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\treturn _mavlink_command_handler_base::_handle_command_preflight_calibration_baro(msg);\n}", "CodeBleu_score": 29.405409569215312}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tif (m_preflight_calibration_baro_set) {\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\n\tm_preflight_calibration_baro_set = true;\n\treturn _handle_command_preflight_calibration(msg);\n}", "CodeBleu_score": 37.62188578429476}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n\tif (this->get_mavlink_system_id() == msg.sysid && this->get_mavlink_component_id() == msg.compid) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tthis->set_preflight_calibration_baro_needed(true);\n\t}\n\n\treturn this->handle_command_preflight_calibration(result, msg);\n}", "CodeBleu_score": 34.32192999546593}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\t// Arm the servos\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\t// Disarm the servos\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\t// Unsupported command parameter\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 42.634872392902246}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\t// Arm the servos\n\t\tarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\t// Disarm the servos\n\t\tdisarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\t// Unsupported command parameter\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 47.51640911440245}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\tarm_disarm_servos(true);\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0.0) {\n\t\tarm_disarm_servos(false);\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 53.30662128436951}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over all channels and check if there is available space for the data stream\n\tfor (int i = 0; i < GCS_CHANNELS; i++) {\n\t\t// Check if there is available space for the data stream\n\t\tif (gcs_channels[i].available_space() >= sizeof(mavlink_global_position_int_t)) {\n\t\t\t// Send the request to start the data stream\n\t\t\tmavlink_msg_request_data_stream_send(gcs_channels[i].get_mavlink_channel(), sysid, compid, MAV_DATA_STREAM_POSITION, 1, 10);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.82056462748564}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Check if there is available payload space on the GCS channels\n\tuint8_t payload_space = 0;\n\tfor (uint8_t i = 0; i < GCS_CHANNELS; i++) {\n\t\tpayload_space += _gcs_channels[i].get_payload_space();\n\t}\n\tif (payload_space == 0) {\n\t\t// No payload space available\n\t\treturn;\n\t}\n\n\t// Find the first available channel\n\tuint8_t channel = 0;\n\tfor (uint8_t i = 0; i < GCS_CHANNELS; i++) {\n\t\tif (_gcs_channels[i].get_payload_space() > 0) {\n\t\t\tchannel = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Send the request\n\t_gcs_channels[channel].send_request_datastream(sysid, compid, 100);\n}", "CodeBleu_score": 35.615851809963715}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (int i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\tif (GCS_channels[i].available_payload_space() >= sizeof(mavlink_msg_position_target_global_int_t)) {\n\t\t\tGCS_channels[i].send_request_datastream(sysid, compid, MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT, 1, 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 44.04800740503452}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = AHRS::getInstance();\n\tfloat pitch_cos = ahrs->getPitchCos();\n\tif (pitch_cos!= 0) {\n\t\tef_pitch = asin(pitch_cos);\n\t\tef_yaw = yaw;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 41.20339410124807}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS* ahrs = AHRS::get_instance();\n\tif (ahrs->get_pitch_cosine()!= 0) {\n\t\tef_pitch = asin(ahrs->get_pitch_sine() * pitch + ahrs->get_roll_sine() * yaw);\n\t\tef_yaw = atan2(ahrs->get_pitch_sine() * ahrs->get_roll_cosine() - ahrs->get_roll_sine() * ahrs->get_pitch_cosine() * yaw, ahrs->get_roll_cosine() * ahrs->get_pitch_cosine() + ahrs->get_pitch_sine() * ahrs->get_roll_sine() * yaw);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 54.04825890111318}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Retrieve the AHRS instance\n\tAHRS* ahrs = AHRS::get_instance();\n\n\t// Check for a zero pitch cosine\n\tif (cos(pitch)!= 0) {\n\t\t// Calculate earth frame pitch and yaw\n\t\tef_pitch = asin(cos(ahrs->get_pitch()) * sin(pitch) + sin(ahrs->get_pitch()) * cos(pitch) * cos(yaw));\n\t\tef_yaw = atan2(sin(yaw) * sin(pitch) * cos(ahrs->get_pitch()) - cos(yaw) * sin(ahrs->get_pitch()), cos(pitch) * cos(yaw));\n\n\t\t// Return true\n\t\treturn true;\n\t}\n\n\t// Return false\n\treturn false;\n}", "CodeBleu_score": 47.540005221621065}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}, {"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}, {"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t", "CodeBleu_score": 1.8359599812427831}, {"code": "void Tracker::update_GPS(void){\n\t\t// Check if the GPS has a new message\n\tif (GPS.newNMEAreceived()) {\n\t\t// Update the GPS data\n\t\tGPS.parse(GPS.lastNMEA());\n\t}\n\n\t// Check if the last message time has changed\n\tif (GPS.lastNMEA()!= last_GPS_message) {\n\t\t// Update the last message time\n\t\tlast_GPS_message = GPS.lastNMEA();\n\t\t// Check if the GPS status is at least 3D fix\n\t\tif (GPS.fix) {\n\t\t\t// Update the GPS data\n\t\t\tGPS.update();\n\t\t\t// Check if the countdown is running\n\t\t\tif (countdown) {\n\t\t\t\t// Check if the current location is valid\n\t\t\t\tif (GPS.location.isValid()) {\n\t\t\t\t\t// Set the home location\n\t\t\t\t\thome_location = GPS.location;\n\t\t\t\t\t// Reset the countdown\n\t\t\t\t\tcountdown = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Check if the current location is valid\n\t\t\t\tif (GPS.location.isValid()) {\n\t\t\t\t\t// Check if the current location is close to the home location\n\t\t\t\t\tif (GPS.location.distanceTo(home_location) < 20) {\n\t\t\t\t\t\t// Start the countdown\n\t\t\t\t\t\tcountdown = 10;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.88928143131772}, {"code": "void Tracker::update_GPS(void){\n\t\t// Read GPS data\n\tif (GPS.newNMEAreceived()) {\n\t\tif (!GPS.parse(GPS.lastNMEA())) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Update GPS data\n\tif (GPS.fix) {\n\t\t// Update the last message time\n\t\tlast_message_time = millis();\n\n\t\t// Update the GPS data\n\t\tlatitude = GPS.latitude;\n\t\tlongitude = GPS.longitude;\n\t\taltitude = GPS.altitude;\n\t\tsatellites = GPS.satellites;\n\t\thdop = GPS.hdop;\n\t\tspeed = GPS.speed;\n\t\tcourse = GPS.course;\n\t\tdate = GPS.date;\n\t\ttime = GPS.time;\n\n\t\t// Check if the GPS status is good enough\n\t\tif (GPS.fix == 3) {\n\t\t\t// Check if the GPS has been initialized\n\t\t\tif (!initialized) {\n\t\t\t\t// Set the home location\n\t\t\t\thome_latitude = latitude;\n\t\t\t\thome_longitude = longitude;\n\t\t\t\thome_altitude = altitude;\n\t\t\t\thome_satellites = satellites;\n\t\t\t\thome_hdop = hdop;\n\t\t\t\thome_speed = speed;\n\t\t\t\thome_course = course;\n\t\t\t\thome_date = date;\n\t\t\t\thome_time = time;\n\t\t\t\tinitialized = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 33.86977360186042}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0f) {\n\t\tif (pitch_onoff_servo_on_off_ == false) {\n\t\t\tpitch_onoff_servo_on_off_ = true;\n\t\t\tpitch_onoff_servo_on_off_time_ = millis();\n\t\t}\n\t} else {\n\t\tif (pitch_onoff_servo_on_off_ == true) {\n\t\t\tpitch_onoff_servo_on_off_ = false;\n\t\t\tpitch_onoff_servo_on_off_time_ = millis();\n\t\t}\n\t}\n}", "CodeBleu_score": 18.57104280257644}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// if we are in the ground start phase, and we are not at the last location, then we need to keep the pitch servo on\n\tif (ground_start_countdown > 0 && current_location.valid) {\n\t\t// if we are not at the last location, then we need to keep the pitch servo on\n\t\tif (ground_start_countdown > 1) {\n\t\t\t// we are not at the last location, so we keep the pitch servo on\n\t\t\tif (pitch_servo_on) {\n\t\t\t\t// if the pitch servo is already on, then we do not need to do anything\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// if the pitch servo is not on, then we turn it on\n\t\t\t\tpitch_servo_on = true;\n\t\t\t\t// we set the pitch servo to the current pitch\n\t\t\t\tset_pitch_servo(pitch);\n\t\t\t}\n\t\t} else {\n\t\t\t// we are at the last location, so we need to turn the pitch servo off\n\t\t\tif (!pitch_servo_on) {\n\t\t\t\t// if the pitch servo is already off, then we do not need to do anything\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// if the pitch servo is not off, then we turn it off\n\t\t\t\tpitch_servo_on = false;\n\t\t\t\t// we set the pitch servo to the current pitch\n\t\t\t\tset_pitch_servo(pitch);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 25.536619162140862}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0f) {\n\t\t_pitch_onoff_servo.set_servo_position(0);\n\t} else {\n\t\t_pitch_onoff_servo.set_servo_position(1800);\n\t}\n}", "CodeBleu_score": 13.446637463770525}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tif (!Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (Arming::get_arming_check_baro()) {\n\t\t// check barometer altitude\n\t\tif (fabsf(Arming::get_baro_reference() - get_inertial_nav_altitude()) > Arming::get_baro_disparity_limit()) {\n\t\t\tif (display_failure) {\n\t\t\t\t_failure_reason = AP_Arming::BAROMETER_DISPARITY;\n\t\t\t\t_failure_reason_str = \"Barometer disparity\";\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 24.48361416784849}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool ret = AP_Arming::barometer_checks(display_failure);\n\n\tif (ret && (ARMED_CHECK_BARO & ARMED_CHECK_FLAGS)) {\n\t\t// check barometer altitude against inertial navigation altitude\n\t\t// we don't want to arm the copter if the barometer is too far off\n\t\tif (fabsf(baro_alt - nav_alt) > 1.0f) {\n\t\t\tif (display_failure) {\n\t\t\t\t_failure_reason = AP_Arming::BARO_ALT_FAIL;\n\t\t\t\t_failure_alt = baro_alt;\n\t\t\t\t_failure_nav_alt = nav_alt;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 31.065776624410912}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool result = true;\n\n\t// check barometer reference\n\tif (ArmingCheckBaro) {\n\t\tresult = result && base_class::barometer_checks(display_failure);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 15.933844202208011}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\treturn false;\n}", "CodeBleu_score": 8.614048038226855}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_terrain_source == TerrainSource::Rangefinder) {\n\t\treturn false;\n\t}\n\n\tif (_terrain_source == TerrainSource::TerrainDatabase) {\n\t\tif (_rtl_altitude_type == RTLAltitudeType::Terrain) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 50.569103217812284}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif ( _terrain_source == TerrainSource::Rangefinder ) {\n\t\treturn false;\n\t}\n\n\tif ( _terrain_source == TerrainSource::TerrainDatabase && _alt_type == AltitudeType::Terrain ) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming_Copter::terrain_database_required();\n}", "CodeBleu_score": 49.418413906832434}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// Set the loop time for the rate controllers\n\tattitude_controller.set_loop_time(loop_time);\n\tposition_controller.set_loop_time(loop_time);\n\tmotor_controller.set_loop_time(loop_time);\n\n\t// Run the rate controllers\n\tattitude_controller.run();\n\tposition_controller.run();\n\tmotor_controller.run();\n}", "CodeBleu_score": 46.637379213090256}, {"code": "void Copter::run_rate_controller(){\n\t\t// Get loop time from scheduler\n\tfloat loop_time = scheduler.get_loop_time();\n\n\t// Run the attitude controller\n\tattitude_controller.run(loop_time);\n\n\t// Run the position controller\n\tposition_controller.run(loop_time);\n\n\t// Run the motor controller\n\tmotor_controller.run(loop_time);\n}", "CodeBleu_score": 43.39099095816673}, {"code": "void Copter::run_rate_controller(){\n\t\t// Set the loop time to the last loop time\n\tloop_time = scheduler.get_last_loop_time();\n\n\t// Run the attitude controller\n\tattitude_controller.run(loop_time);\n}", "CodeBleu_score": 28.516458052029968}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// check if old location matches the new location\n\tif (old_loc.is_equal(new_loc)) {\n\t\treturn false;\n\t}\n\n\t// check if the altitude frames of the old and new locations are the same\n\tif (old_loc.get_altitude_frame()!= new_loc.get_altitude_frame()) {\n\t\treturn false;\n\t}\n\n\t// set the new location as the target\n\tmode_guided.set_destination(new_loc);\n\n\treturn true;\n}", "CodeBleu_score": 51.326098647644}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// check if the new location matches the old location\n\tif (old_loc.lat_lon_alt_valid() && new_loc.lat_lon_alt_valid() && (old_loc.get_lat_lon_alt() == new_loc.get_lat_lon_alt())) {\n\t\t// check if the altitude frames of the old and new locations are the same\n\t\tif (old_loc.get_frame() == new_loc.get_frame()) {\n\t\t\t// set the new location as the target\n\t\t\treturn set_target_location(new_loc);\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 49.71276474481113}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (new_loc.is_valid()) {\n\t\tif (old_loc.is_valid()) {\n\t\t\tif (old_loc.alt_frame() == new_loc.alt_frame()) {\n\t\t\t\tif (old_loc.lat_lon() == new_loc.lat_lon()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tset_target_location(new_loc);\n\treturn true;\n}", "CodeBleu_score": 49.93525974147056}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\t// attempt to set the mode\n\t\tif (set_mode(mode) == false) {\n\t\t\t// failed to set the mode\n\t\t\t// TODO: log error\n\t\t}\n\t} else {\n\t\t// reset the mode switch\n\t\treset_mode_switch();\n\t}\n}", "CodeBleu_score": 29.197780803091156}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\t// Attempt to set the mode\n\t\tif (set_mode(mode)) {\n\t\t\t// If the mode was set successfully, reset the mode switch\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t} else {\n\t\t// If the mode switch is not in the HIGH position and the current mode matches the given mode, reset the mode switch\n\t\tif (mode == mode_number()) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 51.72273919249204}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (set_mode(mode)) {\n\t\t\t// If we successfully set the mode, then we don't need to reset the mode switch.\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch_flag == AuxSwitchPos::LOW) {\n\t\tif (current_mode == mode) {\n\t\t\t// If we're already in the mode we want, then we don't need to reset the mode switch.\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// If we get here, then we need to reset the mode switch.\n\trc().reset_mode_switch();\n}", "CodeBleu_score": 40.123871933312806}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// Get the current roll and pitch trim values\n\tfloat roll_trim = m_control_in->get_trim(ROLL);\n\tfloat pitch_trim = m_control_in->get_trim(PITCH);\n\n\t// Convert the trim values to radians\n\troll_trim = roll_trim * DEG_TO_RAD;\n\tpitch_trim = pitch_trim * DEG_TO_RAD;\n\n\t// Add the trim values to the AHRS trim\n\tm_ahrs->set_trim(roll_trim, pitch_trim);\n\n\t// Log the event\n\tm_log_handler->log_event(LOG_EVENT_SAVE_TRIM);\n\n\t// Send a confirmation message\n\tm_mavlink_handler->send_message(MAVLINK_MSG_ID_HEARTBEAT, MAV_SEVERITY_INFO, \"Trim values saved\");\n}", "CodeBleu_score": 50.156074703481245}, {"code": "void Copter::save_trim(){\n\t\ttrim_roll = (float) (control_in[ROLL] - (float) (control_in[ROLL] - control_in[ROLL_TRIM]) / 2.0) * M_PI / 180.0;\n\ttrim_pitch = (float) (control_in[PITCH] - (float) (control_in[PITCH] - control_in[PITCH_TRIM]) / 2.0) * M_PI / 180.0;\n\ttrim_yaw = (float) (control_in[YAW] - (float) (control_in[YAW] - control_in[YAW_TRIM]) / 2.0) * M_PI / 180.0;\n\tahrs.set_trim(trim_roll, trim_pitch, trim_yaw);\n\tlog_info(\"Trim saved\");\n\tmavlink_log_info(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 40.42638640133392}, {"code": "void Copter::save_trim(){\n\t\t// Calculate the trim values from the control inputs of the roll and pitch channels\n\tfloat roll_trim = (float)rc_channels.channels[ROLL].control / 1000.0f;\n\tfloat pitch_trim = (float)rc_channels.channels[PITCH].control / 1000.0f;\n\n\t// Convert the trim values to radians\n\troll_trim *= M_PI / 180.0f;\n\tpitch_trim *= M_PI / 180.0f;\n\n\t// Add the trim values to the AHRS trim\n\tahrs_trim[ROLL] += roll_trim;\n\tahrs_trim[PITCH] += pitch_trim;\n\n\t// Log the trim event\n\tmavlink_log_info(0, \"Trim saved: roll trim: %f, pitch trim: %f\", roll_trim, pitch_trim);\n\n\t// Send a confirmation message with MAV_SEVERITY_INFO\n\tmavlink_log_info(0, \"Trim saved: roll trim: %f, pitch trim: %f\", roll_trim, pitch_trim);\n}", "CodeBleu_score": 45.38092215144003}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat look_ahead_yaw = 0.0f;\n\tfloat speed_squared = 0.0f;\n\n\t// Retrieve the copter's velocity\n\tconst Vector3f& velocity = copter.get_velocity();\n\n\t// Calculate the speed squared\n\tspeed_squared = velocity.x * velocity.x + velocity.y * velocity.y;\n\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components\n\tif (copter.get_position_valid() && speed_squared > MIN_SPEED_SQUARED) {\n\t\tlook_ahead_yaw = atan2f(velocity.y, velocity.x);\n\t}\n\n\treturn look_ahead_yaw;\n}", "CodeBleu_score": 46.76026583604642}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Get the copter's velocity.\n\tfloat v_x = copter->get_velocity_x();\n\tfloat v_y = copter->get_velocity_y();\n\tfloat v_z = copter->get_velocity_z();\n\tfloat v_mag = sqrt(pow(v_x, 2) + pow(v_y, 2) + pow(v_z, 2));\n\n\t// Check if the copter's position is valid and the speed exceeds a minimum threshold.\n\tif (copter->get_position_valid() && v_mag > 0.1) {\n\t\t// Calculate the look-ahead yaw angle using the arctangent of the velocity components.\n\t\tfloat yaw_angle = atan2(v_y, v_x);\n\n\t\t// Update the look-ahead yaw angle.\n\t\tlook_ahead_yaw_angle = yaw_angle;\n\t}\n\n\t// Return the computed look-ahead yaw angle.\n\treturn look_ahead_yaw_angle;\n}", "CodeBleu_score": 41.21087917263907}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tif (copter_position_valid()) {\n\t\tfloat speed_squared = copter_velocity_x() * copter_velocity_x() + copter_velocity_y() * copter_velocity_y();\n\t\tif (speed_squared > MIN_SPEED_SQUARED) {\n\t\t\tfloat yaw_angle = atan2f(copter_velocity_y(), copter_velocity_x());\n\t\t\treturn yaw_angle;\n\t\t}\n\t}\n\treturn 0;\n}", "CodeBleu_score": 32.3519247483526}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// Check if arming is disabled\n\tif (AP_Arming::disabled()) {\n\t\treturn true;\n\t}\n\n\t// Check if watchdog was armed\n\tif (AP_Arming::armed()) {\n\t\treturn true;\n\t}\n\n\t// Check if throttle is zero\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (!AP_Arming::throttle_zero()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn AP_Arming_Plane::arm_checks(method);\n}", "CodeBleu_score": 35.37943350619608}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tswitch (method) {\n\tcase AP_Arming::RUDDER:\n\t\t// if rudder arming is disabled, or if throttle is not zero, return false\n\t\tif (AP_Arming::rudder_arming_disabled() || _rudder_throttle_check()) {\n\t\t\treturn false;\n\t\t}\n\t\t// if arming checks are disabled or watchdog was armed, return true\n\t\tif (AP_Arming::arming_checks_disabled() || AP_Arming::watchdog_armed()) {\n\t\t\treturn true;\n\t\t}\n\t\t// otherwise, call parent class's arm_checks method\n\t\treturn AP_Arming::arm_checks(method);\n\tdefault:\n\t\t// otherwise, call parent class's arm_checks method\n\t\treturn AP_Arming::arm_checks(method);\n\t}\n}", "CodeBleu_score": 38.699497078533646}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// If the watchdog was armed, we can arm the plane without further checks\n\tif (AP_Arming::is_armed(method) || AP_Arming::is_watchdog_armed()) {\n\t\treturn true;\n\t}\n\n\t// If arming checks are disabled, we can arm the plane without further checks\n\tif (!AP_Arming::is_checks_enabled(method)) {\n\t\treturn true;\n\t}\n\n\tswitch (method) {\n\tcase AP_Arming::RUDDER:\n\t\t// If rudder arming is disabled, we can't arm the plane\n\t\tif (!AP_Arming::is_rudder_armed()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the throttle is not zero, we can't arm the plane\n\t\tif (get_throttle()!= 0.0f) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase AP_Arming::THROTTLE:\n\t\t// If throttle arming is disabled, we can't arm the plane\n\t\tif (!AP_Arming::is_throttle_armed()) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase AP_Arming::THROTTLE_RUDDER:\n\t\t// If throttle arming is disabled, we can't arm the plane\n\t\tif (!AP_Arming::is_throttle_armed()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If rudder arming is disabled, we can't arm the plane\n\t\tif (!AP_Arming::is_rudder_armed()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the throttle is not zero, we can't arm the plane\n\t\tif (get_throttle()!= 0.0f) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\n\t// Call the parent's arm_checks method\n\treturn AP_Arming_Plane::arm_checks(method);\n}", "CodeBleu_score": 50.51584942861359}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t#if HAL_QUADPLANE_ENABLED\n    if (plane.quadplane.is_armed()) {\n        return false;\n    }\n#endif\n\n    // update the current location\n    update_current_location();\n\n    // update the home location\n    update_home_location();\n\n    // update the arming state\n    change_arm_state();\n\n    // arm the plane\n    bool armed = false;\n    switch (method) {\n        case AP_Arming::METHOD_DISARMED:\n            armed = true;\n            break;\n        case AP_Arming::METHOD_SOFT:\n            armed = true;\n            if (do_arming_checks) {\n                armed = check_arming_checks();\n            }\n            break;\n        case AP_Arming::METHOD_HARD:\n            armed = true;\n            if (do_arming_checks) {\n                armed = check_arming_checks();\n            }\n            break;\n        default:\n            break;\n    }\n\n    // set a delay arming flag\n    if (armed) {\n        delay_arming = true;\n    }\n\n    // send a status text\n    if (armed) {\n        hal.console->send_text_P(PSTR(\"Throttle armed\"));\n    } else {\n        hal.console->send_text_P(PSTR(\"Throttle disarmed\"));\n    }\n\n    return armed;\n}", "CodeBleu_score": 46.10027225039152}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (sub.armed()) {\n\t\treturn true;\n\t}\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\t// no disarm function\n\t\t\tsub.failure_reason = AP_Arming::k_no_disarm_function;\n\t\t\tsub.arming_failure();\n\t\t}\n\t\treturn false;\n\t}\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 66.78500500883067}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_SITL\n    return true;\n#else\n    if (sub.armed()) {\n        if (display_failure) {\n            // display failure message\n            sub.get_vehicle()->console_printf_P(PSTR(\"Armed, cannot arm again\n\"));\n        }\n        return true;\n    }\n\n    // check if disarm button is configured\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            // display failure message\n            sub.get_vehicle()->console_printf_P(PSTR(\"No disarm button configured\n\"));\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n#endif\n}", "CodeBleu_score": 61.10480850491544}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_APM2\n    if (sub.armed()) {\n        return true;\n    }\n#endif\n    if (has_disarm_function()) {\n        // if there is a disarm button, check if it's configured\n        if (!sub.get_button(JS_DISARM_BUTTON)->is_configured()) {\n            // disarm button is not configured, display failure message\n            if (display_failure) {\n                sub.get_console()->printf_P(PSTR(\"Disarm button not configured\n\"));\n            }\n            return false;\n        }\n    }\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 58.282542142412076}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat yaw_rad = yaw * (M_PI / 180.0);\n\tfloat cos_yaw = cos(yaw_rad);\n\tfloat sin_yaw = sin(yaw_rad);\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 52.19622404468242}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat yaw = get_yaw();\n\tfloat cos_yaw = cos(yaw);\n\tfloat sin_yaw = sin(yaw);\n\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 56.457271610898594}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat yaw = ahrs->getYaw();\n\tfloat cos_yaw = cos(yaw);\n\tfloat sin_yaw = sin(yaw);\n\n\tfloat ne_x = x * cos_yaw - y * sin_yaw;\n\tfloat ne_y = x * sin_yaw + y * cos_yaw;\n\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 61.934812904835304}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t//Check if the yaw angle is within the acceptable range\n\tif (packet.param1 > 180 || packet.param1 < -180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t//Check if the yaw speed is within the acceptable range\n\tif (packet.param2 > 180 || packet.param2 < -180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t//Set the yaw heading and speed\n\tset_yaw_heading(packet.param1);\n\tset_yaw_speed(packet.param2);\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 43.912214905019866}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t//check if the yaw angle is within acceptable ranges\n\tif (packet.param1 < -180 || packet.param1 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t//check if the yaw condition type is within acceptable ranges\n\tif (packet.param2 < 0 || packet.param2 > 2) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t//check if the yaw angle is within acceptable ranges\n\tif (packet.param3 < -180 || packet.param3 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t//check if the yaw angle is within acceptable ranges\n\tif (packet.param4 < -180 || packet.param4 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t//set the yaw heading\n\tif (packet.param2 == 0) {\n\t\t_yaw_heading = packet.param1;\n\t} else if (packet.param2 == 1) {\n\t\t_yaw_heading = packet.param3;\n\t} else if (packet.param2 == 2) {\n\t\t_yaw_heading = packet.param4;\n\t}\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 47.40652307552281}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if the yaw angle is within acceptable ranges.\n\tif (packet.param1 > 180 || packet.param1 < -180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the yaw speed is within acceptable ranges.\n\tif (packet.param2 > 180 || packet.param2 < -180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the yaw direction is within acceptable ranges.\n\tif (packet.param3!= 0 && packet.param3!= 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the yaw relative is within acceptable ranges.\n\tif (packet.param4!= 0 && packet.param4!= 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw condition.\n\tset_yaw_condition(packet.param1, packet.param2, packet.param3, packet.param4);\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 49.86881816110804}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\tuint8_t retval = 0;\n\tif (this->control_mode == MAV_MODE_AUTO_ARMED || this->control_mode == MAV_MODE_GUIDED_ARMED) {\n\t\tretval = (uint8_t)((this->high_latency_tgt_bearing + 18000) % 36000 / 2);\n\t}\n\treturn retval;\n}", "CodeBleu_score": 40.23884764764536}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn (uint8_t) (high_latency_tgt_heading_ * 0.5);\n}", "CodeBleu_score": 6.527192752255775}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.150400996515202}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (Log_Enabled) {\n\t\tLog_Write_Data(id, value, 0);\n\t}\n}", "CodeBleu_score": 23.954904637483054}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (LOGGING_ENABLED) {\n\t\tLog_Write_Data_Critical(id, value);\n\t}\n}", "CodeBleu_score": 17.907953936104303}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (log_enabled) {\n\t\tLog_Write_Data(id, (uint32_t) value);\n\t}\n}", "CodeBleu_score": 25.581058819251734}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t#if defined(CONFIG_ARCH_BOARD_PX4FMU_V2) || defined(CONFIG_ARCH_BOARD_PX4FMU_V3)\n    // don't update home if we have a valid home location\n    if (home_is_set()) {\n        return;\n    }\n\n    // set home to EKF location\n    Location temp_loc;\n    if (ahrs.get_location(temp_loc)) {\n        // set home to current location\n        if (motors.armed()) {\n            set_home_to_current_location();\n        } else {\n            set_home(temp_loc, false);\n        }\n    }\n#endif\n}", "CodeBleu_score": 31.133150704344214}, {"code": "void Sub::update_home_from_EKF(){\n\t#if defined(SUB_HAS_HOME_POSITION_LOCK)\n    // if home position lock is enabled, then home position is not updated from EKF\n    return;\n#endif\n\n    // get current location from EKF\n    Location temp_loc;\n    if (ahrs.get_location(temp_loc)) {\n\n        // Make home always at the water's surface.\n        // This allows disarming and arming again at depth.\n        // This also ensures that mission items with relative altitude frame, are always\n        // relative to the water's surface, whether in a high elevation lake, or at sea level.\n        temp_loc.alt -= barometer.get_altitude() * 100.0f;\n\n        // if home position is not set, then set it\n        if (!home_position.is_set()) {\n            set_home(temp_loc, false);\n        }\n        // else, if home position is set, then check if it is different from the current EKF location\n        else {\n            // if the home position is different from the EKF location, then update it\n            if (home_position.get_lat()!= temp_loc.lat || home_position.get_lon()!= temp_loc.lon) {\n                set_home(temp_loc, false);\n            }\n        }\n    }\n}", "CodeBleu_score": 23.73677798828621}, {"code": "void Sub::update_home_from_EKF(){\n\t\t// get current location from EKF\n    Location temp_loc;\n    Location ekf_origin;\n    if (ahrs.get_location(temp_loc) && ahrs.get_origin(ekf_origin)) {\n        temp_loc.alt = ekf_origin.alt;\n        if (!set_home(temp_loc, false)) {\n            // ignore this failure\n        }\n    }\n}", "CodeBleu_score": 21.898076348476962}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\tif (!motorsAreArmed) {\n\t\tsetThrottle(0);\n\t\tspoolState = SpoolState::UNLIMITED_THROTTLE;\n\t\trelaxAttitudeControllers();\n\t\texit();\n\t} else {\n\t\tspoolState = SpoolState::UNLIMITED_THROTTLE;\n\t\tsetThrottle(pilotThrottle);\n\t\tif (pilotThrottle == 0) {\n\t\t\trelaxAttitudeControllers();\n\t\t\texit();\n\t\t} else {\n\t\t\tconvertPilotRatesToBodyFrameRates();\n\t\t\tattitudeController.run();\n\t\t\tsetMotorInputs();\n\t\t}\n\t}\n}", "CodeBleu_score": 31.978677568141283}, {"code": "void ModeAcro::run(){\n\t\t// if motors are not armed, set throttle to zero and exit\n\tif (!motorsArmed) {\n\t\tthrottle = 0;\n\t\tspoolState = SpoolState::UNLIMITED_THROTTLE;\n\t\tattitudeController.relax();\n\t\treturn;\n\t}\n\n\t// if armed, set spool state to unlimited throttle, convert pilot inputs to rates, run attitude controller with these rates\n\tspoolState = SpoolState::UNLIMITED_THROTTLE;\n\tattitudeController.run(throttle, pitchRate, rollRate, yawRate);\n\n\t// output throttle without angle boost and set motor inputs based on pilot controls\n\tthrottle = throttle * (1 - angleBoost);\n\tsetMotorInputs(throttle, pitchRate, rollRate, yawRate);\n}", "CodeBleu_score": 33.1235833681953}, {"code": "void ModeAcro::run(){\n\t\t// If the motors are not armed, set throttle to zero and exit\n\tif (!motors.armed) {\n\t\tthrottle = 0;\n\t\tspoolState = SPOOL_UNLIMITED;\n\t\trelaxAttitude();\n\t\treturn;\n\t}\n\n\t// Set throttle to unlimited\n\tspoolState = SPOOL_UNLIMITED;\n\n\t// Convert pilot inputs to desired body frame rates\n\tbodyFrameRates.roll = pilot.roll * pilot.throttle;\n\tbodyFrameRates.pitch = pilot.pitch * pilot.throttle;\n\tbodyFrameRates.yaw = pilot.yaw * pilot.throttle;\n\n\t// Run the attitude controller\n\tattitudeController.run(bodyFrameRates, attitude);\n\n\t// Set the forward and lateral motor inputs\n\tmotors.forward = attitude.forward;\n\tmotors.lateral = attitude.lateral;\n}", "CodeBleu_score": 32.76135608995995}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// Set guided mode\n\tset_guided_mode();\n\t// Set the stopping point as the destination\n\tset_destination(sub.stopping_point);\n\t// Set the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n\t// Initialize the waypoint controller\n\twp_control.init();\n}", "CodeBleu_score": 18.757158061762897}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set the mode to position control\n\tset_mode(MODE_POSCTL);\n\t// set the destination to the current position\n\tset_destination(current_position);\n\t// set the default yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 13.080511676035172}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t", "CodeBleu_score": 2.656653974022399}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set vertical max speeds and acceleration\n\t// set vertical max speeds and acceleration\n\tsub.guided_vel_max_speed = 1.0f;\n\tsub.guided_vel_max_accel = 1.0f;\n\n\t// set horizontal max speeds and acceleration\n\t// set horizontal max speeds and acceleration\n\tsub.guided_vel_x_max_speed = 1.0f;\n\tsub.guided_vel_x_max_accel = 1.0f;\n\n\t// set vertical velocity controller\n\t// set vertical velocity controller\n\tsub.guided_vel_z_vel_controller.set_max_velocity(sub.guided_vel_max_speed);\n\tsub.guided_vel_z_vel_controller.set_max_acceleration(sub.guided_vel_max_accel);\n\n\t// set horizontal velocity controller\n\t// set horizontal velocity controller\n\tsub.guided_vel_x_vel_controller.set_max_velocity(sub.guided_vel_x_max_speed);\n\tsub.guided_vel_x_vel_controller.set_max_acceleration(sub.guided_vel_x_max_accel);\n\n\t// set yaw control mode\n\t// set yaw control mode\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 27.146066860624114}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t", "CodeBleu_score": 2.0063663692733846}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set guided mode\n\tset_guided_mode(GUIDED_VEL_CONTROL);\n\n\t// set vertical max speed and acceleration\n\tif (sub.max_speed_z_vel_cms > 0) {\n\t\tsub.vertical_max_speed_cms = sub.max_speed_z_vel_cms;\n\t} else {\n\t\tsub.vertical_max_speed_cms = 0;\n\t}\n\tif (sub.max_accel_z_vel_cms > 0) {\n\t\tsub.vertical_max_accel_cms = sub.max_accel_z_vel_cms;\n\t} else {\n\t\tsub.vertical_max_accel_cms = 0;\n\t}\n\n\t// set horizontal max speed and acceleration\n\tif (sub.max_speed_xy_vel_cms > 0) {\n\t\tsub.horizontal_max_speed_cms = sub.max_speed_xy_vel_cms;\n\t} else {\n\t\tsub.horizontal_max_speed_cms = 0;\n\t}\n\tif (sub.max_accel_xy_vel_cms > 0) {\n\t\tsub.horizontal_max_accel_cms = sub.max_accel_xy_vel_cms;\n\t} else {\n\t\tsub.horizontal_max_accel_cms = 0;\n\t}\n\n\t// set vertical velocity controller\n\tsub.vertical_vel_controller.set_limits(sub.vertical_max_speed_cms, sub.vertical_max_accel_cms);\n\tsub.vertical_vel_controller.set_setpoint(0);\n\n\t// set horizontal velocity controller\n\tsub.horizontal_vel_controller.set_limits(sub.horizontal_max_speed_cms, sub.horizontal_max_accel_cms);\n\tsub.horizontal_vel_controller.set_setpoint(0);\n\n\t// set yaw control mode\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 23.539768423811264}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if timeout has been exceeded\n\tif (guided_timeout_check()) {\n\t\treturn true;\n\t}\n\n\t// Check if altitude is below minimum or above maximum\n\tif (guided_altitude_check()) {\n\t\treturn true;\n\t}\n\n\t// Check if horizontal distance moved exceeds limit\n\tif (guided_horizontal_distance_check()) {\n\t\treturn true;\n\t}\n\n\t// No limit was exceeded\n\treturn false;\n}", "CodeBleu_score": 11.299425478805714}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if timeout has been exceeded\n\tif (millis() - m_last_guided_update > m_guided_timeout) {\n\t\treturn true;\n\t}\n\n\t// Check if altitude is above maximum\n\tif (m_altitude > m_max_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if altitude is below minimum\n\tif (m_altitude < m_min_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if horizontal distance moved exceeds limit\n\tif (m_horizontal_distance > m_horizontal_limit) {\n\t\treturn true;\n\t}\n\n\t// No limit has been exceeded\n\treturn false;\n}", "CodeBleu_score": 17.477116188468393}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check for timeout\n\tif (millis() - _start_time > _timeout) {\n\t\treturn true;\n\t}\n\n\t// Check altitude limits\n\tif (_current_alt < _min_alt || _current_alt > _max_alt) {\n\t\treturn true;\n\t}\n\n\t// Check horizontal distance moved\n\tif (_current_pos.x > _max_pos.x || _current_pos.x < _min_pos.x || _current_pos.y > _max_pos.y || _current_pos.y < _min_pos.y) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 33.07364101235205}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tif (motor_test_timeout_counter == 0) {\n\t\tif (motor_test_timeout_counter == 0) {\n\t\t\tmotor_test_timeout_counter = 2;\n\t\t\tmotor_test_timeout_counter_flag = true;\n\t\t}\n\t\treturn false;\n\t}\n\telse {\n\t\tmotor_test_timeout_counter--;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 27.19446982597659}, {"code": "bool Sub::verify_motor_test(){\n\t", "CodeBleu_score": 3.6872060888959766}, {"code": "bool Sub::verify_motor_test(){\n\t\tif (motor_test_start_time == 0) {\n\t\tmotor_test_start_time = millis();\n\t\treturn false;\n\t}\n\tif (millis() - motor_test_start_time > 2000) {\n\t\tmotor_test_start_time = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 40.07070474308214}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.roll_target;\n\tfloat pitch_target = wp_nav.pitch_target;\n\n\t// constrain roll and pitch targets to a maximum range\n\tif (roll_target > max_roll) {\n\t\troll_target = max_roll;\n\t} else if (roll_target < -max_roll) {\n\t\troll_target = -max_roll;\n\t}\n\tif (pitch_target > max_pitch) {\n\t\tpitch_target = max_pitch;\n\t} else if (pitch_target < -max_pitch) {\n\t\tpitch_target = -max_pitch;\n\t}\n\n\t// normalize roll and pitch targets\n\troll_target = (roll_target + max_roll) / (2 * max_roll);\n\tpitch_target = (pitch_target + max_pitch) / (2 * max_pitch);\n\n\t// assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 37.86025714214507}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t", "CodeBleu_score": 3.4981965412920477}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = wp_nav.roll_target;\n\tfloat pitch_target = wp_nav.pitch_target;\n\n\t// constrain roll and pitch targets within the specified angle range\n\tif (roll_target > roll_max) {\n\t\troll_target = roll_max;\n\t} else if (roll_target < roll_min) {\n\t\troll_target = roll_min;\n\t}\n\tif (pitch_target > pitch_max) {\n\t\tpitch_target = pitch_max;\n\t} else if (pitch_target < pitch_min) {\n\t\tpitch_target = pitch_min;\n\t}\n\n\t// normalize roll and pitch targets\n\troll_target = (roll_target - roll_min) / (roll_max - roll_min);\n\tpitch_target = (pitch_target - pitch_min) / (pitch_max - pitch_min);\n\n\t// assign normalized values to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 36.02206887199807}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t", "CodeBleu_score": 2.5263458681211657}, {"code": "void Sub::read_barometer(){\n\t\t// Read barometer\n\tbarometer_status = barometer.read();\n\n\t// If barometer is healthy, update the calibration\n\tif (barometer_status == Barometer::OK) {\n\t\tbarometer.get_calibration(barometer_calibration);\n\t}\n\n\t// If barometer is healthy and the altitude is above zero, update the sensor health status\n\tif (barometer_status == Barometer::OK && barometer_calibration.altitude > 0) {\n\t\tsensor_health_status = barometer_calibration.altitude;\n\t}\n}", "CodeBleu_score": 44.31065074521054}, {"code": "void Sub::read_barometer(){\n\t\t//read barometer\n\tif (barometer_present) {\n\t\tbarometer_data.read(barometer_data_buffer);\n\t\tbarometer_data.get_temperature(barometer_temperature);\n\t\tbarometer_data.get_pressure(barometer_pressure);\n\t\tbarometer_data.get_altitude(barometer_altitude);\n\t\tbarometer_data.get_pressure_temperature(barometer_pressure_temperature);\n\t\tbarometer_data.get_pressure_altitude(barometer_pressure_altitude);\n\n\t\t//update barometer calibration\n\t\tif (barometer_altitude > 0) {\n\t\t\tbarometer_calibration.update(barometer_altitude);\n\t\t}\n\n\t\t//update sensor health\n\t\tif (depth_sensor_present) {\n\t\t\tif (barometer_data.get_sensor_health() == 0) {\n\t\t\t\tdepth_sensor_health = false;\n\t\t\t} else {\n\t\t\t\tdepth_sensor_health = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 48.36678099014787}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\tbool ekf_position_ok = false;\n\tif (inertial_navigation_enabled) {\n\t\tif (vehicle_status.arming_state == vehicle_status_s::ARMING_STATE_ARMED) {\n\t\t\tif (vehicle_status.system_status!= vehicle_status_s::SYSTEM_STATUS_EMERGENCY) {\n\t\t\t\tekf_position_ok = true;\n\t\t\t}\n\t\t} else {\n\t\t\tekf_position_ok = true;\n\t\t}\n\t} else {\n\t\tekf_position_ok = true;\n\t}\n\treturn ekf_position_ok;\n}", "CodeBleu_score": 38.52063998866369}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// Check if we have inertial navigation\n\tif (!inav_ok()) {\n\t\treturn false;\n\t}\n\n\t// Check if we have armed motors\n\tif (!motors_armed()) {\n\t\treturn false;\n\t}\n\n\t// Check if we have a good absolute position\n\tif (!absolute_position_ok()) {\n\t\treturn false;\n\t}\n\n\t// Check if we are not in constant position mode\n\tif (ekf_control_mode == EkfControlMode::EKF_POS_MODE) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 14.323196238947839}, {"code": "bool Sub::ekf_position_ok(){\n\t\tbool ok = false;\n\n\t// Inertial navigation is not available\n\tif (inav_ok == false) {\n\t\treturn false;\n\t}\n\n\t// Motors disarmed\n\tif (motors_armed == false) {\n\t\treturn true;\n\t}\n\n\t// Absolute position available\n\tif (ekf_ok == true) {\n\t\tok = true;\n\t}\n\n\treturn ok;\n}", "CodeBleu_score": 24.958195443870217}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// check if we are armed and the rover is ready\n\tif (!is_armed() ||!is_ready()) {\n\t\treturn false;\n\t}\n\n\t// check if we have a valid position\n\tif (!get_position_valid()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::panic(\"No valid position\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if the EKF failsafe is active\n\tif (get_ekf_failsafe()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::panic(\"EKF failsafe active\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if the AHRS system is ready\n\tif (!ahrs->is_ready()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::panic(\"AHRS not ready\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 30.185754243698383}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// call parent class check\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if the AHRS system is ready\n\tif (!ahrs->is_ready()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::console->printf_P(PSTR(\"AHRS not ready\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if the EKF failsafe is active\n\tif (ekf->is_failsafe()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::console->printf_P(PSTR(\"EKF failsafe active\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if the position estimate is valid\n\tif (!ekf->is_position_valid()) {\n\t\tif (display_failure) {\n\t\t\tAP_HAL::console->printf_P(PSTR(\"EKF position estimate invalid\n\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 44.619492695456074}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// check if we have a valid GPS lock\n\tif (!AP_GPS::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if the AHRS system is ready\n\tif (!AP_AHRS::ahrs_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if the EKF failsafe is active\n\tif (!AP_EKF::ekf_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if the position estimate is valid\n\tif (!AP_Rover_Position::position_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 24.540896279949408}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tbool result = false;\n\n\tif (do_arming_checks) {\n\t\t// check if we are already armed\n\t\tif (is_armed()) {\n\t\t\t// already armed\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in manual mode\n\t\tif (is_manual()) {\n\t\t\t// in manual mode\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if we are in a safe mode\n\t\tif (is_safe()) {\n\t\t\t// in safe mode\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// arm the vehicle\n\tswitch (method) {\n\tcase AP_Arming::METHOD_STAY_ARMED:\n\t\tresult = arm_stay_armed();\n\t\tbreak;\n\tcase AP_Arming::METHOD_AUTO_ARMED:\n\t\tresult = arm_auto_armed();\n\t\tbreak;\n\tcase AP_Arming::METHOD_AUTO_DISARMED:\n\t\tresult = arm_auto_disarmed();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t// if we are armed, set the home location\n\tif (result) {\n\t\tif (is_sail_vehicle()) {\n\t\t\t// set the sail vehicle home heading\n\t\t\tset_sail_home_heading();\n\t\t} else {\n\t\t\t// set the simple mode heading\n\t\t\tset_simple_home_heading();\n\t\t}\n\n\t\t// update the soft armed status\n\t\tupdate_soft_armed();\n\n\t\t// send the arm/disarm status text\n\t\tsend_arm_disarm_status_text();\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 34.05730582182397}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t#if HAL_LOGGING_ENABLED\n    AP::logger().set_arming_method(method);\n#endif\n\n    if (do_arming_checks) {\n        // if we're already armed, don't do anything\n        if (is_armed()) {\n            return true;\n        }\n\n        // check for safety switch\n        if (hal.util->safety_switch_state()!= AP_HAL::Util::SAFETY_ARMED) {\n            // safety switch is not armed, so we can't arm\n            hal.util->set_armed(false);\n            return false;\n        }\n\n        // check for arming override\n        if (hal.util->armed_override()) {\n            // arming override is on, so we can't arm\n            hal.util->set_armed(false);\n            return false;\n        }\n    }\n\n    // arm the rover\n    hal.util->set_armed(true);\n\n    // set the home location to the current location\n    hal.util->set_home_location(hal.util->home_location());\n\n    // set the simple mode heading to the current heading\n    simple_mode_heading = hal.util->heading();\n\n    // record the home heading for sail vehicles\n    if (is_sail()) {\n        home_heading = hal.util->heading();\n    }\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    hal.util->send_text(AP_HAL::Util::TEXT_STATUS, \"Arming\");\n\n    // return true\n    return true;\n}", "CodeBleu_score": 40.828600252137726}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (status_message.charging_allowed) {\n\t\tif (checkShouldCharge()) {\n\t\t\tif (!chargingEnabled) {\n\t\t\t\tchargingEnabled = true;\n\t\t\t\tchargingStartTime = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (chargingEnabled) {\n\t\t\t\tchargingEnabled = false;\n\t\t\t\tchargingStartTime = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (chargingEnabled) {\n\t\t\tchargingEnabled = false;\n\t\t\tchargingStartTime = 0;\n\t\t}\n\t\tif (millis() - chargingStartTime > 10000) {\n\t\t\tif (checkShouldCharge()) {\n\t\t\t\tchargingEnabled = true;\n\t\t\t\tchargingStartTime = millis();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.30507218628541}, {"code": "void updateChargingEnabled(){\n\t#ifdef DEBUG_CHARGE_ENABLED\n    Serial.println(\"updateChargingEnabled\");\n#endif\n    if (status_message.charging_allowed) {\n        if (checkShouldCharge()) {\n            if (!charging_enabled) {\n                charging_enabled = true;\n                last_charging_enabled = millis();\n            }\n        } else {\n            if (charging_enabled) {\n                charging_enabled = false;\n            }\n        }\n    } else {\n        if (charging_enabled) {\n            charging_enabled = false;\n        }\n        if (millis() - last_charging_enabled > 5000) {\n            if (checkShouldCharge()) {\n                if (!charging_enabled) {\n                    charging_enabled = true;\n                    last_charging_enabled = millis();\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 48.336441039244605}, {"code": "void updateChargingEnabled(){\n\t#ifdef DEBUG\n    Serial.println(\"updateChargingEnabled\");\n#endif\n\n    // If charging is not allowed, check if we should enable charging\n    if (!status_message.charging_allowed) {\n        // If we should charge, enable charging\n        if (checkShouldCharge()) {\n            status_message.charging_enabled = true;\n            status_message.charging_enabled_timestamp = millis();\n        } else {\n            // If we should not charge, disable charging\n            status_message.charging_enabled = false;\n            status_message.charging_disabled_timestamp = millis();\n        }\n    } else {\n        // If charging is allowed, check if we should disable charging\n        if (checkShouldCharge()) {\n            // If we should charge, disable charging\n            status_message.charging_enabled = false;\n            status_message.charging_disabled_timestamp = millis();\n        } else {\n            // If we should not charge, check if we should enable charging\n            if (!status_message.charging_enabled) {\n                // If we should not charge and not currently enabling, check if we should enable charging\n                if (status_message.charging_enabled_timestamp + CHARGING_ENABLED_TIMEOUT < millis()) {\n                    status_message.charging_enabled = true;\n                    status_message.charging_enabled_timestamp = millis();\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 37.58869568990041}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::master::check() && size >= 4) {\n\t\tuint8_t crc = 0;\n\t\tuint8_t *messagePtr = (uint8_t *) message;\n\t\tuint8_t *crcPtr = messagePtr + size - 1;\n\n\t\tfor (uint8_t i = 0; i < size - 1; i++) {\n\t\t\tcrc += *messagePtr;\n\t\t\tmessagePtr++;\n\t\t}\n\n\t\t*crcPtr = crc;\n\t\tpacketSerial.send(message, size);\n\t}\n}", "CodeBleu_score": 46.735020412293984}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::ok()) {\n\t\tif (size >= 4) {\n\t\t\tunsigned char crc = 0;\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tcrc ^= ((unsigned char *) message)[i];\n\t\t\t}\n\t\t\t((unsigned char *) message)[size] = crc;\n\t\t\tsize++;\n\t\t\tpacketSerial.send(message, size);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.924289593030714}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::isStarted()) {\n\t\tif (size >= 4) {\n\t\t\tuint8_t crc = crc8((uint8_t*) message, size);\n\t\t\tuint8_t *msg = (uint8_t*) malloc(size + 1);\n\t\t\tmemcpy(msg, message, size);\n\t\t\tmsg[size] = crc;\n\t\t\tpacketSerial.send(msg, size + 1);\n\t\t\tfree(msg);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.55223038361457}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t\t// Initialize the serial communication with the sound module\n\tSerial.begin(9600);\n\tSerial.flush();\n\n\t// Clear any existing data in the buffer\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\n\t// Initialize the sound module\n\tsendCommand(CMD_PLAY_FOLDER_FILE, 0, 0);\n\tdelay(1000);\n\n\t// Get the number of sound files available on the SD card\n\tint numFiles = getNumberOfFiles();\n\n\t// Return true if there are one or more sound files available, indicating successful initialization\n\treturn numFiles > 0;\n}", "CodeBleu_score": 46.65582683839169}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t\tSerial.begin(9600);\n\tSerial.println(\"Initializing SD card...\");\n\tif (!SD.begin(SD_CHIP_SELECT)) {\n\t\tSerial.println(\"Card failed, or not present\");\n\t\treturn false;\n\t}\n\tSerial.println(\"Card initialized.\");\n\tSerial.println(\"Initializing MP3 module...\");\n\tmp3_set_serial(Serial);\n\tif (!mp3_reset()) {\n\t\tSerial.println(\"Unable to reset MP3 module\");\n\t\treturn false;\n\t}\n\tSerial.println(\"MP3 module initialized.\");\n\tSerial.println(\"Retrieving number of sound files...\");\n\tuint16_t num_files = mp3_get_num_files();\n\tSerial.print(\"Number of sound files: \");\n\tSerial.println(num_files);\n\tif (num_files == 0) {\n\t\tSerial.println(\"No sound files found on SD card\");\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 40.52577469935198}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tif (mp3.isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\tif (activeSounds.empty()) {\n\t\treturn 0;\n\t}\n\tSound *sound = activeSounds.back();\n\tactiveSounds.pop_back();\n\tsound->play();\n\treturn activeSounds.size();\n}", "CodeBleu_score": 39.871956349839245}, {"code": "int MP3Sound::processSounds(){\n\t\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t} else if (playingMP3 == true) {\n\t\treturn activeSounds.size();\n\t} else {\n\t\t// Get the last active sound and play it\n\t\tSound *s = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\ts->play();\n\t\tplayingMP3 = true;\n\t\treturn activeSounds.size();\n\t}\n}", "CodeBleu_score": 43.22567851736022}, {"code": "int MP3Sound::processSounds(){\n\t\tif (mp3->isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\tif (activeSounds.size() > 0) {\n\t\tSound *sound = activeSounds.front();\n\t\tactiveSounds.pop_front();\n\t\tsound->play();\n\t\treturn activeSounds.size();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 38.75483066359559}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    WbMemoryMappedFile *mmf = reinterpret_cast<WbMemoryMappedFile *>(r->data);\n    if (mmf) {\n      if (d->memory_mapped_file)\n        wb_memory_mapped_file_delete(d->memory_mapped_file);\n      d->memory_mapped_file = wb_memory_mapped_file_new(mmf->name.c_str(), mmf->size);\n      if (d->memory_mapped_file)\n        return true;\n    }\n  }\n#endif  // _WIN32\n  return false;\n}", "CodeBleu_score": 31.40126194361556}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *)d;\n\n\tswitch (command) {\n\t\tcase C_CAMERA_MEMORY_MAPPED_FILE:\n\t\t\tif (ac->memory_mapped_file)\n\t\t\t\twb_memory_mapped_file_delete(ac->memory_mapped_file);\n\t\t\tac->memory_mapped_file = wb_memory_mapped_file_new(r);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}", "CodeBleu_score": 42.75471828292664}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef _WIN32\n  WbCamera *camera = static_cast<WbCamera *>(d);\n#else\n  WbCamera *camera = reinterpret_cast<WbCamera *>(d);\n#endif\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    WbMemoryMappedFile *memory_mapped_file = camera->memoryMappedFile();\n    if (memory_mapped_file)\n      memory_mapped_file->cleanup();\n\n    WbMemoryMappedFileRequest *request = static_cast<WbMemoryMappedFileRequest *>(r);\n    if (request->has_file_name()) {\n      WbMemoryMappedFile *memory_mapped_file = new WbMemoryMappedFile(request->file_name(), request->file_size());\n      camera->setMemoryMappedFile(memory_mapped_file);\n    } else {\n      camera->setMemoryMappedFile(NULL);\n    }\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 26.911409132834468}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tWbAbstractCamera *c = (WbAbstractCamera *)d;\n\tint height = -1;\n\tif (c->data) {\n\t\tWbMutexLocker locker(&c->data->mutex);\n\t\theight = c->data->height;\n\t}\n\treturn height;\n}", "CodeBleu_score": 42.282908930146945}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tWbAbstractCamera *camera = (WbAbstractCamera *)d->data;\n\tint height;\n\n\tif (camera->height!= -1)\n\t\treturn camera->height;\n\n\tif (pthread_mutex_lock(&camera->mutex)!= 0)\n\t\treturn -1;\n\theight = camera->height;\n\tif (pthread_mutex_unlock(&camera->mutex)!= 0)\n\t\treturn -1;\n\treturn height;\n}", "CodeBleu_score": 39.18680884501596}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tif (d->camera_data) {\n\t\tWbMutexLocker locker(&d->mutex);\n\t\treturn d->camera_data->height;\n\t}\n\treturn -1;\n}", "CodeBleu_score": 10.250459966784376}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tif (tag == WB_NODE_TAG_INVALID) {\n\t\tprintf(\"Error: wb_accelerometer_get_sampling_period: invalid device tag\n\");\n\t\treturn -1;\n\t}\n\tpthread_mutex_lock(&mutex);\n\tstruct wb_accelerometer *accelerometer = get_accelerometer(tag);\n\tif (accelerometer!= NULL) {\n\t\tsampling_period = accelerometer->sampling_period;\n\t} else {\n\t\tprintf(\"Error: wb_accelerometer_get_sampling_period: device tag does not exist\n\");\n\t\tsampling_period = -1;\n\t}\n\tpthread_mutex_unlock(&mutex);\n\treturn sampling_period;\n}", "CodeBleu_score": 45.74065958575637}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period = 0;\n\tWbMutexLocker locker(mutex);\n\tif (tag < 0 || tag >= MAX_ACCELEROMETERS) {\n\t\tprintf(\"Error: Accelerator tag is invalid.\n\");\n\t} else {\n\t\tif (accelerometers[tag]!= NULL) {\n\t\t\tsampling_period = accelerometers[tag]->sampling_period;\n\t\t} else {\n\t\t\tprintf(\"Error: Accelerator tag is invalid.\n\");\n\t\t}\n\t}\n\treturn sampling_period;\n}", "CodeBleu_score": 47.118613202870385}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint period;\n\tWbMutexLocker locker(wb_accelerometer_mutex);\n\tWbAccelerometerStruct* accelerometer = wb_accelerometer_get_structure(tag);\n\tif (accelerometer)\n\t\tperiod = accelerometer->sampling_period;\n\telse\n\t\twb_error(wb_accelerometer_error_message(tag, WB_ACCELEROMETER_INVALID_TAG));\n\tlocker.unlock();\n\treturn period;\n}", "CodeBleu_score": 35.12959875903374}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result(dmsString);\n\tfree(dmsString);\n\treturn result;\n}", "CodeBleu_score": 40.65260581687794}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString = dms;\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 42.81118257012261}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar* dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms(dmsString);\n\tfree(dmsString);\n\treturn dms;\n}", "CodeBleu_score": 40.04028656387365}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdIASSERT (o1->type == dBoxClass);\n\tdIASSERT (o2->type == dCapsuleClass);\n\n\tdIASSERT (immersion!= NULL);\n\tdIASSERT (immersion->capsuleGeom == NULL);\n\tdIASSERT (immersion->boxGeom == NULL);\n\tdIASSERT (immersion->capsuleGeom!= immersion->boxGeom);\n\n\tdxBox *box = (dxBox *)o1;\n\tdxCapsule *capsule = (dxCapsule *)o2;\n\n\tdIASSERT (box->body!= NULL);\n\tdIASSERT (capsule->body!= NULL);\n\n\tsCapsuleImmersionData data(box, capsule, immersion, flags);\n\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 41.51680240534942}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 4.191970305576363}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (o1->type == dCapsuleClass);\n\tdIASSERT (o2->type == dTrimeshClass);\n\n\tdUASSERT (immersion, \"immersion geometry must be non-NULL\");\n\tdUASSERT (immersion->capsule, \"immersion geometry must be a capsule\");\n\tdUASSERT (immersion->capsule->body, \"immersion geometry capsule must be a body\");\n\tdUASSERT (immersion->trimesh, \"immersion geometry must be a trimesh\");\n\tdUASSERT (immersion->trimesh->body, \"immersion geometry trimesh must be a body\");\n\n\tdCapsuleImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 28.75636110849511}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdUASSERT(o1->type == dCapsuleClass, \"First geom is not a capsule\");\n\tdUASSERT(o2->type == dTrimeshClass, \"Second geom is not a trimesh\");\n\tdUASSERT(immersion, \"No immersion data provided\");\n\n\tdxCapsule *capsule = (dxCapsule*)o1;\n\tdxTrimesh *trimesh = (dxTrimesh*)o2;\n\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdIASSERT(capsule->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\tdIASSERT(trimesh->body, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsCapsuleImmersionData data(capsule, trimesh, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 40.46185487140137}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// Get the sleep duration from the input\n\tconst auto sleep_duration = getParameter<double>(\"sleep_duration\");\n\n\t// Check if the sleep duration is missing or non-positive\n\tif (sleep_duration <= 0.0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\n\t// Start a timer\n\ttimer_ = std::make_unique<Timer>(sleep_duration);\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_->setCallback([this]() {\n\t\temitWakeUp();\n\t});\n\n\t// Start the timer\n\ttimer_->start();\n\n\t// Set the timer_waiting_ flag to true\n\ttimer_waiting_ = true;\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 41.438855771863246}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Check if the duration is missing or non-positive\n\tif (sleep_duration_ms_ < 0) {\n\t\treturn SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING\n\tsetStatus(RUNNING);\n\n\t// Start a timer with the specified duration\n\ttimer_ = std::make_unique<Timer>(sleep_duration_ms_);\n\ttimer_->start();\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_->setCallback([this] {\n\t\temitWakeUpSignal();\n\t});\n\n\t// Reset the timer_waiting_ flag if the timer is aborted\n\ttimer_->setAbortCallback([this] {\n\t\ttimer_waiting_ = false;\n\t});\n\n\treturn SUCCESS;\n}", "CodeBleu_score": 29.81254405936197}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (!this->duration_ms_ || *duration_ms_ <= 0) {\n\t\treturn SUCCESS;\n\t}\n\n\tthis->setStatus(RUNNING);\n\tthis->timer_ = this->getScheduler()->createTimer(this->duration_ms_);\n\tthis->timer_waiting_ = false;\n\tthis->timer_->setCallback(std::bind(&SleepNode::onWakeUp, this));\n\tthis->timer_->start();\n\n\treturn SUCCESS;\n}", "CodeBleu_score": 20.40517099628433}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Get the entry from the blackboard\n\tstd::shared_ptr<Entry> entry = blackboard->getEntry(entryName);\n\n\t// If the entry is not found, return failure\n\tif (entry == nullptr) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the entry\n\tentry->lock();\n\n\t// Get the current sequence ID\n\tuint64_t currentSequenceID = entry->getSequenceID();\n\n\t// If the sequence ID has changed, update the stored sequence ID and return success\n\tif (currentSequenceID!= sequenceID) {\n\t\tsequenceID = currentSequenceID;\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// If the sequence ID has not changed, return failure\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 43.44831203324758}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (blackboard->getEntry(entryName, entry)) {\n\t\tif (entry->getSequenceID()!= sequenceID) {\n\t\t\tsequenceID = entry->getSequenceID();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 24.29684308687155}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Get the entry from the blackboard\n\tstd::string entryName = getParameter(\"entry\");\n\tstd::string entry = getBlackboard()->get<std::string>(entryName);\n\n\t// Lock the mutex\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Get the stored sequence ID\n\tstd::string storedSequenceID = getBlackboard()->get<std::string>(sequenceIDName);\n\n\t// Get the current sequence ID\n\tstd::string currentSequenceID = entry;\n\n\t// Check if the entry has been updated\n\tif (storedSequenceID!= currentSequenceID) {\n\t\t// Update the stored sequence ID\n\t\tgetBlackboard()->set<std::string>(sequenceIDName, currentSequenceID);\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\telse {\n\t\treturn NodeStatus::FAILURE;\n\t}\n}", "CodeBleu_score": 44.23281309967372}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (successThreshold_ < 0) {\n\t\treturn (size_t) (successThreshold_ + (double) childNodes_.size());\n\t} else {\n\t\treturn (size_t) successThreshold_;\n\t}\n}", "CodeBleu_score": 54.67877951799428}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (successThreshold_ < 0) {\n\t\treturn static_cast<size_t>(-successThreshold_ / static_cast<double>(children_.size()));\n\t}\n\treturn static_cast<size_t>(successThreshold_);\n}", "CodeBleu_score": 52.756948305878694}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (successThreshold_ < 0) {\n\t\treturn (size_t) (successThreshold_ * (double) children.size());\n\t} else {\n\t\treturn (size_t) successThreshold_;\n\t}\n}", "CodeBleu_score": 54.03091945962765}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\t// wait for 10 ms\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\t// check if the server is still alive\n\t\tif (isServerAlive()) {\n\t\t\t// heartbeat is still active\n\t\t\tif (!_p->is_heartbeat_active) {\n\t\t\t\t// heartbeat is not active, so enable all breakpoints\n\t\t\t\tenableAllHooks(true);\n\t\t\t\t_p->is_heartbeat_active = true;\n\t\t\t}\n\t\t} else {\n\t\t\t// heartbeat is not active\n\t\t\tif (_p->is_heartbeat_active) {\n\t\t\t\t// heartbeat is active, so disable all breakpoints\n\t\t\t\tenableAllHooks(false);\n\t\t\t\t_p->is_heartbeat_active = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 33.61129647664471}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true)\n\t{\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n\t\tif(_p->heartbeat_last_time!= 0)\n\t\t{\n\t\t\tif(std::chrono::duration_cast<std::chrono::seconds>(_p->heartbeat_last_time.time_since_epoch()).count() < _p->heartbeat_timeout)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tenableAllHooks(false);\n\t\t_p->heartbeat_last_time = std::chrono::steady_clock::now();\n\t}\n}", "CodeBleu_score": 32.60146635412495}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile(true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif(_p->heartbeat_status!= _p->last_heartbeat_status) {\n\t\t\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\t\t\tfor(auto& [node_uid, hook] : _p->pre_hooks) {\n\t\t\t\tstd::unique_lock<std::mutex> lk(hook->mutex);\n\t\t\t\tif(hook->mode == Monitor::Hook::Mode::BREAKPOINT) {\n\t\t\t\t\tif(_p->heartbeat_status) {\n\t\t\t\t\t\thook->enabled = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thook->enabled = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t_p->last_heartbeat_status = _p->heartbeat_status;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.22683167285825}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t", "CodeBleu_score": 5.780157160879095}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> msg;\n\tstd::vector<std::string> bb_names;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\tfor (auto& bb_name : bb_names) {\n\t\tstd::string bb_name_trimmed = bb_name.substr(0, bb_name.length() - 1);\n\t\tif (blackboard_manager.getBlackboard(bb_name_trimmed)) {\n\t\t\tstd::unique_ptr<Blackboard> bb = blackboard_manager.getBlackboard(bb_name_trimmed);\n\t\t\tbb->lock();\n\t\t\tstd::string bb_json = bb->exportAsJSON();\n\t\t\tmsg.insert(msg.end(), bb_json.begin(), bb_json.end());\n\t\t\tbb->unlock();\n\t\t}\n\t}\n\treturn msg;\n}", "CodeBleu_score": 44.667079488058}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> output;\n\tstd::vector<std::string> blackboards = split(bb_list, ',');\n\n\tfor (std::string& bb : blackboards) {\n\t\tstd::string bb_name = bb;\n\t\tif (bb_name.find_first_of(\" \")!= std::string::npos) {\n\t\t\tbb_name = bb_name.substr(0, bb_name.find_first_of(\" \"));\n\t\t}\n\n\t\tif (blackboards_map.find(bb_name) == blackboards_map.end()) {\n\t\t\tstd::cout << \"Blackboard '\" << bb_name << \"' does not exist.\" << std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstd::shared_ptr<Blackboard> bb_ptr = blackboards_map[bb_name];\n\t\tstd::shared_ptr<Blackboard> subtree = bb_ptr->getSubtree();\n\n\t\tif (subtree == nullptr) {\n\t\t\tstd::cout << \"Blackboard '\" << bb_name << \"' is not valid.\" << std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!subtree->lock()) {\n\t\t\tstd::cout << \"Blackboard '\" << bb_name << \"' is locked.\" << std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstd::string json_str = subtree->exportJSON();\n\t\tstd::vector<uint8_t> json_vec = MessagePack::pack(json_str);\n\t\toutput.insert(output.end(), json_vec.begin(), json_vec.end());\n\n\t\tsubtree->unlock();\n\t}\n\n\treturn output;\n}", "CodeBleu_score": 38.819736279137}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tifdef DEBUG_GROOT2_PUBLISHER\n  std::cout << \"Groot2Publisher::unlockBreakpoint(\" << node_uid << \") called\" << std::endl;\n#endif\n  auto hooks = pos == Position::PRE? &_p->pre_hooks : &_p->post_hooks;\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto bk_it = hooks->find(node_uid);\n  if(bk_it == hooks->end())\n  {\n    return false;\n  }\n  auto hook = bk_it->second;\n  if(hook->status == Hook::Status::BREAKPOINT)\n  {\n    hook->status = Hook::Status::READY;\n    hook->result = result;\n    hook->remove = remove;\n    hook->ready.notify_all();\n  }\n  return true;\n}", "CodeBleu_score": 55.63815861485863}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tifdef DEBUG\n  std::cout << \"Groot2Publisher::unlockBreakpoint: \" << std::endl;\n#endif\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto hooks = pos == Position::PRE? &_p->pre_hooks : &_p->post_hooks;\n  auto bk_it = hooks->find(node_uid);\n  if(bk_it == hooks->end())\n  {\n    return false;\n  }\n  auto hook = bk_it->second;\n  if(hook->status!= Hook::Status::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = Hook::Status::READY;\n  hook->result = result;\n  hook->remove = remove;\n  hook->ready_cv.notify_all();\n  return true;\n}", "CodeBleu_score": 55.62648782759943}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hooks = pos == Position::PRE? &_p->pre_hooks : &_p->post_hooks;\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto bk_it = hooks->find(node_uid);\n\tif(bk_it == hooks->end())\n\t{\n\t\treturn false;\n\t}\n\tauto hook = bk_it->second;\n\tif(hook->getMode()!= Monitor::Hook::Mode::BREAKPOINT)\n\t{\n\t\treturn false;\n\t}\n\thook->setResult(result);\n\thook->setRemove(remove);\n\thook->setReady(true);\n\thook->notifyAll();\n\treturn true;\n}", "CodeBleu_score": 49.80264429432965}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tif(status() == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\thalt_requested_.store(false);\n\t\tstd::thread(std::bind(&ThreadedAction::tick_functor_, this)).detach();\n\t\treturn NodeStatus::RUNNING;\n\t}\n\ttry {\n\t\tNodeStatus status = tick_functor_(*this);\n\t\tif(status!= NodeStatus::IDLE) {\n\t\t\tsetStatus(status);\n\t\t}\n\t\treturn status;\n\t} catch(std::exception& e) {\n\t\tsetStatus(NodeStatus::IDLE);\n\t\tthrow;\n\t}\n}", "CodeBleu_score": 33.34115235494648}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t\thalt_requested_.store(false);\n\t\tasync_thread_ = std::thread(&ThreadedAction::tick_functor_, this);\n\t}\n\n\tNodeStatus status = NodeStatus::IDLE;\n\ttry {\n\t\tif (async_thread_.joinable()) {\n\t\t\tasync_thread_.join();\n\t\t}\n\t\tif (!halt_requested_.load()) {\n\t\t\tstatus = tick_functor_(*this);\n\t\t} else {\n\t\t\tsetStatus(NodeStatus::HALTED);\n\t\t}\n\t} catch (const std::exception& e) {\n\t\tsetStatus(NodeStatus::IDLE);\n\t\tstd::string msg = \"Exception caught in executeTick(): \" + std::string(e.what());\n\t\tROS_ERROR_STREAM(msg);\n\t\tif (stored_exception_) {\n\t\t\tthrow *stored_exception_;\n\t\t}\n\t}\n\tif (stored_exception_) {\n\t\tthrow *stored_exception_;\n\t}\n\treturn status;\n}", "CodeBleu_score": 41.78247241174502}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t}\n\ttry {\n\t\tNodeStatus status = tick_functor_(*this);\n\t\tif (status!= prev_status) {\n\t\t\tsetStatus(status);\n\t\t}\n\t\tif (!isHaltRequested()) {\n\t\t\treturn status;\n\t\t}\n\t\treturn NodeStatus::IDLE;\n\t} catch (std::exception& e) {\n\t\tstd::cerr << \"Exception in executeTick: \" << e.what() << std::endl;\n\t\tsetStatus(NodeStatus::IDLE);\n\t\treturn NodeStatus::IDLE;\n\t}\n}", "CodeBleu_score": 37.87903145304416}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// Define a lambda function to handle the printing\n\tauto printNode = [&](const TreeNode* node, int depth) {\n\t\t// Print separator lines\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"    \";\n\t\t}\n\t\tstream << \"+--\";\n\t\t// Print the node name\n\t\tstream << node->getName();\n\t\tstream << std::endl;\n\t\t// Recursively print the children of ControlNode or the child of DecoratorNode\n\t\tif (node->isControlNode()) {\n\t\t\tconst ControlNode* control_node = dynamic_cast<const ControlNode*>(node);\n\t\t\tfor (const auto& child : control_node->getChildren()) {\n\t\t\t\tprintNode(child.get(), depth + 1);\n\t\t\t}\n\t\t} else {\n\t\t\tconst DecoratorNode* decorator_node = dynamic_cast<const DecoratorNode*>(node);\n\t\t\tprintNode(decorator_node->getChild().get(), depth + 1);\n\t\t}\n\t};\n\t// Print the tree structure starting from the root_node\n\tstream << \"Tree Structure:\" << std::endl;\n\tprintNode(root_node, 0);\n\tstream << std::endl;\n}", "CodeBleu_score": 51.19616686883024}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\tstream << \"----------------------------------------\" << std::endl;\n\tstream << \"Tree structure:\" << std::endl;\n\tstream << \"----------------------------------------\" << std::endl;\n\tprintTreeRecursively(root_node, 0, stream);\n\tstream << \"----------------------------------------\" << std::endl;\n}", "CodeBleu_score": 21.56807938667718}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\tstd::string separator = \"------------------------------------------------------\n\";\n\tstream << separator;\n\tprintTreeRecursively(root_node, 0, stream);\n\tstream << separator;\n}", "CodeBleu_score": 13.423120053172111}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tapplyRecursiveVisitor(node, visitor);\n}", "CodeBleu_score": 14.991219623511448}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children()) {\n\t\t\tapplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n\t\t}\n\t} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child(), visitor);\n\t}\n}", "CodeBleu_score": 90.54280928346758}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children()) {\n\t\t\tapplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n\t\t}\n\t} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child(), visitor);\n\t}\n}", "CodeBleu_score": 90.54280928346758}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.find(manifest.registration_id_)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"The builder with the registration ID '\" + manifest.registration_id_ +\n\t\t\t\"' is already registered.\");\n\t}\n\tbuilders_.insert(std::make_pair(manifest.registration_id_, builder));\n\tmanifests_.insert(std::make_pair(manifest.registration_id_, manifest));\n}", "CodeBleu_score": 48.04441627547579}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.find(manifest.registrationID)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"NodeBuilder with registration ID '\" + manifest.registrationID +\n\t\t\t\"' is already registered\");\n\t}\n\n\tbuilders_.emplace(manifest.registrationID, builder);\n\tmanifests_.emplace(manifest.registrationID, manifest);\n}", "CodeBleu_score": 46.39652206162217}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.registrationID)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"The registration ID '\" + manifest.registrationID + \"' is already registered.\");\n\t}\n\n\tbuilders.insert(std::make_pair(manifest.registrationID, builder));\n\tmanifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 49.99837922843563}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tifndef NDEBUG\n  if(ID.empty())\n  {\n    throw BehaviorTreeException(\"ID cannot be empty\");\n  }\n#endif\n\n  auto it = _p->builders.find(ID);\n  if(it!= _p->builders.end())\n  {\n    throw BehaviorTreeException(\"ID [\", ID, \"] already registered\");\n  }\n\n  auto manifest = TreeNodeManifest(ID, SimpleActionNode::type_name(), ports);\n  auto builder = [tick_functor](const TreeNodeManifest& manifest, const std::string& name)\n  {\n    return std::make_shared<SimpleActionNode>(name, manifest, tick_functor);\n  };\n\n  _p->builders.insert({ ID, builder });\n  _p->manifests.insert({ ID, manifest });\n}", "CodeBleu_score": 51.67626585669769}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tif defined(BT_ENABLE_PYTHON)\n  throw BehaviorTreeException(\"registerSimpleAction is not supported on Python\");\n#else\n  auto builder = [tick_functor, ports](const TreeNodeManifest& manifest) {\n    return std::make_unique<SimpleActionNode>(manifest.registration_ID, tick_functor,\n                                              std::move(ports));\n  };\n  registerBuilder(TreeNodeManifest(ID, SimpleActionNode::typeInfo()), builder);\n#endif\n}", "CodeBleu_score": 47.626402826328615}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t/  auto manifest = TreeNodeManifest(ID, SimpleActionNode::type, ports);\n  auto manifest = TreeNodeManifest(ID, SimpleActionNode::type, ports);\n  auto builder = [tick_functor](const std::string& ID, const PortsList& ports, const std::string& config)\n  {\n    return std::make_unique<SimpleActionNode>(ID, tick_functor, ports, config);\n  };\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 59.694351129631315}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.GetSubtreeCount());\n\tfor (int i = 0; i < tree.GetSubtreeCount(); i++) {\n\t\tbackups.push_back(Blackboard::Clone(tree.GetSubtree(i)->GetBlackboard()));\n\t}\n\treturn backups;\n}", "CodeBleu_score": 50.804204249211296}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.size());\n\tfor (auto& subtree : tree) {\n\t\tBlackboard::Ptr backup = std::make_shared<Blackboard>();\n\t\tbackup->Clone(subtree->GetBlackboard());\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}", "CodeBleu_score": 51.30419968080224}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.GetSubtreeCount());\n\tfor (const auto& subtree : tree.GetSubtrees()) {\n\t\tauto backup = std::make_shared<Blackboard>();\n\t\tbackup->Clone(subtree->GetBlackboard());\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}", "CodeBleu_score": 50.66816434912437}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\treturn ParseScript(script)(env);\n}", "CodeBleu_score": 23.883290906960614}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\treturn ParseScript(script)(env);\n}", "CodeBleu_score": 23.883290906960614}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto result = ParseScript(script);\n\tif(result.has_value()) {\n\t\treturn result.value()(env);\n\t} else {\n\t\treturn nonstd::make_unexpected(result.error());\n\t}\n}", "CodeBleu_score": 66.10563982895118}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\n\tif (m_loaded) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\n\tm_path = path;\n\n\tm_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n\tif (!m_handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\n\tm_loaded = true;\n}", "CodeBleu_score": 50.1966368265601}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tloaded = true;\n\tthis->path = path;\n}", "CodeBleu_score": 51.787710085920565}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Library is already loaded\");\n\t}\n\tlibrary = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!library) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tloaded = true;\n\tthis->path = path;\n}", "CodeBleu_score": 51.03971932341527}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) return false;\n\tStringView stripped = str.strip();\n\tif (stripped.size() < 3) return false;\n\tif (stripped[0]!= '{' || stripped[stripped.size() - 1]!= '}') return false;\n\tif (stripped_pointer!= nullptr) *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\treturn true;\n}", "CodeBleu_score": 22.247901628279223}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped.front()!= '{') {\n\t\treturn false;\n\t}\n\tif (stripped.back()!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 25.125384940526686}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\n\t// Strip leading and trailing spaces.\n\tStringView stripped = str.strip_leading_and_trailing_spaces();\n\n\t// Check if the stripped string starts with '{' and ends with '}'.\n\tif (stripped.size() < 2 || stripped[0]!= '{' || stripped[stripped.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\n\t// If a stripped_pointer is provided, assign the inner content to it.\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 25.874860969684278}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble cost = 0;\n\tLineIterator line_iterator(costmap_, x0, y0, x1, y1);\n\tfor(int i = 0; i < line_iterator.size(); ++i, line_iterator.next()) {\n\t\tif(pointCost(line_iterator.getX(), line_iterator.getY()) < 0)\n\t\t\treturn pointCost(line_iterator.getX(), line_iterator.getY());\n\t\tcost = std::max(cost, pointCost(line_iterator.getX(), line_iterator.getY()));\n\t}\n\treturn cost;\n}", "CodeBleu_score": 49.95985933497206}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\t//initialize the line cost to 0\n\tdouble lineCost = 0;\n\t//initialize the line iterator\n\tLineIterator it(costmap_, x0, y0, x1, y1);\n\t//iterate through each point on the line\n\tfor(int i = 0; i < it.size(); i++) {\n\t\t//get the point cost\n\t\tdouble pointCost = pointCost(it.getX(), it.getY());\n\t\t//if the point cost is negative, return the point cost immediately\n\t\tif(pointCost < 0)\n\t\t\treturn pointCost;\n\t\t//otherwise, update the line cost if the point cost is higher\n\t\telse if(pointCost > lineCost)\n\t\t\tlineCost = pointCost;\n\t\t//increment the line iterator\n\t\tit.advance();\n\t}\n\t//return the total line cost\n\treturn lineCost;\n}", "CodeBleu_score": 53.46688701258977}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t", "CodeBleu_score": 4.037265882870389}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif(path.empty())\n\t\treturn;\n\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\n\tfor(const auto& pose : path)\n\t\tpath_msg.poses.push_back(pose.pose);\n\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 53.33566816360269}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\treturn;\n\t}\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\tfor (const auto& pose : path) {\n\t\tpath_msg.poses.push_back(pose.pose);\n\t}\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 50.51952175869325}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.size() == 0) {\n\t\tROS_WARN(\"No path to be published\");\n\t\treturn;\n\t}\n\n\t// Create a nav_msgs::Path message\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\n\t// Copy each pose from the input path to the path message\n\tfor (const auto& pose : path) {\n\t\tpath_msg.poses.push_back(pose);\n\t}\n\n\t// Publish the path message using the provided ROS publisher\n\tpub.publish(path_msg);\n}", "CodeBleu_score": 49.46251353017999}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tbool stopped = true;\n\tif (base_odom.twist.twist.angular.z > rot_stopped_velocity)\n\t\tstopped = false;\n\tif (base_odom.twist.twist.angular.z < -rot_stopped_velocity)\n\t\tstopped = false;\n\tif (base_odom.twist.twist.linear.x > trans_stopped_velocity)\n\t\tstopped = false;\n\tif (base_odom.twist.twist.linear.x < -trans_stopped_velocity)\n\t\tstopped = false;\n\treturn stopped;\n}", "CodeBleu_score": 52.579906816833066}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// Check if the robot has stopped\n\tbool is_stopped = true;\n\n\t// Check if the robot has stopped in the x-direction\n\tif (fabs(base_odom.twist.twist.linear.x) > trans_stopped_velocity) {\n\t\tis_stopped = false;\n\t}\n\n\t// Check if the robot has stopped in the y-direction\n\tif (fabs(base_odom.twist.twist.linear.y) > trans_stopped_velocity) {\n\t\tis_stopped = false;\n\t}\n\n\t// Check if the robot has stopped in the z-direction\n\tif (fabs(base_odom.twist.twist.linear.z) > trans_stopped_velocity) {\n\t\tis_stopped = false;\n\t}\n\n\t// Check if the robot has stopped in the rotational direction\n\tif (fabs(base_odom.twist.twist.angular.z) > rot_stopped_velocity) {\n\t\tis_stopped = false;\n\t}\n\n\treturn is_stopped;\n}", "CodeBleu_score": 57.51218180306217}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\t// Check if the robot has stopped\n\tbool stopped = false;\n\n\t// Get the current odometry data\n\tdouble current_rot_velocity = base_odom.twist.twist.angular.z;\n\tdouble current_trans_velocity = base_odom.twist.twist.linear.x;\n\n\t// Check if the robot has stopped\n\tif (fabs(current_rot_velocity) <= rot_stopped_velocity && fabs(current_trans_velocity) <= trans_stopped_velocity) {\n\t\tstopped = true;\n\t}\n\n\treturn stopped;\n}", "CodeBleu_score": 51.28363609423313}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// check if the cell is an obstacle or has no information\n\tif (check_cell->cost == costmap.getCost(check_cell->x, check_cell->y) || check_cell->cost == costmap.getCost(check_cell->x, check_cell->y) + 1) {\n\t\t// set the cell's target distance to the maximum obstacle cost and return false\n\t\tcurrent_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\n\t\treturn false;\n\t}\n\n\t// calculate a new target distance and update the cell's target distance if the new distance is shorter\n\tcurrent_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y) + current_cell->distance;\n\tif (current_cell->target_distance < current_cell->target_distance) {\n\t\tcurrent_cell->target_distance = current_cell->target_distance;\n\t}\n\n\t// return true\n\treturn true;\n}", "CodeBleu_score": 43.62552804503939}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\tif (check_cell->cost == costmap.getCost(check_cell->x, check_cell->y)) {\n\t\treturn false;\n\t} else {\n\t\tdouble new_cost = costmap.getCost(check_cell->x, check_cell->y);\n\t\tif (new_cost > costmap.getCost(current_cell->x, current_cell->y)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tcheck_cell->target_distance = new_cost;\n\t\t\treturn true;\n\t\t}\n\t}\n}", "CodeBleu_score": 42.05417008514378}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// Check if the cell is an obstacle or has no information\n\tif (!costmap.isCellEnabled(check_cell->getX(), check_cell->getY()) ||\n\t\t\tcostmap.getCost(check_cell->getX(), check_cell->getY()) == costmap_2d::NO_INFORMATION) {\n\t\t// Set the target distance to the maximum obstacle cost and return false\n\t\tcurrent_cell->setTargetDistance(costmap.getCost(check_cell->getX(), check_cell->getY()));\n\t\treturn false;\n\t}\n\n\t// Calculate the new target distance\n\tdouble new_target_distance = current_cell->getDistance() + costmap.getCost(check_cell->getX(), check_cell->getY());\n\n\t// If the new target distance is shorter, update the cell's target distance\n\tif (new_target_distance < current_cell->getTargetDistance()) {\n\t\tcurrent_cell->setTargetDistance(new_target_distance);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 46.530955544701804}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//  ROS_INFO(\"scoreTrajectory\");\n  //initialize the cost and scaling factor\n  double cost = 0.0;\n  double scale = 1.0;\n\n  //if the footprint is empty, log an error and return -9\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"Footprint specification is empty!\");\n    return -9.0;\n  }\n\n  //get the scaling factor\n  scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //calculate the footprint cost\n  for (unsigned int i = 0; i < traj.getPoints().size(); ++i) {\n    double footprint_cost = footprintCost(traj.getPoints()[i].x, traj.getPoints()[i].y, traj.getPoints()[i].theta, scale, footprint_spec_, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return -9.0;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 58.62738398947095}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//initialize the cost and scaling factor based on the trajectory and speed parameters\n\tdouble cost = 0.0;\n\tdouble scale = 1.0;\n\tdouble scaling_speed = 0.0;\n\tdouble max_trans_vel = 0.0;\n\tdouble max_scaling_factor = 0.0;\n\tif (footprint_spec_.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty\");\n\t\treturn -9.0;\n\t}\n\n\t//get the scaling factor\n\tscale = getScalingFactor(traj, scaling_speed, max_trans_vel, max_scaling_factor);\n\n\t//score the trajectory\n\tcost = scoreTrajectory(traj, scale);\n\n\treturn cost;\n}", "CodeBleu_score": 34.18477720598299}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//  if(footprint_spec_.empty()) {\n//    ROS_ERROR(\"Footprint specification is empty. This is not allowed.\");\n//    return -9;\n//  }\n\n  //initialize the cost and scaling factor based on the trajectory and speed parameters\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  double footprint_cost = footprintCost(traj.xv_, traj.yv_, traj.thv_, scale, footprint_spec_, costmap_, world_model_);\n\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  //sum the scores\n  if (sum_scores_) {\n    return footprint_cost + traj.cost_;\n  } else {\n    return std::max(footprint_cost, traj.cost_);\n  }\n}", "CodeBleu_score": 28.70881839001762}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t//ROS_INFO(\"ObstacleCostFunction::footprintCost\");\n    // scale the footprint\n    std::vector<geometry_msgs::Point> scaled_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        geometry_msgs::Point p;\n        p.x = footprint_spec[i].x * scale;\n        p.y = footprint_spec[i].y * scale;\n        scaled_footprint.push_back(p);\n    }\n\n    // transform the footprint into the global frame\n    std::vector<geometry_msgs::Point> global_footprint;\n    tf::Stamped<tf::Pose> global_pose;\n    global_pose.setIdentity();\n    global_pose.setOrigin(tf::Vector3(x, y, 0.0));\n    tf::Quaternion q;\n    q.setRPY(0, 0, th);\n    global_pose.setRotation(q);\n    costmap_2d::transformFootprint(global_pose, scaled_footprint, global_footprint);\n\n    // check if the footprint is empty\n    if (global_footprint.size() == 0) {\n        return -6.0;\n    }\n\n    // check if the footprint is off the map\n    if (costmap->worldToMap(global_footprint[0].x, global_footprint[0].y, x_i, y_i)) {\n        return -7.0;\n    }\n\n    // compute the footprint cost\n    double footprint_cost = costmap->getCost(x_i, y_i);\n    double max_cost = std::max(footprint_cost, costmap->getCost(x_i, y_i));\n\n    // check if the footprint is in the free space\n    if (world_model->footprintCost(global_footprint, costmap, footprint_cost, max_cost)) {\n        return footprint_cost;\n    } else {\n        return -6.0;\n    }\n}", "CodeBleu_score": 61.64962879075182}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\t//std::cout << \"footprintCost\" << std::endl;\n  // scale the footprint by the given scale factor\n  std::vector<geometry_msgs::Point> scaled_footprint_spec;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point p;\n    p.x = footprint_spec[i].x * scale;\n    p.y = footprint_spec[i].y * scale;\n    scaled_footprint_spec.push_back(p);\n  }\n\n  // find the maximum cost of the footprint\n  double max_cost = -1000000.0;\n  double footprint_cost;\n  for (unsigned int i = 0; i < scaled_footprint_spec.size(); ++i) {\n    // find the index of the cell that the footprint point is in\n    unsigned int index_x, index_y;\n    if (!costmap->worldToMap(scaled_footprint_spec[i].x, scaled_footprint_spec[i].y, index_x, index_y)) {\n      return -7.0;\n    }\n\n    // get the cost of the footprint point\n    footprint_cost = costmap->getCost(index_x, index_y);\n    if (footprint_cost > max_cost) {\n      max_cost = footprint_cost;\n    }\n  }\n\n  // find the cost of the robot's position\n  double cell_cost = costmap->getCost(x, y);\n  if (cell_cost > max_cost) {\n    max_cost = cell_cost;\n  }\n\n  // if the cost of the footprint is negative, return -6.0\n  if (max_cost < 0) {\n    return -6.0;\n  }\n\n  // return the maximum cost\n  return max_cost;\n}", "CodeBleu_score": 60.555378963805126}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t\tROS_INFO_ONCE(\"odom topic received!\");\n  boost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic_!= odom_topic) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Subscribing to odometry topic %s\", odom_topic_.c_str());\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Unsubscribing from odometry topic\");\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 44.807986384439495}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"In the setOdomTopic function with the topic: %s\", odom_topic.c_str());\n  boost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic!= odom_topic_) {\n    if (odom_topic!= \"\") {\n      odom_topic_ = odom_topic;\n      odom_sub_ = node_handle_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n      odom_topic_ = \"\";\n    }\n  }\n}", "CodeBleu_score": 48.85900438390854}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"In the setOdomTopic function with topic: %s\", odom_topic.c_str());\n  if(odom_topic!= odom_topic_) {\n    odom_topic_ = odom_topic;\n    if(odom_topic_.empty()) {\n      odom_sub_.shutdown();\n    } else {\n      odom_sub_ = node_handle_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n  }\n}", "CodeBleu_score": 46.02355849713407}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\t// Calculate the squared distance\n\tfloat dist_sq = (pos - prev).squaredNorm();\n\n\t// If the squared distance exceeds a threshold, reset the oscillation flags\n\tif (dist_sq > oscillation_threshold_sq_) {\n\t\tresetOscillationFlags();\n\t}\n\telse {\n\t\t// Calculate the angular difference\n\t\tfloat ang_diff = std::abs(pos.dot(prev) / (pos.norm() * prev.norm()));\n\n\t\t// If the angular difference is greater than a set angle, reset the oscillation flags\n\t\tif (ang_diff > oscillation_angle_) {\n\t\t\tresetOscillationFlags();\n\t\t}\n\t}\n}", "CodeBleu_score": 38.34917997145329}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tconst float sq_dist = (pos - prev).squaredNorm();\n\tconst float angle_diff = fabs(atan2(pos.y() - prev.y(), pos.x() - prev.x()) - atan2(pos.y(), pos.x()));\n\tif (sq_dist > sq_dist_threshold_ || angle_diff > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 38.03499329492631}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat sqr_dist = (pos - prev).squaredNorm();\n\tfloat angle_diff = fabs(angle_diff_between_vectors(pos, prev));\n\n\tif (sqr_dist > sqr_dist_threshold_) {\n\t\tresetOscillationFlags();\n\t} else if (angle_diff > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 34.31451218686829}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t", "CodeBleu_score": 5.072917382472679}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\t//check if the point is too close to its nearest neighbor\n\tif (sq_distance(pt, nearestNeighbor(pt)) < sq_min_separation_)\n\t\treturn;\n\n\t//check if the point is outside the grid bounds\n\tif (gx >= width_ || gy >= height_)\n\t\treturn;\n\n\t//get the bounds of the grid cell in world coords\n\tgeometry_msgs::Point lower_left, upper_right;\n\tgetCellBounds(gx, gy, lower_left, upper_right);\n\n\t//check if the point is outside the cell bounds\n\tif (pt.x < lower_left.x || pt.x > upper_right.x || pt.y < lower_left.y || pt.y > upper_right.y)\n\t\treturn;\n\n\t//calculate the grid index\n\tunsigned int grid_index = gy * width_ + gx;\n\n\t//insert the point into the grid\n\tgrid_points_[grid_index].push_back(pt);\n}", "CodeBleu_score": 57.56080728206292}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //check if the point is too close to its nearest neighbor\n    if(sq_distance(pt, getNearestInCell(pt, gx, gy)) < sq_min_separation_)\n      return;\n\n    //check if the point is outside the grid bounds\n    if(gx >= width_ || gy >= height_)\n      return;\n\n    //check if the point is too close to the edge of a cell\n    if(gx == 0 && pt.x < lower_left_.x)\n      return;\n    if(gy == 0 && pt.y < lower_left_.y)\n      return;\n    if(gx == width_ - 1 && pt.x > upper_right_.x)\n      return;\n    if(gy == height_ - 1 && pt.y > upper_right_.y)\n      return;\n\n    //now we know the point is valid, so insert it\n    unsigned int index = gy * width_ + gx;\n    cells_[index].insert(pt);\n  }", "CodeBleu_score": 52.57222338477082}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n\t// For each of the three velocity components, increase or decrease the current velocity towards the target velocity within the acceleration limits.\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel(i) > vel(i)) {\n\t\t\tif (sample_target_vel(i) - vel(i) > acclimits(i) * dt) {\n\t\t\t\tnew_vel(i) = vel(i) + acclimits(i) * dt;\n\t\t\t} else {\n\t\t\t\tnew_vel(i) = sample_target_vel(i);\n\t\t\t}\n\t\t} else if (sample_target_vel(i) < vel(i)) {\n\t\t\tif (vel(i) - sample_target_vel(i) > acclimits(i) * dt) {\n\t\t\t\tnew_vel(i) = vel(i) - acclimits(i) * dt;\n\t\t\t} else {\n\t\t\t\tnew_vel(i) = sample_target_vel(i);\n\t\t\t}\n\t\t} else {\n\t\t\tnew_vel(i) = sample_target_vel(i);\n\t\t}\n\t}\n\n\treturn new_vel;\n}", "CodeBleu_score": 55.33679462412033}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\n\t// For each of the three velocity components, increase or decrease the current velocity towards the target velocity within the acceleration limits.\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] - vel[i] > acclimits[i]) {\n\t\t\tnew_vel[i] = vel[i] + acclimits[i] * dt;\n\t\t} else if (sample_target_vel[i] - vel[i] < -acclimits[i]) {\n\t\t\tnew_vel[i] = vel[i] - acclimits[i] * dt;\n\t\t} else {\n\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t}\n\t}\n\n\treturn new_vel;\n}", "CodeBleu_score": 69.97336327392827}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tif (sample_target_vel[i] - vel[i] < acclimits[i] * dt) {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t} else {\n\t\t\t\tnew_vel[i] = vel[i] + acclimits[i] * dt;\n\t\t\t}\n\t\t} else if (sample_target_vel[i] < vel[i]) {\n\t\t\tif (vel[i] - sample_target_vel[i] < acclimits[i] * dt) {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t} else {\n\t\t\t\tnew_vel[i] = vel[i] - acclimits[i] * dt;\n\t\t\t}\n\t\t} else {\n\t\t\tnew_vel[i] = vel[i];\n\t\t}\n\t}\n\n\treturn new_vel;\n}", "CodeBleu_score": 70.22330280127194}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble min_diff = DBL_MAX;\n\tdouble diff;\n\tint x_diff;\n\tint y_diff;\n\tint x_goal;\n\tint y_goal;\n\tint i;\n\tint j;\n\tint n = global_plan.size();\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tx_goal = global_plan[i].x;\n\t\ty_goal = global_plan[i].y;\n\n\t\tx_diff = x_goal - x;\n\t\ty_diff = y_goal - y;\n\n\t\tif (x_diff == 0 && y_diff == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdiff = atan2(y_diff, x_diff) - heading;\n\t\tdiff = atan2(sin(diff), cos(diff));\n\n\t\tif (diff < 0) {\n\t\t\tdiff += 2 * M_PI;\n\t\t}\n\n\t\tif (diff < min_diff) {\n\t\t\tmin_diff = diff;\n\t\t}\n\t}\n\n\treturn min_diff;\n}", "CodeBleu_score": 41.54688920535492}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t", "CodeBleu_score": 3.717784580155612}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\t//TODO: Implement this function\n\treturn 0.0;\n}", "CodeBleu_score": 3.817897446023423}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//    std::cout << \"checkTrajectory: \" << x << \" \" << y << \" \" << theta << \" \" << vx << \" \" << vy << \" \" << vtheta << \" \" << vx_samp << \" \" << vy_samp << \" \" << vtheta_samp << std::endl;\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0.0) {\n      ROS_WARN(\"Trajectory cost is negative: %.3f.  Sampled velocities were: %.3f, %.3f, %.3f.\", cost, vx_samp, vy_samp, vtheta_samp);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 73.65685874182482}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\t// Evaluate the trajectory.\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    if (cost < 0) {\n      ROS_WARN(\"Trajectory cost is negative: %.2f, vx=%.2f, vy=%.2f, vtheta=%.2f, vxs=%.2f, vys=%.2f, vthetas=%.2f\", cost, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 69.5363761728198}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t#ifdef DEBUG_TRAJECTORY_PLANNER\n    std::cout << \"TrajectoryPlanner::checkTrajectory(\" << x << \", \" << y << \", \" << theta << \", \" << vx << \", \" << vy << \", \" << vtheta << \", \" << vx_samp << \", \" << vy_samp << \", \" << vtheta_samp << \")\" << std::endl;\n#endif\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost >= 0) {\n#ifdef DEBUG_TRAJECTORY_PLANNER\n      std::cout << \"TrajectoryPlanner::checkTrajectory() returning true\" << std::endl;\n#endif\n      return true;\n    } else {\n      std::cout << \"TrajectoryPlanner::checkTrajectory() returning false\" << std::endl;\n      return false;\n    }\n  }", "CodeBleu_score": 60.415812822782534}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tOS_INFO(\"Clearing costmaps...\");\n\tros::Time start = ros::Time::now();\n\t// check if the object is initialized and if the costmaps are not NULL, logging errors if these conditions are not met\n\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before running a behavior\");\n\t\treturn;\n\t}\n\tif (costmap_ == NULL) {\n\t\tROS_ERROR(\"This object must have a costmap before running a behavior\");\n\t\treturn;\n\t}\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"This object must have a local costmap before running a behavior\");\n\t\treturn;\n\t}\n\n\t// depending on the invert_area_to_clear_ flag, it logs a warning about clearing inside or outside a specified area\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing inside the specified area\");\n\t} else {\n\t\tROS_WARN(\"Clearing outside the specified area\");\n\t}\n\n\t// it then clears the global and/or local costmap based on the affected_maps_ setting, optionally forcing an update, and logs the time taken for each operation\n\tros::Time end = ros::Time::now();\n\tif (affected_maps_ == \"global\") {\n\t\tif (force_update_) {\n\t\t\tclear(costmap_);\n\t\t}\n\t\tROS_INFO(\"Time to clear global costmap: %f\", (end - start).toSec());\n\t} else if (affected_maps_ == \"local\") {\n\t\tif (force_update_) {\n\t\t\tclear(local_costmap_);\n\t\t}\n\t\tROS_INFO(\"Time to clear local costmap: %f\", (end - start).toSec());\n\t} else if (affected_maps_ == \"both\") {\n\t\tif (force_update_) {\n\t\t\tclear(costmap_);\n\t\t\tclear(local_costmap_);\n\t\t}\n\t\tROS_INFO(\"Time to clear both costmaps: %f\", (end - start).toSec());\n\t}\n}", "CodeBleu_score": 49.38058307406713}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells polygon_outline_cells;\n\t// If the polygon is empty, return.\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\t// Otherwise, iterate through the polygon vertices.\n\tfor (int i = 0; i < polygon.size(); i++) {\n\t\t// Initialize the start and end points of the line.\n\t\tMapLocation start_point = polygon[i];\n\t\tMapLocation end_point = polygon[(i + 1) % polygon.size()];\n\t\t// If the line is not vertical, add the cells between the start and end points.\n\t\tif (start_point.x!= end_point.x) {\n\t\t\t// If the line is horizontal, add the cells between the start and end points.\n\t\t\tif (start_point.y == end_point.y) {\n\t\t\t\tfor (int x = start_point.x; x <= end_point.x; x++) {\n\t\t\t\t\tMapLocation cell(x, start_point.y);\n\t\t\t\t\tpolygon_outline_cells.addCell(cell);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, add the cells between the start and end points.\n\t\t\telse {\n\t\t\t\tfor (int y = start_point.y; y <= end_point.y; y++) {\n\t\t\t\t\tMapLocation cell(start_point.x + (y - start_point.y) * (end_point.x - start_point.x) / (end_point.y - start_point.y), y);\n\t\t\t\t\tpolygon_outline_cells.addCell(cell);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Otherwise, if the line is vertical, add the cells between the start and end points.\n\t\telse {\n\t\t\tfor (int y = start_point.y; y <= end_point.y; y++) {\n\t\t\t\tMapLocation cell(start_point.x, y);\n\t\t\t\tpolygon_outline_cells.addCell(cell);\n\t\t\t}\n\t\t}\n\t}\n\t// Add the cells of the polygon to the output vector.\n\tpolygon_cells = polygon_outline_cells.getCells();\n}", "CodeBleu_score": 38.38553717506371}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t// Initialize the PolygonOutlineCells object\n\tPolygonOutlineCells polys(polygon);\n\n\t// Iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tMapLocation p1 = polygon[i];\n\t\tMapLocation p2 = polygon[(i + 1) % polygon.size()];\n\t\tMapLocation p3;\n\t\tif (i == 0) {\n\t\t\tp3 = polygon[polygon.size() - 1];\n\t\t} else {\n\t\t\tp3 = polygon[i - 1];\n\t\t}\n\t\traytraceLine(p1, p2, polys);\n\t\tif (i == 0) {\n\t\t\traytraceLine(p3, p1, polys);\n\t\t} else {\n\t\t\traytraceLine(p2, p3, polys);\n\t\t}\n\t}\n\n\t// Add the cells to the polygon_cells vector\n\tfor (unsigned int i = 0; i < polys.cells.size(); i++) {\n\t\tpolygon_cells.push_back(polys.cells[i]);\n\t}\n}", "CodeBleu_score": 52.61497819055718}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.size() == 0) {\n\t\treturn;\n\t}\n\tPolygonOutlineCells outline_cells;\n\tMapLocation prev_loc = polygon.back();\n\tfor (std::vector<MapLocation>::const_iterator it = polygon.begin(); it!= polygon.end(); it++) {\n\t\tMapLocation loc = *it;\n\t\toutline_cells.addCells(raytraceLine(prev_loc, loc));\n\t\tprev_loc = loc;\n\t}\n\toutline_cells.addCells(raytraceLine(prev_loc, polygon.front()));\n\tpolygon_cells = outline_cells.getCells();\n}", "CodeBleu_score": 35.337469944648184}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 63.39452022692005}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 63.39452022692005}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the mutex\n\tcostmap_mutex_.lock();\n\n\t// Get the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\n\t// Set the resolution, width, and height\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Get the origin\n\tgeometry_msgs::Pose origin = costmap_->getOrigin();\n\n\t// Convert the origin to world coordinates\n\tgrid_.info.origin.position.x = origin.position.x;\n\tgrid_.info.origin.position.y = origin.position.y;\n\tgrid_.info.origin.position.z = origin.position.z;\n\tgrid_.info.origin.orientation.x = origin.orientation.x;\n\tgrid_.info.origin.orientation.y = origin.orientation.y;\n\tgrid_.info.origin.orientation.z = origin.orientation.z;\n\tgrid_.info.origin.orientation.w = origin.orientation.w;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Set the translation table\n\tint8_t* table = costmap_->getCharMap();\n\n\t// Populate the grid data\n\tfor (unsigned int i = 0; i < grid_.data.size(); ++i) {\n\t\tgrid_.data[i] = table[i];\n\t}\n\n\t// Unlock the mutex\n\tcostmap_mutex_.unlock();\n}", "CodeBleu_score": 57.334998013417774}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t//lock the mutex\n\tcostmap_mutex_.lock();\n\n\t//get the resolution\n\tresolution_ = costmap_->getResolution();\n\n\t//set the grid header\n\theader_.frame_id = costmap_->getGlobalFrameID();\n\theader_.stamp = ros::Time::now();\n\n\t//set the grid's resolution\n\tresolution_ = costmap_->getResolution();\n\n\t//set the grid's width and height\n\twidth_ = costmap_->getSizeInCellsX();\n\theight_ = costmap_->getSizeInCellsY();\n\n\t//set the grid's origin\n\torigin_x_ = costmap_->getOriginX();\n\torigin_y_ = costmap_->getOriginY();\n\torigin_z_ = 0.0;\n\torigin_ = tf::Vector3(origin_x_, origin_y_, origin_z_);\n\n\t//resize the grid data vector\n\tgrid_data_.resize(width_*height_);\n\n\t//unlock the mutex\n\tcostmap_mutex_.unlock();\n}", "CodeBleu_score": 28.474075796487725}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tstd::lock_guard<std::mutex> lock(costmap_mutex_);\n\tconst double resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tfor (int i = 0; i < grid_.info.width * grid_.info.height; i++) {\n\t\tgrid_.data[i] = costmap_->getCharMap().get(i);\n\t}\n}", "CodeBleu_score": 55.92058659043314}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t", "CodeBleu_score": 4.722552995136935}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\t// If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n\tif (new_config.robot_radius == old_config.robot_radius && new_config.footprint == old_config.footprint) {\n\t\treturn;\n\t}\n\n\t// If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n\tif (new_config.footprint!= \"\") {\n\t\tstd::vector<geometry_msgs::Point> points;\n\t\tif (parseFootprintString(new_config.footprint, points)) {\n\t\t\tsetUnpaddedRobotFootprint(points);\n\t\t} else {\n\t\t\tROS_ERROR(\"Invalid footprint string\");\n\t\t}\n\t}\n\n\t// If the footprint string is invalid, it logs an error.\n\tif (new_config.footprint == \"\" && new_config.robot_radius!= 0) {\n\t\tsetUnpaddedRobotFootprint(makeCircleFootprint(new_config.robot_radius));\n\t}\n\n\t// If no valid footprint string is provided, it sets the footprint based on the robot radius.\n\tif (new_config.footprint == \"\" && new_config.robot_radius == 0) {\n\t\tsetUnpaddedRobotFootprint(std::vector<geometry_msgs::Point>());\n\t}\n}", "CodeBleu_score": 69.53632749048818}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.robot_radius == old_config.robot_radius) {\n\t\tROS_DEBUG(\"Footprint radius unchanged, no need to recompute footprint\");\n\t\treturn;\n\t}\n\n\tif (new_config.footprint.size() > 0) {\n\t\tROS_DEBUG(\"Setting footprint from config\");\n\t\tstd::vector<geometry_msgs::Point> points;\n\t\tstd::istringstream iss(new_config.footprint);\n\t\tgeometry_msgs::Point point;\n\t\twhile (iss >> point.x) {\n\t\t\tiss >> point.y;\n\t\t\tpoints.push_back(point);\n\t\t}\n\t\tsetUnpaddedRobotFootprint(points);\n\t} else {\n\t\tROS_DEBUG(\"Setting footprint from robot radius\");\n\t\tsetUnpaddedRobotFootprint(makeFootprint(new_config.robot_radius));\n\t}\n}", "CodeBleu_score": 51.59962186174907}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// get the robot's current pose\n  geometry_msgs::PoseStamped robot_pose;\n  if (!getRobotPose(robot_pose))\n  {\n    ROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n    return;\n  }\n\n  // check if the robot's pose has changed\n  if (new_pose_.pose.position.x == robot_pose.pose.position.x && new_pose_.pose.position.y == robot_pose.pose.position.y && new_pose_.pose.position.z == robot_pose.pose.position.z && new_pose_.pose.orientation.x == robot_pose.pose.orientation.x && new_pose_.pose.orientation.y == robot_pose.pose.orientation.y && new_pose_.pose.orientation.z == robot_pose.pose.orientation.z && new_pose_.pose.orientation.w == robot_pose.pose.orientation.w)\n  {\n    return;\n  }\n\n  // update the robot's pose\n  new_pose_ = robot_pose;\n\n  // update the global pose\n  geometry_msgs::PoseStamped global_pose;\n  if (!getRobotPose(global_pose))\n  {\n    ROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n    return;\n  }\n  global_pose_ = global_pose;\n\n  // update the map origin\n  map_origin_ = global_pose_.pose.position;\n\n  // update the map frame\n  map_frame_ = global_pose_.header.frame_id;\n\n  // publish the new pose\n  publishGlobalPose();\n\n  // update the costmap\n  updateCostmap();\n}", "CodeBleu_score": 51.743764267175386}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// get the robot's current pose\n\tgeometry_msgs::PoseStamped robot_pose;\n\tif (!getRobotPose(robot_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose. Cancelling reconfiguration.\");\n\t\treturn;\n\t}\n\n\t// check if the robot's pose has changed\n\tif (new_pose.position.x == robot_pose.pose.position.x && new_pose.position.y == robot_pose.pose.position.y && new_pose.position.z == robot_pose.pose.position.z && new_pose.orientation.x == robot_pose.pose.orientation.x && new_pose.orientation.y == robot_pose.pose.orientation.y && new_pose.orientation.z == robot_pose.pose.orientation.z && new_pose.orientation.w == robot_pose.pose.orientation.w) {\n\t\treturn;\n\t}\n\n\t// update the robot's current pose\n\tnew_pose = robot_pose.pose;\n\n\t// publish the robot's new pose\n\tpublishRobotPose(robot_pose);\n}", "CodeBleu_score": 50.65166646926581}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\t// get robot pose\n\tif (!getRobotPose(new_pose_)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose\");\n\t\treturn;\n\t}\n\n\t// if the robot is moving, update the map\n\tif (new_pose_.pose.position.x!= old_pose_.pose.position.x || new_pose_.pose.position.y!= old_pose_.pose.position.y) {\n\t\tif (updateMap(new_pose_, old_pose_)) {\n\t\t\t// reset the old pose\n\t\t\told_pose_ = new_pose_;\n\t\t}\n\t}\n}", "CodeBleu_score": 52.04765417810799}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\t// Get the list of plugins and check if the costmap was stopped\n\tplugin_list_ = getPlugins();\n\tif (stopped_) {\n\t\t// If the costmap was stopped, reactivate each plugin and set the stopped flag to false\n\t\tfor (unsigned int i = 0; i < plugin_list_.size(); ++i) {\n\t\t\tplugin_list_[i]->activate();\n\t\t}\n\t\tstopped_ = false;\n\t}\n\n\t// Set stop_updates_ to false\n\tstop_updates_ = false;\n\n\t// Wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n\twhile (!ros::isStarted() &&!is_initialized_ &&!update_thread_.is_running()) {\n\t\tros::Duration(0.1).sleep();\n\t}\n\n\t// If the costmap is initialized, start the map update thread\n\tif (is_initialized_) {\n\t\tupdate_thread_.start();\n\t}\n}", "CodeBleu_score": 45.890337158044886}, {"code": "void Costmap2DROS::start(){\n\t\t// Get the list of plugins\n\tpluginlib::ClassLoader<Costmap2D> c2d(\"costmap_2d\", \"Costmap2D\");\n\tstd::vector<std::string> plugins = c2d.getDeclaredClasses();\n\n\t// Check if the costmap was stopped\n\tif (stopped_) {\n\t\t// Re-subscribe to topics by activating each plugin\n\t\tfor (std::vector<std::string>::iterator it = plugins.begin(); it!= plugins.end(); ++it) {\n\t\t\t// Get the plugin\n\t\t\tCostmap2D* plugin = c2d.createInstance(*it);\n\n\t\t\t// Activate the plugin\n\t\t\tplugin->activate();\n\n\t\t\t// Set the stopped flag to false\n\t\t\tstopped_ = false;\n\n\t\t\t// Set stop_updates_ to false\n\t\t\tstop_updates_ = false;\n\t\t}\n\t}\n\n\t// Wait until ROS is running, the costmap is initialized, and the map update thread is active\n\twhile (!ros::ok() ||!is_initialized_ ||!update_thread_.active()) {\n\t\tros::spinOnce();\n\t\tros::Duration(0.01).sleep();\n\t}\n}", "CodeBleu_score": 51.28302397930259}, {"code": "void Costmap2DROS::start(){\n\t\t// Get list of plugins\n\tvector<string> plugins = getPlugins();\n\n\t// Check if costmap was stopped\n\tif (stopped_) {\n\t\t// Re-subscribe to topics by activating each plugin\n\t\tfor (size_t i = 0; i < plugins.size(); ++i) {\n\t\t\tplugins_[plugins[i]]->activate();\n\t\t}\n\n\t\t// Set stopped flag to false\n\t\tstopped_ = false;\n\t}\n\n\t// Set stop_updates_ to false\n\tstop_updates_ = false;\n\n\t// Wait for ROS to be initialized\n\twhile (!ros::isInitialized()) {\n\t\tros::WallDuration sleep_time(0.01);\n\t\tsleep_time.sleep();\n\t}\n\n\t// Wait for the costmap to be initialized\n\twhile (!is_initialized_) {\n\t\tros::WallDuration sleep_time(0.01);\n\t\tsleep_time.sleep();\n\t}\n\n\t// Wait for the map update thread to be active\n\twhile (!map_update_thread_active_) {\n\t\tros::WallDuration sleep_time(0.01);\n\t\tsleep_time.sleep();\n\t}\n}", "CodeBleu_score": 55.658211753071555}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == 0) {\n\t\twhile (!observations_.empty()) {\n\t\t\tobservations_.pop_front();\n\t\t}\n\t} else {\n\t\twhile (!observations_.empty()) {\n\t\t\tif (observations_.front().timestamp_ - observations_.front().timestamp_ > observation_keep_time_) {\n\t\t\t\tobservations_.pop_front();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 29.178472677344715}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t", "CodeBleu_score": 1.4641945780713905}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If the observation_keep_time_ is zero, it keeps only the most recent observation.\n\tif (observation_keep_time_ == 0) {\n\t\t// Remove the oldest observation from the observation list.\n\t\tobservations_.pop_front();\n\t} else {\n\t\t// Iterate through the list and remove observations that are older than the specified keep time, stopping once it finds a valid observation.\n\t\tfor (auto it = observations_.begin(); it!= observations_.end(); it++) {\n\t\t\tif ((*it)->getObservationTime() + observation_keep_time_ > ros::Time::now()) {\n\t\t\t\t// Remove the observation from the observation list.\n\t\t\t\tobservations_.erase(it);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 29.434188945622275}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// Get the start and end yaw angles\n\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n\t// Determine the shortest angular distance between start and end yaw angles\n\tdouble delta_yaw = end_yaw - start_yaw;\n\tif (delta_yaw > M_PI) {\n\t\tdelta_yaw -= 2 * M_PI;\n\t} else if (delta_yaw < -M_PI) {\n\t\tdelta_yaw += 2 * M_PI;\n\t}\n\n\t// Interpolate the orientation of each pose in the specified range\n\tfor (int i = start_index; i <= end_index; i++) {\n\t\tdouble yaw = start_yaw + (i - start_index) * delta_yaw / (end_index - start_index);\n\t\tset_angle(&path[i], yaw);\n\t}\n}", "CodeBleu_score": 59.12955574931811}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\tdouble delta_yaw = end_yaw - start_yaw;\n\tdouble yaw_increment = delta_yaw / (end_index - start_index);\n\tfor (int i = start_index; i < end_index; i++) {\n\t\ttf2::Quaternion q;\n\t\ttf2::convert(path[i].pose.orientation, q);\n\t\tq.setRPY(0, 0, yaw_increment * (i - start_index) + start_yaw);\n\t\ttf2::convert(q, path[i].pose.orientation);\n\t}\n}", "CodeBleu_score": 58.17944509816283}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\tdouble delta_yaw = end_yaw - start_yaw;\n\tdouble delta_yaw_abs = fabs(delta_yaw);\n\n\t// If the yaw angles are not in the range [-pi, pi], then the shortest angular distance is the sum of the two angles.\n\tif (delta_yaw_abs > M_PI) {\n\t\tdelta_yaw_abs = 2 * M_PI - delta_yaw_abs;\n\t}\n\n\t// Compute the incremental change in angle for each pose and update the orientation of each pose in the specified range.\n\tfor (int i = start_index; i <= end_index; i++) {\n\t\tdouble delta_yaw_i = delta_yaw_abs / (end_index - start_index + 1);\n\t\tdouble yaw_i = start_yaw + (i - start_index) * delta_yaw_i;\n\t\ttf2::Quaternion q;\n\t\tq.setRPY(0, 0, yaw_i);\n\t\ttf2::convert(q, path[i].pose.orientation);\n\t}\n}", "CodeBleu_score": 51.87829509631129}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a plan request for (%.2f, %.2f) to (%.2f, %.2f) with tolerance %.3f\", req.start.pose.position.x, req.start.pose.position.y, req.goal.pose.position.x, req.goal.pose.position.y, req.tolerance);\n\tgeometry_msgs::PoseStamped start, goal;\n\tstart.pose = req.start.pose;\n\tstart.header.frame_id = \"map\";\n\tgoal.pose = req.goal.pose;\n\tgoal.header.frame_id = \"map\";\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tbool found_path = planner->makePlan(start, goal, plan);\n\tresp.plan.poses.resize(plan.size());\n\tfor (unsigned int i = 0; i < plan.size(); i++) {\n\t\tresp.plan.poses[i] = plan[i];\n\t}\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.found_path = found_path;\n\treturn true;\n}", "CodeBleu_score": 50.1508535019341}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\t// set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// generate a path\n\tbool found_path = makePlan(req.start, req.goal, resp.plan);\n\n\t// return the success status\n\tresp.success = found_path;\n\n\t// return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 54.45035976125475}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_DEBUG_NAMED(\"navfn\", \"Received request to make plan from %s to %s\", req.start.frame_id.c_str(), req.goal.frame_id.c_str());\n\n\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call the makePlan function to generate a path\n\tbool success = makePlan(req.start, req.goal, resp.plan.poses);\n\n\t// Update the response with the success status and the generated path if a plan is found\n\tresp.success = success;\n\n\t// Return true to indicate that the service was processed\n\treturn true;\n}", "CodeBleu_score": 60.37938283360702}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\t// TODO Auto-generated constructor stub\n\tnh = ros::NodeHandle(\"~\");\n\tthis->cmap = cmap;\n\tplanner_name = name;\n\t//setupService();\n\tsetupSubscriber();\n\tsetupPublisher();\n}", "CodeBleu_score": 27.526401484625257}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\t// Create private node handle\n\tros::NodeHandle private_nh(\"~/\" + name);\n\n\t// Create a service client to call the planner\n\tros::ServiceClient client = private_nh.serviceClient<nav_msgs::GetPlan>(\"/move_base/make_plan\");\n\n\t// Advertise a service to make a plan\n\tros::ServiceServer service = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\n\n\t// Subscribe to the goal topic\n\tros::Subscriber sub = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n\n\t// Set up the planner's configuration\n\tsetup(client, service, sub);\n}", "CodeBleu_score": 56.27486125162198}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t", "CodeBleu_score": 18.432682072468964}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy < costmap_->getOriginY() || wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\treturn false;\n\t}\n\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 40.776261806020706}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy < costmap_->getOriginY() || wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\treturn false;\n\t}\n\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n\treturn true;\n}", "CodeBleu_score": 40.64664274902524}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_->getOriginX() || wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() || wy < costmap_->getOriginY() || wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}", "CodeBleu_score": 40.776261806020706}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = path_frame_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 84.356398703637}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 82.53666226729315}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 82.53666226729315}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In MoveBase::goalCB, received a goal of type PoseStamped\");\n\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 75.85969282078278}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(name, \"In MoveBase::goalCB, wrapping goal in action message.\");\n\n\t// Create an action goal message\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\n\t// Set the timestamp\n\taction_goal.header.stamp = ros::Time::now();\n\n\t// Set the goal pose\n\taction_goal.goal.target_pose = *goal;\n\n\t// Publish the goal\n\tROS_DEBUG_NAMED(name, \"Publishing goal.\");\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 64.11719044283637}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_NAMED(\"move_base\", \"In move_base goal callback\");\n\n\t// Copy the goal\n\tmove_base_msgs::MoveBaseActionGoal goal_msg;\n\tgoal_msg.header.stamp = ros::Time::now();\n\tgoal_msg.goal.target_pose = *goal;\n\n\t// Publish the goal\n\taction_goal_pub_.publish(goal_msg);\n}", "CodeBleu_score": 64.09249286147931}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble sq_distance = getSqDistance();\n\tdouble sq_limit_distance = speed_limit_distance_ * speed_limit_distance_;\n\tif (sq_distance > sq_limit_distance) {\n\t\tROS_INFO(\"Robot has moved %f m, which is more than the limit distance of %f m.\", sqrt(sq_distance), sqrt(sq_limit_distance));\n\t\tif (remove_limit_thread_) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t\tremove_limit_thread_ = NULL;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 62.61507845801165}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tROS_INFO(\"Distance check timer triggered.\");\n\tif (getSqDistance() > distance_limit_sq_) {\n\t\tROS_INFO(\"Robot has moved far enough. Removing speed limit.\");\n\t\tremoveLimit();\n\t}\n}", "CodeBleu_score": 24.105944347699854}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble sq_distance = getSqDistance();\n\tif (sq_distance > sq_distance_limit_) {\n\t\tROS_INFO_STREAM(\"Robot has moved \" << sqrt(sq_distance) << \"m from the speed limit\");\n\t\tif (remove_limit_thread_) {\n\t\t\tremove_limit_thread_->join();\n\t\t}\n\t\tremove_limit_thread_ = boost::shared_ptr<boost::thread>(new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this)));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 54.14687187469514}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Goal received!\");\n\t// Get current pose\n\tPoseStamped current_pose;\n\tgetRobotPose(current_pose);\n\t// Generate path\n\tstd::vector<PoseStamped> plan;\n\tmakePlan(current_pose, *goal, plan);\n\t// Publish path\n\tpublishPlan(plan);\n}", "CodeBleu_score": 54.501152283037}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Retrieve the current global pose of the robot\n\trm::PoseStamped robot_pose = getRobotPose();\n\t// Generate a path from the current pose to the goal pose\n\tvector<geometry_msgs::PoseStamped> plan;\n\tmakePlan(robot_pose, *goal, plan);\n\t// Publish the path\n\tpublishPlan(plan);\n}", "CodeBleu_score": 51.5850205783667}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current global pose of the robot\n\tPoseStamped current_pose = getRobotPose();\n\t// Generate a path from the current pose to the goal pose\n\tvector<PoseStamped> path;\n\tmakePlan(current_pose, *goal, path);\n\t// Set the path to be used by the controller\n\tcontroller_path = path;\n}", "CodeBleu_score": 54.679720813895514}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create service request\n\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\n\t// Send request\n\tparam_set_client_.call(param_set_srv);\n\n\t// Check if request was successful\n\tif (param_set_srv.response.success) {\n\t\tROS_INFO(\"Gimbal parameter set successful!\");\n\t} else {\n\t\tROS_ERROR(\"Gimbal parameter set unsuccessful!\");\n\t}\n}", "CodeBleu_score": 51.587736854130405}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tstruct ParamSet param_set_msg;\n\tparam_set_msg.param_id = param_set.param_id;\n\tparam_set_msg.value = param_set.value;\n\tparam_set_client_.call(param_set_msg);\n}", "CodeBleu_score": 49.4236061460343}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create a ParamSet service request\n\tparam_set_srv.request.param_set.param_id = param_set.param_id;\n\tparam_set_srv.request.param_set.param_value = param_set.param_value;\n\n\t// Send the request to the param_set_client_\n\tparam_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 51.74177659768582}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\t//ROS_INFO(\"Received command from UAV %d\", uav_cmd.uav_id);\n\tif (uav_cmd.uav_id == 0) {\n\t\tuav_basic_.publish(uav_cmd);\n\t} else {\n\t\tuav_cmd.uav_id = uav_cmd.uav_id - 1;\n\t\tswarm_control_simulation_.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 19.724487898077424}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\t// If in simulation mode, find the UAV corresponding to the ID of the command and publish it.\n\tif (simulation_mode_) {\n\t\tint id = uav_cmd.id;\n\t\tfor (int i = 0; i < swarm_control_simulation_.uavs.size(); i++) {\n\t\t\tif (swarm_control_simulation_.uavs[i].id == id) {\n\t\t\t\tswarm_control_simulation_.uavs[i].cmd = uav_cmd;\n\t\t\t\tswarm_control_simulation_.uavs[i].cmd_pub.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// If not in simulation mode, publish the command to the UAV specified by the ID.\n\telse {\n\t\tuav_basic_.cmd = uav_cmd;\n\t\tuav_basic_.cmd_pub.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 38.015193448620735}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (!sim_mode_) {\n\t\tuav_basic_.publish(uav_cmd);\n\t} else {\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].id == uav_cmd.id) {\n\t\t\t\tswarm_control_simulation_[i].publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.00514488289138}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == 1) {\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == 0) {\n\t\tdeleteMode(mode_selection);\n\t} else if (mode_selection.use_mode == 2) {\n\t\tsystem(\"reboot\");\n\t} else if (mode_selection.use_mode == 3) {\n\t\tsystem(\"exit\");\n\t}\n}", "CodeBleu_score": 57.68430779595146}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\t// Check if the mode_selection is valid\n\tif (mode_selection.use_mode == 0) {\n\t\tstd::cout << \"Invalid mode selection\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Check if the mode_selection is valid\n\tif (mode_selection.use_mode == 1) {\n\t\t// Execute REBOOTNX command\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == 2) {\n\t\t// Execute EXITNX command\n\t\tsystem(\"exitnx\");\n\t} else {\n\t\t// Check if the mode_selection is valid\n\t\tif (mode_selection.use_mode == 3) {\n\t\t\t// Execute CREATEMODE command\n\t\t\tcreateMode(mode_selection.mode_name);\n\t\t} else if (mode_selection.use_mode == 4) {\n\t\t\t// Execute DELETEMODE command\n\t\t\tdeleteMode(mode_selection.mode_name);\n\t\t}\n\t}\n}", "CodeBleu_score": 50.952658498348605}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch (mode_selection.mode) {\n\t\tcase REBOOTNX:\n\t\t\tsystem(REBOOTNX_COMMAND);\n\t\t\tbreak;\n\t\tcase EXITNX:\n\t\t\tsystem(EXITNX_COMMAND);\n\t\t\tbreak;\n\t\tcase CREATE_MODE:\n\t\t\tcreateMode(mode_selection.mode_name);\n\t\t\tbreak;\n\t\tcase DELETE_MODE:\n\t\t\tdeleteMode(mode_selection.mode_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 37.01363782078765}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// Check if the heartbeat count has exceeded the maximum number of missed heartbeats\n\tif (heartbeat_count > max_missed_heartbeats) {\n\t\t// Print an error message\n\t\tROS_ERROR(\"Heartbeat lost. Max missed heartbeats exceeded.\");\n\n\t\t// If the vehicle is a swarm, trigger the swarm_disconnect_flag\n\t\tif (vehicle_type == VehicleType::SWARM) {\n\t\t\tswarm_disconnect_flag = true;\n\t\t}\n\t\t// If the vehicle is a UAV, trigger the UAV_disconnect_flag\n\t\telse if (vehicle_type == VehicleType::UAV) {\n\t\t\tUAV_disconnect_flag = true;\n\t\t}\n\t\t// If the vehicle is a UGV, trigger the UGV_disconnect_flag\n\t\telse if (vehicle_type == VehicleType::UGV) {\n\t\t\tUGV_disconnect_flag = true;\n\t\t}\n\n\t\t// Set the disconnect_flag to true\n\t\tdisconnect_flag = true;\n\t}\n\n\t// Reset the heartbeat count to 0\n\theartbeat_count = 0;\n}", "CodeBleu_score": 20.272041824275615}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// Check heartbeat status\n\tif (ros::ok()) {\n\t\tif (heartbeat_count_ > 0) {\n\t\t\theartbeat_count_--;\n\t\t} else {\n\t\t\tROS_ERROR(\"Heartbeat timeout. Disconnecting...\");\n\t\t\tdisconnect_flag_ = true;\n\t\t\tif (vehicle_type_ == VehicleType::UAV) {\n\t\t\t\tROS_ERROR(\"UAV is disconnected.\");\n\t\t\t} else if (vehicle_type_ == VehicleType::UGV) {\n\t\t\t\tROS_ERROR(\"UGV is disconnected.\");\n\t\t\t} else if (vehicle_type_ == VehicleType::Swarm) {\n\t\t\t\tROS_ERROR(\"Swarm is disconnected.\");\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 28.745588076422308}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t", "CodeBleu_score": 2.830075858955893}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tsensor_msgs::PointCloud2 compressed_msg;\n\n\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> pcl_msg;\n\tpcl_conversions::toPCL(msg, pcl_msg);\n\n\t// Compress the point cloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr pcl_msg_ptr(new pcl::PointCloud<pcl::PointXYZ>(pcl_msg));\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr pcl_msg_compressed_ptr(new pcl::PointCloud<pcl::PointXYZ>());\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression(0.01f);\n\toctree_compression.setInputCloud(pcl_msg_ptr);\n\toctree_compression.addPointsFromInputCloud();\n\toctree_compression.compressPointCloud(*pcl_msg_compressed_ptr);\n\n\t// Create a new PointCloud2 message with the compressed data\n\tpcl::PCLPointCloud2 pcl_msg_compressed;\n\tpcl::toPCLPointCloud2(*pcl_msg_compressed_ptr, pcl_msg_compressed);\n\tpcl_conversions::fromPCL(pcl_msg_compressed, compressed_msg);\n\n\t// Release dynamically allocated memory\n\tpcl_msg_ptr.reset();\n\tpcl_msg_compressed_ptr.reset();\n\n\treturn compressed_msg;\n}", "CodeBleu_score": 38.81207773536457}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 54.21600270455358}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (uav_state.uav_id == multi_uav_state_[i].uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 53.18669451584205}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 54.21600270455358}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t//Initialize MultiUGVState message\n\tMultiUGVState ugv_state_msg;\n\n\t//Iterate through each UGV state\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\t//Initialize UGVState message\n\t\tUGVState ugv_state_msg;\n\n\t\t//Populate UGVState message with ID, battery, position, velocity, and attitude data\n\t\tugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state_msg.position = m_multi_ugv_state.ugv_state[i].position;\n\t\tugv_state_msg.velocity = m_multi_ugv_state.ugv_state[i].velocity;\n\t\tugv_state_msg.attitude = m_multi_ugv_state.ugv_state[i].attitude;\n\n\t\t//Add UGVState message to MultiUGVState message\n\t\tugv_state_msg.ugv_state.push_back(ugv_state_msg);\n\t}\n\n\t//Publish MultiUGVState message\n\tugv_state_pub_.publish(ugv_state_msg);\n}", "CodeBleu_score": 30.347182649012893}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\t// initialize the MultiUGVState message\n\tMultiUGVState msg;\n\n\t// iterate through each UGV state\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\t// initialize the UGVState message\n\t\tUGVState ugv_state;\n\n\t\t// populate the UGVState message with ID, battery, position, velocity, and attitude data\n\t\tugv_state.ugv_id = m_multi_ugv_state.ugv_states[i].ugv_id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_states[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_states[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_states[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_states[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_states[i].attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_states[i].attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_states[i].attitude.yaw;\n\n\t\t// add the UGVState to the MultiUGVState message\n\t\tmsg.ugv_states.push_back(ugv_state);\n\t}\n\n\t// publish the assembled MultiUGVState message\n\tugv_state_pub.publish(msg);\n}", "CodeBleu_score": 43.717101553432634}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tgradient.setZero(q.rows(), q.cols());\n\n\tEigen::MatrixXd predicted_pos = calcPredictedPos(q);\n\n\tfor (int i = 0; i < predicted_pos.rows(); i++) {\n\t\tdouble distance = (predicted_pos.row(i) - q.row(i)).norm();\n\t\tif (distance < clearance_) {\n\t\t\tcost += (distance - clearance_) * (distance - clearance_);\n\t\t\tgradient.row(i) += 2.0 * (predicted_pos.row(i) - q.row(i)) / (distance - clearance_);\n\t\t}\n\t}\n}", "CodeBleu_score": 26.488322872275997}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tdouble obj_cost = 0.0;\n\tEigen::MatrixXd obj_gradient(q.rows(), q.cols());\n\tobj_gradient.setZero();\n\n\t// Iterate through control points of the B-spline\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\tEigen::Vector3d qi = q.row(i);\n\n\t\t// Compute predicted positions of moving objects\n\t\tEigen::Vector3d predicted_obj_pos = moving_obj_model_->predict(qi);\n\n\t\t// Evaluate distance between control points and predicted positions of moving objects\n\t\tdouble dist = (qi - predicted_obj_pos).norm();\n\n\t\t// Update cost and gradient if distance is less than specified clearance\n\t\tif (dist < clearance_) {\n\t\t\tobj_cost += (dist - clearance_) * (dist - clearance_);\n\t\t\tobj_gradient.row(i) = 2.0 * (qi - predicted_obj_pos);\n\t\t}\n\t}\n\n\t// Update cost and gradient of the B-spline trajectory\n\tcost = obj_cost + cost_;\n\tgradient = obj_gradient + gradient_;\n}", "CodeBleu_score": 32.09146716454405}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Initialize the cost to zero\n\tcost = 0.0;\n\t// Initialize the gradient to zero\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// Iterate through the control points of the trajectory\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\t// Compute the positional error relative to reference points\n\t\tEigen::Vector3d e = q.row(i) - ref_points_.row(i);\n\t\t// Compute the velocity vector\n\t\tEigen::Vector3d v = (q.row(i + 1) - q.row(i)) / (time_step_);\n\t\t// Compute the squared dot product\n\t\tdouble dot_product = e.dot(v);\n\t\tdot_product *= dot_product;\n\t\t// Compute the squared cross product\n\t\tdouble cross_product = e.cross(v).norm();\n\t\tcross_product *= cross_product;\n\t\t// Update the cost function\n\t\tcost += a2_ * dot_product + b2_ * cross_product;\n\t\t// Update the gradient\n\t\tgradient.row(i) += 2 * a2_ * e + 2 * b2_ * e.cross(v);\n\t}\n}", "CodeBleu_score": 31.201136603183393}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0.0;\n\tgradient.setZero(q.rows(), q.cols());\n\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\tEigen::Vector3d p = q.row(i);\n\t\tEigen::Vector3d p_ref = reference.row(i);\n\t\tEigen::Vector3d dp = p - p_ref;\n\t\tEigen::Vector3d ddp = (p - 2.0 * p_ref + reference.row(i + 1)) / 2.0;\n\t\tEigen::Vector3d dddp = (p - 2.0 * p_ref + 2.0 * reference.row(i + 1) - reference.row(i + 2)) / 2.0;\n\n\t\tdouble a2 = 1.0 / (ddp.norm() * ddp.norm());\n\t\tdouble b2 = 1.0 / (dddp.norm() * ddp.norm());\n\n\t\tdouble cost_i = a2 * dp.dot(dp) + b2 * ddp.dot(dp);\n\t\tcost += cost_i;\n\n\t\tEigen::Vector3d gradient_i = 2.0 * a2 * dp + 2.0 * b2 * ddp;\n\t\tgradient.row(i) = gradient_i;\n\t}\n}", "CodeBleu_score": 38.53712971928071}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\t// get the third derivative\n\tUniformBspline third_derivative = getThirdDerivative();\n\n\t// get the knot times and control points of the third derivative\n\tEigen::VectorXd knot_times = third_derivative.getKnot();\n\tEigen::MatrixXd control_points = third_derivative.getControlPoints();\n\n\t// sum the squared control point values multiplied by the differences in knot times\n\tdouble jerk = 0.0;\n\tfor (int i = 0; i < control_points.rows(); i++) {\n\t\tfor (int j = 0; j < control_points.cols(); j++) {\n\t\t\tjerk += pow(control_points(i, j), 2) * (knot_times(i + 1) - knot_times(i));\n\t\t}\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 56.731267312011454}, {"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd jerk_ctp = getJerkControlPoints();\n\tEigen::VectorXd jerk_knot = getKnotTimes();\n\n\tdouble jerk = 0;\n\tfor (int i = 0; i < jerk_ctp.cols(); i++) {\n\t\tfor (int j = 0; j < jerk_ctp.rows(); j++) {\n\t\t\tjerk += pow(jerk_ctp(j, i), 2) * (jerk_knot(j + 1) - jerk_knot(j));\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 46.97329034645463}, {"code": "double UniformBspline::getJerk(){\n\t\tdouble jerk = 0;\n\tEigen::MatrixXd jerk_trajectory = getDerivative().getDerivative().getDerivative().getControlPoints();\n\tEigen::VectorXd knot_times = getKnotTimes();\n\n\tfor (int i = 0; i < jerk_trajectory.rows(); i++) {\n\t\tfor (int j = 0; j < jerk_trajectory.cols(); j++) {\n\t\t\tjerk += pow(jerk_trajectory(i, j), 2) * (knot_times(i + 1) - knot_times(i));\n\t\t}\n\t}\n\n\treturn jerk;\n}", "CodeBleu_score": 54.86822433948221}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << (u - cx_) / fx_ * depth, (v - cy_) / fy_ * depth, depth, 1.0;\n\treturn pos;\n}", "CodeBleu_score": 41.0043521350121}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos << depth * (u - cx_) / fx_, depth * (v - cy_) / fy_, depth, 1.0;\n\treturn pos;\n}", "CodeBleu_score": 38.401332806414366}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 74.49740701774701}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = getDroneID(odom.child_frame_id);\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (std::exception& e) {\n\t\tstd::cerr << e.what() << std::endl;\n\t}\n}", "CodeBleu_score": 47.77815868111062}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, getDroneID(odom.child_frame_id));\n\t} catch (std::exception& e) {\n\t\tstd::cerr << e.what() << std::endl;\n\t}\n}", "CodeBleu_score": 37.693832896549154}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, extractDroneId(odom));\n\t} catch (std::exception& e) {\n\t\tstd::cerr << e.what() << std::endl;\n\t}\n}", "CodeBleu_score": 36.47640943127628}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the drone from the map\n\tDrone *drone = getDrone(drone_id);\n\n\t// If the drone is not found, update the debug result and return\n\tif (drone == nullptr) {\n\t\tdebug_result = \"Drone not found\";\n\t\treturn;\n\t}\n\n\t// Get the drone's pose in the camera frame\n\tEigen::Vector3d drone_pose = drone->getPose();\n\n\t// Calculate the error between the drone's pose and the true pose\n\tEigen::Vector3d error = drone_pose - true_pose;\n\n\t// Update the debug result with the error\n\tstd::stringstream ss;\n\tss << \"Drone found at (\" << drone_pose(0) << \", \" << drone_pose(1) << \", \" << drone_pose(2) << \") with error (\" << error(0) << \", \" << error(1) << \", \" << error(2) << \")\";\n\tdebug_result = ss.str();\n\n\t// Publish the error\n\tdrone_pose_error_pub.publish(error);\n}", "CodeBleu_score": 30.234412039928603}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\tEigen::Vector3d true_pose;\n\tEigen::Vector3d camera_pose;\n\tEigen::Vector3d drone_pose;\n\tEigen::Vector3d drone_pose_error;\n\tEigen::Vector3d drone_pose_error_world;\n\n\t// Calculate the true pose of the drone in the camera frame\n\tcamera_pose = getCameraPose(drone_id);\n\ttrue_pose = getTruePose(drone_id, true_pixel);\n\tdrone_pose = camera_pose + true_pose;\n\n\t// Check if the drone is present\n\tif (drone_pose(2) > 0) {\n\t\t// Calculate the pose error between the camera and world coordinates\n\t\tdrone_pose_error = drone_pose - getTruePose(drone_id, true_pixel);\n\t\tdrone_pose_error_world = drone_pose_error + getTruePose(drone_id, true_pixel);\n\n\t\t// Update the debug result\n\t\tdebug_result.drone_id = drone_id;\n\t\tdebug_result.true_pixel = true_pixel;\n\t\tdebug_result.drone_pose = drone_pose;\n\t\tdebug_result.drone_pose_error = drone_pose_error;\n\t\tdebug_result.drone_pose_error_world = drone_pose_error_world;\n\t\tdebug_result.present = true;\n\n\t\t// Publish the pose error\n\t\tdebug_result_pub.publish(debug_result);\n\t}\n\telse {\n\t\t// Update the debug result to indicate failure\n\t\tdebug_result.present = false;\n\n\t\t// Publish the pose error\n\t\tdebug_result_pub.publish(debug_result);\n\t}\n}", "CodeBleu_score": 37.89604670838577}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (cameFrom.find(current)!= cameFrom.end()) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.04679189896778}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (cameFrom.find(current)!= cameFrom.end()) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.04679189896778}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (cameFrom.count(current)!= 0) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 70.87353730700183}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert the start and end points to grid indices.\n\tif (!ConvertToIndex(start_pt, start_idx) ||!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// If the start point is inside an obstacle, adjust it by moving it away from the end point until it is no longer inside an obstacle.\n\tif (IsInsideObstacle(start_idx)) {\n\t\tVector3d new_start_pt = start_pt;\n\t\tVector3d new_end_pt = end_pt;\n\t\twhile (IsInsideObstacle(start_idx)) {\n\t\t\tnew_start_pt.x() -= 0.001;\n\t\t\tnew_end_pt.x() += 0.001;\n\t\t\tif (!ConvertToIndex(new_start_pt, start_idx) ||!ConvertToIndex(new_end_pt, end_idx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tstart_pt = new_start_pt;\n\t\tend_pt = new_end_pt;\n\t}\n\n\t// If the end point is inside an obstacle, adjust it by moving it away from the start point until it is no longer inside an obstacle.\n\tif (IsInsideObstacle(end_idx)) {\n\t\tVector3d new_start_pt = start_pt;\n\t\tVector3d new_end_pt = end_pt;\n\t\twhile (IsInsideObstacle(end_idx)) {\n\t\t\tnew_start_pt.x() += 0.001;\n\t\t\tnew_end_pt.x() -= 0.001;\n\t\t\tif (!ConvertToIndex(new_start_pt, start_idx) ||!ConvertToIndex(new_end_pt, end_idx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tstart_pt = new_start_pt;\n\t\tend_pt = new_end_pt;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 47.608893553075646}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t", "CodeBleu_score": 2.802449016888383}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\tstart_idx = ConvertToIndex(start_pt);\n\tend_idx = ConvertToIndex(end_pt);\n\n\tif (start_idx.x < 0 || start_idx.x >= m_grid.size() || start_idx.y < 0 || start_idx.y >= m_grid[0].size() || start_idx.z < 0 || start_idx.z >= m_grid[0][0].size()) {\n\t\tstart_idx = Vector3i(-1, -1, -1);\n\t\treturn false;\n\t}\n\tif (end_idx.x < 0 || end_idx.x >= m_grid.size() || end_idx.y < 0 || end_idx.y >= m_grid[0].size() || end_idx.z < 0 || end_idx.z >= m_grid[0][0].size()) {\n\t\tend_idx = Vector3i(-1, -1, -1);\n\t\treturn false;\n\t}\n\n\tif (m_grid[start_idx.x][start_idx.y][start_idx.z] == 1) {\n\t\twhile (m_grid[start_idx.x][start_idx.y][start_idx.z] == 1) {\n\t\t\tstart_idx += Vector3i(1, 0, 0);\n\t\t}\n\t}\n\tif (m_grid[end_idx.x][end_idx.y][end_idx.z] == 1) {\n\t\twhile (m_grid[end_idx.x][end_idx.y][end_idx.z] == 1) {\n\t\t\tend_idx += Vector3i(1, 0, 0);\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 32.68943630847961}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = grid_map_to_grid_id(min_pos);\n\tEigen::Vector3i max_id = grid_map_to_grid_id(max_pos);\n\n\tfor (int i = min_id[0]; i <= max_id[0]; i++) {\n\t\tfor (int j = min_id[1]; j <= max_id[1]; j++) {\n\t\t\tfor (int k = min_id[2]; k <= max_id[2]; k++) {\n\t\t\t\toccupancy_buffer_inflate_[i][j][k] = 0;\n\t\t\t\tdistance_buffer_inflate_[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.23701771917895}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3d min_id = getGridIdFromWorldCoordinates(min_pos);\n\tEigen::Vector3d max_id = getGridIdFromWorldCoordinates(max_pos);\n\n\tfor (int i = min_id(0); i <= max_id(0); i++) {\n\t\tfor (int j = min_id(1); j <= max_id(1); j++) {\n\t\t\tfor (int k = min_id(2); k <= max_id(2); k++) {\n\t\t\t\tif (occupancy_buffer_inflate_(i, j, k) > 0) {\n\t\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 49.52890743491204}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3d min_id = grid_map::worldToMap(min_pos, resolution_, origin_);\n\tEigen::Vector3d max_id = grid_map::worldToMap(max_pos, resolution_, origin_);\n\tfor (int i = min_id(0); i <= max_id(0); i++) {\n\t\tfor (int j = min_id(1); j <= max_id(1); j++) {\n\t\t\tfor (int k = min_id(2); k <= max_id(2); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t\tdistance_buffer_inflate_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.228419548677266}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t", "CodeBleu_score": 4.826190268379092}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_pt = pt;\n\tEigen::Vector3d max_pt = pt;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tdouble min_scale = std::max(1.0, std::min(1.0, (double)min_pt(i) / diff(i)));\n\t\tdouble max_scale = std::max(1.0, std::min(1.0, (double)max_pt(i) / diff(i)));\n\t\tmin_pt(i) = min_scale * diff(i);\n\t\tmax_pt(i) = max_scale * diff(i);\n\t}\n\treturn min_pt;\n}", "CodeBleu_score": 39.07476060275542}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_pt = pt;\n\tEigen::Vector3d max_pt = pt;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff[i] > 0) {\n\t\t\tmin_pt[i] = pt[i] - (diff[i] / diff[i] - 1) * diff[i];\n\t\t\tmax_pt[i] = pt[i];\n\t\t} else {\n\t\t\tmin_pt[i] = pt[i];\n\t\t\tmax_pt[i] = pt[i] - (diff[i] / diff[i] - 1) * diff[i];\n\t\t}\n\t}\n\treturn min_pt;\n}", "CodeBleu_score": 37.246514938341605}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// update the last occupancy update time\n\tlastOccupancyUpdateTime = ros::Time::now();\n\n\t// check if an update is needed\n\tif (lastOccupancyUpdateTime - lastOccupancyUpdateCheckTime < ros::Duration(occupancyUpdateInterval)) {\n\t\treturn;\n\t}\n\tlastOccupancyUpdateCheckTime = lastOccupancyUpdateTime;\n\n\t// check if the odometry is valid\n\tif (odomValid) {\n\t\t// check if the depth image is valid\n\t\tif (depthValid) {\n\t\t\t// check if the local map has been updated\n\t\t\tif (localMapUpdated) {\n\t\t\t\t// clear the local map\n\t\t\t\tclearLocalMap();\n\n\t\t\t\t// inflate the local map\n\t\t\t\tinflateLocalMap();\n\t\t\t}\n\n\t\t\t// project the depth image into points\n\t\t\tprojectDepthImageIntoPoints();\n\n\t\t\t// process the points with raycasting\n\t\t\tprocessPointsWithRaycasting();\n\t\t}\n\t\telse {\n\t\t\t// set the depth image valid flag to false\n\t\t\tdepthValid = false;\n\n\t\t\t// set the odometry valid flag to false\n\t\t\todomValid = false;\n\t\t}\n\t}\n\telse {\n\t\t// set the odometry valid flag to false\n\t\todomValid = false;\n\t}\n}", "CodeBleu_score": 29.353646173211857}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tif (depthImage.image.width == 0 || depthImage.image.height == 0) {\n\t\tROS_WARN(\"No depth image received yet!\");\n\t\treturn;\n\t}\n\n\tif (odometry.header.stamp < lastOccupancyUpdateTime + ros::Duration(0.1)) {\n\t\treturn;\n\t}\n\n\tlastOccupancyUpdateTime = ros::Time::now();\n\n\t// Project the depth image into points\n\tstd::vector<Point> points;\n\tif (!projectDepthImageIntoPoints(points)) {\n\t\treturn;\n\t}\n\n\t// Process the points\n\tstd::vector<Point> processedPoints;\n\tif (!processPoints(points, processedPoints)) {\n\t\treturn;\n\t}\n\n\t// Clear and inflate the local map\n\tclearLocalMap();\n\tinflateLocalMap(processedPoints);\n\n\t// Set the local map as the current map\n\tsetCurrentMap(localMap);\n\n\t// Set the occupancy grid as the current map\n\tsetCurrentMap(occupancyMap);\n\n\t// Set the occupancy grid as the current map\n\tsetCurrentMap(occupancyMap);\n\n\t// Set the map as the current map\n\tsetCurrentMap(map);\n\n\t// Set the map as the current map\n\tsetCurrentMap(map);\n}", "CodeBleu_score": 30.71804402854042}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update last occupancy update time\n\tlastOccupancyUpdateTime = ros::Time::now();\n\n\t// If no sensor data is available, return\n\tif (!depthImage.image.data.size())\n\t\treturn;\n\n\t// If no odometry data is available, return\n\tif (!odometry.data.size())\n\t\treturn;\n\n\t// If no local map is available, return\n\tif (!localMap.image.data.size())\n\t\treturn;\n\n\t// If the local map has not been updated, return\n\tif (!localMapUpdated)\n\t\treturn;\n\n\t// Clear local map\n\tlocalMap.image.data.clear();\n\n\t// Project depth image into points\n\tstd::vector<geometry_msgs::Point> points;\n\tprojectDepthImageIntoPoints(points);\n\n\t// If no points are available, return\n\tif (!points.size())\n\t\treturn;\n\n\t// Raycast points\n\tstd::vector<geometry_msgs::Point> raycastedPoints;\n\traycastPoints(points, raycastedPoints);\n\n\t// If no raycasted points are available, return\n\tif (!raycastedPoints.size())\n\t\treturn;\n\n\t// Update local map\n\tupdateLocalMap(raycastedPoints);\n\n\t// Clear local map\n\tlocalMap.image.data.clear();\n\n\t// Inflate local map\n\tinflateLocalMap();\n\n\t// Reset local map updated flag\n\tlocalMapUpdated = false;\n}", "CodeBleu_score": 32.9565649332663}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat avg_fmeasure = 0.f;\n\tfor (unsigned int i = 0; i < image_fns.size(); ++i) {\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\t\tMat img = imread(image_fns[i]);\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\t\tavg_fmeasure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t}\n\treturn avg_fmeasure / float(image_fns.size());\n}", "CodeBleu_score": 60.96012527962724}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure_sum = 0.f;\n\tfor (unsigned int i = 0; i < image_fns.size(); ++i) {\n\t\tMat img = imread(image_fns[i]);\n\t\tif (!img.data) {\n\t\t\tcout << \"Error reading image: \" << image_fns[i] << endl;\n\t\t\treturn 0.f;\n\t\t}\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t\tfmeasure_sum += fmeasure;\n\t}\n\n\treturn fmeasure_sum / float(image_fns.size());\n}", "CodeBleu_score": 58.689401623819606}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure = 0.f;\n\tunsigned n = image_fns.size();\n\tfor (unsigned i = 0; i < n; ++i) {\n\t\tstring image_fn = image_fns[i];\n\t\tstring gt_fn = gt_fns[i];\n\t\tstring dt_fn = dt_fns[i];\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fn, gt_ellipses, gt_angle_radians);\n\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fn, dt_ellipses, gt_angle_radians);\n\n\t\tMat3b img = imread(image_fn);\n\n\t\tfloat fmeasure_one = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t\tfmeasure += fmeasure_one;\n\t}\n\tfmeasure /= n;\n\treturn fmeasure;\n}", "CodeBleu_score": 51.35867602341823}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_diff_signed;\n\tif (foci!= NULL) {\n\t\tfloat angle_diff_a = angle_diff_signed(atan2(y, x), atan2(foci[1], foci[0]));\n\t\tfloat angle_diff_b = angle_diff_signed(atan2(y, x), atan2(foci[3], foci[2]));\n\t\tangle_diff_signed = angle_diff_a - angle_diff_b;\n\t\twhile (angle_diff_signed <= -M_PI) angle_diff_signed += M_2__PI;\n\t\twhile (angle_diff_signed >   M_PI) angle_diff_signed -= M_2__PI;\n\t\treturn angle_diff_signed;\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 43.251311160555964}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_diff_signed;\n\tfloat angle_diff;\n\tfloat angle;\n\tfloat angle_f1;\n\tfloat angle_f2;\n\n\tif (foci == NULL) {\n\t\treturn 0.0f;\n\t}\n\n\tangle_f1 = atan2(y - foci[1], x - foci[0]);\n\tangle_f2 = atan2(y - foci[3], x - foci[2]);\n\tangle_diff = angle_f1 - angle_f2;\n\tangle_diff_signed = angle_diff_signed(angle_f1, angle_f2);\n\tangle = angle_diff_signed;\n\n\treturn angle;\n}", "CodeBleu_score": 53.17725774289468}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a = foci[0];\n\tfloat b = foci[1];\n\tfloat angle_diff_signed = angle_diff_signed(atan2f(y, x), atan2f(b, a));\n\tif (angle_diff_signed < 0) {\n\t\tangle_diff_signed += M_2__PI;\n\t}\n\treturn angle_diff_signed;\n}", "CodeBleu_score": 25.630268401995547}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tdouble integral_above = 0.0;\n\tdouble integral_below = 0.0;\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x) {\n\t\t\tmin_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > max_x) {\n\t\t\tmax_x = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < min_y) {\n\t\t\tmin_y = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > max_y) {\n\t\t\tmax_y = vp1[i].y;\n\t\t}\n\t\tintegral_above += (vp1[i].x * vp1[i + 1].y) - (vp1[i + 1].x * vp1[i].y);\n\t\tintegral_below += (vp1[i].x * vp1[i + 1].y) - (vp1[i + 1].x * vp1[i].y);\n\t}\n\tintegral_above = integral_above / 2.0;\n\tintegral_below = integral_below / 2.0;\n\tif (integral_above < integral_below) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 35.43091695190127}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t//ROS_INFO(\"In ellipse_det_cb\");\n\t//ROS_INFO(\"msg->detections.size() = %d\", msg->detections.size());\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\t//ROS_INFO(\"msg->detections[%d].name = %s\", i, msg->detections[i].name.c_str());\n\t\tif (msg->detections[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t} else if (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t}\n\tif (msg->detections.size() > 0) {\n\t\t//ROS_INFO(\"msg->detections[0].name = %s\", msg->detections[0].name.c_str());\n\t\t//ROS_INFO(\"msg->detections[0].sight_angle = %f\", msg->detections[0].sight_angle);\n\t\tif (msg->detections[0].name == \"T\") {\n\t\t\tellipse_det.sight_angle = msg->detections[0].sight_angle;\n\t\t\tellipse_det.is_detected = true;\n\t\t} else {\n\t\t\tellipse_det.sight_angle = 0;\n\t\t\tellipse_det.is_detected = false;\n\t\t}\n\t} else {\n\t\tellipse_det.sight_angle = 0;\n\t\tellipse_det.is_detected = false;\n\t}\n\t//ROS_INFO(\"ellipse_det.sight_angle = %f\", ellipse_det.sight_angle);\n\t//ROS_INFO(\"ellipse_det.is_detected = %d\", ellipse_det.is_detected);\n}", "CodeBleu_score": 61.895918021104954}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tEigen::Vector3d pos_to_check = cur_pos;\n\tpos_to_check(2) = 0;\n\treturn Occupy_map_ptr->check_safety(pos_to_check, safe_distance);\n}", "CodeBleu_score": 52.55621132885775}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tdouble dist_x = cur_pos[0] - Occupy_map_ptr->get_x_center();\n\tdouble dist_y = cur_pos[1] - Occupy_map_ptr->get_y_center();\n\tdouble dist_z = cur_pos[2] - Occupy_map_ptr->get_z_center();\n\tdouble dist_total = sqrt(dist_x*dist_x + dist_y*dist_y + dist_z*dist_z);\n\tif (dist_total > safe_distance) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 41.51651221115348}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t//std::cout << \"Checking safety of \" << cur_pos.transpose() << std::endl;\n\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.63250389573369}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_front(current_node);\n\t\tcurrent_node = current_node->parent_;\n\t}\n}", "CodeBleu_score": 37.083009794644404}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_front(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 58.33524190180429}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent_;\n\t}\n\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 52.56319380083464}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\t//ROS_INFO(\"nei_odom_cb %d\", id);\n\n\tif (odom->pose.pose.position.x == 0 && odom->pose.pose.position.y == 0 && odom->pose.pose.position.z == 0) {\n\t\t//ROS_INFO(\"nei_odom_cb %d\", id);\n\t\treturn;\n\t}\n\n\t//ROS_INFO(\"nei_odom_cb %d\", id);\n\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\n\t//ROS_INFO(\"nei_odom_cb %d\", id);\n\n\tif (sim_mode) {\n\t\t//ROS_INFO(\"nei_odom_cb %d\", id);\n\t\tif (sqrt(pow(state_nei[id].x - start_pos.x, 2) + pow(state_nei[id].y - start_pos.y, 2)) > 5) {\n\t\t\t//ROS_INFO(\"nei_odom_cb %d\", id);\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\t//ROS_INFO(\"nei_odom_cb %d\", id);\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n\n\t//ROS_INFO(\"nei_odom_cb %d\", id);\n}", "CodeBleu_score": 52.60650051824871}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"UGV %d: nei_odom_cb\", id);\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\n\tdouble dist = sqrt(pow(state_nei[id].x - state_me.x, 2) + pow(state_nei[id].y - state_me.y, 2) + pow(state_nei[id].z - state_me.z, 2));\n\t//ROS_INFO(\"UGV %d: nei_odom_cb: dist = %f\", id, dist);\n\tif (dist > 5) {\n\t\tget_nei_state[id] = false;\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 43.710876199565384}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\tif (id >= 0) {\n\t\tif (id == 0) {\n\t\t\t//ROS_INFO(\"nei_odom_cb\");\n\t\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\t\t\tstate_nei[id].y = odom->pose.pose.position.y;\n\t\t\tstate_nei[id].z = odom->pose.pose.position.z;\n\t\t\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\t\t\tif (sim_mode) {\n\t\t\t\tif (sqrt(pow(state_nei[id].x - start_x, 2) + pow(state_nei[id].y - start_y, 2)) > 5) {\n\t\t\t\t\tget_nei_state[id] = false;\n\t\t\t\t} else {\n\t\t\t\t\tget_nei_state[id] = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tget_nei_state[id] = true;\n\t\t\t}\n\t\t} else {\n\t\t\tstate_nei[id].x = odom->pose.pose.position.x;\n\t\t\tstate_nei[id].y = odom->pose.pose.position.y;\n\t\t\tstate_nei[id].z = odom->pose.pose.position.z;\n\t\t\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\t\t\tif (sim_mode) {\n\t\t\t\tif (sqrt(pow(state_nei[id].x - start_x, 2) + pow(state_nei[id].y - start_y, 2)) > 5) {\n\t\t\t\t\tget_nei_state[id] = false;\n\t\t\t\t} else {\n\t\t\t\t\tget_nei_state[id] = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tget_nei_state[id] = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 51.69218459077225}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odom_ready == true) {\n\t\tsensor_ready = true;\n\t\tupdate_count++;\n\t}\n}", "CodeBleu_score": 10.385344420609455}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tupdate_counter++;\n\t\tif (update_counter >= 5) {\n\t\t\tupdate_counter = 0;\n\t\t\t//ROS_INFO(\"UGV: updating map with new point cloud data\");\n\t\t\tupdate_map(msg);\n\t\t}\n\t}\n}", "CodeBleu_score": 38.554726876788045}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (odom_ready) {\n\t\tsensor_ready = true;\n\t\tupdate_counter++;\n\t}\n}", "CodeBleu_score": 10.221413240641407}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl) {\n\t\t//ROS_INFO(\"global point cloud received\");\n\t\tget_gpcl = false;\n\t\t//convert sensor_msgs::PointCloud2 to pcl::PointCloud<pcl::PointXYZ>\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(*global_point, *cloud);\n\t\t//ROS_INFO(\"global point cloud converted\");\n\t\t//store the point cloud\n\t\tgpcl = cloud;\n\t\t//ROS_INFO(\"global point cloud stored\");\n\t\t//inflate the point cloud\n\t\tinflate_pcl(gpcl);\n\t\t//ROS_INFO(\"global point cloud inflated\");\n\t}\n}", "CodeBleu_score": 48.40658147030808}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t//if in simulation mode, only use local map\n\tif (simulation_mode) {\n\t\tmap_update_laser_sim(local_point, odom);\n\t} else {\n\t\tmap_update_laser_real(local_point, odom);\n\t}\n}", "CodeBleu_score": 29.499049304197012}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\tif (local_point->ranges.size() == 0) {\n\t\tROS_WARN(\"No laser scan data received.\");\n\t\treturn;\n\t}\n\n\t// Convert to PointCloud2\n\tpcl::PointCloud<pcl::PointXYZ> laser_scan;\n\tpcl::fromROSMsg(*local_point, laser_scan);\n\n\t// Convert to PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> laser_scan_pcl;\n\tpcl::copyPointCloud(laser_scan, laser_scan_pcl);\n\n\t// Transform to map frame\n\tpcl_ros::transformPointCloud(map_frame_, laser_scan_pcl, laser_scan_pcl);\n\n\t// Project to map\n\tpcl::PointCloud<pcl::PointXYZ> map_points;\n\tpcl::ProjectInliers<pcl::PointXYZ> proj;\n\tproj.setModelType(pcl::SACMODEL_PLANE);\n\tproj.setInputCloud(laser_scan_pcl.makeShared());\n\tproj.setModelCoefficients(boost::make_shared<pcl::ModelCoefficients>(pcl::ModelCoefficients(1, 0, 0, 0)));\n\tproj.filter(map_points);\n\n\t// Merge with local map\n\tif (!simulation_mode_) {\n\t\tpcl::PointCloud<pcl::PointXYZ> merged_map;\n\t\tpcl::transformPointCloud(odom.pose.pose, map_points, merged_map);\n\t\tmerged_map += local_map_;\n\t\tlocal_map_ = merged_map;\n\t}\n\n\t// Update occupancy map\n\tpcl::VoxelGrid<pcl::PointXYZ> downsample;\n\tdownsample.setInputCloud(local_map_.makeShared());\n\tdownsample.setLeafSize(resolution_, resolution_, resolution_);\n\tdownsample.filter(local_map_);\n\n\tpcl::PointCloud<pcl::PointXYZ> map_pcl;\n\tpcl::copyPointCloud(local_map_, map_pcl);\n\tpcl::toROSMsg(map_pcl, map_msg_);\n\tmap_msg_.header.frame_id = map_frame_;\n\tmap_msg_.header.stamp = ros::Time::now();\n\tmap_pub_.publish(map_msg_);\n}", "CodeBleu_score": 41.231383869337705}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert global point cloud to ROS message\n\tpcl::PointCloud<pcl::PointXYZI> ros_msg;\n\tpcl::copyPointCloud(*global_map, ros_msg);\n\n\t// Publish the global point cloud\n\tglobal_pcl_pub.publish(ros_msg);\n\n\t// Convert inflated point cloud to ROS message\n\tpcl::PointCloud<pcl::PointXYZI> ros_msg_inflate;\n\tpcl::copyPointCloud(*inflate_map, ros_msg_inflate);\n\n\t// Publish the inflated point cloud\n\tinflate_pcl_pub.publish(ros_msg_inflate);\n}", "CodeBleu_score": 43.62420738245518}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert the global point cloud map to a ROS message and publish it to the global_pcl_pub topic\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr global_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr inflate_pcl(new pcl::PointCloud<pcl::PointXYZ>);\n\tfor (int i = 0; i < map_size_x; i++) {\n\t\tfor (int j = 0; j < map_size_y; j++) {\n\t\t\tif (occupancy_grid[i][j] == 0) {\n\t\t\t\tglobal_pcl->push_back(pcl::PointXYZ(i, j, 0));\n\t\t\t\tinflate_pcl->push_back(pcl::PointXYZ(i, j, 0));\n\t\t\t} else {\n\t\t\t\tglobal_pcl->push_back(pcl::PointXYZ(i, j, 1));\n\t\t\t\tinflate_pcl->push_back(pcl::PointXYZ(i, j, 1));\n\t\t\t}\n\t\t}\n\t}\n\tpcl::toROSMsg(*global_pcl, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\tpcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 56.21513999242651}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert the global point cloud map to a ROS message\n\tpcl::PointCloud<pcl::PointXYZ> pcl_msg;\n\tpcl_msg.header.frame_id = \"world\";\n\tpcl_msg.header.stamp = ros::Time::now();\n\tpcl_msg.width = map_width;\n\tpcl_msg.height = map_height;\n\tpcl_msg.is_dense = false;\n\tpcl_msg.points.resize(map_width * map_height);\n\tfor (int i = 0; i < map_width * map_height; i++) {\n\t\tpcl_msg.points[i].x = map_data[i].x;\n\t\tpcl_msg.points[i].y = map_data[i].y;\n\t\tpcl_msg.points[i].z = map_data[i].z;\n\t}\n\n\t// Publish the global point cloud map\n\tglobal_pcl_pub.publish(pcl_msg);\n\n\t// Convert the inflated point cloud map to a ROS message\n\tpcl::PointCloud<pcl::PointXYZ> inflate_pcl_msg;\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\tinflate_pcl_msg.width = map_width;\n\tinflate_pcl_msg.height = map_height;\n\tinflate_pcl_msg.is_dense = false;\n\tinflate_pcl_msg.points.resize(map_width * map_height);\n\tfor (int i = 0; i < map_width * map_height; i++) {\n\t\tinflate_pcl_msg.points[i].x = inflate_map_data[i].x;\n\t\tinflate_pcl_msg.points[i].y = inflate_map_data[i].y;\n\t\tinflate_pcl_msg.points[i].z = inflate_map_data[i].z;\n\t}\n\n\t// Publish the inflated point cloud map\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 48.603303086467456}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t/Calculate target foot positions\n\tbase_.calculateTargetFootPositions(desired_pose_);\n\n\t//Compute velocities for the legs\n\tbase_.computeLegVelocities(desired_pose_);\n\n\t//Compute target joint positions\n\tbase_.computeLegJointPositions(desired_pose_);\n\n\t//Publish foot contacts and joint positions\n\tpublishFootContacts_(base_.foot_contacts);\n\tpublishJoints_(base_.target_joints);\n}", "CodeBleu_score": 31.67961175448861}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0) {\n\t\t// Create a message\n\t\tgeometry_msgs::WrenchStamped wrench_msg;\n\t\twrench_msg.header.stamp = ros::Time::now();\n\t\twrench_msg.wrench.force.x = 0.0;\n\t\twrench_msg.wrench.force.y = 0.0;\n\t\twrench_msg.wrench.force.z = 0.0;\n\t\twrench_msg.wrench.torque.x = 0.0;\n\t\twrench_msg.wrench.torque.y = 0.0;\n\t\twrench_msg.wrench.torque.z = 0.0;\n\n\t\t// Populate the message\n\t\tfor (int leg_index = 0; leg_index < 4; leg_index++) {\n\t\t\tif (foot_contacts[leg_index]) {\n\t\t\t\twrench_msg.wrench.force.x = 1.0;\n\t\t\t\twrench_msg.wrench.torque.x = 1.0;\n\t\t\t}\n\t\t}\n\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_.publish(wrench_msg);\n\t}\n}", "CodeBleu_score": 33.112232256145155}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_.getNumSubscribers() > 0 &&!gazebo_) {\n\t\tgeometry_msgs::WrenchStamped wrench_msg;\n\t\twrench_msg.header.stamp = ros::Time::now();\n\t\twrench_msg.wrench.force.x = 0.0;\n\t\twrench_msg.wrench.force.y = 0.0;\n\t\twrench_msg.wrench.force.z = 0.0;\n\t\twrench_msg.wrench.torque.x = 0.0;\n\t\twrench_msg.wrench.torque.y = 0.0;\n\t\twrench_msg.wrench.torque.z = 0.0;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (foot_contacts[i]) {\n\t\t\t\twrench_msg.wrench.force.x += 1.0;\n\t\t\t\twrench_msg.wrench.torque.y += 1.0;\n\t\t\t}\n\t\t}\n\n\t\tfoot_contacts_publisher_.publish(wrench_msg);\n\t}\n}", "CodeBleu_score": 41.682641751573335}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (foot_contacts_publisher_ == nullptr) {\n\t\tROS_INFO(\"Foot contacts publisher is not initialized.\");\n\t\treturn;\n\t}\n\n\tif (!is_gazebo_) {\n\t\t// Only publish foot contacts if the robot is not in Gazebo\n\t\t// Create message\n\t\tgeometry_msgs::Wrench wrench;\n\t\twrench.force.x = 0.0;\n\t\twrench.force.y = 0.0;\n\t\twrench.force.z = 0.0;\n\t\twrench.torque.x = 0.0;\n\t\twrench.torque.y = 0.0;\n\t\twrench.torque.z = 0.0;\n\n\t\t// Populate message\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (foot_contacts[i]) {\n\t\t\t\twrench.force.x = 1.0;\n\t\t\t\twrench.force.y = 1.0;\n\t\t\t\twrench.force.z = 1.0;\n\t\t\t}\n\t\t}\n\n\t\t// Publish message\n\t\tfoot_contacts_publisher_->publish(wrench);\n\t}\n}", "CodeBleu_score": 36.853227876181805}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t", "CodeBleu_score": 0.0}, {"code": "def joints_cmd_callback(self, joints){\n\t", "CodeBleu_score": 0.0}, {"code": "def joints_cmd_callback(self, joints){\n\t", "CodeBleu_score": 0.0}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t//std::cout << _msg->contact(i).collision1() << std::endl;\n\t\t//std::cout << _msg->contact(i).collision2() << std::endl;\n\t\t//std::cout << _msg->contact(i).collision1().substr(0, 6) << std::endl;\n\t\t//std::cout << _msg->contact(i).collision2().substr(0, 6) << std::endl;\n\t\tif (_msg->contact(i).collision1().substr(0, 6) == \"foot_l\" || _msg->contact(i).collision2().substr(0, 6) == \"foot_l\") {\n\t\t\tfoot_l_contact = true;\n\t\t}\n\t\tif (_msg->contact(i).collision1().substr(0, 6) == \"foot_r\" || _msg->contact(i).collision2().substr(0, 6) == \"foot_r\") {\n\t\t\tfoot_r_contact = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 31.889926117326773}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t//ROS_INFO(\"Gazebo Callback\");\n\tfor (unsigned int i = 0; i < _msg->contact_size(); i++) {\n\t\t//ROS_INFO(\"Gazebo Callback: contact %d\", i);\n\t\tstd::string collisionName = _msg->contact(i).collision1();\n\t\tstd::string contactName = _msg->contact(i).collision2();\n\t\tstd::string contactLink = \"\";\n\t\tstd::string footLink = \"\";\n\t\tif (collisionName.find(\"foot\")!= std::string::npos) {\n\t\t\tcontactLink = collisionName;\n\t\t\tfootLink = contactName;\n\t\t} else {\n\t\t\tcontactLink = contactName;\n\t\t\tfootLink = collisionName;\n\t\t}\n\t\t//ROS_INFO(\"Gazebo Callback: contact %d: %s, %s\", i, contactLink.c_str(), footLink.c_str());\n\t\tif (contactLink.find(footLink)!= std::string::npos) {\n\t\t\t//ROS_INFO(\"Gazebo Callback: contact %d: %s, %s\", i, contactLink.c_str(), footLink.c_str());\n\t\t\tif (footLink == \"right_foot_link\") {\n\t\t\t\trightFootContact = true;\n\t\t\t} else if (footLink == \"left_foot_link\") {\n\t\t\t\tleftFootContact = true;\n\t\t\t} else {\n\t\t\t\tROS_WARN(\"Gazebo Callback: contact %d: %s, %s\", i, contactLink.c_str(), footLink.c_str());\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.675734069197496}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\t//ROS_INFO(\"Gazebo callback called\");\n\t//ROS_INFO(\"Contact size: %d\", _msg->contact_size());\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t//ROS_INFO(\"Contact %d: %s\", i, _msg->contact(i).collision1().c_str());\n\t\tif (_msg->contact(i).collision1().find(\"foot_left\")!= std::string::npos) {\n\t\t\tROS_INFO(\"Contact %d: %s\", i, _msg->contact(i).collision1().c_str());\n\t\t\tfoot_contact_left_ = true;\n\t\t}\n\t\tif (_msg->contact(i).collision1().find(\"foot_right\")!= std::string::npos) {\n\t\t\tROS_INFO(\"Contact %d: %s\", i, _msg->contact(i).collision1().c_str());\n\t\t\tfoot_contact_right_ = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.91237630670711}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\tif (!active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\tEigen::Vector3d acceleration;\n\tComputeDesiredAcceleration(&acceleration);\n\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n\tEigen::Vector3d thrust_body_frame;\n\tthrust_body_frame = acceleration.dot(Eigen::Vector3d::UnitZ()) * Eigen::Vector3d::UnitZ();\n\n\tEigen::Vector3d angular_acceleration_body_frame;\n\tangular_acceleration_body_frame = angular_acceleration.dot(Eigen::Vector3d::UnitZ()) * Eigen::Vector3d::UnitZ();\n\n\tEigen::Vector3d rotor_velocities_body_frame;\n\trotor_velocities_body_frame = thrust_body_frame + angular_acceleration_body_frame;\n\n\trotor_velocities->setZero();\n\trotor_velocities->segment(0, 3) = rotor_velocities_body_frame;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (rotor_velocities->coeffRef(i) < 0) {\n\t\t\trotor_velocities->coeffRef(i) = 0;\n\t\t}\n\t}\n\n\trotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 58.73584323929415}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\tif (!is_active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\tEigen::Vector3d acceleration;\n\tComputeDesiredAcceleration(&acceleration);\n\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n\tEigen::Vector3d thrust = acceleration.cwiseProduct(normalized_attitude_gain_) + angular_acceleration;\n\tEigen::Vector3d thrust_body = odometry_.orientation.toRotationMatrix() * thrust;\n\n\tEigen::Vector3d thrust_body_z_axis = thrust_body.cwiseProduct(normalized_attitude_gain_);\n\n\tEigen::Vector3d rotor_velocities_body;\n\trotor_velocities_body = thrust_body_z_axis.cwiseProduct(rotor_velocities_matrix_);\n\trotor_velocities_body.cwiseAbs();\n\trotor_velocities_body.cwiseSqrt();\n\n\tEigen::Vector3d rotor_velocities_body_z_axis = rotor_velocities_body.cwiseProduct(normalized_attitude_gain_);\n\tEigen::Vector3d rotor_velocities_body_x_axis = rotor_velocities_body.cwiseProduct(normalized_angular_rate_gain_);\n\n\trotor_velocities->setZero();\n\trotor_velocities->segment(0, 3) = rotor_velocities_body_z_axis;\n\trotor_velocities->segment(3, 3) = rotor_velocities_body_x_axis;\n}", "CodeBleu_score": 52.933451879820126}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 2.947191336884822}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d world_velocity;\n\tEigen::Vector3d world_position;\n\tEigen::Vector3d world_acceleration;\n\n\t// Get the current odometry data\n\tconst Eigen::Vector3d& position = odometry_.position();\n\tconst Eigen::Vector3d& velocity = odometry_.velocity();\n\n\t// Get the current world position and velocity\n\tworld_position = position;\n\tworld_velocity = velocity;\n\n\t// Get the commanded acceleration\n\tconst Eigen::Vector3d& commanded_acceleration = commanded_acceleration_;\n\n\t// Transform the vehicle's velocity to the world frame\n\tworld_velocity = world_velocity_transform_ * world_velocity;\n\n\t// Calculate the position error\n\tconst Eigen::Vector3d& position_error = position_error_;\n\n\t// Calculate the velocity error\n\tconst Eigen::Vector3d& velocity_error = velocity_error_;\n\n\t// Calculate the desired acceleration\n\tconst Eigen::Vector3d& desired_acceleration = desired_acceleration_;\n\tworld_acceleration = desired_acceleration;\n\n\t// Add the position and velocity gains to the desired acceleration\n\tworld_acceleration = world_acceleration + position_gain_ * position_error + velocity_gain_ * velocity_error;\n\n\t// Adjust for vehicle mass, gravity, and the commanded acceleration\n\tworld_acceleration = world_acceleration + mass_ * gravity_ * commanded_acceleration;\n\n\t// Transform the desired acceleration back to the vehicle frame\n\t*acceleration = world_velocity_transform_.transpose() * world_acceleration;\n}", "CodeBleu_score": 45.21560334149725}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d commandedAcceleration = Eigen::Vector3d(0, 0, 0);\n\tEigen::Vector3d positionError = Eigen::Vector3d(0, 0, 0);\n\tEigen::Vector3d velocityError = Eigen::Vector3d(0, 0, 0);\n\tEigen::Vector3d velocity = Eigen::Vector3d(0, 0, 0);\n\tEigen::Vector3d velocityWorld = Eigen::Vector3d(0, 0, 0);\n\tEigen::Vector3d accelerationWorld = Eigen::Vector3d(0, 0, 0);\n\tEigen::Vector3d accelerationWorldDesired = Eigen::Vector3d(0, 0, 0);\n\tEigen::Vector3d accelerationWorldDesiredFinal = Eigen::Vector3d(0, 0, 0);\n\tEigen::Vector3d accelerationWorldDesiredFinalFinal = Eigen::Vector3d(0, 0, 0);\n\tEigen::Vector3d accelerationWorldDesiredFinalFinalFinal = Eigen::Vector3d(0, 0, 0);\n\tEigen::Vector3d accelerationWorldDesiredFinalFinalFinalFinal = Eigen::Vector3d(0, 0, 0);\n\n\t// Compute position error\n\tpositionError = (trajectory_.GetPosition() - odometry_.GetPosition());\n\n\t// Compute velocity error\n\tvelocity = odometry_.GetVelocity();\n\tvelocityWorld = world_.TransformToWorld(velocity);\n\tvelocityError = (trajectory_.GetVelocity() - velocityWorld);\n\n\t// Compute acceleration\n\taccelerationWorldDesired = (positionGains_.GetGain() * positionError) + (velocityGains_.GetGain() * velocityError);\n\taccelerationWorldDesiredFinal = (accelerationWorldDesired / (mass_ + commandedAcceleration.norm()));\n\taccelerationWorldDesiredFinalFinal = (accelerationWorldDesiredFinal + gravity_);\n\taccelerationWorldDesiredFinalFinalFinal = (accelerationWorldDesiredFinalFinal + commandedAcceleration);\n\n\t// Transform acceleration to world frame\n\taccelerationWorld = world_.TransformToWorld(accelerationWorldDesiredFinalFinalFinal);\n\n\t// Assign acceleration\n\t*acceleration = accelerationWorld;\n}", "CodeBleu_score": 41.63342729254681}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\tEigen::Vector3d commanded_acceleration;\n\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d acceleration_error;\n\tEigen::Vector3d desired_acceleration;\n\tEigen::Vector3d desired_acceleration_world;\n\n\t// Compute position and velocity errors\n\tposition_error = commanded_trajectory_.Position() - odometry_.Position();\n\tvelocity_error = commanded_trajectory_.Velocity() - odometry_.Velocity();\n\n\t// Compute acceleration errors\n\tacceleration_error = commanded_trajectory_.Acceleration() - odometry_.Acceleration();\n\n\t// Compute desired acceleration\n\tcommanded_acceleration = commanded_trajectory_.Acceleration();\n\tdesired_acceleration = commanded_acceleration + position_error * position_gain_ + velocity_error * velocity_gain_ + acceleration_error * acceleration_gain_;\n\n\t// Transform desired acceleration to world frame\n\tdesired_acceleration_world = odometry_.Rotation().transpose() * desired_acceleration;\n\n\t// Set acceleration\n\t*acceleration = desired_acceleration_world;\n}", "CodeBleu_score": 46.44933731313336}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\t// check input\n\tassert(rotor_velocities->size() == num_rotors_);\n\n\t// resize output\n\trotor_velocities->resize(num_rotors_);\n\n\t// compute desired angular acceleration\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\t// compute rotor velocities\n\tEigen::Matrix3d rotor_velocities_matrix;\n\trotor_velocities_matrix << 0, -angular_acceleration(2), angular_acceleration(1),\n\t\tangular_acceleration(2), 0, -angular_acceleration(0),\n\t\t-angular_acceleration(1), angular_acceleration(0), 0;\n\trotor_velocities->array() = sqrt(rotor_velocities_matrix.array().square().sum(1)).array().max(1.0);\n}", "CodeBleu_score": 49.60404925514491}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\t// check if the input is valid\n\tif (rotor_velocities->size()!= num_rotors_) {\n\t\tthrow std::runtime_error(\"Rotor velocities vector is not the correct size\");\n\t}\n\n\t// compute the desired angular acceleration\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\t// compute the rotor velocities\n\tEigen::Vector3d rotor_velocities_unscaled;\n\trotor_velocities_unscaled = Eigen::Vector3d(angular_acceleration[0], angular_acceleration[1], angular_acceleration[2])\n\t\t+ thrust_reference_.cwiseProduct(Eigen::Vector3d::Ones());\n\trotor_velocities_unscaled.array() = rotor_velocities_unscaled.array().max(1.0); // ensure minimum of 1\n\trotor_velocities_unscaled.array() = rotor_velocities_unscaled.array().sqrt();\n\n\t// scale the rotor velocities\n\t*rotor_velocities = rotor_velocities_unscaled.cwiseProduct(rotor_velocities_scaling_factor_);\n}", "CodeBleu_score": 46.075752143233}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t", "CodeBleu_score": 3.965771277166072}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    sliced_object = copy.deepcopy(self)\n    sliced_object.time = self.time[start_index:end_index]\n    sliced_object.value = self.value[start_index:end_index]\n    return sliced_object", "CodeBleu_score": 32.97337211632296}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    if start_index == 0:\n        start_index = 1\n    if end_index == len(self.time):\n        end_index -= 1\n    copied_object = copy.deepcopy(self)\n    copied_object.time = copied_object.time[start_index:end_index]\n    copied_object.value = copied_object.value[start_index:end_index]\n    copied_object.error = copied_object.error[start_index:end_index]\n    copied_object.units = copied_object.units[start_index:end_index]\n    return copied_object", "CodeBleu_score": 50.91697562047736}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    if start_index == 0:\n        start_index = 1\n    if end_index == 0:\n        end_index = 1\n    new_obj = copy.deepcopy(self)\n    new_obj.time = new_obj.time[start_index:end_index]\n    new_obj.values = new_obj.values[start_index:end_index]\n    return new_obj", "CodeBleu_score": 31.465157876998422}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if self.append_point(waypoint_msg.pose.pose.position):\n        self.append_yaw(waypoint_msg.pose.pose.orientation)\n        self.append_times(msg_time, bag_time)\n", "CodeBleu_score": 10.477252724437664}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    point = Point()\n    point.append_point(waypoint_msg)\n    point.append_times(msg_time, bag_time)\n    yaw = waypoint_msg.pose.pose.orientation.w\n    if self.yaw is None:\n        self.yaw = yaw\n        return\n    elif yaw!= self.yaw:\n        self.points.append(point)\n        self.yaw = yaw\n\n", "CodeBleu_score": 14.413346251839007}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    if len(self.x) > 0:\n        if waypoint_msg.position.x!= self.x[-1] or waypoint_msg.position.y!= self.y[-1] or waypoint_msg.position.z!= self.z[-1] or waypoint_msg.yaw!= self.yaw[-1]:\n            point = Point()\n            point.append_point(waypoint_msg)\n            point.append_times(msg_time, bag_time)\n            self.append_point(point)\n            self.yaw = numpy.append(self.yaw, waypoint_msg.yaw)\n    else:\n        point = Point()\n        point.append_point(waypoint_msg)\n        point.append_times(msg_time, bag_time)\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, waypoint_msg.yaw)\n\n", "CodeBleu_score": 31.647641804860903}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.imu_topic:\n        self.acc_x = numpy.append(self.acc_x, msg.linear_acceleration.x)\n        self.acc_y = numpy.append(self.acc_y, msg.linear_acceleration.y)\n        self.acc_z = numpy.append(self.acc_z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 34.542314443086205}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.accel_x.append_times(msg.linear_acceleration.x, bag_time)\n        self.accel_y.append_times(msg.linear_acceleration.y, bag_time)\n        self.accel_z.append_times(msg.linear_acceleration.z, bag_time)\n\n", "CodeBleu_score": 24.23324255744177}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_x = numpy.append(self.imu_x, msg.linear_acceleration.x)\n        self.imu_y = numpy.append(self.imu_y, msg.linear_acceleration.y)\n        self.imu_z = numpy.append(self.imu_z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 33.71022040044694}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create figure and subplots\n    fig, axs = plt.subplots(3, 1, figsize=(10, 10))\n    fig.suptitle('Accelerations')\n\n    # Plot x, y, and z components of acceleration data\n    axs[0].plot(self.accel_x, label='x')\n    axs[0].plot(self.accel_y, label='y')\n    axs[0].plot(self.accel_z, label='z')\n    axs[0].set_xlabel('Time (s)')\n    axs[0].set_ylabel('Acceleration (g)')\n    axs[0].legend()\n\n    # Save plot if save_plots is True\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        filename = self.plot_prefix + '_accelerations' + plot_suffix + '.png'\n        plt.savefig(filename, bbox_inches='tight')\n\n    # Show plot\n    plt.show()\n\n", "CodeBleu_score": 30.364309356000923}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # TODO: implement plot_accelerations\n    # TODO: add a title and subplot\n    # TODO: add x and y axis labels\n    # TODO: add a legend\n    # TODO: add saving plots\n    pass\n", "CodeBleu_score": 1.1312217194570136}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.save_plots:\n        if plot_suffix:\n            plot_filename = self.plot_prefix + plot_suffix + '.png'\n        else:\n            plot_filename = self.plot_prefix + '.png'\n        plt.savefig(plot_filename)\n    else:\n        plt.show()\n\n", "CodeBleu_score": 18.33746699713351}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"ERROR: Not enough pose indices to compare positions.\")\n        return None\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(self.get_xyz(pose_indeces[i]), self.get_xyz(pose_indeces[j]))\n\n", "CodeBleu_score": 40.313613501883104}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        raise ValueError(\"The number of pose indices must be at least two.\")\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(self.poses[pose_indeces[i]].position, self.poses[pose_indeces[j]].position)\n\n", "CodeBleu_score": 40.52729480942869}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(self.poses[pose_indeces[i]].position, self.poses[pose_indeces[j]].position)\n\n", "CodeBleu_score": 30.705973895209503}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if time >= start_time and time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 33.221366883419925}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if collision.time >= start_time and collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 40.28684565890178}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check if data pointer is null\n  if (data == NULL) {\n    return;\n  }\n\n// Calculate multiplier\n  float multiplier = this->CalculateMultiplier(width, height);\n\n// Calculate RMS noise\n  float rms = this->CalculateRMS(multiplier);\n\n// Calculate noise values\n  float noise = this->CalculateNoise(rms);\n\n// Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> eigen_data(data, width * height);\n\n// Add noise to data\n  eigen_data += noise;\n\n// Set bad points\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (!this->InRange(eigen_data[i])) {\n      eigen_data[i] = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 45.850876959786454}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t#if defined(D435_DEPTH_NOISE_MODEL_DEBUG)\n  std::cout << \"D435DepthNoiseModel::ApplyNoise\" << std::endl;\n#endif\n  if (!data) {\n    return;\n  }\n\n  const float multiplier = this->GetMultiplier(width, height);\n  Eigen::VectorXf noise_values(width * height);\n  float noise_rms = 0;\n  this->GetNoiseValues(width, height, noise_values, noise_rms);\n\n  for (uint32_t y = 0; y < height; y++) {\n    for (uint32_t x = 0; x < width; x++) {\n      const uint32_t index = y * width + x;\n      if (this->InRange(data[index])) {\n        data[index] += noise_values(index) * multiplier;\n      } else {\n        data[index] = this->bad_point;\n      }\n    }\n  }\n}", "CodeBleu_score": 46.01861149017411}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check if data pointer is null\n  if (data == nullptr) {\n    return;\n  }\n// Calculate a multiplier based on camera parameters\n  const float multiplier = this->GetMultiplier(width, height);\n// Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n// Compute the RMS noise\n  const float rms_noise = this->GetRMSNoise(width, height);\n// Compute the noise values\n  const float noise = rms_noise * multiplier;\n// For each pixel, add noise if the pixel value is in range, otherwise set the pixel to a bad point value\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (this->InRange(depth_data(i))) {\n      depth_data(i) += noise;\n    } else {\n      depth_data(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 47.676297723482236}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// ROS_INFO(\"WaypointCallback called\");\n  ros::Time ros_time = ros::Time::now();\n  ros_time = ros_time.fromSec(trajectory_msg->header.stamp.sec);\n  ros_time = ros_time.fromNSec(trajectory_msg->header.stamp.nsec);\n\n  bag_trajectory_writer_.write(trajectory_msg->joint_names, trajectory_msg->points, ros_time);\n}", "CodeBleu_score": 38.29363211043748}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Convert the trajectory message to ROS time\n\tros::Time ros_time = ros::Time::now();\n\tros_time = ros_time + ros::Duration(trajectory_msg->header.stamp.sec, trajectory_msg->header.stamp.nsec);\n\n\t// Write the trajectory message to the bag file\n\tbag_writer_->write(waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 41.088343507241454}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time\n\tros::Time time = ros::Time::now();\n\t// Convert the simulation time to ROS time\n\ttime = gazebo_ros::Convert<ros::Time>(time);\n\t// Write the trajectory message to the bag file using the specified namespace and waypoint topic\n\tbag.write(trajectory_msg->header.frame_id + \"/\" + waypoint_topic, time, *trajectory_msg);\n}", "CodeBleu_score": 44.463683206227344}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t", "CodeBleu_score": 3.558047406471674}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert the simulation time to ROS time\n\tros::Time ros_time = ros::Time::now();\n\tros_time += ros::Duration(now.sec, now.nsec);\n\n\t// Prepare the message\n\tsensor_msgs::JointState msg;\n\tmsg.header.stamp = ros_time;\n\tmsg.name.resize(motor_joints.size());\n\tmsg.velocity.resize(motor_joints.size());\n\n\t// Iterate through the motor joints\n\tfor (int i = 0; i < motor_joints.size(); i++) {\n\t\t// Get the motor joint\n\t\tphysics::JointPtr motor_joint = motor_joints[i];\n\n\t\t// Calculate the slowed-down rotational velocity\n\t\tdouble slowed_down_rotational_velocity = motor_joint->GetAngle(0).Radian() - motor_joint->GetAngle(1).Radian();\n\t\tslowed_down_rotational_velocity *= motor_joint->GetMaxForce(0);\n\t\tslowed_down_rotational_velocity /= motor_joint->GetMaxForce(1);\n\n\t\t// Assign the slowed-down rotational velocity to the message\n\t\tmsg.name[i] = motor_joint->GetName();\n\t\tmsg.velocity[i] = slowed_down_rotational_velocity;\n\t}\n\n\t// Set the message timestamp\n\tmsg.header.stamp = ros_time;\n\n\t// Write the message to the bag file\n\tbag_file.write(motor_topic, ros_time, msg);\n}", "CodeBleu_score": 50.226938200638585}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert simulation time to ROS time.\n\tros::Time ros_time = ros::Time::now();\n\tros_time = ros_time + ros::Duration(now.Double());\n\n\t// Prepare message for actuator velocities.\n\tsensor_msgs::JointState joint_state_msg;\n\tjoint_state_msg.header.stamp = ros_time;\n\tjoint_state_msg.name.resize(motor_joints.size());\n\tjoint_state_msg.velocity.resize(motor_joints.size());\n\n\t// Iterate through the motor joints, calculating the slowed-down rotational velocities, and assigning them to the message.\n\tfor (int i = 0; i < motor_joints.size(); i++) {\n\t\tjoint_state_msg.name[i] = motor_joints[i]->GetName();\n\t\tjoint_state_msg.velocity[i] = motor_joints[i]->GetVelocity(0);\n\t\tjoint_state_msg.velocity[i] = joint_state_msg.velocity[i] * slowdown_factor;\n\t}\n\n\t// Write the message to the bag file.\n\tbag_file_writer.write(motor_topic, ros_time, joint_state_msg);\n}", "CodeBleu_score": 46.95246526916377}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT\n  ROS_INFO(\"RollPitchYawrateThrustCallback called\");\n#endif\n  double roll_input = roll_pitch_yawrate_thrust_msg->roll_input;\n  double pitch_input = roll_pitch_yawrate_thrust_msg->pitch_input;\n  double yaw_rate_input = roll_pitch_yawrate_thrust_msg->yaw_rate_input;\n  double thrust_input = roll_pitch_yawrate_thrust_msg->thrust_input;\n  double roll_angle = NormalizedInputToAngle(aileron_surface_, roll_input);\n  double pitch_angle = NormalizedInputToAngle(elevator_surface_, pitch_input);\n  double yaw_rate_angle = NormalizedInputToAngle(rudder_surface_, yaw_rate_input);\n  double thrust_angle = NormalizedInputToAngle(throttle_surface_, thrust_input);\n  SetControlSurfaceAngle(aileron_surface_, roll_angle);\n  SetControlSurfaceAngle(elevator_surface_, pitch_angle);\n  SetControlSurfaceAngle(rudder_surface_, yaw_rate_angle);\n  SetControlSurfaceAngle(throttle_surface_, thrust_angle);\n  SetThrust(thrust_angle);\n}", "CodeBleu_score": 37.49896838234895}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if PRINT_DEBUG_MESSAGES\n  std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n#endif\n\n  // Convert the normalized roll, pitch, and yaw rate inputs to angles for\n  // the ailerons, elevator, and rudder respectively.\n  double roll_angle = NormalizedInputToAngle(aileron, roll_pitch_yawrate_thrust_msg->roll);\n  double pitch_angle = NormalizedInputToAngle(elevator, roll_pitch_yawrate_thrust_msg->pitch);\n  double yawrate_angle = NormalizedInputToAngle(rudder, roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set the throttle value from the thrust message.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // Set the control surface angles for the ailerons, elevator, and rudder\n  // respectively.\n  aileron.angle = roll_angle;\n  elevator.angle = pitch_angle;\n  rudder.angle = yawrate_angle;\n\n  // Set the control surface throttle value.\n  throttle_control_surface.angle = throttle;\n}", "CodeBleu_score": 40.00521052286073}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINTING\n  std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n#endif\n\n  // Set the control surface angles from the normalized inputs\n  control_surface_angles_[aileron_index_] =\n      NormalizedInputToAngle(aileron_control_surface_,\n                             roll_pitch_yawrate_thrust_msg->roll_input);\n  control_surface_angles_[elevator_index_] =\n      NormalizedInputToAngle(elevator_control_surface_,\n                             roll_pitch_yawrate_thrust_msg->pitch_input);\n  control_surface_angles_[rudder_index_] =\n      NormalizedInputToAngle(rudder_control_surface_,\n                             roll_pitch_yawrate_thrust_msg->yaw_input);\n\n  // Set the throttle value from the thrust message\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust_input;\n}", "CodeBleu_score": 41.52015690196915}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  gzdbg << \"pollForMAVLinkMessages: \" << _timeoutMs << \"ms\n\";\n\n  // Convert timeout to a timeval structure.\n  timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for MAVLink messages.\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n  int ret = select(_fd + 1, &fds, NULL, NULL, &timeout);\n\n  if (ret == 0) {\n    // Timeout.\n    return;\n  }\n\n  // Check for errors.\n  if (ret < 0) {\n    gzerr << \"Error polling for MAVLink messages.\n\";\n    return;\n  }\n\n  // Receive data from the serial port.\n  char buffer[MAVLINK_MAX_PACKET_LEN];\n  ssize_t len = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n\n  if (len <= 0) {\n    gzerr << \"Error receiving MAVLink messages.\n\";\n    return;\n  }\n\n  // Parse the received MAVLink messages.\n  mavlink_message_t msg;\n  mavlink_status_t status;\n  for (unsigned i = 0; i < len; ++i) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n      // Handle the message.\n      handle_message(&msg);\n\n      // Forward the message to the serial port.\n      if (serial_enabled_) {\n        send_mavlink_message(&msg, 0);\n      }\n    }\n  }\n}", "CodeBleu_score": 56.87164776396575}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t/   gzdbg << \"GazeboMavlinkInterface::pollForMAVLinkMessages\n\";\n\n  // Convert timeout to timeval structure\n  timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Set up poll structure\n  pollfd fds[1];\n  fds[0].fd = _fd;\n  fds[0].events = POLLIN;\n\n  // Poll for MAVLink messages\n  int ret = poll(fds, 1, _timeoutMs);\n\n  // Check for errors\n  if (ret < 0) {\n    gzerr << \"Error polling for MAVLink messages: \" << strerror(errno) << \"\n\";\n    return;\n  }\n\n  // Check if there is data available\n  if (ret == 0) {\n    return;\n  }\n\n  // Check if there is data available\n  if (fds[0].revents & POLLIN) {\n\n    // Read data from serial port\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    ssize_t len = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n\n    // Check for errors\n    if (len < 0) {\n      gzerr << \"Error reading from serial port: \" << strerror(errno) << \"\n\";\n      return;\n    }\n\n    // Parse MAVLink messages from buffer\n    uint8_t* buf = buffer;\n    while (len > 0) {\n      // Read message header\n      mavlink_message_t msg;\n      uint8_t* buf_ptr = buf;\n      int r = mavlink_parse_char(MAVLINK_COMM_0, *buf_ptr, &msg, &buf_ptr);\n\n      // Check for errors\n      if (r < 0) {\n        gzerr << \"Error parsing MAVLink message: \" << r << \"\n\";\n        return;\n      }\n\n      // Handle message\n      handle_message(&msg);\n\n      // Move buffer pointer to next message\n      buf = buf_ptr;\n      len -= buf_ptr - buf;\n    }\n  }\n}", "CodeBleu_score": 49.777615500474276}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tf 0\n  if (serial_enabled_) {\n    if (!is_open()) {\n      gzerr << \"Serial port closed! \n\";\n      return;\n    }\n\n    {\n      lock_guard lock(mutex_);\n\n      if (rx_q_.size() >= MAX_RXQ_SIZE) {\n        //         gzwarn << \"RX queue overflow. \n\";\n      }\n      rx_q_.emplace_back(message);\n    }\n    io_service_.post(std::bind(&GazeboMavlinkInterface::do_read, this, true));\n  }\n#endif\n\n  // Poll for new data.\n  int timeout_ms = _timeoutMs;\n  struct timeval tv;\n  tv.tv_sec = timeout_ms / 1000;\n  tv.tv_usec = (timeout_ms % 1000) * 1000;\n\n  fd_set read_fds;\n  FD_ZERO(&read_fds);\n  FD_SET(_fd, &read_fds);\n\n  int ret = select(_fd + 1, &read_fds, NULL, NULL, &tv);\n\n  if (ret == -1) {\n    gzerr << \"Error in select\n\";\n    return;\n  } else if (ret == 0) {\n    gzwarn << \"Timeout in select\n\";\n    return;\n  }\n\n  if (FD_ISSET(_fd, &read_fds)) {\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    ssize_t len = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n\n    if (len > 0) {\n      mavlink_message_t msg;\n      mavlink_status_t status;\n\n      for (ssize_t i = 0; i < len; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n          handle_message(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 54.442910386418994}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif(is_open) {\n\t\tmavlink_interface_stop();\n\t\tmavlink_interface_close();\n\t\tis_open = false;\n\t}\n}", "CodeBleu_score": 29.96437533663872}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (is_open) {\n\t\tmavlink_interface->stop();\n\t\tmavlink_interface->close();\n\t\tif (mavlink_interface->is_joinable()) {\n\t\t\tmavlink_interface->join();\n\t\t}\n\t\tis_open = false;\n\t}\n}", "CodeBleu_score": 51.16858799700038}, {"code": "void GazeboMavlinkInterface::close() {\n\t\t// Lock mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(mutex_);\n\n\t// Check if interface is open\n\tif (open_) {\n\t\t// Stop I/O service\n\t\tio_service_.stop();\n\n\t\t// Close serial device\n\t\tserial_port_.close();\n\n\t\t// If the I/O thread is joinable, join it to clean up resources\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\n\t\t// Set interface closed\n\t\topen_ = false;\n\t}\n}", "CodeBleu_score": 58.92716944062508}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(this->wind_position_2 - this->wind_position_1) * this->wind_interpolation_factor + this->wind_position_1\n}", "CodeBleu_score": 6.721868371310793}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(this->wind_speed_max - this->wind_speed_min) / (this->wind_speed_max - this->wind_speed_min) * (this->wind_direction_max - this->wind_direction_min) + this->wind_speed_min,\n\t(this->wind_speed_max - this->wind_speed_min) / (this->wind_speed_max - this->wind_speed_min) * (this->wind_direction_max - this->wind_direction_min) + this->wind_speed_min,\n\t(this->wind_speed_max - this->wind_speed_min) / (this->wind_speed_max - this->wind_speed_min) * (this->wind_direction_max - this->wind_direction_min) + this->wind_speed_min\n}", "CodeBleu_score": 5.876756159986045}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(this->wind_point_1.X() - this->wind_point_2.X()) / this->wind_time_difference,\n\t(this->wind_point_1.Y() - this->wind_point_2.Y()) / this->wind_time_difference,\n\t(this->wind_point_1.Z() - this->wind_point_2.Z()) / this->wind_time_difference\n}", "CodeBleu_score": 7.18718872109455}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\ttime = _time;\n\tif (looping) {\n\t\ttime = fmod(time, length);\n\t} else {\n\t\ttime = min(max(0.0, time), length);\n\t}\n}", "CodeBleu_score": 21.03226476763238}, {"code": "void Animation::SetTime(double _time){\n\t\tif (_time!= m_time) {\n\t\tm_time = _time;\n\t\tif (m_looping) {\n\t\t\tm_time = fmod(m_time, m_length);\n\t\t\tif (m_time < 0)\n\t\t\t\tm_time += m_length;\n\t\t} else {\n\t\t\tm_time = clamp(m_time, 0.0, m_length);\n\t\t}\n\t\tUpdate();\n\t}\n}", "CodeBleu_score": 32.970136580576806}, {"code": "void Animation::SetTime(double _time){\n\t\tif (time!= _time) {\n\t\ttime = _time;\n\t\tif (time < 0) {\n\t\t\ttime = 0;\n\t\t} else if (time > length) {\n\t\t\tif (looping) {\n\t\t\t\ttime = fmod(time, length);\n\t\t\t} else {\n\t\t\t\ttime = length;\n\t\t\t}\n\t\t}\n\t\tUpdate();\n\t}\n}", "CodeBleu_score": 33.60292610759953}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    target_raw_pose = self.construct_target(self.x, self.y, self.z, 0, 0, 0, 0, 0, 0, self.yaw, 0)\n    self.send_target_raw_pose(target_raw_pose)\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: %s\" % self.flight_mode)\n", "CodeBleu_score": 22.922399643525107}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n\n    self.target_raw_pose = self.construct_target(self.current_position.x, self.current_position.y, self.current_position.z, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.send_mavlink_message(self.target_raw_pose)\n    print(\"Vehicle type: \" + str(self.vehicle_type))\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight mode: \" + str(self.flight_mode))\n", "CodeBleu_score": 51.22069923346859}, {"code": "def hover(self)\n\t\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    target_raw_pose = self.construct_target(self.get_x(), self.get_y(), self.get_z(), 0, 0, 0, 0, 0, 0, self.get_yaw(), 0)\n    self.send_setpoint(target_raw_pose)\n    print(\"Vehicle type: \" + str(self.get_vehicle_type()) + \"", "CodeBleu_score": 23.302196082582192}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.vehicle.mode = VehicleMode(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode changed to \"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Flight mode change failed\")\n            return False\n", "CodeBleu_score": 49.423116662579424}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        if self.flight_mode == 'AUTO':\n            if self.vehicle_type == 'plane':\n                self.flight_mode = 'AUTO_TAKEOFF'\n            elif self.vehicle_type == 'quadrotor':\n                self.flight_mode = 'AUTO_TAKEOFF'\n            else:\n                self.flight_mode = 'AUTO_LAND'\n        else:\n            if self.vehicle_type == 'plane':\n                self.flight_mode = 'GUIDED'\n            elif self.vehicle_type == 'quadrotor':\n                self.flight_mode = 'GUIDED'\n            else:\n                self.flight_mode = 'STABILIZE'\n        self.vehicle.mode = VehicleMode(self.flight_mode)\n        print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n        return True\n", "CodeBleu_score": 41.7651843781639}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode = self.flightModeService.request(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": Could not switch to \"+self.flight_mode)\n            return False\n", "CodeBleu_score": 49.88323894588147}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z, 'enu')\n    if self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=0, yaw_rate=msg.angular.z)\n", "CodeBleu_score": 54.47113079432982}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 64.32590962893586}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n\n    if self.hover_flag == 0:\n        self.hold_state_transition(x, y, z, w, 'enu')\n    else:\n        self.hover_state_transition(x, y, z, w, 'enu')\n\n    if self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n", "CodeBleu_score": 50.423081650273005}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode == 'OFFBOARD':\n        self.hover()\n    if self.flight_mode == 'HOVER':\n        if (x > 0.02) or (y > 0.02) or (z > 0.02) or (w > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.hover()\n        else:\n            if self.hover_flag == 0:\n                self.hover_flag = 1\n                self.flight_mode = 'HOVER'\n                self.hover()\n\n", "CodeBleu_score": 49.90884382766968}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode == 'OFFBOARD':\n        self.hover()\n    else:\n        if self.hover_flag == 0:\n            if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n                self.hover_flag = 1\n                self.set_mode(FlightMode.HOVER)\n        else:\n            if abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005:\n                self.hover_flag = 0\n                self.set_mode(FlightMode.OFFBOARD)\n\n", "CodeBleu_score": 55.97062630881635}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (self.current_position.x > 0.02 or self.current_position.x < -0.02 or self.current_position.y > 0.02 or self.current_position.y < -0.02 or self.current_position.z > 0.02 or self.current_position.z < -0.02 or self.current_yaw > 0.005 or self.current_yaw < -0.005):\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        self.hover()\n    elif (self.hover_flag == 1):\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n\n", "CodeBleu_score": 47.6613499499734}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n\n", "CodeBleu_score": 19.528210155997467}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        yaw = Quaternion(q[0], q[1], q[2], q[3]).yaw\n    return yaw\n\n", "CodeBleu_score": 36.644194759173175}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw()\n    else:\n        return Quaternion(q).yaw()\n\n", "CodeBleu_score": 17.87598314614692}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 1\n    self.target_raw_pose = self.construct_target(self.current_position[0], self.current_position[1], self.current_position[2], 0, 0, 0, 0, 0, 0, self.current_yaw, 0)\n    print(\"Vehicle Type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: \" + self.flight_mode)\n    print(\"Hovering\")\n\n", "CodeBleu_score": 34.51785245357293}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.current_position.x, y=self.current_position.y, z=self.current_position.z, yaw=self.current_yaw)\n    self.send_position_target_setpoint(target_raw_pose)\n    print(\"Vehicle Type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + self.vehicle_id)\n    print(\"Flight Mode: \" + self.flight_mode)\n\n", "CodeBleu_score": 49.52447785962763}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 0\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.position[0], y=self.position[1], z=self.position[2], yaw=self.yaw)\n    self.send_mavlink(target_raw_pose)\n    print(\"Vehicle Type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: \" + self.flight_mode)\n\n", "CodeBleu_score": 47.51308894136638}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode = self.flight_mode_service(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except Exception as e:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Failed to switch flight mode to \" + self.flight_mode)\n            print(e)\n            return False\n\n", "CodeBleu_score": 53.401313797129944}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode = self.flightModeService.set_vehicle_mode(VehicleMode(self.flight_mode))\n            print(self.vehicle_type + '_' + self.vehicle_id + ':' + self.flight_mode)\n            return True\n        except:\n            print('Failed to switch flight mode to'+ self.flight_mode)\n            return False\n\n", "CodeBleu_score": 47.813643880646254}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        self.flight_mode = self.flight_mode_service.flightModeService(self.vehicle_type, self.vehicle_id,\n                                                                      self.flight_mode, 'HOVER')\n        if self.flight_mode == 'HOVER':\n            print(self.vehicle_type + '_' + self.vehicle_id + \": flight mode changed to \" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": failed to change flight mode to \" + self.flight_mode)\n            return False\n\n", "CodeBleu_score": 51.52537262727053}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n        if self.takeoff_target_pose is None:\n            self.takeoff_target_pose = self.local_pose.pose\n        if self.hover_target_pose is None:\n            self.hover_target_pose = self.local_pose.pose\n        self.global_pose = self.local_pose.pose.pose.position + self.bias_position\n        self.global_pose.z = 0.0\n        self.global_pose.x = self.global_pose.x - self.local_pose.pose.pose.position.x\n        self.global_pose.y = self.global_pose.y - self.local_pose.pose.pose.position.y\n        self.global_pose.z = self.global_pose.z - self.local_pose.pose.pose.position.z\n        self.local_pose.pose.position.x = self.local_pose.pose.position.x - self.bias_position.x\n        self.local_pose.pose.position.y = self.local_pose.pose.position.y - self.bias_position.y\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z - self.bias_position.z\n        self.local_pose.pose.orientation.x = self.local_pose.pose.orientation.x - self.bias_orientation.x\n        self.local_pose.pose.orientation.y = self.local_pose.pose.orientation.y - self.bias_orientation.y\n        self.local_pose.pose.orientation.z = self.local_pose.pose.orientation.z - self.bias_orientation.z\n        self.local_pose.pose.orientation.w = self.local_pose.pose.orientation.w - self.bias_orientation.w\n        self.local_pose.pose.orientation = Quaternion(self.local_pose.pose.orientation.x, self.local_pose.pose.orientation.y, self.local_pose.pose.orientation.z, self.local_pose.pose.orientation.w)\n        self.local_pose.pose.orientation = euler_to_quaternion(self.local_", "CodeBleu_score": 19.606561618975213}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    # Get the message\n    msg_id = msg.header.frame_id\n    msg_pose = msg.pose\n    msg_position = msg_pose.position\n    msg_orientation = msg_pose.orientation\n    # Get the UAV ID\n    uav_id = self.uav_ids[i]\n    # Check if the message matches the UAV ID\n    if msg_id == uav_id:\n        # Set the local pose to the message\n        self.local_pose[i] = msg_pose\n        # Get the position and orientation\n        position = msg_position\n        orientation = msg_orientation\n        # Update the takeoff target pose\n        if self.takeoff_target_pose[i] == self.hover_target_pose[i]:\n            self.takeoff_target_pose[i] = position\n        # Update the hover target pose\n        if self.hover_target_pose[i] == self.hover_target_pose[i]:\n            self.hover_target_pose[i] = position\n        # Update the global pose\n        self.global_pose[i] = self.global_pose[i] + self.local_pose[i] - self.local_pose[i].pose.position\n        # Update the global pose with a bias\n        self.global_pose[i].pose.position.x = self.global_pose[i].pose.position.x + self.bias_x\n        self.global_pose[i].pose.position.y = self.global_pose[i].pose.position.y + self.bias_y\n        self.global_pose[i].pose.position.z = self.global_pose[i].pose.position.z + self.bias_z\n        # Update the global pose with a bias\n        self.global_pose[i].pose.orientation.x = self.global_pose[i].pose.orientation.x + self.bias_x\n        self.global_pose[i].pose.orientation.y = self.global_pose[i].pose.orientation.y + self.bias_y\n        self.global_pose[i].pose.orientation.z = self.global_pose[i].pose.orientation.z + self.bias_z\n        self.global_pose[i].pose.orientation.w = self.global_pose[i].pose.orientation", "CodeBleu_score": 14.706591038205175}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if self.uav_id == i:\n        self.local_pose = msg\n        self.local_pose.pose.position.x = self.local_pose.pose.position.x - self.x_bias\n        self.local_pose.pose.position.y = self.local_pose.pose.position.y - self.y_bias\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z - self.z_bias\n        self.local_pose.pose.position.x = self.local_pose.pose.position.x * self.x_scale\n        self.local_pose.pose.position.y = self.local_pose.pose.position.y * self.y_scale\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z * self.z_scale\n        self.local_pose.pose.position.x = self.local_pose.pose.position.x + self.x_offset\n        self.local_pose.pose.position.y = self.local_pose.pose.position.y + self.y_offset\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z + self.z_offset\n        self.local_pose.pose.orientation.w = self.local_pose.pose.orientation.w * self.w_scale\n        self.local_pose.pose.orientation.x = self.local_pose.pose.orientation.x * self.x_scale\n        self.local_pose.pose.orientation.y = self.local_pose.pose.orientation.y * self.y_scale\n        self.local_pose.pose.orientation.z = self.local_pose.pose.orientation.z * self.z_scale\n        self.local_pose.pose.orientation.w = self.local_pose.pose.orientation.w + self.w_offset\n        self.local_pose.pose.orientation.x = self.local_pose.pose.orientation.x + self.x_offset\n        self.local_pose.pose.orientation.y = self.local_pose.pose.orientation.y + self.y_offset\n        self.local_pose.pose.orientation.z =", "CodeBleu_score": 17.841696753069726}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == 1:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.609826728102846}, {"code": "def takeoff_detection(self)\n\t\n    if self.altitude > 0.2 and self.arm_state == True:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.88263518862473}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.mode == 'GUIDED' and self.state.altitude > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 58.997434928278494}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n\n    # Calculate the pairwise distances between UAVs in the original and changed formations\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i, j] = np.linalg.norm(np.array(orig_formation[i]) - np.array(change_formation[j]))\n\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    dist_matrix = np.round(50 - dist_matrix).astype(int)\n\n    return dist_matrix\n\n", "CodeBleu_score": 26.519933360066666}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # TODO: implement this function\n    return np.array([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])\n\n", "CodeBleu_score": 2.0098670176444364}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    formation_diff = np.subtract(orig_formation, change_formation)\n    formation_diff = np.absolute(formation_diff)\n    formation_diff = np.round(formation_diff)\n    formation_diff = formation_diff.astype(int)\n    return formation_diff\n\n", "CodeBleu_score": 8.322050018683315}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    for i in range(self.num_uavs):\n        self.slack_right[i] = 0\n        self.visit_right[i] = False\n        self.match_right[i] = -1\n    for i in range(self.num_uavs):\n        self.slack_left[i] = 0\n        self.visit_left[i] = False\n        self.match_left[i] = -1\n    for i in range(self.num_uavs):\n        self.label_left[i] = 0\n        for j in range(self.num_uavs):\n            self.label_left[i] = max(self.label_left[i], self.adj_matrix[i][j])\n        self.label_left[i] += self.num_uavs\n    for i in range(self.num_uavs):\n        for j in range(self.num_uavs):\n            self.label_right[j] = max(self.label_right[j], self.adj_matrix[i][j])\n    for i in range(self.num_uavs):\n        self.find_path(i)\n    return self.match_right", "CodeBleu_score": 28.81186540896267}, {"code": "def KM(self)\n\t\n    self.label_left = [0] * self.UAVs\n    self.label_right = [0] * self.UAVs\n    self.slack_right = [0] * self.UAVs\n    self.match_right = [-1] * self.UAVs\n    self.visit_left = [False] * self.UAVs\n    self.visit_right = [False] * self.UAVs\n    for i in range(self.UAVs):\n        self.find_path(i)\n    for i in range(self.UAVs):\n        if self.match_right[i] == -1:\n            continue\n        self.label_left[self.match_right[i]] += self.slack_right[self.match_right[i]]\n        self.label_right[i] -= self.slack_right[self.match_right[i]]\n    for i in range(self.UAVs):\n        self.visit_left[i] = False\n        self.visit_right[i] = False\n    for i in range(self.UAVs):\n        self.find_path(i)\n    for i in range(self.UAVs):\n        if self.match_right[i] == -1:\n            continue\n        self.label_left[self.match_right[i]] += self.slack_right[self.match_right[i]]\n        self.label_right[i] -= self.slack_right[self.match_right[i]]\n    for i in range(self.UAVs):\n        if self.match_right[i] == -1:\n            continue\n        self.match_right[i] = self.match_right[self.match_right[i]]\n    return self.match_right\n\n", "CodeBleu_score": 27.44583705855063}, {"code": "def KM(self)\n\t\n    for i in range(self.num_uavs):\n        self.visit_left[i] = False\n        self.visit_right = [False] * self.num_uavs\n        self.match_right = [-1] * self.num_uavs\n        self.slack_right = [0] * self.num_uavs\n        self.label_left = [0] * self.num_uavs\n        self.label_right = [0] * self.num_uavs\n        self.find_path(i)\n        for j in range(self.num_uavs):\n            if self.visit_right[j]:\n                self.label_left[self.match_right[j]] -= self.slack_right[j]\n                self.label_right[j] += self.slack_right[j]\n                self.slack_right[j] = 0\n        while True:\n            delta = sys.maxsize\n            for i in range(self.num_uavs):\n                for j in range(self.num_uavs):\n                    if self.visit_right[j]:\n                        delta = min(delta, self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j])\n            if delta == sys.maxsize:\n                break\n            for i in range(self.num_uavs):\n                if not self.visit_left[i]:\n                    self.label_left[i] -= delta\n            for j in range(self.num_uavs):\n                if self.visit_right[j]:\n                    self.label_right[j] += delta\n            for i in range(self.num_uavs):\n                for j in range(self.num_uavs):\n                    if self.visit_right[j]:\n                        self.slack_right[j] -= delta\n            for i in range(self.num_uavs):\n                if not self.visit_left[i]:\n                    self.visit_left[i] = True\n                    for j in range(self.num_uavs):\n                        if self.visit_right[j]:\n                            self.label_left[self.match_right[j]] -= self.slack_right[j]\n                            self.label_right[j] += self", "CodeBleu_score": 28.15613851488759}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower = np.array([20, 100, 100])\n    upper = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower, upper)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 37.51478398450005}, {"code": "def yellow_dectection(image)\n\t\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)\n\n    # Define range of yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Threshold the HSV image to get only yellow colors\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 27.209591522105914}, {"code": "def yellow_dectection(image)\n\t\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define range of yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Threshold the HSV image to get only yellow colors\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\t(const std::string &id, TagDescriptionContainer &descriptionContainer, bool printWarning) const {\n\t\tauto it = standalone_tag_descriptions_.find(id);\n\t\tif (it == standalone_tag_descriptions_.end()) {\n\t\t\tif (printWarning) {\n\t\t\t\tLOG(WARNING) << \"Standalone tag description with ID \" << id << \" not found.\";\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tdescriptionContainer = it->second;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 53.17603511344979}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}]}
