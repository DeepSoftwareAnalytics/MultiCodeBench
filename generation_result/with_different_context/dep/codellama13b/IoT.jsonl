{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tusb_conf_desc_t UDC_DESC_STORAGE *desc_ptr = desc;\n\n\twhile (desc_ptr->bDescriptorType != desc_id) {\n\t\tdesc_ptr = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t\t((uint8_t UDC_DESC_STORAGE *) desc_ptr\n\t\t\t\t\t\t+ desc_ptr->bLength);\n\t\tif (desc_ptr->bDescriptorType == USB_DESC_TYPE_INTERFACE) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn desc_ptr;\n}", "CodeBleu_score": 36.63237044293539}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tuint8_t desc_type;\n\tusb_conf_desc_t UDC_DESC_STORAGE *desc_next;\n\n\twhile (desc && (desc->bDescriptorType != desc_id)) {\n\t\tdesc_next = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t\n\t\t\t\tUDC_DESC_STORAGE *) desc\n\t\t\t\t+ desc->bLength);\n\t\tdesc = desc_next;\n\t}\n\treturn desc;\n}", "CodeBleu_score": 37.125500227468265}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = (usb_conf_desc_t UDC_DESC_STORAGE\n\t\t\t*) ((uint8_t UDC_DESC_STORAGE *) desc + desc->bLength);\n\twhile (desc->bLength != 0) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = next_desc;\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 50.218575705118006}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tuint8_t *desc;\n    uint8_t *cfg_desc = udc_device.config_desc;\n    uint8_t *iface_desc = NULL;\n    uint8_t *setting_desc = NULL;\n    uint8_t iface_desc_len = 0;\n    uint8_t setting_desc_len = 0;\n    uint8_t iface_desc_found = 0;\n    uint8_t setting_desc_found = 0;\n    uint8_t setting_num_found = 0;\n    uint8_t iface_num_found = 0;\n    uint8_t num_iface_desc = 0;\n    uint8_t num_setting_desc = 0;\n    uint8_t num_alt_setting = 0;\n    uint8_t num_endpoint = 0;\n    uint8_t num_endpoint_found = 0;\n    uint8_t endpoint_num = 0;\n    uint8_t endpoint_num_found = 0;\n    uint8_t endpoint_type = 0;\n    uint8_t endpoint_type_found = 0;\n    uint8_t endpoint_direction = 0;\n    uint8_t endpoint_direction_found = 0;\n    uint8_t endpoint_size = 0;\n    uint8_t endpoint_size_found = 0;\n    uint8_t endpoint_interval = 0;\n    uint8_t endpoint_interval_found = 0;\n    uint8_t endpoint_found = 0;\n    uint8_t endpoint_found_found = 0;\n    uint8_t endpoint_found_found_found = 0;\n    uint8_t endpoint_found_found_found_found = 0;\n    uint8_t endpoint_found_found_found_found_found = 0;\n    uint8_t endpoint_found_found_found_found_found_found = 0;\n    uint8_t endpoint_found_found_found_found_found_found_found = 0;\n    uint8_t endpoint_found_found_found_found_found", "CodeBleu_score": 10.83655019775301}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tstruct usb_config_descriptor *config_desc;\n\tstruct usb_interface_descriptor *iface_desc;\n\tuint8_t *desc_ptr;\n\tuint8_t desc_len;\n\tuint8_t desc_type;\n\tuint8_t iface_num_found;\n\tuint8_t setting_num_found;\n\n\t/*\n\t * If there is no current configuration, return false.\n\t */\n\tif (udc_config_num == 0) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * If the interface number is out of range, return false.\n\t */\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Get a pointer to the beginning of the configuration descriptor.\n\t */\n\tconfig_desc = (struct usb_config_descriptor *) udc_config_desc;\n\n\t/*\n\t * Get a pointer to the first interface descriptor.\n\t */\n\tdesc_ptr = (uint8_t *) udc_config_desc + sizeof(struct usb_config_descriptor);\n\n\t/*\n\t * Loop through the descriptors, starting from the first interface descriptor.\n\t */\n\tiface_num_found = 0;\n\tsetting_num_found = 0;\n\twhile (iface_num_found < iface_num) {\n\t\t/*\n\t\t * Get the descriptor type and length.\n\t\t */\n\t\tdesc_type = *desc_ptr;\n\t\tdesc_len = *(desc_ptr + 1);\n\n\t\t/*\n\t\t * If the descriptor is an interface descriptor, increment the number of interfaces found.\n\t\t */\n\t\tif (desc_type == USB_DT_INTERFACE) {\n\t\t\tiface_num_found++;\n\t\t}\n\n\t\t/*\n\t\t * If the descriptor is an interface descriptor and it matches the specified interface number, increment the number of settings found.\n\t\t */\n\t\tif ((desc_type == USB_DT_INTERFACE) && (iface", "CodeBleu_score": 33.62444608991659}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tuint8_t i, j;\n    uint8_t *desc = NULL;\n    uint16_t len = 0;\n\n    // Verify that the interface number is in bounds\n    if (iface_num >= udc_config_desc.bNumInterfaces) {\n        return false;\n    }\n\n    // Verify that there is a valid configuration\n    if (udc_config_desc.bConfigurationValue == 0) {\n        return false;\n    }\n\n    // Iterate through the descriptors, starting from the beginning of the configuration descriptor, and check each one to see if it matches the specified interface number and setting number\n    desc = udc_config_desc_buf;\n    len = udc_config_desc.wTotalLength;\n    for (i = 0; i < udc_config_desc.bNumInterfaces; i++) {\n        if (desc[0] == USB_DT_INTERFACE) {\n            if (desc[2] == iface_num) {\n                for (j = 0; j < desc[4]; j++) {\n                    if (desc[5 + j] == setting_num) {\n                        return true;\n                    }\n                }\n            }\n        }\n        desc += desc[0];\n        len -= desc[0];\n    }\n\n    return false;\n}", "CodeBleu_score": 44.23489090827134}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\tuint8_t ep_num = usb_setup.wIndex & 0x0f;\n\tuint16_t status = 0;\n\tif (usb_setup.wLength != 2) {\n\t\treturn false;\n\t}\n\tif (udd_ep_halted(ep_num)) {\n\t\tstatus = 1;\n\t}\n\tudc_payload_stage_start();\n\tudc_payload_put16(status);\n\tudc_payload_stage_end();\n\treturn true;\n}", "CodeBleu_score": 21.97267341382318}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tuint8_t ep_num = udc_req_std_get_w_value();\n\n\tif (udc_req_std_get_w_length() != 2) {\n\t\treturn false;\n\t}\n\n\tif (ep_num == 0) {\n\t\tudc_req_std_write(0, 2);\n\t\treturn true;\n\t}\n\n\tif (udc_is_endpoint_halted(ep_num)) {\n\t\tudc_req_std_write(1, 2);\n\t} else {\n\t\tudc_req_std_write(0, 2);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 24.27686795853351}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tuint8_t ep;\n\tuint16_t status;\n\n\tif (udc_req_payload_size != sizeof(status)) {\n\t\treturn false;\n\t}\n\n\tep = udc_req_value & 0x0F;\n\tstatus = (udc_ep_halted(ep) ? 1 : 0);\n\tudc_req_payload_set(status, sizeof(status));\n\treturn true;\n}", "CodeBleu_score": 29.458233545624662}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tbool b_valid_iface;\n\tbool b_valid_setting;\n\tbool b_valid_request;\n\tbool b_req_handled;\n\n\tif (0 == udc_num_configuration) {\n\t\t// Device is not configured\n\t\treturn false;\n\t}\n\n\t// Get interface number\n\tiface_num = udc_setup_req->wIndex & 0xFF;\n\n\t// Get alternate setting number\n\tsetting_num = udc_setup_req->wValue & 0xFF;\n\n\t// Check if the requested interface number is valid\n\tb_valid_iface = udc_update_iface_desc(iface_num, 0);\n\n\tif (b_valid_iface) {\n\t\t// Check if the requested alternate setting number is valid\n\t\tb_valid_setting = udc_update_iface_desc(iface_num, setting_num);\n\n\t\tif (b_valid_setting) {\n\t\t\t// Check if the requested request is valid\n\t\t\tb_valid_request = (USB_REQ_SET_INTERFACE ==\n\t\t\t\t\tudc_setup_req->bRequest) ||\n\t\t\t\t\t(USB_REQ_GET_INTERFACE ==\n\t\t\t\t\tudc_setup_req->bRequest);\n\n\t\t\tif (b_valid_request) {\n\t\t\t\t// Forward request to the corresponding USB Device Interface (UDI) handler\n\t\t\t\tb_req_handled = udc_iface_data[iface_num].\n\t\t\t\t\t\tudi_api_setup->setup(\n\t\t\t\t\t\tudc_setup_req);\n\n\t\t\t\t// Return result of the handler's setup function\n\t\t\t\treturn b_req_handled;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Request is not valid\n\treturn false;\n}", "CodeBleu_score": 52.48415933580037}, {"code": "static bool udc_req_iface(void){\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tbool b_iface_found;\n\tbool b_setting_found;\n\tbool b_iface_changed;\n\tbool b_setting_changed;\n\n\t// Check if the device is in a configured state\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tiface_num = udc_req_value;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tb_iface_found = udc_update_iface_desc(iface_num, 0);\n\tif (!b_iface_found) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tsetting_num = udc_ptr_iface->bAlternateSetting;\n\tb_setting_found = udc_update_iface_desc(iface_num, setting_num);\n\tif (!b_setting_found) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface has been changed\n\tb_iface_changed = (iface_num != udc_iface_selected);\n\tif (b_iface_changed) {\n\t\t// Interface has been changed\n\t\t// Check if the alternate setting has been changed\n\t\tb_setting_changed = (setting_num != udc_setting_selected);\n\t\tif (b_setting_changed) {\n\t\t\t// Alternate setting has been changed\n\t\t\t// Call the UDI interface disconnect function\n\t\t\tif (NULL != udc_ptr_iface->udi_api->disconnect) {\n\t\t\t\tudc_ptr_iface->udi_api->disconnect(iface_num,\n\t\t\t\t\t\tsetting_num);\n\t\t\t}\n\t\t}\n\t\t// Call the UDI interface connect function\n\t\tif (NULL != udc_ptr_iface", "CodeBleu_score": 59.54935494402264}, {"code": "static bool udc_req_iface(void){\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tif (udc_ptr_setup->wIndex >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tif (!udc_update_iface_desc(udc_ptr_setup->wIndex, 0)) {\n\t\treturn false;\n\t}\n\n\tif (!udc_update_iface_desc(udc_ptr_setup->wIndex,\n\t\t\tudc_ptr_iface->bAlternateSetting)) {\n\t\treturn false;\n\t}\n\n\treturn udc_iface_setup();\n}", "CodeBleu_score": 48.88340702119158}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t// Reset all flags\n  udi_msc_b_cbw_invalid = false;\n  udi_msc_b_cbw_invalid_signature = false;\n  udi_msc_b_cbw_invalid_tag = false;\n  udi_msc_b_cbw_invalid_data_size = false;\n  udi_msc_b_cbw_invalid_direction = false;\n  udi_msc_b_cbw_invalid_lun = false;\n  udi_msc_b_cbw_invalid_field = false;\n  udi_msc_b_csw_invalid = false;\n  udi_msc_b_csw_invalid_signature = false;\n  udi_msc_b_csw_invalid_tag = false;\n  udi_msc_b_csw_invalid_data_size = false;\n  udi_msc_b_csw_invalid_status = false;\n  udi_msc_b_csw_invalid_field = false;\n  udi_msc_b_csw_invalid_phase = false;\n  udi_msc_b_csw_invalid_lun = false;\n  udi_msc_b_csw_invalid_status_not_set = false;\n  udi_msc_b_csw_invalid_status_not_set_no_phase = false;\n  udi_msc_b_csw_invalid_status_not_set_no_phase_no_lun = false;\n  udi_msc_b_csw_invalid_status_not_set_no_lun = false;\n  udi_msc_b_csw_invalid_status_not_set_no_lun_no_phase = false;\n  udi_msc_b_csw_invalid_status_not_set_no_phase_no_lun_no_data = false;\n  udi_msc_b_csw_invalid_status_not_set_no_lun_no_phase_no_data_no_tag = false", "CodeBleu_score": 10.295986206665695}, {"code": "bool udi_msc_enable(void){\n\t// Reset flags\n  udi_msc_b_cbw_invalid = false;\n  udi_msc_b_cbw_wait_csw = false;\n  udi_msc_b_csw_invalid = false;\n  udi_msc_b_csw_wait_cbw = false;\n  udi_msc_b_csw_phase_error = false;\n  udi_msc_b_csw_error = false;\n  udi_msc_b_csw_fail = false;\n  udi_msc_b_csw_pass = false;\n  // Reset CBW\n  memset(&udi_msc_cbw, 0, sizeof(udi_msc_cbw));\n  // Reset CSW\n  memset(&udi_msc_csw, 0, sizeof(udi_msc_csw));\n  // Get number of LUNs\n  udi_msc_nb_lun = udi_msc_get_nb_lun();\n  // Check if there are any LUNs available\n  if (!udi_msc_nb_lun)\n    return false;\n  // Unload medium on each LUN\n  for (uint8_t udi_msc_lun = 0; udi_msc_lun < udi_msc_nb_lun; udi_msc_lun++) {\n    // Unload medium on LUN\n    if (!udi_msc_unload_medium(udi_msc_lun))\n      return false;\n  }\n  // Start MSC process by waiting for a Command Block Wrapper (CBW) reception\n  udi_msc_cbw_wait();\n  return true;\n}", "CodeBleu_score": 51.890412694317845}, {"code": "bool udi_msc_enable(void){\n\t// Check if USB device is in SUSPENDED state\n  if (udd_is_suspended()) {\n    // USB device is in SUSPENDED state, then wait a resume\n    udd_sleep_mode(UDD_SLEEP_MODE_WAIT_RESUME);\n    return false;\n  }\n  // Check if USB device is in ATTACHED state\n  if (!udd_is_attached()) {\n    // USB device is not attached, then wait a connection event\n    udd_sleep_mode(UDD_SLEEP_MODE_WAIT_DEVICE);\n    return false;\n  }\n  // Check if MSC interface is already enabled\n  if (udi_msc_b_enable) {\n    return true;\n  }\n  // Reset all flags\n  udi_msc_b_reset = false;\n  udi_msc_b_reset_change = false;\n  udi_msc_b_stall_reset = false;\n  udi_msc_b_stall_reset_change = false;\n  udi_msc_b_stall_csw = false;\n  udi_msc_b_stall_csw_change = false;\n  udi_msc_b_cbw_invalid = false;\n  udi_msc_b_cbw_invalid_change = false;\n  udi_msc_b_cbw_aborted = false;\n  udi_msc_b_cbw_aborted_change = false;\n  udi_msc_b_csw_invalid = false;\n  udi_msc_b_csw_invalid_change = false;\n  udi_msc_b_csw_error = false;\n  udi_msc_b_csw_error_change = false;\n  udi_msc_b_csw_wait = false;\n  udi_msc_b_csw_wait_change = false;\n  udi_msc_b_csw_phase = UDI_MSC_CSW_PHASE_ERROR;", "CodeBleu_score": 28.615204041678645}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDD_EP_TRANSFER_OK != status) {\n    // Transfer error\n    // then STALL next request from USB host on corresponding endpoint\n    udd_ep_set_halt(ep);\n    return;\n  }\n  // Update data residue\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 74.03733773905776}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDD_EP_TRANSFER_OK != status) {\n    // Transfer error\n    // then STALL next request from USB host on corresponding endpoint\n    if (UDI_MSC_EP_IN == ep)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    return;\n  }\n  // Transfer complete\n  // Update data residue in CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 73.32935923812475}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif (UDD_EP_TRANSFER_OK != status) {\n    // Transfer error\n    if (UDD_EP_TRANSFER_STALL == status) {\n      // Stall sent\n      if (UDI_MSC_EP_IN == ep) {\n        // Stall sent on IN endpoint\n        // then Stall next request from USB host on corresponding endpoint\n        udd_ep_set_halt(UDI_MSC_EP_OUT);\n      } else {\n        // Stall sent on OUT endpoint\n        // then Stall next request from USB host on corresponding endpoint\n        udd_ep_set_halt(UDI_MSC_EP_IN);\n      }\n    }\n    // Wait a MSC setup reset to restart CBW reception\n    udi_msc_cbw_wait();\n  } else {\n    // Transfer success\n    if (UDI_MSC_EP_IN == ep) {\n      // IN endpoint\n      // Update the sense data\n      udi_msc_sense_pass();\n      // Decrease the data residue in the Command Status Wrapper (CSW)\n      udi_msc_csw.dCSWDataResidue -= nb_sent;\n      // Process the updated CSW\n      udi_msc_csw_process();\n    } else {\n      // OUT endpoint\n      // Update the sense data\n      udi_msc_sense_pass();\n      // Decrease the data residue in the Command Status Wrapper (CSW)\n      udi_msc_csw.dCSWDataResidue -= nb_sent;\n      // Process the updated CSW\n      udi_msc_csw_process();\n    }\n  }\n}", "CodeBleu_score": 66.25975707377243}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t// If there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n  if (udi_msc_cbw.dCBWDataTransferLength) {\n    if (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIRECTION_IN) {\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    } else {\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    }\n  }\n  // Prepare CSW by setting its tag and converting the data residue to little-endian format\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 70.12158266248221}, {"code": "static void udi_msc_csw_process(void){\n\t// If there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\n  if (udi_msc_cbw.dCBWDataTransferLength != 0) {\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n      // Stall IN endpoint\n      udd_ep_set_stall_wait(UDI_MSC_EP_IN);\n    } else {\n      // Stall OUT endpoint\n      udd_ep_set_stall_wait(UDI_MSC_EP_OUT);\n    }\n  }\n  // Prepare CSW by setting its tag and converting the data residue to little-endian format\n  udi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 63.05782390966969}, {"code": "static void udi_msc_csw_process(void){\n\t// Check if there is a non-zero data residue\n  if (udi_msc_cbw.data_transfer_length) {\n    // Stall the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW)\n    if (udi_msc_cbw.bm_flags.direction == UDI_MSC_CBW_DIRECTION_OUT) {\n      // Stall the next request from the USB host on the OUT endpoint\n      udd_ep_set_stall_wait(UDI_MSC_EP_OUT);\n    } else {\n      // Stall the next request from the USB host on the IN endpoint\n      udd_ep_set_stall_wait(UDI_MSC_EP_IN);\n    }\n  }\n\n  // Prepare the CSW by setting its tag and converting the data residue to little-endian format\n  udi_msc_csw.tag = udi_msc_cbw.tag;\n  udi_msc_csw.data_residue = udi_msc_cbw.data_transfer_length;\n  udi_msc_csw.data_residue_le = udi_msc_csw.data_residue;\n\n  // Send the CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 51.016333536324865}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (b_enable) {\n        if (usb_task_cdc_get_baud(port) == 1200) {\n            cancelReset();\n        }\n    } else {\n        if (usb_task_cdc_get_baud(port) == 1200) {\n            initiateReset();\n        }\n    }\n}", "CodeBleu_score": 34.79280580466819}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (b_enable) {\n\t\tcancelReset();\n\t} else {\n\t\tif (getDTRRate(port) == 1200) {\n\t\t\tscheduleReset(port);\n\t\t}\n\t}\n}", "CodeBleu_score": 33.1677113364061}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (b_enable) {\n        // DTR is enabled.\n        // Cancel any scheduled reset.\n        cancelReset();\n    } else {\n        // DTR is disabled.\n        // Check if the baud rate is 1200.\n        if (usb_task_cdc_get_baud_rate(port) == 1200) {\n            // Baud rate is 1200.\n            // Schedule a delayed system reset.\n            scheduleReset();\n        }\n    }\n}", "CodeBleu_score": 32.91941626403476}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t// If the current request is a Microsoft-compatible ID request\n\tif (usb_request.bmRequestType == USB_SETUP_RECIPIENT_DEVICE && usb_request.bRequest == 0x04) {\n\n\t\t// Set up the payload and size for the Microsoft-compatible ID descriptor\n\t\tusb_payload = (uint8_t*) &usb_ms_compat_id_desc;\n\t\tusb_payload_size = sizeof(usb_ms_compat_id_desc);\n\n\t\t// Return \"true\" to indicate that the request was processed\n\t\treturn true;\n\t}\n\n\t// If the current request is a Microsoft-compatible extended properties request\n\tif (usb_request.bmRequestType == USB_SETUP_RECIPIENT_DEVICE && usb_request.bRequest == 0x05) {\n\n\t\t// Set up the payload and size for the Microsoft-compatible extended properties descriptor\n\t\tusb_payload = (uint8_t*) &usb_ms_ext_prop_desc;\n\t\tusb_payload_size = sizeof(usb_ms_ext_prop_desc);\n\n\t\t// Return \"true\" to indicate that the request was processed\n\t\treturn true;\n\t}\n\n\t// Return \"false\" to indicate that the request was not processed\n\treturn false;\n}", "CodeBleu_score": 22.64691554856854}, {"code": "bool usb_task_other_requests(void){\n\t// Check if the request is a Microsoft-compatible ID request\n    if (usb_setup.wIndex == 0x04) {\n        // Set the pointer to the Microsoft-compatible ID descriptor\n        usb_setup.wIndex = 0x00;\n        usb_setup.wLength = sizeof(usb_microsoft_compatible_id_descriptor);\n        return true;\n    }\n\n    // Check if the request is an extended properties request\n    if (usb_setup.wIndex == 0x05) {\n        // Set the pointer to the extended properties descriptor\n        usb_setup.wIndex = 0x00;\n        usb_setup.wLength = sizeof(usb_extended_properties_descriptor);\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 15.513966196649362}, {"code": "bool usb_task_other_requests(void){\n\tuint8_t request_type;\n  uint8_t request_index;\n  uint8_t request_value;\n\n  request_type = usb_setup.bmRequestType & USB_BMREQUESTTYPE_TYPE_MASK;\n  request_index = usb_setup.bRequest;\n  request_value = usb_setup.wValue.bytes[0];\n\n  if (request_type == USB_BMREQUESTTYPE_TYPE_VENDOR && request_index == 0x04) {\n    usb_setup.wIndex.word = 0;\n    usb_setup.wLength.word = 2;\n    usb_setup.wValue.word = 0x0001;\n    usb_setup.bRequest = 0x06;\n    return true;\n  }\n\n  if (request_type == USB_BMREQUESTTYPE_TYPE_VENDOR && request_index == 0x05) {\n    usb_setup.wIndex.word = 0;\n    usb_setup.wLength.word = 0x0004;\n    usb_setup.wValue.word = 0x0003;\n    usb_setup.bRequest = 0x06;\n    return true;\n  }\n\n  if (request_type == USB_BMREQUESTTYPE_TYPE_VENDOR && request_index == 0x06) {\n    usb_setup.wIndex.word = 0;\n    usb_setup.wLength.word = 0x0008;\n    usb_setup.wValue.word = 0x0004;\n    usb_setup.bRequest = 0x06;\n    return true;\n  }\n\n  if (request_type == USB_BMREQUESTTYPE_TYPE_VENDOR && request_index == 0x07) {\n    usb_setup.wIndex.word = 0;\n    usb_setup.wLength.word = 0x0008;\n    usb_setup.wValue.word = 0x0005;\n    usb", "CodeBleu_score": 28.909090075401956}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n\n  if (nbyte == 0) {\n    return;\n  }\n\n  for (i = 0; i < nbyte - 1; i++) {\n    SPI_DR = 0xFF;\n    while (!(SPI_SR & SPI_SR_RXNE)) {\n    }\n    buf[i] = SPI_DR;\n  }\n  buf[i] = spiRec();\n}", "CodeBleu_score": 52.09205750541898}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n\n    if (nbyte == 0)\n        return;\n\n    for (i = 0; i < nbyte - 1; i++) {\n        SPI1BUF = 0xFF;\n        while (!SPI1STATbits.SPIRBF)\n            ;\n        buf[i] = SPI1BUF;\n    }\n    buf[i] = spiRec();\n}", "CodeBleu_score": 49.716053513936764}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n\n    if (nbyte == 0) return;\n\n    for (i = 0; i < nbyte - 1; i++) {\n        spiSend(0x00);\n        buf[i] = spiRec();\n    }\n\n    buf[i] = spiRecLast();\n}", "CodeBleu_score": 46.834390947729354}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n    uint32_t primask;\n\n    primask = __get_PRIMASK();\n    __disable_irq();\n\n    oldHandler = (pfnISR_Handler)__Vectors[irq + 16];\n    __Vectors[irq + 16] = (uint32_t)newHandler;\n\n    __set_PRIMASK(primask);\n    return oldHandler;\n}", "CodeBleu_score": 56.43348587234745}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n\tuint32_t *vectors = (uint32_t *)SCB->VTOR;\n\tuint32_t irq_offset = irq + 16;\n\tuint32_t *irq_handler = &vectors[irq_offset];\n\n\t/* Disable global interrupts to ensure atomic operation */\n\t__disable_irq();\n\n\t/* Get the original ISR handler */\n\toldHandler = (pfnISR_Handler) *irq_handler;\n\n\t/* Replace the ISR handler with the new handler */\n\t*irq_handler = (uint32_t)newHandler;\n\n\t/* Re-enable global interrupts */\n\t__enable_irq();\n\n\treturn oldHandler;\n}", "CodeBleu_score": 47.06644237709728}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler = 0;\n    uint32_t *vectors = (uint32_t *)SCB->VTOR;\n    uint32_t irqMask = (1 << ((uint32_t)(irq) & 0x1F));\n\n    // Disable global interrupts to ensure atomic operation\n    __disable_irq();\n\n    // Retrieve the current handler for the specified IRQ\n    oldHandler = (pfnISR_Handler)(vectors[(((uint32_t)irq) >> 5) + 16]);\n\n    // Replace the current handler with the new handler\n    vectors[(((uint32_t)irq) >> 5) + 16] = (uint32_t)newHandler;\n\n    // Enable global interrupts\n    __enable_irq();\n\n    // Return the original ISR handler\n    return oldHandler;\n}", "CodeBleu_score": 48.718398042438096}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\tint c = -1;\n  if (usb_serial_available()) {\n    c = usb_serial_peek();\n    if (c != -1) {\n      if (emergency_parser.enabled) emergency_parser.update(c);\n      if (c == '\\r') c = '\n';\n    }\n  }\n  return c;\n}", "CodeBleu_score": 42.90092398661274}, {"code": "int MarlinSerialUSB::peek(){\n\tint c = -1;\n  if (usb_serial_available()) {\n    c = usb_serial_peek();\n    if (c >= 0 && parser.enabled) {\n      if (parser.process(c)) {\n        c = -1;\n        if (parser.abort_on_error) {\n          usb_serial_flush_input();\n        }\n      }\n    }\n  }\n  return c;\n}", "CodeBleu_score": 42.028302770014065}, {"code": "int MarlinSerialUSB::peek(){\n\tif (!USB_SERIAL_CONNECTION_ENABLED) return -1;\n  if (usb_serial_available() > 0) {\n    int c = usb_serial_getchar();\n    if (c < 0) return -1;\n    if (emergency_parser.enabled) emergency_parser.update(c);\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 41.86498530031252}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\tif (ring_buffer_bytes_available()) return ring_buffer_read();\n  if (!(usb_product_id == 0x584C && usb_serial_has_read_callback)) return -1;\n  if (!usb_serial_available()) return -1;\n  return usb_serial_read();\n}", "CodeBleu_score": 17.227665948843946}, {"code": "int MarlinSerialUSB::read(){\n\tif (pending_rx_count) return pending_rx_buffer[--pending_rx_count];\n  if (!usb_cdc_is_enabled || !usb_cdc_is_connected) return -1;\n  if (!usb_cdc_data_waiting()) return -1;\n  return usb_cdc_getc();\n}", "CodeBleu_score": 24.395201868645128}, {"code": "int MarlinSerialUSB::read(){\n\tif (pending_rx_count) {\n    // If there is a pending character, return it\n    pending_rx_count--;\n    return pending_rx_buffer[pending_rx_index++];\n  }\n  else if (!usb_serial_connected) {\n    // If the USB CDC is not enabled, return -1\n    return -1;\n  }\n  else if (!usb_serial_available()) {\n    // If no bytes are available to read, return -1\n    return -1;\n  }\n  else {\n    // Read the next byte from the PC\n    const int c = usb_serial_read();\n\n    #if ENABLED(EMERGENCY_PARSER)\n      emergency_parser.update(c);\n    #endif\n\n    return c;\n  }\n}", "CodeBleu_score": 38.69967373474204}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\tif (cdc_enabled) return CDC_RX_Available();\n  return 0;\n}", "CodeBleu_score": 13.957542737993005}, {"code": "int MarlinSerialUSB::available(){\n\tif (usb_serial_available()) return usb_serial_read_buffer_length();\n  return 0;\n}", "CodeBleu_score": 16.330646602380387}, {"code": "int MarlinSerialUSB::available(){\n\tif (m_rx_buffer_ptr > m_rx_buffer_tail) return m_rx_buffer_ptr - m_rx_buffer_tail;\n  return (CDC_RX_BUFFER_SIZE + m_rx_buffer_ptr - m_rx_buffer_tail);\n}", "CodeBleu_score": 35.36977428558325}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t *pflash = (uint8_t*)getFlashStorage(curPage + curGroup * PagesPerGroup);\n\n  uint16_t i = 0;\n  while (i <= (PageSize - 4)) { /* (PageSize - 4) because otherwise, there is not enough room for data and headers */\n\n    // Get the address of the block\n    uint16_t baddr = pflash[i] | (pflash[i + 1] << 8);\n\n    // Get the length of the block\n    uint8_t blen = pflash[i + 2];\n\n    // If we reach the end of the list, break loop\n    if (blen == 0xFF)\n      break;\n\n    // Check if data is contained in this block\n    if (pos >= baddr && pos < (baddr + blen)) {\n\n      // Yes, it is contained.\n      uint8_t *ptr = &pflash[i + 3];\n      uint8_t *val = &value[pos - baddr];\n      uint16_t len = baddr + blen - pos;\n\n      // If we are writing, write the data to the value buffer\n      if (writing) {\n        while (len--)\n          *val++ = *ptr++;\n      }\n      else {\n        // If we are not writing, just advance the pointer\n        ptr += len;\n      }\n\n      // Update the CRC\n      crc16(crc, &pflash[i + 3 + pos - baddr], blen - pos + baddr);\n\n      // Increment the position\n      pos += blen - pos + baddr;\n\n      // Return \"true\" if we have read the whole size\n      return pos == (baddr + blen);\n    }\n\n    // As blocks are always sorted, if the starting address of this block is higher\n    // than the address we are looking for, break loop now - We wont find the value\n    // associated to the address\n    if (baddr > pos)\n      break;\n\n    // Jump to the next block\n    i += 3 + blen;\n  }", "CodeBleu_score": 37.39965474601388}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t c;\n  while (size--) {\n    c = ee_Read(pos);\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 75.40954163582015}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tif (!writing) {\n    while (size--) {\n      uint8_t v = ee_Read(pos);\n      if (value) *value = v;\n      crc16(crc, &v, 1);\n      ++pos;\n    }\n    return false;\n  }\n\n  while (size--) {\n    uint8_t v = ee_Read(pos, true);\n    if (v != ee_Read(pos, false)) {\n      ee_Write(pos, v);\n      if (value) *value = v;\n      crc16(crc, &v, 1);\n      ++pos;\n    }\n    else {\n      if (value) *value = v;\n      ++pos;\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 52.06614762427323}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tint8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n\n  // No hardware PWM channel available, use software PWM\n  if (cid == -1) {\n    // No software PWM state for this pin, allocate one\n    cid = get_soft_pwm_channel(pin);\n    if (cid < 0) return;\n\n    // Start the software PWM timer if this is the first PWM pin used\n    if (pwm_count == 0) {\n      // Setup the timer\n      ledcSetup(SOFT_PWM_TIMER, SOFT_PWM_FREQ, SOFT_PWM_RES);\n      // Attach the ISR to the timer\n      ledcAttachPin(pin, SOFT_PWM_TIMER);\n      // Start the timer\n      ledcWrite(SOFT_PWM_TIMER, 0);\n    }\n\n    // Increment the used PWM count\n    pwm_count++;\n  }\n\n  // Set the PWM value\n  soft_pwm_info[cid].pin = pin;\n  soft_pwm_info[cid].value = value;\n  soft_pwm_info[cid].freq = freq;\n  soft_pwm_info[cid].res = res;\n  soft_pwm_info[cid].count = 0;\n}", "CodeBleu_score": 53.72373680680622}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (pin >= NUM_DIGITAL_PINS) return;\n\n  if (!WITHIN(value, 0, 255)) return;\n\n  const uint16_t scaled = value * 127 / 255;\n\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, scaled);\n    return;\n  }\n\n  // Software PWM\n  uint8_t slot = 0;\n  for (uint8_t i = 0; i < NUM_SOFTWARE_PWM; i++) {\n    if (soft_pwm_state[i].pin == pin) {\n      slot = i;\n      break;\n    }\n  }\n  if (slot == 0) {\n    for (uint8_t i = 0; i < NUM_SOFTWARE_PWM; i++) {\n      if (soft_pwm_state[i].pin == 0) {\n        slot = i;\n        break;\n      }\n    }\n  }\n  if (slot == 0) return; // No PWM slots available\n\n  if (soft_pwm_state[slot].pin == 0) {\n    soft_pwm_state[slot].pin = pin;\n    soft_pwm_state[slot].count = 0;\n    soft_pwm_state[slot].on_tick = 0;\n    soft_pwm_state[slot].on_cycle = 0;\n    soft_pwm_state[slot].isr_enabled = 0;\n    soft_pwm_state[slot].freq = freq;\n    soft_pwm_state[slot].res = res;\n\n    soft_pwm_state[slot].timer = timerBegin(0, 80, true);\n    timerAttachInterrupt(soft_pwm_state[slot].timer, soft_pwm_isr, true);\n    timerAlarm", "CodeBleu_score": 57.45163814490353}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tuint32_t pwm_freq = freq;\n  uint16_t pwm_res = res;\n  int8_t cid = get_pwm_channel(pin, pwm_freq, pwm_res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n\n  // Not a hardware PWM pin?\n  if (WITHIN(pin, 1, MAX_PWM_IOPIN)) {\n    // Use software PWM\n    if (pwm_count == 0) {\n      // First PWM pin used? Start the timer.\n      ledcSetup(PWM_TIMER, PWM_FREQUENCY, PWM_RESOLUTION);\n      ledcAttachPin(pin, PWM_TIMER);\n    }\n    if (pwm_count >= MAX_PWM_CHANNELS) {\n      // Too many PWM pins?\n      SERIAL_ECHO_START();\n      SERIAL_ECHOLNPAIR(\"PWM: Too many PWM pins (\", pwm_count, \").\");\n      return;\n    }\n    // Allocate PWM to this pin\n    pwm_pin[pwm_count] = pin;\n    pwm_count++;\n    ledcWrite(PWM_TIMER, value);\n  }\n}", "CodeBleu_score": 48.5631053328006}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\tstatic_assert(NUM_SERVOS <= MAX_SERVOS, \"The number of servos attached exceeds the MAX_SERVOS value.\");\n  if (channel < 0) {\n    channel = attach();\n    if (channel < 0) return;\n  }\n  write(value);\n  safe_delay(delay_microseconds[channel]);\n  #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n    detach();\n  #endif\n}", "CodeBleu_score": 52.645711968703125}, {"code": "void Servo::move(const int value){\n\tstatic_assert(NUM_SERVOS <= MAX_SERVOS, \"NUM_SERVOS exceeds MAX_SERVOS. Please increase MAX_SERVOS in Configuration.h.\");\n  static_assert(NUM_SERVOS <= MAX_SERVO_INDEX, \"NUM_SERVOS exceeds MAX_SERVO_INDEX. Please increase MAX_SERVO_INDEX in Configuration.h.\");\n  static_assert(NUM_SERVOS <= MAX_PCA9685_SERVOS, \"NUM_SERVOS exceeds MAX_PCA9685_SERVOS. Please increase MAX_PCA9685_SERVOS in Configuration.h.\");\n  if (channel < 0) return;\n  if (channel >= NUM_SERVOS) return;\n  if (servo_delay[channel] > 0) safe_delay(servo_delay[channel]);\n  write(value);\n  #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n    detach();\n  #endif\n}", "CodeBleu_score": 46.195880325008964}, {"code": "void Servo::move(const int value){\n\tstatic_assert(NUM_SERVOS <= MAX_SERVOS, \"MAX_SERVOS is too small\");\n  if (channel < 0) return;\n  write(value);\n  safe_delay(delay_microseconds(channel));\n  #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n    detach();\n  #endif\n}", "CodeBleu_score": 41.96376862922764}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\tuint8_t i;\n  uint8_t bit;\n  uint8_t port_data;\n  uint8_t port_mask;\n  uint8_t port_state;\n  uint8_t port_state_mask;\n  uint8_t port_state_bit;\n  uint8_t port_state_mask_inv;\n  uint8_t port_state_bit_inv;\n  uint8_t port_state_bit_inv_mask;\n  uint8_t port_state_bit_inv_mask_inv;\n  uint8_t pwm_tick_count;\n  uint8_t pwm_tick_count_mask;\n  uint8_t pwm_tick_count_mask_inv;\n  uint8_t pwm_tick_count_mask_inv_mask;\n  uint8_t pwm_tick_count_mask_inv_mask_inv;\n  uint8_t pwm_tick_count_mask_inv_mask_inv_mask;\n  uint8_t pwm_tick_count_mask_inv_mask_inv_mask_inv;\n  uint8_t pwm_tick_count_mask_inv_mask_inv_mask_inv_mask;\n  uint8_t pwm_tick_count_mask_inv_mask_inv_mask_inv_mask_inv;\n  uint8_t pwm_tick_count_mask_inv_mask_inv_mask_inv_mask_inv_mask;\n  uint8_t pwm_tick_count_mask_inv_mask_inv_mask_inv_mask_inv_mask_inv;\n  uint8_t pwm_tick_count_mask_inv_mask_inv_mask_inv_mask_inv_mask_inv_mask;\n  uint8_t pwm_tick_count_mask_inv_mask_inv_mask_inv_mask_inv_mask_inv_mask_inv;\n  uint8_t pwm_tick_count_mask_inv_mask_inv_mask_inv_mask_inv_mask_inv_mask_inv_mask;\n  uint", "CodeBleu_score": 4.774243960555335}, {"code": "void i2s_push_sample(){\n\t// For each pin, check if the pin has active PWM by evaluating its duty cycle.\n    for (uint8_t i = 0; i < PWM_PIN_COUNT; i++) {\n        if (pwm_duty_cycles[i] > 0) {\n            // If the PWM tick count reaches zero, it toggles the pin state between high and low based on its current state and sets the tick count for the next transition.\n            if (pwm_ticks[i] == 0) {\n                // Toggle the pin state between high and low based on its current state.\n                if (pwm_states[i] == 0) {\n                    pwm_states[i] = 1;\n                } else {\n                    pwm_states[i] = 0;\n                }\n                // Set the tick count for the next transition.\n                pwm_ticks[i] = pwm_periods[i];\n            } else {\n                // Decrement the tick count for the next transition.\n                pwm_ticks[i]--;\n            }\n        }\n    }\n\n    // Store the updated port data into the current position of the DMA buffer and increment the buffer position.\n    i2s_buffer[i2s_buffer_position] = 0;\n    for (uint8_t i = 0; i < PWM_PIN_COUNT; i++) {\n        if (pwm_states[i] == 0) {\n            i2s_buffer[i2s_buffer_position] |= (1 << i);\n        }\n    }\n    i2s_buffer_position++;\n\n    // If the DMA buffer is full, start the next transmission.\n    if (i2s_buffer_position == I2S_BUFFER_LENGTH) {\n        i2s_buffer_position = 0;\n        i2s_tx_buffer_full_flag = 1;\n    }\n}", "CodeBleu_score": 38.31048237125759}, {"code": "void i2s_push_sample(){\n\t// Check if the PWM tick count for each pin has reached zero.\n    if (pwm_tick_count[0] == 0) {\n        // If the PWM tick count has reached zero, toggle the pin state and set the tick count for the next transition.\n        if (pwm_state[0] == 0) {\n            pwm_state[0] = 1;\n        } else {\n            pwm_state[0] = 0;\n        }\n        pwm_tick_count[0] = pwm_tick_count_max;\n    } else {\n        // If the PWM tick count has not reached zero, decrement the tick count.\n        pwm_tick_count[0]--;\n    }\n    // Check if the PWM tick count for each pin has reached zero.\n    if (pwm_tick_count[1] == 0) {\n        // If the PWM tick count has reached zero, toggle the pin state and set the tick count for the next transition.\n        if (pwm_state[1] == 0) {\n            pwm_state[1] = 1;\n        } else {\n            pwm_state[1] = 0;\n        }\n        pwm_tick_count[1] = pwm_tick_count_max;\n    } else {\n        // If the PWM tick count has not reached zero, decrement the tick count.\n        pwm_tick_count[1]--;\n    }\n    // Check if the PWM tick count for each pin has reached zero.\n    if (pwm_tick_count[2] == 0) {\n        // If the PWM tick count has reached zero, toggle the pin state and set the tick count for the next transition.\n        if (pwm_state[2] == 0) {\n            pwm_state[2] = 1;\n        } else {\n            pwm_state[2] = 0;\n        }\n        pwm_tick_count[2] = pwm_tick_count_max;\n    } else {\n        // If the PWM", "CodeBleu_score": 32.35635812056671}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\tuint32_t count = 0;\n    if (timer_num == 0) {\n        count = TIMER0->TCNT;\n    } else if (timer_num == 1) {\n        count = TIMER1->TCNT;\n    } else if (timer_num == 2) {\n        count = TIMER2->TCNT;\n    } else if (timer_num == 3) {\n        count = TIMER3->TCNT;\n    } else if (timer_num == 4) {\n        count = TIMER4->TCNT;\n    } else if (timer_num == 5) {\n        count = TIMER5->TCNT;\n    } else {\n        count = 0;\n    }\n    return count;\n}", "CodeBleu_score": 30.532932076963164}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t current_counter = 0;\n\n\t/*\n\t * The function \"HAL_timer_get_count\" retrieves the current counter value of a specified hardware timer.\nIt takes a timer number as input, accesses the corresponding timer configuration, and fetches the current counter value from the timer.\nThe function then returns this counter value.\n\t */\n\tswitch (timer_num) {\n\tcase HAL_TIMER_0:\n\t\tcurrent_counter = TIMER0_CNT;\n\t\tbreak;\n\tcase HAL_TIMER_1:\n\t\tcurrent_counter = TIMER1_CNT;\n\t\tbreak;\n\tcase HAL_TIMER_2:\n\t\tcurrent_counter = TIMER2_CNT;\n\t\tbreak;\n\tcase HAL_TIMER_3:\n\t\tcurrent_counter = TIMER3_CNT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn current_counter;\n}", "CodeBleu_score": 28.266453636342824}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\treturn (hal_timer_t)0;\n}", "CodeBleu_score": 6.821087192047072}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint8_t c;\n  LOOP_L_N(i, size) {\n    c = eeprom_read_byte((uint8_t*)pos);\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 52.76722237152593}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint8_t c;\n  LOOP_L_N(i, size) {\n    c = eeprom_read_byte((uint8_t*)(persistent_store_address + pos + i));\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n  }\n  pos += size;\n  return false;\n}", "CodeBleu_score": 67.02922293836858}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tuint8_t * const start = value;\n  LOOP_L_N(i, size) {\n    uint8_t v = eeprom_read_byte((uint8_t*)pos);\n    if (writing) *value = v;\n    crc16(crc, &v, 1);\n    pos++;\n    value++;\n  }\n  return pos < (int)eeprom_index_size();\n}", "CodeBleu_score": 38.75136879816329}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (SDIO == NULL || src == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: invalid parameter(s)\n\");\n\t\treturn false;\n\t}\n\n\tint retries = 0;\n\twhile (retries < MAX_SDIO_RETRIES) {\n\t\tif (SDIO_WriteBlock_Impl(block, src)) {\n\t\t\treturn true;\n\t\t}\n\t\tretries++;\n\t}\n\tprintf(\"SDIO_WriteBlock: failed to write block %lu\n\", block);\n\treturn false;\n}", "CodeBleu_score": 33.61572961080112}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (!sdioHandle || !src) {\n        return false;\n    }\n    uint32_t status;\n    uint32_t retryCount = 0;\n    do {\n        status = SD_WriteBlock(sdioHandle, block, src, SD_TRANSFER_TIMEOUT);\n        if (status != kStatus_Success) {\n            retryCount++;\n            if (retryCount == SD_WRITE_RETRY_TIMES) {\n                PRINTF(\"Write block failed with error 0x%x\n\", status);\n                return false;\n            }\n        } else {\n            break;\n        }\n    } while (true);\n    return true;\n}", "CodeBleu_score": 34.5264579753771}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tuint32_t i;\n  uint32_t timeout;\n\n  if (!src) {\n    printf(\"SDIO_WriteBlock: Error! Source pointer is null\n\");\n    return false;\n  }\n\n  if (!hsd.Instance) {\n    printf(\"SDIO_WriteBlock: Error! SDIO handle is null\n\");\n    return false;\n  }\n\n  for (i = 0; i < SD_BLOCK_WRITE_RETRY_COUNT; i++) {\n    timeout = SD_DATATIMEOUT;\n    if (HAL_SDIO_WriteBlocks_DMA(&hsd, (uint32_t *)src, block, 1) == HAL_OK) {\n      while (!__HAL_SD_GET_FLAG(&hsd, SDIO_FLAG_TXFIFOHE)) {\n        if (__HAL_SD_GET_FLAG(&hsd, SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_STBITERR)) {\n          printf(\"SDIO_WriteBlock: Error! Write operation failed\n\");\n          return false;\n        }\n\n        if (__HAL_SD_GET_FLAG(&hsd, SDIO_FLAG_TXUNDERR)) {\n          printf(\"SDIO_WriteBlock: Error! Tx FIFO underrun error\n\");\n          return false;\n        }\n\n        if (timeout-- == 0) {\n          printf(\"SDIO_WriteBlock: Error! Write operation timeout\n\");\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n\n  printf(\"SDIO_WriteBlock: Error! Write operation failed after %d retries\n\", SD_BLOCK_WRITE_RETRY_COUNT);\n  return false;\n}", "CodeBleu_score": 38.952729971149836}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t// Start the timer with the given frequency and prescale\n    timer_start(timer_num, frequency);\n\n    // Set the callback priority for temperature or stepper\n    if (timer_num == TEMP_TIMER_NUM) {\n        NVIC_SetPriority(TEMP_TIMER_IRQn, TEMP_TIMER_PRIORITY);\n    } else if (timer_num == STEP_TIMER_NUM) {\n        NVIC_SetPriority(STEP_TIMER_IRQn, STEP_TIMER_PRIORITY);\n    } else {\n        // If the timer channel is invalid, trigger an assertion failure\n        assert(false);\n    }\n}", "CodeBleu_score": 35.04879939364886}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t// Check if the timer channel is valid\n    if (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n        // Initialize the temperature timer with the given frequency and temperature timer prescale\n        TIMER_Init(TEMPERATURE_TIMER, &(timer_config_t){\n            .prescale = TEMPERATURE_TIMER_PRESCALE,\n            .counter_dir = TIMER_COUNT_UP,\n            .alarm_en = TIMER_ALARM_EN,\n            .intr_type = TIMER_INTR_LEVEL,\n            .counter_en = TIMER_PAUSE,\n            .auto_reload = TIMER_AUTORELOAD_EN,\n            .divider = 1\n        });\n        // Set the temperature timer callback priority\n        TIMER_SetCounterMode(TEMPERATURE_TIMER, TIMER_PAUSE);\n        TIMER_SetAlarm(TEMPERATURE_TIMER, TIMER_DIVIDER_US * 1000000 / frequency);\n        TIMER_EnableIntr(TEMPERATURE_TIMER);\n        TIMER_SetISR(TEMPERATURE_TIMER, temperature_timer_isr, NULL);\n        TIMER_Start(TEMPERATURE_TIMER);\n    }\n    else if (timer_num == TIMER_CHANNEL_STEPPER) {\n        // Initialize the stepper timer with the given frequency and stepper timer prescale\n        TIMER_Init(STEPPER_TIMER, &(timer_config_t){\n            .prescale = STEPPER_TIMER_PRESCALE,\n            .counter_dir = TIMER_COUNT_UP,\n            .alarm_en = TIMER_ALARM_EN,\n            .intr_type = TIMER_INTR_LEVEL,\n            .counter_en = TIMER_PAUSE,\n            .auto_reload = TIMER_AUTORELOAD_EN,", "CodeBleu_score": 33.25822605659319}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tif (timer_num == TEMP_TIMER_CH) {\n        // Set the timer prescale to 1000000000/frequency\n        TCCR1B = (1 << CS12) | (1 << CS10);\n        TCCR1B &= ~(1 << CS11);\n        // Set the callback priority for temperature\n        TIMSK1 |= (1 << OCIE1A);\n        // Set the timer counter to 0\n        TCNT1 = 0;\n        // Set the compare value to the period\n        OCR1A = 1000000000/frequency;\n        // Start the timer\n        TCCR1B |= (1 << CS12);\n    } else if (timer_num == STEP_TIMER_CH) {\n        // Set the timer prescale to 1000000000/frequency\n        TCCR2B = (1 << CS22) | (1 << CS20);\n        TCCR2B &= ~(1 << CS21);\n        // Set the callback priority for stepper\n        TIMSK2 |= (1 << OCIE2A);\n        // Set the timer counter to 0\n        TCNT2 = 0;\n        // Set the compare value to the period\n        OCR2A = 1000000000/frequency;\n        // Start the timer\n        TCCR2B |= (1 << CS22);\n    } else {\n        // If the timer channel is invalid, it triggers an assertion failure\n        assert(0);\n    }\n}", "CodeBleu_score": 33.12711270842726}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t#if ENABLED(SDSUPPORT)\n\n    if (card.isMounted()) {\n\n      // Open the EEPROM file\n      if (!eeprom_file.open(filename, O_RDWR | O_CREAT)) {\n        SERIAL_ERROR_START();\n        SERIAL_ERRORLNPGM(MSG_SD_ERR_OPEN_EEPROM_FILE);\n        return false;\n      }\n\n      // Get the file size\n      int32_t fileSize = eeprom_file.fileSize();\n\n      // If the file is too small, fill the remainder with a default erase value\n      if (fileSize < EEPROM_SIZE) {\n        uint16_t bytesToWrite = EEPROM_SIZE - fileSize;\n        uint8_t write_buf[bytesToWrite];\n        memset(write_buf, eeprom_type == (uint8_t)EEPROM_I2C ? 0xFF : 0, bytesToWrite);\n        eeprom_file.write(write_buf, bytesToWrite);\n      }\n\n      // If the file is too large, truncate it\n      if (fileSize > EEPROM_SIZE) {\n        eeprom_file.truncate(EEPROM_SIZE);\n        fileSize = EEPROM_SIZE;\n      }\n\n      // Read the file into the buffer\n      eeprom_file.seekSet(0);\n      eeprom_file.read(eeprom_data, fileSize);\n\n      // Close the file\n      eeprom_file.close();\n\n      return true;\n    }\n\n  #endif // SDSUPPORT\n\n  return false;\n}", "CodeBleu_score": 38.74693037783714}, {"code": "bool PersistentStore::access_start(){\n\t#ifdef DEBUG_PRINT\n    SERIAL_ECHOPGM(\"PersistentStore::access_start()\");\n  #endif\n\n  #if ENABLED(SDSUPPORT)\n    if (card.flag.mounting) return false;\n  #endif\n\n  #if ENABLED(EEPROM_SETTINGS)\n\n    if (!eeprom_file_open(true)) return false;\n\n    eeprom_file_size = eeprom_file.fileSize();\n\n    if (eeprom_file_size < (size_t)EEPROM_SIZE) {\n      #ifdef DEBUG_PRINT\n        SERIAL_ECHOPGM(\" EEPROM_SIZE:\");\n        SERIAL_ECHOLN(EEPROM_SIZE);\n        SERIAL_ECHOPGM(\" eeprom_file_size:\");\n        SERIAL_ECHOLN(eeprom_file_size);\n      #endif\n      eeprom_file_close();\n      return false;\n    }\n\n    eeprom_file.read(eeprom_data, EEPROM_SIZE);\n    eeprom_file_close();\n\n    return true;\n\n  #else\n    return false;\n  #endif\n}", "CodeBleu_score": 34.97681980994838}, {"code": "bool PersistentStore::access_start(){\n\tif (file) return true;\n\n  if (file_name) {\n    file = fopen(file_name, \"rb\");\n    if (!file) return false;\n    if (fread(buffer, 1, size, file) != size) {\n      fclose(file);\n      return false;\n    }\n    fclose(file);\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 25.767607089981816}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPI_PORT, SPI_MISO_PIN) == GPIO_PIN_SET) {\n\t\t\tr |= 0x01;\n\t\t}\n\t\tr <<= 1;\n\t\tb <<= 1;\n\t}\n\treturn r;\n}", "CodeBleu_score": 37.12186117857812}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t rb = 0;\n\tuint8_t i = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_RESET);\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin)) {\n\t\t\trb |= 1;\n\t\t}\n\t\trb <<= 1;\n\t\tb <<= 1;\n\t}\n\n\treturn rb;\n}", "CodeBleu_score": 36.683263577246684}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t bit;\n\tuint8_t byte = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < 8; i++) {\n\n\t\tHAL_SPI_STM32_SpiSetClockPin_Low();\n\t\tbit = (b >> 7) & 0x01;\n\t\tHAL_SPI_STM32_SpiSetMosiPin(bit);\n\t\tHAL_SPI_STM32_SpiSetClockPin_High();\n\t\tbit = HAL_SPI_STM32_SpiGetMisoPin();\n\t\tbyte = (byte << 1) | bit;\n\t\tb = b << 1;\n\t}\n\n\treturn byte;\n}", "CodeBleu_score": 35.798739967995466}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE) {\n    /* Enable the AHB peripheral clock by setting the bit in the AHBENR register */\n    RCC->AHBENR |= RCC_AHBPeriph;\n  }\n  else {\n    /* Disable the AHB peripheral clock by clearing the bit in the AHBENR register */\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 85.58291844853368}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE) {\n    /* Enable the selected AHB peripheral clock */\n    RCC->AHBENR |= RCC_AHBPeriph;\n  }\n  else {\n    /* Disable the selected AHB peripheral clock */\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 85.58291844853368}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE) {\n    /* Enable the selected AHB peripheral clock */\n    RCC->AHBENR |= RCC_AHBPeriph;\n  }\n  else {\n    /* Disable the selected AHB peripheral clock */\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}", "CodeBleu_score": 85.58291844853368}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c;\n  if (!serial_readable(obj)) return;\n  c = serial_getc(obj);\n  if (MarlinSerial::emergency_parser.add_char(c)) return;\n  if (MarlinSerial::rx_buffer_index >= (RX_BUFFER_SIZE - 1)) {\n    // No room: Increase rx_dropped_bytes\n    MarlinSerial::rx_dropped_bytes++;\n  }\n  else {\n    // Room: Store received byte and increase rx_buffer_loop_count\n    MarlinSerial::rx_buffer[MarlinSerial::rx_buffer_index] = c;\n    MarlinSerial::rx_buffer_index++;\n    MarlinSerial::rx_buffer_loop_count++;\n  }\n}", "CodeBleu_score": 31.210036059889312}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t// Read one byte from the receive data register\n  uint8_t c = (uint8_t)obj->uart->RXDATA;\n\n  // If the parity is ok, store the new byte in the buffer\n  if ((obj->uart->RXSTATUS & UART_RXSTATUS_PARITYERROR_Msk) == 0) {\n    if (obj->rx_buff.head == obj->rx_buff.tail) {\n      // save new data in buffer: tail (inc) -> head (inc) -> [new data] -> tail (inc)\n      obj->rx_buff.buffer[obj->rx_buff.head] = c;\n      obj->rx_buff.head = (obj->rx_buff.head + 1) % SERIAL_BUFFER_SIZE;\n      obj->rx_buff.tail = (obj->rx_buff.tail + 1) % SERIAL_BUFFER_SIZE;\n    }\n    else {\n      // save new data in buffer: head (inc) -> [new data] -> tail\n      obj->rx_buff.buffer[obj->rx_buff.head] = c;\n      obj->rx_buff.head = (obj->rx_buff.head + 1) % SERIAL_BUFFER_SIZE;\n    }\n  }\n\n  // Enable the next receive interrupt\n  obj->uart->IEN |= UART_IEN_RXDATAV_Msk;\n\n  // Update the emergency parser in case it was enabled\n  if (obj->emergency_parser.enabled) {\n    obj->emergency_parser.count++;\n    if (obj->emergency_parser.count >= obj->emergency_parser.max_chars) {\n      obj->emergency_parser.count = 0;\n      obj->emergency_parser.index = 0;\n      obj->emergency_parser.enabled = false;\n    }\n  }\n}", "CodeBleu_score": 37.16937279916582}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = (uint8_t)obj->reg_data;\n\n  // If the character is not a valid ASCII character ignore it.\n  // This prevents G0/G1/etc... commands from being executed.\n  if (c < 0x20 || c > 0x7E) return;\n\n  if (obj->rx_head == obj->rx_tail) {\n    // Save the character in the buffer: tail (where we save) == head (oldest)\n    obj->rx_buffer[obj->rx_head] = c;\n    // Increment the head (move to the next position)\n    obj->rx_head = (obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n  else {\n    // Save the character in the buffer: tail (where we save) != head (oldest)\n    obj->rx_buffer[obj->rx_tail] = c;\n    // Increment the tail (move to the next position)\n    obj->rx_tail = (obj->rx_tail + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n\n  // Call the parser, if enabled\n  if (obj->rx_buffer_callback) {\n    obj->rx_buffer_callback(obj->rx_buffer[obj->rx_tail]);\n  }\n}", "CodeBleu_score": 47.09384208660962}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_num == MF_TIMER_STEP) {\n        if (timer_step.initialized && !timer_step.interrupt_attached) {\n            timer_step.interrupt_attached = true;\n            attachInterrupt(digitalPinToInterrupt(MF_TIMER_STEP_PIN), Step_Handler, RISING);\n        }\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n        if (timer_temp.initialized && !timer_temp.interrupt_attached) {\n            timer_temp.interrupt_attached = true;\n            attachInterrupt(digitalPinToInterrupt(MF_TIMER_TEMP_PIN), Temp_Handler, RISING);\n        }\n    }\n}", "CodeBleu_score": 34.34643632089447}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (MF_timer_step.initialized && MF_timer_step.interrupt_attached == false) {\n\t\t\tMF_timer_step.interrupt_attached = true;\n\t\t\tHAL_timer_attach_interrupt(MF_TIMER_STEP, Step_Handler);\n\t\t}\n\t}\n\telse if (timer_num == MF_TIMER_TEMP) {\n\t\tif (MF_timer_temp.initialized && MF_timer_temp.interrupt_attached == false) {\n\t\t\tMF_timer_temp.interrupt_attached = true;\n\t\t\tHAL_timer_attach_interrupt(MF_TIMER_TEMP, Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 27.75993002795004}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (timer_step_initialized && !timer_step_interrupt_attached) {\n\t\t\ttimer_step_interrupt_attached = true;\n\t\t\tattachInterrupt(digitalPinToInterrupt(MF_TIMER_STEP_PIN), Step_Handler, FALLING);\n\t\t}\n\t}\n\telse if (timer_num == MF_TIMER_TEMP) {\n\t\tif (timer_temp_initialized && !timer_temp_interrupt_attached) {\n\t\t\ttimer_temp_interrupt_attached = true;\n\t\t\tattachInterrupt(digitalPinToInterrupt(MF_TIMER_TEMP_PIN), Temp_Handler, FALLING);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.14426480243795}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\thash, pow := HashStrRev[T](sep)\n\th := uint32(0)\n\tfor i := len(sep) - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hash && Equal(s[:len(sep)], sep) {\n\t\treturn len(s) - len(sep)\n\t}\n\tfor i := len(sep) - 1; i < len(s); i++ {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-len(sep)+1])\n\t\tif h == hash && Equal(s[i-len(sep)+1:i+1], sep) {\n\t\t\treturn i - len(sep) + 1\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 52.765301587578136}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tvar hash, pow uint32\n\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(sep) == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\thash, pow = HashStrRev(sep)\n\tvar (\n\t\th uint32 = 0\n\t\ti int\n\t)\n\tfor i = len(sep) - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(sep[i])\n\t}\n\tfor i = len(s) - len(sep); i >= 0; i-- {\n\t\tif h == hash && Equal(s[i:i+len(sep)], sep) {\n\t\t\treturn i\n\t\t}\n\t\th -= pow * uint32(s[i])\n\t\th *= PrimeRK\n\t\th += uint32(s[i+len(sep)])\n\t}\n\treturn -1\n}", "CodeBleu_score": 47.858992194668296}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tvar (\n\t\thash, pow uint32\n\t\tn         = len(s)\n\t\tm         = len(sep)\n\t)\n\tif m > n {\n\t\treturn -1\n\t}\n\tif m == 0 {\n\t\treturn n\n\t}\n\thash, pow = HashStrRev(sep)\n\tpow *= uint32(math.Pow(float64(PrimeRK), float64(n-m)))\n\th := uint32(0)\n\tfor i := n - 1; i >= n-m; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hash && Equal(s[n-m:], sep) {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+m])\n\t\tif h == hash && Equal(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 51.96880433293295}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\tusbcdc.Lock()\n\tdefer usbcdc.Unlock()\n\tif usbcdc.txBuf.Len() > 0 {\n\t\tusbcdc.waitTxc = true\n\t\tusbcdc.Unlock()\n\t\tusbcdc.SendUSBInPacket()\n\t\tusbcdc.Lock()\n\t\tusbcdc.waitTxc = false\n\t}\n}", "CodeBleu_score": 32.872565059760895}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t// Disable interrupts\n\t// Disable interrupts\n\tinterrupt.Disable()\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txc {\n\t\t// Send the data in the transmit buffer to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// Set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t}\n\t// Restore the interrupt mask\n\tinterrupt.Enable()\n}", "CodeBleu_score": 43.86682750694014}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tusbcdc.Lock()\n\tdefer usbcdc.Unlock()\n\n\tusbcdc.txc.DisableIRQ()\n\tdefer usbcdc.txc.EnableIRQ()\n\n\tif usbcdc.txc.Buffered() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n}", "CodeBleu_score": 38.74024227279827}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// Clear the interrupt flag\n\ti2c.cr1.SetBits(I2C_CR1_START)\n\n\t// Put a start condition on the SDA line\n\ti2c.cr1.SetBits(I2C_CR1_PE)\n\n\t// Wait for the start condition to be transmitted\n\tfor i2c.sr1.HasBits(I2C_SR1_SB) == false {\n\t}\n\n\t// Write the 7-bit shifted peripheral address to the bus\n\ti2c.dr.Store(uint32(address << 1) | B.Get(write))\n}", "CodeBleu_score": 29.23753178855041}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// Clear the interrupt flag\n\ti2c.ClearInterruptFlag()\n\t// Put a start condition on the SDA line\n\ti2c.ControlRegister.SetBits(I2C_CR2_START)\n\t// Wait for the start condition to be transmitted\n\tfor !i2c.InterruptFlagStatus() {\n\t}\n\t// Write the 7-bit shifted peripheral address to the bus, setting the read flag if needed and send it\n\ti2c.SendAddress(address<<1 | uint8(bool2uint8(write)))\n}", "CodeBleu_score": 25.262101926388198}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.clearInterruptFlag()\n\ti2c.setStartCondition()\n\tfor !i2c.checkInterruptFlag() {\n\t}\n\ti2c.write(address<<1 | (1-uint8(write)))\n}", "CodeBleu_score": 23.377412130385338}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif start < 0 || len < 0 {\n\t\treturn errors.New(\"Invalid start or length\")\n\t}\n\tif start+len > int64(f.blockCount) {\n\t\treturn errors.New(\"Start and length out of range\")\n\t}\n\tif len == 0 {\n\t\treturn nil\n\t}\n\n\t// Calculate the start address\n\tstartAddress := f.baseAddress + start*int64(f.blockSize)\n\n\t// Set the flash to erase mode\n\tif err := f.setMode(eraseMode); err != nil {\n\t\treturn err\n\t}\n\n\t// Erase the blocks\n\tfor i := int64(0); i < len; i++ {\n\t\t// Set the address\n\t\tif err := f.setAddress(startAddress + i*int64(f.blockSize)); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Erase the block\n\t\tif err := f.writeEnable(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := f.writeCommand(f.eraseCommand); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the flash to finish erasing the block\n\t\tif err := f.waitUntilReady(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Set the flash back to read mode\n\tif err := f.setMode(readMode); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 34.772727929778505}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif start < 0 || len <= 0 {\n\t\treturn fmt.Errorf(\"invalid start or length\")\n\t}\n\tif start+len > int64(f.numBlocks) {\n\t\treturn fmt.Errorf(\"start+len too large\")\n\t}\n\n\t// calculate the start address\n\taddr := uint32(start * int64(f.blockSize))\n\n\t// wait for any ongoing flash operations to complete\n\tfor {\n\t\tif f.status()&(flashStatusBusy|flashStatusEraseError) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// configure the flash for erasing\n\tf.writeEnable()\n\tf.writeCommand(flashCommandSectorErase)\n\n\t// erase each block\n\tfor i := int64(0); i < len; i++ {\n\t\t// set the address\n\t\tf.writeAddress(addr)\n\n\t\t// wait until the flash is no longer busy\n\t\tfor {\n\t\t\tif f.status()&flashStatusBusy == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// advance to the next block\n\t\taddr += uint32(f.blockSize)\n\t}\n\n\t// set the flash back to read mode\n\tf.writeCommand(flashCommandReadMode)\n\n\treturn nil\n}", "CodeBleu_score": 37.66669405982454}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif start < 0 || start >= f.blockCount || len < 0 || start+len > f.blockCount {\n\t\treturn errors.New(\"invalid block number\")\n\t}\n\tif len == 0 {\n\t\treturn nil\n\t}\n\n\t// Wait for any ongoing flash operations to complete.\n\tfor f.flash.Status().Busy() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\n\t// Configure flash for erasing.\n\tf.flash.Configure(flash.ERASE)\n\n\t// Erase the blocks.\n\tfor i := int64(0); i < len; i++ {\n\t\taddr := f.blockSize * (start + i)\n\t\tf.flash.Erase(addr, f.blockSize)\n\n\t\t// Wait for the flash to complete the operation.\n\t\tfor f.flash.Status().Busy() {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}\n\n\t// Set the flash back to read mode.\n\tf.flash.Configure(flash.READ)\n\n\treturn nil\n}", "CodeBleu_score": 35.18236697463838}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 {\n\t\treturn 0, errors.New(\"WriteAt: negative offset\")\n\t}\n\tif off >= int64(f.size) {\n\t\treturn 0, errors.New(\"WriteAt: offset is past flash memory end\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, errors.New(\"WriteAt: data exceeds flash memory size\")\n\t}\n\n\t// Calculate the start address for writing\n\tstart := uint32(off)\n\n\t// Pad the data to fit the write block size\n\tpad := f.writeBlockSize - (uint32(len(p)) % f.writeBlockSize)\n\tif pad != f.writeBlockSize {\n\t\tp = append(p, make([]byte, pad)...)\n\t}\n\n\t// Enable write mode on the flash memory controller\n\tf.enableWrite()\n\n\t// Write the data in blocks\n\tfor i := 0; i < len(p); i += int(f.writeBlockSize) {\n\t\t// Write the data\n\t\tf.writeData(start, p[i:i+int(f.writeBlockSize)])\n\n\t\t// Wait for the flash memory to be ready\n\t\tf.waitReady()\n\n\t\t// Increment the start address\n\t\tstart += f.writeBlockSize\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 33.210146719467694}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 {\n\t\treturn 0, errors.New(\"WriteAt: negative offset\")\n\t}\n\tif off >= int64(f.size) {\n\t\treturn 0, errors.New(\"WriteAt: offset out of bounds\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, errors.New(\"WriteAt: write length out of bounds\")\n\t}\n\tif f.wmode == 0 {\n\t\treturn 0, errors.New(\"WriteAt: write mode not enabled\")\n\t}\n\t// Calculate the start address for writing\n\taddr := uint32(off)\n\t// Pad the byte slice to fit the write block size\n\tp = pad(p, f.wblock)\n\t// Enable write mode on the flash memory controller\n\tf.writeMode()\n\t// Write the data in blocks\n\tfor len(p) > 0 {\n\t\t// Wait for the flash memory to be ready\n\t\tf.waitReady()\n\t\t// Write the data\n\t\tf.write(addr, p[:f.wblock])\n\t\t// Wait for the flash memory to be ready\n\t\tf.waitReady()\n\t\t// Increment the address\n\t\taddr += uint32(f.wblock)\n\t\t// Remove the written data from the byte slice\n\t\tp = p[f.wblock:]\n\t}\n\t// Return the number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 29.919757104490095}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 || off >= f.size {\n\t\treturn 0, errors.New(\"WriteAt: offset out of bounds\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off+int64(len(p)) > f.size {\n\t\treturn 0, errors.New(\"WriteAt: data out of bounds\")\n\t}\n\n\t// Calculate the start address for writing\n\tstartAddr := uint32(off) + f.base\n\n\t// Pad the data to fit the write block size\n\tpadLen := f.writeBlockSize - (len(p) % f.writeBlockSize)\n\tif padLen == f.writeBlockSize {\n\t\tpadLen = 0\n\t}\n\tp = append(p, make([]byte, padLen)...)\n\n\t// Enable write mode on the flash memory controller\n\tf.enableWriteMode()\n\n\t// Write the data in blocks\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\t// Wait for the flash memory to be ready\n\t\tf.waitForReady()\n\n\t\t// Write the data\n\t\tf.writeData(startAddr+uint32(i), p[i:i+f.writeBlockSize])\n\n\t\t// Wait for the flash memory to be ready\n\t\tf.waitForReady()\n\t}\n\n\t// Disable write mode on the flash memory controller\n\tf.disableWriteMode()\n\n\treturn len(p), nil\n}", "CodeBleu_score": 32.0479422226432}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tdir, err := syscall.Fdopendir(dup(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dup(fd))\n\t\tif err != nil {\n\t\t\tif err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsyscall.Close(dup(fd))\n\t\t\treturn 0, \"\", err\n\t\t}\n\t\tbreak\n\t}\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 58.97573071301325}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\tvar err error\n\tvar dir uintptr\n\tvar dupfd syscallFd\n\tvar errno syscall.Errno\n\tvar errmsg string\n\tvar errmsg2 string\n\tvar e2 error\n\n\t// Duplicate the file descriptor.\n\tdupfd, err = syscall.Dup(fd)\n\tif err != nil {\n\t\terrmsg = fmt.Sprintf(\"Dup: %v\", err)\n\t\treturn 0, errmsg, nil\n\t}\n\n\t// Attempt to open the directory.\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupfd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Check for a non-EINTR error.\n\t\terrno = err.(syscall.Errno)\n\t\tif errno != syscall.EINTR {\n\t\t\terrmsg = fmt.Sprintf(\"Fdopendir: %v\", err)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the duplicated file descriptor if necessary.\n\tif err != nil {\n\t\te2 = syscall.Close(dupfd)\n\t\tif e2 != nil {\n\t\t\terrmsg2 = fmt.Sprintf(\"Close: %v\", e2)\n\t\t}\n\t}\n\n\t// Return the directory pointer and error message.\n\tif err != nil {\n\t\terrmsg = errmsg2 + \": \" + errmsg\n\t\treturn 0, errmsg, nil\n\t}\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 46.988549878459466}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// First, duplicate the provided file descriptor.\n\tnewfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// Then, attempt to open the directory using \"syscall.Fdopendir\".\n\t// If successful, the directory pointer is returned.\n\t// If not, the error is checked and, if it is \"syscall.EINTR\", the function is called again.\n\t// Otherwise, the error is returned.\n\tfor {\n\t\tdirp, err := syscall.Fdopendir(newfd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dirp), \"\", nil\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(newfd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 58.17189815024293}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\tuint32_t freeSketchSpace = 0;\n  uint32_t actualSketchSize = 0;\n  uint32_t sketchSpace = 0;\n  uint32_t ota_size = 0;\n  uint32_t ota_data_size = 0;\n  uint32_t ota_data_crc = 0;\n  uint32_t ota_sig_size = 0;\n  uint32_t ota_sig_md5 = 0;\n\n  if (response == FREE_SPACE) {\n    if (esp_ota_get_partition_description(esp_ota_get_running_partition()) == NULL) {\n      return 0;\n    }\n    sketchSpace = esp_ota_get_running_partition()->size;\n    actualSketchSize = esp_ota_get_app_partition_size();\n    ota_size = esp_ota_get_app_partition_size();\n    ota_data_size = esp_ota_get_app_partition_size();\n    ota_data_crc = esp_ota_get_app_partition_size();\n    ota_sig_size = esp_ota_get_app_partition_size();\n    ota_sig_md5 = esp_ota_get_app_partition_size();\n    freeSketchSpace = sketchSpace - actualSketchSize - ota_size - ota_data_size - ota_data_crc - ota_sig_size - ota_sig_md5;\n  } else if (response == ACTUAL_SKETCH_SIZE) {\n    actualSketchSize = esp_ota_get_app_partition_size();\n  }\n  return actualSketchSize;\n}", "CodeBleu_score": 30.501837294485224}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tuint32_t size = 0;\n  uint32_t imageSize = 0;\n  uint32_t imageCrc = 0;\n  uint8_t imageHeader[16];\n  uint32_t offset = 0;\n  uint32_t sectorSize = 0;\n  uint32_t flashSize = 0;\n  uint32_t flashMode = 0;\n  uint32_t flashSpeed = 0;\n  uint32_t flashSizeMap = 0;\n  uint32_t flashChipId = 0;\n  uint32_t flashChipSize = 0;\n  uint32_t flashChipSpeed = 0;\n  uint32_t flashChipMode = 0;\n  uint32_t flashChipSize2 = 0;\n  uint32_t flashChipSpeed2 = 0;\n  uint32_t flashChipMode2 = 0;\n  uint32_t flashChipSize4 = 0;\n  uint32_t flashChipSpeed4 = 0;\n  uint32_t flashChipMode4 = 0;\n  uint32_t flashChipSize8 = 0;\n  uint32_t flashChipSpeed8 = 0;\n  uint32_t flashChipMode8 = 0;\n  uint32_t flashChipSize16 = 0;\n  uint32_t flashChipSpeed16 = 0;\n  uint32_t flashChipMode16 = 0;\n  uint32_t flashChipSize32 = 0;\n  uint32_t flashChipSpeed32 = 0;\n  uint32_t flashChipMode32 = 0;\n  uint32_t flashChipSize64 = 0;\n  uint32_t flashChipSpeed64 = 0;\n  uint32_t flashChipMode64 = 0;\n  uint32_t flashChipSize128 = 0;\n  uint32_t flashCh", "CodeBleu_score": 4.396811203246928}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tuint32_t sketchSize = 0;\n  uint32_t freeSpace = 0;\n  esp_image_header_t fhdr;\n  const esp_partition_t *part;\n  part = esp_ota_get_running_partition();\n  if (part == NULL) {\n    ESP_LOGE(TAG, \"Could not get running partition\");\n    return 0;\n  }\n  const esp_partition_pos_t ota_info = {\n    .offset = part->address,\n    .size = part->size,\n  };\n  if (esp_ota_get_partition_description(part, &fhdr) == ESP_OK) {\n    if (fhdr.magic == ESP_IMAGE_HEADER_MAGIC) {\n      if (response) {\n        freeSpace = part->size - fhdr.image_len;\n        return freeSpace;\n      } else {\n        sketchSize = fhdr.image_len;\n        return sketchSize;\n      }\n    }\n  }\n  return 0;\n}", "CodeBleu_score": 51.17013702447184}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_disk = (uint8_t *) calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk) {\n    log_e(\"Could not allocate memory for disk\");\n    return false;\n  }\n  if (msc_run_partition) {\n    if (!msc_update_setup_disk_fat_data(msc_run_partition)) {\n      return false;\n    }\n  }\n  if (msc_ota_partition) {\n    if (!msc_update_setup_disk_fat_data(msc_ota_partition)) {\n      return false;\n    }\n  }\n  if (!msc_update_setup_disk_fat_boot(volume_label, serial_number)) {\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 35.14712979487443}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  if (total_sectors == 0) {\n    log_e(\"Couldn't calculate required disk sectors\");\n    return false;\n  }\n  msc_disk_buffer = malloc(total_sectors * DISK_SECTOR_SIZE);\n  if (msc_disk_buffer == NULL) {\n    log_e(\"Couldn't allocate memory for RAM disk\");\n    return false;\n  }\n  memset(msc_disk_buffer, 0, total_sectors * DISK_SECTOR_SIZE);\n  msc_update_setup_boot_sector(volume_label, serial_number);\n  msc_update_setup_fat();\n  if (msc_run_partition) {\n    msc_update_add_firmware_entry(msc_run_partition);\n  }\n  return true;\n}", "CodeBleu_score": 34.70018227206591}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  if (total_sectors == 0) {\n    return false;\n  }\n  msc_disk_buffer = (uint8_t *) calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (msc_disk_buffer == NULL) {\n    log_e(\"Failed to allocate memory for disk\");\n    return false;\n  }\n  log_d(\"Disk buffer at %p\", msc_disk_buffer);\n  if (msc_run_partition) {\n    if (!msc_update_setup_disk_fat(volume_label, serial_number, msc_run_partition)) {\n      return false;\n    }\n  }\n  if (msc_ota_partition) {\n    if (!msc_update_setup_disk_fat(volume_label, serial_number, msc_ota_partition)) {\n      return false;\n    }\n  }\n  return true;\n}", "CodeBleu_score": 36.86839673649784}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err;\n    size_t erase_size;\n\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        // Erase the sector if it is aligned\n        erase_size = SPI_FLASH_SEC_SIZE;\n        err = esp_partition_erase_range(partition, offset, erase_size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase sector at 0x%x\", offset);\n            return err;\n        }\n    } else {\n        // If the offset is not aligned, we cannot erase the sector\n        erase_size = 0;\n    }\n\n    // Write the data\n    err = esp_partition_write(partition, offset + erase_size, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data at 0x%x\", offset);\n        return err;\n    }\n\n    return ESP_OK;\n}", "CodeBleu_score": 56.39954592233796}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err;\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        err = spi_flash_erase_sector(offset / SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase sector at offset %d: 0x%x\", offset, err);\n            return err;\n        }\n    }\n    err = spi_flash_write(offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data at offset %d: 0x%x\", offset, err);\n    }\n    return err;\n}", "CodeBleu_score": 49.61620002340239}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err = ESP_OK;\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Erase failed at offset 0x%x\", offset);\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    return err;\n}", "CodeBleu_score": 68.76353832261492}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i, j;\n  uint8_t c;\n  size_t len = 0;\n\n  for (i = 0, j = 0; in[i] && len < maxlen; i += 1, j += 1) {\n    c = hex_char_to_byte(in[i]);\n    if (c < 0x10) {\n      if (in[i + 1] == '\\0') {\n        out[j] = c << 4;\n        break;\n      } else {\n        c = hex_char_to_byte(in[i + 1]);\n        if (c < 0x10) {\n          out[j] = (c << 4) | hex_char_to_byte(in[i]);\n          i += 1;\n        } else {\n          out[j] = c << 4;\n        }\n      }\n    } else {\n      out[j] = c;\n    }\n    len += 1;\n  }\n\n  return len;\n}", "CodeBleu_score": 52.3186833858299}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i, j;\n  for (i = 0, j = 0; i < strlen(in) && j < maxlen; i += 2, j++) {\n    out[j] = (hex_char_to_byte(in[i]) << 4) | hex_char_to_byte(in[i + 1]);\n  }\n  return j;\n}", "CodeBleu_score": 35.92863481260423}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i = 0;\n  size_t j = 0;\n  unsigned char c;\n  unsigned char d;\n\n  while (in[i] && j < maxlen) {\n    c = hex_char_to_byte(in[i]);\n    if (c >= 0x10) {\n      i++;\n      continue;\n    }\n    i++;\n    d = hex_char_to_byte(in[i]);\n    if (d >= 0x10) {\n      i++;\n      continue;\n    }\n    i++;\n    out[j] = (c << 4) | d;\n    j++;\n  }\n\n  return j;\n}", "CodeBleu_score": 48.26072709890175}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\tif (m_tx_ring_buffer == NULL) {\n    return 0;\n  }\n  if (m_tx_ring_buffer->lock() == 0) {\n    int available = m_tx_ring_buffer->availableForWrite();\n    m_tx_ring_buffer->unlock();\n    return available;\n  }\n  return 0;\n}", "CodeBleu_score": 53.836912453279886}, {"code": "int HWCDC::availableForWrite(void){\n\tint freeSize;\n\n    if (!_tx_buffer || !_tx_buffer_lock) {\n        return 0;\n    }\n\n    if (xSemaphoreTake(_tx_buffer_lock, 10) == pdTRUE) {\n        freeSize = _tx_buffer->availableForStore();\n        xSemaphoreGive(_tx_buffer_lock);\n        return freeSize;\n    } else {\n        return 0;\n    }\n}", "CodeBleu_score": 50.94237598098176}, {"code": "int HWCDC::availableForWrite(void){\n\tint freeSize;\n    if (tx_ring_buffer == NULL) {\n        return 0;\n    }\n    if (xSemaphoreTake(tx_ring_buffer_lock, TX_RING_BUFFER_LOCK_TIMEOUT) == pdTRUE) {\n        freeSize = tx_ring_buffer->availableForStore();\n        xSemaphoreGive(tx_ring_buffer_lock);\n        return freeSize;\n    }\n    return 0;\n}", "CodeBleu_score": 56.32398469647889}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\tif (function == NULL) {\n    _onReceiveCB = NULL;\n    _rxTimeout = 0;\n    _rxTimeoutOnly = false;\n    return;\n  }\n\n  _onReceiveCB = function;\n  _rxTimeoutOnly = onlyOnTimeout;\n  if (_rxTimeoutOnly) {\n    _rxTimeout = 0;\n  }\n\n  if (_onReceiveCB != NULL) {\n    if (_rxBufferSize == 0) {\n      _rxBufferSize = 64;\n    }\n    if (_rxBuffer == NULL) {\n      _rxBuffer = (uint8_t *)malloc(_rxBufferSize);\n      if (_rxBuffer == NULL) {\n        log_e(\" -- UART%d RX Buffer not Created!\", _uart_nr);\n      }\n    }\n\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n}", "CodeBleu_score": 53.430389055424676}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t_onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB) {\n    _rx_fifo_full_threshold = _rx_buffer_size / 2;\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n}", "CodeBleu_score": 33.99507035548399}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t_lock();\n  _onReceiveCB = function;\n  if (function != NULL) {\n    _rxTimeout = onlyOnTimeout;\n    _setRxFifoFullThreshold();\n    _createEventTask();\n  }\n  _unlock();\n}", "CodeBleu_score": 26.637463136210005}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) return 0;\n  char * end = buffer + length - 1;\n  while (buffer < end) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) break;\n    *buffer++ = (char)c;\n  }\n  *buffer = 0;\n  return buffer - start;\n}", "CodeBleu_score": 64.17246051313916}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer = (char)c;\n    index++;\n    buffer++;\n  }\n  *buffer = 0;\n  return index;\n}", "CodeBleu_score": 86.16182426716423}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) return 0;\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer = (char)c;\n    index++;\n    buffer++;\n  }\n  return index; // return number of characters, not including null terminator\n}", "CodeBleu_score": 87.00796124543078}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_i(\"Tone on pin %d, frequency %d, duration %d\", pin, frequency, duration);\n  if (pin >= PINS_COUNT) {\n    log_e(\"Pin %d out of range\", pin);\n    return;\n  }\n  if (_tone_pins[pin] != 0) {\n    log_e(\"Pin %d is already in use\", pin);\n    return;\n  }\n  _tone_pins[pin] = 1;\n  tone_msg_t msg = {\n    .pin = pin,\n    .freq = frequency,\n    .duration = duration\n  };\n  if (xQueueSend(_tone_queue, &msg, 0) != pdTRUE) {\n    log_e(\"Could not send tone message to queue\");\n  }\n}", "CodeBleu_score": 54.90223427223905}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_v(\"Tone: pin=%d, freq=%d, duration=%ld\", pin, frequency, duration);\n  if (pin >= 0 && pin <= 20) {\n    if (_tone_pins[pin] == 0) {\n      _tone_pins[pin] = 1;\n      tone_msg_t msg;\n      msg.pin = pin;\n      msg.freq = frequency;\n      msg.duration = duration;\n      msg.cmd = TONE_CMD_START;\n      if (xQueueSend(_tone_queue, &msg, 0) != pdPASS) {\n        log_e(\"Could not send tone message\");\n      }\n    } else {\n      log_e(\"Tone: pin %d is already in use\", pin);\n    }\n  } else {\n    log_e(\"Tone: pin %d is not available\", pin);\n  }\n}", "CodeBleu_score": 46.622854084562974}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_v(\"Tone on pin %d with frequency %d and duration %ld\", pin, frequency, duration);\n  if (pin >= 0 && pin < NUM_TONE_PINS) {\n    if (_tone_pin[pin] == NULL) {\n      log_v(\"Pin %d available\", pin);\n      _tone_pin[pin] = xSemaphoreCreateBinary();\n      if (_tone_pin[pin] == NULL) {\n        log_e(\"Could not create semaphore for pin %d\", pin);\n        return;  // ERR\n      }\n      tone_msg_t msg = {\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n        .cmd = TONE_CMD_START\n      };\n      if (xQueueSend(_tone_queue, &msg, 0) != pdPASS) {\n        log_e(\"Could not send tone start message for pin %d\", pin);\n        return;  // ERR\n      }\n    } else {\n      log_e(\"Pin %d already in use\", pin);\n      return;  // ERR\n    }\n  } else {\n    log_e(\"Pin %d out of range\", pin);\n    return;  // ERR\n  }\n}", "CodeBleu_score": 57.517585893659415}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\tbool ret = false;\n  if (!_usbStarted) {\n    ret = true;\n  }\n  if (enabled) {\n    if (!_webUSBEnabled) {\n      if (!_usbStarted) {\n        _usbVersion = 0x0210;\n      }\n      _webUSBEnabled = true;\n    }\n  } else {\n    _webUSBEnabled = false;\n  }\n  return ret;\n}", "CodeBleu_score": 45.16828944923462}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!USBStarted) {\n    WebUSBEnabled = enabled;\n    return true;\n  }\n  if (enabled) {\n    if (USBVersion < 0x0210) {\n      USBVersion = 0x0210;\n    }\n    USBDevice.webUSB();\n  } else {\n    USBDevice.disableWebUSB();\n  }\n  return false;\n}", "CodeBleu_score": 51.2170735885061}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tbool ret = false;\n  if (enabled) {\n    if (usbVersion() < 0x0210) {\n      usbVersion(0x0210);\n      ret = true;\n    }\n    _webUSB = true;\n  } else {\n    _webUSB = false;\n  }\n  return ret;\n}", "CodeBleu_score": 40.50543632639069}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\tuint8_t buf[64];\n    uint32_t len = 0;\n\n    while (1) {\n        int32_t n = _read(buf, sizeof(buf));\n        if (n <= 0) {\n            break;\n        }\n\n        len += n;\n\n        if (n < sizeof(buf)) {\n            break;\n        }\n    }\n\n    if (len > 0) {\n        if (_rxQueue.push_for(len, &buf[0]) == Queue::ERR_QUEUE_FULL) {\n            _overflowEvent.post(len);\n            _log.error(\"RX queue overflow\");\n        } else {\n            _receiveEvent.post(len);\n        }\n    }\n}", "CodeBleu_score": 23.557207083675564}, {"code": "void USBCDC::_onRX(){\n\tuint8_t buf[64];\n\tuint8_t len;\n\tuint8_t overflow = 0;\n\tuint8_t i;\n\n\t// Read data from USB\n\tlen = USBCDC::read(buf, 64);\n\n\t// Attempt to send each byte to the receive queue\n\tfor (i = 0; i < len; i++) {\n\t\tif (!USBCDC::receiveQueue.push(buf[i])) {\n\t\t\toverflow++;\n\t\t}\n\t}\n\n\t// Post an overflow event if necessary\n\tif (overflow) {\n\t\tUSBCDC::overflowEvent.post(overflow);\n\t\tUSBCDC::errorEvent.post(USBCDC_ERROR_OVERFLOW);\n\t}\n\n\t// Post a receive event\n\tUSBCDC::receiveEvent.post(len);\n}", "CodeBleu_score": 19.730839558826847}, {"code": "void USBCDC::_onRX(){\n\tuint8_t buf[USBCDC_RX_BUF_SIZE];\n    uint32_t len = _rxBuf.read(buf, USBCDC_RX_BUF_SIZE);\n    if (len > 0) {\n        if (_rxQueue.push_back(buf, len)) {\n            _rxQueue.post();\n        } else {\n            _rxQueue.clear();\n            _rxQueue.push_back(buf, len);\n            _rxQueue.post();\n            _overflowEvent.post(len);\n            _errorEvent.post(USBCDC_ERROR_RX_OVERFLOW);\n        }\n    }\n}", "CodeBleu_score": 19.219176167199432}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\":robot_name\")\n\trobot, err := a.db.GetRobotByName(robotName)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(`{\"error\": \"No robot with the given name found.\"}`))\n\t\treturn\n\t}\n\n\tdevices, err := a.db.GetDevicesByRobotID(robot.ID)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(`{\"error\": \"Internal server error.\"}`))\n\t\treturn\n\t}\n\n\tjson, err := json.Marshal(devices)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(`{\"error\": \"Internal server error.\"}`))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(json)\n}", "CodeBleu_score": 34.109410294113104}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t// We check if the robot name is provided in the URL.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tif robotName == \"\" {\n\n\t\t// If the robot name is not provided, we return an error message.\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(\"{\\\"error\\\":\\\"No robot name provided\\\"}\"))\n\t\treturn\n\t}\n\n\t// We check if a robot with the given name exists.\n\trobot := a.store.Robot(robotName)\n\tif robot == nil {\n\n\t\t// If no robot was found, we return an error message.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"{\\\"error\\\":\\\"No robot found with the given name\\\"}\"))\n\t\treturn\n\t}\n\n\t// We create a JSON object that contains the robot's devices.\n\tdevices := make([]map[string]interface{}, 0, len(robot.Devices))\n\tfor _, device := range robot.Devices {\n\t\tdevices = append(devices, map[string]interface{}{\n\t\t\t\"name\":   device.Name,\n\t\t\t\"type\":   device.Type,\n\t\t\t\"values\": device.Values,\n\t\t})\n\t}\n\n\t// We write the JSON response to the HTTP response writer.\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(map[string]interface{}{\n\t\t\"devices\": devices,\n\t})\n}", "CodeBleu_score": 48.57368283662233}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\trobotName := req.URL.Query().Get(\"name\")\n\tif robotName == \"\" {\n\t\thttp.Error(res, \"No robot name specified\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\trobot, err := a.db.Robot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices, err := robot.Devices()\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 36.13962969884783}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL.\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Check if a robot with the specified name exists.\n\tif robot, ok := a.robots[robotName]; ok {\n\t\t// The robot was found.\n\t\t// Initialize a slice to hold the robot's connections.\n\t\tconnections := make([]robotConnection, 0)\n\n\t\t// Iterate through the robot's connections and add them to the slice.\n\t\tfor _, connection := range robot.Connections() {\n\t\t\tconnections = append(connections, robotConnection{\n\t\t\t\tName: connection.Name(),\n\t\t\t\tType: connection.Type(),\n\t\t\t})\n\t\t}\n\n\t\t// Convert the slice of connections to JSON.\n\t\tjsonConnections, err := json.Marshal(connections)\n\t\tif err != nil {\n\t\t\t// Writing the error message to the HTTP response.\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\tres.Write([]byte(fmt.Sprintf(\"Failed to convert robot connections to JSON: %s\", err)))\n\t\t\treturn\n\t\t}\n\n\t\t// Write the JSON to the HTTP response.\n\t\tres.WriteHeader(http.StatusOK)\n\t\tres.Write(jsonConnections)\n\t} else {\n\t\t// The robot was not found.\n\t\t// Write an error message to the HTTP response.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"No robot with name '%s' found\", robotName)))\n\t}\n}", "CodeBleu_score": 43.24078311630735}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Check if a robot with the specified name exists\n\trobot := a.db.Robot(robotName)\n\tif robot == nil {\n\t\t// If no robot with the specified name was found, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with name \\\"\" + robotName + \"\\\" was found\"))\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections\n\tconnections := make([]map[string]interface{}, 0)\n\tfor _, connection := range robot.Connections() {\n\t\t// Convert the connection to JSON format\n\t\tconnectionJSON := make(map[string]interface{})\n\t\tconnectionJSON[\"id\"] = connection.ID()\n\t\tconnectionJSON[\"name\"] = connection.Name()\n\t\tconnectionJSON[\"description\"] = connection.Description()\n\t\tconnectionJSON[\"type\"] = connection.Type()\n\t\tconnectionJSON[\"direction\"] = connection.Direction()\n\t\tconnectionJSON[\"status\"] = connection.Status()\n\t\tconnectionJSON[\"robot\"] = connection.Robot()\n\t\tconnectionJSON[\"target\"] = connection.Target()\n\n\t\t// Add the connection to the list of connections\n\t\tconnections = append(connections, connectionJSON)\n\t}\n\n\t// Write the list of connections to the HTTP response\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 38.648503842107495}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Check if a robot with the specified name exists\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\t// If the robot is not found, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"No robot with the name '%s' was found.\", robotName)))\n\t\treturn\n\t}\n\n\t// If the robot is found, iterate through its connections and convert them to JSON format\n\tjsonConnections, err := json.Marshal(robot.Connections())\n\tif err != nil {\n\t\t// If an error occurs while converting the connections to JSON format, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(fmt.Sprintf(\"An error occurred while converting the connections of robot '%s' to JSON format.\", robotName)))\n\t\treturn\n\t}\n\n\t// If the connections are successfully converted to JSON format, write them to the HTTP response\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(jsonConnections)\n}", "CodeBleu_score": 33.46206452344085}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t// Get robot and device names from URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot exists.\n\trobot := a.robot(robotName)\n\tif robot == nil {\n\t\t// Write an error message as a JSON response and return.\n\t\tres.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tif err := json.NewEncoder(res).Encode(map[string]string{\"error\": \"robot not found\"}); err != nil {\n\t\t\ta.error(err)\n\t\t}\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\t// Write an error message as a JSON response and return.\n\t\tres.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tif err := json.NewEncoder(res).Encode(map[string]string{\"error\": \"device not found\"}); err != nil {\n\t\t\ta.error(err)\n\t\t}\n\t\treturn\n\t}\n\n\t// Get the command name from the request body.\n\tvar commandName string\n\tif err := json.NewDecoder(req.Body).Decode(&commandName); err != nil {\n\t\t// Write an error message as a JSON response and return.\n\t\tres.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tif err := json.NewEncoder(res).Encode(map[string]string{\"error\": err.Error()}); err != nil {\n\t\t\ta.error(err)\n\t\t}\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\tif err := device.Command(commandName); err != nil {\n\t\t// Write an error message as a JSON response", "CodeBleu_score": 48.85265760474025}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t// Retrieve the robot and device names from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot exists.\n\tif !a.RobotExists(robotName) {\n\t\t// Write an error message as a JSON response and return from the function.\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"robot does not exist\"}`))\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tif !a.DeviceExists(robotName, deviceName) {\n\t\t// Write an error message as a JSON response and return from the function.\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"device does not exist\"}`))\n\t\treturn\n\t}\n\n\t// Check if the device supports commands.\n\tif !a.DeviceSupportsCommands(robotName, deviceName) {\n\t\t// Write an error message as a JSON response and return from the function.\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"device does not support commands\"}`))\n\t\treturn\n\t}\n\n\t// Retrieve the command name from the request body.\n\tvar commandName string\n\terr := json.NewDecoder(req.Body).Decode(&commandName)\n\tif err != nil {\n\t\t// Write an error message as a JSON response and return from the function.\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write([]byte(`{\"error\": \"invalid request body\"}`))\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\terr = a.ExecuteRobotDeviceCommand(robotName, deviceName, commandName)\n\tif err != nil {\n\t\t// Write an error message as a JSON response and return from the function.\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(`{\"error\": \"` + err.Error", "CodeBleu_score": 47.70379481352099}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t// Get the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot exists\n\tif _, err := a.getRobot(robotName); err != nil {\n\t\ta.writeJSONError(res, err)\n\t\treturn\n\t}\n\n\t// Check if the device exists\n\tif _, err := a.getDevice(robotName, deviceName); err != nil {\n\t\ta.writeJSONError(res, err)\n\t\treturn\n\t}\n\n\t// Get the command name from the URL query parameters\n\tcommandName := req.URL.Query().Get(\"command\")\n\n\t// Execute the command on the device\n\tif err := a.executeCommand(robotName, deviceName, commandName); err != nil {\n\t\ta.writeJSONError(res, err)\n\t\treturn\n\t}\n\n\t// Write the JSON response\n\ta.writeJSONResponse(res, http.StatusOK, \"Command executed\")\n}", "CodeBleu_score": 55.208266012362174}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tconst prefix = \"Basic \"\n\t\tif !strings.HasPrefix(auth, prefix) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tc, err := base64.StdEncoding.DecodeString(auth[len(prefix):])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\ts := string(c)\n\t\ti := strings.IndexByte(s, ':')\n\t\tif i < 0 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif !secureCompare(username, s[:i]) || !secureCompare(password, s[i+1:]) {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 48.143357085467834}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tgiven := r.Header.Get(\"Authorization\")\n\t\tactual := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\t\tif !secureCompare(given, actual) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Authorization succeeded\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 56.49731361187123}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tconst prefix = \"Basic \"\n\t\tif !strings.HasPrefix(auth, prefix) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tc, err := base64.StdEncoding.DecodeString(auth[len(prefix):])\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tcs := string(c)\n\t\ts := strings.IndexByte(cs, ':')\n\t\tif s < 0 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif !secureCompare(username, cs[:s]) || !secureCompare(password, cs[s+1:]) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Invoke the next handler\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 46.23145401540201}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.Lock()\n\tdefer a.Unlock()\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, ErrAnalogNotSupported\n\t}\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := float64(raw) * a.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 45.101026286807574}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mux.Lock()\n\tdefer a.mux.Unlock()\n\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog read\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.scale\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 47.74952268745235}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"Connection does not support analog read\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scaleValue(raw)\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.00505827966393}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:  pin,\n\t\tv:    a,\n\t\tl:    gobot.NewLevelReader(0, 1023),\n\t}\n\n\tfor _, option := range opts {\n\t\tif s, ok := option.(string); ok {\n\t\t\td.name = s\n\t\t} else if l, ok := option.(gobot.LevelReader); ok {\n\t\t\td.l = l\n\t\t}\n\t}\n\n\td.l.WithinRange = func(data interface{}, min interface{}, max interface{}) bool {\n\t\treturn data.(int) > min.(int) && data.(int) < max.(int)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 36.77860826007425}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:  pin,\n\t\tvref: 5.0,\n\t\ta:    a,\n\t}\n\n\tfor _, option := range opts {\n\t\tif s, ok := option.(string); ok {\n\t\t\td.name = s\n\t\t} else if f, ok := option.(float64); ok {\n\t\t\td.vref = f\n\t\t}\n\t}\n\n\td.mutex = &sync.Mutex{}\n\n\t// TODO: replace with ADC\n\td.connection = a.(gobot.Connection)\n\n\treturn d\n}", "CodeBleu_score": 36.91616453633875}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tconnector: &gobot.DigitalConnector{\n\t\t\tDigitalReader: a,\n\t\t},\n\t\tpin: pin,\n\t\tvcc: 3.3,\n\t\tgnd: 0,\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase string:\n\t\t\td.name = option.(string)\n\t\tcase float64:\n\t\t\td.vcc = option.(float64)\n\t\tcase float32:\n\t\t\td.vcc = float64(option.(float32))\n\t\tcase int:\n\t\t\td.gnd = float64(option.(int))\n\t\tcase int64:\n\t\t\td.gnd = float64(option.(int64))\n\t\tcase int32:\n\t\t\td.gnd = float64(option.(int32))\n\t\tcase int16:\n\t\t\td.gnd = float64(option.(int16))\n\t\tcase int8:\n\t\t\td.gnd = float64(option.(int8))\n\t\tcase float64:\n\t\t\td.gnd = option.(float64)\n\t\tcase float32:\n\t\t\td.gnd = float64(option.(float32))\n\t\t}\n\t}\n\n\treturn d\n}", "CodeBleu_score": 33.04109488530014}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t// Write soft reset command\n\tif err := d.writeRegister(CommandReg, SoftReset); err != nil {\n\t\treturn err\n\t}\n\t// Wait for at least 10 ms\n\ttime.Sleep(10 * time.Millisecond)\n\t// Read the command register to check the power down bit\n\tvalue, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Return an error if the power down bit is not cleared\n\tif value&0x80 > 0 {\n\t\treturn fmt.Errorf(\"MFRC522: Soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 68.96532667815976}, {"code": "func (d *MFRC522Common) softReset() error{\n\td.writeRegister(CommandReg, SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\n\tif d.readRegister(CommandReg) == 0x00 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 26.0949875417521}, {"code": "func (d *MFRC522Common) softReset() error{\n\t// Write the soft-reset command to the command register\n\td.WriteRegister(MFRC522CommandReg, MFRC522CommandSoftReset)\n\n\t// Wait for the chip to initialize\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// Read the command register to check the status\n\tvalue, err := d.ReadRegister(MFRC522CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the power-down bit is still set\n\tif value&MFRC522CommandPowerDown != 0 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 52.92347946465693}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Fill byte buffer with result\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i] = d.ReadRegister(FIFODataReg)\n\t}\n\t// Read the last bits\n\treturn d.ReadRegister(ControlReg), nil\n}", "CodeBleu_score": 17.307978962824205}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Get the number of bytes currently in the FIFO\n\tfifoLen, err := d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// The FIFO buffer size is 64 bytes.\n\tif fifoLen > 64 {\n\t\treturn 0, errors.New(\"FIFO overflow\")\n\t}\n\n\t// Check if the requested number of bytes to read is available in the FIFO\n\tif fifoLen < len(backData) {\n\t\treturn 0, errors.New(\"FIFO underflow\")\n\t}\n\n\t// Read the bytes from the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\tb, err := d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = b\n\t}\n\n\t// Read the last bits received\n\treturn d.readRegister(ControlReg) & 0x07, nil\n}", "CodeBleu_score": 48.3038473417443}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tvar n uint8\n\tvar err error\n\tvar val byte\n\n\t// Read the length of the data available in the FIFO\n\tn, err = d.ReadRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if the length read from the FIFO level register matches the provided length\n\tif n != uint8(len(backData)) {\n\t\treturn 0, errors.New(\"MFRC522: Invalid length of data received from FIFO\")\n\t}\n\n\t// Read the data from the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\tval, err = d.ReadRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tbackData[i] = val\n\t}\n\n\t// Read the control register to get the Parity and CRC_Check bits\n\tval, err = d.ReadRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn val, nil\n}", "CodeBleu_score": 46.92052209527109}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\td.log(\"piccHalt\")\n\td.WriteRegister(CommandReg, PiccHalt)\n\td.WriteRegister(ComIEnReg, 0x7F)\n\td.WriteRegister(ComIrqReg, 0x7F)\n\td.WriteRegister(FIFOLevelReg, 0x80)\n\td.WriteRegister(CommandReg, PiccHalt)\n\td.WriteRegister(BitFramingReg, 0x00)\n\terr := d.expectError(PiccHalt)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 27.491333362045502}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\td.log(\"Halting PICC ...\")\n\tcmd := []byte{byte(MFRC522Command.PiccHaltA)}\n\tif err := d.write(cmd); err != nil {\n\t\treturn err\n\t}\n\tif _, err := d.read(1); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 28.735037259650653}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\td.debugPrint(\"piccHalt\")\n\t// Create the command.\n\tvar cmd []byte\n\tcmd = append(cmd, byte(0x50)) // PICC_CMD_HLTA\n\t// Calculate CRC.\n\tcmd = append(cmd, d.calculateCRC(cmd)...)\n\t// Send the command.\n\terr := d.write(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Wait for the PICC to become active again.\n\t_, err = d.piccRequest(byte(0x50), false)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 34.868817193808134}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Prepare the command\n\tcmd := []byte{0x30, 0x00, 0x00, 0x00, 0x00, 0x00}\n\tcmd[0] = 0x30\n\tcmd[1] = block\n\n\t// Calculate CRC\n\tcrc := d.calcCRC(cmd)\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Send the command\n\tif err := d.piccTransmit(cmd); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the data\n\tdata, err := d.piccReceive(16)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}", "CodeBleu_score": 31.984947739136615}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Prepare the command\n\tcmd := make([]byte, 2)\n\tcmd[0] = byte(PiccCmdRead)\n\tcmd[1] = block\n\n\t// Calculate CRC_A\n\tcrc := d.CalulateCRC(cmd)\n\tcmd = append(cmd, crc...)\n\n\t// Send the command\n\tif err := d.SendRecv(cmd, 4, 0x00); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the data\n\treturn d.Read(16)\n}", "CodeBleu_score": 27.52816706569327}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Prepare the command\n\tcmd := make([]byte, 2)\n\tcmd[0] = byte(0x30)\n\tcmd[1] = byte(block)\n\n\t// Calculate CRC\n\tcrc := d.calcCRC(cmd)\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Transmit the command\n\terr := d.piccTransmit(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Retrieve response\n\tresponse, err := d.piccReceive()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check response\n\tif response[0] != byte(0x0A) {\n\t\treturn nil, fmt.Errorf(\"read error: %v\", response[0])\n\t}\n\n\t// Return data\n\treturn response[1:17], nil\n}", "CodeBleu_score": 37.239207770552206}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// TODO: check if this is needed\n\t// if (sizeof(answer) < 2) {\n\t// \treturn fmt.Errorf(\"answer buffer to small\")\n\t// }\n\n\t// Set the command to send (Transceive) and the arguments to send (request mode and size)\n\t// Set the transmitter to send 1 byte of data\n\td.writeRegister(MFRC522_REG_COMMAND, MFRC522_CMD_TRANSCEIVE)\n\td.writeRegister(MFRC522_REG_COM_IRQ, 0x70)\n\td.writeRegister(MFRC522_REG_BIT_FRAMING, 0x87)\n\n\t// Set the communication to use 100% ASK modulation\n\td.writeRegister(MFRC522_REG_MODE, 0x3D)\n\n\t// Set the TxLastBits value\n\tif reqMode == MFRC522_PICC_REQA || reqMode == MFRC522_PICC_WUPA || reqMode == MFRC522_PICC_CT {\n\t\td.writeRegister(MFRC522_REG_TX_LAST_BITS, 0x00)\n\t} else {\n\t\td.writeRegister(MFRC522_REG_TX_LAST_BITS, 0x01)\n\t}\n\n\t// Set the request mode\n\td.writeRegister(MFRC522_REG_MODE, reqMode)\n\n\t// Set the collision bits\n\td.writeRegister(MFRC522_REG_RX_THRESHOLD, 0x00)\n\td.writeRegister(MFRC522_REG_RX_THRESHOLD, 0x00)\n\n\t// Send the command\n\td.writeRegister(MFRC522_REG_COM_IRQ, 0x80)\n\td.writeRegister(MFRC522_REG_COM_IRQ, 0xA0)\n\td.", "CodeBleu_score": 29.33659011380699}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// Check if the answer buffer is big enough to hold the response.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer must be at least 2 bytes long\")\n\t}\n\n\t// Clear the collision flag in the FIFO status register.\n\tif err := d.writeRegister(FIFOStatusReg, 0x80); err != nil {\n\t\treturn err\n\t}\n\n\t// Transmit the request and receive the response.\n\tif err := d.transceive(reqMode, answer); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if a collision occurred during the communication.\n\tif d.readRegister(FIFOStatusReg)&0x80 == 0x80 {\n\t\treturn fmt.Errorf(\"collision error\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.107076039266246}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// Check if the answer buffer is big enough\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Build command buffer\n\tcmd := []byte{\n\t\tbyte(reqMode),\n\t}\n\n\t// Clear the bit in the collision register indicating a collision\n\td.ClearBitMask(d.REG_COLL, 0x80)\n\n\t// Transmit the command and receive the answer\n\tif err := d.transceive(cmd, answer); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if there is a collision\n\tif d.ReadFromReg(d.REG_COLL) & 0x80 != 0 {\n\t\treturn fmt.Errorf(\"collision\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 54.056439253767316}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == 0 {\n\t\treturn errors.New(\"Step pin not set\")\n\t}\n\n\tif err := d.p.DigitalWrite(d.stepPin, 0); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\tif err := d.p.DigitalWrite(d.stepPin, 1); err != nil {\n\t\treturn err\n\t}\n\n\tif d.stepNumber == d.stepsPerRevolution {\n\t\td.stepNumber = 0\n\t} else {\n\t\td.stepNumber++\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 67.00201164165638}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Set the step pin low, wait for a delay, and set the step pin high\n\terr := d.p.Write(d.stepPin, gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.delay)\n\terr = d.p.Write(d.stepPin, gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction\n\tif d.direction == CW {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 63.95285967874918}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Set the step pin low\n\terr := d.pins[step].Write(0)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Wait for the delay\n\ttime.Sleep(d.delay)\n\n\t// Set the step pin high\n\terr = d.pins[step].Write(1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 62.878241181719915}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mux.Lock()\n\tdefer d.mux.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"Distance monitor already running\")\n\t}\n\n\td.stopChan = make(chan struct{})\n\td.wg.Add(1)\n\td.distanceMonitorRunning = true\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\td.log.Printf(\"Error while measuring distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.log.Printf(\"Distance: %v\", distance)\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(d.distanceMonitorDelay)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 41.17247569686066}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.stop != nil {\n\t\treturn fmt.Errorf(\"distance monitor already running\")\n\t}\n\n\td.stop = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\td.distanceMonitor()\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 35.07507905551157}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"Distance monitor already running\")\n\t}\n\n\td.stop = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\td.distanceMonitorRunning = true\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.Distance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error reading distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.distance = distance\n\t\t\t\t}\n\t\t\t\ttime.Sleep(d.distanceMonitorDelay)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 47.03384389395436}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTime time.Time\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := time.Now().Sub(startTime)\n\t\t\td.sendDuration(duration)\n\t\t}\n\t}\n}", "CodeBleu_score": 38.5162943043383}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar start time.Time\n\treturn func(pin int, duration time.Duration, edge string, level uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := time.Since(start)\n\t\t\td.durationChannel <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 37.99805680856626}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar start time.Time\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, id uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := time.Since(start)\n\t\t\td.durationChan <- duration\n\t\t}\n\t}\n}", "CodeBleu_score": 37.97287285541549}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\terr := d.trig.Write(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(10 * time.Microsecond)\n\terr = d.trig.Write(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the echo\n\ttimeout := time.After(d.timeout)\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn errors.New(\"timeout while waiting for echo\")\n\t\tdefault:\n\t\t\tif d.echo.Read() == gpio.High {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Wait for the echo to go low\n\ttimeout = time.After(d.timeout)\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn errors.New(\"timeout while waiting for echo to go low\")\n\t\tdefault:\n\t\t\tif d.echo.Read() == gpio.Low {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Measure the time between the echo going high and low\n\tstart := time.Now()\n\tfor {\n\t\tif d.echo.Read() == gpio.High {\n\t\t\tbreak\n\t\t}\n\t}\n\tend := time.Now()\n\td.time = end.Sub(start)\n\n\treturn nil\n}", "CodeBleu_score": 56.97108127873669}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor to measure distance.\n\terr := d.trigger()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the sensor to complete the measurement.\n\ttimeout := time.After(d.timeout)\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn errors.New(\"timeout\")\n\t\tdefault:\n\t\t\tif d.echo.Read() == gpio.Low {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 47.20927212022781}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t// Lock the mutex\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\tif err := d.trigger(); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the echo pin to be activated\n\tif err := d.waitForEcho(); err != nil {\n\t\treturn err\n\t}\n\n\t// Get the duration of the echo pulse\n\tif err := d.getEchoDuration(); err != nil {\n\t\treturn err\n\t}\n\n\t// Unlock the mutex\n\treturn nil\n}", "CodeBleu_score": 44.43716628453947}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\tif self.access_token is not None and self.access_token_expires_at is not None:\n        if self.access_token_expires_at > datetime.utcnow():\n            return self.access_token\n\n    if self.refresh_token is not None:\n        self.fetch_authentication_token_from_refresh_token()\n        return self.access_token\n\n    if self.client_id is not None and self.client_secret is not None:\n        self.fetch_authentication_token_from_client_credentials()\n        return self.access_token\n\n    raise AccountNotAuthorized(\n        \"No valid authentication token available. \"\n        \"Please authenticate with a valid username and password, \"\n        \"or set the environment variables 'CLIENT_ID' and 'CLIENT_SECRET'.\"\n    )\n\n", "CodeBleu_score": 22.530184775237426}, {"code": "def fetch_authentication_token(self)\n\ttry:\n        return os.environ[\"ACCESS_TOKEN\"]\n    except KeyError:\n        pass\n    try:\n        return self.state.get(\"access_token\")\n    except KeyError:\n        pass\n    try:\n        expiration_time = self.state.get(\"expiration_time\")\n        if expiration_time and expiration_time > time.time():\n            return self.state.get(\"access_token\")\n    except KeyError:\n        pass\n    try:\n        refresh_token = self.state.get(\"refresh_token\")\n        if not refresh_token:\n            raise AccountError(\"No refresh token available.\")\n        response = self.fetch_json_data(\n            \"https://accounts.spotify.com/api/token\",\n            method=\"POST\",\n            data={\n                \"grant_type\": \"refresh_token\",\n                \"refresh_token\": refresh_token,\n            },\n        )\n        self.state[\"access_token\"] = response[\"access_token\"]\n        self.state[\"expiration_time\"] = time.time() + response[\"expires_in\"]\n        self.state[\"refresh_token\"] = response[\"refresh_token\"]\n        return response[\"access_token\"]\n    except AccountError as exc:\n        raise AccountNotAuthorized(exc) from exc\n\n", "CodeBleu_score": 41.45054878201762}, {"code": "def fetch_authentication_token(self)\n\t# Check if the access token is available in the environment variables.\n    if self.access_token:\n        return self.access_token\n\n    # Check if the access token is available in the local state.\n    if self.access_token_expiration_time:\n        if self.access_token_expiration_time > datetime.now():\n            return self.access_token\n\n        if self.refresh_token:\n            # Fetch a new access token using the refresh token.\n            response = self.request(\n                method=\"POST\",\n                url=self.oauth_token_url,\n                headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n                data={\n                    \"grant_type\": \"refresh_token\",\n                    \"refresh_token\": self.refresh_token,\n                    \"client_id\": self.client_id,\n                    \"client_secret\": self.client_secret,\n                },\n            )\n\n            # Update the local state with the new authentication data.\n            self.access_token = response.json()[\"access_token\"]\n            self.access_token_expiration_time = datetime.now() + timedelta(\n                seconds=response.json()[\"expires_in\"]\n            )\n            self.refresh_token = response.json()[\"refresh_token\"]\n\n            # Return the new access token.\n            return self.access_token\n\n    # If all methods fail, raise an \"AccountNotAuthorized\" exception.\n    raise AccountNotAuthorized(\n        \"The application is not authorized to access the account. \"\n        \"Please authenticate the application by following the instructions in the README.md file.\"\n    )\n\n", "CodeBleu_score": 36.56178481617566}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\trefresh_token = self.get_refresh_token()\n    self.delete_session()\n    try:\n        self.fetch_json_data(\n            \"/v1/logout\",\n            method=\"POST\",\n            data={\"refresh_token\": refresh_token},\n            allow_redirects=False,\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 51.776200436599204}, {"code": "def logout(self)\n\ttry:\n        self.refresh_token\n    except AttributeError:\n        return True\n    try:\n        self.session.delete(self.base_url + \"/v1/logout\")\n    except AccountError:\n        pass\n    del self.refresh_token\n    return True\n\n", "CodeBleu_score": 41.1153433558533}, {"code": "def logout(self)\n\ttry:\n        self.refresh_token = self.session.get_refresh_token()\n        self.session.delete()\n        self.fetch_json_data(\n            \"/v1/logout\",\n            method=\"POST\",\n            headers={\"Authorization\": f\"Bearer {self.refresh_token}\"},\n        )\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 45.23358806860425}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\tused_packages = []\n    for package in self.packages:\n        if not package.optional:\n            package_data = package.get_metadata()\n            if package_data.get(\"external\", False):\n                package_data[\"source\"] = package.source_url\n            used_packages.append(package_data)\n    return used_packages\n\n", "CodeBleu_score": 23.524673572114235}, {"code": "def dump_used_packages(self)\n\tused_packages = []\n    for pkg in self.pm.packages:\n        if pkg.optional:\n            continue\n        used_packages.append({\n            \"name\": pkg.name,\n            \"version\": pkg.version,\n            \"source\": pkg.source,\n            \"spec\": pkg.spec,\n        })\n    return used_packages\n\n", "CodeBleu_score": 25.215446762284977}, {"code": "def dump_used_packages(self)\n\tpackages = []\n    for pkg in self.pm.get_packages():\n        if pkg.optional:\n            continue\n        pkg_data = {\n            \"name\": pkg.name,\n            \"version\": pkg.version,\n            \"source\": pkg.source,\n        }\n        if pkg.external:\n            pkg_data[\"source\"] = pkg.source\n        packages.append(pkg_data)\n    return packages\n\n", "CodeBleu_score": 32.690463867427226}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\ttry:\n        platform = cls.get_platform(env)\n    except exception.UndefinedEnvPlatformError:\n        if autoinstall:\n            platform = cls.install_env(env)\n        else:\n            raise\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.set_env(env)\n    instance.configure(targets=targets)\n    return instance\n\n", "CodeBleu_score": 33.776711641758276}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif not env:\n        raise exception.UndefinedEnvPlatformError()\n\n    platform_spec = cls.get_platform_spec(env)\n    if not platform_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.set_project_env(env)\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 38.012382875972456}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif not env:\n        raise exception.UndefinedEnvPlatformError(\n            \"The environment name is not specified.\"\n        )\n    if not isinstance(env, str):\n        raise exception.InvalidEnvPlatformError(\n            \"The environment name must be a string.\"\n        )\n    if not targets:\n        targets = []\n    if not isinstance(targets, list):\n        raise exception.InvalidEnvPlatformError(\n            \"The environment targets must be a list.\"\n        )\n    env_platform = cls.get_platform(env)\n    if not env_platform:\n        raise exception.UndefinedEnvPlatformError(\n            \"The environment platform is not defined.\"\n        )\n    instance = cls(env_platform, autoinstall=autoinstall)\n    instance.set_env(env)\n    instance.configure(targets)\n    return instance\n\n", "CodeBleu_score": 33.12613030812448}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire.beginTransmission(AXP192_I2C_ADDRESS);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(AXP192_I2C_ADDRESS, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 63.072894800782166}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 69.07439625977746}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 69.07439625977746}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        Write1Byte(0x36, 0x80);\n        Write1Byte(0x37, time_in_us & 0xFF);\n        Write1Byte(0x38, time_in_us >> 8);\n        Write1Byte(0x39, time_in_us >> 16);\n    } else {\n        Write1Byte(0x36, 0x00);\n    }\n    Write1Byte(0x33, 0xC0);\n}", "CodeBleu_score": 54.90731724007206}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        Write1Byte(0x33, (uint8_t)(time_in_us & 0xFF));\n        Write1Byte(0x32, (uint8_t)((time_in_us >> 8) & 0xFF));\n        Write1Byte(0x31, (uint8_t)((time_in_us >> 16) & 0xFF));\n        Write1Byte(0x30, (uint8_t)((time_in_us >> 24) & 0xFF));\n        Write1Byte(0x82, 0x00);\n        Write1Byte(0x80, 0x01);\n    } else {\n        Write1Byte(0x82, 0x00);\n        Write1Byte(0x80, 0x00);\n    }\n    Write1Byte(0x81, 0x00);\n}", "CodeBleu_score": 52.12303565382357}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        uint8_t buf = Read8bit(0x36);\n        buf         = (1 << 7) | buf;\n        Write1Byte(0x36, buf);\n        Write1Byte(0x30, time_in_us & 0xFF);\n        Write1Byte(0x31, (time_in_us >> 8) & 0xFF);\n        Write1Byte(0x32, (time_in_us >> 16) & 0xFF);\n        Write1Byte(0x33, (time_in_us >> 24) & 0xFF);\n        Write1Byte(0x34, (time_in_us >> 32) & 0xFF);\n        Write1Byte(0x35, (time_in_us >> 40) & 0xFF);\n        Write1Byte(0x36, (1 << 7) | buf);\n        Write1Byte(0x37, 0x00);\n    } else {\n        Write1Byte(0x36, 0x00);\n    }\n    Write1Byte(0x37, 0x00);\n}", "CodeBleu_score": 50.73575228465243}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\tuint16_t y = y_scroll;\n  if (tteBar) {\n    tft.fillRect(0, 0, TFT_WIDTH, TFT_HEIGHT - TFT_HEIGHT / 10, color);\n    y_scroll = TFT_HEIGHT / 10;\n  } else {\n    tft.fillRect(0, y_scroll, TFT_WIDTH, TFT_HEIGHT - TFT_HEIGHT / 10, color);\n    y_scroll += TFT_HEIGHT / 10;\n    if (y_scroll >= TFT_HEIGHT - TFT_HEIGHT / 10) y_scroll = 0;\n  }\n  scrollAddress(y_scroll);\n  return y;\n}", "CodeBleu_score": 24.017971927310032}, {"code": "int Display::scroll_line(uint32_t color){\n\tuint16_t y = tte_y;\n  uint16_t y_new = y + TTE_LINE_HEIGHT;\n  uint16_t y_new_max = TTE_HEIGHT - TTE_BOTTOM_FIXED_AREA;\n  if (tte_bar) {\n    y_new_max = TTE_HEIGHT - TTE_TOP_FIXED_AREA;\n    if (y_new > TTE_HEIGHT - TTE_TOP_FIXED_AREA) y_new = TTE_TOP_FIXED_AREA;\n  }\n  if (y_new > y_new_max) y_new = TTE_BOTTOM_FIXED_AREA;\n  tft.fillRect(0, y, TFT_WIDTH, TTE_LINE_HEIGHT, color);\n  tte_y = y_new;\n  scrollAddress(TTE_BOTTOM_FIXED_AREA - tte_y);\n  return y;\n}", "CodeBleu_score": 32.61781490846069}, {"code": "int Display::scroll_line(uint32_t color){\n\tuint16_t y_old = y_scroll;\n  uint16_t y_new = y_scroll + tft.fontSize();\n  if (y_new >= tft.height() - tft.fontSize()) {\n    y_new = 0;\n    if (tteBar) {\n      y_new = tft.fontSize();\n    }\n  }\n  tft.fillRect(0, y_scroll, tft.width(), tft.fontSize(), color);\n  y_scroll = y_new;\n  scrollAddress(y_scroll);\n  return y_old;\n}", "CodeBleu_score": 19.377049902609045}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  if (this->ssids->getLength() == 0) {\n    Serial.println(F(\"No SSIDs defined!\"));\n    return false;\n  }\n\n  if (this->access_points->getLength() == 0) {\n    Serial.println(F(\"No access points defined!\"));\n    return false;\n  }\n\n  if (!this->setupAccessPoints()) {\n    Serial.println(F(\"Failed to setup access points!\"));\n    return false;\n  }\n\n  if (!this->setupHTML()) {\n    Serial.println(F(\"Failed to setup HTML!\"));\n    return false;\n  }\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 50.723124671151055}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t// set up access points\n  if (!this->setupAccessPoints(access_points)) {\n    return false;\n  }\n\n  // set up HTML content\n  if (!this->setupHTML(ssids)) {\n    return false;\n  }\n\n  // start portal\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 61.87905814240209}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tif (this->setupAccessPoints(access_points) == false) {\n    return false;\n  }\n  if (this->setupHTML(ssids) == false) {\n    return false;\n  }\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 59.31089173318469}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n        if (queue.size() == 0) {\n            text = \"\";\n            text_in = \"\";\n        }\n    } else {\n        queue.clear();\n        text = \"\";\n        text_in = \"\";\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 15.58756282489892}, {"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n        if (queue.empty()) {\n            queue.push_back(text);\n            text = \"\";\n            text_in = \"\";\n        }\n    } else {\n        queue.clear();\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 15.429937691002463}, {"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n    if (queue_init_flag) {\n      return;\n    }\n    else {\n      queue_init_flag = true;\n      queue = new std::queue<std::string>;\n      text = new std::string;\n      text_in = new std::string;\n    }\n  }\n  else {\n    queue_enabled_flag = true;\n    queue_init_flag = true;\n    queue = new std::queue<std::string>;\n    text = new std::string;\n    text_in = new std::string;\n  }\n}", "CodeBleu_score": 13.068164667912985}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\tif (queue_nmea != NULL) {\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = NULL;\n\t}\n\tqueue_nmea = new Queue<NmeaSentence*>();\n}", "CodeBleu_score": 35.98462598340618}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif (this->nmea_queue != NULL) {\n\t\tdelete this->nmea_queue;\n\t\tthis->nmea_queue = new Queue<String>();\n\t}\n\telse {\n\t\tthis->nmea_queue = new Queue<String>();\n\t}\n}", "CodeBleu_score": 20.289683138984696}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif (nmea_queue != NULL) {\n        delete nmea_queue;\n        nmea_queue = new Queue<NmeaSentence*>(MAX_NMEA_SENTENCE_QUEUE_SIZE);\n    }\n    else {\n        nmea_queue = new Queue<NmeaSentence*>(MAX_NMEA_SENTENCE_QUEUE_SIZE);\n    }\n}", "CodeBleu_score": 39.3381421051817}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t/*Write the buffer to the display*/\n    uint8_t *buf = (uint8_t *) color_p;\n    uint16_t length = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1);\n    /*Set the address*/\n    uint8_t x_start = area->x1;\n    uint8_t y_start = area->y1;\n    uint8_t x_end = area->x2;\n    uint8_t y_end = area->y2;\n    /*Set the address*/\n    write_cmd(0x2a);\n    write_data(x_start);\n    write_data(x_end);\n    write_cmd(0x2b);\n    write_data(y_start);\n    write_data(y_end);\n    write_cmd(0x2c);\n    /*Send the buffer*/\n    write_data(buf, length * 2);\n    /*Set the address*/\n    write_cmd(0x2a);\n    write_data(x_start);\n    write_data(x_end);\n    write_cmd(0x2b);\n    write_data(y_start);\n    write_data(y_end);\n    write_cmd(0x2c);\n    /*Notify the end of flush*/\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 44.15175556071752}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t/*Write the memory of the display*/\n    uint32_t size = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1);\n    uint32_t i;\n    for(i = 0; i < size; i++) {\n        /*Set the address*/\n        ili9341_set_cursor(area->x1 + i % (area->x2 - area->x1 + 1), area->y1 + i / (area->x2 - area->x1 + 1));\n        /*Write the color*/\n        ili9341_write_data((uint8_t *)&color_p[i], 1);\n    }\n    /*IMPORTANT! It must be called to tell the system that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 44.78377149983916}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t//Set the address window to the area to be updated\n    ili9341_set_window(area->x1, area->y1, area->x2, area->y2);\n\n    //Iterate through each pixel in the area and write the corresponding color to the display\n    for(int y = area->y1; y <= area->y2; y++) {\n      for(int x = area->x1; x <= area->x2; x++) {\n        //Write the pixel color to the display\n        ili9341_write_data(color_p->full);\n\n        //Increment the color buffer pointer to the next pixel\n        color_p++;\n      }\n    }\n\n    //Notify that the flush is complete\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 48.818682685032286}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t// Iterate through all menu nodes\n\tfor (int i = 0; i < menu->getMenuNodeCount(); i++) {\n\n\t\t// Print the name of the current node\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tstd::cout << \"  \";\n\t\t}\n\t\tstd::cout << menu->getMenuNode(i)->getName() << std::endl;\n\n\t\t// If the current node has sub-nodes, call the function recursively\n\t\tif (menu->getMenuNode(i)->getSubMenu() != NULL) {\n\t\t\tshowMenuList(menu->getMenuNode(i)->getSubMenu(), layer + 1);\n\t\t}\n\t}\n\n\t// Print an empty line\n\tstd::cout << std::endl;\n}", "CodeBleu_score": 44.6089512853092}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tif (menu == NULL) {\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < menu->getNumberOfNodes(); i++) {\n\t\tMenuNode * node = menu->getNode(i);\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \" \";\n\t\t}\n\t\tcout << node->getName() << endl;\n\t\tif (node->getType() == MenuNode::TYPE_MENU) {\n\t\t\tshowMenuList(node->getMenu(), layer + 1);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.846595985986305}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t// Iterate through all menu nodes and print each node's name with indentation proportional to the layer level.\n\tfor (int i = 0; i < menu->getNumberOfNodes(); i++) {\n\t\t// Print the node's name with indentation proportional to the layer level.\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \"  \";\n\t\t}\n\t\tcout << menu->getNode(i)->getName() << endl;\n\t\t// If the node has children, call the function recursively to display the child nodes.\n\t\tif (menu->getNode(i)->getNumberOfChildren() > 0) {\n\t\t\tshowMenuList(menu->getNode(i), layer + 1);\n\t\t}\n\t}\n\t// Print an empty line.\n\tcout << endl;\n}", "CodeBleu_score": 45.61901302534773}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\tint i;\n  for (i = 0; i < count; i++) {\n    char ssid[7];\n    char mac[18];\n    int channel;\n    int mac_index = 0;\n    int ssid_index = 0;\n    int channel_index = 0;\n    int channel_count = 0;\n    int ssid_count = 0;\n    int ssid_length = 0;\n    int mac_length = 0;\n    int ssid_char = 0;\n    int mac_char = 0;\n    int ssid_char_index = 0;\n    int mac_char_index = 0;\n    int ssid_char_value = 0;\n    int mac_char_value = 0;\n    int ssid_char_value_index = 0;\n    int mac_char_value_index = 0;\n    int ssid_char_value_count = 0;\n    int mac_char_value_count = 0;\n    int ssid_char_value_length = 0;\n    int mac_char_value_length = 0;\n    int ssid_char_value_length_index = 0;\n    int mac_char_value_length_index = 0;\n    int ssid_char_value_length_count = 0;\n    int mac_char_value_length_count = 0;\n    int ssid_char_value_length_count_index = 0;\n    int mac_char_value_length_count_index = 0;\n    int ssid_char_value_length_count_count = 0;\n    int mac_char_value_length_count_count = 0;\n    int ssid_char_value_length_count_count_index = 0;\n    int mac_char_value_length_count_count_index = 0;\n    int ssid_char_value_length_count_count_count = 0;\n    int mac_char_value_length_count_count_count = 0;\n    int ssid_char_value_length_count_count_count_", "CodeBleu_score": 12.81761097433044}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t// Initialize the random seed\n  randomSeed(analogRead(0));\n\n  // Initialize the list of SSIDs\n  SSIDList.clear();\n\n  // Iterate through the given count\n  for (int i = 0; i < count; i++) {\n\n    // Generate a random SSID\n    String ssid = generateRandomSSID();\n\n    // Generate a random channel\n    int channel = random(1, 14);\n\n    // Generate a random MAC address\n    String mac = generateRandomMAC();\n\n    // Add the SSID to the list\n    SSIDList.push_back(ssid);\n\n    // Print the generated SSID\n    Serial.println(\"Generated SSID: \" + ssid + \" on channel: \" + String(channel) + \" with MAC: \" + mac);\n  }\n\n  // Return the number of generated SSIDs\n  return count;\n}", "CodeBleu_score": 40.06562645398544}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint i;\n  for (i = 0; i < count; i++) {\n    // create random SSID\n    char ssid[7];\n    for (int j = 0; j < 6; j++) {\n      ssid[j] = (char)random(97, 122);\n    }\n    ssid[6] = '\\0';\n\n    // create random channel\n    int channel = random(1, 14);\n\n    // create random MAC address\n    char mac[18];\n    sprintf(mac, \"%02X:%02X:%02X:%02X:%02X:%02X\", random(256), random(256), random(256), random(256), random(256), random(256));\n\n    // create SSID object\n    SSID ssidObject;\n    ssidObject.ssid = ssid;\n    ssidObject.channel = channel;\n    ssidObject.mac = mac;\n\n    // add SSID object to list\n    ssidList.push_back(ssidObject);\n\n    // print SSID to serial output\n    Serial.print(i + 1);\n    Serial.print(\": \");\n    Serial.print(ssid);\n    Serial.print(\" (\");\n    Serial.print(channel);\n    Serial.print(\") \");\n    Serial.println(mac);\n  }\n  return i;\n}", "CodeBleu_score": 48.73057063708425}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t# [START pubsub_create_topic]\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n    # [END pubsub_create_topic]\n\n", "CodeBleu_score": 90.9582225300981}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\timport jwt\n    import time\n    import datetime\n    from google.oauth2 import service_account\n    from google.auth.transport.requests import Request\n    from google.auth.transport.requests import AuthorizedSession\n\n    # Set the current UTC time in seconds since the epoch.\n    now = int(time.time())\n\n    # Set the expiration time to 1 hour later.\n    exp = now + 3600\n\n    # Set the audience to the GCP project ID.\n    aud = project_id\n\n    # Create the JWT payload.\n    payload = {\n        'iat': now,\n        'exp': exp,\n        'aud': aud\n    }\n\n    # Read the private key from the specified file.\n    with open(private_key_file, 'rb') as f:\n        private_key = f.read()\n\n    # Create a JWT signer using the private key.\n    signer = service_account.IDTokenSigner(Request(), private_key, algorithm=algorithm)\n\n    # Create the signed JWT.\n    signed_jwt = signer.sign_jwt(payload)\n\n    # Return the signed JWT.\n    return signed_jwt\n\n", "CodeBleu_score": 44.085023588016455}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\timport datetime\n    import jwt\n    now = datetime.datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(payload, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 58.9669837465279}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\timport datetime\n    import jwt\n    from google.oauth2 import service_account\n    now = datetime.datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    signer = service_account.Signer.from_string(private_key)\n    return jwt.encode(payload, signer, algorithm=algorithm)\n\n", "CodeBleu_score": 60.293875714499144}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\tpayload = message.payload.decode('utf-8')\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        path = '/tmp/image.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        print(url)\n        publish_message(\n                args.project_id, args.cloud_region, args.registry_id,\n                args.device_id, args.private_key_file, args.algorithm,\n                args.ca_certs, args.mqtt_bridge_hostname,\n                args.mqtt_bridge_port, 'events', url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 50.87576755355485}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print('Received payload \\'on\\'')\n        path = '/tmp/image.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        print('Uploaded image to: {}'.format(url))\n        client.publish(\n                'events',\n                url,\n                qos=1)\n        print('Published message \\'{}\\' to topic \\'{}\\''.format(\n                url, 'events'))\n    else:\n        print('Received payload \\'off\\'')\n\n", "CodeBleu_score": 44.35587289804735}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message \\'{}\\' on topic \\'{}\\' with QoS {}'.format(\n            message.payload, message.topic, message.qos))\n    if message.payload == b'on':\n        # Capture a preview image\n        path = '/home/pi/Desktop/image.jpg'\n        preview_capture(path)\n        # Upload the file to a specified bucket\n        url = upload_file(path, args.bucket_name)\n        # Publish the file's URL to an MQTT event topic\n        mqtt_client.publish(\n                'events',\n                url,\n                qos=1)\n    elif message.payload == b'off':\n        print('off')\n\n", "CodeBleu_score": 38.92827910915663}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\timport argparse\n    import os\n    import sys\n\n    parser = argparse.ArgumentParser(\n        description=\"Google Cloud IoT MQTT device connection example.\")\n    parser.add_argument(\n        \"--project_id\",\n        help=\"GCP cloud project name\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\n        \"--registry_id\",\n        help=\"Cloud IoT registry id\",\n        default=\"my-registry\")\n    parser.add_argument(\n        \"--device_id\",\n        help=\"Cloud IoT device id\",\n        default=\"my-device\")\n    parser.add_argument(\n        \"--private_key_file\",\n        help=\"Path to private key file.\")\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n        default=\"ES256\")\n    parser.add_argument(\n        \"--cloud_region\",\n        help=\"GCP cloud region, e.g. 'us-central1'\",\n        default=\"us-central1\")\n    parser.add_argument(\n        \"--ca_certs\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n        default=\"roots.pem\")\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        help=\"Number of messages to publish.\",\n        default=1000)\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        help=\"MQTT bridge hostname.\",\n        default=\"mqtt.googleapis.com\")\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        help=\"MQTT bridge port.\",\n        default=8883)\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        type=int,\n        help=\"Expiration time, in minutes, for JWT tokens.\",\n        default=20)\n    parser.", "CodeBleu_score": 50.215392782050316}, {"code": "def parse_command_line_args()\n\timport argparse\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT device connection')\n    parser.add_argument('--project_id', default=os.environ.get('GOOGLE_CLOUD_PROJECT'), help='GCP cloud project name')\n    parser.add_argument('--registry_id', required=True, help='Cloud IoT Core registry id')\n    parser.add_argument('--device_id', required=True, help='Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', required=True, help='Path to private key file.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--ca_certs', default='roots.pem', help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument('--num_messages', type=int, default=100, help='Number of messages to publish.')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--message_type', choices=('event', 'state'), default='event', help='Indicates whether the message to be published is a telemetry event or a device state message.')\n    parser.add_argument('--jwt_expires_minutes', default=60, type=int, help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument('--jwt_issuer', default=None, help='Issuer ID for JWT tokens.')\n    parser.add_argument('--jwt_subject', default=None, help='Subject for", "CodeBleu_score": 38.0797775206797}, {"code": "def parse_command_line_args()\n\timport argparse\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Project ID. If not set, uses the value of the GOOGLE_CLOUD_PROJECT environment variable.')\n    parser.add_argument(\n        '--registry_id',\n        help='Cloud IoT Core Registry ID.')\n    parser.add_argument(\n        '--device_id',\n        help='Cloud IoT Core Device ID.')\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event', 'state'),\n        default='event',\n        help=('Indicates whether the message to be published is a '\n              'telemetry event or a device state message.'))\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        choices=(8883, 443),\n        default=8883,\n        type=int,\n        help='MQTT bridge port.')\n    parser.add_argument(", "CodeBleu_score": 31.558345275574606}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t# The scopes below are the minimum required to use the Cloud IoT Core API.\n    # See the following documentation for more information:\n    # https://cloud.google.com/iot/docs/iam#roles\n    SCOPES = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/cloudiot\",\n    ]\n    # The version below specifies the version of the API to use.\n    # For more information, see:\n    # https://cloud.google.com/iot/docs/reference/cloudiot/rest/v1/projects.locations.registries\n    API_VERSION = \"v1\"\n    # The discovery URL below identifies where to find the most recent versions\n    # of the Cloud IoT Core API.\n    DISCOVERY_URL = (\n        \"https://cloudiot.googleapis.com/$discovery/rest?version=\" + API_VERSION\n    )\n    # The client below identifies the service account credentials and scopes.\n    # It will be used to call the Cloud IoT Core API.\n    # For more information, see:\n    # https://developers.google.com/api-client-library/python/auth/service-accounts\n    client = googleapiclient.discovery.build(\n        \"cloudiot\", API_VERSION, credentials=service_account_json, discoveryServiceUrl=DISCOVERY_URL\n    )\n    return client\n\n", "CodeBleu_score": 26.902269595086114}, {"code": "def get_client(service_account_json)\n\t# Define the scopes and discovery URL\n    SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n    DISCOVERY_URL = 'https://cloudiot.googleapis.com/$discovery/rest?version=v1'\n\n    # Load the service account credentials and define the service account\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(SCOPES)\n    service_account_email = scoped_credentials.service_account_email\n\n    # Build the client for the Cloud IoT Core API\n    return discovery.build('cloudiot', 'v1', credentials=scoped_credentials,\n                           discoveryServiceUrl=DISCOVERY_URL)\n\n", "CodeBleu_score": 24.88560588669844}, {"code": "def get_client(service_account_json)\n\t# Define the necessary API scopes, version, and discovery URL\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    version = 'v1'\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials, scoped appropriately\n    credentials = ServiceAccountCredentials.from_json_keyfile_name(service_account_json, scopes)\n\n    # Build and return the client for the Cloud IoT Core service using the discovery API URL\n    return discovery.build('cloudiot', version, credentials=credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 17.28529899735701}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t# Get ASN1 code for hash method\n    asn1_code = get_asn1_code(hash_method)\n\n    # Concatenate ASN1 code with hash value\n    hash_value = asn1_code + hash_value\n\n    # Pad for signing\n    padded_hash = _pad_for_signing(hash_value, 100)\n\n    # Encrypt padded hash with private key\n    encrypted_hash = priv_key.encrypt(padded_hash, 1)\n\n    # Return encrypted signature\n    return encrypted_hash\n\n\n", "CodeBleu_score": 11.487228254739534}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\tif hash_method == 'SHA1':\n        asn1_code = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == 'SHA256':\n        asn1_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'SHA384':\n        asn1_code = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'SHA512':\n        asn1_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n\n    padded_hash = _pad_for_signing(asn1_code + hash_value, 128)\n\n    return encrypt_message(padded_hash, priv_key)\n\n\n", "CodeBleu_score": 17.152577178560307}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t# Retrieve the ASN1 code for the hash method\n    hash_method_asn1 = _hash_method_to_asn1(hash_method)\n\n    # Concatenate the ASN1 code with the hash value\n    hash_value_with_hash_method = hash_method_asn1 + hash_value\n\n    # Pad the result for signing\n    hash_value_with_hash_method_padded = _pad_for_signing(hash_value_with_hash_method, 128)\n\n    # Encrypt the padded hash using the private key\n    signature = _rsa_encrypt(hash_value_with_hash_method_padded, priv_key)\n\n    return signature\n\n\n", "CodeBleu_score": 13.227790458153017}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t# convert signature to an integer\n    sig_int = int(signature, 16)\n\n    # decrypt signature\n    clear_sig = pub_key.decrypt(sig_int)\n\n    # find hash method\n    hash_method = _find_method_hash(clear_sig)\n\n    # compute hash\n    hash_obj = compute_hash(message, hash_method)\n\n    # reconstruct padded hash\n    padded_hash = _pad_for_signing(hash_obj, len(clear_sig) - 3)\n\n    # compare with clear signature\n    if padded_hash != clear_sig:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n\n", "CodeBleu_score": 20.095533562766676}, {"code": "def verify(message, signature, pub_key)\n\t# Convert the signature to an integer.\n    signature_int = decode_signature(signature)\n\n    # Decrypt the signature.\n    clear_signature = pub_key.decrypt(signature_int)\n\n    # Find the hash method.\n    hash_method = _find_method_hash(clear_signature)\n\n    # Compute the hash of the message.\n    message_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the padded hash.\n    padded_hash = _pad_for_signing(message_hash, len(clear_signature))\n\n    # Compare the padded hash with the clear signature.\n    if padded_hash != clear_signature:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n", "CodeBleu_score": 20.09891329285438}, {"code": "def verify(message, signature, pub_key)\n\t# TODO: Implement\n    # TODO: Rename this to something like verify_signature\n\n    # TODO: Verify that the signature is a valid DER-encoded ASN.1 sequence\n    # TODO: Verify that the public key is a valid DER-encoded ASN.1 sequence\n\n    # TODO: Determine the hash method used\n    # TODO: Compute the hash of the message\n    # TODO: Reconstruct the expected padded hash\n    # TODO: Compare the expected padded hash with the clear signature\n    # TODO: Return the hash method name\n\n    # TODO: Raise a VerificationError if the verification fails\n\n    # TODO: Implement this function\n\n", "CodeBleu_score": 1.8790849673202614}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\tuint32_t epoch;\n   uint8_t res = CRYPTO_CLIENT_getEpoch(&epoch);\n   if (res == 0) {\n      updateJWT(epoch);\n   } else {\n      debug_printError(\"MQTT: Time is not valid\");\n   }\n\n   MQTT_CLIENT_connect(&mqttClient, mqttServer, mqttPort, mqttKeepAlive, mqttClientId, mqttUsername, mqttPassword, mqttCleanSession);\n   MQTT_CLIENT_setConnectActionCallback(&mqttClient, connectActionCallback);\n   debug_printInfo(\"MQTT: Connecting to %s:%d\", mqttServer, mqttPort);\n}", "CodeBleu_score": 40.890601115243854}, {"code": "static void connectMQTT(){\n\tif (time(NULL) > 0) {\n      updateJWT(time(NULL));\n   }\n   else {\n      debug_printError(\"MQTT: Invalid time\");\n   }\n\n   int rc = MQTT_CLIENT_connect(&mqttClient, mqttBroker, mqttPort, 60, false, mqttUsername, mqttPassword, mqttPassword);\n   if (rc != 0) {\n      debug_printError(\"MQTT: Connection failed with result code %d\", rc);\n      return;\n   }\n   debug_printInfo(\"MQTT: Connection successful\");\n   mqttSubscribe = true;\n}", "CodeBleu_score": 48.133722992261156}, {"code": "static void connectMQTT(){\n\ttime_t now;\n   time(&now);\n   if (now < 1500000000) {\n      debug_printInfo(\"Time is not valid, not connecting to MQTT.\");\n      return;\n   }\n\n   updateJWT(now);\n\n   MQTT_CLIENT_connect(&mqttClient, mqttPassword, 0, 1, 1);\n   mqttSubscribe = 1;\n   debug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 44.43425168994162}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t result = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        result = result * 10 + str[i] - '0';\n    }\n    *num = result;\n    return str + width;\n}", "CodeBleu_score": 27.477061973738063}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t res = 0;\n\tuint32_t base = 1;\n\tuint32_t max_val = 0xffffffff / 10;\n\tuint32_t digit;\n\twhile (width--) {\n\t\tdigit = *str - '0';\n\t\tif (digit > 9)\n\t\t\treturn str;\n\t\tif (res > max_val)\n\t\t\treturn str;\n\t\tres = res * 10 + digit;\n\t\tstr++;\n\t}\n\t*num = res;\n\treturn str;\n}", "CodeBleu_score": 26.71721733121627}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t result = 0;\n    uint8_t digit;\n    while (width--) {\n        digit = *str++;\n        if (digit < '0' || digit > '9') {\n            return str - 1;\n        }\n        if (result > 429496729) {\n            return str - 1;\n        }\n        result = result * 10 + (digit - '0');\n    }\n    *num = result;\n    return str;\n}", "CodeBleu_score": 25.061136148930512}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    size_t cert_size = 0;\n    size_t cert_max_size = 0;\n    size_t cert_offset = 0;\n    uint8_t cert_temp[ATCACERT_MAX_CERT_SIZE];\n    uint8_t cert_temp_size = 0;\n    uint8_t cert_temp_offset = 0;\n    uint8_t cert_temp_max_size = 0;\n    uint8_t cert_temp_max_size_temp = 0;\n    uint8_t cert_temp_max_size_temp_offset = 0;\n    uint8_t cert_temp_max_size_temp_count = 0;\n    uint8_t cert_temp_max_size_temp_count_offset = 0;\n    uint8_t cert_temp_max_size_temp_count_count = 0;\n    uint8_t cert_temp_max_size_temp_count_count_offset = 0;\n    uint8_t cert_temp_max_size_temp_count_count_count = 0;\n    uint8_t cert_temp_max_size_temp_count_count_count_offset = 0;\n    uint8_t cert_temp_max_size_temp_count_count_count_count = 0;\n    uint8_t cert_temp_max_size_temp_count_count_count_count_offset = 0;\n    uint8_t cert_temp_max_size_temp_count_count_count_count_count = 0;\n    uint8_t cert_temp_max_size_temp_count_count_count_count_count_offset = 0;\n    uint8_t cert_temp_max_size_temp_count_count_count_count_count_count = 0;\n    uint8_t cert_temp_max_size_temp_count_count_count_count_count_count_offset = 0;\n    uint8_t cert_temp_max_size_temp_count_count_count_count_count_count_count = 0;", "CodeBleu_score": 9.801498476204761}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    uint8_t* cert_ptr = build_state->cert_tmpl;\n    size_t cert_size = build_state->cert_size;\n    const atcacert_def_t* cert_def = build_state->cert_def;\n    uint8_t* cert = build_state->cert;\n    size_t cert_max_size = build_state->cert_max_size;\n    const uint8_t* device_sn = build_state->device_sn;\n    uint8_t* nonce = build_state->nonce;\n    size_t nonce_size = build_state->nonce_size;\n    uint8_t* issue_date_tm_utc = build_state->issue_date_tm_utc;\n    uint8_t* expire_date_tm_utc = build_state->expire_date_tm_utc;\n    uint8_t* signer_cert = build_state->signer_cert;\n    size_t signer_cert_size = build_state->signer_cert_size;\n    uint8_t* signer_ca_public_key = build_state->signer_ca_public_key;\n    size_t signer_ca_public_key_size = build_state->signer_ca_public_key_size;\n    uint8_t* signer_cert_sn = build_state->signer_cert_sn;\n    size_t signer_cert_sn_size = build_state->signer_cert_sn_size;\n    uint8_t* signer_cert_public_key = build_state->signer_cert_public_key;\n    size_t signer_cert_public_key_size = build_state->signer_cert_public_key_size;\n    uint8_t* signer_cert_comp_cert = build_state->signer_cert_comp_cert;\n    size_t signer_cert_comp_cert_size = build_state->signer_cert_comp_cert_size;\n    uint8_t* signer_cert_tbs = build", "CodeBleu_score": 16.96227098957676}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    size_t i = 0;\n    size_t cert_size = 0;\n    size_t cert_size_max = 0;\n    uint8_t* cert = NULL;\n    uint8_t* cert_end = NULL;\n    uint8_t* cert_start = NULL;\n    uint8_t* cert_max = NULL;\n    const atcacert_def_t* cert_def = NULL;\n    atcacert_tm_utc_t issue_date;\n    atcacert_tm_utc_t expire_date;\n    atcacert_tm_utc_t now;\n    uint8_t* cert_sn = NULL;\n    uint8_t* cert_sn_end = NULL;\n    uint8_t* cert_sn_start = NULL;\n    uint8_t* cert_sn_max = NULL;\n    uint8_t* cert_sig = NULL;\n    uint8_t* cert_sig_end = NULL;\n    uint8_t* cert_sig_start = NULL;\n    uint8_t* cert_sig_max = NULL;\n    uint8_t* cert_sig_comp = NULL;\n    uint8_t* cert_sig_comp_end = NULL;\n    uint8_t* cert_sig_comp_start = NULL;\n    uint8_t* cert_sig_comp_max = NULL;\n    uint8_t* cert_sig_comp_temp = NULL;\n    uint8_t* cert_sig_comp_temp_end = NULL;\n    uint8_t* cert_sig_comp_temp_start = NULL;\n    uint8_t* cert_sig_comp_temp_max = NULL;\n    uint8_t* cert_sig_comp_temp_temp = NULL;\n    uint8_t* cert_sig_comp_temp_temp_end = NULL;\n    uint8_t* cert_sig_comp_temp_temp_start = NULL;\n    uint8_t* cert_sig_comp_temp_temp_max = NULL;\n    uint8_t* cert_sig_comp_", "CodeBleu_score": 13.585007203946184}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = ATCACERT_E_SUCCESS;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    size_t signature_size = sizeof(signature);\n    uint8_t ca_public_key_comp[72];\n    uint8_t ca_public_key_comp_size = sizeof(ca_public_key_comp);\n    uint8_t ca_public_key_temp[72];\n    uint8_t ca_public_key_temp_size = sizeof(ca_public_key_temp);\n\n    if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (cert_def->type != CERTTYPE_X509) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_subj_public_key(cert_def, cert, cert_size, ca_public_key_comp);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_device_loc_comp_cert(cert_def, cert, cert_size, ca_public_key_temp);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_hw_verify_signature(tbs_digest, signature, signature_size, ca_public_key_comp, ca_public_key_comp", "CodeBleu_score": 73.40061594258499}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    uint8_t pubkey[64];\n    uint8_t pubkey_comp[32];\n    uint8_t temp_buf[72];\n    size_t tbs_digest_size = 0;\n    size_t signature_size = 0;\n    size_t pubkey_size = 0;\n    uint8_t* tbs = NULL;\n    size_t tbs_size = 0;\n\n    if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    /* Get the TBS portion of the certificate */\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest, &tbs_digest_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    /* Get the signature from the certificate */\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature, &signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    /* Get the public key from the certificate */\n    ret = atcacert_get_subj_public_key(cert_def, cert, cert_size, pubkey, &pubkey_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    /* Get the TBS portion of the certificate */\n    ret = atcacert_get_tbs(cert_def, cert, cert_size, temp_buf, &tbs_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n    tbs = &temp_buf[0];\n\n    /* Convert the public key to a compressed format */\n    ret", "CodeBleu_score": 71.10111383845845}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = ATCACERT_E_SUCCESS;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    size_t tbs_digest_size = sizeof(tbs_digest);\n    size_t signature_size = sizeof(signature);\n    uint8_t pubkey[64];\n    uint8_t signature_comp[64];\n    uint8_t pubkey_comp[64];\n    uint8_t digest[32];\n    uint8_t digest_comp[32];\n    uint8_t *p_pubkey = NULL;\n    uint8_t *p_pubkey_comp = NULL;\n    uint8_t *p_signature = NULL;\n    uint8_t *p_signature_comp = NULL;\n    uint8_t *p_tbs_digest = NULL;\n    uint8_t *p_digest = NULL;\n    uint8_t *p_digest_comp = NULL;\n    uint8_t *p_cert = NULL;\n    uint8_t *p_cert_end = NULL;\n    uint8_t *p_cert_start = NULL;\n    uint8_t *p_cert_tbs_start = NULL;\n    uint8_t *p_cert_tbs_end = NULL;\n    uint8_t *p_cert_tbs_digest = NULL;\n    uint8_t *p_cert_signature = NULL;\n    uint8_t *p_cert_signature_comp = NULL;\n    size_t cert_tbs_size = 0;\n    size_t cert_signature_size = 0;\n    size_t cert_tbs_digest_size = 0;\n    size_t cert_signature_comp_size = 0;\n    size_t cert_tbs_digest_comp_size = 0;\n    uint8_t cert_tbs_digest_comp[32];\n    uint8_t cert_signature_comp[64];\n    uint8_t cert_tbs_dig", "CodeBleu_score": 21.251633139660246}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tif (*list == NULL)\n        {\n            return false;\n        }\n\n        if (*list == timer)\n        {\n            *list = timer->next;\n            return true;\n        }\n\n        timerStruct_t *current = *list;\n        while (current->next != NULL)\n        {\n            if (current->next == timer)\n            {\n                current->next = timer->next;\n                return true;\n            }\n            current = current->next;\n        }\n        return false;\n    }", "CodeBleu_score": 39.318755799109084}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tif (timer->next == NULL)\n        {\n            *list = NULL;\n            return true;\n        }\n        *list = timer->next;\n        return true;\n    }", "CodeBleu_score": 12.989699590671561}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\ttimerStruct_t * volatile *listIterator = list;\n        timerStruct_t * volatile *listIteratorPrev = list;\n\n        while (*listIterator != NULL)\n        {\n            if (*listIterator == timer)\n            {\n                *listIteratorPrev = (*listIterator)->next;\n                return true;\n            }\n            listIteratorPrev = listIterator;\n            listIterator = &((*listIterator)->next);\n        }\n        return false;\n    }", "CodeBleu_score": 29.128735495449202}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tsint8\ts8Ret;\n\ts8Ret = close((SOCKET)socket);\n\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\tbsd_setErrNo(BSD_ERROR);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 21.729684885133587}, {"code": "int BSD_close(int socket){\n\tint ret;\n\ttstrSocket *pstrSock = NULL;\n\t\n\tif(socket >= 0 && socket < MAX_SOCKET)\n\t{\n\t\tpstrSock = &gastrSockets[socket];\n\t}\n\tif(pstrSock == NULL)\n\t{\n\t\tbsd_setErrNo(BSD_ENOMEM);\n\t\treturn BSD_ERROR;\n\t}\n\tif(pstrSock->bIsUsed == 0)\n\t{\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tret = close(socket);\n\tif(ret == SOCK_ERR_NO_ERROR)\n\t{\n\t\treturn BSD_SUCCESS;\n\t}\n\t\n\tswitch(ret)\n\t{\n\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INVALID:\n\t\t\tbsd_setErrNo(BSD_ENOTSOCK);\n\t\t\tbreak;\n\t\tcase SOCK_ERR_INVALID_ADDRESS:\n\t\t\tbsd_setErrNo(BSD_EADDRINUSE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbsd_setErrNo(BSD_EIO);\n\t\t\tbreak;\n\t}\n\treturn BSD_ERROR;\n}", "CodeBleu_score": 52.55867909487743}, {"code": "int BSD_close(int socket){\n\tint ret;\n\tif(socket < 0 || socket >= MAX_SOCKET)\n\t{\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\treturn BSD_ERROR;\n\t}\n\tif(gastrSockets[socket].bIsUsed == 0)\n\t{\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\treturn BSD_ERROR;\n\t}\n\tret = close(socket);\n\tif(ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\tswitch(ret)\n\t\t{\n\t\t\tcase SOCK_ERR_INVALID_ARG:\n\t\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_INVALID:\n\t\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_NO_CONNECTION:\n\t\t\t\tbsd_setErrNo(BSD_ENOTCONN);\n\t\t\t\tbreak;\n\t\t\tcase SOCK_ERR_INVALID_ADDRESS:\n\t\t\t\tbsd_setErrNo(BSD_EADDRINUSE);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 47.84249311631763}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tint s8Ret = BSD_ERROR;\n\t\n\ts8Ret = listen(socket, backlog);\n\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\ts8Ret = BSD_ERROR;\n\t\tbsd_setErrNo(s8Ret);\n\t}\n\telse\n\t{\n\t\ts8Ret = BSD_SUCCESS;\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 33.62633089226854}, {"code": "int BSD_listen(int socket, int backlog){\n\tint s8Ret;\n\ts8Ret = listen(socket, backlog);\n\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\tBSD_SET_ERROR(s8Ret);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 26.952893045580566}, {"code": "int BSD_listen(int socket, int backlog){\n\tint s8Ret;\n\ts8Ret = listen(socket, backlog);\n\tif (s8Ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\tbsd_setErrNo(s8Ret);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 27.18663636062554}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tint\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(addr != NULL)\n\t\t{\n\t\t\tif(addrlen != NULL)\n\t\t\t{\n\t\t\t\tif(addr->sa_family == AF_INET)\n\t\t\t\t{\n\t\t\t\t\tif(*addrlen >= sizeof(struct sockaddr_in))\n\t\t\t\t\t{\n\t\t\t\t\t\ts8Ret = accept(socket, (struct sockaddr *)addr, (uint8 *)addrlen);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 26.08138663013344}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\tuint8\tu8AddrLen = 0;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(addr != NULL)\n\t\t{\n\t\t\tif(addrlen != NULL)\n\t\t\t{\n\t\t\t\tu8AddrLen = *addrlen;\n\t\t\t}\n\t\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 13.766536726394863}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tint\t\t\t\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\tuint8\t\t\t\t\t\tu8AddrLen = 0;\n\tstruct bsd_sockaddr_in\t\t*pstrAddr = NULL;\n\tstruct sockaddr_in\t\t\tstrAddr;\n\tSOCKET\t\t\t\t\t\tsAcceptSock = 0;\n\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(addr != NULL)\n\t\t{\n\t\t\tpstrAddr = (struct bsd_sockaddr_in *)addr;\n\t\t\tu8AddrLen = sizeof(struct bsd_sockaddr_in);\n\t\t}\n\t\tif(pstrAddr != NULL)\n\t\t{\n\t\t\tif(pstrAddr->sin_family == BSD_AF_INET)\n\t\t\t{\n\t\t\t\tstrAddr.sin_family = BSD_AF_INET;\n\t\t\t\tstrAddr.sin_port = pstrAddr->sin_port;\n\t\t\t\tstrAddr.sin_addr.s_addr = pstrAddr->sin_addr.s_addr;\n\t\t\t\tsAcceptSock = accept(socket, (struct sockaddr *)&strAddr, (uint8 *)&u8AddrLen);\n\t\t\t\tif(sAcceptSock < 0)\n\t\t\t\t{\n\t\t\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts8Ret = sAcceptSock;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 40.73543778362316}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\ttime_t now;\n   time(&now);\n   struct tm *timeinfo;\n   timeinfo = gmtime(&now);\n   if (timeinfo->tm_year < 100) {\n      debug_printError(\"Invalid time\");\n      return;\n   }\n\n   updateJWT(now);\n\n   // Connect to the MQTT broker\n   int rc = MQTTClient_connect(client, &conn_opts);\n   if (rc != MQTTCLIENT_SUCCESS) {\n      debug_printError(\"Failed to connect, return code %d\n\", rc);\n      return;\n   }\n   debug_printInfo(\"MQTT: Connected to %s\", conn_opts.host);\n\n   // Set flag to send MQTT SUBSCRIBE packet once the connection is established\n   subscribe = 1;\n}", "CodeBleu_score": 39.93198229016377}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n   uint8_t res = CRYPTO_CLIENT_getEpoch(&epoch);\n   if (res != 0) {\n      debug_printError(\"MQTT: Failed to get Epoch\");\n      return;\n   }\n\n   if (epoch < MIN_EPOCH) {\n      debug_printError(\"MQTT: Epoch is invalid\");\n      return;\n   }\n\n   updateJWT(epoch);\n   debug_printInfo(\"MQTT: Connecting to %s\", mqttBroker);\n   mqttClient.setServer(mqttBroker, 8883);\n   mqttClient.setCallback(mqttCallback);\n}", "CodeBleu_score": 41.73957487682898}, {"code": "static void connectMQTT(){\n\ttime_t t = 0;\n   uint8_t res = 0;\n   uint32_t epoch = 0;\n\n   res = CRYPTO_CLIENT_getEpoch(&epoch);\n   if (res != 0) {\n      debug_printError(\"MQTT: Failed to get current time\");\n      return;\n   }\n\n   t = epoch - UNIX_OFFSET;\n   if (t < 1000000000) {\n      debug_printError(\"MQTT: Invalid time\");\n      return;\n   }\n\n   updateJWT(epoch);\n\n   debug_printInfo(\"MQTT: Connecting to %s\", mqttServer);\n   res = MQTT_CLIENT_connect(&mqttClient, mqttServer, mqttPort, mqttClientId, mqttUsername, mqttPassword, mqttKeepAlive, mqttCleanSession, mqttWillFlag, mqttWillTopic, mqttWillMessage, mqttWillQos, mqttWillRetain);\n   if (res != 0) {\n      debug_printError(\"MQTT: Failed to connect\");\n      return;\n   }\n\n   debug_printInfo(\"MQTT: Connected to %s\", mqttServer);\n   mqttConnected = true;\n   mqttSubscribe = true;\n}", "CodeBleu_score": 42.41625547768203}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tif (mqttState == CONNECTED) {\n      MQTT_Disconnect(&mqttClientInfo);\n   }\n   mqttState = DISCONNECTED;\n   LOG_INFO((\"Disconnected from cloud\n\"));\n}", "CodeBleu_score": 45.03184387161787}, {"code": "void CLOUD_disconnect(void){\n\tMQTT_Disconnect(&mqttClient);\n}", "CodeBleu_score": 4.479249899893753}, {"code": "void CLOUD_disconnect(void){\n\tif (mqttState == CONNECTED) {\n      mqttContext* mqttCtx = mqtt_get_context();\n\n      MQTT_Disconnect(mqttCtx);\n   }\n\n   mqttState = DISCONNECTED;\n   debugp(\"MQTT disconnected.\n\");\n}", "CodeBleu_score": 53.14320691669533}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t// If we're passed new WiFi credentials, connect using them. Otherwise, use default credentials.\n\tif (passed_wifi_creds) {\n\t\t// Connect to the WiFi network using the provided credentials.\n\t\tm2m_wifi_connect((char *)wifi_ssid, strlen((char *)wifi_ssid), WIFI_SEC_WPA_PSK, (void *)wifi_pass, M2M_WIFI_CH_ALL);\n\t} else {\n\t\t// Connect to the WiFi network using default credentials.\n\t\tm2m_wifi_default_connect();\n\t}\n\n\t// Wait for the connection to complete.\n\twhile ((wifi_status != M2M_WIFI_CONNECTED) && (wifi_status != M2M_WIFI_DISCONNECTED)) {\n\t\tosDelay(100);\n\t}\n\n\t// If the connection failed, log an error message.\n\tif (wifi_status == M2M_WIFI_DISCONNECTED) {\n\t\t// Log an error message.\n\t\tprintf(\"Failed to connect to WiFi network.\n\");\n\n\t\t// Update the networking error status.\n\t\tnetworking_error_status = 1;\n\n\t\t// Return false.\n\t\treturn false;\n\t}\n\n\t// If the connection succeeded, return true.\n\treturn true;\n}", "CodeBleu_score": 51.14207216440951}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tsint8\t\t\t\tret = M2M_ERR_FAIL;\n\ttstrM2mWifiWep\t\twepParams;\n\ttstrNetworkId\t\tnetworkId;\n\ttstrAuthPsk\t\t\tpsk;\n\ttstrM2mWifiWep\t\t*pWepParams;\n\ttstrAuthPsk\t\t\t*pPsk;\n\ttstrM2mWifiWep\t\t*pDefaultWepParams;\n\ttstrAuthPsk\t\t\t*pDefaultPsk;\n\tuint8_t\t\t\t\t*pu8ConnectIndex;\n\tuint8_t\t\t\t\tu8ConnectIndex;\n\tuint8_t\t\t\t\tu8SsidLen;\n\tuint8_t\t\t\t\tu8DefaultConnectIndex;\n\tuint8_t\t\t\t\tu8DefaultSsidLen;\n\tuint8_t\t\t\t\tu8SecType;\n\tuint8_t\t\t\t\t*pu8Ssid;\n\tuint8_t\t\t\t\t*pu8DefaultSsid;\n\tuint8_t\t\t\t\tu8Ch;\n\tuint8_t\t\t\t\t*pu8Ch;\n\tuint8_t\t\t\t\t*pu8DefaultCh;\n\tuint8_t\t\t\t\tu8DefaultCh;\n\tuint8_t\t\t\t\t*pu8Psk;\n\tuint8_t\t\t\t\t*pu8DefaultPsk;\n\tuint8_t\t\t\t\tu8DefaultPskLen;\n\tuint8_t\t\t\t\tu8PskLen;\n\tuint8_t\t\t\t\t*pu8AuthInfo;\n\tuint8_t\t\t\t\t*pu8DefaultAuthInfo;\n\tuint8_t\t\t\t\tu8DefaultAuthInfoLen;\n\tuint8_t\t\t\t\tu8AuthInfoLen;\n\n\tif (passed_wifi_creds) {\n\t\tpu8ConnectIndex = &u8ConnectIndex;\n\t\tpu8Ssid = &wifi_creds.ssid[0];\n\t\tpu8SecType =", "CodeBleu_score": 13.851080206548716}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tsint8 ret;\n\tif (passed_wifi_creds) {\n\t\tret = m2m_wifi_connect(\n\t\t\t\t(char *) WIFI_SSID,\n\t\t\t\tstrlen(WIFI_SSID),\n\t\t\t\tWIFI_SEC_TYPE,\n\t\t\t\t(void *) WIFI_PSK,\n\t\t\t\tWIFI_CHANNEL);\n\t} else {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret == M2M_ERR_NONE) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 48.86247318980245}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t// Create a client to send the GraphQL query with.\n  const client = new AWSAppSync.AWSAppSyncClient({\n    url: awsconfig.aws_appsync_graphqlEndpoint,\n    region: awsconfig.aws_appsync_region,\n    auth: {\n      type: awsconfig.aws_appsync_authenticationType,\n      apiKey: awsconfig.aws_appsync_apiKey,\n    },\n    disableOffline: true,\n  });\n\n  // Create a GraphQL query to fetch sensor data.\n  const query = gql`\n    query GetSensors {\n      listSensors {\n        items {\n          sensorId\n          sensorType\n          sensorLat\n          sensorLon\n        }\n      }\n    }\n  `;\n\n  // Send the GraphQL query with the client and log the response.\n  const response = await client.query({\n    query: query,\n  });\n\n  // If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker.\n  if (response.data.listSensors.items) {\n    console.log('Retrieved sensors: ', response.data.listSensors.items);\n    response.data.listSensors.items.forEach(sensor => {\n      // Create a marker for each sensor.\n      const marker = new google.maps.Marker({\n        position: {lat: sensor.sensorLat, lng: sensor.sensorLon},\n        map: map,\n        title: sensor.sensorId,\n      });\n      // Create an info window for each marker.\n      const infoWindow = new google.maps.InfoWindow({\n        content: `<p>Sensor ID: ${sensor.sensorId}</p>\n                   <p>Sensor Type: ${sensor.sensorType}</p>`,\n      });\n      // Open the info window when the marker is clicked.\n      marker.addListener('click', () => {\n        infoWindow.open(map, marker);\n      });\n    });\n  }\n}", "CodeBleu_score": 37.06071818024833}, {"code": "async function DisplaySensors(map){\n\t// Create a new client with the API key.\n  const client = new APIClient(API_KEY);\n\n  // Create a GraphQL query to fetch sensor data.\n  const query = `\n    query GetSensors {\n      sensors {\n        id\n        name\n        lat\n        lon\n        status\n        sensorType {\n          name\n        }\n      }\n    }\n  `;\n\n  // Send the GraphQL query to the API and await the response.\n  const response = await client.query(query);\n\n  // Log the response.\n  console.log(response);\n\n  // If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker.\n  if (response.data.sensors) {\n    console.log('Sensors retrieved');\n    response.data.sensors.forEach(sensor => {\n      // Create a marker for each sensor.\n      const marker = L.marker([sensor.lat, sensor.lon]);\n\n      // Add a popup to each marker.\n      marker.bindPopup(`${sensor.name} (${sensor.sensorType.name})`);\n\n      // Add the marker to the map.\n      marker.addTo(map);\n    });\n  }\n}", "CodeBleu_score": 45.22374607637164}, {"code": "async function DisplaySensors(map){\n\t// Create a client to send the GraphQL request\n    const client = new AWSAppSyncClient({\n        url: AppSync.graphqlEndpoint,\n        region: AppSync.region,\n        auth: {\n            type: AppSync.authenticationType,\n            apiKey: AppSync.apiKey,\n        },\n        disableOffline: true,\n    });\n\n    // Create a GraphQL query to retrieve sensor data\n    const query = gql(`\n        query GetSensors {\n            listSensors {\n                items {\n                    sensorId\n                    sensorType\n                    sensorLat\n                    sensorLong\n                }\n            }\n        }\n    `);\n\n    // Send the GraphQL query to AppSync\n    const { data } = await client.query({ query: query });\n\n    // If the response contains data, log the retrieval of sensors and iterate through each sensor to create a marker\n    if (data.listSensors.items) {\n        console.log(\"Retrieved sensors: \", data.listSensors.items);\n        data.listSensors.items.forEach(function (sensor) {\n            // Create a marker for each sensor\n            var marker = new google.maps.Marker({\n                position: { lat: sensor.sensorLat, lng: sensor.sensorLong },\n                map: map,\n                title: sensor.sensorId,\n            });\n        });\n    }\n}", "CodeBleu_score": 38.37897164709465}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\tlet sensorMarker = document.createElement(\"div\");\n  sensorMarker.id = sensor.id;\n  sensorMarker.classList.add(\"sensorMarker\");\n  sensorMarker.style.backgroundColor = sensor.color;\n  sensorMarker.style.border = \"1px solid black\";\n  return sensorMarker;\n}", "CodeBleu_score": 44.79415084899252}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t// Create a new div element\n  let sensorMarker = document.createElement(\"div\");\n  // Set the marker's id to the sensor's unique ID\n  sensorMarker.id = sensor.id;\n  // Assign the marker a class name\n  sensorMarker.className = \"sensor-marker\";\n  // Style the marker with a default color and border\n  sensorMarker.style.backgroundColor = \"red\";\n  sensorMarker.style.border = \"1px solid black\";\n  // Return the created marker element\n  return sensorMarker;\n}", "CodeBleu_score": 43.787034122483796}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'marker';\n  marker.style.backgroundColor = sensor.color;\n  marker.style.border = '2px solid black';\n  return marker;\n}", "CodeBleu_score": 46.3189953447687}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t# Construct the module path\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    # Attempt to import the module\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"The MFA module '%s' is not installed. Please install it with 'pip3 install %s'.\",\n            module_name,\n            module_name,\n        )\n        raise err\n    # Process the module's requirements if they haven't been processed\n    if not hass.data.get(DATA_MFA_MODULES, {}).get(module_name):\n        # Get the requirements\n        requirements = getattr(module, \"REQUIREMENTS\", None)\n        # Check if requirements exist\n        if requirements:\n            # Check if pip installation is skipped\n            if not hass.config.skip_pip:\n                # Process the requirements\n                await hass.async_add_executor_job(\n                    process_requirements, module_name, requirements\n                )\n            else:\n                _LOGGER.warning(\n                    \"The MFA module '%s' requires installation of the following packages: %s. \"\n                    \"Please install them manually with 'pip3 install %s'.\",\n                    module_name,\n                    requirements,\n                    requirements,\n                )\n        # Add the module to the cache\n        hass.data[DATA_MFA_MODULES][module_name] = module\n    # Return the module\n    return module\n\n", "CodeBleu_score": 44.26473517078884}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\timport importlib\n\n    if module_name in MFA_MODULES:\n        return MFA_MODULES[module_name]\n\n    module = importlib.import_module(f\"homeassistant.auth.mfa_modules.{module_name}\")\n\n    if module.REQUIREMENTS:\n        if not hass.config.skip_pip:\n            await async_process_requirements(\n                hass, \"mfa_modules\", module_name, module.REQUIREMENTS\n            )\n        else:\n            _LOGGER.warning(\n                \"Skipping pip installation of %s. You may have missing dependencies.\",\n                module_name,\n            )\n\n    MFA_MODULES[module_name] = module\n    return module\n\n", "CodeBleu_score": 31.62524900646026}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import module '%s' for MFA: %s\",\n            module_path,\n            err,\n        )\n        raise\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not module.REQUIREMENTS:\n        return module\n    if not hass.config.skip_pip:\n        await async_process_requirements(\n            hass,\n            module_path,\n            module.REQUIREMENTS,\n        )\n    return module\n\n", "CodeBleu_score": 46.70050167816046}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tif user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n", "CodeBleu_score": 33.82239040504908}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tif user_id in self.data:\n        self.data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self.data[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n    return True\n\n", "CodeBleu_score": 35.39893819066292}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tself.users[user_id] = setup_data[\"pin\"]\n\n", "CodeBleu_score": 16.117209519818807}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\tif not self._user_settings:\n        if not (data := await self._store.async_load()):\n            self._user_settings = {}\n            return\n\n        self._user_settings = {}\n\n        for user_id, user_data in data.items():\n            notify_settings = []\n            for platform_name, platform_data in user_data.items():\n                notify_settings.append(\n                    NotifySetting(\n                        platform_name=platform_name,\n                        enabled=platform_data[\"enabled\"],\n                        settings=platform_data[\"settings\"],\n                    )\n                )\n\n            self._user_settings[user_id] = notify_settings\n\n", "CodeBleu_score": 24.63688533296815}, {"code": "async def _async_load(self) -> None\n\tif self._data is not None:\n        return\n\n    async with self._lock:\n        if self._data is not None:\n            return\n\n        if (data := await self._store.async_load()) is None:\n            data = {}\n\n        self._data = {}\n\n        for user_id, user_data in data.items():\n            self._data[user_id] = NotifySetting(\n                user_id,\n                user_data.get(\"notify_mode\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v2\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v3\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v4\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v5\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v6\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v7\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v8\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v9\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v10\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v11\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v12\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v13\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v14\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v15\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v16\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_v17\", DEFAULT_NOTIFY_MODE),\n                user_data.get(\"notify_mode_", "CodeBleu_score": 28.884342191027745}, {"code": "async def _async_load(self) -> None\n\tif self._data is not None:\n        return\n\n    async with self._lock:\n        if self._data is not None:\n            return\n\n        if not (data := await self._store.async_load()):\n            data = {}\n\n        self._data = {\n            user_id: NotifySetting(\n                user_id,\n                data.get(user_id, {}).get(\"notify\"),\n                data.get(user_id, {}).get(\"message\"),\n            )\n            for user_id in data\n        }\n\n", "CodeBleu_score": 43.49989118536291}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tif user_input is None:\n        return False\n\n    # Load user settings\n    await self.async_load_user_settings(user_id)\n\n    # Retrieve the user's notification settings\n    notification_settings = self._user_settings.get(user_id)\n    if notification_settings is None:\n        return False\n\n    # Validate the user input\n    return await self.hass.async_add_executor_job(\n        self._validate_user_input, notification_settings, user_input\n    )\n\n", "CodeBleu_score": 56.01881855139552}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t# Ensure user settings are loaded\n    await self.async_load_user_settings(user_id)\n\n    # Retrieve the notification settings for the specified user\n    user_settings = self._user_settings.get(user_id)\n    if not user_settings:\n        return False\n\n    # Validate the user input by verifying the OTP using an executor job\n    return await self._executor.async_execute(\n        self._validate_user_input,\n        user_id,\n        user_input,\n        user_settings,\n    )\n\n", "CodeBleu_score": 50.72143620046471}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tawait self._async_load_user_settings(user_id)\n    user_settings = self._users_settings[user_id]\n    if user_settings is None:\n        return False\n    if not user_settings.enabled:\n        return False\n    if user_settings.method == METHOD_TOTP:\n        return await self._async_validate_totp(user_settings, user_input)\n    if user_settings.method == METHOD_DEVICE:\n        return await self._async_validate_device(user_settings, user_input)\n    return False\n\n", "CodeBleu_score": 49.454760571918364}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 64.3044905491215}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t# Fetch the entity entry\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n\n    # Fetch the device entry\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n\n    # Fetch the area ID\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    # Return the permissions for the area\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 64.42890356638978}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity = perm_lookup.entities.get(entity_id)\n    if entity is None:\n        return None\n    device_id = entity.device_id\n    if device_id is None:\n        return None\n    device = perm_lookup.devices.get(device_id)\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 59.69036703151852}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\treturn _merge_policies(policies)\n\n", "CodeBleu_score": 7.36791490198009}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t# We need to merge policies.\n    # This means we need to merge each policy's categories.\n    # We also need to merge each category's permissions.\n    #\n    # For example, if we have:\n    #\n    # {\n    #   \"categories\": {\n    #     \"a\": True,\n    #     \"b\": True\n    #   }\n    # }\n    #\n    # {\n    #   \"categories\": {\n    #     \"a\": {\n    #       \"permissions\": {\n    #         \"read\": True\n    #       }\n    #     }\n    #   }\n    # }\n    #\n    # We need to merge the permissions.\n    #\n    # The result should be:\n    #\n    # {\n    #   \"categories\": {\n    #     \"a\": {\n    #       \"permissions\": {\n    #         \"read\": True\n    #       }\n    #     },\n    #     \"b\": True\n    #   }\n    # }\n    #\n    # If we have:\n    #\n    # {\n    #   \"categories\": {\n    #     \"a\": True,\n    #     \"b\": True\n    #   }\n    # }\n    #\n    # {\n    #   \"categories\": {\n    #     \"a\": False\n    #   }\n    # }\n    #\n    # We need to merge the permissions.\n    #\n    # The result should be:\n    #\n    # {\n    #   \"categories\": {\n    #     \"a\": False,\n    #     \"b\": True\n    #   }\n    # }\n    #\n    # If we have:\n    #\n    # {\n    #   \"categories\": {\n    #     \"a\": True,\n    #     \"b\": True\n    #   }\n    # }\n    #\n    # {\n    #   \"categories\": {\n    #     \"a\": True\n    #   }\n    # }\n    #\n    # We need to merge the permissions.\n    #\n    # The result should be:\n    #\n    # {\n    #   \"categories\": {", "CodeBleu_score": 6.25}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\treturn _merge_policies(policies)\n\n", "CodeBleu_score": 7.36791490198009}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\tmodule = await async_import_module(hass, \"homeassistant.auth.providers.\" + provider)\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not isinstance(module.REQUIREMENTS, list):\n        _LOGGER.error(\n            \"Invalid REQUIREMENTS in auth provider %s: %s\",\n            provider,\n            module.REQUIREMENTS,\n        )\n        return module\n    if not hass.config.skip_pip:\n        await requirements.async_process_requirements(\n            hass, module.REQUIREMENTS, \"auth provider \" + provider\n        )\n    return module\n\n", "CodeBleu_score": 34.13649902494239}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\tmodule = await async_import_module(hass, provider)\n    if not hasattr(module, \"async_get_auth_provider\"):\n        raise HomeAssistantError(\n            f\"Auth provider {provider} does not contain an async_get_auth_provider function\"\n        )\n    return module\n\n", "CodeBleu_score": 17.865512121007864}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\tif not (module := await async_import_module(hass, provider)):\n        raise HomeAssistantError(f\"Unable to import provider {provider}\")\n\n    if not hasattr(module, \"CONFIG_SCHEMA\"):\n        _LOGGER.error(\"Provider %s has no CONFIG_SCHEMA\", provider)\n        return module\n\n    if not hasattr(module, \"async_get_auth\"):\n        _LOGGER.error(\"Provider %s has no async_get_auth\", provider)\n        return module\n\n    if not hasattr(module, \"async_create_auth\"):\n        _LOGGER.error(\"Provider %s has no async_create_auth\", provider)\n        return module\n\n    if not hasattr(module, \"async_login_flow\"):\n        _LOGGER.error(\"Provider %s has no async_login_flow\", provider)\n        return module\n\n    if not hasattr(module, \"async_validate_login\"):\n        _LOGGER.error(\"Provider %s has no async_validate_login\", provider)\n        return module\n\n    if not hasattr(module, \"async_get_or_create_credentials\"):\n        _LOGGER.error(\n            \"Provider %s has no async_get_or_create_credentials\", provider\n        )\n        return module\n\n    if not hasattr(module, \"async_user_meta_for_credentials\"):\n        _LOGGER.error(\n            \"Provider %s has no async_user_meta_for_credentials\", provider\n        )\n        return module\n\n    if not hasattr(module, \"async_will_remove_credentials\"):\n        _LOGGER.error(\n            \"Provider %s has no async_will_remove_credentials\", provider\n        )\n        return module\n\n    if not hasattr(module, \"async_credentials\"):\n        _LOGGER.error(\"Provider %s has no async_credentials\", provider)\n        return module\n\n    if not hasattr(module, \"async_delete_credentials\"):\n        _LOGGER.error(\n            \"Provider %s has no async_delete_credentials\", provider\n        )", "CodeBleu_score": 27.802165381622096}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t# Normalize the username\n    username = username.lower().strip()\n\n    # Initialize a dummy hash to prevent timing attacks\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n\n    # Iterate through all users to find a matching username\n    for user in self.users:\n        if user.username == username:\n            # Decode the stored password hash\n            stored_hash = base64.b64decode(user.password)\n\n            # Use bcrypt's timing-safe check to compare the provided password with the stored hash\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n\n            # Raise an \"InvalidAuth\" exception if the passwords do not match\n            raise InvalidAuth\n\n    # Raise an \"InvalidAuth\" exception if no matching user is found\n    raise InvalidAuth\n\n", "CodeBleu_score": 35.49549516574601}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = username.lower().strip()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            password_hash = base64.b64decode(user[\"password\"])\n            if bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                return\n            else:\n                bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n                raise InvalidAuth(\"Invalid username or password\")\n    bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n    raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 41.95918221515231}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t# Normalize the username\n    username = username.lower().strip()\n\n    # Initialize dummy hash to prevent timing attacks\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt(12))\n\n    # Iterate through all users to find a matching username\n    for user in self.users:\n        if user.username == username:\n            # Decode the stored password hash\n            stored_hash = base64.b64decode(user.password)\n\n            # Use bcrypt's timing-safe check to compare the provided password with the stored hash\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                # If the passwords match, return the user\n                return user\n\n    # If no matching user is found, perform a dummy hash check\n    if not bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        raise InvalidAuth\n\n\n", "CodeBleu_score": 39.260382533007}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\tusername = username.lower()\n    for i in range(len(self.users)):\n        if self.users[i].username == username:\n            self.users.pop(i)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n\n\n\n\n", "CodeBleu_score": 27.56738159599254}, {"code": "def async_remove_auth(self, username: str) -> None\n\tusername = self.normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 29.51776948228107}, {"code": "def async_remove_auth(self, username: str) -> None\n\t# normalize the username\n    username = username.lower()\n    # search for the user in the users list\n    for user in self.users:\n        # if the user is found\n        if user.username == username:\n            # remove the user from the list\n            self.users.remove(user)\n            # return\n            return\n    # if the user is not found\n    # raise an exception\n    raise InvalidUser(\"user_not_found\")\n\n\n", "CodeBleu_score": 26.007322982359536}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        await self.async_load()\n    if self._data is None:\n        self._data = {}\n    try:\n        del self._data[credentials.data[\"username\"]]\n    except KeyError:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 55.9433419970542}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        await self.async_initialize()\n    try:\n        self._data.pop(credentials.data[CONF_USERNAME])\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 50.51574975113836}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        await self._async_load()\n\n    if self._data is not None:\n        try:\n            self._data.pop(credentials.id)\n            await self.async_save()\n        except KeyError:\n            pass\n\n", "CodeBleu_score": 55.34873924741842}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident is None:\n                joined.add(thread)\n            else:\n                if log:\n                    _log_thread_running_at_shutdown(thread.name, thread.ident)\n                thread.join(timeout)\n                if thread.is_alive():\n                    thread.join()\n                    if thread.is_alive():\n                        try:\n                            thread.raise_exception(SystemExit)\n                        except Exception:\n                            pass\n                        joined.add(thread)\n                else:\n                    joined.add(thread)\n        else:\n            joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 43.07006065001239}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined_threads: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            if thread.ident:\n                try:\n                    thread.join(timeout)\n                except RuntimeError:\n                    pass\n                if thread.is_alive():\n                    if log:\n                        _log_thread_running_at_shutdown(thread.name, thread.ident)\n                    try:\n                        thread.raise_exc(SystemExit)\n                    except RuntimeError:\n                        pass\n                else:\n                    joined_threads.add(thread)\n            else:\n                joined_threads.add(thread)\n    return joined_threads\n\n", "CodeBleu_score": 41.330513730666574}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined_threads = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined_threads.add(thread)\n            continue\n        if thread.ident is None:\n            joined_threads.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            pass\n        if not thread.is_alive():\n            joined_threads.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        try:\n            thread.raise_exc(SystemExit)\n        except RuntimeError:\n            pass\n        if not thread.is_alive():\n            joined_threads.add(thread)\n    return joined_threads\n\n", "CodeBleu_score": 46.834882857198224}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\timport threading\n    import logging\n    import time\n    import sys\n    import os\n\n    # Calculate the total shutdown timeout\n    total_shutdown_timeout = 10\n\n    # Identify all non-main, non-daemon, alive threads\n    non_main_non_daemon_alive_threads = [\n        thread for thread in threading.enumerate()\n        if thread is not threading.main_thread\n        and not thread.daemon\n        and thread.is_alive()\n    ]\n\n    # Calculate the timeout for each thread\n    timeout_per_thread = total_shutdown_timeout / len(non_main_non_daemon_alive_threads)\n\n    # Join each thread\n    for thread in non_main_non_daemon_alive_threads:\n        # Calculate the timeout for this thread\n        timeout = timeout_per_thread + 1\n\n        # Join the thread\n        try:\n            thread.join(timeout=timeout)\n        except Exception as e:\n            # Log a warning\n            logging.warning(f\"Failed to join thread \\\"{thread.name}\\\" in {timeout} seconds. Exception: {e}\")\n\n        # If the thread is still alive, log a warning\n        if thread.is_alive():\n            logging.warning(f\"Thread \\\"{thread.name}\\\" is still alive after {timeout} seconds.\")\n\n    # Shutdown the process\n    sys.exit(os.EX_OK)\n\n\n", "CodeBleu_score": 46.609493646184085}, {"code": "def deadlock_safe_shutdown() -> None\n\timport threading\n    import logging\n    import time\n    import os\n    import sys\n\n    logger = logging.getLogger(\"deadlock_safe_shutdown\")\n\n    # calculate the total timeout for the shutdown\n    total_timeout = 10\n    # calculate the timeout for each thread\n    timeout = total_timeout / (threading.active_count() - 1)\n    # create a list of all non-main, non-daemon, alive threads\n    threads = [thread for thread in threading.enumerate() if not thread.is_alive()]\n    # join each thread within the timeout\n    for thread in threads:\n        try:\n            thread.join(timeout=timeout)\n        except RuntimeError:\n            logger.warning(f\"Failed to join thread {thread}\")\n    # if the main thread is still alive, exit the process\n    if threading.main_thread().is_alive():\n        logger.warning(\"Failed to join main thread, exiting process\")\n        os.kill(os.getpid(), 9)\n\n", "CodeBleu_score": 34.61761274715799}, {"code": "def deadlock_safe_shutdown() -> None\n\timport threading\n    import time\n    import logging\n    import sys\n\n    # Get the timeout for the shutdown\n    shutdown_timeout = sys.modules[\"__main__\"].shutdown_timeout\n\n    # Get all non-main, non-daemon, alive threads\n    all_threads = [thread for thread in threading.enumerate() if not thread.is_alive() or thread.daemon or thread is threading.current_thread()]\n\n    # If there are no remaining threads, return\n    if len(all_threads) == 0:\n        return\n\n    # Calculate the timeout for each thread\n    timeout = shutdown_timeout / len(all_threads)\n\n    # Join all threads\n    for thread in all_threads:\n        try:\n            thread.join(timeout)\n        except Exception as e:\n            logging.warning(f\"Failed to join thread {thread.name} ({thread.ident}) with exception {e}\")\n\n    # Log a warning if any threads are still alive\n    if any(thread.is_alive() for thread in all_threads):\n        logging.warning(f\"Failed to join all threads in time. The following threads are still alive: {', '.join([thread.name for thread in all_threads])}\")\n\n    # If the timeout is not zero, sleep for the remaining time\n    if shutdown_timeout > 0:\n        time.sleep(shutdown_timeout)\n\n", "CodeBleu_score": 39.36574116993686}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tremaining = self.remaining_setups\n    if remaining or self.previous_remaining:\n        self._dispatcher_signal.emit(remaining)\n        self.previous_remaining = remaining\n    else:\n        self.previous_remaining = remaining\n\n", "CodeBleu_score": 38.51045701845809}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif remaining_with_setup_started:\n        self._remaining_with_setup_started = remaining_with_setup_started\n        self.dispatcher_signal.emit(remaining_with_setup_started)\n    else:\n        self._remaining_with_setup_started = {}\n        self.dispatcher_signal.emit({})", "CodeBleu_score": 35.94846142445092}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif self._remaining_setups:\n        self._remaining_setups = remaining_with_setup_started\n        self._dispatcher.dispatch(self._remaining_setups)\n    elif self._remaining_setups != {}:\n        self._remaining_setups = {}\n        self._dispatcher.dispatch(self._remaining_setups)", "CodeBleu_score": 39.12780874431072}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t# Generate and validate bluetooth data\n    generated_bluetooth = generate_and_validate(integrations)\n\n    # Check if the current bluetooth.py file is valid\n    bluetooth_path = config.path(\"homeassistant/components/bluetooth.py\")\n    if not bluetooth_path.is_file():\n        config.cache.set(\"bluetooth\", generated_bluetooth)\n        return\n\n    with bluetooth_path.open(\"r\") as bluetooth_file:\n        bluetooth_content = bluetooth_file.read()\n\n    if bluetooth_content == generated_bluetooth:\n        return\n\n    config.add_error(\n        \"bluetooth.py\",\n        \"The bluetooth.py file is not up to date. Run `hass-code-gen bluetooth` to fix this.\",\n        fixable=True,\n        fixer=\"hass-code-gen bluetooth\",\n    )\n\n    config.cache.set(\"bluetooth\", generated_bluetooth)\n\n", "CodeBleu_score": 46.48214482943842}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tbluetooth_file = config.path / \"bluetooth.py\"\n    bluetooth_content = bluetooth_file.read_text()\n\n    if not bluetooth_content:\n        raise RuntimeError(\n            f\"{bluetooth_file} is empty. Please run `hass-code-gen bluetooth` to generate the file.\"\n        )\n\n    generated_content = generate_and_validate(integrations)\n\n    if generated_content == bluetooth_content:\n        return\n\n    diff = difflib.unified_diff(\n        bluetooth_content.splitlines(keepends=True),\n        generated_content.splitlines(keepends=True),\n        fromfile=bluetooth_file.name,\n        tofile=\"<generated>\",\n    )\n\n    raise RuntimeError(\n        f\"{bluetooth_file} is not up to date. Please run `hass-code-gen bluetooth` to regenerate the file.", "CodeBleu_score": 44.99249870146931}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tbluetooth_path = config.path / \"bluetooth.py\"\n\n    if not bluetooth_path.is_file():\n        return\n\n    bluetooth_content = bluetooth_path.read_text()\n\n    if not bluetooth_content.strip():\n        return\n\n    generated_content = generate_and_validate(integrations)\n\n    if generated_content == bluetooth_content:\n        return\n\n    config.add_error(\n        \"bluetooth.py\",\n        \"The bluetooth.py file is not up to date. Please run `ha bluetooth generate` to regenerate it.\",\n        fixable=True,\n        fixer=lambda: bluetooth_path.write_text(generated_content),\n    )\n\n", "CodeBleu_score": 46.631971292260346}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\tparams := url.Values{}\n\tparams.Add(\"refresh_token\", d.RefreshToken)\n\tparams.Add(\"client_id\", d.AppKey)\n\tparams.Add(\"client_secret\", d.AppSecret)\n\tparams.Add(\"grant_type\", \"refresh_token\")\n\n\tresp, err := http.PostForm(tokenEndpoint, params)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\treturn fmt.Errorf(\"status code: %d, response: %s\", resp.StatusCode, string(body))\n\t}\n\n\tvar tokenResponse struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int64  `json:\"expires_in\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t}\n\n\tif err := json.Unmarshal(body, &tokenResponse); err != nil {\n\t\treturn err\n\t}\n\n\td.AccessToken = tokenResponse.AccessToken\n\td.ExpiresAt = time.Now().Add(time.Duration(tokenResponse.ExpiresIn) * time.Second)\n\n\treturn nil\n}", "CodeBleu_score": 48.3545087363739}, {"code": "func (d *Dropbox) refreshToken() error{\n\t// Create the request body.\n\tbody := map[string]string{\n\t\t\"grant_type\":    \"refresh_token\",\n\t\t\"refresh_token\": d.RefreshToken,\n\t}\n\t// Marshal the request body.\n\tb, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Create the request.\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", bytes.NewBuffer(b))\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Set the headers.\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Basic \"+d.auth)\n\t// Send the request.\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Read the response.\n\tdefer resp.Body.Close()\n\tb, err = ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Unmarshal the response.\n\tvar r map[string]string\n\terr = json.Unmarshal(b, &r)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Check if the response is an error.\n\tif r[\"error\"] != \"\" {\n\t\treturn errors.New(r[\"error\"] + \": \" + r[\"error_description\"])\n\t}\n\t// Set the access token.\n\td.AccessToken = r[\"access_token\"]\n\t// Return nil.\n\treturn nil\n}", "CodeBleu_score": 52.07518005261923}, {"code": "func (d *Dropbox) refreshToken() error{\n\t// Create a new request to the Dropbox OAuth2 token endpoint.\n\turl := \"https://api.dropboxapi.com/oauth2/token\"\n\treq, err := http.NewRequest(\"POST\", url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers.\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Create a new URL encoded form.\n\tv := url.Values{}\n\tv.Add(\"refresh_token\", d.RefreshToken)\n\tv.Add(\"client_id\", d.AppKey)\n\tv.Add(\"client_secret\", d.AppSecret)\n\tv.Add(\"grant_type\", \"refresh_token\")\n\n\t// Set the request body to the URL encoded form.\n\treq.Body = ioutil.NopCloser(strings.NewReader(v.Encode()))\n\n\t// Send the request.\n\tres, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check the response status code.\n\tif res.StatusCode != 200 {\n\t\t// Read the response body.\n\t\tbody, err := ioutil.ReadAll(res.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Log the response body.\n\t\tlog.Println(string(body))\n\n\t\t// Return an error.\n\t\treturn errors.New(\"unable to refresh access token\")\n\t}\n\n\t// Decode the response body.\n\tvar r struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\tif err := json.NewDecoder(res.Body).Decode(&r); err != nil {\n\t\treturn err\n\t}\n\n\t// Set the access token.\n\td.AccessToken = r.AccessToken\n\n\t// Return nil.\n\treturn nil\n}", "CodeBleu_score": 51.35016443538871}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tvar (\n\t\tbody []byte\n\t\terr  error\n\t)\n\n\tif d.accessToken == \"\" {\n\t\tif err = d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tfor i := 0; i < 2; i++ {\n\t\tif body, err = d.client.Request(url, method, callback, resp); err == nil {\n\t\t\treturn body, nil\n\t\t}\n\t\tif err != nil && err.Error() != \"401 Unauthorized\" {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err = d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn nil, err\n}", "CodeBleu_score": 41.73094085912935}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tvar (\n\t\terr  error\n\t\tbody []byte\n\t)\n\tfor i := 0; i < 2; i++ {\n\t\tif body, err = d.client.request(url, method, callback, resp); err == nil {\n\t\t\treturn body, nil\n\t\t}\n\t\tif err != nil && err.Error() != \"401 Unauthorized\" {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err = d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn nil, err\n}", "CodeBleu_score": 35.11259183766753}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tif resp != nil {\n\t\treq.Header.Set(\"Accept\", \"application/json\")\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\tif d.driveId != \"\" {\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", d.driveId)\n\t}\n\tif d.teamDriveId != \"\" {\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", d.teamDriveId)\n\t}\n\tif d.supportsAllDrives {\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", \"root\")\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", \"root\")\n\t}\n\tif d.supportsTeamDrives {\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", \"root\")\n\t}\n\tif d.supportsAllDrives {\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", \"root\")\n\t}\n\tif d.includeItemsFromAllDrives {\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", \"root\")\n\t}\n\tif d.includeTeamDriveItems {\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", \"root\")\n\t}\n\tif d.corpora != \"\" {\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", \"root\")\n\t}\n\tif d.corpora != \"\" {\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", \"root\")\n\t}\n\tif d.corpora != \"\" {\n\t\treq.Header.Set(\"X-Goog-Drive-Resource-Id\", \"root\")", "CodeBleu_score": 39.79442130700966}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t// Calculate the chunk size.\n\tchunkSize := d.getChunkSize(stream)\n\n\t// Create a buffer to store each chunk.\n\tbuffer := make([]byte, chunkSize)\n\n\t// Read the file in chunks.\n\tfor {\n\t\t// Check for context cancellation.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Read a chunk.\n\t\tn, err := stream.Read(buffer)\n\n\t\t// Check if the chunk is the last chunk.\n\t\tif n == 0 {\n\t\t\t// If so, send the last chunk.\n\t\t\tif err := d.sendChunk(ctx, url, buffer[:n], true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Break the loop.\n\t\t\tbreak\n\t\t}\n\n\t\t// If the chunk is not the last chunk, send it.\n\t\tif err := d.sendChunk(ctx, url, buffer[:n], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 26.39668499847038}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t// Get the file size and chunk size.\n\tsize, chunkSize := stream.Size(), d.chunkSize\n\n\t// Calculate the number of chunks.\n\tchunks := int(math.Ceil(float64(size) / float64(chunkSize)))\n\n\t// Create a buffer for the chunk data.\n\tbuf := make([]byte, chunkSize)\n\n\t// Create a buffer for the request body.\n\tbody := bytes.NewBuffer(nil)\n\n\t// Create a new HTTP request.\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers.\n\treq.Header.Set(\"Content-Type\", \"application/offset+octet-stream\")\n\treq.Header.Set(\"Content-Range\", \"bytes 0-\"+strconv.Itoa(chunkSize-1)+\"/\"+strconv.Itoa(size))\n\n\t// Upload the file in chunks.\n\tfor i := 0; i < chunks; i++ {\n\t\t// Check for context cancellation.\n\t\tif err := ctx.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Read the next chunk of data.\n\t\tn, err := stream.Read(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Write the chunk to the request body.\n\t\t_, err = body.Write(buf[:n])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Reset the request body.\n\t\tbody.Reset()\n\n\t\t// Set the request headers.\n\t\treq.Header.Set(\"Content-Range\", \"bytes \"+strconv.Itoa(i*chunkSize)+\"-\"+strconv.Itoa((i+1)*chunkSize-1)+\"/\"+strconv.Itoa(size))\n\n\t\t// Send the request.\n\t\tresp, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}", "CodeBleu_score": 43.289030157524465}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tchunkSize := int64(d.chunkSize)\n\tchunkCount := int64(math.Ceil(float64(stream.Size()) / float64(chunkSize)))\n\n\t// The \"uploadType\" is set to \"resumable\" for the first chunk to initiate the upload.\n\tif chunkCount > 1 {\n\t\turl = fmt.Sprintf(\"%s&uploadType=resumable\", url)\n\t}\n\n\tfor i := int64(0); i < chunkCount; i++ {\n\t\tchunkStart := i * chunkSize\n\t\tchunkEnd := (i + 1) * chunkSize\n\n\t\tif chunkEnd > stream.Size() {\n\t\t\tchunkEnd = stream.Size()\n\t\t}\n\n\t\tchunkSize = chunkEnd - chunkStart\n\n\t\t// The \"uploadType\" is set to \"resumable\" for the first chunk to initiate the upload.\n\t\tif i == 0 {\n\t\t\turl = fmt.Sprintf(\"%s&uploadType=resumable\", url)\n\t\t}\n\n\t\t// The \"uploadType\" is set to \"resumable\" for the first chunk to initiate the upload.\n\t\tif i == 0 {\n\t\t\turl = fmt.Sprintf(\"%s&uploadType=resumable\", url)\n\t\t}\n\n\t\t// The \"uploadType\" is set to \"resumable\" for the first chunk to initiate the upload.\n\t\tif i == 0 {\n\t\t\turl = fmt.Sprintf(\"%s&uploadType=resumable\", url)\n\t\t}\n\n\t\t// The \"uploadType\" is set to \"resumable\" for the first chunk to initiate the upload.\n\t\tif i == 0 {\n\t\t\turl = fmt.Sprintf(\"%s&uploadType=resumable\", url)\n\t\t}\n\n\t\t// The \"uploadType\" is set to \"resumable\" for the first chunk to initiate the upload.\n\t\tif i == 0 {\n\t\t\turl = fmt.Sprintf(\"%s&uploadType=resumable\", url)\n\t\t}\n\n\t\t// The \"uploadType", "CodeBleu_score": 33.31568268115082}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\tvar data struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&data); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\tif data.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"Mount point is empty\")\n\t}\n\tif err := umountStorage(data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\tif err := deleteStorageConfig(data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, \"Successfully unmounted storage\")\n}", "CodeBleu_score": 32.101807049236896}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tvar storage Storage\n\tif err := ctx.Bind(&storage); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, Response{\n\t\t\tSuccess: false,\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\tif storage.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, Response{\n\t\t\tSuccess: false,\n\t\t\tMessage: \"mount_point cannot be empty\",\n\t\t})\n\t}\n\tif err := umountStorage(storage.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, Response{\n\t\t\tSuccess: false,\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\tif err := deleteStorage(storage.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, Response{\n\t\t\tSuccess: false,\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\treturn ctx.JSON(http.StatusOK, Response{\n\t\tSuccess: true,\n\t\tMessage: \"storage unmounted successfully\",\n\t})\n}", "CodeBleu_score": 42.90041525475737}, {"code": "func UmountStorage(ctx echo.Context) error{\n\tvar (\n\t\terr", "CodeBleu_score": 1.2852592910872978}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"path parameter is missing\"})\n\t}\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"file not found\"})\n\t\t}\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"error reading file\"})\n\t}\n\tdefer file.Close()\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 37.6067163117789}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Extract the file path from the query parameters.\n\tpath := ctx.QueryParam(\"path\")\n\t// Check if the path is provided.\n\tif path == \"\" {\n\t\t// Return an error message if the path is missing.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"The 'path' query parameter is missing.\"})\n\t}\n\t// Check if the file exists.\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\t// Return an error message if the file does not exist.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"The file does not exist.\"})\n\t}\n\t// Read the file.\n\tfile, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\t// Return an error message if the file could not be read.\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"The file could not be read.\"})\n\t}\n\t// Return the file to the client.\n\treturn ctx.Blob(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 40.703617578458974}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Extract the file path from the request query parameters.\n\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"File path is missing.\")\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, \"File not found.\")\n\t}\n\n\t// Open the file.\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"File could not be opened.\")\n\t}\n\n\t// Close the file.\n\tdefer file.Close()\n\n\t// Return the file to the client.\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 38.433953650935074}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Create a new message map.\n\tm := &Message{}\n\n\t// Bind the request body to the message map.\n\tif err := ctx.Bind(m); err != nil {\n\t\t// If binding fails, return a bad request error with the binding error message.\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\".\n\tgo sendNotification(name, m.Message)\n\n\t// Return a success response.\n\treturn ctx.String(http.StatusOK, \"Success\")\n}", "CodeBleu_score": 33.89267909634363}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Create a new message map.\n\tmessage := make(map[string]string)\n\n\t// Bind the request body to the message map.\n\tif err := ctx.Bind(&message); err != nil {\n\t\t// Return a bad request error with the binding error message.\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\".\n\tnotification.Send(name, message[\"message\"])\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"status\": \"success\"})\n}", "CodeBleu_score": 43.14099820198961}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\n\t// Create a message map.\n\tmessage := make(map[string]string)\n\n\t// Bind the request body to the message map.\n\tif err := ctx.Bind(&message); err != nil {\n\t\t// If binding fails, return a bad request error with the binding error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": err.Error()})\n\t}\n\n\t// If successful, send the notification using the \"name\" and \"message\", then return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": fmt.Sprintf(\"Hello, %s! You have a new message: %s\", name, message[\"message\"])})\n}", "CodeBleu_score": 50.51695101017227}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t// Upgrade the HTTP request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service if it is not already running.\n\tif !messageSendingServiceRunning {\n\t\tgo sendMessages()\n\t\tmessageSendingServiceRunning = true\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv: %s\", message)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\tconnections = removeWS(ws)\n\n\t// Close the WebSocket connection.\n\tws.Close()\n\n\treturn nil\n}", "CodeBleu_score": 50.24044327701795}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t// Add the new WebSocket connection to a list of connections.\n\t// The list is used to broadcast messages to all connections.\n\tconnections = append(connections, &connection{\n\t\tsend: make(chan []byte, 256),\n\t\tws:   ctx.Response().Writer,\n\t})\n\n\t// Start the message sending service.\n\t// The service reads messages from the connection list and sends them to all connections.\n\tif !service.IsRunning() {\n\t\tservice.Run()\n\t}\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t_, message, err := ctx.Response().Reader.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"recv: %s\n\", message)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 42.04229137293382}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t// Ensure that the message sending service is running.\n\tif !sending.IsRunning() {\n\t\tsending.Start()\n\t}\n\n\t// Upgrade the HTTP request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections.\n\tconnections.Add(ws)\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t// Read a message from the WebSocket connection.\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors.\n\t\tfmt.Println(\"Message type:\", ws.MessageType())\n\t\tfmt.Println(\"Message:\", string(msg))\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\tconnections.Remove(ws)\n\n\t// Return nil.\n\treturn nil\n}", "CodeBleu_score": 42.86202297883653}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Create a new response object to be returned\n\tresponse := new(Response)\n\n\t// Create a new system hardware information object to be returned\n\tsystemHardwareInfo := new(SystemHardwareInfo)\n\n\t// Retrieve system hardware information\n\tsystemHardwareInfo.DriveModel = GetDriveModel()\n\tsystemHardwareInfo.Architecture = GetArchitecture()\n\tsystemHardwareInfo.CPUInfo = GetCPUInfo()\n\n\t// Create a new success message\n\tsuccessMessage := new(SuccessMessage)\n\tsuccessMessage.Message = \"System hardware information retrieved successfully\"\n\n\t// Set the success message to the response\n\tresponse.Success = successMessage\n\n\t// Set the system hardware information to the response\n\tresponse.SystemHardwareInfo = systemHardwareInfo\n\n\t// Return the response\n\treturn ctx.JSON(http.StatusOK, response)\n}", "CodeBleu_score": 19.24386601443759}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Get system hardware information\n\tvar sysInfo syscall.Sysinfo_t\n\terr := syscall.Sysinfo(&sysInfo)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Error: \" + err.Error())\n\t}\n\n\t// Get drive model and architecture\n\tdriveModel, err := syscall.Sysctl(\"kern.ostype\")\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Error: \" + err.Error())\n\t}\n\tdriveArch, err := syscall.Sysctl(\"kern.osrelease\")\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Error: \" + err.Error())\n\t}\n\n\t// Get CPU information if available\n\tcpuInfo, err := syscall.Sysctl(\"machdep.cpu.brand_string\")\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"Error: \" + err.Error())\n\t}\n\n\t// Return system hardware information\n\tif cpuInfo == \"\" {\n\t\treturn ctx.JSON(http.StatusOK, \"{\\\"DriveModel\\\": \\\"\"+driveModel+\"\\\", \\\"DriveArch\\\": \\\"\"+driveArch+\"\\\"}\")\n\t} else {\n\t\treturn ctx.JSON(http.StatusOK, \"{\\\"DriveModel\\\": \\\"\"+driveModel+\"\\\", \\\"DriveArch\\\": \\\"\"+driveArch+\"\\\", \\\"CPU\\\": \\\"\"+cpuInfo+\"\\\"}\")\n\t}\n}", "CodeBleu_score": 16.155134444362933}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\tvar (\n\t\terr error\n\t\tdata = make(map[string]interface{})\n\t\tcpuInfo = make(map[string]interface{})\n\t\tdriveInfo = make(map[string]interface{})\n\t)\n\n\t// Gather drive model and architecture\n\tdriveInfo[\"model\"], driveInfo[\"architecture\"] = getDriveInfo()\n\n\t// Gather CPU information\n\tcpuInfo[\"model\"], cpuInfo[\"cores\"], cpuInfo[\"threads\"], err = getCPUInfo()\n\tif err != nil {\n\t\tdata[\"message\"] = \"CPU information is not available.\"\n\t\tdata[\"cpu\"] = nil\n\t} else {\n\t\tdata[\"message\"] = \"Successfully retrieved CPU information.\"\n\t\tdata[\"cpu\"] = cpuInfo\n\t}\n\n\tdata[\"drive\"] = driveInfo\n\n\treturn ctx.JSON(http.StatusOK, data)\n}", "CodeBleu_score": 24.84345988219775}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := make([]string, 0)\n\tnotRunningServices := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}", "CodeBleu_score": 66.46983727640232}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to list services\")\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 69.68467457600896}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t// Get a list of all services\n\tservices, err := s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Separate the services into running and not running lists\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif service.Status == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\t// Return a map with boolean keys indicating the running status, each pointing to the corresponding list of service names\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 71.56727348164648}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tvar err error\n\n\t// Create a new event with the given name and message map.\n\tevent := &notify.Event{\n\t\tName:    name,\n\t\tMessage: message,\n\t}\n\n\t// Serialize the event message values to JSON strings.\n\tif err = event.SerializeValues(); err != nil {\n\t\ti.logger.Errorf(\"Failed to serialize event values for event %s: %s\", event.Name, err)\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\tif err = i.bus.Publish(event); err != nil {\n\t\ti.logger.Errorf(\"Failed to publish event %s: %s\", event.Name, err)\n\t\treturn\n\t}\n\n\t// If the response status code is not OK, log the failure along with the response details.\n\tif event.Response.StatusCode != http.StatusOK {\n\t\ti.logger.Errorf(\"Failed to publish event %s: %s\", event.Name, event.Response.Message)\n\t}\n}", "CodeBleu_score": 40.60885458469428}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Error marshalling message: %v\", err)\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus\n\tresponse, err := i.messageBus.Publish(name, jsonMessage)\n\tif err != nil {\n\t\tlog.Printf(\"Error publishing event: %v\", err)\n\t\treturn\n\t}\n\n\t// If the response status code is not OK, log the failure\n\tif response.StatusCode != http.StatusOK {\n\t\tlog.Printf(\"Error sending event: %v\", response.StatusCode)\n\t}\n}", "CodeBleu_score": 32.72944187667217}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t// Serialize the message values to JSON strings.\n\tmessageJSON, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Error: %v\", err)\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\tstatusCode, responseBody, err := i.publisher.Publish(name, messageJSON)\n\tif err != nil {\n\t\tlog.Printf(\"Error: %v\", err)\n\t\treturn\n\t}\n\n\t// If the response status code is not OK, log the failure.\n\tif statusCode != http.StatusOK {\n\t\tlog.Printf(\"Error: %v\nResponse: %v\", statusCode, responseBody)\n\t}\n}", "CodeBleu_score": 31.237689215685204}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t// Initialize the client\n\tclient := message_bus.NewClientWithResponses(c.config.MessageBusURL())\n\t// Attempt to retrieve the message bus address\n\taddress, err := c.config.MessageBusAddress()\n\t// If the address is found, set the client's server to the retrieved address; otherwise, set the server to a default error message\n\tif err == nil {\n\t\tclient.Server = address\n\t} else {\n\t\tclient.Server = \"error: no message bus address found\"\n\t}\n\treturn client\n}", "CodeBleu_score": 37.24598971289398}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tvar err error\n\tvar server string\n\tvar client *message_bus.ClientWithResponses\n\tserver, err = c.GetMessageBusAddress()\n\tif err != nil {\n\t\tserver = \"Error: Could not get message bus address\"\n\t}\n\tclient = message_bus.NewClientWithResponses(server)\n\treturn client\n}", "CodeBleu_score": 33.78844348588067}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tvar mb *message_bus.ClientWithResponses\n\tvar err error\n\tvar address string\n\n\t// If the address has already been found, return the client with the address set.\n\tif c.address != \"\" {\n\t\tmb = message_bus.NewClientWithResponses(c.address)\n\t\treturn mb\n\t}\n\n\t// If the address has not been found, attempt to retrieve it using the runtime path.\n\tif address, err = c.runtimePath(); err != nil {\n\t\tc.address = \"Error: \" + err.Error()\n\t\tmb = message_bus.NewClientWithResponses(c.address)\n\t\treturn mb\n\t}\n\n\t// If the address was found, set the client's server to the retrieved address.\n\tc.address = address\n\tmb = message_bus.NewClientWithResponses(c.address)\n\treturn mb\n}", "CodeBleu_score": 36.14296258603121}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.TrimSpace(strings.Split(ip, \",\")[0])\n\tip = strings.TrimPrefix(ip, \"[\")\n\tip = strings.TrimSuffix(ip, \"]\")\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t} else if ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 65.59285741440277}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"X-Forwarded-For\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \":\")[0]\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t} else if ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 61.80363558542709}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\tif ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 52.14768391515122}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Define paths for the modules directory and the entry file, ensuring the entry file exists.\n\tmodulesDir := filepath.Join(c.config.System.Root, \"modules\")\n\tentryFile := filepath.Join(modulesDir, \"entry.json\")\n\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\tif err := ioutil.WriteFile(entryFile, []byte(\"[]\"), 0644); err != nil {\n\t\t\tc.logger.Errorf(\"Failed to create system entry file: %s\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files, concatenate their content into a single JSON array, and write this array to the entry file path.\n\tvar entry []byte\n\tif err := filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tc.logger.Errorf(\"Failed to read system entry file: %s\", err)\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif filepath.Base(path) != \"entry.json\" {\n\t\t\treturn nil\n\t\t}\n\t\tb, err := ioutil.ReadFile(path)\n\t\tif err != nil {\n\t\t\tc.logger.Errorf(\"Failed to read system entry file: %s\", err)\n\t\t\treturn err\n\t\t}\n\t\tentry = append(entry, b...)\n\t\treturn nil\n\t}); err != nil {\n\t\tc.logger.Errorf(\"Failed to read system entry file: %s\", err)\n\t\treturn\n\t}\n\tif err := ioutil.WriteFile(entryFile, entry, 0644); err != nil {\n\t\tc.logger.Errorf(\"Failed to write system entry file: %s\", err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 40.381778119058644}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Set the path for the modules directory\n\tmodulesPath := c.systemPath + \"/modules\"\n\n\t// Set the path for the entry file\n\tentryFilePath := modulesPath + \"/entry.json\"\n\n\t// Ensure the modules directory exists\n\tif _, err := os.Stat(modulesPath); os.IsNotExist(err) {\n\t\tlog.Fatal(\"The modules directory does not exist.\")\n\t}\n\n\t// Ensure the entry file exists\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tlog.Fatal(\"The entry file does not exist.\")\n\t}\n\n\t// Read the entry file\n\tentryFile, err := ioutil.ReadFile(entryFilePath)\n\tif err != nil {\n\t\tlog.Fatal(\"Unable to read the entry file: \", err)\n\t}\n\n\t// Read the entry file as a JSON array\n\tvar entryArray []map[string]interface{}\n\terr = json.Unmarshal(entryFile, &entryArray)\n\tif err != nil {\n\t\tlog.Fatal(\"Unable to read the entry file as a JSON array: \", err)\n\t}\n\n\t// Read each module directory\n\tfiles, err := ioutil.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlog.Fatal(\"Unable to read the modules directory: \", err)\n\t}\n\n\t// For each module directory\n\tfor _, f := range files {\n\t\t// Set the path for the module directory\n\t\tmodulePath := modulesPath + \"/\" + f.Name()\n\n\t\t// Set the path for the module entry file\n\t\tmoduleEntryFilePath := modulePath + \"/entry.json\"\n\n\t\t// Ensure the module directory exists\n\t\tif _, err := os.Stat(modulePath); os.IsNotExist(err) {\n\t\t\tlog.Fatal(\"The module directory does not exist.\")\n\t\t}\n\n\t\t// Ensure the module entry file exists\n\t\tif _, err := os.Stat(moduleEntryFilePath); os.IsNotExist(err) {\n\t\t\tlog.Fatal(\"The module entry file does", "CodeBleu_score": 40.818350760853846}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Define the path for the modules directory.\n\tmodulesPath := c.config.GetString(\"modules_path\")\n\n\t// Ensure the modules directory exists.\n\tif _, err := os.Stat(modulesPath); os.IsNotExist(err) {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Define the path for the entry file.\n\tentryFilePath := c.config.GetString(\"entry_file_path\")\n\n\t// Ensure the entry file exists.\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Create a new empty JSON array.\n\tvar modules []map[string]interface{}\n\n\t// Read each module directory for entry.json files.\n\terr := filepath.Walk(modulesPath, func(path string, info os.FileInfo, err error) error {\n\n\t\t// If the file is an entry.json file, read the file.\n\t\tif strings.HasSuffix(path, \"entry.json\") {\n\n\t\t\t// Read the file.\n\t\t\tbytes, err := ioutil.ReadFile(path)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\n\t\t\t// Unmarshal the JSON array.\n\t\t\tvar module map[string]interface{}\n\t\t\terr = json.Unmarshal(bytes, &module)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\n\t\t\t// Add the module to the modules array.\n\t\t\tmodules = append(modules, module)\n\n\t\t}\n\n\t\t// Return nil.\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Marshal the modules array.\n\tbytes, err := json.Marshal(modules)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Write the modules array to the entry file.\n\terr = ioutil.WriteFile(entry", "CodeBleu_score": 42.09371805967144}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t// Get a list of the network interfaces on the local computer.\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the list of network interfaces.\n\tfor _, i := range interfaces {\n\t\t// Print the name and address of the network interface.\n\t\t//fmt.Printf(\"Interface: %v\n\", i.Name)\n\n\t\t// Check if the interface is up.\n\t\tif i.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // Skip interfaces that are down.\n\t\t}\n\n\t\t// Get a list of the addresses of the interface.\n\t\taddrs, err := i.Addrs()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\t// Iterate over the list of addresses of the interface.\n\t\tfor _, addr := range addrs {\n\t\t\t// Check the type of address.\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\t// Print the IP address of the interface.\n\t\t\t\t//fmt.Printf(\"  IP address: %v\n\", v.IP)\n\n\t\t\t\t// Check if the interface has the 169.254.x.x address.\n\t\t\t\tif v.IP.IsLinkLocalUnicast() {\n\t\t\t\t\t//fmt.Printf(\"  Link-local address: %v\n\", v.IP)\n\n\t\t\t\t\t// Get the hardware address of the interface.\n\t\t\t\t\thwaddr := i.HardwareAddr.String()\n\n\t\t\t\t\t// Return the hardware address of the interface.\n\t\t\t\t\treturn hwaddr, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return an error if no matching interface is found.\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 60.09658381259846}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t// Get a list of the system's network interfaces\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over all of the system's interfaces\n\tfor _, i := range ifaces {\n\t\t// Check if the interface is up\n\t\tif i.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // Skip interfaces that are down\n\t\t}\n\n\t\t// Check if the interface is a loopback interface\n\t\tif i.Flags&net.FlagLoopback != 0 {\n\t\t\tcontinue // Skip loopback interfaces\n\t\t}\n\n\t\t// Attempt to retrieve the MAC address of the interface\n\t\tmac := i.HardwareAddr.String()\n\t\tif len(mac) == 0 {\n\t\t\tcontinue // Skip interfaces with no MAC address\n\t\t}\n\n\t\t// Return the MAC address of the first matching interface\n\t\treturn mac, nil\n\t}\n\n\t// If we get here, we haven't found a matching interface\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 55.94775913385095}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t// Get a list of the system's network interfaces\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate through the list of interfaces\n\tfor _, i := range ifaces {\n\t\t// Read the interface's attributes\n\t\tif i.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // Skip down interfaces\n\t\t}\n\t\tif i.Flags&net.FlagLoopback != 0 {\n\t\t\tcontinue // Skip loopback interfaces\n\t\t}\n\n\t\t// Retrieve the MAC address of the interface\n\t\tmac := i.HardwareAddr.String()\n\n\t\t// Search for the interface with the specified name\n\t\tif i.Name == \"eth0\" {\n\t\t\treturn mac, nil\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"Cannot find eth0 interface\")\n}", "CodeBleu_score": 59.4591154140217}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t result = 0;\n\tint32_t i;\n\tSApplicationObj *pAppObj;\n\tSRequestObj *pRequestObj;\n\n\t/*\n\t * Add a reference to the request object and increment the request count for the associated TSC object.\n\t */\n\tpRequest->pTscObj = pTscObj;\n\tpRequest->pTscObj->requestCount++;\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary, including total and current request counts.\n\t */\n\tif (pTscObj->pAppObj) {\n\t\tpAppObj = pTscObj->pAppObj;\n\t\tpAppObj->requestCount++;\n\t\tpAppObj->currentRequestCount++;\n\t\tpRequestObj = pAppObj->pRequestObj;\n\t\tfor (i = 0; i < pAppObj->requestCount; i++) {\n\t\t\tif (pRequestObj[i].requestId == pRequest->requestId) {\n\t\t\t\tpRequestObj[i].requestCount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == pAppObj->requestCount) {\n\t\t\tpRequestObj[i].requestId = pRequest->requestId;\n\t\t\tpRequestObj[i].requestCount = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tlogDebug(\"Registered request %d for TSC %d\", pRequest->requestId, pTscObj->tscId);\n\n\treturn result;\n}", "CodeBleu_score": 38.278455351593664}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t ret = 0;\n    int32_t i;\n    int32_t j;\n    int32_t count;\n    int32_t index;\n    int32_t appIndex;\n    int32_t appCount;\n    int32_t appCountMax;\n    int32_t appCountMaxIndex;\n    int32_t appCountMaxIndexNext;\n    int32_t appCountMaxIndexNextNext;\n    int32_t appCountMaxIndexNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext;\n    int32_t appCountMaxIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext;\n    int3", "CodeBleu_score": 5.566606321132014}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc = 0;\n\tSTscAppInfo *pAppInfo = NULL;\n\tint32_t i;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\trc = -1;\n\t\tgoto end;\n\t}\n\n\tpRequest->pTscObj = pTscObj;\n\tpRequest->requestCount = 1;\n\tpRequest->next = NULL;\n\tpRequest->prev = NULL;\n\n\tif (pTscObj->pRequestList == NULL) {\n\t\tpTscObj->pRequestList = pRequest;\n\t\tpTscObj->requestCount = 1;\n\t} else {\n\t\tpTscObj->pRequestList->prev = pRequest;\n\t\tpRequest->next = pTscObj->pRequestList;\n\t\tpTscObj->pRequestList = pRequest;\n\t\tpTscObj->requestCount++;\n\t}\n\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpAppInfo = pTscObj->pAppInfo;\n\t\tpAppInfo->totalRequestCount++;\n\t\tpAppInfo->currentRequestCount++;\n\t\tpAppInfo->requestTime = pRequest->requestTime;\n\t\tpAppInfo->requestTime = pRequest->requestTime;\n\n\t\tif (pAppInfo->requestCountList != NULL) {\n\t\t\tfor (i = 0; i < pAppInfo->requestCountListSize; i++) {\n\t\t\t\tif (pAppInfo->requestCountList[i] == pRequest->requestCount) {\n\t\t\t\t\tpAppInfo->requestCountList[i]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpAppInfo->requestCountListSize = 1;\n\t\t\tpAppInfo->requestCountList = (int32_t *) malloc(sizeof(int32_t));\n\t\t\tpAppInfo->requestCountList[0] = pRequest->requestCount;\n\t\t}\n\t}\n\n\tif (pTscObj->pSessObj !=", "CodeBleu_score": 39.69276356933381}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tif (pRequest->pPrimaryDb != NULL) {\n        if (strcmp(pRequest->pPrimaryDb, exceptDb) != 0) {\n            return true;\n        }\n    }\n    for (int i = 0; i < pRequest->dbCount; i++) {\n        if (strcmp(pRequest->dbs[i], exceptDb) != 0) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 51.971666789186145}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tbool bRet = true;\n    char* pDb = pRequest->getPrimaryDb();\n    if (pDb != NULL) {\n        if (strcmp(pDb, exceptDb) != 0) {\n            bRet = false;\n        }\n    }\n    else {\n        bRet = false;\n    }\n    if (bRet == false) {\n        return bRet;\n    }\n    int iDbCount = pRequest->getDbCount();\n    for (int i = 0; i < iDbCount; i++) {\n        char* pDb = pRequest->getDb(i);\n        if (strcmp(pDb, exceptDb) != 0) {\n            bRet = false;\n        }\n    }\n    return bRet;\n}", "CodeBleu_score": 46.839368745396634}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tchar *pDb;\n    bool found = false;\n    int i;\n\n    if (pRequest->pPrimaryDb == NULL) {\n        return false;\n    }\n\n    if (strcmp(pRequest->pPrimaryDb, exceptDb) == 0) {\n        return false;\n    }\n\n    for (i = 0; i < pRequest->dbCount; i++) {\n        pDb = pRequest->pDbList[i];\n        if (pDb[0] == 's' || pDb[0] == 'S') {\n            pDb = pDb + 1;\n        }\n        if (strcmp(pDb, exceptDb) == 0) {\n            found = true;\n            break;\n        }\n    }\n    return !found;\n}", "CodeBleu_score": 53.80205807160371}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tbool rv = false;\n    switch (code) {\n        case ECONNREFUSED:\n        case ECONNRESET:\n        case ETIMEDOUT:\n        case ENETUNREACH:\n        case EHOSTUNREACH:\n        case EHOSTDOWN:\n        case EPIPE:\n        case ENOTCONN:\n        case EINTR:\n        case EAGAIN:\n        case EWOULDBLOCK:\n        case EINPROGRESS:\n        case EALREADY:\n        case EADDRINUSE:\n        case EADDRNOTAVAIL:\n        case ECONNABORTED:\n        case EISCONN:\n        case ENETDOWN:\n        case ESHUTDOWN:\n        case ETOOMANYREFS:\n        case ETXTBSY:\n        case EUSERS:\n        case EDQUOT:\n        case ESTALE:\n        case EREMOTE:\n        case EBADMSG:\n        case EOVERFLOW:\n        case EILSEQ:\n        case ENOTSUP:\n        case EOPNOTSUPP:\n        case EPFNOSUPPORT:\n        case EAFNOSUPPORT:\n        case EADDRNOTAVAIL:\n        case ENETDOWN:\n        case ENETUNREACH:\n        case ENETRESET:\n        case ECONNABORTED:\n        case ECONNRESET:\n        case ENOBUFS:\n        case EISCONN:\n        case ENOTCONN:\n        case ESHUTDOWN:\n        case ETOOMANYREFS:\n        case ETIMEDOUT:\n        case ECONNREFUSED:\n        case ELOOP:\n        case ENAMETOOLONG:\n        case EHOSTDOWN:\n        case EHOSTUNREACH:\n        case ENOTEMPTY:\n        case EPROCLIM:\n        case EUSERS:\n        case EDQUOT:\n        case ESTALE:\n        case EREMOTE:\n        case EBADRPC:\n        case ERPCMISMATCH", "CodeBleu_score": 26.213043484768487}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tif (code == SYS_REDIRECT_RC) {\n        if (msgType == TMSG_REPL_OPEN_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_READ_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_WRITE_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_CLOSE_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_UNLINK_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_STAT_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_FSTAT_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_LSEEK_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_GET_RESC_QUOTA_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_OPR_COMPLETED_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_OPEN_COLL_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_READ_COLL_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_WRITE_COLL_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_CLOSE_COLL_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_UNLINK_COLL_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_STAT_COLL_AN) {\n            return false;\n        } else if (msgType == TMSG_REPL_FSTAT_COLL_AN) {\n            return false;\n        } else if (msgType ==", "CodeBleu_score": 45.701684447031134}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tbool rv = false;\n\n    if (code == RPC_REDIRECT_TO_LOCAL_SERVER) {\n        if (msgType != TMSG_RPC_REPLY_DATA) {\n            rv = true;\n        }\n    }\n\n    return rv;\n}", "CodeBleu_score": 31.30940778293721}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\tif (pRequests == NULL) return;\n    SHashObj *pRequest;\n    SHashIterator *pIterator = sHashIteratorCreate(pRequests);\n    while ((pRequest = sHashIteratorNext(pIterator)) != NULL) {\n        int64_t rid = sHashObjGetKey(pRequest);\n        if (rid != -1) {\n            //printf(\"stopAllRequests: rid=%ld\n\", rid);\n            taosStopRequest(clientReqRefPool, rid);\n            taosReleaseRef(clientReqRefPool, rid);\n        }\n    }\n    sHashIteratorDestroy(pIterator);\n}", "CodeBleu_score": 43.95774358064149}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tSHashObj *pObj = NULL;\n    SRequest *pRequest = NULL;\n    SHashObj *pObjNext = NULL;\n\n    if (pRequests == NULL) {\n        return;\n    }\n\n    for (pObj = pRequests->pNext; pObj != NULL; pObj = pObjNext) {\n        pObjNext = pObj->pNext;\n        pRequest = (SRequest *)pObj->pData;\n        if (pRequest != NULL) {\n            if (pRequest->query != NULL) {\n                taos_cancel(pRequest->query);\n            }\n            releaseRequest(pObj->rid);\n        }\n    }\n}", "CodeBleu_score": 38.27282765524219}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tSHashObj *pRequest;\n    int64_t rid;\n    int32_t ret;\n    if (pRequests == NULL)\n        return;\n    for (rid = 0; rid < pRequests->size; rid++) {\n        pRequest = sHashGetObj(pRequests, rid);\n        if (pRequest == NULL)\n            continue;\n        ret = taosAcquireRef(clientReqRefPool, rid);\n        if (ret == 0) {\n            if (pRequest->req.type == TAOS_CMD_QUERY) {\n                taos_query_cancel(pRequest->req.query);\n            }\n            taosReleaseRef(clientReqRefPool, rid);\n        }\n    }\n}", "CodeBleu_score": 40.00813665868501}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\tif (tscCrashReportEnabled == 0) {\n\t\treturn;\n\t}\n\n\tif (__sync_bool_compare_and_swap(&tscCrashReportClientStop, 0, 1) == 0) {\n\t\treturn;\n\t}\n\n\twhile (tscCrashReportClientStop != 0) {\n\t\tsleep(1);\n\t}\n}", "CodeBleu_score": 41.76437690324126}, {"code": "void tscStopCrashReport(){\n\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\tif (!__sync_bool_compare_and_swap(&tscCrashReportingClientStop, 0, 1)) {\n\t\tTS_LOG_ERROR(\"tscStopCrashReport: crash report thread is already stopped\");\n\t\treturn;\n\t}\n\twhile (tscCrashReportingClientStop) {\n\t\tusleep(10000);\n\t}\n}", "CodeBleu_score": 54.97188764809018}, {"code": "void tscStopCrashReport(){\n\tif (!tscCrashReportingEnabled) {\n\t\treturn;\n\t}\n\tif (__sync_bool_compare_and_swap(&tscCrashReportClientStop, 0, 1)) {\n\t\twhile (tscCrashReportClientStop) {\n\t\t\tsleep(1);\n\t\t}\n\t} else {\n\t\ttscLogError(\"The crash report thread is already stopped.\");\n\t}\n}", "CodeBleu_score": 51.588956385740495}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t i, j, rc = 0;\n    char *p = (char *)value;\n    char *pEnd = p + valueLen;\n    int32_t viewCnt;\n    int32_t viewId;\n    int32_t viewNameLen;\n    char *viewName;\n    int32_t colCnt;\n    int32_t colNameLen;\n    char *colName;\n    int32_t colType;\n    int32_t colLen;\n    int32_t colPrec;\n    int32_t colScale;\n    int32_t colNullable;\n    int32_t colKey;\n    int32_t colDefault;\n    int32_t colAutoinc;\n    int32_t colUpdatable;\n    int32_t colCaseSensitive;\n    int32_t colSearchable;\n    int32_t colTypeNameLen;\n    char *colTypeName;\n    int32_t colLabelLen;\n    char *colLabel;\n    int32_t colDisplaySize;\n    int32_t colOctetLength;\n    int32_t colBufferLength;\n    int32_t colDecimalDigits;\n    int32_t colNumPrecRadix;\n    int32_t colNullableUnk;\n    int32_t colRemarksLen;\n    char *colRemarks;\n    int32_t colSchemaLen;\n    char *colSchema;\n    int32_t colCatalogLen;\n    char *colCatalog;\n    int32_t colBaseColumnNameLen;\n    char *colBaseColumnName;\n    int32_t colBaseTableNameLen;\n    char *colBaseTableName;\n    int32_t colBaseTableCatLen;\n    char *colBaseTableCat;\n    int32_t colBaseTableSchemaLen;\n    char *colBaseTableSchema;\n    int32_t colBaseTableColNameLen;\n    char *colBaseTableColName;\n    int32", "CodeBleu_score": 10.096025529788214}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t ret = 0;\n\tint32_t viewCnt = 0;\n\tint32_t viewIdx = 0;\n\tint32_t viewId = 0;\n\tint32_t viewColCnt = 0;\n\tint32_t viewColIdx = 0;\n\tint32_t viewColId = 0;\n\tint32_t viewColNameLen = 0;\n\tchar *viewColName = NULL;\n\tint32_t viewColType = 0;\n\tint32_t viewColLen = 0;\n\tint32_t viewColPrec = 0;\n\tint32_t viewColScale = 0;\n\tint32_t viewColNullable = 0;\n\tint32_t viewColDefault = 0;\n\tint32_t viewColDefaultLen = 0;\n\tint32_t viewColDefaultType = 0;\n\tchar *viewColDefaultVal = NULL;\n\tint32_t viewColDefaultValLen = 0;\n\tint32_t viewColDefaultValType = 0;\n\tint32_t viewColDefaultValPrec = 0;\n\tint32_t viewColDefaultValScale = 0;\n\tint32_t viewColDefaultValNullable = 0;\n\tint32_t viewColDefaultValLenBytes = 0;\n\tint32_t viewColDefaultValLenChars = 0;\n\tint32_t viewColDefaultValLenWideChars = 0;\n\tint32_t viewColDefaultValLenWideVarchars = 0;\n\tint32_t viewColDefaultValLenBinary = 0;\n\tint32_t viewColDefaultValLenVarbinary = 0;\n\tint32_t viewColDefaultValLenBlob = 0;\n\tint32_t viewColDefaultValLenClob = 0;\n\tint32_t viewColDefaultValLenNclob = 0;\n\tint32_t viewColDefaultValLenSqlXml =", "CodeBleu_score": 8.484312032391907}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t rc = 0;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t k = 0;\n    int32_t numViews = 0;\n    int32_t numCols = 0;\n    int32_t numColsInCatalog = 0;\n    int32_t numColsInRsp = 0;\n    int32_t numColsToAdd = 0;\n    int32_t numColsToRemove = 0;\n    int32_t numColsToUpdate = 0;\n    int32_t numColsToUpdateInCatalog = 0;\n    int32_t numColsToUpdateInRsp = 0;\n    int32_t numColsToAddInCatalog = 0;\n    int32_t numColsToAddInRsp = 0;\n    int32_t numColsToRemoveInCatalog = 0;\n    int32_t numColsToRemoveInRsp = 0;\n    int32_t numColsInCatalogToAdd = 0;\n    int32_t numColsInCatalogToRemove = 0;\n    int32_t numColsInRspToAdd = 0;\n    int32_t numColsInRspToRemove = 0;\n    int32_t numColsInCatalogToUpdate = 0;\n    int32_t numColsInRspToUpdate = 0;\n    int32_t numColsToUpdateInCatalogToRemove = 0;\n    int32_t numColsToUpdateInRspToRemove = 0;\n    int32_t numColsToAddInCatalogToRemove = 0;\n    int32_t numColsToAddInRspToRemove = 0;\n    int32_t numColsToRemoveInCatalogToAdd = 0;\n    int32_t numColsToRemoveInRspToAdd = 0;", "CodeBleu_score": 11.642177209672473}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3Status status;\n    S3GetObjectHandler *handler = (S3GetObjectHandler *) callbackData;\n\n    if (properties->contentLength > 0) {\n        handler->contentLength = properties->contentLength;\n    } else {\n        handler->contentLength = 0;\n    }\n\n    status = S3StatusOK;\n    return status;\n}", "CodeBleu_score": 71.0234234901889}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3Status status = S3StatusOK;\n    S3ResponsePropertiesCurl *responsePropertiesCurl = (S3ResponsePropertiesCurl *) properties;\n    S3GetObjectResponseData *getObjectResponseData = (S3GetObjectResponseData *) callbackData;\n\n    if (responsePropertiesCurl->contentLength > 0) {\n        getObjectResponseData->contentLength = responsePropertiesCurl->contentLength;\n    } else {\n        getObjectResponseData->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 60.13979054090445}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3Status status;\n    CallbackData *data = (CallbackData *) callbackData;\n\n    /* Extract the content length from the response properties. */\n    status = s3_get_content_length(properties, &data->contentLength);\n    if (status != S3StatusOK) {\n        return status;\n    }\n\n    /* If the content length is greater than zero, set the content length in the callback data structure; otherwise, set the content length to zero. */\n    if (data->contentLength > 0) {\n        data->contentLength = data->contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 65.03437165316308}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tif (taosCreateDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --port %d --config %srsync.conf\", tsCheckpointPort, tsCheckpointBackupDir);\n  uDebug(\"[rsync] start rsync server, cmd:%s\", cmd);\n  if (system(cmd) == 0) {\n    uDebug(\"[rsync] rsync server start success\");\n  } else {\n    uError(\"[rsync] rsync server start error\");\n  }\n}", "CodeBleu_score": 65.25799492467253}, {"code": "void startRsync(){\n\tif (taosCreateDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%s%s\", tsCheckpointBackupDir, \"rsync.conf\");\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s,\" ERRNO_ERR_FORMAT, confDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX * 4] = {0};\n  snprintf(cmd, PATH_MAX * 4, \"rsync --daemon --config=%s\", confDir);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) == -1) {\n    uError(\"[rsync] start error, cmd:%s,\" ERRNO_ERR_FORMAT, cmd, ERRNO_ERR_DATA);\n    return;\n  }\n  uInfo(\"[rsync] start success, cmd:%s\", cmd);\n}", "CodeBleu_score": 63.34401769442931}, {"code": "void startRsync(){\n\tif (tsCheckpointBackupDir == NULL) {\n    uError(\"[rsync] checkpoint backup dir is null\");\n    return;\n  }\n\n  if (taosCreateDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, sizeof(confDir), \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s\", confDir);\n    return;\n  }\n\n  char cmd[PATH_MAX * 4] = {0};\n  snprintf(cmd, PATH_MAX * 4, \"rsync --daemon --port %d --config %s\", tsCheckpointBackupPort, confDir);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) != 0) {\n    uError(\"[rsync] start error, cmd:%s\", cmd);\n  }\n}", "CodeBleu_score": 60.25638406220498}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t// Get the dispatcher from the dispatchers collection\n\tDispatcher dispatcher = (Dispatcher) dispatchers.remove(dispatcherId);\n\n\t// If the dispatcher is not found, throw a runtime exception\n\tif (dispatcher == null) {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n\t}\n\n\t// Shutdown the dispatcher's executor\n\tdispatcher.getExecutor().shutdown();\n\n}", "CodeBleu_score": 64.3256351681799}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not registered\");\n\t}\n}", "CodeBleu_score": 46.64781781462906}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tif (dispatcherId == null) {\n        throw new IllegalArgumentException(\"The dispatcherId argument cannot be null.\");\n    }\n    Dispatcher dispatcher = (Dispatcher)dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new IllegalArgumentException(\"The dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n    dispatcher.shutdownNow();\n}", "CodeBleu_score": 53.421279764381644}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tif (parent.isRoot()) {\n            return;\n        }\n        if (parent.getId() == null) {\n            log.warn(\"[{}] Failed to broadcast message to children: [{}]\", parent, msg);\n            return;\n        }\n        List<TbActorId> children = getChildren(parent);\n        if (children == null) {\n            log.warn(\"[{}] Failed to broadcast message to children: [{}]\", parent, msg);\n            return;\n        }\n        children.stream().filter(childFilter).forEach(child -> {\n            if (child.isRoot()) {\n                log.warn(\"[{}] Failed to broadcast message to children: [{}]\", parent, msg);\n            } else {\n                tell(child, msg, highPriority);\n            }\n        });\n    }", "CodeBleu_score": 45.84475165120089}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId[] children = parent.getChildren();\n        if (children != null) {\n            for (TbActorId child : children) {\n                if (childFilter.test(child)) {\n                    try {\n                        tell(child, msg, highPriority);\n                    } catch (Exception e) {\n                        log.warn(\"[{}] Failed to send message to child actor: {}\", parent, child, e);\n                    }\n                }\n            }\n        }\n    }", "CodeBleu_score": 54.33614728544125}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tSet<TbActorId> children = actorCtx.getChildren(parent);\n        if (children != null) {\n            for (TbActorId child : children) {\n                if (childFilter.test(child)) {\n                    tell(child, msg, highPriority);\n                }\n            }\n        }\n    }", "CodeBleu_score": 56.53755090348781}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroyInProgress.get()) {\n        if (highPriority && msg instanceof RuleNodeUpdatedMsg) {\n            tryInit(2);\n        } else {\n            msg.getSender().tell(new ActorTerminatedMsg(selfId));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    }\n}", "CodeBleu_score": 41.29050472694044}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (log.isTraceEnabled()) {\n            log.trace(\"[{}] Enqueueing message: {}\", selfId, msg);\n        }\n        if (destructionInProgress.get() && msg instanceof RuleNodeUpdateMsg) {\n            RuleNodeUpdateMsg ruleNodeUpdateMsg = (RuleNodeUpdateMsg) msg;\n            if (ruleNodeUpdateMsg.isRuleNodeUpdatedMsg()) {\n                if (ruleNodeUpdateMsg.getError() != null) {\n                    log.debug(\"[{}] Failed to process message: {}\", selfId, msg);\n                }\n                if (ruleNodeUpdateMsg.getError() != null || ruleNodeUpdateMsg.isRestart()) {\n                    if (ruleNodeUpdateMsg.isRestart()) {\n                        log.debug(\"[{}] Restarting actor: {}\", selfId, msg);\n                    } else {\n                        log.debug(\"[{}] Reinitializing actor: {}\", selfId, msg);\n                    }\n                    tryInit(1);\n                } else {\n                    log.debug(\"[{}] Actor has stopped: {}\", selfId, msg);\n                }\n                return;\n            }\n        }\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(false);\n    }", "CodeBleu_score": 49.24955284511447}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroyInProgress.get()) {\n        if (msg instanceof TbActorStopRpcMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);\n        } else if (msg instanceof TbActorInitMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);\n        } else if (msg instanceof TbActorStopRpcMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);\n        } else if (msg instanceof TbActorStopRpcMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);\n        } else if (msg instanceof TbActorStopRpcMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);\n        } else if (msg instanceof TbActorStopRpcMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);\n        } else if (msg instanceof TbActorStopRpcMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);\n        } else if (msg instanceof TbActorStopRpcMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);\n        } else if (msg instanceof TbActorStopRpcMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);\n        } else if (msg instanceof TbActorStopRpcMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);\n        } else if (msg instanceof TbActorStopRpcMsg) {\n            log.trace(\"[{}] Message [{}] is ignored because the actor is in the process of destruction\", selfId, msg);", "CodeBleu_score": 32.41843469239919}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\ttry {\n            int highPriorityMsgsProcessed = 0;\n            int normalPriorityMsgsProcessed = 0;\n            while (highPriorityMsgsProcessed < throughput && highPriorityMsgs.size() > 0) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg != null) {\n                    try {\n                        actor.process(msg);\n                    } catch (Throwable t) {\n                        log.warn(\"[{}] Failed to process message: {}\", selfId, t);\n                        actor.getProcessFailureStrategy().handle(t);\n                    }\n                    highPriorityMsgsProcessed++;\n                }\n            }\n            while (normalPriorityMsgsProcessed < throughput && normalPriorityMsgs.size() > 0) {\n                TbActorMsg msg = normalPriorityMsgs.poll();\n                if (msg != null) {\n                    try {\n                        actor.process(msg);\n                    } catch (Throwable t) {\n                        log.warn(\"[{}] Failed to process message: {}\", selfId, t);\n                        actor.getProcessFailureStrategy().handle(t);\n                    }\n                    normalPriorityMsgsProcessed++;\n                }\n            }\n            if (highPriorityMsgs.size() == 0 && normalPriorityMsgs.size() == 0) {\n                busy.set(FREE);\n                tryProcessQueue(false);\n            }\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n            stopReason = TbActorStopReason.PROCESS_FAILURE;\n            destroy(t);\n        }\n    }", "CodeBleu_score": 43.427774465824456}, {"code": "private void processMailbox(){\n\ttry {\n            int throughput = 0;\n            while (throughput < dispatcher.getThroughput()) {\n                if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                    break;\n                }\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    msg = normalPriorityMsgs.poll();\n                }\n                if (msg != null) {\n                    try {\n                        actor.process(msg);\n                    } catch (Throwable e) {\n                        log.warn(\"[{}] Failed to process msg: {}\", selfId, msg, e);\n                        if (msg.isFailureProcessing()) {\n                            if (stopReason == null) {\n                                stopReason = TbActorStopReason.FAILURE;\n                            }\n                            destroy(e);\n                            return;\n                        }\n                    }\n                    throughput++;\n                }\n            }\n            busy.set(FREE);\n            tryProcessQueue(false);\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n            if (stopReason == null) {\n                stopReason = TbActorStopReason.FAILURE;\n            }\n            destroy(t);\n        }\n    }", "CodeBleu_score": 52.270401787100575}, {"code": "private void processMailbox(){\n\ttry {\n            int throughput = actor.getMailboxProcessorConfig().getMailboxProcessingThreshold();\n            int processed = 0;\n            int processedHigh = 0;\n            int processedNormal = 0;\n            boolean highPriorityQueueEmpty = highPriorityMsgs.isEmpty();\n            boolean normalPriorityQueueEmpty = normalPriorityMsgs.isEmpty();\n            while (processed < throughput && !highPriorityQueueEmpty && !normalPriorityQueueEmpty) {\n                if (processedHigh < throughput) {\n                    TbActorMsg msg = highPriorityMsgs.poll();\n                    if (msg != null) {\n                        try {\n                            actor.process(msg);\n                            processedHigh++;\n                        } catch (Throwable t) {\n                            processFailure(msg, t);\n                        }\n                    } else {\n                        highPriorityQueueEmpty = true;\n                    }\n                }\n                if (processedNormal < throughput) {\n                    TbActorMsg msg = normalPriorityMsgs.poll();\n                    if (msg != null) {\n                        try {\n                            actor.process(msg);\n                            processedNormal++;\n                        } catch (Throwable t) {\n                            processFailure(msg, t);\n                        }\n                    } else {\n                        normalPriorityQueueEmpty = true;\n                    }\n                }\n                processed += processedHigh + processedNormal;\n            }\n            if (highPriorityQueueEmpty && normalPriorityQueueEmpty) {\n                busy.set(FREE);\n                tryProcessQueue(false);\n            }\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n            destroy(t);\n        }\n    }", "CodeBleu_score": 38.30779904810606}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.66735696636148}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitType rateLimitType = tenantProfile.getRateLimitType();\n    if (rateLimitType == null) {\n        return true;\n    }\n    RateLimitConfig rateLimitConfig = rateLimitConfigCache.get(rateLimitType);\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    RateLimitStrategy rateLimitStrategy = rateLimitStrategyCache.get(rateLimitType);\n    if (rateLimitStrategy == null) {\n        return true;\n    }\n    boolean result = rateLimitStrategy.checkRateLimit(api, tenantId, level, rateLimitConfig);\n    if (!result) {\n        rateLimitNotificationService.processRateLimitNotification(api, tenantId, rateLimitType);\n    }\n    return result;\n}", "CodeBleu_score": 57.005761039648426}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (isSystemTenant(tenantId)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitType rateLimitType = getRateLimitType(api);\n    RateLimitConfig rateLimitConfig = tenantProfile.getRateLimit(rateLimitType);\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    if (rateLimitConfig.isDisabled()) {\n        return true;\n    }\n    RateLimit rateLimit = rateLimitService.checkRateLimit(tenantId, rateLimitType, level);\n    if (rateLimit.isExceeded()) {\n        rateLimitService.processRateLimitNotification(tenantId, rateLimitType, rateLimit);\n    }\n    return !rateLimit.isExceeded();\n}", "CodeBleu_score": 58.51357593305384}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.isSystemTenant()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitType rateLimitType = tenantProfile.getRateLimitType();\n    if (rateLimitType == null) {\n        return true;\n    }\n    RateLimitConfig rateLimitConfig = tenantProfile.getRateLimitConfig();\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    boolean checkResult = rateLimitService.check(api, tenantId, level, rateLimitType, rateLimitConfig);\n    if (!checkResult) {\n        rateLimitService.processRateLimitNotification(api, tenantId, level, rateLimitType, rateLimitConfig);\n    }\n    return checkResult;\n}", "CodeBleu_score": 58.9284058517549}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - inactivityTimeout;\n\t\n\tfor(Map.Entry<Integer, DTLSSession> entry : sessions.entrySet()) {\n\t\tDTLSSession session = entry.getValue();\n\t\tif(session.getLastActivityTime() < expirationTime) {\n\t\t\tsessions.remove(entry.getKey());\n\t\t\tlogger.info(\"Evicted session with id \" + entry.getKey() + \" from DTLS session map\");\n\t\t}\n\t}\n}", "CodeBleu_score": 37.6080710873171}, {"code": "public void evictTimeoutSessions(){\n\tlong now = System.currentTimeMillis();\n\tlong expirationTime = now - timeout;\n\tfor (Iterator<Map.Entry<String, DTLS_Session>> it = sessions.entrySet().iterator(); it.hasNext();) {\n\t\tMap.Entry<String, DTLS_Session> entry = it.next();\n\t\tDTLS_Session session = entry.getValue();\n\t\tif (session.getLastActivity() < expirationTime) {\n\t\t\tit.remove();\n\t\t\tlogger.info(\"Removed session: \" + entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 34.983833743761764}, {"code": "public void evictTimeoutSessions(){\n\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n  for (Map.Entry<String, DtlsSession> entry : sessions.entrySet()) {\n    if (entry.getValue().lastActivityTime < expirationTime) {\n      sessions.remove(entry.getKey());\n      log.info(\"Removing DTLS session with ID \" + entry.getKey() + \" due to inactivity.\");\n    }\n  }\n}", "CodeBleu_score": 44.26438869604495}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries != null && !timeseries.isEmpty()) {\n        List<TsKvEntry> tsKvEntryList = new ArrayList<>(timeseries.size());\n        timeseries.forEach((key, value) -> {\n            if (value != null && !value.isEmpty()) {\n                value.forEach(v -> {\n                    tsKvEntryList.add(new BasicTsKvEntry(System.currentTimeMillis(), parseValue(key, v)));\n                });\n            }\n        });\n        return tsKvEntryList;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 48.444155094645545}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries == null || timeseries.isEmpty()) {\n            return Collections.emptyList();\n        } else {\n            return timeseries.entrySet().stream().flatMap(entry -> {\n                String key = entry.getKey();\n                List<JsonNode> values = entry.getValue();\n                return values.stream().map(value -> new BasicTsKvEntry(parseValue(key, value), System.currentTimeMillis()));\n            }).collect(Collectors.toList());\n        }\n    }", "CodeBleu_score": 37.048334100664}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        } else {\n            return timeseries.entrySet().stream().flatMap(entry -> {\n                String key = entry.getKey();\n                return entry.getValue().stream().map(value -> new BasicTsKvEntry(parseValue(key, value), System.currentTimeMillis()));\n            }).collect(Collectors.toList());\n        }\n    }", "CodeBleu_score": 33.1088654281486}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tMap<String, Object> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", refreshToken);\n        String responseBody = sendPostRequest(requestMap, AUTH_ENDPOINT);\n        JsonNode tokenInfo = Json.parse(responseBody);\n        setTokenInfo(System.currentTimeMillis(), tokenInfo);\n    }", "CodeBleu_score": 44.6591708790273}, {"code": "public void refreshToken(){\n\tif (this.refreshToken == null) {\n            throw new IllegalStateException(\"Refresh token is not set\");\n        }\n\n        Map<String, Object> requestMap = new HashMap<String, Object>();\n        requestMap.put(\"refreshToken\", this.refreshToken);\n\n        JsonNode response = this.sendPostRequest(this.authEndpoint, requestMap);\n        this.setTokenInfo(System.currentTimeMillis(), response);\n    }", "CodeBleu_score": 34.93918019589608}, {"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", this.refreshToken);\n        JsonNode response = this.postRequest(requestMap, this.authEndpoint);\n        this.setTokenInfo(System.currentTimeMillis(), response);\n    }", "CodeBleu_score": 37.8953831934463}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\tlong ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", this.username);\n        loginRequest.put(\"password\", this.password);\n        JsonNode tokenInfo = this.sendPostRequest(\"/api/auth/login\", loginRequest);\n        this.setTokenInfo(ts, tokenInfo);\n    }", "CodeBleu_score": 63.85282985985833}, {"code": " private void doLogin(){\n\tlong ts = System.currentTimeMillis();\n        Map<String, Object> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", this.username);\n        loginRequest.put(\"password\", this.password);\n        try {\n            HttpResponse<JsonNode> response = Unirest.post(this.endpoint + \"/api/auth/login\")\n                    .header(\"Content-Type\", \"application/json\")\n                    .body(loginRequest)\n                    .asJson();\n            if (response.getStatus() == 200) {\n                setTokenInfo(ts, response.getBody());\n            } else {\n                throw new RuntimeException(\"Login failed: \" + response.getStatusText());\n            }\n        } catch (UnirestException e) {\n            throw new RuntimeException(\"Login failed: \" + e.getMessage());\n        }\n    }", "CodeBleu_score": 56.06406475213254}, {"code": " private void doLogin(){\n\ttry {\n            long ts = System.currentTimeMillis();\n            Map<String, Object> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", this.username);\n            loginRequest.put(\"password\", this.password);\n            String response = HttpUtil.post(this.authUrl, loginRequest);\n            JsonNode tokenInfo = JsonUtil.getJsonNodeFromString(response);\n            setTokenInfo(ts, tokenInfo);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "CodeBleu_score": 57.91248694670719}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        return Optional.of(deviceApi.getDeviceById(deviceId));\n    } catch (ApiException e) {\n        if (e.getCode() == 404) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 26.385100981167515}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t// Create the request object\n    RestRequest request = RestRequestBuilder.forCurrentContext()\n        .path(\"/api/device/{deviceId}\")\n        .resolveTemplate(\"deviceId\", deviceId.getValue())\n        .build();\n\n    // Send the request\n    RestResponse<Device> response = request.execute(Device.class);\n\n    // Return the device wrapped in an Optional\n    return response.getEntity();\n}", "CodeBleu_score": 40.06367627171519}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        return Optional.of(restTemplate.getForObject(\n                \"/api/device/{deviceId}\", Device.class, deviceId));\n    } catch (HttpClientErrorException e) {\n        if (e.getRawStatusCode() == 404) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 35.77952091301402}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\n\t\tDeviceWithCredentials request = new DeviceWithCredentials(device, credentials);\n\t\treturn Optional.of(deviceService.saveDeviceWithCredentials(request));\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.73656588535705}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tDeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n\n    Optional<Device> savedDevice = Optional.empty();\n\n    try {\n        savedDevice = Optional.of(restTemplate.postForObject(url + \"/device-with-credentials\", deviceWithCredentials, Device.class));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode().equals(HttpStatus.NOT_FOUND)) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n\n    return savedDevice;\n}", "CodeBleu_score": 59.84090368560378}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\n    DeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n    HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(deviceWithCredentials, headers);\n    ResponseEntity<Device> response = restTemplate.postForEntity(baseUrl + \"/api/device-with-credentials\", request, Device.class);\n    return Optional.of(response.getBody());\n  } catch (HttpClientErrorException e) {\n    if (e.getStatusCode().equals(HttpStatus.NOT_FOUND)) {\n      return Optional.empty();\n    }\n    throw e;\n  }\n}", "CodeBleu_score": 61.51467019099039}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n        const callbackMethod = method + 'Callback';\n        target[callbackMethod] = (collection, duration, callback) => {\n            const promises = [];\n            collection.forEach(element => {\n                const promise = new Promise(resolve => {\n                    setTimeout(() => {\n                        element[method]();\n                        resolve();\n                    }, duration);\n                });\n                promises.push(promise);\n            });\n            Promise.all(promises).then(() => {\n                if (callback) {\n                    callback();\n                }\n            });\n        };\n    });\n}", "CodeBleu_score": 32.13483577986164}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    target[`${method}Callback`] = (collection, callback, duration) => {\n      duration = duration || 1000;\n      if (typeof callback !== 'function') {\n        throw new Error('The callback must be a function.');\n      }\n      let promises = collection.map(item => {\n        return new Promise(resolve => {\n          setTimeout(() => {\n            item[method]();\n            resolve();\n          }, duration);\n        });\n      });\n      Promise.all(promises).then(() => {\n        callback();\n      });\n    };\n  });\n}", "CodeBleu_score": 41.712238009440064}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n    const callbackMethod = method + \"Callback\";\n    const reconcileMethod = method + \"Reconcile\";\n\n    target[callbackMethod] = (collection, duration, callback) => {\n      if (duration === undefined) {\n        duration = 1000;\n      }\n\n      if (typeof callback !== \"function\") {\n        callback = () => {};\n      }\n\n      const promises = [];\n      collection.forEach(element => {\n        promises.push(target[method](element, duration));\n      });\n\n      Promise.all(promises).then(callback);\n    };\n\n    target[reconcileMethod] = (collection) => {\n      return new Promise(resolve => {\n        target[callbackMethod](collection, 1000, resolve);\n      });\n    };\n  });\n}", "CodeBleu_score": 43.6662019620765}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tint err = 0;\n\tuint8_t i;\n\tuint8_t num_channels = 0;\n\tuint8_t num_active_channels = 0;\n\tuint8_t sample_size = 0;\n\tuint8_t num_samples = 0;\n\tuint8_t num_bytes = 0;\n\n\tif (sequence->channels == NULL) {\n\t\tLOG_ERR(\"Invalid channel list\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_channels = sequence->channels->channel_id + 1;\n\tnum_samples = sequence->channels->buffer_length;\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tif (sequence->channels->channel_id != ADC_CHANNEL_VDD) {\n\t\t\tnum_active_channels++;\n\t\t}\n\t}\n\n\tif (sequence->resolution == 8) {\n\t\tsample_size = 1;\n\t} else if (sequence->resolution == 12) {\n\t\tsample_size = 2;\n\t} else if (sequence->resolution == 14) {\n\t\tsample_size = 3;\n\t} else if (sequence->resolution == 16) {\n\t\tsample_size = 4;\n\t} else {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_bytes = num_samples * num_active_channels * sample_size;\n\n\tif (num_bytes > sequence->buffer_length) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\terr = -ENOMEM;\n\t}\n\n\treturn err;\n}", "CodeBleu_score": 42.37623522929167}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tuint32_t num_active_channels;\n\tuint32_t buffer_size_needed;\n\n\tnum_active_channels = adc_ad559x_get_num_active_channels(dev, sequence);\n\n\tbuffer_size_needed = num_active_channels * sizeof(uint16_t);\n\n\tif (sequence->options & ADC_SEQ_NO_DMA) {\n\t\tbuffer_size_needed *= 2;\n\t}\n\n\tif (sequence->buffer_size < buffer_size_needed) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 64.70166317414593}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tuint8_t active_channels = 0;\n\tuint8_t bytes_per_sample = 0;\n\tuint32_t needed_buffer_size = 0;\n\n\tif (sequence->resolution == 12) {\n\t\tbytes_per_sample = 2;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i] < config->num_channels) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = active_channels * bytes_per_sample;\n\n\tif (needed_buffer_size > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 43.38310908120366}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\tuint8_t channels;\n\tuint8_t channel_mask;\n\tuint8_t channel;\n\tuint8_t resolution;\n\tuint8_t buffer_size;\n\tuint8_t i;\n\tuint16_t *buffer;\n\n\t/* Check if the resolution matches the expected resolution */\n\tresolution = adc_ad559x_get_resolution(data->resolution);\n\tif (sequence->resolution != resolution) {\n\t\tLOG_ERR(\"Invalid resolution %d for device %s\",\n\t\t\tsequence->resolution, dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the specified channels are valid */\n\tchannels = POPCOUNT(sequence->channels);\n\tchannel_mask = 0;\n\tfor (i = 0; i < channels; i++) {\n\t\tchannel = find_lsb_set(sequence->channels) - 1;\n\t\tif (channel >= ADC_AD559X_CHANNELS) {\n\t\t\tLOG_ERR(\"Invalid channel %d for device %s\",\n\t\t\t\tchannel, dev->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tchannel_mask |= BIT(channel);\n\t}\n\n\t/* Validate the buffer size for the ADC read */\n\tbuffer_size = adc_ad559x_get_buffer_size(data->resolution);\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret != 0) {\n\t\tLOG_ERR(\"Invalid buffer size for device %s\", dev->name);\n\t\treturn ret;\n\t}\n\n\t/* Set the buffer and start the ADC read context */\n\tbuffer = sequence->buffer;\n\tdata->buffer = buffer;\n\tdata->buffer_size = buffer_size;\n\tdata->buffer_count = 0;\n\tdata->channel_mask = channel_mask;\n\tdata->repeat_buffer = sequence->options & ADC_", "CodeBleu_score": 57.457308689721245}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tuint8_t channel_mask;\n\tint ret;\n\n\tif (sequence->resolution != ADC_RESOLUTION) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tchannel_mask = sequence->channels;\n\n\tif (channels > config->channels) {\n\t\tLOG_ERR(\"Invalid channel mask\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn ret;\n\t}\n\n\tadc_context_lock(&data->ctx, false, NULL);\n\tdata->buffer = sequence->buffer;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\tadc_context_release(&data->ctx, ret);\n\n\treturn ret;\n}", "CodeBleu_score": 68.00193027556931}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_ad559x_dev_config *config = dev->config;\n\tint ret;\n\n\t/* Check if the resolution of the ADC sequence matches the expected resolution */\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the specified channels are valid */\n\tif (!adc_ad559x_validate_channel(dev, sequence->channels)) {\n\t\tLOG_ERR(\"invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate the buffer size for the ADC read */\n\tif (!adc_ad559x_validate_buffer_size(dev, sequence)) {\n\t\tLOG_ERR(\"invalid buffer size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Set the buffer */\n\tdata->buffer = sequence->buffer;\n\n\t/* Start the ADC read context */\n\tadc_context_start_read(&data->ctx, sequence);\n\n\t/* Wait for the read operation to complete */\n\tret = adc_context_wait_for_completion(&data->ctx);\n\n\t/* Return the result */\n\treturn ret;\n}", "CodeBleu_score": 60.78999467716106}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_dev_s *dev = ctx->dev;\n\n    /* Retrieve the ADC data structure from the context */\n    struct adc_dev_s *dev = ctx->dev;\n\n    /* Set the channels to be sampled */\n    dev->ad_ops->ao_setup(dev);\n\n    /* Initialize the repeat buffer with the data buffer */\n    memcpy(dev->ad_rbuf, dev->ad_buf, dev->ad_buf_len);\n\n    /* Release a semaphore to signal the start of sampling */\n    nxsem_post(&dev->ad_sem);\n}", "CodeBleu_score": 49.19342620214639}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_sampling_event *event = (struct adc_sampling_event *)ctx->event_data;\n    struct adc_sampling_event *event_next = (struct adc_sampling_event *)ctx->event_next;\n    struct adc_sampling_event *event_last = (struct adc_sampling_event *)ctx->event_last;\n    struct adc_sampling_event *event_repeat;\n    struct adc_sampling_event *event_repeat_next;\n    struct adc_sampling_event *event_repeat_last;\n    struct adc_sampling_event *event_repeat_current;\n    struct adc_sampling_event *event_repeat_current_next;\n    struct adc_sampling_event *event_repeat_current_last;\n    struct adc_sampling_event *event_repeat_current_next_next;\n    struct adc_sampling_event *event_repeat_current_next_last;\n    struct adc_sampling_event *event_repeat_current_last_next;\n    struct adc_sampling_event *event_repeat_current_last_last;\n    struct adc_sampling_event *event_repeat_current_last_last_next;\n    struct adc_sampling_event *event_repeat_current_last_last_last;\n    struct adc_sampling_event *event_repeat_current_last_last_last_next;\n    struct adc_sampling_event *event_repeat_current_last_last_last_last;\n    struct adc_sampling_event *event_repeat_current_last_last_last_last_next;\n    struct adc_sampling_event *event_repeat_current_last_last_last_last_last;\n    struct adc_sampling_event *event_repeat_current_last_last_last_last_last_next;\n    struct adc_sampling_event *event_repeat_current_last_last_last_last_last_last;\n    struct adc_sampling_event *event_repeat_current_last_last_last_last_last", "CodeBleu_score": 12.724918189571643}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_sampling_data *sampling_data;\n\n\tsampling_data = &ctx->sampling_data;\n\n\tsampling_data->repeat_buffer = sampling_data->buffer;\n\n\tsampling_data->sampling_index = 0;\n\n\tsampling_data->sampling_length = sampling_data->length;\n\n\tk_sem_give(&sampling_data->sem);\n}", "CodeBleu_score": 50.89517236554813}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tif (repeat_sampling) {\n        ctx->data->buffer = ctx->data->repeat_buffer;\n    }\n}", "CodeBleu_score": 43.8441172999915}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tstruct adc_data *adc_data = (struct adc_data *)ctx->data;\n\n    if (repeat_sampling) {\n        adc_data->buffer_ptr = adc_data->repeat_buffer;\n    }\n    else {\n        adc_data->buffer_ptr = adc_data->buffer;\n    }\n}", "CodeBleu_score": 49.660587734289514}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tif (repeat_sampling) {\n\t\tctx->data->buffer = ctx->data->repeat_buffer;\n\t}\n}", "CodeBleu_score": 42.20757641912009}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tstruct adc_ad559x_config *config = data->dev->config;\n\tuint16_t *buffer = data->buffer;\n\tuint8_t channel;\n\tuint8_t active_channels;\n\tuint8_t channel_mask;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tactive_channels = data->active_channels;\n\t\tchannel_mask = data->channel_mask;\n\t\tfor (channel = 0U; channel < ADC_AD559X_CHANNEL_COUNT; channel++) {\n\t\t\tif ((active_channels & BIT(channel)) == 0U) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &buffer[channel]);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"ADC channel %d read failed with error %d\", channel, ret);\n\t\t\t\tdata->error = 1U;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchannel_mask &= ~BIT(channel);\n\t\t}\n\n\t\tif (channel_mask == 0U) {\n\t\t\tk_sem_give(&data->sem);\n\t\t\tk_sem_give(&data->sync);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.556335771206136}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tuint16_t val;\n\tuint8_t channel;\n\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->acquisition_sem, K_FOREVER);\n\n\t\t/* Read channels */\n\t\tfor (channel = 0; channel < ADC_CHANNELS; channel++) {\n\t\t\tif (!BIT(channel) & data->active_channels) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\tdata->error = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->buffer[channel] = val;\n\t\t}\n\n\t\t/* Signal that sampling is done */\n\t\tk_sem_give(&data->completion_sem);\n\t}\n}", "CodeBleu_score": 52.74588096055185}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tstruct adc_ad559x_channel_cfg *channels = data->active_channels;\n\tuint16_t *buffer = data->buffer;\n\tuint8_t num_active_channels = data->num_active_channels;\n\tuint8_t channel;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < num_active_channels; channel++) {\n\t\t\tret = adc_ad559x_read_channel(data->dev, channels[channel].channel_id,\n\t\t\t\t\t\t      &buffer[channel]);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"ADC channel %d read failed with error %d\",\n\t\t\t\t\tchannels[channel].channel_id, ret);\n\t\t\t\tdata->state = ADC_AD559X_STATE_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tk_sem_give(&data->sync_sem);\n\t}\n}", "CodeBleu_score": 44.80680685801324}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc;\n\n\tk_sleep(K_USEC(config->ready_time));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\tif (reg_val & ADS1112_CONFIG_OS_MASK) {\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tk_sleep(K_USEC(100));\n\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (reg_val & ADS1112_CONFIG_OS_MASK) {\n\t\t\treturn 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 59.73958861943955}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val[3] = {0};\n\tuint8_t config_reg_val[3] = {0};\n\tint rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, config_reg_val);\n\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\tif (config_reg_val[0] & ADS1112_CONFIG_OS_MASK) {\n\t\tk_sleep(config->ready_time);\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, config_reg_val);\n\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\twhile (!(config_reg_val[0] & ADS1112_CONFIG_OS_MASK)) {\n\t\tk_sleep(100);\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, config_reg_val);\n\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_OUTPUT, reg_val);\n\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.18926830723108}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc = 0;\n\tint i = 0;\n\n\tk_msleep(config->ready_time);\n\n\tfor (i = 0; i < 10; i++) {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc != 0) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (reg_val & ADS1112_CONFIG_OS) {\n\t\t\tbreak;\n\t\t}\n\n\t\tk_usleep(100);\n\t}\n\n\tif (i == 10) {\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 52.88237704238651}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tint buffer_size = sequence->buffer_size;\n    int samplings = sequence->samplings;\n    int extra_samplings = sequence->options & ADC_SEQUENCE_EXTRA_SAMPLINGS ? 1 : 0;\n\n    if (buffer_size < samplings + extra_samplings) {\n        LOG_ERR(\"Buffer size %d is less than the number of samplings %d and extra samplings %d\", buffer_size, samplings, extra_samplings);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 44.78180333823247}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tif (sequence->buffer_size < sequence->samplings + sequence->options.extra_samplings) {\n        LOG_ERR(\"Buffer size is too small\");\n        return -EINVAL;\n    }\n    return 0;\n}", "CodeBleu_score": 32.0536756231604}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tint buffer_size = sequence->buffer_size;\n    int num_samplings = sequence->samplings;\n    int extra_samplings = sequence->options & ADC_SEQUENCE_EXTRASAMPLINGS_MASK;\n    int required_buffer_size = num_samplings + extra_samplings;\n\n    if (buffer_size < required_buffer_size) {\n        LOG_ERROR(\"Buffer size %d is less than required size %d\", buffer_size, required_buffer_size);\n        return -1;\n    }\n\n    return 0;\n}", "CodeBleu_score": 35.91955442127101}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint err;\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err != 0) {\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tif (wait) {\n\t\treturn ads1112_read_async(dev, sequence->channels, sequence->buffer);\n\t}\n\n\treturn ads1112_read_async(dev, sequence->channels, sequence->buffer);\n}", "CodeBleu_score": 61.85651056084915}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint err = 0;\n\n\tif (data->busy) {\n\t\tLOG_ERR(\"ADC busy\");\n\t\treturn -EBUSY;\n\t}\n\n\terr = ads1112_validate_sequence(dev, sequence);\n\tif (err) {\n\t\tLOG_ERR(\"Invalid sequence\");\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_length = sequence->buffer_length;\n\n\terr = ads1112_start_read(dev);\n\tif (err) {\n\t\tLOG_ERR(\"Failed to start ADC read\");\n\t\treturn err;\n\t}\n\n\tif (wait) {\n\t\terr = ads1112_wait_for_completion(dev);\n\t\tif (err) {\n\t\t\tLOG_ERR(\"ADC read failed\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.10837553466493}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tstruct ads1112_dev_data *dev_data = data->dev_data;\n\n\tif (ads1112_validate_sequence(dev, sequence) != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tdev_data->buffer = sequence->buffer;\n\tdev_data->buffer_size = sequence->buffer_size;\n\tdev_data->buffer_count = 0U;\n\n\treturn ads1112_adc_read_async(dev, sequence->channels);\n}", "CodeBleu_score": 47.708461231551595}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tint ret = 0;\n\tconst struct device *dev = NULL;\n\tchar *name = argv[1];\n\tconst struct codec_driver_api *api;\n\n\tif (!strcmp(name, \"playback\")) {\n\t\tdev = device_get_binding(PLAYBACK_DEV_NAME);\n\t} else if (!strcmp(name, \"capture\")) {\n\t\tdev = device_get_binding(CAPTURE_DEV_NAME);\n\t} else {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tapi = (const struct codec_driver_api *) dev->api;\n\n\tif (api->apply_prop) {\n\t\tret = api->apply_prop(dev);\n\t} else {\n\t\tshell_error(sh, \"apply_prop function not implemented\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (ret) {\n\t\tshell_error(sh, \"Error applying properties\");\n\t} else {\n\t\tshell_print(sh, \"Properties applied successfully\");\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 55.18590560902103}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tstruct device *dev;\n\tint ret;\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tLOG_ERR(\"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = codec_apply_prop(dev);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Error applying properties\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 58.063287428800514}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tstruct device *dev = NULL;\n\tint ret = 0;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tLOG_ERR(\"device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = codec_apply_prop(dev);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"failed to apply properties to %s\", argv[1]);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 54.09830050199884}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint err = 0;\n    struct mpxxdtyy_dev_data *dev_data = DEV_DATA(dev);\n    struct mpxxdtyy_dev_config *dev_config = DEV_CFG(dev);\n    struct mpxxdtyy_i2s_config i2s_cfg = {0};\n\n    if (cmd == DMIC_TRIGGER_START) {\n        if (dev_data->state == MPXXDTYY_STATE_READY) {\n            i2s_cfg.channels = dev_data->i2s_cfg.channels;\n            i2s_cfg.format = dev_data->i2s_cfg.format;\n            i2s_cfg.frame_clk_freq = dev_data->i2s_cfg.frame_clk_freq;\n            i2s_cfg.samp_freq = dev_data->i2s_cfg.samp_freq;\n            i2s_cfg.word_size = dev_data->i2s_cfg.word_size;\n\n            err = mpxxdtyy_i2s_configure(dev_config->i2s, &i2s_cfg);\n            if (err) {\n                LOG_ERR(\"Failed to configure I2S (err %d)\", err);\n                return err;\n            }\n\n            err = mpxxdtyy_i2s_trigger(dev_config->i2s, MPXXDTYY_I2S_DIR_RX, MPXXDTYY_I2S_MODE_CONTINUOUS);\n            if (err) {\n                LOG_ERR(\"Failed to trigger I2S (err %d)\", err);\n                return err;\n            }\n\n            dev_data->state = MPXXDTYY_STATE_ACTIVE;\n        } else {\n            LOG_ERR(\"Invalid state %d\", dev_data->state);\n            err = -EIO;\n        }\n    } else if (cmd == DMIC_TRIGGER_STOP) {\n        if (dev_data->state == MPXXDTYY_STATE_ACTIVE) {\n            err = mpxxd", "CodeBleu_score": 47.19837129097276}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tint err;\n  struct mpxxdtyy_dev_data *dev_data = dev->data;\n  struct mpxxdtyy_dev_cfg *dev_cfg = dev->config;\n  struct i2s_config i2s_cfg;\n  struct i2s_tdm_cfg i2s_tdm_cfg;\n  struct i2s_tdm_ch_cfg i2s_tdm_ch_cfg;\n  struct i2s_config_channel_mask i2s_cfg_ch_mask;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_all;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_none;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_1;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_2;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_3;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_4;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_5;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_6;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_7;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_8;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_9;\n  struct i2s_tdm_slot_mask i2s_tdm_slot_mask_10;\n  struct i2s_tdm_slot_mask i2s_tdm_", "CodeBleu_score": 12.994037758203161}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_dev_data *dev_data = dev->data;\n    struct mpxxdtyy_dev_cfg *dev_cfg = dev->config;\n\n    int ret;\n\n    switch (cmd) {\n\n        case DMIC_TRIGGER_START:\n            if (dev_data->state == MPXXDTYY_STATE_READY) {\n                dev_data->state = MPXXDTYY_STATE_ACTIVE;\n                ret = mpxxdtyy_i2s_start(dev);\n                if (ret < 0) {\n                    LOG_ERR(\"Failed to start device %s: %d\",\n                            dev->name, ret);\n                    dev_data->state = MPXXDTYY_STATE_ERROR;\n                    return ret;\n                }\n            } else {\n                LOG_ERR(\"Invalid state %d\", dev_data->state);\n                return -EIO;\n            }\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (dev_data->state == MPXXDTYY_STATE_ACTIVE) {\n                dev_data->state = MPXXDTYY_STATE_READY;\n                ret = mpxxdtyy_i2s_stop(dev);\n                if (ret < 0) {\n                    LOG_ERR(\"Failed to stop device %s: %d\",\n                            dev->name, ret);\n                    dev_data->state = MPXXDTYY_STATE_ERROR;\n                    return ret;\n                }\n            } else {\n                LOG_ERR(\"Invalid state %d\", dev_data->state);\n                return -EIO;\n            }\n            break;\n\n        default:\n            LOG_ERR(\"Invalid trigger command %d\", cmd);\n            return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 52.834477654446566}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (config->blink_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, cmd, config->mode);\n}", "CodeBleu_score": 68.35805603119172}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_BLINK_ON) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_BLINK_ON;\n\t}\n\n\tif (config->display_mode & AUXDISPLAY_HD44780_DISPLAY_MODE_2_LINE) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_2_LINE;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 60.452663176020216}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\tbool cursor = false;\n\tbool blink = false;\n\n\tif (config->cursor_enabled) {\n\t\tcursor = true;\n\t}\n\n\tif (config->blink_enabled) {\n\t\tblink = true;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (cursor) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_BLINK_ON;\n\t}\n\n\tif (config->display_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_MOVE;\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, cmd, config->mode);\n}", "CodeBleu_score": 67.72968924754818}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\tif (config->busy_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get(config->busy_port, config->busy_pin);\n}", "CodeBleu_score": 69.89134691668383}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tstruct auxdisplay_itron_data *data = dev->data;\n    int ret = 0;\n    int status = 0;\n\n    if (data->gpio_busy_port == NULL) {\n        ret = -ENOTSUP;\n    } else {\n        status = gpio_pin_get(data->gpio_busy_port, data->gpio_busy_pin);\n        if (status < 0) {\n            LOG_ERR(\"Error reading GPIO pin %d\", data->gpio_busy_pin);\n            ret = status;\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 47.352474389598136}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tstruct auxdisplay_itron_data *data = dev->data;\n    const struct auxdisplay_itron_config *config = dev->config;\n    int ret;\n\n    if (config->busy_port == NULL) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get(config->busy_port, config->busy_pin);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to get busy pin status\");\n        return ret;\n    }\n\n    if (ret) {\n        LOG_ERR(\"Busy pin is high\");\n        return -EBUSY;\n    }\n\n    return 0;\n}", "CodeBleu_score": 62.8750861665196}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\tint ret;\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\tret = i2c_write(data->i2c_master, buf, sizeof(buf), config->i2c_address);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tk_sleep(K_MSEC(config->delay_before_returning_from_special_command_ms));\n\n\treturn 0;\n}", "CodeBleu_score": 61.1354406050914}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tint ret;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = data->config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tret = i2c_write(data->i2c_dev, buffer, 2, data->config->i2c_address);\n\tk_sleep(data->config->delay_after_special_command_ms);\n\treturn ret;\n}", "CodeBleu_score": 50.99151892996643}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t command_buffer[2];\n\n\tcommand_buffer[0] = data->config->special_command_prefix;\n\tcommand_buffer[1] = command;\n\n\treturn i2c_write(data->i2c, command_buffer, 2, data->config->i2c_address);\n}", "CodeBleu_score": 49.72380102663249}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *data_p = dev->data;\n\tint ret = 0;\n\n\tif (offset + size > data_p->size) {\n\t\tLOG_ERR(\"Read out of bounds: offset %zu size %zu\", offset, size);\n\t\tret = -EINVAL;\n\t} else if (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Read from invalid memory\");\n\t\tret = -EIO;\n\t} else {\n\t\tmemcpy(data, data_p->mem + offset, size);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 56.30957327559325}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *data_ptr = dev->data;\n\tint ret = 0;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_ptr->read_callback) {\n\t\tret = data_ptr->read_callback(dev, offset, size, data);\n\t} else {\n\t\tmemcpy(data, data_ptr->data + offset, size);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 58.23194376710865}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *data_ptr = dev->data;\n\tuint8_t *data_ptr_local = data_ptr->data;\n\tint ret = 0;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > data_ptr->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &data_ptr_local[offset], size);\n\n\treturn ret;\n}", "CodeBleu_score": 48.71022965933868}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\tint ret = 0;\n\n\t/* Check if the write size is valid */\n\tif (size > 1) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM */\n\tif ((offset + size) > data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state */\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory */\n\tmemcpy(&data->mem[offset], data, size);\n\n\treturn ret;\n}", "CodeBleu_score": 51.997518331081714}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data_p = dev->data;\n\tuint8_t *mem_p = data_p->mem;\n\tuint8_t *mem_end_p = mem_p + data_p->size;\n\n\t/* Check if the write size is valid */\n\tif (size == 0 || size > data_p->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM */\n\tif (offset > data_p->size - size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state */\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory */\n\tmemcpy(mem_p + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 61.446756284164024}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data->mem + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 65.4624357873082}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc > 1) {\n\t\tLOG_ERR(\"Invalid arguments: %s\", argv[1]);\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(DT_LABEL(DT_INST(0, zephyr_bbram)));\n\tif (*bbram_dev == NULL) {\n\t\tLOG_ERR(\"Device not found: %s\", DT_LABEL(DT_INST(0, zephyr_bbram)));\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 59.54712422335051}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.3361941712862}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tconst struct device *dev;\n\tint rc;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device name missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\trc = bbram_bind(dev);\n\tif (rc) {\n\t\tshell_error(sh, \"Failed to bind to device %s\", argv[1]);\n\t\treturn rc;\n\t}\n\n\t*bbram_dev = dev;\n\treturn 0;\n}", "CodeBleu_score": 66.0430227132687}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tint bytes_read = 0;\n  int remaining_bytes = 0;\n  int rc = 0;\n  struct h4_dev_data *dev_data = DEV_DATA(dev);\n  struct h4_rx_buf *rx_buf = &dev_data->rx_buf;\n  struct h4_hdr *hdr = &rx_buf->hdr;\n  remaining_bytes = hdr->len - rx_buf->read_pos;\n  rc = uart_fifo_read(dev, hdr->data + rx_buf->read_pos, remaining_bytes);\n  if (rc < 0) {\n    LOG_ERR(\"Unable to read from UART FIFO (%d)\", rc);\n  } else {\n    bytes_read = rc;\n    rx_buf->read_pos += bytes_read;\n  }\n}", "CodeBleu_score": 49.59492765821294}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tuint8_t buf[4];\n    int bytes_read;\n    int remaining = 4 - h4_rx_buf_bytes_read;\n\n    bytes_read = uart_fifo_read(dev, buf, remaining);\n    if (bytes_read < 0) {\n        LOG_ERR(\"Error reading header from UART (%d)\", bytes_read);\n    } else {\n        memcpy(h4_rx_buf + h4_rx_buf_bytes_read, buf, bytes_read);\n        h4_rx_buf_bytes_read += bytes_read;\n    }\n}", "CodeBleu_score": 46.02797243383387}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tint rc;\n    uint8_t buf[1];\n    uint8_t *hdr = h4_buf.hdr;\n    uint8_t *buf_ptr = hdr + h4_buf.hdr_len;\n    uint32_t remaining = h4_buf.hdr_len - h4_buf.hdr_read;\n\n    if (remaining == 0) {\n        return;\n    }\n\n    rc = uart_fifo_read(dev, buf, 1);\n    if (rc < 0) {\n        LOG_ERR(\"Failed to read header byte (err %d)\", rc);\n        return;\n    }\n\n    *buf_ptr = buf[0];\n    h4_buf.hdr_read++;\n    remaining--;\n    buf_ptr++;\n\n    if (remaining == 0) {\n        h4_buf.hdr_len = 0;\n        h4_buf.hdr_read = 0;\n        h4_buf.hdr_state = H4_HDR_STATE_LEN;\n    }\n}", "CodeBleu_score": 45.78127559020745}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n\tsize_t read_len;\n\tint ret;\n\n\tret = uart_fifo_read(uart, buf, sizeof(buf), &read_len);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to read from UART (err %d)\", ret);\n\t\treturn 0;\n\t}\n\n\treturn read_len;\n}", "CodeBleu_score": 55.31557540264737}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n    size_t read_len;\n    int ret;\n\n    if (len > 33) {\n        len = 33;\n    }\n\n    ret = uart_read(uart, buf, len, &read_len);\n    if (ret != 0) {\n        LOG_ERR(\"Failed to discard %d bytes\", len);\n        return 0;\n    }\n\n    return read_len;\n}", "CodeBleu_score": 53.353078142619715}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n    size_t read_bytes;\n\n    read_bytes = uart_fifo_read(uart, buf, sizeof(buf));\n    if (read_bytes == 0) {\n        LOG_ERR(\"Failed to read from UART FIFO\");\n    }\n    return read_bytes;\n}", "CodeBleu_score": 47.10908127073083}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tstruct zbus_observer *obs;\n\tuint32_t highest_prio = 0xffffffff;\n\n\tzbus_chan_lock(chan);\n\n\tzassert_true(chan->observers != NULL, \"Channel has no observers!\");\n\n\tfor (obs = chan->observers; obs != NULL; obs = obs->next) {\n\t\tif (obs->enabled && obs->priority < highest_prio) {\n\t\t\thighest_prio = obs->priority;\n\t\t}\n\t}\n\n\tchan->highest_prio = highest_prio;\n\n\tzbus_chan_unlock(chan);\n}", "CodeBleu_score": 24.174135297879793}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tuint8_t highest_observer_priority = 0xff;\n    bool observer_enabled = false;\n    struct zbus_observer *observer = NULL;\n\n    for (observer = chan->observer_list; observer != NULL; observer = observer->next) {\n        if (observer->priority < highest_observer_priority && observer->enabled) {\n            highest_observer_priority = observer->priority;\n            observer_enabled = true;\n        }\n    }\n\n    chan->highest_observer_priority = highest_observer_priority;\n    chan->observer_enabled = observer_enabled;\n}", "CodeBleu_score": 28.992668617138033}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tstruct zbus_observer *obs;\n    uint8_t highest = 0xff;\n\n    zbus_lock(&chan->lock);\n    zbus_list_for_each_entry(obs, &chan->observers, node) {\n        if (obs->enabled && obs->priority < highest)\n            highest = obs->priority;\n    }\n    chan->highest_observer_priority = highest;\n    zbus_unlock(&chan->lock);\n}", "CodeBleu_score": 15.702366766736104}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = zbus_channel_observation_count();\n\n\t\tfor (int16_t i = 0; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.33565340375118}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_observations_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_observations_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.005298392335863}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_channel_observation_end_idx;\n\n\t\tfor (int16_t i = _zbus_channel_observation_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs != obs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.8509960096328}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tZBUS_ASSERT(obs != NULL);\n\n\tzbus_thread_t *thread = zbus_thread_get_current();\n\tZBUS_ASSERT(thread != NULL);\n\n\tzbus_thread_prio_t prio = zbus_thread_get_prio(thread);\n\tzbus_thread_prio_t min_prio = zbus_thread_get_min_prio(thread);\n\n\tzbus_thread_prio_set(thread, ZBUS_THREAD_PRIO_MIN);\n\n\tupdate_all_channels_hop(obs);\n\n\tzbus_thread_prio_set(thread, prio);\n\n\treturn 0;\n}", "CodeBleu_score": 43.976454804829025}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tk_spinlock_key_t key = k_spin_lock(&zbus_spinlock);\n\tZBUS_ASSERT(obs != NULL, \"zbus observer is NULL\");\n\n\tz_thread_priority_set(k_current_get(), K_PRIO_PREEMPT(ZBUS_THREAD_PRIORITY));\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&zbus_spinlock, key);\n\treturn 0;\n}", "CodeBleu_score": 28.59519295994577}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tif (z_is_in_isr()) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!obs) {\n\t\treturn -EINVAL;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\tobs->priority = k_thread_priority_get(k_current_get());\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 32.046184764719335}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tint err = 0;\n\tint prio = 0;\n\tk_timepoint_t end_time = 0;\n\n\tif (k_is_in_isr()) {\n\t\tend_time = sys_time_timeout_end_calc(timeout);\n\t} else {\n\t\tend_time = sys_timepoint_now();\n\t\tsys_timepoint_add_ms(end_time, timeout);\n\t}\n\n\terr = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 61.30516363492219}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tint err = 0;\n\tint prio = 0;\n\n\tk_timepoint_t end_time = _ZBUS_TIMEOUT_TO_END_TIME(timeout);\n\n\t/* Adjusting the timeout if in an ISR */\n\tif (k_is_in_isr()) {\n\t\tend_time = _ZBUS_TIMEOUT_TO_END_TIME(K_NO_WAIT);\n\t}\n\n\terr = chan_lock(chan, end_time, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 59.99767887837677}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tint err = 0;\n\tint prio = 0;\n\tk_timepoint_t end_time = K_TIMEPOINT_INITIALIZER;\n\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = ZBUS_ISR_TIMEOUT;\n\t}\n\n\tend_time = sys_timepoint_now() + timeout;\n\n\terr = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 73.79207687111956}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tif (enable) {\n    if (Int & ETH_INT_RX_BIT) {\n      ETH->INT_EN |= ETH_INT_RX_BIT;\n      ETH->RX_INT_EN = ETH->RX_INT_EN | ETH_RX_INT_EN_BITS;\n    }\n    if (Int & ETH_INT_TX_BIT) {\n      ETH->INT_EN |= ETH_INT_TX_BIT;\n      ETH->TX_INT_EN = ETH->TX_INT_EN | ETH_TX_INT_EN_BITS;\n    }\n    if (Int & ETH_INT_ERR_BIT) {\n      ETH->INT_EN |= ETH_INT_ERR_BIT;\n      ETH->ERR_INT_EN = ETH->ERR_INT_EN | ETH_ERR_INT_EN_BITS;\n    }\n  } else {\n    if (Int & ETH_INT_RX_BIT) {\n      ETH->INT_EN &= ~ETH_INT_RX_BIT;\n      ETH->RX_INT_EN = ETH->RX_INT_EN & ~ETH_RX_INT_EN_BITS;\n    }\n    if (Int & ETH_INT_TX_BIT) {\n      ETH->INT_EN &= ~ETH_INT_TX_BIT;\n      ETH->TX_INT_EN = ETH->TX_INT_EN & ~ETH_TX_INT_EN_BITS;\n    }\n    if (Int & ETH_INT_ERR_BIT) {\n      ETH->INT_EN &= ~ETH_INT_ERR_BIT;\n      ETH->ERR_INT_EN = ETH->ERR_INT_EN & ~ETH_ERR_INT_EN_BITS;\n    }\n  }\n}", "CodeBleu_score": 41.59650944434782}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t/* Check the parameters */\n  assert_param(IS_ETH_INT(Int));\n  assert_param(IS_BOOL(enable));\n  if (enable) {\n    /* Enable the selected ETHERNET interrupts */\n    if (Int & ETH_INT_RX_STA_INT) {\n      ETH->INT_EN |= ETH_INT_RX_STA_INT;\n    }\n    if (Int & ETH_INT_TX_STA_INT) {\n      ETH->INT_EN |= ETH_INT_TX_STA_INT;\n    }\n    if (Int & ETH_INT_RX_OVF_INT) {\n      ETH->INT_EN |= ETH_INT_RX_OVF_INT;\n    }\n    if (Int & ETH_INT_RX_ERR_INT) {\n      ETH->INT_EN |= ETH_INT_RX_ERR_INT;\n    }\n    if (Int & ETH_INT_TX_ERR_INT) {\n      ETH->INT_EN |= ETH_INT_TX_ERR_INT;\n    }\n    if (Int & ETH_INT_TX_STA_INT) {\n      ETH->INT_EN |= ETH_INT_TX_STA_INT;\n    }\n    if (Int & ETH_INT_RX_INT) {\n      ETH->INT_EN |= ETH_INT_RX_INT;\n    }\n    if (Int & ETH_INT_TX_INT) {\n      ETH->INT_EN |= ETH_INT_TX_INT;\n    }\n    if (Int & ETH_INT_RX_BUF_INT) {\n      ETH->INT_EN |= ETH_INT_RX_BUF_INT;\n    }\n    if (Int & ETH_INT_TX_BUF_INT) {\n      ETH->INT_EN |= ETH_INT_TX_BUF_INT;\n    }\n    if (Int & ETH_INT_TX_REQ_INT) {\n      ETH->", "CodeBleu_score": 38.36979817836977}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tif (enable) {\n    /* Enable the selected interrupts */\n    if (Int & ETH_INT_RX_BIT) {\n      ETH->INTEN |= ETH_INT_RX;\n    }\n    if (Int & ETH_INT_TX_BIT) {\n      ETH->INTEN |= ETH_INT_TX;\n    }\n    if (Int & ETH_INT_RX_OVERRUN_BIT) {\n      ETH->INTEN |= ETH_INT_RX_OVERRUN;\n    }\n    if (Int & ETH_INT_TX_UNDERRUN_BIT) {\n      ETH->INTEN |= ETH_INT_TX_UNDERRUN;\n    }\n    if (Int & ETH_INT_RX_ERROR_BIT) {\n      ETH->INTEN |= ETH_INT_RX_ERROR;\n    }\n    if (Int & ETH_INT_TX_ERROR_BIT) {\n      ETH->INTEN |= ETH_INT_TX_ERROR;\n    }\n    if (Int & ETH_INT_BUS_ERROR_BIT) {\n      ETH->INTEN |= ETH_INT_BUS_ERROR;\n    }\n    if (Int & ETH_INT_ABNORMAL_SUMMARY_BIT) {\n      ETH->INTEN |= ETH_INT_ABNORMAL_SUMMARY;\n    }\n    if (Int & ETH_INT_NORMAL_SUMMARY_BIT) {\n      ETH->INTEN |= ETH_INT_NORMAL_SUMMARY;\n    }\n    if (Int & ETH_INT_WAKEUP_BIT) {\n      ETH->INTEN |= ETH_INT_WAKEUP;\n    }\n  } else {\n    /* Disable the selected interrupts */\n    if (Int & ETH_INT_RX_BIT) {\n      ETH->INTEN &= ~ETH_INT_RX;\n    }\n    if (Int & ETH_INT_TX_BIT) {\n      ETH->INT", "CodeBleu_score": 40.3779538687487}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc;\n\tuint32_t i = 0;\n\n\tpTxDesc = (ETH_TX_DESC *)(ETH_BASE_ADDR + ETH_DMA_TRANS_DESC_REG);\n\n\twhile (i < ETH_TX_DESC_CNT) {\n\t\tif (pTxDesc->tdes0.tdes0_own == 0) {\n\t\t\treturn pTxDesc;\n\t\t}\n\n\t\tpTxDesc++;\n\t\ti++;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 32.29554424116932}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc = (ETH_TX_DESC *) (ETH_BASE + ETH_TX_DESC_OFFSET);\n    ETH_TX_DESC *pCurrentTxDesc = pTxDesc;\n    uint32_t u32CurrentTxDesc = ETH->ETH_TDT;\n    uint32_t u32NextTxDesc;\n\n    /* Check if the descriptor is owned by the device */\n    while (pCurrentTxDesc->ETH_TDES0_OWN == 1) {\n        /* Get the next descriptor */\n        u32NextTxDesc = pCurrentTxDesc->ETH_TDES0_NDES;\n\n        /* Check if the descriptor is the last one */\n        if (u32NextTxDesc == u32CurrentTxDesc) {\n            /* No free descriptors */\n            return 0;\n        }\n\n        /* Get the next descriptor */\n        pCurrentTxDesc = (ETH_TX_DESC *) (ETH_BASE + u32NextTxDesc);\n    }\n\n    /* Return the current (free) descriptor */\n    return pCurrentTxDesc;\n}", "CodeBleu_score": 35.87840067984443}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc;\n  uint32_t i;\n\n  pTxDesc = (ETH_TX_DESC *)(ETH_BASE + ETH_TDTADDR_OFFSET);\n\n  for (i = 0; i < ETH_TXBUFNB; i++) {\n    if ((pTxDesc->tdes0 & ETH_TDES0_OWN) == 0) {\n      return pTxDesc;\n    }\n    pTxDesc++;\n  }\n\n  return 0;\n}", "CodeBleu_score": 33.68992010646862}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\tRT_ASSERT(device != RT_NULL);\n\n    rt_err_t result = RT_EOK;\n\n    struct cyp_adc_device *cyp_adc_device = (struct cyp_adc_device *)device;\n    CY_CSDIDAC_T *cyp_dac_base = (CY_CSDIDAC_T *)cyp_adc_device->cyp_dac_base;\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (cyp_dac_base == RT_NULL)\n    {\n        LOG_E(\"cyp_adc_convert: CYP_DAC_BASE is null\");\n        result = -RT_EIO;\n    }\n    else\n    {\n        if (Cy_CSDIDAC_OutputEnable(cyp_dac_base, cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS)\n        {\n            LOG_E(\"cyp_adc_convert: Cy_CSDIDAC_OutputEnable failed\");\n            result = -RT_EIO;\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 52.31682270931112}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_err_t result = RT_EOK;\n    cy_rslt_t status;\n    rt_uint32_t cyp_dac_channel = 0;\n    cy_stc_csd_dac_config_t cyp_dac_config;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    cyp_dac_config.outputMode = CY_CSDIDAC_OUTPUT_MODE_UNSIGNED_12;\n    cyp_dac_config.outputRange = CY_CSDIDAC_OUTPUT_RANGE_VREF;\n    cyp_dac_config.reference = CY_CSDIDAC_REFERENCE_VDDA;\n    cyp_dac_config.deglitchMode = CY_CSDIDAC_DEGLITCH_DISABLE;\n    cyp_dac_config.deglitchCycles = 0UL;\n    cyp_dac_config.outputSwingMode = CY_CSDIDAC_OUTPUT_SWING_DISABLE;\n    cyp_dac_config.outputSwingLevel = CY_CSDIDAC_OUTPUT_SWING_LEVEL_LOW;\n\n    status = Cy_CSDIDAC_Init(device->parent.user_data, cyp_dac_channel, &cyp_dac_config);\n\n    if (status != CY_RSLT_SUCCESS) {\n        rt_kprintf(\"cy_csd_dac_init failed, status: 0x%08X", "CodeBleu_score": 48.66309450218969}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_err_t result = RT_EOK;\n    cyp_dac_device_t *cyp_dac_device = (cyp_dac_device_t *)device;\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    RT_ASSERT(cyp_dac_device != RT_NULL);\n    RT_ASSERT(cyp_dac_device->cyp_dac_base != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_dac_device->cyp_dac_base, cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"cyp_adc_convert failed!\");\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 52.1285866713973}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tif (addr > FLASH_END_ADDRESS)\n\t{\n\t\tLOG_E(\"read flash error: read address 0x%08x is larger than flash size 0x%08x\", addr, FLASH_END_ADDRESS);\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (addr + size > FLASH_END_ADDRESS)\n\t{\n\t\tLOG_E(\"read flash error: read out of flash size. Read address is 0x%08x, size is %d\", addr, size);\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (addr % 4 != 0)\n\t{\n\t\tLOG_E(\"read flash error: read address 0x%08x is not 4-byte aligned\", addr);\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (size % 4 != 0)\n\t{\n\t\tLOG_E(\"read flash error: read size %d is not 4-byte aligned\", size);\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (buf == RT_NULL)\n\t{\n\t\tLOG_E(\"read flash error: read buffer is NULL\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (size == 0)\n\t{\n\t\tLOG_E(\"read flash error: read size is 0\");\n\t\treturn -RT_ERROR;\n\t}\n\n\tif (size > FLASH_PAGE_SIZE)\n\t{\n\t\tLOG_E(\"read flash error: read size %d is larger than page size %d\", size, FLASH_PAGE_SIZE);\n\t\treturn -RT_ERROR;\n\t}\n\n\t// Check if the buffer is 4-byte aligned\n\tif (((rt_uint32_t) buf) % 4 != 0)\n\t{\n\t\tLOG_E(\"read flash error: read buffer is not 4-byte aligned\");\n\t\treturn -RT_ERROR;\n\t}\n\n\t// Check if the buffer is in RAM\n\tif (((rt_uint32_t) buf) < 0x20000", "CodeBleu_score": 32.747748437331076}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t i;\n    rt_uint32_t end_addr = addr + size;\n\n    if (end_addr > FLASH_END_ADDR) {\n        return -RT_ERROR;\n    }\n\n    for (i = 0; i < size; i++) {\n        *(buf + i) = *((rt_uint8_t *)(FLASH_START_ADDR + addr + i));\n    }\n\n    return size;\n}", "CodeBleu_score": 47.33905117222616}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t i;\n\trt_uint8_t *p;\n\n\tif (addr + size > IFX_FLASH_END_ADDR) {\n\t\tLOG_E(\"Reading from flash memory address 0x%08x would exceed flash memory's end address 0x%08x\", addr + size, IFX_FLASH_END_ADDR);\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (i = 0, p = (rt_uint8_t *)addr; i < size; i++, p++) {\n\t\t*buf++ = *p;\n\t}\n\n\treturn i;\n}", "CodeBleu_score": 49.7529760740869}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tcyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 21.332773143826312}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tcyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n  return cyhal_timer_read(obj);\n}", "CodeBleu_score": 20.968607734802763}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\trt_uint32_t count;\n    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    count = cyhal_timer_read(obj);\n    return count;\n}", "CodeBleu_score": 74.73932070265008}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\tint ret;\n\n\twhile (true) {\n\t\tret = k_mutex_lock(&dfs_lock_mutex, K_FOREVER);\n\t\tif (ret == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t__ASSERT(ret == -EBUSY, \"k_mutex_lock failed with error %d\", ret);\n\t}\n}", "CodeBleu_score": 34.96341866827757}, {"code": "void dfs_lock(void){\n\twhile (1) {\n\t\tif (k_mutex_lock(&dfs_lock_mutex, K_FOREVER) == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* An error occurred */\n\t\t__ASSERT(0, \"Mutex lock failed\");\n\t}\n}", "CodeBleu_score": 20.294189463491914}, {"code": "void dfs_lock(void){\n\twhile (1) {\n        int ret = pthread_mutex_trylock(&dfs_lock_mutex);\n        if (ret == 0)\n            return;\n        if (ret != EBUSY)\n            dfs_assert(0, \"mutex lock failed: %s\", strerror(ret));\n        sleep(1);\n    }\n}", "CodeBleu_score": 40.58305027805701}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint index;\n    int fd;\n\n    if (startfd < 0)\n    {\n        startfd = 0;\n    }\n\n    for (index = startfd; index < fdt->maxfd; index++)\n    {\n        if (fdt->fds[index] == NULL)\n        {\n            return index;\n        }\n    }\n\n    fd = fd_slot_expand(fdt, index);\n    if (fd < 0)\n    {\n        return -1;\n    }\n\n    return fd;\n}", "CodeBleu_score": 47.762820569970955}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint index;\n\n    for (index = startfd; index < fdt->maxfd; index++)\n    {\n        if (fdt->fds[index] == NULL)\n        {\n            return index;\n        }\n    }\n\n    return fd_slot_expand(fdt, index);\n}", "CodeBleu_score": 31.26295581790493}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            return fd;\n        }\n    }\n\n    /* no empty slot found, try to expand the fd table */\n    fd = fd_slot_expand(fdt, fd);\n    if (fd >= 0)\n    {\n        return fd;\n    }\n\n    return -1;\n}", "CodeBleu_score": 39.76595564211385}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\trt_uint32_t index;\n\n    if (error < 0)\n        error = -error;\n\n    for (index = 0; index < sizeof(error_lookup) / sizeof(error_lookup[0]); index++) {\n        if (error_lookup[index].error_code == error)\n            return error_lookup[index].error_string;\n    }\n\n    return \"EUNKNOWN\";\n}", "CodeBleu_score": 68.19115627699605}, {"code": "const char *rt_strerror(rt_err_t error){\n\trt_uint32_t index;\n    rt_uint32_t err_num;\n\n    err_num = (error < 0) ? -error : error;\n\n    for (index = 0; index < sizeof(error_desc) / sizeof(error_desc[0]); index++) {\n        if (err_num == error_desc[index].num) {\n            return error_desc[index].desc;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 53.42951207856779}, {"code": "const char *rt_strerror(rt_err_t error){\n\trt_uint32_t index;\n    rt_uint32_t num;\n    rt_uint32_t start;\n    rt_uint32_t end;\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    start = 0;\n    end = sizeof(error_table) / sizeof(error_table[0]);\n    while (start < end) {\n        num = start + (end - start) / 2;\n        if (error_table[num].num == error) {\n            return error_table[num].str;\n        } else if (error_table[num].num < error) {\n            start = num + 1;\n        } else {\n            end = num;\n        }\n    }\n\n    return \"EUNKNOWN\";\n}", "CodeBleu_score": 55.2326348668845}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result;\n  rt_base_t level;\n  rt_thread_idle_hook_t *idle_hook;\n\n  result = -RT_EFULL;\n\n  level = rt_hw_interrupt_disable();\n\n  for (idle_hook = &rt_thread_idle_gethook(); idle_hook != &rt_thread_idle_gethook() + sizeof(rt_thread_idle_hook_t) / sizeof(rt_thread_idle_hook_t); idle_hook++) {\n    if (idle_hook->idle_hook == RT_NULL) {\n      idle_hook->idle_hook = hook;\n      result = RT_EOK;\n      break;\n    }\n  }\n\n  rt_hw_interrupt_enable(level);\n\n  return result;\n}", "CodeBleu_score": 46.627983618645466}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t lock;\n    rt_err_t result = -RT_EFULL;\n    struct rt_thread *thread;\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* try to find an empty slot */\n    for (thread = &thread_idle; thread != RT_NULL; thread = thread->next) {\n        if (thread->idle_hook == RT_NULL) {\n            thread->idle_hook = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    return result;\n}", "CodeBleu_score": 48.68463976245111}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t lock;\n    rt_err_t  result = RT_EFULL;\n    rt_uint8_t i;\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i].hook == RT_NULL) {\n            idle_hook_list[i].hook = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    return result;\n}", "CodeBleu_score": 62.11424771034238}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_base_t lock;\n    register rt_uint8_t i;\n    rt_err_t ret = -RT_ERROR;\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* find specified hook */\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_thread_idle_hook_list[i] == hook) {\n            rt_thread_idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    return ret;\n}", "CodeBleu_score": 74.41884314560376}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_base_t lock;\n    rt_err_t  result;\n    register rt_uint8_t i;\n\n    result = RT_EOK;\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* find the specified hook */\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_thread_idle_hook_list[i] == hook) {\n            /* set the entry to null */\n            rt_thread_idle_hook_list[i] = RT_NULL;\n            break;\n        }\n    }\n\n    /* check if the hook is found */\n    if (i == RT_IDLE_HOOK_LIST_SIZE) {\n        /* not found */\n        result = -RT_ERROR;\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    return result;\n}", "CodeBleu_score": 62.17336052993989}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_err_t result;\n  rt_base_t lock[2];\n  register rt_thread_t thread;\n  register rt_uint8_t index;\n  register rt_uint8_t found;\n\n  result = RT_EOK;\n  found = 0;\n  thread = rt_current_thread;\n  lock[0] = thread->spinlock_nest;\n  lock[1] = thread->resources->lock[1];\n\n  /* disable interrupt */\n  RT_DEBUG_IN_THREAD_CTXT(thread);\n  RT_DEBUG_IN_ISR_CTXT;\n\n  /* lock scheduler */\n  rt_enter_critical();\n\n  /* find the hook */\n  for (index = 0; index < RT_IDLE_HOOK_LIST_SIZE; index++) {\n    if (rt_thread_idle_hook_list[index] == hook) {\n      found = 1;\n      break;\n    }\n  }\n\n  /* not found */\n  if (found == 0) {\n    result = -RT_ERROR;\n    goto __exit;\n  }\n\n  /* remove the hook */\n  rt_thread_idle_hook_list[index] = RT_NULL;\n\n__exit:\n  /* unlock scheduler */\n  rt_exit_critical();\n\n  /* enable interrupt */\n  if (lock[0] != 0) {\n    rt_exit_critical_from_isr(lock[0]);\n  }\n  if (lock[1] != 0) {\n    rt_exit_critical_from_isr(lock[1]);\n  }\n\n  return result;\n}", "CodeBleu_score": 42.13997266911159}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\tstruct rt_thread *thread;\n    struct rt_thread *next;\n\n    /* ensure the scheduler is unlocked */\n    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (\"resume all suspended threads\n\"));\n\n    /* suspend all threads */\n    rt_enter_critical();\n\n    /* set error code */\n    for (thread = (struct rt_thread *)susp_list->next;\n         thread != (struct rt_thread *)susp_list;\n         thread = (struct rt_thread *)thread->tlist.next) {\n        thread->error = thread_error;\n    }\n\n    /* resume all suspended threads */\n    for (thread = (struct rt_thread *)susp_list->next;\n         thread != (struct rt_thread *)susp_list;\n         thread = next) {\n        next = (struct rt_thread *)thread->tlist.next;\n\n        /* remove thread from suspended list */\n        rt_slist_remove(&(thread->tlist));\n\n        /* resume thread */\n        thread->stat = RT_THREAD_READY;\n        rt_schedule();\n    }\n\n    rt_exit_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 34.950075983023176}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\tstruct rt_thread *thread;\n    register rt_base_t temp;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* disable interrupt */\n    temp = rt_hw_interrupt_disable();\n\n    /* resume all suspended thread */\n    while (!rt_list_isempty(susp_list)) {\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n        rt_schedule_insert_thread(thread);\n        rt_list_remove(&(thread->tlist));\n        thread->error = thread_error;\n        rt_thread_resume(thread);\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(temp);\n\n    return RT_EOK;\n}", "CodeBleu_score": 40.046306175569526}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\tstruct rt_thread *thread;\n    register rt_base_t temp;\n\n    /*\n     * The function \"rt_scheduler_lock\" locks the scheduler and disables all interrupts.\nIt returns the previous interrupt status.\n     */\n    temp = rt_scheduler_lock();\n\n    /*\n     * The function \"rt_list_entry\" returns a pointer to the structure (the type of which is defined by type) that contains the head member.\n     */\n    while (!rt_list_isempty(susp_list)) {\n        /*\n         * The function \"rt_list_first_entry\" returns a pointer to the structure (the type of which is defined by type) that contains the head member in a list.\n         */\n        thread = rt_list_first_entry(susp_list, struct rt_thread, tlist);\n\n        /*\n         * The function \"rt_thread_resume\" resumes a thread from suspension state.\nIt returns RT_EOK to indicate successful completion.\n         */\n        rt_thread_resume(thread);\n\n        /*\n         * The function \"rt_thread_startup\" initializes a thread and puts it into ready state.\n         */\n        rt_thread_startup(thread);\n    }\n\n    /*\n     * The function \"rt_scheduler_unlock\" unlocks the scheduler and restores the interrupt status.\n     */\n    rt_scheduler_unlock(temp);\n\n    return RT_EOK;\n}", "CodeBleu_score": 40.090682672144894}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console = RT_NULL;\n    rt_device_t new_console = RT_NULL;\n\n    if (name == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* save current console device */\n    old_console = rt_console_get_device();\n\n    /* find new console device */\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* check if it is the same as the current console device */\n    if (old_console != RT_NULL && old_console == new_console) {\n        return old_console;\n    }\n\n    /* close old console device */\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    /* open new console device */\n    if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_OFLAG_STREAM) != RT_EOK) {\n        return RT_NULL;\n    }\n\n    /* set new console device */\n    rt_console_set_device(new_console);\n\n    return old_console;\n}", "CodeBleu_score": 56.37222702809518}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console = RT_NULL;\n    rt_device_t console = RT_NULL;\n    rt_err_t result = RT_EOK;\n    rt_device_t device = RT_NULL;\n\n    if (name == RT_NULL) {\n        return RT_NULL;\n    }\n\n    old_console = rt_console_get_device();\n    if (old_console != RT_NULL) {\n        if (rt_strncmp(name, old_console->parent.name, RT_NAME_MAX) == 0) {\n            return old_console;\n        }\n    }\n\n    device = rt_device_find(name);\n    if (device == RT_NULL) {\n        return RT_NULL;\n    }\n\n    console = rt_console_get_device();\n    if (console != RT_NULL) {\n        if (rt_strncmp(name, console->parent.name, RT_NAME_MAX) == 0) {\n            return old_console;\n        }\n\n        result = rt_device_close(console);\n        if (result != RT_EOK) {\n            return RT_NULL;\n        }\n    }\n\n    result = rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        return RT_NULL;\n    }\n\n    rt_console_set_device(device);\n\n    return old_console;\n}", "CodeBleu_score": 51.717101100265296}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console = RT_NULL;\n    rt_device_t new_console = RT_NULL;\n\n    /* find new console device */\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* open new console device */\n    if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return RT_NULL;\n    }\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* set new console device */\n    old_console = rt_console_get_device();\n    if (new_console != old_console) {\n        if (old_console != RT_NULL) {\n            /* close old console device */\n            rt_device_close(old_console);\n        }\n\n        /* set new console device */\n        rt_console_set_device(new_console);\n    }\n\n    /* enable interrupt */\n    rt_exit_critical();\n\n    return old_console;\n}", "CodeBleu_score": 56.09399057477711}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tstruct rt_object_information *information;\n\tregister rt_base_t temp;\n\tregister int count = 0;\n\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL)\n\t\treturn 0;\n\n\trt_enter_critical();\n\tfor (temp = 0; temp < information->object_table_size; temp ++) {\n\t\tif (information->object_table[temp] != RT_NULL)\n\t\t\tcount ++;\n\t}\n\trt_exit_critical();\n\n\treturn count;\n}", "CodeBleu_score": 44.81236446756468}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tint count = 0;\n\tstruct rt_object *object;\n\tregister rt_base_t temp;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tRT_OBJECT_HOOK_CALL(rt_object_get_length_enter, (type));\n\n\t/* get the object type */\n\tif (type >= RT_Object_Class_Unknown)\n\t\treturn 0;\n\n\t/* lock scheduler */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* get the first object */\n\tobject = rt_object_container[type].object_list;\n\twhile (object != RT_NULL)\n\t{\n\t\tcount ++;\n\t\tobject = object->list_node.next;\n\t}\n\n\t/* unlock scheduler */\n\trt_hw_interrupt_enable(temp);\n\n\tRT_OBJECT_HOOK_CALL(rt_object_get_length_exit, (type));\n\n\treturn count;\n}", "CodeBleu_score": 46.051736187263344}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tint count = 0;\n\tregister struct rt_object_information *information;\n\tregister rt_list_t *list;\n\n\tRT_ASSERT(type < RT_Object_Class_Unknown);\n\n\t/* get object information */\n\tinformation = rt_object_get_information(type);\n\tRT_ASSERT(information != RT_NULL);\n\n\t/* lock object list */\n\trt_enter_critical();\n\n\t/* get object list */\n\tlist = &(information->object_list);\n\n\t/* iterate list */\n\twhile (!rt_list_isempty(list)) {\n\t\t/* increase count */\n\t\tcount ++;\n\n\t\t/* get next object */\n\t\tlist = list->next;\n\t}\n\n\t/* unlock object list */\n\trt_exit_critical();\n\n\treturn count;\n}", "CodeBleu_score": 43.832125257627766}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\tregister rt_base_t temp;\n\n    /* check object */\n    RT_ASSERT(object != RT_NULL);\n\n    /* call object detach hook */\n    if (object->type == RT_Object_Class_Thread) {\n        /* remove thread from schedule */\n        rt_schedule_remove_thread((rt_thread_t)object);\n    }\n\n    /* lock object */\n    rt_object_take_lock(object);\n\n    /* remove object from object list */\n    rt_list_remove(&(object->list));\n\n    /* unlock object */\n    rt_object_release_lock(object);\n\n    /* set object type */\n    object->type = 0;\n\n    /* set object flag */\n    object->flag = 0;\n\n    /* set object name */\n    object->name[0] = '\\0';\n\n    /* set object short name */\n    object->short_name[0] = '\\0';\n\n    /* set object user data */\n    object->user_data = RT_NULL;\n\n    /* set object inited flag */\n    object->inited = RT_FALSE;\n\n    /* set object ref count */\n    object->ref_count = 0;\n\n    /* set object flag */\n    object->flag = 0;\n\n    /* set object lock flag */\n    object->lock_flag = 0;\n\n    /* set object lock value */\n    object->lock_value = 0;\n\n    /* set object lock owner */\n    object->lock_owner = RT_NULL;\n\n    /* set object lock count */\n    object->lock_count = 0;\n\n    /* set object suspend thread */\n    object->suspend_thread = RT_NULL;\n\n    /* set object suspend timeout */\n    object->suspend_timeout = 0;\n\n    /* set object suspend tick */\n    object->suspend_tick = 0;\n\n    /* set object suspend init tick */\n    object->suspend_init_tick = 0;\n\n    /* set object suspend list */\n    rt_list_init(&", "CodeBleu_score": 49.43695270233744}, {"code": "void rt_object_detach(rt_object_t object){\n\trt_object_t *object_list;\n\trt_list_t *list;\n\trt_base_t lock_temp;\n\n\t/* parameter check */\n\tif (object == RT_NULL)\n\t\treturn;\n\n\t/* call object detach hook */\n\tif (rt_object_detach_hook != RT_NULL)\n\t\trt_object_detach_hook(object);\n\n\t/* get object list */\n\tobject_list = rt_object_get_object(RT_Object_Class_Object);\n\tlist = &(object_list->object_list);\n\n\t/* lock object list */\n\trt_enter_critical(&lock_temp);\n\n\t/* remove object from object list */\n\trt_list_remove(&(object->list));\n\n\t/* unlock object list */\n\trt_exit_critical(lock_temp);\n\n\t/* set object type */\n\tobject->type = 0;\n}", "CodeBleu_score": 29.849221835759405}, {"code": "void rt_object_detach(rt_object_t object){\n\tregister rt_base_t temp;\n    rt_object_t *object_list;\n    struct rt_object_information *information;\n\n    /* object check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* get object information */\n    information = (struct rt_object_information *)object;\n\n    /* get object type */\n    object_list = (rt_object_t *)&(RT_KERNEL->object_list);\n    object_list += object->type;\n\n    /* lock object */\n    rt_enter_critical();\n\n    /* remove object from object list */\n    rt_list_remove(&(information->list));\n\n    /* unlock object */\n    rt_exit_critical();\n\n    /* set object type */\n    object->type = 0;\n}", "CodeBleu_score": 47.75471517261383}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result = RT_EOK;\n\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    if (obj->type == RT_Object_Class_Custom) {\n        if (obj->type->destructor != RT_NULL) {\n            result = obj->type->destructor(obj);\n        }\n        rt_object_delete(obj);\n    }\n\n    return result;\n}", "CodeBleu_score": 54.01820009521246}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result = RT_EOK;\n    struct rt_object_information *information;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    information = rt_object_get_information(RT_Object_Class_Custom);\n    RT_ASSERT(information != RT_NULL);\n\n    /* invoke object destroy function */\n    if (obj->type == RT_Object_Class_Custom) {\n        if (information->object != RT_NULL) {\n            if (information->object->type == RT_Object_Class_Custom) {\n                if (information->object->destructor != RT_NULL) {\n                    result = information->object->destructor(obj);\n                }\n            }\n        }\n    }\n\n    /* delete object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 47.689284459687165}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tstruct rt_object_information *information;\n    rt_err_t (*destory)(rt_object_t);\n    rt_err_t result = RT_EOK;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(!(obj->type & RT_Object_Class_Static));\n\n    information = rt_object_get_information(RT_Object_Class_Custom);\n    RT_ASSERT(information != RT_NULL);\n\n    if (obj->type & RT_Object_Class_Custom) {\n        destory = (rt_err_t (*)(rt_object_t))obj->type;\n        result = destory(obj);\n    }\n\n    /* delete object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 47.298095094606694}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n    register rt_base_t level;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* change stat */\n    rt_sched_thread_exit(thread);\n\n    /* release thread timer */\n    rt_timer_detach(&(thread->thread_timer));\n\n    /* add to defunct thread list */\n    rt_sched_add_thread(thread, RT_THREAD_DEFUNCT);\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    /* do schedule */\n    rt_schedule();\n\n    /* never reach here */\n}", "CodeBleu_score": 36.93957525733298}, {"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_scheduler_add_thread(&rt_thread_defunct, thread);\n\n    /* leave critical */\n    rt_exit_critical();\n\n    /* do a context switch */\n    rt_schedule();\n\n    /* never reach here */\n}", "CodeBleu_score": 38.136915686915835}, {"code": "static void _thread_exit(void){\n\trt_thread_t thread;\n    rt_sched_lock_level_t slvl;\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* change stat */\n    rt_sched_thread_exit(thread);\n\n    /* leave critical */\n    rt_exit_critical();\n\n    /* do schedule */\n    rt_schedule();\n\n    /* never reach here */\n}", "CodeBleu_score": 35.614976537314966}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\tstruct thread *thread;\n  struct thread *next;\n  struct thread *prev;\n  struct thread *current;\n  struct thread *temp;\n  unsigned int timeout;\n  unsigned int flags;\n\n  /*\n   * Check parameter.\n   */\n  if (parameter == NULL) return;\n\n  /*\n   * Lock scheduler.\n   */\n  _thread_lock_scheduler();\n\n  /*\n   * Get current thread.\n   */\n  current = _thread_current;\n\n  /*\n   * Get the thread that timed out.\n   */\n  thread = (struct thread *)parameter;\n\n  /*\n   * Check if the thread is valid.\n   */\n  if (thread == NULL) {\n    /*\n     * Unlock scheduler.\n     */\n    _thread_unlock_scheduler();\n\n    /*\n     * Return.\n     */\n    return;\n  }\n\n  /*\n   * Check if the thread is suspended.\n   */\n  if (thread->state != THREAD_SUSPENDED) {\n    /*\n     * Unlock scheduler.\n     */\n    _thread_unlock_scheduler();\n\n    /*\n     * Return.\n     */\n    return;\n  }\n\n  /*\n   * Get the thread's timeout.\n   */\n  timeout = thread->timeout;\n\n  /*\n   * Check if the thread has a timeout.\n   */\n  if (timeout == 0) {\n    /*\n     * Unlock scheduler.\n     */\n    _thread_unlock_scheduler();\n\n    /*\n     * Return.\n     */\n    return;\n  }\n\n  /*\n   * Get the thread's flags.\n   */\n  flags = thread->flags;\n\n  /*\n   * Check if the thread has a timeout.\n   */\n  if ((flags & THREAD_FLAG_TIMEOUT) == 0) {\n    /*\n     * Unlock scheduler.\n     */\n    _thread_unlock_scheduler();\n\n    /*\n     * Return.\n     */\n    return;\n  }\n\n  /*\n   * Clear the timeout flag.", "CodeBleu_score": 34.64887330573559}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct thread *thread = (struct thread *)parameter;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\tscheduler_lock();\n\n\tif (thread->state != THREAD_SUSPENDED) {\n\t\tscheduler_unlock();\n\t\treturn;\n\t}\n\n\tthread->error = ETIMEDOUT;\n\n\tthread_remove_from_suspend_list(thread);\n\tthread_add_to_ready_list(thread);\n\n\tscheduler_unlock();\n}", "CodeBleu_score": 36.57362369609459}, {"code": "static void _thread_timeout(void *parameter){\n\tthread_t *thread;\n\tthread = (thread_t *)parameter;\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\tscheduler_lock();\n\tif (thread->state != THREAD_SUSPENDED) {\n\t\tscheduler_unlock();\n\t\treturn;\n\t}\n\tthread->error = ETIMEDOUT;\n\tlist_remove(&thread->suspend_link);\n\tlist_insert_first(&thread->ready_link);\n\tscheduler_unlock();\n}", "CodeBleu_score": 29.26146306395302}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n\trt_mutex_t next;\n\trt_bool_t is_pending;\n\trt_bool_t is_waiting;\n\trt_bool_t is_taken;\n\n\t/* Lock the thread's spinlock */\n\trt_spinlock_acquire(&thread->spinlock);\n\n\t/* Check if the thread is waiting on a mutex */\n\tif (thread->pending_object != NULL) {\n\t\t/* Get the pending object */\n\t\tmutex = (rt_mutex_t)thread->pending_object;\n\n\t\t/* Check if the thread is waiting on the mutex */\n\t\tif (thread->pending_object_waiting == RT_TRUE) {\n\t\t\t/* Remove the thread from the mutex's waiting list */\n\t\t\trt_list_remove(&thread->pending_object_list);\n\n\t\t\t/* Clear the pending object */\n\t\t\tthread->pending_object = NULL;\n\n\t\t\t/* Clear the pending object waiting flag */\n\t\t\tthread->pending_object_waiting = RT_FALSE;\n\n\t\t\t/* Check if the mutex is in the taken state */\n\t\t\tif (mutex->state == RT_MUTEX_TAKEN) {\n\t\t\t\t/* Check if the mutex has a waiting thread */\n\t\t\t\tif (mutex->waiting_thread != NULL) {\n\t\t\t\t\t/* Set the mutex state to pending */\n\t\t\t\t\tmutex->state = RT_MUTEX_PENDING;\n\n\t\t\t\t\t/* Set the pending thread to the waiting thread */\n\t\t\t\t\tmutex->pending_thread = mutex->waiting_thread;\n\n\t\t\t\t\t/* Clear the waiting thread */\n\t\t\t\t\tmutex->waiting_thread = NULL;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* Set the mutex state to taken */\n\t\t\t\t\tmutex->state = RT_MUTEX_TAKEN;\n\t\t\t\t}", "CodeBleu_score": 40.67983136340181}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n    rt_list_t *list;\n    rt_list_t *node;\n    rt_list_t *next;\n    rt_bool_t mutex_taken = RT_FALSE;\n\n    /* lock thread's spinlock */\n    rt_spin_lock(&thread->spinlock);\n\n    /* check if thread is waiting on a mutex */\n    if (thread->pending_object != RT_NULL) {\n        /* get mutex */\n        mutex = (rt_mutex_t)thread->pending_object;\n\n        /* remove thread from mutex's waiting list */\n        list = &mutex->waiting_list;\n        for (node = list->next; node != list; node = next) {\n            next = node->next;\n            if (rt_list_entry(node, struct rt_thread, tlist) == thread) {\n                rt_list_remove(node);\n                break;\n            }\n        }\n\n        /* clear pending object */\n        thread->pending_object = RT_NULL;\n\n        /* unlock thread's spinlock */\n        rt_spin_unlock(&thread->spinlock);\n\n        /* release mutex */\n        rt_mutex_release(mutex);\n\n        /* set mutex taken flag */\n        mutex_taken = RT_TRUE;\n    }\n    else {\n        /* unlock thread's spinlock */\n        rt_spin_unlock(&thread->spinlock);\n    }\n\n    /* release all mutexes the thread has taken */\n    if (mutex_taken) {\n        /* lock scheduler */\n        rt_enter_critical();\n\n        /* release all mutexes the thread has taken */\n        while (thread->mutex_list != RT_NULL) {\n            rt_mutex_release(thread->mutex_list);\n        }\n\n        /* unlock scheduler */\n        rt_exit_critical();\n    }\n}", "CodeBleu_score": 47.13099545304558}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n\trt_list_t *list, *list_next;\n\trt_list_t *mutex_list;\n\trt_thread_t thread_next;\n\n\t/* Lock the thread spinlock. */\n\trt_spinlock_lock(&thread->spinlock);\n\n\t/* Check if the thread is waiting on a mutex. */\n\tif (thread->pending_object != NULL) {\n\t\t/* Get the mutex object. */\n\t\tmutex = thread->pending_object;\n\n\t\t/* Get the thread's waiting list. */\n\t\tlist = &thread->waiting_list;\n\n\t\t/* Remove the thread from the mutex's waiting list. */\n\t\trt_list_remove(list);\n\n\t\t/* Clear the pending object. */\n\t\tthread->pending_object = NULL;\n\n\t\t/* Unlock the thread spinlock. */\n\t\trt_spinlock_unlock(&thread->spinlock);\n\n\t\t/* Lock the mutex spinlock. */\n\t\trt_spinlock_lock(&mutex->spinlock);\n\n\t\t/* Get the mutex's waiting list. */\n\t\tmutex_list = &mutex->waiting_list;\n\n\t\t/* Check if the mutex's waiting list is empty. */\n\t\tif (rt_list_isempty(mutex_list)) {\n\t\t\t/* Clear the mutex's owner. */\n\t\t\tmutex->owner = NULL;\n\t\t}\n\t\telse {\n\t\t\t/* Get the next thread in the mutex's waiting list. */\n\t\t\tthread_next = rt_list_entry(mutex_list->next, rt_thread_t, waiting_list);\n\n\t\t\t/* Unlock the mutex spinlock. */\n\t\t\trt_spinlock_unlock(&mutex->spinlock);\n\n\t\t\t/* Wake up the next thread in the mutex's waiting list. */\n\t\t\trt_thread_wakeup(thread_next);\n\t\t}\n\t}\n\telse {", "CodeBleu_score": 41.11767960897188}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t result;\n\n    /* check thread */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    /* check thread state */\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* set thread state */\n    thread->stat = RT_THREAD_READY;\n\n    /* reset thread error number */\n    thread->error = RT_EOK;\n\n    /* calculate priority attribute */\n    thread->number = rt_list_len(&(thread->parent.sibling));\n    thread->current_priority = thread->init_priority;\n    thread->init_priority = thread->init_priority & RT_THREAD_PRIORITY_MASK;\n\n    /* reset thread timer */\n    rt_timer_control(&(thread->thread_timer),\n                     RT_TIMER_CTRL_SET_TIME,\n                     &thread->init_tick);\n\n    /* insert to schedule ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* resume thread */\n    result = rt_thread_resume(thread);\n\n    return result;\n}", "CodeBleu_score": 54.761068434437085}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    /* check thread state */\n    if (thread->stat != RT_THREAD_INIT)\n    {\n        rt_sched_unlock(slvl);\n\n        return -RT_ERROR;\n    }\n\n    /* set thread state */\n    thread->stat = RT_THREAD_READY;\n\n    /* reset thread error number */\n    thread->error = RT_EOK;\n\n    /* calculate priority attribute */\n    rt_sched_priority_init(thread);\n\n    /* reset thread timer */\n    rt_timer_control(&(thread->thread_timer),\n                     RT_TIMER_CTRL_SET_TIME,\n                     &thread->init_tick);\n\n    /* insert to schedule ready queue */\n    rt_sched_insert_thread(thread);\n\n    error = rt_sched_unlock_n_resched(slvl);\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 51.66359372212295}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t result;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    /* set to suspend state */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* insert to schedule ready queue */\n    result = rt_sched_thread_ready(thread);\n\n    /* return thread startup status */\n    return result;\n}", "CodeBleu_score": 45.920930284986774}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_list_t *l;\n    rt_timer_t timer;\n    rt_tick_t tick;\n\n    RT_ASSERT(timer_list != RT_NULL);\n    RT_ASSERT(timeout_tick != RT_NULL);\n\n    l = timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n    if (l != RT_NULL) {\n        timer = rt_list_entry(l, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n        tick = timer->timeout_tick - rt_tick_get();\n        if (tick > 0) {\n            *timeout_tick = tick;\n            return RT_EOK;\n        }\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 58.461404618648295}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_tick_t tick;\n    struct rt_timer *timer;\n\n    RT_ASSERT(timer_list != RT_NULL);\n    RT_ASSERT(timeout_tick != RT_NULL);\n\n    tick = (rt_tick_t)RT_TIMER_SKIP_LIST_LEVEL - 1;\n    while (tick) {\n        if (!rt_list_isempty(&timer_list[tick])) {\n            timer = rt_list_entry(timer_list[tick].next, struct rt_timer, list);\n            *timeout_tick = timer->timeout_tick;\n            return RT_EOK;\n        }\n        tick--;\n    }\n\n    return -RT_ETIMEOUT;\n}", "CodeBleu_score": 53.328077123221405}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tstruct rt_timer *timer;\n\n    timer = (struct rt_timer *)timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next;\n    if (timer == (struct rt_timer *)&(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ETIMEOUT;\n    }\n\n    *timeout_tick = timer->timeout_tick;\n    return RT_EOK;\n}", "CodeBleu_score": 54.186398381691845}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    /* allocate a object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    /* initialize timer object */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 57.55331387667868}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    /* allocate timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer object */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 63.91372542950107}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    /* allocate a new timer object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n        return RT_NULL;\n\n    /* initialize timer object */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    return timer;\n}", "CodeBleu_score": 57.55331387667868}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tvar (\n\t\tstatus int\n\t\terr    error\n\t)\n\n\t// Create a new recorder to capture the response.\n\trec := httptest.NewRecorder()\n\n\t// If the request is an OPTIONS request then we need to set the headers\n\t// to the defaults if not set.\n\tif req.Method == \"OPTIONS\" {\n\t\tif res.Header().Get(\"Access-Control-Allow-Origin\") == \"\" {\n\t\t\tres.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t\t}\n\t\tif res.Header().Get(\"Access-Control-Allow-Methods\") == \"\" {\n\t\t\tres.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n\t\t}\n\t\tif res.Header().Get(\"Access-Control-Allow-Headers\") == \"\" {\n\t\t\tres.Header().Set(\"Access-Control-Allow-Headers\", \"Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization\")\n\t\t}\n\t}\n\n\t// Execute the request through each handler.\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\n\t\t// If the response status is 401 then we need to stop processing the\n\t\t// request and return a 401 error.\n\t\tif rec.Code == 401 {\n\t\t\tstatus = rec.Code\n\t\t\terr = errors.New(\"Not Authorized\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If the request was not stopped by a 401 then we need to forward the\n\t// request to the router for further processing.\n\tif status != 401 {\n\t\ta.router.ServeHTTP(rec, req)\n\t\tstatus = rec.Code\n\t\terr = rec.Body.Err()\n\t}\n\n\t// If there was an error then we need to write the error to the response.\n\tif err != nil {\n\t\tres.WriteHeader(status)\n\t\tres.Write([]byte(err.Error()))", "CodeBleu_score": 42.03267683840484}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tvar (\n\t\trecorder = httptest.NewRecorder()\n\t\thandlers = []Handler{\n\t\t\ta.AuthHandler,\n\t\t\ta.LimitHandler,\n\t\t\ta.LoggingHandler,\n\t\t\ta.MetricsHandler,\n\t\t\ta.CorsHandler,\n\t\t}\n\t)\n\tfor _, handler := range handlers {\n\t\thandler.ServeHTTP(recorder, req)\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\ta.ErrorHandler.ServeHTTP(res, req, errors.New(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\ta.Router.ServeHTTP(res, req)\n}", "CodeBleu_score": 46.643921707635876}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\tfor _, handler := range a.handlers {\n\t\trecorder := httptest.NewRecorder()\n\t\thandler.ServeHTTP(recorder, req)\n\t\tcopyHeaders(res.Header(), recorder.Header())\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\ta.sendError(res, req, http.StatusUnauthorized, \"Not Authorized\")\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 55.311530691752985}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tvar (\n\t\tassetPath = req.URL.Path\n\t\tasset     []byte\n\t\terr       error\n\t)\n\t// The \"robeaux\" function uses the \"Asset\" and \"AssetDir\" functions from the \"embed\" package to retrieve the requested asset.\n\t// The \"Asset\" function returns the content of the asset as a byte slice and an error.\n\t// The \"AssetDir\" function returns the names of the files in a directory.\n\t// If the asset is not found, the \"Asset\" function returns an error.\n\t// If the asset is a directory, the \"AssetDir\" function returns an error.\n\tif asset, err = Asset(assetPath); err != nil {\n\t\tif asset, err = AssetDir(assetPath); err != nil {\n\t\t\thttp.Error(res, \"Not Found\", 404)\n\t\t\treturn\n\t\t}\n\t}\n\t// If the asset is found, set the Content-Type header based on the file extension.\n\tswitch filepath.Ext(assetPath) {\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\t// Write the asset content to the response.\n\tif _, err = res.Write(asset); err != nil {\n\t\thttp.Error(res, \"Internal Server Error\", 500)\n\t\treturn\n\t}\n}", "CodeBleu_score": 43.954324574766325}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t// Retrieve the requested asset based on the URL path.\n\t// If the asset is found, it sets the appropriate Content-Type header based on the file extension (js, css, html).\n\t// It then writes the asset content to the response.\n\t// If an error occurs while retrieving the asset, it returns a 404 error.\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//", "CodeBleu_score": 2.29984901754818}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tasset, err := a.assets.Open(path)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer asset.Close()\n\text := filepath.Ext(path)\n\tswitch ext {\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tio.Copy(res, asset)\n}", "CodeBleu_score": 51.43612995992719}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL.\n\trobotName := req.URL.Query().Get(\":robot\")\n\t// Find the robot with the specified name.\n\trobot := a.master.GetRobot(robotName)\n\t// If the robot was found, gather its connections and convert them to JSON format.\n\tif robot != nil {\n\t\t// Create a new JSON object to store the robot connections.\n\t\tconnections := make(map[string]interface{})\n\t\t// Gather the robot connections.\n\t\tfor _, connection := range robot.GetConnections() {\n\t\t\t// Create a new JSON object to store the connection.\n\t\t\tconnectionJSON := make(map[string]interface{})\n\t\t\t// Add the connection name to the JSON object.\n\t\t\tconnectionJSON[\"name\"] = connection.GetName()\n\t\t\t// Add the connection type to the JSON object.\n\t\t\tconnectionJSON[\"type\"] = connection.GetType()\n\t\t\t// Add the connection address to the JSON object.\n\t\t\tconnectionJSON[\"address\"] = connection.GetAddress()\n\t\t\t// Add the connection port to the JSON object.\n\t\t\tconnectionJSON[\"port\"] = connection.GetPort()\n\t\t\t// Add the connection protocol to the JSON object.\n\t\t\tconnectionJSON[\"protocol\"] = connection.GetProtocol()\n\t\t\t// Add the connection to the JSON object containing all the robot connections.\n\t\t\tconnections[connection.GetName()] = connectionJSON\n\t\t}\n\t\t// Convert the JSON object to a JSON string.\n\t\tconnectionsJSON, _ := json.Marshal(connections)\n\t\t// Write the JSON string containing the robot connections to the HTTP response.\n\t\tfmt.Fprint(res, string(connectionsJSON))\n\t} else {\n\t\t// If the robot was not found, write a JSON error message to the HTTP response.\n\t\tfmt.Fprint(res, \"{\\\"error\\\": \\\"No robot found with the specified name.\\\"}\")\n\t}\n}", "CodeBleu_score": 44.03878500231897}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL.\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Find the robot with the specified name using the master instance.\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\t// If the robot was not found, write an error message.\n\t\ta.writeJSONError(res, \"No robot found with the specified name\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Gather the connections of the robot.\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format.\n\tjsonConnections, err := json.Marshal(connections)\n\tif err != nil {\n\t\ta.writeJSONError(res, \"Failed to convert robot connections to JSON\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the robot connections.\n\ta.writeJSON(res, jsonConnections)\n}", "CodeBleu_score": 36.545635459312145}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL.\n\trobotName := mux.Vars(req)[\"robot\"]\n\t// Find the robot with the specified name using the master instance.\n\trobot := a.master.GetRobot(robotName)\n\t// If the robot was found, gather its connections and convert them to JSON format.\n\tif robot != nil {\n\t\tconnections := robot.GetConnections()\n\t\tjsonConnections, err := json.Marshal(connections)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t\t// Write the JSON response containing the connections.\n\t\tres.WriteHeader(http.StatusOK)\n\t\tres.Write(jsonConnections)\n\t} else {\n\t\t// If the robot was not found, write a JSON error message indicating that no robot was found with the specified name.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"{\\\"error\\\":\\\"No robot found with the specified name.\\\"}\"))\n\t}\n}", "CodeBleu_score": 34.413461300276126}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif !isBasicAuth(r, username, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Secure Area\\\"\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tw.WriteHeader(http.StatusOK)\n\t\tfmt.Fprintf(w, \"Authorized\")\n\t}\n}", "CodeBleu_score": 55.36847744562321}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tw.WriteHeader(http.StatusOK)\n\t}\n}", "CodeBleu_score": 49.01458371575039}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\tgiven := strings.Split(r.Header.Get(\"Authorization\"), \" \")\n\t\tif len(given) != 2 || given[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\texpected := base64.StdEncoding.EncodeToString([]byte(username + \":\" + password))\n\t\tif !secureCompare(given[1], expected) {\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t\t// All good\n\t\tw.WriteHeader(200)\n\t}\n}", "CodeBleu_score": 53.97194885809845}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - (slope * fromMin)\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(input * slope + intercept)\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t} else if value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 58.221838706940545}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t// Calculate the slope and intercept for the scaling transformation\n\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope * fromMin\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\t// Scale the input value\n\t\tvalue = int(slope * input + intercept)\n\n\t\t// Ensure the output is clamped within the target range\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn value\n\t}\n}", "CodeBleu_score": 61.202819768581094}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := float64(toMax-toMin) / (fromMax-fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 53.54363206380298}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = a.scale(float64(raw))\n\n\treturn raw, a.lastScaledValue, nil\n}", "CodeBleu_score": 55.19218818769717}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = float64(raw) * a.scale\n\n\treturn raw, a.lastScaledValue, nil\n}", "CodeBleu_score": 53.863549893924386}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"Connection does not support analog read\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 50.24461728791133}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - m*float64(fromMin)\n\treturn func(fromValue int) float64 {\n\t\treturn m*float64(fromValue) + n\n\t}\n}", "CodeBleu_score": 52.78805112601277}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 51.03527461979588}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 51.03527461979588}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tg := &GrovePiezoVibrationSensorDriver{\n\t\tname: gopi.DRIVER_NAME_GROVE_PIEZO_VIBRATION_SENSOR,\n\t\tlog:  gopi.NewLogger(gopi.MODULE_NAME_GROVE_PIEZO_VIBRATION_SENSOR),\n\t}\n\n\t// Create analog sensor driver\n\tif g.sensor, err = gopi.NewAnalogSensorDriver(a, pin, opts...); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Add vibration event\n\tif g.sensor.AddEvent(gopi.EVENT_VIBRATION) == false {\n\t\tpanic(\"NewGrovePiezoVibrationSensorDriver: AddEvent failed\")\n\t}\n\n\t// Setup event listener\n\tif err := g.sensor.Subscribe(g.sensor_data_callback); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Return success\n\treturn g\n}", "CodeBleu_score": 41.17341695280759}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\tg := &GrovePiezoVibrationSensorDriver{\n\t\tname: gopi.DRIVER_NAME_GROVE_PIEZO_VIBRATION_SENSOR,\n\t\tlog:  gopi.NewLogger(gopi.MODULE_NAME_GROVE_PIEZO_VIBRATION_SENSOR).Level(gopi.LOG_LEVEL_INFO),\n\t}\n\n\t// Create analog sensor driver\n\tif g.sensor, err = gopi.NewAnalogSensorDriver(a, pin, opts...); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Setup event listener\n\tif err := g.sensor.Subscribe(gopi.EVENT_DATA, g.sensor_data_event); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Return success\n\treturn g\n}", "CodeBleu_score": 38.80959170013468}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tpin:  pin,\n\t\tv:    NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\td.v.SetName(d.Name() + \"-AnalogSensor\")\n\td.AddEvent(Vibration)\n\n\td.v.On(d.v.Event(data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tgobot.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 52.476136922361086}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif hz == 0 {\n\t\treturn errors.New(\"Invalid frequency\")\n\t}\n\tif duration == 0 {\n\t\treturn errors.New(\"Invalid duration\")\n\t}\n\n\tperiod := 60.0 / d.BPM / hz\n\tduration = duration / 1000.0\n\n\tfor i := 0.0; i < duration*1000; i = i + period {\n\t\terr := d.On()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period * 1000) * time.Millisecond)\n\t\terr = d.Off()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period * 1000) * time.Millisecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 46.518637451208335}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif hz < 1 {\n\t\treturn fmt.Errorf(\"invalid frequency: %f\", hz)\n\t}\n\tif duration < 0 {\n\t\treturn fmt.Errorf(\"invalid duration: %f\", duration)\n\t}\n\n\t// Calculate the tone period.\n\tperiod := time.Duration(float64(time.Second) / hz)\n\t// Calculate the tempo.\n\ttempo := time.Duration(float64(time.Minute) / (d.BPM * 4))\n\t// Calculate the number of beats in the duration.\n\tbeats := int(duration / float64(tempo))\n\n\t// Turn the buzzer on.\n\tif err := d.On(); err != nil {\n\t\treturn err\n\t}\n\n\t// Start the tone.\n\tfor i := 0; i < beats; i++ {\n\t\t// Wait for the tone period.\n\t\ttime.Sleep(period)\n\t\t// Toggle the buzzer.\n\t\tif err := d.toggle(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Turn the buzzer off.\n\tif err := d.Off(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 52.24339534237059}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif hz < 0 {\n\t\treturn errors.New(\"Invalid frequency\")\n\t}\n\n\tif duration < 0 {\n\t\treturn errors.New(\"Invalid duration\")\n\t}\n\n\t// Calculate the period in milliseconds\n\tperiod := 60000 / (hz * d.BPM)\n\n\t// Calculate the number of toggles\n\ttoggles := int(duration * 1000 / period)\n\n\t// Toggle the buzzer\n\tfor i := 0; i < toggles; i++ {\n\t\terr := d.On()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Millisecond)\n\t\terr = d.Off()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Millisecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 51.00010308793592}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == nil {\n\t\treturn errors.New(\"Sleep pin not configured\")\n\t}\n\n\tif !d.sleepPin.Get() {\n\t\treturn errors.New(\"Sleep pin is not active\")\n\t}\n\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 35.649477073500684}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\n\t// Stop any ongoing operations\n\td.stop()\n\n\t// Set the sleep pin to low\n\td.sleepPin.Low()\n\n\t// Mark the driver as sleeping\n\td.isSleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 28.422322383868227}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not configured\")\n\t}\n\tif !d.sleepPin.Get() {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\td.stop()\n\td.sleepPin.Set(false)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 35.48508985641394}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin, err := gpio.OpenAnalogPin(path, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 52.19868586634817}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err := gpio.OpenPin(path, params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 51.87982761418306}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Pins are not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.connect(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 54.86751867572285}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id, gpio.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}", "CodeBleu_score": 65.33952091093104}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.Lock()\n\tdefer a.Unlock()\n\n\tp, err := a.GetPin(id, gpio.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn p.DigitalWrite(val)\n}", "CodeBleu_score": 53.37327638046201}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.Lock()\n\tdefer a.Unlock()\n\tif a.pins == nil {\n\t\treturn fmt.Errorf(\"DigitalPinsAdaptor not initialized\")\n\t}\n\tpin, err := a.pins.GetPin(id, gpio.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(int(val))\n}", "CodeBleu_score": 64.18975116252079}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor not connected\")\n\t}\n\tif _, ok := a.pins[id]; !ok {\n\t\tchip, line, err := a.translatePinID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins[id] = gpio.NewDigitalPin(a.gpio, chip, line)\n\t\tfor _, option := range opts {\n\t\t\toption(a.pins[id])\n\t\t}\n\t} else {\n\t\tfor _, option := range opts {\n\t\t\toption(a.pins[id])\n\t\t}\n\t}\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 46.659332185161794}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor not connected\")\n\t}\n\n\tif a.pins[id] == nil {\n\t\tchip, line, err := translatePinID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.pins[id] = gobot.NewDigitalPin(a, id, chip, line)\n\t}\n\n\tfor _, o := range opts {\n\t\to(a.pins[id])\n\t}\n\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 40.85881005604096}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif a.digitalPins == nil {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor not connected\")\n\t}\n\tif len(a.digitalPins) == 0 {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor not connected\")\n\t}\n\tif p, ok := a.digitalPins[id]; ok {\n\t\tfor _, o := range opts {\n\t\t\to(p)\n\t\t}\n\t\treturn p, nil\n\t}\n\tif !strings.HasPrefix(id, \"chip\") {\n\t\tid = \"chip0_\" + id\n\t}\n\tchip, line, err := a.translateID(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp := gobot.NewDigitalPin(a, id, chip, line)\n\tfor _, o := range opts {\n\t\to(p)\n\t}\n\ta.digitalPins[id] = p\n\treturn p, nil\n}", "CodeBleu_score": 46.57474663103633}]}
