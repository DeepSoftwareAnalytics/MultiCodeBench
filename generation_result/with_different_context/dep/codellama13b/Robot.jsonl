{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Retrieve the list of required files from the server\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // If the download flag is set to true, check if each file exists locally\n    if (download) {\n        for (auto &file : files) {\n            // If the file does not exist locally, request it from the server\n            if (!FileTransfer::FileExists(file)) {\n                RequestFile(file);\n                LOG_INFO(\"Downloaded file: \" + file);\n            }\n            // If the file exists locally, log that the file is found in the cache\n            else {\n                LOG_INFO(\"Found file in cache: \" + file);\n            }\n        }\n    }\n\n    return files;\n}", "CodeBleu_score": 66.67596681841226}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Retrieve the list of files from the server\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Check if the files exist locally\n    for (const auto &file : files) {\n        if (download && !FileTransfer::FileExists(file)) {\n            RequestFile(file);\n        }\n        else if (download) {\n            Logging::Log(Logging::INFO, \"File \" + file + \" found in cache\");\n        }\n    }\n\n    return files;\n}", "CodeBleu_score": 54.494658150029075}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of files in the specified folder\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Check if the files are in the cache\n    for (auto &file : files) {\n        if (FileTransfer::FileExists(file)) {\n            LOG_INFO(\"Found file \" << file << \" in the cache\");\n        } else {\n            // If the file is not found, request it\n            if (download) {\n                LOG_INFO(\"File \" << file << \" not found in the cache, requesting it from the server\");\n                RequestFile(file);\n            }\n        }\n    }\n\n    return files;\n}", "CodeBleu_score": 63.60436802558682}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tif (description.IsA<rpc::TrafficLight>()) {\n        // Traffic lights are special.\n        return SpawnTrafficLight(\n            description.As<rpc::TrafficLight>(),\n            transform,\n            parent,\n            attachment_type,\n            socket_name);\n    }\n    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        // Check the validity of the transformation to avoid ill-formed\n        // transformations when the translation is only in the 'z' axis.\n        if (transform.location.x == 0.0f && transform.location.y == 0.0f &&\n            transform.location.z == 0.0f) {\n            log_warning(\n                \"SpawnActorWithParent: Transform location is zero. \"\n                \"This may lead to ill-formed transformations. \"\n                \"Parent actor id: \" +\n                parent.id +\n                \", child actor type: \" +\n                description.type.name() +\n                \", attachment type: \" +\n                rpc::AttachmentType_Name(attachment_type));\n        }\n    }\n    return SpawnActorWithParentImpl(\n        description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 42.829337650467025}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t// Check if the actor can be spawned\n    if (!Episode->CanSpawnActorWithParent(description, parent)) {\n        throw rpc::ActorSpawnException(\"Cannot spawn actor with parent\");\n    }\n\n    // Check if the attachment type is valid\n    if (attachment_type != rpc::AttachmentType::Rigid &&\n        attachment_type != rpc::AttachmentType::SpringArm &&\n        attachment_type != rpc::AttachmentType::SpringArmGhost) {\n        throw rpc::ActorSpawnException(\"Invalid attachment type\");\n    }\n\n    // Check if the transformation is valid\n    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        geom::Vector3D translation = transform.location;\n        if (translation.x == 0.0f && translation.y == 0.0f &&\n            translation.z != 0.0f) {\n            UE_LOG(LogCarla, Warning, TEXT(\"The actor's transformation is not valid.\"));\n        }\n    }\n\n    // Spawn the actor\n    Actor actor = Episode->SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n\n    // Set the actor's autopilot\n    if (description.variables.find(\"role_name\") != description.variables.end()) {\n        if (description.variables[\"role_name\"] == \"autopilot\") {\n            SetActorAutopilot(actor.GetActorId(), true);\n        }\n    }\n\n    // Return the actor\n    return actor.Serialize();\n}", "CodeBleu_score": 49.09259529007259}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tRELEASE_ASSERT(Episode != nullptr);\n  RELEASE_ASSERT(Episode->GetState() != EpisodeState::Uninitialized);\n  RELEASE_ASSERT(Episode->GetState() != EpisodeState::ShuttingDown);\n  RELEASE_ASSERT(Episode->GetState() != EpisodeState::Shutdown);\n\n  rpc::Actor actor;\n  actor.set_id(Episode->CreateActor(description, transform, parent, attachment_type, socket_name));\n  actor.set_parent_id(parent);\n  actor.set_is_alive(true);\n  actor.set_name(description.name());\n  actor.set_type(description.type());\n\n  return actor;\n}", "CodeBleu_score": 34.40766281836104}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Retrieve the token for the G-buffer\n  auto token = GetGBufferToken(ActorId, GBufferId);\n\n  // Copy the token data to a Buffer object\n  Buffer buffer;\n  buffer.data = token.data();\n  buffer.size = token.size();\n\n  // Subscribe to the streaming client using the provided callback function\n  SubscribeToStream(buffer, callback);\n}", "CodeBleu_score": 37.36437278099206}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the token for the G-buffer\n    rpc::StreamingToken token =\n        _client->SubscribeToGBuffer(ActorId, GBufferId);\n\n    // Copy the token data\n    Buffer token_buffer = Buffer(token.size());\n    std::memcpy(token_buffer.Data(), token.data(), token.size());\n\n    // Subscribe to the streaming client using the provided callback function\n    _client->SubscribeToStreamingClient(token_buffer, callback);\n}", "CodeBleu_score": 44.99817324112272}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the token for the G-buffer\n    rpc::Token token = Client::GetGBufferToken(ActorId, GBufferId);\n\n    // Copy the token data\n    Buffer buffer;\n    buffer.resize(token.data().size());\n    std::memcpy(buffer.data(), token.data().data(), token.data().size());\n\n    // Subscribe to the streaming client using the provided callback function\n    Client::SubscribeToStreamingClient(\n          token.streaming_client_id(),\n          token.streaming_token(),\n          callback);\n}", "CodeBleu_score": 42.5431755783623}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tif (!navigation_) {\n    navigation_ = std::make_shared<WalkerNavigation>(this);\n    if (!navigation_->IsValid()) {\n      navigation_.reset();\n    }\n  }\n  return navigation_;\n}", "CodeBleu_score": 33.37856874817085}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = GetNavigation();\n    if (navigation == nullptr) {\n        navigation = std::make_shared<WalkerNavigation>(this);\n        SetNavigation(navigation);\n    }\n    return navigation;\n}", "CodeBleu_score": 40.4800121602964}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tif (m_navigation == nullptr) {\n        m_navigation = std::make_shared<WalkerNavigation>(*this);\n    }\n    return m_navigation;\n}", "CodeBleu_score": 26.670704339471747}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tusing namespace std::chrono;\n  auto start_time = steady_clock::now();\n  auto end_time = start_time + timeout;\n  while (steady_clock::now() < end_time) {\n    if (episode.GetCurrentFrame() >= frame) {\n      episode.Tick();\n      return true;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  }\n  return false;\n}", "CodeBleu_score": 41.414846466500265}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tusing namespace std::chrono;\n  constexpr auto one_second = 1s;\n\n  auto start_time = high_resolution_clock::now();\n  auto timeout_time = start_time + timeout;\n\n  while (episode.GetCurrentFrame() < frame) {\n    if (high_resolution_clock::now() > timeout_time) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n\n  episode.Lock()->Tick();\n  return true;\n}", "CodeBleu_score": 40.2198270696713}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tusing namespace std::chrono;\n    auto start_time = high_resolution_clock::now();\n    while (episode.GetCurrentFrame() < frame) {\n        if (high_resolution_clock::now() - start_time > timeout) {\n            return false;\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n\n    // Synchronization successful. Trigger a tick in the TrafficManager\n    episode.Lock()->GetTrafficManager()->Tick();\n    return true;\n}", "CodeBleu_score": 40.76381128156974}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t// TODO: Implement\n    return EpisodeProxy{shared_from_this()};\n}", "CodeBleu_score": 6.701002605276709}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\trpc::LoadEpisodeRequest request;\n    request.set_map_name(map_name);\n    request.set_reset_settings(reset_settings);\n    request.set_map_layers(map_layers);\n    rpc::LoadEpisodeResponse response;\n\n    if (EpisodeProxy::IsValid()) {\n        request.set_episode_id(EpisodeProxy::GetId());\n    }\n\n    bool bSuccess = false;\n    int iAttempt = 0;\n    int iMaxAttempt = 10;\n    while (iAttempt < iMaxAttempt) {\n        try {\n            client->LoadEpisode(request, &response);\n            bSuccess = true;\n            break;\n        }\n        catch (std::exception &e) {\n            ++iAttempt;\n            if (iAttempt >= iMaxAttempt) {\n                throw;\n            }\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n    }\n\n    if (!bSuccess) {\n        throw std::runtime_error(\"Unable to connect to the new episode\");\n    }\n\n    EpisodeProxy episode = EpisodeProxy{shared_from_this()};\n    episode.SetId(response.episode_id());\n    return episode;\n}", "CodeBleu_score": 46.27382289272274}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tGetReadyCurrentEpisode();\n\n    // Load the episode\n    std::string episode_id = LoadEpisodeSync(map_name, reset_settings, map_layers);\n\n    // Wait for the episode to be ready\n    std::chrono::time_point<std::chrono::system_clock> start_time = std::chrono::system_clock::now();\n    while (true) {\n        std::chrono::time_point<std::chrono::system_clock> current_time = std::chrono::system_clock::now();\n        std::chrono::duration<double> elapsed_time = current_time - start_time;\n        if (elapsed_time.count() > 10.0) {\n            throw std::runtime_error(\"Failed to connect to the episode\");\n        }\n\n        // If the episode ID has changed, then the episode is ready\n        if (GetEpisodeId() == episode_id) {\n            return EpisodeProxy{shared_from_this()};\n        }\n\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n}", "CodeBleu_score": 40.01583839145195}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tauto walker = GetWalker(controller.GetWalkerID());\n  if (!walker) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n  if (!episode_) {\n    throw std::runtime_error(\"Episode is null\");\n  }\n  if (!walker->navigation) {\n    walker->navigation = std::make_shared<Navigation>(*walker, *episode_);\n  }\n  walker->navigation->RegisterController(controller.GetControllerId());\n}", "CodeBleu_score": 50.77452437633217}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tWalker *walker = GetWalker(controller.GetWalkerID());\n  if (walker == nullptr) {\n    throw std::invalid_argument(\"Walker not found for AI controller.\");\n  }\n  assert(episode != nullptr);\n  if (walker->navigation == nullptr) {\n    walker->navigation = new Navigation();\n  }\n  walker->navigation->RegisterAIController(controller.GetID());\n}", "CodeBleu_score": 49.92899811403032}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tWalker *walker = GetWalker(controller.GetWalkerID());\n  if (!walker)\n    throw std::runtime_error(\"Simulator::RegisterAIController: Walker not found.\");\n  if (!episode)\n    throw std::runtime_error(\"Simulator::RegisterAIController: Episode is null.\");\n  if (!walker->navigation)\n    walker->navigation = std::make_shared<Navigation>(walker, episode);\n  walker->navigation->RegisterController(controller);\n}", "CodeBleu_score": 45.43152493391916}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tGetReadyCurrentEpisode();\n    auto actor = _episode->SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n    if (actor == nullptr) {\n      throw SimulatorException(\"Failed to spawn actor\");\n    }\n    return actor;\n  }", "CodeBleu_score": 30.69498548661709}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tGetReadyCurrentEpisode();\n\n    auto actor = GetCurrentEpisode().SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n\n    return actor;\n}", "CodeBleu_score": 23.04816058354793}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t// Get the episode\n    GetReadyCurrentEpisode();\n\n    // Spawn the actor\n    SharedPtr<Actor> actor = _episode->SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n\n    // Register the actor in the current episode\n    _episode->RegisterActor(actor);\n\n    // Apply the garbage collection policy\n    _episode->ApplyGarbageCollectionPolicy(gc);\n\n    // Log the creation\n    _episode->LogActorCreation(actor, blueprint.GetId(), parent, attachment_type, gc, socket_name);\n\n    return actor;\n}", "CodeBleu_score": 37.81236160590116}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tif (!CheckSimulatorValid()) {\n        return;\n    }\n    const auto &client = GetClient();\n    client->SubscribeToStream(sensor.GetDataStreamName(),\n                              [this, callback](SharedPtr<sensor::SensorData> data) {\n                                  data->SetFrame(GetCurrentEpisode().GetCurrentFrame());\n                                  callback(data);\n                              });\n}", "CodeBleu_score": 36.27553574916383}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t// Ensure that the episode is valid.\n  if (!Episode->IsValid()) {\n    throw std::runtime_error(\n        \"Simulator::SubscribeToSensor: episode is not valid\");\n  }\n\n  // Subscribe to the sensor's data stream.\n  auto stream = sensor.GetDataStream(*Episode);\n  if (!stream) {\n    throw std::runtime_error(\n        \"Simulator::SubscribeToSensor: failed to get sensor's data stream\");\n  }\n  if (!Client->SubscribeToStream(stream, callback)) {\n    throw std::runtime_error(\n        \"Simulator::SubscribeToSensor: failed to subscribe to sensor's data \"\n        \"stream\");\n  }\n}", "CodeBleu_score": 35.9949415934332}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tif (!Episode->IsValid()) {\n        UE_LOG(LogCarla, Error, TEXT(\"Simulator::SubscribeToSensor: episode is not valid!\"));\n        return;\n    }\n\n    auto sensor_id = sensor.GetId();\n    auto sensor_type = sensor.GetSensorType();\n\n    UE_LOG(LogCarla, Log, TEXT(\"Simulator::SubscribeToSensor: sensor id: %d, type: %d\"), sensor_id, sensor_type);\n\n    auto sensor_stream = Episode->FindStreamForSensor(sensor_id);\n\n    if (sensor_stream == nullptr) {\n        UE_LOG(LogCarla, Error, TEXT(\"Simulator::SubscribeToSensor: sensor stream not found!\"));\n        return;\n    }\n\n    sensor_stream->Listen([this, sensor_id, sensor_type, callback](SharedPtr<sensor::SensorData> sensor_data) {\n        UE_LOG(LogCarla, Log, TEXT(\"Simulator::SubscribeToSensor: sensor data received\"));\n        if (!Episode->IsValid()) {\n            UE_LOG(LogCarla, Error, TEXT(\"Simulator::SubscribeToSensor: episode is not valid!\"));\n            return;\n        }\n        auto sensor = Episode->FindSensor(sensor_id);\n        if (sensor == nullptr) {\n            UE_LOG(LogCarla, Error, TEXT(\"Simulator::SubscribeToSensor: sensor not found!\"));\n            return;\n        }\n        if (sensor->GetSensorType() != sensor_type) {\n            UE_LOG(LogCarla, Error, TEXT(\"Simulator::SubscribeToSensor: sensor type does not match!\"));\n            return;\n        }\n        callback(sensor_data);\n    });\n}", "CodeBleu_score": 42.689678517446275}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// load the walkers\n    std::vector<WalkerHandle> walkers = _walkers.lock()->GetWalkers();\n    // check if empty\n    if (walkers.empty()) return;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // check if any walker exists\n    CheckIfWalkerExist(walkers, *state);\n\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update the crowd\n    _nav.UpdateCrowd();\n\n    // apply the transforms and velocities to the simulator\n    for (int i = 0; i < _nav.GetCrowd()->getAgentCount(); ++i) {\n      // get the agent\n      const dtCrowdAgent *agent = _nav.GetCrowd()->getAgent(i);\n      if (agent) {\n        // get the transform\n        carla::geom::Transform transform;\n        transform.location.x = agent->npos[0];\n        transform.location.z = agent->npos[2];\n        transform.location.y = agent->npos[1];\n        transform.rotation.yaw = agent->rotation;\n        // get the velocity\n        carla::geom::Vector3D velocity;\n        velocity.x = agent->vel[0];\n        velocity.z = agent->vel[2];\n        velocity.y = agent->vel[1];\n        // set the transform and velocity\n        _simulator.lock()->SetActorTransform(walkers[i].walker, transform);\n        _simulator.lock()->SetActorVelocity(walkers[i].walker, velocity);\n      }\n    }\n\n    // check if any walker has been killed\n    for (int i = 0; i < _nav.GetCrowd()->getAgentCount(); ++i) {\n      // get the agent\n      const dtCrowdAgent *agent = _nav.GetCrowd()->getAgent(i);\n      if (agent && agent->state == DT_CROWDAGENT_STATE_DE", "CodeBleu_score": 47.851492336709626}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// get the walkers\n    std::vector<WalkerHandle> walkers = GetWalkers();\n\n    // if empty, return\n    if (walkers.empty()) return;\n\n    // get the state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // check if the walkers exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update the vehicles\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update the crowd\n    _nav.UpdateCrowd(_simulator.lock()->GetWorld()->GetTime());\n\n    // get the transforms\n    std::vector<carla::geom::Transform> transforms;\n    std::vector<float> speeds;\n    for (auto &&walker : walkers) {\n      transforms.emplace_back(state->GetActorSnapshot(walker.walker).transform);\n      speeds.emplace_back(state->GetActorSnapshot(walker.walker).velocity.length());\n    }\n\n    // apply the transforms\n    _simulator.lock()->ApplyBatchTransform(transforms);\n\n    // apply the speeds\n    _simulator.lock()->ApplyBatchSpeed(speeds);\n\n    // check if any walker has been killed\n    for (auto &&walker : walkers) {\n      // if dead, remove from the crowd\n      if (state->GetActorSnapshot(walker.walker).is_alive == false) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n\n  }", "CodeBleu_score": 49.16832671782073}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// get the list of walkers\n    std::vector<WalkerHandle> walkers = GetWalkers();\n\n    // check if empty\n    if (walkers.empty())\n      return;\n\n    // get the current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // check if the walkers still exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, true);\n\n    // update the crowd\n    _nav.UpdateCrowd();\n\n    // apply the states in a batch\n    _simulator.lock()->ApplyBatch(\n        [&](auto &client) {\n          // get the transforms\n          std::vector<carla::geom::Transform> transforms;\n          std::vector<float> speeds;\n          for (auto &&walker : walkers) {\n            // get the transform\n            transforms.emplace_back(state->GetActorSnapshot(walker.walker).transform);\n            // get the speed\n            speeds.emplace_back(state->GetActorSnapshot(walker.walker).velocity.comp_x);\n          }\n\n          // apply the transforms\n          client.ApplyBatchTransform(transforms);\n          // apply the speeds\n          client.ApplyBatchSpeed(speeds);\n        },\n        true);\n\n    // check if any walker has been killed\n    for (auto &&walker : walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n      // check if dead\n      if (snapshot.is_dead) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n\n  }", "CodeBleu_score": 51.25568510898423}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription desc;\n    desc.set_uid(GetActorBlueprintUID());\n    desc.set_id(GetActorBlueprintID());\n    desc.mutable_attributes()->Reserve(GetNumAttributes());\n    for (const auto& it : GetAttributes()) {\n        desc.add_attributes()->CopyFrom(it.second);\n    }\n    return desc;\n}", "CodeBleu_score": 51.10515762597435}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription actor_description;\n\n    actor_description.set_uid(GetActorUID());\n    actor_description.set_id(GetActorId());\n\n    for (auto it = attributes.begin(); it != attributes.end(); ++it) {\n        actor_description.add_attributes(it->second);\n    }\n\n    return actor_description;\n}", "CodeBleu_score": 48.317733752997505}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription actor_description;\n  actor_description.set_uid(GetActorId());\n  actor_description.set_id(GetActorId());\n  actor_description.set_owner(GetOwner());\n  actor_description.set_parent_id(GetParentId());\n  actor_description.set_name(GetName());\n  actor_description.set_is_alive(IsAlive());\n  actor_description.set_is_parenting_allowed(IsParentingAllowed());\n  actor_description.set_is_alive(IsAlive());\n  actor_description.set_is_parenting_allowed(IsParentingAllowed());\n\n  actor_description.mutable_attributes()->Reserve(GetNumAttributes());\n  for (auto it = GetAttributes().begin(); it != GetAttributes().end(); ++it) {\n    actor_description.add_attributes(it->first);\n    actor_description.add_attribute_types(it->second);\n  }\n\n  return actor_description;\n}", "CodeBleu_score": 43.824162630024325}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t// Create a new BlueprintLibrary to store the results.\n    auto result = MakeShared<BlueprintLibrary>();\n\n    // Iterate through the blueprints in this BlueprintLibrary.\n    for (auto& blueprint : blueprints_) {\n        // Check if the blueprint has the specified attribute.\n        if (blueprint->HasAttribute(name)) {\n            // Get the attribute.\n            auto attribute = blueprint->GetAttribute(name);\n\n            // Check if the attribute has the specified value.\n            if (attribute->GetValue() == value) {\n                // Add the blueprint to the result.\n                result->AddBlueprint(blueprint);\n            } else {\n                // Check if the attribute has recommended values.\n                if (attribute->HasRecommendedValues()) {\n                    // Iterate through the recommended values.\n                    for (auto& recommended_value : attribute->GetRecommendedValues()) {\n                        // Check if the recommended value matches the specified value.\n                        if (recommended_value == value) {\n                            // Add the blueprint to the result.\n                            result->AddBlueprint(blueprint);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Return the result.\n    return result;\n}", "CodeBleu_score": 53.04600726024135}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result = make_shared<BlueprintLibrary>();\n    for (const auto& blueprint : blueprints) {\n        if (blueprint->attributes.find(name) != blueprint->attributes.end()) {\n            if (blueprint->attributes.at(name).value == value) {\n                result->blueprints.push_back(blueprint);\n            } else {\n                for (const auto& recommendedValue : blueprint->attributes.at(name).recommendedValues) {\n                    if (recommendedValue == value) {\n                        result->blueprints.push_back(blueprint);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 52.760222449450445}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tSharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\n    for (auto& blueprint : blueprints_) {\n        if (blueprint->HasAttribute(name)) {\n            const std::vector<std::string> &values = blueprint->GetAttribute(name);\n            for (auto& val : values) {\n                if (val == value) {\n                    result->AddBlueprint(blueprint);\n                    break;\n                }\n            }\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 47.55941814656186}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string fullPath = GetFullPath(path);\n    if (fullPath.empty()) {\n        return false;\n    }\n\n    std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    file.write(reinterpret_cast<char*>(content.data()), content.size());\n    file.close();\n    return true;\n}", "CodeBleu_score": 44.815900377926795}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string fullPath = GetFullPath(path);\n\tif (ValidateFilePath(fullPath)) {\n\t\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\t\tif (file.is_open()) {\n\t\t\tfile.write((char*)content.data(), content.size());\n\t\t\tfile.close();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 41.56776214202155}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t//Construct the full file path using the base folder and version information\n    std::string fullPath = GetFullPath(path);\n    //Validate the file path\n    if (!ValidatePath(fullPath)) {\n        return false;\n    }\n    //Open the file in binary mode to truncate its contents\n    std::ofstream file(fullPath, std::ios::out | std::ios::binary | std::ios::trunc);\n    //If the file is successfully opened, write the content and close the file\n    if (file.is_open()) {\n        file.write((char*)content.data(), content.size());\n        file.close();\n        return true;\n    }\n    //If the file cannot be opened, return false\n    return false;\n}", "CodeBleu_score": 43.58045099790458}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto &parent = transform.GetParent();\n    const auto &location = parent->GetLocation() + transform.GetLocation();\n    const auto &extent = parent->GetExtent();\n    const auto &yaw = parent->GetYaw();\n    const auto &corners = GetCorners(extent, yaw);\n    return std::make_shared<const Bounds>(\n        frame,\n        location,\n        corners);\n  }", "CodeBleu_score": 31.580979781786606}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst geom::Location location = transform.location + parent_bounds_.at(frame).location;\n    const geom::Vector3D extents = transform.rotation.Rotate(parent_bounds_.at(frame).extents);\n    const geom::Vector3D x_vec = geom::Vector3D(extents.x, 0.0f, 0.0f);\n    const geom::Vector3D y_vec = geom::Vector3D(0.0f, extents.y, 0.0f);\n    const geom::Vector3D z_vec = geom::Vector3D(0.0f, 0.0f, extents.z);\n    const geom::Location front_left = Rotate(transform.rotation.yaw, location - x_vec - y_vec - z_vec);\n    const geom::Location front_right = Rotate(transform.rotation.yaw, location + x_vec - y_vec - z_vec);\n    const geom::Location back_left = Rotate(transform.rotation.yaw, location - x_vec + y_vec - z_vec);\n    const geom::Location back_right = Rotate(transform.rotation.yaw, location + x_vec + y_vec - z_vec);\n    return std::make_shared<const Bounds>(frame, front_left, front_right, back_left, back_right);\n  }", "CodeBleu_score": 42.85916717188505}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto &extent = _actor_bounds[frame];\n    const auto &location = transform.location;\n    const auto &yaw = transform.rotation.yaw;\n    const auto &corners = geom::Math::GetCorners(extent);\n    const auto &rotated_corners = geom::Math::Rotate2D(corners, yaw);\n    const auto &rotated_extent = geom::Math::GetExtent(rotated_corners);\n    const auto &rotated_location = Rotate(yaw, location);\n    const auto &rotated_extent_location = geom::Math::AddVectors(rotated_location, rotated_extent);\n    const auto &bounds = std::make_shared<const Bounds>(frame, rotated_extent_location, rotated_extent);\n    return bounds;\n  }", "CodeBleu_score": 38.07334459867066}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t// Lock the mutex\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    // Create a new list of lights\n    std::vector<Light> lights;\n\n    // Query the server for the current light states\n    _server.QueryLightsState(lights);\n\n    // Iterate through the lights and update the local light states\n    for (auto light : lights) {\n        // Check if the light exists in the _lights map\n        if (_lights.find(light.id) != _lights.end()) {\n            // If it does, update the light\n            _lights[light.id]->SetLightState(light);\n        }\n        else {\n            // If it does not, create a new light object\n            _lights[light.id] = std::make_shared<Light>(light);\n        }\n    }\n}", "CodeBleu_score": 33.70416026782259}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t// Lock the mutex\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Get the light states from the server\n\tstd::vector<LightState> lightStates = _server->GetLightStates();\n\n\t// For each light state\n\tfor (auto lightState : lightStates) {\n\t\t// If the light does not exist in the _lights map\n\t\tif (_lights.find(lightState.id) == _lights.end()) {\n\t\t\t// Create a new light object and add it to the _lights map\n\t\t\t_lights[lightState.id] = std::make_unique<Light>(lightState.id, lightState.type, lightState.position, lightState.color, lightState.radius, lightState.intensity, lightState.attenuation, lightState.ambientIntensity, lightState.ambientColor);\n\t\t}\n\n\t\t// Update the light object with the new light state\n\t\t_lights[lightState.id]->Update(lightState.position, lightState.color, lightState.radius, lightState.intensity, lightState.attenuation, lightState.ambientIntensity, lightState.ambientColor);\n\t}\n}", "CodeBleu_score": 32.73502630105554}, {"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(_lights_mutex);\n\n\t// Query the current state of the lights from the server\n\tstd::vector<std::string> lights_state = _server->QueryLightsState();\n\n\t// Iterate through the lights and update their states\n\tfor (auto it = lights_state.begin(); it != lights_state.end(); ++it) {\n\n\t\t// Split the string into a vector of strings\n\t\tstd::vector<std::string> light_state = split(*it, \",\");\n\n\t\t// Check if the light already exists in the _lights map\n\t\tif (_lights.find(light_state[0]) == _lights.end()) {\n\t\t\t// If the light does not exist, create a new light\n\t\t\t_lights[light_state[0]] = new Light(light_state[0], light_state[1], light_state[2], light_state[3]);\n\t\t}\n\t\telse {\n\t\t\t// If the light already exists, update its state\n\t\t\t_lights[light_state[0]]->SetLightState(light_state[1], light_state[2], light_state[3]);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.95813198054733}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(lights_mutex);\n\tif (lights_changed) {\n\t\t// Create a message containing the updated light states\n\t\tstd::stringstream ss;\n\t\tss << \"UPDATE_LIGHTS \" << lights.size() << \" \";\n\t\tfor (auto& light : lights) {\n\t\t\tss << light.second.id << \" \";\n\t\t\tss << light.second.color.x << \" \";\n\t\t\tss << light.second.color.y << \" \";\n\t\t\tss << light.second.color.z << \" \";\n\t\t\tss << light.second.intensity << \" \";\n\t\t\tss << light.second.position.x << \" \";\n\t\t\tss << light.second.position.y << \" \";\n\t\t\tss << light.second.position.z << \" \";\n\t\t\tss << light.second.direction.x << \" \";\n\t\t\tss << light.second.direction.y << \" \";\n\t\t\tss << light.second.direction.z << \" \";\n\t\t\tss << light.second.spot_angle << \" \";\n\t\t\tss << light.second.spot_attenuation << \" \";\n\t\t\tss << light.second.type << \" \";\n\t\t\tss << light.second.enabled << \" \";\n\t\t}\n\n\t\t// Send the message to the server\n\t\tif (discard_client) {\n\t\t\tserver.SendMessage(ss.str());\n\t\t} else {\n\t\t\tserver.SendMessageToAll(ss.str());\n\t\t}\n\n\t\t// Clear the changes and reset the dirty flag\n\t\tlights_changed = false;\n\t}\n}", "CodeBleu_score": 42.400065939961685}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t// Lock the mutex\n    std::lock_guard<std::mutex> lock(lights_mutex);\n\n    // Check if there are any changes\n    if (!lights_changed) return;\n\n    // Create a message\n    std::string message = \"{\\\"type\\\":\\\"lights\\\",\\\"lights\\\":[\";\n\n    // Iterate through the lights\n    for (auto& light : lights) {\n        // Append the light to the message\n        message += light->Serialize();\n\n        // If it is not the last light, append a comma\n        if (light != lights.back()) {\n            message += \",\";\n        }\n    }\n\n    // Append the end of the message\n    message += \"]}\";\n\n    // Send the message to the server\n    if (discard_client) {\n        server_socket->SendMessage(message);\n    } else {\n        server_socket->SendMessage(message, true);\n    }\n\n    // Clear the changes\n    ClearLightChanges();\n}", "CodeBleu_score": 34.15427781103356}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(lights_mutex_);\n    if (lights_dirty_ && lights_.size() > 0) {\n        // Create a message containing the updated light states\n        std::string message = \"{\\\"lights\\\":[\";\n        for (auto it = lights_.begin(); it != lights_.end(); it++) {\n            if (it != lights_.begin()) {\n                message += \",\";\n            }\n            message += it->second->ToJson();\n        }\n        message += \"]}\";\n\n        // Send the message to the server\n        if (discard_client) {\n            client_->SendMessage(message, true);\n        } else {\n            client_->SendMessage(message);\n        }\n\n        // Clear the changes and reset the dirty flag\n        for (auto it = lights_.begin(); it != lights_.end(); it++) {\n            it->second->ClearChanges();\n        }\n        lights_dirty_ = false;\n    }\n}", "CodeBleu_score": 50.36658949511502}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t// Log a debug message\n    std::cout << \"ServerSideSensor::Send called\" << std::endl;\n    // Check if the sensor's ID is \"sensor.other.v2x_custom\"\n    if (this->GetSensorId() != \"sensor.other.v2x_custom\") {\n        // Log a warning message\n        std::cout << \"ServerSideSensor::Send - WARNING: Sensor ID is not sensor.other.v2x_custom\" << std::endl;\n        // Return\n        return;\n    }\n    // Log a debug message\n    std::cout << \"ServerSideSensor::Send - Sensor ID is sensor.other.v2x_custom\" << std::endl;\n    // Get the sensor's context\n    auto context = this->GetContext();\n    // Log a debug message\n    std::cout << \"ServerSideSensor::Send - Sensor context is \" << context << std::endl;\n    // Send the message to the episode using the sensor's context\n    this->GetEpisode().Lock()->SendMessage(context, message);\n}", "CodeBleu_score": 43.063431818841245}, {"code": "void ServerSideSensor::Send(std::string message){\n\t// Logging\n    std::stringstream ss;\n    ss << \"Sensor \" << GetId() << \" sending message: \" << message;\n    Logger::Log(ss.str(), 1);\n\n    // Check if sensor ID is \"sensor.other.v2x_custom\"\n    if (GetId() != \"sensor.other.v2x_custom\") {\n        // Logging\n        std::stringstream ss;\n        ss << \"Sensor \" << GetId() << \" is not of type sensor.other.v2x_custom\";\n        Logger::Log(ss.str(), 0);\n        return;\n    }\n\n    // Send message to episode\n    GetContext()->GetEpisode()->SendMessage(message);\n}", "CodeBleu_score": 50.138065986061164}, {"code": "void ServerSideSensor::Send(std::string message){\n\tif (sensor_id != \"sensor.other.v2x_custom\") {\n        std::cout << \"Warning: ServerSideSensor::Send() called on a sensor with ID: \" << sensor_id << std::endl;\n        return;\n    }\n    std::cout << \"ServerSideSensor::Send() called on a sensor with ID: \" << sensor_id << std::endl;\n    std::cout << \"Message: \" << message << std::endl;\n    episode.Lock()->SendMessage(sensor_id, message);\n}", "CodeBleu_score": 44.51071967864033}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tunimplemented_(u\"void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\");\n}", "CodeBleu_score": 7.195831535819128}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n        if (!autopilot_enabled) {\n            autopilot_enabled = true;\n            autopilot_tm_port = tm_port;\n            // If the vehicle is not in gear, we need to engage it before we enable the autopilot.\n            if (!IsInGear()) {\n                SetThrottle(1.0f);\n                while (!IsInGear()) {\n                    std::this_thread::sleep_for(100ms);\n                }\n            }\n            // Set the vehicle's autopilot.\n            SetAutopilot(autopilot_tm_port);\n        }\n    }\n    else {\n        if (autopilot_enabled) {\n            autopilot_enabled = false;\n            UnsetAutopilot();\n        }\n    }\n}", "CodeBleu_score": 36.13585026864947}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tpy::gil_scoped_acquire acquire;\n    unmanaged_shared_ptr<Vehicle> *self_ptr = reinterpret_cast<unmanaged_shared_ptr<Vehicle> *>(\n        Ptr<Vehicle>::ptr());\n    (*self_ptr)->SetAutopilot(enabled, tm_port);\n}", "CodeBleu_score": 34.565193844009755}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\n\t// Get the Pawn\n\tWalker = Cast<AWalker>(GetPawn());\n\tif (Walker == nullptr) {\n\t\tUE_LOG(LogTemp, Error, TEXT(\"WalkerAIController::Start: AWalker is nullptr\"));\n\t}\n\n\t// Get the navigation system\n\tUNavigationSystemV1* NavSys = UNavigationSystemV1::GetCurrent(GetWorld());\n\tif (NavSys == nullptr) {\n\t\tUE_LOG(LogTemp, Error, TEXT(\"WalkerAIController::Start: NavSys is nullptr\"));\n\t}\n\n\t// Register the walker with the navigation system\n\tNavSys->AddActorToNavigation(Walker);\n\n\t// Disable physics simulation and collisions for the walker\n\tWalker->SetActorEnableCollision(false);\n\tWalker->SetActorTickEnabled(false);\n}", "CodeBleu_score": 37.38710258121149}, {"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\n\t// Get the Pawn\n\tAPawn* Walker = GetPawn();\n\tif (Walker) {\n\t\t// Get the character mesh\n\t\tWalkerMesh = Cast<UCharacterMovementComponent>(Walker->GetComponentByClass(UCharacterMovementComponent::StaticClass()));\n\t\tif (WalkerMesh) {\n\t\t\t// Disable the physics simulation and collisions for the walker mesh\n\t\t\tWalkerMesh->SetSimulatePhysics(false);\n\t\t\tWalkerMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t\t}\n\t\t// Get the character mesh\n\t\tWalkerMesh = Cast<UCharacterMovementComponent>(Walker->GetComponentByClass(UCharacterMovementComponent::StaticClass()));\n\t\tif (WalkerMesh) {\n\t\t\t// Disable the physics simulation and collisions for the walker mesh\n\t\t\tWalkerMesh->SetSimulatePhysics(false);\n\t\t\tWalkerMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t\t}\n\t}\n\n\t// Get the world\n\tUWorld* World = GetWorld();\n\tif (World) {\n\t\t// Get the episode\n\t\tUEpisode* Episode = Cast<UEpisode>(World->GetCurrentLevel());\n\t\tif (Episode) {\n\t\t\t// Register the AI controller with the episode\n\t\t\tEpisode->RegisterAIController(this);\n\t\t}\n\t}\n}", "CodeBleu_score": 33.58543953860106}, {"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\n\t// Get the walker actor\n\tAMyWalkerCharacter* MyWalkerCharacter = Cast<AMyWalkerCharacter>(GetPawn());\n\tif (MyWalkerCharacter == nullptr) {\n\t\tUE_LOG(LogTemp, Error, TEXT(\"AI Controller could not find the walker actor.\"));\n\t\treturn;\n\t}\n\n\t// Set the episode\n\tEpisode = Cast<APaperFlipCharacter>(GetPawn())->Episode;\n\tif (Episode == nullptr) {\n\t\tUE_LOG(LogTemp, Error, TEXT(\"AI Controller could not find the episode.\"));\n\t\treturn;\n\t}\n\n\t// Set the navigation system\n\tNavSystem = Cast<APaperFlipCharacter>(GetPawn())->NavSystem;\n\tif (NavSystem == nullptr) {\n\t\tUE_LOG(LogTemp, Error, TEXT(\"AI Controller could not find the navigation system.\"));\n\t\treturn;\n\t}\n\n\t// Add the walker actor to the navigation system\n\tNavSystem->AddWalker(MyWalkerCharacter);\n\n\t// Set the walker actor's location\n\tFVector Location = MyWalkerCharacter->GetActorLocation();\n\tMyWalkerCharacter->SetActorLocation(Location, false, nullptr, ETeleportType::TeleportPhysics);\n\n\t// Disable physics simulation and collisions for the walker actor\n\tMyWalkerCharacter->SetActorEnableCollision(false);\n\tMyWalkerCharacter->SetActorTickEnabled(false);\n}", "CodeBleu_score": 38.76152844299205}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tif (m_pCurrentEpisode) {\n    // Get the navigation instance\n    const ANavigationInterface* nav = m_pCurrentEpisode->GetNavigation();\n    if (nav) {\n      // Get the parent walker\n      AWalker* walker = GetWalker();\n      if (walker) {\n        // Set the speed\n        if (nav->SetWalkerSpeed(walker, max_speed)) {\n          return;\n        }\n      }\n      else {\n        UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController: cannot set max speed, no walker found\"));\n      }\n    }\n    else {\n      UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController: cannot set max speed, no navigation instance found\"));\n    }\n  }\n  else {\n    UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController: cannot set max speed, no episode found\"));\n  }\n}", "CodeBleu_score": 44.53938651695157}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tif (UNLIKELY(!episode_->GetNavigation())) {\n        UE_LOG(LogCarla, Warning, TEXT(\"Failed to set max speed, navigation not available\"));\n        return;\n    }\n    APawn *pawn = GetPawn();\n    if (UNLIKELY(!pawn)) {\n        UE_LOG(LogCarla, Warning, TEXT(\"Failed to set max speed, pawn not available\"));\n        return;\n    }\n    auto *walker = Cast<AWalker>(pawn);\n    if (UNLIKELY(!walker)) {\n        UE_LOG(LogCarla, Warning, TEXT(\"Failed to set max speed, pawn is not a walker\"));\n        return;\n    }\n    if (UNLIKELY(!walker->GetNavigationController())) {\n        UE_LOG(LogCarla, Warning, TEXT(\"Failed to set max speed, navigation controller not available\"));\n        return;\n    }\n    if (!walker->GetNavigationController()->SetMaxSpeed(max_speed)) {\n        UE_LOG(LogCarla, Warning, TEXT(\"Failed to set max speed\"));\n    }\n}", "CodeBleu_score": 42.09587067636818}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tif (m_pNav == nullptr) {\n    m_pNav = Cast<UNavigationSystemV1>(GetWorld()->GetNavigationSystem());\n    if (m_pNav == nullptr) {\n      UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Navigation instance is null!\"));\n      return;\n    }\n  }\n\n  AWalkerCharacter* pWalker = Cast<AWalkerCharacter>(GetPawn());\n  if (pWalker == nullptr) {\n    UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Walker is null!\"));\n    return;\n  }\n\n  if (!m_pNav->SetWalkerMaxSpeed(pWalker, max_speed)) {\n    UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set maximum speed for walker %s!\"), *pWalker->GetName());\n  }\n}", "CodeBleu_score": 45.63871604167735}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n\n    std::vector<SharedPtr<Waypoint>> previous_waypoints = map_->GetPreviousWaypoints(this->id_, distance);\n\n    for (auto &waypoint : previous_waypoints) {\n        result.push_back(SharedPtr<Waypoint>(new Waypoint(map_, waypoint->id_)));\n    }\n\n    return result;\n}", "CodeBleu_score": 55.15459967457438}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n\n    std::vector<SharedPtr<Waypoint>> previous = GetMap()->GetPrevious(this, distance);\n\n    for (auto& previous_waypoint : previous) {\n        result.push_back(previous_waypoint);\n    }\n\n    return result;\n}", "CodeBleu_score": 51.50587214355629}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n    std::vector<Waypoint> waypoints = map_->GetPreviousWaypoints(*this, distance);\n    for (const Waypoint& waypoint : waypoints) {\n        result.push_back(MakeShared<Waypoint>(waypoint));\n    }\n    return result;\n}", "CodeBleu_score": 48.31172687738123}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t// Retrieve all signals within distance\n  std::vector<SharedPtr<Signal>> signals =\n      GetSignalsInDistance(distance, stop_at_junction);\n\n  // Create a set to avoid duplicates\n  std::set<SharedPtr<Signal>> unique_signals;\n  for (SharedPtr<Signal> signal : signals) {\n    unique_signals.insert(signal);\n  }\n\n  // Create a vector of landmarks\n  std::vector<SharedPtr<Landmark>> landmarks;\n\n  // For each unique signal, create a new landmark and add it to the vector\n  for (SharedPtr<Signal> signal : unique_signals) {\n    SharedPtr<Landmark> landmark =\n        std::make_shared<Landmark>(signal->GetId(), signal->GetLocation(),\n                                   signal->GetType(), signal->GetColor());\n    landmarks.push_back(landmark);\n  }\n\n  return landmarks;\n}", "CodeBleu_score": 42.39637556008756}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t// Get the signals within distance\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  // Create a set to store the unique signals\n  std::set<SharedPtr<Signal>> unique_signals;\n  // Iterate through the signals\n  for (SharedPtr<Signal> signal : signals) {\n    // Check if the signal is already in the set\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      // If not, add it to the set\n      unique_signals.insert(signal);\n    }\n  }\n  // Create a vector to store the landmarks\n  std::vector<SharedPtr<Landmark>> landmarks;\n  // Iterate through the unique signals\n  for (SharedPtr<Signal> signal : unique_signals) {\n    // Create a new waypoint\n    Waypoint waypoint(signal->GetTransform());\n    // Create a new landmark\n    Landmark landmark(signal->GetId(), signal->GetTransform());\n    // Add the landmark to the vector\n    landmarks.push_back(SharedPtr<Landmark>(new Landmark(landmark)));\n  }\n  return landmarks;\n}", "CodeBleu_score": 39.352997706835716}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::set<SharedPtr<Signal>> unique_signals;\n  for (SharedPtr<Signal> signal : signals) {\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      unique_signals.insert(signal);\n      SharedPtr<Waypoint> wp = GetMap()->GetWaypoint(signal->GetTransform());\n      SharedPtr<Landmark> landmark = wp->GetLandmark();\n      result.push_back(landmark);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 46.746566398291066}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->ApplySettings(settings, local_timeout);\n  }", "CodeBleu_score": 21.1666198964955}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->ApplySettings(settings, local_timeout);\n  }", "CodeBleu_score": 21.1666198964955}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t_episode.Lock()->SetEpisodeSettings(settings);\n    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->ApplySettings(local_timeout);\n  }", "CodeBleu_score": 23.61429083504992}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t/*\n     * This function, Math::DistanceSegmentToPoint::operator(), calculates the shortest distance from a point to a line segment in 2D space.\nIt first computes the squared length of the segment and its length.\nIf the segment length is zero, it returns zero and the distance from the point to one endpoint.\nOtherwise, it projects the point onto the segment, clamps the projection, and returns the distance along the segment and the distance from the projection to the point.\n     */\n    float operator()(const Vector2f& point, const Vector2f& start, const Vector2f& end) {\n        Vector2f segment = end - start;\n        float squaredSegmentLength = segment.squaredLength();\n        if (squaredSegmentLength == 0) {\n            return { 0.0f, (point - start).length() };\n        }\n\n        float t = segment.dot(point - start) / squaredSegmentLength;\n        t = std::clamp(t, 0.0f, 1.0f);\n        Vector2f projection = start + segment * t;\n        return { (point - projection).length(), t };\n    }\n}", "CodeBleu_score": 39.15495902235482}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t/*!\n     * Computes the shortest distance from a point to a line segment in 2D space.\n     * @param point The point.\n     * @param segmentStart The start of the segment.\n     * @param segmentEnd The end of the segment.\n     * @return A pair containing the distance along the segment and the distance from the projection to the point.\n     */\n    float point, segmentStart, segmentEnd;\n    std::pair<float, float> result;\n\n    result.first = 0.0f;\n    result.second = 0.0f;\n\n    float segmentLengthSquared = (segmentEnd - segmentStart).LengthSquared();\n\n    if (segmentLengthSquared == 0.0f) {\n        result.second = (point - segmentStart).Length();\n        return result;\n    }\n\n    float t = Math::Clamp((point - segmentStart).Dot(segmentEnd - segmentStart) / segmentLengthSquared, 0.0f, 1.0f);\n    result.first = t;\n    result.second = (point - (segmentStart + t * (segmentEnd - segmentStart))).Length();\n    return result;\n}", "CodeBleu_score": 33.23900044847192}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat x1, float y1, float x2, float y2, float x3, float y3,\n    float& distance, float& distanceToPoint\n}", "CodeBleu_score": 8.289179435624488}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tassert(vertices.size() >= 3);\n    index_type initial = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 0; i < vertices.size() - 2; ++i) {\n      AddIndex(initial);\n      AddIndex(initial + i + 1);\n      AddIndex(initial + i + 2);\n    }\n  }", "CodeBleu_score": 49.20921969730038}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tassert(vertices.size() >= 3);\n    AddIndex(static_cast<index_type>(_vertices.size()));\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(static_cast<index_type>(_vertices.size() - 1));\n      AddIndex(static_cast<index_type>(_vertices.size()));\n    }\n  }", "CodeBleu_score": 50.81527264497237}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tassert(vertices.size() >= 3);\n    const auto initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 50.94936875070617}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tif (!message) {\n    throw std::invalid_argument(\"message cannot be nullptr\");\n  }\n  if (message->size() > carla::streaming::detail::tcp::Message::MAX_SIZE) {\n    throw std::invalid_argument(\n        \"message is too large (\" + std::to_string(message->size()) + \" bytes)\");\n  }\n  strand.post([this, message]() {\n    if (!socket.is_open()) {\n      return;\n    }\n    socket.async_write_some(\n        boost::asio::buffer(message->data(), message->size()),\n        [this, message](const boost::system::error_code &ec, std::size_t) {\n          if (ec) {\n            LOG_ERROR(\"failed to send message: \", ec.message());\n            Close();\n          } else {\n            LOG_TRACE(\"message sent\");\n          }\n        });\n  });\n}", "CodeBleu_score": 36.21617082879246}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tif (message->GetDataSize() > 0) {\n    if (message->GetDataSize() > 1000000000) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0xFFFFFFFF) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0xFFFF) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0xFF) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0xF) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0x3) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0x1) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0x0) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0x0) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0x0) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0x0) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0x0) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0x0) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0x0) {\n      throw std::invalid_argument(\"Message too big\");\n    }\n    if (message->GetDataSize() > 0x0) {\n      throw std::invalid_argument(\"Message too", "CodeBleu_score": 20.040356527802366}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tif (message == nullptr) {\n    return;\n  }\n\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  if (_socket == nullptr) {\n    return;\n  }\n\n  _strand.post([this, message]() {\n    if (_socket == nullptr) {\n      return;\n    }\n\n    boost::asio::async_write(\n        *_socket,\n        boost::asio::buffer(message->GetBuffer(), message->GetSize()),\n        _strand.wrap([this](const boost::system::error_code &ec, std::size_t) {\n          if (ec) {\n            if (_socket != nullptr) {\n              _socket->close();\n              _socket = nullptr;\n            }\n            LOG_ERROR(\"Primary::Write error: \" << ec.message());\n          }\n        }));\n  });\n}", "CodeBleu_score": 35.562869980037924}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t// Cancel the deadline timer.\n  deadline_timer_.cancel();\n\n  // If no error code was provided, then assume the socket is open and try to shut it down and close it.\n  if (!ec) {\n    // Shutdown the socket.\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n    // Close the socket.\n    socket_.close(ec);\n  }\n\n  // Trigger the on_closed callback.\n  on_closed_();\n\n  // Log that the session has been closed.\n  LOG(INFO) << \"Session closed.\";\n}", "CodeBleu_score": 41.972808960477636}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (!ec) {\n\t\tboost::system::error_code ignored_ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t}\n\n\tif (socket_.is_open()) {\n\t\tsocket_.close();\n\t}\n\n\tif (on_closed_) {\n\t\ton_closed_();\n\t}\n\n\tLOG_INFO(\"Session closed\");\n}", "CodeBleu_score": 53.0828181342855}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t// Cancel the deadline timer.\n  deadline_timer_.cancel();\n\n  // If no error code is provided and the socket is open, attempt to shut down and close the socket.\n  if (!ec && socket_.is_open()) {\n    boost::system::error_code ignored_ec;\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n    socket_.close(ignored_ec);\n  }\n\n  // Trigger the on_closed callback and log that the session has been closed.\n  if (on_closed_) {\n    on_closed_();\n  }\n  std::cout << \"Session closed\" << std::endl;\n}", "CodeBleu_score": 57.425197846261014}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\tchar buffer[100];\n    sprintf(buffer, \"Are you alive?\");\n    Logger::Log(buffer, Logger::EventType::SEND);\n    this->router->WriteNext(buffer, 100, Router::Command::YOU_ALIVE);\n    this->router->ReadNext();\n    Logger::Log(\"I'm alive!\", Logger::EventType::RECEIVE);\n}", "CodeBleu_score": 25.56944855782193}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tchar buffer[BUFFER_SIZE];\n    sprintf(buffer, \"Are you alive?\");\n    Log::LogWrite(buffer, Log::LOG_COMMAND);\n    WriteToNext(buffer, YOU_ALIVE);\n    Log::LogWrite(buffer, Log::LOG_COMMAND);\n}", "CodeBleu_score": 25.284161419035666}, {"code": "void PrimaryCommands::SendIsAlive(){\n\tchar buffer[BUFFER_SIZE];\n    memset(buffer, 0, BUFFER_SIZE);\n    strcpy(buffer, \"Are you alive?\");\n    Logging::LogMessage(Logging::DEBUG, \"PrimaryCommands::SendIsAlive: Sending message to next router: %s\", buffer);\n    this->WriteToNextRouter(buffer, YOU_ALIVE);\n    Logging::LogMessage(Logging::DEBUG, \"PrimaryCommands::SendIsAlive: Waiting for response from next router...\");\n    this->ReadFromNextRouter();\n    Logging::LogMessage(Logging::DEBUG, \"PrimaryCommands::SendIsAlive: Received response from next router: %s\", this->buffer);\n}", "CodeBleu_score": 33.90321586883527}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t//Create a buffer to send the command to the server\n\tstd::vector<uint8_t> buffer;\n\tbuffer.push_back(static_cast<uint8_t>(Command::ENABLE_ROS));\n\tbuffer.push_back(static_cast<uint8_t>(sensor_id));\n\n\t//Send the buffer to the server using the router\n\trouter->Send(buffer);\n\n\t//Wait for and process the server's response\n\tstd::vector<uint8_t> response = router->Receive();\n\tif (response.size() == 0) {\n\t\tlogger->Log(LogLevel::ERROR, \"PrimaryCommands::SendEnableForROS\", \"The server did not respond to the ENABLE_ROS command.\");\n\t\treturn;\n\t}\n\n\t//Check the response\n\tif (response.at(0) == static_cast<uint8_t>(Command::ENABLE_ROS)) {\n\t\tif (response.at(1) == static_cast<uint8_t>(Command::SUCCESS)) {\n\t\t\tlogger->Log(LogLevel::INFO, \"PrimaryCommands::SendEnableForROS\", \"The server successfully enabled the sensor for ROS.\");\n\t\t}\n\t\telse if (response.at(1) == static_cast<uint8_t>(Command::FAILURE)) {\n\t\t\tlogger->Log(LogLevel::ERROR, \"PrimaryCommands::SendEnableForROS\", \"The server failed to enable the sensor for ROS.\");\n\t\t}\n\t\telse {\n\t\t\tlogger->Log(LogLevel::ERROR, \"PrimaryCommands::SendEnableForROS\", \"The server responded with an invalid response to the ENABLE_ROS command.\");\n\t\t}\n\t}\n\telse {\n\t\tlogger->Log(LogLevel::ERROR, \"PrimaryCommands::SendEnableForROS\", \"The server responded with an invalid response to the ENABLE_ROS command.\");\n\t}\n}", "CodeBleu_score": 35.43747295478693}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Create a buffer for the sensor ID\n    std::string buffer = std::to_string(sensor_id);\n    // Send the command to the router\n    router.SendCommand(\"ENABLE_ROS\", buffer);\n    // Wait for the response\n    std::string response = router.WaitForResponse();\n    // If the response is not a positive response, log an error message\n    if (response != \"1\") {\n        std::cout << \"Error: Could not enable ROS for sensor \" << sensor_id << std::endl;\n    }\n}", "CodeBleu_score": 31.340984459856834}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Create a buffer to store the sensor ID\n    std::vector<uint8_t> buffer;\n    buffer.push_back(sensor_id);\n\n    // Send the command to the router\n    router.SendCommand(buffer, Command::ENABLE_ROS);\n\n    // Wait for the response\n    std::vector<uint8_t> response = router.WaitForResponse();\n\n    // Process the response\n    if (response.size() == 0) {\n        // If the response is empty, the sensor was not found on any server\n        std::cout << \"ERROR: Sensor not found on any server\" << std::endl;\n    } else {\n        // If the response is not empty, the sensor was found on a server\n        // Check if the sensor was enabled on the server\n        if (response[0] == 1) {\n            // If the sensor was enabled, log a success message\n            std::cout << \"Sensor \" << sensor_id << \" enabled on server\" << std::endl;\n        } else {\n            // If the sensor was not enabled, log an error message\n            std::cout << \"ERROR: Sensor \" << sensor_id << \" not enabled on server\" << std::endl;\n        }\n    }\n}", "CodeBleu_score": 47.240866856529315}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tauto it = _token_map.find(sensor_id);\n  if (it != _token_map.end()) {\n    log_info(\"found a token for sensor \", sensor_id);\n    return it->second;\n  }\n  else {\n    log_info(\"sensor \", sensor_id, \" not found, enabling it\");\n    SendEnableSensor(sensor_id);\n    token_type new_token = SendGetToken(sensor_id);\n    _token_map.insert(std::pair<stream_id, token_type>(sensor_id, new_token));\n    return new_token;\n  }\n}", "CodeBleu_score": 49.40102609994883}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tif (sensor_id == 0) {\n    log_error(\"invalid sensor_id\");\n    throw std::runtime_error(\"invalid sensor_id\");\n  }\n\n  auto it = _token_map.find(sensor_id);\n  if (it != _token_map.end()) {\n    log_info(\"token already exists for sensor_id \", sensor_id);\n    return it->second;\n  }\n\n  log_info(\"enabling sensor \", sensor_id);\n  auto new_token = SendGetToken(sensor_id);\n  _token_map.insert(std::make_pair(sensor_id, new_token));\n  log_info(\"token enabled for sensor \", sensor_id);\n  return new_token;\n}", "CodeBleu_score": 47.53341499939114}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tif (sensor_id == 0) {\n    log_error(\"0 is not a valid sensor_id\");\n    return token_type();\n  }\n\n  if (sensor_id == _last_token.get_stream_id()) {\n    log_info(\"reusing token for \", sensor_id);\n    return _last_token;\n  }\n\n  if (_token_map.count(sensor_id) != 0) {\n    log_info(\"reusing token for \", sensor_id);\n    _last_token = _token_map[sensor_id];\n    return _last_token;\n  }\n\n  _last_token = SendGetToken(sensor_id);\n  _token_map[sensor_id] = _last_token;\n  return _last_token;\n}", "CodeBleu_score": 45.39496507956194}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.97093417638999}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!IsReady()) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Navigation system not ready!\"));\n        return false;\n    }\n    if (Crowd == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Crowd object is null!\"));\n        return false;\n    }\n    if (WalkerManager == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: WalkerManager object is null!\"));\n        return false;\n    }\n    if (VehicleManager == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: VehicleManager object is null!\"));\n        return false;\n    }\n\n    int32 agentIndex;\n    if (WalkerMapping.Find(id, agentIndex)) {\n        // UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Found walker agent %d\"), agentIndex);\n        int32 crowdAgentIndex = WalkerManager->GetCrowdAgentIndex(agentIndex);\n        if (crowdAgentIndex != -1) {\n            // UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Found crowd agent %d\"), crowdAgentIndex);\n            Crowd->RemoveAgent(crowdAgentIndex);\n            WalkerManager->RemoveAgent(agentIndex);\n            WalkerMapping.Remove(id);\n            return true;\n        }\n    }\n    if (VehicleMapping.Find(id, agentIndex)) {\n        // UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Found vehicle agent %d\"), agentIndex);\n        int32 crowdAgentIndex = VehicleManager->GetCrowdAgentIndex(agentIndex);\n        if (crowdAgentIndex != -1) {\n            // UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Found crowd agent %d\"), crowdAgentIndex);\n            Crowd->RemoveAgent(crowdAgentIndex);\n            VehicleManager->RemoveAgent(agentIndex);\n            VehicleMapping.Remove(id);\n            return true;\n        }\n    }", "CodeBleu_score": 38.71792356088004}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!IsReady()) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Navigation system is not ready.\"));\n        return false;\n    }\n    if (crowd == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Crowd object is null.\"));\n        return false;\n    }\n\n    // Check if the agent is a walker.\n    if (walkerManager.Contains(id)) {\n        // Critical section to safely remove the agent.\n        {\n            std::lock_guard<std::mutex> lock(crowdMutex);\n            dtCrowdAgent* agent = crowd->getAgent(walkerManager.at(id));\n            if (agent != nullptr) {\n                crowd->removeAgent(walkerManager.at(id));\n            }\n        }\n        walkerManager.erase(id);\n        return true;\n    }\n\n    // Check if the agent is a vehicle.\n    if (vehicleManager.Contains(id)) {\n        // Critical section to safely remove the agent.\n        {\n            std::lock_guard<std::mutex> lock(crowdMutex);\n            dtCrowdAgent* agent = crowd->getAgent(vehicleManager.at(id));\n            if (agent != nullptr) {\n                crowd->removeAgent(vehicleManager.at(id));\n            }\n        }\n        vehicleManager.erase(id);\n        return true;\n    }\n\n    // Agent was not found.\n    UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Agent with id %d was not found.\"), id);\n    return false;\n}", "CodeBleu_score": 45.33378791081194}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!IsReady()) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Navigation system not ready.\"));\n        return false;\n    }\n\n    if (crowd == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Crowd object is null.\"));\n        return false;\n    }\n\n    // find the agent id in the walker mapping\n    auto walker_it = walker_mapping.find(id);\n    if (walker_it != walker_mapping.end()) {\n        // found in walker mapping\n        // enter critical section to safely remove the agent\n        FScopeLock lock(&critical_section);\n\n        // remove the agent from the crowd\n        dtStatus status = crowd->removeAgent(walker_it->second);\n        if (status != DT_SUCCESS) {\n            UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Failed to remove agent from crowd.\"));\n            return false;\n        }\n\n        // remove the agent from the walker manager\n        walker_manager->RemoveWalker(walker_it->second);\n\n        // remove the agent id from the walker mapping\n        walker_mapping.erase(walker_it);\n\n        return true;\n    }\n\n    // find the agent id in the vehicle mapping\n    auto vehicle_it = vehicle_mapping.find(id);\n    if (vehicle_it != vehicle_mapping.end()) {\n        // found in vehicle mapping\n        // enter critical section to safely remove the agent\n        FScopeLock lock(&critical_section);\n\n        // remove the agent from the crowd\n        dtStatus status = crowd->removeAgent(vehicle_it->second);\n        if (status != DT_SUCCESS) {\n            UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Failed to remove agent from crowd.\"));\n            return false;\n        }\n\n        // remove the agent from the vehicle manager\n        vehicle_manager->RemoveVehicle(vehicle_it->second);\n\n        // remove the agent id from the vehicle mapping\n        vehicle_mapping.erase(ve", "CodeBleu_score": 44.956125157932874}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tif (id == 0) {\n        return false;\n    }\n\n    // Find the actor in the walker and vehicle lists.\n    Walker* walker = nullptr;\n    Vehicle* vehicle = nullptr;\n    for (auto& w : walkers) {\n        if (w->id == id) {\n            walker = w;\n            break;\n        }\n    }\n    for (auto& v : vehicles) {\n        if (v->id == id) {\n            vehicle = v;\n            break;\n        }\n    }\n\n    // If the actor is not found, return false.\n    if (walker == nullptr && vehicle == nullptr) {\n        return false;\n    }\n\n    // Enter a critical section.\n    std::lock_guard<std::mutex> lock(crowd_mutex);\n\n    // If the actor is a walker, compute the squared distance to the actor.\n    float squared_distance = 0.0f;\n    if (walker != nullptr) {\n        squared_distance = carla::geom::Math::DistanceSquared(walker->GetLocation(), direction);\n    }\n    // If the actor is a vehicle, compute the squared distance to the actor.\n    else if (vehicle != nullptr) {\n        squared_distance = carla::geom::Math::DistanceSquared(vehicle->GetLocation(), direction);\n    }\n\n    // Use the crowd system to determine if a vehicle is nearby.\n    bool result = false;\n    if (squared_distance <= distance * distance) {\n        dtPolyRef poly_ref;\n        float poly_pos[3];\n        result = crowd->getClosestObstacle(walker->GetLocation().x, walker->GetLocation().y, &poly_ref, poly_pos) != 0;\n    }\n\n    // Return the result.\n    return result;\n}", "CodeBleu_score": 48.90229597039226}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tauto vehicle = GetActorById(id);\n  if (vehicle == nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Navigation: HasVehicleNear: Actor %d not found\"), id);\n    return false;\n  }\n\n  // Check if the actor is a walker\n  if (vehicle->IsWalker()) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Navigation: HasVehicleNear: Actor %d is a walker\"), id);\n    return false;\n  }\n\n  // Check if the actor is a vehicle\n  auto vehicle_pawn = Cast<ACarlaWheeledVehicle>(vehicle->GetRootComponent()->GetOwner());\n  if (vehicle_pawn == nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Navigation: HasVehicleNear: Actor %d is not a vehicle\"), id);\n    return false;\n  }\n\n  // Check if the actor is a vehicle\n  auto controller = Cast<AWheeledVehicleAIController>(vehicle_pawn->GetController());\n  if (controller == nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Navigation: HasVehicleNear: Actor %d is not a vehicle\"), id);\n    return false;\n  }\n\n  // Check if the actor is a vehicle\n  auto crowd_agent = controller->GetCrowdAgent();\n  if (crowd_agent == nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Navigation: HasVehicleNear: Actor %d is not a vehicle\"), id);\n    return false;\n  }\n\n  // Check if the actor is a vehicle\n  auto crowd_manager = controller->GetCrowdManager();\n  if (crowd_manager == nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"Navigation: HasVehicleNear: Actor %d is not a vehicle\"), id);\n    return false;\n  }\n\n  // Check if the actor is a vehicle\n  auto crowd_manager_comp = crowd", "CodeBleu_score": 39.44592971545319}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tauto actor = GetActorById(id);\n  if (actor == nullptr) {\n    return false;\n  }\n\n  // Get the location of the actor\n  auto actor_location = actor->GetLocation();\n\n  // Get the forward vector of the actor\n  auto actor_forward = actor->GetTransform().GetForwardVector();\n\n  // Get the squared distance of the actor\n  auto actor_squared_distance = actor_location.DistanceSquared(actor_location + distance * direction);\n\n  // Check if the actor is a vehicle\n  if (actor->GetParentId() != 0) {\n    return false;\n  }\n\n  // Enter the critical section\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  // Check if the actor is in the walkers or vehicles list\n  auto walker = walkers_.find(id);\n  auto vehicle = vehicles_.find(id);\n  if (walker != walkers_.end() || vehicle != vehicles_.end()) {\n    // Check if a vehicle is nearby\n    if (crowd_manager_->IsVehicleNear(actor_location, actor_forward, actor_squared_distance)) {\n      return true;\n    }\n  }\n\n  return false;\n}", "CodeBleu_score": 50.2819415284746}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tconst auto &route = info.route;\n    const auto &route_point = route[info.route_point];\n    WalkerEventVisitor visitor(id, info, delta);\n    return boost::variant2::visit(visitor, route_point.event);\n}", "CodeBleu_score": 55.288477789717874}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tauto routePoint = info.routePoint;\n  WalkerEventVisitor visitor(info, delta);\n  EventResult result = boost::variant2::visit(visitor, routePoint);\n  return result;\n}", "CodeBleu_score": 50.780931565731855}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t// Get the current route point for the walker.\n  RoutePoint *routePoint = info.GetRoutePoint();\n\n  // Create a WalkerEventVisitor with the current context.\n  WalkerEventVisitor visitor(this, id, info, delta);\n\n  // Use boost::variant2::visit to process the event at the current route point.\n  return boost::variant2::visit(visitor, routePoint->GetEvent());\n}", "CodeBleu_score": 58.87327739402268}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t(void)writer;\n    std::unique_lock<std::mutex> lock(mutex_);\n    if (info.current_count_change == 1) {\n        matched_ = info.total_count;\n        first_connected_ = true;\n    } else if (info.current_count_change == -1) {\n        matched_ = info.total_count;\n    } else if (info.current_count_change != 0) {\n        logError(CARLA_LOG_TAG, \"Unexpected number of matched publications for topic \" << topic_name_);\n    }\n}", "CodeBleu_score": 55.95435235258631}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif(info.current_count_change == 1) {\n        std::cout << \"CarlaListenerImpl::on_publication_matched(): \" << info.current_count << \" matching readers\" << std::endl;\n        this->matched_ = info.current_count;\n        if(info.current_count == 1) {\n            this->first_connected_ = true;\n        }\n    } else if(info.current_count_change == -1) {\n        std::cout << \"CarlaListenerImpl::on_publication_matched(): \" << info.current_count << \" matching readers\" << std::endl;\n        this->matched_ = info.current_count;\n    } else {\n        std::cout << \"CarlaListenerImpl::on_publication_matched(): \" << info.current_count << \" matching readers\" << std::endl;\n        std::cout << \"ERROR: CarlaListenerImpl::on_publication_matched(): \" << info.current_count_change << \" is an invalid value for current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 55.46429530196541}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tstd::lock_guard<std::mutex> lock(mutex_);\n    if(info.current_count_change == 1) {\n        std::cout << \"New publication matched\" << std::endl;\n        matched_ = info.total_count;\n        first_connected_ = true;\n    } else if(info.current_count_change == -1) {\n        std::cout << \"Publication match lost\" << std::endl;\n        matched_ = info.total_count;\n    } else {\n        std::cout << \"ERROR: Unexpected value for current count change: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 64.19874836954266}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n    first_connected = true;\n    std::cout << \"Subscriber matched.\" << std::endl;\n  } else if (info.current_count_change == -1) {\n    std::cout << \"Subscriber unmatched.\" << std::endl;\n  } else {\n    std::cout << \"Subscriber matched error.\" << std::endl;\n  }\n}", "CodeBleu_score": 47.9093610013093}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n\t\tstd::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: \" << info.current_count << std::endl;\n\t\tfirst_connected = true;\n\t} else if (info.current_count_change == -1) {\n\t\tstd::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: \" << info.current_count << std::endl;\n\t\tfirst_connected = false;\n\t} else {\n\t\tstd::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 58.64271817272978}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched\" << std::endl;\n        first_connected = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched\" << std::endl;\n        if (info.total_count == 0) {\n            std::cout << \"No subscribers, deleting subscriber\" << std::endl;\n            delete this;\n        }\n    } else {\n        std::cout << \"on_subscription_matched error, invalid count change\" << std::endl;\n    }\n}", "CodeBleu_score": 57.91336760221122}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n\n    // Object that manages the raw buffer.\n    FastBuffer fastbuffer(1024);\n\n    // Object that writes the key fields to the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\n    // Write the object to the raw buffer.\n    p_type->serializeKey(ser);\n\n    // Move the buffer length to its actual size.\n    fastbuffer.length(ser.getSerializedDataLength());\n\n    // MD5 is calculated from the raw buffer.\n    if (force_md5 || eprosima::fastrtps::rtps::PParamSecurity::is_security_enabled()) {\n        m_md5.init();\n        m_md5.update(fastbuffer.data(), fastbuffer.length());\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        // In case of fastcdr serialization, a memcpy is performed.\n        memcpy(handle->value, fastbuffer.data(), 16);\n    }\n    return true;\n}", "CodeBleu_score": 61.053399762391706}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n\n    // Object that manages the raw buffer.\n    FastBuffer fastbuffer(1024);\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\n    // Serialize the key.\n    p_type->serializeKey(ser);\n\n    // Move to the beginning of the stream.\n    ser.first();\n    // Object that holds the serialized data.\n    SerializedPayload_t payload = ser.dserialize();\n\n    // If the data is not internal, move the ownership to the handle object.\n    if (!m_keyBuffer) {\n        payload.data = payload.buffer;\n    }\n    // Store the serialized data in the handle.\n    storeSerializedData(handle, payload, m_keyBuffer);\n\n    return true;\n}", "CodeBleu_score": 34.747172773873615}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*) data;\n\n    // Object that manages the raw buffer.\n    FastBuffer fastbuffer(1024);\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serialize(ser);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer2(1024);\n\n    // Object that deserializes the data.\n    eprosima::fastcdr::Cdr deser(fastbuffer2, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    deser.setKeyBuffer(p_type->getKeyBuffer(), p_type->getKeyBufferSize());\n    deser.deserialize(p_type);\n\n    // If the data is not internal, move the buffer so it can be reused.\n    if (!p_type->isInternal()) {\n        p_type->stealKeyBuffer(p_type->getKeyBufferSize());\n    }\n\n    // Set the handle in the hash map.\n    return true;\n}", "CodeBleu_score": 34.34112293857559}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    // Serialize encapsulation.\n    ser.serialize_encapsulation();\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 82.8635574758957}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\n    // Serialize encapsulation.\n    ser.serialize_encapsulation();\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\n    return true;\n}", "CodeBleu_score": 82.6428481541292}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n  eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n  eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n  payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n  // Serialize encapsulation\n  ser.serialize_encapsulation();\n\n  try {\n    // Serialize the object.\n    p_type->serialize(ser);\n  } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n    return false;\n  }\n\n  // Get the serialized length\n  payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n  return true;\n}", "CodeBleu_score": 97.73932531671106}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV:\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV_ADDED:\n\tcase MAVLINK_MSG_ID_LOCAL_POSITION_NED:\n\tcase MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV:\n\tcase MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV_ADDED:\n\tcase MAVLINK_MSG_ID_GLOBAL_VELOCITY_INT:\n\tcase MAVLINK_MSG_ID_LOCAL_VELOCITY_NED:\n\tcase MAVLINK_MSG_ID_ATTITUDE:\n\tcase MAVLINK_MSG_ID_ATTITUDE_TARGET:\n\tcase MAVLINK_MSG_ID_ATTITUDE_QUATERNION:\n\tcase MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV:\n\tcase MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV_ADDED:\n\tcase MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CORRECTED:\n\tcase MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CORRECTED_COV:\n\tcase MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CORRECTED_COV_ADDED:\n\tcase MAVLINK_MSG_ID_ATTITUDE_QUATERNION_CORRECTED_ESTIMATED:", "CodeBleu_score": 14.198677673961274}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (target_set) {\n        return;\n    }\n\n    switch (msg.msgid) {\n\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n    case MAVLINK_MSG_ID_SCALED_PRESSURE:\n    case MAVLINK_MSG_ID_ATTITUDE:\n    case MAVLINK_MSG_ID_VFR_HUD:\n    case MAVLINK_MSG_ID_SYS_STATUS:\n    case MAVLINK_MSG_ID_MISSION_CURRENT:\n    case MAVLINK_MSG_ID_MISSION_REQUEST_LIST:\n    case MAVLINK_MSG_ID_MISSION_REQUEST:\n    case MAVLINK_MSG_ID_MISSION_COUNT:\n    case MAVLINK_MSG_ID_MISSION_ITEM_INT:\n    case MAVLINK_MSG_ID_MISSION_REQUEST_INT:\n    case MAVLINK_MSG_ID_MISSION_SET_CURRENT:\n    case MAVLINK_MSG_ID_MISSION_ITEM:\n    case MAVLINK_MSG_ID_MISSION_CLEAR_ALL:\n    case MAVLINK_MSG_ID_MISSION_COUNT_REPLY:\n    case MAVLINK_MSG_ID_MISSION_ITEM_REPLY:\n    case MAVLINK_MSG_ID_MISSION_REQUEST_REPLY:\n    case MAVLINK_MSG_ID_MISSION_ACK:\n    case MAVLINK_MSG_ID_MISSION_ITEM_INT_REPLY:\n    case MAVLINK_MSG_ID_MISSION_ITEM_REPLY_INT:\n    case MAVLINK_MSG_ID_MISSION_SET_GLOBAL_CURRENT:\n    case MAVLINK_MSG_ID_MISSION_SET_GLOBAL_CURRENT_REPLY:\n    case MAVLINK_MSG_ID_PARAM_REQUEST_", "CodeBleu_score": 16.01466954539719}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t// If the target has already been set, exit immediately\n  if (target_set) return;\n\n  // Decode the MAVLink message\n  mavlink_msg_to_gcs_t msg_to_gcs;\n  mavlink_msg_to_gcs_decode(&msg, &msg_to_gcs);\n\n  // If the message type is not one that should be tracked, exit immediately\n  if (msg_to_gcs.msg_type != MAVLINK_MSG_ID_GLOBAL_POSITION_INT &&\n      msg_to_gcs.msg_type != MAVLINK_MSG_ID_AIR_PRESSURE &&\n      msg_to_gcs.msg_type != MAVLINK_MSG_ID_SYS_STATUS) return;\n\n  // If the target system ID is not set, set it to the target and request position and air pressure data streams from the target\n  if (target_sysid == 0) {\n    target_sysid = msg_to_gcs.sysid;\n    mavlink_msg_request_data_stream_send(mavlink_fd, target_sysid, target_compid, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 0, 10);\n    mavlink_msg_request_data_stream_send(mavlink_fd, target_sysid, target_compid, MAVLINK_MSG_ID_AIR_PRESSURE, 0, 10);\n  }\n\n  // Flag that the target has been set\n  target_set = true;\n}", "CodeBleu_score": 36.70623924114912}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_generic(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_cal_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 51.949161098114985}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = MAV_RESULT_ACCEPTED;\n    mavlink_command_long_t cmd;\n    mavlink_msg_command_long_decode(&msg, &cmd);\n    result = MAV_RESULT_ACCEPTED;\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_baro_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 54.87803695445723}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK_Tracker::_handle_command_preflight_calibration(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _baro_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 55.96757008064941}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    // check if command is supported\n    if (packet.param1 == 1.0) {\n        // arm the servos\n        result = MAV_RESULT_ACCEPTED;\n        // set the armed state\n        set_armed(true);\n    } else if (packet.param1 == 0.0) {\n        // disarm the servos\n        result = MAV_RESULT_ACCEPTED;\n        // set the armed state\n        set_armed(false);\n    }\n\n    return result;\n}", "CodeBleu_score": 52.70016915306132}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n  if (packet.param1 == 1.0) {\n    result = MAV_RESULT_ACCEPTED;\n    servos.arm();\n  } else if (packet.param1 == 0) {\n    result = MAV_RESULT_ACCEPTED;\n    servos.disarm();\n  }\n  return result;\n}", "CodeBleu_score": 56.72381661268297}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tif (packet.param1 == 1.0) {\n    // Arming\n    if (servos.arm()) {\n      return MAV_RESULT_ACCEPTED;\n    } else {\n      return MAV_RESULT_FAILED;\n    }\n  } else if (packet.param1 == 0.0) {\n    // Disarming\n    if (servos.disarm()) {\n      return MAV_RESULT_ACCEPTED;\n    } else {\n      return MAV_RESULT_FAILED;\n    }\n  } else {\n    return MAV_RESULT_UNSUPPORTED;\n  }\n}", "CodeBleu_score": 57.16117910336811}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// iterate over all available channels\n  for (uint8_t channel = 0; channel < GCS_CHANNEL_COUNT; channel++) {\n    // check if channel is available\n    if (mavlink_channels[channel].sysid == 0 && mavlink_channels[channel].compid == 0) {\n      // check if channel has available payload space\n      if (mavlink_channels[channel].payload_length < MAVLINK_MSG_ID_HIL_STATE_QUATERNION_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n        // request position data stream\n        mavlink_msg_hil_state_quaternion_pack(mavlink_channels[channel].sysid, mavlink_channels[channel].compid, &mavlink_channels[channel].last_msg, mavlink_channels[channel].sysid, mavlink_channels[channel].compid, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "CodeBleu_score": 39.358028718244164}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// Iterate over all available GCS channels and check if there is space for a new data stream\n    for (uint8_t i = 0; i < GCS_CHANNEL_COUNT; i++) {\n        if (gcs_channels[i].is_free()) {\n            // If space is available, send a request to start the data stream on the corresponding channel\n            gcs_channels[i].request_datastream_position(sysid, compid, GCS_DATASTREAM_POSITION_RATE);\n            return;\n        }\n    }\n}", "CodeBleu_score": 35.253627633750206}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// check if we have a free channel\n  for (int i = 0; i < GCS_CHANNELS; i++) {\n    if (!_channel_status[i]) {\n      // send request\n      mavlink_message_t msg;\n      mavlink_msg_request_data_stream_pack(GCS_SYSTEM_ID, GCS_COMPONENT_ID, &msg, i, 0, sysid, compid, MAV_DATA_STREAM_POSITION, 10);\n      _mavlink_interface->send_message(msg);\n      // set status\n      _channel_status[i] = true;\n      return;\n    }\n  }\n}", "CodeBleu_score": 47.2131726395131}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAHRS* ahrs = AHRS::getInstance();\n\tfloat pitch_cos = cos(pitch);\n\tif (pitch_cos != 0) {\n\t\tef_pitch = atan2(pitch_cos * sin(yaw), pitch_cos * cos(yaw));\n\t\tef_yaw = atan2(sin(pitch), -cos(pitch) * sin(yaw));\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 40.19214093529961}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAHRS* ahrs = AHRS::get_instance();\n\tif (ahrs == NULL) {\n\t\treturn false;\n\t}\n\t\n\tfloat pitch_cosine = cosf(pitch);\n\tif (pitch_cosine == 0.0f) {\n\t\treturn false;\n\t}\n\t\n\tef_pitch = atan2f(sinf(pitch) * sinf(yaw), pitch_cosine);\n\tef_yaw = atan2f(sinf(pitch) * cosf(yaw), cosf(pitch));\n\t\n\treturn true;\n}", "CodeBleu_score": 39.76283015076763}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAHRS* ahrs = AHRS::get_instance();\n    if (ahrs->get_pitch_cos() != 0.0f) {\n        ef_pitch = atan2f(ahrs->get_pitch_sin() * ahrs->get_roll_cos() - ahrs->get_yaw_sin() * ahrs->get_pitch_sin() * ahrs->get_roll_sin(),\n                          ahrs->get_pitch_cos() * ahrs->get_roll_cos() + ahrs->get_yaw_cos() * ahrs->get_pitch_sin() * ahrs->get_roll_sin());\n        ef_yaw = atan2f(ahrs->get_pitch_sin() * ahrs->get_roll_sin() + ahrs->get_yaw_sin() * ahrs->get_pitch_cos() * ahrs->get_roll_cos(),\n                        ahrs->get_pitch_cos() * ahrs->get_roll_cos() - ahrs->get_yaw_cos() * ahrs->get_pitch_sin() * ahrs->get_roll_sin());\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 34.93206580338597}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t// get navigation status\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n\n    // get parameters\n    Parameters &g = tracker.g;\n\n    // calculate target yaw and pitch in centi-degrees\n    float yaw_target = wrap_180_cd((nav_status.bearing+g.yaw_trim)*100);\n    float pitch_target = (nav_status.distance*100) + g.pitch_trim;\n\n    // check if direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    float yaw_angle_error_upper;\n    float yaw_angle_error_lower;\n    if (yaw_target >= 0) {\n        yaw_angle_error_upper = yaw_target;\n        yaw_angle_error_lower = yaw_target - 36000;\n    } else {\n        yaw_angle_error_upper = 36000 + yaw_target;\n        yaw_angle_error_lower = yaw_target;\n    }\n\n    // checks that the vehicle is outside the tracker's range\n    if ((yaw_angle_error_lower < g.yaw_range) && (yaw_angle_error_upper > g.yaw_range)) {\n        // if the tracker is trying to move clockwise to reach the vehicle,\n        // but the tracker could get closer to the vehicle by moving counter-clockwise then set direction_reversed to true\n        if (yaw_target>0 && ((g.yaw_range - yaw_angle_error_lower) < (yaw_angle_error_upper - g.yaw_range))) {\n            direction_reversed = true;\n        }\n        // if the tracker is trying to move counter-clockwise to reach the vehicle,\n        // but the tracker could get closer to the vehicle by moving then set direction_reversed to true\n        if (yaw_target<", "CodeBleu_score": 54.635891606326695}, {"code": "void Mode::update_auto(void){\n\t// calculate the target yaw and pitch in centi-degrees\n    Parameters &g = tracker.g;\n    float yaw_target = wrap_180_cd((g.yaw_trim + tracker.nav_status.bearing) * 100);\n    float pitch_target = (tracker.nav_status.distance * 0.01f) * g.pitch_range;\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    float yaw_angle_error_upper;\n    float yaw_angle_error_lower;\n    if (yaw_target >= 0) {\n        yaw_angle_error_upper = yaw_target;\n        yaw_angle_error_lower = yaw_target - 36000;\n    } else {\n        yaw_angle_error_upper = 36000 + yaw_target;\n        yaw_angle_error_lower = yaw_target;\n    }\n\n    // checks that the vehicle is outside the tracker's range\n    if ((yaw_angle_error_lower < g.yaw_range) && (yaw_angle_error_upper > g.yaw_range)) {\n        // if the tracker is trying to move clockwise to reach the vehicle,\n        // but the tracker could get closer to the vehicle by moving counter-clockwise then set direction_reversed to true\n        if (yaw_target>0 && ((g.yaw_range - yaw_angle_error_lower) < (yaw_angle_error_upper - g.yaw_range))) {\n            direction_reversed = true;\n        }\n        // if the tracker is trying to move counter-clockwise to reach the vehicle,\n        // but the tracker could get closer to the vehicle by moving then set direction_reversed to true\n        if (yaw_target<0 && ((g.yaw_range - yaw_angle_error_lower) >", "CodeBleu_score": 44.25651629356573}, {"code": "void Mode::update_auto(void){\n\t// calculate target pitch and yaw in earth frame\n    Parameters &g = tracker.g;\n    float yaw_angle_target = wrap_180_cd((tracker.nav_status.bearing+g.yaw_trim)*100);\n    float pitch_angle_target = (tracker.nav_status.distance*100) + (tracker.nav_status.altitude*100);\n\n    // check if the direction needs to be reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    float yaw_angle_error_upper;\n    float yaw_angle_error_lower;\n    if (yaw_angle_target >= 0) {\n        yaw_angle_error_upper = yaw_angle_target;\n        yaw_angle_error_lower = yaw_angle_target - 36000;\n    } else {\n        yaw_angle_error_upper = 36000 + yaw_angle_target;\n        yaw_angle_error_lower = yaw_angle_target;\n    }\n\n    // checks that the vehicle is outside the tracker's range\n    if ((yaw_angle_error_lower < g.yaw_range_cd) && (yaw_angle_error_upper > g.yaw_range_cd)) {\n        // if the tracker is trying to move clockwise to reach the vehicle,\n        // but the tracker could get closer to the vehicle by moving counter-clockwise then set direction_reversed to true\n        if (yaw_angle_target>0 && ((g.yaw_range_cd - yaw_angle_error_lower) < (yaw_angle_error_upper - g.yaw_range_cd))) {\n            direction_reversed = true;\n        }\n        // if the tracker is trying to move counter-clockwise to reach the vehicle,\n        // but the tracker could get closer to the vehicle by moving then set direction_reversed to true\n        if (y", "CodeBleu_score": 44.36227169087501}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t// update the GPS data\n\tgps.read();\n\n\t// check if the last message time has changed\n\tif (gps.time.age() < 1000) {\n\t\t// check if the GPS status is at least 3D fix\n\t\tif (gps.status >= 3) {\n\t\t\t// check if the location is valid\n\t\t\tif (gps.location.isValid()) {\n\t\t\t\t// check if the altitude is valid\n\t\t\t\tif (gps.altitude.isValid()) {\n\t\t\t\t\t// check if the countdown is not zero\n\t\t\t\t\tif (countdown > 0) {\n\t\t\t\t\t\t// decrement the countdown\n\t\t\t\t\t\tcountdown--;\n\t\t\t\t\t}\n\t\t\t\t\t// check if the countdown is one\n\t\t\t\t\tif (countdown == 1) {\n\t\t\t\t\t\t// set the home location\n\t\t\t\t\t\thome_location.lat = gps.location.lat();\n\t\t\t\t\t\thome_location.lon = gps.location.lng();\n\t\t\t\t\t\thome_location.alt = gps.altitude.meters();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// check if the location is invalid\n\t\t\telse {\n\t\t\t\t// reset the countdown\n\t\t\t\tcountdown = 30;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.76456959114504}, {"code": "void Tracker::update_GPS(void){\n\tstatic int ground_start_countdown = 0;\n  static bool ground_start_countdown_started = false;\n  static bool home_set = false;\n  static float home_lat = 0.0;\n  static float home_lon = 0.0;\n  static float home_alt = 0.0;\n  static bool home_valid = false;\n  static float last_lat = 0.0;\n  static float last_lon = 0.0;\n  static float last_alt = 0.0;\n  static bool last_valid = false;\n  static uint32_t last_time = 0;\n  static uint32_t last_home_time = 0;\n  static uint32_t last_gps_time = 0;\n  static uint32_t last_gps_fix_time = 0;\n  static uint32_t last_gps_fix_type = 0;\n  static uint32_t last_gps_sat_count = 0;\n  static uint32_t last_gps_sat_count_type = 0;\n  static uint32_t last_gps_fix_type_time = 0;\n  static uint32_t last_gps_sat_count_type_time = 0;\n  static uint32_t last_gps_sat_count_time = 0;\n\n  uint32_t current_time = millis();\n  uint32_t current_gps_time = GPS.time;\n  uint32_t current_gps_fix_time = GPS.fix_age;\n  uint32_t current_gps_fix_type = GPS.fix_type;\n  uint32_t current_gps_sat_count = GPS.satellites;\n  uint32_t current_gps_sat_count_type = GPS.satellites_type;\n\n  if (current_gps_time != last_gps_time) {\n    last_gps_time = current_gps_time;", "CodeBleu_score": 29.82346186881583}, {"code": "void Tracker::update_GPS(void){\n\t// If the GPS is not initialized, initialize it\n  if (!GPS_init) {\n    // Set the GPS baud rate\n    GPS.begin(GPS_BAUD);\n    // Set the GPS baud rate to the GPS\n    GPS.sendCommand(PMTK_SET_BAUD_57600);\n    // Set the update rate to 1000ms\n    GPS.sendCommand(PMTK_SET_NMEA_UPDATE_1HZ);\n    // Set the GPS to send out RMC (recommended minimum) and GGA (fix data)\n    GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCGGA);\n    // Set the GPS to send out GLL (geographic position)\n    GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_GLLONLY);\n    // Set the GPS to send out VTG (course over ground and ground speed)\n    GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_VTGONLY);\n    // Request updates on antenna status, comment out to keep quiet\n    GPS.sendCommand(PGCMD_ANTENNA);\n    // Request firmware version\n    GPS.sendCommand(PGCMD_VERSION);\n    delay(1000);\n    // Set the GPS to output only the NMEA data\n    GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_OFF);\n    // Request updates on antenna status, comment out to keep quiet\n    GPS.sendCommand(PGCMD_ANTENNA);\n    delay(1000);\n    // Set the GPS to output only the NMEA data\n    GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCGGA);\n    // Request updates on antenna status, comment out to keep quiet\n    GPS.sendCommand(PGCMD_ANTENNA);\n    delay(1000);\n    // Set the GPS to output only the NMEA data\n    GPS.sendCommand(PMTK_SET_", "CodeBleu_score": 26.501194400556805}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t//Serial.print(\"pitch: \");\n  //Serial.println(pitch);\n  //Serial.print(\"pitch_servo_pos: \");\n  //Serial.println(pitch_servo_pos);\n  //Serial.print(\"pitch_servo_min: \");\n  //Serial.println(pitch_servo_min);\n  //Serial.print(\"pitch_servo_max: \");\n  //Serial.println(pitch_servo_max);\n  //Serial.print(\"pitch_servo_mid: \");\n  //Serial.println(pitch_servo_mid);\n  //Serial.print(\"pitch_servo_range: \");\n  //Serial.println(pitch_servo_range);\n  //Serial.print(\"pitch_servo_range_mid: \");\n  //Serial.println(pitch_servo_range_mid);\n  //Serial.print(\"pitch_servo_range_min: \");\n  //Serial.println(pitch_servo_range_min);\n  //Serial.print(\"pitch_servo_range_max: \");\n  //Serial.println(pitch_servo_range_max);\n\n  if (pitch > 0) {\n    pitch_servo_pos = pitch_servo_min + (pitch_servo_range * pitch);\n  }\n  else {\n    pitch_servo_pos = pitch_servo_max + (pitch_servo_range * pitch);\n  }\n\n  //Serial.print(\"pitch_servo_pos: \");\n  //Serial.println(pitch_servo_pos);\n\n  //pitch_servo.write(pitch_servo_pos);\n}", "CodeBleu_score": 15.712063527224899}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t//Serial.println(pitch);\n  if (pitch > 0) {\n    pitch_onoff_servo.write(pitch);\n  }\n  else {\n    pitch_onoff_servo.write(0);\n  }\n}", "CodeBleu_score": 14.53977991516728}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\tif (pitch > 15) {\n    pitch = 15;\n  }\n  if (pitch < -15) {\n    pitch = -15;\n  }\n  //pitch = constrain(pitch, -15, 15);\n  //Serial.print(\"pitch: \");\n  //Serial.println(pitch);\n  //pitch = map(pitch, -15, 15, 0, 180);\n  //Serial.print(\"pitch: \");\n  //Serial.println(pitch);\n  //pitch = map(pitch, -15, 15, 180, 0);\n  //Serial.print(\"pitch: \");\n  //Serial.println(pitch);\n  //pitch = map(pitch, -15, 15, 0, 180);\n  //Serial.print(\"pitch: \");\n  //Serial.println(pitch);\n  //pitch = map(pitch, -15, 15, 180, 0);\n  //Serial.print(\"pitch: \");\n  //Serial.println(pitch);\n  //pitch = map(pitch, -15, 15, 0, 180);\n  //Serial.print(\"pitch: \");\n  //Serial.println(pitch);\n  //pitch = map(pitch, -15, 15, 180, 0);\n  //Serial.print(\"pitch: \");\n  //Serial.println(pitch);\n  //pitch = map(pitch, -15, 15, 0, 180);\n  //Serial.print(\"pitch: \");\n  //Serial.println(pitch);\n  //pitch = map(pitch, -15, 15, 180, 0);\n  //Serial.print(\"pitch: \");\n  //Serial.println(pitch);\n  //pitch = map(pitch, -15, 15, 0, 180);\n  //Serial.print(\"pitch: \");\n  //Serial", "CodeBleu_score": 9.276445215774078}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming_Base::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (g.arming_check_baro) {\n        float baro_alt = _ahrs->get_altitude();\n        float baro_ref = _ahrs->get_pressure_altitude();\n        float baro_diff = baro_alt - baro_ref;\n        if (fabsf(baro_diff) > g.baro_alt_max_diff) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Baro altitude check failed: %.1f m\n\"), (double)baro_diff);\n            }\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 48.67179113549245}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t// call the base class barometer_checks\n\tif (!AP_Arming_Base::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n#if ARMING_CHECK_BARO\n\t// check barometer reference\n\tif (!_gps.baro_healthy()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Baro not healthy\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check barometer altitude\n\tfloat baro_alt = _gps.altitude();\n\tfloat inertial_alt = _gps.altitude_ellipsoid();\n\tif (fabsf(baro_alt - inertial_alt) > AP_BARO_CHECK_FAIL_DELTA) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Baro altitude check failed: %f, %f\", (double)baro_alt, (double)inertial_alt);\n\t\t}\n\t\treturn false;\n\t}\n#endif\n\n\treturn true;\n}", "CodeBleu_score": 45.3699193545737}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming_Base::barometer_checks(display_failure)) {\n        return false;\n    }\n\n#if ARMING_CHECK_BARO\n    // get barometer altitude\n    float baro_alt = barometer.get_altitude();\n\n    // get inertial navigation altitude\n    float inertial_nav_alt = inertial_nav.get_altitude();\n\n    // get barometer reference altitude\n    float baro_ref_alt = barometer.get_altitude_reference();\n\n    // calculate baro altitude disparity\n    float baro_alt_disparity = baro_alt - baro_ref_alt;\n\n    // check baro altitude disparity\n    if (fabsf(baro_alt_disparity) > AP_INERTIAL_NAV_INTEGRATION_BARO_ALT_DISPARITY_THRESHOLD) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Baro altitude disparity too high: %f\", (double)baro_alt_disparity);\n        }\n        return false;\n    }\n#endif\n\n    return true;\n}", "CodeBleu_score": 45.74074327038996}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (ap.land_rtl_alt_type == RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming_Base::terrain_database_required();\n}", "CodeBleu_score": 29.242145214166506}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\treturn _terrain_source == terrain_source_t::terrain_database && _rtl_alt_type == rtl_alt_type_t::terrain;\n}", "CodeBleu_score": 6.667692431425144}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (g.rtl_alt_type == RTL_ALT_TERRAIN) {\n        if (g.rangefinder_enabled) {\n            return false;\n        } else {\n            return true;\n        }\n    } else {\n        return AP_Arming_Base::terrain_database_required();\n    }\n}", "CodeBleu_score": 48.06377293064953}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t// set the loop time used by the controllers\n    float dt = (float)scheduler.micros() * 1e-6f;\n    if (dt > 0.5f) {\n        // the last loop time from the scheduler was very long ago\n        dt = 0.02f;\n    }\n    attitude_control.set_dt(dt);\n    rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin speeds\n    attitude_control.rate_controller_run();\n\n    // run the rate controller to calculate the desired attitude rates\n    // and the desired motor spin", "CodeBleu_score": 48.161089993499104}, {"code": "void Copter::run_rate_controller(){\n\t// set loop time\n    const uint32_t now = micros();\n    const uint32_t loop_time_us = now - last_run_time;\n    last_run_time = now;\n\n    // run the attitude controller\n    attitude_control.rate_controller_run(loop_time_us);\n\n    // run the position controller\n    if (control_mode == POSITION_CONTROL) {\n        position_control.rate_controller_run(loop_time_us);\n    }\n\n    // run the motor controller\n    motor_control.rate_controller_run(loop_time_us);\n\n    // run the gps controller\n    if (control_mode == POSITION_CONTROL) {\n        gps_control.rate_controller_run(loop_time_us);\n    }\n\n    // run the range finder controller\n    if (control_mode == POSITION_CONTROL) {\n        range_finder_control.rate_controller_run(loop_time_us);\n    }\n\n    // run the sonar controller\n    if (control_mode == POSITION_CONTROL) {\n        sonar_control.rate_controller_run(loop_time_us);\n    }\n\n    // run the barometer controller\n    if (control_mode == POSITION_CONTROL) {\n        barometer_control.rate_controller_run(loop_time_us);\n    }\n\n    // run the flow controller\n    if (control_mode == POSITION_CONTROL) {\n        flow_control.rate_controller_run(loop_time_us);\n    }\n\n    // run the optical flow controller\n    if (control_mode == POSITION_CONTROL) {\n        optical_flow_control.rate_controller_run(loop_time_us);\n    }\n\n    // run the vibration controller\n    vibration_control.rate_controller_run(loop_time_us);\n\n    // run the battery controller\n    if (control_mode == POSITION_CONTROL) {\n        battery_control.rate_controller_run(loop_time_us);\n    }", "CodeBleu_score": 42.60005705271598}, {"code": "void Copter::run_rate_controller(){\n\t// get the current time\n    uint32_t now = micros();\n\n    // calculate the loop time in seconds\n    float delta_time = (now - last_loop_time) / 1000000.0f;\n\n    // set the loop time for the attitude controller\n    attitude_control.set_loop_time(delta_time);\n\n    // set the loop time for the position controller\n    position_control.set_loop_time(delta_time);\n\n    // set the loop time for the motor controller\n    motor_control.set_loop_time(delta_time);\n\n    // run the rate controllers\n    attitude_control.rate_controller_run();\n    position_control.rate_controller_run();\n    motor_control.rate_controller_run();\n\n    // set the last loop time\n    last_loop_time = now;\n}", "CodeBleu_score": 50.527527409325124}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    return mode_guided.update_destination(old_loc, new_loc);\n}", "CodeBleu_score": 38.37259811153257}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t// exit immediately if not in Guided or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // exit immediately if the old and new locations match\n    if (old_loc == new_loc) {\n        return false;\n    }\n\n    // exit immediately if the altitude frames of the old and new locations are not the same\n    if (old_loc.alt_cm != new_loc.alt_cm) {\n        return false;\n    }\n\n    // set the new location as the target location\n    return set_target_location(new_loc);\n}", "CodeBleu_score": 59.407268546746714}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // get the next waypoint location\n    Location next_wp_loc = mission.get_next_nav_location();\n\n    // check if the old location matches the next waypoint location\n    if (old_loc.lat == next_wp_loc.lat && old_loc.lng == next_wp_loc.lng) {\n        // check if the altitude frames of the old and new locations are the same\n        if (old_loc.alt_relative == new_loc.alt_relative) {\n            // set the new location as the target\n            return set_target_location(new_loc);\n        }\n    }\n\n    // if we get here, return false\n    return false;\n}", "CodeBleu_score": 61.187165604518114}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (aux_switch_pos(ch_flag)) {\n        set_mode(mode);\n    } else if (mode == get_mode()) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 41.155458009965926}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (aux_function_change_mode_enabled) {\n    if (aux_function_change_mode_enabled_flag == ch_flag) {\n      if (aux_function_change_mode_enabled_flag == AuxSwitchPos::HIGH) {\n        if (aux_function_change_mode_enabled_flag == AuxSwitchPos::HIGH) {\n          if (rc().aux_switch_2 == AuxSwitchPos::HIGH) {\n            if (rc().aux_switch_3 == AuxSwitchPos::HIGH) {\n              if (rc().aux_switch_4 == AuxSwitchPos::HIGH) {\n                set_mode(mode);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 41.150488040597985}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t// if the aux switch is in the HIGH position, attempt to set the mode\n    if (aux_switch_position(ch_flag) == AUX_SWITCH_HIGH) {\n        // set the mode\n        copter().set_mode(mode);\n    }else{\n        // if the aux switch is not in the HIGH position and the current flight mode matches the given mode, reset the mode switch\n        if (copter().flight_mode() == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 59.83594925832255}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t// get the roll and pitch trim values from the control inputs\n    int16_t roll_trim = (int16_t)((float)rc_1.control_in / (float)rc_1.control_mid * 1000.0f);\n    int16_t pitch_trim = (int16_t)((float)rc_2.control_in / (float)rc_2.control_mid * 1000.0f);\n\n    // convert to radians\n    roll_trim *= 0.0174532925f;\n    pitch_trim *= 0.0174532925f;\n\n    // add to the AHRS trim\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log the event\n    Log_Write_Event(DATA_TRIM_SAVED);\n\n    // send a confirmation message with MAV_SEVERITY_INFO\n    mavlink_log_info(&mavlink_log_pub, \"Trim saved\");\n}", "CodeBleu_score": 46.84799623162499}, {"code": "void Copter::save_trim(){\n\t// get the current trim\n    Vector3f trim = ahrs.get_trim();\n    // get the current control inputs\n    float roll_in = channel_roll->get_control_in();\n    float pitch_in = channel_pitch->get_control_in();\n    // convert to radians\n    float roll_trim = roll_in * 0.01745329252f;\n    float pitch_trim = pitch_in * 0.01745329252f;\n    // add to trim\n    trim.x += roll_trim;\n    trim.y += pitch_trim;\n    // set new trim\n    ahrs.set_trim(trim);\n    // log event\n    Log_Write_Event(DATA_TRIM_SAVED);\n    // send confirmation message\n    mavlink_log_info(&mavlink_log_pub, \"Trim saved\");\n}", "CodeBleu_score": 48.577012390031854}, {"code": "void Copter::save_trim(){\n\t// get the trim values from the channels\n    float roll_trim = get_radio_in(RC_ROLL) - 1500;\n    float pitch_trim = get_radio_in(RC_PITCH) - 1500;\n\n    // convert to radians\n    roll_trim *= 0.00122173f;\n    pitch_trim *= 0.00122173f;\n\n    // add to the AHRS\n    ahrs.set_trim(roll_trim, pitch_trim);\n\n    // log the event\n    Log_Write_Event(DATA_TRIM_SAVED);\n\n    // send a confirmation message\n    mavlink_log_info(&mavlink_log_pub, \"Trim saved\");\n}", "CodeBleu_score": 52.070142771205475}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// get velocity\n    Vector3f velocity = vehicle->get_velocity();\n\n    // check for valid position\n    if (!vehicle->get_position()->valid()) {\n        return 0.0f;\n    }\n\n    // calculate speed squared\n    float speed_squared = velocity.length2();\n\n    // check for minimum speed\n    if (speed_squared < MIN_SPEED_SQUARED) {\n        return 0.0f;\n    }\n\n    // calculate look-ahead yaw angle\n    float look_ahead_yaw = atan2f(velocity.z, velocity.x);\n\n    // return look-ahead yaw angle\n    return look_ahead_yaw;\n}", "CodeBleu_score": 44.82884403129284}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// retrieve the copter's velocity\n  float velocity_x = get_velocity_x();\n  float velocity_y = get_velocity_y();\n\n  // calculate the speed squared\n  float speed_squared = velocity_x * velocity_x + velocity_y * velocity_y;\n\n  // if the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n  if (position_valid && speed_squared > LOOK_AHEAD_SPEED_THRESHOLD) {\n\n    // calculate the look-ahead yaw angle\n    float look_ahead_yaw = atan2(velocity_y, velocity_x);\n\n    // return the look-ahead yaw angle\n    return look_ahead_yaw;\n\n  }\n\n  // otherwise, return the last look-ahead yaw angle\n  return last_look_ahead_yaw;\n\n}", "CodeBleu_score": 37.03811825634708}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\tfloat vx, vy, vz;\n  float speed_sq;\n  float look_ahead_yaw_angle;\n  // Retrieve the velocity\n  get_velocity(vx, vy, vz);\n  // Calculate the speed squared\n  speed_sq = vx * vx + vy * vy;\n  // If the copter's position is valid and the speed exceeds a minimum threshold\n  if (is_position_valid() && speed_sq > MIN_SPEED_SQ) {\n    // Update the look-ahead yaw angle using the arctangent of the velocity components\n    look_ahead_yaw_angle = atan2(vy, vx);\n  }\n  // Otherwise, return the current look-ahead yaw angle\n  else {\n    look_ahead_yaw_angle = look_ahead_yaw_angle_current;\n  }\n  // Return the computed look-ahead yaw angle\n  return look_ahead_yaw_angle;\n}", "CodeBleu_score": 42.548015630770664}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t// rudder arming checks\n    if (method == AP_Arming::RUDDER) {\n        if (_rudder_disarmed || _throttle_zero == 0) {\n            return false;\n        }\n    }\n\n    // if we're disarmed, bypass checks\n    if (!_armed) {\n        return true;\n    }\n\n    // if watchdog was armed, bypass checks\n    if (_watchdog_armed) {\n        return true;\n    }\n\n    // call parent method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 40.4972859241774}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t// rudder method\n    if (method == AP_Arming::RUDDER) {\n        if (arming_checks_disable || _watchdog.armed()) {\n            return true;\n        }\n        if (!_rudder_arming_disable && _throttle_control.get_control_in() > 0.01f) {\n            return false;\n        }\n    }\n\n    // call parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 40.542727225800704}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t// rudder arming check\n    if (method == AP_Arming::RUDDER) {\n        if (rudder_disarmed || throttle_zero == 0) {\n            return false;\n        }\n    }\n\n    // check for watchdog armed\n    if (watchdog_armed) {\n        return true;\n    }\n\n    // check for arming checks disabled\n    if (arming_checks_disabled) {\n        return true;\n    }\n\n    // call parent class\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 41.05801845151576}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t// set the arming method\n    arming_method = method;\n\n    // do arming checks\n    if (do_arming_checks) {\n        if (!do_arming_checks()) {\n            return false;\n        }\n    }\n\n    // set the home location\n    if (home_is_set) {\n        ahrs.set_home(ahrs.get_home());\n    } else {\n        ahrs.set_home(ahrs.get_current_loc());\n        home_is_set = true;\n    }\n\n    // update the current location\n    ahrs.update_current_loc();\n\n    // change the arm state\n    change_arm_state();\n\n    // set a delay arming flag\n    delay_armed = true;\n\n    // send a status text indicating that the throttle is armed\n    if (method == AP_Arming::ARM_NOW) {\n        hal.util->set_soft_armed(true);\n        hal.console->printf_P(PSTR(\"Throttle armed\n\"));\n    } else {\n        hal.console->printf_P(PSTR(\"Throttle armed in %d seconds\n\"), (int)arming_delay);\n    }\n\n    return true;\n}", "CodeBleu_score": 57.16226063350936}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t// exit immediately if we are already armed\n    if (armed) {\n        return true;\n    }\n\n    // exit immediately if we are not ready to arm\n    if (!ready_to_arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // update the home location\n    plane.home.update_home_and_channels();\n\n    // update the current location\n    plane.location.update();\n\n    // set the arm state\n    armed = true;\n    change_arm_state();\n\n    // set a delay arming flag\n    delay_armed = true;\n\n    // send a status text indicating that the throttle is armed\n    plane.gcs().send_text_fmt(MAV_SEVERITY_INFO, \"Throttle armed\");\n\n    return true;\n}", "CodeBleu_score": 62.78949464024659}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\tif (!do_arming_checks) {\n        return arm_without_checks(method);\n    }\n\n    // check if we are already armed\n    if (is_armed()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_allowed()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_pre_arm_checks()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_post_arm_checks()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_pre_arm_checks_2()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_post_arm_checks_2()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_pre_arm_checks_3()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_post_arm_checks_3()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_pre_arm_checks_4()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_post_arm_checks_4()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_pre_arm_checks_5()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_post_arm_checks_5()) {\n        return false;\n    }\n\n    // check if we are allowed to arm\n    if (!check_arming_pre_arm_checks_6()) {\n        return false;\n    }\n\n    // check if we are allowed to arm", "CodeBleu_score": 27.960970761798098}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (armed) {\n        return true;\n    }\n\n    // make sure the craft has a disarm button assigned before it is armed\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            sub.gcs().text_info(0, 0, \"No disarm button assigned\");\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 76.82201243534902}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// check if the vehicle is already armed\n    if (arming.is_armed()) {\n        return true;\n    }\n\n    // check if the vehicle has a disarm button assigned\n    if (!has_disarm_function()) {\n        // display a message if requested\n        if (display_failure) {\n            sub.log_write_warning(MAV_SEVERITY_WARNING, \"No Disarm Button Assigned\");\n        }\n        return false;\n    }\n\n    // proceed with the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.49605818789513}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (armed()) {\n        return true;\n    }\n\n    // make sure the craft has a disarm button assigned before it is armed\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            sub.console->printf_P(PSTR(\"Disarm button not configured\n\"));\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 71.78947494174363}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x, ne_y;\n\tfloat cos_yaw = cos(yaw);\n\tfloat sin_yaw = sin(yaw);\n\tne_x = x * cos_yaw - y * sin_yaw;\n\tne_y = x * sin_yaw + y * cos_yaw;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 52.730287080219476}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// calculate rotation matrix\n  float c = cos(yaw);\n  float s = sin(yaw);\n  float rot_matrix[2][2] = {{c, -s}, {s, c}};\n\n  // calculate new coordinates\n  float ne_x = rot_matrix[0][0] * x + rot_matrix[0][1] * y;\n  float ne_y = rot_matrix[1][0] * x + rot_matrix[1][1] * y;\n\n  // update x and y\n  x = ne_x;\n  y = ne_y;\n}", "CodeBleu_score": 48.723549019293486}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// Define rotation matrix\n  float R[2][2];\n\n  // Calculate the rotation matrix\n  R[0][0] = cos(ahrs.yaw);\n  R[0][1] = -sin(ahrs.yaw);\n  R[1][0] = sin(ahrs.yaw);\n  R[1][1] = cos(ahrs.yaw);\n\n  // Calculate new coordinates in the North-East frame\n  float ne_x = R[0][0] * x + R[0][1] * y;\n  float ne_y = R[1][0] * x + R[1][1] * y;\n\n  // Update x and y with the new coordinates\n  x = ne_x;\n  y = ne_y;\n}", "CodeBleu_score": 53.20458740726166}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t// Check if the yaw angle is within the acceptable range\n    if (packet.param1 < -M_PI || packet.param1 > M_PI) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if the param4 value is within the acceptable range\n    if (packet.param4 < -1 || packet.param4 > 1) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Set the yaw heading using the provided parameters\n    set_yaw_heading(packet.param1, packet.param4);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 45.849258494162434}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_DENIED;\n    float yaw = packet.param1;\n    float yaw_rate = packet.param2;\n    float yaw_angle = packet.param3;\n    float relative_angle = packet.param4;\n\n    if (yaw_rate < 0.0f || yaw_rate > 300.0f) {\n        result = MAV_RESULT_DENIED;\n    } else if (yaw_angle < 0.0f || yaw_angle > 360.0f) {\n        result = MAV_RESULT_DENIED;\n    } else if (relative_angle < 0.0f || relative_angle > 1.0f) {\n        result = MAV_RESULT_DENIED;\n    } else {\n        // set yaw heading\n        set_yaw_heading(yaw, yaw_rate, yaw_angle, relative_angle);\n        result = MAV_RESULT_ACCEPTED;\n    }\n\n    return result;\n}", "CodeBleu_score": 34.52377019252694}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t// Check if the yaw angle is within the acceptable range\n    if (packet.param1 < 0 || packet.param1 > 360) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Check if the param4 value is within the acceptable range\n    if (packet.param4 < 0 || packet.param4 > 1) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // Set the yaw heading using the provided parameters\n    _vehicle->set_yaw_heading(packet.param1, packet.param4);\n\n    // Return MAV_RESULT_ACCEPTED\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 46.101588109337534}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tuint8_t heading = 0;\n    if (control_mode == MAV_MODE_AUTO_ARMED || control_mode == MAV_MODE_GUIDED_ARMED) {\n        // Convert the waypoint bearing from -18000->18000 to 0->360 and then divide by 2.\n        heading = (uint8_t)((waypoint_bearing + 18000) / 360);\n    }\n    return heading;\n}", "CodeBleu_score": 43.578324736993274}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tuint8_t tgt_heading = 0;\n\tif (control_mode == GCS_MAVLINK::MAV_MODE_AUTO_ARMED || control_mode == GCS_MAVLINK::MAV_MODE_GUIDED_ARMED) {\n\t\tif (waypoint_bearing >= 0) {\n\t\t\ttgt_heading = (waypoint_bearing / 2) % 360;\n\t\t} else {\n\t\t\ttgt_heading = (360 + waypoint_bearing / 2) % 360;\n\t\t}\n\t}\n\treturn tgt_heading;\n}", "CodeBleu_score": 37.691073872093796}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\tuint8_t tgt_heading = 0;\n    if ((_control_mode == GCS_MAVLINK::MAV_MODE_AUTO_MISSION) || (_control_mode == GCS_MAVLINK::MAV_MODE_GUIDED)) {\n        tgt_heading = (((uint16_t)(_waypoint_bearing * 100)) + 18000) / 2;\n    }\n    return tgt_heading;\n}", "CodeBleu_score": 41.21108346605673}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (Sub::logging_enabled) {\n\n    // Create a log packet with the current time, log data ID, and value\n    LogPacket log_packet = {\n      .time = millis(),\n      .id = id,\n      .value = value\n    };\n\n    // Write this packet to the logger as a critical block\n    Sub::log_file.writeCriticalBlock((uint8_t*)&log_packet, sizeof(LogPacket));\n\n  }\n\n}", "CodeBleu_score": 38.57352391914075}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (Logging_Enabled) {\n\t\t// Create a log packet with the current time, log data ID, and value\n\t\tLogPacket log_packet;\n\t\tlog_packet.Time = Time_Get_Now();\n\t\tlog_packet.ID = id;\n\t\tlog_packet.Data = value;\n\n\t\t// Write this packet to the logger as a critical block\n\t\tLogger_Write_Critical(log_packet);\n\t}\n}", "CodeBleu_score": 34.33631185511087}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (Log_Is_Enabled()) {\n\t\tLogPacket packet;\n\t\tpacket.time = Log_Get_Time();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tLog_Write_Critical_Block(&packet, sizeof(packet));\n\t}\n}", "CodeBleu_score": 38.47988609132502}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\tif (home_is_set()) {\n        // home is already set\n        return;\n    }\n    if (motors.armed()) {\n        // set home to current location in-flight\n        set_home_to_current_location_inflight();\n    } else {\n        // set home to current location on the ground\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 50.47295625458429}, {"code": "void Sub::update_home_from_EKF(){\n\t// exit immediately if home is already set\n    if (home_is_set()) {\n        return;\n    }\n\n    // if motors are armed, set home to current location in-flight\n    if (ap.armed()) {\n        set_home_to_current_location_inflight();\n        return;\n    }\n\n    // if motors are not armed, set home to current EKF location and ignore any failure\n    set_home_to_current_location(false);\n}", "CodeBleu_score": 39.15661509324059}, {"code": "void Sub::update_home_from_EKF(){\n\tif (home_is_set()) {\n        return;\n    }\n    if (ap.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 45.18211653770261}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\tif (!motorsArmed()) {\n        // motors are not armed\n        setMotorTest(0);\n        setSpoolState(SPOOL_STATE_OFF);\n        attitudeController.relax();\n        return;\n    }\n\n    // motors are armed\n    setSpoolState(SPOOL_STATE_UNLIMITED);\n\n    // convert pilot inputs to desired body frame rates\n    attitudeController.setDesiredRates(getPilotDesiredRates());\n\n    // run attitude controller\n    attitudeController.run();\n\n    // set pilot's throttle input without angle boost\n    setThrottle(getPilotThrottle());\n\n    // set forward and lateral motor inputs\n    setMotorTest(getPilotMotorTest());\n}", "CodeBleu_score": 29.488203724693772}, {"code": "void ModeAcro::run(){\n\tif (motors.armed()) {\n    // set the spool state to unlimited throttle\n    spool_state = SpoolState::UNLIMITED_THROTTLE;\n    // convert pilot inputs to desired body frame rates\n    rate_desired.x = g.pid_rate_pitch.get_pid(rc_values.roll);\n    rate_desired.y = g.pid_rate_roll.get_pid(rc_values.pitch);\n    rate_desired.z = g.pid_rate_yaw.get_pid(rc_values.yaw);\n    // run attitude controller with these rates\n    attitude_control.angle_ef_roll_pitch_rate_ef_yaw_rate(rate_desired, g.rc_10.get_pid(rc_values.throttle));\n    // set the forward and lateral motor inputs based on pilot controls\n    motors.set_forward_backward(g.rc_11.get_pid(rc_values.throttle));\n    motors.set_left_right(g.rc_12.get_pid(rc_values.throttle));\n  } else {\n    // set the spool state to throttle\n    spool_state = SpoolState::THROTTLE;\n    // set the throttle to zero\n    motors.set_throttle(0);\n    // relax the attitude controller\n    attitude_control.relax();\n  }\n}", "CodeBleu_score": 47.58015223556652}, {"code": "void ModeAcro::run(){\n\t// If the motors are not armed, set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit\n    if (!motorsArmed()) {\n        // Set the spool state to unlimited throttle\n        setSpoolState(SPOOL_STATE_UNLIMITED_THROTTLE);\n\n        // Relax the attitude controllers\n        attitudeControl.relax();\n\n        // Exit\n        return;\n    }\n\n    // Set the spool state to unlimited throttle\n    setSpoolState(SPOOL_STATE_UNLIMITED_THROTTLE);\n\n    // Convert pilot inputs to desired body frame rates\n    attitudeControl.convertPilotInputsToRates(rcData.ch3, rcData.ch4, rcData.ch1, rcData.ch2);\n\n    // Run the attitude controller with these rates\n    attitudeControl.run();\n\n    // Output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls\n    setMotorSpeeds(rcData.ch3, rcData.ch4, rcData.ch1, rcData.ch2);\n}", "CodeBleu_score": 34.16979836838543}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t// set initial_armed_bearing to the current yaw\n    sub.initial_armed_bearing = ahrs.yaw_sensor;\n\n    // set initial_armed_bearing to the current yaw\n    sub.initial_armed_bearing = ahrs.yaw_sensor;\n\n    // set the yaw mode\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n\n    // set the waypoint controller to use the current position as the destination\n    wp_nav.init_wpnav(ahrs.get_position(), get_auto_yaw_mode());\n\n    // set the waypoint controller to use the current position as the destination\n    wp_nav.set_destination(ahrs.get_position());\n\n    // set the waypoint controller to use the current position as the destination\n    wp_nav.set_loiter_radius(get_loiter_radius());\n\n    // set the waypoint controller to use the current position as the destination\n    wp_nav.set_loiter_direction(get_loiter_direction());\n\n    // set the waypoint controller to use the current position as the destination\n    wp_nav.set_loiter_altitude(get_loiter_altitude());\n\n    // set the waypoint controller to use the current position as the destination\n    wp_nav.set_loiter_time(get_loiter_time());\n\n    // set the waypoint controller to use the current position as the destination\n    wp_nav.set_landing_approach(get_landing_approach());\n\n    // set the waypoint controller to use the current position as the destination\n    wp_nav.set_landing_target(get_landing_target());\n\n    // set the waypoint controller to use the current position as the destination\n    wp_nav.set_landing_abort_alt(get_landing_abort_alt());\n\n    // set the waypoint controller to use the current position as the destination\n    wp_nav.set_landing_final_alt(get_landing_final_alt());\n\n    // set the waypoint controller to use", "CodeBleu_score": 35.03939985622071}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set the mode to position control\n    set_mode(WPNAV);\n    // set the target waypoint to the stopping point\n    wp_nav.set_destination(g.stop_trigger_distance, g.stop_trigger_altitude, get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 22.05189570066092}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set position control mode\n    set_mode(WPNAV);\n\n    // set destination to stopping point\n    wp_nav.set_destination(wp_nav.get_stopping_point());\n\n    // set initial yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 28.182437620304757}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// set guided mode to velocity controller\n    sub.guided_mode = GUIDED_MODE_VEL_CONTROL;\n\n    // set vertical maximum speeds and acceleration\n    sub.max_vel_z_cm = pilot.get_param_float(PARAM_GUIDED_MAX_VERT_SPEED);\n    sub.max_accel_z_cm = pilot.get_param_float(PARAM_GUIDED_ACCEL_Z);\n\n    // set initial vertical velocity controller\n    sub.vz_controller.set_target_velocity(0);\n    sub.vz_controller.set_target_acceleration(sub.max_accel_z_cm);\n\n    // set initial horizontal velocity controller\n    sub.vx_controller.set_target_velocity(0);\n    sub.vx_controller.set_target_acceleration(pilot.get_param_float(PARAM_GUIDED_ACCEL_XY));\n\n    // set yaw control mode to AUTO_YAW_HOLD\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 38.28876815645032}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set vertical maximum speeds and acceleration\n    // XXX: should we use a different acceleration for takeoff?\n    // XXX: should we use a different acceleration for landing?\n    // XXX: should we use a different acceleration for RTL?\n    // XXX: should we use a different acceleration for loiter?\n    // XXX: should we use a different acceleration for guided mode?\n    // XXX: should we use a different acceleration for guided mode when not armed?\n    // XXX: should we use a different acceleration for guided mode when not armed and not flying?\n    // XXX: should we use a different acceleration for guided mode when not armed and not flying and not on the ground?\n    // XXX: should we use a different acceleration for guided mode when not armed and not flying and not on the ground and not in a loiter?\n    // XXX: should we use a different acceleration for guided mode when not armed and not flying and not on the ground and not in a loiter and not in a takeoff?\n    // XXX: should we use a different acceleration for guided mode when not armed and not flying and not on the ground and not in a loiter and not in a takeoff and not in a land?\n    // XXX: should we use a different acceleration for guided mode when not armed and not flying and not on the ground and not in a loiter and not in a takeoff and not in a land and not in a rtl?\n    // XXX: should we use a different acceleration for guided mode when not armed and not flying and not on the ground and not in a loiter and not in a takeoff and not in a land and not in a rtl and not in a loiter?\n    // XXX: should we use a different acceleration for guided mode when not armed and not flying and not on the ground and not in a loiter and not in a takeoff and not in a land and not in a rtl and not in a loiter and not in a takeoff?\n    // XXX: should we use a different acceleration for guided mode when not armed and not flying and not on the ground and not in a loiter and not in a takeoff and not in a land and not in a rtl and not in a loiter and not in a takeoff and not in a land?\n    // XXX: should we use a", "CodeBleu_score": 2.0064253739430145}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set initial guided mode velocity\n    sub.guided_mode_velocity = pilot.get_guided_mode_velocity();\n\n    // set initial vertical maximum speeds and acceleration\n    set_vertical_max_speed(pilot.get_guided_mode_max_speed());\n    set_vertical_acceleration(pilot.get_guided_mode_acceleration());\n\n    // initialise vertical velocity controller\n    velocity_controller_init(&sub.vert_control,\n                             sub.guided_mode_velocity,\n                             sub.guided_mode_max_speed,\n                             sub.guided_mode_acceleration,\n                             sub.guided_mode_deceleration);\n\n    // initialise horizontal velocity controller\n    velocity_controller_init(&sub.horiz_control,\n                             sub.guided_mode_velocity,\n                             sub.guided_mode_max_speed,\n                             sub.guided_mode_acceleration,\n                             sub.guided_mode_deceleration);\n\n    // set yaw control mode to AUTO_YAW_HOLD\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 42.10683553719735}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t// Check if a timeout has been exceeded\n  if (hrt_elapsed_time(&_time_last_inside_guided) > GUIDED_TIMEOUT) {\n    return true;\n  }\n\n  // Check if the altitude is below a minimum or above a maximum threshold\n  if ((_param_agl_setpoint_min.get() > 0 && _current_alt_agl <= _param_agl_setpoint_min.get()) ||\n      (_param_agl_setpoint_max.get() > 0 && _current_alt_agl >= _param_agl_setpoint_max.get())) {\n    return true;\n  }\n\n  // Check if the horizontal distance moved exceeds a specified limit\n  if (_param_dist_setpoint_max.get() > 0 && _dist_to_target <= _param_dist_setpoint_max.get()) {\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 33.71513279635906}, {"code": "bool ModeGuided::guided_limit_check(){\n\tbool ret = false;\n  float alt_min = _param_nav_gnd_alt.get();\n  float alt_max = _param_nav_gnd_alt_max.get();\n  float dist_max = _param_nav_gnd_d_max.get();\n  float timeout = _param_nav_gnd_timeout.get();\n  // check if timeout has been exceeded\n  if (hrt_elapsed_time(&_time_started) > timeout * 1000000UL) {\n    ret = true;\n  }\n  // check if the altitude is below the minimum\n  if (_alt_sp < alt_min) {\n    ret = true;\n  }\n  // check if the altitude is above the maximum\n  if (_alt_sp > alt_max) {\n    ret = true;\n  }\n  // check if the horizontal distance moved is greater than the maximum\n  if (fabsf(_dist_to_bottom) > dist_max) {\n    ret = true;\n  }\n  return ret;\n}", "CodeBleu_score": 32.67809685441091}, {"code": "bool ModeGuided::guided_limit_check(){\n\t// return true if any of the limits are exceeded\n  return (\n          // check timeout\n          (hrt_elapsed_time(&_time_started) > _param_com_rcl_gm_timeout.get() * 1000000) ||\n          // check minimum altitude\n          (get_absolute_altitude() < _param_com_rcl_gm_min_alt.get()) ||\n          // check maximum altitude\n          (get_absolute_altitude() > _param_com_rcl_gm_max_alt.get()) ||\n          // check distance\n          (get_distance_to_next_waypoint() > _param_com_rcl_gm_max_dist.get())\n          );\n}", "CodeBleu_score": 14.40496184665946}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t// This function, Sub::verify_motor_test, verifies the motor test by checking if motor test requests are received at least every 2 Hz.", "CodeBleu_score": 5.394976786444216}, {"code": "bool Sub::verify_motor_test(){\n\tif (motor_test_pass) {\n\t\tif (ros::Time::now().toSec() - motor_test_start > motor_test_timeout) {\n\t\t\tmotor_test_pass = false;\n\t\t\tmotor_test_fail_time = ros::Time::now().toSec();\n\t\t\tmotor_test_start = ros::Time::now().toSec();\n\t\t\tmotor_test_timeout = 0;\n\t\t\tmotor_test_timeout_msg.data = \"Motor test timed out\";\n\t\t\tmotor_test_timeout_pub.publish(motor_test_timeout_msg);\n\t\t\tmotor_test_pass_msg.data = false;\n\t\t\tmotor_test_pass_pub.publish(motor_test_pass_msg);\n\t\t\tmotor_test_enable_msg.data = false;\n\t\t\tmotor_test_enable_pub.publish(motor_test_enable_msg);\n\t\t\tarm_disarm_msg.data = false;\n\t\t\tarm_disarm_pub.publish(arm_disarm_msg);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (ros::Time::now().toSec() - motor_test_start > motor_test_timeout) {\n\t\tmotor_test_pass = true;\n\t\tmotor_test_start = ros::Time::now().toSec();\n\t\tmotor_test_timeout = 0;\n\t\tmotor_test_timeout_msg.data = \"Motor test passed\";\n\t\tmotor_test_timeout_pub.publish(motor_test_timeout_msg);\n\t\tmotor_test_pass_msg.data = true;\n\t\tmotor_test_pass_pub.publish(motor_test_pass_msg);\n\t\tmotor_test_enable_msg.data = false;\n\t\tmotor_test_enable_pub.publish(motor_test_enable_msg);\n\t\tarm_disarm_msg.data = false;\n\t\tarm_disarm_pub.publish(arm_disarm", "CodeBleu_score": 40.15431524841709}, {"code": "bool Sub::verify_motor_test(){\n\t// If the motor test is not running, return true\n  if (!motor_test_running) {\n    return true;\n  }\n  // If the motor test is running, check if the motor test requests have been received at least every 2 Hz.\n  if (millis() - motor_test_last_request_time > 500) {\n    // If the requests have timed out, send a timeout message, set the pass flag to false, disables the motor test, disarms the system, records the failure time, and returns false.\n    Serial.println(\"Motor test timed out.\");\n    motor_test_pass = false;\n    motor_test_running = false;\n    disarm();\n    motor_test_failure_time = millis();\n    return false;\n  }\n  // If the motor test requests have been received, return true.\n  return true;\n}", "CodeBleu_score": 48.57236953683768}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\tfloat roll_target = wp_nav.get_roll_target();\n  float pitch_target = wp_nav.get_pitch_target();\n\n  // constrain roll and pitch targets to within specified maximum angle range\n  roll_target = constrain_angle(roll_target);\n  pitch_target = constrain_angle(pitch_target);\n\n  // normalize roll and pitch targets\n  float roll_norm = norm_angle(roll_target);\n  float pitch_norm = norm_angle(pitch_target);\n\n  // assign normalized roll and pitch targets to lateral_out and forward_out\n  lateral_out = roll_norm;\n  forward_out = pitch_norm;\n\n}", "CodeBleu_score": 41.73207097192595}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Retrieve roll and pitch targets from wp_nav in centidegrees\n  float roll_target = wp_nav.get_roll_target();\n  float pitch_target = wp_nav.get_pitch_target();\n\n  // Constrain roll and pitch targets within a specified maximum angle range\n  roll_target = constrain_angle(roll_target, -max_angle_cd, max_angle_cd);\n  pitch_target = constrain_angle(pitch_target, -max_angle_cd, max_angle_cd);\n\n  // Normalize roll and pitch targets\n  float roll_target_norm = normalize_angle(roll_target);\n  float pitch_target_norm = normalize_angle(pitch_target);\n\n  // Assign normalized roll and pitch targets to lateral_out and forward_out\n  lateral_out = roll_target_norm;\n  forward_out = pitch_target_norm;\n}", "CodeBleu_score": 43.76897570618365}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Get roll and pitch targets from wp_nav\n  float roll_target = wp_nav.get_roll();\n  float pitch_target = wp_nav.get_pitch();\n\n  // Constrain roll and pitch targets to specified maximum angle range\n  if (roll_target > roll_max_angle) roll_target = roll_max_angle;\n  if (roll_target < -roll_max_angle) roll_target = -roll_max_angle;\n  if (pitch_target > pitch_max_angle) pitch_target = pitch_max_angle;\n  if (pitch_target < -pitch_max_angle) pitch_target = -pitch_max_angle;\n\n  // Normalize roll and pitch targets\n  float norm_roll_target = (roll_target/roll_max_angle);\n  float norm_pitch_target = (pitch_target/pitch_max_angle);\n\n  // Assign normalized roll and pitch targets to lateral_out and forward_out\n  lateral_out = norm_roll_target;\n  forward_out = norm_pitch_target;\n\n}", "CodeBleu_score": 42.624982419679206}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t// Read the barometer data\n  barometer.read();\n\n  // If the altitude is above zero, update the barometer calibration\n  if (barometer.getAltitude() > 0) {\n    barometer.updateCalibration();\n  }\n\n  // If a depth sensor is present, update the sensor health status based on the barometer's health\n  if (depth_sensor_present) {\n    if (barometer.getHealth() == 0) {\n      sensor_health_status = 0;\n    } else {\n      sensor_health_status = 1;\n    }\n  }\n}", "CodeBleu_score": 61.77384951572711}, {"code": "void Sub::read_barometer(){\n\t// Update the barometer data\n\tbarometer.update();\n\n\t// If the altitude is above zero, update the barometer calibration\n\tif (barometer.altitude > 0.0) {\n\t\tbarometer.calibrate();\n\t}\n\n\t// If a depth sensor is present, update the sensor health status based on the barometer's health\n\tif (depth_sensor.present) {\n\t\tdepth_sensor.healthy = barometer.healthy;\n\t}\n}", "CodeBleu_score": 54.43413617736375}, {"code": "void Sub::read_barometer(){\n\t// Read the barometer data\n  barometer.read();\n\n  // If the altitude is above zero, it updates the barometer calibration\n  if (barometer.getAltitude() > 0) {\n    barometer.calibrate(barometer.getPressure(), barometer.getTemperature(), barometer.getAltitude());\n  }\n\n  // If a depth sensor is present, it updates the sensor health status based on the barometer's health\n  if (depth_sensor_present) {\n    if (barometer.getHealth() == BMP085_OK) {\n      depth_sensor_health = 1;\n    }\n    else {\n      depth_sensor_health = 0;\n    }\n  }\n}", "CodeBleu_score": 56.30228003038772}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\tif (!inertial_nav_available) {\n    return false;\n  }\n  if (!motors_armed) {\n    return true;\n  }\n  if (ekf_predicted_position_valid) {\n    return true;\n  }\n  if (ekf_const_pos_mode) {\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 15.752439983233735}, {"code": "bool Sub::ekf_position_ok(){\n\t// TODO: check for inertial navigation\n  // TODO: check for good absolute position\n  // TODO: check for not in constant position mode\n  return true;\n}", "CodeBleu_score": 2.2774809390436817}, {"code": "bool Sub::ekf_position_ok(){\n\treturn false;\n}", "CodeBleu_score": 5.492677746086194}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!AP_Arming_Plane::gps_checks(display_failure)) {\n        return false;\n    }\n    if (!_ahrs->healthy()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"AHRS not healthy\n\"));\n        }\n        return false;\n    }\n    if (_ekf->failsafe_land()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"EKF failsafe land active\n\"));\n        }\n        return false;\n    }\n    if (!_ekf->position_ok()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"EKF position not ok\n\"));\n        }\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 49.92837023576014}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// If the current control mode does not require position or velocity, return true\n    if (!_vehicle->control_mode().flag_control_position_enabled && !_vehicle->control_mode().flag_control_velocity_enabled) {\n        return true;\n    }\n\n    // Check if the AHRS system is ready and if the EKF failsafe is active\n    if (!_vehicle->is_ahrs_healthy() || _vehicle->is_failsafe_ekf_enabled()) {\n        if (display_failure) {\n            _vehicle->scheduler->printf_P(PSTR(\"EKF not ready\n\"));\n        }\n        return false;\n    }\n\n    // Check if the position estimate is valid\n    if (!_vehicle->is_position_ok()) {\n        if (display_failure) {\n            _vehicle->scheduler->printf_P(PSTR(\"Position invalid\n\"));\n        }\n        return false;\n    }\n\n    // All checks passed, return true\n    return true;\n}", "CodeBleu_score": 39.09534688588718}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// check if we are in a mode that requires position or velocity\n    if (!_vehicle->control_mode().posctl ||\n        !_vehicle->control_mode().velctl) {\n        return true;\n    }\n\n    // call parent class's GPS checks\n    if (!AP_Arming_Base::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!_vehicle->ahrs.healthy()) {\n        if (display_failure) {\n            _vehicle->console->printf_P(PSTR(\"AHRS system not ready\n\"));\n        }\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (_vehicle->ekf.in_failsafe()) {\n        if (display_failure) {\n            _vehicle->console->printf_P(PSTR(\"EKF failsafe active\n\"));\n        }\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!_vehicle->ekf.position_ok()) {\n        if (display_failure) {\n            _vehicle->console->printf_P(PSTR(\"Position estimate not valid\n\"));\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 51.53890942773437}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// check for arming checks\n    if (do_arming_checks && !_check_arming_preconditions()) {\n        return false;\n    }\n\n    // set the arming method\n    _set_arming_method(method);\n\n    // arm the vehicle\n    if (!_arm_vehicle()) {\n        return false;\n    }\n\n    // set the SmartRTL home location\n    if (smart_rtl.enabled()) {\n        smart_rtl.set_home_location();\n    }\n\n    // set the initial heading for simple mode\n    if (simple_mode.enabled()) {\n        simple_mode.set_initial_heading();\n    }\n\n    // record the home heading for sail vehicles\n    if (sail_mode.enabled()) {\n        sail_mode.set_home_heading();\n    }\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    send_arm_disarm_status_text();\n\n    // return true\n    return true;\n}", "CodeBleu_score": 47.468728884159916}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif (do_arming_checks) {\n        if (!do_arming_checks()) {\n            return false;\n        }\n    }\n\n    if (method == AP_Arming::ARMING_CHECK) {\n        // we're just checking arming\n        return true;\n    }\n\n    if (method == AP_Arming::ARMING_VOLTAGE_CHECK) {\n        // we're just checking voltage\n        return true;\n    }\n\n    if (method == AP_Arming::ARMING_FAILSAFE) {\n        // we're just checking failsafe\n        return true;\n    }\n\n    // set the home location\n    if (method == AP_Arming::ARMING_VOLTAGE_CHECK ||\n        method == AP_Arming::ARMING_FAILSAFE) {\n        // don't set home location if we're just checking voltage or failsafe\n    } else {\n        if (should_set_home_on_arming()) {\n            // set home location\n            hal.util->set_soft_armed(false);\n            set_home_location();\n        }\n    }\n\n    // record the home heading for sail vehicles\n    if (should_record_home_heading_on_arming()) {\n        record_home_heading();\n    }\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // send an arm/disarm status text\n    send_arm_disarm_status_text();\n\n    // arming succeeded\n    return true;\n}", "CodeBleu_score": 45.012307990437364}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tbool ret = false;\n    if (method == AP_Arming::Method::Manual) {\n        // Manual arming\n        if (do_arming_checks) {\n            if (!_arming_checks()) {\n                // arming checks failed\n                return false;\n            }\n        }\n        if (is_armed()) {\n            // already armed\n            return true;\n        }\n        // arm the vehicle\n        _arming_method = method;\n        armed_time = hal.scheduler->millis();\n        armed_by_stick = false;\n        update_soft_armed();\n        hal.util->set_soft_armed(true);\n        hal.util->set_soft_armed_ignore_throttle(false);\n        hal.util->set_soft_armed_ignore_rc_checks(false);\n        hal.util->set_soft_armed_ignore_throttle_checks(false);\n        hal.util->set_soft_armed_ignore_failsafe_battery(false);\n        hal.util->set_soft_armed_ignore_failsafe_gps(false);\n        hal.util->set_soft_armed_ignore_failsafe_radio(false);\n        hal.util->set_soft_armed_ignore_failsafe_geofence(false);\n        hal.util->set_soft_armed_ignore_failsafe_avoidance(false);\n        hal.util->set_soft_armed_ignore_failsafe_landing_gear(false);\n        hal.util->set_soft_armed_ignore_failsafe_motors(false);\n        hal.util->set_soft_armed_ignore_failsafe_serial_loss(false);\n        hal.util->set_soft_armed_ignore_failsafe_data_link_loss(false);\n        hal.util->set_soft_armed_ignore_failsafe_rssi(false);\n        hal.util->set_soft_armed_ignore_failsafe_airspeed(false", "CodeBleu_score": 36.24212804088488}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\tif (charging_allowed && checkShouldCharge()) {\n        if (status_message.charging_enabled == 0) {\n            status_message.charging_enabled = 1;\n            status_message.charging_start_time = time(NULL);\n            status_message.charging_current = 0;\n            status_message.charging_current_start_time = time(NULL);\n        }\n    } else {\n        if (status_message.charging_enabled == 1) {\n            status_message.charging_enabled = 0;\n            status_message.charging_stop_time = time(NULL);\n            status_message.charging_current = 0;\n            status_message.charging_current_start_time = time(NULL);\n        }\n        if (charging_allowed) {\n            // if charging is allowed but should not continue, disable charging\n            // and record the time\n            status_message.charging_enabled = 0;\n            status_message.charging_stop_time = time(NULL);\n            status_message.charging_current = 0;\n            status_message.charging_current_start_time = time(NULL);\n        } else {\n            // if charging is not allowed, retry enabling charging after a\n            // specified delay, checking the conditions again to decide whether\n            // to enable or continue disabling charging\n            if (time(NULL) - status_message.charging_stop_time > 10) {\n                status_message.charging_enabled = 1;\n                status_message.charging_start_time = time(NULL);\n                status_message.charging_current = 0;\n                status_message.charging_current_start_time = time(NULL);\n            }\n        }\n    }\n}", "CodeBleu_score": 28.361400230963664}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed) {\n        if (!status_message.charging_enabled) {\n            // Enable charging\n            status_message.charging_enabled = true;\n            status_message.charging_start = millis();\n            status_message.charging_current = 0;\n            status_message.charging_power = 0;\n            status_message.charging_energy = 0;\n        }\n    } else {\n        if (status_message.charging_enabled) {\n            // Disable charging\n            status_message.charging_enabled = false;\n            status_message.charging_stop = millis();\n        }\n        // Retry enabling charging after a delay\n        if (millis() - status_message.charging_stop > 10000) {\n            updateChargingEnabled();\n        }\n    }\n}", "CodeBleu_score": 35.172213591718496}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed) {\n        if (checkShouldCharge()) {\n            charging_enabled = true;\n            charging_disabled_time = 0;\n        } else {\n            charging_enabled = false;\n            charging_disabled_time = time;\n        }\n    } else {\n        if (time - charging_disabled_time > 10000) {\n            charging_enabled = true;\n        } else {\n            charging_enabled = false;\n        }\n    }\n}", "CodeBleu_score": 39.304902997370775}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\tif (ros::isRunning() && size >= 4) {\n    uint8_t crc = crc8((uint8_t *)message, size);\n    uint8_t crc_message[size + 1];\n    memcpy(crc_message, message, size);\n    crc_message[size] = crc;\n    packetSerial.send(crc_message, size + 1);\n  }\n}", "CodeBleu_score": 44.47180069307816}, {"code": "void sendMessage(void *message, size_t size){\n\tif (ros::ok() && size >= 4) {\n    uint8_t *buffer = (uint8_t*)message;\n    uint32_t crc = crc32(buffer, size);\n    buffer[size] = crc & 0xff;\n    buffer[size + 1] = (crc >> 8) & 0xff;\n    buffer[size + 2] = (crc >> 16) & 0xff;\n    buffer[size + 3] = (crc >> 24) & 0xff;\n    packetSerial.send(buffer, size + 4);\n  }\n}", "CodeBleu_score": 54.64017612618991}, {"code": "void sendMessage(void *message, size_t size){\n\tif (ros::isRunning() && size >= 4) {\n    uint8_t *crc = (uint8_t *)message + size - 4;\n    *crc = crc8((uint8_t *)message, size - 4);\n    packetSerial.send(message, size);\n  }\n}", "CodeBleu_score": 37.178287747558905}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t// initialize serial communication:\n  Serial1.begin(9600);\n  // wait for serial port to open:\n  while (!Serial1) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n  // clear any existing serial data:\n  while (Serial1.available()) {\n    Serial1.read();\n  }\n  // initialize the sound module:\n  Serial1.print(\"$\");\n  delay(200);\n  // retrieve the number of sound files available:\n  Serial1.print(\"$\");\n  delay(200);\n  while (Serial1.available()) {\n    // read the number of sound files available:\n    char c = Serial1.read();\n    // if the character is a digit, add it to the number of sound files:\n    if (isDigit(c)) {\n      numFiles += (c - '0');\n    }\n  }\n  // if there is at least one sound file, return true:\n  if (numFiles >= 1) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 47.27011688989195}, {"code": "bool MP3Sound::begin(){\n\t// Initialize the serial port\n  Serial.begin(9600);\n\n  // Clear the buffer\n  clearBuffer();\n\n  // Send the initialization command\n  sendCommand(CMD_INIT);\n\n  // Wait for the response\n  delay(100);\n\n  // Read the response\n  readResponse();\n\n  // Read the number of sound files available\n  numFiles = readByte();\n\n  // Return true if there are sound files available\n  return numFiles > 0;\n}", "CodeBleu_score": 27.86642121839204}, {"code": "bool MP3Sound::begin(){\n\t// initialize the serial port\n  Serial.begin(9600);\n  Serial.setTimeout(1000);\n  // clear the buffer\n  while (Serial.available()) {\n    Serial.read();\n  }\n  // initialize the sound module\n  Serial.write(0x7E);\n  Serial.write(0xFF);\n  Serial.write(0x06);\n  Serial.write(0x01);\n  Serial.write(0x56);\n  Serial.write(0xAE);\n  // wait for the sound module to respond\n  delay(500);\n  // retrieve the number of sound files\n  Serial.write(0x7E);\n  Serial.write(0xFF);\n  Serial.write(0x01);\n  Serial.write(0x0C);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00);\n  Serial.write(0x00", "CodeBleu_score": 36.288706408138644}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\tif (sounds.size() == 0) {\n\t\treturn sounds.size();\n\t}\n\tif (isPlaying()) {\n\t\treturn sounds.size();\n\t}\n\tint lastSound = sounds.size() - 1;\n\tplay(sounds[lastSound]);\n\tsounds.pop_back();\n\treturn sounds.size();\n}", "CodeBleu_score": 37.37200606729487}, {"code": "int MP3Sound::processSounds(){\n\tint i;\n\t\n\tif (activeSounds.size() == 0) return 0;\n\tif (playing) return activeSounds.size();\n\t\n\ti = activeSounds.size() - 1;\n\tplaySound(activeSounds[i]);\n\tactiveSounds.erase(activeSounds.begin() + i);\n\treturn activeSounds.size();\n}", "CodeBleu_score": 41.841163893198996}, {"code": "int MP3Sound::processSounds(){\n\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (isPlaying) {\n\t\treturn activeSounds.size();\n\t}\n\tint soundNum = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplaySound(soundNum);\n\treturn activeSounds.size();\n}", "CodeBleu_score": 42.65079667971713}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *abstract_camera = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (abstract_camera->memory_mapped_file) {\n        wb_abstract_camera_cleanup_memory_mapped_file(abstract_camera);\n      }\n      const char *filename = wb_request_read_string(r);\n      if (filename) {\n        abstract_camera->memory_mapped_file = wbu_file_map(filename, wb_abstract_camera_get_image_size(abstract_camera), WB_FILE_MAP_READ_WRITE);\n        if (abstract_camera->memory_mapped_file) {\n          wb_request_write_uchar(r, C_CAMERA_MEMORY_MAPPED_FILE);\n          wb_request_write_uchar(r, 1);\n          return true;\n        }\n      }\n      wb_request_write_uchar(r, C_CAMERA_MEMORY_MAPPED_FILE);\n      wb_request_write_uchar(r, 0);\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 46.046704564194755}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *abstract_camera = (WbAbstractCamera *)d;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {", "CodeBleu_score": 26.455740479898726}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *ac = d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      // close existing memory-mapped file\n      if (ac->mmapped_file) {\n        munmap(ac->mmapped_file, ac->mmapped_file_size);\n        ac->mmapped_file = NULL;\n      }\n      // create a new memory-mapped file\n      ac->mmapped_file_size = wb_request_read_uint32(r);\n      ac->mmapped_file = mmap(NULL, ac->mmapped_file_size, PROT_READ | PROT_WRITE, MAP_SHARED, ac->fd, 0);\n      if (ac->mmapped_file == MAP_FAILED) {\n        ac->mmapped_file = NULL;\n        perror(\"mmap\");\n        return false;\n      }\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 48.566685270363116}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tWbAbstractCamera *ac = d->pdata;\n  int height;\n\n  if (ac->data) {\n    wb_abstract_camera_lock(ac);\n    height = ac->data->height;\n    wb_abstract_camera_unlock(ac);\n    return height;\n  }\n  return -1;\n}", "CodeBleu_score": 45.32553770982194}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tWbAbstractCamera *camera = d->pdata;\n  if (camera->data)\n    return camera->data->height;\n  else\n    return -1;\n}", "CodeBleu_score": 15.633619510465685}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tAbstractCamera *ac = d->pdata;\n  int height = -1;\n  if (ac->data) {\n    wb_abstract_camera_lock(ac);\n    height = ac->data->height;\n    wb_abstract_camera_unlock(ac);\n  }\n  return height;\n}", "CodeBleu_score": 50.55257364328888}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tWbDevice *d = wb_accelerometer_get_device(tag);\n  if (d)\n    return d->p->sampling_period;\n  else {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    return 0;\n  }\n}", "CodeBleu_score": 22.776486172962844}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  robot_mutex_lock_step();\n  WbDevice *d = robot_get_device_with_node(tag, WB_NODE_ACCELEROMETER, true);\n  if (d) {\n    WbAccelerometer *accelerometer = d->pdata;\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    sampling_period = 0;\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  }\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 46.99656968011905}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  robot_mutex_lock_step();\n  WbDevice *d = robot_get_device_with_node(tag, WB_NODE_ACCELEROMETER, true);\n  if (d) {\n    WbAccelerometer *accelerometer = d->pdata;\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    sampling_period = 0;\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  }\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 46.99656968011905}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms;\n    dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result = dms;\n    free(dms);\n    return result;\n}", "CodeBleu_score": 42.97333671682144}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result(dms);\n    free(dms);\n    return result;\n}", "CodeBleu_score": 39.26029543458189}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t// convert decimal degree to DMS\n  char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  // store the result in a string\n  string result(dms);\n  // free the allocated memory\n  free(dms);\n  // return the DMS string\n  return result;\n}", "CodeBleu_score": 39.19929114150604}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdAASSERT (g && g->type == dBoxClass);\n\tdUASSERT (plane, \"argument is null\");\n\n\tdReal *side = ((dxBox *) g)->side;\n\n\tdVector3 r;\n\tr[0] = x - ((dxBox *) g)->final_posr->pos[0];\n\tr[1] = y - ((dxBox *) g)->final_posr->pos[1];\n\tr[2] = z - ((dxBox *) g)->final_posr->pos[2];\n\n\t// rotate the point into the box's coordinate frame\n\tdMultiply1_331 (r, ((dxBox *) g)->final_posr->R, r);\n\n\t// find the largest coordinate of the rotated point\n\tdReal maxr = dFabs (r[0]);\n\tint maxi = 0;\n\tif (dFabs (r[1]) > maxr) {\n\t\tmaxr = dFabs (r[1]);\n\t\tmaxi = 1;\n\t}\n\tif (dFabs (r[2]) > maxr) {\n\t\tmaxr = dFabs (r[2]);\n\t\tmaxi = 2;\n\t}\n\n\t// find the plane normal, which is the largest axis\n\tdVector3 n;\n\tn[0] = n[1] = n[2] = 0;\n\tn[maxi] = (r[maxi] > 0) ? -1 : 1;\n\n\t// find the plane distance\n\tdReal dist = -dCalcVectorDot3 (n, ((dxBox *) g)->final_posr->pos);\n\n\t// rotate the plane normal into world coordinates\n\tdMultiply0_331 (plane, ((dxBox *) g)->final_posr->R, n);\n\tplane[3] = dist;\n}", "CodeBleu_score": 32.538149674718056}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdAASSERT (g);\n  dUASSERT (plane, \"argument plane is NULL\");\n  dGeomID b = dGeomGetBody(g);\n  if (b) {\n    dBodyGetRotation (b, plane);\n    plane[3] = 0;\n    dVector3 p;\n    p[0] = x - dGeomGetPosition(g)[0];\n    p[1] = y - dGeomGetPosition(g)[1];\n    p[2] = z - dGeomGetPosition(g)[2];\n    dVector3 tp;\n    dVector3Cross (plane, p, tp);\n    dReal d = dVector3Dot (tp, p);\n    dVector3Cross (plane, tp, plane);\n    dVector3Normalize (plane);\n    plane[3] = d;\n  } else {\n    dReal lx = dGeomBoxGetLength (g) * REAL(0.5);\n    dReal ly = dGeomBoxGetWidth (g) * REAL(0.5);\n    dReal lz = dGeomBoxGetHeight (g) * REAL(0.5);\n    dReal nx = x - dGeomGetPosition(g)[0];\n    dReal ny = y - dGeomGetPosition(g)[1];\n    dReal nz = z - dGeomGetPosition(g)[2];\n    dReal dist = dFabs (nx) + dFabs (ny) + dFabs (nz);\n    if (dist <= lx) {\n      if (nx >= 0) {\n        plane[0] = 1;\n        plane[1] = 0;\n        plane[2] = 0;\n      } else {\n        plane[0] = -1;\n        plane[1] = 0;\n        plane[2] = 0;\n      }\n    } else if (dist <= lx + ly) {\n      if (ny >= 0) {\n        plane[0] = 0;\n        plane[1] = 1;\n        plane[2] = 0;\n      } else {", "CodeBleu_score": 33.882040122772295}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdAASSERT (g && g->type == dBoxClass);\n  dUASSERT (plane, \"argument plane is NULL\");\n  dGeomBoxGetTangentPlane_ST (g, x, y, z, plane);\n}", "CodeBleu_score": 8.038738199666009}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdAASSERT (box);\n  dAASSERT (box->body);\n  dAASSERT (box->geom.body);\n  dAASSERT (box->geom.body->world == box->body->world);\n  dAASSERT (fluidPlane);\n  dAASSERT (immersion);\n  dAASSERT ((flags & (~(dIMMERSE_BOX_SIDE_TOP | dIMMERSE_BOX_SIDE_BOTTOM | dIMMERSE_BOX_SIDE_LEFT | dIMMERSE_BOX_SIDE_RIGHT))) == 0);\n\n  sBoxImmersionData data;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.flags = flags;\n  data.immersion = immersion;\n\n  return dImmerseBoxData (&data);\n}", "CodeBleu_score": 42.31590726212709}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdAASSERT (box);\n  dAASSERT (box->body);\n  dAASSERT ((flags & (dxImmersionOutside|dxImmersionInside|dxImmersionSurrounds))\n      != (dxImmersionOutside|dxImmersionInside|dxImmersionSurrounds));\n  dAASSERT ((flags & (dxImmersionOutside|dxImmersionInside|dxImmersionSurrounds))\n      != 0);\n  dAASSERT (immersion);\n\n  sBoxImmersionData data;\n  data.box = box;\n  data.plane = fluidPlane;\n  data.flags = flags;\n  data.immersion = immersion;\n  return dImmerseBoxData (&data);\n}", "CodeBleu_score": 42.227900075429574}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdAASSERT (box);\n    dAASSERT (box->body);\n    dAASSERT ((flags & ~(dxImmersionBoxSpace)) == 0);\n\n    sBoxImmersionData data;\n    data.box = box;\n    data.fluidPlane = fluidPlane;\n    data.flags = flags;\n    data.immersion = immersion;\n    data.nContacts = 0;\n    data.maxContacts = 0;\n    data.contacts = NULL;\n\n    dImmerseBoxStep1 (&data);\n    dImmerseBoxStep2 (&data);\n\n    return data.nContacts;\n}", "CodeBleu_score": 43.083625109426585}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT (o1 && o2);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dIASSERT (immersion);\n  dIASSERT ((flags & GI_TEST_UNIMPORTANT) == 0);\n\n  dxBox *box = (dxBox *)o1;\n  dxCapsule *capsule = (dxCapsule *)o2;\n\n  dVector3 fluidPlane;\n  dReal t;\n\n  if (!dCapsuleBox (capsule->final_posr->pos, capsule->side, box->side,\n                    capsule->final_posr->R, fluidPlane, &t))\n    return 0;\n\n  if (t < 0) {\n    // the capsule is completely inside the box\n    if (flags & GI_IMPORTANT) {\n      // the user wants to know the contact point\n      dReal sign = (dDOT14(capsule->final_posr->pos, capsule->final_posr->R+2) > 0) ? REAL(1.0) : REAL(-1.0);\n      dVector3Copy(capsule->final_posr->pos, immersion->contact.pos);\n      immersion->contact.pos[1] += sign * capsule->side;\n      dCROSS(immersion->contact.normal, =, capsule->final_posr->R+1, capsule->final_posr->R+2);\n      dNormalize3(immersion->contact.normal);\n    }\n    return 1;\n  }\n\n  // the capsule is not completely inside the box\n  dReal sign = (dDOT14(capsule->final_posr->pos, capsule->final_posr->R+2) > 0) ? REAL(1.0) : REAL(-1.0);\n  dVector3Copy(capsule->final_posr->pos, immersion->contact.pos);\n  immersion->contact.pos[1] += sign * capsule->side * t;\n  dCROSS(immersion->", "CodeBleu_score": 43.64556898531207}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sBoxCapsuleImmersionData data(o1, o2, immersion, flags);\n\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 27.723582473240644}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT (o1 && o2);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This geom has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This geom has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleBoxImmersionData data(o1, o2, immersion, flags);\n\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 31.543244935863274}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tdReal volume = 0;\n\n\t// First, integrate from 0 to tanTheta0\n\tdReal z0 = 0;\n\tdReal z1 = tanTheta0;\n\tdReal sinTheta0 = 0;\n\tdReal sinTheta2 = sinTheta1;\n\tdReal cosTheta0 = 0;\n\tdReal cosTheta2 = dSqrt(1 - sinTheta2 * sinTheta2);\n\tdReal sinTheta12 = sinTheta1 * sinTheta2;\n\tdReal cosTheta12 = cosTheta2 * cosTheta2 - sinTheta12 * sinTheta12;\n\tdReal cosTheta10 = dSqrt(1 - sinTheta0 * sinTheta0);\n\tdReal cosTheta20 = dSqrt(1 - sinTheta2 * sinTheta2);\n\tdReal cosTheta120 = cosTheta10 * cosTheta20;\n\tdReal cosTheta02 = dSqrt(1 - sinTheta0 * sinTheta0);\n\tdReal cosTheta020 = cosTheta02 * cosTheta20;\n\tdReal cosTheta01 = dSqrt(1 - sinTheta0 * sinTheta0);\n\tdReal cosTheta012 = cosTheta01 * cosTheta12;\n\tdReal cosTheta210 = cosTheta20 * cosTheta10;\n\tdReal cosTheta2102 = cosTheta210 * cosTheta2;\n\tdReal cosTheta2100 = cosTheta210 * cosTheta0;\n\tdReal cosTheta0120 = cosTheta01 * cosTheta120;\n\tdReal cosTheta01202 = cosTheta0120 * cosTheta2;\n\tdReal cosTheta01200 = cosTheta0120 * cosTheta0;\n\tdReal cosTheta1200 = cosTheta120 * cosTheta0;\n\tdReal cosTheta1202 = cosTheta120 * cosTheta2;\n\tdReal cosTheta0202 = cosTheta020 * cosTheta2;\n\tdReal cosTheta0200 = cosTheta020 * cosTheta", "CodeBleu_score": 37.56110998599706}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tconst dReal R = m_radius;\n\tconst dReal r = m_radius - m_thickness;\n\tconst dReal R2 = R*R;\n\tconst dReal r2 = r*r;\n\tconst dReal R2mr2 = R2 - r2;\n\tconst dReal R2pR = R2 + R;\n\tconst dReal R2mR = R2 - R;\n\tconst dReal R2pR2 = R2 + R2;\n\tconst dReal R2mR2 = R2 - R2;\n\tconst dReal R2pRmr2 = R2pR - r2;\n\tconst dReal R2mRmr2 = R2mR - r2;\n\tconst dReal R2pRpR2 = R2pR + R2;\n\tconst dReal R2mRpR2 = R2mR + R2;\n\tconst dReal R2pRmR2 = R2pR - R2;\n\tconst dReal R2mRmR2 = R2mR - R2;\n\tconst dReal R2pRpRmr2 = R2pRpR2 - r2;\n\tconst dReal R2mRpRmr2 = R2mRpR2 - r2;\n\tconst dReal R2pRmRmr2 = R2pRmR2 - r2;\n\tconst dReal R2mRmRmr2 = R2mRmR2 - r2;\n\tconst dReal R2pRpRmR2 = R2pRpR2 - R2;\n\tconst dReal R2mRpRmR2 = R2mRpR2 - R2;\n\tconst dReal R2pRmRmR2 = R2pRmR2 - R2;\n\tconst dReal R2mRmRmR2 = R2mRmR2 - R2;\n\n\tconst dReal zI = zIOverR*R;\n\tconst dReal zI2 = zI*zI;\n\tconst dReal zI3 = zI*zI2;", "CodeBleu_score": 35.40834508781698}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tconst dReal zI = zIOverR * m_radius;\n\n\tconst dReal z0 = zI + m_height;\n\tconst dReal z1 = zI - m_height;\n\n\tconst dReal tanTheta0Sq = tanTheta0 * tanTheta0;\n\tconst dReal tanTheta1Sq = sinTheta1 * sinTheta1;\n\n\tconst dReal z0Sq = z0 * z0;\n\tconst dReal z1Sq = z1 * z1;\n\n\tconst dReal z0CosTheta0Sq = z0Sq - zIOverR * zIOverR;\n\tconst dReal z1CosTheta1Sq = z1Sq - zIOverR * zIOverR;\n\n\tconst dReal z0CosTheta0 = dSqrt(z0CosTheta0Sq);\n\tconst dReal z1CosTheta1 = dSqrt(z1CosTheta1Sq);\n\n\tconst dReal z0SinTheta0 = zIOverR * dSqrt(1.0 - tanTheta0Sq);\n\tconst dReal z1SinTheta1 = zIOverR * dSqrt(1.0 - tanTheta1Sq);\n\n\tconst dReal z0CosTheta0OverR = z0CosTheta0 / m_radius;\n\tconst dReal z1CosTheta1OverR = z1CosTheta1 / m_radius;\n\n\tconst dReal z0SinTheta0OverR = z0SinTheta0 / m_radius;\n\tconst dReal z1SinTheta1OverR = z1SinTheta1 / m_radius;\n\n\tconst dReal z0CosTheta0OverR2 = z0CosTheta0OverR * z0CosTheta0OverR;\n\tconst dReal z1CosTheta1OverR2 = z1CosTheta1OverR * z1CosTheta1OverR;\n\n\tconst dReal z0SinTheta0OverR2 = z0SinTheta0OverR * z0SinTheta0OverR;\n\tconst dReal z1SinTheta1OverR", "CodeBleu_score": 37.34331286095036}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tconst dReal r = getRadius();\n\tconst dReal r2 = r*r;\n\tconst dReal r3 = r2*r;\n\tconst dReal r4 = r3*r;\n\tconst dReal r5 = r4*r;\n\tconst dReal r6 = r5*r;\n\tconst dReal r7 = r6*r;\n\tconst dReal r8 = r7*r;\n\tconst dReal r9 = r8*r;\n\tconst dReal r10 = r9*r;\n\tconst dReal r11 = r10*r;\n\tconst dReal r12 = r11*r;\n\tconst dReal r13 = r12*r;\n\tconst dReal r14 = r13*r;\n\tconst dReal r15 = r14*r;\n\tconst dReal r16 = r15*r;\n\tconst dReal r17 = r16*r;\n\tconst dReal r18 = r17*r;\n\tconst dReal r19 = r18*r;\n\tconst dReal r20 = r19*r;\n\tconst dReal r21 = r20*r;\n\tconst dReal r22 = r21*r;\n\tconst dReal r23 = r22*r;\n\tconst dReal r24 = r23*r;\n\tconst dReal r25 = r24*r;\n\tconst dReal r26 = r25*r;\n\tconst dReal r27 = r26*r;\n\tconst dReal r28 = r27*r;\n\tconst dReal r29 = r28*r;\n\tconst dReal r30 = r29*r;\n\tconst dReal r31 = r30*r;\n\tconst dReal r32 = r31*r;\n\tconst dReal r33 = r32*r;\n\tconst dReal r34 = r33*r;\n\tconst dReal r35 = r34*r;\n\tconst dReal r36 = r3", "CodeBleu_score": 35.037781656294406}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tdReal xBuoyancyCenter = 0.0;\n    dReal x0 = 0.0;\n    dReal x1 = 0.0;\n    dReal x2 = 0.0;\n    dReal x3 = 0.0;\n    dReal x4 = 0.0;\n    dReal x5 = 0.0;\n    dReal x6 = 0.0;\n    dReal x7 = 0.0;\n    dReal x8 = 0.0;\n    dReal x9 = 0.0;\n    dReal x10 = 0.0;\n    dReal x11 = 0.0;\n    dReal x12 = 0.0;\n    dReal x13 = 0.0;\n    dReal x14 = 0.0;\n    dReal x15 = 0.0;\n    dReal x16 = 0.0;\n    dReal x17 = 0.0;\n    dReal x18 = 0.0;\n    dReal x19 = 0.0;\n    dReal x20 = 0.0;\n    dReal x21 = 0.0;\n    dReal x22 = 0.0;\n    dReal x23 = 0.0;\n    dReal x24 = 0.0;\n    dReal x25 = 0.0;\n    dReal x26 = 0.0;\n    dReal x27 = 0.0;\n    dReal x28 = 0.0;\n    dReal x29 = 0.0;\n    dReal x30 = 0.0;\n    dReal x31 = 0.0;\n    dReal x32 = 0.0;\n    dReal x33 = 0.0;\n    dReal x34 = 0.0;\n    dReal x35 = 0.0;\n    dReal x36 = 0.0;\n    dReal x37 = 0.0;\n    dReal x38 = 0.0;", "CodeBleu_score": 10.219180234606998}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tdReal x, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63, x64, x65, x66, x67, x68, x69, x70, x71, x72, x73, x74, x75, x76, x77, x78, x79, x80, x81, x82, x83, x84, x85, x86, x87, x88, x89, x90, x91, x92, x93, x94, x95, x96, x97, x98, x99, x100, x101, x102, x103, x104, x105, x106, x107, x108, x109, x110, x111, x112, x113, x114, x115, x116, x117, x118, x119, x120, x121, x122, x123,", "CodeBleu_score": 9.01383198571992}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data((dxCapsule*)o1, (dxTriMesh*)o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 40.971826598364515}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data((dxCapsule*)o1, (dxTriMesh*)o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 34.03392350516129}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleTrimeshImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 33.715619559797915}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the duration of the sleep from the input\n  int duration;\n  if (!getInput<int>(\"duration\", duration)) {\n    // If the duration is missing or non-positive, return SUCCESS\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n\n  // Start the timer\n  timer_ = std::make_unique<ros::Timer>(\n    getNodeHandle().createTimer(ros::Duration(duration / 1000.0),\n      &SleepNode::onTimer, this, true, false));\n\n  // Set the callback to emit a wake-up signal when the timer expires\n  timer_->setCallback(boost::bind(&SleepNode::onTimer, this, _1));\n\n  // Set the timer_waiting_ flag\n  timer_waiting_ = true;\n\n  // Return RUNNING\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 47.39344963078908}, {"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the duration from the input\n    double duration;\n    if (!getInput(duration_input_port_, duration)) {\n        return NodeStatus::FAILURE;\n    }\n    // If the duration is missing or non-positive, return SUCCESS\n    if (duration <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n    // Set the node status to RUNNING\n    setStatus(NodeStatus::RUNNING);\n    // Start a timer\n    timer_ = std::make_shared<rclcpp::TimerBase::SharedPtr>(\n        this->create_wall_timer(std::chrono::milliseconds(duration),\n                                [this]() {\n                                    // When the timer expires, emit a wake-up signal\n                                    this->wakeUp();\n                                }));\n    // Set a callback to reset the timer_waiting_ flag when the timer is aborted\n    timer_->async_reset(\n        [this]() {\n            timer_waiting_ = false;\n        });\n    // Set the timer_waiting_ flag\n    timer_waiting_ = true;\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 51.89441626262301}, {"code": "NodeStatus SleepNode::onStart(){\n\t// Retrieve the duration from the input\n  double duration = getInput<double>(\"duration\");\n\n  // If the duration is missing or non-positive, return SUCCESS\n  if (duration <= 0.0) {\n    return SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  setStatus(RUNNING);\n\n  // Start a timer\n  timer_ = nh_.createTimer(ros::Duration(duration), &SleepNode::timerCallback, this, true, false);\n\n  // Set a callback to emit a wake-up signal when the timer expires\n  timer_.setCanceledCallback(boost::bind(&SleepNode::timerCanceledCallback, this));\n\n  return RUNNING;\n}", "CodeBleu_score": 31.305918274563147}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t// Get the entry\n\tEntry* entry = blackboard->getEntry(entryName);\n\n\t// If the entry was not found\n\tif (entry == NULL) {\n\t\t// Return failure\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the entry mutex\n\tentry->mutex.lock();\n\n\t// If the entry sequence ID is different from the stored sequence ID\n\tif (entry->sequenceID != sequenceID) {\n\t\t// Update the stored sequence ID\n\t\tsequenceID = entry->sequenceID;\n\n\t\t// Unlock the entry mutex\n\t\tentry->mutex.unlock();\n\n\t\t// Return success\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Unlock the entry mutex\n\tentry->mutex.unlock();\n\n\t// Return failure\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 36.02777331163166}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t// Check if the entry exists\n\tif (blackboard->getEntry(entryName) == nullptr)\n\t\treturn NodeStatus::FAILURE;\n\n\t// Retrieve the entry\n\tBlackboard::Entry* entry = blackboard->getEntry(entryName);\n\n\t// Lock the mutex\n\tentry->mutex.lock();\n\n\t// Check if the entry has been updated\n\tif (entry->sequenceID != sequenceID) {\n\t\t// Update the stored sequence ID\n\t\tsequenceID = entry->sequenceID;\n\n\t\t// Unlock the mutex\n\t\tentry->mutex.unlock();\n\n\t\t// Return success\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Unlock the mutex\n\tentry->mutex.unlock();\n\n\t// Return failure\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 41.129868270912965}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tif (entry_found) {\n\t\tentry_mutex->lock();\n\t\tif (entry->sequence_id != last_sequence_id) {\n\t\t\tlast_sequence_id = entry->sequence_id;\n\t\t\tentry_mutex->unlock();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t\telse {\n\t\t\tentry_mutex->unlock();\n\t\t\treturn NodeStatus::FAILURE;\n\t\t}\n\t}\n\telse {\n\t\treturn NodeStatus::FAILURE;\n\t}\n}", "CodeBleu_score": 42.888252594669666}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tif (successThreshold_ < 0) {\n        return -successThreshold_ * children_.size();\n    }\n    return successThreshold_;\n}", "CodeBleu_score": 49.70044753966186}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (m_successThreshold < 0) {\n        return m_childNodes.size() + m_successThreshold;\n    }\n    return m_successThreshold;\n}", "CodeBleu_score": 48.80496116925271}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (successThreshold_ >= 0)\n        return successThreshold_;\n    else\n        return -successThreshold_ * children_.size();\n}", "CodeBleu_score": 46.480274745457514}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t// Continuously check the heartbeat status and enable/disable breakpoints\n  // accordingly.\n  while(true) {\n    // Wait for a second.\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n    // Check the heartbeat status.\n    bool heartbeat_active = false;\n    {\n      std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n      heartbeat_active = _p->heartbeat_active;\n    }\n\n    // Enable or disable all breakpoints depending on the heartbeat status.\n    if(heartbeat_active) {\n      enableAllHooks(true);\n    } else {\n      enableAllHooks(false);\n    }\n  }\n}", "CodeBleu_score": 40.595457408051736}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile(_p->running) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    if(_p->heartbeat_thread_running) {\n      auto now = std::chrono::steady_clock::now();\n      auto delta = std::chrono::duration_cast<std::chrono::milliseconds>(now - _p->heartbeat_time).count();\n      if(delta > 1000) {\n        _p->heartbeat_thread_running = false;\n        enableAllHooks(false);\n      }\n    }\n  }\n}", "CodeBleu_score": 51.391606533191805}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile(!_p->shutdown) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    if(_p->heartbeat_enabled) {\n      if(std::chrono::steady_clock::now() - _p->last_heartbeat > std::chrono::seconds(1)) {\n        // heartbeat is not active anymore, disable all breakpoints\n        enableAllHooks(false);\n      }\n    }\n  }\n}", "CodeBleu_score": 30.149155551444178}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> result;\n  std::vector<std::string> bb_names;\n  std::stringstream ss(bb_list);\n  std::string item;\n  while (std::getline(ss, item, ',')) {\n    bb_names.push_back(item);\n  }\n  for (const std::string& bb_name : bb_names) {\n    const std::string subtree_name = \"groot/\" + bb_name;\n    const std::string json_name = bb_name + \".json\";\n    const std::string msgpack_name = bb_name + \".msgpack\";\n    const std::string json_path = \"/tmp/\" + json_name;\n    const std::string msgpack_path = \"/tmp/\" + msgpack_name;\n    const std::string subtree_path = \"/\" + subtree_name;\n    const std::string subtree_path_slash = \"/\" + subtree_name + \"/\";\n    const std::string subtree_path_slash_slash = \"/\" + subtree_name + \"//\";\n    const std::string subtree_path_slash_slash_slash = \"/\" + subtree_name + \"///\";\n    const std::string subtree_path_slash_slash_slash_slash = \"/\" + subtree_name + \"////\";\n    const std::string subtree_path_slash_slash_slash_slash_slash = \"/\" + subtree_name + \"/////\";\n    const std::string subtree_path_slash_slash_slash_slash_slash_slash = \"/\" + subtree_name + \"//////\";\n    const std::string subtree_path_slash_slash_slash_slash_slash_slash_slash = \"/\" + subtree_name + \"///////\";\n    const std::string subtree_path_slash_slash_slash_slash_slash_slash_slash_slash = \"/\" + subtree_name + \"////////\";\n    const std::string subtree_path_slash_slash_slash_slash_slash_slash_slash_slash_slash = \"/\" + subtree_name + \"/////////\";\n    const std::string", "CodeBleu_score": 34.730440277077854}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t// Split the input string of blackboard names and iterate through them\n    std::vector<std::string> bb_names = split(bb_list, ',');\n    for (const std::string& bb_name : bb_names) {\n        // Find the corresponding subtree and lock it\n        auto subtree = m_tree.lock_subtree(bb_name);\n        if (subtree) {\n            // If the subtree is valid, export the blackboard to JSON and add it to the JSON object\n            std::string json_string = subtree->to_json();\n            m_json_object[bb_name] = json_string;\n        }\n    }\n\n    // Convert the JSON object to MessagePack format and return it as a vector of uint8_t\n    std::vector<uint8_t> msgpack_data;\n    msgpack::pack(msgpack_data, m_json_object);\n    return msgpack_data;\n}", "CodeBleu_score": 47.014840904329105}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> result;\n  std::string bb_name;\n  std::string bb_json;\n  std::string bb_msgpack;\n  std::string::size_type pos = 0;\n  std::string::size_type prev_pos = 0;\n  std::string::size_type len = bb_list.length();\n  std::vector<std::string> blackboard_names;\n  std::vector<std::string>::iterator bb_name_it;\n  std::vector<std::string>::iterator bb_name_end;\n  std::vector<std::string> bb_names;\n  std::vector<std::string> bb_values;\n  std::vector<std::string> bb_types;\n  std::vector<std::string> bb_paths;\n  std::vector<std::string> bb_subscribers;\n  std::vector<std::string> bb_subscribers_types;\n  std::vector<std::string> bb_subscribers_paths;\n  std::vector<std::string> bb_subscribers_values;\n  std::vector<std::string> bb_subscribers_timestamps;\n  std::vector<std::string> bb_subscribers_ids;\n  std::vector<std::string> bb_subscribers_ids_types;\n  std::vector<std::string> bb_subscribers_ids_paths;\n  std::vector<std::string> bb_subscribers_ids_values;\n  std::vector<std::string> bb_subscribers_ids_timestamps;\n  std::vector<std::string> bb_subscribers_ids_ids;\n  std::vector<std::string> bb_subscribers_ids_ids_types;\n  std::vector<std::string> bb_subscribers_ids_ids_paths;\n  std::vector<std::string> bb_subscribers_ids_ids_values;\n  std::vector<std::string> bb_subscribers_ids_ids", "CodeBleu_score": 16.260517507301564}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tMonitor::Hook::Ptr hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->mode != Monitor::Hook::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->cv.notify_all();\n  return true;\n}", "CodeBleu_score": 46.690470561105386}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->mode != Monitor::Hook::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->mode = Monitor::Hook::NORMAL;\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->cv.notify_all();\n  return true;\n}", "CodeBleu_score": 49.29660989099395}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->mode != Monitor::Hook::Mode::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->mode = Monitor::Hook::Mode::NORMAL;\n  hook->result = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->cv.notify_all();\n  return true;\n}", "CodeBleu_score": 50.714286544949935}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  std::future<NodeStatus> future_status;\n  {\n    std::unique_lock<std::mutex> lock(halt_mutex_);\n    future_status = std::async(std::launch::async, [this]() {\n      try\n      {\n        halt_requested_.store(false);\n        return tick_functor_(*this);\n      }\n      catch(const std::exception& ex)\n      {\n        setStatus(NodeStatus::IDLE);\n        std::stringstream ss;\n        ss << \"Caught exception in \" << name() << \": \" << ex.what();\n        throw std::runtime_error(ss.str());\n      }\n    });\n  }\n\n  while(future_status.wait_for(std::chrono::milliseconds(10)) != std::future_status::ready)\n  {\n    if(halt_requested())\n    {\n      {\n        std::unique_lock<std::mutex> lock(halt_mutex_);\n        halt_requested_.store(true);\n      }\n      future_status.get();\n      setStatus(NodeStatus::IDLE);\n      return NodeStatus::IDLE;\n    }\n  }\n\n  NodeStatus status = future_status.get();\n  if(status != prev_status)\n  {\n    setStatus(status);\n  }\n  return status;\n}", "CodeBleu_score": 55.253034341212}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  std::future<NodeStatus> tick_thread = std::async(std::launch::async, &BT::ThreadedAction::tickThread, this);\n  tick_thread_ = std::move(tick_thread);\n\n  return tick_thread_.get();\n}", "CodeBleu_score": 27.471410050486554}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t// Check if the node has already been halted\n  if (halt_requested_) {\n    return NodeStatus::IDLE;\n  }\n\n  // Check if the node is already running\n  if (status() == NodeStatus::RUNNING) {\n    return NodeStatus::RUNNING;\n  }\n\n  // Check if the node has finished\n  if (status() == NodeStatus::SUCCESS || status() == NodeStatus::FAILURE) {\n    return status();\n  }\n\n  // Start the node\n  setStatus(NodeStatus::RUNNING);\n  halt_requested_ = false;\n  std::thread tick_thread([&]() {\n    try {\n      tick_functor_(*this);\n    } catch (const BT::Exception& ex) {\n      setErrorMessage(ex.what());\n      setStatus(NodeStatus::FAILURE);\n    } catch (...) {\n      setErrorMessage(\"Unknown exception\");\n      setStatus(NodeStatus::FAILURE);\n    }\n  });\n  tick_thread.detach();\n\n  return status();\n}", "CodeBleu_score": 41.754124791127545}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t// Define a recursive lambda function to handle the printing\n\tauto print_recursive = [&](const TreeNode* node, int depth) {\n\t\t// Indent the output based on the node's depth\n\t\tfor (int i = 0; i < depth; i++) {\n\t\t\tstream << \"\\t\";\n\t\t}\n\t\t// Print the node's name\n\t\tstream << node->name << std::endl;\n\t\t// Recursively print the children for ControlNode or the child for DecoratorNode\n\t\tif (typeid(*node) == typeid(ControlNode)) {\n\t\t\tfor (auto child : node->children) {\n\t\t\t\tprint_recursive(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (typeid(*node) == typeid(DecoratorNode)) {\n\t\t\tprint_recursive(node->child, depth + 1);\n\t\t}\n\t};\n\t// Begin and end with separator lines\n\tstream << \"--------------------------------------------------------------------------------\" << std::endl;\n\tprint_recursive(root_node, 0);\n\tstream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 42.15668132943828}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tstream << std::endl << \"--------------------------------------------------------------------------------\" << std::endl;\n\tauto print_tree_recursively = [&](const TreeNode* node, int depth) {\n\t\tstd::string indent(depth, '\\t');\n\t\tif (node->getType() == TreeNode::Type::CONTROL_NODE) {\n\t\t\tauto control_node = static_cast<const ControlNode*>(node);\n\t\t\tstream << indent << control_node->getName() << std::endl;\n\t\t\tfor (const auto& child : control_node->getChildren()) {\n\t\t\t\tprint_tree_recursively(child, depth + 1);\n\t\t\t}\n\t\t}\n\t\telse if (node->getType() == TreeNode::Type::DECORATOR_NODE) {\n\t\t\tauto decorator_node = static_cast<const DecoratorNode*>(node);\n\t\t\tstream << indent << decorator_node->getName() << std::endl;\n\t\t\tprint_tree_recursively(decorator_node->getChild(), depth + 1);\n\t\t}\n\t};\n\tprint_tree_recursively(root_node, 0);\n\tstream << std::endl << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 43.91112815218846}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tconst std::string separator = \"--------------------------------------------------------------------------------\";\n\n    stream << separator << std::endl;\n\n    std::function<void(const TreeNode*, int)> printTreeRecursively = [&](const TreeNode* node, int depth) {\n        if (node == nullptr) {\n            return;\n        }\n\n        for (int i = 0; i < depth; i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n\n        if (typeid(*node) == typeid(ControlNode)) {\n            for (const auto& child : static_cast<const ControlNode*>(node)->children()) {\n                printTreeRecursively(child.get(), depth + 1);\n            }\n        } else if (typeid(*node) == typeid(DecoratorNode)) {\n            printTreeRecursively(static_cast<const DecoratorNode*>(node)->child(), depth + 1);\n        }\n    };\n\n    printTreeRecursively(root_node, 0);\n\n    stream << separator << std::endl;\n}", "CodeBleu_score": 52.2688955017082}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.65854358087711}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.65854358087711}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.65854358087711}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builders.find(manifest.registration_ID) != builders.end()) {\n        throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder - \"\n                                    \"Builder with registration ID \" +\n                                    manifest.registration_ID +\n                                    \" already exists in the builders map\");\n    }\n    if (manifests.find(manifest.registration_ID) != manifests.end()) {\n        throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder - \"\n                                    \"Manifest with registration ID \" +\n                                    manifest.registration_ID +\n                                    \" already exists in the manifests map\");\n    }\n    builders.insert(std::make_pair(manifest.registration_ID, builder));\n    manifests.insert(std::make_pair(manifest.registration_ID, manifest));\n}", "CodeBleu_score": 40.31887257297287}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tstd::string registrationID = manifest.registrationID();\n\n    // Check if the registration ID already exists in the builders map\n    if (builders.find(registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder: Registration ID \" + registrationID + \" already exists in the builders map\");\n    }\n\n    // Insert the builder and manifest into their respective maps using the registration ID\n    builders[registrationID] = builder;\n    manifests[registrationID] = manifest;\n}", "CodeBleu_score": 42.64586790697632}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t// Check if the registration ID already exists in the builders map.\n    auto it = builders.find(manifest.registrationID);\n\n    // If the ID is already registered, throw an exception.\n    if (it != builders.end()) {\n        throw BehaviorTreeException(\"Registration ID already exists.\");\n    }\n\n    // If not, insert the builder and manifest into their respective maps using the registration ID.\n    builders.insert(std::make_pair(manifest.registrationID, builder));\n    manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}", "CodeBleu_score": 54.88129408905644}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t// Create the builder\n  NodeBuilder builder = [tick_functor](const std::string& name,\n                                       const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n  };\n\n  // Create the manifest\n  TreeNodeManifest manifest;\n  manifest.type = TreeNodeManifest::ACTION;\n  manifest.registration_ID = ID;\n  manifest.ports = ports;\n\n  // Register the builder and the manifest\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 66.8506404405671}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tauto builder = [=](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = TreeNodeManifest::NodeType::ACTION;\n  manifest.registration_ID = ID;\n  manifest.ports = ports;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 62.05888441298054}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tauto builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n  };\n\n  TreeNodeManifest manifest(ID, ActionNode::type(), std::move(ports));\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 57.46897452681894}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> blackboard_backups;\n    blackboard_backups.reserve(tree.GetSubtrees().size());\n    for (auto& subtree : tree.GetSubtrees()) {\n        auto blackboard_backup = std::make_shared<Blackboard>();\n        for (auto& key : subtree.GetBlackboard().GetKeys()) {\n            blackboard_backup->Set(key, subtree.GetBlackboard().Get(key));\n        }\n        blackboard_backups.push_back(blackboard_backup);\n    }\n    return blackboard_backups;\n}", "CodeBleu_score": 46.90398699037074}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> backups;\n  backups.reserve(tree.GetChildren().size());\n  for (const auto& subtree : tree.GetChildren()) {\n    backups.push_back(std::make_shared<Blackboard>(*subtree->GetBlackboard()));\n  }\n  return backups;\n}", "CodeBleu_score": 54.990832467730485}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.GetChildren().size());\n\n\tfor (const auto& child : tree.GetChildren()) {\n\t\tbackups.push_back(std::make_shared<Blackboard>());\n\t\t*backups.back() = *child.GetBlackboard();\n\t}\n\n\treturn backups;\n}", "CodeBleu_score": 53.865890018884855}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor.has_value())\n  {\n    return executor.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 88.44682696911835}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto result = ParseScript(script);\n  if(result.has_value())\n  {\n    return result.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(result.error());\n  }\n}", "CodeBleu_score": 69.96473983782967}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto maybe_script = ParseScript(script);\n  if(maybe_script.has_value())\n  {\n    return maybe_script.value()(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(maybe_script.error());\n  }\n}", "CodeBleu_score": 69.73553427080549}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\tif (loaded_) {\n        throw RuntimeError(\"Shared library is already loaded\");\n    }\n    if (path.empty()) {\n        throw RuntimeError(\"Shared library path is empty\");\n    }\n\n    std::unique_lock<std::mutex> lock(mutex_);\n    if (loaded_) {\n        throw RuntimeError(\"Shared library is already loaded\");\n    }\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle_) {\n        throw RuntimeError(std::string(\"Failed to load shared library: \") + dlerror());\n    }\n    path_ = path;\n    loaded_ = true;\n}", "CodeBleu_score": 52.54032719182808}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t// Acquire the unique lock on the mutex\n    std::unique_lock<std::mutex> lock(mutex);\n\n    // If a library is already loaded, throw a RuntimeError\n    if (isLoaded()) {\n        throw RuntimeError(\"A library is already loaded.\");\n    }\n\n    // Attempt to load the library using dlopen with RTLD_NOW and RTLD_GLOBAL flags\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    // If the load fails, retrieve the error message and throw a RuntimeError\n    if (handle == nullptr) {\n        throw RuntimeError(dlerror());\n    }\n\n    // Store the path of the loaded library\n    this->path = path;\n}", "CodeBleu_score": 48.78571814928048}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tif (m_libraryHandle != NULL) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n\n    m_libraryHandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (m_libraryHandle == NULL) {\n        throw RuntimeError(std::string(\"Failed to load library: \") + dlerror());\n    }\n\n    m_libraryPath = path;\n}", "CodeBleu_score": 46.37581017540043}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size() < 3) {\n        return false;\n    }\n    StringView stripped = str.trim();\n    if (stripped.size() < 3) {\n        return false;\n    }\n    if (stripped[0] != '{' || stripped[stripped.size() - 1] != '}') {\n        return false;\n    }\n    if (stripped_pointer) {\n        *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    }\n    return true;\n}", "CodeBleu_score": 28.70073895900717}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.length() < 3) {\n        return false;\n    }\n    StringView stripped = str.trim();\n    if (stripped.length() < 3) {\n        return false;\n    }\n    if (stripped[0] != '{') {\n        return false;\n    }\n    if (stripped[stripped.length() - 1] != '}') {\n        return false;\n    }\n    if (stripped_pointer) {\n        *stripped_pointer = stripped.substr(1, stripped.length() - 2);\n    }\n    return true;\n}", "CodeBleu_score": 28.74209860948377}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.length() < 3) {\n        return false;\n    }\n    StringView stripped = str.trim();\n    if (stripped.length() < 3) {\n        return false;\n    }\n    if (stripped.at(0) != '{' || stripped.at(stripped.length() - 1) != '}') {\n        return false;\n    }\n    if (stripped_pointer) {\n        *stripped_pointer = stripped.substr(1, stripped.length() - 2);\n    }\n    return true;\n}", "CodeBleu_score": 28.251554349726714}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble cost = 0;\n    LineIterator line(x0, y0, x1, y1);\n    while(line.isValid()) {\n      cost = pointCost(line.getX(), line.getY());\n      if(cost < 0)\n        return cost;\n      if(cost > cost)\n        cost = cost;\n      line.advance();\n    }\n    return cost;\n  }", "CodeBleu_score": 53.956386625413856}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//initialize the line cost\n    double lineCost = 0;\n    //create a line iterator\n    LineIterator line(x0, y0, x1, y1);\n\n    //iterate through each point on the line\n    while(!line.isDone()) {\n        //calculate the point cost\n        double pointCost = pointCost(line.getX(), line.getY());\n        //if the point cost is negative, return the point cost immediately\n        if(pointCost < 0)\n          return pointCost;\n        //otherwise, update the line cost if the point cost is higher\n        else if(pointCost > lineCost)\n          lineCost = pointCost;\n        //advance the line iterator\n        line.advance();\n    }\n\n    //return the total line cost\n    return lineCost;\n}", "CodeBleu_score": 64.07862760262351}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble lineCost = 0;\n\n    //initialize the line cost to the cost of the first point\n    lineCost = pointCost(x0, y0);\n    if(lineCost < 0)\n      return lineCost;\n\n    //initialize the line iterator\n    LineIterator line(x0, y0, x1, y1);\n    int x, y;\n    //iterate through each point on the line\n    while(!line.isDone()) {\n      line.getNext(x, y);\n      //calculate the cost of the current point\n      double pointCost = pointCost(x, y);\n      //if the point cost is negative, return the point cost immediately\n      if(pointCost < 0)\n        return pointCost;\n      //otherwise, update the line cost if the point cost is higher\n      if(pointCost > lineCost)\n        lineCost = pointCost;\n    }\n    return lineCost;\n  }", "CodeBleu_score": 51.299816757811975}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}", "CodeBleu_score": 86.37196477222697}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  for (unsigned int i=0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 88.93789901765876}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t// TODO: Implement this function!\n}", "CodeBleu_score": 5.57416675955503}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\treturn (std::abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n      std::abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      std::abs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity);\n}", "CodeBleu_score": 67.22879305298619}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\tif (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 84.81861217264999}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t// Check if the robot has stopped.\n  // A robot has stopped when its linear and angular velocities are below\n  // the given thresholds.\n  if (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 76.70913801725064}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t// check if the setup flag is set\n    if (setup_){\n\n        // if so, lock the configuration mutex\n        boost::mutex::scoped_lock lock(config_mutex_);\n\n        // if requested, reset the configuration to default values\n        if (restore_defaults) {\n            config_ = LocalPlannerLimits();\n        }\n\n        // set the configuration to the provided configuration\n        config_ = config;\n\n        // unlock the configuration mutex\n        lock.unlock();\n\n        // update the current limits with the new configuration\n        updateCurrentLimits();\n\n    }\n\n    // if the setup flag is not set, set it up\n    else {\n\n        // set the configuration to the provided configuration\n        config_ = config;\n\n        // set the setup flag\n        setup_ = true;\n\n        // update the current limits with the new configuration\n        updateCurrentLimits();\n\n    }\n\n}", "CodeBleu_score": 51.712683160077944}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_ && restore_defaults) {\n    ROS_WARN(\"Resetting local planner limits to default values.\");\n    config_ = LocalPlannerLimits();\n    setup_ = false;\n  }\n  if (!setup_) {\n    ROS_INFO(\"Setting up local planner limits.\");\n    config_ = config;\n    setup_ = true;\n  }\n  boost::mutex::scoped_lock lock(mutex_);\n  current_ = config;\n}", "CodeBleu_score": 62.044218550757435}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup_ && restore_defaults) {\n        config.max_vel_x = default_config_.max_vel_x;\n        config.min_vel_x = default_config_.min_vel_x;\n        config.max_vel_x_backwards = default_config_.max_vel_x_backwards;\n        config.min_vel_x_backwards = default_config_.min_vel_x_backwards;\n        config.max_vel_y = default_config_.max_vel_y;\n        config.min_vel_y = default_config_.min_vel_y;\n        config.max_vel_theta = default_config_.max_vel_theta;\n        config.min_vel_theta = default_config_.min_vel_theta;\n        config.max_acc_x = default_config_.max_acc_x;\n        config.min_acc_x = default_config_.min_acc_x;\n        config.max_acc_x_backwards = default_config_.max_acc_x_backwards;\n        config.min_acc_x_backwards = default_config_.min_acc_x_backwards;\n        config.max_acc_y = default_config_.max_acc_y;\n        config.min_acc_y = default_config_.min_acc_y;\n        config.max_acc_theta = default_config_.max_acc_theta;\n        config.min_acc_theta = default_config_.min_acc_theta;\n        config.max_rot_vel = default_config_.max_rot_vel;\n        config.min_rot_vel = default_config_.min_rot_vel;\n        config.max_trans_vel = default_config_.max_trans_vel;\n        config.min_trans_vel = default_config_.min_trans_vel;\n        config.max_trans_acc = default_config_.max_trans_acc;\n        config.min_trans_acc = default_config_.min_trans_acc;\n        config.max_rot_acc = default_config_.max_rot_acc;\n        config.min_rot_acc = default_config_.min_", "CodeBleu_score": 29.725266181850923}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tunsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (cost == costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_distance = obstacle_cost_;\n    return false;\n  } else if (cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = obstacle_cost_;\n    return false;\n  }\n  double dist = distance(current_cell, check_cell);\n  if (dist < check_cell->target_distance) {\n    check_cell->target_distance = dist;\n  }\n  return true;\n}", "CodeBleu_score": 61.53865295823567}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tunsigned char cost = costmap.getCost(check_cell->m_x_coord, check_cell->m_y_coord);\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->m_target_distance = std::numeric_limits<float>::max();\n    return false;\n  }\n  else {\n    float new_target_distance = current_cell->m_target_distance +\n      sqrt(pow(check_cell->m_x_coord - current_cell->m_x_coord, 2) +\n      pow(check_cell->m_y_coord - current_cell->m_y_coord, 2));\n    if (new_target_distance < check_cell->m_target_distance) {\n      check_cell->m_target_distance = new_target_distance;\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n}", "CodeBleu_score": 61.590153553695174}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// Check if the cell is an obstacle or has no information\n  if (check_cell->cost == costmap_2d::LETHAL_OBSTACLE || check_cell->cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = obstacle_cost_;\n    return false;\n  }\n\n  // Calculate the new target distance\n  double new_distance = current_cell->target_distance + costmap.getCost(check_cell->x, check_cell->y);\n\n  // Update the target distance if the new distance is shorter\n  if (new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n    return true;\n  }\n\n  return false;\n}", "CodeBleu_score": 52.704887955913236}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = 1.0;\n\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"No footprint specified for ObstacleCostFunction\");\n    return -9.0;\n  }\n\n  scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  for(unsigned int i = 0; i < traj.points_.size(); ++i) {\n    cost = footprintCost(traj.points_[i].x_, traj.points_[i].y_, traj.points_[i].theta_, scale, footprint_spec_, costmap_, world_model_);\n    if (cost < 0) {\n      return cost;\n    }\n\n    if (sum_scores_) {\n      cost += cost;\n    }\n    else {\n      cost = std::max(cost, cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 55.29977539915216}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = 1.0;\n\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"Footprint specification is empty\");\n    return -9.0;\n  }\n\n  scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  for (unsigned int i = 0; i < traj.points_.size(); ++i) {\n    cost = footprintCost(traj.points_[i].x, traj.points_[i].y, traj.points_[i].theta, scale, footprint_spec_, costmap_, world_model_);\n    if (cost < 0) {\n      return cost;\n    }\n    else {\n      if (sum_scores_) {\n        cost += cost;\n      }\n      else {\n        cost = std::max(cost, cost);\n      }\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 56.73604698042861}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n  double scale = 1.0;\n\n  //if we're over a certain speed threshold, we'll scale the robot's\n  //footprint to make it either slow down or stay further from walls\n  scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"No footprint specified for ObstacleCostFunction\");\n    return -9.0;\n  }\n\n  for (unsigned int i = 0; i < traj.points_.size(); ++i) {\n    cost = footprintCost(traj.points_[i].x, traj.points_[i].y, traj.points_[i].theta, scale, footprint_spec_, costmap_, world_model_);\n    if (cost < 0.0) {\n      return cost;\n    }\n    if (sum_scores_) {\n      cost += cost;\n    } else {\n      cost = std::max(cost, cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 56.17839584118417}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// Calculate the footprint points\n  std::vector<geometry_msgs::Point> footprint_points;\n  for (int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point point;\n    point.x = x + (footprint_spec[i].x * scale * cos(th));\n    point.y = y + (footprint_spec[i].y * scale * sin(th));\n    footprint_points.push_back(point);\n  }\n  // Calculate the footprint cost\n  double footprint_cost = world_model->footprintCost(footprint_points, costmap);\n  // If the footprint cost is negative, return -6.0\n  if (footprint_cost < 0.0) {\n    return -6.0;\n  }\n  // If the position is off the map, return -7.0\n  if (!costmap->worldToMap(x, y, x, y)) {\n    return -7.0;\n  }\n  // Otherwise, return the maximum cost between the footprint cost and the cell cost at the given position\n  return std::max(footprint_cost, costmap->getCost(x, y));\n}", "CodeBleu_score": 61.569331726547475}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// Get the current cost at the given position\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my))\n    return -7.0;\n  unsigned char cost = costmap->getCost(mx, my);\n\n  // Scale the footprint points\n  std::vector<geometry_msgs::Point> scaled_footprint_spec;\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point scaled_point;\n    scaled_point.x = scale * footprint_spec[i].x;\n    scaled_point.y = scale * footprint_spec[i].y;\n    scaled_footprint_spec.push_back(scaled_point);\n  }\n\n  // Calculate the footprint cost\n  double footprint_cost = 0.0;\n  for (unsigned int i = 0; i < scaled_footprint_spec.size(); i++) {\n    double footprint_x = scaled_footprint_spec[i].x * cos(th) - scaled_footprint_spec[i].y * sin(th);\n    double footprint_y = scaled_footprint_spec[i].x * sin(th) + scaled_footprint_spec[i].y * cos(th);\n    footprint_x += x;\n    footprint_y += y;\n    unsigned int mx, my;\n    if (!costmap->worldToMap(footprint_x, footprint_y, mx, my))\n      return -7.0;\n    unsigned char footprint_cost_at_point = costmap->getCost(mx, my);\n    if (footprint_cost_at_point == costmap_2d::LETHAL_OBSTACLE)\n      return -6.0;\n    if (footprint_cost_at_point > footprint_cost)\n      footprint_cost = footprint_cost_at_point;\n  }\n\n  // Return the maximum cost between the footprint cost and the cell cost at the given position\n  if (footprint_cost > cost", "CodeBleu_score": 61.89281929596135}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// Scaling the footprint points\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point p;\n    p.x = scale * footprint_spec[i].x;\n    p.y = scale * footprint_spec[i].y;\n    scaled_footprint.push_back(p);\n  }\n\n  // Transforming the footprint points to the robot's frame\n  std::vector<geometry_msgs::Point> transformed_footprint;\n  for (unsigned int i = 0; i < scaled_footprint.size(); i++) {\n    geometry_msgs::Point p;\n    p.x = scaled_footprint[i].x * cos(th) - scaled_footprint[i].y * sin(th);\n    p.y = scaled_footprint[i].x * sin(th) + scaled_footprint[i].y * cos(th);\n    transformed_footprint.push_back(p);\n  }\n\n  // Calculating the footprint cost\n  double footprint_cost = 0.0;\n  for (unsigned int i = 0; i < transformed_footprint.size(); i++) {\n    geometry_msgs::Point p;\n    p.x = x + transformed_footprint[i].x;\n    p.y = y + transformed_footprint[i].y;\n    double cost = world_model->footprintCost(p, costmap);\n    if (cost < 0) {\n      return -6.0;\n    }\n    footprint_cost = std::max(footprint_cost, cost);\n  }\n\n  // Calculating the cell cost\n  double cell_cost = world_model->footprintCost(x, y, costmap);\n  if (cell_cost < 0) {\n    return -7.0;\n  }\n\n  // Returning the maximum cost\n  return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 64.30630086511513}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tboost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic_ == odom_topic)\n    return;\n  odom_topic_ = odom_topic;\n  if (odom_topic_ != \"\") {\n    odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n  } else {\n    odom_sub_.shutdown();\n  }\n}", "CodeBleu_score": 48.81274981588937}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Setting odometry topic to [%s]\", odom_topic_.c_str());\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Unsubscribing from odometry topic\");\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 49.04807177468354}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tROS_DEBUG_NAMED(\"dwa_local_planner\", \"OdometryHelperRos::setOdomTopic: new odom topic is [%s]\", odom_topic.c_str());\n  boost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      ROS_DEBUG_NAMED(\"dwa_local_planner\", \"OdometryHelperRos::setOdomTopic: subscribing to topic [%s]\", odom_topic_.c_str());\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      ROS_DEBUG_NAMED(\"dwa_local_planner\", \"OdometryHelperRos::setOdomTopic: shutting down odometry subscription\");\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 42.5984481469723}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist = (pos - prev).squaredNorm();\n  float angle = (pos - prev).normalized().dot(prev - pos);\n\n  if (dist > oscillation_distance_threshold_ || angle > oscillation_angle_threshold_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 35.44886761359578}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tEigen::Vector3f diff = pos - prev;\n  float dist = diff.norm();\n  float angle = atan2(diff(1), diff(0));\n\n  if (dist > 0.005 || fabs(angle) > 0.1) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 31.783877826868572}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tEigen::Vector3f diff = pos - prev;\n  float dist_sq = diff.dot(diff);\n  float angle = std::acos(diff.normalized().dot(prev.normalized()));\n\n  if (dist_sq > dist_sq_threshold_) {\n    resetOscillationFlags();\n  }\n  else if (angle > angle_threshold_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 38.904575487040994}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  gridCoords(pt, gx, gy);\n\n  //if the point is outside the grid bounds, or too close to its nearest neighbor, return\n  if(gx >= width_ || gy >= height_ || nearestNeighborDistance(pt) < sq_min_separation_)\n    return;\n\n  //get the grid index\n  unsigned int idx = gx + gy * width_;\n\n  //insert the point into the cell\n  cells_[idx].push_back(pt);\n}", "CodeBleu_score": 70.25429848779446}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //check if the point is outside the grid bounds\n    if(gx >= width_ || gy >= height_)\n      return;\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //check if the point is too close to its nearest neighbor\n    if(sq_distance(pt, lower_left) < sq_min_separation_)\n      return;\n\n    //now we can insert the point\n    unsigned int index = gx + gy * width_;\n    cells_[index].push_back(pt);\n}", "CodeBleu_score": 63.73661131411319}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  gridCoords(pt, gx, gy);\n\n  //if the point is too close to its nearest neighbor, don't insert it\n  if(nearestNeighborDistance(pt) < sq_min_separation_)\n    return;\n\n  //if the point is outside the grid bounds, don't insert it\n  if(gx >= width_ || gy >= height_)\n    return;\n\n  //calculate the grid index\n  unsigned int index = gy * width_ + gx;\n\n  //insert the point into the cell\n  cells_[index].push_back(pt);\n}", "CodeBleu_score": 72.23284282102341}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel;\n  new_vel.setZero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel(i) > vel(i)) {\n      new_vel(i) = vel(i) + acclimits(i) * dt;\n      if (new_vel(i) > sample_target_vel(i)) {\n        new_vel(i) = sample_target_vel(i);\n      }\n    }\n    else {\n      new_vel(i) = vel(i) - acclimits(i) * dt;\n      if (new_vel(i) < sample_target_vel(i)) {\n        new_vel(i) = sample_target_vel(i);\n      }\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 54.31266117378717}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel;\n  new_vel.setZero();\n  for (int i = 0; i < 3; i++) {\n    if (vel(i) < sample_target_vel(i)) {\n      new_vel(i) = vel(i) + acclimits(i) * dt;\n      if (new_vel(i) > sample_target_vel(i)) {\n        new_vel(i) = sample_target_vel(i);\n      }\n    }\n    else if (vel(i) > sample_target_vel(i)) {\n      new_vel(i) = vel(i) - acclimits(i) * dt;\n      if (new_vel(i) < sample_target_vel(i)) {\n        new_vel(i) = sample_target_vel(i);\n      }\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 53.04017644841391}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel(i) > vel(i) + acclimits(i) * dt) {\n      new_vel(i) = vel(i) + acclimits(i) * dt;\n    } else if (sample_target_vel(i) < vel(i) - acclimits(i) * dt) {\n      new_vel(i) = vel(i) - acclimits(i) * dt;\n    } else {\n      new_vel(i) = sample_target_vel(i);\n    }\n  }\n\n  return new_vel;\n}", "CodeBleu_score": 62.01504322373028}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tdouble heading_diff = DBL_MAX;\n  double goal_heading = atan2(y - cell_y, x - cell_x);\n\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    if (isCellClear(cell_x, cell_y)) {\n      goal_heading = atan2(y - cell_y, x - cell_x);\n      break;\n    }\n\n    cell_x = global_plan_[i].x;\n    cell_y = global_plan_[i].y;\n  }\n\n  if (goal_heading < 0) {\n    goal_heading += 2 * M_PI;\n  }\n\n  heading_diff = fabs(goal_heading - heading);\n\n  if (heading_diff > M_PI) {\n    heading_diff = 2 * M_PI - heading_diff;\n  }\n\n  return heading_diff;\n}", "CodeBleu_score": 51.592777372470245}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tdouble diff = 0.0;\n  double goal_x, goal_y;\n  double goal_heading;\n\n  // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell.\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    // Convert the goal cell coordinates to world coordinates.\n    goal_x = global_plan_[i].x;\n    goal_y = global_plan_[i].y;\n    // Calculate the shortest angular distance between the current heading and the direction to the goal point.\n    goal_heading = atan2(goal_y - y, goal_x - x);\n    diff = fabs(angles::shortest_angular_distance(heading, goal_heading));\n    // If a valid point is found, return the absolute value of the shortest angular distance between the current heading and the direction to the goal point.\n    if (pointValid(cell_x, cell_y) && lineCost(cell_x, cell_x + (int) round(cos(goal_heading)), cell_y, cell_y + (int) round(sin(goal_heading))) >= 0) {\n      return diff;\n    }\n  }\n\n  // If no valid point is found, return DBL_MAX.\n  return DBL_MAX;\n}", "CodeBleu_score": 57.64709766674836}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t//Find the farthest point in the global plan with a clear line of sight to the goal\n  int i = globalPlan.size() - 1;\n  while (i >= 0) {\n    if (globalPlan[i].x == cell_x && globalPlan[i].y == cell_y) {\n      //If the cell is on the global plan, then the line of sight is clear\n      break;\n    }\n    else {\n      //If the cell is not on the global plan, then check if the cell is occupied\n      if (map.data[cell_y * map.info.width + cell_x] == 100) {\n        //If the cell is occupied, then the line of sight is blocked\n        break;\n      }\n      else {\n        //If the cell is not occupied, then check if the cell is in the global plan\n        bool in_plan = false;\n        for (unsigned int j = 0; j < globalPlan.size(); j++) {\n          if (globalPlan[j].x == cell_x && globalPlan[j].y == cell_y) {\n            in_plan = true;\n            break;\n          }\n        }\n        if (in_plan) {\n          //If the cell is in the global plan, then the line of sight is clear\n          break;\n        }\n        else {\n          //If the cell is not in the global plan, then check if the cell is in the local plan\n          bool in_local = false;\n          for (unsigned int j = 0; j < localPlan.size(); j++) {\n            if (localPlan[j].x == cell_x && localPlan[j].y == cell_y) {\n              in_local = true;\n              break;\n            }\n          }\n          if (in_local) {\n            //If the cell is in the local plan, then the line of sight is clear\n            break;\n          }\n          else {\n            //If the cell is not in the local plan, then check if the cell is in the local plan\n            bool in_local = false;\n            for (unsigned int j = 0; j < localPlan.size(); j++) {\n              if (localPlan[j].x", "CodeBleu_score": 37.70141784992952}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tTrajectory t;\n    double impossible_cost = path_map_.obstacleCosts();\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // return the cost.\n    if (t.cost_ < 0) {\n      ROS_WARN(\"Invalid trajectory: vx_samp=%f, vy_samp=%f, vtheta_samp=%f, cost=%f\",\n               vx_samp, vy_samp, vtheta_samp, t.cost_);\n      return false;\n    }\n    else {\n      return true;\n    }\n}", "CodeBleu_score": 58.48841683703094}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    // if the cost is negative, then the trajectory is invalid.\n    if( cost < 0.0 ) {\n      ROS_WARN(\"Trajectory rejected: sample velocities (%f,%f,%f), cost %f\",\n               vx_samp, vy_samp, vtheta_samp, cost);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 77.66489634407603}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n      ROS_WARN(\"Trajectory rejected: cost=%f, vx_samp=%f, vy_samp=%f, vtheta_samp=%f\",\n               cost, vx_samp, vy_samp, vtheta_samp);\n      return false;\n    } else {\n      return true;\n    }\n}", "CodeBleu_score": 74.74262219663417}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"The plugin must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"The global_costmap_ member must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"The local_costmap_ member must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside of the area to clear\");\n  } else {\n    ROS_WARN(\"Clearing inside of the area to clear\");\n  }\n\n  ros::Time start_time = ros::Time::now();\n\n  if (affected_maps_ == AFFECTED_MAPS_GLOBAL) {\n    clear(global_costmap_);\n  } else if (affected_maps_ == AFFECTED_MAPS_LOCAL) {\n    clear(local_costmap_);\n  } else if (affected_maps_ == AFFECTED_MAPS_BOTH) {\n    clear(global_costmap_);\n    clear(local_costmap_);\n  }\n\n  ros::Time end_time = ros::Time::now();\n\n  ROS_INFO_STREAM(\"Time to clear: \" << (end_time - start_time).toSec());\n}", "CodeBleu_score": 46.00825750637082}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"The behavior has not been initialized, please call initialize() before runBehavior()\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"The global costmap is NULL, please set it before runBehavior()\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"The local costmap is NULL, please set it before runBehavior()\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing outside of the specified area\");\n  } else {\n    ROS_WARN(\"Clearing inside of the specified area\");\n  }\n\n  ros::Time start = ros::Time::now();\n  clear(global_costmap_);\n  ros::Duration global_clear_time = ros::Time::now() - start;\n  ROS_INFO_STREAM(\"Global costmap clearing took \" << global_clear_time.toSec() << \" seconds\");\n\n  if (affected_maps_ == AFFECT_GLOBAL_COSTMAP || affected_maps_ == AFFECT_BOTH_COSTMAPS) {\n    start = ros::Time::now();\n    clear(local_costmap_);\n    ros::Duration local_clear_time = ros::Time::now() - start;\n    ROS_INFO_STREAM(\"Local costmap clearing took \" << local_clear_time.toSec() << \" seconds\");\n  }\n}", "CodeBleu_score": 47.640495984291974}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"The plugin must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmap pointers must be set before runBehavior is called\");\n    return;\n  }\n\n  if (invert_area_to_clear_ && (clearing_inside_robot_footprint_ || clearing_inside_inscribed_polygon_)) {\n    ROS_WARN(\"Clearing inside the footprint or inscribed polygon, this will clear the area outside the footprint or inscribed polygon\");\n  }\n\n  if (!invert_area_to_clear_ && (clearing_outside_robot_footprint_ || clearing_outside_inscribed_polygon_)) {\n    ROS_WARN(\"Clearing outside the footprint or inscribed polygon, this will clear the area inside the footprint or inscribed polygon\");\n  }\n\n  if (affected_maps_ & GLOBAL_COSTMAP) {\n    if (clearing_inside_robot_footprint_) {\n      ROS_INFO(\"Clearing inside the footprint\");\n      clearMap(global_costmap_, global_costmap_->getRobotPose().x, global_costmap_->getRobotPose().y);\n    } else if (clearing_inside_inscribed_polygon_) {\n      ROS_INFO(\"Clearing inside the inscribed polygon\");\n      clearMap(global_costmap_, global_costmap_->getRobotPose().x, global_costmap_->getRobotPose().y);\n    } else if (clearing_outside_robot_footprint_) {\n      ROS_INFO(\"Clearing outside the footprint\");\n      clearMap(global_costmap_, global_costmap_->getRobotPose().x, global_costmap_->getRobotPose().y);\n    } else if (clearing_outside_inscribed_polygon_) {\n      ROS_INFO(\"Clearing outside the inscribed polygon\");\n      clearMap(global_costmap_, global_costmap_", "CodeBleu_score": 39.65022595347369}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tpolygon_cells.clear();\n  if (polygon.empty()) {\n    return;\n  }\n  PolygonOutlineCells outline_cells(polygon, *this);\n  outline_cells.getCells(polygon_cells);\n}", "CodeBleu_score": 17.612435802616595}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t// create an object to collect the cells\n  PolygonOutlineCells outline;\n\n  // iterate through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points\n  for(unsigned int i = 0; i < polygon.size(); ++i) {\n    const MapLocation& vertex1 = polygon[i];\n    const MapLocation& vertex2 = polygon[(i + 1) % polygon.size()];\n    raytraceLine(vertex1, vertex2, outline);\n  }\n\n  // if the polygon is not empty, it also closes the polygon by connecting the last point to the first\n  if(polygon.size() > 0) {\n    const MapLocation& vertex1 = polygon[polygon.size() - 1];\n    const MapLocation& vertex2 = polygon[0];\n    raytraceLine(vertex1, vertex2, outline);\n  }\n\n  // copy the cells into the output vector\n  polygon_cells = outline.cells;\n\n}", "CodeBleu_score": 51.67184860467856}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tpolygon_cells.clear();\n    if (polygon.empty()) {\n        return;\n    }\n    PolygonOutlineCells outline(polygon, *this);\n    outline.gatherCells(polygon_cells);\n}", "CodeBleu_score": 17.895364415979458}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tif (pub.getSubscriberName() != \"map_server\")\n  {\n    prepareGrid();\n    pub.publish(grid_);\n  }\n}", "CodeBleu_score": 80.77021088330969}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tif (pub.getSubscriber().getTopic() == topic_) {\n    prepareGrid();\n    pub.publish(grid_);\n  }\n}", "CodeBleu_score": 80.8734843657371}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tif (pub.getSubscriber().getTopic() == \"costmap_updates\")\n  {\n    prepareGrid();\n    pub.publish(grid_);\n  }\n}", "CodeBleu_score": 79.67675125033307}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\tboost::mutex::scoped_lock lock(costmap_mutex_);\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = costmap_->getResolution();\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = char2cost(costmap_->getCost(i % grid_.info.width, i / grid_.info.width));\n  }\n}", "CodeBleu_score": 55.922102742914085}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*costmap_);\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\ttf::Quaternion q(0, 0, 0, 1);\n\ttf::quaternionTFToMsg(q, grid_.info.origin.orientation);\n\tgrid_.data.resize(costmap_->getSizeInCellsX() * costmap_->getSizeInCellsY());\n\tfor (unsigned int i = 0; i < costmap_->getSizeInCellsX() * costmap_->getSizeInCellsY(); i++) {\n\t\tgrid_.data[i] = costmap_->getCharMap()[i];\n\t}\n}", "CodeBleu_score": 56.659986861759634}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t// Lock the costmap mutex\n\tboost::mutex::scoped_lock lock(costmap_mutex_);\n\n\t// Retrieve the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\n\t// Set the grid's resolution, width, and height\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\t// Set the origin's position and orientation\n\tgeometry_msgs::Pose origin;\n\tcostmap_->mapToWorld(0, 0, origin.position.x, origin.position.y);\n\ttf::Quaternion q = tf::createQuaternionFromYaw(costmap_->getYaw());\n\torigin.orientation.x = q.x();\n\torigin.orientation.y = q.y();\n\torigin.orientation.z = q.z();\n\torigin.orientation.w = q.w();\n\n\t// Save the origin coordinates\n\torigin_ = origin;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < costmap_->getSizeInCellsX(); ++i) {\n\t\tfor (unsigned int j = 0; j < costmap_->getSizeInCellsY(); ++j) {\n\t\t\tunsigned int index = i + j * costmap_->getSizeInCellsX();\n\t\t\tgrid_.data[index] = translation_table_[costmap_->getCost(i, j)];\n\t\t}\n\t}\n}", "CodeBleu_score": 60.33264715616233}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t// if the footprint or robot radius hasn't changed, don't do anything\n  if (new_config.robot_radius == old_config.robot_radius &&\n      new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  // if a valid footprint string has been provided, parse it\n  if (new_config.footprint != \"\") {\n    std::vector<geometry_msgs::Point> points;\n    if (!parseFootprintString(new_config.footprint, points)) {\n      ROS_ERROR(\"Could not parse the footprint string.  The old footprint will be used.\");\n      return;\n    }\n\n    // set the footprint\n    setUnpaddedRobotFootprint(points);\n    return;\n  }\n\n  // if no valid footprint string has been provided, set the footprint based on the robot radius\n  std::vector<geometry_msgs::Point> points;\n  points.push_back(geometry_msgs::Point(new_config.robot_radius, 0.0, 0.0));\n  points.push_back(geometry_msgs::Point(0.0, new_config.robot_radius, 0.0));\n  points.push_back(geometry_msgs::Point(0.0, 0.0, new_config.robot_radius));\n  points.push_back(geometry_msgs::Point(-new_config.robot_radius, 0.0, 0.0));\n  points.push_back(geometry_msgs::Point(0.0, -new_config.robot_radius, 0.0));\n  points.push_back(geometry_msgs::Point(0.0, 0.0, -new_config.robot_radius));\n  setUnpaddedRobotFootprint(points);\n}", "CodeBleu_score": 57.86955499168065}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.robot_radius == old_config.robot_radius &&\n      new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  std::vector<geometry_msgs::Point> points;\n  if (!new_config.footprint.empty()) {\n    if (!layered_costmap_->parseFootprintFromString(new_config.footprint, points)) {\n      ROS_ERROR(\"Invalid footprint string provided.  Using default.\");\n    } else {\n      setUnpaddedRobotFootprint(points);\n      return;\n    }\n  }\n\n  // if we get here, we need to generate a default footprint based on the radius\n  setUnpaddedRobotFootprint(layered_costmap_->createFootprintFromRadius(new_config.robot_radius));\n}", "CodeBleu_score": 62.27171857148809}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\tif (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> points;\n    if (!layered_costmap_->parseFootprint(new_config.footprint, new_config.robot_radius, points)) {\n      ROS_ERROR(\"Invalid footprint string\");\n      return;\n    }\n    setUnpaddedRobotFootprint(points);\n  } else {\n    setUnpaddedRobotFootprint(layered_costmap_->getDefaultFootprint(new_config.robot_radius));\n  }\n}", "CodeBleu_score": 68.7170161889363}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t// get the robot's pose\n  geometry_msgs::PoseStamped global_pose;\n  if (!getRobotPose(global_pose))\n  {\n    ROS_WARN(\"Unable to reconfigure the costmap because the robot's pose could not be determined.\");\n    return;\n  }\n\n  // update the robot's pose\n  if (global_pose.header.frame_id != global_frame_)\n  {\n    ROS_WARN(\"The robot's pose was in the wrong frame. This should not happen.\");\n    return;\n  }\n  if (!tf_.waitForTransform(global_frame_, robot_base_frame_, global_pose.header.stamp, ros::Duration(0.1)))\n  {\n    ROS_WARN(\"The robot's pose was in the wrong frame. This should not happen.\");\n    return;\n  }\n  tf2::doTransform(global_pose, new_pose, tf_);\n\n  // update the costmap\n  if (new_pose.header.stamp != last_update_time_)\n  {\n    // update the costmap\n    if (new_pose.header.stamp.toSec() - last_update_time_.toSec() > update_interval_)\n    {\n      // update the robot's pose\n      if (!tf_.waitForTransform(global_frame_, robot_base_frame_, new_pose.header.stamp, ros::Duration(0.1)))\n      {\n        ROS_WARN(\"The robot's pose was in the wrong frame. This should not happen.\");\n        return;\n      }\n      tf2::doTransform(new_pose, new_pose, tf_);\n      if (new_pose.header.stamp != last_update_time_)\n      {\n        // update the costmap\n        updateMap(new_pose);\n        last_update_time_ = new_pose.header.stamp;\n      }\n    }\n  }\n}", "CodeBleu_score": 44.894725337795464}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped global_pose;\n  if (!getRobotPose(global_pose)) {\n    ROS_WARN_THROTTLE(1.0, \"Failed to get robot pose for reconfiguration. Aborting.\");\n    return;\n  }\n  new_pose_ = global_pose.pose;\n  reconfigure_ = true;\n}", "CodeBleu_score": 59.77669121257267}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t// get the robot's pose\n  geometry_msgs::PoseStamped global_pose;\n  if (!getRobotPose(global_pose))\n  {\n    ROS_WARN(\"Failed to get the robot pose. Reconfiguration canceled.\");\n    return;\n  }\n\n  // check if the robot has moved\n  if (global_pose.pose.position.x == last_pose_.pose.position.x &&\n      global_pose.pose.position.y == last_pose_.pose.position.y &&\n      global_pose.pose.orientation.z == last_pose_.pose.orientation.z &&\n      global_pose.pose.orientation.w == last_pose_.pose.orientation.w)\n  {\n    return;\n  }\n\n  // update the robot's pose\n  last_pose_ = global_pose;\n\n  // update the global_frame_ to the robot's new pose\n  global_frame_ = tf2::getFrameId(global_pose);\n\n  // update the robot's footprint if it has changed\n  if (robot_footprint_pub_.getNumSubscribers() > 0)\n  {\n    updateRobotFootprint();\n  }\n\n  // update the costmap\n  if (update_thread_.joinable())\n  {\n    update_thread_.join();\n  }\n  update_thread_ = std::thread(&Costmap2DROS::updateCostmap, this);\n}", "CodeBleu_score": 45.90537118679578}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t// get the list of plugins\n  std::vector<boost::shared_ptr<Layer> > layers;\n  getLayers(layers);\n\n  // check if the costmap was stopped\n  if (stopped_) {\n    // re-subscribe to topics by activating each plugin\n    for (std::vector<boost::shared_ptr<Layer> >::iterator it = layers.begin(); it != layers.end(); ++it) {\n      (*it)->onInitialize();\n    }\n    // set the stopped flag to false\n    stopped_ = false;\n  }\n\n  // set stop_updates_ to false\n  stop_updates_ = false;\n\n  // wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::ok() || !initialized_ || !map_update_thread_.isRunning()) {\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 62.58873433316157}, {"code": "void Costmap2DROS::start(){\n\tif (!stopped_) {\n    return;\n  }\n  stopped_ = false;\n  stop_updates_ = false;\n  for (std::vector<boost::shared_ptr<Layer> >::iterator layer = layers_.begin(); layer != layers_.end(); ++layer) {\n    (*layer)->activate();\n  }\n  ROS_DEBUG(\"Reactivated plugins\");\n  // wait until ROS is running\n  while (!ros::ok()) {\n  }\n  // wait until the costmap is initialized\n  while (!initialized_) {\n  }\n  // wait until the map update thread is active\n  while (!map_update_thread_active_) {\n  }\n  ROS_INFO(\"Costmap2DROS started\");\n}", "CodeBleu_score": 49.00018619892376}, {"code": "void Costmap2DROS::start(){\n\tif (!is_running_) {\n    ROS_INFO(\"Starting the costmap\");\n    is_running_ = true;\n    if (stop_updates_) {\n      ROS_INFO(\"Reactivating costmap plugins\");\n      for (std::list<Costmap2D::CostmapPluginPtr>::iterator plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n        if ((*plugin)->getCostmap2D() != NULL) {\n          (*plugin)->activate();\n        }\n      }\n      stop_updates_ = false;\n    }\n  }\n  while (!ros::ok() || !initialized_ || !map_update_thread_active_) {\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 48.310386690335996}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == 0) {\n    // Keep only the most recent observation.\n    if (observation_list_.size() > 1) {\n      observation_list_.pop_front();\n    }\n    return;\n  }\n\n  // Iterate through the list and remove observations that are older than the specified keep time.\n  while (!observation_list_.empty()) {\n    // Get the time of the oldest observation.\n    ros::Time oldest_observation_time = observation_list_.front().header.stamp;\n\n    // Check if the oldest observation is still valid.\n    if (ros::Time::now() - oldest_observation_time < observation_keep_time_) {\n      // The oldest observation is still valid.\n      return;\n    }\n\n    // The oldest observation is not valid.\n    observation_list_.pop_front();\n  }\n}", "CodeBleu_score": 35.627973812655085}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == ros::Duration(0.0)) {\n    // If the observation keep time is zero, we only keep the most recent observation.\n    if (observations_.size() > 1) {\n      observations_.pop_front();\n    }\n    return;\n  }\n\n  // Iterate through the list and remove observations that are older than the specified keep time, stopping once it finds a valid observation.\n  while (observations_.size() > 1) {\n    if (observations_.front().header.stamp + observation_keep_time_ > ros::Time::now()) {\n      break;\n    }\n    observations_.pop_front();\n  }\n}", "CodeBleu_score": 32.060184177475435}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == ros::Duration(0.0)) {\n        // Keep only the most recent observation\n        if (observation_list_.size() > 0) {\n            observation_list_.pop_front();\n        }\n    } else {\n        // Keep only the most recent observation within the specified time\n        ros::Time now = ros::Time::now();\n        while (observation_list_.size() > 0) {\n            if (now - observation_list_.front().header.stamp < observation_keep_time_) {\n                break;\n            }\n            observation_list_.pop_front();\n        }\n    }\n}", "CodeBleu_score": 38.694812121692166}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tif (start_index >= end_index) {\n    return;\n  }\n\n  double start_angle = get_angle(&path[start_index]);\n  double end_angle = get_angle(&path[end_index]);\n  double increment = 0;\n  double angle = 0;\n\n  if (fabs(end_angle - start_angle) > M_PI) {\n    if (end_angle < start_angle) {\n      increment = 2 * M_PI + end_angle - start_angle;\n    } else {\n      increment = end_angle - start_angle - 2 * M_PI;\n    }\n  } else {\n    increment = end_angle - start_angle;\n  }\n\n  for (int i = start_index + 1; i < end_index; i++) {\n    angle = start_angle + (i - start_index) * increment / (end_index - start_index);\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 50.67685062021503}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// if the path is empty, return\n  if (path.size() == 0) {\n    return;\n  }\n\n  // if the start index is greater than the end index, swap them\n  if (start_index > end_index) {\n    int temp = start_index;\n    start_index = end_index;\n    end_index = temp;\n  }\n\n  // if the start index is negative, set it to 0\n  if (start_index < 0) {\n    start_index = 0;\n  }\n\n  // if the end index is greater than the size of the path, set it to the last pose in the path\n  if (end_index >= path.size()) {\n    end_index = path.size() - 1;\n  }\n\n  // if the start and end indices are the same, return\n  if (start_index == end_index) {\n    return;\n  }\n\n  // get the yaw angle at the start index\n  double start_angle = get_angle(&path[start_index]);\n\n  // get the yaw angle at the end index\n  double end_angle = get_angle(&path[end_index]);\n\n  // get the shortest angular distance between the start and end angles\n  double delta_angle = angles::shortest_angular_distance(start_angle, end_angle);\n\n  // if the angular distance is 0, return\n  if (delta_angle == 0.0) {\n    return;\n  }\n\n  // get the incremental change in angle for each pose\n  double delta_angle_inc = delta_angle / (end_index - start_index);\n\n  // set the yaw angle of the start pose to the end pose\n  set_angle(&path[start_index], end_angle);\n\n  // for each pose between the start and end indices\n  for (int i = start_index + 1; i <= end_index; i++) {\n    // get the yaw angle at the current index\n    double angle = get_angle(&path[i]);\n\n    // get the incremental change in angle\n    double delta_angle_inc_current = delta_angle_inc *", "CodeBleu_score": 48.16495064375223}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tif (start_index < 0 || start_index >= path.size() || end_index < 0 || end_index >= path.size())\n    return;\n\n  double start_angle = get_angle(&path[start_index]);\n  double end_angle = get_angle(&path[end_index]);\n\n  double delta_angle = shortest_angular_distance(start_angle, end_angle);\n\n  double increment = delta_angle / (end_index - start_index);\n  for (int i = start_index + 1; i < end_index; i++) {\n    double angle = start_angle + (i - start_index) * increment;\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 56.8390486417414}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tif (!initialized_) {\n    ROS_ERROR(\"PlannerWithCostmap has not been initialized\");\n    return false;\n  }\n\n  // convert the start and goal pose to a frame_id of \"map\"\n  geometry_msgs::PoseStamped start, goal;\n  start.header = req.start.header;\n  start.header.frame_id = \"map\";\n  start.pose = req.start.pose;\n  goal.header = req.goal.header;\n  goal.header.frame_id = \"map\";\n  goal.pose = req.goal.pose;\n\n  // make the plan\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(start, goal, path);\n\n  // set the success status and the path\n  resp.success = success;\n  if (success) {\n    resp.plan = path;\n  }\n\n  return true;\n}", "CodeBleu_score": 62.03458597672344}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t//ROS_INFO(\"PlannerWithCostmap::makePlanService called\");\n\n  // set the frame_id of the start and goal to \"map\"\n  geometry_msgs::PoseStamped start;\n  start.header.frame_id = \"map\";\n  start.pose = req.start;\n  geometry_msgs::PoseStamped goal;\n  goal.header.frame_id = \"map\";\n  goal.pose = req.goal;\n\n  // call makePlan to generate a path\n  bool success = makePlan(start, goal, resp.plan);\n\n  // update the response with the success status and the generated path if a plan is found\n  resp.success = success;\n  if (success) {\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n  }\n\n  // return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 60.58113795675181}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t// set the start and goal frames to be the global frame\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // make a plan\n  bool success = makePlan(req.start, req.goal, resp.plan);\n\n  // set the success status and the plan length\n  resp.success = success;\n  resp.plan_length = resp.plan.poses.size();\n\n  // return true if a plan was found\n  return success;\n}", "CodeBleu_score": 63.33657882585402}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tros::NodeHandle private_nh(\"~/\" + name);\n    costmap_ros_ = cmap;\n    costmap_ = costmap_ros_->getCostmap();\n\n    // Set up the planner\n    setup();\n\n    // Set up the planner's ROS interaction\n    initROS(private_nh);\n}", "CodeBleu_score": 40.15177748912346}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tros::NodeHandle nh(\"~/\" + name);\n    costmap_ros_ = cmap;\n    costmap_ = costmap_ros_->getCostmap();\n    costmap_ros_->start();\n    costmap_ros_->setThreadSafe(true);\n    initializePubSub();\n}", "CodeBleu_score": 40.41344787358236}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tros::NodeHandle private_nh(\"~/\" + name);\n    costmap_ros_ = cmap;\n    costmap_ = costmap_ros_->getCostmap();\n    costmap_ros_->start();\n    initialize();\n}", "CodeBleu_score": 37.916247492750685}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t// Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n      wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    return false;\n  }\n  // Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n  return true;\n}", "CodeBleu_score": 42.920681205368595}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t// Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy < costmap_->getOriginY() || wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    ROS_DEBUG(\"GlobalPlanner::worldToMap: Coordinates (%.2f, %.2f) are outside of the costmap's bounds\", wx, wy);\n    return false;\n  }\n\n  // Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // Check if the map coordinates are within the costmap's size limits\n  if (mx < 0 || mx >= costmap_->getSizeInCellsX() || my < 0 || my >= costmap_->getSizeInCellsY()) {\n    ROS_DEBUG(\"GlobalPlanner::worldToMap: Coordinates (%.2f, %.2f) are outside of the costmap's bounds\", wx, wy);\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 43.71462140048899}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n      wx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    ROS_DEBUG(\n        \"The coordinates are outside the local costmap bounds. \"\n        \"Cannot convert from world to map\");\n    return false;\n  }\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n  return true;\n}", "CodeBleu_score": 42.78435030199693}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  //create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i=0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 89.13440179404702}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 90.1647751094476}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // Create a message for the path\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n\n  // Extract the poses from the path into gui_path\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  // Publish the path\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 90.1647751094476}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG(\"Got a goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 68.0525217664177}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG(\"In goal callback\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 69.15128641008138}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG(\"Got a new goal!\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 68.2890268591229}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif(getSqDistance() > sq_distance_limit_) {\n\n    ROS_INFO_STREAM(\"MoveSlowAndClear: Robot has moved far enough to clear the speed limit.\");\n\n    // Stop the distance check timer\n    distance_check_timer_.stop();\n\n    // Join and delete any existing remove limit thread\n    if(remove_limit_thread_.joinable()) {\n      remove_limit_thread_.join();\n    }\n\n    // Start a new thread to remove the speed limit\n    remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n  }\n\n}", "CodeBleu_score": 43.10959247793764}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tdouble sq_distance = getSqDistance();\n  if (sq_distance >= sq_limit_distance_) {\n    ROS_INFO_STREAM(\"Moved far enough, removing speed limit.\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 83.63042650530646}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO_STREAM(\"MoveSlowAndClear: Distance check passed. Robot has moved \" << sqrt(getSqDistance()) << \" meters.\");\n    if (remove_limit_thread_.joinable()) {\n      remove_limit_thread_.join();\n    }\n    remove_limit_thread_ = std::thread([&]() {\n      ROS_INFO_STREAM(\"MoveSlowAndClear: Removing speed limit.\");\n      std::lock_guard<std::mutex> lock(speed_limit_mutex_);\n      speed_limit_pose_.header.stamp = ros::Time::now();\n      speed_limit_pose_.pose.position.x = 0;\n      speed_limit_pose_.pose.position.y = 0;\n      speed_limit_pose_.pose.position.z = 0;\n      speed_limit_pose_.pose.orientation.x = 0;\n      speed_limit_pose_.pose.orientation.y = 0;\n      speed_limit_pose_.pose.orientation.z = 0;\n      speed_limit_pose_.pose.orientation.w = 0;\n      speed_limit_pub_.publish(speed_limit_pose_);\n      ROS_INFO_STREAM(\"MoveSlowAndClear: Speed limit removed.\");\n    });\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 43.68934366404651}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// Get the current global pose of the robot\n  tf::Stamped<tf::Pose> robot_pose;\n  if (!getRobotPose(robot_pose)) {\n    ROS_ERROR(\"Failed to get robot pose\");\n    return;\n  }\n\n  // Generate a plan to the goal pose\n  std::vector<geometry_msgs::PoseStamped> plan;\n  if (!makePlan(robot_pose, *goal, plan)) {\n    ROS_ERROR(\"Failed to generate a plan to the goal pose\");\n    return;\n  }\n\n  // Publish the plan\n  publishPlan(plan);\n}", "CodeBleu_score": 46.813687339606176}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t//Get the current global pose of the robot\n    rm::PoseStamped robotPose = getRobotPose();\n\n    //Generate a path from the current pose to the goal pose\n    std::vector<rm::PoseStamped> path;\n    bool success = makePlan(robotPose, *goal, path);\n\n    //If a path was found, publish it\n    if (success) {\n        path.insert(path.begin(), robotPose);\n        publishPlan(path);\n    }\n}", "CodeBleu_score": 50.34231820152336}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// Get the global pose of the robot\n    tf::Stamped<tf::Pose> robot_pose;\n    tf::Stamped<tf::Pose> goal_pose;\n\n    try {\n        listener_.waitForTransform(global_frame_, base_frame_,\n                                   ros::Time(0), ros::Duration(10.0));\n        listener_.lookupTransform(global_frame_, base_frame_,\n                                  ros::Time(0), robot_pose);\n        listener_.lookupTransform(global_frame_, goal->header.frame_id,\n                                  ros::Time(0), goal_pose);\n    }\n    catch (tf::TransformException ex) {\n        ROS_ERROR(\"Failed to look up transform between %s and %s: %s\",\n                  global_frame_.c_str(), base_frame_.c_str(), ex.what());\n        return;\n    }\n\n    // Convert the poses to the correct frame\n    tf::poseStampedMsgToTF(goal_pose, goal_pose);\n    tf::poseStampedMsgToTF(robot_pose, robot_pose);\n\n    // Generate a plan to the goal pose\n    std::vector<geometry_msgs::PoseStamped> path;\n    bool success = makePlan(robot_pose, goal_pose, path);\n\n    // Publish the plan\n    if (success) {\n        nav_msgs::Path plan;\n        plan.poses = path;\n        plan_pub_.publish(plan);\n    }\n}", "CodeBleu_score": 42.77807269154266}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create a service request\n  mavros_msgs::ParamSetRequest ps_req;\n\n  // Assign the parameter ID and value to the service request\n  ps_req.param_id = param_set.param_id;\n  ps_req.param_value = param_set.param_value;\n\n  // Call the param_set_client_ to send the request\n  param_set_client_.call(ps_req);\n\n  // If the service call fails, print out the error message\n  if (!param_set_client_.call(ps_req)) {\n    ROS_ERROR(\"Failed to call service param_set\");\n  }\n}", "CodeBleu_score": 49.282723781801714}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create a service request\n  std_srvs::SetBool srv;\n\n  // Assign the parameter ID and value to the service request\n  srv.request.data = true;\n  param_set_client_.call(srv);\n\n  // Check if the service request was successful\n  if (srv.response.success) {\n    ROS_INFO(\"Set gimbal parameter: %s\", param_set.param_id.c_str());\n  } else {\n    ROS_ERROR(\"Failed to set gimbal parameter: %s\", param_set.param_id.c_str());\n  }\n}", "CodeBleu_score": 49.334750413769285}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t// Create a service request\n  ros::ServiceClient param_set_client_ = nh_.serviceClient<mavros_msgs::ParamSet>(\"mavros/param/set\");\n  mavros_msgs::ParamSet srv;\n  // Assign the parameter ID and value to the service request\n  srv.request.param_id = param_set.param_id;\n  srv.request.param_value = param_set.param_value;\n  // Send the service request\n  if (param_set_client_.call(srv)) {\n    ROS_INFO(\"Set parameter: %s to %f\", srv.request.param_id.c_str(), srv.request.param_value);\n  }\n  else {\n    ROS_ERROR(\"Failed to call service mavros/param/set\");\n  }\n}", "CodeBleu_score": 52.292688057563296}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t// Create a TCP socket for the server.\n    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n\n    // Create a sockaddr_in struct to hold the address of the server.\n    struct sockaddr_in serverAddress;\n\n    // Set the address family, IP address, and port number.\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_addr.s_addr = INADDR_ANY;\n    serverAddress.sin_port = htons(serverPort);\n\n    // Bind the address to the socket.\n    bind(serverSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress));\n\n    // Listen for incoming connections.\n    listen(serverSocket, 1);\n\n    // Create a sockaddr_in struct to hold the address of the client.\n    struct sockaddr_in clientAddress;\n\n    // Create a variable to hold the size of the client address.\n    socklen_t clientAddressSize = sizeof(clientAddress);\n\n    // Accept an incoming connection.\n    int clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, &clientAddressSize);\n\n    // Create a variable to hold the length of the message.\n    int messageLength;\n\n    // Create a variable to hold the received message.\n    char message[MAX_MESSAGE_LENGTH];\n\n    // Create a variable to hold the decoded message.\n    char decodedMessage[MAX_MESSAGE_LENGTH];\n\n    // Create a variable to hold the number of bytes received.\n    int bytesReceived;\n\n    // Enter a loop to handle further connections.\n    while (1) {\n\n        // Receive the message length.\n        bytesReceived = recv(clientSocket, &messageLength, sizeof(messageLength), 0);\n\n        // If the message length is zero or less, log an error and close the socket.\n        if (messageLength <= 0) {\n            ROS_ERROR(\"Message length is zero or less\");\n            close(clientSocket);\n        }\n\n        // If the number of bytes received is less than the size of the message length, log an error and close the", "CodeBleu_score": 45.398521367028856}, {"code": "void CommunicationBridge::serverFun(){\n\t// Create a socket to listen for incoming connections\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n\n    // Create the socket.\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n\n    // Set socket options.\n    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    // Initialize address/port to bind to.\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(port);\n\n    // Bind to the specified port.\n    bind(server_fd, (struct sockaddr *)&address, sizeof(address));\n\n    // Start listening for connections.\n    listen(server_fd, 3);\n\n    // Loop to accept incoming connections.\n    while(1) {\n\n        // Wait for a connection.\n        new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);\n\n        // If connection is established, enter loop to receive data.\n        if (new_socket < 0) {\n            ROS_ERROR(\"[CommunicationBridge]: Failed to establish a connection with the ground station.\");\n        } else {\n\n            // Loop to receive data.\n            while(1) {\n\n                // Declare buffer to hold data.\n                char buffer[256];\n\n                // Receive data.\n                int bytes_received = recv(new_socket, buffer, 256, 0);\n\n                // If data is received, process it.\n                if (bytes_received > 0) {\n\n                    // If message length is zero or less, log error and close socket.\n                    if (bytes_received <= 0) {\n                        ROS_ERROR(\"[CommunicationBridge]: Message length is zero or less.\");\n                        close(new_socket);\n                        break;\n                    }", "CodeBleu_score": 49.32270844364}, {"code": "void CommunicationBridge::serverFun(){\n\t//Create a socket\n\tint serverSocket;\n\tserverSocket = socket(AF_INET, SOCK_STREAM, 0);\n\tif (serverSocket < 0) {\n\t\tROS_ERROR(\"Error opening socket\");\n\t}\n\n\t//Bind the socket to the specified port\n\tstruct sockaddr_in serverAddress;\n\tserverAddress.sin_family = AF_INET;\n\tserverAddress.sin_port = htons(serverPort);\n\tserverAddress.sin_addr.s_addr = INADDR_ANY;\n\tint bindRes = bind(serverSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress));\n\tif (bindRes < 0) {\n\t\tROS_ERROR(\"Error binding socket\");\n\t}\n\n\t//Listen for incoming connections\n\tint listenRes = listen(serverSocket, 1);\n\tif (listenRes < 0) {\n\t\tROS_ERROR(\"Error listening on socket\");\n\t}\n\n\t//Accept incoming connections\n\tstruct sockaddr_in clientAddress;\n\tsocklen_t clientAddressLength = sizeof(clientAddress);\n\tint clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, &clientAddressLength);\n\tif (clientSocket < 0) {\n\t\tROS_ERROR(\"Error accepting connection\");\n\t}\n\n\t//Receive data\n\tchar buffer[256];\n\tint bytesReceived = recv(clientSocket, buffer, 256, 0);\n\tif (bytesReceived <= 0) {\n\t\tROS_ERROR(\"Error receiving data\");\n\t}\n\n\t//Decode message\n\tstd_msgs::String message;\n\tmessage.data = buffer;\n\n\t//Publish message\n\tpub.publish(message);\n}", "CodeBleu_score": 40.81266286170268}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t// Publish the command to a single UAV\n  if (!simulation_mode_) {\n    uav_basic_.publish(uav_cmd);\n    return;\n  }\n\n  // Find the corresponding UAV by ID in the swarm_control_simulation_ and publish the command to the matching UAV\n  for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n    if (uav_cmd.uav_id == swarm_control_simulation_[i].id) {\n      swarm_control_simulation_[i].publish(uav_cmd);\n      return;\n    }\n  }\n}", "CodeBleu_score": 38.41269211140468}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t// If not in simulation mode, publish the command to a single UAV\n  if (simulation_mode_ == false) {\n    // Publish the command to the single UAV\n    uav_basic_.publish(uav_cmd);\n  }\n\n  // If in simulation mode, publish the command to the correct UAV\n  else {\n\n    // Find the UAV with the correct ID\n    for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\n      // If the UAV has the correct ID, publish the command to it\n      if (swarm_control_simulation_[i].getId() == uav_cmd.id) {\n        swarm_control_simulation_[i].publish(uav_cmd);\n      }\n    }\n  }\n}", "CodeBleu_score": 38.69267832925861}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (simulation_mode_ == true) {\n        for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n            if (swarm_control_simulation_[i].getID() == uav_cmd.id) {\n                swarm_control_simulation_[i].uav_basic_.publishCommand(uav_cmd.command);\n            }\n        }\n    } else {\n        uav_basic_.publishCommand(uav_cmd.command);\n    }\n}", "CodeBleu_score": 39.983669030576664}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == 1) {\n\t\tcreateMode(mode_selection.mode_name);\n\t}\n\telse if (mode_selection.use_mode == 0) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n\telse if (mode_selection.use_mode == 2) {\n\t\tif (mode_selection.mode_name == \"REBOOTNX\") {\n\t\t\tsystem(\"reboot\");\n\t\t}\n\t\telse if (mode_selection.mode_name == \"EXITNX\") {\n\t\t\tsystem(\"shutdown -h now\");\n\t\t}\n\t}\n}", "CodeBleu_score": 49.51829075475045}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == 0) {\n    // If the use_mode field is 0, then the mode is being deleted.\n    deleteMode(mode_selection.mode_name);\n  } else {\n    // If the use_mode field is 1, then the mode is being created.\n    createMode(mode_selection.mode_name);\n  }\n}", "CodeBleu_score": 21.112391131413414}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == 1) {\n\t\tcreateMode(mode_selection.mode_name, mode_selection.mode_path);\n\t} else {\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 24.593442104852613}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// Check if the heartbeat has been received\n    if (heartbeat_received) {\n        // Reset the heartbeat counter\n        heartbeat_count = 0;\n        // Set the heartbeat received flag to false\n        heartbeat_received = false;\n    }\n    else {\n        // Increment the heartbeat counter\n        heartbeat_count++;\n        // Check if the heartbeat count has exceeded the threshold\n        if (heartbeat_count > heartbeat_count_threshold) {\n            // Print an error message\n            ROS_ERROR(\"Heartbeat not received for %d consecutive heartbeat checks. Disconnecting.\", heartbeat_count_threshold);\n            // Set the disconnect flag\n            disconnect_flag = true;\n            // Trigger the appropriate action based on the type of vehicle\n            if (vehicle_type == \"swarm\") {\n                // If the vehicle is a swarm, trigger the swarm disconnect action\n                swarm_disconnect_action();\n            }\n            else if (vehicle_type == \"UAV\") {\n                // If the vehicle is a UAV, trigger the UAV disconnect action\n                uav_disconnect_action();\n            }\n            else if (vehicle_type == \"UGV\") {\n                // If the vehicle is a UGV, trigger the UGV disconnect action\n                ugv_disconnect_action();\n            }\n        }\n    }\n}", "CodeBleu_score": 36.79419625336804}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// Check if the heartbeat is received\n    if (heartbeat_received) {\n        // Reset the heartbeat counter\n        heartbeat_counter = 0;\n        // Reset the flag\n        heartbeat_received = false;\n    } else {\n        // Increment the heartbeat counter\n        heartbeat_counter++;\n        // Check if the heartbeat counter has reached the maximum number of attempts\n        if (heartbeat_counter >= max_heartbeat_attempts) {\n            // Print an error message\n            ROS_ERROR(\"[CommunicationBridge]: Heartbeat lost. Connectivity to the vehicle is lost.\");\n            // Trigger the appropriate action based on the type of vehicle\n            if (vehicle_type == \"swarm\") {\n                // Set the disconnect_flag to true\n                disconnect_flag = true;\n            } else if (vehicle_type == \"uav\") {\n                // Set the disconnect_flag to true\n                disconnect_flag = true;\n            } else if (vehicle_type == \"ugv\") {\n                // Set the disconnect_flag to true\n                disconnect_flag = true;\n            }\n        }\n    }\n\n}", "CodeBleu_score": 34.86831290692285}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// If the heartbeat counter is the same as the previous iteration, increment the missed heartbeat counter\n    if (heartbeat_counter == previous_heartbeat_counter) {\n        missed_heartbeat_counter++;\n    } else {\n        // If the heartbeat counter is different from the previous iteration, reset the missed heartbeat counter\n        missed_heartbeat_counter = 0;\n    }\n\n    // If the missed heartbeat counter reaches the specified number of attempts, print an error message and trigger appropriate actions\n    if (missed_heartbeat_counter >= heartbeat_attempts) {\n        ROS_ERROR(\"[CommunicationBridge]: Lost heartbeat connection with the vehicle. Please check the vehicle and try again.\");\n\n        // If the vehicle is a swarm, call the disconnectSwarm function\n        if (vehicle_type == \"swarm\") {\n            disconnectSwarm();\n        }\n\n        // If the vehicle is a UAV, call the disconnectUAV function\n        if (vehicle_type == \"uav\") {\n            disconnectUAV();\n        }\n\n        // If the vehicle is a UGV, call the disconnectUGV function\n        if (vehicle_type == \"ugv\") {\n            disconnectUGV();\n        }\n\n        // If the vehicle is a UGV, call the disconnectUGV function\n        if (vehicle_type == \"uuv\") {\n            disconnectUUV();\n        }\n\n        // Set the disconnect flag to true\n        disconnect_flag = true;\n    }\n\n    // Store the current heartbeat counter as the previous heartbeat counter for the next iteration\n    previous_heartbeat_counter = heartbeat_counter;\n}", "CodeBleu_score": 40.51185764925598}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// Declare variables\n    int drone_id;\n    int i, j;\n    int n_points;\n    int n_knots;\n    int n_segments;\n    int n_splines;\n    int n_points_per_segment;\n    int n_points_per_spline;\n    int n_points_per_knot;\n    int n_knots_per_spline;\n    int n_knots_per_segment;\n    int n_knots_per_drone;\n    int n_points_per_drone;\n    int n_segments_per_drone;\n    int n_splines_per_drone;\n    int n_points_per_drone_per_spline;\n    int n_points_per_drone_per_segment;\n    int n_points_per_drone_per_knot;\n    int n_knots_per_drone_per_spline;\n    int n_knots_per_drone_per_segment;\n    int n_knots_per_drone_per_knot;\n    int n_points_per_drone_per_knot;\n    int n_points_per_drone_per_knot_per_segment;\n    int n_points_per_drone_per_knot_per_spline;\n    int n_points_per_drone_per_knot_per_spline_per_segment;\n    int n_points_per_drone_per_knot_per_spline_per_spline;\n    int n_points_per_drone_per_knot_per_spline_per_spline_per_segment;\n    int n_points_per_drone_per_knot_per_spline_per_spline_per_spline;\n    int n_points_per_drone_per_knot_per_spline_per_spline_per_spline_per_segment;\n    int n_points_per_drone_per_knot_per_spline_per_spline_", "CodeBleu_score": 8.72693453932446}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// Create a new MultiBsplines message\n  prometheus_msgs::MultiBsplines multi_bsplines_msg;\n\n  // Set the message ID\n  multi_bsplines_msg.id = msg->id;\n\n  // Set the message type\n  multi_bsplines_msg.type = msg->type;\n\n  // Set the message time stamp\n  multi_bsplines_msg.time_stamp = msg->time_stamp;\n\n  // Set the message start time\n  multi_bsplines_msg.start_time = msg->start_time;\n\n  // Set the message duration\n  multi_bsplines_msg.duration = msg->duration;\n\n  // Set the message trajectory type\n  multi_bsplines_msg.trajectory_type = msg->trajectory_type;\n\n  // Set the message trajectory type\n  multi_bsplines_msg.planning_type = msg->planning_type;\n\n  // Set the message trajectory type\n  multi_bsplines_msg.num_of_segments = msg->num_of_segments;\n\n  // Set the message trajectory type\n  multi_bsplines_msg.num_of_points = msg->num_of_points;\n\n  // Set the message trajectory type\n  multi_bsplines_msg.dimension = msg->dimension;\n\n  // Set the message trajectory type\n  multi_bsplines_msg.n_knots = msg->n_knots;\n\n  // Set the message trajectory type\n  multi_bsplines_msg.n_control_points = msg->n_control_points;\n\n  // Set the message trajectory type\n  multi_bsplines_msg.n_polynomial_segments = msg->n_polynomial_segments;\n\n  // Set the message trajectory type\n  multi_bsplines_msg.n_polynomial_points = msg->n_polynomial_points;\n\n  // Set the message trajectory type\n  multi_bsplines_msg.n_polynomial_segments_per_control_segment = msg->n_polynomial_seg", "CodeBleu_score": 20.169080065074795}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// Check if the message is for this drone\n  if (msg->id == uav_id) {\n\n    // Initialize the MultiBspline message\n    prometheus_msgs::MultiBsplines multiBspline;\n    multiBspline.id = uav_id;\n    multiBspline.time_from_start = msg->time_from_start;\n    multiBspline.group_name = msg->group_name;\n    multiBspline.num_trajs = msg->num_trajs;\n\n    // Loop over the number of trajectories\n    for (int i = 0; i < msg->num_trajs; i++) {\n\n      // Initialize the Bspline message\n      prometheus_msgs::Bspline bspline;\n\n      // Set the Bspline attributes\n      bspline.id = uav_id;\n      bspline.group_name = msg->group_name;\n      bspline.traj_num = i;\n      bspline.time_from_start = msg->time_from_start;\n      bspline.duration = msg->duration;\n      bspline.start_time = msg->start_time;\n      bspline.start_state = msg->start_state;\n      bspline.end_state = msg->end_state;\n      bspline.start_state_type = msg->start_state_type;\n      bspline.end_state_type = msg->end_state_type;\n      bspline.is_init = msg->is_init;\n      bspline.is_valid = msg->is_valid;\n      bspline.is_safe = msg->is_safe;\n      bspline.is_feasible = msg->is_feasible;\n      bspline.is_done = msg->is_done;\n      bspline.is_replanned = msg->is_replanned;\n      bspline.is_replanning = msg->is_replanning;\n      bspline.is_debug = msg->is_debug;\n      bspline.is_failure = msg->is_", "CodeBleu_score": 37.00030336106849}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the input message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Create the octree\n  pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree (resolution_);\n\n  // Set the octree parameters\n  octree.setInputCloud(cloud);\n  octree.setMaxDepthAdjustment(10);\n  octree.addPointsFromInputCloud();\n\n  // Compress the octree\n  std::vector<int> key_indices;\n  octree.getVoxelCentroidKeyIndices(key_indices);\n\n  // Create a new PointCloud2 message\n  sensor_msgs::PointCloud2 compressed_msg;\n  compressed_msg.header = msg.header;\n  compressed_msg.height = 1;\n  compressed_msg.width = key_indices.size();\n  compressed_msg.fields = msg.fields;\n  compressed_msg.point_step = 12;\n  compressed_msg.row_step = compressed_msg.point_step * compressed_msg.width;\n  compressed_msg.is_bigendian = false;\n  compressed_msg.is_dense = true;\n  compressed_msg.data.resize(compressed_msg.row_step * compressed_msg.height);\n\n  // Copy the compressed data into the new message\n  memcpy(&compressed_msg.data[0], &key_indices[0], key_indices.size() * sizeof(int));\n\n  // Release dynamically allocated memory\n  cloud.reset();\n\n  // Return the compressed message\n  return compressed_msg;\n}", "CodeBleu_score": 42.24259585352508}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Create a new PointCloud2 message\n  sensor_msgs::PointCloud2 compressed_msg;\n\n  // Copy the header (stamp and frame_id) from the input message\n  compressed_msg.header = msg.header;\n\n  // Set the height and width of the compressed point cloud to 1\n  compressed_msg.height = 1;\n  compressed_msg.width = 1;\n\n  // Set the point step of the compressed point cloud to 1\n  compressed_msg.point_step = 1;\n\n  // Set the number of fields in the compressed point cloud to 1\n  compressed_msg.fields.resize(1);\n\n  // Set the name of the compressed point cloud to \"data\"\n  compressed_msg.fields[0].name = \"data\";\n\n  // Set the offset of the compressed point cloud to 0\n  compressed_msg.fields[0].offset = 0;\n\n  // Set the datatype of the compressed point cloud to 7 (uint8)\n  compressed_msg.fields[0].datatype = 7;\n\n  // Set the count of the compressed point cloud to 1\n  compressed_msg.fields[0].count = 1;\n\n  // Set the is_bigendian of the compressed point cloud to 0\n  compressed_msg.is_bigendian = 0;\n\n  // Set the is_dense of the compressed point cloud to 0\n  compressed_msg.is_dense = 0;\n\n  // Convert the input message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZRGB> cloud;\n  pcl::fromROSMsg(msg, cloud);\n\n  // Create a new pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZRGB> compressed_cloud;\n\n  // Create a new pcl::octree::OctreePointCloudSearch\n  pcl::octree::OctreePointCloudSearch<pcl::PointXYZRGB> octree(resolution_);\n\n  // Set the input point cloud to the octree\n  octree.setInput", "CodeBleu_score": 26.845199995689324}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the ROS PointCloud2 message to a pcl::PointCloud<pcl::PointXYZ> object\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Create an octree with the resolution specified by the user\n    pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree(resolution_);\n\n    // Add the point cloud data to the octree\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n\n    // Convert the octree to a PointCloud2 message\n    sensor_msgs::PointCloud2 compressed_cloud;\n    pcl::toROSMsg(octree.getOctreePointCloud(), compressed_cloud);\n\n    // Set the header of the output PointCloud2 message\n    compressed_cloud.header.frame_id = msg.header.frame_id;\n    compressed_cloud.header.stamp = msg.header.stamp;\n\n    // Release dynamically allocated memory\n    cloud.reset();\n\n    // Return the compressed point cloud\n    return compressed_cloud;\n}", "CodeBleu_score": 33.625978848030144}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < multi_uav_state_.uav_state_list_size(); i++) {\n\t\tif (multi_uav_state_.uav_state_list(i).uav_id() == uav_state.uav_id()) {\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->SwapElements(i, multi_uav_state_.uav_state_list_size() - 1);\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->RemoveLast();\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->SwapElements(i, multi_uav_state_.uav_state_list_size() - 1);\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->RemoveLast();\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->SwapElements(i, multi_uav_state_.uav_state_list_size() - 1);\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->RemoveLast();\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->SwapElements(i, multi_uav_state_.uav_state_list_size() - 1);\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->RemoveLast();\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->SwapElements(i, multi_uav_state_.uav_state_list_size() - 1);\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->RemoveLast();\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->SwapElements(i, multi_uav_state_.uav_state_list_size() - 1);\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->RemoveLast();\n\t\t\tmulti_uav_state_.mutable_uav_state_list()->SwapElements(i, multi_uav", "CodeBleu_score": 41.77647139332256}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t// Iterate through the list of UAV states\n\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\t// If the UAV ID matches the current UAV state, replace the UAV state with the new uav_state data\n\t\tif (multi_uav_state_[i].UAV_ID == uav_state.UAV_ID) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 52.305542264015536}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].id == uav_state.id) {\n            multi_uav_state_[i] = uav_state;\n        }\n    }\n}", "CodeBleu_score": 55.773279107313336}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize the MultiUGVState message\n    m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n    m_multi_ugv_state_msg.header.frame_id = \"map\";\n    m_multi_ugv_state_msg.UGV_count = 0;\n\n    // Iterate through each UGV in the MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.num_UGV; i++) {\n        // Initialize the UGVState message\n        m_ugv_state_msg.header.stamp = ros::Time::now();\n        m_ugv_state_msg.header.frame_id = \"map\";\n        m_ugv_state_msg.UGV_ID = m_multi_ugv_state.UGV_state[i].UGV_ID;\n        m_ugv_state_msg.battery = m_multi_ugv_state.UGV_state[i].battery;\n        m_ugv_state_msg.position.x = m_multi_ugv_state.UGV_state[i].position.x;\n        m_ugv_state_msg.position.y = m_multi_ugv_state.UGV_state[i].position.y;\n        m_ugv_state_msg.position.z = m_multi_ugv_state.UGV_state[i].position.z;\n        m_ugv_state_msg.velocity.x = m_multi_ugv_state.UGV_state[i].velocity.x;\n        m_ugv_state_msg.velocity.y = m_multi_ugv_state.UGV_state[i].velocity.y;\n        m_ugv_state_msg.velocity.z = m_multi_ugv_state.UGV_state[i].velocity.z;\n        m_ugv_state_msg.attitude.x = m_multi_ugv_state.UGV_state[i].attitude.x;\n        m_ugv_state_msg.attitude.", "CodeBleu_score": 43.0539385877495}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize MultiUGVState message\n  m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n  m_multi_ugv_state_msg.header.frame_id = \"map\";\n  m_multi_ugv_state_msg.num_of_ugv = 0;\n\n  // Iterate through each UGV in the MultiUGVState structure\n  for(int i = 0; i < MAX_NUM_UGV; i++) {\n\n    // If the UGV is in the MultiUGVState structure, add it to the MultiUGVState message\n    if(m_multi_ugv_state.ugv_state[i].id != -1) {\n\n      // Increment the UGV count\n      m_multi_ugv_state_msg.num_of_ugv++;\n\n      // Populate the UGVState message\n      m_multi_ugv_state_msg.ugv_state[i].id = m_multi_ugv_state.ugv_state[i].id;\n      m_multi_ugv_state_msg.ugv_state[i].battery = m_multi_ugv_state.ugv_state[i].battery;\n      m_multi_ugv_state_msg.ugv_state[i].position.x = m_multi_ugv_state.ugv_state[i].position.x;\n      m_multi_ugv_state_msg.ugv_state[i].position.y = m_multi_ugv_state.ugv_state[i].position.y;\n      m_multi_ugv_state_msg.ugv_state[i].position.z = m_multi_ugv_state.ugv_state[i].position.z;\n      m_multi_ugv_state_msg.ugv_state[i].velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n      m_multi_ugv_state_msg.ugv_state[i].velocity.y = m_multi_ugv_state.ugv_state[i", "CodeBleu_score": 36.69264027362986}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize a MultiUGVState message\n    m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n    m_multi_ugv_state_msg.header.frame_id = \"world\";\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.num_ugv; i++) {\n\n        // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n        m_ugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n        m_ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n        m_ugv_state_msg.pos.x = m_multi_ugv_state.ugv_state[i].pos[0];\n        m_ugv_state_msg.pos.y = m_multi_ugv_state.ugv_state[i].pos[1];\n        m_ugv_state_msg.pos.z = m_multi_ugv_state.ugv_state[i].pos[2];\n        m_ugv_state_msg.vel.x = m_multi_ugv_state.ugv_state[i].vel[0];\n        m_ugv_state_msg.vel.y = m_multi_ugv_state.ugv_state[i].vel[1];\n        m_ugv_state_msg.vel.z = m_multi_ugv_state.ugv_state[i].vel[2];\n        m_ugv_state_msg.att.x = m_multi_ugv_state.ugv_state[i].att[0];\n        m_ugv_state_msg.att.y = m_multi_ugv_state.ugv_state[i].att[1];\n        m_ugv_state_msg.att.z = m_multi_ugv_state.ugv_state[i].att[2];\n\n        //", "CodeBleu_score": 42.44444577868263}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0;\n    gradient.setZero();\n    for (int i = 0; i < num_moving_objects; i++) {\n        Eigen::Vector3d p_obj_pred = Eigen::Vector3d::Zero();\n        for (int j = 0; j < num_segments; j++) {\n            Eigen::Vector3d p_obj_pred_temp = Eigen::Vector3d::Zero();\n            for (int k = 0; k < 4; k++) {\n                p_obj_pred_temp += bspline_coeffs.block(j, 3 * k, 1, 3) * pow(q(j), k);\n            }\n            p_obj_pred += p_obj_pred_temp;\n        }\n        Eigen::Vector3d p_obj_pred_last = p_obj_pred;\n        for (int j = 0; j < num_segments; j++) {\n            Eigen::Vector3d p_obj_pred_temp = Eigen::Vector3d::Zero();\n            for (int k = 0; k < 4; k++) {\n                p_obj_pred_temp += bspline_coeffs.block(j, 3 * k, 1, 3) * pow(q(j), k);\n            }\n            p_obj_pred += p_obj_pred_temp;\n        }\n        Eigen::Vector3d p_obj_pred_last_last = p_obj_pred;\n        for (int j = 0; j < num_segments; j++) {\n            Eigen::Vector3d p_obj_pred_temp = Eigen::Vector3d::Zero();\n            for (int k = 0; k < 4; k++) {\n                p_obj_pred_temp += bspline_coeffs.block(j, 3 * k, 1, 3) * pow(q(j), k);\n            }\n            p_obj_pred += p_obj_pred_temp;\n        }\n        Eigen::Vector3d p_obj_pred_last_last_last = p_obj_pred;", "CodeBleu_score": 36.11715445743727}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tint n = q.cols();\n    int nc = num_control_points_;\n    int num_moving_objects = moving_objects_.size();\n    int num_points = num_moving_objects * nc;\n\n    Eigen::MatrixXd q_seg(3, n);\n    Eigen::VectorXd q_seg_t(n);\n    Eigen::VectorXd q_seg_x(n);\n    Eigen::VectorXd q_seg_y(n);\n    Eigen::VectorXd q_seg_z(n);\n\n    Eigen::VectorXd q_seg_t_pred(n);\n    Eigen::VectorXd q_seg_x_pred(n);\n    Eigen::VectorXd q_seg_y_pred(n);\n    Eigen::VectorXd q_seg_z_pred(n);\n\n    Eigen::VectorXd q_seg_t_diff(n);\n    Eigen::VectorXd q_seg_x_diff(n);\n    Eigen::VectorXd q_seg_y_diff(n);\n    Eigen::VectorXd q_seg_z_diff(n);\n\n    Eigen::VectorXd q_seg_t_diff_norm(n);\n    Eigen::VectorXd q_seg_x_diff_norm(n);\n    Eigen::VectorXd q_seg_y_diff_norm(n);\n    Eigen::VectorXd q_seg_z_diff_norm(n);\n\n    Eigen::VectorXd q_seg_t_diff_norm_sq(n);\n    Eigen::VectorXd q_seg_x_diff_norm_sq(n);\n    Eigen::VectorXd q_seg_y_diff_norm_sq(n);\n    Eigen::VectorXd q_seg_z_diff_norm_sq(n);\n\n    Eigen::VectorXd q_seg_t_diff_norm_cub(n);\n    Eigen::VectorXd q_seg_x_diff_norm_cub(n);\n    Eigen::VectorXd q_seg_y_", "CodeBleu_score": 18.807452544824827}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0;\n  gradient.setZero();\n\n  for (int i = 0; i < moving_objects.size(); i++) {\n    // for each moving object\n    Eigen::MatrixXd predicted_positions(moving_objects[i].size(), 3);\n    Eigen::MatrixXd predicted_velocities(moving_objects[i].size(), 3);\n    Eigen::MatrixXd predicted_accelerations(moving_objects[i].size(), 3);\n\n    // calculate predicted positions, velocities, and accelerations\n    moving_objects[i].predictPositions(q, predicted_positions, predicted_velocities, predicted_accelerations);\n\n    // calculate the distance between control points and predicted positions of moving objects\n    Eigen::MatrixXd dist(control_points.size(), predicted_positions.rows());\n    dist.setZero();\n\n    for (int j = 0; j < control_points.size(); j++) {\n      for (int k = 0; k < predicted_positions.rows(); k++) {\n        dist(j, k) = (control_points[j] - predicted_positions.row(k)).norm();\n      }\n    }\n\n    // update cost and gradient\n    for (int j = 0; j < control_points.size(); j++) {\n      for (int k = 0; k < predicted_positions.rows(); k++) {\n        if (dist(j, k) < clearance) {\n          cost += dist(j, k) - clearance;\n\n          // gradient of cost w.r.t. control points\n          gradient.row(j) += (predicted_positions.row(k) - control_points[j]) / dist(j, k);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 38.460711623409814}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0;\n  gradient.setZero();\n\n  // Initialize the cost and gradient to zero\n  //  cost = 0;\n  //  gradient.setZero();\n\n  // Iterate through the control points of the trajectory\n  for (int i = 0; i < q.rows(); i++) {\n    // Compute the positional error relative to reference points\n    Eigen::Vector3d q_i = q.block<3, 1>(0, i);\n    Eigen::Vector3d q_i_ref = q_ref_.block<3, 1>(0, i);\n    Eigen::Vector3d q_i_err = q_i - q_i_ref;\n\n    // Compute the velocity vector\n    Eigen::Vector3d q_i_vel = q.block<3, 1>(0, i + 1) - q.block<3, 1>(0, i);\n\n    // Compute the cost and gradient\n    double cost_i = a2_ * q_i_err.dot(q_i_err) + b2_ * q_i_vel.dot(q_i_err);\n    cost += cost_i;\n    gradient.block<3, 1>(0, i) = 2 * a2_ * q_i_err;\n    gradient.block<3, 1>(0, i + 1) = 2 * b2_ * q_i_err;\n  }\n}", "CodeBleu_score": 29.96557329667674}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0;\n    gradient.setZero();\n\n    double a2 = 1.0;\n    double b2 = 1.0;\n\n    // Iterate through the control points of the trajectory\n    for (int i = 0; i < q.rows(); i++) {\n        // Get the positional error between the reference point and the control point\n        Eigen::Vector3d e = q.row(i) - ref_points_[i];\n        // Get the velocity vector between the reference point and the control point\n        Eigen::Vector3d v = ref_points_[i + 1] - ref_points_[i];\n        // Compute the squared dot product of the positional error and the velocity vector\n        double e_dot_v = e.dot(v);\n        // Compute the squared cross product of the positional error and the velocity vector\n        double e_cross_v = e.cross(v).squaredNorm();\n        // Compute the cost for the control point\n        double cost_i = a2 * e_dot_v * e_dot_v + b2 * e_cross_v;\n        // Add the cost for the control point to the total cost\n        cost += cost_i;\n        // Compute the derivative of the cost for the control point with respect to the control point\n        Eigen::Vector3d grad_i = 2.0 * a2 * e_dot_v * v + 2.0 * b2 * e_cross_v * e.cross(v);\n        // Add the derivative of the cost for the control point to the total gradient\n        gradient.row(i) += grad_i;\n    }\n}", "CodeBleu_score": 37.61270994956929}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// Initialize the cost to zero and the gradient to zero.\n    cost = 0;\n    gradient.setZero(q.rows(), q.cols());\n\n    // Iterate through the control points of the trajectory.\n    for (int i = 0; i < q.rows(); i++) {\n\n        // Compute the positional error relative to reference points.\n        Eigen::Vector3d pos_error = q.row(i) - q_ref_.row(i);\n\n        // Compute the velocity vector.\n        Eigen::Vector3d vel_vec = (q.row(i + 1) - q.row(i)) / dt_;\n\n        // Compute the cost function and its gradient.\n        double pos_cost = pos_error.dot(pos_error) / a2_;\n        double vel_cost = pos_error.dot(vel_vec) / b2_;\n\n        // Update the cost and gradient.\n        cost += pos_cost + vel_cost;\n        gradient.row(i) = 2 * a2_ * pos_error.transpose() + 2 * b2_ * vel_vec.transpose();\n    }\n}", "CodeBleu_score": 29.424357587586965}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tEigen::MatrixXd ctp = getThirdDerivativeControlPoints();\n  double jerk = 0;\n\n  for (int i = 0; i < ctp.rows(); i++) {\n    for (int j = 0; j < ctp.cols(); j++) {\n      jerk += (ctp(i, j) * ctp(i, j)) * (u_(i + 1) - u_(i));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 46.95847865074524}, {"code": "double UniformBspline::getJerk(){\n\t/* compute the third derivative */\n  UniformBspline jerk = getDerivative().getDerivative();\n\n  /* retrieve the knot times and control points of the jerk trajectory */\n  Eigen::VectorXd jerk_u = jerk.getKnot();\n  Eigen::MatrixXd jerk_cp = jerk.getControlPoints();\n\n  /* iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times */\n  double jerk_sum = 0;\n  for (int i = 0; i < jerk_cp.rows(); i++) {\n    for (int j = 0; j < jerk_cp.cols(); j++) {\n      jerk_sum += jerk_cp(i, j) * jerk_cp(i, j) * (jerk_u(i + 1) - jerk_u(i));\n    }\n  }\n\n  return jerk_sum;\n}", "CodeBleu_score": 60.72036964678345}, {"code": "double UniformBspline::getJerk(){\n\tEigen::MatrixXd ctp = getJerkControlPoints();\n  Eigen::VectorXd knot(u_.rows() - 2);\n  knot = u_.segment(1, u_.rows() - 2);\n\n  double jerk = 0;\n  for (int i = 0; i < ctp.rows(); i++) {\n    for (int j = 0; j < ctp.cols(); j++) {\n      jerk += (ctp(i, j) * (knot(i + 1) - knot(i)));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 50.239313126114396}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1;\n\n\treturn pos;\n\n}", "CodeBleu_score": 60.75738753577817}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1;\n\n    return pos;\n}", "CodeBleu_score": 63.078628641293434}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1.0;\n\n    return pos;\n}", "CodeBleu_score": 64.32370769035728}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n        // Extract the drone ID from the child_frame_id field of the odometry message\n        int droneId = extractDroneIdFromOdom(odom);\n        // Call rcvDroneOdomCallbackBase with the odometry data and drone ID\n        rcvDroneOdomCallbackBase(odom, droneId);\n    } catch (const std::exception& e) {\n        // If extracting the drone ID fails, catch and print the exception\n        ROS_ERROR_STREAM(\"Exception: \" << e.what());\n    }\n}", "CodeBleu_score": 48.97351727452205}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n    rcvDroneOdomCallbackBase(odom);\n  }\n  catch (const std::exception& e) {\n    ROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback: Failed to extract drone ID from odometry message: \" << e.what());\n  }\n}", "CodeBleu_score": 37.23096744213624}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\tint drone_id = -1;\n    try {\n        drone_id = extractDroneID(odom.child_frame_id);\n    }\n    catch (const std::exception& e) {\n        ROS_ERROR_STREAM(e.what());\n        return;\n    }\n    rcvDroneOdomCallbackBase(odom, drone_id);\n}", "CodeBleu_score": 53.66822285434226}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Check if drone is in the detection range\n  if (drone_id < 0 || drone_id >= num_drones_) {\n    ROS_ERROR(\"[DroneDetector::detect] Invalid drone id %d\", drone_id);\n    return;\n  }\n\n  // Check if drone is in the detection range\n  if (true_pixel[0] < 0 || true_pixel[0] >= image_width_ || true_pixel[1] < 0 || true_pixel[1] >= image_height_) {\n    ROS_ERROR(\"[DroneDetector::detect] Invalid true pixel position %d %d\", true_pixel[0], true_pixel[1]);\n    return;\n  }\n\n  // Get the drone object\n  Drone *drone = drones_[drone_id];\n\n  // Check if drone is in the detection range\n  if (!drone->in_detection_range_) {\n    ROS_ERROR(\"[DroneDetector::detect] Drone %d is not in detection range\", drone_id);\n    return;\n  }\n\n  // Check if drone is in the detection range\n  if (!drone->is_detected_) {\n    ROS_ERROR(\"[DroneDetector::detect] Drone %d is not detected\", drone_id);\n    return;\n  }\n\n  // Check if drone is in the detection range\n  if (drone->is_tracked_) {\n    ROS_ERROR(\"[DroneDetector::detect] Drone %d is already tracked\", drone_id);\n    return;\n  }\n\n  // Get the drone's true position in the camera frame\n  Eigen::Vector3d true_position = drone->get_true_position();\n\n  // Get the drone's true orientation in the camera frame\n  Eigen::Vector3d true_orientation = drone->get_true_orientation();\n\n  // Get the drone's true position in the camera frame\n  Eigen::Vector3d true_position_in_camera_frame = camera_frame", "CodeBleu_score": 30.349309057402646}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Get the true pose of the drone in the camera frame\n  Eigen::Vector3f true_pose;\n  if (!getTruePose(drone_id, true_pose)) {\n    ROS_INFO(\"Could not get true pose of drone %d\", drone_id);\n    return;\n  }\n\n  // Get the true pose of the drone in the world frame\n  Eigen::Vector3f true_pose_world;\n  if (!getTruePoseWorld(drone_id, true_pose_world)) {\n    ROS_INFO(\"Could not get true pose of drone %d in world frame\", drone_id);\n    return;\n  }\n\n  // Check if the drone is present in the camera frame\n  bool found = false;\n  Eigen::Vector2f camera_pose;\n  if (!getCameraPose(drone_id, camera_pose)) {\n    ROS_INFO(\"Could not get camera pose of drone %d\", drone_id);\n    return;\n  }\n\n  // If found, compute the pose error\n  if (found) {\n    Eigen::Vector3f pose_error = true_pose_world - camera_pose;\n    float error = pose_error.norm();\n    ROS_INFO(\"Pose error: %f\", error);\n\n    // Update the debug result\n    debug_result.found = true;\n    debug_result.pose_error = error;\n    debug_result.pose_error_x = pose_error(0);\n    debug_result.pose_error_y = pose_error(1);\n    debug_result.pose_error_z = pose_error(2);\n    debug_result.true_pose_x = true_pose_world(0);\n    debug_result.true_pose_y = true_pose_world(1);\n    debug_result.true_pose_z = true_pose_world(2);\n    debug_result.camera_pose_x = camera_pose(0);\n    debug_result.camera_pose_y = camera_pose(1);\n    debug_result.camera_pose_z = camera_pose(2);", "CodeBleu_score": 42.01016233435758}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Get the drone's pose in the camera frame\n    Eigen::Vector3d true_pose_camera;\n    get_true_pose_camera(drone_id, true_pose_camera);\n\n    // Check if the drone is present in the camera frame\n    bool drone_found = check_drone_presence(drone_id, true_pose_camera);\n\n    // If the drone is present, compute the pose error\n    if (drone_found) {\n\n        // Get the drone's pose in the world frame\n        Eigen::Vector3d true_pose_world;\n        get_true_pose_world(drone_id, true_pose_world);\n\n        // Compute the pose error\n        Eigen::Vector3d pose_error = true_pose_world - true_pose_camera;\n\n        // Update the debug result\n        debug_result.detection_success = true;\n        debug_result.pose_error = pose_error;\n\n        // Publish the pose error\n        geometry_msgs::Vector3 pose_error_msg;\n        pose_error_msg.x = pose_error(0);\n        pose_error_msg.y = pose_error(1);\n        pose_error_msg.z = pose_error(2);\n        pose_error_pub.publish(pose_error_msg);\n\n    }\n\n    // If the drone is not present, update the debug result\n    else {\n\n        // Update the debug result\n        debug_result.detection_success = false;\n        debug_result.pose_error = Eigen::Vector3d::Zero();\n\n    }\n\n}", "CodeBleu_score": 40.93718097531808}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->getParent() != nullptr) {\n\t\tcurrent = current->getParent();\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.22222056290752}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n\n    while (current->getCameFrom() != nullptr) {\n        current = current->getCameFrom();\n        path.push_back(current);\n    }\n\n    return path;\n}", "CodeBleu_score": 77.3329999488077}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->getParent() != nullptr) {\n\t\tcurrent = current->getParent();\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.22222056290752}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert start and end points to grid indices.\n    start_idx = ConvertToIndex(start_pt);\n    end_idx = ConvertToIndex(end_pt);\n\n    // If the start or end point is inside an obstacle, adjust it.\n    if (IsObstacle(start_idx)) {\n        if (!AdjustPoint(start_pt, end_pt, start_idx)) {\n            return false;\n        }\n    }\n    if (IsObstacle(end_idx)) {\n        if (!AdjustPoint(end_pt, start_pt, end_idx)) {\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 31.055977923296513}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// convert the start and end points to grid indices\n\tstart_idx = ConvertToIndex(start_pt);\n\tend_idx = ConvertToIndex(end_pt);\n\n\t// if the start or end point is inside an obstacle, adjust the point\n\tif (IsInObstacle(start_pt)) {\n\t\tif (!AdjustStartEndPoint(start_pt, end_pt, start_idx, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (IsInObstacle(end_pt)) {\n\t\tif (!AdjustStartEndPoint(end_pt, start_pt, end_idx, start_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 29.708132789924335}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Check if start point is inside an obstacle\n\tif (grid_map->IsInsideObstacle(start_pt)) {\n\t\t// Try to adjust the start point by moving it away from the end point\n\t\tbool success = AdjustStartEndPoints(start_pt, end_pt, start_idx, end_idx, true);\n\t\tif (!success) {\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\t// Convert start point to grid indices\n\t\tstart_idx = grid_map->ConvertToGridIndex(start_pt);\n\t}\n\n\t// Check if end point is inside an obstacle\n\tif (grid_map->IsInsideObstacle(end_pt)) {\n\t\t// Try to adjust the end point by moving it away from the start point\n\t\tbool success = AdjustStartEndPoints(start_pt, end_pt, start_idx, end_idx, false);\n\t\tif (!success) {\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\t// Convert end point to grid indices\n\t\tend_idx = grid_map->ConvertToGridIndex(end_pt);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 33.31193027204955}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tEigen::Vector3i min_id, max_id;\n  getGridIndex(min_pos, min_id);\n  getGridIndex(max_pos, max_id);\n  resetBuffer(min_id, max_id);\n}", "CodeBleu_score": 26.48792133703192}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tint min_id[3];\n    int max_id[3];\n    gridToIndex(min_pos, min_id);\n    gridToIndex(max_pos, max_id);\n\n    for (int x = min_id[0]; x <= max_id[0]; x++) {\n        for (int y = min_id[1]; y <= max_id[1]; y++) {\n            for (int z = min_id[2]; z <= max_id[2]; z++) {\n                int idx = index(x, y, z);\n                occupancy_buffer_inflate_[idx] = 0;\n                distance_buffer_inflate_[idx] = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 42.39896881225004}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t// TODO: implement\n  Eigen::Vector3i min_id, max_id;\n  getGridCoordinates(min_pos, min_id);\n  getGridCoordinates(max_pos, max_id);\n  for (int x = min_id(0); x <= max_id(0); x++) {\n    for (int y = min_id(1); y <= max_id(1); y++) {\n      for (int z = min_id(2); z <= max_id(2); z++) {\n        occupancy_buffer_inflate_(x, y, z) = 0;\n        distance_buffer_inflate_(x, y, z) = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 66.65585370888026}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d min_max_trans(0, 0, 0);\n    for (int i = 0; i < 3; i++) {\n        min_max_trans(i) = std::max(std::min(diff(i), map_max_[i] - pt(i)), map_min_[i] - pt(i));\n    }\n    Eigen::Vector3d trans = min_max_trans.array().abs().min(Eigen::Array3d::Ones()).matrix();\n    return pt + trans;\n}", "CodeBleu_score": 35.74016076923121}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t// Calculate the difference vector between the point and the camera position\n    Eigen::Vector3d diff = pt - camera_pt;\n\n    // Determine the maximum and minimum translation coefficients along each axis\n    double max_x = diff.x() > 0 ? diff.x() : -diff.x();\n    double max_y = diff.y() > 0 ? diff.y() : -diff.y();\n    double max_z = diff.z() > 0 ? diff.z() : -diff.z();\n\n    // Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n    double scale_x = 1.0;\n    double scale_y = 1.0;\n    double scale_z = 1.0;\n\n    if (max_x > map_size_x_) {\n        scale_x = map_size_x_ / max_x;\n    }\n    if (max_y > map_size_y_) {\n        scale_y = map_size_y_ / max_y;\n    }\n    if (max_z > map_size_z_) {\n        scale_z = map_size_z_ / max_z;\n    }\n\n    // Return the adjusted point near the boundary\n    return Eigen::Vector3d(pt.x() - (scale_x * diff.x()),\n                           pt.y() - (scale_y * diff.y()),\n                           pt.z() - (scale_z * diff.z()));\n}", "CodeBleu_score": 37.25927335264966}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d max_trans, min_trans;\n    max_trans << map_size_x, map_size_y, map_size_z;\n    min_trans << -map_size_x, -map_size_y, -map_size_z;\n    Eigen::Vector3d trans;\n    for (int i = 0; i < 3; i++) {\n        if (diff(i) > 0) {\n            trans(i) = std::min(diff(i), max_trans(i));\n        } else {\n            trans(i) = std::max(diff(i), min_trans(i));\n        }\n    }\n    return camera_pt + trans;\n}", "CodeBleu_score": 45.08415887154239}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update last occupancy update time\n\tlast_occupancy_update_ = ros::Time::now();\n\n\t// If an update is needed, project depth image into points and process them with raycasting\n\tif (update_needed_) {\n\n\t\t// Update the local map if needed\n\t\tif (update_local_map_) {\n\n\t\t\t// Clear the local map\n\t\t\tclearLocalMap();\n\n\t\t\t// Inflate the local map\n\t\t\tinflateLocalMap();\n\n\t\t\t// Set the update local map flag to false\n\t\t\tupdate_local_map_ = false;\n\t\t}\n\n\t\t// Get the depth image\n\t\tconst sensor_msgs::ImageConstPtr &depth_image = getDepthImage();\n\n\t\t// Get the depth image header\n\t\tconst std_msgs::Header &depth_image_header = depth_image->header;\n\n\t\t// Get the depth image time stamp\n\t\tconst ros::Time depth_image_time = depth_image_header.stamp;\n\n\t\t// Get the depth image frame id\n\t\tconst std::string &depth_image_frame_id = depth_image_header.frame_id;\n\n\t\t// Get the depth image width\n\t\tconst int depth_image_width = depth_image->width;\n\n\t\t// Get the depth image height\n\t\tconst int depth_image_height = depth_image->height;\n\n\t\t// Get the depth image step size\n\t\tconst int depth_image_step = depth_image->step;\n\n\t\t// Get the depth image data size\n\t\tconst int depth_image_data_size = depth_image->data.size();\n\n\t\t// Get the depth image data pointer\n\t\tconst uint16_t *depth_image_data = reinterpret_cast<const uint16_t *>(&depth_image->data[0]);\n\n\t\t// Get the depth image data pointer\n\t\tconst uint8_t *depth_image_data_byte = reinterpret_cast<const uint8_t *>(&depth_image->data[0]);\n\n\t\t// Get the depth image data pointer\n\t\tconst", "CodeBleu_score": 35.00846754842713}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update last occupancy update time\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // Check if an update is needed\n  if (!needUpdate()) {\n    return;\n  }\n\n  // Get the latest sensor data\n  ros::Time current_time = ros::Time::now();\n  bool odom_updated = false;\n  bool depth_updated = false;\n  bool depth_image_updated = false;\n  bool depth_cloud_updated = false;\n  bool depth_fused_updated = false;\n  bool depth_fused_image_updated = false;\n  bool depth_fused_cloud_updated = false;\n  bool depth_fused_fused_updated = false;\n  bool depth_fused_fused_image_updated = false;\n  bool depth_fused_fused_cloud_updated = false;\n  bool depth_fused_fused_fused_updated = false;\n  bool depth_fused_fused_fused_image_updated = false;\n  bool depth_fused_fused_fused_cloud_updated = false;\n  bool depth_fused_fused_fused_fused_updated = false;\n  bool depth_fused_fused_fused_fused_image_updated = false;\n  bool depth_fused_fused_fused_fused_cloud_updated = false;\n  bool depth_fused_fused_fused_fused_fused_updated = false;\n  bool depth_fused_fused_fused_fused_fused_image_updated = false;\n  bool depth_fused_fused_fused_fused_fused_cloud_updated = false;\n  bool depth_fused_fused_fused_fused_fused_fused_updated = false;\n  bool depth_fused_fused_fused_fused_fused_fused_image_updated = false;\n  bool depth_fused_fused_fused_fused_fused_fused_cloud_updated = false;\n  bool depth_fused_fused_fused_fused_fused_f", "CodeBleu_score": 19.48389347513266}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\tif (!odometryReceived || !depthReceived) {\n    ROS_WARN_STREAM(\"GridMap: No odometry or depth data received yet, skipping occupancy update\");\n    return;\n  }\n\n  // Update last occupancy update time\n  lastOccupancyUpdate = ros::Time::now();\n\n  // Check if an update is needed\n  if (lastOccupancyUpdate - lastOccupancyUpdateTime < updateFrequency) {\n    ROS_DEBUG_STREAM(\"GridMap: Occupancy update skipped, last update was \" << lastOccupancyUpdate - lastOccupancyUpdateTime << \" seconds ago\");\n    return;\n  }\n\n  // Project depth image into points\n  ROS_DEBUG_STREAM(\"GridMap: Projecting depth image into points\");\n  std::vector<Point> points;\n  depthImageToPoints(points);\n\n  // Process points with raycasting\n  ROS_DEBUG_STREAM(\"GridMap: Processing points with raycasting\");\n  processPoints(points);\n\n  // Clear and inflate local map\n  ROS_DEBUG_STREAM(\"GridMap: Clearing and inflating local map\");\n  clearAndInflateLocalMap();\n\n  // Handle timeout errors\n  if (lastOccupancyUpdate - lastOdometryUpdate > timeoutOdometry) {\n    ROS_ERROR_STREAM(\"GridMap: Odometry timeout error, last odometry update was \" << lastOccupancyUpdate - lastOdometryUpdate << \" seconds ago\");\n    odometryReceived = false;\n    return;\n  }\n  if (lastOccupancyUpdate - lastDepthUpdate > timeoutDepth) {\n    ROS_ERROR_STREAM(\"GridMap: Depth timeout error, last depth update was \" << lastOccupancyUpdate - lastDepthUpdate << \" seconds ago\");\n    depthReceived = false;\n    return;\n  }\n}", "CodeBleu_score": 28.7305132884289}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tvector<Ellipse> gt_ellipses;\n    vector<Ellipse> dt_ellipses;\n    Mat3b img;\n\n    float fmeasure_sum = 0.f;\n    float fmeasure_count = 0.f;\n\n    for (unsigned i = 0; i < image_fns.size(); ++i)\n    {\n        cout << \"Evaluating image \" << i + 1 << \" of \" << image_fns.size() << endl;\n\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        img = imread(image_fns[i]);\n        if (img.empty())\n        {\n            cout << \"Error loading: \" << image_fns[i] << endl;\n            return 0.f;\n        }\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        fmeasure_sum += fmeasure;\n        fmeasure_count += 1.f;\n\n        gt_ellipses.clear();\n        dt_ellipses.clear();\n    }\n\n    return fmeasure_sum / fmeasure_count;\n}", "CodeBleu_score": 55.646489777718486}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tfloat fmeasure_total = 0.f;\n    float fmeasure_count = 0.f;\n\n    for (unsigned i = 0; i < image_fns.size(); ++i)\n    {\n        Mat3b img = imread(image_fns[i]);\n        if (img.empty())\n        {\n            cout << \"Error loading: \" << image_fns[i] << endl;\n            return -1.f;\n        }\n\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        fmeasure_total += fmeasure;\n        fmeasure_count++;\n    }\n\n    return fmeasure_total / fmeasure_count;\n}", "CodeBleu_score": 56.44902233077023}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tfloat fmeasure_sum = 0.f;\n\n    unsigned sz_img = image_fns.size();\n\n    for (unsigned i = 0; i < sz_img; ++i)\n    {\n        Mat3b img = imread(image_fns[i]);\n\n        vector<Ellipse> gt_ellipses;\n        vector<Ellipse> dt_ellipses;\n\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        fmeasure_sum += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n    }\n\n    return fmeasure_sum / float(sz_img);\n}", "CodeBleu_score": 58.64855026533425}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat angle = 0.0f;\n    if (foci != NULL) {\n        float angle_to_focus_1 = atan2f(y - foci[0].y, x - foci[0].x);\n        float angle_to_focus_2 = atan2f(y - foci[1].y, x - foci[1].x);\n        angle = angle_diff_signed(angle_to_focus_1, angle_to_focus_2);\n    }\n    while (angle < -M_PI) angle += M_2__PI;\n    while (angle >   M_PI) angle -= M_2__PI;\n    return angle;\n}", "CodeBleu_score": 47.826530650910094}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a1, a2, a3;\n    if (foci) {\n        a1 = atan2(y - foci[1], x - foci[0]);\n        a2 = atan2(y - foci[1], -x + foci[0]);\n        a3 = atan2(-y + foci[1], x - foci[0]);\n        a1 = angle_diff_signed(a1, a2);\n        a2 = angle_diff_signed(a3, a2);\n        return angle_diff_signed(a1, a2);\n    }\n    return atan2(y, x);\n}", "CodeBleu_score": 48.297861680047774}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat angle1 = atan2(y, x);\n    if (foci) {\n        float angle2 = atan2(y - foci[1], x - foci[0]);\n        float angle3 = atan2(y - foci[0], x - foci[1]);\n        angle1 = angle_diff_signed(angle1, angle2);\n        angle1 = angle_diff_signed(angle1, angle3);\n    }\n    while (angle1 < 0) angle1 += M_2__PI;\n    while (angle1 > M_2__PI) angle1 -= M_2__PI;\n    return angle1;\n}", "CodeBleu_score": 52.916736844062704}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint i;\n\tfloat min_x, max_x, min_y, max_y, sum_above, sum_below;\n\tmin_x = vp1[start].x;\n\tmax_x = vp1[start].x;\n\tmin_y = vp1[start].y;\n\tmax_y = vp1[start].y;\n\tfor (i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\tsum_above = 0.0;\n\tsum_below = 0.0;\n\tfor (i = start; i <= end; i++) {\n\t\tsum_above += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n\t\tsum_below += (vp1[i].x - min_x) * (max_y - vp1[i].y);\n\t}\n\tif (sum_above < sum_below)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 37.10738304464524}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint i;\n\tfloat xmin, xmax, ymin, ymax;\n\tfloat x1, y1, x2, y2;\n\tfloat x1_min, x1_max, y1_min, y1_max;\n\tfloat x2_min, x2_max, y2_min, y2_max;\n\tfloat integral_above, integral_below;\n\tfloat x1_min_below, x1_max_below, y1_min_below, y1_max_below;\n\tfloat x2_min_below, x2_max_below, y2_min_below, y2_max_below;\n\tfloat x1_min_above, x1_max_above, y1_min_above, y1_max_above;\n\tfloat x2_min_above, x2_max_above, y2_min_above, y2_max_above;\n\tfloat x1_min_below_below, x1_max_below_below, y1_min_below_below, y1_max_below_below;\n\tfloat x2_min_below_below, x2_max_below_below, y2_min_below_below, y2_max_below_below;\n\tfloat x1_min_above_above, x1_max_above_above, y1_min_above_above, y1_max_above_above;\n\tfloat x2_min_above_above, x2_max_above_above, y2_min_above_above, y2_max_above_above;\n\tfloat x1_min_below_above, x1_max_below_above, y1_min_below_above, y1_max_below_above;\n\tfloat x2_min_below_above, x2_max_below_above, y2_min_below_above, y2_max_below_above;\n\n\txmin = vp1[start].x;\n\txmax = vp1[start].x;\n\tymin = vp1[start].y;\n\tymax = vp1[start].y;\n\n\tfor (i = start +", "CodeBleu_score": 15.655863627032574}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tdouble min_x = vp1[start].x;\n  double max_x = vp1[start].x;\n  double min_y = vp1[start].y;\n  double max_y = vp1[start].y;\n\n  for (int i = start + 1; i <= end; i++) {\n    if (vp1[i].x < min_x) {\n      min_x = vp1[i].x;\n    }\n    if (vp1[i].x > max_x) {\n      max_x = vp1[i].x;\n    }\n    if (vp1[i].y < min_y) {\n      min_y = vp1[i].y;\n    }\n    if (vp1[i].y > max_y) {\n      max_y = vp1[i].y;\n    }\n  }\n\n  double area_above = 0;\n  double area_below = 0;\n\n  for (int i = start + 1; i <= end; i++) {\n    area_above += (vp1[i].x - vp1[start].x) * (vp1[i].y + vp1[start].y);\n    area_below += (vp1[i].x - vp1[start].x) * (vp1[i].y - vp1[start].y);\n  }\n\n  if (area_above < area_below) {\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 36.63605587832442}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tif (msg->detected_objects.size() == 0) {\n    return;\n  }\n\n  for (int i = 0; i < msg->detected_objects.size(); i++) {\n    if (msg->detected_objects[i].object_name == \"T\") {\n      ellipse_det.is_detected = true;\n      num_regain++;\n      num_lost = 0;\n    } else {\n      num_regain = 0;\n      num_lost++;\n    }\n\n    if (num_lost > VISION_THRES) {\n      ellipse_det.is_detected = false;\n    }\n\n    if (num_regain > VISION_THRES) {\n      ellipse_det.is_detected = true;\n    }\n\n    if (ellipse_det.is_detected) {\n      ellipse_det.sight_angle = msg->detected_objects[i].sight_angle;\n    } else {\n      ellipse_det.sight_angle = msg->detected_objects[i].sight_angle;\n    }\n  }\n}", "CodeBleu_score": 57.25262145895781}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tellipse_det.header = msg->header;\n  ellipse_det.detections.clear();\n  for (int i = 0; i < msg->detections.size(); i++) {\n    ellipse_det.detections.push_back(msg->detections[i]);\n    if (msg->detections[i].name == \"T\") {\n      num_regain++;\n      num_lost = 0;\n    } else {\n      num_regain = 0;\n      num_lost++;\n    }\n  }\n  if (num_lost > VISION_THRES) {\n    is_detected = false;\n  } else if (num_regain > VISION_THRES) {\n    is_detected = true;\n  }\n  if (is_detected) {\n    ellipse_det.detections[0].sight_angle = ellipse_det.detections[1].sight_angle;\n    ellipse_det.detections[1].sight_angle = ellipse_det.detections[2].sight_angle;\n    ellipse_det.detections[2].sight_angle = ellipse_det.detections[0].sight_angle;\n  }\n}", "CodeBleu_score": 67.65897263453967}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->det_info.size(); i++) {\n        if (msg->det_info[i].det_name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n    }\n\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n\n    if (is_detected == true) {\n        ellipse_det.sight_angle = ellipse_det.sight_angle_2;\n    } else {\n        ellipse_det.sight_angle = ellipse_det.sight_angle_1;\n    }\n}", "CodeBleu_score": 65.4829895361269}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tEigen::Vector3d pos_to_check(cur_pos[0], cur_pos[1], cur_pos[2]);\n  double safe_distance_squared = safe_distance * safe_distance;\n\n  bool safe = true;\n  // Check if the position is in the map\n  if (Occupy_map_ptr->get_unknown_point(pos_to_check[0], pos_to_check[1], pos_to_check[2])) {\n    safe = false;\n  }\n\n  // Check if the position is in the obstacle\n  if (Occupy_map_ptr->get_occupied_point(pos_to_check[0], pos_to_check[1], pos_to_check[2])) {\n    safe = false;\n  }\n\n  // Check if the position is too close to the robot\n  double distance_to_robot_squared = (pos_to_check - robot_pos).squaredNorm();\n  if (distance_to_robot_squared < safe_distance_squared) {\n    safe = false;\n  }\n\n  return safe;\n}", "CodeBleu_score": 39.71921509875865}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tif (Occupy_map_ptr->getOccupancyMap().data.find(cur_pos) !=\n      Occupy_map_ptr->getOccupancyMap().data.end()) {\n    if (Occupy_map_ptr->getOccupancyMap().data.at(cur_pos) > safe_distance) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 34.31168954656159}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tbool is_safe = false;\n  if (Occupy_map_ptr->getOccupancyMap().data[int(cur_pos(0)) + int(cur_pos(1)) * Occupy_map_ptr->getGridSize()] == 0) {\n    if (cur_pos(2) < safe_distance) {\n      is_safe = true;\n    }\n  }\n  return is_safe;\n}", "CodeBleu_score": 45.610862631517854}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\tNodePtr node = end_node;\n    path_nodes_.push_back(node);\n    while (node->getParent() != NULL) {\n        node = node->getParent();\n        path_nodes_.push_back(node);\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.12659835023027}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tNodePtr curr_node = end_node;\n    while (curr_node != nullptr) {\n        path_nodes_.push_back(curr_node);\n        curr_node = curr_node->parent;\n    }\n    reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 60.91255060430758}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tpath_nodes_.clear();\n    path_nodes_.push_back(end_node);\n    NodePtr current_node = end_node;\n    while (current_node->getParent() != nullptr) {\n        current_node = current_node->getParent();\n        path_nodes_.push_back(current_node);\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 58.893598974542904}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\tif (id == 0) {\n        if (sim_mode) {\n            double dx = odom->pose.pose.position.x - start_pos.x;\n            double dy = odom->pose.pose.position.y - start_pos.y;\n            double dist = sqrt(dx * dx + dy * dy);\n            if (dist > 5.0) {\n                get_nei_state[id] = false;\n            }\n            else {\n                get_nei_state[id] = true;\n            }\n        }\n        else {\n            get_nei_state[id] = true;\n        }\n        state_nei[id][0] = odom->pose.pose.position.x;\n        state_nei[id][1] = odom->pose.pose.position.y;\n        state_nei[id][2] = odom->pose.pose.position.z;\n    }\n    else {\n        state_nei[id][0] = odom->pose.pose.position.x;\n        state_nei[id][1] = odom->pose.pose.position.y;\n        state_nei[id][2] = odom->pose.pose.position.z;\n    }\n}", "CodeBleu_score": 61.90001776123204}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t//Get the current state of the UGV\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n    state_nei[id][3] = odom->twist.twist.linear.x;\n    state_nei[id][4] = odom->twist.twist.linear.y;\n    state_nei[id][5] = odom->twist.twist.linear.z;\n    state_nei[id][6] = odom->twist.twist.angular.x;\n    state_nei[id][7] = odom->twist.twist.angular.y;\n    state_nei[id][8] = odom->twist.twist.angular.z;\n\n    if(sim_mode) {\n        //Check the distance from the start position\n        double dist = sqrt(pow(state_nei[id][0] - start_pos[0], 2) + pow(state_nei[id][1] - start_pos[1], 2));\n        if(dist > 5) {\n            get_nei_state[id] = false;\n            return;\n        }\n    }\n\n    get_nei_state[id] = true;\n}", "CodeBleu_score": 52.965725176975084}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\tif (odom->pose.pose.position.z > 0.001) {\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n    state_nei[id][3] = odom->twist.twist.linear.x;\n    state_nei[id][4] = odom->twist.twist.linear.y;\n    state_nei[id][5] = odom->twist.twist.linear.z;\n    state_nei[id][6] = odom->twist.twist.angular.x;\n    state_nei[id][7] = odom->twist.twist.angular.y;\n    state_nei[id][8] = odom->twist.twist.angular.z;\n\n    if (sim_mode) {\n      double dx = state_nei[id][0] - state_start[0];\n      double dy = state_nei[id][1] - state_start[1];\n      double dist = sqrt(dx*dx + dy*dy);\n      if (dist > 5.0) {\n        get_nei_state[id] = false;\n      }\n      else {\n        get_nei_state[id] = true;\n      }\n    }\n    else {\n      get_nei_state[id] = true;\n    }\n  }\n}", "CodeBleu_score": 62.59937065290182}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// if odometry is not ready, return immediately\n    if (!odom_ready)\n        return;\n\n    // set sensor ready flag to true and increment update counter\n    sensor_ready = true;\n    sensor_update_count++;\n\n    // if update count is not equal to 5, return immediately\n    if (sensor_update_count != 5)\n        return;\n\n    // reset update count\n    sensor_update_count = 0;\n\n    // create point cloud object\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n\n    // convert sensor_msgs::PointCloud2 to pcl::PointCloud\n    pcl::fromROSMsg(*msg, cloud);\n\n    // convert pcl::PointCloud to pcl::PointCloud<pcl::PointXYZI>\n    pcl::PointCloud<pcl::PointXYZI> cloud_I;\n    pcl::copyPointCloud(cloud, cloud_I);\n\n    // convert pcl::PointCloud<pcl::PointXYZI> to pcl::PointCloud<pcl::PointXYZRGB>\n    pcl::PointCloud<pcl::PointXYZRGB> cloud_RGB;\n    pcl::copyPointCloud(cloud_I, cloud_RGB);\n\n    // convert pcl::PointCloud<pcl::PointXYZRGB> to pcl::PointCloud<pcl::PointXYZI>\n    pcl::PointCloud<pcl::PointXYZI> cloud_I_RGB;\n    pcl::copyPointCloud(cloud_RGB, cloud_I_RGB);\n\n    // set the header of the point cloud\n    cloud_I_RGB.header.frame_id = \"odom\";\n    cloud_I_RGB.header.stamp = ros::Time::now();\n\n    // publish point cloud\n    pub_cloud.publish(cloud_I_RGB);\n\n    // convert pcl::PointCloud<pcl::PointXYZI> to pcl::PointCloud<pcl::PointXYZ>\n    pcl::PointCloud<pcl::PointXYZ> cloud_XYZ;\n    pcl::copyPointCloud(cloud_I, cloud_XYZ);", "CodeBleu_score": 44.53991681619806}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (odom_ready == false) {\n    return;\n  }\n\n  if (sensor_ready == false) {\n    sensor_ready = true;\n    update_counter = 0;\n  }\n\n  update_counter++;\n\n  if (update_counter < 5) {\n    return;\n  }\n\n  // ROS_INFO(\"Gpointcloud_cb: updating Astar map\");\n\n  // convert point cloud to vector of points\n  std::vector<Point> points;\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  pcl::fromROSMsg(*msg, cloud);\n  for (int i = 0; i < cloud.points.size(); i++) {\n    Point p;\n    p.x = cloud.points[i].x;\n    p.y = cloud.points[i].y;\n    p.z = cloud.points[i].z;\n    points.push_back(p);\n  }\n\n  // update Astar map\n  map.update(points);\n\n  // reset update counter\n  update_counter = 0;\n}", "CodeBleu_score": 43.085994165928966}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (odom_ready == false) {\n    return;\n  }\n  if (sensor_ready == false) {\n    sensor_ready = true;\n    update_count = 0;\n  }\n  update_count++;\n  if (update_count < 5) {\n    return;\n  }\n  sensor_msgs::PointCloud2 pc2_copy;\n  sensor_msgs::convertPointCloud2ToPointCloud(*msg, *pc2_copy);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(*msg, *cloud_in);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::VoxelGrid<pcl::PointXYZ> vg;\n  vg.setInputCloud(cloud_in);\n  vg.setLeafSize(0.1, 0.1, 0.1);\n  vg.filter(*cloud_out);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;\n  sor.setInputCloud(cloud_out);\n  sor.setMeanK(50);\n  sor.setStddevMulThresh(1.0);\n  sor.filter(*cloud_filtered);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_2(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor2;\n  sor2.setInputCloud(cloud_filtered);\n  sor2.setMeanK(50);\n  sor2.setStddevMulThresh(1.0);\n  sor2.filter(*cloud_filtered_2);\n  pcl::PointCloud<pcl::PointXYZ", "CodeBleu_score": 36.95026724883649}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t// Check if the global point cloud has been updated yet\n  if (get_gpcl == false) {\n\n    // Set the flag to true\n    get_gpcl = true;\n\n    // Convert the sensor message to a point cloud\n    pcl::fromROSMsg(*global_point, *gpcl);\n\n    // Store the point cloud\n    gpcl_store = *gpcl;\n\n    // Inflate the point cloud\n    gpcl_inf = *gpcl;\n    pcl::PointCloud<pcl::PointXYZ> gpcl_inf_temp;\n    pcl::VoxelGrid<pcl::PointXYZ> gpcl_inf_voxel;\n    gpcl_inf_voxel.setLeafSize(0.5, 0.5, 0.5);\n    gpcl_inf_voxel.setInputCloud(gpcl);\n    gpcl_inf_voxel.filter(gpcl_inf_temp);\n    pcl::toROSMsg(gpcl_inf_temp, gpcl_inf);\n\n  }\n\n}", "CodeBleu_score": 49.872089249244326}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (!get_gpcl) {\n    get_gpcl = true;\n\n    // Convert the sensor message to a point cloud\n    pcl::fromROSMsg(*global_point, *global_point_map);\n\n    // Store the point cloud\n    global_point_map_ptr = global_point_map;\n\n    // Inflate the point cloud\n    global_point_map_inflated = *global_point_map;\n    pcl::InflatePointCloud(global_point_map_inflated, global_point_map_inflated, inflation_radius);\n\n    // Set the flag to false\n    get_gpcl = false;\n  }\n}", "CodeBleu_score": 55.37610747723571}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t//check if the global map has been updated yet\n    if(get_gpcl) {\n        //if the global map has been updated, do nothing\n        return;\n    }\n    else {\n        //if the global map has not been updated, set the flag\n        get_gpcl = true;\n    }\n\n    //convert the sensor message to a point cloud\n    pcl::PointCloud<pcl::PointXYZ> global_pcl;\n    pcl::fromROSMsg(*global_point, global_pcl);\n\n    //store the point cloud\n    global_pcl_ptr = boost::make_shared<pcl::PointCloud<pcl::PointXYZ> >(global_pcl);\n\n    //inflate the point cloud\n    inflate_pointcloud(global_pcl_ptr, global_pcl_inflated_ptr, inflation_radius);\n\n    //update the global map with the inflated point cloud\n    update_map_gpcl(global_pcl_inflated_ptr);\n\n    //reset the flag\n    get_gpcl = false;\n}", "CodeBleu_score": 58.72013917804507}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// Convert the laser scan into a PointCloud2 format and convert it to a pcl::PointCloud\n  sensor_msgs::PointCloud2 laser_cloud_temp;\n  projector_.transformLaserScanToPointCloud(local_point->header.frame_id, *local_point, laser_cloud_temp, listener_);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(laser_cloud_temp, *laser_cloud);\n\n  // If not in simulation mode, merge the local map with the provided odometry data\n  if (!simulation_mode_) {\n    tf::Transform laser_pose;\n    tf::poseMsgToTF(odom.pose.pose, laser_pose);\n    laser_pose = laser_pose * laser_to_map_pose_;\n    laser_cloud->header.frame_id = map_frame_;\n    laser_cloud->header.stamp = ros::Time::now();\n    laser_cloud->header.seq = 0;\n    sensor_msgs::PointCloud2 laser_cloud_merged;\n    sensor_msgs::PointCloud2 laser_cloud_temp;\n    pcl::toROSMsg(*laser_cloud, laser_cloud_temp);\n    sensor_msgs::convertPointCloud2ToPointCloud2(laser_cloud_temp, laser_cloud_merged, laser_pose);\n    laser_cloud_merged.header.frame_id = map_frame_;\n    laser_cloud_merged.header.stamp = ros::Time::now();\n    laser_cloud_merged.header.seq = 0;\n    sensor_msgs::PointCloud2 laser_cloud_merged_filtered;\n    laser_cloud_merged_filtered = map_filter_->filter(laser_cloud_merged);\n    laser_cloud_merged_filtered.header.frame_id = map_frame_;\n    laser_cloud_merged_filtered.header.stamp = ros::", "CodeBleu_score": 44.473570085667696}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// Transform the laser scan into a PointCloud2 format and convert it to a pcl::PointCloud\n  sensor_msgs::PointCloud2 laser_cloud;\n  projector_.transformLaserScanToPointCloud(base_link_name_, *local_point, laser_cloud, listener_);\n  pcl::fromROSMsg(laser_cloud, *laser_cloud_);\n\n  // If not in simulation mode, merge the local map with the provided odometry data\n  if (!simulation_) {\n    // Transform the odometry data into a PointCloud2 format and convert it to a pcl::PointCloud\n    sensor_msgs::PointCloud2 odom_cloud;\n    projector_.transformPointCloud(odom.header.frame_id, odom.header.stamp, odom.pose.pose, base_link_name_, odom_cloud, listener_);\n    pcl::fromROSMsg(odom_cloud, *odom_cloud_);\n\n    // Merge the local map with the odometry data\n    *laser_cloud_ += *odom_cloud_;\n  }\n\n  // Update the occupancy map\n  map_update_pcl(*laser_cloud_);\n}", "CodeBleu_score": 45.84450020272131}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\tif (simulation_mode == false) {\n\n\t\t// 1. Convert the laser scan into a PointCloud2 format\n\t\tsensor_msgs::PointCloud2 laser_cloud_temp;\n\t\tprojector_.transformLaserScanToPointCloud(odom.header.frame_id, *local_point, laser_cloud_temp, laser_offset_x, laser_offset_y, laser_offset_z, laser_range_min, laser_range_max, laser_voxel_size);\n\n\t\t// 2. Convert the PointCloud2 format into a pcl::PointCloud format\n\t\tpcl::fromROSMsg(laser_cloud_temp, laserCloud);\n\n\t\t// 3. Merge the local map with the provided odometry data\n\t\tlaserCloud = laserCloud + odom;\n\n\t} else {\n\n\t\t// 1. Convert the laser scan into a PointCloud2 format\n\t\tsensor_msgs::PointCloud2 laser_cloud_temp;\n\t\tprojector_.transformLaserScanToPointCloud(odom.header.frame_id, *local_point, laser_cloud_temp, laser_offset_x, laser_offset_y, laser_offset_z, laser_range_min, laser_range_max, laser_voxel_size);\n\n\t\t// 2. Convert the PointCloud2 format into a pcl::PointCloud format\n\t\tpcl::fromROSMsg(laser_cloud_temp, laserCloud);\n\n\t}\n\n\t// 4. Update the occupancy map\n\toccupancy_map_update();\n\n}", "CodeBleu_score": 41.40272215748415}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t// Publish the global point cloud map\n  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(*global_pcl_ptr, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // Publish the inflated point cloud\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(*inflate_pcl_ptr, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 65.04287261418962}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t// Convert the global point cloud map to a ROS message\n  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(*global_pcl_ptr, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n\n  // Publish the global point cloud map\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // Convert the inflated point cloud to a ROS message\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(*inflate_pcl_ptr, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n\n  // Publish the inflated point cloud\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n\n}", "CodeBleu_score": 65.04287261418962}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t// Convert the global point cloud map to a ROS message\n  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(global_pcl, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_msg.header.stamp = ros::Time::now();\n\n  // Publish the global point cloud map\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // Convert the inflated point cloud to a ROS message\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(inflate_pcl, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_msg.header.stamp = ros::Time::now();\n\n  // Publish the inflated point cloud\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 54.25884935188052}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (odometry_ready) {\n        sensor_ready = true;\n        //ROS_INFO(\"Sensor is ready\");\n    }\n\n    if (sensor_ready) {\n        pcl::PointCloud<pcl::PointXYZ> cloud;\n        pcl::fromROSMsg(*msg, cloud);\n        pcl::PointXYZ min_pt, max_pt;\n        pcl::getMinMax3D(cloud, min_pt, max_pt);\n\n        //ROS_INFO(\"PointCloud received\");\n\n        // Update map\n        if (map_update_ready) {\n            map_update_ready = false;\n            //ROS_INFO(\"Map update ready\");\n\n            // Update map\n            map.header = msg->header;\n            map.header.frame_id = \"world\";\n            map.header.stamp = ros::Time::now();\n            map.info.resolution = map_resolution;\n            map.info.origin.position.x = min_pt.x;\n            map.info.origin.position.y = min_pt.y;\n            map.info.origin.position.z = min_pt.z;\n            map.info.origin.orientation.x = 0;\n            map.info.origin.orientation.y = 0;\n            map.info.origin.orientation.z = 0;\n            map.info.origin.orientation.w = 1;\n            map.info.width = (int) ((max_pt.x - min_pt.x) / map_resolution);\n            map.info.height = (int) ((max_pt.y - min_pt.y) / map_resolution);\n            map.data.resize(map.info.width * map.info.height);\n\n            // Update map data\n            for (int i = 0; i < cloud.points.size(); i++) {\n                int x = (int) ((cloud.points[i].x - min_pt.x) / map_resolution);\n                int y = (int) ((cloud.points[i].y - min_pt.y) / map_resolution);\n                if (x >= 0 && x", "CodeBleu_score": 43.43234028053695}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\n  // Check if odometry is ready\n  if (odometry_ready == true) {\n    sensor_ready = true;\n  }\n\n  // Get current time\n  ros::Time current_time = ros::Time::now();\n\n  // If odometry is ready and sensor is ready\n  if (odometry_ready == true && sensor_ready == true) {\n\n    // Get the current pose\n    tf::StampedTransform transform;\n    try {\n      listener.lookupTransform(\"/world\", \"/uav1\", ros::Time(0), transform);\n    }\n    catch (tf::TransformException ex) {\n      ROS_ERROR(\"%s\", ex.what());\n      ros::Duration(1.0).sleep();\n    }\n\n    // Get the current pose in the form of a 3D point\n    tf::Vector3 current_pose;\n    current_pose.setX(transform.getOrigin().x());\n    current_pose.setY(transform.getOrigin().y());\n    current_pose.setZ(transform.getOrigin().z());\n\n    // Get the current orientation in the form of a quaternion\n    tf::Quaternion current_orientation;\n    current_orientation.setX(transform.getRotation().x());\n    current_orientation.setY(transform.getRotation().y());\n    current_orientation.setZ(transform.getRotation().z());\n    current_orientation.setW(transform.getRotation().w());\n\n    // Update the A* algorithm's map using the new point cloud data and current UAV odometry\n    map.update_map(msg, current_pose, current_orientation, current_time);\n\n    // Reset the sensor_ready flag\n    sensor_ready = false;\n  }\n}", "CodeBleu_score": 42.77306141616478}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (!sensor_ready) {\n    ROS_INFO(\"Sensor ready\");\n    sensor_ready = true;\n  }\n\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  pcl::fromROSMsg(*msg, cloud);\n\n  // Get the current odometry\n  nav_msgs::Odometry odom;\n  if (!odom_ready) {\n    odom = odom_buffer.front();\n    odom_ready = true;\n    odom_buffer.pop_front();\n  } else {\n    odom = odom_buffer.front();\n    odom_buffer.pop_front();\n  }\n\n  // Update the map using the current point cloud data and UAV odometry\n  map.updateMap(cloud, odom);\n\n}", "CodeBleu_score": 50.421544138102114}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Check if we're in simulation\n  in_gazebo_ = false;\n  if (ros::topic::waitForMessage<gazebo_msgs::LinkStates>(\"/gazebo/link_states\", ros::Duration(1.0))) {\n    in_gazebo_ = true;\n  }\n\n  // Update the base\n  base_.update();\n\n  // Update the body controller\n  body_controller_.update();\n\n  // Update the leg controllers\n  for (int i = 0; i < 4; i++) {\n    leg_controllers_[i]->update();\n  }\n\n  // Compute target joint positions\n  float target_joints[12];\n  computeTargetJoints(target_joints);\n\n  // Compute foot contact information\n  bool foot_contacts[4];\n  computeFootContacts(foot_contacts);\n\n  // Publish joint commands\n  publishJoints_(target_joints);\n\n  // Publish foot contact information\n  publishFootContacts_(foot_contacts);\n}", "CodeBleu_score": 50.57994570554716}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Get the current time\n  champ::Phase current_time = rosTimeToChampTime(event.current_real);\n\n  // Update the base controller\n  base_.update(current_time);\n\n  // Update the body controller\n  body_.update(current_time);\n\n  // Compute the target foot positions for the current time\n  float target_feet[12];\n  body_.getTargetFootPositions(target_feet);\n\n  // Compute the target joint positions for the current time\n  float target_joints[12];\n  base_.computeIK(target_feet, target_joints);\n\n  // Publish joint commands\n  publishJoints_(target_joints);\n\n  // Publish foot contact information\n  bool foot_contacts[4];\n  base_.getFootContacts(foot_contacts);\n  publishFootContacts_(foot_contacts);\n}", "CodeBleu_score": 51.223956204918785}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t//Update the current time\n  ros::Time now = ros::Time::now();\n\n  //Update the current phase\n  base_.updatePhase(rosTimeToChampTime(now));\n\n  //Update the current foot positions\n  base_.updateFeet();\n\n  //Get the current joint positions\n  float current_joints[12];\n  for(size_t i = 0; i < 12; i++)\n  {\n    current_joints[i] = base_.legs[i]->joint_positions_[0];\n  }\n\n  //Compute the desired foot positions\n  float desired_feet[4][3];\n  base_.getDesiredFootPositions(desired_feet);\n\n  //Compute the desired joint positions\n  float desired_joints[12];\n  base_.getDesiredJointPositions(desired_feet, desired_joints);\n\n  //Compute the desired joint velocities\n  float desired_velocities[12];\n  base_.getDesiredJointVelocities(desired_feet, desired_velocities);\n\n  //Compute the desired joint torques\n  float desired_torques[12];\n  base_.getDesiredJointTorques(desired_feet, desired_torques);\n\n  //Publish the desired joint positions\n  publishJoints_(desired_joints);\n\n  //Publish the desired foot contacts\n  publishFootContacts_(base_.getFootContacts());\n}", "CodeBleu_score": 53.39176638657148}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publisher_ != nullptr) {\n    quadruped_msgs::ContactsStamped contacts;\n    contacts.header.stamp = ros::Time::now();\n    for (int leg = 0; leg < 4; leg++) {\n      contacts.contacts[leg].is_in_contact = foot_contacts[leg];\n      contacts.contacts[leg].gait_phase =\n          gait_phase_[leg] * (1.0 / gait_phase_multiplier_);\n    }\n    foot_contacts_publisher_.publish(contacts);\n  }\n}", "CodeBleu_score": 43.78970813020262}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t// Create a new ContactsStamped message\n  quadruped_msgs::ContactsStamped foot_contacts_msg;\n  // Set the header of the message\n  foot_contacts_msg.header.stamp = ros::Time::now();\n  // Set the gait phase of each leg\n  foot_contacts_msg.contacts.resize(4);\n  foot_contacts_msg.contacts[0] = foot_contacts[0];\n  foot_contacts_msg.contacts[1] = foot_contacts[1];\n  foot_contacts_msg.contacts[2] = foot_contacts[2];\n  foot_contacts_msg.contacts[3] = foot_contacts[3];\n  // Publish the message\n  foot_contacts_publisher_.publish(foot_contacts_msg);\n}", "CodeBleu_score": 52.65244595316527}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publisher_->trylock()) {\n    auto& contacts = foot_contacts_publisher_->msg_;\n    contacts.header.stamp = this->now();\n    contacts.header.frame_id = \"base_link\";\n    contacts.contact_states.clear();\n    for (int i = 0; i < 4; i++) {\n      if (foot_contacts[i]) {\n        contacts.contact_states.push_back(gait_phase_[i]);\n      }\n    }\n    foot_contacts_publisher_->unlockAndPublish();\n  }\n}", "CodeBleu_score": 45.947841465669406}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\tprintln \"joints_cmd_callback\"\n    println joints\n    def joints_msg = JointState()\n    joints_msg.header.stamp = joints.header.stamp\n    joints_msg.name = joints.name[0..11]\n    joints_msg.position = joints.position[0..11]\n    joints_msg.velocity = joints.velocity[0..11]\n    joints_msg.effort = joints.effort[0..11]\n    self.joints_pub.publish(joints_msg)\n\n    def joints_traj = JointTrajectory()\n    joints_traj.header.stamp = joints.header.stamp\n    joints_traj.joint_names = joints.name[0..11]\n    def point = JointTrajectoryPoint()\n    point.positions = joints.position[0..11]\n    point.velocities = joints.velocity[0..11]\n    point.effort = joints.effort[0..11]\n    point.time_from_start = Duration.new(1.0)\n    joints_traj.points.add(point)\n    self.joints_traj_pub.publish(joints_traj)\n}", "CodeBleu_score": 47.952480989840105}, {"code": "def joints_cmd_callback(self, joints){\n\tself.joints_pub.publish(joints)\n    self.joints_traj_msg.header.stamp = joints.header.stamp\n    self.joints_traj_msg.points[0].positions = joints.position\n    self.joints_traj_pub.publish(self.joints_traj_msg)\n}", "CodeBleu_score": 21.644386939663967}, {"code": "def joints_cmd_callback(self, joints){\n\t// Create a minimal joints message with the first 12 joint positions\n\tJoints joints_msg = new Joints()\n\tjoints_msg.header.stamp = joints.header.stamp\n\tfor (int i = 0; i < 12; i++) {\n\t\tjoints_msg.position[i] = joints.position[i]\n\t}\n\t// Publish the joints message to the joints topic\n\tself.joints_pub.publish(joints_msg)\n\n\t// Create a joint trajectory message with the same positions and a specified duration\n\tJointTrajectory joint_traj = new JointTrajectory()\n\tjoint_traj.header.stamp = joints.header.stamp\n\tjoint_traj.joint_names = self.joint_names\n\tJointTrajectoryPoint point = new JointTrajectoryPoint()\n\tpoint.positions = joints.position\n\tpoint.time_from_start = self.duration\n\tjoint_traj.points = [point]\n\n\t// Publish the trajectory message to the joint trajectory topic\n\tself.joint_traj_pub.publish(joint_traj)\n}", "CodeBleu_score": 52.7867700756846}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize all foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    footContactStates_[i] = false;\n  }\n\n  // For each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Split the collision string to identify the contact link\n    std::vector<std::string> collision = split(_msg->contact(i).collision1(), ':');\n\n    // If a contact matches one of the foot links\n    if (collision[collision.size() - 1] == \"l_foot\" ||\n        collision[collision.size() - 1] == \"r_foot\") {\n      // Set the corresponding foot contact state to true\n      if (collision[collision.size() - 1] == \"l_foot\") {\n        footContactStates_[0] = true;\n      } else {\n        footContactStates_[1] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 54.1528107748521}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Reset foot contact flags\n    for (int i = 0; i < NUM_FOOTS; ++i) {\n        foot_contact_[i] = false;\n    }\n\n    // Check each contact\n    for (int i = 0; i < _msg->contact_size(); ++i) {\n        // Get the contact link names\n        const string &collision1 = _msg->contact(i).collision1();\n        const string &collision2 = _msg->contact(i).collision2();\n\n        // Check if the contact involves one of the feet\n        for (int j = 0; j < NUM_FOOTS; ++j) {\n            if ((collision1.compare(0, foot_link_names_[j].size(), foot_link_names_[j]) == 0) ||\n                (collision2.compare(0, foot_link_names_[j].size(), foot_link_names_[j]) == 0)) {\n                // Found a foot contact\n                foot_contact_[j] = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 57.42804730313142}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize the foot contact states\n  leftFootContact_ = false;\n  rightFootContact_ = false;\n\n  // For each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Split the collision string to identify the contact link\n    std::vector<std::string> collision_strings = split(_msg->contact(i).collision2(), '/');\n\n    // If the contact matches one of the foot links\n    if (collision_strings[collision_strings.size() - 1] == \"l_sole\") {\n      // Set the left foot contact state to true\n      leftFootContact_ = true;\n    } else if (collision_strings[collision_strings.size() - 1] == \"r_sole\") {\n      // Set the right foot contact state to true\n      rightFootContact_ = true;\n    }\n  }\n}", "CodeBleu_score": 40.5670370293502}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!is_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(vehicle_parameters_.rotor_count);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::Vector3d thrust = acceleration + angular_acceleration;\n\n  Eigen::Vector3d thrust_body = odometry_.orientation.inverse()._transformVector(thrust);\n\n  // Project thrust onto body z-axis.\n  thrust_body[0] = 0;\n  thrust_body[1] = 0;\n\n  // Combine angular acceleration and thrust.\n  Eigen::VectorXd rotor_velocities_body = Eigen::VectorXd::Zero(vehicle_parameters_.rotor_count);\n  for (int i = 0; i < vehicle_parameters_.rotor_count; ++i) {\n    rotor_velocities_body(i) = thrust_body.dot(vehicle_parameters_.rotor_direction[i]);\n  }\n\n  // Ensure non-negative values.\n  rotor_velocities_body = rotor_velocities_body.cwiseMax(Eigen::VectorXd::Zero(vehicle_parameters_.rotor_count));\n\n  // Compute rotor velocities.\n  *rotor_velocities = rotor_velocities_body.array().sqrt();\n}", "CodeBleu_score": 55.88416138123187}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // If the controller is not active, we just return zero rotor velocities.\n  if (!IsActive()) {\n    *rotor_velocities = Eigen::VectorXd::Zero(vehicle_parameters_.rotor_count_);\n    return;\n  }\n\n  // Compute desired acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  // Compute desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z-axis and combine with angular acceleration.\n  Eigen::Vector3d thrust = acceleration + angular_acceleration;\n\n  // Compute rotor velocities.\n  Eigen::VectorXd rotor_velocities_temp =\n      thrust.cwiseProduct(controller_parameters_.thrust_to_torque_matrix_);\n  rotor_velocities_temp = rotor_velocities_temp.cwiseMax(Eigen::VectorXd::Zero(rotor_velocities_temp.rows()));\n  *rotor_velocities = rotor_velocities_temp.array().sqrt();\n}", "CodeBleu_score": 47.40495684937558}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!IsActive()) {\n    *rotor_velocities = Eigen::VectorXd::Zero(vehicle_parameters_.rotor_count);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust = acceleration.cwiseProduct(vehicle_parameters_.mass_);\n\n  // Combine thrust and angular acceleration.\n  Eigen::Vector3d rotor_velocities_3d = thrust + angular_acceleration;\n\n  // Project onto the rotor velocity matrix.\n  Eigen::VectorXd rotor_velocities_projected =\n      vehicle_parameters_.rotor_velocity_to_thrust_matrix_ * rotor_velocities_3d;\n\n  // Ensure non-negative values.\n  rotor_velocities_projected = rotor_velocities_projected.cwiseMax(Eigen::VectorXd::Zero(rotor_velocities_projected.size()));\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities_projected.cwiseSqrt();\n}", "CodeBleu_score": 55.389252581230174}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tEigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n\n  // Calculate the position error\n  position_error = command_trajectory_.GetPosition(current_time_) - odometry_.GetPosition();\n\n  // Calculate the velocity error\n  velocity_error = command_trajectory_.GetVelocity(current_time_) - odometry_.GetVelocity();\n\n  // Transform the velocity error into the world frame\n  velocity_error = odometry_.GetRotation() * velocity_error;\n\n  // Calculate the desired acceleration\n  *acceleration = (position_error * position_gain_ + velocity_error * velocity_gain_) / mass_;\n  acceleration->z() -= gravity_;\n  acceleration->z() += command_trajectory_.GetAcceleration(current_time_);\n}", "CodeBleu_score": 42.01399557559954}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// get the current odometry data\n    Eigen::Vector3d position = odometry_->GetPosition();\n    Eigen::Vector3d velocity = odometry_->GetVelocity();\n    Eigen::Vector3d orientation = odometry_->GetOrientation();\n\n    // transform the velocity from the vehicle frame to the world frame\n    Eigen::Vector3d world_velocity = odometry_->TransformVehicleVelocityToWorld(velocity);\n\n    // get the current position and velocity errors\n    Eigen::Vector3d position_error = odometry_->GetPositionError();\n    Eigen::Vector3d velocity_error = odometry_->GetVelocityError();\n\n    // get the current orientation error\n    Eigen::Vector3d orientation_error = odometry_->GetOrientationError();\n\n    // get the desired acceleration\n    Eigen::Vector3d desired_acceleration = odometry_->GetDesiredAcceleration();\n\n    // get the current acceleration\n    Eigen::Vector3d acceleration_ = odometry_->GetAcceleration();\n\n    // calculate the desired acceleration\n    *acceleration = desired_acceleration +\n                    (position_gain_ * position_error) +\n                    (velocity_gain_ * velocity_error) +\n                    (orientation_gain_ * orientation_error) -\n                    (mass_ * gravity_) -\n                    (mass_ * world_velocity);\n}", "CodeBleu_score": 41.213212272806246}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// 1. Compute the position error.\n  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n  // 2. Compute the velocity error.\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity - odometry_.velocity;\n\n  // 3. Transform the velocity error to the world frame.\n  Eigen::Vector3d world_velocity_error = odometry_.rotation * velocity_error;\n\n  // 4. Compute the desired acceleration.\n  *acceleration = (position_gain_ * position_error) + (velocity_gain_ * world_velocity_error) +\n                  (acceleration_gain_ * command_trajectory_.acceleration);\n\n  // 5. Adjust the desired acceleration to account for gravity.\n  *acceleration -= gravity_;\n\n  // 6. Adjust the desired acceleration to account for the vehicle mass.\n  *acceleration /= mass_;\n}", "CodeBleu_score": 39.90547139759109}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // ensure that the parameters are valid\n  assert(rotor_velocities->size() == kNumMotors);\n\n  // ensure that the input is valid\n  assert(attitude_.w().norm() > 0.0);\n  assert(attitude_.vec().norm() > 0.0);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd rotor_velocities_desired =\n      Eigen::VectorXd::Zero(kNumMotors);\n  rotor_velocities_desired.segment<3>(0) =\n      angular_acceleration.cwiseProduct(kRotorVelocityCoefficients);\n  rotor_velocities_desired.segment<3>(3) =\n      control_attitude_thrust_reference_.segment<3>(3);\n\n  // ensure that the rotor velocities are at least one\n  rotor_velocities_desired = rotor_velocities_desired.cwiseMax(1.0);\n\n  // take the square root of each component\n  *rotor_velocities = rotor_velocities_desired.array().sqrt();\n}", "CodeBleu_score": 46.108634830643005}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // ensure that the number of rotors is valid\n  assert(num_rotors_ == rotor_velocities->size());\n\n  // ensure that the parameters are valid\n  assert(gain_attitude_.size() == 3);\n  assert(gain_angular_rate_.size() == 3);\n  assert(control_attitude_thrust_reference_.size() == 3);\n\n  // resize the vector to the number of rotors\n  rotor_velocities->resize(num_rotors_);\n\n  // get the desired angular acceleration\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // combine the desired angular acceleration with the thrust reference\n  Eigen::Vector3d thrust_reference = control_attitude_thrust_reference_.cwiseProduct(Eigen::Vector3d::Ones());\n  Eigen::Vector3d desired_angular_acceleration = thrust_reference.cwiseProduct(angular_acceleration);\n\n  // compute the rotor velocities\n  Eigen::VectorXd rotor_velocities_temp = desired_angular_acceleration.cwiseProduct(rotor_velocities_map_);\n  for (int i = 0; i < num_rotors_; i++) {\n    (*rotor_velocities)[i] = rotor_velocities_temp[i];\n    if ((*rotor_velocities)[i] < 0) {\n      (*rotor_velocities)[i] = 0;\n    }\n    (*rotor_velocities)[i] = sqrt((*rotor_velocities)[i]);\n  }\n}", "CodeBleu_score": 52.147612551603714}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // check if input is valid\n  if (control_attitude_thrust_reference_.size() != 3) {\n    throw std::invalid_argument(\"control_attitude_thrust_reference_ must be of size 3.\");\n  }\n\n  // resize rotor velocities\n  rotor_velocities->resize(motor_speed_controller_->GetMotorCount());\n\n  // get desired angular acceleration\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  // combine desired angular acceleration and thrust reference\n  Eigen::VectorXd control_attitude_thrust_reference_combined(6);\n  control_attitude_thrust_reference_combined << control_attitude_thrust_reference_, thrust_reference_;\n\n  // compute rotor velocities\n  Eigen::VectorXd rotor_velocities_temp = motor_speed_controller_->CalculateRotorVelocities(control_attitude_thrust_reference_combined, angular_acceleration);\n  *rotor_velocities = rotor_velocities_temp.head(motor_speed_controller_->GetMotorCount());\n}", "CodeBleu_score": 42.130768049373714}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\tstart_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    new_object = copy.deepcopy(self)\n    new_object.time = self.time[start_index:end_index]\n    new_object.data = self.data[start_index:end_index]\n    return new_object\n\n", "CodeBleu_score": 31.901414233482186}, {"code": "def slice(self, start_time, end_time)\n\ttry:\n        start_index = self.get_next_index(start_time)\n        end_index = self.get_next_index(end_time)\n        new_obj = deepcopy(self)\n        new_obj.time = self.time[start_index:end_index]\n        new_obj.x = self.x[start_index:end_index]\n        new_obj.y = self.y[start_index:end_index]\n        new_obj.z = self.z[start_index:end_index]\n        new_obj.vx = self.vx[start_index:end_index]\n        new_obj.vy = self.vy[start_index:end_index]\n        new_obj.vz = self.vz[start_index:end_index]\n        new_obj.ax = self.ax[start_index:end_index]\n        new_obj.ay = self.ay[start_index:end_index]\n        new_obj.az = self.az[start_index:end_index]\n        return new_obj\n    except Exception, e:\n        raise e\n\n", "CodeBleu_score": 43.50761079163572}, {"code": "def slice(self, start_time, end_time)\n\tstart_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    sliced_object = copy.deepcopy(self)\n    sliced_object.time = sliced_object.time[start_index:end_index]\n    sliced_object.data = sliced_object.data[start_index:end_index]\n    return sliced_object", "CodeBleu_score": 31.804439082387116}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t# Extract the position and rotation\n    position = waypoint_msg.pose.pose.position\n    quaternion = waypoint_msg.pose.pose.orientation\n    # Convert the quaternion to Euler angles\n    euler = euler_from_quaternion([quaternion.x, quaternion.y, quaternion.z, quaternion.w])\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one\n    if self.last_point is None:\n        self.last_point = point\n    if self.last_yaw is None:\n        self.last_yaw = euler[2]\n    if point.x != self.last_point.x or point.y != self.last_point.y or point.z != self.last_point.z or euler[2] != self.last_yaw:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.points.append_point(point)\n        self.yaw.append(euler[2])\n        self.points.append_times(msg_time, bag_time)\n        self.yaw.append_times(msg_time, bag_time)\n        # Update the last point and yaw\n        self.last_point = point\n        self.last_yaw = euler[2]\n\n", "CodeBleu_score": 31.340369885618323}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tpoint = Point(waypoint_msg.pose.pose.position.x,\n                  waypoint_msg.pose.pose.position.y,\n                  waypoint_msg.pose.pose.position.z)\n    quat = [waypoint_msg.pose.pose.orientation.x,\n            waypoint_msg.pose.pose.orientation.y,\n            waypoint_msg.pose.pose.orientation.z,\n            waypoint_msg.pose.pose.orientation.w]\n    euler = tf.transformations.euler_from_quaternion(quat)\n    yaw = euler[2]\n    if self.last_waypoint is None:\n        self.last_waypoint = waypoint_msg\n        self.last_yaw = yaw\n        self.last_point = point\n        self.last_time = msg_time\n        self.last_bag_time = bag_time\n    elif (self.last_point != point or self.last_yaw != yaw):\n        self.append_point(point)\n        self.append_yaw(yaw)\n        self.append_times(msg_time, bag_time)\n        self.last_waypoint = waypoint_msg\n        self.last_yaw = yaw\n        self.last_point = point\n        self.last_time = msg_time\n        self.last_bag_time = bag_time\n\n", "CodeBleu_score": 28.19899155786631}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t# Extract the position and rotation\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert the rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one\n    if self.last_point is None or not point.is_equal(self.last_point) or self.last_yaw != euler[2]:\n        # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.append_yaw(euler[2])\n        self.append_times(msg_time, bag_time)\n        # Set the last waypoint to the current one\n        self.last_point = point\n        self.last_yaw = euler[2]\n\n", "CodeBleu_score": 24.822033627371955}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t# Convert the message timestamp to seconds.\n    msg_time = msg.header.stamp.to_sec()\n    # For each IMU topic, if the topic matches, it appends the linear acceleration data to the corresponding x, y, and z attributes.\n    if topic == self.imu_topic:\n        self.acceleration.x = numpy.append(self.acceleration.x, msg.linear_acceleration.x)\n        self.acceleration.y = numpy.append(self.acceleration.y, msg.linear_acceleration.y)\n        self.acceleration.z = numpy.append(self.acceleration.z, msg.linear_acceleration.z)\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 36.127154173527316}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t# Convert the message timestamp to seconds.\n    msg_time = msg.header.stamp.secs + 1e-9 * msg.header.stamp.nsecs\n    # For each IMU topic, if the topic matches, it appends the linear acceleration data to the corresponding x, y, and z attributes.\n    if topic == self.imu_topic_list[0]:\n        self.acc_x.append_times(msg_time, bag_time)\n        self.acc_x.append_data(msg.linear_acceleration.x)\n    elif topic == self.imu_topic_list[1]:\n        self.acc_y.append_times(msg_time, bag_time)\n        self.acc_y.append_data(msg.linear_acceleration.y)\n    elif topic == self.imu_topic_list[2]:\n        self.acc_z.append_times(msg_time, bag_time)\n        self.acc_z.append_data(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.520862815980966}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t# Convert the message timestamp to seconds\n    msg_time = msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9\n\n    # If the topic matches, append the linear acceleration data to the\n    # corresponding x, y, and z attributes\n    if topic == self.imu_topic:\n        self.imu_linear_acc_x.append_times(msg_time, bag_time)\n        self.imu_linear_acc_y.append_times(msg_time, bag_time)\n        self.imu_linear_acc_z.append_times(msg_time, bag_time)\n\n        self.imu_linear_acc_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acc_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acc_z.append(msg.linear_acceleration.z)\n\n    # If the topic matches, append the angular velocity data to the\n    # corresponding x, y, and z attributes\n    if topic == self.imu_topic:\n        self.imu_angular_vel_x.append_times(msg_time, bag_time)\n        self.imu_angular_vel_y.append_times(msg_time, bag_time)\n        self.imu_angular_vel_z.append_times(msg_time, bag_time)\n\n        self.imu_angular_vel_x.append(msg.angular_velocity.x)\n        self.imu_angular_vel_y.append(msg.angular_velocity.y)\n        self.imu_angular_vel_z.append(msg.angular_velocity.z)\n\n", "CodeBleu_score": 30.91626970532132}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Create a figure with a title and a subplot for accelerations\n    fig = plt.figure(figsize=(10, 10))\n    fig.suptitle(\"Accelerations\", fontsize=16)\n    ax = fig.add_subplot(111)\n\n    # For each acceleration dataset, plot the x, y, and z components over time with different colors and labels\n    ax.plot(self.acceleration_x, color=\"red\", label=\"x\")\n    ax.plot(self.acceleration_y, color=\"green\", label=\"y\")\n    ax.plot(self.acceleration_z, color=\"blue\", label=\"z\")\n\n    # Add labels for the x and y axes and include a legend\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (g)\")\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        if plot_suffix:\n            plt.savefig(self.plot_dir + self.plot_prefix + \"accelerations_\" + plot_suffix + \".png\")\n        else:\n            plt.savefig(self.plot_dir + self.plot_prefix + \"accelerations.png\")\n\n", "CodeBleu_score": 33.37305767872505}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Generate plot title\n    plot_title = \"Acceleration Data\"\n    # Generate plot filename\n    plot_filename = \"accelerations\"\n    if plot_suffix is not None:\n        plot_filename = plot_filename + \"_\" + plot_suffix\n    # Create figure and subplot\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    # Plot each acceleration dataset\n    for accel_dataset in self.acceleration_datasets:\n        # Get x, y, and z data\n        x = accel_dataset.x\n        y = accel_dataset.y\n        z = accel_dataset.z\n        # Plot x, y, and z data\n        ax.plot(x, color=\"red\", label=\"x\")\n        ax.plot(y, color=\"green\", label=\"y\")\n        ax.plot(z, color=\"blue\", label=\"z\")\n    # Add labels for x and y axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (g)\")\n    # Add legend\n    ax.legend()\n    # Add plot title\n    plt.title(plot_title)\n    # If saving plots is enabled, save plot as PNG\n    if self.save_plots:\n        # Construct filename\n        filename = self.plot_dir + \"/\" + plot_filename + \".png\"\n        # Save plot as PNG\n        plt.savefig(filename, format=\"png\")\n    # Show plot\n    plt.show()\n\n\n", "CodeBleu_score": 38.43412806761064}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Create figure and subplot\n    fig, ax = plt.subplots()\n    fig.suptitle(self.name + \" Acceleration Data\")\n    ax.set_title(\"Accelerations\")\n\n    # Plot acceleration data\n    for i, acc in enumerate(self.accelerations):\n        ax.plot(acc.time, acc.x, color=colors[i], label=\"X\", alpha=0.5)\n        ax.plot(acc.time, acc.y, color=colors[i], label=\"Y\", alpha=0.5)\n        ax.plot(acc.time, acc.z, color=colors[i], label=\"Z\", alpha=0.5)\n\n    # Add labels for axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n    # Add legend\n    ax.legend()\n\n    # Save plot\n    if self.save_plots:\n        # Construct filename\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        filename = self.name + \"_accelerations\" + plot_suffix + \".png\"\n\n        # Save plot\n        plt.savefig(filename)\n        print(\"Saved plot to \" + filename)\n\n    # Show plot\n    plt.show()\n\n", "CodeBleu_score": 37.89917958026424}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\tif len(pose_indeces) < 2:\n        print(\"At least two pose indices are required to perform comparisons\")\n        return\n\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(self.poses[pose_indeces[i]].xyz, self.poses[pose_indeces[j]].xyz)\n\n", "CodeBleu_score": 41.070685176371164}, {"code": "def compare_positions(self, pose_indeces)\n\tif len(pose_indeces) < 2:\n        raise ValueError(\n            \"You need to provide at least two pose indices to perform comparisons.\"\n        )\n\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(\n                self.poses[pose_indeces[i]].xyz, self.poses[pose_indeces[j]].xyz\n            )\n\n", "CodeBleu_score": 38.98085599040015}, {"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 38.34182643493508}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for time in self.wrench.keys():\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 36.26111171189776}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for collision in self.wrench:\n        collision_time = collision[0]\n        if start_time is None or collision_time >= start_time:\n            if end_time is None or collision_time <= end_time:\n                collision_times.append(collision_time)\n    return collision_times\n\n", "CodeBleu_score": 50.42819477150184}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {\n    return;\n  }\n  const float multiplier = this->multiplier;\n  Eigen::Map<Eigen::VectorXf> vec(data, width * height);\n  const float rms_noise = this->rms_noise;\n  const float bad_point = this->bad_point;\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (this->InRange(vec(i))) {\n      vec(i) += multiplier * rms_noise *\n                std::sqrt(std::log(1.0f + vec(i) * vec(i) / 10000000.0f));\n    } else {\n      vec(i) = bad_point;\n    }\n  }\n}", "CodeBleu_score": 43.479508685060445}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {\n    return;\n  }\n\n  // Calculate the multiplier based on the camera parameters\n  const float multiplier = this->multiplier_;\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Calculate the RMS noise\n  const float rms = this->rms_;\n\n  // Calculate the noise values\n  const float noise_min = this->noise_min_;\n  const float noise_max = this->noise_max_;\n\n  // Iterate over the data\n  for (uint32_t i = 0; i < width * height; i++) {\n    // Add noise if the pixel value is in range, otherwise set the pixel to a\n    // bad point value\n    if (InRange(data_vec[i])) {\n      data_vec[i] += multiplier * rms *\n                     (noise_max - noise_min) * (rand() / (RAND_MAX + 1.0)) +\n                     noise_min;\n    } else {\n      data_vec[i] = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 54.48544562765502}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n  const float multiplier = this->multiplier(width, height);\n  Eigen::Map<Eigen::VectorXf> data_vector(data, width * height);\n  const float rms_noise = this->rms_noise(width, height);\n  const float noise_min = this->noise_min(width, height);\n  const float noise_max = this->noise_max(width, height);\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (this->InRange(data_vector(i))) {\n      data_vector(i) += data_vector(i) * rms_noise * multiplier;\n      if (data_vector(i) < noise_min) {\n        data_vector(i) = noise_min;\n      } else if (data_vector(i) > noise_max) {\n        data_vector(i) = noise_max;\n      }\n    } else {\n      data_vector(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 56.64034505300768}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time\n  common::Time current_time = world_->GetSimTime();\n\n  // Convert to ROS time\n  ros::Time ros_time(current_time.sec, current_time.nsec);\n\n  // Write the message to the bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 63.75845353898608}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time\n  gazebo::common::Time current_time = world_->GetSimTime();\n  // Convert to ROS time\n  ros::Time ros_time = ros::Time(current_time.sec, current_time.nsec);\n  // Write the trajectory message to the bag file\n  bag.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 64.5031701903894}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Retrieve the current simulation time and convert it to ROS time\n  common::Time sim_time = this->world->GetSimTime();\n  ros::Time ros_time = ros::Time(sim_time.sec, sim_time.nsec);\n\n  // Write the trajectory message to a bag file using the specified namespace and waypoint topic\n  this->bag.write(this->namespace_ + \"/\" + this->waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 58.09786483226149}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert simulation time to ROS time\n  ros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n  // Prepare message\n  gazebo_msgs::Actuators actuators;\n  actuators.header.stamp = ros_time;\n\n  // Iterate through motor joints and calculate slowed-down rotational velocities\n  for (int i = 0; i < motor_joint_names_.size(); i++) {\n    // Get joint velocity\n    double vel = motor_joints_[i]->GetVelocity(0);\n\n    // Slow down rotational velocity\n    vel *= motor_velocity_slowdown_factor_;\n\n    // Assign slowed-down rotational velocity to message\n    actuators.angular_velocities.push_back(vel);\n  }\n\n  // Write data to bag file\n  actuators_pub_.publish(actuators);\n}", "CodeBleu_score": 40.294868982533835}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Create a new message\n  std_msgs::Float64MultiArray motorVelocities;\n\n  // Set the time stamp\n  motorVelocities.header.stamp = ros::Time(now.sec, now.nsec);\n\n  // Iterate through the joints\n  for (int i = 0; i < joints.size(); i++) {\n\n    // Calculate the slowed-down rotational velocities\n    double rotationalVelocity = joints[i]->GetVelocity(0) * slowdownFactor;\n\n    // Assign the rotational velocities to the message\n    motorVelocities.data.push_back(rotationalVelocity);\n  }\n\n  // Write the data to a bag file\n  motorVelocitiesPub.publish(motorVelocities);\n}", "CodeBleu_score": 35.868266857893644}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Convert the simulation time to ROS time\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Prepare a message for motor velocities\n  actuator_msgs::ActuatorVelocities actuator_velocities_msg;\n  actuator_velocities_msg.header.stamp = ros_now;\n\n  // Iterate through the motor joints\n  for (unsigned int i = 0; i < motor_joint_names_.size(); i++) {\n\n    // Calculate the slowed-down rotational velocities\n    double slowed_down_velocity = motor_joint_velocities_[i] * slowdown_factor_;\n\n    // Assign the velocities to the message\n    actuator_velocities_msg.velocities.push_back(slowed_down_velocity);\n  }\n\n  // Write the message to a bag file\n  actuator_velocities_pub_.publish(actuator_velocities_msg);\n}", "CodeBleu_score": 45.09792156457557}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called\n\";\n  }\n\n  // Convert normalized roll, pitch, and yaw rate to control surface angles\n  aileron_angle_ = NormalizedInputToAngle(aileron_,\n                                         roll_pitch_yawrate_thrust_msg->roll);\n  elevator_angle_ = NormalizedInputToAngle(elevator_,\n                                           roll_pitch_yawrate_thrust_msg->pitch);\n  rudder_angle_ = NormalizedInputToAngle(rudder_,\n                                         roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set the throttle value\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust;\n}", "CodeBleu_score": 37.29999688095086}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called\n\";\n  }\n\n  // Convert the normalized roll, pitch, and yaw rate inputs to control surface angles.\n  aileron_angle_ = NormalizedInputToAngle(aileron_, roll_pitch_yawrate_thrust_msg->roll);\n  elevator_angle_ = NormalizedInputToAngle(elevator_, roll_pitch_yawrate_thrust_msg->pitch);\n  rudder_angle_ = NormalizedInputToAngle(rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set the throttle value.\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust;\n}", "CodeBleu_score": 34.90646769886314}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // Convert normalized inputs to control surface angles.\n  aileron_angle_ = NormalizedInputToAngle(aileron_, roll_pitch_yawrate_thrust_msg->roll);\n  elevator_angle_ = NormalizedInputToAngle(elevator_, roll_pitch_yawrate_thrust_msg->pitch);\n  rudder_angle_ = NormalizedInputToAngle(rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set throttle.\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust;\n}", "CodeBleu_score": 36.02247368253808}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t// Timeout in microseconds\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs - (timeout.tv_sec * 1000)) * 1000;\n\n  // Poll file descriptors\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n  int maxfd = _fd + 1;\n\n  int rv = select(maxfd, &fds, NULL, NULL, &timeout);\n\n  // Check for errors\n  if (rv < 0) {\n    gzerr << \"Error while polling for MAVLink messages.\n\";\n    return;\n  }\n\n  // Check for timeout\n  if (rv == 0) {\n    return;\n  }\n\n  // Check for data\n  if (FD_ISSET(_fd, &fds)) {\n    // Receive data\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    ssize_t len = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n    if (len <= 0) {\n      gzerr << \"Error while receiving data.\n\";\n      return;\n    }\n\n    // Parse MAVLink messages\n    for (ssize_t i = 0; i < len; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &last_msg_, &status_)) {\n        // Forward message to serial\n        if (serial_enabled_) {\n          send_mavlink_message(&last_msg_, 0);\n        }\n\n        // Handle message\n        handle_message(&last_msg_);\n      }\n    }\n  }\n}", "CodeBleu_score": 52.231826026537796}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t// Setup timeout for poll\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs - (timeout.tv_sec * 1000)) * 1000;\n\n  // Poll for new data\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n  int nfds = _fd + 1;\n  int r = select(nfds, &fds, NULL, NULL, &timeout);\n\n  if (r > 0) {\n    // Data available, receive it\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    ssize_t len = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n    if (len > 0) {\n      // Parse MAVLink messages\n      for (ssize_t i = 0; i < len; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &last_msg_, &status_)) {\n          if (last_msg_.msgid == MAVLINK_MSG_ID_HEARTBEAT) {\n            mavlink_heartbeat_t heartbeat;\n            mavlink_msg_heartbeat_decode(&last_msg_, &heartbeat);\n            if (heartbeat.type == MAV_TYPE_FIXED_WING) {\n              fixed_wing_ = true;\n            } else {\n              fixed_wing_ = false;\n            }\n          }\n          if (last_msg_.msgid == MAVLINK_MSG_ID_COMMAND_LONG) {\n            mavlink_command_long_t command;\n            mavlink_msg_command_long_decode(&last_msg_, &command);\n            if (command.command == MAV_CMD_DO_REPOSITION) {\n              if (command.param1 == 1) {\n                // Repositioning was", "CodeBleu_score": 46.12857484995234}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tstruct timeval tv;\n  tv.tv_sec = 0;\n  tv.tv_usec = _timeoutMs * 1000;\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n  int ret = select(_fd + 1, &fds, NULL, NULL, &tv);\n  if (ret > 0) {\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    int packetlen = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n    if (packetlen <= 0) {\n      gzerr << \"Failed receiving mavlink message\n\";\n      return;\n    }\n\n    mavlink_message_t msg;\n    mavlink_status_t status;\n    for (int i = 0; i < packetlen; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n        handle_message(&msg);\n        if (serial_enabled_) {\n          send_mavlink_message(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 57.66814762325051}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\tif (isOpen()) {\n    boost::mutex::scoped_lock lock(mutex_);\n    stop();\n    serial_.close();\n  }\n}", "CodeBleu_score": 39.73933257636691}, {"code": "void GazeboMavlinkInterface::close() {\n\tboost::mutex::scoped_lock lock(mutex_);\n\tif (is_open_) {\n\t\tio_service_.stop();\n\t\tserial_port_.close();\n\t\tif (io_thread_.joinable()) {\n\t\t\tio_thread_.join();\n\t\t}\n\t\tis_open_ = false;\n\t}\n}", "CodeBleu_score": 58.19954788990728}, {"code": "void GazeboMavlinkInterface::close() {\n\tboost::mutex::scoped_lock lock(mutex_);\n  if (is_open_) {\n    io_service_.stop();\n    serial_.close();\n    if (io_thread_.joinable())\n      io_thread_.join();\n    is_open_ = false;\n  }\n}", "CodeBleu_score": 63.698533148615944}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tignition::math::Vector3d pos1,\n    ignition::math::Vector3d pos2,\n    ignition::math::Vector3d val1,\n    ignition::math::Vector3d val2,\n    ignition::math::Vector3d pos\n}", "CodeBleu_score": 17.11928048857912}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tignition::math::Vector3d position,\n  ignition::math::Vector3d point1,\n  ignition::math::Vector3d point2,\n  ignition::math::Vector3d value1,\n  ignition::math::Vector3d value2\n}", "CodeBleu_score": 17.77082542527969}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tconst ignition::math::Vector3d &_pos,\n    const ignition::math::Vector3d &_p1,\n    const ignition::math::Vector3d &_p2,\n    const ignition::math::Vector3d &_v1,\n    const ignition::math::Vector3d &_v2\n}", "CodeBleu_score": 26.11365281560245}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\tif (m_looping) {\n        m_time = fmod(_time, m_length);\n    } else {\n        m_time = clamp(_time, 0.0, m_length);\n    }\n}", "CodeBleu_score": 29.767356634573183}, {"code": "void Animation::SetTime(double _time){\n\tif (m_looping) {\n\t\tm_time = fmod(_time, m_length);\n\t\tif (m_time < 0) {\n\t\t\tm_time += m_length;\n\t\t}\n\t}\n\telse {\n\t\tm_time = std::max(0.0, std::min(_time, m_length));\n\t}\n\n}", "CodeBleu_score": 30.987493753750645}, {"code": "void Animation::SetTime(double _time){\n\tif (this->time == _time) {\n\t\treturn;\n\t}\n\tthis->time = _time;\n\tthis->UpdateTime();\n}", "CodeBleu_score": 35.338726285341295}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.send_target_raw_pose(target_raw_pose)\n    print(\"Vehicle type: %s, ID: %s, Flight mode: %s\" % (self.vehicle_type, self.vehicle_id, self.flight_mode))\n\n", "CodeBleu_score": 42.55738366504934}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_raw_pose = self.construct_target()\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight mode: %s\" % self.flight_mode)\n", "CodeBleu_score": 42.484351622978494}, {"code": "def hover(self)\n\tself.coordinate_frame = self.coordinate_frame_enu\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.target_pose_pub.publish(target_raw_pose)\n    print(\"Vehicle type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight mode:\", self.flight_mode)\n\n", "CodeBleu_score": 29.35988863979246}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        self.flight_mode = self.flight_mode_service(self.flight_mode)\n        if self.flight_mode == 'HOVER':\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode switch successful.\")\n            self.hover()\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode switch failed.\")\n            return False\n\n", "CodeBleu_score": 55.71628082338038}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        mode_service = rospy.ServiceProxy(self.vehicle_id+'_flight_mode_service', SetFlightMode)\n        mode_service(self.flight_mode)\n        if mode_service.wait_for_service(timeout=1):\n            try:\n                mode_service(self.flight_mode)\n                print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode set successfully.\")\n                return True\n            except rospy.ServiceException as e:\n                print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode set failed: \"+str(e))\n                return False\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode set failed: service not available.\")\n            return False\n\n", "CodeBleu_score": 46.86277029133615}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            self.flight_mode = self.flight_mode\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": mode switch failed\")\n            return False\n\n", "CodeBleu_score": 55.60888778166003}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\tself.hover_flag = 0\n    if self.flight_mode == 'HOVER':\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.hover_action.hover()\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    elif self.flight_mode == 'OFFBOARD':\n        if x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover_action.hover()\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    else:\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover_action.hover()\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n\n", "CodeBleu_score": 44.24191237509408}, {"code": "def hover_state_transition(self, x, y, z, w)\n\tif x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        self.action_client.wait_for_server()\n        goal = ActionGoal()\n        goal.goal.command = 1\n        self.action_client.send_goal(goal)\n        self.action_client.wait_for_result()\n        self.action_client.get_result()\n        self.action_client.wait_for_server()\n        goal = ActionGoal()\n        goal.goal.command = 0\n        self.action_client.send_goal(goal)\n        self.action_client.wait_for_result()\n        self.action_client.get_result()\n        self.action_client.wait_for_server()\n        goal = ActionGoal()\n        goal.goal.command = 1\n        self.action_client.send_goal(goal)\n        self.action_client.wait_for_result()\n        self.action_client.get_result()\n        self.action_client.wait_for_server()\n        goal = ActionGoal()\n        goal.goal.command = 0\n        self.action_client.send_goal(goal)\n        self.action_client.wait_for_result()\n        self.action_client.get_result()\n        self.action_client.wait_for_server()\n        goal = ActionGoal()\n        goal.goal.command = 1\n        self.action_client.send_goal(goal)\n        self.action_client.wait_for_result()\n        self.action_client.get_result()\n        self.action_client.wait_for_server()\n        goal = ActionGoal()\n        goal.goal.command = 0\n        self.action_client.send_goal(goal)\n        self.action_client.wait_for_result()\n        self.action_client.get_result()\n        self.action_client.wait_for_server()\n        goal = ActionGo", "CodeBleu_score": 34.317042252232646}, {"code": "def hover_state_transition(self, x, y, z, w)\n\tif x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n        self.hover_action()\n    elif self.hover_flag == 0 and self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover_action()\n\n", "CodeBleu_score": 51.26833803120626}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 16.806809161752323}, {"code": "def q2yaw(self, q)\n\t# check if the input is an instance of Quaternion\n    if isinstance(q, Quaternion):\n        # extract the yaw component from the input quaternion\n        yaw = q.yaw\n    else:\n        # create a Quaternion from the input components\n        q = Quaternion(q)\n        # extract the yaw component from the Quaternion\n        yaw = q.yaw\n\n    return yaw\n\n", "CodeBleu_score": 27.52863807726429}, {"code": "def q2yaw(self, q)\n\t# Check if the input is an instance of Quaternion.\n    if isinstance(q, Quaternion):\n        # If it is, extract the yaw component directly.\n        yaw = q.yaw\n    else:\n        # Otherwise, create a Quaternion from the input components and then extract the yaw component.\n        yaw = Quaternion(q).yaw\n\n    # Return the yaw rotation in radians.\n    return yaw\n\n\n\n\n\n", "CodeBleu_score": 25.283454472451417}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\tself.coordinate_frame = self.coordinate_frame_default\n    self.motion_type = self.motion_type_default\n    self.target_raw_pose = self.construct_target()\n    print(\"Vehicle Type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight Mode:\", self.flight_mode)\n\n", "CodeBleu_score": 26.068645222030806}, {"code": "def hover(self)\n\tself.coordinate_frame = self.coordinate_frame_user\n    self.motion_type = self.motion_type_user\n\n    target_raw_pose = self.construct_target()\n\n    self.vehicle.send_mavlink(self.vehicle.Message_factory.set_position_target_global_int(\n        self.vehicle.target_system,\n        self.vehicle.target_component,\n        self.coordinate_frame,\n        self.motion_type,\n        target_raw_pose.latitude,\n        target_raw_pose.longitude,\n        target_raw_pose.altitude,\n        target_raw_pose.vx,\n        target_raw_pose.vy,\n        target_raw_pose.vz,\n        target_raw_pose.afx,\n        target_raw_pose.afy,\n        target_raw_pose.afz,\n        target_raw_pose.yaw,\n        target_raw_pose.yaw_rate))\n\n    print(\"Vehicle Type: %s\" % self.vehicle.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle.target_system)\n    print(\"Flight Mode: %s\" % self.vehicle.flight_mode)\n\n", "CodeBleu_score": 20.75685907176078}, {"code": "def hover(self)\n\tself.coordinate_frame = self.coordinate_frame_type.BODY_NED\n    self.motion_type = self.motion_type_type.FORWARD_ONLY\n    target_raw_pose = self.construct_target()\n    self.vehicle.send_mavlink(self.vehicle.message_factory.command_long_encode(\n        0, 0, self.vehicle.target_system, self.vehicle.target_component, mavutil.mavlink.MAV_CMD_DO_SET_MODE, 0, 0, 0, 0, 0, 0, 0))\n    self.vehicle.send_mavlink(self.vehicle.message_factory.command_long_encode(\n        0, 0, self.vehicle.target_system, self.vehicle.target_component, mavutil.mavlink.MAV_CMD_NAV_GUIDED_ENABLE, 0, 0, 0, 0, 0, 0, 0))\n    self.vehicle.send_mavlink(self.vehicle.message_factory.command_long_encode(\n        0, 0, self.vehicle.target_system, self.vehicle.target_component, mavutil.mavlink.MAV_CMD_DO_HOLD, 0, 0, 0, 0, 0, 0, 0))\n    self.vehicle.send_mavlink(self.vehicle.message_factory.command_long_encode(\n        0, 0, self.vehicle.target_system, self.vehicle.target_component, mavutil.mavlink.MAV_CMD_DO_SET_ROI_LOCATION, 0, 0, 0, 0, 0, 0, 0))\n    self.vehicle.send_mavlink(self.vehicle.message_factory.command_long_encode(\n        0, 0, self.vehicle.target_system, self.vehicle", "CodeBleu_score": 19.139911317887204}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n    else:\n        self.flight_mode = self.flightModeService(self.flight_mode)\n        if self.flight_mode:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(\"Failed to switch flight mode\")\n            return False\n\n", "CodeBleu_score": 63.017864167874514}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        rospy.wait_for_service('flight_mode_service')\n        flight_mode_service = rospy.ServiceProxy('flight_mode_service', FlightMode)\n        flight_mode_switch_attempt = flight_mode_service(self.vehicle_id, self.flight_mode)\n        if flight_mode_switch_attempt.success:\n            self.flight_mode = self.flight_mode\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        else:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + \"Failed to switch to \" + self.flight_mode)\n            return False\n\n", "CodeBleu_score": 50.08232840955913}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        self.flightModeService(custom_mode=self.flight_mode)\n        if self.flight_mode == 'HOVER':\n            self.hover = True\n            self.hover()\n            return True\n        else:\n            print('Flight mode switch failed for ' + self.vehicle_type + '_' + self.vehicle_id)\n            return False\n\n", "CodeBleu_score": 40.04083698319681}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.26923076876874}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 55.40188162220928}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 55.40188162220928}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t# Set the local pose based on the incoming message\n    if msg.id == i:\n        self.local_pose = msg\n\n    # Update the takeoff target pose\n    if self.takeoff_target_pose_active:\n        if self.takeoff_target_pose_index == i:\n            self.takeoff_target_pose = msg\n\n    # Update the hover target pose\n    if self.hover_target_pose_active:\n        if self.hover_target_pose_index == i:\n            self.hover_target_pose = msg\n\n    # Update the global pose\n    self.global_pose.position.x = self.local_pose.position.x + self.global_pose_bias_x\n    self.global_pose.position.y = self.local_pose.position.y + self.global_pose_bias_y\n    self.global_pose.position.z = self.local_pose.position.z + self.global_pose_bias_z\n\n    # Update the yaw angle\n    self.yaw_angle = self.local_pose.orientation.z\n\n", "CodeBleu_score": 25.183627701841736}, {"code": "def local_pose_callback(self, msg, i)\n\t# update local pose\n    if i == self.id:\n        self.local_pose = msg\n\n    # update takeoff target pose\n    if self.takeoff_target_pose is None:\n        if self.gcs_command == 'takeoff':\n            self.takeoff_target_pose = msg\n\n    # update hover target pose\n    if self.hover_target_pose is None:\n        if self.gcs_command == 'hover':\n            self.hover_target_pose = msg\n\n    # update global pose\n    self.global_pose = self.local_pose\n    self.global_pose.position.x += self.x_bias\n    self.global_pose.position.y += self.y_bias\n    self.global_pose.position.z += self.z_bias\n", "CodeBleu_score": 27.632874311951213}, {"code": "def local_pose_callback(self, msg, i)\n\tif i == self.ID:\n        self.local_pose = msg\n        # update the takeoff_target_pose if the GCS command is takeoff\n        if self.gcs_command == 'takeoff':\n            self.takeoff_target_pose = msg\n        # update the hover_target_pose if the GCS command is hover\n        elif self.gcs_command == 'hover':\n            self.hover_target_pose = msg\n        # update the global_pose for the UAV\n        self.global_pose.position.x = msg.position.x + self.x_bias\n        self.global_pose.position.y = msg.position.y + self.y_bias\n        self.global_pose.position.z = msg.position.z + self.z_bias\n        self.global_pose.orientation.x = msg.orientation.x\n        self.global_pose.orientation.y = msg.orientation.y\n        self.global_pose.orientation.z = msg.orientation.z\n        self.global_pose.orientation.w = msg.orientation.w\n", "CodeBleu_score": 24.49023609634496}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\tif self.arm_state == 'active':\n        if self.altitude > 0.2:\n            return True\n        else:\n            return False\n    else:\n        return False\n\n", "CodeBleu_score": 60.29555276760943}, {"code": "def takeoff_detection(self)\n\tif self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n", "CodeBleu_score": 61.889133687930844}, {"code": "def takeoff_detection(self)\n\tif self.arm_state == True and self.altitude > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 59.481327133295636}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t# Get the number of UAVs in the formations\n    num_orig_uavs = orig_formation.shape[0]\n    num_change_uavs = change_formation.shape[0]\n\n    # Create the distance matrix\n    dist_matrix = np.zeros((num_orig_uavs, num_change_uavs))\n\n    # Calculate the distances between UAVs in the original and changed formations\n    for i in range(num_orig_uavs):\n        for j in range(num_change_uavs):\n            dist_matrix[i, j] = np.linalg.norm(orig_formation[i, :] - change_formation[j, :])\n\n    # Adjust the distances and convert to integers\n    dist_matrix = dist_matrix - 50\n    dist_matrix = np.round(dist_matrix).astype(int)\n\n    # Return the distance matrix\n    return dist_matrix\n\n", "CodeBleu_score": 23.187779135608178}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t# Calculate pairwise distances between UAVs in the original and changed formations\n    distances = np.sqrt(np.sum(np.square(orig_formation - change_formation), axis=2))\n\n    # Adjust distances by subtracting them from 50 and converting to integers\n    distances = np.round(50 - distances)\n\n    # Return the distance matrix\n    return distances\n\n", "CodeBleu_score": 9.22702173226048}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t# Build the distance matrix\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = int(50 - np.linalg.norm(orig_formation[i] - change_formation[j]))\n    return dist_matrix\n\n", "CodeBleu_score": 26.12554233785645}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\tfor i in range(self.n_left):\n        self.match_right[i] = -1\n        self.slack_right[i] = float(\"inf\")\n        self.visit_right[i] = False\n    for i in range(self.n_left):\n        self.visit_left[i] = False\n        self.label_left[i] = 0\n        if self.find_path(i):\n            break\n        else:\n            for j in range(self.n_right):\n                self.slack_right[j] += self.label_left[i]\n            self.label_left[:] = [\n                min(self.slack_right[j], self.label_left[i]) for j in range(self.n_right)\n            ]\n    return self.match_right\n\n", "CodeBleu_score": 26.34369092467892}, {"code": "def KM(self)\n\twhile True:\n        self.visit_left = [False] * self.num_left\n        self.visit_right = [False] * self.num_right\n        for i in range(self.num_left):\n            self.slack_right = [sys.maxsize] * self.num_right\n            self.match_right = [-1] * self.num_right\n            if self.find_path(i):\n                break\n        else:\n            break\n        for j in range(self.num_right):\n            if not self.visit_right[j]:\n                self.label_right[j] += self.slack_right[j]\n\n    return self.match_right\n\n", "CodeBleu_score": 26.801685106419313}, {"code": "def KM(self)\n\twhile True:\n        for i in range(self.n_left):\n            if self.match_left[i] == -1:\n                self.slack_left[i] = 0\n                self.visit_left[i] = False\n                self.visit_right[i] = False\n                if self.find_path(i):\n                    break\n        else:\n            break\n\n        for j in range(self.n_right):\n            if self.match_right[j] == -1:\n                self.slack_right[j] = float('inf')\n                self.visit_left[j] = False\n                self.visit_right[j] = False\n\n        min_slack = float('inf')\n        for j in range(self.n_right):\n            if self.slack_right[j] < min_slack:\n                min_slack = self.slack_right[j]\n                min_slack_index = j\n\n        for i in range(self.n_left):\n            if self.visit_left[i]:\n                self.label_left[i] -= min_slack\n            if self.visit_right[i]:\n                self.label_right[i] += min_slack\n\n        for j in range(self.n_right):\n            if self.slack_right[j] == min_slack:\n                self.slack_right[j] = float('inf')\n                self.visit_left[j] = True\n\n    return self.match_right\n\n", "CodeBleu_score": 31.90429734098967}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t# Convert image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Create a mask for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t# Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Create a mask for the color \"yellow\"\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t# Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Define lower and upper boundaries for yellow color\n    lower = np.array([20, 100, 100])\n    upper = np.array([30, 255, 255])\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower, upper)\n    # Apply the mask to the image\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 37.51478398450005}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t[&](const TagDescriptionId &tagDescriptionId, bool printWarning, StandaloneTagDescription &descriptionContainer) -> bool {\n        auto it = standalone_tag_descriptions_.find(tagDescriptionId);\n        if (it == standalone_tag_descriptions_.end()) {\n            if (printWarning) {\n                std::cout << \"TagDetector::findStandaloneTagDescription(): No standalone tag description found for ID \" << tagDescriptionId << \".\" << std::endl;\n            }\n            return false;\n        }\n        descriptionContainer = it->second;\n        return true;\n    }\n}", "CodeBleu_score": 60.582396148573906}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t[&](const std::string& id,\n        TagDescriptionContainer& descriptionContainer,\n        bool printWarning) -> bool {\n        auto it = standalone_tag_descriptions_.find(id);\n        if (it == standalone_tag_descriptions_.end()) {\n            if (printWarning) {\n                Log::warning(\n                    [&]() {\n                        std::stringstream ss;\n                        ss << \"Tag description not found for ID: \" << id;\n                        return ss.str();\n                    }());\n            }\n            return false;\n        }\n        descriptionContainer = it->second;\n        return true;\n    }\n}", "CodeBleu_score": 57.167162110465064}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t(\n        TagDetector * tagDetector,\n        const TagDescriptionId & tagDescriptionId,\n        TagDescription * & descriptionContainer,\n        bool printWarning = true\n    ) {\n        auto it = tagDetector->standalone_tag_descriptions_.find(tagDescriptionId);\n        if (it != tagDetector->standalone_tag_descriptions_.end()) {\n            descriptionContainer = it->second;\n            return true;\n        }\n        if (printWarning) {\n            tagDetector->logger_.log(\n                LogLevel::Warning,\n                \"TagDetector::findStandaloneTagDescription: standalone tag description with ID %s not found.\",\n                tagDescriptionId.c_str()\n            );\n        }\n        return false;\n    }\n}", "CodeBleu_score": 46.64418752921223}]}
